
			goto Finish;
		}
	}
	else
	{
		//if process was not created, return reason why
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to create process; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	hr = NOERROR;

Finish:
	if ((pi.hProcess != NULL) && (pi.hProcess != INVALID_HANDLE_VALUE))
	{
		if (!::CloseHandle(pi.hProcess))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Closing handle for process %08lx failed; last error = %d", pi.hProcess, dwLastError);
		}
	}

	return hr;
}


//waits for process to finish and returns success code
HRESULT HrWaitForProcess(HANDLE handle)
{
	HRESULT hr = NOERROR;

	//loop forever to wait
	while (true)
	{
		//wait for object
		switch (::MsgWaitForMultipleObjects(1, &handle, false, INFINITE, QS_ALLINPUT))
		{
		//success!
		case WAIT_OBJECT_0:
			goto Finish;

		//not the process that we're waiting for
		case (WAIT_OBJECT_0 + 1):
			{
				hr = ::HrPumpMessages(true);

				if (FAILED(hr))
				{
					::VLog(L"Message pump failed; hresult = 0x%08lx", hr);
					goto Finish;
				}

				break;
			}
		//did not return an OK; return error status
		default:
			{
				const DWORD dwLastError = ::GetLastError();
				::VLog(L"MsgWaitForMultipleObjects() failed; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}
		}
	}

Finish:
	return hr;
}

HRESULT CWorkItemList::HrCheckCommandConditions(CWorkItem::CommandCondition *pCC, bool fConditionsAreRequirements, bool &rfDoCommand)
{
	HRESULT hr = NOERROR;
	bool fDoCommand = fConditionsAreRequirements || (pCC == NULL);

	while (pCC != NULL)
	{
		WCHAR szBuffer[_MAX_PATH];

		::VExpandFilename(pCC->m_szFilename, NUMBER_OF(szBuffer), szBuffer);

		// First let's see if the file is there.
		DWORD dwAttr = NVsWin32::GetFileAttributesW(szBuffer);
		if (dwAttr == 0xffffffff)
		{
			const DWORD dwLastError = ::GetLastError();
			// We should really check the error code and if it's not file not found, report an error.

			if ((dwLastError == ERROR_FILE_NOT_FOUND) ||
				(dwLastError == ERROR_PATH_NOT_FOUND))
			{
				// It's not there.  If it was a requirement, we can't run.  If it's just something
				// we're looking for, we have to run.  In either case, there's nothing more to check.

				fDoCommand = !fConditionsAreRequirements;
				hr = NOERROR;
			}
			else
			{
				::VLog(L"Attempt to get file attributes for command condition file \"%s\" failed; last error = %d", pCC->m_szFilename, dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
			}

			goto Finish;
		}

		// Ok, it's there.  Are we doing a version check?
		if (pCC->m_fCheckVersion)
		{
			DWORD dwMSVersion = 0;
			DWORD dwLSVersion = 0;

			if (pCC->m_szReferenceFilename[0] != L'\0')
			{
				WCHAR szReference[_MAX_PATH];
				bool fReg, fIsEXE, fIsDLL;

				::VExpandFilename(pCC->m_szReferenceFilename, NUMBER_OF(szReference), szReference);

				// What's the version of the reference file?
				hr = ::HrGetFileVersionNumber(szReference, dwMSVersion, dwLSVersion, fReg, fIsEXE, fIsDLL);
				if (FAILED(hr))
				{
					::VLog(L"Getting file version number for command condition reference file \"%s\" failed; hresult = 0x%08lx", szReference, hr);
					goto Finish;
				}

				::VLog(L"Got version from reference file \"%s\": 0x%08lx 0x%08lx", szReference, dwMSVersion, dwLSVersion);
			}
			else
			{
				dwMSVersion = pCC->m_dwMSVersion;
				dwLSVersion = pCC->m_dwLSVersion;
			}

			// And what's the version of the candidate?
			DWORD dwMSVersion_Candidate = 0;
			DWORD dwLSVersion_Candidate = 0;
			bool fReg, fIsEXE, fIsDLL;

			hr = ::HrGetFileVersionNumber(szBuffer, dwMSVersion_Candidate, dwLSVersion_Candidate, fReg, fIsEXE, fIsDLL);
			if (FAILED(hr))
			{
				::VLog(L"Failed to get file version number for command condition candidate file \"%s\" failed; hresult = 0x%08lx", szBuffer, hr);
				goto Finish;
			}

			int iVersionCompare = ::ICompareVersions(dwMSVersion_Candidate, dwLSVersion_Candidate, dwMSVersion, dwLSVersion);

			if (fConditionsAreRequirements)
			{
				if (iVersionCompare > 0)
				{
					fDoCommand = false;
					hr = NOERROR;
					goto Finish;
				}
			}
			else
			{
				if ((iVersionCompare < 0) || (g_fReinstall && (iVersionCompare == 0)))
				{
					fDoCommand = true;
					hr = NOERROR;
					goto Finish;
				}
			}
		}

		pCC = pCC->m_pCommandCondition_Next;
	}

Finish:
	rfDoCommand = fDoCommand;
	return hr;
}

HRESULT CWorkItemList::HrParseCommandCondition(LPCWSTR szCommand, CWorkItem::CommandCondition *&rpCC)
{
	WCHAR szBuffer[MSINFHLP_MAX_PATH];
	WCHAR szBuffer2[MSINFHLP_MAX_PATH];
	CWorkItem::CommandCondition *pCC_Head = NULL;

	LPCWSTR pszVBar;
	LPCWSTR pszCurrent = szCommand;
	HRESULT hr = NOERROR;

	rpCC = NULL;

	do
	{
		CWorkItem::CommandCondition *pCCNew = new CWorkItem::CommandCondition;
		if (pCCNew == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Finish;
		}

		pCCNew->m_pCommandCondition_Next = pCC_Head;

		pszVBar = wcschr(pszCurrent, L'|');
		LPCWSTR pszEnd = pszVBar;
		if (pszEnd == NULL)
			pszEnd = pszCurrent + wcslen(pszCurrent);

		ULONG cch = pszEnd - pszCurrent;
		if (cch > (NUMBER_OF(szBuffer) - 2))
			cch = NUMBER_OF(szBuffer) - 2;

		memcpy(szBuffer, pszCurrent, cch * sizeof(WCHAR));
		szBuffer[cch] = L'\0';

		LPCWSTR pszEquals = wcschr(szBuffer, L'=');

		if (pszEquals == NULL)
		{
			pCCNew->m_dwMSVersion = 0;
			pCCNew->m_dwLSVersion = 0;
			pCCNew->m_fCheckVersion = false;

			wcsncpy(pCCNew->m_szFilename, szBuffer, NUMBER_OF(pCCNew->m_szFilename));
			pCCNew->m_szFilename[NUMBER_OF(pCCNew->m_szFilename) - 1] = L'\0';

			pCCNew->m_szReferenceFilename[0] = L'\0';
		}
		else
		{
			cch = pszEquals - szBuffer;
			if (cch > (NUMBER_OF(pCCNew->m_szFilename) - 2))
				cch = NUMBER_OF(pCCNew->m_szFilename) - 2;

			memcpy(pCCNew->m_szFilename, szBuffer, cch * sizeof(WCHAR));
			pCCNew->m_szFilename[cch] = L'\0';

			pszEquals++;

			if (*pszEquals == L'*')
			{
				// Another hack... if the first character is '*', we assume that what
				// follows is the reference file's name within the installation source directory.
				pszEquals++;
				wcsncpy(pCCNew->m_szReferenceFilename, pszEquals, NUMBER_OF(pCCNew->m_szReferenceFilename));
				pCCNew->m_szReferenceFilename[NUMBER_OF(pCCNew->m_szReferenceFilename) - 1] = L'\0';

				pCCNew->m_dwMSVersion = 0;
				pCCNew->m_dwLSVersion = 0;
				pCCNew->m_fCheckVersion = true;
			}
			else
			{
				int a, b, c, d;
				swscanf(pszEquals, L"%d,%d,%d,%d", &a, &b, &c, &d);
				pCCNew->m_szReferenceFilename[0] = L'\0';
				pCCNew->m_dwMSVersion = (a << 16) | b;
				pCCNew->m_dwLSVersion = (c << 16) | d;
				pCCNew->m_fCheckVersion = true;
			}
		}

		pCC_Head = pCCNew;

	} while (pszVBar != NULL);

	rpCC = pCC_Head;
	pCC_Head = NULL;

Finish:
	// Really should clean up if pCC_Head != NULL... someday.  -mgrier 2/27/98

	return hr;
}

HRESULT CWorkItemList::HrAddString(LPCSTR szKey, LPCWSTR wszValue)
{
	if (szKey == NULL)
		return E_INVALIDARG;

	ULONG ulPseudoKey = this->UlHashString(szKey);
	ULONG iBucket = ulPseudoKey % NUMBER_OF(m_rgpStringBucketTable);
	StringBucket *pStringBucket = m_rgpStringBucketTable[iBucket];

	while (pStringBucket != NULL)
	{
		if ((pStringBucket->m_ulPseudoKey == ulPseudoKey) &&
			(strcmp(pStringBucket->m_szKey, szKey) == 0))
			break;

		pStringBucket = pStringBucket->m_pStringBucket_Next;
	}

	assert(pStringBucket == NULL);
	if (pStringBucket != NULL)
		return S_FALSE;

	pStringBucket = new StringBucket;
	if (pStringBucket == NULL)
		return E_OUTOFMEMORY;

	pStringBucket->m_pStringBucket_Next = m_rgpStringBucketTable[iBucket];
	pStringBucket->m_ulPseudoKey = ulPseudoKey;

	strncpy(pStringBucket->m_szKey, szKey, NUMBER_OF(pStringBucket->m_szKey));
	pStringBucket->m_szKey[NUMBER_OF(pStringBucket->m_szKey) - 1] = '\0';

	if (wszValue != NULL)
	{
		wcsncpy(pStringBucket->m_wszValue, wszValue, NUMBER_OF(pStringBucket->m_wszValue));
		pStringBucket->m_wszValue[NUMBER_OF(pStringBucket->m_wszValue) - 1] = L'\0';
	}
	else
		pStringBucket->m_wszValue[0] = L'\0';

	m_rgpStringBucketTable[iBucket] = pStringBucket;
	return NOERROR;
}

HRESULT CWorkItemList::HrAddString(LPCWSTR szLine, LPCWSTR szSeparator)
{
	if ((szLine == NULL) || (szSeparator == NULL))
		return E_INVALIDARG;

	if (szSeparator < szLine)
		return E_INVALIDARG;

	CHAR szKey[MSINFHLP_MAX_PATH];
	ULONG cwchKey = szSeparator - szLine;
	int iResult = ::WideCharToMultiByte(CP_ACP, 0, szLine, cwchKey, szKey, NUMBER_OF(szKey), NULL, NULL);
	if (iResult == 0)
	{
		const DWORD dwLastError = ::GetLastError();
		return HRESULT_FROM_WIN32(dwLastError);
	}

	return this->HrAddString(szKey, szSeparator);
}

ULONG CWorkItemList::UlHashString(LPCSTR szKey)
{
	ULONG ulPseudoKey = 0;
	CHAR ch;

	while ((ch = *szKey++) != L'\0')
		ulPseudoKey = (ulPseudoKey * 65599) + ch;

	return ulPseudoKey;
}

bool CWorkItemList::FLookupString(LPCSTR szKey, ULONG cchBuffer, WCHAR wszBuffer[])
{
	if ((szKey == NULL) || (cchBuffer == 0))
		return false;

	ULONG ulPseudoKey = this->UlHashString(szKey);
	ULONG iBucket = ulPseudoKey % NUMBER_OF(m_rgpStringBucketTable);
	StringBucket *pStringBucket = m_rgpStringBucketTable[iBucket];

	while (pStringBucket != NULL)
	{
		if ((pStringBucket->m_ulPseudoKey == ulPseudoKey) &&
			(strcmp(pStringBucket->m_szKey, szKey) == 0))
			break;

		pStringBucket = pStringBucket->m_pStringBucket_Next;
	}

	if (pStringBucket == NULL)
		return false;

	wcsncpy(wszBuffer, pStringBucket->m_wszValue, cchBuffer);
	wszBuffer[cchBuffer - 1] = L'\0';

	return true;
}

void CWorkItemList::VLookupString(LPCSTR szKey, ULONG cchBuffer, WCHAR wszBuffer[])
{
	if (!this->FLookupString(szKey, cchBuffer, wszBuffer))
		::MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszBuffer, cchBuffer);
}

bool CWorkItemList::FFormatString(ULONG cchBuffer, WCHAR wszBuffer[], LPCSTR szKey, ...)
{
	if ((szKey == NULL) || (cchBuffer == 0))
		return false;

	ULONG ulPseudoKey = this->UlHashString(szKey);
	ULONG iBucket = ulPseudoKey % NUMBER_OF(m_rgpStringBucketTable);
	StringBucket *pStringBucket = m_rgpStringBucketTable[iBucket];

	while (pStringBucket != NULL)
	{
		if ((pStringBucket->m_ulPseudoKey == ulPseudoKey) &&
			(strcmp(pStringBucket->m_szKey, szKey) == 0))
			break;

		pStringBucket = pStringBucket->m_pStringBucket_Next;
	}

	if (pStringBucket == NULL)
	{
		// The string wasn't found; log a complaint but use the key.
		VLog(L"Unable to find string with key: \"%S\"", szKey);
		::MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszBuffer, cchBuffer);
		return false;
	}

	va_list ap;
	va_start(ap, szKey);
	::VFormatStringVa(cchBuffer, wszBuffer, pStringBucket->m_wszValue, ap);
	va_end(ap);

	return true;
}

void CWorkItemList::VFormatString(ULONG cchBuffer, WCHAR wszBuffer[], LPCSTR szKey, ...)
{
	if ((szKey == NULL) || (cchBuffer == 0))
		return;

	ULONG ulPseudoKey = this->UlHashString(szKey);
	ULONG iBucket = ulPseudoKey % NUMBER_OF(m_rgpStringBucketTable);
	StringBucket *pStringBucket = m_rgpStringBucketTable[iBucket];

	while (pStringBucket != NULL)
	{
		if ((pStringBucket->m_ulPseudoKey == ulPseudoKey) &&
			(strcmp(pStringBucket->m_szKey, szKey) == 0))
			break;

		pStringBucket = pStringBucket->m_pStringBucket_Next;
	}

	if (pStringBucket == NULL)
	{
		// The string wasn't found; log a complaint but use the key.
		VLog(L"Unable to find string with key: \"%S\"", szKey);
		::MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszBuffer, cchBuffer);
	}
	else
	{
		va_list ap;
		va_start(ap, szKey);
		::VFormatStringVa(cchBuffer, wszBuffer, pStringBucket->m_wszValue, ap);
		va_end(ap);
	}
}

HRESULT CWorkItemList::HrDeleteString(LPCSTR szKey)
{
	if (szKey == NULL)
		return E_INVALIDARG;

	ULONG ulPseudoKey = this->UlHashString(szKey);
	ULONG iBucket = ulPseudoKey % NUMBER_OF(m_rgpStringBucketTable);
	StringBucket *pStringBucket = m_rgpStringBucketTable[iBucket];
	StringBucket *pStringBucket_Previous = NULL;

	while (pStringBucket != NULL)
	{
		if ((pStringBucket->m_ulPseudoKey == ulPseudoKey) &&
			(strcmp(pStringBucket->m_szKey, szKey) == 0))
			break;

		pStringBucket_Previous = pStringBucket;
		pStringBucket = pStringBucket->m_pStringBucket_Next;
	}

	if (pStringBucket == NULL)
		return E_INVALIDARG;

	if (pStringBucket_Previous == NULL)
		m_rgpStringBucketTable[iBucket] = pStringBucket->m_pStringBucket_Next;
	else
		pStringBucket_Previous->m_pStringBucket_Next = pStringBucket->m_pStringBucket_Next;

	delete pStringBucket;
	return NOERROR;
}

HRESULT CWorkItemList::HrRegisterSelfRegisteringFiles(bool &rfAnyProgress)
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);
	HINSTANCE hInstance = NULL;

	VLog(L"Beginning self-registration pass");

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		// This has to be a file, which is self registering, which we have updated.
		if ((iter->m_type == CWorkItem::eWorkItemCommand) ||
			!iter->m_fSourceSelfRegistering ||
			iter->m_fAlreadyRegistered)
			continue;

		// The source had better be at the Target at this point...
		::VLog(L"Attempting to register file: \"%s\"", iter->m_szTargetFile);

		WCHAR szExt[_MAX_EXT];
		_wsplitpath(iter->m_szTargetFile, NULL, NULL, NULL, szExt);

		if (_wcsicmp(szExt, L".exe") == 0)
		{
			// It's an .EXE, not a DLL; let's run it with /regserver
			WCHAR rgwchBuffer[MSINFHLP_MAX_PATH];
			swprintf(rgwchBuffer, L"\"%s\" /RegServer", iter->m_szTargetFile);

			hr = this->HrRunProcess(rgwchBuffer);
			if (FAILED(hr))
			{
				::VLog(L"Attempt to run regserver command process failed; hresult = 0x%08lx", hr);
				goto Finish;
			}

			iter->m_fAlreadyRegistered = true;
			rfAnyProgress = true;
		}
		else
		{
			//Here, we know that the ole self register flag is set.  So if we cannot load it, or
			//if we run int oa problem loading this file, then we cannot register it, so we fail.
			hInstance = NVsWin32::LoadLibraryExW(iter->m_szTargetFile, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
			if (hInstance == NULL)
			{
				const DWORD dwLastError = ::GetLastError();
				hr = HRESULT_FROM_WIN32(dwLastError);
				VLog(L"Attempt to load library \"%s\" failed", iter->m_szTargetFile);
				goto Finish;
			}

			//get the procedure address for registering this thing; exit if it doesn't exist
			typedef HRESULT (__stdcall *LPFNDLLREGISTERSERVER)();
			LPFNDLLREGISTERSERVER pfn;
			pfn = (LPFNDLLREGISTERSERVER) NVsWin32::GetProcAddressW(hInstance, L"DllRegisterServer");
			if (!pfn)
			{
				// I guess it doesn't really self-register!
				hr = NOERROR;
				VLog(L"The DLL \"%s\" has OLESelfRegister, but no DllRegisterServer entry point", iter->m_szTargetFile);
				iter->m_fSourceSelfRegistering = false;
				goto Finish;
			}

			::SetErrorInfo(0, NULL);
			hr = (*pfn)();
			if (FAILED(hr))
			{
				VLog(L"Call to DllRegisterServer() failed; hresult = 0x%08lx", hr);
				goto Finish;
			}

			if (!::FreeLibrary(hInstance))
			{
				hInstance = NULL;
				const DWORD dwLastError = ::GetLastError();
				hr = HRESULT_FROM_WIN32(dwLastError);
				VLog(L"FreeLibrary() failed, last error = %d", dwLastError);
				goto Finish;
			}

			hInstance = NULL;

			iter->m_fAlreadyRegistered = true;
			rfAnyProgress = true;
		}
	}

	hr = NOERROR;

Finish:
	if (hInstance != NULL)
		::FreeLibrary(hInstance);

	return hr;
}

HRESULT CWorkItemList::HrIncrementReferenceCounts()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);
	HKEY hkeySharedDlls = NULL;

	LONG lResult;
	DWORD dwDisposition;

	lResult = NVsWin32::RegCreateKeyExW(
							HKEY_LOCAL_MACHINE,
							L"Software\\Microsoft\\Windows\\CurrentVersion\\SharedDlls",
							0,
							L"", // lpClass
							REG_OPTION_NON_VOLATILE,
							KEY_QUERY_VALUE | KEY_SET_VALUE,
							NULL,
							&hkeySharedDlls,
							&dwDisposition);
	if (lResult != ERROR_SUCCESS)
	{
		::VLog(L"Unable to open SharedDlls key; last error = %d", lResult);
		hr = HRESULT_FROM_WIN32(lResult);
		goto Finish;
	}

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (!iter->m_fIsRefCounted)
			continue;

		::VLog(L"About to increment reference count for \"%s\"", iter->m_szTargetFile);

		DWORD dwType;
		DWORD dwRefCount = 0;
		DWORD cbData = sizeof(dwRefCount);

		lResult = NVsWin32::RegQueryValueExW(
								hkeySharedDlls,
								iter->m_szTargetFile,
								0,
								&dwType,
								(LPBYTE) &dwRefCount,
								&cbData);
		if (lResult == ERROR_FILE_NOT_FOUND)
		{
			dwRefCount = 0;
			cbData = sizeof(dwRefCount);
			dwType = REG_DWORD;
		}
		else if (lResult != ERROR_SUCCESS)
		{
			::VLog(L"Error getting current reference count from registry; last error = %d", lResult);
			hr = HRESULT_FROM_WIN32(lResult);
			goto Finish;
		}

		assert(cbData == sizeof(dwRefCount));

		if (dwType != REG_DWORD)
			dwRefCount = 0;

		// If the file is reference counted and already was on disk but the
		// ref count was missing or stored in the registry as zero, we make the ref count
		// one (and then we'll increment it to two).
		if ((dwRefCount == 0)  || (dwRefCount == 0xffffffff))
		{
			::VLog(L"Target had no previous reference count");

			if (iter->m_fAlreadyExists)
			{
				::VLog(L"The file's already there, so we're setting the refcount to 2");
				// The file already existed, but didn't have a reference count.  We should set it to two.
				dwRefCount = 2;
			}
			else
			{
				::VLog(L"The file's not already there, so we're setting the refcount to 1");
				// The file doesn't already exist, didn't have a ref count (or had a ref count
				// of zero); set it to one.
				dwRefCount = 1;
			}
		}
		else
		{
			if (!g_fReinstall)
			{
				dwRefCount++;
			}
		}

		lResult = NVsWin32::RegSetValueExW(
								hkeySharedDlls,
								iter->m_szTargetFile,
								0,
								REG_DWORD,
								(LPBYTE) &dwRefCount,
								sizeof(dwRefCount));
		if (lResult != ERROR_SUCCESS)
		{
			hr = HRESULT_FROM_WIN32(lResult);
			goto Finish;
		}

		iter->m_fRefCountUpdated = true;
	}

	hr = NOERROR;

Finish:
	if (hkeySharedDlls != NULL)
		::RegCloseKey(hkeySharedDlls);

	return hr;
}

HRESULT CWorkItemList::HrRegisterJavaClasses()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);

	WCHAR szVjReg[_MAX_PATH];
	::VExpandFilename(L"<SysDir>\\vjreg.exe", NUMBER_OF(szVjReg), szVjReg);

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (!iter->m_fFileUpdated)
			continue;

		WCHAR szExt[_MAX_EXT];

		_wsplitpath(iter->m_szTargetFile, NULL, NULL, NULL, szExt);

		if (_wcsicmp(szExt, L".tlb") != 0)
			continue;

		::VLog(L"Loading type library \"%s\"", iter->m_szTargetFile);

		ITypeLib *pITypeLib = NULL;
		hr = ::LoadTypeLib(iter->m_szTargetFile, &pITypeLib);
		if (FAILED(hr))
		{
			::VLog(L"Failed to load type library; hresult = 0x%08lx", hr);
			goto Finish;
		}

		hr = ::RegisterTypeLib(pITypeLib, iter->m_szTargetFile, NULL);
		if (FAILED(hr))
		{
			if (pITypeLib != NULL)
			{
				pITypeLib->Release();
				pITypeLib = NULL;
			}

			::VLog(L"Failed to register type library; hresult = 0x%08lx", hr);
			goto Finish;
		}

		if (pITypeLib != NULL)
		{
			pITypeLib->Release();
			pITypeLib = NULL;
		}
	}

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (!iter->m_fFileUpdated)
			continue;

		WCHAR szExt[_MAX_EXT];

		_wsplitpath(iter->m_szTargetFile, NULL, NULL, NULL, szExt);

		if (_wcsicmp(szExt, L".class") != 0)
			continue;

		::VLog(L"Analyzing class file \"%s\"", iter->m_szTargetFile);

		bool fNeedsRegistration = false;
		hr = ::HrAnalyzeClassFile(iter->m_szTargetFile, fNeedsRegistration);
		if (FAILED(hr))
		{
			::VLog(L"Failure analyzing Java class file; hresult = 0x%08lx", hr);
			goto Finish;
		}

		if (!fNeedsRegistration)
		{
			::VLog(L"Not registering class file because it's doesn't expose any com stuff");
			continue;
		}

		WCHAR szCommandLine[MSINFHLP_MAX_PATH];

		swprintf(szCommandLine, L"%s /nologo \"%s\"", szVjReg, iter->m_szTargetFile);

		// If the file is getting copied on reboot, we can't register it until then.
		if (iter->m_fDeferredRenamePending)
		{
			hr = this->HrAddRunOnce(szCommandLine, 0, NULL);
			if (FAILED(hr))
				goto Finish;
		}
		else
		{
			hr = this->HrRunProcess(szCommandLine);
			if (FAILED(hr))
			{
				VLog(L"Running command line failed: \"%s\"; hr = 0x%08lx", szCommandLine, hr);
				goto Finish;
			}
		}
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrProcessDCOMEntries()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);

	bool fHasDCOMEntries = false;
	// First, do we have any?
	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fRegisterAsDCOMComponent)
		{
			fHasDCOMEntries = true;
			break;
		}
	}

	// No DCOM thingies, let's get outta here.
	if (!fHasDCOMEntries)
		goto Finish;

	if (g_wszDCOMServerName[0] == L'\0')
	{
		if (!this->FLookupString(achRemoteServer, NUMBER_OF(g_wszDCOMServerName), g_wszDCOMServerName))
			g_wszDCOMServerName[0] = L'\0';
	}

	if (g_fSilent && (g_wszDCOMServerName[0] == L'\0'))
	{
		VLog(L"Unable to continue silent installation; remote DCOM server name required");
		hr = E_FAIL;
		goto Finish;
	}

	while (g_wszDCOMServerName[0] == L'\0')
	{
		hr = HrPromptForRemoteServer();
		if (FAILED(hr))
			goto Finish;
	}

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (!iter->m_fRegisterAsDCOMComponent)
			continue;

		WCHAR szCommandLine[MSINFHLP_MAX_PATH];
		swprintf(szCommandLine, iter->m_szSourceFile, g_wszDCOMServerName);

		if (g_fRebootRequired)
		{
			hr = this->HrAddRunOnce(szCommandLine, 0, NULL);
			if (FAILED(hr))
				goto Finish;
		}
		else
		{
			hr = this->HrRunProcess(szCommandLine);
			if (FAILED(hr))
				goto Finish;
		}
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrAddRunOnce(LPCWSTR szCommandLine, ULONG cchBufferOut, WCHAR szBufferOut[])
{
	HRESULT hr = NOERROR;
	HKEY hkeyRunOnce = NULL;

	static int iSeq = 1;

	WCHAR szBuffer[80];
	DWORD dwDisposition;

	LONG lResult = NVsWin32::RegCreateKeyExW(
							HKEY_LOCAL_MACHINE,
							L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
							0,
							NULL,
							0, // dwOptions
							KEY_SET_VALUE | KEY_QUERY_VALUE,
							NULL,
							&hkeyRunOnce,
							&dwDisposition);
	if (lResult != ERROR_SUCCESS)
	{
		::VLog(L"Failed to create/open Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce; last error = %d", lResult);
		hr = HRESULT_FROM_WIN32(lResult);
		goto Finish;
	}

	for (;;)
	{
		swprintf(szBuffer, L"MSINFHLP %d", iSeq++);

		::VLog(L"Looking for existing run-once value: \"%s\"", szBuffer);

		DWORD dwType;
		lResult = NVsWin32::RegQueryValueExW(
						hkeyRunOnce,
						szBuffer,
						0,
						&dwType,
						NULL,
						0);

		if (lResult == ERROR_SUCCESS)
		{
			::VLog(L"Value already in use; trying another...");
			continue;
		}

		if (lResult == ERROR_FILE_NOT_FOUND)
			break;

		::VLog(L"Unexpected error querying for run-once value; last error = %d", lResult);

		hr = HRESULT_FROM_WIN32(lResult);
		goto Finish;
	}

	lResult = NVsWin32::RegSetValueExW(
					hkeyRunOnce,
					szBuffer,
					0,
					REG_SZ,
					(LPBYTE) szCommandLine,
					(wcslen(szCommandLine) + 1) * sizeof(WCHAR));
	if (lResult != ERROR_SUCCESS)
	{
		::VLog(L"Error setting run-once value; last error = %d", lResult);
		hr = HRESULT_FROM_WIN32(lResult);
		goto Finish;
	}

	if ((cchBufferOut != 0) && (szBufferOut != NULL))
	{
		wcsncpy(szBufferOut, szBuffer, cchBufferOut);
		szBufferOut[cchBufferOut - 1] = L'\0';
	}

	hr = NOERROR;

Finish:
	if (hkeyRunOnce != NULL)
		::RegCloseKey(hkeyRunOnce);

	return hr;
}

//given the command line that invokes rundll32 to install a package to the java package
//manager, we parse through the command line, get the arguments, load the JPM, and call
//the APIs to install them manually.
HRESULT CWorkItemList::HrInstallViaJPM(LPCWSTR szCmdLine)
{
	HRESULT hr = NOERROR;

	HINSTANCE hInstance=NULL;
	WCHAR szFilename[MSINFHLP_MAX_PATH];
	DWORD dwFileType=0;
	DWORD dwHighVersion=0;
	DWORD dwLowVersion=0;
	DWORD dwBuild=0;
	DWORD dwPackageFlags=0;
	DWORD dwInstallFlags=0;
	WCHAR szNameSpace[MSINFHLP_MAX_PATH];

	int iLen;

	WCHAR szCurrentDirectory[_MAX_PATH];
	WCHAR szFileToInstall[_MAX_PATH];
	WCHAR szLibraryURL[_MAX_PATH + 8]; // 8 extra characters for "file:///"

	DWORD dwLen = MSINFHLP_MAX_PATH;

    IBindCtx *pbc = NULL;
    CodeDownloadBSC *pCDLBSC=NULL;
    HANDLE hEvent = NULL;
    DWORD dwWaitRet;

    SHASYNCINSTALLDISTRIBUTIONUNIT lpfnAsyncInstallDistributionUnit = NULL;

	WCHAR szExpanded[_MAX_PATH];
	::VExpandFilename(L"<SysDir>\\urlmon.dll", NUMBER_OF(szExpanded), szExpanded);

	szFilename[0] = 0;
	szNameSpace[0] = 0;

	//let's get URLMON
	hInstance = NVsWin32::LoadLibraryExW(szExpanded, 0, 0);
	if (hInstance == NULL)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Error loading urlmon library; last error = %d", dwLastError);

		hr = HRESULT_FROM_WIN32(dwLastError);

		if (dwLastError == ERROR_FILE_NOT_FOUND)
		{
			if (!g_fSilent)
				::VReportError(achInstallTitle, hr);
		}

		goto Finish;
	}

	//get the procedure address for registering this thing; exit if it doesn't exist
	lpfnAsyncInstallDistributionUnit = (SHASYNCINSTALLDISTRIBUTIONUNIT) NVsWin32::GetProcAddressW(hInstance, L"AsyncInstallDistributionUnit");
	if (lpfnAsyncInstallDistributionUnit == NULL)
	{
		const DWORD dwLastError = ::GetLastError();

		::VLog(L"GetProcAddress(hinstance, \"AsyncInstallDistributionUnit\") failed; last error = %d", dwLastError);

		// if the entry point doesn't exist, we should tell the user that they need to update
		// their verion of IE.
		if ((dwLastError == ERROR_FILE_NOT_FOUND) || (dwLastError == ERROR_PROC_NOT_FOUND) || (dwLastError == ERROR_MOD_NOT_FOUND))
		{
			if (!g_fSilent)
				::VMsgBoxOK(achInstallTitle, achErrorUpdateIE);

			hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
		}
		else
			hr = HRESULT_FROM_WIN32(dwLastError);

		goto Finish;
	}

	typedef HRESULT (__stdcall *PFNRegisterBindStatusCallback)(
				IBindCtx *pIBindCtx,
				IBindStatusCallback *pIBindStatusCallback,
				IBindStatusCallback **ppIBindStatusCallback_Previous,
				DWORD dwReserved);

	PFNRegisterBindStatusCallback pfnRegisterBindStatusCallback;
	pfnRegisterBindStatusCallback = (PFNRegisterBindStatusCallback) NVsWin32::GetProcAddressW(hInstance, L"RegisterBindStatusCallback");
	if (pfnRegisterBindStatusCallback == NULL)
	{
		const DWORD dwLastError = ::GetLastError();

		::VLog(L"GetProcAddress(hinstance, \"RegisterBindStatusCallback\") failed; last error = %d", dwLastError);

		// if the entry point doesn't exist, we should tell the user that they need to update
		// their verion of IE.
		if ((dwLastError == ERROR_FILE_NOT_FOUND) || (dwLastError == ERROR_PROC_NOT_FOUND) || (dwLastError == ERROR_MOD_NOT_FOUND))
		{
			if (!g_fSilent)
				::VMsgBoxOK(achInstallTitle, achErrorUpdateIE);
			hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
		}
		else
			hr = HRESULT_FROM_WIN32(dwLastError);

		goto Finish;
	}

	//NOTE:  need to put the code for inserting into package here...
	hr = ::HrParseJavaPkgMgrInstall(
				szCmdLine,
				NUMBER_OF(szFilename),
				szFilename,
				dwFileType,
				dwHighVersion,
				dwLowVersion,
				dwBuild,
				dwPackageFlags,
				dwInstallFlags,
				NUMBER_OF(szNameSpace),
				szNameSpace);
	if (FAILED(hr))
	{
		::VLog(L"Parsing the JPM install command line failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	if (g_hwndProgressItem != NULL)
	{
		NVsWin32::LrWmSetText(g_hwndProgressItem, szFilename);
		::UpdateWindow(g_hwndProgressItem);
	}

	::VSetErrorContext(achErrorInstallingCabinet, szFilename);

	//let's get the current directory
	if (NVsWin32::GetCurrentDirectoryW(NUMBER_OF(szCurrentDirectory), szCurrentDirectory) == 0)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Attempt to get current directory failed in java pkg mgr install; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	iLen = wcslen(szCurrentDirectory);
	if ((iLen > 0) && (szCurrentDirectory[iLen - 1] != L'\\'))
	{
		szCurrentDirectory[iLen] = L'\\';
		szCurrentDirectory[iLen+1] = L'\0';
	}

	::VFormatString(NUMBER_OF(szFileToInstall), szFileToInstall, L"%0%1", szCurrentDirectory, szFilename);
	::VFormatString(NUMBER_OF(szLibraryURL), szLibraryURL, L"file:///%0", szFileToInstall);

    // create an event to be signaled when the download is complete
    hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hEvent == NULL)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Unable to create Win32 event object; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
        goto Finish;
    }

    // make a bind context
    hr = ::CreateBindCtx(0, &pbc);
    if (FAILED(hr))
	{
		::VLog(L"Unable to create ole binding context; hresult = 0x%08lx", hr);
        goto Finish;
	}

    // make a bind status callback, and tell it the event to signal when complete
    pCDLBSC = new CodeDownloadBSC(hEvent);
    if (pCDLBSC == NULL)
	{
		::VLog(L"Attempt to create new code download status callback object failed");
		hr = E_OUTOFMEMORY;
        goto Finish;
    }
    
	hr = (*pfnRegisterBindStatusCallback)(pbc, pCDLBSC, NULL, 0);
	if (FAILED(hr))
	{
		::VLog(L"Call to register bind status callback failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	::VLog(L"Initiating asynchronous DU installation");
	::VLog(L"   File to install: \"%s\"", szFileToInstall);
	::VLog(L"   high version: 0x%08lx", dwHighVersion);
	::VLog(L"   low version: 0x%08lx", dwLowVersion);
	::VLog(L"   library URL: \"%s\"", szLibraryURL);
	::VLog(L"   install flags: 0x%08lx", dwInstallFlags);

	// call URLMON's async API to install the distribution unit      
	hr = (*lpfnAsyncInstallDistributionUnit)(
				szFileToInstall,
				NULL,
				NULL,
				dwHighVersion,
				dwLowVersion,
				szLibraryURL,
				pbc,
				NULL,
				dwInstallFlags);

    if (hr != MK_S_ASYNCHRONOUS)
	{
        if (SUCCEEDED(hr))
		{
            // if we got some success code other than MK_S_ASYNCHRONOUS,
            // something weird happened and we probably didn't succeed...
            // so make sure we report failure.
            hr = E_FAIL;
        }

		::VLog(L"Failure calling async DU install function; hresult = 0x%08lx", hr);

        goto Finish;
    }

    do
    {   
        // allow posted messages to get delivered and
        // wait until our event is set
        dwWaitRet =
			::MsgWaitForMultipleObjects(  1,
                                        &hEvent,
                                        FALSE,
                                        100,
                                        QS_ALLINPUT);

        // if we got a message, dispatch it
        if (dwWaitRet == (WAIT_OBJECT_0+1))
        {
			//call message look to keep for outstanding messages...
			hr = ::HrPumpMessages(true);
			if (FAILED(hr))
			{
				::VLog(L"Failure during CAB install pumping messages; hresult = 0x%08lx", hr);
				goto Finish;
			}
        }
		else if (dwWaitRet == 0xffffffff)
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Failure while waiting for event to be signalled during CAB install; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}
    } while (dwWaitRet != WAIT_OBJECT_0);

    // the download is complete; not necessarily successfully.  Get the
    // final return code from the bind status callback.
    hr = pCDLBSC->GetHResult();
	if (FAILED(hr))
	{
		::VLog(L"CAB install failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	hr = NOERROR;
	::VClearErrorContext();

Finish:

    if (pCDLBSC != NULL)
        pCDLBSC->Release();

    if (pbc != NULL)
        pbc->Release();

    if (hEvent != NULL)
        ::CloseHandle(hEvent);

	if (hInstance != NULL)
		::FreeLibrary(hInstance);

	return hr;
}

HRESULT HrParseJavaPkgMgrInstall
(
LPCWSTR szCmdLine,
ULONG cchFilename,
WCHAR szFilename[],
DWORD &rdwFileType,
DWORD &rdwHighVersion, 
DWORD &rdwLowVersion,
DWORD &rdwBuild,
DWORD &rdwPackageFlags,
DWORD &rdwInstallFlags,
ULONG cchNameSpace,
WCHAR szNameSpace[]
)
{
	HRESULT hr = NOERROR;

	WCHAR szBuffer[MSINFHLP_MAX_PATH];
	LPCWSTR pszCurrent = szCmdLine;

	for (ULONG i=0; (i<9) && (pszCurrent != NULL); i++)
	{
		const LPCWSTR pszComma = wcschr(pszCurrent, L',');
		const LPCWSTR pszEnd = (pszComma == NULL) ? (pszCurrent + wcslen(pszCurrent)) : pszComma;
		ULONG cch = pszEnd - pszCurrent;
		if (cch > (NUMBER_OF(szBuffer) - 2))
			cch = NUMBER_OF(szBuffer) - 2;

		memcpy(szBuffer, pszCurrent, cch * sizeof(WCHAR));
		szBuffer[cch] = L'\0';

		::VLog(L"In iteration %d of java pkg mgr install parser, buffer = \"%s\"", i, szBuffer);

		switch (i)
		{
		case 0:
			break;

		case 1:
		{
			LPCWSTR pszMatch = wcsstr(szBuffer, L"JavaPkgMgr_Install ");
			if (pszMatch == NULL)
			{
				hr = E_INVALIDARG;
				goto Finish;
			}

			wcsncpy(szFilename, pszMatch + 19, cchFilename);
			szFilename[cchFilename - 1] = L'\0';
			break;
		}
	
		case 2:
			rdwFileType = (DWORD) _wtol(szBuffer);
			break;

		case 3:
			rdwHighVersion = (DWORD) _wtol(szBuffer);
			break;

		case 4:
			rdwLowVersion = (DWORD) _wtol(szBuffer);
			break;

		case 5:
			rdwBuild = (DWORD) _wtol(szBuffer);
			break;

		case 6:
			rdwPackageFlags = (DWORD) _wtol(szBuffer);
			break;

		case 7:
			rdwInstallFlags = (DWORD) _wtol(szBuffer);
			break;

		case 8:
			wcsncpy(szNameSpace, szBuffer, cchNameSpace);
			szNameSpace[cchNameSpace - 1] = L'\0';
			break;
			
		}

		if (pszComma != NULL)
			pszCurrent = pszComma + 1;
		else
			pszCurrent = NULL;
	}

	hr = NOERROR;

Finish:
	return hr;
}


HRESULT CWorkItemList::HrAddRegistryEntries()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(g_pwil);
	HKEY hkeySubkey = NULL;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fAddToRegistry)
			continue;

		HKEY hkeyRoot = NULL;
		WCHAR szBuffer[MSINFHLP_MAX_PATH];
		LPCWSTR pszKeyName = szBuffer;
		LPCWSTR pszSubkeyName = NULL;
		LPCWSTR pszValueName = NULL;
		LPCWSTR pszValue = NULL;

		// We move the whole thing into our temporary buffer so we can put null characters where
		// we want them.

		wcsncpy(szBuffer, iter->m_szSourceFile, NUMBER_OF(szBuffer));
		szBuffer[NUMBER_OF(szBuffer) - 1] = L'\0';

		LPWSTR pszComma = wcschr(szBuffer, L',');
		if (pszComma == NULL)
		{
			VLog(L"Invalid registry add request (no first comma): \"%s\"", iter->m_szSourceFile);
			hr = E_FAIL;
			goto Finish;
		}

		*pszComma = L'\0';

		if ((_wcsicmp(pszKeyName, L"HKLM") == 0) ||
			(_wcsicmp(pszKeyName, L"HKEY_LOCAL_MACHINE") == 0))
		{
			hkeyRoot = HKEY_LOCAL_MACHINE;
		}
		else if ((_wcsicmp(pszKeyName, L"HKCU") == 0) ||
			     (_wcsicmp(pszKeyName, L"HKEY_CURRENT_USER") == 0))
		{
			hkeyRoot = HKEY_CURRENT_USER;
		}
		else if ((_wcsicmp(pszKeyName, L"HKCR") == 0) ||
			     (_wcsicmp(pszKeyName, L"HKEY_CLASSES_ROOT") == 0))
		{
			hkeyRoot = HKEY_CLASSES_ROOT;
		}
		else
		{
			VLog(L"Invalid registry root requested: \"%s\"", pszKeyName);
			hr = E_FAIL;
			goto Finish;
		}

		pszSubkeyName = pszComma + 1;
		pszComma = wcschr(pszSubkeyName, L',');

		if (pszComma == NULL)
		{
			VLog(L"Invalid registry add request (no second comma): \"%s\"", iter->m_szSourceFile);
			hr = E_FAIL;
			goto Finish;
		}

		*pszComma = L'\0';
		pszValueName = pszComma + 1;
		pszComma = wcschr(pszValueName, L',');

		if (pszComma == NULL)
		{
			VLog(L"Invalid registry key add request (no third comma): \"%s\"", iter->m_szSourceFile);
			hr = E_FAIL;
			goto Finish;
		}

		*pszComma = L'\0';
		pszValue = pszComma + 1;

		DWORD dwDisposition;
		LONG lResult = NVsWin32::RegCreateKeyExW(
									hkeyRoot,
									pszSubkeyName,
									0,
									NULL,
									0, // dwOptions
									KEY_SET_VALUE,
									NULL, // lpSecurityAttributes
									&hkeySubkey,
									&dwDisposition);
		if (lResult != ERROR_SUCCESS)
		{
			hr = HRESULT_FROM_WIN32(lResult);
			goto Finish;
		}

		WCHAR szExpandedValue[MSINFHLP_MAX_PATH];
		szExpandedValue[0] = L'\0';
		::VExpandFilename(pszValue, NUMBER_OF(szExpandedValue), szExpandedValue);

		lResult = NVsWin32::RegSetValueExW(
								hkeySubkey,
								pszValueName,
								0,
								REG_SZ,
								(LPBYTE) szExpandedValue,
								(wcslen(szExpandedValue) + 1) * sizeof(WCHAR));
		if (lResult != ERROR_SUCCESS)
		{
			hr = HRESULT_FROM_WIN32(lResult);
			goto Finish;
		}
	}

	hr = NOERROR;

Finish:
	if ((hkeySubkey != NULL) && (hkeySubkey != INVALID_HANDLE_VALUE))
		::RegCloseKey(hkeySubkey);

	return hr;
}

HRESULT CWorkItemList::HrDeleteRegistryEntries()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(g_pwil);

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fDeleteFromRegistry)
			continue;

		::VLog(L"About to delete registry entry \"%s\"", iter->m_szSourceFile);

		HKEY hkeyRoot = NULL;
		WCHAR szBuffer[MSINFHLP_MAX_PATH];
		LPCWSTR pszKeyName = szBuffer;
		LPCWSTR pszSubkeyName = NULL;
		LPCWSTR pszValueName = NULL;
		LPCWSTR pszValue = NULL;

		// We move the whole thing into our temporary buffer so we can put null characters where
		// we want them.

		wcsncpy(szBuffer, iter->m_szSourceFile, NUMBER_OF(szBuffer));
		szBuffer[NUMBER_OF(szBuffer) - 1] = L'\0';

		LPWSTR pszComma = wcschr(szBuffer, L',');
		if (pszComma == NULL)
		{
			::VLog(L"Invalid registry delete request (no first comma): \"%s\"", iter->m_szSourceFile);
			hr = E_FAIL;
			goto Finish;
		}

		*pszComma = L'\0';

		if ((_wcsicmp(pszKeyName, L"HKLM") == 0) ||
			(_wcsicmp(pszKeyName, L"HKEY_LOCAL_MACHINE") == 0))
		{
			hkeyRoot = HKEY_LOCAL_MACHINE;
		}
		else if ((_wcsicmp(pszKeyName, L"HKCU") == 0) ||
			     (_wcsicmp(pszKeyName, L"HKEY_CURRENT_USER") == 0))
		{
			hkeyRoot = HKEY_CURRENT_USER;
		}
		else if ((_wcsicmp(pszKeyName, L"HKCR") == 0) ||
			     (_wcsicmp(pszKeyName, L"HKEY_CLASSES_ROOT") == 0))
		{
			hkeyRoot = HKEY_CLASSES_ROOT;
		}
		else
		{
			::VLog(L"Invalid registry root requested: \"%s\"", pszKeyName);
			hr = E_FAIL;
			goto Finish;
		}

		pszSubkeyName = pszComma + 1;
		pszComma = wcschr(pszSubkeyName, L',');

		CVsRegistryKey hkeySubkey;

		hr = hkeySubkey.HrOpenKeyExW(hkeyRoot, pszSubkeyName, 0, KEY_ALL_ACCESS);
		if (FAILED(hr))
		{
			::VLog(L"Attempt to open subkey failed; hresult = 0x%08lx", hr);
			goto Finish;
		}

		if (pszComma == NULL)
		{
			// No value name; we're trying to delete the entire subkey.
			hr = hkeySubkey.HrDeleteValuesAndSubkeys();
			if (FAILED(hr))
			{
				::VLog(L"Attempt to delete values and subkeys from key failed; hresult = 0x%08lx", hr);
				goto Finish;
			}

			hr = hkeySubkey.HrCloseKey();
			if (FAILED(hr))
			{
				::VLog(L"Attempt to close registry key failed; hresult = 0x%08lx", hr);
				goto Finish;
			}

			LONG lResult = NVsWin32::RegDeleteKeyW(hkeyRoot, pszSubkeyName);
			if (lResult != ERROR_SUCCESS)
			{
				::VLog(L"Attempt to delete registry key failed; last error = %d", lResult);
				hr = HRESULT_FROM_WIN32(lResult);
				goto Finish;
			}
		}
		else
		{
			*pszComma = L'\0';
			pszValueName = pszComma + 1;

			hr = hkeySubkey.HrDeleteValueW(pszValueName);
			if (FAILED(hr))
			{
				::VLog(L"Attempt to delete registry value failed; hresult = 0x%08lx", hr);
				goto Finish;
			}
		}
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrCreateShortcuts()
{
	HRESULT hr = NOERROR;

	HANDLE hLink = INVALID_HANDLE_VALUE;
	HANDLE hPif = INVALID_HANDLE_VALUE;

	WCHAR szEXE[MSINFHLP_MAX_PATH];
	WCHAR szArgument[MSINFHLP_MAX_PATH];
	WCHAR szEXEexpanded[MSINFHLP_MAX_PATH];
	WCHAR szArgumentexpanded[MSINFHLP_MAX_PATH];
	WCHAR szStartMenu[MSINFHLP_MAX_PATH];
	WCHAR szLinkName[MSINFHLP_MAX_PATH];
	WCHAR szPifName[MSINFHLP_MAX_PATH];
	WCHAR szAppDir[MSINFHLP_MAX_PATH];
	WCHAR szStartName[MSINFHLP_MAX_PATH];
	WCHAR szExt[_MAX_EXT];
	bool fArgument = true;

	szEXE[0]=0;
	szArgument[0]=0;

	// If there's no start exe, then I guess that's all there is to say.
	if (!g_pwil->FLookupString(achStartEXE, NUMBER_OF(szEXE), szEXE))
		goto Finish;

	if (!g_pwil->FLookupString(achStartName, NUMBER_OF(szStartName), szStartName))
	{
		wcsncpy(szStartName, g_wszApplicationName, NUMBER_OF(szStartName));
		szStartName[NUMBER_OF(szStartName) - 1] = L'\0';
	}

	fArgument = g_pwil->FLookupString(achStartArgument, NUMBER_OF(szArgument), szArgument);

	//expand the EXE and argumemt strings
	::VExpandFilename(szEXE, NUMBER_OF(szEXEexpanded), szEXEexpanded);
	::VExpandFilename(szArgument, NUMBER_OF(szArgumentexpanded), szArgumentexpanded);

	_wsplitpath(szEXEexpanded, NULL, NULL, NULL, szExt);

	hr = ::HrGetStartMenuDirectory(NUMBER_OF(szStartMenu), szStartMenu);
	if (FAILED(hr))
		goto Finish;

	//construct name of shortcut file, with both LNK and PIF files!
	swprintf(szLinkName, L"%s\\%s", szStartMenu, szStartName);
	wcscpy(szPifName, szLinkName);

	wcscat(szPifName, L".pif");
	wcscat(szLinkName, L".lnk");

	::VExpandFilename(L"<AppDir>", NUMBER_OF(szAppDir), szAppDir);

//pszShortcutFile == path of shortcut target
//pszLink == name of shortcut file
//pszDesc == description of this link
//pszWorkingDir == working directory
//pszArguments == arguments given to the EXE that we run

	hr = ::HrCreateLink(szEXEexpanded, szLinkName, szStartName, szAppDir, szArgumentexpanded);
	if (FAILED(hr))
		goto Finish;

	//afterwards, let's check for the creation time of both the LNK and the PIF file
	if (NVsWin32::GetFileAttributesW(szLinkName) == 0xFFFFFFFF)
	{
		//LNK file is not there, so PIF was created
		hr = ::HrWriteShortcutEntryToRegistry(szPifName);
		if (FAILED(hr))
			goto Finish;
	}
	else
	{
		//If the PIF file doesn't exist, then we don't care, since the default name
		//points to the LNK file; we only care if the PIF file is NOT zero
		if (NVsWin32::GetFileAttributesW(szPifName) != 0xFFFFFFFF)
		{
			FILETIME timeLink, timePif;

			hLink = NVsWin32::CreateFileW(szLinkName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			hPif = NVsWin32::CreateFileW(szPifName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

			//if we cannot get file time for any reason, we'll just pop up the default dialog
			if (!::GetFileTime(hLink, &timeLink, NULL, NULL) || !::GetFileTime(hPif, &timePif, NULL, NULL))
				goto Finish;
			else
			{
				//if the PIF file is more recent, then that's the one that we created
				if ((timePif.dwHighDateTime > timeLink.dwHighDateTime) ||
					((timePif.dwHighDateTime == timeLink.dwHighDateTime) && (timePif.dwLowDateTime > timeLink.dwLowDateTime)))
				{
					hr = ::HrWriteShortcutEntryToRegistry(szPifName);
					if (FAILED(hr))
						goto Finish;
				}
			}
		}
	}

	hr = NOERROR;

Finish:

	if (hLink != INVALID_HANDLE_VALUE) 
		::CloseHandle(hLink); 

	if (hPif != INVALID_HANDLE_VALUE) 
		::CloseHandle(hPif);

	if (FAILED(hr) && !g_fSilent)
		::VMsgBoxOK(achInstallTitle, achErrorCreatingShortcut);

	return hr;
}

HRESULT CWorkItemList::HrUninstall_InitialScan()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);

	CVsRegistryKey hkeySharedDlls;

	hr = hkeySharedDlls.HrOpenKeyExW(
			HKEY_LOCAL_MACHINE,
			L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls",
			0,
			KEY_QUERY_VALUE);
	if (FAILED(hr))
	{
		::VLog(L"Opening SharedDlls key in initial scan failed; hresult = 0x%08lx", hr);
		goto Finish;
	}

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem)
			continue;

		{
			WCHAR szTemp[MSINFHLP_MAX_PATH];

			::VExpandFilename(iter->m_szTargetFile, NUMBER_OF(szTemp), szTemp);
			wcsncpy(iter->m_szTargetFile, szTemp, NUMBER_OF(iter->m_szTargetFile));
			iter->m_szTargetFile[NUMBER_OF(iter->m_szTargetFile) - 1] = L'\0';

			::VExpandFilename(iter->m_szSourceFile, NUMBER_OF(szTemp), szTemp);
			wcsncpy(iter->m_szSourceFile, szTemp, NUMBER_OF(iter->m_szSourceFile));
			iter->m_szSourceFile[NUMBER_OF(iter->m_szSourceFile) - 1] = L'\0';
		}

		if (iter->m_fIsRefCounted)
		{
			DWORD dwType = 0;
			DWORD dwRefCount = 0;
			DWORD cbData = sizeof(dwRefCount);

			hr = hkeySharedDlls.HrQueryValueExW(
						iter->m_szTargetFile,
						0,
						&dwType,
						(LPBYTE) &dwRefCount,
						&cbData);

			if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
			{
				hr = NOERROR;
				dwRefCount = 0xffffffff;
			}

			if (FAILED(hr))
			{
				::VLog(L"Failed to find registry key for file: \"%s\"", iter->m_szTargetFile);
				goto Finish;
			}

			::VLog(L"Found reference count for file \"%s\": %d", iter->m_szTargetFile, dwRefCount);

			iter->m_dwFileReferenceCount = dwRefCount;
		}

		if (iter->m_fIsRefCounted || iter->m_fUnconditionalDeleteOnUninstall)
		{
			iter->m_dwTargetAttributes = NVsWin32::GetFileAttributesW(iter->m_szTargetFile);
			if (iter->m_dwTargetAttributes == 0xffffffff)
			{
				const DWORD dwLastError = ::GetLastError();

				::VLog(L"Error getting file attributes from \"%s\"; last error = %d", iter->m_szTargetFile, dwLastError);

				if ((dwLastError != ERROR_FILE_NOT_FOUND) &&
					(dwLastError != ERROR_PATH_NOT_FOUND))
				{
					hr = HRESULT_FROM_WIN32(dwLastError);
					goto Finish;
				}
			}
			else
			{
				hr = ::HrGetFileVersionNumber(
							iter->m_szTargetFile,
							iter->m_dwMSTargetVersion,
							iter->m_dwLSTargetVersion,
							iter->m_fTargetSelfRegistering,
							iter->m_fTargetIsEXE,
							iter->m_fTargetIsDLL);
				if (FAILED(hr))
				{
					::VLog(L"Error getting file version number from \"%s\"; hresult = 0x%08lx", iter->m_szTargetFile, hr);
					goto Finish;
				}

				hr = ::HrGetFileDateAndSize(
							iter->m_szTargetFile,
							iter->m_ftTarget,
							iter->m_uliTargetBytes);
				if (FAILED(hr))
				{
					::VLog(L"Error getting file date and size from \"%s\"; hresult = 0x%08lx", iter->m_szTargetFile, hr);
					goto Finish;
				}

				iter->m_fAlreadyExists = true;
			}
		}
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrUninstall_DetermineFilesToDelete()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || iter->m_fToBeDeleted || iter->m_fToBeSaved || iter->m_type == CWorkItem::eWorkItemCommand)
			continue;

		::VLog(L"Determining whether to delete file \"%s\"", iter->m_szTargetFile);

		// Let's figure out what we really want to delete!
		if (iter->m_fIsRefCounted)
		{
			if (iter->m_dwFileReferenceCount == 1)
			{
				if (!iter->m_fAskOnRefCountZeroDelete)
					iter->m_fToBeDeleted = true;
				else
				{
					if (g_fUninstallKeepAllSharedFiles)
						iter->m_fToBeSaved = true;
					else
					{
						if (g_fUninstallDeleteAllSharedFiles)
							iter->m_fToBeDeleted = true;
						else
						{
							if (g_fSilent)
								iter->m_fToBeDeleted = true;
							else
							{
								DWORD dwResult = ::DwMsgBoxYesNoAll(achUninstallTitle, achRemovePrompt, iter->m_szTargetFile);

								switch (dwResult)
								{
								case MSINFHLP_YNA_CANCEL:
									hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
									goto Finish;

								case MSINFHLP_YNA_NOTOALL:
									g_fUninstallKeepAllSharedFiles = true;
								default: // safest to keep, so we default there
								case MSINFHLP_YNA_NO:
									iter->m_fToBeSaved = true;
									break;

								case MSINFHLP_YNA_YESTOALL:
									g_fUninstallDeleteAllSharedFiles = true;

								case MSINFHLP_YNA_YES:
									iter->m_fToBeDeleted = true;
									break;
								}
							}
						}
					}
				}
			}

			if (iter->m_fUnconditionalDeleteOnUninstall)
				iter->m_fToBeDeleted = true;
		}

		::VLog(L"to be deleted: %s", iter->m_fToBeDeleted ? L"true" : L"false");
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrUninstall_CheckIfRebootRequired()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);
	bool fRebootRequired = false;
	bool fDeleteMe = false;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		HANDLE hFile = NULL;

		if (iter->m_fErrorInWorkItem || !iter->m_fToBeDeleted)
			continue;

		iter->m_fTargetInUse = false;

		::VLog(L"Checking for reboot required to delete file \"%s\"", iter->m_szTargetFile);

		// If the file's not there, we can skip all of this:
		if (iter->m_dwTargetAttributes == 0xffffffff)
			continue;

		// We're planning on deleting the file; let's get rid of the readonly attribute if it's set.
		if (iter->m_dwTargetAttributes & FILE_ATTRIBUTE_READONLY)
		{
			::VLog(L"Clearing readonly file attribute for file");
			::SetLastError(ERROR_SUCCESS);
			if (!NVsWin32::SetFileAttributesW(iter->m_szTargetFile, iter->m_dwTargetAttributes & ~FILE_ATTRIBUTE_READONLY))
			{
				const DWORD dwLastError = ::GetLastError();

				if (dwLastError == ERROR_SHARING_VIOLATION)
				{
					// this isn't a bad sign really, it's just that we're definitely going to have to reboot.
					iter->m_fTargetInUse = true;

					// someone might have made us readonly...
					if (_wcsicmp(iter->m_szTargetFile, g_wszThisExe) == 0)
					{
						if (!fRebootRequired)
							fDeleteMe = true;
					}
					else
					{
						::VLog(L"Target file is in use; we're going to have to reboot!");
						fRebootRequired = true;
						fDeleteMe = false;
					}

					continue;
				}
				else if (dwLastError == ERROR_FILE_NOT_FOUND)
				{
					// If the file's already gone, there's no point in complaining!
					continue;
				}
				else if (dwLastError != ERROR_SUCCESS)
				{
					::VLog(L"Error setting file attributes during deletion reboot check; last error = %d", dwLastError);
					hr = HRESULT_FROM_WIN32(dwLastError);
					goto Finish;
				}
			}
		}

		// Let's see if any of these files have open handles to them; if they do, we're going to
		// have to reboot.  This will allow us to warn the user and let them choose to close applications.
		hFile = NVsWin32::CreateFileW(iter->m_szTargetFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			const DWORD dwLastError = ::GetLastError();

			if (dwLastError == ERROR_SHARING_VIOLATION)
			{
				// It's busy... 
				iter->m_fTargetInUse = true;

				if (_wcsicmp(iter->m_szTargetFile, g_wszThisExe) == 0)
				{
					// hey, it's us!  If we're not rebooting, have us commit suicide when this process
					// exits.
					if (!fRebootRequired)
						fDeleteMe = true;
				}
				else
				{
					// If we're going to have to reboot, there's no point in deleting ourselves.
					fRebootRequired = true;
					fDeleteMe = false;
				}
			}
			else
			{
				::VLog(L"Error testing for writability during deletion reboot check; last error = %d", dwLastError);
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}
		}

		if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE) && !::CloseHandle(hFile))
		{
			const DWORD dwLastError = ::GetLastError();
			::VLog(L"Error closing handle during deletion reboot check; last error = %d", dwLastError);
			hr = HRESULT_FROM_WIN32(dwLastError);
			goto Finish;
		}
	}

	hr = NOERROR;

	if (fRebootRequired)
	{
		::VLog(L"We've decided to reboot...");
		g_fRebootRequired = true;
	}

	if (fDeleteMe)
	{
		::VLog(L"We're going to try to delete the running msinfhlp.exe when we're done");
		g_fDeleteMe = true;
	}

Finish:
	return hr;
}

HRESULT CWorkItemList::HrUninstall_Unregister()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);
	bool fRebootRequired = false;
	HINSTANCE hInstance = NULL;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fToBeDeleted || (iter->m_dwTargetAttributes == 0xffffffff))
			continue;

		if (!iter->m_fTargetSelfRegistering)
		{
			WCHAR szExt[_MAX_EXT];

			_wsplitpath(iter->m_szTargetFile, NULL, NULL, NULL, szExt);

			if (_wcsicmp(szExt, L".class") == 0)
			{
				bool fNeedsReg = false;

				::VLog(L"Considering whether to run vjreg to unregister \"%s\"", iter->m_szTargetFile);

				hr = ::HrAnalyzeClassFile(iter->m_szTargetFile, fNeedsReg);
				if (FAILED(hr))
				{
					::VLog(L"Error analyzing java class file; hresult = 0x%08lx", hr);
					goto Finish;
				}

				if (fNeedsReg)
				{
					hr = this->HrUnregisterJavaClass(iter->m_szTargetFile);
					if (FAILED(hr))
					{
						::VLog(L"Error unregistering java class; hresult = 0x%08lx", hr);
						goto Finish;
					}
				}
			}
		}
		else
		{
			// If it's self-registering, let's unregister it.
			if (iter->m_fTargetIsEXE)
			{
				WCHAR szCommandLine[MSINFHLP_MAX_PATH];

				::VFormatString(NUMBER_OF(szCommandLine), szCommandLine, L"%0 /UnRegServer", iter->m_szTargetFile);

				hr = this->HrRunProcess(szCommandLine);
				if (FAILED(hr))
				{
					::VLog(L"Error running process; hresult = 0x%08lx", hr);
					goto Finish;
				}
			}
			
			if (iter->m_fTargetIsDLL)
			{
				//Here, we know that the ole self register flag is set.  So if we cannot load it, or
				//if we run int oa problem loading this file, then we cannot register it, so we fail.
				hInstance = NVsWin32::LoadLibraryExW(iter->m_szTargetFile, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
				if (hInstance == NULL)
				{
					const DWORD dwLastError = ::GetLastError();
					hr = HRESULT_FROM_WIN32(dwLastError);
					VLog(L"Attempt to load library \"%s\" failed", iter->m_szTargetFile);
					goto Finish;
				}

				//get the procedure address for registering this thing; exit if it doesn't exist
				typedef HRESULT (__stdcall *LPFNDLLUNREGISTERSERVER)();
				LPFNDLLUNREGISTERSERVER pfn;
				pfn = (LPFNDLLUNREGISTERSERVER) NVsWin32::GetProcAddressW(hInstance, L"DllUnregisterServer");
				if (!pfn)
				{
					// I guess it doesn't really self-register!
					hr = NOERROR;
					VLog(L"The DLL \"%s\" has OLESelfRegister, but no DllUnregisterServer entry point", iter->m_szTargetFile);
					goto Finish;
				}

				::SetErrorInfo(0, NULL);
				hr = (*pfn)();
				if (FAILED(hr))
				{
					VLog(L"Call to DllUnregisterServer() failed");
					goto Finish;
				}

				if (!::FreeLibrary(hInstance))
				{
					hInstance = NULL;
					const DWORD dwLastError = ::GetLastError();
					hr = HRESULT_FROM_WIN32(dwLastError);
					VLog(L"FreeLibrary() failed");
					goto Finish;
				}

				hInstance = NULL;
			}
		}
	}

	hr = NOERROR;

Finish:
	if (hInstance != NULL)
		::FreeLibrary(hInstance);

	return hr;
}

HRESULT CWorkItemList::HrUnregisterJavaClass(LPCWSTR szFile)
{
	HRESULT hr = NOERROR;
	WCHAR szBuffer[MSINFHLP_MAX_PATH];
	WCHAR szVjReg[_MAX_PATH];

	::VExpandFilename(L"<SysDir>\\vjreg.exe", NUMBER_OF(szVjReg), szVjReg);
	::VFormatString(NUMBER_OF(szBuffer), szBuffer, L"%0 /nologo /unreg \"%1\"", szVjReg, szFile);

	hr = this->HrRunProcess(szBuffer);
	if (FAILED(hr))
		goto Finish;

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrUninstall_DeleteFiles()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);
	WCHAR szDrive[_MAX_DRIVE];
	WCHAR szDir[_MAX_DIR];
	WCHAR szPath[_MAX_PATH];
	ULONG cch;

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fToBeDeleted)
			continue;

		if (_wcsicmp(iter->m_szTargetFile, g_wszThisExe) == 0)
			continue;

		::VLog(L"Attempting to delete file \"%s\"", iter->m_szTargetFile);

		if (!NVsWin32::DeleteFileW(iter->m_szTargetFile))
		{
			const DWORD dwLastError = ::GetLastError();

			::VLog(L"Unable to delete file: \"%s\"; last error = %d", iter->m_szTargetFile, dwLastError);

			if ((g_fRebootRequired) &&
				((dwLastError == ERROR_SHARING_VIOLATION) ||
				 (dwLastError == ERROR_ACCESS_DENIED)))
			{
				// I guess we expected this.  Let's just get rid of the file when we reboot.
				if (_wcsicmp(iter->m_szTargetFile, g_wszThisExe) != 0)
				{
					if (!NVsWin32::MoveFileExW(iter->m_szTargetFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
					{
						const DWORD dwLastError = ::GetLastError();
						::VLog(L"Unable to request file to be deleted at reboot time; last error = %d", dwLastError);
						hr = HRESULT_FROM_WIN32(dwLastError);
						goto Finish;
					}
				}
			}
			else if ((dwLastError == ERROR_FILE_NOT_FOUND) ||
				(dwLastError == ERROR_PATH_NOT_FOUND))
			{
				::VLog(L"Attempted to delete file, but it's already gone!  last error = %d", dwLastError);
			}
			else
			{
				iter->m_fStillExists = true;
				hr = HRESULT_FROM_WIN32(dwLastError);
				goto Finish;
			}
		}

		// We were able to delete the file; try to delete the directory!
		_wsplitpath(iter->m_szTargetFile, szDrive, szDir, NULL, NULL);
		_wmakepath(szPath, szDrive, szDir, NULL, NULL);

		cch = wcslen(szPath);
		if ((cch != 0) && (szPath[cch - 1] == L'\\'))
			szPath[cch - 1] = L'\0';

		::VLog(L"Attempting to remove directory \"%s\"", szPath);

		for (;;)
		{
			if (!NVsWin32::RemoveDirectoryW(szPath))
			{
				const DWORD dwLastError = ::GetLastError();

				if ((dwLastError == ERROR_DIR_NOT_EMPTY) ||
					(dwLastError == ERROR_ACCESS_DENIED))
				{
					if (g_fRebootRequired)
					{
						if (!NVsWin32::MoveFileExW(szPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
						{
							const DWORD dwLastError = ::GetLastError();
							// I believe that not being able to delete a directory should not stop the
							// uninstall; in fact if the directory can't be deleted at reboot time, there's
							// no way to inform the user at all.  So if we get an error here, we're going
							// to log it, but not stop the train.  -mgrier 3/12/98
							::VLog(L"Unable to schedule directory for deletion; last error = %d", dwLastError);
						}
					}
				}
				else
				{
					::VLog(L"Attempt to delete directory \"%s\" failed; last error = %d", szPath, dwLastError);
				}

				break;
			}
			else
			{
				// See if there are more directory names to try to delete.  If there are, just
				// turn the last slash to a null character and iterate.
				LPWSTR pszSlash = wcsrchr(szPath, L'\\');
				if (pszSlash == NULL)
					break;

				*pszSlash = L'\0';
			}
		}
	}

	hr = NOERROR;

Finish:
	return hr;
}

HRESULT CWorkItemList::HrUninstall_UpdateRefCounts()
{
	HRESULT hr = NOERROR;
	CWorkItemIter iter(this);

	CVsRegistryKey hkeySharedDlls;

	hr = hkeySharedDlls.HrOpenKeyExW(
			HKEY_LOCAL_MACHINE,
			L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls",
			0,
			KEY_QUERY_VALUE | KEY_SET_VALUE);
	if (FAILED(hr))
	{
		::VLog(L"Failed to open the SharedDlls registry key; hresult = 0x%08lx", hr);
		goto Finish;
	}

	for (iter.VReset(); iter.FMore(); iter.VNext())
	{
		if (iter->m_fErrorInWorkItem || !iter->m_fIsRefCounted || iter->m_dwFileReferenceCount == 0xffffffff)
			continue;

		DWORD dwRefCount = iter->m_dwFileReferenceCount - 1;

		::VLog(L"Updating reference count for file \"%s\" to %u", iter->m_szTargetFile, dwRefCount);

		if (dwRefCount == 0)
		{
			hr = hkeySharedDlls.HrDeleteValueW(iter->m_szTargetFile);
			if (FAILED(hr))
			{
				::VLog(L"Failed to delete registry entry; hresult = 0x%08lx", hr);
				goto Finish;
			}
		}
		else
		{
			hr = hkeySharedDlls.HrSetValueExW(
						iter->m_szTargetFile,
						0,
						REG_DWORD,
						(LPBYTE) &dwRefCount,
						sizeof(dwRefCount));
			if (FAILED(hr))
			{
				::VLog(L"Failed to update registry value; hresult = 0x%08lx", hr);
				goto Finish;
			}
		}
	}

	hr = NOERROR;

Finish:
	return hr;
}

static inline BYTE to_u1(BYTE *pb) { return *pb; }
static inline USHORT to_u2(BYTE *pb) { return static_cast<USHORT>(((*pb) << 8) + *(pb + 1)); }
static inline ULONG to_u4(BYTE *pb) { return (*pb << 24) + (*(pb+ 1) << 16) + (*(pb + 2) << 8) + (*(pb + 3) << 0); }

HRESULT HrAnalyzeClassFile
(
LPCOLESTR szFileName,
bool &rfNeedsToBeRegistered
) throw ()
{
	HRESULT hr = S_FALSE;

	HANDLE hFile = INVALID_HANDLE_VALUE;
	HANDLE hMapping = INVALID_HANDLE_VALUE;
	BYTE *pbFileStart = NULL;

    // Apparently, ::CreateFileMapping() crashes when the file size is 0.
    // So, lets do a quick return if the file size is 0.
	ULONG ulFileSize;

	unsigned short usAccessFlags = 0;
	unsigned short usThisClass = 0;
	unsigned short usSuperClass = 0;
	unsigned short usInterfaceCount = 0;
	unsigned short usFieldCount = 0;
	unsigned short usMethodCount = 0;
	unsigned short usAttributeCount = 0;
	unsigned short usClsidGuidPoolIndex = 0xffff;
	LPBYTE pbGuidPool = NULL;
	
	int iResult;

	ULONG cCP = 0;

	LPBYTE rgpbCP_auto[1000];
	LPBYTE *prgpbCP_dynamic = NULL;

	LPBYTE *prgpbCP = rgpbCP_auto;

	ULONG i;
	BYTE *pbCurrent;
	BYTE *pbEnd;

	hFile = NVsWin32::CreateFileW(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == NULL)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Failed to create file; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	ulFileSize = ::GetFileSize(hFile, NULL);
	if (ulFileSize == 0xffffffff)
	{
		const DWORD dwLastError = ::GetLastError();
		::VLog(L"Failed to get file size; last error = %d", dwLastError);
		hr = HRESULT_FROM_WIN32(dwLastError);
		goto Finish;
	}

	if (ulFileSize == 0)
		goto Finish;

	hMapping = ::CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMapping == NULL)
	{
		hr = E_FAIL;
		hMapping = INVALID_HANDLE_VALUE;
		goto Finish;
	}

	pbFileStart = reinterpret_cast<BYTE *>(::MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0));
	if (pbFileStart == NULL)
	{
		hr = E_FAIL;
		goto Finish;
	}

	pbEnd = pbFileStart + ulFileSize;

	// If the file doesn't have the right magic number, and/or it doesn't have the right major version
	// number, punt.
	if ((to_u4(pbFileStart) != 0xcafebabe) ||
		(to_u2(pbFileStart + 6) != 45))
	{
		hr = S_FALSE;
		goto Finish;
	}

	// We now do some preliminary analysis on the class file that we need to do,
	// regardless of what we're really trying to do; this means building up a table
	// in memory of the constant pool.
	cCP = to_u2(pbFileStart + 8);

	prgpbCP_dynamic = NULL;
	prgpbCP = rgpbCP_auto;

	if (cCP > NUMBER_OF(rgpbCP_auto))
	{
		prgpbCP_dynamic = new LPBYTE[cCP];
		if (prgpbCP_dynamic == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Finish;
		}
		prgpbCP = prgpbCP_dynamic;
	}

	pbCurrent = pbFileStart + 10;

	// The constant pool starts its indexing at 1.  Whatever.
	for (i=1; (pbCurrent != NULL) && (i < cCP); i++)
	{
		prgpbCP[i] = pbCurrent;

		switch (*pbCurrent)
		{
		case 1: // CONSTANT_Utf8
			pbCurrent += to_u2(pbCurrent + 1);
			pbCurrent += 3; // for the u2 length referenced above
			break;

		case 3: // CONSTANT_Integer
		case 4: // CONSTANT_Float
		case 9: // CONSTANT_Fieldref
		case 10: // CONSTANT_Methodref
		case 11: // CONSTANT_InterfaceMethodRef
		case 12: // CONSTANT_NameAndType
			pbCurrent += 5;
			break;

		case 5: // CONSTANT_Long
		case 6: // CONSTANT_Double
			pbCurrent += 9;
			prgpbCP[i++] = NULL;
			break;

		case 7: // CONSTANT_Class
		case 8: // CONSTANT_String
			pbCurrent += 3;
			break;

		default:
			pbCurrent = NULL;
			break;
		}
	}

	// If we hit any errors during the constant pool analysis, just close up shop.
	if (pbCurrent == NULL)
	{
		hr = S_FALSE;
		goto Finish;
	}

	if ((pbCurrent + 1) >= pbEnd)
		goto Finish;

	usAccessFlags = to_u2(pbCurrent);
	pbCurrent += 2;

	if ((pbCurrent + 1) >= pbEnd)
		goto Finish;

	usThisClass = to_u2(pbCurrent);
	pbCurrent += 2;

	if ((pbCurrent + 1) >= pbEnd)
		goto Finish;

	usSuperClass = to_u2(pbCurrent);
	pbCurrent += 2;

	if ((pbCurrent  + 1) >= pbEnd)
		goto Finish;

	usInterfaceCount = to_u2(pbCurrent);
	pbCurrent += 2;

	// usInterfaceCount is the number of interface constant pool indices; we're not interested in interfaces
	// so we just skip over them.
	pbCurrent += (usInterfaceCount * 2);

	if ((pbCurrent + 1) >= pbEnd)
		goto Finish;

	usFieldCount = to_u2(pbCurrent);
	pbCurrent += 2;

	// we're also not interested in fields, but this is harder to skip.
	for (i=0; i<usFieldCount; i++)
	{
		if ((pbCurrent + 1) >= pbEnd)
			goto Finish;

		unsigned short usFieldAccessFlags = to_u2(pbCurrent);
		pbCurrent += 2;

		if ((pbCurrent + 1) >= pbEnd)
			goto Finish;

		unsigned short usFieldNameIndex = to_u2(pbCurrent);
		pbCurrent += 2;

		if ((pbCurrent + 1) >= pbEnd)
			goto Finish;

		unsigned short usFieldDescriptorIndex = to_u2(pbCurrent);
		pbCurrent += 2;

		if ((pbCurrent + 1) >= pbEnd)
			goto Finish;

		unsigned short usFieldAttributeCount = to_u2(pbCurrent);
		pbCurrent += 2;

		ULONG j;

		for (j=0; j<usFieldAttributeCount; j++)
		{
			if ((pbCurrent + 1) >= pbEnd)
				goto Finish;

			unsigned short usFieldAttributeNameIndex = to_u2(pbCurrent);
			pbCurrent += 2;

			if ((pbCurrent + 3) >= pbEnd)
				goto Finish;

			unsigned long ulFieldAttributeLength = to_u4(pbCurrent);
			pbCurrent += 4;

			pbCurrent += ulFieldAttributeLength;
		}
	}

	// we've skipped the class's fields; let's skip the methods too:

	if ((pbCurrent + 1) >= pbEnd)
		goto Finish;

	usMethodCount = to_u2(pbCurrent);
	pbCurrent += 2;

	for (i=0; i<usMethodCount; i++)
	{
		if ((pbCurrent + 1) >= pbEnd)
			goto Finish;

		unsigned short usMethodAccessFlags = to_u2(pbCurrent);
		pbCurrent += 2;

		if ((pbCurrent + 1) >= pbEnd)
			goto Finish;

		unsigned short usMethodNameIndex = to_u2(pbCurrent);
		pbCurrent += 2;

		if ((pbCurrent + 1) >= pbEnd)
			goto Finish;

		unsigned short usMethodDescriptorIndex = to_u2(pbCurrent);
		pbCurrent += 2;

		if ((pbCurrent + 1) >= pbEnd)
			goto Finish;

		unsigned short usMethodAttributeCount = to_u2(pbCurrent);
		pbCurrent += 2;

		ULONG j;

		for (j=0; j<usMethodAttributeCount; j++)
		{
			if ((pbCurrent + 1) >= pbEnd)
				goto Finish;

			unsigned short usMethodAttributeNameIndex = to_u2(pbCurrent);
			pbCurrent += 2;

			if ((pbCurrent + 3) >= pbEnd)
				goto Finish;

			unsigned long ulMethodAttributeLength = to_u4(pbCurrent);
			pbCurrent += 4;

			pbCurrent += ulMethodAttributeLength;
		}
	}

	if ((pbCurrent + 1) >= pbEnd)
		goto Finish;

	usAttributeCount = to_u2(pbCurrent);
	pbCurrent += 2;

	for (i=0; i<usAttributeCount; i++)
	{
		if ((pbCurrent + 1) >= pbEnd)
			goto Finish;

		unsigned short usAttributeNameIndex = to_u2(pbCurrent);
		pbCurrent += 2;

		if ((pbCurrent + 3) >= pbEnd)
			goto Finish;

		unsigned long ulAttributeLength = to_u4(pbCurrent);
		pbCurrent += 4;

		if (ConstantPoolNameEquals(cCP, prgpbCP, usAttributeNameIndex, "COM_Register"))
		{
			if ((pbCurrent + 13) >= pbEnd)
				goto Finish;

			unsigned short usFlags = to_u2(pbCurrent);
			usClsidGuidPoolIndex = to_u2(pbCurrent + 2);
			unsigned short usTypelibIndex = to_u2(pbCurrent + 4);
			unsigned short usTypelibMajor = to_u2(pbCurrent + 6);
			unsigned short usTypelibMinor = to_u2(pbCurrent + 8);
			unsigned short usProgid = to_u2(pbCurrent + 10);
			unsigned short usDescriptIdx = to_u2(pbCurrent + 12);
		}
		else if (ConstantPoolNameEquals(cCP, prgpbCP, usAttributeNameIndex, "COM_GuidPool"))
		{
			pbGuidPool = pbCurrent;
		}

		pbCurrent += ulAttributeLength;
	}

	if ((pbGuidPool != NULL) && (usClsidGuidPoolIndex != 0xffff))
	{
		if ((pbGuidPool + 1) >= pbEnd)
			goto Finish;

		unsigned short nGuids = to_u2(pbGuidPool);
		GUID *prgguid = (GUID *) (pbGuidPool + 2);

		if (usClsidGuidPoolIndex < nGuids)
		{
			CLSID *pclsid = prgguid + usClsidGuidPoolIndex;

			if ((((LPBYTE) pclsid) + sizeof(CLSID) - 1) >= pbEnd)
				goto Finish;

			rfNeedsToBeRegistered = true;
		}
	}

	hr = NOERROR;

Finish:

	if (pbFileStart != NULL)
	{
		::UnmapViewOfFile(pbFileStart);
		pbFileStart = NULL;
	}

	if (hMapping != INVALID_HANDLE_VALUE)
	{
		::CloseHandle(hMapping);
		hMapping = INVALID_HANDLE_VALUE;
	}

	if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))
	{
		::CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	}

	if (prgpbCP_dynamic != NULL)
	{
		delete []prgpbCP_dynamic;
		prgpbCP_dynamic = NULL;
	}

	return hr;
}

static bool ConstantPoolNameEquals
(
ULONG cCP,
LPBYTE *prgpbCP,
ULONG iCP,
char szString[]
)
{
	if ((prgpbCP == NULL) || (szString == NULL))
		return false;

	if ((iCP == 0) || (iCP >= cCP))
		return false;

	BYTE *pb = prgpbCP[iCP];

	// Make sure it's a UTF-8 string
	if (to_u1(pb) != 1)
		return false;

	const ULONG cch = strlen(szString);

	const unsigned short cchCP = to_u2(pb + 1);

	if (cch != cchCP)
		return false;

	return (memcmp(pb + 3, szString, cch) == 0);
}

static void CALLBACK TimerProc_PostRunProcess(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
	// All we do is set this event so that the message loop after creating the process continues.
	::SetEvent(s_hEvent_PostRunProcess);
	::KillTimer(NULL, s_uiTimer_PostRunProcess);
	s_uiTimer_PostRunProcess = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\selfextract\sxsexpress.cpp ===
#include "windows.h"
#include "sxsexpress.h"


int __cdecl wmain(int argc, WCHAR* argv[])
{
    HMODULE hmOurHandle = NULL;

    //
    // Install all the cabinets we have internally
    //
    return SxsExpressCore(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxsexpress\creator\creator.cpp ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "fcntl.h"
#include "sxsexpress.h"
#include "fci.h"

#define NUMBER_OF(q) (sizeof(q)/sizeof(*q))

#ifndef PAGE_SIZE
#define PAGE_SIZE   (4*1024)
#endif

#define FILETYPE_CABINET            (0x00000001)
#define FILETYPE_DISKFILE           (0x00000002)
#define DEFAULT_RESERVE_SIZE        (1024*1024*80) // By default, reserve 80mb
//#define DEFAULT_RESERVE_SIZE        (1024*8) // By default, reserve 80mb

typedef struct _FILE_HANDLE {
    DWORD dwFileType;
    union {
        HANDLE hDiskFile;
        struct {
            PVOID pvFileBase;
            PVOID pvCursor;
            SIZE_T cbReserved;
            SIZE_T cbCommitted;
            SIZE_T cbWritten;
        } CabinetFile;
    };
} FILE_HANDLE;

typedef struct _INSTALLED_FILE_NAME {
    LIST_ENTRY Links;
    PCWSTR pwszFileName;
    PCWSTR pwszSubDir;
} INSTALLED_FILE;

LIST_ENTRY InstalledFiles;

typedef struct _FCI_CONTEXT_OBJECT
{
    bool fWasError;
    DWORD dwLastError;
    FILE_HANDLE *CabinetFileHandle;
    PCSTR pszCabFileName;

    void ObtainErrorContext()
    {
        if (!fWasError)
        {
            fWasError = true;
            dwLastError = ::GetLastError();
        }
    }

} FCI_CONTEXT_OBJECT;

BOOL CreateCabFromPath(PCWSTR pcwszBasePath, FILE_HANDLE *CreatedCabinet, PCWSTR pcwszInfName);

void
DoHelp(PCWSTR pcwszName)
{
    static const WCHAR wchHelp[] =
        L"SxsExpress Self-Extracting Creator Tool\r\n"
        L"Copyright (c) 2001-2002 Microsoft Corporation, all \r\n"
        L"\r\n"
        L"Commandline:\r\n"
        L"\r\n"
        L"   %ls [options] outputname\r\n"
        L"\r\n"
        L"Options:\r\n"
        L"-sourcedir <dir>      : Sets the base path to package up\r\n"
        L"-sfxheader <file>     : Self-extractor core (exe or dll) file\r\n"
        L"-infname <file>       : Pass in a pre-built downlevel installer .INF\r\n"
        L"                        (If not specified, the tool will build an appropriate\r\n"
        L"                        .INF that installs everything to system32)\r\n"
        L"-overwrite            : Forces the tool to output the built package even\r\n"
        L"                        if the file <outputname> already exists\r\n";

    wprintf(wchHelp, pcwszName);
}


PCWSTR
GenerateInfFromTo(
    PCWSTR pcwszPackageDir
    )
{
    return NULL;
}


int __cdecl wmain(int argc, PCWSTR* argv)
{
    PCWSTR pcwszHeaderName = NULL;
    PCWSTR pcwszPackageDir = NULL;
    PCWSTR pcwszInfName = NULL;
    PCWSTR pcwszOutputName = NULL;
    bool fAllocatedInfName = false;
    bool fOverwrite = false;
    FILE_HANDLE Created;
    HANDLE hResource = INVALID_HANDLE_VALUE;;
    int iResult = -1;
    BOOL fOk = FALSE;

    //
    // Determine parameters
    //
    for (int i = 1; i < argc; i++)
    {
        if ((*argv[i] == L'-') || (*argv[i] == L'/'))
        {
            PCWSTR psz = argv[i] + 1;

            if (lstrcmpiW(psz, L"sourcedir") == 0)
            {
                if (pcwszPackageDir != NULL)
                {
                    DoHelp(argv[0]);
                    wprintf(L"Already specified a packaging directory.\r\n");
                    goto Exit;
                }
                else
                {
                    pcwszPackageDir = argv[++i];
                }
            }
            else if (lstrcmpiW(psz, L"sfxheader") == 0)
            {
                if (pcwszHeaderName != NULL)
                {
                    DoHelp(argv[0]);
                    wprintf(L"Already specified the SFX header.\r\n");
                    goto Exit;
                }
                else
                {
                    pcwszHeaderName = argv[++i];
                }
            }
            else if (lstrcmpiW(psz, L"infname") == 0)
            {
                if (pcwszInfName != NULL)
                {
                    DoHelp(argv[0]);
                    wprintf(L"Already specified an INF name, only one at a time.\r\n");
                    goto Exit;
                }
                else
                {
                    pcwszInfName = argv[++i];
                }
            }
            else if (lstrcmpiW(psz, L"overwrite") == 0)
            {
                fOverwrite = true;
            }
            else
            {
                DoHelp(argv[0]);
                wprintf(L"\r\nUnknown option %ls\r\n", psz);
                goto Exit;
            }
        }
        else
        {
            if (pcwszOutputName != NULL)
            {
                DoHelp(argv[0]);
                wprintf(L"\r\nToo many output names, just one please.\r\n");
                goto Exit;
            }
            else
            {
                pcwszOutputName = argv[i];
            }
        }
    }

    if ((pcwszHeaderName == NULL) || (pcwszPackageDir == NULL) || (pcwszOutputName == NULL))
    {
        DoHelp(argv[0]);
        wprintf(L"\r\nMust specify at least the sfx header file, source directory, and output\r\n");
        goto Exit;
    }


    //
    // Ok, let's generate the cabinet file from the source directory.  When this is done,
    // it'll be sitting in memory.  We then have to copy the source header to the target
    // filename and do some work to update its resources
    //
    if (!CreateCabFromPath(pcwszPackageDir, &Created, pcwszInfName))
    {
        wprintf(L"Error %ld creating cabinet from %ls\r\n", ::GetLastError(), pcwszPackageDir);
        goto Exit;
    }

    //
    // Copy the file over
    //
    if (!CopyFileW(pcwszHeaderName, pcwszOutputName, fOverwrite ? FALSE : TRUE))
    {
        const DWORD dwError = ::GetLastError();
        if (dwError == ERROR_FILE_EXISTS)
        {
            wprintf(L"Error, file %ls already exists.  Move it or delete it, please.\r\n", pcwszOutputName);
        }
        else
        {
            wprintf(L"Error %ld copying SFX header %ls to output %ls\r\n", dwError, pcwszHeaderName, pcwszOutputName);
        }
        goto Exit;
    }

    //
    // The output contains the cabinet data above in its resources at a certain name.
    // Do this by updating the resource table now.
    //
    hResource = BeginUpdateResourceW(pcwszOutputName, FALSE);

    if ((hResource == NULL) || (hResource == INVALID_HANDLE_VALUE))
    {
        wprintf(L"Unable to open %ls for resource updating, error 0x%08lx\n", pcwszOutputName, GetLastError());
        goto Exit;
    }

    fOk = UpdateResourceW(hResource, SXSEXPRESS_RESOURCE_TYPE, SXSEXPRESS_RESOURCE_NAME, 0, Created.CabinetFile.pvFileBase, Created.CabinetFile.cbWritten);

    if (!EndUpdateResourceW(hResource, !fOk))
    {
        wprintf(L"Failed updating resources, error code 0x%08lx\n", GetLastError());
        goto Exit;
    }

    iResult = 0;
Exit:

    if (fAllocatedInfName && pcwszInfName)
        HeapFree(GetProcessHeap(), 0, (PVOID)pcwszInfName);

    return iResult;

}

/*

    Our very own mini-cabarc code to create sxsexpress packages

*/
CHAR WorkingBufferOne[2048];
CHAR WorkingBufferTwo[2048];



FNFCIFILEPLACED(s_FilePlaced) { printf("Placed file %s (%d bytes)\n", pszFile, cbFile); return 1; }
FNFCIALLOC(s_Alloc) { return HeapAlloc(GetProcessHeap(), 0, cb); }
FNFCIFREE(s_Free) { HeapFree(GetProcessHeap(), 0, memory); }

FNFCIOPEN(s_OpenFile)
{
    FCI_CONTEXT_OBJECT *pContext = (FCI_CONTEXT_OBJECT*)pv;
    FILE_HANDLE *hHandle = NULL;
    INT_PTR ipRetVal = -1;
    int iConversion = 0, iActual = 0;
    PWSTR pszConverted = NULL;

    hHandle = (FILE_HANDLE*)s_Alloc(sizeof(FILE_HANDLE));
    if (!hHandle) {
        pContext->ObtainErrorContext();
        *err = ::GetLastError();
        goto Exit;
    }

    ZeroMemory(hHandle, sizeof(*hHandle));

    //
    // All strings that get here are in UTF-8.  Convert them back.
    //
    iConversion = MultiByteToWideChar(CP_UTF8, 0, pszFile, -1, NULL, 0);
    if (iConversion == 0)
    {
        pContext->ObtainErrorContext();
        *err = ::GetLastError();
        goto Exit;
    }

    pszConverted = (PWSTR)s_Alloc(sizeof(WCHAR) * (iConversion + 1));
    if (NULL == pszConverted)
    {
        pContext->ObtainErrorContext();
        *err = ::GetLastError();
        goto Exit;
    }

    iActual = MultiByteToWideChar(CP_UTF8, 0, pszFile, -1, pszConverted, iConversion);
    if ((iActual == 0) || (iActual > iConversion))
    {
        pContext->ObtainErrorContext();
        *err = ::GetLastError();
        goto Exit;
    }
    else
    {
        pszConverted[iConversion] = UNICODE_NULL;
    }


    if (oflag & _O_CREAT)
    {
        //
        // The actual cabinet file becomes a large block of committed bytes
        //
        if (lstrcmpiA(pContext->pszCabFileName, pszFile) == 0)
        {
            if (pContext->CabinetFileHandle)
            {
                pContext->fWasError = true;
                *err = (int)(pContext->dwLastError = ERROR_INVALID_PARAMETER);
            }
            else
            {
                hHandle->dwFileType = FILETYPE_CABINET;
                hHandle->CabinetFile.pvFileBase = VirtualAlloc(NULL, DEFAULT_RESERVE_SIZE, MEM_RESERVE, PAGE_READWRITE);
                hHandle->CabinetFile.cbReserved = DEFAULT_RESERVE_SIZE;
                hHandle->CabinetFile.cbCommitted = 0;
                hHandle->CabinetFile.pvCursor = hHandle->CabinetFile.pvFileBase;
                hHandle->CabinetFile.cbWritten = 0;
                pContext->CabinetFileHandle = hHandle;
            }
        }
        else
        {

            //
            // Open a real file on disk to write - probably a temp file
            //
            hHandle->dwFileType = FILETYPE_DISKFILE;
            hHandle->hDiskFile = CreateFileW(pszConverted, GENERIC_READ | GENERIC_WRITE , FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

            if (hHandle->hDiskFile == INVALID_HANDLE_VALUE)
            {
                pContext->ObtainErrorContext();
                *err = ::GetLastError();
                goto Exit;
            }
        }
    }
    //
    // Read a file from disk
    //
    else
    {
        hHandle->dwFileType = FILETYPE_DISKFILE;
        wprintf(L"Opening %ls\n", pszConverted);
        hHandle->hDiskFile = CreateFileW(pszConverted, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (hHandle->hDiskFile == INVALID_HANDLE_VALUE)
        {
            pContext->ObtainErrorContext();
            *err = ::GetLastError();
            goto Exit;
        }
    }

    ipRetVal = (INT_PTR)hHandle;
    hHandle = NULL;
Exit:
    if (pszConverted)
        s_Free(pszConverted);
        
    if (hHandle)
    {
        s_Free(hHandle);
    }

    return ipRetVal;
}

FNFCIREAD(s_ReadFile)
{
    FILE_HANDLE *pFile = (FILE_HANDLE*)hf;
    FCI_CONTEXT_OBJECT *pContext = (FCI_CONTEXT_OBJECT*)pv;
    DWORD cbReadSize = 0;
    UINT uiRetVal = -1;

    if (pFile->dwFileType == FILETYPE_DISKFILE)
    {
        if (!ReadFile(pFile->hDiskFile, memory, cb, &cbReadSize, NULL))
        {
            pContext->ObtainErrorContext();
            *err = ::GetLastError();
            goto Exit;
        }
    }
    else if (pFile->dwFileType == FILETYPE_CABINET)
    {
        ULONG_PTR ulCursor = (ULONG_PTR)pFile->CabinetFile.pvCursor;
        const ULONG_PTR ulTotalSize = (ULONG_PTR)pFile->CabinetFile.pvFileBase + pFile->CabinetFile.cbWritten;

        if (ulCursor >= ulTotalSize)
        {
            cbReadSize = 0;
        }
        else
        {
            if (cb > (ulTotalSize - ulCursor))
            {
                cb = (ulTotalSize - ulCursor);
            }

            memcpy(memory, pFile->CabinetFile.pvCursor, cb);
            pFile->CabinetFile.pvCursor = (PVOID)(ulCursor + cb);
        }
    }
    else
    {
        pContext->fWasError = true;
        *err = (int)(pContext->dwLastError = ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    uiRetVal = cbReadSize;
Exit:
    return uiRetVal;
}

FNFCIWRITE(s_WriteFile)
{
    FILE_HANDLE *pFile = (FILE_HANDLE*)hf;
    FCI_CONTEXT_OBJECT *pContext = (FCI_CONTEXT_OBJECT*)pv;
    UINT uiRetVal = -1;

    //
    // Cabinet in-memory files are in large chunks.  If the current cursor
    // plus the requested write size goes beyond the commit limit, then
    // reserve some more pages.
    //
    if (pFile->dwFileType == FILETYPE_CABINET)
    {
        ULONG_PTR ulpRequiredCommitted = cb;

        ulpRequiredCommitted += ((ULONG_PTR)pFile->CabinetFile.pvCursor - (ULONG_PTR)pFile->CabinetFile.pvFileBase);

        //
        // If the cursor is NULL, or the cursor plus the write request goes beyond
        // the committed range..
        //
        if (ulpRequiredCommitted > pFile->CabinetFile.cbCommitted)
        {
            PVOID pvReserveState;

            //
            // Just attempt to commit all the pages required
            //
            pvReserveState = VirtualAlloc(pFile->CabinetFile.pvFileBase, ulpRequiredCommitted, MEM_COMMIT, PAGE_READWRITE);

            //
            // If this fails, reserve another blob and schmooze the bytes over from the
            // original allocation
            //
            if (pvReserveState == NULL)
            {
                const SIZE_T cbNewReserve = (ulpRequiredCommitted * 2) + (PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

                // Reserve the new block
                pvReserveState = VirtualAlloc(NULL, cbNewReserve, MEM_RESERVE, PAGE_READWRITE);
                if (!pvReserveState)
                {
                    pContext->ObtainErrorContext();
                    *err = ::GetLastError();
                    goto Exit;
                }

                // Commit what's necessary
                if (!VirtualAlloc(pvReserveState, ulpRequiredCommitted, MEM_COMMIT, PAGE_READWRITE))
                {
                    pContext->ObtainErrorContext();
                    *err = ::GetLastError();
                    goto Exit;
                }

                // Shoof data over
                memcpy(pvReserveState, pFile->CabinetFile.pvFileBase, pFile->CabinetFile.cbWritten);

                // Adjust file cursor, if necessary
                if (pFile->CabinetFile.pvCursor == NULL)
                    pFile->CabinetFile.pvCursor = pvReserveState;
                else
                    pFile->CabinetFile.pvCursor = (PVOID)(((ULONG_PTR)pvReserveState) + ((ULONG_PTR)pFile->CabinetFile.pvCursor - (ULONG_PTR)pFile->CabinetFile.pvFileBase));

                // Free old reservation
                VirtualFree(pFile->CabinetFile.pvFileBase, 0, MEM_RELEASE);

                // Reset stuff
                pFile->CabinetFile.pvFileBase = pvReserveState;
                pFile->CabinetFile.cbReserved = cbNewReserve;
                pFile->CabinetFile.cbCommitted = ulpRequiredCommitted;
            }
            else
            {
                pFile->CabinetFile.cbCommitted = ulpRequiredCommitted;
            }
        }

        //
        // Okay, now just copy to the cursor and be done
        //
        memcpy(pFile->CabinetFile.pvCursor, memory, cb);
        pFile->CabinetFile.pvCursor = (PVOID)(((ULONG_PTR)pFile->CabinetFile.pvCursor) + cb);

        // If we wrote more than the high-water marker, reset it
        if (ulpRequiredCommitted > pFile->CabinetFile.cbWritten)
        {
            pFile->CabinetFile.cbWritten = ulpRequiredCommitted;
        }

        uiRetVal = cb;
    }
    else if (pFile->dwFileType == FILETYPE_DISKFILE)
    {
        DWORD cbWritten;

        if (!WriteFile(pFile->hDiskFile, memory, cb, &cbWritten, NULL))
        {
            pContext->ObtainErrorContext();
            *err = ::GetLastError();
            goto Exit;
        }

        uiRetVal = cbWritten;
    }
    else
    {
        pContext->fWasError = true;
        *err = (int)(pContext->dwLastError = ERROR_INVALID_PARAMETER);
        uiRetVal = -1;
        goto Exit;
    }

Exit:
    return uiRetVal;
}

FNFCICLOSE(s_Close)
{
    FILE_HANDLE *pFile = (FILE_HANDLE*)hf;
    FCI_CONTEXT_OBJECT *pContext = (FCI_CONTEXT_OBJECT*)pv;

    if (pFile->dwFileType == FILETYPE_DISKFILE)
    {
        CloseHandle(pFile->hDiskFile);
    }
    else if (pFile->dwFileType == FILETYPE_CABINET)
    {
        if (pFile == pContext->CabinetFileHandle)
            pFile = NULL;
        else
            VirtualFree(pFile->CabinetFile.pvFileBase, 0, MEM_RELEASE);
    }

    if (pFile)
        s_Free(pFile);
    return 0;
}

FNFCISEEK(s_Seek)
{
    FILE_HANDLE *pFile = (FILE_HANDLE*)hf;
    long result;

    if (pFile->dwFileType == FILETYPE_CABINET)
    {
        switch (seektype) {

        case SEEK_SET:
            if (dist < 0) dist = 0;
            pFile->CabinetFile.pvCursor = (PVOID)(((ULONG_PTR)pFile->CabinetFile.pvFileBase) + dist);
            break;

        case SEEK_CUR:
            pFile->CabinetFile.pvCursor = (PVOID)(((INT_PTR)pFile->CabinetFile.pvCursor) + dist);
            break;

        case SEEK_END:
            pFile->CabinetFile.pvCursor = (PVOID)(((INT_PTR)pFile->CabinetFile.pvFileBase) + pFile->CabinetFile.cbWritten + dist);
            break;
        }

        result = (long)((LONG_PTR)pFile->CabinetFile.pvCursor - (LONG_PTR)pFile->CabinetFile.pvFileBase);
    }
    else if (pFile->dwFileType == FILETYPE_DISKFILE)
    {
        result = (long)SetFilePointer(pFile->hDiskFile, dist, NULL, seektype);
    }

    return result;
}

FNFCIDELETE(s_Delete)
{
    FCI_CONTEXT_OBJECT *pContext = (FCI_CONTEXT_OBJECT*)pv;
    *err = 0;

    if (lstrcmpiA(pContext->pszCabFileName, pszFile) == 0)
        return 0;

    if (!DeleteFileA(pszFile))
    {
        pContext->ObtainErrorContext();
        *err = ::GetLastError();
        return -1;
    }
    else
    {
        return 1;
    }
}

FNFCIGETTEMPFILE(s_TempFile)
{
    WCHAR chTemp[MAX_PATH];
    WCHAR chTempOutput[MAX_PATH];
    int i;

    GetTempPathW(NUMBER_OF(chTemp), chTemp);
    GetTempFileNameW(chTemp, L"SXP", 0, chTempOutput);

    i = WideCharToMultiByte(CP_UTF8, 0, chTempOutput, -1, pszTempName, cbTempName, NULL, NULL);
    return ((i > 0) && (i < cbTempName));
}

FNFCIGETNEXTCABINET(s_GetNextCabinet) { return FALSE; }

//
// All files are UTF-8 encoded
//
FNFCIGETOPENINFO(s_GetOpenInfo)
{
    *pdate = *ptime = 0;
    *pattribs = _A_NAME_IS_UTF;
    return s_OpenFile(pszName, _O_BINARY|_O_RDONLY, _A_NAME_IS_UTF, err, pv);
}

FNFCISTATUS(s_StatusCallback)
{
    switch (typeStatus)
    {
    case statusFile:
    case statusFolder:
        return 1;
        break;

    case statusCabinet:
        return cb2;
        break;
    }

    return -1;
}

BOOL
CabPathWorkerCallback(
    HFCI hCabinet,
    PWSTR pwszWorkingTemp,
    SIZE_T cchTotalTemp,
    PCWSTR pwszBaseInCabinet,
    WIN32_FIND_DATAW *pFindData
    )
{
    HANDLE hFind = INVALID_HANDLE_VALUE;
    BOOL fResult = FALSE;
    SIZE_T ccOriginalLength = wcslen(pwszWorkingTemp);
    SIZE_T cchBasePathLength;

    if (pwszBaseInCabinet[0] == L'\\')
        pwszBaseInCabinet++;

    cchBasePathLength = wcslen(pwszBaseInCabinet);

    //
    // Ensure that the string is slash-terminated
    //
    if (pwszWorkingTemp[ccOriginalLength-1] != L'\\')
    {
        pwszWorkingTemp[ccOriginalLength++] = L'\\';
        pwszWorkingTemp[ccOriginalLength] = UNICODE_NULL;
    }

    wcscpy(pwszWorkingTemp + ccOriginalLength, L"*");
    hFind = ::FindFirstFileW(pwszWorkingTemp, pFindData);

    if (hFind != NULL) do
    {
        pwszWorkingTemp[ccOriginalLength] = UNICODE_NULL;
        
        if (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            wcscat(pwszWorkingTemp, pFindData->cFileName);

            if ((wcscmp(pFindData->cFileName, L".") == 0) ||
                (wcscmp(pFindData->cFileName, L"..") == 0))
                continue;

            if (!CabPathWorkerCallback(hCabinet, pwszWorkingTemp, cchTotalTemp, pwszBaseInCabinet, pFindData))
                goto Exit;
        }
        else
        {
            int i;
            INSTALLED_FILE *pFile = NULL;
            PWSTR pwszCursor = NULL;
            SIZE_T cchRequired;

            cchRequired = (cchBasePathLength + 1) + (wcslen(pFindData->cFileName) + 1);

            pFile = (INSTALLED_FILE*)s_Alloc(sizeof(INSTALLED_FILE) + (sizeof(WCHAR) * cchRequired));

            if (pFile == NULL)
                goto Exit;

            pwszCursor = (PWSTR)(pFile + 1);
            wcscpy(pwszCursor, pwszBaseInCabinet);
            pFile->pwszSubDir = pwszCursor;
            pwszCursor[cchBasePathLength] = UNICODE_NULL;

            pwszCursor += cchBasePathLength + 1;
            wcscpy(pwszCursor, pFindData->cFileName);
            pFile->pwszFileName = pwszCursor;

            InsertHeadList(&InstalledFiles, &pFile->Links);

            wcscat(pwszWorkingTemp, pFindData->cFileName);

            i = WideCharToMultiByte(
                CP_UTF8,
                0,
                pwszBaseInCabinet,
                -1,
                WorkingBufferTwo,
                sizeof(WorkingBufferTwo),
                NULL,
                NULL);

            if ((i == 0) || (i > sizeof(WorkingBufferTwo)))
                goto Exit;

            i = WideCharToMultiByte(
                CP_UTF8,
                0,
                pwszWorkingTemp,
                -1,
                WorkingBufferOne,
                sizeof(WorkingBufferOne),
                NULL,
                NULL);

            if ((i == 0) || (i > sizeof(WorkingBufferOne)))
                goto Exit;



            if (!FCIAddFile(
                hCabinet,
                WorkingBufferOne,
                WorkingBufferTwo,
                FALSE,
                s_GetNextCabinet,
                s_StatusCallback,
                s_GetOpenInfo,
                tcompTYPE_LZX | tcompLZX_WINDOW_HI))
            {
                goto Exit;
            }
        }
    }
    while (::FindNextFileW(hFind, pFindData));

    if (::GetLastError() != ERROR_NO_MORE_FILES)
        goto Exit;


    fResult = TRUE;
Exit:
    if (hFind != INVALID_HANDLE_VALUE)
        FindClose(hFind);

    pwszWorkingTemp[ccOriginalLength] = UNICODE_NULL;

    return fResult;
}


BOOL
WriteFormatted(
    INT_PTR File,
    PVOID pvContext,
    PCWSTR fmt,
    ...
    )
{
    static WCHAR wchDump[1024];
    va_list va;
    int iError;
    int iResult;

    va_start(va, fmt);
    iResult = _vsnwprintf(wchDump, NUMBER_OF(wchDump), fmt, va);
    va_end(va);

    if ((iResult >= 0) && (iResult < NUMBER_OF(wchDump)))
        wchDump[iResult] = UNICODE_NULL;
    else
        iResult = 0;

    return (s_WriteFile(File, wchDump, iResult * sizeof(WCHAR), &iError, pvContext) != -1);
}

BOOL
CreateCabFromPath(
    PCWSTR pcwszBasePath,
    FILE_HANDLE *CreatedCabinet,
    PCWSTR pcwszInfName
    )
{
    CHAR chCabName[] = "::::";
    ERF erf;
    FCI_CONTEXT_OBJECT Context = { false, 0, NULL, chCabName };
    const ULONG CabMaxSize = 0x04000000;
    CCAB CabInfo = { CabMaxSize, CabMaxSize };
    HFCI hCabinet = NULL;
    WIN32_FIND_DATAW FindData;
    BOOL fResult = FALSE;
    HANDLE hFindFile = INVALID_HANDLE_VALUE;
    static WCHAR wchBasePath[2048];
    int i = 0;

    InitializeListHead(&InstalledFiles);

    lstrcpyA(CabInfo.szDisk, "SxsExpressCompressedCabinet");
    lstrcpyA(CabInfo.szCab, "::");
    lstrcpyA(CabInfo.szCabPath, "::");

    wcscpy(wchBasePath, pcwszBasePath);

    //
    // Start off by creating a compression object
    //
    hCabinet = FCICreate(
        &erf,
        s_FilePlaced,
        s_Alloc,
        s_Free,
        s_OpenFile,
        s_ReadFile,
        s_WriteFile,
        s_Close,
        s_Seek,
        s_Delete,
        s_TempFile,
        &CabInfo,
        (void*)&Context);

    fResult = CabPathWorkerCallback(hCabinet, wchBasePath, NUMBER_OF(wchBasePath), wchBasePath + wcslen(wchBasePath), &FindData);

    if (!fResult)
    {
        printf("Error adding cabinet files, %d (code %d)\n", erf.erfOper, erf.erfType);
        goto Exit;
    }

    //
    // No name given?  Cons one up from the files found
    //
    if (pcwszInfName == NULL)
    {
        CHAR chTempFile[MAX_PATH];
        int iError;
        INT_PTR p;
        LIST_ENTRY *pLink;
        s_TempFile(chTempFile, NUMBER_OF(chTempFile), &Context);
        p = s_OpenFile(chTempFile, _O_CREAT, 0, &iError, &Context);
        WORD wBom = 0xfeff;

        //
        // This is a UCS-2 file.
        //
        s_WriteFile(p, &wBom, sizeof(wBom), &iError, &Context);

        //
        // Spit out the source and target paths
        //
        WriteFormatted(p, &Context, L"[FileEntries]\r\n");
        pLink = InstalledFiles.Flink;
        while (pLink && (pLink != &InstalledFiles))
        {
            INSTALLED_FILE *pFile = CONTAINING_RECORD(pLink, INSTALLED_FILE, Links);
            WriteFormatted(p, &Context, L"%ls\\%ls;<SysDir>\\%ls\r\n", pFile->pwszSubDir, pFile->pwszFileName, pFile->pwszFileName);
            pLink = pLink->Flink;
        }

        s_Close(p, &iError, &Context);

        strcpy(WorkingBufferOne, chTempFile);
    }
    else
    {
        i = WideCharToMultiByte(CP_UTF8, 0, pcwszInfName, -1, WorkingBufferOne, sizeof(WorkingBufferOne), NULL, NULL);
        if ((i == 0) || (i > sizeof(WorkingBufferOne)))
        {
            wprintf(L"Error converting INF file %ls name to UTF-8\r\n", pcwszInfName);
            goto Exit;
        }
    }

    fResult = FCIAddFile(
        hCabinet,
        WorkingBufferOne,
        INF_SPECIAL_NAME,
        FALSE,
        s_GetNextCabinet,
        s_StatusCallback,
        s_GetOpenInfo,
        tcompTYPE_LZX | tcompLZX_WINDOW_HI);

    FCIFlushFolder(hCabinet, s_GetNextCabinet, s_StatusCallback);
    FCIFlushCabinet(hCabinet, FALSE, s_GetNextCabinet, s_StatusCallback);

    fResult = TRUE;
Exit:
    if (hCabinet != NULL)
        FCIDestroy(hCabinet);

    *CreatedCabinet = *Context.CabinetFileHandle;

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxspad\precomp.h ===
#define WIN31
#include "sxspad.h"
#include <shellapi.h>
#include <cderr.h>
#include <winnlsp.h>   // for NORM_STOP_ON_NULL

#include <string.h>

//
// We need to define BYTE_ORDER_MARK, and figure
// out how to get the system to tell us a font is a
// unicode font, and then we can eliminate uconvert.h
//
#include <uconvert.h>
#include <uniconv.h>
#include <stdio.h>

#include <stdlib.h>

#include <ctype.h>
#include <time.h>
#include <winspool.h>
#include "dlgs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxspad\sxspadfile.c ===
/*
 * sxspadfile.c  - Routines for file i/o for sxspad
 *   Copyright (C) 1984-2000 Microsoft Inc.
 */

#include "precomp.h"


HANDLE  hFirstMem;
CHAR    BOM_UTF8[3]= {(BYTE) 0xEF, (BYTE) 0xBB, (BYTE)0xBF};



//****************************************************************
//
//   ReverseEndian
//
//   Purpose: copies unicode character from one endian source
//            to another.
//
//            may work on lpDst == lpSrc
//

VOID ReverseEndian( PTCHAR lpDst, PTCHAR lpSrc, DWORD nChars )
{
    DWORD  cnt;

    for( cnt=0; cnt < nChars; cnt++,lpDst++,lpSrc++ )
    {
        *lpDst= (TCHAR) (((*lpSrc<<8) & 0xFF00) + ((*lpSrc>>8)&0xFF));
    }
}

//*****************************************************************
//
//   AnsiWriteFile()
//
//   Purpose     : To simulate the effects of _lwrite() in a Unicode
//                 environment by converting to ANSI buffer and
//                 writing out the ANSI text.
//   Returns     : TRUE is successful, FALSE if not
//                 GetLastError() will have the error code.
//
//*****************************************************************

BOOL AnsiWriteFile(HANDLE  hFile,    // file to write to
                   UINT uCodePage,   // code page to convert unicode to
                   LPVOID lpBuffer,  // unicode buffer
                   DWORD nChars,     // number of unicode chars
                   DWORD nBytes )    // number of ascii chars to produce
{
    LPSTR   lpAnsi;              // pointer to allocate buffer
    BOOL    Done;                // status from write (returned)
    BOOL    fDefCharUsed;        // flag that conversion wasn't perfect
    BOOL*   pfDefCharUsed;       // pointer to flag
    DWORD   nBytesWritten;       // number of bytes written

    lpAnsi= (LPSTR) LocalAlloc( LPTR, nBytes + 1 );
    if( !lpAnsi )
    {
       SetLastError( ERROR_NOT_ENOUGH_MEMORY );
       return (FALSE);
    }

    pfDefCharUsed= NULL;
    if( (uCodePage != CP_UTF8 ) && (uCodePage != CP_UTF7) )
    {
        pfDefCharUsed= &fDefCharUsed;
    }
    WideCharToMultiByte( uCodePage,       // code page
                         0,               // performance and mapping flags
                        (LPWSTR) lpBuffer,// wide char buffer
                         nChars,          // chars in wide char buffer
                         lpAnsi,          // resultant ascii string
                         nBytes,          // size of ascii string buffer
                         NULL,            // char to sub. for unmapped chars
                         pfDefCharUsed);  // flag to set if default char used


    Done= WriteFile( hFile, lpAnsi, nBytes, &nBytesWritten, NULL );

    LocalFree( lpAnsi );

    return (Done);

} // end of AnsiWriteFile()

#define NOTUSED 0
static DWORD dwStartSel;    // saved start of selection
static DWORD dwEndSel;      // saved end of selection

VOID ClearFmt(VOID)
{
    DWORD SelStart;
    DWORD SelEnd;

    SendMessage( hwndEdit, EM_GETSEL, (WPARAM) &dwStartSel, (LPARAM) &dwEndSel );

    SendMessage( hwndEdit, EM_SETSEL, (WPARAM) 0, (LPARAM) 0 );   // this is always legal
    // should we scrollcaret here?

    SendMessage( hwndEdit, EM_FMTLINES, (WPARAM)FALSE, NOTUSED );   // remove soft EOLs

}

VOID RestoreFmt(VOID)
{
    UINT CharIndex;

    SendMessage( hwndEdit, EM_FMTLINES, (WPARAM)TRUE, NOTUSED );    // restore soft EOLS

    CharIndex= (UINT) SendMessage( hwndEdit, EM_SETSEL, (WPARAM) dwStartSel, (LPARAM) dwEndSel);

}

/* Save sxspad file to disk.  szFileSave points to filename.  fSaveAs
   is TRUE iff we are being called from SaveAsDlgProc.  This implies we must
   open file on current directory, whether or not it already exists there
   or somewhere else in our search path.
   Assumes that text exists within hwndEdit.    30 July 1991  Clark Cyr
 */

BOOL FAR SaveFile (HWND hwndParent, TCHAR *szFileSave, BOOL fSaveAs )
{
  LPTSTR    lpch;
  UINT      nChars;
  BOOL      flag;
  BOOL      fNew = FALSE;
  BOOL      fDefCharUsed = FALSE;
  BOOL*     pfDefCharUsed;
  static    WCHAR wchBOM = BYTE_ORDER_MARK;
  static    WCHAR wchRBOM= REVERSE_BYTE_ORDER_MARK;
  HLOCAL    hEText;                // handle to MLE text
  DWORD     nBytesWritten;         // number of bytes written
  DWORD     nAsciiLength;          // length of equivalent ascii file
  UINT      cpTemp= CP_ACP;        // code page to convert to


    /* If saving to an existing file, make sure correct disk is in drive */
    if (!fSaveAs)
    {
       fp= CreateFile( szFileSave,                 // name of file
                       GENERIC_READ|GENERIC_WRITE, // access mode
                       FILE_SHARE_READ,            // share mode
                       NULL,                       // security descriptor
                       OPEN_EXISTING,              // how to create
                       FILE_ATTRIBUTE_NORMAL,      // file attributes
                       NULL);                      // hnd of file with attrs
    }
    else
    {

       // Carefully open the file.  Do not truncate it if it exists.
       // set the fNew flag if it had to be created.
       // We do all this in case of failures later in the process.

       fp= CreateFile( szFileSave,                 // name of file
                       GENERIC_READ|GENERIC_WRITE, // access mode
                       FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                       NULL,                       // security descriptor
                       OPEN_ALWAYS,                // how to create
                       FILE_ATTRIBUTE_NORMAL,      // file attributes
                       NULL);                      // hnd of file with attrs

       if( fp != INVALID_HANDLE_VALUE )
       {
          fNew= (GetLastError() != ERROR_ALREADY_EXISTS );
       }
    }

    if( fp == INVALID_HANDLE_VALUE )
    {
        if (fSaveAs)
          AlertBox( hwndParent, szNN, szCREATEERR, szFileSave,
                    MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }


    // if wordwrap, remove soft carriage returns
    // Also move the cursor to a safe place to get around MLE bugs

    if( fWrap )
    {
       ClearFmt();
    }

    /* Must get text length after formatting */
    nChars = (UINT)SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, (LPARAM)0);

    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0,0 );
    if(  !hEText || !(lpch= (LPTSTR) LocalLock(hEText) ))
    {
       AlertUser_FileFail( szFileSave );
       goto CleanUp;
    }




    // Determine the SaveAs file type, and write the appropriate BOM.
    // If the filetype is UTF-8 or Ansi, do the conversion.
    switch(g_ftSaveAs)
    {
    case FT_UNICODE:
        WriteFile( fp, &wchBOM, ByteCountOf(1), &nBytesWritten, NULL );
        flag= WriteFile(fp, lpch, ByteCountOf(nChars), &nBytesWritten, NULL);
        break;

    case FT_UNICODEBE:
        WriteFile( fp, &wchRBOM, ByteCountOf(1), &nBytesWritten, NULL );
        ReverseEndian( lpch, lpch,nChars );
        flag= WriteFile(fp, lpch, ByteCountOf(nChars), &nBytesWritten, NULL);
        ReverseEndian( lpch, lpch, nChars );
        break;

    // If it UTF-8, write the BOM (3 bytes), set the code page and fall
    // through to the default case.
    case FT_UTF8:
        WriteFile( fp, &BOM_UTF8, 3, &nBytesWritten, NULL );
        cpTemp= CP_UTF8;
        // fall through to convert and write the file

    default:
        pfDefCharUsed= NULL;


        if (g_ftSaveAs != FT_UTF8)
        {
            //
            // Always use the current locale code page to do the translation
            // If the user changes locales, they will need to know what locale
            // this version of the file was saved with.  Since we don't save that
            // information, the user may be backed into a corner.  Unicode would
            // save his bacon.
            //

            cpTemp= GetACP();

            pfDefCharUsed= &fDefCharUsed;
        }

        nAsciiLength= WideCharToMultiByte( cpTemp,
                                           0,
                                           (LPWSTR)lpch,
                                           nChars,
                                           NULL,
                                           0,
                                           NULL,
                                           pfDefCharUsed);


        if( fDefCharUsed )
        {
            if ( AlertBox( hwndParent, szNN, szErrUnicode, szFileSave,
                  MB_APPLMODAL|MB_OKCANCEL|MB_ICONEXCLAMATION) == IDCANCEL)
               goto CleanUp;
        }
        flag= AnsiWriteFile( fp, cpTemp, lpch, nChars, nAsciiLength );
        break;
    }


    if (!flag)
    {
       SetCursor(hStdCursor);     /* display normal cursor */

       AlertUser_FileFail( szFileSave );
CleanUp:
       SetCursor( hStdCursor );
       CloseHandle (fp); fp=INVALID_HANDLE_VALUE;
       if( hEText )
           LocalUnlock( hEText );
       if (fNew)
          DeleteFile (szFileSave);
       /* if wordwrap, insert soft carriage returns */
       if (fWrap)
       {
           RestoreFmt();
       }
       return FALSE;
    }
    else
    {
       SetEndOfFile (fp);

       SendMessage (hwndEdit, EM_SETMODIFY, FALSE, 0L);
       SetTitle (szFileSave);
       fUntitled = FALSE;
    }

    CloseHandle (fp); fp=INVALID_HANDLE_VALUE;

    if( hEText )
        LocalUnlock( hEText );

    /* if wordwrap, insert soft carriage returns */
    if (fWrap)
    {
       RestoreFmt();
    }

    /* Display the hour glass cursor */
    SetCursor(hStdCursor);

    return TRUE;

} // end of SaveFile()

/* Read contents of file from disk.
 * Do any conversions required.
 * File is already open, referenced by handle fp
 * Close the file when done.
 * If typeFlag>=0, then use it as filetype, otherwise do automagic guessing.
 */

BOOL FAR LoadFile (TCHAR * sz, INT typeFlag )
{
    UINT      len, i, nChars;
    LPTSTR    lpch=NULL;
    LPTSTR    lpBuf;
    LPSTR     lpBufAfterBOM;
    BOOL      fLog=FALSE;
    TCHAR*    p;
    TCHAR     szSave[MAX_PATH]; /* Private copy of current filename */
    BOOL      bUnicode=FALSE;   /* true if file detected as unicode */
    BOOL      bUTF8=FALSE;      /* true if file detected as UTF-8 */
    DWORD     nBytesRead;       // number of bytes read
    BY_HANDLE_FILE_INFORMATION fiFileInfo;
    BOOL      bStatus;          // boolean status
    HLOCAL    hNewEdit=NULL;    // new handle for edit buffer
    HANDLE    hMap;             // file mapping handle
    TCHAR     szNullFile[2];    // fake null mapped file
    INT       cpTemp = CP_ACP;
    SP_FILETYPE ftOpenedAs=FT_UNKNOWN;


    if( fp == INVALID_HANDLE_VALUE )
    {
       AlertUser_FileFail( sz );
       return (FALSE);
    }

    //
    // Get size of file
    // We use this heavy duty GetFileInformationByHandle API
    // because it finds bugs.  It takes longer, but it only is
    // called at user interaction time.
    //

    bStatus= GetFileInformationByHandle( fp, &fiFileInfo );
    len= (UINT) fiFileInfo.nFileSizeLow;

    // NT may delay giving this status until the file is accessed.
    // i.e. the open succeeds, but operations may fail on damaged files.

    if( !bStatus )
    {
        AlertUser_FileFail( sz );
        CloseHandle( fp ); fp=INVALID_HANDLE_VALUE;
        return( FALSE );
    }

    // If the file is too big, fail now.
    // -1 not valid because we need a zero on the end.

    if( len == -1 || fiFileInfo.nFileSizeHigh != 0 )
    {
       AlertBox( hwndSP, szNN, szErrSpace, sz,
                 MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION );
       CloseHandle (fp); fp=INVALID_HANDLE_VALUE;
       return (FALSE);
    }

    SetCursor(hWaitCursor);                // physical I/O takes time

    //
    // Create a file mapping so we don't page the file to
    // the pagefile.  This is a big win on small ram machines.
    //

    if( len != 0 )
    {
        lpBuf= NULL;

        hMap= CreateFileMapping( fp, NULL, PAGE_READONLY, 0, len, NULL );

        if( hMap )
        {
            lpBuf= MapViewOfFile( hMap, FILE_MAP_READ, 0,0,len);
            CloseHandle( hMap );
        }
    }
    else  // file mapping doesn't work on zero length files
    {
        lpBuf= (LPTSTR) &szNullFile;
        *lpBuf= 0;  // null terminate
    }

    CloseHandle( fp ); fp=INVALID_HANDLE_VALUE;

    if( lpBuf == NULL )
    {
        SetCursor( hStdCursor );
        AlertBox( hwndSP, szNN, szErrSpace, sz,
                  MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION );
        return( FALSE );
    }


    //
    // protect access to the mapped file with a try/except so we
    // can detect I/O errors.
    //

    //
    // WARNING: be very very careful.  This code is pretty fragile.
    // Files across the network, or RSM files (tape) may throw excepts
    // at random points in this code.  Anywhere the code touches the
    // memory mapped file can cause an AV.  Make sure variables are
    // in consistent state if an exception is thrown.  Be very careful
    // with globals.

    __try
    {
    /* Determine the file type and number of characters
     * If the user overrides, use what is specified.
     * Otherwise, we depend on 'IsTextUnicode' getting it right.
     * If it doesn't, bug IsTextUnicode.
     */

    lpBufAfterBOM= (LPSTR) lpBuf;
    if( typeFlag == FT_UNKNOWN )
    {
        switch(*lpBuf)
        {
        case BYTE_ORDER_MARK:
            bUnicode= TRUE;
            ftOpenedAs= FT_UNICODE;

            // don't count the BOM.
            nChars= len / sizeof(TCHAR) -1;
            break;

        case REVERSE_BYTE_ORDER_MARK:
            bUnicode= TRUE;
            ftOpenedAs= FT_UNICODEBE;

            // don't count the BOM.
            nChars= len / sizeof(TCHAR) -1;
            break;

        // UTF bom has 3 bytes; if it doesn't have UTF BOM just fall through ..
        case BOM_UTF8_HALF:
            if (len > 2 && ((BYTE) *(((LPSTR)lpBuf)+2) == BOM_UTF8_2HALF) )
            {
                bUTF8= TRUE;
                cpTemp= CP_UTF8;
                ftOpenedAs= FT_UTF8;
                // Ignore the first three bytes.
                lpBufAfterBOM= (LPSTR)lpBuf + 3;
                len -= 3;
                break;
            }

        default:

            // Is the file unicode without BOM ?
            if ((bUnicode= IsInputTextUnicode((LPSTR) lpBuf, len)))
            {
                ftOpenedAs= FT_UNICODE;
                nChars= len / sizeof(TCHAR);
            }
            else
            {
                // Is the file UTF-8 even though it doesn't have UTF-8 BOM.
                if ((bUTF8= IsTextUTF8((LPSTR) lpBuf, len)))
                {
                    ftOpenedAs= FT_UTF8;
                    cpTemp= CP_UTF8;
                }
                // well, not it must be an ansi file!
                else
                {
                    ftOpenedAs= FT_ANSI;
                    cpTemp= CP_ACP;
                }
            }
            break;
        }
    }

    // find out no. of chars present in the string.
    if (!bUnicode)
    {
        nChars = MultiByteToWideChar (cpTemp,
                                      0,
                                      (LPSTR)lpBufAfterBOM,
                                      len,
                                      NULL,
                                      0);
    }

    //
    // Don't display text until all done.
    //

    SendMessage (hwndEdit, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM)0);

    // Reset selection to 0

    SendMessage(hwndEdit, EM_SETSEL, 0, 0L);
    SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);

    // resize the edit buffer
    // if we can't resize the memory, inform the user

    if (!(hNewEdit= LocalReAlloc(hEdit,ByteCountOf(nChars + 1),LMEM_MOVEABLE)))
    {
      /* Bug 7441: New() causes szFileName to be set to "Untitled".  Save a
       *           copy of the filename to pass to AlertBox.
       *  17 November 1991    Clark R. Cyr
       */
       lstrcpy(szSave, sz);
       New(FALSE);

       /* Display the hour glass cursor */
       SetCursor(hStdCursor);

       AlertBox( hwndSP, szNN, szFTL, szSave,
                 MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
       if( lpBuf != (LPTSTR) &szNullFile )
       {
           UnmapViewOfFile( lpBuf );
       }

       // let user see old text

       SendMessage (hwndEdit, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM)0);
       return FALSE;
    }

    /* Transfer file from temporary buffer to the edit buffer */
    lpch= (LPTSTR) LocalLock(hNewEdit);

    if( bUnicode )
    {
       /* skip the Byte Order Mark */
       if (*lpBuf == BYTE_ORDER_MARK)
       {
          CopyMemory (lpch, lpBuf + 1, ByteCountOf(nChars));
       }
       else if( *lpBuf == REVERSE_BYTE_ORDER_MARK )
       {
          ReverseEndian( lpch, lpBuf+1, nChars );
       }
       else
       {
          CopyMemory (lpch, lpBuf, ByteCountOf(nChars));
       }
    }
    else
    {
       nChars = MultiByteToWideChar (cpTemp,
                                     0,
                                     (LPSTR)lpBufAfterBOM,
                                     len,
                                     (LPWSTR)lpch,
                                     nChars);

    }

    g_ftOpenedAs= ftOpenedAs;   // got everything; update global safe now

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AlertBox( hwndSP, szNN, szDiskError, sz,
            MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION );
        nChars= 0;   // don't deal with it.
    }

    /* Free file mapping */
    if( lpBuf != (LPTSTR) &szNullFile )
    {
        UnmapViewOfFile( lpBuf );
    }


    if( lpch )
    {

       // Fix any NUL character that came in from the file to be spaces.

       for (i = 0, p = lpch; i < nChars; i++, p++)
       {
          if( *p == (TCHAR) 0 )
             *p= TEXT(' ');
       }

       // null terminate it.  Safe even if nChars==0 because it is 1 TCHAR bigger

       *(lpch+nChars)= (TCHAR) 0;      /* zero terminate the thing */

       // Set 'fLog' if first characters in file are ".LOG"

       fLog= *lpch++ == TEXT('.') && *lpch++ == TEXT('L') &&
             *lpch++ == TEXT('O') && *lpch == TEXT('G');
    }

    if( hNewEdit )
    {
       LocalUnlock( hNewEdit );

       // now it is safe to set the global edit handle

       hEdit= hNewEdit;
    }

    lstrcpy( szFileName, sz );
    SetTitle( sz );
    fUntitled= FALSE;

  /* Pass handle to edit control.  This is more efficient than WM_SETTEXT
   * which would require twice the buffer space.
   */

  /* Bug 7443: If EM_SETHANDLE doesn't have enough memory to complete things,
   * it will send the EN_ERRSPACE message.  If this happens, don't put up the
   * out of memory notification, put up the file to large message instead.
   *  17 November 1991     Clark R. Cyr
   */
    dwEmSetHandle = SETHANDLEINPROGRESS;
    SendMessage (hwndEdit, EM_SETHANDLE, (WPARAM)hEdit, (LPARAM)0);
    if (dwEmSetHandle == SETHANDLEFAILED)
    {
       SetCursor(hStdCursor);

       dwEmSetHandle = 0;
       AlertBox( hwndSP, szNN, szFTL, sz,MB_APPLMODAL|MB_OK|MB_ICONEXCLAMATION);
       New (FALSE);
       SendMessage (hwndEdit, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0);
       return (FALSE);
    }
    dwEmSetHandle = 0;

    PostMessage (hwndEdit, EM_LIMITTEXT, (WPARAM)CCHSPMAX, 0L);

    /* If file starts with ".LOG" go to end and stamp date time */
    if (fLog)
    {
       SendMessage( hwndEdit, EM_SETSEL, (WPARAM)nChars, (LPARAM)nChars);
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0);
       InsertDateTime(TRUE);
    }

    /* Move vertical thumb to correct position */
    SetScrollPos (hwndSP,
                  SB_VERT,
                  (int) SendMessage (hwndEdit, WM_VSCROLL, EM_GETTHUMB, 0L),
                  TRUE);

    /* Now display text */
    SendMessage( hwndEdit, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0 );
    InvalidateRect( hwndEdit, (LPRECT)NULL, TRUE );
    UpdateWindow( hwndEdit );

    SetCursor(hStdCursor);

    return( TRUE );

} // end of LoadFile()

/* New Command - reset everything
 */

void FAR New (BOOL  fCheck)
{
    HANDLE hTemp;
    TCHAR* pSz;

    if (!fCheck || CheckSave (FALSE))
    {
       SendMessage( hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)TEXT("") );
       fUntitled= TRUE;
       lstrcpy( szFileName, szUntitled );
       SetTitle(szFileName );
       SendMessage( hwndEdit, EM_SETSEL, 0, 0L );
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );

       // resize of 1 NULL character i.e. zero length

       hTemp= LocalReAlloc( hEdit, sizeof(TCHAR), LMEM_MOVEABLE );
       if( hTemp )
       {
          hEdit= hTemp;
       }

       // null terminate the buffer.  LocalReAlloc won't do it
       // because in all cases it is not growing which is the
       // only time it would zero out anything.

       pSz= LocalLock( hEdit );
       *pSz= TEXT('\0');
       LocalUnlock( hEdit );

       SendMessage (hwndEdit, EM_SETHANDLE, (WPARAM)hEdit, 0L);
       szSearch[0] = (TCHAR) 0;
    }

} // end of New()

/* If sz does not have extension, append ".Manifest"
 * This function is useful for getting to undecorated filenames
 * that setup apps use.  DO NOT CHANGE the extension.  Too many setup
 * apps depend on this functionality.
 */

void FAR AddExt( TCHAR* sz )
{
    TCHAR*   pch1;
    int      ch;
    DWORD    dwSize;

    dwSize= lstrlen(sz);

    pch1= sz + dwSize;   // point to end

    ch= *pch1;
    while( ch != TEXT('.') && ch != TEXT('\\') && ch != TEXT(':') && pch1 > sz)
    {
        //
        // backup one character.  Do NOT use CharPrev because
        // it sometimes doesn't actually backup.  Some Thai
        // tone marks fit this category but there seems to be others.
        // This is safe since it will stop at the beginning of the
        // string or on delimiters listed above.  bug# 139374 2/13/98
        //
        // pch1= (TCHAR*)CharPrev (sz, pch1);
        pch1--;  // back up
        ch= *pch1;
    }

    if( *pch1 != TEXT('.') )
    {
       if( dwSize + sizeof(".Manifest") <= MAX_PATH ) {  // avoid buffer overruns
           lstrcat( sz, TEXT(".Manifest") );
       }
    }

}


/* AlertUser_FileFail( LPTSTR szFileName )
 *
 * szFileName is the name of file that was attempted to open.
 * Some sort of failure on file open.  Alert the user
 * with some monologue box.  At least give him decent
 * error messages.
 */

VOID FAR AlertUser_FileFail( LPTSTR szFileName )
{
    TCHAR msg[256];     // buffer to format message into
    DWORD dwStatus;     // status from FormatMessage
    UINT  style= MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION;

    // Check GetLastError to see why we failed
    dwStatus=
    FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   GetLastError(),
                   GetUserDefaultLangID(),
                   msg,  // where message will end up
                   CharSizeOf(msg), NULL );
    if( dwStatus )
    {
          MessageBox( hwndSP, msg, szNN, style );
    }
    else
    {
        AlertBox( hwndSP, szNN, szDiskError, szFileName, style );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxspad\sxspad.c ===
/*
 *   SxSpad application
 *   Copyright (C) 1984-1995 Microsoft Inc.
 */


#include "precomp.h"
#include <htmlhelp.h>

#define DeepTrouble() MessageBox(hwndSP, szErrSpace, szNN, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND);

UINT     lGotoLine;                  /* line number to goto to */

TCHAR    chMerge;
HWND     hwndSP = 0;                 /* handle to sxspad parent window   */
HWND     hwndEdit = 0;               /* handle to main text control item  */
HANDLE   hEdit;                      /* Handle to storage for edit item   */
HWND     hDlgFind = NULL;            /* handle to modeless FindText window */
HANDLE   hStdCursor;                 /* handle to arrow or beam cursor    */
HANDLE   hWaitCursor;                /* handle to hour glass cursor       */
HANDLE   hInstanceSP;                /* Module instance handle            */
HANDLE   hFont;                      /* handle to Unicode font            */
LOGFONT  FontStruct;                 /* font dialog structure             */
INT      iPointSize=120;             /* current point size unit=1/10 pts  */
TCHAR    szFileName[MAX_PATH+1];     /* Current sxspad filename           */
TCHAR    szSearch[CCHKEYMAX];        /* Search string                     */
TCHAR    szReplace[CCHKEYMAX];       /* replace string                    */

BOOL     fUntitled = TRUE;           /* TRUE if sxspad has no title       */

HMENU hSysMenuSetup;                 /* Save Away for disabled Minimize   */

DWORD     dwEmSetHandle = 0;         /* Is EM_SETHANDLE in process?       */
HANDLE   hAccel;                     /* Handle to accelerator table       */
BOOL     fRunBySetup = FALSE;        /* Did SlipUp WinExec us??           */
BOOL     fWrap = 0;                  /* Flag for word wrap                */
TCHAR    szSxspad[] = TEXT("Sxspad");/* Name of sxspad window class       */

BOOL fInSaveAsDlg = FALSE;

/* variables for the new File/Open, File/Saveas,Find Text and Print dialogs */
OPENFILENAME OFN;                     /* passed to the File Open/save APIs */
TCHAR szOpenFilterSpec[CCHFILTERMAX]; /* default open filter spec          */
TCHAR szSaveFilterSpec[CCHFILTERMAX]; /* default save filter spec          */
SP_FILETYPE g_ftOpenedAs=FT_UNKNOWN;  /* current file was opened           */
SP_FILETYPE g_ftSaveAs;               /* current file was opened           */

FINDREPLACE FR;                       /* Passed to FindText()              */
PAGESETUPDLG g_PageSetupDlg;
UINT wFRMsg;                          /* message used in communicating     */
                                      /* with Find/Replace dialog          */

DWORD dwCurrentSelectionStart = 0L;      /* WM_ACTIVATEAPP selection pos */
DWORD dwCurrentSelectionEnd   = 0L;      /* WM_ACTIVATEAPP selection pos */
UINT wHlpMsg;                        /* message used in invoking help     */

/* Strings loaded from resource file passed to LoadString at initialization time */
/* To add resource string:
 * 1) create IDS_ macro definition in sxspad.h
 * 2) create string in resource file
 * 3) create 'TCHAR*' variable directly below and in sxspad.h file
 * 4) add &variable to rgsz
 * 5) increment CSTRINGS
 */
TCHAR *szDiskError =(TCHAR *)IDS_DISKERROR;  /* Can't open File, check disk  */
TCHAR *szFNF       =(TCHAR *)IDS_FNF;        /* File not found               */
TCHAR *szSCBC      =(TCHAR *)IDS_SCBC;       /* Save changes before closing? */
TCHAR *szUntitled  =(TCHAR *)IDS_UNTITLED;   /* Untitled                     */
TCHAR *szNpTitle   =(TCHAR *)IDS_SXSPAD;     /* Sxspad -                     */
TCHAR *szCFS       =(TCHAR *)IDS_CFS;        /* Can't find string            */
TCHAR *szErrSpace  =(TCHAR *)IDS_ERRSPACE;   /* Memory space exhausted       */
TCHAR *szFTL       =(TCHAR *)IDS_FTL;        /* File too large for sxspad    */
TCHAR *szNN        =(TCHAR *)IDS_NN;         /* sxspad name                  */

TCHAR *szCommDlgInitErr = (TCHAR*)IDS_COMMDLGINIT; /* common dialog error %x */
TCHAR *szPDIE      =(TCHAR*) IDS_PRINTDLGINIT; /* Print dialog init error    */
TCHAR *szCP        =(TCHAR*) IDS_CANTPRINT;  /* Can't print                  */
TCHAR *szNVF       =(TCHAR*) IDS_NVF;        /* Not a valid filename.        */
TCHAR *szCREATEERR =(TCHAR*) IDS_CREATEERR;  /* cannot create file           */
TCHAR *szNoWW      =(TCHAR*) IDS_NOWW;       /* Too much text to word wrap   */
TCHAR *szMerge     =(TCHAR*) IDS_MERGE1;     /* search string for merge      */
TCHAR *szHelpFile  =(TCHAR*) IDS_HELPFILE;   /* Name of helpfile.            */
TCHAR *szHeader    =(TCHAR*) IDS_HEADER;
TCHAR *szFooter    =(TCHAR*) IDS_FOOTER;

TCHAR *szAnsiText    = (TCHAR*)IDS_ANSITEXT; /* File/Open ANSI filter spec. string */
TCHAR *szAllFiles    = (TCHAR*)IDS_ALLFILES;   /* File/Open Filter spec. string */
TCHAR *szOpenCaption = (TCHAR*)IDS_OPENCAPTION; /* caption for File/Open dlg */
TCHAR *szSaveCaption = (TCHAR*)IDS_SAVECAPTION; /* caption for File/Save dlg */
TCHAR *szCannotQuit  = (TCHAR*)IDS_CANNOTQUIT;  /* cannot quit during a WM_QUERYENDSESSION */
TCHAR *szLoadDrvFail = (TCHAR*)IDS_LOADDRVFAIL;  /* LOADDRVFAIL from PrintDlg */
TCHAR *szACCESSDENY  = (TCHAR*)IDS_ACCESSDENY; /* Access denied on Open */
TCHAR *szErrUnicode  = (TCHAR*)IDS_ERRUNICODE;  /* Unicode character existence error */
TCHAR *szFontTooBig  = (TCHAR*)IDS_FONTTOOBIG; /* font too big or page too small */

TCHAR *szCommDlgErr   = (TCHAR*) IDS_COMMDLGERR; /* common dialog error %x */
TCHAR *szLineError    = (TCHAR*) IDS_LINEERROR;   /* line number error        */
TCHAR *szLineTooLarge = (TCHAR*) IDS_LINETOOLARGE;/* line number out of range */
TCHAR *szFtAnsi       = (TCHAR*) IDS_FT_ANSI;
TCHAR *szFtUnicode    = (TCHAR*) IDS_FT_UNICODE;
TCHAR *szFtUnicodeBe  = (TCHAR*) IDS_FT_UNICODEBE;
TCHAR *szFtUtf8       = (TCHAR*) IDS_FT_UTF8;
TCHAR *szCurrentPage  = (TCHAR*) IDS_CURRENT_PAGE;

TCHAR **rgsz[CSTRINGS] = {
        &szDiskError,
        &szFNF,
        &szSCBC,
        &szUntitled,
        &szErrSpace,
        &szCFS,
        &szNpTitle,
        &szFTL,
        &szNN,
        &szCommDlgInitErr,
        &szPDIE,
        &szCP,
        &szNVF,
        &szCREATEERR,
        &szNoWW,
        &szMerge,
        &szHelpFile,
        &szAnsiText,
        &szAllFiles,
        &szOpenCaption,
        &szSaveCaption,
        &szCannotQuit,
        &szLoadDrvFail,
        &szACCESSDENY,
        &szErrUnicode,
        &szCommDlgErr,
        &szFontTooBig,
        &szLineError,
        &szLineTooLarge,
        &szFtAnsi,
        &szFtUnicode,
        &szFtUnicodeBe,
        &szFtUtf8,
        &szCurrentPage,
        &szHeader,
        &szFooter,
};


HANDLE   fp;          /* file pointer */

static TCHAR  szPath[MAX_PATH];

void FileDragOpen(void);
VOID NpResetMenu(HWND hWnd);
BOOL SignalCommDlgError(VOID);
VOID ReplaceSel( BOOL bView );

/* FreeGlobal, frees  all global memory allocated. */

void NEAR PASCAL FreeGlobal()
{
    if(g_PageSetupDlg.hDevMode)
    {
        GlobalFree(g_PageSetupDlg.hDevMode);
    }

    if(g_PageSetupDlg.hDevNames)
    {
        GlobalFree(g_PageSetupDlg.hDevNames);
    }

    g_PageSetupDlg.hDevMode=  NULL; // make sure they are zero for PrintDlg
    g_PageSetupDlg.hDevNames= NULL;
}

VOID PASCAL SetPageSetupDefaults( VOID )
{
    TCHAR szIMeasure[ 2 ];

    g_PageSetupDlg.lpfnPageSetupHook= PageSetupHookProc;
    g_PageSetupDlg.lpPageSetupTemplateName= MAKEINTRESOURCE(IDD_PAGESETUP);

    GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_IMEASURE, szIMeasure, 2 );

    g_PageSetupDlg.Flags= PSD_MARGINS  |
            PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGESETUPTEMPLATE;

    if (szIMeasure[ 0 ] == TEXT( '1' ))
    {
        //  English measure (in thousandths of inches).
        g_PageSetupDlg.Flags |= PSD_INTHOUSANDTHSOFINCHES;
        g_PageSetupDlg.rtMargin.top    = 1000;
        g_PageSetupDlg.rtMargin.bottom = 1000;
        g_PageSetupDlg.rtMargin.left   = 750;
        g_PageSetupDlg.rtMargin.right  = 750;
    }
    else
    {
        //  Metric measure (in hundreths of millimeters).
        g_PageSetupDlg.Flags |= PSD_INHUNDREDTHSOFMILLIMETERS;
        g_PageSetupDlg.rtMargin.top    = 2500;
        g_PageSetupDlg.rtMargin.bottom = 2500;
        g_PageSetupDlg.rtMargin.left   = 2000;
        g_PageSetupDlg.rtMargin.right  = 2000;
    }

}

/* Standard window size proc */
void SPSize (int cxNew, int cyNew)
{
    /* Invalidate the edit control window so that it is redrawn with the new
     * margins. Needed when comming up from iconic and when doing word wrap so
     * the new margins are accounted for.
     */
    InvalidateRect(hwndEdit, (LPRECT)NULL, TRUE);
    MoveWindow( hwndEdit, 0, 0, cxNew, cyNew, TRUE );
}

// NpSaveDialogHookProc
//
// Common dialog hook procedure for handling
// the file type while saving.
//

const DWORD s_SaveAsHelpIDs[]=
    {
        IDC_FILETYPE, IDH_FILETYPE,
        IDC_ENCODING, IDH_FILETYPE,
        0, 0
    };

UINT_PTR APIENTRY NpSaveDialogHookProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    INT id;
    POINT pt;
    TCHAR* szSelect;        // selected type

    switch( msg )
    {
        case WM_INITDIALOG:
            // Warning: the order here must be the same as SP_FILETYPE

            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtAnsi );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUnicode );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUnicodeBe );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUtf8 );

            szSelect= szFtAnsi;         // default
            g_ftSaveAs= g_ftOpenedAs;   // default: save as same type as opened
            switch( g_ftSaveAs )
            {
                case FT_UNICODE:   szSelect= szFtUnicode;   break;
                case FT_UNICODEBE: szSelect= szFtUnicodeBe; break;
                case FT_UTF8:      szSelect= szFtUtf8;      break;
                default: break;
            }

            SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)szSelect );
            break;

        case WM_COMMAND:
            g_ftSaveAs= (SP_FILETYPE) SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_GETCURSEL, 0, 0 );
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if ( id != IDC_FILETYPE && id != IDC_ENCODING)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle,
                      szHelpFile,
                      HELP_WM_HELP,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hWnd == (HWND) wParam )
            {
                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hWnd, pt);
            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if ( id != IDC_FILETYPE && id != IDC_ENCODING)
                break;

            WinHelp( (HWND)   wParam,
                              szHelpFile,
                              HELP_CONTEXTMENU,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;
    }
    return( FALSE );
}
/* ** Sxspad command proc - called whenever sxspad gets WM_COMMAND
      message.  wParam passed as cmd */
INT SPCommand(
    HWND     hwnd,
    WPARAM   wParam,
    LPARAM   lParam )
{
    HWND     hwndFocus;
    LONG     lSel;
    TCHAR    szNewName[MAX_PATH] = TEXT("");      /* New file name */
    FARPROC  lpfn;
    LONG     style;
    DWORD    rc;

    switch (LOWORD(wParam))
    {
        case M_EXIT:
            PostMessage(hwnd, WM_CLOSE, 0, 0L);
            break;

        case M_NEW:
            New(TRUE);
            break;

        case M_OPEN:
            if (CheckSave(FALSE))
            {
                /* set up the variable fields of the OPENFILENAME struct.
                 * (the constant fields have been set in SPInit()
                 */
                OFN.lpstrFile         = szNewName;
                lstrcpy(szNewName, TEXT("*.txt") ); /* set default selection */
                OFN.lpstrTitle        = szOpenCaption;

                /* ALL non-zero long pointers must be defined immediately
                 * before the call, as the DS might move otherwise.
                 * 12 February 1991    clarkc
                 */
                OFN.lpstrFilter       = szOpenFilterSpec;
                OFN.lpstrDefExt       = TEXT("txt");
                /* Added OFN_FILEMUSTEXIST to eliminate problems in LoadFile.
                 * 12 February 1991    clarkc
                 */
                OFN.Flags          = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
                OFN.nFilterIndex   = FILE_TEXT;
                OFN.lpTemplateName = NULL;
                OFN.lpfnHook       = NULL;

                if( GetOpenFileName( (LPOPENFILENAME)&OFN ) )
                {
                   HANDLE oldfp= fp;

                   fp= CreateFile( szNewName,            // filename
                                   GENERIC_READ,         // access mode
                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                   NULL,                 // security descriptor
                                   OPEN_EXISTING,        // how to create
                                   FILE_ATTRIBUTE_NORMAL,// file attributes
                                   NULL);                // hnd to file attrs
                   /* Try to load the file and reset fp if failed */
                   if( !LoadFile( szNewName, FT_UNKNOWN ) )
                   {
                      fp= oldfp;
                   }
                }
                else
                {
                    SignalCommDlgError();
                }
            }
            break;

        case M_SAVE:
            /* set up the variable fields of the OPENFILENAME struct.
             * (the constant fields have been sel in SPInit()
             */
            g_ftSaveAs = g_ftOpenedAs;
            if( !fUntitled && SaveFile( hwndSP, szFileName, FALSE ) )
               break;

            /* fall through */

        case M_SAVEAS:

            OFN.lpstrFile       = szNewName;
            OFN.lpstrTitle      = szSaveCaption;
            /* Added OFN_PATHMUSTEXIST to eliminate problems in SaveFile.
             * 12 February 1991    clarkc
             */
            OFN.Flags = OFN_HIDEREADONLY     | OFN_OVERWRITEPROMPT |
                        OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST   |
                        OFN_EXPLORER         |
                        OFN_ENABLESIZING     |
                        OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

            OFN.lpTemplateName= TEXT("NpSaveDialog");
            OFN.lpfnHook= NpSaveDialogHookProc;

            /* ALL non-zero long pointers must be defined immediately
             * before the call, as the DS might move otherwise.
             * 12 February 1991    clarkc
             */
            OFN.lpstrFilter       = szSaveFilterSpec;
            OFN.lpstrDefExt       = TEXT("txt");

            if (!fUntitled)
            {
                lstrcpyn(szNewName, szFileName, MAX_PATH); /* set default selection */
            }
            else
            {
                lstrcpy (szNewName, TEXT("*.txt") );
            }

            fInSaveAsDlg = TRUE;

            OFN.nFilterIndex= FILE_TEXT;

            //
            // Do common dialog to save file
            //


            if (GetSaveFileName(&OFN))
            {

               if( SaveFile(hwnd, szNewName, TRUE) )
               {
                  lstrcpyn( szFileName, szNewName, MAX_PATH);
                  g_ftOpenedAs= g_ftSaveAs;
               }
            }
            else
            {
                SignalCommDlgError();
            }

            fInSaveAsDlg = FALSE;
            break;

        case M_SELECTALL:
            {
                HMENU    hMenu;

                hMenu = GetMenu(hwndSP);
                lSel = (LONG) SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, 0L);
                SendMessage (hwndEdit, EM_SETSEL, 0, lSel );
                SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
                EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_GRAYED);
                break;
            }

        case M_REPLACE:
            if( hDlgFind )
            {
               SetFocus( hDlgFind );
            }
            else
            {
               FR.Flags= FR_HIDEWHOLEWORD | FR_REPLACE;
               FR.lpstrReplaceWith= szReplace;
               FR.wReplaceWithLen= CCHKEYMAX;
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = ReplaceText( &FR );
            }
            break;

        case M_FINDNEXT:
            if (szSearch[0])
            {
               Search(szSearch);
               break;
            }
            /* else fall thro' a,d bring up "find" dialog */

        case M_FIND:
            if (hDlgFind)
            {
               SetFocus(hDlgFind);
            }
            else
            {
               FR.Flags= FR_DOWN | FR_HIDEWHOLEWORD;
               FR.lpstrReplaceWith= NULL;
               FR.wReplaceWithLen= 0;
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = FindText((LPFINDREPLACE)&FR);
            }
            break;

        case M_GOTO:
            {
                INT  Result;

                Result= (INT)DialogBox( hInstanceSP,
                                        MAKEINTRESOURCE(IDD_GOTODIALOG),
                                        hwndSP,
                                        GotoDlgProc );

                //
                // move cursor only if ok pressed and line number ok
                //

                if( Result == 0 )
                {
                    UINT CharIndex;
                    CharIndex= (UINT) SendMessage( hwndEdit,
                                                   EM_LINEINDEX,
                                                   lGotoLine-1,
                                                   0 );
                    if( CharIndex != (UINT) -1 )
                    {
                        SendMessage( hwndEdit, EM_SETSEL, CharIndex, CharIndex);
                        SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
                    }
                }
            }
            break;

        case M_ABOUT:
            ShellAbout(hwndSP,
                       szNN,
                       TEXT(""),
                       LoadIcon(hInstanceSP,
                                (LPTSTR)MAKEINTRESOURCE(ID_ICON)));

            break;

        case M_HELP:
            HtmlHelpA(GetDesktopWindow(), "sxspad.chm", HH_DISPLAY_TOPIC, 0L);
            break;

        case M_CUT:
        case M_COPY:
        case M_CLEAR:
            lSel = (LONG)SendMessage (hwndEdit, EM_GETSEL, 0, 0L);
            if (LOWORD(lSel) == HIWORD(lSel))
               break;

        case M_PASTE:
            /* If sxspad parent or edit window has the focus,
               pass command to edit window.
               make sure line resulting from paste will not be too long. */
            hwndFocus = GetFocus();
            if (hwndFocus == hwndEdit || hwndFocus == hwndSP)
            {
                PostMessage(hwndEdit, LOWORD(wParam), 0, 0);
            }
            break;

        case M_DATETIME:
            InsertDateTime(FALSE);
            break;

        case M_UNDO:
            SendMessage (hwndEdit, EM_UNDO, 0, 0L);
            break;

        case M_WW:
            style= (!fWrap) ? ES_STD : (ES_STD | WS_HSCROLL);
            if( NpReCreate( style ) )
            {
                fWrap= !fWrap;
            }
            else
            {
                MessageBox(hwndSP, szNoWW, szNN,
                           MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
            }
            break;

        case ID_EDIT:
            break;

        case M_PRINT:
            PrintIt( UseDialog );
            break;

        case M_PAGESETUP:
            TryPrintDlgAgain:

            if( PageSetupDlg(&g_PageSetupDlg) )
            {
                //  We know it's okay to copy these strings over...
                lstrcpy(chPageText[HEADER], chPageTextTemp[HEADER]);
                lstrcpy(chPageText[FOOTER], chPageTextTemp[FOOTER]);
            }
            else
            {
                rc= CommDlgExtendedError();

                if( rc == PDERR_PRINTERNOTFOUND ||
                    rc == PDERR_DNDMMISMATCH    ||
                    rc == PDERR_DEFAULTDIFFERENT )
                  {
                      FreeGlobal();
                      g_PageSetupDlg.hDevMode= g_PageSetupDlg.hDevNames= 0;
                      goto TryPrintDlgAgain;
                  }

                // Check for Dialog Failure

                SignalCommDlgError( );

            }
            break;

        case M_SETFONT:
        {
            CHOOSEFONT  cf;
            HFONT       hFontNew;
            HDC         hDisplayDC;     // display DC

            hDisplayDC= GetDC(NULL);    // try to get display DC
            if( !hDisplayDC )
                break;

            /* calls the font chooser (in commdlg)
             * We set lfHeight; choosefont returns ipointsize
             */
            cf.lStructSize = sizeof(CHOOSEFONT);
            cf.hwndOwner = hwnd;
            cf.lpLogFont = &FontStruct;         // filled in by init
            FontStruct.lfHeight= -MulDiv(iPointSize,GetDeviceCaps(hDisplayDC,LOGPIXELSY),720);
            cf.Flags = CF_INITTOLOGFONTSTRUCT |
                       CF_SCREENFONTS         |
                       CF_NOVERTFONTS         |
                       0;
            cf.rgbColors = 0;                   // only if cf_effects
            cf.lCustData = 0;                   // for hook function
            cf.lpfnHook = (LPCFHOOKPROC) NULL;
            cf.lpTemplateName = (LPTSTR) NULL;
            cf.hInstance = NULL;
            cf.lpszStyle = NULL;                // iff cf_usestyle
            cf.nFontType = SCREEN_FONTTYPE;
            cf.nSizeMin  = 0;  // iff cf_limitsize
            cf.nSizeMax  = 0;  // iff cf_limitsize
            ReleaseDC( NULL, hDisplayDC );

            if( ChooseFont(&cf) )
            {
                SetCursor( hWaitCursor );        // may take some time

                hFontNew= CreateFontIndirect(&FontStruct);
                if( hFontNew )
                {
                   DeleteObject( hFont );
                   hFont= hFontNew;
                   SendMessage( hwndEdit, WM_SETFONT,
                               (WPARAM)hFont, MAKELPARAM(TRUE, 0));
                   iPointSize= cf.iPointSize;  // remember for printer
                }
                SetCursor( hStdCursor );
            }
            break;
        }

        default:
            return FALSE;
    }
    return TRUE;
}


// for some reason, this procedure tries to maintain
// a valid 'fp' even though I believe it does not need
// to be.
void FileDragOpen(void)
{
    HANDLE oldfp;

    oldfp= fp;       // remember in case of error

    if( CheckSave(FALSE) )
    {

         fp= CreateFile( szPath,               // filename
                         GENERIC_READ,         // access mode
                         FILE_SHARE_READ|FILE_SHARE_WRITE,
                         NULL,                 // security descriptor
                         OPEN_EXISTING,        // how to create
                         FILE_ATTRIBUTE_NORMAL,// file attributes
                         NULL);                // hnd to file attrs

       if( fp == INVALID_HANDLE_VALUE )
       {
          AlertUser_FileFail( szPath );

          // Restore fp to original file.
          fp= oldfp;
       }
       /* Try to load the file and reset fp if failed */
       else if( !LoadFile( szPath, FT_UNKNOWN ) )
       {
           fp= oldfp;
       }
    }
}


/* Proccess file drop/drag options. */
void doDrop (WPARAM wParam, HWND hwnd)
{
   /* If user dragged/dropped a file regardless of keys pressed
    * at the time, open the first selected file from file manager. */

    if (DragQueryFile ((HANDLE)wParam, 0xFFFFFFFF, NULL, 0)) /* # of files dropped */
    {
       DragQueryFile ((HANDLE)wParam, 0, szPath, CharSizeOf(szPath));
       SetActiveWindow (hwnd);
       FileDragOpen();
    }
    DragFinish ((HANDLE)wParam);  /* Delete structure alocated for WM_DROPFILES*/
}

/* ** if sxspad is dirty, check to see if user wants to save contents */
BOOL FAR CheckSave (BOOL fSysModal)
{
    INT    mdResult = IDOK;
    TCHAR  szNewName[MAX_PATH] = TEXT("");      /* New file name */
    TCHAR *pszFileName;

/* If it's untitled and there's no text, don't worry about it */
    if (fUntitled && !SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, (LPARAM)0))
        return (TRUE);

    if (SendMessage (hwndEdit, EM_GETMODIFY, 0, 0L))
    {
       if( fUntitled )
           pszFileName= szUntitled;
       else
           pszFileName= szFileName;

       mdResult= AlertBox( hwndSP, szNN, szSCBC, pszFileName,
       (WORD)((fSysModal ? MB_SYSTEMMODAL :
                           MB_APPLMODAL)|MB_YESNOCANCEL|MB_ICONEXCLAMATION));
       if( mdResult == IDYES )
       {
          if( fUntitled )
          {
             lstrcpy( szNewName, TEXT("*.txt") );
SaveFilePrompt:
             OFN.lpstrFile        = szNewName;
             OFN.lpstrTitle       = szSaveCaption;

            /* Added OFN_PATHMUSTEXIST to eliminate problems in SaveFile.
             * 12 February 1991    clarkc
             */

            OFN.Flags = OFN_HIDEREADONLY     | OFN_OVERWRITEPROMPT |
                        OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST   |
                        OFN_EXPLORER         |
                        OFN_ENABLESIZING     |
                        OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

            OFN.lpTemplateName= TEXT("NpSaveDialog");
            OFN.lpfnHook= NpSaveDialogHookProc;

            /* ALL non-zero long pointers must be defined immediately
             * before the call, as the DS might move otherwise.
             * 12 February 1991    clarkc
             */
             OFN.lpstrFilter       = szSaveFilterSpec;
             OFN.lpstrDefExt       = TEXT("txt");

             OFN.nFilterIndex= FILE_TEXT;

             //
             // Set dialog checkmark by current file type
             //

             fInSaveAsDlg = TRUE;
             if (GetSaveFileName(&OFN))
             {
                // since SaveFile() uses near ptr to name (obs.)
                lstrcpy(szNewName, OFN.lpstrFile);
                if( SaveFile(hwndSP, szNewName, TRUE) )
                {
                   lstrcpy(szFileName, szNewName);
                   g_ftOpenedAs= g_ftSaveAs;
                }
                else
                {      // Fixing close without saving file when disk-full
                   lstrcpy(szNewName, szFileName);
                   goto SaveFilePrompt;
                }
             }
             else
             {
                mdResult= IDCANCEL;       /* Don't exit Program */
                if( CommDlgExtendedError() )/* Dialog box failed, Lo-mem*/
                   DeepTrouble();
             }

             fInSaveAsDlg = FALSE;
          }
          else
          {
            // initialize the save type.
             g_ftSaveAs = g_ftOpenedAs;
             if( SaveFile(hwndSP, szFileName, FALSE) )
                return(TRUE);
             lstrcpy(szNewName, szFileName);
             goto SaveFilePrompt;
          }
       }
    }
    return (mdResult != IDCANCEL);
}


/* sxspad window class procedure */
LRESULT FAR SPWndProc(
        HWND       hwnd,
        UINT       message,
        WPARAM     wParam,
        LPARAM     lParam)
{
    RECT rc;
    LPFINDREPLACE lpfr;
    DWORD dwFlags;
    HANDLE hMenu;



    switch (message)
    {
/* If we're being run by Setup and it's the system menu, be certain that
 * the minimize menu item is disabled.  Note that hSysMenuSetup is only
 * initialized if sxspad is being run by Setup.  Don't use it outside
 * the fRunBySetup conditional!    28 June 1991    Clark Cyr
 */
        case WM_INITMENUPOPUP:
            if (fRunBySetup && HIWORD(lParam))
               EnableMenuItem(hSysMenuSetup,SC_MINIMIZE,MF_GRAYED|MF_DISABLED);
            break;

        case WM_SYSCOMMAND:
            if (fRunBySetup)
            {
                /* If we have been spawned by SlipUp we need to make sure the
                 * user doesn't minimize us or alt tab/esc away.
                 */
                if (wParam == SC_MINIMIZE ||
                    wParam == SC_NEXTWINDOW ||
                    wParam == SC_PREVWINDOW)
                    break;
            }
            DefWindowProc(hwnd, message, wParam, lParam);
            break;

        case WM_SETFOCUS:
            if (!IsIconic(hwndSP))
            {
               SetFocus(hwndEdit);
            }
            break;

        case WM_KILLFOCUS:
            SendMessage (hwndEdit, message, wParam, lParam);
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_CLOSE:

            // Save any globals in the registry if need be

            SaveGlobals();

            if (CheckSave(FALSE))
            {
                /* Exit help */
                if(!WinHelp(hwndSP, (LPTSTR)szHelpFile, HELP_QUIT, 0))
                    DeepTrouble();

                DestroyWindow(hwndSP);
                DeleteObject(hFont);
            }

            break;

        case WM_QUERYENDSESSION:
            if (fInSaveAsDlg)
            {
                MessageBeep (0);
                MessageBeep (0);
                MessageBox (hwndSP, szCannotQuit, szNN, MB_OK|MB_SYSTEMMODAL);
                return FALSE;
            }
            else
                return (CheckSave(TRUE));
            break;


        case WM_ACTIVATEAPP:
            if (wParam)
            {
            /* This causes the caret position to be at the end of the selection
             * but there's no way to ask where it was or set it if known.  This
             * will cause a caret change when the selection is made from bottom
             * to top.
             */
                if( dwCurrentSelectionStart != 0 || dwCurrentSelectionEnd != 0 )
                {
                   SendMessage( hwndEdit, EM_SETSEL,
                                dwCurrentSelectionStart,
                                dwCurrentSelectionEnd );
                   SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
                }
            }
            else
            {
                SendMessage( hwndEdit, EM_GETSEL,
                            (WPARAM) &dwCurrentSelectionStart,
                            (LPARAM) &dwCurrentSelectionEnd);
                if (dwCurrentSelectionStart == dwCurrentSelectionEnd)
                {
                    dwCurrentSelectionStart = 0L;
                    dwCurrentSelectionEnd = 0L;
                }
                else
                {
                   SendMessage (hwndEdit, EM_SETSEL, dwCurrentSelectionStart,
                                dwCurrentSelectionEnd);
                   SendMessage (hwndEdit, EM_SCROLLCARET, 0, 0);
                }
            }
            break;

        case WM_ACTIVATE:
            if ((LOWORD(wParam) == WA_ACTIVE       ||
                 LOWORD(wParam) == WA_CLICKACTIVE) &&
                !IsIconic(hwndSP))
               {
                   // active doesn't always mean foreground (ntbug# 53048)
                   if( GetForegroundWindow() == hwndSP )
                   {
                       SetFocus(GetForegroundWindow());
                   }
               }
            break;

        case WM_SIZE:
            switch (wParam)
            {
                case SIZENORMAL:
                case SIZEFULLSCREEN:
                    SPSize(MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y);
                    break;

                case SIZEICONIC:
                    return (DefWindowProc(hwnd, message, wParam, lParam));
                    break;
                }
            break;

        case WM_INITMENU:
            NpResetMenu( hwnd );
            break;

        //
        // Some keyboards come with a "Search" button which the shell team
        // wanted us to handle.  See ntbug# 380067
        //

        case WM_APPCOMMAND:

            if( ( GET_APPCOMMAND_LPARAM(lParam) == APPCOMMAND_BROWSER_SEARCH ) )
            {
                SPCommand(hwnd, M_FIND, 0);
                break;
            }
            // otherwise fall through

        case WM_COMMAND:
            if ((HWND)(lParam) == hwndEdit &&
                (HIWORD(wParam) == EN_ERRSPACE ||
                 HIWORD(wParam) == EN_MAXTEXT))
            {
                if (dwEmSetHandle == SETHANDLEINPROGRESS)
                    dwEmSetHandle = SETHANDLEFAILED;
                else
                    DeepTrouble();
                return 0L;
            }

            if (!SPCommand(hwnd, wParam, lParam))
               return (DefWindowProc(hwnd, message, wParam, lParam));
            break;

        case WM_WININICHANGE:
            // Ignore for now.
            // If you put this back in, be sure it handles both
            // the metric change and the decimal change.
            //NpWinIniChange ();
            break;

        case WM_DROPFILES: /*case added 03/26/91 for file drag/drop support*/
            doDrop (wParam,hwnd);
            break;

        case PWM_CHECK_HKL: /* private message: corresponding to HKL change message */
            {
                LPARAM lParam = 0;

                if (PRIMARYLANGID(LOWORD((DWORD) (INT_PTR) GetKeyboardLayout(0))) == LANG_JAPANESE) {
                    /*
                     * If new current HKL is Japanese, handle the result string at once.
                     */
                    lParam = EIMES_GETCOMPSTRATONCE;
                }
                SendMessage(hwndEdit, EM_SETIMESTATUS, EMSIS_COMPOSITIONSTRING, lParam);
            }
            break;

        default:
            /* this can be a message from the modeless Find Text window */
            if (message == wFRMsg)
            {
                BOOL bStatus;    // true if found text

                lpfr = (LPFINDREPLACE)lParam;
                dwFlags = lpfr->Flags;

                fReverse = (dwFlags & FR_DOWN      ? FALSE : TRUE);
                fCase    = (dwFlags & FR_MATCHCASE ? TRUE  : FALSE);

                if( dwFlags & FR_FINDNEXT )
                {
                    SetCursor( hWaitCursor );
                    Search( szSearch );
                    SetCursor( hStdCursor );
                }
                else if( dwFlags & FR_REPLACE )
                {
                    //
                    // Replace current selection if it matches
                    // then highlight the next occurence of the string.
                    //

                    SetCursor( hWaitCursor );
                    ReplaceSel( TRUE );
                    Search( szSearch );
                    SetCursor( hStdCursor );
                }
                else if( dwFlags & FR_REPLACEALL )
                {
                   //
                   // The replace dialog doesn't allow reverse searches
                   // but just it cases it changes, for it to false.
                   //
                   if( fReverse )
                   {
                       fReverse= FALSE;
                   }

                   //
                   // Replace all occurances of text in the file
                   // starting from the top.  Reset the selection
                   // to the top of the file.
                   //
                   SetCursor( hWaitCursor );
                   SendMessage( hwndEdit, EM_SETSEL, 0, 0 );
                   do
                   {
                      ReplaceSel( FALSE );
                      bStatus= Search( szSearch );
                   }
                   while( bStatus );
                   SetCursor( hStdCursor );
                   //
                   // back to the top of the file.
                   //
                   SendMessage( hwndEdit, EM_SETSEL, 0, 0 );
                   SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0);

                }
                else if (dwFlags & FR_DIALOGTERM)
                    hDlgFind = NULL;   /* invalidate modeless window handle */
                break;
            }
            return (DefWindowProc(hwnd, message, wParam, lParam));
    }
    return (0L);
}

LPTSTR SkipProgramName (LPTSTR lpCmdLine)
{
    LPTSTR  p = lpCmdLine;
    BOOL    bInQuotes = FALSE;

    //
    // Skip executable name
    //
    for (p; *p; p = CharNext(p))
    {
       if ((*p == TEXT(' ') || *p == TEXT('\t')) && !bInQuotes)
          break;

       if (*p == TEXT('\"'))
          bInQuotes = !bInQuotes;
    }

    while (*p == TEXT(' ') || *p == TEXT('\t'))
       p++;

    return (p);
}

/* ** Main loop */

INT WINAPI WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR lpAnsiCmdLine,
   INT cmdShow)
{
    MSG msg;
    VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL) = NULL;
    LPTSTR lpCmdLine = GetCommandLine ();


/* PenWindow registration must be before creating an edit class window.
 * Moved here, along with goto statement below for appropriate cleanup.
 *                 10 July 1991    ClarkC
 */
    if ((FARPROC) lpfnRegisterPenApp = GetProcAddress((HINSTANCE)(INT_PTR)(GetSystemMetrics(SM_PENWINDOWS)),
        "RegisterPenApp"))
        (*lpfnRegisterPenApp)(1, TRUE);

    if (!SPInit(hInstance, hPrevInstance, SkipProgramName (lpCmdLine), cmdShow))
    {
       msg.wParam = FALSE;
       goto UnRegisterPenWindows;
    }

    while (GetMessage((LPMSG)&msg, (HWND)NULL, 0, 0))
    {
        //
        // To handle IME status when active KL is changed.
        //
        if (msg.message == WM_INPUTLANGCHANGEREQUEST) {
            //
            // WM_INPUTLANGCHANGE will be *sent* to WndProc,
            // so there's no chance to catch WM_INPUTLANGCHANGE from the frame window.
            // Instead, we post the private message to check the active HKL later.
            //
            PostMessage(hwndSP, PWM_CHECK_HKL, 0, 0);
        }

        if (!hDlgFind || !IsDialogMessage(hDlgFind, &msg))
        {
            if (TranslateAccelerator(hwndSP, hAccel, (LPMSG)&msg) == 0)
            {
               TranslateMessage ((LPMSG)&msg);
               DispatchMessage ((LPMSG)&msg);
            }
        }
    }

    /* Clean up any global allocations */

    FreeGlobal();

    LocalFree( hEdit );

UnRegisterPenWindows:

    if (lpfnRegisterPenApp)
        (*lpfnRegisterPenApp)(1, FALSE);

    return (int)(msg.wParam);
}

/* ** Set Window caption text */
void FAR SetTitle( TCHAR  *sz )
{
    TCHAR    szWindowText[MAX_PATH+50];
    TCHAR    szFileName[MAX_PATH];
    HANDLE   hFindFile;
    WIN32_FIND_DATA info;

    // if "untitled" then don't do all this work...
    if( lstrcmp( sz, szUntitled ) == 0 )
       lstrcpy( szWindowText, sz );
    else
    {
       // Get real(file system) name for the file.
       hFindFile= FindFirstFile( sz, &info );

       if( hFindFile != INVALID_HANDLE_VALUE )
       {
          lstrcpy( szFileName, info.cFileName );
          FindClose( hFindFile );
       }
       else
          lstrcpy( szFileName, sz );

       GetFileTitle(szFileName, szWindowText, MAX_PATH);
    }

    lstrcat(szWindowText, szNpTitle);
    SetWindowText(hwndSP, (LPTSTR)szWindowText);
}

/* ** Given filename which may or maynot include path, return pointer to
      filename (not including path part.) */
LPTSTR PASCAL far PFileInPath(
    LPTSTR sz)
{
    LPTSTR pch = sz;
    LPTSTR psz;

    /* Strip path/drive specification from name if there is one */
    /* Ripped out AnsiPrev calls.     21 March 1991  clarkc     */
    for (psz = sz; *psz; psz = CharNext(psz))
      {
        if ((*psz == TEXT(':')) || (*psz == TEXT('\\')))
            pch = psz;
      }

    if (pch != sz)   /* If found slash or colon, return the next character */
        pch++;       /* increment OK, pch not pointing to DB character     */

    return(pch);
}

/* ** Enable or disable menu items according to selection state
      This routine is called when user tries to pull down a menu. */

VOID NpResetMenu( HWND hwnd )
{
    LONG    lsel;
    INT     mfcc;   /* menuflag for cut, copy */
    BOOL    fCanUndo;
    HANDLE  hMenu;
    TCHAR   msgbuf[20];
    BOOL    fPaste= FALSE;
    UINT    uSelState;

    hMenu = GetMenu(hwndSP);

    // cut, copy and delete only get enabled if there is text selected.

    lsel = (LONG)SendMessage(hwndEdit, EM_GETSEL, 0, 0L);
    mfcc = LOWORD(lsel) == HIWORD(lsel) ? MF_GRAYED : MF_ENABLED;
    EnableMenuItem(GetSubMenu(hMenu, 1), M_CUT, mfcc);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_COPY, mfcc);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_CLEAR, mfcc);

    // check if the selectall is gray (that means the user has already
    // done select-all) and it the user has deselected - if so, time
    // to re-enable selectall menu.

    uSelState = GetMenuState(GetSubMenu(hMenu, 1), M_SELECTALL, MF_BYCOMMAND);
    if ((uSelState == MF_GRAYED) && (mfcc == MF_GRAYED))
    {
        EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_ENABLED);
    }

    // paste is enabled if there is text in the clipboard

    if( OpenClipboard(hwnd) )
    {
        fPaste= IsClipboardFormatAvailable(CF_TEXT);
        CloseClipboard();
    }
    EnableMenuItem(GetSubMenu(hMenu, 1), M_PASTE, fPaste ? MF_ENABLED : MF_GRAYED);

    // enable Undo only if editcontrol says we can do it.

    fCanUndo = (BOOL) SendMessage(hwndEdit, EM_CANUNDO, 0, 0L);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_UNDO, fCanUndo ? MF_ENABLED : MF_GRAYED);

    // check the word wrap item correctly

    CheckMenuItem(GetSubMenu(hMenu, 2), M_WW, fWrap ? MF_CHECKED : MF_UNCHECKED);

}


void FAR NpWinIniChange(VOID)
{
   InitLocale ();
}

/* ** Scan sz1 for merge spec.    If found, insert string sz2 at that point.
      Then append rest of sz1 NOTE! Merge spec guaranteed to be two chars.
      returns TRUE if it does a merge, false otherwise. */
BOOL MergeStrings(
    TCHAR    *szSrc,
    TCHAR    *szMerge,
    TCHAR    *szDst)
    {
    register    TCHAR *pchSrc;
    register    TCHAR *pchDst;

    pchSrc = szSrc;
    pchDst = szDst;

    /* Find merge spec if there is one. */
    while ( *pchSrc != chMerge)
        {
        *pchDst++ = *pchSrc;

        /* If we reach end of string before merge spec, just return. */
        if (!*pchSrc++)
            return FALSE;

        }

    /* If merge spec found, insert sz2 there. (check for null merge string */
    if (szMerge)
        {
        while (*szMerge)
            *pchDst++ = *szMerge++;
        }

    /* Jump over merge spec */
    pchSrc++,pchSrc++;

    /* Now append rest of Src String */
    while (*pchDst++ = *pchSrc++);
    return TRUE;

    }

/* ** Post a message box */
INT FAR AlertBox(
    HWND    hwndParent,
    TCHAR    *szCaption,
    TCHAR    *szText1,
    TCHAR    *szText2,
    UINT     style)
{
    INT iResult;                      // result of function
    INT iAllocSize;                   // size needed for message
    TCHAR*  pszMessage;               // combined message

    // Allocate a message buffer assuming there will be a merge.
    // If we cannot do the allocation, tell the user something
    // related to the original problem. (not the allocation failure)
    // Then pray that MessageBox can get enough memory to actually work.

    iAllocSize= (lstrlen(szText1) + (szText2 ? lstrlen(szText2) : 0) + 1 ) * sizeof(TCHAR);

    pszMessage= (TCHAR*) LocalAlloc( LPTR, iAllocSize );

    if( pszMessage )
    {
        MergeStrings( szText1, szText2, pszMessage );
        iResult= MessageBox( hwndParent, pszMessage, szCaption, style );
        LocalFree( (HLOCAL) pszMessage );
    }
    else
    {
        iResult= MessageBox( hwndParent, szText1, szCaption, style );
    }

    return( iResult );
}

// SignalCommDlgError
//
// If a common dialog error occurred, put up reasonable message box.
//
// returns: TRUE if error occurred, FALSE if no error.
//

typedef struct tagMAPERROR
{
    DWORD   rc;            // return code from CommDlgExtendedError()
    PTCHAR* ppszMsg;       // text of message pointer
} MAPERROR;

// errors not in this list get generic "common dialog error %x" message.
static TCHAR* szNull= TEXT("");

MAPERROR maperror[]=
{
    CDERR_DIALOGFAILURE,  &szErrSpace,
    CDERR_INITIALIZATION, &szCommDlgInitErr,
    CDERR_MEMLOCKFAILURE, &szPDIE,
    CDERR_LOADSTRFAILURE, &szErrSpace,
    CDERR_FINDRESFAILURE, &szErrSpace,
    PDERR_LOADDRVFAILURE, &szLoadDrvFail,
    PDERR_GETDEVMODEFAIL, &szErrSpace,
    PDERR_NODEFAULTPRN,   &szNull,          // don't report; common dialog does already
};

BOOL SignalCommDlgError(VOID)
{
    DWORD rc;               // return code
    TCHAR* pszMsg;          // message
    INT    i;
    TCHAR  szBuf[200];      // just for common dialog failure

    rc= CommDlgExtendedError();

    // no failure - just return

    if( rc == 0 )
    {
        return FALSE;
    }

    // some sort of error - pick up message

    pszMsg= NULL;
    for( i=0; i< sizeof(maperror)/sizeof(maperror[0]); i++ )
    {
        if( rc == maperror[i].rc )
        {
            pszMsg= *maperror[i].ppszMsg;
        }
    }

    // if no known mapping - tell user the actual return code
    // this may be a bit confusing, but rare hopefully.

    if( !pszMsg )
    {
        wsprintf( szBuf, szCommDlgErr, rc );   // fill in error code
        pszMsg= szBuf;
    }

    // popup if there is any message to give user

    if( *pszMsg )
    {
        MessageBox(hwndSP, pszMsg, szNN, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND);
    }

    return TRUE;

}

// ReplaceSel
//
// Replace the current selection with string from FR struct
// if the current selection matches our search string.
//
// MLE will show selection if bView is true.
//


VOID ReplaceSel( BOOL bView )
{
    DWORD StartSel;    // start of selected text
    DWORD EndSel;      // end of selected text

    HANDLE hEText;
    TCHAR* pStart;
    DWORD  ReplaceWithLength;  // length of replacement string
    DWORD  FindWhatLength;

    ReplaceWithLength= lstrlen(FR.lpstrReplaceWith);
    FindWhatLength= lstrlen(FR.lpstrFindWhat);

    SendMessage( hwndEdit, EM_GETSEL, (WPARAM) &StartSel, (LPARAM) &EndSel );
    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hEText )  // silently return if we can't get it
    {
        return;
    }

    pStart= LocalLock( hEText );
    if( !pStart )
    {
        return;
    }

    if(  (EndSel-StartSel) == FindWhatLength )
    {
       if( (fCase &&
            !_tcsncmp(  FR.lpstrFindWhat, pStart+StartSel, FindWhatLength) ) ||
           (!fCase &&
           ( 2 == CompareString(LOCALE_USER_DEFAULT,
                  NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                  FR.lpstrFindWhat, FindWhatLength,
                  pStart+StartSel,  FindWhatLength ) ) ) )
        {
            SendMessage( hwndEdit, EM_REPLACESEL,
                         TRUE, (LPARAM) FR.lpstrReplaceWith);
            SendMessage( hwndEdit, EM_SETSEL,
                         StartSel, StartSel+ReplaceWithLength );

            if( bView )
            {
                SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
            }
        }
    }

    LocalUnlock( hEText );
}

// GotoDlgProc
//
// Handle the Goto Dialog window processing
//
// Returns:
//
// 1 if successfull
// 0 if not (cancelled)
//
// Modifies global lGotoLine
//

const DWORD s_GotoHelpIDs[] = {
    IDC_GOTO, IDH_GOTO,
    0, 0
};

#define GOTOBUFSIZE 100
INT_PTR CALLBACK GotoDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    TCHAR szBuf[GOTOBUFSIZE];
    UINT LineNum;
    DWORD SelStart, SelEnd;
    POINT pt;
    INT id;

    switch (message)
    {
        //
        // initialize input field to size of file
        //
        case WM_INITDIALOG:
            SendMessage(hwndEdit,EM_GETSEL,(WPARAM) &SelStart,(WPARAM)&SelEnd);

            // the line numbers are 1 based instead 0 based. hence add 1.
            LineNum= (UINT)SendMessage( hwndEdit, EM_LINEFROMCHAR, SelStart, 0 ) + 1;
            wsprintf(szBuf, TEXT("%d"), LineNum);
            SetDlgItemText( hDlg, IDC_GOTO, szBuf );
            SetFocus( hDlg );
            return TRUE;
            break;

        // context sensitive help.
        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, szHelpFile,
                HELP_WM_HELP, (ULONG_PTR) (LPVOID) s_GotoHelpIDs);
            break;

        case WM_CONTEXTMENU:

            WinHelp((HWND) wParam, szHelpFile, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPVOID) s_GotoHelpIDs);
            break;

        case WM_COMMAND:

            switch (LOWORD(wParam))
            {
                UINT CharIndex;

                case IDC_GOTO:
                    return TRUE;
                    break;

                case IDOK:
                    GetDlgItemText( hDlg, IDC_GOTO, szBuf, GOTOBUFSIZE );

                    // convert all unicode numbers to range L'0' to L'9'

                    FoldString( MAP_FOLDDIGITS, szBuf, -1, szBuf, GOTOBUFSIZE);
                    lGotoLine= _ttol( szBuf );

                    //
                    // see if valid line number
                    //

                    CharIndex= (UINT)SendMessage( hwndEdit,
                                            EM_LINEINDEX,
                                            lGotoLine-1,
                                            0);
                    if( lGotoLine > 0 && CharIndex != -1 )
                    {
                        EndDialog(hDlg, 0);  // successfull
                        return TRUE;
                    }

                    //
                    // Invalid line number
                    // warning user and set to reasonable value
                    //

                    MessageBox( hDlg, szLineTooLarge, szLineError, MB_OK );

                    LineNum= (UINT)SendMessage( hwndEdit, EM_GETLINECOUNT, 0, 0 );
                    wsprintf(szBuf, TEXT("%d"), LineNum);
                    SetDlgItemText( hDlg, IDC_GOTO, szBuf );
                    SetFocus( hDlg );
                    break;

                case IDCANCEL :
                    EndDialog(hDlg, 1 );   // cancelled
                    return TRUE;
                    break;

                default:

                    break;

            } // switch (wParam)

            break;

       default:

             break;

    } // switch (message)


    return FALSE;     // Didn't process a message


} // GotoDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxspad\sxspad.h ===
/* SxSpad.h */

#define NOCOMM
#define NOSOUND
#include <windows.h>
#include <ole2.h>
#include <commdlg.h>
// we need this for CharSizeOf(), ByteCountOf(),
#include "uniconv.h"

/* handy debug macro */
#define ODS OutputDebugString

typedef enum _SP_FILETYPE {
   FT_UNKNOWN=-1,
   FT_ANSI=0,
   FT_UNICODE=1,
   FT_UNICODEBE=2,
   FT_UTF8=3,
} SP_FILETYPE;


#define BOM_UTF8_HALF        0xBBEF
#define BOM_UTF8_2HALF       0xBF


/* openfile filter for all text files */
#define FILE_TEXT         1


#define PT_LEN               40    /* max length of page setup strings */
#define CCHFILTERMAX         80    /* max. length of filter name buffers */

// Menu IDs
#define ID_APPICON           1 /* must be one for explorer to find this */
#define ID_ICON              2
#define ID_MENUBAR           1

// Dialog IDs

#define IDD_ABORTPRINT       11
#define IDD_PAGESETUP        12
#define IDD_SAVEDIALOG       13    // template for save dialog
#define IDD_GOTODIALOG       14    // goto line number dialog

// Control IDs

#define IDC_FILETYPE         257   // listbox in save dialog
#define IDC_GOTO             258   // line number to goto
#define IDC_ENCODING         259   // static text in save dialog

//  Menu IDs

// File
#define M_NEW                1
#define M_OPEN               2
#define M_SAVE               3
#define M_SAVEAS             4
#define M_PAGESETUP          5
#define M_PRINT              6
#define M_EXIT               7

// Edit
#define M_UNDO               16
#define M_CUT                WM_CUT       /* These just get passed down to the edit control */
#define M_COPY               WM_COPY
#define M_PASTE              WM_PASTE
#define M_CLEAR              WM_CLEAR
#define M_FIND               21
#define M_FINDNEXT           22
#define M_REPLACE            23
#define M_GOTO               24
#define M_SELECTALL          25
#define M_DATETIME           26

// Format
#define M_WW                 32
#define M_SETFONT            33

// Help
#define M_HELP               64
#define M_ABOUT              65



// Control IDs

#define ID_EDIT              15
#define ID_FILENAME          20
#define ID_PAGENUMBER        21


#define ID_HEADER            30
#define ID_FOOTER            31
#define ID_HEADER_LABEL      32
#define ID_FOOTER_LABEL      33

#define ID_ASCII             50
#define ID_UNICODE           51


// IDs used to load RC strings

#define IDS_DISKERROR         1
#define IDS_FNF               2
#define IDS_SCBC              3
#define IDS_UNTITLED          4
#define IDS_SXSPAD            5
#define IDS_CFS               6
#define IDS_ERRSPACE          7
#define IDS_FTL               8
#define IDS_NN                9
#define IDS_COMMDLGINIT      10
#define IDS_PRINTDLGINIT     11
#define IDS_CANTPRINT        12
#define IDS_NVF              13
#define IDS_CREATEERR        14
#define IDS_NOWW             15
#define IDS_MERGE1           16
#define IDS_HELPFILE         17
#define IDS_HEADER           18
#define IDS_FOOTER           19

#define IDS_ANSITEXT         20
#define IDS_ALLFILES         21
#define IDS_OPENCAPTION      22
#define IDS_SAVECAPTION      23
#define IDS_CANNOTQUIT       24
#define IDS_LOADDRVFAIL      25
#define IDS_ACCESSDENY       26
#define IDS_ERRUNICODE       27


#define IDS_FONTTOOBIG       28
#define IDS_COMMDLGERR       29


#define IDS_LINEERROR        30  /* line number error     */
#define IDS_LINETOOLARGE     31  /* line number too large */

#define IDS_FT_ANSI          32  /* ascii              */
#define IDS_FT_UNICODE       33  /* unicode            */
#define IDS_FT_UNICODEBE     34  /* unicode big endian */
#define IDS_FT_UTF8          35  /* UTF-8 format       */

#define IDS_CURRENT_PAGE     36  /* currently printing page on abort dlg */

#define CSTRINGS             36  /* cnt of stringtable strings from .rc file */

#define CCHKEYMAX           128  /* max characters in search string */

#define CCHSPMAX              0  /* no limit on file size */

#define SETHANDLEINPROGRESS   0x0001 /* EM_SETHANDLE has been sent */
#define SETHANDLEFAILED       0x0002 /* EM_SETHANDLE caused EN_ERRSPACE */

/* Standard edit control style:
 * ES_NOHIDESEL set so that find/replace dialog doesn't undo selection
 * of text while it has the focus away from the edit control.  Makes finding
 * your text easier.
 */
#define ES_STD (WS_CHILD|WS_VSCROLL|WS_VISIBLE|ES_MULTILINE|ES_NOHIDESEL)

/* EXTERN decls for data */
extern SP_FILETYPE fFileType;     /* Flag indicating the type of text file */

extern BOOL fCase;                /* Flag specifying case sensitive search */
extern BOOL fReverse;             /* Flag for direction of search */
extern TCHAR szSearch[];
extern HWND hDlgFind;             /* handle to modeless FindText window */

extern HANDLE hEdit;
extern HANDLE hFont;
extern HANDLE hAccel;
extern HANDLE hInstanceSP;
extern HANDLE hStdCursor, hWaitCursor;
extern HWND   hwndSP, hwndEdit;

extern LOGFONT  FontStruct;
extern INT      iPointSize;

extern BOOL     fRunBySetup;

extern DWORD    dwEmSetHandle;

extern TCHAR    chMerge;

extern BOOL     fUntitled;
extern BOOL     fWrap;
extern TCHAR    szFileName[];
extern HANDLE   fp;

//
// Holds header and footer strings to be used in printing.
// use HEADER and FOOTER to index.
//
extern TCHAR    chPageText[2][PT_LEN]; // header and footer strings
#define HEADER 0
#define FOOTER 1
//
// Holds header and footer from pagesetupdlg during destroy.
// if the user hit ok, then keep.  Otherwise ignore.
//
extern TCHAR    chPageTextTemp[2][PT_LEN];

extern TCHAR    szSxspad[];
extern TCHAR   *szMerge;
extern TCHAR   *szUntitled, *szNpTitle, *szNN, *szErrSpace;
extern TCHAR   *szErrUnicode;
extern TCHAR  **rgsz[];          /* More strings. */
extern TCHAR   *szNVF;
extern TCHAR   *szPDIE;
extern TCHAR   *szDiskError;
extern TCHAR   *szCREATEERR;
extern TCHAR   *szWE;
extern TCHAR   *szFTL;
extern TCHAR   *szINF;
extern TCHAR   *szFNF;
extern TCHAR   *szNEDSTP;
extern TCHAR   *szNEMTP;
extern TCHAR   *szCFS;
extern TCHAR   *szPE;
extern TCHAR   *szCP;
extern TCHAR   *szACCESSDENY;
extern TCHAR   *szFontTooBig;
extern TCHAR   *szLoadDrvFail;
extern TCHAR   *szCommDlgErr;
extern TCHAR   *szCommDlgInitErr;
extern TCHAR   *szHelpFile;

extern TCHAR   *szFtAnsi;
extern TCHAR   *szFtUnicode;
extern TCHAR   *szFtUnicodeBe;
extern TCHAR   *szFtUtf8;
extern TCHAR   *szCurrentPage;
extern TCHAR   *szHeader;
extern TCHAR   *szFooter;

/* variables for the new File/Open and File/Saveas dialogs */
extern OPENFILENAME OFN;        /* passed to the File Open/save APIs */
extern TCHAR  szOpenFilterSpec[]; /* default open filter spec          */
extern TCHAR  szSaveFilterSpec[]; /* default save filter spec          */
extern TCHAR *szAnsiText;       /* part of the text for the above    */
extern TCHAR *szAllFiles;       /* part of the text for the above    */
extern FINDREPLACE FR;          /* Passed to FindText()        */
extern PAGESETUPDLG g_PageSetupDlg;
extern TCHAR  szPrinterName []; /* name of the printer passed to PrintTo */

extern SP_FILETYPE    g_ftOpenedAs;     /* file was opened           */
extern SP_FILETYPE    g_ftSaveAs;       /* file was saved as type    */

extern UINT   wFRMsg;           /* message used in communicating    */
                                /*   with Find/Replace dialog       */
extern UINT   wHlpMsg;          /* message used in invoking help    */

extern HMENU hSysMenuSetup;     /* Save Away for disabled Minimize   */

/* EXTERN procs */
/* procs in sxspad.c */
VOID
PASCAL
SetPageSetupDefaults(
    VOID
    );

BOOL far PASCAL SaveAsDlgHookProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

LPTSTR PASCAL far PFileInPath (LPTSTR sz);

BOOL FAR CheckSave (BOOL fSysModal);
LRESULT FAR SPWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void FAR SetTitle (TCHAR *sz);
INT FAR  AlertBox (HWND hwndParent, TCHAR *szCaption, TCHAR *szText1,
                   TCHAR *szText2, UINT style);
void FAR NpWinIniChange (VOID);
void FAR FreeGlobalPD (void);
INT_PTR CALLBACK GotoDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);

/* procs in npdate.c */
VOID FAR InsertDateTime (BOOL fCrlf);

/* procs in npfile.c */
BOOL FAR  SaveFile (HWND hwndParent, TCHAR *szFileSave, BOOL fSaveAs);
BOOL FAR  LoadFile (TCHAR *sz, INT type );
VOID FAR  New (BOOL  fCheck);
void FAR  AddExt (TCHAR *sz);
INT FAR   Remove (LPTSTR szFileName);
VOID FAR  AlertUser_FileFail( LPTSTR szFileName );

/* procs in npinit.c */
INT FAR  SPInit (HANDLE hInstance, HANDLE hPrevInstance,
                 LPTSTR lpCmdLine, INT cmdShow);
void FAR InitLocale (VOID);
void SaveGlobals( VOID );

/* procs in npmisc.c */
INT FAR  FindDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL     Search (TCHAR *szSearch);
INT FAR  AboutDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL FAR NpReCreate (LONG style);
LPTSTR   ForwardScan (LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive);


/* procs in npprint.c */
typedef enum _PRINT_DIALOG_TYPE {
   UseDialog,
   DoNotUseDialog,
   NoDialogNonDefault
} PRINT_DIALOG_TYPE;

INT    AbortProc( HDC hPrintDC, INT reserved );
INT_PTR AbortDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
INT    NpPrint( PRINT_DIALOG_TYPE type );
INT    NpPrintGivenDC( HDC hPrintDC );

UINT_PTR
CALLBACK
PageSetupHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

HANDLE GetPrinterDC (VOID);
HANDLE GetNonDefPrinterDC (VOID);
VOID   PrintIt(PRINT_DIALOG_TYPE type);


/* procs in nputf.c */

INT    IsTextUTF8   (LPSTR lpstrInputStream, INT iLen);
INT    IsInputTextUnicode(LPSTR lpstrInputStream, INT iLen);



// Help IDs for Sxspad

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_PAGE_FOOTER                 1000
#define IDH_PAGE_HEADER                 1001
#define IDH_FILETYPE                    1002
#define IDH_GOTO                        1003

// Private message to track the HKL switch

#define PWM_CHECK_HKL                   (WM_APP + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxspad\sxspadinit.c ===
/*
 *   SxSpad application
 *
 *      Copyright (C) 1984-2000 Microsoft Inc.
 *
 *      SPInit - One time init for sxspad.
 *               Routines are in a separate segment.
 */

#include "precomp.h"


TCHAR chPageText[2][PT_LEN];    /* Strings to hold PageSetup items.        */
TCHAR chPageTextTemp[2][PT_LEN];
TCHAR szPrinterName[256];       /* String to hold printername for PrintTo verb */

static SP_FILETYPE fInitFileType;     /* file type override                      */
static INT fSavePageSettings=0;       /* if true, save page settings in registry */
static INT fSaveWindowPositions=0;    /* true if we are to save window position  */

static INT g_WPtop,g_WPleft,g_WPDX,g_WPDY;   /* initial window positions          */

/* routines to handle saving and restoring information in the registry.
 *
 * SaveGlobals - saves interesting globals to the registry
 *
 * GetGlobals  - gets interesting globals from the registry
 *
 * Interesting Globals:
 *
 * FontStruct information include calculated pointsize
 * Codepage
 *
 * If we want to save PageSetup info, save the margins in some
 * units (cm for example) and convert on input and output.
 */

/* name of section to save into -- never internationalize */
#define OURKEYNAME TEXT("Software\\Microsoft\\Sxspad")

// RegWriteInt - write an integer to the registry

VOID RegWriteInt( HKEY hKey, PTCHAR pszKey, INT iValue )
{
    RegSetValueEx( hKey, pszKey, 0, REG_DWORD, (BYTE*)&iValue, sizeof(INT) );
}

// RegWriteString - write a string to the registry

VOID RegWriteString( HKEY hKey, PTCHAR pszKey, PTCHAR pszValue )
{
    INT len;     // length of string with null in bytes

    len= (lstrlen( pszValue )+1) * sizeof(TCHAR);
    RegSetValueEx( hKey, pszKey, 0, REG_SZ, (BYTE*)pszValue, len );
}

// RegGetInt - Get integer from registry

DWORD RegGetInt( HKEY hKey, PTCHAR pszKey, DWORD dwDefault )
{
    DWORD dwResult= !ERROR_SUCCESS;
    LONG  lStatus= ERROR_SUCCESS;
    DWORD dwSize= sizeof(DWORD);
    DWORD dwType= 0;

    if( hKey )
    {
        lStatus= RegQueryValueEx( hKey,
                                  pszKey,
                                  NULL,
                                  &dwType,
                          (BYTE*) &dwResult,
                                  &dwSize );
    }

    if( lStatus != ERROR_SUCCESS || dwType != REG_DWORD )
    {
        dwResult= dwDefault;
    }
    return( dwResult );
}

// RegGetString - get string from registry

VOID RegGetString( HKEY hKey, PTCHAR pszKey, PTCHAR pszDefault, PTCHAR pszResult, INT iCharLen )
{
    LONG  lStatus= !ERROR_SUCCESS;
    DWORD dwSize;      // size of buffer
    DWORD dwType;

    dwSize= iCharLen * sizeof(TCHAR);

    if( hKey )
    {
        lStatus= RegQueryValueEx( hKey,
                                  pszKey,
                                  NULL,
                                  &dwType,
                          (BYTE*) pszResult,
                                  &dwSize );
    }

    if( lStatus != ERROR_SUCCESS || dwType != REG_SZ )
    {
        CopyMemory( pszResult, pszDefault, iCharLen*sizeof(TCHAR) );
    }
}


// lfHeight is calculated using PointSize
// lfWidth set by font mapper


VOID SaveGlobals(VOID)
{
    HKEY hKey;    // key to our registry root
    LONG lStatus; // status from RegCreateKey
    WINDOWPLACEMENT wp;

    lStatus= RegCreateKey( HKEY_CURRENT_USER, OURKEYNAME, &hKey );
    if( lStatus != ERROR_SUCCESS )
    {
        return;   // just return quietly
    }

    RegWriteInt( hKey, TEXT("lfEscapement"),     FontStruct.lfEscapement);
    RegWriteInt( hKey, TEXT("lfOrientation"),    FontStruct.lfOrientation);
    RegWriteInt( hKey, TEXT("lfWeight"),         FontStruct.lfWeight);
    RegWriteInt( hKey, TEXT("lfItalic"),         FontStruct.lfItalic);
    RegWriteInt( hKey, TEXT("lfUnderline"),      FontStruct.lfUnderline);
    RegWriteInt( hKey, TEXT("lfStrikeOut"),      FontStruct.lfStrikeOut);
    RegWriteInt( hKey, TEXT("lfCharSet"),        FontStruct.lfCharSet);
    RegWriteInt( hKey, TEXT("lfOutPrecision"),   FontStruct.lfOutPrecision);
    RegWriteInt( hKey, TEXT("lfClipPrecision"),  FontStruct.lfClipPrecision);
    RegWriteInt( hKey, TEXT("lfQuality"),        FontStruct.lfQuality);
    RegWriteInt( hKey, TEXT("lfPitchAndFamily"), FontStruct.lfPitchAndFamily);
    RegWriteInt( hKey, TEXT("iPointSize"),       iPointSize);
    RegWriteInt( hKey, TEXT("fWrap"),            fWrap);
    RegWriteInt( hKey, TEXT("fSavePageSettings"),fSavePageSettings );
    RegWriteInt( hKey, TEXT("fSaveWindowPositions"),fSaveWindowPositions );

    RegWriteString( hKey, TEXT("lfFaceName"), FontStruct.lfFaceName);

    if( fSavePageSettings )
    {
        RegWriteString( hKey, TEXT("szHeader"),  chPageText[HEADER] );
        RegWriteString( hKey, TEXT("szTrailer"), chPageText[FOOTER] );
        RegWriteInt( hKey, TEXT("iMarginTop"),    g_PageSetupDlg.rtMargin.top );
        RegWriteInt( hKey, TEXT("iMarginBottom"), g_PageSetupDlg.rtMargin.bottom );
        RegWriteInt( hKey, TEXT("iMarginLeft"),   g_PageSetupDlg.rtMargin.left );
        RegWriteInt( hKey, TEXT("iMarginRight"),  g_PageSetupDlg.rtMargin.right );
    }

    wp.length= sizeof(wp);

    if( GetWindowPlacement( hwndSP, &wp ) )
    {
        RegWriteInt( hKey, TEXT("iWindowPosX"), wp.rcNormalPosition.left);
        RegWriteInt( hKey, TEXT("iWindowPosY"), wp.rcNormalPosition.top);
        RegWriteInt( hKey, TEXT("iWindowPosDX"), wp.rcNormalPosition.right - wp.rcNormalPosition.left);
        RegWriteInt( hKey, TEXT("iWindowPosDY"), wp.rcNormalPosition.bottom - wp.rcNormalPosition.top);
    }

    RegCloseKey( hKey );
}


// GetGlobals
//
// Pick up font information etc that may be saved in the registry.
//
// We are called pretty early in setup and don't have things like hwndSP valid yet.
//

VOID GetGlobals( VOID )
{
    LOGFONT lfDef;          // default logical font
    HFONT   hFont;          // standard font to use
    LONG    lStatus;        // status from RegCreateKey
    HKEY    hKey;           // key into registry

    //
    // quickly get a reasonable set of default parameters
    // for the default font if we need it.
    //

    hFont= GetStockObject( SYSTEM_FIXED_FONT );

    GetObject( hFont, sizeof(LOGFONT), &lfDef );

    lStatus= RegCreateKey( HKEY_CURRENT_USER, OURKEYNAME, &hKey );
    if( lStatus != ERROR_SUCCESS )
    {
        hKey= NULL;   // later calls to RegGet... will return defaults
    }
    FontStruct.lfWidth= 0;



    FontStruct.lfEscapement=     (LONG)RegGetInt( hKey, TEXT("lfEscapement"),     lfDef.lfEscapement);
    FontStruct.lfOrientation=    (LONG)RegGetInt( hKey, TEXT("lfOrientation"),    lfDef.lfOrientation);
    FontStruct.lfWeight=         (LONG)RegGetInt( hKey, TEXT("lfWeight"),         lfDef.lfWeight);
    FontStruct.lfItalic=         (BYTE)RegGetInt( hKey, TEXT("lfItalic"),         lfDef.lfItalic);
    FontStruct.lfUnderline=      (BYTE)RegGetInt( hKey, TEXT("lfUnderline"),      lfDef.lfUnderline);
    FontStruct.lfStrikeOut=      (BYTE)RegGetInt( hKey, TEXT("lfStrikeOut"),      lfDef.lfStrikeOut);

    //
    // We have to preserve lfCharSet because some fonts (symbol, marlett) don't handle
    // 0 (ANSI_CHARSET) or 1 (DEFAULT_CHARSET), and the font mapper will map to a
    // different facename.  Later we will see if the CreateFont has the same FaceName
    // and get a more appropriate lfCharSet if need be.
    //

    FontStruct.lfCharSet=        (BYTE)RegGetInt( hKey, TEXT("lfCharSet"),        lfDef.lfCharSet);

    FontStruct.lfOutPrecision=   (BYTE)RegGetInt( hKey, TEXT("lfOutPrecision"),   lfDef.lfOutPrecision);
    FontStruct.lfClipPrecision=  (BYTE)RegGetInt( hKey, TEXT("lfClipPrecision"),  lfDef.lfClipPrecision);
    FontStruct.lfQuality=        (BYTE)RegGetInt( hKey, TEXT("lfQuality"),        lfDef.lfQuality);
    FontStruct.lfPitchAndFamily= (BYTE)RegGetInt( hKey, TEXT("lfPitchAndFamily"), lfDef.lfPitchAndFamily);

    //
    // If there is no FaceName in the registry, use the default "Lucida Console"
    // This will show off most of the glyphs except in the FE locales.
    // For FE, we can't font link fonts with the glyphs because they would have to have
    // the exact width as lucida console, or the console/csrss will AV (July 9, 1999)
    //

    RegGetString( hKey, TEXT("lfFaceName"), TEXT("Lucida Console"), FontStruct.lfFaceName, LF_FACESIZE);

    iPointSize= RegGetInt( hKey, TEXT("iPointSize"), 100);
    fWrap=      RegGetInt( hKey, TEXT("fWrap"),      0);
    fSavePageSettings= RegGetInt( hKey, TEXT("fSavePageSettings"), 0 );
    fSaveWindowPositions= RegGetInt( hKey, TEXT("fSaveWindowPositions"), 0 );

    // if page settings not in registry, we will use defaults

    RegGetString( hKey, TEXT("szHeader"),  chPageText[HEADER], chPageText[HEADER], PT_LEN );
    RegGetString( hKey, TEXT("szTrailer"), chPageText[FOOTER], chPageText[FOOTER], PT_LEN );

    g_PageSetupDlg.rtMargin.top=    (LONG)RegGetInt( hKey, TEXT("iMarginTop"),    g_PageSetupDlg.rtMargin.top );
    g_PageSetupDlg.rtMargin.bottom= (LONG)RegGetInt( hKey, TEXT("iMarginBottom"), g_PageSetupDlg.rtMargin.bottom );
    g_PageSetupDlg.rtMargin.left=   (LONG)RegGetInt( hKey, TEXT("iMarginLeft"),   g_PageSetupDlg.rtMargin.left );
    g_PageSetupDlg.rtMargin.right=  (LONG)RegGetInt( hKey, TEXT("iMarginRight"),  g_PageSetupDlg.rtMargin.right );

    // if window positions in registry use them, otherwise us defaults

    g_WPtop=  RegGetInt( hKey, TEXT("iWindowPosY"),  CW_USEDEFAULT );
    g_WPleft= RegGetInt( hKey, TEXT("iWindowPosX"),  CW_USEDEFAULT );
    g_WPDX=   RegGetInt( hKey, TEXT("iWindowPosDX"), CW_USEDEFAULT );
    g_WPDY=   RegGetInt( hKey, TEXT("iWindowPosDY"), CW_USEDEFAULT );



    if( hKey )
    {
        RegCloseKey( hKey );
    }

}

/*
 * lstrncmpi( str1, str2, len )
 * compares two strings, str1 and str2, up
 * to length 'len' ignoring case.  If they
 * are equal, we will return 0.  Otherwise not 0.
 */

static
INT lstrncmpi( PTCHAR sz1, PTCHAR sz2 )
{
    TCHAR ch1, ch2;
    while( *sz1 )
    {
        ch1= (TCHAR) (INT_PTR) CharUpper( (LPTSTR) (INT_PTR) *sz1++ );
        ch2= (TCHAR) (INT_PTR) CharUpper( (LPTSTR) (INT_PTR) *sz2++ );
        if( ch1 != ch2 )
            return 1;
    }
    return 0;                // they are equal
}

static int SPRegister (HANDLE hInstance);

/* GetFileName
 *
 * Parse off filename from command line and put
 * into lpFileName
 */

LPTSTR GetFileName( LPTSTR lpFileName, LPTSTR lpCmdLine )
{
   LPTSTR lpTemp = lpFileName;
   HANDLE hFindFile;
   WIN32_FIND_DATA info;

   /*
   ** Allow for filenames surrounded by double and single quotes
   ** like in longfilenames.
   */
   if( *lpCmdLine == TEXT('\"') || *lpCmdLine == TEXT('\'') )
   {
      TCHAR chMatch = *lpCmdLine;
      DWORD dwSize=0;

      // Copy over filename
      while( *(++lpCmdLine) && (*lpCmdLine != chMatch) && (dwSize<MAX_PATH) )
      {
         *lpTemp++ = *lpCmdLine;
         dwSize++;
      }

      // NULL terminate the filename (no embedded quotes allowed in filenames)
      *lpTemp = TEXT('\0');
   }
   else
   {
      lstrcpyn(lpFileName, lpCmdLine,MAX_PATH);
   }

   /*
   ** Check to see if the unaltered filename exists.  If it does then don't
   ** append a default extension.
   */
   hFindFile= FindFirstFile( lpFileName, &info );

   if( hFindFile != INVALID_HANDLE_VALUE )
   {
      FindClose( hFindFile );
   }
   else
   {
      /*
      ** Add default extension and try again
      */
      AddExt( lpFileName );

      hFindFile= FindFirstFile( lpFileName, &info );

      if( hFindFile != INVALID_HANDLE_VALUE )
      {
         FindClose( hFindFile );
      }
   }

   // return the pointer to the end of the filename.
   return lpCmdLine;
}

/* SizeStrings - Get the total size of the resource strings   */
/* returns size in 'chars' or zero if failure                 */
/* we do this in case the international people really change  */
/* the size of resources.                                     */

/* Read all the strings into a buffer to size them.  Since we  */
/* don't know the maximum size of string resource, we may have */
/* to change the size of the read buffer.  This is done with   */
/* a simple doubling algorithm.                                */

INT SizeStrings(HANDLE hInstance)
{
    INT    iElementSize=256;  // current max size of string
    INT    total;             // total size of resources
    PTCHAR Buf;               // buffer to try putting resources into
    INT    ids;               // identifier number for resource
    INT    len;               // length of one resource

    while( 1 )   // keep looping til all strings can be read
    {
        if( !(Buf= LocalAlloc( LPTR, ByteCountOf(iElementSize) ) ) )
            return 0;    // failure
        for( ids=0, total=0; ids < CSTRINGS; ids++ )
        {
            len= LoadString( hInstance, (UINT) (UINT_PTR) (*rgsz[ids]), Buf, iElementSize );

            if( len >= iElementSize-1 )
            {
                #if DBG
                    ODS(TEXT("sxspad: resource string too long!\n"));
                #endif
                break;
            }
            total += len+1;  // account for null terminator
        }
        LocalFree( Buf );
        if( ids >= CSTRINGS )
            break;
        iElementSize= iElementSize*2;
    }
    return( total );
}


/* InitStrings - Get all text strings from resource file */
BOOL InitStrings (HANDLE hInstance)
{
    TCHAR*   pch;
    INT      cchRemaining;
    INT      ids, cch;

    // allocate memory and lock it down forever.  we have pointers into it.
    // the localrealloc() function will not work well for freeing
    // unused memory because it may (and did) move memory.

    cchRemaining= SizeStrings( hInstance );
    if( !cchRemaining )
        return( FALSE );       // fail because we are out of memory

    pch= LocalAlloc( LPTR, ByteCountOf(cchRemaining) );
    if( !pch )
        return( FALSE );

    cchRemaining= (INT)LocalSize( pch ) / sizeof(TCHAR);
    if( cchRemaining == 0 )    // can't alloc memory - failure
        return( FALSE );

    for( ids = 0; ids < CSTRINGS; ids++ )
    {
       cch= 1 + LoadString( hInstance, (UINT) (UINT_PTR) (*rgsz[ids]), pch, cchRemaining );
       *rgsz[ids]= pch;
       pch += cch;

       if( cch > cchRemaining )   // should never happen
       {
           MessageBox( NULL, TEXT("Out of RC string space!!"),
                      TEXT("DEV Error!"), MB_OK);
           return( FALSE );
       }

       cchRemaining -= cch;
    }

    /* Get header and footer strings */

    lstrcpyn( chPageText[HEADER], szHeader, PT_LEN );
    lstrcpyn( chPageText[FOOTER], szFooter, PT_LEN );

    chMerge= *szMerge;
    return (TRUE);
}

/*
 * SkipBlanks( pszText )
 * skips blanks or tabs to either next character or EOL
 * returns pointer to same.
 */
PTCHAR SkipBlanks( PTCHAR pszText )
{
    while( *pszText == TEXT(' ') || *pszText == TEXT('\t') )
        pszText++;

    return pszText;
}


// if /.SETUP option exists in the command line process it.
BOOL ProcessSetupOption (LPTSTR lpszCmdLine)
{
    INT iSta= 0;
    /* Search for /.SETUP in the command line */
    if( !lstrncmpi( TEXT("/.SETUP"), lpszCmdLine ) )
    {
        fRunBySetup = TRUE;
        /* Save system menu handle for INITMENUPOPUP message */
        hSysMenuSetup =GetSystemMenu(hwndSP, FALSE);
        /* Allow exit on ^C, ^D and ^Z                      */
        /* Note that LoadAccelerators must be called before */
        /* TranslateAccelerator is called, true here        */
        hAccel = LoadAccelerators(hInstanceSP, TEXT("SlipUpAcc"));
        lpszCmdLine += 7;
    }
    else
        return FALSE;

    /* Don't offer a minimize button */
    SetWindowLong( hwndSP, GWL_STYLE,
                   WS_OVERLAPPED | WS_CAPTION     | WS_SYSMENU     |
                   WS_THICKFRAME |                  WS_MAXIMIZEBOX |
                   WS_VSCROLL    | WS_HSCROLL);

    /* skip blanks again to get to filename */
    lpszCmdLine= SkipBlanks( lpszCmdLine );

    if (*lpszCmdLine)
    {
        /* Get the filename. */
        GetFileName(szFileName, lpszCmdLine);

        fp= CreateFile( szFileName,             // filename
                        GENERIC_READ,           // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE, // share mode
                        NULL,                   // security descriptor
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  //file attributes
                        NULL);                  // hnd of file attrs

        if( fp == INVALID_HANDLE_VALUE )
        {
           DWORD dwErr;

           // Check GetLastError to see why we failed
           dwErr = GetLastError ();
           switch (dwErr)
           {
              case ERROR_ACCESS_DENIED:
                 iSta= AlertBox( hwndSP, szNN, szACCESSDENY, szFileName,
                           MB_APPLMODAL | MB_OKCANCEL | MB_ICONEXCLAMATION);
                 break;

              case ERROR_FILE_NOT_FOUND:
                 iSta= AlertBox(hwndSP, szNN, szFNF, szFileName,
                      MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONEXCLAMATION);
                 if( iSta == IDYES )
                 {
                    fp= CreateFile( szFileName,            // filename
                                    GENERIC_READ|GENERIC_WRITE,  // access
                                    FILE_SHARE_READ|FILE_SHARE_WRITE, // share
                                    NULL,                  // security descrp
                                    OPEN_ALWAYS,           // how to create
                                    FILE_ATTRIBUTE_NORMAL, // file attributes
                                    NULL);                 // hnd of file attrs
                 }
                 break;

              case ERROR_INVALID_NAME:
                 iSta= AlertBox( hwndSP, szNN, szNVF, szFileName,
                           MB_APPLMODAL | MB_OKCANCEL | MB_ICONEXCLAMATION);
                 break;

              default:
                 iSta= AlertBox(hwndSP, szNN, szDiskError, szFileName,
                          MB_APPLMODAL | MB_OKCANCEL | MB_ICONEXCLAMATION);
                 break;
           }
        }

        if (fp == INVALID_HANDLE_VALUE)
           return (FALSE);
        LoadFile(szFileName, fInitFileType );    // load setup file
    }

    if( iSta == IDCANCEL )
       return( IDCANCEL );
    else
       return( IDYES );
}

/*
 * ProcessShellOptions(lpszCmdLine)
 *
 * If the command line has any options specified by the shell
 * process them.
 * Currently /P <filename> - prints the given file
 *           /PT "filename" "printer name" "Driver dll" "port"
 */
BOOL ProcessShellOptions (LPTSTR lpszCmdLine, int cmdShow)
{
    BOOL   bDefPrinter = TRUE;
    LPTSTR lpszAfterFileName;
    INT    i = 0;


    // Is it PrintTo ?
    if( lstrncmpi( TEXT("/PT"), lpszCmdLine ) == 0)
    {
        lpszCmdLine= SkipBlanks( lpszCmdLine+3 );
        bDefPrinter = FALSE;
    }
    // Or is it Print ?
    else if ( lstrncmpi( TEXT("/P"), lpszCmdLine ) == 0)
    {
        lpszCmdLine= SkipBlanks( lpszCmdLine+2 );
    }
    else
        return FALSE;

    if (!*lpszCmdLine)
       return FALSE;

/* Added as per Bug #10923 declaring that the window should show up
 * and then the printing should begin.   29 July 1991  Clark Cyr
 */
    ShowWindow(hwndSP, cmdShow);

    /* Get the filename; have the pointer to the end of the filename */
    lpszAfterFileName= GetFileName (szFileName, lpszCmdLine) + 1;

    if (!bDefPrinter)
    {
        /* extract the printer name from the command line. */
        if (!*lpszAfterFileName)
            return FALSE;

        lpszAfterFileName = SkipBlanks( lpszAfterFileName );

        /* (since we are passing multiple arguments here, the filename, */
        /* the printername have to be in quotes. */
        if( *lpszAfterFileName != TEXT('\"') )
            return FALSE;

        // Copy over printername
        while( *(++lpszAfterFileName) && *lpszAfterFileName != TEXT('\"') )
        {
            szPrinterName[i++] = *lpszAfterFileName;
        }

        // NULL terminate the printername (no embedded quotes allowed in printernames)
        szPrinterName[i] = TEXT('\0');
    }


    fp= CreateFile( szFileName,             // filename
                    GENERIC_READ,           // access mode
                    FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                    NULL,                   // security descriptor
                    OPEN_EXISTING,          // how to create
                    FILE_ATTRIBUTE_NORMAL,  // file attributes
                    NULL);                  // hnd of file attrs to copy

    if( fp == INVALID_HANDLE_VALUE )
    {
       TCHAR* pszMsg;

       // select reasonable error message based on GetLastError

       switch( GetLastError() )
       {
          case ERROR_ACCESS_DENIED:
          case ERROR_NETWORK_ACCESS_DENIED:
              pszMsg= szACCESSDENY;
              break;

          case ERROR_FILE_NOT_FOUND:
              pszMsg= szFNF;
              break;

          case ERROR_INVALID_NAME:
              pszMsg= szNVF;
              break;

          default:
              pszMsg= szDiskError;
              break;
       }

       AlertBox(hwndSP, szNN, pszMsg, szFileName,
                 MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
       return (TRUE);
    }

    /* load the file into the edit control */
    LoadFile( szFileName, fInitFileType );         // get print file


    /* print the file */

    if (bDefPrinter)
    {
        PrintIt( DoNotUseDialog );
    }
    else
    {
        PrintIt( NoDialogNonDefault );
    }


    return (TRUE);
}

/* CreateFilter
 *
 * Creates filters for GetOpenFileName.
 *
 */

VOID CreateFilter(PTCHAR szFilterSpec )
{
    PTCHAR pszFilterSpec;

    /* construct default filter string in the required format for
     * the new FileOpen and FileSaveAs dialogs
     * if you add to this, make sure CCHFILTERMAX is large enough.
     */

    // .Manifest first for compatibility
    pszFilterSpec= szFilterSpec;
    lstrcpy( pszFilterSpec, szAnsiText );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    lstrcpy( pszFilterSpec, TEXT("*.Manifest"));
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    // and last, all files
    lstrcpy( pszFilterSpec, szAllFiles );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.*") );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    *pszFilterSpec = TEXT('\0');

}

// EnumProc
//
// Callback function for EnumFonts
//
// Purpose: sets lfCharSet in passed logfont to a valid lfCharSet
//          and terminates enumeration.
//

int CALLBACK EnumProc(
    LOGFONT*     pLf,
    TEXTMETRIC*  pTm,
    DWORD        dwType,
    LPARAM       lpData )
{

    ((LOGFONT*) lpData)-> lfCharSet= pLf->lfCharSet;

    return( 0 );  // stop enumeration
}


/* One time initialization */
INT FAR SPInit (HANDLE hInstance, HANDLE hPrevInstance,
                LPTSTR lpCmdLine, INT cmdShow)
{
    HDC    hDisplayDC;     /* screen DC                */
    RECT   rcT1;           /* for sizing edit window   */
    INT    iSta;
    WINDOWPLACEMENT wp;    /* structure to place window at the correct position */


    /* determine the message number to be used for communication with
     * Find dialog
     */
    if (!(wFRMsg = RegisterWindowMessage ((LPTSTR)FINDMSGSTRING)))
         return FALSE;
    if (!(wHlpMsg = RegisterWindowMessage ((LPTSTR)HELPMSGSTRING)))
         return FALSE;

    /* open a global DC to the display */

    hDisplayDC= GetDC(NULL);
    if( !hDisplayDC )
        return FALSE;

    /* Go load strings */
    if (!InitStrings (hInstance))
        return FALSE;

    InitLocale();     // localize strings etc.

    /* Load the arrow and hourglass cursors. */
    hStdCursor= LoadCursor( NULL,
           (LPTSTR) (INT_PTR) (GetSystemMetrics(SM_PENWINDOWS) ? IDC_ARROW : IDC_IBEAM ));
    hWaitCursor= LoadCursor( NULL, IDC_WAIT );

    /* Load accelerators. */
    hAccel= LoadAccelerators(hInstance, TEXT("MainAcc"));
    if( !hWaitCursor || !hAccel )
        return FALSE;

    if( !hPrevInstance )
    {
       if( !SPRegister( hInstance ) )
          return (FALSE);
    }

    hInstanceSP= hInstance;

    /* init. fields of PRINTDLG struct.. */
    /* Inserted here since command line print statements are valid. */
    g_PageSetupDlg.lStructSize   = sizeof(PAGESETUPDLG);
    g_PageSetupDlg.hDevMode      = NULL;
    g_PageSetupDlg.hDevNames     = NULL;
    g_PageSetupDlg.hInstance     = hInstance;
    SetPageSetupDefaults();

    //
    // Pick up information saved in registry
    //

    GetGlobals();


    hwndSP= CreateWindow(  szSxspad,
                           TEXT(""),
                           WS_OVERLAPPED | WS_CAPTION     | WS_SYSMENU     |
                           WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | 0,
                           g_WPleft,     // x
                           g_WPtop,      // y
                           g_WPDX,       // width
                           g_WPDY,       // height
                           (HWND)NULL,   // parent or owner
                           (HMENU)NULL,  // menu or child window
                           hInstance,    // application instance
                           NULL);        // window creation data

    g_PageSetupDlg.hwndOwner     = hwndSP;

    if( !hwndSP )
        return FALSE;

    // On multimon machines, the previous position stored of sxspad may
    // not be in the display area. call SetWindowPlacement to fix this.

    // If the information specified in WINDOWPLACEMENT would result in a window
    // that is completely off the screen, the system will automatically adjust
    // the coordinates so that the window is visible, taking into account
    // changes in screen resolution and multiple monitor configuration.

    // g_WPDX and g_WPDY are CW_USEDEFAULT when sxspad is started for the
    // first time on the user machine.
    if (g_WPDX != CW_USEDEFAULT && g_WPDY != CW_USEDEFAULT)
    {
        memset(&wp, 0, sizeof(wp));
        wp.length = sizeof(wp);
        wp.rcNormalPosition.left = g_WPleft;
        wp.rcNormalPosition.right = g_WPleft + g_WPDX;
        wp.rcNormalPosition.top = g_WPtop;
        wp.rcNormalPosition.bottom = g_WPtop + g_WPDY;

        // don't check the return value; if this call fails for any reason,
        // just go on with the position of the sxspad in the above CreateWindow() call.
        SetWindowPlacement(hwndSP, &wp);
    }

    /* File Drag Drop support added 03/26/91 - prototype only. w-dougw   */
    /* All processing of drag/drop files is done the under WM_DROPFILES  */
    /* message.                                                          */
    DragAcceptFiles( hwndSP,TRUE ); /* Process dragged and dropped files. */


    GetClientRect( hwndSP, (LPRECT) &rcT1 );

    if (!(hwndEdit = CreateWindowEx(WS_EX_CLIENTEDGE,
                     TEXT("Edit"), TEXT(""),
                     (fWrap) ? ES_STD : (ES_STD | WS_HSCROLL),
                     0, 0, rcT1.right, rcT1.bottom,
                     hwndSP, (HMENU)ID_EDIT, hInstance, (LPVOID)NULL)))
        return FALSE;


    // handle word wrap now if set in registry

    SendMessage( hwndEdit, EM_FMTLINES, fWrap, 0L );  // tell MLE

    FontStruct.lfHeight= -MulDiv(iPointSize,
                                 GetDeviceCaps(hDisplayDC,LOGPIXELSY),
                                 720);
    hFont= CreateFontIndirect( &FontStruct );

    //
    // Make sure the font mapper gives us the same face name.
    //
    // If the locale changes, a font that use to work just fine gets mapped to
    // a different facename because of support for the charset does not exist
    // in the new locale.
    //
    // In this case, we will find one lfCharSet that does exist for this FaceName
    // and use that for the CreateFontIndirect.
    //

    {
        HFONT hPrev;
        TCHAR szTextFace[LF_FACESIZE];

        // Get the facename that was really used.

        hPrev= SelectObject( hDisplayDC, hFont );
        GetTextFace( hDisplayDC, sizeof(szTextFace)/sizeof(TCHAR), (LPTSTR) &szTextFace );
        SelectObject( hDisplayDC, hPrev );

        // if not the same, get a lfCharSet that does exist in this font

        if( lstrcmpi( szTextFace, FontStruct.lfFaceName ) != 0 )
        {
            EnumFonts( hDisplayDC, FontStruct.lfFaceName, (FONTENUMPROC) EnumProc, (LPARAM) &FontStruct );
            DeleteObject( hFont );

            hFont= CreateFontIndirect( &FontStruct );
        }
    }

    SendMessage (hwndEdit, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(FALSE, 0));
    ReleaseDC( NULL, hDisplayDC );

    /* we will not verify that a unicode font is available until
    ** we actually need it.  Perhaps we'll get lucky, and only deal
    ** with ascii files.
    */

    szSearch[0] = (TCHAR) 0;
    /*
     * Win32s does not allow local memory handles to be passed to Win3.1.
     * So, hEdit is used for transferring text to and from the edit control.
     * Before reading text into it, it must be reallocated to a proper size.
     */
    hEdit = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, ByteCountOf(1));

    /* limit text for safety's sake. */
    PostMessage( hwndEdit, EM_LIMITTEXT, (WPARAM)CCHSPMAX, 0L );

    /* get visible window on desktop; helps taskman  find it */
    SetTitle( szUntitled );
    ShowWindow( hwndSP, cmdShow );
    SetCursor( hStdCursor );

    /* Scan for initial /A or /W to override automatic file typing for
     * 'sxspad /p file' or 'sxspad file'
     */
    lpCmdLine= SkipBlanks( lpCmdLine );
    fInitFileType= FT_UNKNOWN;
    if( !lstrncmpi( TEXT("/A"), lpCmdLine ) )
        fInitFileType= FT_ANSI;
    else if( !lstrncmpi( TEXT("/W"), lpCmdLine ) )
        fInitFileType= FT_UNICODE;

    if( fInitFileType != FT_UNKNOWN )    // skip over option
        lpCmdLine= SkipBlanks( lpCmdLine+2 );

    /* check for /.SETUP option first.
       if /.SETUP absent, check for SHELL options /P
       Whenever a SHELL option is processed, post a WM_CLOSE msg.
       */
    if( iSta= ProcessSetupOption( lpCmdLine ) )
    {
        if( iSta == IDCANCEL )
        {
            return( FALSE );
        }
    }
    else if( ProcessShellOptions( lpCmdLine, cmdShow ) )
    {
        PostMessage( hwndSP, WM_CLOSE, 0, 0L );
        return TRUE;
    }
    else if( *lpCmdLine )
    {
        /* Get the filename. */
        GetFileName( szFileName, lpCmdLine );
        fp= CreateFile( szFileName,             // filename
                        GENERIC_READ,           // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                        NULL,                   // security descriptor
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);                  // hnd of file attrs to copy

        if( fp == INVALID_HANDLE_VALUE )
        {
           // If the file can't be opened, maybe the user wants a new
           // one created.

           if( GetLastError() == ERROR_FILE_NOT_FOUND )
           {
              INT iSta;

              iSta= AlertBox( hwndSP, szNN, szFNF, szFileName,
                     MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONEXCLAMATION);
              if( iSta == IDCANCEL )
              {
                  return( FALSE );
              }

              if( iSta == IDYES )
              {
                 fp= CreateFile( szFileName,            // filename
                                 GENERIC_READ|GENERIC_WRITE,  // access
                                 FILE_SHARE_READ|FILE_SHARE_WRITE, // share
                                 NULL,                  // security descrp
                                 OPEN_ALWAYS,           // how to create
                                 FILE_ATTRIBUTE_NORMAL, // file attributes
                                 NULL);                 // hnd of file attrs
              }

           }
           else
           {
               AlertUser_FileFail(szFileName);
               // now open an untitled file instead of the file that we failed
               // to read.
               SetTitle( szUntitled );
               lstrcpy(szFileName, szUntitled);
           }
        }

        if( fp != INVALID_HANDLE_VALUE )
        {
           LoadFile( szFileName, fInitFileType );   // get file specified on command line
        }
    }

    CreateFilter( szOpenFilterSpec );
    CreateFilter( szSaveFilterSpec );

    /* init. some fields of the OPENFILENAME struct used by fileopen and
     * filesaveas, but NEVER changed.
     */
    memset( &OFN, 0, sizeof(OFN) );
    OFN.lStructSize       = sizeof(OPENFILENAME);
    OFN.hwndOwner         = hwndSP;
    OFN.nMaxFile          = MAX_PATH;
    OFN.hInstance         = hInstance;

    /* init.fields of the FINDREPLACE struct used by FindText() */
    memset( &FR, 0, sizeof(FR) );
    FR.lStructSize        = sizeof(FINDREPLACE);       /* Don't hard code it */
    FR.hwndOwner          = hwndSP;


    /* Force a scroll to current selection (which could be at eof if
       we loaded a log file.) */
    {
       DWORD  dwStart, dwEnd;

       SendMessage( hwndEdit, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd );
       SendMessage( hwndEdit, EM_SETSEL, dwStart, dwEnd );
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
    }



    if (PRIMARYLANGID(LOWORD((DWORD) (INT_PTR) GetKeyboardLayout(0))) == LANG_JAPANESE) {
        /*
         * If current HKL is Japanese, handle the result string at once.
         */
        SendMessage(hwndEdit, EM_SETIMESTATUS,
                                EMSIS_COMPOSITIONSTRING, EIMES_GETCOMPSTRATONCE);
    }

     return TRUE;
}

/* ** Sxspad class registration proc */
BOOL SPRegister (HANDLE hInstance)
{
    WNDCLASSEX   SPClass;
    PWNDCLASSEX  pSPClass = &SPClass;

/* Bug 12191: If Pen Windows is running, make the background cursor an
 * arrow instead of the edit control ibeam.  This way the user will know
 * where they can use the pen for writing vs. what will be considered a
 * mouse action.   18 October 1991       Clark Cyr
 */
    pSPClass->cbSize        = sizeof(SPClass);
    pSPClass->hCursor       = LoadCursor(NULL, GetSystemMetrics(SM_PENWINDOWS)
                                               ? IDC_ARROW : IDC_IBEAM);
    pSPClass->hIcon         = LoadIcon(hInstance,
                                      (LPTSTR) MAKEINTRESOURCE(ID_ICON));

    pSPClass->hIconSm       = LoadImage(hInstance,
                                        MAKEINTRESOURCE(ID_ICON),
                                        IMAGE_ICON, 16, 16,
                                        LR_DEFAULTCOLOR);
    pSPClass->lpszMenuName  = (LPTSTR) MAKEINTRESOURCE(ID_MENUBAR);
    pSPClass->hInstance     = hInstance;
    pSPClass->lpszClassName = szSxspad;
    pSPClass->lpfnWndProc   = SPWndProc;
    pSPClass->hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    pSPClass->style         = 0; // was CS_BYTEALIGNCLIENT (obsolete)
    pSPClass->cbClsExtra    = 0;
    pSPClass->cbWndExtra    = 0;

    if (!RegisterClassEx((LPWNDCLASSEX)pSPClass))
        return (FALSE);

    return (TRUE);
}


/* Get Locale info from the Registry, and initialize global vars  */

void FAR InitLocale (void)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxspad\sxspadprint.c ===
/*
 * npprint.c -- Code for printing from sxspad.
 * Copyright (C) 1984-2000 Microsoft Inc.
 */

#define NOMINMAX
#include "precomp.h"

//#define DBGPRINT

/* indices into chBuff */
#define LEFT   0
#define CENTER 1
#define RIGHT  2

INT     tabSize;                    /* Size of a tab for print device in device units*/
HWND    hAbortDlgWnd;
INT     fAbort;                     /* true if abort in progress      */
INT     yPrintChar;                 /* height of a character          */


RECT rtMargin;

/* left,center and right string for header or trailer */
#define MAXTITLE MAX_PATH
TCHAR chBuff[RIGHT+1][MAXTITLE];

/* date and time stuff for headers */
#define MAXDATE MAX_PATH
#define MAXTIME MAX_PATH
TCHAR szFormattedDate[MAXDATE]=TEXT("Y");   // formatted date (may be internationalized)
TCHAR szFormattedTime[MAXTIME]=TEXT("Y");   // formatted time (may be internaltionalized)
SYSTEMTIME PrintTime;                       // time we started printing


INT xPrintRes;          // printer resolution in x direction
INT yPrintRes;          // printer resolution in y direction
INT yPixInch;           // pixels/inch
INT xPhysRes;           // physical resolution x of paper
INT yPhysRes;           // physical resolution y of paper

INT xPhysOff;           // physical offset x
INT yPhysOff;           // physical offset y

INT dyTop;              // width of top border (pixels)
INT dyBottom;           // width of bottom border
INT dxLeft;             // width of left border
INT dxRight;            // width of right border

INT iPageNum;           // global page number currently being printed

/* define a type for NUM and the base */
typedef long NUM;
#define BASE 100L

/* converting in/out of fixed point */
#define  NumToShort(x,s)   (LOWORD(((x) + (s)) / BASE))
#define  NumRemToShort(x)  (LOWORD((x) % BASE))

/* rounding options for NumToShort */
#define  NUMFLOOR      0
#define  NUMROUND      (BASE/2)
#define  NUMCEILING    (BASE-1)

#define  ROUND(x)  NumToShort(x,NUMROUND)
#define  FLOOR(x)  NumToShort(x,NUMFLOOR)

/* Unit conversion */
#define  InchesToCM(x)  (((x) * 254L + 50) / 100)
#define  CMToInches(x)  (((x) * 100L + 127) / 254)

void     DestroyAbortWnd(void) ;
VOID     TranslateString(TCHAR *);

BOOL CALLBACK AbortProc(HDC hPrintDC, INT reserved)
{
    MSG msg;

    while( !fAbort && PeekMessage((LPMSG)&msg, NULL, 0, 0, TRUE) )
    {
       if( !hAbortDlgWnd || !IsDialogMessage( hAbortDlgWnd, (LPMSG)&msg ) )
       {
          TranslateMessage( (LPMSG)&msg );
          DispatchMessage( (LPMSG)&msg );
       }
    }
    return( !fAbort );

    UNREFERENCED_PARAMETER(hPrintDC);
    UNREFERENCED_PARAMETER(reserved);
}


INT_PTR CALLBACK AbortDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    static HMENU hSysMenu;

    switch( msg )
    {
       case WM_COMMAND:
          fAbort= TRUE;
          DestroyAbortWnd();
          return( TRUE );

       case WM_INITDIALOG:
          hSysMenu= GetSystemMenu( hwnd, FALSE );
          SetDlgItemText( hwnd, ID_FILENAME,
             fUntitled ? szUntitled : PFileInPath(szFileName) );
          SetFocus( hwnd );
          return( TRUE );

       case WM_INITMENU:
          EnableMenuItem( hSysMenu, (WORD)SC_CLOSE, (DWORD)MF_GRAYED );
          return( TRUE );
    }
    return( FALSE );

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
}


/*
 * print out the translated header/footer string in proper position.
 * uses globals xPrintWidth, ...
 *
 * returns 1 if line was printed, otherwise 0.
 */

INT PrintHeaderFooter (HDC hDC, INT nHF)
{
    SIZE    Size;    // to compute the width of each string
    INT     yPos;    // y position to print
    INT     xPos;    // x position to print

    if( *chPageText[nHF] == 0 )   // see if anything to do
        return 0;                // we didn't print

    TranslateString( chPageText[nHF] );

    // figure out the y position we are printing

    if( nHF == HEADER )
        yPos= dyTop;
    else
        yPos= yPrintRes - dyBottom - yPrintChar;

    // print out the various strings
    // N.B. could overprint which seems ok for now

    if( *chBuff[LEFT] )     // left string
    {
        TextOut( hDC, dxLeft, yPos, chBuff[LEFT], lstrlen(chBuff[LEFT]) );
    }

    if( *chBuff[CENTER] )   // center string
    {
        GetTextExtentPoint32( hDC, chBuff[CENTER], lstrlen(chBuff[CENTER]), &Size );
        xPos= (xPrintRes-dxRight+dxLeft)/2 - Size.cx/2;
        TextOut( hDC, xPos, yPos, chBuff[CENTER], lstrlen(chBuff[CENTER]) );
    }

    if( *chBuff[RIGHT] )    // right string
    {
        GetTextExtentPoint32( hDC, chBuff[RIGHT], lstrlen(chBuff[RIGHT]), &Size );
        xPos= xPrintRes - dxRight - Size.cx;
        TextOut( hDC, xPos, yPos, chBuff[RIGHT], lstrlen(chBuff[RIGHT]) );
    }
    return 1;              // we did print something
}
/*
 * GetResolutions
 *
 * Gets printer resolutions.
 * sets globals: xPrintRes, yPrintRes, yPixInch
 *
 */

VOID GetResolutions(HDC hPrintDC)
{
    xPrintRes = GetDeviceCaps( hPrintDC, HORZRES );
    yPrintRes = GetDeviceCaps( hPrintDC, VERTRES );
    yPixInch  = GetDeviceCaps( hPrintDC, LOGPIXELSY );

    xPhysRes  = GetDeviceCaps( hPrintDC, PHYSICALWIDTH );
    yPhysRes  = GetDeviceCaps( hPrintDC, PHYSICALHEIGHT );

    xPhysOff  = GetDeviceCaps( hPrintDC, PHYSICALOFFSETX );
    yPhysOff  = GetDeviceCaps( hPrintDC, PHYSICALOFFSETY );
}

/* GetMoreText
 *
 * Gets the next line of text from the MLE, returning a pointer
 * to the beginning and just past the end.
 *
 * linenum    - index into MLE                                   (IN)
 * pStartText - start of MLE                                     (IN)
 * ppsStr     - pointer to where to put pointer to start of text (OUT)
 * ppEOL      - pointer to where to put pointer to just past EOL (OUT)
 *
 */

VOID GetMoreText( INT linenum, PTCHAR pStartText, PTCHAR* ppsStr, PTCHAR* ppEOL )
{
    INT Offset;        // offset in 'chars' into edit buffer
    INT nChars;        // number of chars in line

    Offset= (INT)SendMessage( hwndEdit, EM_LINEINDEX, linenum, 0 );

    nChars= (INT)SendMessage( hwndEdit, EM_LINELENGTH, Offset, 0 );

    *ppsStr= pStartText + Offset;

    *ppEOL= (pStartText+Offset) + nChars;
}

#ifdef DBGPRINT
TCHAR dbuf[100];
VOID ShowMargins( HDC hPrintDC )
{
    INT xPrintRes, yPrintRes;
    RECT rct;
    HBRUSH hBrush;

    xPrintRes= GetDeviceCaps( hPrintDC, HORZRES );
    yPrintRes= GetDeviceCaps( hPrintDC, VERTRES );
    hBrush= GetStockObject( BLACK_BRUSH );
    SetRect( &rct, 0,0,xPrintRes-1, yPrintRes-1 );
    FrameRect( hPrintDC, &rct, hBrush );
    SetRect( &rct, dxLeft, dyTop, xPrintRes-dxRight, yPrintRes-dyBottom );
    FrameRect( hPrintDC, &rct, hBrush );
}

VOID PrintLogFont( LOGFONT lf )
{
    wsprintf(dbuf,TEXT("lfHeight          %d\n"), lf.lfHeight        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWidth           %d\n"), lf.lfWidth         ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfEscapement      %d\n"), lf. lfEscapement   ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOrientation     %d\n"), lf.lfOrientation   ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWeight          %d\n"), lf.lfWeight        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfItalic          %d\n"), lf.lfItalic        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfUnderline       %d\n"), lf.lfUnderline     ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfStrikeOut       %d\n"), lf.lfStrikeOut     ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfCharSet         %d\n"), lf.lfCharSet       ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOutPrecision    %d\n"), lf.lfOutPrecision  ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfClipPrecison    %d\n"), lf.lfClipPrecision ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfQuality         %d\n"), lf.lfQuality       ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfPitchAndFamily  %d\n"), lf.lfPitchAndFamily); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfFaceName        %s\n"), lf.lfFaceName      ); ODS(dbuf);
}
#endif

// GetPrinterDCviaDialog
//
// Use the common dialog PrintDlgEx() function to get a printer DC to print to.
//
// Returns: valid HDC or INVALID_HANDLE_VALUE if error.
//

HDC GetPrinterDCviaDialog( VOID )
{
    PRINTDLGEX pdTemp;
    HDC hDC;
    HRESULT hRes;

    //
    // Get the page setup information
    //

    if( !g_PageSetupDlg.hDevNames )   /* Retrieve default printer if none selected. */
    {
        g_PageSetupDlg.Flags |= (PSD_RETURNDEFAULT|PSD_NOWARNING );
        PageSetupDlg(&g_PageSetupDlg);
        g_PageSetupDlg.Flags &= ~(PSD_RETURNDEFAULT|PSD_NOWARNING);
    }

    //
    // Initialize the dialog structure
    //

    ZeroMemory( &pdTemp, sizeof(pdTemp) );

    pdTemp.lStructSize= sizeof(pdTemp);

    pdTemp.hwndOwner= hwndSP;
    pdTemp.nStartPage= START_PAGE_GENERAL;
    pdTemp.Flags= PD_NOPAGENUMS  | PD_RETURNDC | PD_NOCURRENTPAGE |
                  PD_NOSELECTION | 0;

    // if use set printer in PageSetup, use it here too.

    if( g_PageSetupDlg.hDevMode )
    {
        pdTemp.hDevMode= g_PageSetupDlg.hDevMode;
    }

    if( g_PageSetupDlg.hDevNames )
    {
        pdTemp.hDevNames= g_PageSetupDlg.hDevNames;
    }


    //
    // let user select printer
    //

    hRes= PrintDlgEx( &pdTemp );

    //
    // get DC if valid return
    //

    hDC= INVALID_HANDLE_VALUE;

    if( hRes == S_OK )
    {
        if( (pdTemp.dwResultAction == PD_RESULT_PRINT) || (pdTemp.dwResultAction == PD_RESULT_APPLY) )
        {
            if( pdTemp.dwResultAction == PD_RESULT_PRINT )
            {
                hDC= pdTemp.hDC;
            }

            //
            // Get the page setup information for the printer selected in case it was
            // the first printer added by the user through sxspad.
            //
            if( !g_PageSetupDlg.hDevMode )
            {
                g_PageSetupDlg.Flags |= (PSD_RETURNDEFAULT|PSD_NOWARNING );
                PageSetupDlg(&g_PageSetupDlg);
                g_PageSetupDlg.Flags &= ~(PSD_RETURNDEFAULT|PSD_NOWARNING);
            }

            // change devmode if user pressed print or apply
            g_PageSetupDlg.hDevMode= pdTemp.hDevMode;
            g_PageSetupDlg.hDevNames= pdTemp.hDevNames;
        }
    }

    // FEATURE: free hDevNames

    return( hDC );
}

INT NpPrint( PRINT_DIALOG_TYPE type)
{
    HDC hPrintDC;

    SetCursor( hWaitCursor );

    switch( type )
    {
        case UseDialog:
            hPrintDC= GetPrinterDCviaDialog();
            break;
        case NoDialogNonDefault:
            hPrintDC= GetNonDefPrinterDC();
            break;
        case DoNotUseDialog:
        default:
            hPrintDC= GetPrinterDC();
            break;
    }

    if( hPrintDC == INVALID_HANDLE_VALUE )
    {
        SetCursor( hStdCursor );
        return( 0 );   // message already given
    }

    return( NpPrintGivenDC( hPrintDC ) );

}

INT NpPrintGivenDC( HDC hPrintDC )
{
    HANDLE     hText= NULL;          // handle to MLE text
    HFONT      hPrintFont= NULL;     // font to print with
    HANDLE     hPrevFont= NULL;      // previous font in hPrintDC

    BOOL       fPageStarted= FALSE;  // true if StartPage called for this page
    BOOL       fDocStarted=  FALSE;  // true if StartDoc called
    PTCHAR     pStartText= NULL;     // start of edit text (locked hText)
    TEXTMETRIC Metrics;
    TCHAR      msgbuf[MAX_PATH];     // Document name for tracking print job
    INT        nLinesPerPage;        // not inc. header and footer
    // iErr will contain the first error discovered ie it is sticky
    // This will be the value returned by this function.
    // It does not need to translate SP_* errors except for SP_ERROR which should be
    // GetLastError() right after it is first detected.
    INT        iErr=0;               // error return
    DOCINFO    DocInfo;
    LOGFONT    lfPrintFont;          // local version of FontStruct
    LCID       lcid;                 // locale id

    fAbort = FALSE;
    hAbortDlgWnd= NULL;

    SetCursor( hWaitCursor );

    GetResolutions( hPrintDC );

    // Get the time and date for use in the header or trailer.
    // We use the GetDateFormat and GetTimeFormat to get the
    // internationalized versions.

    GetLocalTime( &PrintTime );       // use local, not gmt

    lcid= GetUserDefaultLCID();

    GetDateFormat( lcid, DATE_LONGDATE, &PrintTime, NULL, szFormattedDate, MAXDATE );

    GetTimeFormat( lcid, 0,             &PrintTime, NULL, szFormattedTime, MAXTIME );


   /*
    * This part is to select the current font to the printer device.
    * We have to change the height because FontStruct was created
    * assuming the display.  Using the remembered pointsize, calculate
    * the new height.
    */

    lfPrintFont= FontStruct;                          // make local copy
    lfPrintFont.lfHeight= -(iPointSize*yPixInch)/(72*10);
    lfPrintFont.lfWidth= 0;

    //
    // convert margins to pixels
    // ptPaperSize is the physical paper size, not the printable area.
    // do the mapping in physical units
    //

    SetMapMode( hPrintDC, MM_ANISOTROPIC );

    SetViewportExtEx( hPrintDC,
                      xPhysRes,
                      yPhysRes,
                      NULL );

    SetWindowExtEx( hPrintDC,
                    g_PageSetupDlg.ptPaperSize.x,
                    g_PageSetupDlg.ptPaperSize.y,
                    NULL );

    rtMargin = g_PageSetupDlg.rtMargin;

    LPtoDP( hPrintDC, (LPPOINT) &rtMargin, 2 );

    SetMapMode( hPrintDC,MM_TEXT );    // restore to mm_text mode

    hPrintFont= CreateFontIndirect(&lfPrintFont);

    if( !hPrintFont )
    {
        goto ErrorExit;
    }

    hPrevFont= SelectObject( hPrintDC, hPrintFont );
    if( !hPrevFont )
    {
        goto ErrorExit;
    }

    SetBkMode( hPrintDC, TRANSPARENT );
    if( !GetTextMetrics( hPrintDC, (LPTEXTMETRIC) &Metrics ) )
    {
        goto ErrorExit;
    }

    // The font may not a scalable (say on a bubblejet printer)
    // In this case, just pick some font
    // For example, FixedSys 9 pt would be non-scalable

    if( !(Metrics.tmPitchAndFamily & (TMPF_VECTOR | TMPF_TRUETYPE )) )
    {
        // remove just created font

        hPrintFont= SelectObject( hPrintDC, hPrevFont );  // get old font
        DeleteObject( hPrintFont );

        memset( lfPrintFont.lfFaceName, 0, LF_FACESIZE*sizeof(TCHAR) );

        hPrintFont= CreateFontIndirect( &lfPrintFont );
        if( !hPrintFont )
        {
            goto ErrorExit;
        }

        hPrevFont= SelectObject( hPrintDC, hPrintFont );
        if( !hPrevFont )
        {
            goto ErrorExit;
        }

        if( !GetTextMetrics( hPrintDC, (LPTEXTMETRIC) &Metrics ) )
        {
            goto ErrorExit;
        }
    }
    yPrintChar= Metrics.tmHeight+Metrics.tmExternalLeading;  /* the height */

    tabSize = Metrics.tmAveCharWidth * 8; /* 8 ave char width pixels for tabs */

    // compute margins in pixels

    dxLeft=   max(rtMargin.left - xPhysOff,0);
    dxRight=  max(rtMargin.right  - (xPhysRes - xPrintRes - xPhysOff), 0 );
    dyTop=    max(rtMargin.top  - yPhysOff,0);
    dyBottom= max(rtMargin.bottom - (yPhysRes - yPrintRes - yPhysOff), 0 );

#ifdef DBGPRINT
    {
        TCHAR dbuf[100];
        RECT rt= g_PageSetupDlg.rtMargin;
        POINT pt;

        wsprintf(dbuf,TEXT("Print pOffx %d  pOffy %d\n"),
                 GetDeviceCaps(hPrintDC, PHYSICALOFFSETX),
                 GetDeviceCaps(hPrintDC, PHYSICALOFFSETY));
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PHYSICALWIDTH: %d\n"), xPhysRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("HORZRES: %d\n"),xPrintRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PHYSICALOFFSETX: %d\n"),xPhysOff);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("LOGPIXELSX: %d\n"),
                 GetDeviceCaps(hPrintDC,LOGPIXELSX));
        ODS(dbuf);

        GetViewportOrgEx( hPrintDC, (LPPOINT) &pt );
        wsprintf(dbuf,TEXT("Viewport org:  %d %d\n"), pt.x, pt.y );
        ODS(dbuf);
        GetWindowOrgEx( hPrintDC, (LPPOINT) &pt );
        wsprintf(dbuf,TEXT("Window org:  %d %d\n"), pt.x, pt.y );
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PrintRes x: %d  y: %d\n"),xPrintRes, yPrintRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PaperSize  x: %d  y: %d\n"),
                 g_PageSetupDlg.ptPaperSize.x,
                 g_PageSetupDlg.ptPaperSize.y );
        ODS(dbuf);
        wsprintf(dbuf,TEXT("unit margins:  l: %d  r: %d  t: %d  b: %d\n"),
                 rt.left, rt.right, rt.top, rt.bottom);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("pixel margins: l: %d  r: %d  t: %d  b: %d\n"),
                 rtMargin.left, rtMargin.right, rtMargin.top, rtMargin.bottom);
        ODS(dbuf);

        wsprintf(dbuf,TEXT("dxLeft %d  dxRight %d\n"),dxLeft,dxRight);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("dyTop %d  dyBot %d\n"),dyTop,dyBottom);
        ODS(dbuf);
    }
#endif


    /* Number of lines on a page with margins  */
    /* two lines are used by header and footer */
    nLinesPerPage = ((yPrintRes - dyTop - dyBottom) / yPrintChar);

    if( *chPageText[HEADER] )
        nLinesPerPage--;
    if( *chPageText[FOOTER] )
        nLinesPerPage--;


    /*
    ** There was a bug in NT once where a printer driver would
    ** return a font that was larger than the page size which
    ** would then cause sxspad to constantly print blank pages
    ** To keep from doing this we check to see if we can fit ANYTHING
    ** on a page, if not then there is a problem so quit.  MarkRi 8/92
    */
    if( nLinesPerPage <= 0 )
    {
FontTooBig:
        MessageBox( hwndSP, szFontTooBig, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION );

        SetLastError(0);          // no error

ErrorExit:
        iErr= GetLastError();     // remember the first error

ExitWithThisError:                // preserve iErr (return SP_* errors)

        if( hPrevFont )
        {
            SelectObject( hPrintDC, hPrevFont );
            DeleteObject( hPrintFont );
        }

        if( pStartText )          // were able to lock hText
            LocalUnlock( hText );

        if( fPageStarted )
        {
            if( EndPage( hPrintDC ) <= 0 )
            {
                // if iErr not already set then set it to the new error code.
                if( iErr == 0 )
                {
                    iErr= GetLastError();
                }

            }
        }

        if( fDocStarted )
        {
            if( fAbort ) {
               AbortDoc( hPrintDC );
            }
            else {
               if( EndDoc( hPrintDC ) <= 0 )
               {
                   // if iErr not already set then set it to the new error code.
                   if (iErr == 0)
                   {
                       iErr= GetLastError();
                   }
               }
            }
        }

        DeleteDC( hPrintDC );

        DestroyAbortWnd();

        SetCursor( hStdCursor );

        if (!fAbort)
        {
            return( iErr );
        }
        else
        {
            return( SP_USERABORT );
        }
    }



    if( (iErr= SetAbortProc (hPrintDC, AbortProc)) < 0 )
    {
        goto ExitWithThisError;
    }

    // get printer to MLE text
    hText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hText )
    {
        goto ErrorExit;
    }
    pStartText= LocalLock( hText );
    if( !pStartText )
    {
        goto ErrorExit;
    }

    GetWindowText( hwndSP, msgbuf, CharSizeOf(msgbuf) );

    EnableWindow( hwndSP, FALSE );    // Disable window to prevent reentrancy

    hAbortDlgWnd= CreateDialog(         hInstanceSP,
                              (LPTSTR)  MAKEINTRESOURCE(IDD_ABORTPRINT),
                                        hwndSP,
                                        AbortDlgProc);

    if( !hAbortDlgWnd )
    {
        goto ErrorExit;
    }

    DocInfo.cbSize= sizeof(DOCINFO);
    DocInfo.lpszDocName= msgbuf;
    DocInfo.lpszOutput= NULL;
    DocInfo.lpszDatatype= NULL; // Type of data used to record print job
    DocInfo.fwType= 0; // not DI_APPBANDING

    SetLastError(0);      // clear error so it reflects errors in the future

    if( StartDoc( hPrintDC, &DocInfo ) <= 0 )
    {
        iErr = GetLastError();
        goto ExitWithThisError;
    }
    fDocStarted= TRUE;


    // Basicly, this is just a loop surrounding the DrawTextEx API.
    // We have to calculate the printable area which will not include
    // the header and footer area.
    {
    INT iTextLeft;        // amount of text left to print
    INT iSta;              // status
    UINT dwDTFormat;       // drawtext flags
    DRAWTEXTPARAMS dtParm; // drawtext control
    RECT rect;             // rectangle to draw in
    UINT dwDTRigh = 0;     // drawtext flags (RTL)

    iPageNum= 1;
    fPageStarted= FALSE;

    // calculate the size of the printable area for the text
    // not including the header and footer

    ZeroMemory( &rect, sizeof(rect) );

    rect.left= dxLeft; rect.right= xPrintRes-dxRight;
    rect.top=  dyTop;  rect.bottom= yPrintRes-dyBottom;

    if( *chPageText[HEADER] != 0 )
    {
        rect.top += yPrintChar;
    }

    if( *chPageText[FOOTER] != 0 )
    {
        rect.bottom -= yPrintChar;
    }

    iTextLeft= lstrlen(pStartText);

    //Get the edit control direction.
    if (GetWindowLong(hwndEdit, GWL_EXSTYLE) & WS_EX_RTLREADING)
        dwDTRigh = DT_RIGHT | DT_RTLREADING;


    while(  !fAbort && (iTextLeft>0) )
    {
        #define MAXSTATUS 100
        TCHAR szPagePrinting[MAXSTATUS+1];

        // update abort dialog box to inform user where we are in the printing
        _sntprintf( szPagePrinting, MAXSTATUS, szCurrentPage, iPageNum );
        SetDlgItemText( hAbortDlgWnd, ID_PAGENUMBER, szPagePrinting );

        PrintHeaderFooter( hPrintDC, HEADER );

        ZeroMemory( &dtParm, sizeof(dtParm) );

        dtParm.cbSize= sizeof(dtParm);
        dtParm.iTabLength= tabSize;

        dwDTFormat= DT_EDITCONTROL | DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX |
                    DT_WORDBREAK | dwDTRigh | 0;

        if( StartPage( hPrintDC ) <= 0 )
        {
            iErr= GetLastError();
            goto ExitWithThisError;
        }
        fPageStarted= TRUE;

        #ifdef DBGPRINT
        ShowMargins(hPrintDC);
        #endif

        /* Ignore errors in printing.  EndPage or StartPage will find them */
        iSta= DrawTextEx( hPrintDC,
                          pStartText,
                          iTextLeft,
                          &rect,
                          dwDTFormat,
                          &dtParm);

        PrintHeaderFooter( hPrintDC, FOOTER );

        if( EndPage( hPrintDC ) <= 0 )
        {
            iErr= GetLastError();
            goto ExitWithThisError;
        }
        fPageStarted= FALSE;

        iPageNum++;

        // if we can't print a single character (too big perhaps)
        // just bail now.
        if( dtParm.uiLengthDrawn == 0 )
        {
            goto FontTooBig;
        }

        pStartText += dtParm.uiLengthDrawn;
        iTextLeft  -= dtParm.uiLengthDrawn;

    }


    }

    iErr=0;        // no errors
    goto ExitWithThisError;

}


VOID DestroyAbortWnd (void)
{
    EnableWindow(hwndSP, TRUE);
    DestroyWindow(hAbortDlgWnd);
    hAbortDlgWnd = NULL;
}



const DWORD s_PageSetupHelpIDs[] = {
    ID_HEADER_LABEL,       IDH_PAGE_HEADER,
    ID_HEADER,             IDH_PAGE_HEADER,
    ID_FOOTER_LABEL,       IDH_PAGE_FOOTER,
    ID_FOOTER,             IDH_PAGE_FOOTER,
    0, 0
};

/*******************************************************************************
*
*  PageSetupHookProc
*
*  DESCRIPTION:
*     Callback procedure for the PageSetup common dialog box.
*
*  PARAMETERS:
*     hWnd, handle of PageSetup window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

UINT_PTR CALLBACK PageSetupHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    INT   id;    /* ID of dialog edit controls */
    POINT pt;

    switch (Message)
    {

        case WM_INITDIALOG:
            for (id = ID_HEADER; id <= ID_FOOTER; id++)
            {
                SendDlgItemMessage(hWnd, id, EM_LIMITTEXT, PT_LEN-1, 0L);
                SetDlgItemText(hWnd, id, chPageText[id - ID_HEADER]);
            }

            SendDlgItemMessage(hWnd, ID_HEADER, EM_SETSEL, 0,
                               MAKELONG(0, PT_LEN-1));
            return TRUE;

        case WM_DESTROY:
            //  We don't know if the user hit OK or Cancel, so we don't
            //  want to replace our real copies until we know!  We _should_ get
            //  a notification from the common dialog code!
            for( id = ID_HEADER; id <= ID_FOOTER; id++ )
            {
                GetDlgItemText(hWnd, id, chPageTextTemp[id - ID_HEADER],PT_LEN);
            }
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if (id < ID_HEADER || id > ID_FOOTER_LABEL)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, szHelpFile,
                HELP_WM_HELP, (UINT_PTR) (LPVOID) s_PageSetupHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hWnd == (HWND) wParam )
            {

                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hWnd, pt);

            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if (id < ID_HEADER || id > ID_FOOTER_LABEL)
                break;

            WinHelp((HWND) wParam, szHelpFile, HELP_CONTEXTMENU,
                (UINT_PTR) (LPVOID) s_PageSetupHelpIDs);
            return TRUE;

    }

    return FALSE;

}

/***************************************************************************
 * VOID TranslateString(TCHAR *src)
 *
 * purpose:
 *    translate a header/footer strings
 *
 * supports the following:
 *
 *    &&    insert a & char
 *    &f    current file name or (untitled)
 *    &d    date in Day Month Year
 *    &t    time
 *    &p    page number
 *    &p+num  set first page number to num
 *
 * Alignment:
 *    &l, &c, &r for left, center, right
 *
 * params:
 *    IN/OUT  src     this is the string to translate
 *
 *
 * used by:
 *    Header Footer stuff
 *
 * uses:
 *    lots of c lib stuff
 *
 ***************************************************************************/


VOID TranslateString (TCHAR * src)
{
    // File, Page, Time, Date, Center, Right, Left
    // these *never* change so don't put into resources for localizers
    TCHAR        letters[15]=TEXT("fFpPtTdDcCrRlL");
    TCHAR        buf[MAX_PATH];
    TCHAR       *ptr;
    INT          page;
    INT          nAlign=CENTER;    // current string to add chars to
    INT          foo;
    INT          nIndex[RIGHT+1];  // current lengths of (left,center,right)
    struct tm   *newtime;
    time_t       long_time;
    INT          iLen;             // length of strings

    nIndex[LEFT]   = 0;
    nIndex[CENTER] = 0;
    nIndex[RIGHT]  = 0;

    /* Get the time we need in case we use &t. */
    time (&long_time);
    newtime = localtime (&long_time);


    while (*src)   /* look at all of source */
    {
        while (*src && *src != TEXT('&'))
        {
            chBuff[nAlign][nIndex[nAlign]] = *src++;
            nIndex[nAlign] += 1;
        }

        if (*src == TEXT('&'))   /* is it the escape char? */
        {
            src++;

            if (*src == letters[0] || *src == letters[1])
            {                      /* &f file name (no path) */
                if (!fUntitled)
                {
                    GetFileTitle(szFileName, buf, CharSizeOf(buf));
                }
                else
                {
                    lstrcpy(buf, szUntitled);
                }

                /* Copy to the currently aligned string. */
                if( nIndex[nAlign] + lstrlen(buf) < MAXTITLE )
                {
                    lstrcpy( chBuff[nAlign] + nIndex[nAlign], buf );

                    /* Update insertion position. */
                    nIndex[nAlign] += lstrlen (buf);
                }

            }
            else if (*src == letters[2] || *src == letters[3])  /* &P or &P+num page */
            {
                src++;
                page = 0;
                if (*src == TEXT('+'))       /* &p+num case */
                {
                    src++;
                    while (_istdigit(*src))
                    {
                        /* Convert to int on-the-fly*/
                        page = (10*page) + (*src) - TEXT('0');
                        src++;
                    }
                }

                wsprintf( buf, TEXT("%d"), iPageNum+page );  // convert to chars

                if( nIndex[nAlign] + lstrlen(buf) < MAXTITLE )
                {
                    lstrcpy( chBuff[nAlign] + nIndex[nAlign], buf );
                    nIndex[nAlign] += lstrlen (buf);
                }
                src--;
            }
            else if (*src == letters[4] || *src == letters[5])   /* &t time */
            {
                iLen= lstrlen( szFormattedTime );

                /* extract time */
                if( nIndex[nAlign] + iLen < MAXTITLE )
                {
                    _tcsncpy (chBuff[nAlign] + nIndex[nAlign], szFormattedTime, iLen);
                    nIndex[nAlign] += iLen;
                }
            }
            else if (*src == letters[6] || *src == letters[7])   /* &d date */
            {
                iLen= lstrlen( szFormattedDate );

                /* extract day month day */
                if( nIndex[nAlign] + iLen < MAXTITLE )
                {
                    _tcsncpy (chBuff[nAlign] + nIndex[nAlign], szFormattedDate, iLen);
                    nIndex[nAlign] += iLen;
                }
            }
            else if (*src == TEXT('&'))       /* quote a single & */
            {
                if( nIndex[nAlign] + 1 < MAXTITLE )
                {
                    chBuff[nAlign][nIndex[nAlign]] = TEXT('&');
                    nIndex[nAlign] += 1;
                }
            }
            /* Set the alignment for whichever has last occured. */
            else if (*src == letters[8] || *src == letters[9])   /* &c center */
                nAlign=CENTER;
            else if (*src == letters[10] || *src == letters[11]) /* &r right */
                nAlign=RIGHT;
            else if (*src == letters[12] || *src == letters[13]) /* &d date */
                nAlign=LEFT;

            src++;
        }
     }
     /* Make sure all strings are null-terminated. */
     for (nAlign= LEFT; nAlign <= RIGHT ; nAlign++)
        chBuff[nAlign][nIndex[nAlign]] = (TCHAR) 0;

}

/* GetPrinterDC() - returns printer DC or INVALID_HANDLE_VALUE if none. */

HANDLE GetPrinterDC (VOID)
{
    LPDEVMODE lpDevMode;
    LPDEVNAMES lpDevNames;
    HDC hDC;


    if( !g_PageSetupDlg.hDevNames )   /* Retrieve default printer if none selected. */
    {
        g_PageSetupDlg.Flags |= PSD_RETURNDEFAULT;
        PageSetupDlg(&g_PageSetupDlg);
        g_PageSetupDlg.Flags &= ~PSD_RETURNDEFAULT;
    }

    if( !g_PageSetupDlg.hDevNames )
    {
        MessageBox( hwndSP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return INVALID_HANDLE_VALUE;
    }

    lpDevNames= (LPDEVNAMES) GlobalLock (g_PageSetupDlg.hDevNames);


    lpDevMode= NULL;

    if( g_PageSetupDlg.hDevMode )
       lpDevMode= (LPDEVMODE) GlobalLock( g_PageSetupDlg.hDevMode );

    /*  For pre 3.0 Drivers,hDevMode will be null  from Commdlg so lpDevMode
     *  will be NULL after GlobalLock()
     */

    /* The lpszOutput name is null so CreateDC will use the current setting
     * from PrintMan.
     */

    hDC= CreateDC (((LPTSTR)lpDevNames)+lpDevNames->wDriverOffset,
                      ((LPTSTR)lpDevNames)+lpDevNames->wDeviceOffset,
                      NULL,
                      lpDevMode);

    GlobalUnlock( g_PageSetupDlg.hDevNames );

    if( g_PageSetupDlg.hDevMode )
        GlobalUnlock( g_PageSetupDlg.hDevMode );


    if( hDC == NULL )
    {
        MessageBox( hwndSP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return INVALID_HANDLE_VALUE;
    }

    return hDC;
}


/* GetNonDefPrinterDC() - returns printer DC or INVALID_HANDLE_VALUE if none. */
/*                        using the name of the Printer server */

HANDLE GetNonDefPrinterDC (VOID)
{
    HDC     hDC;
    HANDLE  hPrinter;
    DWORD   dwBuf;
    DRIVER_INFO_1  *di1;



    // open the printer and retrieve the driver name.
    if (!OpenPrinter(szPrinterName, &hPrinter, NULL))
    {
        return INVALID_HANDLE_VALUE;
    }

    // get the buffer size.
    GetPrinterDriver(hPrinter, NULL, 1, NULL, 0, &dwBuf);
    di1 = (DRIVER_INFO_1  *) LocalAlloc(LPTR, dwBuf);
    if (!di1)
    {
        ClosePrinter(hPrinter);
        return INVALID_HANDLE_VALUE;
    }

    if (!GetPrinterDriver(hPrinter, NULL, 1, (LPBYTE) di1, dwBuf, &dwBuf))
    {
        LocalFree(di1);
        ClosePrinter(hPrinter);
        return INVALID_HANDLE_VALUE;
    }

    // Initialize the PageSetup dlg to default values.
    // using default printer's value for another printer !!
    g_PageSetupDlg.Flags |= PSD_RETURNDEFAULT;
    PageSetupDlg(&g_PageSetupDlg);
    g_PageSetupDlg.Flags &= ~PSD_RETURNDEFAULT;

    // create printer dc with default initialization.
    hDC= CreateDC (di1->pName, szPrinterName, NULL, NULL);

    // cleanup.
    LocalFree(di1);
    ClosePrinter(hPrinter);

    if( hDC == NULL )
    {
        MessageBox( hwndSP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return INVALID_HANDLE_VALUE;
    }

    return hDC;
}


/* PrintIt() - print the file, giving popup if some error */

void PrintIt(PRINT_DIALOG_TYPE type)
{
    INT iError;
    TCHAR* szMsg= NULL;
    TCHAR  msg[400];       // message info on error

    /* print the file */

    iError= NpPrint( type );

    if(( iError != 0) &&
       ( iError != SP_APPABORT )     &&
       ( iError != SP_USERABORT ) )
    {
        // translate any known spooler errors
        if( iError == SP_OUTOFDISK   ) iError= ERROR_DISK_FULL;
        if( iError == SP_OUTOFMEMORY ) iError= ERROR_OUTOFMEMORY;
        if( iError == SP_ERROR       ) iError= GetLastError();
        /* SP_NOTREPORTED not handled.  Does it happen? */


        //
        // iError may be 0 because the user aborted the printing.
        // Just ignore.
        //

        if( iError == 0 ) return;

        // Get system to give reasonable error message
        // These will also be internationalized.

        if(!FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           iError,
                           GetUserDefaultLangID(),
                           msg,  // where message will end up
                           CharSizeOf(msg), NULL ) )
        {
            szMsg= szCP;   // couldn't get system to say; give generic msg
        }
        else
        {
            szMsg= msg;
        }

        AlertBox( hwndSP, szNN, szMsg, fUntitled ? szUntitled : szFileName,
                  MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxspad\sxspadmisc.c ===
/*
 * misc functions
 *  Copyright (C) 1984-2000 Microsoft Inc.
 */

#include "precomp.h"

BOOL fCase = FALSE;         /* Flag specifying case sensitive search */
BOOL fReverse = FALSE;      /* Flag for direction of search */

extern HWND hDlgFind;       /* handle to modeless FindText window */

LPTSTR ReverseScan(
    LPTSTR lpSource,
    LPTSTR lpLast,
    LPTSTR lpSearch,
    BOOL fCaseSensitive )
{
   TCHAR cLastCharU;
   TCHAR cLastCharL;
   INT   iLen;

   cLastCharU= (TCHAR) (INT_PTR) CharUpper( (LPTSTR)(INT_PTR)(*lpSearch) );
   cLastCharL= (TCHAR) (INT_PTR) CharLower( (LPTSTR)(INT_PTR)(*lpSearch) );

   iLen = lstrlen(lpSearch);

   if (!lpLast)
      lpLast = lpSource + lstrlen(lpSource);

   do
   {
      if (lpLast == lpSource)
         return NULL;

      --lpLast;

      if (fCaseSensitive)
      {
         if (*lpLast != *lpSearch)
            continue;
      }
      else
      {
           if( !( *lpLast == cLastCharU || *lpLast == cLastCharL ) )
            continue;
      }

      if (fCaseSensitive)
      {
         if (!_tcsncmp( lpLast, lpSearch, iLen))
            break;
      }
      else
      {
         //
         // compare whole string using locale specific comparison.
         // do not use C runtime version since it may be wrong.
         //

         if( 2 == CompareString( LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                    lpLast,   iLen,
                    lpSearch, iLen) )
            break;
      }
   } while (TRUE);

   return lpLast;
}

LPTSTR ForwardScan(LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive )
{
   TCHAR cFirstCharU;
   TCHAR cFirstCharL;
   int iLen = lstrlen(lpSearch);

   cFirstCharU= (TCHAR) (INT_PTR) CharUpper( (LPTSTR)(INT_PTR)(*lpSearch) );
   cFirstCharL= (TCHAR) (INT_PTR) CharLower( (LPTSTR)(INT_PTR)(*lpSearch) );

   while (*lpSource)
   {
      if (fCaseSensitive)
      {
         if (*lpSource != *lpSearch)
         {
            lpSource++;
            continue;
         }
      }
      else
      {
         if( !( *lpSource == cFirstCharU || *lpSource == cFirstCharL ) )
         {
            lpSource++;
            continue;
         }
      }

      if (fCaseSensitive)
      {
         if (!_tcsncmp( lpSource, lpSearch, iLen))
            break;
      }
      else
      {
         if( 2 == CompareString( LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                    lpSource, iLen,
                    lpSearch, iLen) )
            break;
      }

      lpSource++;
   }

   return *lpSource ? lpSource : NULL;
}


/* search forward or backward in the edit control text for the given pattern */
/* It is the responsibility of the caller to set the cursor                  */

BOOL Search (TCHAR * szKey)
{
    BOOL      bStatus= FALSE;
    TCHAR   * pStart, *pMatch;
    DWORD     StartIndex, LineNum, EndIndex;
    DWORD     SelStart, SelEnd, i;
    HANDLE    hEText;           // handle to edit text
    UINT      uSelState;
    HMENU     hMenu;
    BOOL      bSelectAll = FALSE;


    if (!*szKey)
        return( bStatus );

    SendMessage(hwndEdit, EM_GETSEL, (WPARAM)&SelStart, (LPARAM)&SelEnd);


    /*
    when we finish the search, we highlight the text found, and continue
    the search after the end of the highlighted position (in forward
    case) or from the begining of the highlighted position in the reverse
    direction (in reverse case). this would break if the user has
    selected all text. this hack would take care of it. (this is consistent
    with VC editors' search too.*/

    hMenu = GetMenu(hwndSP);
    uSelState = GetMenuState(GetSubMenu(hMenu, 1), M_SELECTALL, MF_BYCOMMAND);
    if (uSelState == MF_GRAYED)
    {
        bSelectAll = TRUE;
        SelStart = SelEnd =0;
    }


    /*
     * get pointer to edit control text to search
     */

    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hEText )  // silently return if we can't get it
    {
        return( bStatus );
    }
    pStart= LocalLock( hEText );
    if( !pStart )
    {
        return( bStatus );
    }

    if (fReverse)
    {
        /* Get current line number */
        LineNum= (DWORD)SendMessage(hwndEdit, EM_LINEFROMCHAR, SelStart, 0);
        /* Get index to start of the line */
        StartIndex= (DWORD)SendMessage(hwndEdit, EM_LINEINDEX, LineNum, 0);
        /* Set upper limit for search text */
        EndIndex= SelStart;
        pMatch= NULL;

        /* Search line by line, from LineNum to 0 */
        i = LineNum;
        while (TRUE)
        {
            pMatch= ReverseScan(pStart+StartIndex,pStart+EndIndex,szKey,fCase);
            if (pMatch)
               break;
            /* current StartIndex is the upper limit for the next search */
            EndIndex= StartIndex;

            if (i)
            {
                /* Get start of the next line */
                i-- ;
                StartIndex = (DWORD)SendMessage(hwndEdit, EM_LINEINDEX, i, 0);
            }
            else
               break ;
        }
    }
    else
    {
            pMatch= ForwardScan(pStart+SelEnd, szKey, fCase);
    }

    LocalUnlock(hEText);

    if (pMatch == NULL)
    {
        //
        // alert user on not finding any text unless it is replace all
        //
        if( !(FR.Flags & FR_REPLACEALL) )
        {
            HANDLE hPrevCursor= SetCursor( hStdCursor );
            AlertBox( hDlgFind ? hDlgFind : hwndSP,
                      szNN,
                      szCFS,
                      szSearch,
                      MB_APPLMODAL | MB_OK | MB_ICONASTERISK);
            SetCursor( hPrevCursor );
        }
    }
    else
    {
        SelStart = (DWORD)(pMatch - pStart);
        SendMessage( hwndEdit, EM_SETSEL, SelStart, SelStart+lstrlen(szKey));

        // since we are selecting the found text, enable SelectAll again.
        if (bSelectAll)
        {
            EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_ENABLED);
        }

        //
        // show the selected text unless it is replace all
        //

        if( !(FR.Flags & FR_REPLACEALL) )
        {
            SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
        }
        bStatus= TRUE;   // found
    }

    return( bStatus );
}

/* ** Recreate sxspad edit window, get text from old window and put in
      new window.  Called when user changes style from wrap on/off */
BOOL FAR NpReCreate( long style )
{
    RECT    rcT1;
    HWND    hwndT1;
    HANDLE  hT1;
    int     cchTextNew;
    TCHAR*  pchText;
    BOOL    fWrap = ((style & WS_HSCROLL) == 0);
    HCURSOR hPrevCursor;
    BOOL    bModified;     // modify flag from old edit buffer

    /* if wordwrap, remove soft carriage returns */
    hPrevCursor= SetCursor( hWaitCursor );     // this may take some time...
    if (!fWrap)
        SendMessage(hwndEdit, EM_FMTLINES, FALSE, 0L);

    bModified= (SendMessage( hwndEdit, EM_GETMODIFY, 0,0 ) != 0);

    cchTextNew= (int)SendMessage( hwndEdit, WM_GETTEXTLENGTH, 0, 0L );
    hT1= LocalAlloc( LMEM_MOVEABLE, ByteCountOf(cchTextNew + 1) );
    if( !hT1 )
    {
        /* failed, was wordwrap; insert soft carriage returns */
        if (!fWrap)
            SendMessage(hwndEdit, EM_FMTLINES, TRUE, 0L);
        SetCursor( hPrevCursor );
        return FALSE;
    }

    GetClientRect( hwndSP, (LPRECT)&rcT1 );

    /*
     * save the current edit control text.
     */
    pchText= LocalLock (hT1);
    SendMessage( hwndEdit, WM_GETTEXT, cchTextNew+1, (LPARAM)pchText );
    hwndT1= CreateWindowEx( WS_EX_CLIENTEDGE,
        TEXT("Edit"),
        TEXT(""), // pchText
        style,
        0,
        0,
        rcT1.right,
        rcT1.bottom,
        hwndSP,
        (HMENU)ID_EDIT,
        hInstanceSP, NULL );
    if( !hwndT1 )
    {
        SetCursor( hPrevCursor );
        if (!fWrap)
            SendMessage( hwndEdit, EM_FMTLINES, TRUE, 0L );
        LocalUnlock(hT1);
        LocalFree(hT1);
        return FALSE;
    }

    //
    // The user can "add" styles to the edit window after it is
    // created (like WS_EX_RTLREADING) when language packs are installed.
    // Preserve these styles when changing the word wrap.
    //

    SetWindowLong( hwndT1 ,
                   GWL_EXSTYLE ,
                   GetWindowLong( hwndEdit , GWL_EXSTYLE )|WS_EX_CLIENTEDGE ) ;

    // Set font before set text to save time calculating
    SendMessage( hwndT1, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0) );

    if (!SendMessage (hwndT1, WM_SETTEXT, 0, (LPARAM) pchText))
    {
        SetCursor( hPrevCursor );
        if (!fWrap)
            SendMessage( hwndEdit, EM_FMTLINES, TRUE, 0L );
        DestroyWindow( hwndT1 );
        LocalUnlock( hT1 );
        LocalFree( hT1 );
        return FALSE;
    }
    LocalUnlock(hT1);


    DestroyWindow( hwndEdit );     // out with the old
    hwndEdit = hwndT1;             // in with the new
    /*
     * Win32s does not support the EM_SETHANDLE message, so just do
     * the assignment.  hT1 already contains the edit control text.
     */
    /* free the earlier allocated memory in hEdit */
    if (hEdit)
        LocalFree(hEdit);

    hEdit = hT1;

    /* limit text for safety's sake. */
    PostMessage( hwndEdit, EM_LIMITTEXT, (WPARAM)CCHSPMAX, 0L );

    ShowWindow(hwndSP, SW_SHOW);
    SetTitle( fUntitled ? szUntitled : szFileName );
    SendMessage( hwndEdit, EM_SETMODIFY, bModified, 0L );
    SetFocus(hwndEdit);

    SetCursor( hPrevCursor );   // restore cursor
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxspad\sxspaddate.c ===
/* sxsdate - Code for getting and inserting current date and time.
 *   Copyright (C) 1984-2000 Microsoft Inc.
 */

#include "precomp.h"

/* ** Replace current selection with date/time string.
 *    if fCrlf is true, date/time string should begin
 *    and end with crlf
*/
VOID FAR InsertDateTime (BOOL fCrlf)
{
   SYSTEMTIME time ;
   TCHAR szDate[80] ;
   TCHAR szTime[80] ;
   TCHAR szDateTime[sizeof(szDate) + sizeof(szTime) + 10] = TEXT("");
   DWORD locale;
   BOOL bMELocale;
   DWORD dwFlags = DATE_SHORTDATE;

   //  See if the user locale id is Arabic or Hebrew.
   locale    = GetUserDefaultLCID();
   bMELocale = ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
                (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW));

   locale = MAKELCID( MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), SORT_DEFAULT) ;

   // Get the time
   GetLocalTime( &time ) ;

   if (bMELocale)
   {
       //Get the date format that matches the edit control reading direction.
       if (GetWindowLong(hwndEdit, GWL_EXSTYLE) & WS_EX_RTLREADING) {
           dwFlags |= DATE_RTLREADING;
           lstrcat(szDateTime, TEXT("\x200F")); // RLM
       } else {
           dwFlags |= DATE_LTRREADING;
           lstrcat(szDateTime, TEXT("\x200E")); // LRM
       }
   }

   // Format date and time
   GetDateFormat(locale,dwFlags, &time,NULL,szDate,CharSizeOf(szDate));
   GetTimeFormat(locale,TIME_NOSECONDS,&time,NULL,szTime,CharSizeOf(szTime));

   if( fCrlf )
       lstrcat(szDateTime, TEXT("\r\n"));


   lstrcat(szDateTime, szTime);
   lstrcat(szDateTime, TEXT(" "));
   lstrcat(szDateTime, szDate);

   if( fCrlf )
        lstrcat(szDateTime, TEXT("\r\n"));

   // send it in one shot; this is also useful for undo command
   // so that user can undo the date-time.
   SendMessage(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szDateTime);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\sxspad\sxspadputf.c ===
/*
 * nputf.c  - Routines for utf text processing for sxspad
 *
 *   Copyright (C) 1998-2000 Microsoft Inc.
 */

#include "precomp.h"


/* IsTextUTF8
 *
 * UTF-8 is the encoding of Unicode based on Internet Society RFC2279
 * ( See http://www.cis.ohio-state.edu/htbin/rfc/rfc2279.html )
 *
 * Basicly:
 * 0000 0000-0000 007F - 0xxxxxxx  (ascii converts to 1 octet!)
 * 0000 0080-0000 07FF - 110xxxxx 10xxxxxx    ( 2 octet format)
 * 0000 0800-0000 FFFF - 1110xxxx 10xxxxxx 10xxxxxx (3 octet format)
 * (this keeps going for 32 bit unicode)
 *
 *
 * Return value:  TRUE, if the text is in UTF-8 format.
 *                FALSE, if the text is not in UTF-8 format.
 *                We will also return FALSE is it is only 7-bit ascii, so the right code page
 *                will be used.
 *
 *                Actually for 7 bit ascii, it doesn't matter which code page we use, but
 *                sxspad will remember that it is utf-8 and "save" or "save as" will store
 *                the file with a UTF-8 BOM.  Not cool.
 */


INT IsTextUTF8( LPSTR lpstrInputStream, INT iLen )
{
    INT   i;
    DWORD cOctets;  // octets to go in this UTF-8 encoded character
    UCHAR chr;
    BOOL  bAllAscii= TRUE;

    cOctets= 0;
    for( i=0; i < iLen; i++ ) {
        chr= *(lpstrInputStream+i);

        if( (chr&0x80) != 0 ) bAllAscii= FALSE;

        if( cOctets == 0 )  {
            //
            // 7 bit ascii after 7 bit ascii is just fine.  Handle start of encoding case.
            //
            if( chr >= 0x80 ) {
               //
               // count of the leading 1 bits is the number of characters encoded
               //
               do {
                  chr <<= 1;
                  cOctets++;
               }
               while( (chr&0x80) != 0 );

               cOctets--;                        // count includes this character
               if( cOctets == 0 ) return FALSE;  // must start with 11xxxxxx
            }
        }
        else {
            // non-leading bytes must start as 10xxxxxx
            if( (chr&0xC0) != 0x80 ) {
                return FALSE;
            }
            cOctets--;                           // processed another octet in encoding
        }
    }

    //
    // End of text.  Check for consistency.
    //

    if( cOctets > 0 ) {   // anything left over at the end is an error
        return FALSE;
    }

    if( bAllAscii ) {     // Not utf-8 if all ascii.  Forces caller to use code pages for conversion
        return FALSE;
    }

    return TRUE;
}


/* IsInputTextUnicode
 * Verify if the input stream is in Unicode format.
 *
 * Return value:  TRUE, if the text is in Unicode format.
 *
 * 29 June 1998
 */


INT IsInputTextUnicode  (LPSTR lpstrInputStream, INT iLen)
{
    INT  iResult= ~0; // turn on IS_TEXT_UNICODE_DBCS_LEADBYTE
    BOOL bUnicode;

    // We would like to check the possibility
    // of IS_TEXT_UNICODE_DBCS_LEADBYTE.
    //

    bUnicode= IsTextUnicode( lpstrInputStream, iLen, &iResult);

    if (bUnicode                                         &&
       ((iResult & IS_TEXT_UNICODE_STATISTICS)    != 0 ) &&
       ((iResult & (~IS_TEXT_UNICODE_STATISTICS)) == 0 )    )
    {
        CPINFO cpiInfo;
        CHAR* pch= (CHAR*)lpstrInputStream;
        INT  cb;

        //
        // If the result depends only upon statistics, check
        // to see if there is a possibility of DBCS.
        // Only do this check if the ansi code page is DBCS
        //

        GetCPInfo( CP_ACP, &cpiInfo);

        if( cpiInfo.MaxCharSize > 1 )
        {
            for( cb=0; cb<iLen; cb++ )
            {
                if( IsDBCSLeadByte(*pch++) )
                {
                    return FALSE;
                }
            }
        }
     }

     return bUnicode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\typelibrarytool\typelibrarytool.cpp ===
/*
This program does stuff with typelibraries.
*/
#define NOMINMAX
#include "yvals.h"
#undef _MAX
#undef _MIN
#define _cpp_min    min
#define _cpp_max    max
#define _MIN	    min
#define _MAX	    max
#define min         min
#define max         max
#pragma warning(disable:4100)
#pragma warning(disable:4663)
#pragma warning(disable:4511)
#pragma warning(disable:4512)
#pragma warning(disable:4127)
#pragma warning(disable:4018)
#pragma warning(disable:4389)
#pragma warning(disable:4702)
#include <vector>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <string>
#include <string.h>
#include <stdio.h>
#include "windows.h"
#include "oleauto.h"
#include "atlbase.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

//
// get msvcrt.dll wildcard processing on the command line
//
extern "C" { int _dowildcard = 1; }

class TypelibraryTool_t
{
public:
    void Main(unsigned Argc, wchar_t ** Argv);
    void DoStuff(wchar_t * Arg);

    TypelibraryTool_t() { }
    ~TypelibraryTool_t() { }
};

void TypelibraryTool_t::DoStuff(wchar_t * Arg)
{
    ::ATL::CComPtr<ITypeLib> TypeLib;
    HRESULT hr = 0;
    TLIBATTR * LibAttr = 0;
    PCSTR SyskindString = "<undefined>";

    if (FAILED(hr = LoadTypeLibEx(Arg, REGKIND_NONE, &TypeLib)))
        goto Exit;
    if (FAILED(hr = TypeLib->GetLibAttr(&LibAttr)))
        goto Exit;
    switch (LibAttr->syskind)
    {
        case SYS_WIN16:
            SyskindString = "win16";
            break;
        case SYS_MAC:
            SyskindString = "mac";
            break;
        case SYS_WIN32:
            SyskindString = "win32";
            break;
        case SYS_WIN64:
            SyskindString = "win64";
            break;
        default:
            break;
    }
    printf("%ls syskind:0x%lx,%s\n", Arg, (ULONG)LibAttr->syskind, SyskindString);
Exit:
    if (TypeLib != NULL && LibAttr != NULL)
        TypeLib->ReleaseTLibAttr(LibAttr);
    return;
}

void TypelibraryTool_t::Main(unsigned Argc, wchar_t ** Argv)
{
    unsigned Arg;
    for (Arg = 0 ; Arg != Argc ; ++Arg)
    {
        if (Argv[Arg] && Argv[Arg][0])
        {
            DoStuff(Argv[Arg]);
        }
    }
}

int __cdecl wmain(int argc, wchar_t ** argv)
{
    TypelibraryTool_t c;
    c.Main(static_cast<unsigned>(argc - !!argc), argv + !!argc);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\tabstospaces\tabstospaces.cpp ===
/* 
tabstospaces 

Usage: 
    tabstospaces -n filenamein filenameout 

where n is how many spaces there are to a tab, like 4 or 8, and filenamein can be -stdin and filenameout can be -stdout
(if you use -stdin or -stdout, the order is not important; likewise, -n can appear anywhere).

NOTE we don't just replace a tab with n spaces, we assume a tab rounds to next multiple of n spaces, and add
the appropriate, possibly smaller, number of spaces.

If you only list one file, that file is the input and the output. The output will be written to a temporary file
and then copied into the output.

Buffered i/o into a fixed sized buffer is used, so file sizes are not limited by memory or address space.

If you only list -stdin or -stdout, the other is assumed.

Jay Krell
May 14, 2001
*/ 

#include <stdio.h> 
#include <ctype.h> 
#include <string> 
#include <vector>
#include "fcntl.h"
#include "io.h"
#ifndef  _DLL
extern "C" { int _fmode = _O_BINARY; }
#endif

FILE* myfopen(const char* name, const char* mode)
{
    FILE* f;
    int er;

    f = fopen(name, mode);
    if (f != NULL)
        return f;

    er = errno; 
    fprintf(stderr, "%s", (std::string("Unable to open ") + name + " -- " + strerror(er)).c_str());
    exit(EXIT_FAILURE); 
}

int __cdecl main(int argc, char** argv) 
{ 
    unsigned col = 1; 
    char ch = 0; 
    unsigned tabwidth = 1; 
    FILE* filein = NULL; 
    FILE* fileout = NULL;; 
    char* filenamein = NULL; 
    char* filenameout = NULL; 
    char* inbuffer = NULL; 
    FILE* tmp = NULL;
    const unsigned long bufsize = 32768;
    std::vector<char> buffer;
    buffer.resize(bufsize);
    unsigned long i = 0;
    unsigned long j = 0;
    std::vector<char> bufferout;
    bufferout.reserve(bufsize * 2);

    while (*++argv != NULL) 
    { 
        if (argv[0][0] == '/' || argv[0][0] == '-') 
        { 
            if (_stricmp(&argv[0][1], "stdin") == 0) 
            { 
                _setmode(_fileno(stdin), _O_BINARY);
                filein = stdin; 
            } 
            else if (_stricmp(&argv[0][1], "stdout") == 0) 
            {
                _setmode(_fileno(stdout), _O_BINARY);
                fileout = stdout;
            } 
            else if (isdigit(argv[0][1]))
            {
                tabwidth = atoi(argv[0] + 1); 
            } 
        } 
        else 
        { 
            bool gotin = (filenamein != NULL || filein != NULL); 
            char** name = gotin ? &filenameout : &filenamein; 

            *name = argv[0];
        }
    }
    if (filein == NULL && filenamein == NULL)
        exit(EXIT_FAILURE);
    if (filein == NULL && filenamein != NULL)
        filein = myfopen(filenamein, "rb");

    if ((filein == NULL && filenamein == NULL) || (fileout == NULL && filenameout == NULL))
    {
        if (fileout == stdout)
            filein = stdin;
        else if (filein == stdin)
            fileout = stdout;
        else
            filenameout = filenamein;
    }

    if (filein == stdin || fileout == stdout || _stricmp(filenamein, filenameout) == 0)
    {
        tmp = tmpfile();
    }
    else
    {
        fileout = myfopen(filenameout, "wb");
        tmp = fileout;
    }
    while ((i = fread(&buffer[0], 1, buffer.size(), filein)) != 0)
    {
        bufferout.resize(0);
        for (j = 0 ; j != i ; j += 1)
        {
            switch (ch = buffer[j])
            {
            default:
                col += 1;
                bufferout.push_back(ch);
                break;
            case '\r':
            case '\n':
    col = 1;
    bufferout.push_back(ch);
    break;
            case '\t':
    do
    {
        bufferout.push_back(' ');
        col += 1;
                } while (((col - 1) % tabwidth) != 0);
            }
        }
        fwrite(&bufferout[0], 1, bufferout.size(), tmp);
    }
    fflush(tmp);
    fclose(filein);
    if (fileout == NULL)
    {
        fileout = myfopen(filenameout, "wb+");
        fseek(tmp, 0, SEEK_SET);
        while ((i = fread(&buffer[0], 1, buffer.size(), tmp)) != 0)
            fwrite(&buffer[0], 1, i, fileout);
        fclose(tmp);
    }
    fclose(fileout);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\apps\identgetter\identdriver.c ===
#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "identbuilder.h"

#ifdef INVALID_HANDLE_VALUE
#undef INVALID_HANDLE_VALUE
#endif

#include "windows.h"
#include "identbuilder.h"

int __cdecl wmain(int argc, WCHAR** argv)
{
    CHAR cchBuffer[0x5a];
    SIZE_T cchChars = sizeof(cchBuffer)/sizeof(*cchBuffer);
    BOOL fResult;

    cchBuffer[0] = '\0';

    fResult = SxsIdentDetermineManifestPlacementPath(
        0,
        argv[1],
        cchBuffer,
        &cchChars);

    printf("%s\n", cchBuffer);
    fflush(stdout);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\template\tool.cpp ===
#include "stdinc.h" // actually from dll\whistler directory
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#pragma warning(disable: 4663)
#include <yvals.h>
#pragma warning(disable: 4663)
#include <string>
#include <deque>
#include <vector>
#pragma warning(pop)
#include "fusionbuffer.h"
#include "fusion.h"
#include "sxsasmname.h"
#include "util.h"
#include "filestream.cpp"
#include "sxsapi.h"
#include "fusiontrace.h"
#include "cresourcestream.cpp"
#include "cmemorystream.cpp"
#include "wintrust.h"
#include "softpub.h"
#include "perfclocking.h"
#include "strongname.h"
#include "fusionversion.h"

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;


    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\apps\dsigtool\dsigmain.cpp ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "stdio.h"
#include "sxs-rtl.h"
#include "fasterxml.h"
#include "skiplist.h"
#include "namespacemanager.h"
#include "xmlstructure.h"
#undef INVALID_HANDLE_VALUE
#include "windows.h"
#include "sha.h"
#include "sha2.h"
#include "md4.h"
#include "rsa.h"
#include "bcl_w32unicodestringbuffer.h"
#include "bcl_common.h"
#include "hashers.h"
#include "environment.h"

#pragma warning(disable: 4200)

void __cdecl wmain(int argc, wchar_t** argv);
void GetSignatureOf(PCWSTR pcwsz);
void ValidateSignature(PCWSTR pcwsz);

template <typename TStored, typename TCount>
class CArrayBlob
{
public:
    typedef BCL::CMutablePointerAndCountPair<TStored, TCount> TRange;
    typedef BCL::CConstantPointerAndCountPair<TStored, TCount> TConstantRange;    

private:    
    TRange m_InternalRange;

    bool ResizeInternal(TCount cNewCount, bool fPreserve = false)
    {
        //
        // No previous allocation or previous too small
        //
        if ((m_InternalRange.GetPointer() == NULL) || (cNewCount > m_InternalRange.GetCount()))
        {
            //
            // Don't bother preserving if there was no original buffer.
            // Allocate, copy, reset pointers
            //
            if (fPreserve && m_InternalRange.GetPointer())
            {
                TRange NewRange(new TStored[cNewCount], cNewCount);
                TStored *pNewSet = NewRange.GetPointer();
                TStored *pOld = m_InternalRange.GetPointer();

                if (pNewSet == NULL)
                    return false;

                for (TCount c = 0; c < m_InternalRange.GetCount(); c++)
                    pNewSet[c] = pOld[c];

                delete [] m_InternalRange.GetPointer();

                m_InternalRange = NewRange;
            }
            //
            // Otherwise, don't care - free old, allocate new, swap pointers
            //
            else
            {
                TStored *pOld = m_InternalRange.GetPointer();
                TStored *pNew = new TStored[cNewCount];
                
                if (pOld != NULL)
                {
                    delete [] pOld;
                    pOld = NULL;
                }

                if (pNew == NULL)
                    return false;

                m_InternalRange.SetPointerAndCount(pNew, cNewCount);
            }
        }

        return true;
    }

public:
    CArrayBlob() { }
    ~CArrayBlob() { if (m_InternalRange.GetPointer()) { delete [] m_InternalRange.GetPointer(); } }

    bool Initialize(const TConstantRange &src)
    {
        if (ResizeInternal(src.GetCount(), false))
        {
            TStored *pNew = m_InternalRange.GetPointer();
            const TStored *pOld = src.GetPointer();
            
            for (TCount c = 0; c < src.GetCount(); c++)
                pNew[c] = pOld[c];

            return true;
        }
        else
        {
            return false;
        }
    }

    bool Initialize(const CArrayBlob<TStored, TCount>& Other)
    {
        if (&Other != this)
        {
            return this->Initialize(Other.m_InternalRange);
        }
        else
        {
            return true;
        }
    }

    bool EnsureSize(TCount c)
    {
        return ResizeInternal(c, true);
    }

    const TConstantRange &GetRange() const { return m_InternalRange; }
    TRange GetMutableRange() { return m_InternalRange; }
};

typedef CArrayBlob<BYTE, SIZE_T> CByteBlob;

template <
    typename TStoredObject,
    int iInitialSize = 0
    >
class CGrowingList : public RTL_GROWING_LIST
{
    // Each chunk is therefore half a page.
    enum { eDefaultElementsPerChunk = (2048 / sizeof(TStoredObject)) };

    TStoredObject m_InternalObjects[iInitialSize];
    
public:    
    bool Initialize(PRTL_ALLOCATOR Allocator = &g_DefaultAllocator) 
    {
        NTSTATUS status = 
            RtlInitializeGrowingList(
                this, 
                sizeof(TStoredObject), 
                eDefaultElementsPerChunk,
                m_InternalObjects,
                iInitialSize * sizeof(TStoredObject),
                Allocator);

        return NT_SUCCESS(status);
    }

    ~CGrowingList() { Destroy(); }

    bool Destroy()
    {
        return NT_SUCCESS(RtlDestroyGrowingList(this));
    }

    inline TStoredObject &operator[](ULONG i) {        
        TStoredObject *pvObject = NULL;        
        NTSTATUS status = RtlIndexIntoGrowingList(this, i, (PVOID*)&pvObject, TRUE);
        
        if (!NT_SUCCESS(status)) {
            EXCEPTION_RECORD exr = {STATUS_INVALID_PARAMETER, 0, NULL, NULL, 3 };
            exr.ExceptionInformation[0] = i;
            exr.ExceptionInformation[1] = (ULONG_PTR)this;
            exr.ExceptionInformation[2] = status;
            RtlRaiseException(&exr);
        }
        
        return *pvObject;
    }
};

typedef CGrowingList<XMLDOC_ATTRIBUTE, 50> CAttributeList;


class CLogicalXmlParser;

class CXmlMiniTokenizer
{
    XML_RAWTOKENIZATION_STATE RawState;
    NTXML_RAW_TOKEN TokenName;
    ULONG ulCharacter;
    
public:
    CXmlMiniTokenizer() { }
    bool Initialize(XML_EXTENT &Source, CLogicalXmlParser &SourceParser);
    bool More() { return RawState.pvCursor <= RawState.pvDocumentEnd; }
    void Next();
    
    ULONG Name() { return TokenName; }
    ULONG Character() { return ulCharacter; }
};

class CLogicalXmlParser
{
public:   
    typedef CLogicalXmlParser CThis;
    
protected:    
    XML_LOGICAL_STATE   m_XmlState;
    NS_MANAGER          m_Namespaces;
    bool                m_fInitialized;
    CAttributeList      m_Attributes;

    friend CXmlMiniTokenizer;

public:
    CLogicalXmlParser() : m_fInitialized(false) { }
    ~CLogicalXmlParser() { this->Reset(); }

    bool Reset();
    bool Initialize(PVOID pvXmlBase, SIZE_T cbDocumentSize);
    CAttributeList& Attributes() { return this->m_Attributes; }
    bool More() const;
    bool Next(XMLDOC_THING &XmlDocThing);
    bool SkipElement(XMLDOC_ELEMENT &Element);
    bool IsThisNode(XMLDOC_ELEMENT &Element, PCXML_SPECIAL_STRING pName, PCXML_SPECIAL_STRING pNamespace);
    
    template <typename TStringType>
    bool ConvertToString(PXML_EXTENT pExtent, TStringType &Target)
    {
        bool fSuccess = false;
        SIZE_T cch;
        NTSTATUS status;
        
        if (!Target.EnsureSizeChars(pExtent->ulCharacters))
            goto Exit;        

        status = RtlXmlExtentToString(&m_XmlState.ParseState.RawTokenState, pExtent, &Target, &cch);
        if (status == STATUS_BUFFER_TOO_SMALL)
        {
            if (!Target.EnsureSizeChars(cch))
                goto Exit;

            if (!NT_SUCCESS(status = RtlXmlExtentToString(&m_XmlState.ParseState.RawTokenState, pExtent, &Target, &cch)))
                goto Exit;
        }

        fSuccess = true;
    Exit:
        return fSuccess;
    }


private:
    static NTSTATUS StaticCompareStrings(PVOID pv, PCXML_EXTENT pcLeft, PCXML_EXTENT pcRight, XML_STRING_COMPARE *pfMatching)
    {
        CThis *pThis = reinterpret_cast<CThis*>(pv);
        return RtlXmlDefaultCompareStrings(&pThis->m_XmlState.ParseState, pcLeft, pcRight, pfMatching);
    }
    
    static NTSTATUS FASTCALL StaticAllocate(SIZE_T cb, PVOID* ppvOutput, PVOID pvContext)
    {
        return (NULL != (*ppvOutput = HeapAlloc(GetProcessHeap(), 0, cb))) ? STATUS_SUCCESS : STATUS_NO_MEMORY;
    }

    static NTSTATUS FASTCALL StaticFree(PVOID pvPointer, PVOID pvContext)
    {
        return HeapFree(GetProcessHeap(), 0, pvPointer);
    }
};

bool 
CLogicalXmlParser::IsThisNode(
    XMLDOC_ELEMENT &Element,
    PCXML_SPECIAL_STRING pName,
    PCXML_SPECIAL_STRING pNamespace
    )
{
    XML_STRING_COMPARE Comparison;

    if (pNamespace != NULL)
    {
        m_XmlState.ParseState.pfnCompareSpecialString(
            &m_XmlState.ParseState,
            &Element.NsPrefix,
            pNamespace,
            &Comparison);

        if (Comparison != XML_STRING_COMPARE_EQUALS)
            return false;
    }

    m_XmlState.ParseState.pfnCompareSpecialString(
        &m_XmlState.ParseState,
        &Element.Name,
        pName,
        &Comparison);

    return Comparison == XML_STRING_COMPARE_EQUALS;
}

bool CXmlMiniTokenizer::Initialize(
    XML_EXTENT &Source, 
    CLogicalXmlParser &BaseParser
    )
{
    NTSTATUS status;
    
    status = RtlXmlCloneRawTokenizationState(
        &BaseParser.m_XmlState.ParseState.RawTokenState, 
        &RawState);
    
    ulCharacter = 0;
    RawState.pvLastCursor = RawState.pvCursor = Source.pvData;
    RawState.pvDocumentEnd = (PVOID)(((ULONG_PTR)Source.pvData) + Source.cbData);

    return NT_SUCCESS(status);
}

void CXmlMiniTokenizer::Next()
{
    ASSERT(this->More());

    ASSERT(RawState.cbBytesInLastRawToken == RawState.DefaultCharacterSize);
    ASSERT(RawState.NextCharacterResult == STATUS_SUCCESS);

    this->ulCharacter = RawState.pfnNextChar(&RawState);

    if ((ulCharacter == 0) && !NT_SUCCESS(RawState.NextCharacterResult)) {
        this->TokenName = NTXML_RAWTOKEN_ERROR;
        return;
    }

    this->TokenName = _RtlpDecodeCharacter(this->ulCharacter);

    RawState.pvCursor = (PVOID)(((ULONG_PTR)RawState.pvCursor) + RawState.cbBytesInLastRawToken);

    if (RawState.cbBytesInLastRawToken != RawState.DefaultCharacterSize)
        RawState.cbBytesInLastRawToken = RawState.DefaultCharacterSize;
}

//
// The default digestion operation is to digest with UTF-8 encoding
// of characters.
//
class CUTF8BaseDigester
{
    CHashObject &m_Context;
    CLogicalXmlParser *m_pXmlParser;
    
protected:
    enum { eMaxCharacterEncodingBytes = 3 };

    //
    // These are 'special' XML characters that are already UTF-8
    // (or whatever) encoded. These can be hashed as-is
    //
    class XmlSpecialMarkers {
    public:
        static CHAR s_XmlOpenTag[];
        static CHAR s_XmlCloseTag[];
        static CHAR s_XmlCloseEmptyTag[];
        static CHAR s_XmlOpenCloseTag[];
        static CHAR s_XmlNsDelimiter[];
        static CHAR s_XmlWhitespace[];
        static CHAR s_XmlEqualsDQuote[];
        static CHAR s_XmlDQuote[];
    };

    //
    // This encoder uses UTF-8; feel free to derive from this class and implement
    // your own encoding; do -not- make this virtual, force the compiler to use
    // yours so you get the inline/fastcall benefits.  CDige
    //
    inline SIZE_T __fastcall EncodeCharacter(ULONG ucs2Char, PBYTE pbTarget)
    {
        if (ucs2Char <= 0x7f)
        {
            pbTarget[0] = (BYTE)(ucs2Char & 0x7f);
            return 1;
        }
        else if (ucs2Char <= 0x7ff)
        {
            pbTarget[0] = (BYTE)(0xC0 | ((ucs2Char >> 6) & 0x1f));
            pbTarget[1] = (BYTE)(0x80 | (ucs2Char & 0x3F));
            return 2;
        }
        else if (ucs2Char <= 0x7fff)
        {
            pbTarget[0] = (BYTE)(0xE0 | ((ucs2Char >> 12) & 0xF));
            pbTarget[1] = (BYTE)(0x80 | ((ucs2Char >> 6) & 0x3F));
            pbTarget[2] = (BYTE)(0x80 | (ucs2Char & 0x3F));
            return 3;
        }
        else
        {
            return 0;
        }
    }

    inline bool __fastcall EncodeAndHash(const ULONG *ucs2Char, SIZE_T cChars)
    {
        BYTE bDumpArea[eMaxCharacterEncodingBytes];
        SIZE_T cCursor = 0;

        while (cCursor < cChars)
        {
            const SIZE_T cThisSize = EncodeCharacter(ucs2Char[cCursor++], bDumpArea);
            if (cThisSize == 0)
                return false;

            AddHashData(bDumpArea, cThisSize);
        }

        return true;
    }

    bool HashDirectly(XML_EXTENT &eExtent)
    {
        ASSERT(eExtent.Encoding == XMLEF_UTF_8_OR_ASCII);

        if (eExtent.Encoding != XMLEF_UTF_8_OR_ASCII)
            return false;

        return AddHashData(eExtent.pvData, eExtent.cbData);
    }

    //
    // This digests an element open tag as follows:
    //
    // Element, no attributes:          <{ns:}name>
    // Empty element, no attributes:    <{ns:}name></{ns:}name>
    // Element, attributes:             <{ns:}name [{atns:}attrib="text"]xN>
    // Empty element, attributes:       <{ns:}name [{atns:}attrib="text"]xN/>
    //
    template <CHAR *szChars>
    FastHash() {

        #define IS_MARKER(q) if (szChars == XmlSpecialMarkers::q) { AddHashData(XmlSpecialMarkers::q, NUMBER_OF(XmlSpecialMarkers::q)); }

        IS_MARKER(s_XmlOpenTag) else
        IS_MARKER(s_XmlCloseTag) else
        IS_MARKER(s_XmlCloseEmptyTag) else
        IS_MARKER(s_XmlOpenCloseTag) else
        IS_MARKER(s_XmlNsDelimiter) else
        IS_MARKER(s_XmlWhitespace) else
        IS_MARKER(s_XmlEqualsDQuote) else
        IS_MARKER(s_XmlDQuote);
    }

    BYTE m_bHashPrebuffer[64];
    SIZE_T m_cHashPrebufferUsed;

    // This could be more intelligent about ensuring that we fill the buffer up from the input
    // before hashing, but it seems like any sort of buffering at all is a huge win.
    inline bool __fastcall AddHashDataInternal(PVOID pvData, SIZE_T cbData) {

        // If this would overflow the internal buffer, or the input size is larger than
        // the available buffer, then always flush.
        if (((m_cHashPrebufferUsed + cbData) > NUMBER_OF(m_bHashPrebuffer)) || (cbData > NUMBER_OF(m_bHashPrebuffer))) {
            m_Context.Hash(CEnv::CByteRegion(m_bHashPrebuffer, m_cHashPrebufferUsed));
            m_cHashPrebufferUsed = 0;
        }

        // The input size was too large to fit in the prebuffer, hash it directly
        if (cbData > NUMBER_OF(m_bHashPrebuffer)) 
        {
            if (CEnv::DidFail(m_Context.Hash(CEnv::CByteRegion((PBYTE)pvData, m_cHashPrebufferUsed))))
                return false;
        }
        // Otherwise, copy the data into the prebuffer, update the used size
        else 
        {
            memcpy(&m_bHashPrebuffer[m_cHashPrebufferUsed], pvData, cbData);
            m_cHashPrebufferUsed += cbData;
        }

        return true;
    }

    inline bool __fastcall AddHashData(PVOID pvData, SIZE_T cData) { return AddHashDataInternal(pvData, cData); }
    template <typename T> inline bool __fastcall AddHashData(T *pData, SIZE_T cData) { return AddHashDataInternal((PVOID)pData, cData * sizeof(T)); }
    template <typename T> inline bool __fastcall AddHashData(T cSingleData) { return AddHashDataInternal(&cSingleData, sizeof(T)); }
    
    bool Digest(XMLDOC_ELEMENT &Element, CAttributeList &Attributes)
    {
        bool fSuccess = false;

        FastHash<XmlSpecialMarkers::s_XmlOpenTag>();

        if (Element.NsPrefix.ulCharacters != 0)
        {
            if (!Digest(Element.NsPrefix, false))
                goto Exit;

            FastHash<XmlSpecialMarkers::s_XmlNsDelimiter>();
        }

        if (!Digest(Element.Name, false))
            goto Exit;

        //
        // Now digest the attributes, ensuring that a whitespace appears between them.  The
        // initial whitespace ensures one between the element name and the first attribute
        //
        for (ULONG ul = 0; ul < Element.ulAttributeCount; ul++)
        {
            XMLDOC_ATTRIBUTE &Attrib = Attributes[ul];

            FastHash<XmlSpecialMarkers::s_XmlWhitespace>();
                
            if (!Digest(Attrib))
                goto Exit;
        }

        FastHash<XmlSpecialMarkers::s_XmlCloseTag>();

        //
        // Empty elements implicitly get a </close>, so do the above stuff again
        //
        if (Element.fElementEmpty)
        {
            FastHash<XmlSpecialMarkers::s_XmlOpenCloseTag>();

            if (Element.NsPrefix.ulCharacters != 0)
            {
                if (!Digest(Element.NsPrefix, false))
                    goto Exit;

                FastHash<XmlSpecialMarkers::s_XmlNsDelimiter>();
            }

            if (!Digest(Element.Name, false))
                goto Exit;

            FastHash<XmlSpecialMarkers::s_XmlCloseTag>();
        }

        fSuccess = true;
    Exit:
        return fSuccess;
    }


    //
    // Attributes get digested as:
    //
    // {attrnamespace:}attribname="attribvalue"
    //
    // where attribvalue is treated like pcdata for whitespace-compression purposes
    //
    bool Digest(XMLDOC_ATTRIBUTE &Attribute)
    {
        bool fSuccess = false;
        
        if (Attribute.NsPrefix.ulCharacters != 0)
        {
            if (!Digest(Attribute.NsPrefix, false))
                goto Exit;

            FastHash<XmlSpecialMarkers::s_XmlNsDelimiter>();
        }

        if (!Digest(Attribute.Name, false))
            goto Exit;

        FastHash<XmlSpecialMarkers::s_XmlEqualsDQuote>();

        if (!Digest(Attribute.Value, true))
            goto Exit;

        FastHash<XmlSpecialMarkers::s_XmlDQuote>();

        fSuccess = true;
    Exit:
        return fSuccess;
    }
    
    //
    // Digests the xml extent in question.  If the xml parser is in UTF-8 mode, and we're
    // doing CData mode (ie: pcdata == false), then we can simply throw the raw bits through
    // the hasher.  Otherwise, we have to do whitespace compression and whatnot.
    //
    bool Digest(XML_EXTENT &CData, bool WhitespaceCompression)
    {
        CXmlMiniTokenizer MiniTokenizer;
        bool fFoundSomethingLast = false;
        bool fSuccess = false;

        if (CData.cbData == 0)
            return true;

        //
        // PCDATA (the stuff in attributes, between elements, etc.) gets
        // whitespace-compressed by the following rules:
        //
        // Complete-whitespace hyperspace chunk becomes "nothing"
        // - ex: <foo>   <bar>              Zero bytes
        // - ex: <foo></foo>                Zero bytes (see <foo/> in the ELEMENT digester above
        // - ex: <foo>  f   </foo>          Effectively, "f"
        // - ex: <foo>  a  b   </foo>       Effectively, "a b"
        // - ex: <foo>  a  </foo>
        //
        MiniTokenizer.Initialize(CData, *this->m_pXmlParser);

#define FLUSH_BUFFER(buff, used) do { \
    if (!EncodeAndHash((buff), (used))) goto Exit; \
    (used) = 0; \
} while (0) 

#define CHECK_FLUSH_BUFFER(buff, used, toaddsize) do { \
    if (((used) + (toaddsize)) >= NUMBER_OF(buff)) { \
        FLUSH_BUFFER(buff, used); \
        (used) = 0; \
    } } while (0)
            
#define ADD_BUFFER(buff, used, toadd, toaddsize) do { \
    CHECK_FLUSH_BUFFER(buff, used, toaddsize); \
    ASSERT(toaddsize < NUMBER_OF(buff)); \
    memcpy(&((buff)[used]), (toadd), sizeof(toadd[0]) * toaddsize); \
    } while (0)

#define ADD_SINGLE(buff, used, toadd) do { \
    CHECK_FLUSH_BUFFER(buff, used, 1); \
    (buff)[(used)++] = toadd; \
    } while (0)

        if (WhitespaceCompression)
        {
            ULONG ulDecodedBuffer[128];
            SIZE_T cDecodedUsed = 0;

            MiniTokenizer.Next();

            do
            {
                //
                // Skip past all whitespace
                //
                while ((MiniTokenizer.More() && (MiniTokenizer.Name() == NTXML_RAWTOKEN_WHITESPACE)))
                    MiniTokenizer.Next();

                //
                // Stop if we ran out
                //
                if (!MiniTokenizer.More())
                    break;

                //
                // Now, if we'd found something before, add a whitespace marker onto the
                // list of items to encode 
                //
                if (fFoundSomethingLast)
                {
                    FLUSH_BUFFER(ulDecodedBuffer, cDecodedUsed);
                    FastHash<XmlSpecialMarkers::s_XmlWhitespace>();
                }

                //
                // Spin through the elements that are now present, up to another whitespace
                //
                while (MiniTokenizer.More() && (MiniTokenizer.Name() != NTXML_RAWTOKEN_WHITESPACE))
                {
                    if (!fFoundSomethingLast)
                        fFoundSomethingLast = true;
                    ADD_SINGLE(ulDecodedBuffer, cDecodedUsed, MiniTokenizer.Character());
                    
                    MiniTokenizer.Next();
                }
            }
            while (MiniTokenizer.More());

            //
            // Flush out leftover elements
            //
            if (cDecodedUsed != 0)
            {
                EncodeAndHash(ulDecodedBuffer, cDecodedUsed);
            }

        }
        else
        {
            if (CData.Encoding == XMLEF_UTF_8_OR_ASCII)
            {
                HashDirectly(CData);
            }
            else
            {
                ULONG ulBuffer[50];
                SIZE_T cTotal = 0;
                
                MiniTokenizer.Next();
                while (MiniTokenizer.More()) {
                    ADD_SINGLE(ulBuffer, cTotal, MiniTokenizer.Character());
                    MiniTokenizer.Next();
                }

                if (cTotal > 0) 
                {
                    EncodeAndHash(ulBuffer, cTotal);
                }                
            }
        }

        fSuccess = true;
    Exit:
        return fSuccess;
    }

    //
    // To digest an end element, we use </{ns:}element>
    //
    bool Digest(XMLDOC_ENDELEMENT &EndElement)
    {
        bool fSuccess = false;
        
        FastHash<XmlSpecialMarkers::s_XmlOpenCloseTag>();

        if (EndElement.NsPrefix.ulCharacters != 0)
        {
            if (!Digest(EndElement.NsPrefix, true))
                goto Exit;

            FastHash<XmlSpecialMarkers::s_XmlNsDelimiter>();
        }
        
        if (!Digest(EndElement.Name, true))
            goto Exit;

        FastHash<XmlSpecialMarkers::s_XmlCloseTag>();

        fSuccess = true;
    Exit:
        return fSuccess;
    }

    const static CEnv::CConstantUnicodeStringPair DigesterIdentifier;

public:
    CUTF8BaseDigester(CHashObject &Hasher) : m_cHashPrebufferUsed(0), m_Context(Hasher), m_pXmlParser(NULL) { }

    static const CEnv::CConstantUnicodeStringPair &GetDigesterIdentifier() { return DigesterIdentifier; }

    void SetXmlParser(CLogicalXmlParser *pSourceParser) { this->m_pXmlParser = pSourceParser; }

    bool Digest(XMLDOC_THING &Thing, CAttributeList &Attributes)
    {
        switch (Thing.ulThingType)
        {
        case XMLDOC_THING_ELEMENT:
            return Digest(Thing.Element, Attributes);
            break;
            
        case XMLDOC_THING_HYPERSPACE:
            return Digest(Thing.Hyperspace, true);
            break;
            
        case XMLDOC_THING_CDATA:
            return HashDirectly(Thing.CDATA);

        case XMLDOC_THING_END_ELEMENT:
            return Digest(Thing.EndElement);            
        }

        return false;
    }

    bool Finalize() {
        if (m_cHashPrebufferUsed > 0) {
            return !CEnv::DidFail(m_Context.Hash(CEnv::CByteRegion(m_bHashPrebuffer, m_cHashPrebufferUsed)));
        }
        return true;
    }
};

const CEnv::CConstantUnicodeStringPair CUTF8BaseDigester::DigesterIdentifier = CEnv::CConstantUnicodeStringPair(L"sxs-dsig-ops#default-digestion", NUMBER_OF(L"default-digestion"));
CHAR CUTF8BaseDigester::XmlSpecialMarkers::s_XmlOpenTag[] = { '<' };
CHAR CUTF8BaseDigester::XmlSpecialMarkers::s_XmlCloseTag[] = { '>' };
CHAR CUTF8BaseDigester::XmlSpecialMarkers::s_XmlCloseEmptyTag[] = { '/', '>' };
CHAR CUTF8BaseDigester::XmlSpecialMarkers::s_XmlOpenCloseTag[] = { '<', '/' };
CHAR CUTF8BaseDigester::XmlSpecialMarkers::s_XmlNsDelimiter[] = { ':' };
CHAR CUTF8BaseDigester::XmlSpecialMarkers::s_XmlWhitespace[] = { ' ' };
CHAR CUTF8BaseDigester::XmlSpecialMarkers::s_XmlEqualsDQuote[] = { '=', '\"' };
CHAR CUTF8BaseDigester::XmlSpecialMarkers::s_XmlDQuote[] = { '\"' };

const XML_SPECIAL_STRING c_ss_Signature         = MAKE_SPECIAL_STRING("Signature");
const XML_SPECIAL_STRING c_ss_SignedInfo        = MAKE_SPECIAL_STRING("SignedInfo");
const XML_SPECIAL_STRING c_ss_SignatureValue    = MAKE_SPECIAL_STRING("SignatureValue");
const XML_SPECIAL_STRING c_ss_KeyInfo           = MAKE_SPECIAL_STRING("KeyInfo");
const XML_SPECIAL_STRING c_ss_Object            = MAKE_SPECIAL_STRING("Object");
const XML_SPECIAL_STRING c_ss_XmlNsSignature    = MAKE_SPECIAL_STRING("http://www.w3.org/2000/09/xmldsig#");

bool operator==(const XMLDOC_ELEMENT &left, const XMLDOC_ELEMENT &right)
{
    return (left.Name.pvData == right.Name.pvData);
}

void ReverseMemCpy(
    PVOID pvTarget,
    const void* pcvSource,
    SIZE_T cbBytes
    )
{
    const BYTE *pbSource = ((const BYTE*)pcvSource) + cbBytes - 1;
    PBYTE pbTarget = (PBYTE)pvTarget;

    while (cbBytes--)
        *pbTarget++ = *pbSource--;
}
    

CEnv::StatusCode
EncodePKCS1Hash(
    const CHashObject &SourceHash,
    SIZE_T cbPubKeyDataLen,
    CByteBlob &Output
    )
{
    const CEnv::CConstantByteRegion &HashOid = SourceHash.GetOid();
    CEnv::CConstantByteRegion HashData;
    CEnv::CByteRegion OutputRange;
    CEnv::StatusCode Result = CEnv::SuccessCode;
    PBYTE pbWorking;

    if (!Output.EnsureSize(cbPubKeyDataLen)) {
        Result = CEnv::OutOfMemory;
        goto Exit;
    }

    if (CEnv::DidFail(Result = SourceHash.GetValue(HashData)))
        goto Exit;

    OutputRange = Output.GetMutableRange();
    pbWorking = OutputRange.GetPointer();

    //
    // Set the well-known bytes
    //
    pbWorking[cbPubKeyDataLen - 1] = 0x01;
    memset(pbWorking, 0xff, cbPubKeyDataLen - 1);

    //
    // Copy the source hash data 'backwards'
    //
    ReverseMemCpy(pbWorking, HashData.GetPointer(), HashData.GetCount());
    pbWorking += HashData.GetCount();
    
    memcpy(pbWorking, HashOid.GetPointer(), HashOid.GetCount());
    pbWorking += HashOid.GetCount();

    *pbWorking = 0;

    Result = CEnv::SuccessCode;
Exit:
    return Result;
}



bool SignHashContext(
    const CHashObject &SourceHash,
    LPBSAFE_PRV_KEY lpPrivateKey,
    LPBSAFE_PUB_KEY lpPublicKey,
    CByteBlob &Output
    )
{
    CEnv::CByteRegion OutputRange = Output.GetMutableRange();
    SIZE_T cbSignatureSize = (lpPublicKey->bitlen+7)/8;
    PBYTE pbInput, pbWork, pbSigT;

    CByteBlob WorkingBlob;

    //
    // Set up and clear the output buffer
    //
    Output.EnsureSize(lpPublicKey->keylen);
    memset(OutputRange.GetPointer(), 0, OutputRange.GetCount());

    //
    // Put this object into a PKCS1-compliant structure for signing
    //
    if (EncodePKCS1Hash(SourceHash, lpPublicKey->keylen, WorkingBlob))
    {
        if (BSafeDecPrivate(lpPrivateKey, WorkingBlob.GetMutableRange().GetPointer(), OutputRange.GetPointer()))
        {
            return true;
        }
    }

    return false;
}

bool VerifySignature(
    const CHashObject &SourceHash,
    const CEnv::CConstantByteRegion &Signature,
    LPBSAFE_PUB_KEY lpPublicKey
    )
{
    return true;
}


/*

Validating a document signature is pretty easy from our current point of view.
You spin over the contents of the document, hashing all the hashable stuff.
At some point, you should find a <Signature> element, inside which is a <SignedInfo>
element.  You should start another hashing context over the contents of the
<SignedInfo> data.  When that's done, you should have found:

<Signature>
    <SignedInfo>
        <CanonicalizationMethod Algorithm="sidebyside-manifest-canonicalizer"/>
        <Reference>
            <Transforms Algorithm="sidebyside-manifest-digestion#standard-transform"/>
            <DigestMethod Algorithm="sidebyside-manifest-digestion#sha1"/>
            <DigestValue>...</DigestValue>
        </Reference>
        <SignatureMethod Algorithm="sidebyside-manifest-digestion#dsa-sha1"/>
    </SignedInfo>
    <SignatureValue>(signed data goes here)</SignatureValue>
    <KeyInfo>...</KeyInfo>
</Signature>
*/    

bool Base64EncodeBytes(
    const CEnv::CConstantByteRegion &Bytes,
    CEnv::CStringBuffer &Output
    )
{
    SIZE_T cCharsNeeded = 0;
    CArrayBlob<WCHAR, SIZE_T> B64Encoding;
    

    RtlBase64Encode((PVOID)Bytes.GetPointer(), Bytes.GetCount(), NULL, &cCharsNeeded);
    
    if (!B64Encoding.EnsureSize(cCharsNeeded))
        return false;
    
    RtlBase64Encode(
        (PVOID)Bytes.GetPointer(), 
        Bytes.GetCount(), 
        B64Encoding.GetMutableRange().GetPointer(),
        &cCharsNeeded);

    if (!Output.Assign(B64Encoding.GetRange()))
        return false;

    return true;
}


bool
CreateSignatureElement(
    CEnv::CStringBuffer &Target,
    const CEnv::CConstantByteRegion &HashValue,
    const CEnv::CConstantUnicodeStringPair &DigestMethod
    )
{
    static const WCHAR chFormatString[] = 
        L"<SignedInfo>\r\n"
        L"   <CanonicalizationMethod Algorithm='%ls'/>\r\n"
        L"   <Reference>\r\n"
        L"       <DigestMethod Algorithm='%ls'/>\r\n"
        L"       <DigestValue>%ls</DigestValue>\r\n"
        L"   </Reference>\r\n"
        L"   <SignatureMethod Algorithm='%ls'/>\r\n"
        L"</SignedInfo>\r\n";

    Target.Clear();

    return true;
}

template <typename TDigester, typename THashContext>
bool HashXmlSection(
    CEnv::CConstantByteRegion &XmlRange,
    CByteBlob &HashValue
    )
{
    THashContext        HashContext;
    TDigester           DigestEngine(HashContext);
    CEnv::CConstantByteRegion  InternalHashValue;
    CLogicalXmlParser   Parser;

    Parser.Initialize((PVOID)XmlRange.GetPointer(), XmlRange.GetCount());
    DigestEngine.SetXmlParser(&Parser);

    HashContext.Initialize();

    do
    {
        XMLDOC_THING ThisThing;
        
        if (!Parser.Next(ThisThing))
            break;

        //
        // If this thing is a "signature" element, then we need
        // to skip its body
        //
        if ((ThisThing.ulThingType == XMLDOC_THING_ELEMENT) &&
            Parser.IsThisNode(ThisThing.Element, &c_ss_Signature, &c_ss_XmlNsSignature))
        {
            Parser.SkipElement(ThisThing.Element);
        }
        //
        // Otherwise, everybody gets hashed
        //
        else
        {
            DigestEngine.Digest(ThisThing, Parser.Attributes());
        }
    }
    while (Parser.More());

    DigestEngine.Finalize();
    HashContext.Finalize();

    HashContext.GetValue(InternalHashValue);
    HashValue.Initialize(InternalHashValue);

    return true;
}
    

    

void GetSignatureOf(PCWSTR pcwsz)
{
    PVOID               pvFileBase;
    SIZE_T              cbFileBase;
    NTSTATUS            status;
    UNICODE_STRING      usFilePath;
    XMLDOC_THING        XmlThing = { XMLDOC_THING_PROCESSINGINSTRUCTION };
    LARGE_INTEGER       liStart, liEnd, liTotal;
    DWORD               dwBitLength = 2048;
    DWORD               dwPubKeySize, dwPrivKeySize;
    LPBSAFE_PUB_KEY     pPubKey;
    LPBSAFE_PRV_KEY     pPriKey;
    CByteBlob           SignedResult;
    const int           iCount = 100;
    CEnv::CConstantByteRegion XmlSection;
    
    status = RtlOpenAndMapEntireFile(pcwsz, &pvFileBase, &cbFileBase);
    if (!NT_SUCCESS(status)) {
        return;
    }

    XmlSection.SetPointerAndCount((PBYTE)pvFileBase, cbFileBase);

    //
    // Print, then sign the hash
    //    
    BSafeComputeKeySizes(&dwPubKeySize, &dwPrivKeySize, &dwBitLength);
    pPubKey = (LPBSAFE_PUB_KEY)HeapAlloc(GetProcessHeap(), 0, dwPubKeySize);
    pPriKey = (LPBSAFE_PRV_KEY)HeapAlloc(GetProcessHeap(), 0, dwPrivKeySize);
    BSafeMakeKeyPair(pPubKey, pPriKey, dwBitLength);

    
    liTotal.QuadPart = 0;
    for (int i = 0; i < iCount; i++)
    {
        QueryPerformanceCounter(&liStart);
        CEnv::CStringBuffer SignatureBlob;
        CEnv::CConstantByteRegion HashResults;
        CByteBlob HashValue;
        
        HashXmlSection<CUTF8BaseDigester, CSha1HashObject>(XmlSection, HashValue);

        QueryPerformanceCounter(&liEnd);
        liTotal.QuadPart += liEnd.QuadPart - liStart.QuadPart;

        if (i == 0)
        {
            HashResults = HashValue.GetRange();
            printf("\r\n");
            for (SIZE_T c = 0; c < HashResults.GetCount(); c++) {
                printf("%02x", HashResults.GetPointer()[c]);
            }
            printf("\r\n");
        }
    }

    QueryPerformanceFrequency(&liEnd);

    wprintf(
        L"%I64d cycles, %f seconds", 
        liTotal.QuadPart / iCount,
        (double)((((double)liTotal.QuadPart) / iCount) / ((double)liEnd.QuadPart)));

    RtlUnmapViewOfFile(pvFileBase);
}

void __cdecl wmain(int argc, wchar_t *argv[])
{
    GetSignatureOf(argv[1]);
}





bool CLogicalXmlParser::Reset()
{
    bool fSuccess = true;

    if (!m_fInitialized)
        return true;
    
    if (!NT_SUCCESS(RtlNsDestroy(&m_Namespaces)))
        fSuccess = false;
    
    if (!NT_SUCCESS(RtlXmlDestroyNextLogicalThing(&m_XmlState)))
        fSuccess = false;

    m_fInitialized = false;

    return fSuccess;
}

bool CLogicalXmlParser::Initialize(PVOID pvXmlBase, SIZE_T cbDocumentSize)
{
    NTSTATUS status;

    ASSERT(!m_fInitialized);

    RTL_ALLOCATOR Alloc = { StaticAllocate, StaticFree, this };

    status = RtlNsInitialize(
        &m_Namespaces, 
        StaticCompareStrings, this,
        &Alloc);
    if (!NT_SUCCESS(status)) {
        return false;
    }

    status = RtlXmlInitializeNextLogicalThing(
        &m_XmlState, 
        pvXmlBase, 
        cbDocumentSize,
        &Alloc);
    if (!NT_SUCCESS(status)) {
        RtlNsDestroy(&m_Namespaces);
        return false;
    }

    if (!m_Attributes.Initialize()) {
        RtlNsDestroy(&m_Namespaces);
        RtlXmlDestroyNextLogicalThing(&m_XmlState);
        return false;
    }

    m_fInitialized = true;
    return true;
}

bool CLogicalXmlParser::More() const
{
    return m_XmlState.ParseState.PreviousState != XTSS_STREAM_END;
}

bool CLogicalXmlParser::Next(XMLDOC_THING &XmlDocThing)
{
    NTSTATUS status;

    status = RtlXmlNextLogicalThing(&m_XmlState, &m_Namespaces, &XmlDocThing, &m_Attributes);
    return NT_SUCCESS(status);
}


//
// This parades through the document looking for the "end" of this element.
// When this function returns, the following "Next" call will get the document
// chunklet that's after the closing of the element.
//
bool CLogicalXmlParser::SkipElement(XMLDOC_ELEMENT &Element)
{
    if (Element.fElementEmpty)
    {
        return true;
    }
    else
    {
        XMLDOC_THING NextThing;

        do
        {
            if (!this->Next(NextThing))
                return false;

            if ((NextThing.ulThingType == XMLDOC_THING_END_ELEMENT) &&
                (NextThing.EndElement.OpeningElement == Element))
            {
                break;
            }
        }
        while (this->More());

        return true;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\unique\unique.c ===
/*
This program ...
*/
#include <stdio.h>
#include <string.h>

void Unique()
{
#define BUFFER_SIZE (1024)
    char buffer1[BUFFER_SIZE];
    char buffer2[BUFFER_SIZE];
    char * buffers[2];
    unsigned ibuffer = 0;
    unsigned first = 1;

    buffers[0] = buffer1;
    buffers[1] = buffer2;

    while (fgets(buffers[ibuffer], BUFFER_SIZE, stdin))
    {
        if (first)
        {
            first = 0;
            fputs(buffers[ibuffer], stdout);
            ibuffer ^= 1;
        }
        else
        {
            if (strcmp(buffers[ibuffer], buffers[ibuffer ^ 1]) != 0)
            {
                fputs(buffers[ibuffer], stdout);
                ibuffer ^= 1;
            }
            else
            {
                /* do nothing */
            }
        }
    }
}

int __cdecl main()
{
	Unique();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\uniquizefusioncatalognames\uniquizefusioncatalognames.c ===
/*
read a file that
has semicolon initiated comments
and lines with five or six space delimited columns
make the sixth column match the last path element of the first column, %02d.cat, with %02d increasing.
*/
#include "strtok_r.h"
#include "strtok_r.c"
#if defined(NULL)
#undef NULL
#endif
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#include <stdio.h>
#include <string.h>
typedef unsigned long ULONG;
typedef int BOOL;
#define TRUE 1
#define FALSE 0
#define MAX_PATH 260
#pragma warning(disable:4706) /* assignment within conditional */
#pragma warning(disable:4100) /* unused parameter */

BOOL IsComment(const char * s)
{
    s += strspn(s, " \t");
    if (*s == 0 || *s == ';')
        return TRUE;
    return FALSE;
}

void SplitFields(char * String, const char * Delims, char ** Fields, ULONG MaxNumberOfFields, ULONG * NumberOfFields)
{
    char * Field = 0;
    char * strtok_state = 0;
    *NumberOfFields = 0;

    for ( *NumberOfFields += ((Fields[*NumberOfFields] = Field = strtok_r(String, Delims, &strtok_state)) ? 1 : 0) ;
            Field && *NumberOfFields < MaxNumberOfFields;
            *NumberOfFields += ((Fields[*NumberOfFields] = Field = strtok_r(NULL, Delims, &strtok_state)) ? 1 : 0) )
    {
    }
}

char * GetLastPathElement(char * s)
{
    char * t = strrchr(s, '/');
    char * u = strrchr(s, '\\');

    if (t == NULL && u == NULL)
        return NULL;
    if (t == NULL && u != NULL)
        return u + 1;
    if (u == NULL && t != NULL)
        return t + 1;
    if (t > u)
        return t + 1;
    return u + 1;
}

char * GetExtension(char * s)
{
    return strrchr(s, '.');
}

void ChangeExtension(char * s, const char * t)
{
    s = GetExtension(s);
    if (s != NULL)
        strcpy(s, t);
}

void Echo(const char * s)
{
    printf("%s\n", s);
}

BOOL Readline(FILE * File, char * Buffer, ULONG BufferSize)
{
    return (fgets(Buffer, BufferSize, File) ? TRUE : FALSE);
}

void TrimLeadingAndTrailingWhitespace(char * s)
{
    char * t = s + strspn(s, " \t");
    if (t != s)
        memmove(s, t, strlen(t) + 1);
    if (*s == 0)
        return;
    for ( t = s + strlen(s) ; t != s ; --t )
    {
        if (strchr(" \t", *(t - 1)))
            *(t - 1) = 0;
        else
            break;
    }
}

void RemoveTrailingNewline(char * s)
{
    if (*s == 0)
        return;
    s += strlen(s) - 1;
    if (*s == '\n')
        *s = 0;
}

void UniquizeFusionCatalogNames(int argc, char ** argv)
{
    static const char Function[] = __FUNCTION__;
    static const char SourceFile[] = __FILE__;
#define SourceLine ((int)__LINE__)
    ULONG Counter = 0;
    char OriginalLine[MAX_PATH * 6];
    char Line[MAX_PATH * 6];
    char * Fields[16] = { 0 };
    ULONG NumberOfFields = 0;
    char * Extension = 0;
    ULONG i = 0;
    char * LastPathElement = 0;
    FILE * File;
    size_t LineLength;

    File = stdin;
    if (argv[0] != NULL && argv[1] != NULL && argv[1][0] != 0)
    {
        File = fopen(argv[1], "r");
        if (File == NULL)
        {
            fprintf(stderr, "%s:%s:%d failed to open %s\n", SourceFile, Function, SourceLine, argv[1]);
            goto Exit;
        }
    }

    while (Readline(File, OriginalLine, NUMBER_OF(OriginalLine)))
    {
        strcpy(Line, OriginalLine);
        _strlwr(Line);
        RemoveTrailingNewline(Line);
        if (IsComment(Line))
        {
            Echo(Line);
            continue;
        }
        TrimLeadingAndTrailingWhitespace(Line);
        LineLength = strlen(Line);
        SplitFields(Line, " \t", Fields, NUMBER_OF(Fields), &NumberOfFields);
        //printf("NumberOfFields %lu\n", NumberOfFields);
        if (NumberOfFields != 5 && NumberOfFields != 6)
        {
            Echo(Line);
            continue;
        }
        if (NumberOfFields == 5)
        {
            Fields[5] = Line + LineLength + 1;
        }
        LastPathElement = GetLastPathElement(Fields[0]);
        if (LastPathElement == NULL)
        {
            fprintf(stderr, "%s:%s:%d failed to get last path element, Line=%s\n", SourceFile, Function, SourceLine, OriginalLine);
            goto Exit;
        }
        memmove(Fields[5], LastPathElement, strlen(LastPathElement) + 1);
        Extension = GetExtension(Fields[5]);
        if (Extension == NULL)
        {
            fprintf(stderr, "%s:%s:%d failed to get extension, Line=%s\n", SourceFile, Function, SourceLine, OriginalLine);
            goto Exit;
        }
        sprintf(Extension, "%03lu.cat", ++Counter);
        for ( i = 0 ; i != 5 ; ++i)
        {
            Fields[i][strlen(Fields[i])] = ' ';
        }
        Echo(Line);
    }
Exit:
    return;
}

int __cdecl main(int argc, char ** argv)
{
    UniquizeFusionCatalogNames(argc, argv);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\digesters.h ===
#pragma once

#include "bcl_common.h"

class CHashObject;

class CDigestMethod
{
public:
    virtual ~CDigestMethod();
    virtual CEnv::StatusCode DigestExtent(CHashObject &Hash, SIZE_T Offset, const CEnv::CConstantByteRegion &Bytes);
    virtual CEnv::StatusCode Initialize(CHashObject &Hash);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\identbuilder\identrospection.h ===
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\apps\perftest\driver.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "fci.h"
#include "stdio.h"
#include "sxs-rtl.h"
#include "fasterxml.h"
#include "skiplist.h"
#include "namespacemanager.h"
#include "xmlstructure.h"

#ifdef INVALID_HANDLE_VALUE
#undef INVALID_HANDLE_VALUE
#endif
#include "windows.h"
#include "stdlib.h"

NTSTATUS FASTCALL
MyAllocator(SIZE_T cb, PVOID* pvOutput, PVOID pvAllocContext) {
    ASSERT(pvAllocContext == NULL);
    *pvOutput = RtlAllocateHeap(RtlProcessHeap(), 0, cb);
    return *pvOutput ? STATUS_SUCCESS : STATUS_NO_MEMORY;
}

NTSTATUS FASTCALL
MyFreer(PVOID pv, PVOID pvAllocContext) {
    ASSERT(pvAllocContext == NULL);
    return RtlFreeHeap(RtlProcessHeap(), 0, pv) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;    
}

EXTERN_C RTL_ALLOCATOR g_DefaultAllocator = {MyAllocator, MyFreer, NULL};


void GetFormattedStateName(
    XML_TOKENIZATION_SPECIFIC_STATE State,
    CHAR *rgszBuffer,
    SIZE_T cchBuffer
    )
{
    CHAR *pszSpecific = NULL;
    SIZE_T cchSpecific = 0;

#define STRINGIFY(str, sz, cch) case str: sz = #str; cch = NUMBER_OF(#str) - 1; break

    switch(State) {
        STRINGIFY(XTSS_ERRONEOUS, pszSpecific, cchSpecific);

        STRINGIFY(XTSS_ELEMENT_OPEN, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_NAME, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_CLOSE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_CLOSE_EMPTY, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_ATTRIBUTE_NAME, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_ATTRIBUTE_EQUALS, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_ATTRIBUTE_OPEN, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_ATTRIBUTE_CLOSE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_ATTRIBUTE_VALUE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_WHITESPACE, pszSpecific, cchSpecific);

        STRINGIFY(XTSS_ELEMENT_XMLNS, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_XMLNS_DEFAULT, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_XMLNS_ALIAS, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_XMLNS_COLON, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_XMLNS_EQUALS, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_XMLNS_VALUE_OPEN, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_XMLNS_VALUE_CLOSE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_XMLNS_VALUE, pszSpecific, cchSpecific);

        STRINGIFY(XTSS_ELEMENT_NAME_NS_PREFIX, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_NAME_NS_COLON, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_ATTRIBUTE_NAME_NS_PREFIX, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ELEMENT_ATTRIBUTE_NAME_NS_COLON, pszSpecific, cchSpecific);

        STRINGIFY(XTSS_ENDELEMENT_OPEN, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ENDELEMENT_NAME, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ENDELEMENT_WHITESPACE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_ENDELEMENT_CLOSE, pszSpecific, cchSpecific);

        STRINGIFY(XTSS_XMLDECL_OPEN, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_XMLDECL_CLOSE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_XMLDECL_WHITESPACE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_XMLDECL_VALUE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_XMLDECL_VALUE_OPEN, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_XMLDECL_VALUE_CLOSE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_XMLDECL_EQUALS, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_XMLDECL_ENCODING, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_XMLDECL_STANDALONE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_XMLDECL_VERSION, pszSpecific, cchSpecific);

        STRINGIFY(XTSS_PI_OPEN, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_PI_CLOSE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_PI_TARGET, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_PI_VALUE, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_PI_WHITESPACE, pszSpecific, cchSpecific);

        STRINGIFY(XTSS_CDATA_OPEN, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_CDATA_CDATA, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_CDATA_CLOSE, pszSpecific, cchSpecific);

        STRINGIFY(XTSS_COMMENT_OPEN, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_COMMENT_COMMENTARY, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_COMMENT_CLOSE, pszSpecific, cchSpecific);

        STRINGIFY(XTSS_STREAM_START, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_STREAM_END, pszSpecific, cchSpecific);
        STRINGIFY(XTSS_STREAM_HYPERSPACE, pszSpecific, cchSpecific);

    default:
        pszSpecific = "bad specific state"; cchSpecific = strlen(pszSpecific);
        break;
    }

    _snprintf(rgszBuffer, cchBuffer, "%s", pszSpecific);
}

void DisplayToken(PXML_TOKEN pToken, FILE* pFile)
{
    static char Formatter[4096];
    SIZE_T i;

    GetFormattedStateName(pToken->State, Formatter, NUMBER_OF(Formatter));
    fprintf(pFile, "%s, %d {%.*s}\n", 
        Formatter, 
        pToken->Run.cbData,
        pToken->Run.cbData,
        pToken->Run.pvData);
}


NTSTATUS
DisplayLogicalThing(
    PXMLDOC_THING pThing,
    PRTL_GROWING_LIST pAttributeList
    )
{
    printf("Extent {0x%p, %d} (depth %d):\n", 
        pThing->TotalExtent.pvData, 
        pThing->TotalExtent.cbData,
        pThing->ulDocumentDepth);

    switch (pThing->ulThingType) {
    case XMLDOC_THING_HYPERSPACE:
        {
            printf("\tHyperspace: {%.*s}\n", pThing->Hyperspace.cbData, pThing->Hyperspace.pvData);
        }
        break;

    case XMLDOC_THING_ELEMENT:
        {
            PXMLDOC_ATTRIBUTE pAttribute = NULL;
            ULONG ul = 0;
            NTSTATUS status;

            printf("\tElement {%.*s:%.*s} %d attributes %s\n",
                pThing->Element.NsPrefix.cbData,
                pThing->Element.NsPrefix.pvData,
                pThing->Element.Name.cbData,
                pThing->Element.Name.pvData,
                pThing->Element.ulAttributeCount,
                (pThing->Element.fElementEmpty ? "(empty)" : ""));

            for (ul = 0; ul < pThing->Element.ulAttributeCount; ul++) {

                status = RtlIndexIntoGrowingList(
                    pAttributeList,
                    ul,
                    (PVOID*)&pAttribute,
                    FALSE);

                if (NT_SUCCESS(status)) {
                    printf("\t\tAttribute {%.*s:%.*s}={%.*s}\n",
                        pAttribute->NsPrefix.cbData,
                        pAttribute->NsPrefix.pvData,
                        pAttribute->Name.cbData,
                        pAttribute->Name.pvData,
                        pAttribute->Value.cbData,
                        pAttribute->Value.pvData);
                }
                else {
                    printf("\t\t(Can't get attribute, error 0x%08lx)\n", status);
                }

            }
        }
        break;

    case XMLDOC_THING_XMLDECL:
        {
            PXMLDOC_XMLDECL pDecl = &pThing->XmlDecl;
            printf("\tXML Declaration: encoding {%.*s} version {%.*s} standalone {%.*s}\n",
                pDecl->Encoding.cbData,
                pDecl->Encoding.pvData,
                pDecl->Version.cbData,
                pDecl->Version.pvData,
                pDecl->Standalone.cbData,
                pDecl->Standalone.pvData);
        }
        break;

    case XMLDOC_THING_END_ELEMENT:
        {
            PXMLDOC_ENDELEMENT pElement = &pThing->EndElement;

            printf("\tClosing element {%.*s:%.*s} for tag {%.*s:%.*s}\n",
                pElement->NsPrefix.cbData,
                pElement->NsPrefix.pvData,
                pElement->Name.cbData,
                pElement->Name.pvData,
                pElement->OpeningElement.NsPrefix.cbData,
                pElement->OpeningElement.NsPrefix.pvData,
                pElement->OpeningElement.Name.cbData,
                pElement->OpeningElement.Name.pvData);
        }
        break;

    case XMLDOC_THING_END_OF_STREAM:
        printf("End of stream\n");
        break;

    case XMLDOC_THING_ERROR:
        {
            PXMLDOC_ERROR pError = &pThing->Error;

            printf("\tError in XML (or parser) found at {%.*s}, code %08lx\n",
                pError->BadExtent.cbData,
                pError->BadExtent.pvData,
                pError->Code);
        }
        break;
    }

    return STATUS_SUCCESS;
}


BOOL s_fDisplay = FALSE;


NTSTATUS
RunThroughFile(
    PVOID pvData,
    SIZE_T cbData
    )
{
    XML_LOGICAL_STATE    MasterParseState;
    XMLDOC_THING            DocumentPiece;
    RTL_GROWING_LIST        AttributeList;
    NTSTATUS                status;
    LARGE_INTEGER           liStart, liEnd;

    QueryPerformanceCounter(&liStart);

    status = RtlInitializeGrowingList(
        &AttributeList,
        sizeof(XMLDOC_ATTRIBUTE),
        20,
        NULL,
        0,
        &g_DefaultAllocator);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlXmlInitializeNextLogicalThing(
        &MasterParseState,
        pvData,
        cbData,
        &g_DefaultAllocator);

    while (NT_SUCCESS(status)) {

        status = RtlXmlNextLogicalThing(
            &MasterParseState,
            NULL,
            &DocumentPiece,
            &AttributeList);

        if (!NT_SUCCESS(status)) {
            break;
        }

        if (s_fDisplay)
            DisplayLogicalThing(&DocumentPiece, &AttributeList);

        if ((DocumentPiece.ulThingType == XMLDOC_THING_ERROR) ||
            (DocumentPiece.ulThingType == XMLDOC_THING_END_OF_STREAM)) {
            break;
        }

    }

    QueryPerformanceCounter(&liEnd);

    liEnd.QuadPart -= liStart.QuadPart;
    QueryPerformanceFrequency(&liStart);

    printf("%I64d ticks, %f seconds\n", liEnd.QuadPart, (double)liEnd.QuadPart / (double)liStart.QuadPart);

    if (DocumentPiece.ulThingType == XMLDOC_THING_END_OF_STREAM) {

        if (DocumentPiece.ulDocumentDepth == 0) {
            printf("Completed input stream\n");
        }
        else {
            printf("EOF before end of stream, %d elements on stack.\n",
                DocumentPiece.ulDocumentDepth);
        }
    }
    else {
        printf("Error found in stream processing at %.*s, byte offset %d.\n",
            DocumentPiece.TotalExtent.cbData,
            DocumentPiece.TotalExtent.pvData,
            (PBYTE)DocumentPiece.TotalExtent.pvData - (PBYTE)pvData
            );
    }

    return status;
}




NTSTATUS
TimeFileRun(
    PVOID pvFileData,
    SIZE_T dwFileSize,
    PLARGE_INTEGER pliTickCount,
    double* pdblSecondCount)
{
    XML_LOGICAL_STATE State;
    XML_TOKEN Token;
    LARGE_INTEGER liStartTime, liEndTime;
    SIZE_T ulEncodingBytes;
    NTSTATUS success;

    //
    // Start up the parser
    //
    success = RtlXmlInitializeTokenization(&State.ParseState, pvFileData, dwFileSize, NULL, NULL, NULL);
    if (!NT_SUCCESS(success)) {
        printf("Initialization failure\n");
    }

    State.ulElementStackDepth = 0;
    success = RtlInitializeGrowingList(
        &State.ElementStack,
        sizeof(XMLDOC_THING),
        40,
        State.InlineElements,
        sizeof(State.InlineElements),
        &g_DefaultAllocator);

    if (!NT_SUCCESS(success)) {
        printf("Unable to create element stack");
        return success;
    }

    //
    // Let's determine the encoding
    //
    success = RtlXmlDetermineStreamEncoding(&State.ParseState, &ulEncodingBytes, &State.EncodingMarker);
    if (!NT_SUCCESS(success)) {
        printf("Unable to determine the encoding type\n");
    }

    //
    // Advance cursor past encoding bytes if necessary
    //
    State.ParseState.RawTokenState.pvCursor = ((PBYTE)State.ParseState.RawTokenState.pvCursor) + ulEncodingBytes;

    QueryPerformanceCounter(&liStartTime);
    do
    {

        if (NT_SUCCESS(success = RtlXmlNextToken(&State.ParseState, &Token, TRUE))) {

            //
            // Was there an error in this token?
            //
            if (s_fDisplay)
                DisplayToken(&Token, stdout);

            if (Token.fError) {
                printf("(Which was considered an error)\n");
                break;
            }

        }
    }
    while (NT_SUCCESS(success) && !Token.fError && (Token.State != XTSS_STREAM_END));

    QueryPerformanceCounter(&liEndTime);
    
    pliTickCount->QuadPart = liEndTime.QuadPart - liStartTime.QuadPart;
    
    QueryPerformanceFrequency(&liStartTime);

    *pdblSecondCount = (double)pliTickCount->QuadPart / liStartTime.QuadPart;

    return success;
}


DWORD WARMUP_COUNT = 3;
DWORD REAL_COUNT = 5;

int __cdecl wmain(int argc, WCHAR* argv[])
{
    NTSTATUS success = STATUS_SUCCESS;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hFileMapping = INVALID_HANDLE_VALUE;
    PVOID pvFileData = NULL;
    DWORD dwFileSize = 0;
    BOOL fFirstElementFound = FALSE;
    LARGE_INTEGER liTickCount, liTotalTicks;
    double dblSeconds, dblTotalSeconds;
    PCWSTR pcwszFileName = NULL;
    DWORD dw = 0;

    BOOL fJustRun = FALSE;
    int i;

    for (i = 1; i < argc; i++)
    {
        if (lstrcmpiW(L"-file", argv[i]) == 0) {
            pcwszFileName = argv[++i];
        }
        else if (lstrcmpiW(L"-warmup", argv[i]) == 0) {
            WARMUP_COUNT = _wtoi(argv[++i]);
        }
        else if (lstrcmpiW(L"-real", argv[i]) == 0) {
            REAL_COUNT = _wtoi(argv[++i]);
        }
        else if (lstrcmpiW(L"-display", argv[i]) == 0) {
            s_fDisplay = TRUE;
        }            
    }

    if (pcwszFileName == NULL)
    {
        wprintf(L"Must specify at least '-file somefile'\r\n");
        return -1;
    }

    hFile = CreateFileW(
        pcwszFileName, 
        GENERIC_READ, 
        FILE_SHARE_READ, 
        NULL, 
        OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL, 
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("Can't open file %ls\n", pcwszFileName);
        return -1;
    }

    dwFileSize = GetFileSize(hFile, NULL);

    hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, dwFileSize, NULL);
    if ((hFileMapping == NULL) || (hFileMapping == INVALID_HANDLE_VALUE)) {
        CloseHandle(hFile);
        wprintf(L"Can't create file mapping of %ls, lasterror %d\n", pcwszFileName, GetLastError());
        return -1;
    }

    pvFileData = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, dwFileSize);
    if (pvFileData == NULL) {
        CloseHandle(hFile);
        CloseHandle(hFileMapping);
        wprintf(L"Can't create mapped view of file %ls\n", pcwszFileName);
        return -1;
    }

    for (dw = 0; dw < WARMUP_COUNT; dw++) {
        wprintf(L"Warmup cycle %d\n", dw);
        success = TimeFileRun(pvFileData, dwFileSize, &liTickCount, &dblSeconds);
        wprintf(L"%I64d ticks, %f seconds\n", liTickCount.QuadPart, dblSeconds);
    }

    wprintf(L"This one counts:\n");

    liTotalTicks.QuadPart = 0;
    dblTotalSeconds = 0.0;

    for (dw = 0; dw < REAL_COUNT; dw++) {
        success = TimeFileRun(pvFileData, dwFileSize, &liTickCount, &dblSeconds);
        dblTotalSeconds += dblSeconds;
        liTotalTicks.QuadPart += liTickCount.QuadPart;
        wprintf(L".");
    }

    wprintf(L"\n");

    if (REAL_COUNT == 0)
    {
        wprintf(L"No real runs, can't calculate time.\n");
    }
    else {    
        wprintf(L"%d runs: %I64d total ticks, %I64d average, %f total seconds, %f average\n",
            REAL_COUNT,
            liTotalTicks.QuadPart,
            liTotalTicks.QuadPart / REAL_COUNT,
            dblTotalSeconds,
            dblTotalSeconds / REAL_COUNT);
    }
    
    success = RunThroughFile(pvFileData, dwFileSize);

    CloseHandle(hFile);
    CloseHandle(hFileMapping);
    UnmapViewOfFile(pvFileData);

    return success;
    success = RtlInstallAssembly(0, argv[1]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\identbuilder\identbuilder.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "stdio.h"
#include "sxs-rtl.h"
#include "fasterxml.h"
#include "skiplist.h"
#include "namespacemanager.h"
#include "xmlstructure.h"
#include "stdlib.h"
#include "xmlassert.h"

#ifdef INVALID_HANDLE_VALUE
#undef INVALID_HANDLE_VALUE
#endif
#include "windows.h"

#ifndef NUMBER_OF
#define NUMBER_OF(x) (sizeof(x)/sizeof(*x))
#endif

NTSTATUS FASTCALL
MyAllocator(SIZE_T cb, PVOID* pvOutput, PVOID pvAllocContext) {
    ASSERT(pvAllocContext == NULL);
    *pvOutput = HeapAlloc(GetProcessHeap(), 0, cb);
    return *pvOutput ? STATUS_SUCCESS : STATUS_NO_MEMORY;
}

NTSTATUS FASTCALL
MyFreer(PVOID pv, PVOID pvAllocContext) {
    ASSERT(pvAllocContext == NULL);
    return HeapFree(GetProcessHeap(), 0, pv) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;    
}

EXTERN_C RTL_ALLOCATOR g_DefaultAllocator = {MyAllocator, MyFreer, NULL};

//
// The longest an assembly name on-disk can be is:
//
// wow6432      (7)
// _            (1)
// {name}       (64)
// _            (1)
// PKT          (16)
// _            (1)
// Version      (35)
// _            (1)
// Language     (5)
// _            (1)
// {Hash}       (8)
//
// Total: ----> 140 (plus NULL)
//
#define MAX_ASSEMBLY_NAME_LENGTH        (140)
#define MAX_ASSEMBLY_COMPONENT_LENGTH   (64)


typedef struct _tagASM_IDENT_COMPONENT {
    PXML_TOKENIZATION_STATE pState;
    XML_EXTENT Namespace;
    XML_EXTENT Attribute;
    XML_EXTENT Value;
}
ASM_IDENT_COMPONENT, *PASM_IDENT_COMPONENT;

#define MAKE_SPECIAL(q) { L ## q, NUMBER_OF(L##q) - 1 }
static XML_SPECIAL_STRING AssemblyIdentity  = MAKE_SPECIAL("assemblyIdentity");
static XML_SPECIAL_STRING Assembly          = MAKE_SPECIAL("assembly");
static XML_SPECIAL_STRING OurNamespace      = MAKE_SPECIAL("urn:schemas-microsoft-com:asm.v1");

static XML_SPECIAL_STRING ss_ident_Name     = MAKE_SPECIAL("name");
static XML_SPECIAL_STRING ss_ident_Version  = MAKE_SPECIAL("version");
static XML_SPECIAL_STRING ss_ident_PKT      = MAKE_SPECIAL("publicKeyToken");
static XML_SPECIAL_STRING ss_ident_Language = MAKE_SPECIAL("language");
static XML_SPECIAL_STRING ss_ident_ProcArch = MAKE_SPECIAL("processorArchitecture");


int __cdecl
_CompareIdentityComponents(
    const void *pvLeft,
    const void *pvRight
    )
{
    PASM_IDENT_COMPONENT pCompLeft = (PASM_IDENT_COMPONENT)pvLeft;
    PASM_IDENT_COMPONENT pCompRight = (PASM_IDENT_COMPONENT)pvRight;
    NTSTATUS status = STATUS_SUCCESS;
    XML_STRING_COMPARE Result;
    int iResult = 0;

    ASSERT(pCompLeft->pState == pCompRight->pState);

    status = pCompLeft->pState->pfnCompareStrings(
        pCompLeft->pState,
        &pCompLeft->Namespace,
        &pCompRight->Namespace,
        &Result);

    //
    // We're sorting... can't really stop here, return "equal"
    //
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    //
    // Same namespace, compare attribute names
    //
    if (Result == XML_STRING_COMPARE_EQUALS) {
        
        int printf(const char*, ...);

        status = pCompLeft->pState->pfnCompareStrings(
            pCompLeft->pState,
            &pCompLeft->Attribute,
            &pCompRight->Attribute,
            &Result);

        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        //
        // Nicely enough, the result really has -1, 1, 0 property.
        //
        iResult = (int)Result;

        //
        // Ick, we should never have two attributes with the same name
        // in the same namespace on an element.
        //
        ASSERT(iResult != 0);
    }


Exit:
    return iResult;
}

static NTSTATUS
_CompareStrings(
    PVOID pvContext,
    PXML_EXTENT pLeft,
    PXML_EXTENT pRight,
    BOOLEAN *pfMatches
    )
{
    XML_LOGICAL_STATE *pState = (XML_LOGICAL_STATE*)pvContext;
    NTSTATUS status;
    XML_STRING_COMPARE Compare;

    *pfMatches = FALSE;

    status = pState->ParseState.pfnCompareStrings(
        &pState->ParseState,
        pLeft,
        pRight,
        &Compare);

    if (NT_SUCCESS(status)) {
        *pfMatches = (Compare == XML_STRING_COMPARE_EQUALS);
    }

    return status;

}

#define HASH_MULT_CONSTANT      (65599)

static NTSTATUS FASTCALL
HashXmlExtent(
    PXML_RAWTOKENIZATION_STATE  pState,
    PXML_EXTENT                 pExtent,
    PULONG                      pulHash
    )
{
    PVOID           pvOriginal;
    ULONG           ulCharacter;
    ULONG           ulHashResult = 0;
    NTSTATUS        status = STATUS_SUCCESS;
    SIZE_T          cbHashed = 0;

    *pulHash = 0;

    ASSERT(pState->cbBytesInLastRawToken == pState->DefaultCharacterSize);
    ASSERT(NT_SUCCESS(pState->NextCharacterResult));

    pvOriginal = pState->pvCursor;
    pState->pvCursor = pExtent->pvData;

    for (cbHashed = 0; cbHashed < pExtent->cbData;) {

        ulCharacter = pState->pfnNextChar(pState);

        if ((ulCharacter == 0) && !NT_SUCCESS(pState->NextCharacterResult)) {
            status = pState->NextCharacterResult;
            goto Exit;
        }
        else if (ulCharacter > 0xFFFF) {
            status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        ulHashResult = (ulHashResult * HASH_MULT_CONSTANT) + towupper((WCHAR)ulCharacter);

        pState->pvCursor = (PBYTE)pState->pvCursor + pState->cbBytesInLastRawToken;
        cbHashed += pState->cbBytesInLastRawToken;

        if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
            pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
        }
    }

    *pulHash = ulHashResult;

Exit:
    pState->pvCursor = pvOriginal;

    return status;
}



static NTSTATUS FASTCALL
HashIdentityElement(
    PASM_IDENT_COMPONENT    pIdent,
    PULONG                  pulHash
    )
{
    ULONG ulHashValue = 0;
    ULONG ulTempHashValue = 0;
    NTSTATUS status = STATUS_SUCCESS;
    XML_STRING_COMPARE Compare;

    status = HashXmlExtent(&pIdent->pState->RawTokenState, &pIdent->Namespace, &ulTempHashValue);
    ulHashValue = (ulHashValue * HASH_MULT_CONSTANT) + ulTempHashValue;
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    status = HashXmlExtent(&pIdent->pState->RawTokenState, &pIdent->Attribute, &ulTempHashValue);
    ulHashValue = (ulHashValue * HASH_MULT_CONSTANT) + ulTempHashValue;
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    status = HashXmlExtent(&pIdent->pState->RawTokenState, &pIdent->Value, &ulTempHashValue);
    ulHashValue = (ulHashValue * HASH_MULT_CONSTANT) + ulTempHashValue;
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    *pulHash = ulHashValue;

Exit:
    return status;
}


static NTSTATUS
CalculateIdentityHash(
    PASM_IDENT_COMPONENT    pIdents,
    SIZE_T                  cIdents,
    ULONG                  *pulHash
    )
{
    SIZE_T c = 0;
    ULONG ulHash = 0;
    NTSTATUS status = STATUS_SUCCESS;

    *pulHash = 0;

    for (c = 0; c < cIdents; c++) {
        ULONG ulTempHash;
        status = HashIdentityElement(pIdents + c, &ulTempHash);

        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        ulHash = (ulHash * HASH_MULT_CONSTANT) + ulTempHash;
    }

    *pulHash = ulHash;

Exit:
    return status;
}


static int __cdecl 
_FindIdentityComponents(
    const XML_SPECIAL_STRING* pKeyString,
    const PASM_IDENT_COMPONENT pComponent
    )
{
    NTSTATUS status;
    XML_STRING_COMPARE Compare = XML_STRING_COMPARE_GT;

    //
    // Our attributes all live in the 'null' namespace
    //
    if (pComponent->Namespace.cbData == 0) {

        status = pComponent->pState->pfnCompareSpecialString(
            pComponent->pState,
            &pComponent->Attribute,
            (XML_SPECIAL_STRING*)pKeyString,
            &Compare);

        ASSERT(NT_SUCCESS(status));

        //
        // On failure, make sure we don't match this one - checked builds
        // will assert above and point out the error
        //
        if (!NT_SUCCESS(status)) {
            Compare = XML_STRING_COMPARE_GT;
        }
    }

    return (int)Compare;
}

int (__cdecl *pfnIdentCompare)(const void*, const void*) = (int (__cdecl*)(const void*, const void*))_FindIdentityComponents;


#define NO_PKT_PRESENT              ("no-public-key")
#define NO_VERSION_PRESENT          ("0.0.0.0")
#define WORLD_WIDE_LANGUAGE         ("x-ww")


#define IsValidChar(q) (((q >= 'a') && (q <= 'z')) || ((q >= 'A') && (q <= 'Z')) || ((q >= '0') && (q <= '9')) || (q == '.') || (q == '-'))

        

static NTSTATUS
ExtentToPurifiedString(
    PASM_IDENT_COMPONENT pIdent,
    PCSTR pcszDefault,
    PSTR *pszPureString,
    PSIZE_T pcchThis
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    WCHAR wchBuffer[MAX_ASSEMBLY_COMPONENT_LENGTH];
    PWSTR pwszString = wchBuffer;
    SIZE_T cchWritten = 0;
    SIZE_T cchOutput = 0;
    SIZE_T i;

    if ((*pcchThis > 0) && (*pszPureString == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }


    if (!pIdent) {

        //
        // Input string too small?  Allocate and return a new one
        //
        if (strlen(pcszDefault) > *pcchThis) {
            *pszPureString = HeapAlloc(GetProcessHeap(), 0, *pcchThis);
        }

        strcpy(*pszPureString, pcszDefault);
        *pcchThis = strlen(pcszDefault);

        goto Exit;
    }

    //
    // Start by getting the string out of the extent
    //
    cchWritten = NUMBER_OF(wchBuffer);

    status = RtlXmlCopyStringOut(
        pIdent->pState,
        &pIdent->Value,
        wchBuffer,
        &cchWritten);

    //
    // Oops, allocate a buffer large enough and try again
    //
    if (status == STATUS_BUFFER_TOO_SMALL) {

        pwszString = (PWSTR)HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR) * (++cchWritten));

        if (pwszString == NULL) {
            status = STATUS_NO_MEMORY;
            goto Exit;
        }

        status = RtlXmlCopyStringOut(pIdent->pState, &pIdent->Value, pwszString, &cchWritten);
    }

    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    //
    // How long is the output string?
    //
    for (i = 0; i < cchWritten; i++) {

        if (IsValidChar(pwszString[i])) {
            cchOutput++;
        }

    }

    //
    // Needs more in the output, reallocate
    //
    if (cchOutput >= *pcchThis) {
        *pszPureString = (PSTR)HeapAlloc(GetProcessHeap(), 0, cchOutput + 1);
    }

    *pcchThis = cchOutput;

    cchOutput = 0;

    //
    // Now copy characters over
    //
    for (i = 0; i < cchWritten; i++) {

        if (IsValidChar(pwszString[i])) {

            (*pszPureString)[cchOutput++] = (CHAR)(pwszString[i] & 0xFF);

        }
    }

    (*pszPureString)[cchOutput] = 0;

Exit:
    if ((pwszString != wchBuffer) && pwszString) {
        HeapFree(GetProcessHeap(), 0, (PVOID)pwszString);
        pwszString = wchBuffer;
    }

    return status;
}





static NTSTATUS
FixUpNamePortion(
    PSTR pszOutputCursor,
    PSIZE_T pcchThis
    )
{
    ULONG   ulSpaceLeft         = 64;
    ULONG   i, len;
    PSTR    pszOriginalStart    = pszOutputCursor;
    PSTR    pszOriginalEnd      = pszOriginalStart + *pcchThis;
    PSTR    pLeftEnd            = pszOutputCursor;
    PSTR    pRightStart         = pszOriginalEnd;
    PSTR    pszStart, pszEnd, qEnd;
    CHAR    chBuffer[64];
    
    while (pszOriginalStart < pszOriginalEnd) {
        
        pszStart = pszOriginalStart;
        i = 0;
        
        while((strchr(".-", pszStart[i]) == 0) && ((pszStart + i) != pRightStart))
            i++;
        
        pszEnd = pszStart + i;
        len = i;
        
        if (len >= (ulSpaceLeft - 2)) {
            pLeftEnd += (ulSpaceLeft - 2);
            break;
        }
        
        ulSpaceLeft -= len;
        pLeftEnd = pszEnd;
        
        qEnd = pszOriginalEnd;
        i = 0;
        
        while (((qEnd + i)  != pLeftEnd) && (strchr(".-", qEnd[i]) == 0))
            i--;
        
        len = 0 - i;
        if (len >= (ulSpaceLeft - 2)) {
            pRightStart -= ulSpaceLeft - 2;
            break;
        }
        
        ulSpaceLeft -= len;
        pszOriginalStart = pLeftEnd + 1;
        pszOriginalEnd = pRightStart - 1;
    }
    
    strncpy(chBuffer, pszOutputCursor, pLeftEnd - pszOutputCursor);
    strcat(chBuffer, "..");
    strcat(chBuffer, pRightStart);
    strcpy(pszOutputCursor, chBuffer);
    *pcchThis = strlen(chBuffer);

    return STATUS_SUCCESS;
}


static NTSTATUS
ProcessFile(
    PVOID       pvData,
    SIZE_T      cbData,
    PSTR        pszTarget,
    SIZE_T      *pcchTarget
    )
{
    WCHAR                   wchComponentBuffer[MAX_ASSEMBLY_COMPONENT_LENGTH];
    ULONG                   ulIdentComponents = 0;
    ULONG                   i = 0;
    ULONG                   ulHash;
    NTSTATUS                status;
    NS_MANAGER              NamespaceManager;
    XMLDOC_THING            DocumentPiece;
    RTL_GROWING_LIST        AttributeList;
    XML_STRING_COMPARE      fMatching;
    XML_LOGICAL_STATE    MasterParseState;
    PASM_IDENT_COMPONENT    pIdentComponents = NULL;
    
    status = RtlInitializeGrowingList(
        &AttributeList,
        sizeof(XMLDOC_ATTRIBUTE),
        20,
        NULL,
        0,
        &g_DefaultAllocator);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlXmlInitializeNextLogicalThing(
        &MasterParseState,
        pvData,
        cbData,
        &g_DefaultAllocator);

    status = RtlNsInitialize(
        &NamespaceManager,
        RtlXmlDefaultCompareStrings,
        &MasterParseState,
        &g_DefaultAllocator);

    while (NT_SUCCESS(status)) {

        status = RtlXmlNextLogicalThing(
            &MasterParseState,
            &NamespaceManager,
            &DocumentPiece,
            &AttributeList);

        if (!NT_SUCCESS(status)) {
            break;
        }

        if ((DocumentPiece.ulThingType == XMLDOC_THING_ERROR) ||
            (DocumentPiece.ulThingType == XMLDOC_THING_END_OF_STREAM)) {
            break;
        }

        //
        // Level 1 or non-elements are simply ignored
        //
        if ((DocumentPiece.ulDocumentDepth != 1) || (DocumentPiece.ulThingType != XMLDOC_THING_ELEMENT))
            continue;

        //
        // Find out the namespace that this thing is in
        //
        status = MasterParseState.ParseState.pfnCompareSpecialString(
            &MasterParseState.ParseState,
            &DocumentPiece.Element.NsPrefix,
            &OurNamespace,
            &fMatching);

        //
        // Error, stop
        //
        if (!NT_SUCCESS(status)) {
            goto Exit;
        }
        //
        // Go on then, off with ye.
        //
        else if (fMatching != XML_STRING_COMPARE_EQUALS) {
            continue;
        }

        //
        // Is this assembly identity?
        //
        status = MasterParseState.ParseState.pfnCompareSpecialString(
            &MasterParseState.ParseState,
            &DocumentPiece.Element.Name,
            &AssemblyIdentity,
            &fMatching);

        if (!NT_SUCCESS(status)) {
            goto Exit;
        }
        else if (fMatching != XML_STRING_COMPARE_EQUALS) {
            continue;
        }

        //
        // Good, so now we need to look at the attributes
        //
        ulIdentComponents = DocumentPiece.Element.ulAttributeCount;
        pIdentComponents = (PASM_IDENT_COMPONENT)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            ulIdentComponents * sizeof(*pIdentComponents));

        //
        // Copy stuff around
        //
        for (i = 0; i < ulIdentComponents; i++) {

            PXMLDOC_ATTRIBUTE pThisAttribute = NULL;

            status = RtlIndexIntoGrowingList(
                &AttributeList,
                i,
                (PVOID*)&pThisAttribute,
                FALSE);

            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            pIdentComponents[i].Attribute = pThisAttribute->Name;
            pIdentComponents[i].Namespace = pThisAttribute->NsPrefix;
            pIdentComponents[i].Value = pThisAttribute->Value;
            pIdentComponents[i].pState = &MasterParseState.ParseState;
        }

        break;

    }

    //
    // Something bad? Quit.
    //
    if (!NT_SUCCESS(status) || !pIdentComponents) {
        goto Exit;
    }


    //
    // Sort attributes first, then go and create the list of things to be sent to the
    // identity generator
    //
    qsort(pIdentComponents, ulIdentComponents, sizeof(ASM_IDENT_COMPONENT), _CompareIdentityComponents);

    //
    // Now for each component of the name part...
    //
    if (!NT_SUCCESS(status = CalculateIdentityHash(pIdentComponents, ulIdentComponents, &ulHash))) {
        return status;
    }

    //
    // Sort and send out the pointer on success
    //
    if (NT_SUCCESS(status) && pIdentComponents && ulIdentComponents) {

        struct {
            XML_SPECIAL_STRING *pNameBit;
            PCSTR pszDefault;
            BOOL fIsName;
        } NameOperations[] = 
        {
            { &ss_ident_ProcArch, "data", FALSE },
            { &ss_ident_Name, NULL, TRUE },
            { &ss_ident_PKT, NO_PKT_PRESENT, FALSE },
            { &ss_ident_Version, NO_VERSION_PRESENT, FALSE },
            { &ss_ident_Language, WORLD_WIDE_LANGUAGE, FALSE }
        };

        PSTR pszOutputCursor = pszTarget;
        SIZE_T cchTotal = 0, cchThis, cchRemaining;

        for (i = 0; i < NUMBER_OF(NameOperations); i++) {

            PASM_IDENT_COMPONENT pThisOne = NULL;
            CHAR szStaticPureString[64];
            PSTR pszPureString = szStaticPureString;
            SIZE_T cchPureString = NUMBER_OF(szStaticPureString);

            //
            // This segment can have this many characters in it
            //
            cchThis = *pcchTarget - cchTotal;

            //
            // Find the identity part
            //
            pThisOne = bsearch(NameOperations[i].pNameBit, pIdentComponents, ulIdentComponents, sizeof(*pIdentComponents), pfnIdentCompare);

            //
            // Append the extent to the output cursor
            //
            status = ExtentToPurifiedString(
                pThisOne, 
                NameOperations[i].pszDefault, 
                &pszPureString,
                &cchPureString);

            //
            // If this is the name part, adjust it downward sizewize before seeing if there's space
            // in the output buffer
            //
            if (NameOperations[i].fIsName && (cchPureString > 64)) {
                status = FixUpNamePortion(pszPureString, &cchPureString);

                if (!NT_SUCCESS(status)) {

                    //
                    // Ensure the buffer is freed before returning
                    //
                    if (pszPureString && (pszPureString != szStaticPureString)) {
                        HeapFree(GetProcessHeap(), 0, (PVOID)pszPureString);
                        pszPureString = szStaticPureString;
                    }

                    goto Exit;
                }
            }

            //
            // No space in the output buffer, or there was no output buffer
            //
            if (!pszOutputCursor || (cchPureString > (*pcchTarget - cchTotal))) {

                pszOutputCursor = NULL;

                cchThis = cchPureString + 1;
            }
            //
            // Otherwise, copy the pure string onto the output cursor
            //
            else {
                strncpy(pszOutputCursor, pszPureString, cchPureString);
                pszOutputCursor[cchPureString] = '_';
                cchThis = cchPureString + 1;
                pszOutputCursor += cchThis;
            }

            if (pszPureString && (pszPureString != szStaticPureString)) {
                HeapFree(GetProcessHeap(), 0, (PVOID)pszPureString);
            }

            cchTotal += cchThis;
        }


        if (pszOutputCursor && ((*pcchTarget - cchTotal) > 8)) {
            sprintf(pszOutputCursor, "%08lx", ulHash);
        }

        cchTotal += 9;

        if (*pcchTarget < cchTotal) {
            status = STATUS_BUFFER_TOO_SMALL;
        }

        *pcchTarget = cchTotal;
    }

Exit:
    if (pIdentComponents) {
        HeapFree(GetProcessHeap(), 0, (PVOID)pIdentComponents);
        pIdentComponents = NULL;
    }

    RtlDestroyGrowingList(&AttributeList);

    return status;
}





BOOL
SxsIdentDetermineManifestPlacementPathEx(
    DWORD dwFlags,
    PVOID pvManifestData,
    SIZE_T cbLength,
    PSTR pszPlacementPath,
    SIZE_T *pcchPlacementPath
    )
{
    BOOL fSuccess = FALSE;
    NTSTATUS status;

    if (pszPlacementPath) {
        *pszPlacementPath = UNICODE_NULL;
    }

    //
    // Go do the thing
    //
    status = ProcessFile(pvManifestData, cbLength, pszPlacementPath, pcchPlacementPath);
    switch (status) {
    case STATUS_NO_MEMORY:
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        break;
    case STATUS_BUFFER_TOO_SMALL:
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        break;
    case STATUS_NOT_FOUND:
        SetLastError(ERROR_FILE_NOT_FOUND);
        break;
    case STATUS_SUCCESS:
        fSuccess = TRUE;
        SetLastError(ERROR_SUCCESS);
        break;
    default:
        SetLastError(ERROR_GEN_FAILURE);
        break;
    }

    return fSuccess;
}



BOOL
SxsIdentDetermineManifestPlacementPath(
    DWORD dwFlags,
    PCWSTR pcwszManifestPath,
    PSTR pszPlacementPath,
    SIZE_T *cchPlacementPath
    )
{
    UINT cchUserBufferSize;
    BOOL fSuccess = FALSE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PVOID pvFileData = NULL;
    HANDLE hFileMapping = INVALID_HANDLE_VALUE;
    DWORD dwFileSize = 0;
    PASM_IDENT_COMPONENT pAsmIdentSorted = NULL;
    SIZE_T cAsmIdent = 0, cTemp;

    //
    // Some minimal requirements
    //
    if ((dwFlags != 0) || !pcwszManifestPath || !cchPlacementPath ||
        ((*cchPlacementPath > 0) && (pszPlacementPath == NULL)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (pszPlacementPath) {
        *pszPlacementPath = UNICODE_NULL;
    }

    hFile = CreateFileW(
        pcwszManifestPath, 
        GENERIC_READ, 
        FILE_SHARE_READ, 
        NULL, 
        OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL, 
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        goto Exit;
    }

    dwFileSize = GetFileSize(hFile, NULL);

    hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, dwFileSize, NULL);
    if ((hFileMapping == NULL) || (hFileMapping == INVALID_HANDLE_VALUE)) {
        goto Exit;
    }

    pvFileData = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, dwFileSize);
    if (pvFileData == NULL) {
        goto Exit;
    }

    fSuccess = SxsIdentDetermineManifestPlacementPathEx(
        dwFlags,
        pvFileData,
        dwFileSize,
        pszPlacementPath,
        cchPlacementPath);

Exit:
    if (pvFileData != NULL) {
        UnmapViewOfFile(pvFileData);
        pvFileData = NULL;
    }

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    if (hFileMapping != INVALID_HANDLE_VALUE) {
        CloseHandle(hFileMapping);
        hFileMapping = INVALID_HANDLE_VALUE;
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\apps\install\assemblygac.h ===
#pragma once

class CAssemblyIdentity
{
public:
    typedef CEnv::CConstantUnicodeStringPair CStringPair;
    
    CAssemblyIdentity();
    ~CAssemblyIdentity();

    CEnv::StatusCode SetAttribute(const CStringPair &Namespace, const CStringPair &Name, const CStringPair &Value, bool fReplace = true);
    CEnv::StatusCode SetAttribute(const CStringPair &Name, const CStringPair& Value, bool fReplace = true) { return SetAttribute(CStringPair(), Name, Value, fReplace); }
    CEnv::StatusCode DeleteAttribute(const CStringPair &Namespace, const CStringPair &Name);

    //
    // The const version will do a linear or a bsearch depending on the sorted state.  The non-const
    // version will sort the internal attribute list first if necessary before looking up the value.
    // These two are also a little dangerous because they return pointers directly into the data structures
    // (const of course), which if you hold onto them might get invalidated.  If you plan on caching the
    // data for a while, consider using the next two.
    //
    CEnv::StatusCode FindAttribute(const CStringPair &Namespace, const CStringPair &Name, CStringPair& Value) const;
    CEnv::StatusCode FindAttribute(const CStringPair &Namespace, const CStringPair &Name, CStringPair& Value);

    CEnv::StatusCode FindAttribute(const CStringPair &Namespace, const CStringPair &Name, CEnv::CStringBuffer &Target) const;
    CEnv::StatusCode FindAttribute(const CStringPair &Namespace, const CStringPair &Name, CEnv::CStringBuffer &Target);
    
    unsigned long IdentityHash() const;
    unsigned long IdentityHash();
    unsigned long long IdentityHashV2() const;
    unsigned long long IdentityHashV2();

    //
    // Maintainence stuff
    //
    CEnv::StatusCode Freeze();
    CEnv::StatusCode DeleteAllValues();

protected:

    //
    // This is an all-in-one allocation blob
    //
    class CIdentityValue 
    {
        CIdentityValue(const CIdentityValue&);
        void operator=(const CIdentityValue&);
        
    public:
        CIdentityValue() { }
        
        SIZE_T cbAllocationSize;
        bool HashV1Valid;
        unsigned long HashV1;
        
        CStringPair Namespace;
        CStringPair Name;
        CStringPair Value;

        CEnv::StatusCode WriteValues(const CStringPair& Namespace, const CStringPair& Name, const CStringPair& Value);
        CEnv::StatusCode Compare(const CIdentityValue &Other, int &iResult) const;
        
    };

    SIZE_T m_cIdentityValues;
    SIZE_T m_cAvailableIdentitySlots;
    CIdentityValue** m_IdentityValues;

    bool m_fFrozen;
    bool m_fSorted;
    
    bool m_fHashDirtyV1;
    unsigned long m_ulHashV1;

    bool m_fHashDirtyV2;
    unsigned char m_IdentityShaHash[20];
 
    CEnv::StatusCode RegenerateHash();
    CEnv::StatusCode SortIdentityAttributes();
    static int __cdecl SortingCallback(const CIdentityValue **left, const CIdentityValue **right);
    
    CEnv::StatusCode InternalFindValue(const CStringPair &Namespace, const CStringPair &Name, SIZE_T &cIndex) const;
    CEnv::StatusCode InternalFindValue(const CStringPair &Namespace, const CStringPair &Name, SIZE_T &cIndex);
    CEnv::StatusCode InternalCreateValue(const CStringPair &Namespace, const CStringPair &Name, const CStringPair &Value);
    CEnv::StatusCode InternalAllocateValue(const CStringPair &Namespace, const CStringPair &Name, const CStringPair &Value, CIdentityValue* &Allocated);
    CEnv::StatusCode InternalInsertValue(CIdentityValue* NewValue);
    CEnv::StatusCode InternalDestroyValue(CIdentityValue* Victim);
};

static CEnv::StatusCode 
CreateIdentityFromCookedData(
    CAssemblyIdentity& Target, 
    PMANIFEST_COOKED_IDENTITY IdentityData
    );

class COSAssemblyCache
{
public:
    enum UninstallResult {
        UResult_NotPresent,
        UResult_RemovedPayload,
        UResult_RemovedManifest,
        UResult_RemovedReference,
    };

    virtual ~COSAssemblyCache() { }

    virtual CEnv::StatusCode Initialize() = 0;
    
    virtual CEnv::StatusCode InstallAssembly(
        ULONG Flags,
        PMANIFEST_COOKED_DATA ManifestData,
        const CEnv::CConstantUnicodeStringPair &FilePath
        ) = 0;

    virtual CEnv::StatusCode UninstallAssembly(
        ULONG Flags,
        PMANIFEST_COOKED_DATA ManifestData,
        UninstallResult &Result
        ) = 0;
};

class CDotNetSxsAssemblyCache : public COSAssemblyCache
{
    CDotNetSxsAssemblyCache(ULONG ulFlags);
    CDotNetSxsAssemblyCache(const CDotNetSxsAssemblyCache&);
    void operator=(const CDotNetSxsAssemblyCache&);

    static const CEnv::CConstantUnicodeStringPair s_PoliciesPath;
    static const CEnv::CConstantUnicodeStringPair s_ManifestsPath;
    static const CEnv::CConstantUnicodeStringPair s_InstallTemp;
    static const CEnv::CConstantUnicodeStringPair s_BaseDirectory;

    CEnv::StatusCode EnsurePathsAvailable();
    CEnv::CConstantUnicodeStringPair m_WindowsDirectory;

    CEnv::StatusCode IdentityToTargetPath(const CAssemblyIdentity& Ident, CEnv::CStringBuffer &PathSegment);

public:

    virtual ~CDotNetSxsAssemblyCache();

    virtual CEnv::StatusCode Initialize();
    
    virtual CEnv::StatusCode InstallAssembly(
        ULONG Flags,
        PMANIFEST_COOKED_DATA ManifestData,
        const CEnv::CConstantUnicodeStringPair &FilePath
        );

    virtual CEnv::StatusCode UninstallAssembly(
        ULONG Flags,
        PMANIFEST_COOKED_DATA ManifestData,
        UninstallResult &Result
        );

    const static GUID CacheIdentifier;

    static COSAssemblyCache *CreateSelf(ULONG, const GUID *);
};

typedef struct {
    const GUID *CacheIdent;
    COSAssemblyCache* (*pfnCreator)(ULONG ulFlags, const GUID *Ident);
} ASSEMBLY_CACHE_LISTING;

EXTERN_C ASSEMBLY_CACHE_LISTING s_AssemblyCaches[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\apps\install\sxsgac.cpp ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "stdio.h"
#include "sxs-rtl.h"
#undef INVALID_HANDLE_VALUE
#include "windows.h"
#include "environment.h"
#include "manifestcooked.h"
#include "assemblygac.h"
#include "bcl_common.h"
#include "bcl_w32unicodeinlinestringbuffer.h"
#include "search.h"

//
// Crypto stack
//
#include "hashers.h"
#include "digesters.h"



CEnv::StatusCode
FsCopyFileWithHashGeneration(
    const CEnv::CConstantUnicodeStringPair &Source,
    const CEnv::CConstantUnicodeStringPair &Target,
    CHashObject &HashObjectTarget,
    CDigestMethod &DigestMethod
    )
{
    CEnv::StatusCode Result;
    CEnv::CByteRegion TempAllocation(NULL, 0);
    HANDLE SourceHandle = INVALID_HANDLE_VALUE;
    HANDLE TargetHandle = INVALID_HANDLE_VALUE;
    SIZE_T cbDidRead, cbOffset;

    //
    // Force initialization of the hasher and digester.
    //
    
    HashObjectTarget.Initialize();
    DigestMethod.Initialize(HashObjectTarget);

    //
    // Snag some memory to perform the copies
    //
    Result = CEnv::AllocateHeap(2048, TempAllocation, NULL);
    if (CEnv::DidFail(Result))
        goto Exit;
    
    //
    // Obtain handles for both files
    //
    Result = CEnv::GetFileHandle(&SourceHandle, Source, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING);
    if (CEnv::DidFail(Result))
        goto Exit;

    Result = CEnv::GetFileHandle(&TargetHandle, Target, GENERIC_WRITE, FILE_SHARE_READ, CREATE_ALWAYS);
    if (CEnv::DidFail(Result))
        goto Exit;

    //
    // Now spin through the file reading blocks, digesting them.
    //
    cbOffset = 0;
    do
    {
        Result = CEnv::ReadFile(SourceHandle, TempAllocation, cbDidRead);
        if (CEnv::DidFail(Result))
            goto Exit;

        if (cbDidRead == 0)
            break;

        Result = DigestMethod.DigestExtent(HashObjectTarget, cbOffset, TempAllocation);
        if (CEnv::DidFail(Result))
            goto Exit;

        cbOffset += cbDidRead;

        Result = CEnv::WriteFile(TargetHandle, TempAllocation, cbDidRead);
        if (CEnv::DidFail(Result))
            goto Exit;
    }
    while (true);

    //
    // Ok, we're done.
    //

Exit:
    if (TempAllocation.GetPointer())
        CEnv::FreeHeap(TempAllocation.GetPointer(), NULL);

    if (SourceHandle != INVALID_HANDLE_VALUE)
        CEnv::CloseHandle(SourceHandle);

    if (TargetHandle != INVALID_HANDLE_VALUE)
        CEnv::CloseHandle(TargetHandle);
    
    return Result;    
}

COSAssemblyCache*
CDotNetSxsAssemblyCache::CreateSelf(
    ULONG ulFlags,
    const GUID *pCacheIdent
    )
{
    CDotNetSxsAssemblyCache *pAllocation = NULL;
    CEnv::StatusCode status;
        
    if (!pCacheIdent || (*pCacheIdent != CacheIdentifier))
        return NULL;

    status = CEnv::AllocateHeap(sizeof(CDotNetSxsAssemblyCache), (PVOID*)&pAllocation, NULL);
    if (CEnv::DidFail(status))
        return NULL;

    pAllocation->CDotNetSxsAssemblyCache::CDotNetSxsAssemblyCache(ulFlags);
    return pAllocation;
}

CDotNetSxsAssemblyCache::CDotNetSxsAssemblyCache(
    ULONG ulFlags
    )
{
}

CDotNetSxsAssemblyCache::~CDotNetSxsAssemblyCache()
{
}

CEnv::StatusCode
CDotNetSxsAssemblyCache::IdentityToTargetPath(
    const CAssemblyIdentity& Ident, 
    CEnv::CStringBuffer &PathSegment
    )
{
    typedef CEnv::CConstantUnicodeStringPair CStringPair;

    enum {
        Identity_ProcArch = 0,
        Identity_Name,
        Identity_PublicKeyToken,
        Identity_Version,
        Identity_Language,
    };

    static const struct {
        CStringPair Namespace;
        CStringPair Name;
        CStringPair DefaultValue;
    } PathComponents[] = {
        { CStringPair(), CStringPair(L"processorArchitecture", NUMBER_OF(L"processorArchitecture") - 1), CStringPair(L"data", 4) },
        { CStringPair(), CStringPair(L"name", NUMBER_OF(L"name") - 1), CStringPair() },
        { CStringPair(), CStringPair(L"publicKeyToken", NUMBER_OF(L"publicKeyToken") - 1), CStringPair(L"no-public-key-token", NUMBER_OF(L"no-public-key-token") - 1) },
        { CStringPair(), CStringPair(L"version", NUMBER_OF(L"version") - 1), CStringPair(L"0.0.0.0", 7) },
        { CStringPair(), CStringPair(L"language", NUMBER_OF(L"language") - 1), CStringPair(L"x-ww", 4) },
    };

    CEnv::StatusCode Result = CEnv::SuccessCode;
    CStringPair FoundComponents[NUMBER_OF(PathComponents) * 2];
    SIZE_T i;
    

    PathSegment.Clear();
    
    //
    // Look for these identity components in order
    //
    for (i = 0; i < NUMBER_OF(PathComponents); i++)
    {
        Result = Ident.FindAttribute(PathComponents[i].Namespace, PathComponents[i].Name, FoundComponents[2*i]);
        
        if (Result == CEnv::NotFound)
        {
            FoundComponents[2*i] = PathComponents[i].DefaultValue;
        }
        else if (CEnv::DidFail(Result))
        {
            goto Exit;
        }

        FoundComponents[2*i+1].SetPointerAndCount(L"_", 1);
    }

    //
    // Meddle with the 'name' string to ensure that it falls under the filesystem limits
    //
    // TODO: Fix name string
    //
    
    if (!PathSegment.Assign(NUMBER_OF(FoundComponents), FoundComponents))
    {
        //
        // I think we need to fix the string APIs such that on win32 they return lasterror
        // rather than returning BOOL all the time - it'd make transitioning into the RTL
        // much easier...
        //
        Result = CEnv::OutOfMemory;
        PathSegment.Clear();
        goto Exit;
    }

    Result = CEnv::SuccessCode;
Exit:
    return Result;
}


CEnv::StatusCode
CDotNetSxsAssemblyCache::Initialize()
{
    this->m_WindowsDirectory = CEnv::StringFrom(USER_SHARED_DATA->NtSystemRoot);
    return CEnv::SuccessCode;
}

CEnv::StatusCode
CDotNetSxsAssemblyCache::EnsurePathsAvailable()
{
    CEnv::CConstantUnicodeStringPair PathBuilder[3] = {
        m_WindowsDirectory,
        s_BaseDirectory,
        s_ManifestsPath
    };
    CEnv::StatusCode Result = CEnv::SuccessCode;

    //
    // Ensure that the WinSxS store is available:
    // {windir}\{winsxs2}
    // {windir}\{winsxs2}\{manifests}
    //
    // This call has the side-effect of building all three levels.
    //
    if (CEnv::DidFail(Result = CEnv::CreateDirectory(3, PathBuilder)))
        goto Exit;

    Result = CEnv::SuccessCode;
Exit:
    return Result;
}

/*

Installation has these phases:

- Create mandatory directories in the store
    - Store path
    - Manifests
- Create the target assembly identity
- If the target assembly is a policy
    - Write the .policy file into the right place
    - Notify the store metadata manager about the new policy
    - Done
- If the target assembly is not already installed
    - Create '%storeroot%\%asmpath%-temp' to store files
    - Stream files into install target path, validating hashes
    - Rename path to remove -temp marker
    - Place the .manifest
    - Notify the store metadata manager about the new manifest
    - Done
- If the target assembly is already installed
    - Notify the store metadata manager about another reference
    - Done

Unless:
    - If the "refresh" flag is set, then the bits are copied in again
*/

CEnv::StatusCode
CDotNetSxsAssemblyCache::InstallAssembly(
    ULONG Flags, 
    PMANIFEST_COOKED_DATA ManifestData, 
    const CEnv::CConstantUnicodeStringPair &FilePath
    )
{
    CEnv::StatusCode Result = CEnv::SuccessCode;
    CNtEnvironment::StatusCode NtResult;
    CEnv::CStringBuffer FirstFile, SecondFile;
    CAssemblyIdentity ThisIdentity;

    //
    // First, let's ensure that the required directories are present
    //
    if (CEnv::DidFail(Result = EnsurePathsAvailable()))
        goto Exit;

    //
    // Now let's stage the files in question into an installtemp location, validating as we
    // copy.  We will never store the actual manifest, we will only store the solidified blob
    // that we got after parsing and cooking it.  But first, let's turn that set of identity
    // values into an actual identity...
    //
    // Result = ThisIdentity.C

    Result = CEnv::SuccessCode;
Exit:
    return Result;
}


CEnv::StatusCode
CDotNetSxsAssemblyCache::UninstallAssembly(
    ULONG Flags, 
    PMANIFEST_COOKED_DATA ManifestData, 
    UninstallResult & Result
    )
{
    return STATUS_NOT_IMPLEMENTED;
}

const GUID CDotNetSxsAssemblyCache::CacheIdentifier = { /* 37e3c37d-667f-4aee-8dab-a0d117acfa68 */
    0x37e3c37d,
    0x667f,
    0x4aee,
    {0x8d, 0xab, 0xa0, 0xd1, 0x17, 0xac, 0xfa, 0x68}
  };

const CEnv::CConstantUnicodeStringPair CDotNetSxsAssemblyCache::s_PoliciesPath(L"Policies", 8);
const CEnv::CConstantUnicodeStringPair CDotNetSxsAssemblyCache::s_ManifestsPath(L"Manifests", 9);
const CEnv::CConstantUnicodeStringPair CDotNetSxsAssemblyCache::s_InstallTemp(L"InstallTemp", 11);
const CEnv::CConstantUnicodeStringPair CDotNetSxsAssemblyCache::s_BaseDirectory(L"WinSxS2", 7);



//
// Assembly identity stuff - should get split into another file
//
CAssemblyIdentity::CAssemblyIdentity() 
    : m_cIdentityValues(0), m_IdentityValues(NULL), m_fFrozen(false), 
      m_fSorted(true), m_fHashDirtyV1(true), m_fHashDirtyV2(true),
      m_ulHashV1(0), m_cAvailableIdentitySlots(0)
{
    ZeroMemory(m_IdentityShaHash, sizeof(m_IdentityShaHash));
}

CAssemblyIdentity::~CAssemblyIdentity()
{
    DeleteAllValues();
}

CEnv::StatusCode
CAssemblyIdentity::DeleteAllValues()
{
    //
    // Let's keep the table around, just because that's handy
    //
    if (m_IdentityValues != NULL)
    {
        for (SIZE_T c = 0; c < m_cIdentityValues; c++)
        {
            CEnv::FreeHeap(m_IdentityValues[c], NULL);
            m_IdentityValues[c] = NULL;
        }
        
        m_cIdentityValues = 0;
    }

    this->m_fHashDirtyV1 = this->m_fHashDirtyV2 = true;
    this->m_ulHashV1 = 0;    
 
    return CEnv::SuccessCode;
}

CEnv::StatusCode
CAssemblyIdentity::SetAttribute(
    const CStringPair &Namespace, 
    const CStringPair &Name, 
    const CStringPair &Value, 
    bool fReplace
    )
{
    CEnv::StatusCode Result;
    SIZE_T cIndex;

    //
    // If looking for this value had some other problem aside from not being found,
    // then exit.
    //
    Result = this->InternalFindValue(Namespace, Name, cIndex);
    if (CEnv::DidFail(Result) && (Result != CEnv::NotFound))
        goto Exit;

    //
    // Easy - create a new attribute to hold this value.
    //
    if (Result == CEnv::NotFound)
    {
        CIdentityValue *NewValue = NULL;
        SIZE_T c;

        if (CEnv::DidFail(Result = this->InternalAllocateValue(Namespace, Name, Value, NewValue)))
            goto Exit;

        //
        // After we've allocated one, go insert it into the table.  If that failed,
        // the clean up and exit
        //
        if (CEnv::DidFail(Result = this->InternalInsertValue(NewValue)))
        {
            this->InternalDestroyValue(NewValue);
            goto Exit;
        }
    }
    else
    {
        CIdentityValue *ThisValue = m_IdentityValues[cIndex];
        const SIZE_T cbRequiredSize = ((Namespace.GetCount() + Name.GetCount() + Value.GetCount()) * sizeof(WCHAR)) + sizeof(CIdentityValue);

        ASSERT(ThisValue != NULL);

        //
        // Spiffy, there's enough space in the existing value to hold the data from
        // the input value.
        //
        if (cbRequiredSize < ThisValue->cbAllocationSize)
        {
            if (CEnv::DidFail(Result = ThisValue->WriteValues(Namespace, Name, Value)))
                goto Exit;
        }
        //
        // Bah, have to reallocate this entry
        //
        else
        {
            CIdentityValue *NewValue = NULL;

            if (CEnv::DidFail(Result = this->InternalAllocateValue(Namespace, Name, Value, NewValue)))
                goto Exit;

            m_IdentityValues[cIndex] = NewValue;
            NewValue = NULL;

            if (CEnv::DidFail(Result = this->InternalDestroyValue(ThisValue)))
                goto Exit;
        }
    }

    //
    // Now clear all the relevant flags
    //
    this->m_fHashDirtyV1 = this->m_fHashDirtyV2 = true;
    this->m_fSorted = false;

    Result = CEnv::SuccessCode;
Exit:
    return Result;
}

CEnv::StatusCode 
CAssemblyIdentity::DeleteAttribute(
    const CStringPair &Namespace,
    const CStringPair &Name
    )
{
    SIZE_T cIndex;
    CEnv::StatusCode Result;
    CIdentityValue *Victim = NULL;

    //
    // InternalFindValue will return NotFound if it didn't find it.
    //
    if (CEnv::DidFail(Result = this->InternalFindValue(Namespace, Name, cIndex)))
        goto Exit;

    //
    // Remember the one we found, clear its slot, delete the allocation
    //
    Victim = m_IdentityValues[cIndex];
    m_IdentityValues[cIndex] = NULL;

    //
    // And clear the state flags before we delete it
    //
    this->m_fHashDirtyV1 = this->m_fHashDirtyV2 = true;
    this->m_fSorted = false;
    
    if (CEnv::DidFail(Result = this->InternalDestroyValue(Victim)))
        goto Exit;

    Result = CEnv::SuccessCode;
Exit:
    return Result;
}

CEnv::StatusCode
CAssemblyIdentity::CIdentityValue::WriteValues(
    const CStringPair & InNamespace, 
    const CStringPair & InName, 
    const CStringPair & InValue
    )
{
    PWSTR pwszWriteCursor = (PWSTR)(this + 1);
    const SIZE_T cRequired = ((InNamespace.GetCount() + InName.GetCount() + InValue.GetCount()) * sizeof(WCHAR)) * sizeof(*this);

    if (cRequired < this->cbAllocationSize)
    {
        return CEnv::NotEnoughBuffer;
    }

    this->HashV1Valid = false;
    this->HashV1 = 0;

    this->Namespace.SetPointerAndCount(pwszWriteCursor, InNamespace.GetCount());
    memcpy(pwszWriteCursor, InNamespace.GetPointer(), InNamespace.GetCount() * sizeof(WCHAR));
    pwszWriteCursor += InNamespace.GetCount();

    this->Name.SetPointerAndCount(pwszWriteCursor, InName.GetCount());
    memcpy(pwszWriteCursor, InName.GetPointer(), InName.GetCount() * sizeof(WCHAR));
    pwszWriteCursor += InName.GetCount();

    this->Value.SetPointerAndCount(pwszWriteCursor, InValue.GetCount());
    memcpy(pwszWriteCursor, InValue.GetPointer(), InValue.GetCount() * sizeof(WCHAR));

    return CEnv::SuccessCode;
}

CEnv::StatusCode
CAssemblyIdentity::CIdentityValue::Compare(
    const CAssemblyIdentity::CIdentityValue& Other,
    int &iResult
    ) const
{
    CEnv::StatusCode Result;
    int iMyResult = 0;

    iResult = -1;
    
    //
    // this == this
    //
    if (this == &Other)
    {
        iResult = 0;
        return CEnv::SuccessCode;
    }

    //
    // Namespace first, then name.
    //
    if (CEnv::DidFail(Result = CEnv::CompareStrings(this->Namespace, Other.Namespace, iMyResult)))
        goto Exit;

    //
    // Only bother if the namespaces match
    //
    if (iMyResult == 0)
    {
        if (CEnv::DidFail(Result = CEnv::CompareStringsCaseInsensitive(this->Name, Other.Name, iMyResult)))
            goto Exit;
    }

    iResult = iMyResult;

    Result = CEnv::SuccessCode;
Exit:
    return Result;
}


CEnv::StatusCode
CAssemblyIdentity::InternalDestroyValue(
    CIdentityValue *Victim
    )
{
    //
    // This just calls heapfree on the attribute
    //
    return CEnv::FreeHeap((PVOID)Victim, NULL);
}

CEnv::StatusCode
CAssemblyIdentity::InternalAllocateValue(
    const CStringPair &Namespace,
    const CStringPair &Name,
    const CStringPair &Value,
    CAssemblyIdentity::CIdentityValue* &pCreated
    )
{
    const SIZE_T cbRequired = ((Namespace.GetCount() + Name.GetCount() + Value.GetCount()) * sizeof(WCHAR)) + sizeof(CIdentityValue);
    CIdentityValue *pTempCreated = NULL;
    CEnv::StatusCode Result;

    pCreated = NULL;

    if (CEnv::DidFail(Result = CEnv::AllocateHeap(cbRequired, (PVOID*)&pTempCreated, NULL)))
        goto Exit;

    if (CEnv::DidFail(Result = pTempCreated->WriteValues(Namespace, Name, Value)))
        goto Exit;

    pCreated = pTempCreated;
    pTempCreated = NULL;
        
    Result = CEnv::SuccessCode;
Exit:
    if (pTempCreated)
    {
        CEnv::FreeHeap(pTempCreated, NULL);
    }
    
    return Result;
}

//
// Non-const version can sort.
//
CEnv::StatusCode
CAssemblyIdentity::InternalFindValue(
    const CStringPair & Namespace, 
    const CStringPair & Name,
    SIZE_T &cIndex
    )
{
    CEnv::StatusCode Result;
    cIndex = -1;

    if (!this->m_fSorted)
    {
        if (CEnv::DidFail(Result = this->SortIdentityAttributes()))
            goto Exit;
    }

    //
    // Use the built-in searcher on the const one.
    //
    Result = (const_cast<const CAssemblyIdentity&>(*this)).InternalFindValue(Namespace, Name, cIndex);

Exit:
    return Result;
}


CEnv::StatusCode
CAssemblyIdentity::FindAttribute(
    const CStringPair & Namespace, 
    const CStringPair & Name, 
    CStringPair & Value
    )
{
    CEnv::StatusCode Result;
    SIZE_T cIndex;

    Value.SetPointerAndCount(NULL, 0);

    Result = this->InternalFindValue(Namespace, Name, cIndex);
    
    if (!CEnv::DidFail(Result))
    {
        Value = this->m_IdentityValues[cIndex]->Value;
        Result = CEnv::SuccessCode;
    }

    return Result;
}

CEnv::StatusCode 
CAssemblyIdentity::FindAttribute(
    const CStringPair &Namespace, 
    const CStringPair &Name, 
    CStringPair& Value
    ) const
{
    CEnv::StatusCode Result;
    SIZE_T cIndex;

    Value.SetPointerAndCount(NULL, 0);

    Result = this->InternalFindValue(Namespace, Name, cIndex);

    if (!CEnv::DidFail(Result))
    {
        Value = this->m_IdentityValues[cIndex]->Value;
        Result = CEnv::SuccessCode;
    }

    return Result;
}


CEnv::StatusCode
CAssemblyIdentity::InternalFindValue(
    const CStringPair &Namespace,
    const CStringPair &Name,
    SIZE_T &cIndex
    ) const
{
    CEnv::StatusCode Result;
    SIZE_T cLow, cHigh;
    CIdentityValue ComparisonDump;

    cIndex = -1;
    ComparisonDump.Namespace = Namespace;
    ComparisonDump.Name = Name;

    if (!this->m_fSorted)
    {
        //
        // Ick, linear search.
        //
        for (cLow = 0; cLow < this->m_cIdentityValues; cLow++)
        {
            int iResult = 0;
            CIdentityValue *pFound = this->m_IdentityValues[cLow];

            //
            // Possible to have holes in the const linear-search version
            //
            if (!pFound)
                continue;

            if (CEnv::DidFail(Result = pFound->Compare(ComparisonDump, iResult)))
                goto Exit;

            if (iResult == 0)
            {
                cIndex = cLow;
                Result = CEnv::SuccessCode;
                goto Exit;
            }            
        }
    }
    else
    {
        //
        // We're doing our own bsearch here.
        //
        cLow = 0;
        cHigh = this->m_cIdentityValues;
        
        while (cLow < cHigh)
        {
            SIZE_T cMiddle = (cHigh - cLow) / 2;
            int iResult = 0;
            CIdentityValue *pFound = this->m_IdentityValues[cMiddle];

            //
            // The sorting should have reorganized the attributes so NULL slots
            // were past the number of in-use identity values.
            //
            ASSERT(pFound != NULL);

            if (CEnv::DidFail(Result = pFound->Compare(ComparisonDump, iResult)))
                goto Exit;

            if (iResult == 0)
            {
                cIndex = cMiddle;
                Result = CEnv::SuccessCode;
                goto Exit;
            }
            else if (iResult < 0)
            {
                cHigh = cMiddle;
                continue;
            }
            else if (iResult > 0)
            {
                cLow = cMiddle;
                continue;
            }
        }
    }
    
    Result = CEnv::NotFound;    
Exit:
    return Result;
}

#define ASSEMBLY_IDENTITY_TABLE_EXPANDO_FACTOR      (20)

CEnv::StatusCode 
CAssemblyIdentity::Freeze()
{
    CEnv::StatusCode Result;

    if (m_fFrozen)
        return CEnv::SuccessCode;
    
    if (CEnv::DidFail(Result = SortIdentityAttributes()))
        return Result;

    if (CEnv::DidFail(Result = RegenerateHash()))
        return Result;

    m_fFrozen = true;

    return CEnv::SuccessCode;
}

CEnv::StatusCode
CAssemblyIdentity::RegenerateHash()
{
    return CEnv::NotImplemented;
}

CEnv::StatusCode
CAssemblyIdentity::InternalInsertValue(
    CAssemblyIdentity::CIdentityValue * NewValue
    )
{
    CEnv::StatusCode Result;
    
    //
    // If the number of values is the same as the available slots, then we
    // have to expand the internal table.
    //
    if (m_cIdentityValues == m_cAvailableIdentitySlots)
    {
        //
        // Simple logic - increase by 20 slots each time
        //
        CIdentityValue** ppNewTable = NULL;
        CIdentityValue** ppOldTable = m_IdentityValues;
        const SIZE_T cNewSlots = m_cAvailableIdentitySlots + ASSEMBLY_IDENTITY_TABLE_EXPANDO_FACTOR;
        const SIZE_T cbRequired = sizeof(CIdentityValue*) * cNewSlots;

        if (CEnv::DidFail(Result = CEnv::AllocateHeap(cbRequired, (PVOID*)&ppNewTable, NULL)))
            goto Exit;

        //
        // Pointers make this easy
        //
        if (ppOldTable)
        {
            memcpy(ppNewTable, ppOldTable, sizeof(CIdentityValue*) * m_cAvailableIdentitySlots);
        }

        //
        // Clear out the data in these slots
        //
        for (SIZE_T i = m_cAvailableIdentitySlots; i < cNewSlots; i++)
        {
            ppNewTable[i] = NULL;
        }
        
        m_IdentityValues = ppNewTable;
        m_cAvailableIdentitySlots = cNewSlots;

        //
        // Free the old table
        //
        if (ppOldTable)
        {
            CEnv::FreeHeap((PVOID)ppOldTable, NULL);
        }
    }

    ASSERT(m_IdentityValues != NULL);
    ASSERT(m_cIdentityValues < m_cAvailableIdentitySlots);
    
    m_IdentityValues[m_cIdentityValues++] = NewValue;
    Result = CEnv::SuccessCode;
Exit:
    return Result;
}

int __cdecl
CAssemblyIdentity::SortingCallback(
    const CAssemblyIdentity::CIdentityValue **left,
    const CAssemblyIdentity::CIdentityValue **right
    )
{
    const CIdentityValue *pLeft = *left;
    const CIdentityValue *pRight = *right;
    CEnv::StatusCode Result = CEnv::SuccessCode;
    int iResult = 0;

    //
    // Percolate NULL slots towards the 'end'
    //
    if (!left && !right)
    {
        return 0;
    }
    else if (!left && right)
    {
        return 1;
    }
    else if (left && !right)
    {
        return -1;
    }

    ASSERT(pLeft && pRight);

    Result = pLeft->Compare(*pRight, iResult);
    ASSERT(!CEnv::DidFail(Result));

    return iResult;
}
    

CEnv::StatusCode
CAssemblyIdentity::SortIdentityAttributes()
{
    CEnv::StatusCode Result;

    if (this->m_cIdentityValues == 0)
    {
        m_fSorted = true;
    }

    if (m_fSorted)
    {
        return CEnv::SuccessCode;
    }

    qsort(
        this->m_IdentityValues, 
        this->m_cAvailableIdentitySlots, 
        sizeof(this->m_IdentityValues[0]), 
        (int (__cdecl*)(const void*, const void*))SortingCallback
        );

    //
    // Sorted now, but we've invalidated the hash of the overall object.
    //
    m_fSorted = true;
    m_fHashDirtyV1 = m_fHashDirtyV2 = true;

    return CEnv::SuccessCode;
}   

/*
class CAssemblyIdentity
{
public:
    typedef CEnv::CConstantUnicodeStringPair CStringPair;
    
    CAssemblyIdentity();
    ~CAssemblyIdentity();

    CEnv::StatusCode SetAttribute(const CStringPair &Namespace, const CStringPair &Name, const CStringPair &Value, bool fReplace = true);
    CEnv::StatusCode SetAttribute(const CStringPair &Name, const CStringPair& Value, bool fReplace = true) { return SetAttribute(CStringPair(), Name, Value, fReplace); }
    CEnv::StatusCode DeleteAttribute(const CStringPair &Namespace, const CStringPair &Name);

    //
    // The const version will do a linear or a bsearch depending on the sorted state.  The non-const
    // version will sort the internal attribute list first if necessary before looking up the value
    //
    CEnv::StatusCode FindAttribute(const CStringPair &Namespace, const CStringPair &Name, CStringPair& Value) const;
    CEnv::StatusCode FindAttribute(const CStringPair &Namespace, const CStringPair &Name, CStringPair& Value);
    
    unsigned long IdentityHash() const;
    unsigned long IdentityHash();
    unsigned long long IdentityHashV2() const;
    unsigned long long IdentityHashV2();

    //
    // Maintainence stuff
    //
    CEnv::StatusCode Freeze();
    CEnv::StatusCode DeleteAllValues();

    static CEnv::StatusCode ConstructFromCookedData(
        CAssemblyIdentity& Target, 
        PMANIFEST_COOKED_IDENTITY IdentityData
        );        

protected:

    //
    // This is an all-in-one allocation blob
    //
    typedef struct {
        CStringPair Namespace;
        CStringPair Name;
        CStringPair Value;
    } CIdentityValue;

    SIZE_T m_cIdentityValues;
    CIdentityValue** m_IdentityValues;

    bool m_fFrozen;
    bool m_fSorted;
    bool m_fHashDirty;

    CEnv::StatusCode RegenerateHash();
    CEnv::StatusCode SortIdentityAttributes();
    int SortingCallback(const CIdentityValue *left, const CIdentityValue *right);
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\apps\install\installer.cpp ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "stdio.h"
#include "sxs-rtl.h"
#include "fasterxml.h"
#include "skiplist.h"
#include "namespacemanager.h"
#include "xmlstructure.h"
#include "stdlib.h"
#include "xmlassert.h"
#include "manifestinspection.h"
#include "manifestcooked.h"
#include "stringpool.h"
#undef INVALID_HANDLE_VALUE
#include "windows.h"
#include "sha.h"
#include "environment.h"
#include "sha2.h"
#include "assemblygac.h"

ASSEMBLY_CACHE_LISTING s_AssemblyCaches[] = {
    { &CDotNetSxsAssemblyCache::CacheIdentifier, CDotNetSxsAssemblyCache::CreateSelf },
    { NULL, NULL }        
};



LONG
OurFilter(
    PEXCEPTION_POINTERS pExceptionPointers
    )
{
    DbgBreakPoint();
    return EXCEPTION_CONTINUE_SEARCH;
}
    

#define RTL_ANALYZE_MANIFEST_GET_FILES          (0x00000001)
#define RTL_ANALYZE_MANIFEST_GET_WINDOW_CLASSES (0x00000002)
#define RTL_ANALYZE_MANIFEST_GET_COM_CLASSES    (0x00000004)
#define RTL_ANALYZE_MANIFEST_GET_DEPENDENCIES   (0x00000008)
#define RTL_ANALYZE_MANIFEST_GET_SIGNATURES     (0x00000010)

#define RTLSXS_INSTALLER_REGION_SIZE            (128*1024)

NTSTATUS
RtlAnalyzeManifest(
    ULONG                   ulFlags,
    PUNICODE_STRING         pusPath,
    PMANIFEST_COOKED_DATA  *ppusCookedData
    )
{
    PVOID                       pvAllocation = NULL;
    SIZE_T                      cbAllocationSize = 0;
    LARGE_INTEGER               liFileSize;
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    CEnv::StatusCode           StatusCode;
    SIZE_T                      cbReadFileSize;
    PRTL_MANIFEST_CONTENT_RAW   pManifestContent = NULL;
    XML_TOKENIZATION_STATE      XmlState;
    NTSTATUS                    status;
    PMANIFEST_COOKED_DATA       pCookedContent = NULL;
    SIZE_T                      cbCookedContent;
    ULONG                       ulGatherFlags = 0;
    CEnv::CConstantUnicodeStringPair ManifestPath;

    //
    // Snag a region of memory to stash the file into
    //
    StatusCode = CEnv::VirtualAlloc(NULL, RTLSXS_INSTALLER_REGION_SIZE, MEM_RESERVE, PAGE_READWRITE, &pvAllocation);
    if (CEnv::DidFail(StatusCode)) {
        goto Exit;
    }

    //
    // Convert the input flags into the "gather" flagset
    //
    if (ulFlags & RTL_ANALYZE_MANIFEST_GET_FILES)           ulGatherFlags |= RTLIMS_GATHER_FILES;
    if (ulFlags & RTL_ANALYZE_MANIFEST_GET_WINDOW_CLASSES)  ulGatherFlags |= RTLIMS_GATHER_WINDOWCLASSES;
    if (ulFlags & RTL_ANALYZE_MANIFEST_GET_COM_CLASSES)     ulGatherFlags |= RTLIMS_GATHER_COMCLASSES;
    if (ulFlags & RTL_ANALYZE_MANIFEST_GET_DEPENDENCIES)    ulGatherFlags |= RTLIMS_GATHER_DEPENDENCIES;
    if (ulFlags & RTL_ANALYZE_MANIFEST_GET_SIGNATURES)      ulGatherFlags |= RTLIMS_GATHER_SIGNATURES;

    //
    // Acquire a handle on the file, get its size.
    //
    ManifestPath = CEnv::StringFrom(pusPath);
    if (CEnv::DidFail(StatusCode = CEnv::GetFileHandle(&hFile, ManifestPath, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING))) {
        goto Exit;
    }

    if (CEnv::DidFail(StatusCode = CEnv::GetFileSize(hFile, &liFileSize))) {
        goto Exit;
    }

    //
    // Commit enough space to hold the file contents
    //
    cbAllocationSize = (SIZE_T)liFileSize.QuadPart;
    StatusCode = CEnv::VirtualAlloc(pvAllocation, cbAllocationSize, MEM_COMMIT, PAGE_READWRITE, &pvAllocation);
    if (CEnv::DidFail(StatusCode)) {
        goto Exit;
    }

    // Read the file data - in the future, we'll want to respect overlapped
    // IO so this can move into the kernel
    StatusCode = CEnv::ReadFile(hFile, pvAllocation, cbAllocationSize, cbReadFileSize);
    if (CEnv::DidFail(StatusCode)) {
        goto Exit;
    }

    // Initialize our callback stuff.  We want to know only about the files that this
    // manifest contains - anything else is superflous.  Of course, we also want the
    // xml signature data contained herein as well.
    status = RtlSxsInitializeManifestRawContent(ulGatherFlags, &pManifestContent, NULL, 0);
    if (CNtEnvironment::DidFail(status)) {
        StatusCode = CNtEnvironment::ConvertStatusToOther<CEnv::StatusCode>(status);
        goto Exit;
    }

    // Now run through the file looking for useful things
    status = RtlInspectManifestStream(
        ulGatherFlags,
        pvAllocation,
        cbAllocationSize,
        pManifestContent,
        &XmlState);
    if (CNtEnvironment::DidFail(status)) {
        StatusCode = CNtEnvironment::ConvertStatusToOther<CEnv::StatusCode>(status);
        goto Exit;
    }


    //
    // Convert the raw content to cooked content that we can use
    //
    status = RtlConvertRawToCookedContent(pManifestContent, &XmlState.RawTokenState, NULL, 0, &cbCookedContent);
    if (CNtEnvironment::DidFail(status) && (status != CNtEnvironment::NotEnoughBuffer)) {
        StatusCode = CNtEnvironment::ConvertStatusToOther<CEnv::StatusCode>(status);
        goto Exit;
    }

    
    //
    // Allocate some heap to contain the raw content
    //
    else if (status == CNtEnvironment::NotEnoughBuffer) {
        SIZE_T cbDidWrite;
        
        if (CEnv::DidFail(StatusCode = CEnv::AllocateHeap(cbCookedContent, (PVOID*)&pCookedContent, NULL))) {
            goto Exit;
        }
        
        status = RtlConvertRawToCookedContent(
            pManifestContent,
            &XmlState.RawTokenState,
            (PVOID)pCookedContent,
            cbCookedContent,
            &cbDidWrite);
    }

    *ppusCookedData = pCookedContent;
    pCookedContent = NULL;

    // Spiffy.  We now have converted all the strings that make up the file table -
    // let's start installing them!
    StatusCode = CEnv::SuccessCode;
Exit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CEnv::CloseHandle(hFile);
    }

    if (pvAllocation != NULL) {
        CEnv::VirtualFree(pvAllocation, cbAllocationSize, MEM_DECOMMIT);
        CEnv::VirtualFree(pvAllocation, 0, MEM_RELEASE);
        pvAllocation = NULL;
    }

    RtlSxsDestroyManifestContent(pManifestContent);

    if (pCookedContent != NULL) {
		CEnv::FreeHeap(pCookedContent, NULL);
    }
    
    return CEnv::DidFail(StatusCode) ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS;
}


NTSTATUS
InstallAssembly(
    PCWSTR pcwszPath,
    LPGUID lpgGacIdent
    )
{
    PMANIFEST_COOKED_DATA           pCookedData = NULL;
    UNICODE_STRING                  usManifestFile;
    UNICODE_STRING                  usManifestPath;
    CNtEnvironment::StatusCode      Result;
    COSAssemblyCache               *pTargetCache = NULL;
    ULONG                           ul = 0;
    

    RtlInitUnicodeString(&usManifestFile, pcwszPath);

    if ((lpgGacIdent == NULL) || (pcwszPath == NULL)) 
    {
        return STATUS_INVALID_PARAMETER;
    }

    for (ul = 0; s_AssemblyCaches[ul].CacheIdent != NULL; ul++) 
    {
        if (*s_AssemblyCaches[ul].CacheIdent == *lpgGacIdent) 
        {
            pTargetCache = s_AssemblyCaches[ul].pfnCreator(0, lpgGacIdent);
            if (pTargetCache)
                break;
        }
    }

    if (pTargetCache == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Gather junk from the manifest
    //
    Result = RtlAnalyzeManifest(
        RTL_ANALYZE_MANIFEST_GET_SIGNATURES | RTL_ANALYZE_MANIFEST_GET_FILES,
        &usManifestFile, 
        &pCookedData);
    if (CNtEnvironment::DidFail(Result)) {
        goto Exit;
    }

    usManifestPath = usManifestFile;
    while (usManifestPath.Length && (usManifestPath.Buffer[(usManifestPath.Length / sizeof(usManifestPath.Buffer[0])) - 1] != L'\\'))
        usManifestPath.Length -= sizeof(usManifestPath.Buffer[0]);
    
    //
    // Do the installation.  Build the path to the 
    //
    Result = pTargetCache->InstallAssembly(0, pCookedData, CEnv::StringFrom(&usManifestPath));

Exit:
    if (pCookedData != NULL) {
        CEnv::FreeHeap(pCookedData, NULL);
        pCookedData = NULL;
    }

    if (pTargetCache) {
        pTargetCache->~COSAssemblyCache();
        CEnv::FreeHeap(pTargetCache, NULL);
    }
    
    return Result;
}


int __cdecl wmain(int argc, WCHAR** argv)
{
    static int iFrobble = 0;
    NTSTATUS status;
    UNICODE_STRING usGuid;
    GUID gGacGuid;
    WCHAR wch[5];
    int i = _snwprintf(wch, 5, L"123456");

    iFrobble = iFrobble + 1;

    __try
    {
        RtlInitUnicodeString(&usGuid, argv[2]);
        if (NT_SUCCESS(status = RtlGUIDFromString(&usGuid, &gGacGuid))) {
            status = InstallAssembly(argv[1], &gGacGuid);
        }
    }
    __except(OurFilter(GetExceptionInformation()))
    {
    }

    return (int)status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\identbuilder.h ===
#pragma once

#include "windows.h"

#ifdef __cplusplus
extern "C" {
#endif

BOOL
SxsIdentDetermineManifestPlacementPathEx(
    DWORD dwFlags,
    PVOID pvManifestData,
    SIZE_T cbLength,
    PSTR pszPlacementPath,
    SIZE_T *pcchPlacementPath
    );


BOOL
SxsIdentDetermineManifestPlacementPath(
    DWORD dwFlags,
    PCWSTR pcwszManifestPath,
    PSTR pszPlacementPath,
    SIZE_T *cchPlacementPath
    );

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\identhandles.h ===
#pragma once


typedef struct _tagRTLSXS_ASM_IDENT_HANDLE_TABLE_SLOT {

    USHORT usGeneration;

    PASSEMBLY_IDENTITY *pIdentity;
}
RTLSXS_ASM_IDENT_HANDLE_TABLE_SLOT, *PRTLSXS_ASM_IDENT_HANDLE_TABLE_SLOT;



typedef struct _tagRTLSXS_ASM_IDENT_HANDLE_TABLE {

    ULONG ulInlineCount;

    ULONG ulHeapCount;

    PRTLSXS_ASM_IDENT_HANDLE_TABLE_SLOT InlineList;

    PRTLSXS_ASM_IDENT_HANDLE_TABLE_SLOT HeapList;
}
RTLSXS_ASM_IDENT_HANDLE_TABLE, *PRTLSXS_ASM_IDENT_HANDLE_TABLE;



NTSTATUS
RtlAllocateIdentityHandle(
    PRTLSXS_ASM_IDENT_HANDLE_TABLE pHandleTable,
    PHANDLE pHandle,
    PASSEMBLY_IDENTITY pIdentity
    );


NTSTATUS
RtlFreeIdentityHandle(
    PRTLSXS_ASM_IDENT_HANDLE_TABLE pHandleTable,
    PHANDLE pHandle
    );

NTSTATUS
RtlDerefIdentityHandle(
    PRTLSXS_ASM_IDENT_HANDLE_TABLE pHandleTable,
    HANDLE hHandle,
    PASSEMBLY_IDENTITY *ppAsmIdent
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\environment.h ===
#pragma once

#include "bcl_common.h"

#ifndef RTL_SXS_KERNEL_MODE

#include "nturtl.h"
#include "windows.h"
#include "bcl_w32unicodeinlinestringbuffer.h"

#ifndef NUMBER_OF
#define NUMBER_OF(q) (sizeof(q) / sizeof(*q))
#endif

class CWin32Environment
{
public:
    typedef CWin32Environment CEnv;
    typedef DWORD StatusCode;
    typedef BCL::CMutablePointerAndCountPair<BYTE, SIZE_T> CByteRegion;
    typedef BCL::CConstantPointerAndCountPair<BYTE, SIZE_T> CConstantByteRegion;
    typedef BCL::CMutablePointerAndCountPair<WCHAR, SIZE_T> CUnicodeStringPair;
    typedef BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T> CConstantUnicodeStringPair;
    typedef BCL::CWin32BaseUnicodeInlineStringBuffer<128> CStringBuffer;

    static const CConstantUnicodeStringPair s_FileSystemSeperator;

    enum { 
        SuccessCode = ERROR_SUCCESS,
        InvalidParameter = ERROR_INVALID_PARAMETER,
        NotEnoughBuffer = ERROR_INSUFFICIENT_BUFFER,
        OutOfMemory = ERROR_NOT_ENOUGH_MEMORY,
        NotFound = ERROR_NOT_FOUND,
        NotImplemented = ERROR_INVALID_FUNCTION
    };

    //
    // Case-sensitive
    //
    static StatusCode CompareStrings(const CConstantUnicodeStringPair &Left, const CConstantUnicodeStringPair &Right, int &iResult)
    {
        iResult = 0;
        
        int iInternalResult = CompareStringW(
            GetThreadLocale(),
            0,
            Left.GetPointer(),
            Left.GetCount(),
            Right.GetPointer(),
            Right.GetCount());

        switch (iInternalResult)
        {
        case CSTR_EQUAL:
            iResult = 0;
            break;
        case CSTR_GREATER_THAN:
            iResult = 1;
            break;
        case CSTR_LESS_THAN:
            iResult = -1;
            break;
        case 0:
            return ::GetLastError();
        }

        return SuccessCode;            
    }

    static StatusCode CompareStringsCaseInsensitive(const CConstantUnicodeStringPair &Left, const CConstantUnicodeStringPair &Right, int &iResult)
    {
        iResult = 0;
        
        int iInternalResult = CompareStringW(
            GetThreadLocale(),
            NORM_IGNORECASE,
            Left.GetPointer(),
            Left.GetCount(),
            Right.GetPointer(),
            Right.GetCount());

        switch (iInternalResult)
        {
        case CSTR_EQUAL:
            iResult = 0;
            break;
        case CSTR_GREATER_THAN:
            iResult = 1;
            break;
        case CSTR_LESS_THAN:
            iResult = -1;
            break;
        case 0:
            return ::GetLastError();
        }

        return SuccessCode;            
    }

    

    static StatusCode CreateDirectory(SIZE_T ItemCount, const CConstantUnicodeStringPair *Listing) {

        PWSTR pwszWorkingBuffer = NULL, pwszCursor;
        SIZE_T i = 0;
        SIZE_T cchRequired = 0;
        StatusCode Result;

        //
        // Figure out how large the buffer is that we need here
        //
        for (i = 0; i < ItemCount; i++) 
        {
            if (i != 0)
                cchRequired += s_FileSystemSeperator.GetCount();

            cchRequired += Listing[i].GetCount();
        }

        Result = CEnv::AllocateHeap((cchRequired + 1) * sizeof(WCHAR), (PVOID*)&pwszWorkingBuffer, NULL);
        if (CEnv::DidFail(Result))
            return Result;

        pwszCursor = pwszWorkingBuffer;

        //
        // Now for each path segment, start copying it into the
        // working buffer and creating paths from it.
        //
        for (i = 0; i < ItemCount; i++)
        {
            const CConstantUnicodeStringPair &Me = Listing[i];
            if (i != 0)
            {
                memcpy(pwszCursor, s_FileSystemSeperator.GetPointer(), s_FileSystemSeperator.GetCount() * sizeof(WCHAR));
                pwszCursor += s_FileSystemSeperator.GetCount();
            }

            memcpy(pwszCursor, Me.GetPointer(), Me.GetCount() * sizeof(WCHAR));
            pwszCursor += Me.GetCount();
            *pwszCursor = UNICODE_NULL;

            if (!::CreateDirectoryW(pwszWorkingBuffer, NULL) && (::GetLastError() == ERROR_ALREADY_EXISTS))
            {
                Result = ::GetLastError();
                goto Exit;
            }
        }

        Result = CEnv::SuccessCode;
    Exit:
        if (pwszWorkingBuffer)
            CEnv::FreeHeap(pwszWorkingBuffer, NULL);

        return Result;
        
    }

    static CConstantUnicodeStringPair StringFrom(const UNICODE_STRING *pus) {
        return CConstantUnicodeStringPair(pus->Buffer, pus->Length);
    }

    static CConstantUnicodeStringPair StringFrom(PCWSTR pcwszInput) {
        return CConstantUnicodeStringPair(pcwszInput, ::wcslen(pcwszInput));
    }

    static CConstantUnicodeStringPair StringFrom(const CConstantUnicodeStringPair& src) {
        return src;
    }

    static StatusCode Compare(const CConstantUnicodeStringPair &Left, const CConstantUnicodeStringPair &Right, int &Result) {
        
        if (((Left.GetCount() / sizeof(WCHAR)) > USHRT_MAX) || ((Right.GetCount() / sizeof(WCHAR)) > USHRT_MAX))
            return InvalidParameter;

        // Evil casting is required b/c UNICODE_STRING requires it.
        const UNICODE_STRING TheLeft = { (USHORT)Left.GetCount(), 0, (PWSTR)Left.GetPointer() };
        const UNICODE_STRING TheRight = { (SHORT)Right.GetCount(), 0, (PWSTR)Right.GetPointer() };

        Result = RtlCompareUnicodeString(&TheLeft, &TheRight, FALSE);
        return SuccessCode;
    }
    
    static bool DidFail(StatusCode dwCode) { return (dwCode != SuccessCode); }
    
    static StatusCode VirtualAlloc(PVOID pvAddress, SIZE_T cbSize, DWORD flAllocationType, DWORD flProtect, PVOID *ppvRegion) {        
        if (NULL == (*ppvRegion = ::VirtualAlloc(pvAddress, cbSize, flAllocationType, flProtect))) {
            return ::GetLastError();
        }
        else {
            return SuccessCode;
        }
    }

    static StatusCode VirtualFree(PVOID pvAddress, SIZE_T cbSize, DWORD dwFreeType) {
        if (!::VirtualFree(pvAddress, cbSize, dwFreeType)) {
            return ::GetLastError();
        }
        else {
            return SuccessCode;
        }
    }

    static NTSTATUS FASTCALL AllocateHeap(SIZE_T cb, CByteRegion &Recipient, PVOID pvContext) {
        PVOID pvAcquired = NULL;
        CEnv::StatusCode Result;
        Recipient.SetPointerAndCount(NULL, 0);
        if (CEnv::DidFail(Result = CEnv::AllocateHeap(cb, &pvAcquired, pvContext)))
            return Result;
        Recipient.SetPointerAndCount((CByteRegion::TMutableArray)pvAcquired, cb);
        return Result;
    }

    static NTSTATUS FASTCALL AllocateHeap(SIZE_T cb, PVOID *ppvTarget, PVOID pvContext) {
        if (NULL == (*ppvTarget = RtlAllocateHeap(RtlProcessHeap(), 0, cb))) {
            return STATUS_INVALID_PARAMETER;
        }
        else {
            return SuccessCode;
        }
    }

    static NTSTATUS FASTCALL FreeHeap(PVOID ppvTarget, PVOID pvContext) {
        if (!RtlFreeHeap(RtlProcessHeap(), 0, ppvTarget)) {
            return STATUS_INVALID_PARAMETER;
        }
        else {
            return SuccessCode;
        }
    }

    static StatusCode CloseHandle(HANDLE h) {
        if (!::CloseHandle(h)) {
            return ::GetLastError();
        }
        else {
            return SuccessCode;
        }
    }

    static StatusCode GetFileHandle(HANDLE* pHandle, const CConstantUnicodeStringPair &FileName, DWORD dwRights, DWORD dwSharing, DWORD dwCreation) {

        PCWSTR pcwszTemp = NULL;
        PCWSTR pcwszInput = NULL;
        StatusCode dwRetVal = SuccessCode;

        *pHandle = INVALID_HANDLE_VALUE;

        pcwszInput = FileName.GetPointer();

        if (!pcwszInput || (FileName.GetCount() == 0) ||
            (pcwszInput[FileName.GetCount() - 1] != UNICODE_NULL)) 
        {
            
            PWSTR pwszAllocTemp = NULL;
            dwRetVal = AllocateHeap((FileName.GetCount() + 1) * sizeof(WCHAR), (PVOID*)&pwszAllocTemp, NULL);
            if (dwRetVal != SuccessCode) {
                return dwRetVal;
            }
                
            RtlCopyMemory(pwszAllocTemp, pcwszInput, FileName.GetCount() * sizeof(WCHAR));
            pwszAllocTemp[FileName.GetCount()] = UNICODE_NULL;
            pcwszTemp = pwszAllocTemp;
        }
        else {
            pcwszTemp = pcwszInput;
        }

        *pHandle = CreateFileW(pcwszTemp, dwRights, dwSharing, NULL, dwCreation, FILE_ATTRIBUTE_NORMAL, NULL);
        if (*pHandle == INVALID_HANDLE_VALUE) {
            dwRetVal = ::GetLastError();
        }
        else {
            dwRetVal = SuccessCode;
        }

        if (pcwszTemp != pcwszInput) {
            FreeHeap((PVOID)pcwszTemp, NULL);            
        }

        return dwRetVal;
    }

    static StatusCode ReadFile(HANDLE hFile, CEnv::CByteRegion &Target, SIZE_T &cbDidRead) {
        return CEnv::ReadFile(hFile, Target.GetPointer(), Target.GetCount(), cbDidRead);
    }

    static StatusCode ReadFile(HANDLE hFile, PVOID pvTarget, SIZE_T cbToRead, SIZE_T &cbDidRead) {
        DWORD dwToRead, dwDidRead;
        cbDidRead = 0;
        if (cbToRead > 0xFFFFFFFF) {
            return InvalidParameter;
        }
        dwToRead = (DWORD)cbToRead;
        
        if (!::ReadFile(hFile, pvTarget, dwToRead, &dwDidRead, NULL)) {
            return ::GetLastError();
        }

        cbDidRead = dwDidRead;
        return SuccessCode;
    }

    static StatusCode WriteFile(HANDLE hFile, const CEnv::CConstantByteRegion &Source, SIZE_T &cbDidWrite) {
        return CEnv::WriteFile(hFile, (PVOID)Source.GetPointer(), Source.GetCount(), cbDidWrite);
    }


    static StatusCode WriteFile(HANDLE hFile, const PVOID pvSource, SIZE_T cbToWrite, SIZE_T &cbDidWrite) {
        DWORD dwToWrite, dwDidWrite;

        cbDidWrite = 0;
        if (cbDidWrite > 0xFFFFFFFF) {
            return InvalidParameter;
        }
        dwToWrite = (DWORD)cbToWrite;

        if (!::WriteFile(hFile, pvSource, dwToWrite, &dwDidWrite, NULL)) {
            return GetLastError();
        }

        cbDidWrite = dwDidWrite;
        return SuccessCode;
    }


    static StatusCode GetFileSize(HANDLE hFile, PLARGE_INTEGER pcbFileSize) {
        if (GetFileSizeEx(hFile, pcbFileSize)) {
            return SuccessCode;
        }
        else {
            return ::GetLastError();
        }
    }

};

__declspec(selectany) const CWin32Environment::CConstantUnicodeStringPair CWin32Environment::s_FileSystemSeperator(L"\\", 1);
#endif


class CNtEnvironment {
public:
    typedef NTSTATUS StatusCode;

    enum {
        SuccessCode = STATUS_SUCCESS,
        InvalidParameter = STATUS_INVALID_PARAMETER,
        NotEnoughBuffer = STATUS_BUFFER_TOO_SMALL,
    };

    template <typename T> static T ConvertStatusToOther(StatusCode src);

    template <> static CWin32Environment::StatusCode ConvertStatusToOther(StatusCode src) {
        return RtlNtStatusToDosError(src);
    }

    template <> static CNtEnvironment::StatusCode ConvertStatusToOther(StatusCode src) {
        return src;
    }

    static bool DidFail(StatusCode status) { return (status < 0); }
};


#ifndef RTLSXS_USE_KERNEL_MODE
typedef CWin32Environment CEnv;
typedef CNtEnvironment COtherEnv;
#else
typedef CNtEnvironment CEnv;
typedef CWin32Environment COtherEnv;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\manifestcooked.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

////////////////////////////////////////////////////
//
//
// Cooked manifest content


typedef struct _tagMANIFEST_COOKED_IDENTITY_PAIR {
    UNICODE_STRING      Namespace;
    UNICODE_STRING      Name;
    UNICODE_STRING      Value;
} MANIFEST_COOKED_IDENTITY_PAIR, *PMANIFEST_COOKED_IDENTITY_PAIR;

#define COOKEDIDENTITY_FLAG_IS_ROOT                 (0x00000001)

typedef struct _tagMANIFEST_COOKED_IDENTITY {
    ULONG               ulFlags;
    ULONG               ulIdentityComponents;
    PMANIFEST_COOKED_IDENTITY_PAIR pIdentityPairs;
} MANIFEST_COOKED_IDENTITY, *PMANIFEST_COOKED_IDENTITY;

typedef struct _tagMANIFEST_IDENTITY_TABLE {
    ULONG               ulIdentityCount;
    ULONG               ulRootIdentityIndex;
    PMANIFEST_COOKED_IDENTITY CookedIdentities;
} MANIFEST_IDENTITY_TABLE, *PMANIFEST_IDENTITY_TABLE;


#define COOKEDFILE_NAME_VALID                       (0x00000001)
#define COOKEDFILE_LOADFROM_VALID                   (0x00000002)
#define COOKEDFILE_HASHDATA_VALID                   (0x00000004)
#define COOKEDFILE_DIGEST_ALG_VALID                 (0x00000008)
#define COOKEDFILE_HASH_ALG_VALID                   (0x00000010)

typedef struct _tagMANIFEST_COOKED_FILE {
    ULONG               ulFlags;
    UNICODE_STRING      FileName;
    UNICODE_STRING      LoadFrom;
    PBYTE               bHashData;
    ULONG               ulHashByteCount;
    HashType            usDigestAlgorithm;
    HashType            usHashAlgorithm;
} MANIFEST_COOKED_FILE, *PMANIFEST_COOKED_FILE;


typedef struct _tagMANIFEST_COOKED_SUBCATEGORY {
    ULONG               ulFlags;
    UNICODE_STRING      PathName;
} MANIFEST_COOKED_SUBCATEGORY, *PMANIFEST_COOKED_SUBCATEGORY;

typedef struct _tagMANIFEST_COOKED_CATEGORYPARAM {
    ULONG               ulFlags;
    UNICODE_STRING      Name;
    UNICODE_STRING      Value;
} MANIFEST_COOKED_CATEGORYPARAM, *PMANIFEST_COOKED_CATEGORYPARAM;


typedef struct _tagMANIFEST_COOKED_CATEGORY {
    ULONG                           ulFlags;
    ULONG                           ulSubCategoryCount;
    ULONG                           ulCategoryParameters;
    MANIFEST_COOKED_IDENTITY        CategoryIdentity;
    PMANIFEST_COOKED_SUBCATEGORY    pSubCategories;
    PMANIFEST_COOKED_CATEGORYPARAM  pCategoryParameters;
} MANIFEST_COOKED_CATEGORY, *PMANIFEST_COOKED_CATEGORY;


#define COOKEDMANIFEST_HAS_FILES                   (0x00000001)
#define COOKEDMANIFEST_HAS_IDENTITIES              (0x00000002)
#define COOKEDMANIFEST_HAS_COM_CLASSES             (0x00000004)
#define COOKEDMANIFEST_HAS_CLR_CLASSES             (0x00000008)
#define COOKEDMANIFEST_HAS_WINDOW_CLASSES          (0x00000010)
#define COOKEDMANIFEST_HAS_BINDING_REDIRECTS       (0x00000020)

typedef struct _tagMANIFEST_COOKED_DATA {
    SIZE_T                      cbTotalSize;
    ULONG                       ulFlags;
    
    ULONG                       ulFileCount;
    ULONG                       ulCategoryCount;
    
    PMANIFEST_IDENTITY_TABLE    pManifestIdentity;
    PMANIFEST_COOKED_FILE       pCookedFiles;
    PMANIFEST_COOKED_CATEGORY   pCategoryList;

    // More to come here as things evolve
} MANIFEST_COOKED_DATA, *PMANIFEST_COOKED_DATA;



#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\namespacemanager.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif



/*++
    This structure contains an extent and a depth, which the namespace
    manager knows how to interpret in the right context.  The NS_NAMESPACE
    structure contains a list of these which represent aliases at various
    depths along the document structure.  The NS_DEFAULT_NAMESPACES contains
    a pseudo-stack which has the current 'default' namespace at the top.

    
--*/
typedef struct NS_NAME_DEPTH {
    XML_EXTENT      Name;
    ULONG           Depth;
}
NS_NAME_DEPTH, *PNS_NAME_DEPTH;


#define NS_ALIAS_MAP_INLINE_COUNT       (5)
#define NS_ALIAS_MAP_GROWING_COUNT      (20)


typedef struct _NS_ALIAS {

    //
    // Is this in use?
    //
    BOOLEAN fInUse;

    //
    // The name of the alias - "x" or "asm" or the short tag before the : in 
    // an element name, like <x:foo>
    //
    XML_EXTENT  AliasName;

    //
    // How many aliased namespaces are there?
    //
    ULONG ulNamespaceCount;

    //
    // The namespaces that it can map to, with their depths
    //
    RTL_GROWING_LIST    NamespaceMaps;

    //
    // A list of some inline elements, for fun.  This is shallow, as it's
    // the typical case that someone will create a large set of aliases
    // to a small set of namespaces, rather than the other way around.
    //
    NS_NAME_DEPTH InlineNamespaceMaps[NS_ALIAS_MAP_INLINE_COUNT];

}
NS_ALIAS, *PNS_ALIAS;


#define NS_MANAGER_INLINE_ALIAS_COUNT       (10)
#define NS_MANAGER_ALIAS_GROWTH_SIZE        (40)
#define NS_MANAGER_DEFAULT_COUNT            (20)
#define NS_MANAGER_DEFAULT_GROWTH_SIZE      (40)

typedef NTSTATUS (*PFNCOMPAREEXTENTS)(
    PVOID pvContext,
    PCXML_EXTENT pLeft,
    PCXML_EXTENT pRight,
    XML_STRING_COMPARE *pfMatching);



typedef struct _NS_MANAGER {

    //
    // How deep is the default namespace stack?
    //
    ULONG ulDefaultNamespaceDepth;

    //
    // The default namespaces go into this list
    //
    RTL_GROWING_LIST    DefaultNamespaces;

    //
    // How many aliases are there?
    //
    ULONG ulAliasCount;

    //
    // The array of aliases.  N.B. that this list can have holes in it, and
    // the user will have to do some special magic to find empty slots in
    // it to make efficient use of this.  Alternatively, you could have another
    // growing list representing a 'freed slot' stack, but I'm not sure that
    // would really be an optimization.
    //
    RTL_GROWING_LIST  Aliases;

    //
    // Comparison
    //
    PFNCOMPAREEXTENTS pfnCompare;

    //
    // Context
    //
    PVOID pvCompareContext;

    //
    // Inline list of aliases to start with
    //
    NS_ALIAS        InlineAliases[NS_MANAGER_INLINE_ALIAS_COUNT];
    NS_NAME_DEPTH   InlineDefaultNamespaces[NS_MANAGER_DEFAULT_COUNT];
}
NS_MANAGER, *PNS_MANAGER;


NTSTATUS
RtlNsInitialize(
    PNS_MANAGER             pManager,
    PFNCOMPAREEXTENTS       pCompare,
    PVOID                   pCompareContext,
    PRTL_ALLOCATOR          Allocation
    );

NTSTATUS
RtlNsDestroy(
    PNS_MANAGER pManager
    );

NTSTATUS
RtlNsInsertDefaultNamespace(
    PNS_MANAGER     pManager,
    ULONG           ulDepth,
    PXML_EXTENT     pNamespace
    );

NTSTATUS
RtlNsInsertNamespaceAlias(
    PNS_MANAGER     pManager,
    ULONG           ulDepth,
    PXML_EXTENT     pNamespace,
    PXML_EXTENT     pAlias
    );

NTSTATUS
RtlNsLeaveDepth(
    PNS_MANAGER pManager,
    ULONG       ulDepth
    );

NTSTATUS
RtlNsGetNamespaceForAlias(
    PNS_MANAGER     pManager,
    ULONG           ulDepth,
    PXML_EXTENT     Alias,
    PXML_EXTENT     pNamespace
    );


#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\hashers.h ===
#pragma once

#include "sha.h"
#include "sha2.h"
#include "bcl_common.h"
#include "environment.h"

class CHashObject
{
protected:    
    template <typename T> static T* CreateDerived();

    void * operator new(size_t cb);
    void operator delete(void *p);

private:
    typedef struct {
        const CEnv::CConstantByteRegion &Oid;
        const CEnv::CConstantUnicodeStringPair &Name;
        CHashObject* (*pfnCreator)();
    } CHashObjectFactoryMember;

    static CHashObjectFactoryMember s_FactoryItems[];

    typedef CHashObject* (*pfnCreator)();
    
public:
    virtual ~CHashObject() { }
    virtual CEnv::StatusCode Initialize() = 0;
    virtual CEnv::StatusCode Hash(const CEnv::CConstantByteRegion&) = 0;
    virtual CEnv::StatusCode Finalize() = 0;
    virtual CEnv::StatusCode GetValue(CEnv::CConstantByteRegion &pBytes) const = 0;
    virtual const CEnv::CConstantByteRegion &GetOid() const = 0;
    virtual const CEnv::CConstantUnicodeStringPair &GetAlgName() const = 0;

    static CHashObject *HashObjectFromName(const CEnv::CConstantUnicodeStringPair &TextName);
    static CHashObject *HashObjectFromOid(const CEnv::CConstantByteRegion &Oid);
};

class CSha1HashObject : public CHashObject, A_SHA_CTX
{
    unsigned char FinalResult[A_SHA_DIGEST_LEN];
    bool Finalized;
    static const CEnv::CConstantByteRegion s_Sha1Oid;
    static const CEnv::CConstantUnicodeStringPair s_Sha1AlgName;

    CSha1HashObject(const CSha1HashObject&);
    void operator=(const CSha1HashObject&);
public:
    CSha1HashObject();
    virtual ~CSha1HashObject();
    virtual CEnv::StatusCode Initialize();
    virtual CEnv::StatusCode Hash(const CEnv::CConstantByteRegion&);
    virtual CEnv::StatusCode Finalize();
    virtual CEnv::StatusCode GetValue(CEnv::CConstantByteRegion &pBytes) const;
    
    static const CEnv::CConstantByteRegion &Oid() { return s_Sha1Oid; }
    static const CEnv::CConstantUnicodeStringPair &AlgName() { return s_Sha1AlgName; }
    virtual const CEnv::CConstantByteRegion &GetOid() const { return CSha1HashObject::Oid(); }
    virtual const CEnv::CConstantUnicodeStringPair &GetAlgName() const { return CSha1HashObject::AlgName(); }
    static CHashObject* CreateSelf() { return CHashObject::CreateDerived<CSha1HashObject>(); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\manifestinspection.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef enum   {
    eManifestState_DocumentRoot = 0,
    eManifestState_assembly,
    eManifestState_assembly_assemblyIdentity,
    eManifestState_assembly_description,
    eManifestState_assembly_dependency,
    eManifestState_assembly_file,
    eManifestState_assembly_noInherit,
    eManifestState_assembly_noInheritable,
    eManifestState_assembly_comInterfaceExternalProxyStub,
    eManifestState_assembly_dependency_dependentAssembly,
    eManifestState_assembly_dependency_dependentAssembly_assemblyIdentity,
    eManifestState_assembly_dependency_dependentAssembly_bindingRedirect,
    eManifestState_assembly_file_windowClass,
    eManifestState_assembly_file_comClass,
    eManifestState_assembly_file_typelib,
    eManifestState_assembly_file_comInterfaceProxyStub,
    eManifestState_assembly_file_comClass_progId,

    //
    // All this defines the structure of an XMLDSIG <Signature> block
    // for validationd
    //
    eManifestState_Signature,
    eManifestState_Signature_SignatureValue,
    eManifestState_Signature_SignedInfo,
    eManifestState_Signature_SignedInfo_CanonicalizationMethod,
    eManifestState_Signature_SignedInfo_SignatureMethod,
    eManifestState_Signature_SignedInfo_Reference,
    eManifestState_Signature_SignedInfo_Reference_Transforms,
    eManifestState_Signature_SignedInfo_Reference_DigestMethod,
    eManifestState_Signature_SignedInfo_Reference_DigestValue,
    eManifestState_Signature_KeyInfo,
    eManifestState_Signature_KeyInfo_KeyName,
    eManifestState_Signature_KeyInfo_KeyValue,
    eManifestState_Signature_KeyInfo_KeyValue_DSAKeyValue,    
    eManifestState_Signature_KeyInfo_KeyValue_DSAKeyValue_P,
    eManifestState_Signature_KeyInfo_KeyValue_DSAKeyValue_Q,
    eManifestState_Signature_KeyInfo_KeyValue_DSAKeyValue_G,
    eManifestState_Signature_KeyInfo_KeyValue_DSAKeyValue_Y,
    eManifestState_Signature_KeyInfo_KeyValue_DSAKeyValue_J,
    eManifestState_Signature_KeyInfo_KeyValue_DSAKeyValue_Seed,
    eManifestState_Signature_KeyInfo_KeyValue_DSAKeyValue_PgenCounter,    
    eManifestState_Signature_KeyInfo_KeyValue_RSAKeyValue,
    eManifestState_Signature_KeyInfo_KeyValue_RSAKeyValue_Modulus,
    eManifestState_Signature_KeyInfo_KeyValue_RSAKeyValue_Exponent,
    
    eManifestState_Signature_Object,

    eManifestState_State_Count
} MANIFEST_PARSE_STATE;



typedef struct _tagASSEMBLY_MEMBER_FILE_RAW {
    XML_EXTENT              FileName;
    XML_EXTENT              HashAlg;
    XML_EXTENT              HashValue;
    XML_EXTENT              LoadFrom;
    XML_EXTENT              DigestMethod;
    XML_EXTENT              Size;
} ASSEMBLY_MEMBER_FILE_RAW, *PASSEMBLY_MEMBER_FILE_RAW;

typedef struct _tagCOMINTERFACE_REDIRECTION_RAW {
    ULONG                   ulFileTag;
    XML_EXTENT              Iid;
    XML_EXTENT              Name;
    XML_EXTENT              TlbId;
    XML_EXTENT              MethodCount;
    XML_EXTENT              ProxyStubClsid32;
    XML_EXTENT              BaseInterface;
} COMINTERFACE_REDIRECTION_RAW, *PCOMINTERFACE_REDIRECTION_RAW;

typedef struct _tagCOMCLASS_REDIRECTION_RAW {
    ULONG                   ulFileTag;   
    XML_EXTENT              Description;
    XML_EXTENT              clsid;
    XML_EXTENT              tlbident;
    XML_EXTENT              ThreadModel;
    XML_EXTENT              DefaultProgid;
    
} COMCLASS_REDIRECTION_RAW, *PCOMCLASS_REDIRECTION_RAW;

typedef struct _tagCOMCLASS_PROGID_RAW {
    ULONG                   ulComClass;
    XML_EXTENT              ProgId;
} COMCLASS_PROGID_RAW, *PCOMCLASS_PROGID_RAW;


typedef struct _tagWINDOWCLASS_REDIRECT_RAW {
    ULONG                   ulFileTag;
    XML_EXTENT              WindowClass;
    XML_EXTENT              Versioned;
} WINDOWCLASS_REDIRECTION_RAW, *PWINDOWCLASS_REDIRECTION_RAW;


typedef struct _tagTYPELIB_REDIRECT_RAW {
    ULONG                   ulFileTag;   
    XML_EXTENT              tlbident;
    XML_EXTENT              Version;
    XML_EXTENT              HelpDirectory;
    XML_EXTENT              ResourceIdent;
    XML_EXTENT              Flags;
} TYPELIB_REDIRECT_RAW, *PTYPELIB_REDIRECT_RAW;

typedef struct _tagASSEMBLY_IDENTITY_ATTRIBUTE_RAW {
    ULONG                   ulIdentityIndex;
    XML_EXTENT              Namespace;
    XML_EXTENT              Attribute;
    XML_EXTENT              Value;
} ASSEMBLY_IDENTITY_ATTRIBUTE_RAW, *PASSEMBLY_IDENTITY_ATTRIBUTE_RAW;


#define MANIFEST_CONTENT_SELF_ALLOCATED             (0x80000000)
#define INVALID_ASSEMBLY_IDENTITY_INDEX             ((ULONG)-1)

typedef struct _tagRTL_MANIFEST_CONTENT_RAW {
    ULONG               ulFlags;
    ULONG               ulFileMembers;
    ULONG               ulWindowClasses;
    ULONG               ulComClasses;
    ULONG               ulTypeLibraries;
    ULONG               ulInterfaceProxyStubs;
    ULONG               ulExternalInterfaceProxyStubs;
    ULONG               ulDocumentSignatures;

    // How many assembly identity attributes did we find?    
    ULONG               ulAssemblyIdentityAttributes;

    // How many assembly identities is that total?
    ULONG               ulAssemblyIdentitiesFound;

    // And which one is the 'root' identity element? (-1 if not present)
    ULONG               ulRootIdentityIndex;

    RTL_GROWING_LIST    FileMembers;
    RTL_GROWING_LIST    AssemblyIdentityAttributes;    
    PRTL_GROWING_LIST   pWindowClasses;
    PRTL_GROWING_LIST   pComClasses;
    PRTL_GROWING_LIST   pTypeLibraries;
    PRTL_GROWING_LIST   pInterfaceProxyStubs;
    PRTL_GROWING_LIST   pExternalInterfaceProxyStubs;
    PRTL_GROWING_LIST   pManifestSignatures;
    PRTL_GROWING_LIST   pProgIds;
   
} RTL_MANIFEST_CONTENT_RAW, *PRTL_MANIFEST_CONTENT_RAW;




NTSTATUS
RtlInspectManifestStream(
    ULONG                           ulFlags,
    PVOID                           pvManifest,
    SIZE_T                          cbManifest,
    PRTL_MANIFEST_CONTENT_RAW       pContent,
    PXML_TOKENIZATION_STATE         pTargetTokenState
    );


EXTERN_C const XML_SPECIAL_STRING sc_ss_xmldecl_version_10;
EXTERN_C const XML_SPECIAL_STRING sc_ss_xmldecl_yes;
EXTERN_C const XML_SPECIAL_STRING sc_ss_xmlnamespace_default;


NTSTATUS
RtlSxsInitializeManifestRawContent(
    ULONG                           ulRequestedContent,
    PRTL_MANIFEST_CONTENT_RAW      *pRawContentOut,
    PVOID                           pvOriginalBuffer,
    SIZE_T                          cbOriginalBuffer
    );

NTSTATUS
RtlSxsDestroyManifestContent(
    PRTL_MANIFEST_CONTENT_RAW       pRawContent
    );
    

//
// This section gives definitions for how to describe an XML document to 
// be processed in a nicely generic way.  Currently the only client of these definitions
// is the manifest inspector itself, but one can imagine using these to create
// recognizers for various xml document formats.
//
typedef NTSTATUS (*pfnRtlXmlValidateAttributeValue)(
    ULONG ulFlags,
    PXML_TOKENIZATION_STATE LogicalState,
    PRTL_MANIFEST_CONTENT_RAW RawContentBlob,
    const struct _XML_ELEMENT_DEFINITION* ParentElement,
    const struct _XML_VALID_ELEMENT_ATTRIBUTE* CurrentAttribDef,
    BOOLEAN *IsValid
    );

#define XML_ATTRIBUTE_FLAG_REQUIRED             (0x00000001)

typedef struct _XML_VALID_ELEMENT_ATTRIBUTE
{
    ULONG ulFlags;

    XML_ATTRIBUTE_DEFINITION Attribute;
    
    pfnRtlXmlValidateAttributeValue pfnValidator;
    
} XML_VALID_ELEMENT_ATTRIBUTE, *PXML_VALID_ELEMENT_ATTRIBUTE;
typedef const XML_VALID_ELEMENT_ATTRIBUTE *PCXML_VALID_ELEMENT_ATTRIBUTE;


// This element must not contain non-whitespace PCData
#define XML_ELEMENT_FLAG_NO_PCDATA              (0x00000001)

// This element must not contain children of any sort
#define XML_ELEMENT_FLAG_NO_ELEMENTS            (0x00000002)

// Allow arbitrary attributes on this element, not just those defined
#define XML_ELEMENT_FLAG_ALLOW_ANY_ATTRIBUTES   (0x00000004)

// Allow arbitrary children of this element, not just those defined
// (Child elements will not be sent to the notification function)
#define XML_ELEMENT_FLAG_ALLOW_ANY_CHILDREN     (0x00000008)

typedef enum {
    eElementNotify_Open,
    eElementNotify_Close,
    eElementNotify_Hyperspace
} MANIFEST_ELEMENT_CALLBACK_REASON;

typedef NTSTATUS (*pfnManifestElementCallback)(
    PXML_LOGICAL_STATE          pLogicalState,
    PRTL_MANIFEST_CONTENT_RAW   pManifestContent,
    PXMLDOC_THING               pElement,
    PRTL_GROWING_LIST           pAttributes,
    MANIFEST_ELEMENT_CALLBACK_REASON Reason,
    const struct _XML_ELEMENT_DEFINITION *pElementDefinition
    );

#pragma warning(disable:4200)

typedef struct _XML_ELEMENT_DEFINITION
{
    ULONG ulFlags;
    ULONG StateIdentifier;
    const struct _XML_ELEMENT_DEFINITION *ParentElement;

    // The name of this element (not path, just name)
    PCXML_SPECIAL_STRING Namespace;
    const XML_SPECIAL_STRING Name;

    //
    // Who should be notified?
    //
    pfnManifestElementCallback pfnWorkerCallback;

    //
    // The children of this element, terminated with a NULL pointer.
    //
    const struct _XML_ELEMENT_DEFINITION **ChildElements;
    
    
    //
    // Potential attributes of this element
    //
    ULONG AttributeCount;
    const XML_VALID_ELEMENT_ATTRIBUTE AttributeList[];

}
XML_ELEMENT_DEFINITION, *PXML_ELEMENT_DEFINITION; 
typedef const XML_ELEMENT_DEFINITION *PCXML_ELEMENT_DEFINITION;


#define ELEMENT_DEFINITION_NS(parentpath, thisname, ns, validator, flags) \
    extern PCXML_ELEMENT_DEFINITION rgs_Element_##parentpath##_##thisname##_Children[]; \
    XML_ELEMENT_DEFINITION rgs_Element_##parentpath##_##thisname = { \
        (flags), \
        eManifestState_##parentpath##_##thisname, \
        &rgs_Element_##parentpath, \
        &ns, \
        MAKE_SPECIAL_STRING(#thisname), \
        (validator), \
        rgs_Element_##parentpath##_##thisname##_Children, \
        eAttribs_##parentpath##_##thisname##_Count, \
        {

#define ELEMENT_DEFINITION_DEFNS(parentpath, thisname, validator, flags) ELEMENT_DEFINITION_NS(parentpath, thisname, sc_ss_xmlnamespace_default, validator, flags)
#define ELEMENT_DEFINITION_DEFNS_END() } };

#define ELEMENT_DEFINITION_DEFNS_NOCB(p, t) ELEMENT_DEFINITION_DEFNS(p, t, Rtl_Default_Validator)

#define ATTRIBUTE_DEFINITION_NONS_NODEFAULT(attribname) { XML_ATTRIBUTE_FLAG_REQUIRED, { NULL, MAKE_SPECIAL_STRING(#attribname) } }
#define ATTRIBUTE_DEFINITION_NONS_NODEFAULT_OPTIONAL(attribname) { 0, { NULL, MAKE_SPECIAL_STRING(#attribname) } }
#define NO_CHILD_ELEMENTS()
#define ELEMENT_DEFINITION_CHILD_ELEMENTS(parentpath, thisname) PCXML_ELEMENT_DEFINITION rgs_Element_##parentpath##_##thisname##_Children[] = {
#define ELEMENT_CHILD(path, child) (&rgs_Element_##path##_##child)
#define ELEMENT_DEFINITION_CHILD_ELEMENTS_END() NULL };
#define ELEMENT_NAMED(path) (&rgs_Element_##path)
#define DECLARE_ELEMENT(path) \
    extern PCXML_ELEMENT_DEFINITION rgs_Element_##path##_Children[]; \
    extern XML_ELEMENT_DEFINITION rgs_Element_##path


NTSTATUS
RtlConvertRawToCookedContent(
    PRTL_MANIFEST_CONTENT_RAW   pRawContent,
    PXML_RAWTOKENIZATION_STATE  pState,
    PVOID                       pvOriginalRegion,
    SIZE_T                      cbRegionSize,
    PSIZE_T                     pcbRequired
    );

NTSTATUS
RtlValidateAttributesAndOrganize(
    PXML_TOKENIZATION_STATE         State,
    PXMLDOC_ELEMENT                 Element,
    PRTL_GROWING_LIST               Attributes,
    PCXML_ELEMENT_DEFINITION        ThisElement,
    PXMLDOC_ATTRIBUTE              *OrderedList
    );


#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\fasterxml.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned char BYTE;
typedef BYTE *PBYTE;



//
// These "raw tokens" are the stuff that comes out of the
// base tokenization engine.  Special characters are given
// names, a 'special character' being one that is called out
// anywhere in the XML spec as having a meaning other than
// text.
//
typedef enum 
{
    NTXML_RAWTOKEN_ERROR,
    NTXML_RAWTOKEN_DASH,
    NTXML_RAWTOKEN_DOT,
    NTXML_RAWTOKEN_END_OF_STREAM,
    NTXML_RAWTOKEN_EQUALS,
    NTXML_RAWTOKEN_FORWARDSLASH,
    NTXML_RAWTOKEN_GT,
    NTXML_RAWTOKEN_LT,
    NTXML_RAWTOKEN_QUESTIONMARK,
    NTXML_RAWTOKEN_QUOTE,
    NTXML_RAWTOKEN_DOUBLEQUOTE,
    NTXML_RAWTOKEN_START_OF_STREAM,
    NTXML_RAWTOKEN_TEXT,
    NTXML_RAWTOKEN_WHITESPACE,
    NTXML_RAWTOKEN_OPENBRACKET,
    NTXML_RAWTOKEN_CLOSEBRACKET,
    NTXML_RAWTOKEN_BANG,
    NTXML_RAWTOKEN_OPENCURLY,
    NTXML_RAWTOKEN_CLOSECURLY,
    NTXML_RAWTOKEN_COLON,
    NTXML_RAWTOKEN_SEMICOLON,
    NTXML_RAWTOKEN_UNDERSCORE,
    NTXML_RAWTOKEN_AMPERSTAND,
    NTXML_RAWTOKEN_POUNDSIGN
} NTXML_RAW_TOKEN;


typedef enum {

    XMLEF_UNKNOWN = 0,
    XMLEF_UCS_4_LE,
    XMLEF_UCS_4_BE,
    XMLEF_UTF_16_LE,
    XMLEF_UTF_16_BE,
    XMLEF_UTF_8_OR_ASCII

} XML_ENCODING_FAMILY;


typedef struct _XML_EXTENT {
    PVOID   pvData;                 // Pointer into the original XML document
    SIZE_T  cbData;                 // Byte count from the extent base
    XML_ENCODING_FAMILY Encoding;   // Encoding family for faster decoding
    ULONG   ulCharacters;           // Character count in this extent
}
XML_EXTENT, *PXML_EXTENT;

typedef const struct _XML_EXTENT * PCXML_EXTENT;


//
// Clients of the raw tokenizer should provide a "next character"
// functionality.  This way, the tokenization engine doesn't need
// to know anything about how to get the next thing out of a pvoid
// blob of data, allowing for compressed streams, multiple encodings,
// etc.
//
typedef ULONG (__fastcall *NTXMLRAWNEXTCHARACTER)(
    struct _XML_RAWTOKENIZATION_STATE* pContext
    );

typedef struct _XML_SPECIAL_STRING {
    //
    // UNICODE representation of the string
    //
    WCHAR  *wszStringText;
    SIZE_T  cchwszStringText;
}
XML_SPECIAL_STRING, *PXML_SPECIAL_STRING;

typedef const struct _XML_SPECIAL_STRING *PCXML_SPECIAL_STRING;

#define EMPTY_SPECIAL_STRING { NULL, 0 }
#define MAKE_SPECIAL_STRING(str) { L##str, NUMBER_OF(L##str) - 1 }



extern XML_SPECIAL_STRING xss_CDATA;
extern XML_SPECIAL_STRING xss_xml;
extern XML_SPECIAL_STRING xss_encoding;
extern XML_SPECIAL_STRING xss_standalone;
extern XML_SPECIAL_STRING xss_version;

//
// A 'raw' token is more or less a run of bytes in the XML that is given
// a name.  The low-level tokenizer returns these as it runs, and assumes
// that the higher-level tokenizer knows how to turn groups of these into
// productions, and from there the lexer knows how to turn groups of the
// real tokens into meaning.
//
typedef struct _XML_RAW_TOKEN
{
    //
    // This is the 'name' of this token, so that we can easily switch on
    // it in upper-level layers.
    //
    NTXML_RAW_TOKEN     TokenName;

    //
    // Pointer and length of the extent
    //
    XML_EXTENT          Run;
}
XML_RAW_TOKEN, *PXML_RAW_TOKEN;

//
// This is the base tokenization state blob necessary to keep tokenizing
// between calls.  See member descriptions for more details.
//
typedef struct _XML_RAWTOKENIZATION_STATE
{

    //
    // PVOID and length of the original XML document
    //
    XML_EXTENT              OriginalDocument;

    //
    // Pointer to the 'end' of the document.
    //
    PVOID pvDocumentEnd;

    //
    // Pointer into the XML data that represents where we are at the moment
    // in tokenization.  Will not be moved by the raw tokenizer - you must
    // use the NtRawXmlAdvanceCursor (or related) to move the cursor along
    // the data stream.  Hence, calling the tokenizer twice in a row will
    // get you the same token.
    //
    PVOID                   pvCursor;

    //
    // The function that this tokenization run is using for getting the
    // next WCHAR out of the PVOID pointed to by pvCursor.  If this member
    // is NULL, you get a bit of default functionality that knows about
    // UNICODE, little-endianness, and UTF8.
    //
    NTXMLRAWNEXTCHARACTER   pfnNextChar;

    //
    // The encoding family can be detected from the first bytes in the
    // incoming stream.  They are classified according to the XML spec,
    // which defaults to UTF-8.
    //
    XML_ENCODING_FAMILY     EncodingFamily;

    //
    // When the upper-level tokenizer detects the "encoding" statement
    // in the <?xml ...?> declaration, it should set this member to the
    // code page that was found.  Noticably, this will start out as
    // zero on initialization.  A smart "next character" function will
    // do some default operation to continue working even if this is
    // unset.
    //
    ULONG                   DetectedCodePage;

    XML_RAW_TOKEN LastTokenCache;
    PVOID pvLastCursor;

    //
    // How many bytes were in the last thing?
    //
    SIZE_T                  cbBytesInLastRawToken;

    //
    // Result of the next-character call
    //
    NTSTATUS                NextCharacterResult;

    //
    // Default character size, set by the initializer that determines the
    // encoding.
    //
    SIZE_T DefaultCharacterSize;
}
XML_RAWTOKENIZATION_STATE, *PXML_RAWTOKENIZATION_STATE;







//
// Simple interface out to the Real World.  This allocator should be
// replaced (eventually) with calls directly into the proper
// allocator (HeapAlloc/ExAllocatePoolWithTag) in production code.
//
typedef NTSTATUS (*NTXML_ALLOCATOR)(
    SIZE_T ulBytes,
    PVOID *ppvAllocated,
    PVOID pvAllocationContext);

//
// Frees memory allocated with the corresponding NTXML_ALLOCATOR
// call.
//
typedef NTSTATUS (*NTXML_DEALLOCATOR)(PVOID pvAllocated, PVOID pvContext);


/*++

Normal operation would go like this:

  <?xml version="1.0"? encoding="UTF-8" standalone="yes"?>
  <!-- commentary -->
  <?bonk foo?>
  <ham>
    <frooby:cheese hot="yes"/>
  </ham>

  XTLS_STREAM_START
  XTLS_XMLDECL                      {XTSS_XMLDECL_OPEN      "<?xml"         }
  XTLS_XMLDECL                      {XTSS_XMLDECL_VERSION   "version"       }
  XTLS_XMLDECL                      {XTSS_XMLDECL_EQUALS    "="             }
  XTLS_XMLDECL                      {XTSS_XMLDECL_VALUE     "1.0"           }
  XTLS_XMLDECL                      {XTSS_XMLDECL_ENCODING  "encoding"      }
  XTLS_XMLDECL                      {XTSS_XMLDECL_EQUALS    "="             }
  XTLS_XMLDECL                      {XTSS_XMLDECL_VALUE     "UTF-8"         }
  XTLS_XMLDECL                      {XTSS_XMLDECL_STANDALONE "standalone"   }
  XTLS_XMLDECL                      {XTSS_XMLDECL_EQUALS    "="             }
  XTLS_XMLDECL                      {XTSS_XMLDECL_VALUE     "yes"           }
  XTLS_XMLDECL                      {XTSS_XMLDECL_CLOSE     "?>"            }
  XTLS_COMMENT                      {XTSS_COMMENT_OPEN      "<!--"          }
  XTLS_COMMENT                      {XTSS_COMMENT_CONTENT   " commentary "  }
  XTLS_COMMENT                      {XTSS_COMMENT_CLOSE     "-->"           }
  XTLS_PROCESSING_INSTRUCTION       {XTSS_PI_OPEN           "<?"            }
  XTLS_PROCESSING_INSTRUCTION       {XTSS_PI_NAME           "bonk"          }
  XTLS_PROCESSING_INSTRUCTION       {XTSS_PI_CONTENT        "foo"           }
  XTLS_PROCESSING_INSTRUCTION       {XTSS_PI_CLOSE          "?>"            }
  XTLS_FLOATINGDATA                 {XTSS_FD_WHITESPACE     "\n"            }
  XTLS_ELEMENT                      {XTSS_ELEMENT_OPEN      "<"             }
  XTLS_ELEMENT                      {XTSS_ELEMENT_NAME      "ham"           }
  XTLS_ELEMENT                      {XTSS_ELEMENT_CLOSE     ">"             }
  XTLS_FLOATINGDATA                 {XTSS_FLOATINGDATA      "\n  "          }
  XTLS_ELEMENT                      {XTSS_ELEMENT_OPEN      "<"             }
  XTLS_ELEMENT                      {XTSS_ELEMENT_NAMESPACE "frooby"        }
  XTLS_ELEMENT                      {XTSS_ELEMENT_NAME      "cheese"        }
  XTLS_ELEMENT                      {XTSS_ELEMENT_VALUENAME "hot"           }
  XTLS_ELEMENT                      {XTSS_ELEMENT_VALUE     "yes"           }
  XTLS_ELEMENT                      {XTSS_ELEMENT_EMPTYCLOSE   "/>"         }
  XTLS_FLOATINGDATA                 {XTSS_FLOATINGDATA      "\n"            }
  XTLS_ELEMENT                      {XTSS_ELEMENT_CLOSETAG  "</"            }
  XTLS_ELEMENT                      {XTSS_ELEMENT_NAME      "ham"           }
  XTLS_ELEMENT                      {XTSS_ELEMENT_CLOSE     ">"             }
  XTLS_STREAM_END

--*/


typedef enum {

    XTSS_ERRONEOUS,


    //
    // In the middle of "nowhere" - the hyperspace between elements
    //
    XTSS_STREAM_HYPERSPACE,

    //
    // At the start of the input stream
    //
    XTSS_STREAM_START,

    //
    // At the end of the input stream
    //
    XTSS_STREAM_END,


    ////////////////////////////////////////////
    //
    // ELEMENT STATES
    //
    ////////////////////////////////////////////

    //
    // Meaning:     An element tag was found.
    //
    // Rawtoken:    NTXML_RAWTOKEN_LT
    //
    XTSS_ELEMENT_OPEN,

    //
    // Meaning:     A run of text was found that could represent a name.
    //              This is basically all the text found between the opening
    //              element tag and some illegal values.
    //
    // Rawtoken:    A run of any of the following:
    //                  NTXML_RAWTOKEN_TEXT
    //                  NTXML_RAWTOKEN_DOT
    //                  NTXML_RAWTOKEN_COLON
    //                  NTXML_RAWTOKEN_UNDERSCORE
    //                  NTXML_RAWTOKEN_DASH
    //              The name ends when something else appears.
    //
    XTSS_ELEMENT_NAME,


    //
    // Found the xmlns part of <foo xmlns:bar=
    //
    XTSS_ELEMENT_XMLNS,

    //
    // Found <foo xmlns=
    //
    XTSS_ELEMENT_XMLNS_DEFAULT,

    //
    // Found the 'a' in <foo xml:a=
    //
    XTSS_ELEMENT_XMLNS_ALIAS,

    //
    // Found the colon between xmlns and the alias
    //
    XTSS_ELEMENT_XMLNS_COLON,

    //
    // Found the equals sign between xmlns and the value
    //
    XTSS_ELEMENT_XMLNS_EQUALS,

    XTSS_ELEMENT_XMLNS_VALUE_OPEN,
    XTSS_ELEMENT_XMLNS_VALUE_CLOSE,
    XTSS_ELEMENT_XMLNS_VALUE,

    //
    // This is the prefix for an element name, if present
    //
    XTSS_ELEMENT_NAME_NS_PREFIX,

    //
    // This is the colon after an element name ns prefix
    //
    XTSS_ELEMENT_NAME_NS_COLON,

    //
    // This is the prefix on an attribute name for a namespace
    //
    XTSS_ELEMENT_ATTRIBUTE_NAME_NS_PREFIX,

    //
    // This is the colon after an element attribute name namespace prefix
    //
    XTSS_ELEMENT_ATTRIBUTE_NAME_NS_COLON,

    //
    // Meaning:     A close of a tag (>) was found
    //
    // Rawtoken:    NTXML_RAWTOKEN_GT
    //
    XTSS_ELEMENT_CLOSE,

    //
    // Meaning:     An empty-tag (/>) was found
    //
    // Rawtoken:    NTXML_RAWTOKEN_FORWARDSLASH NTXML_RAWTOKEN_GT
    //
    XTSS_ELEMENT_CLOSE_EMPTY,

    //
    // Meaning:     An attribute name was found
    //
    // Rawtoken:    See rules for XTSS_ELEMENT_NAME
    //
    XTSS_ELEMENT_ATTRIBUTE_NAME,

    //
    // Meaning:     An equals sign was found in an element
    //
    // Rawtoken:    NTXML_RAWTOKEN_EQUALS
    //
    XTSS_ELEMENT_ATTRIBUTE_EQUALS,

    //
    // Meaning:     The quote (start or end) of an element-attribute value
    //              was found.
    //
    // Rawtokne;    NTXML_RAWTOKEN_QUOTE
    //
    XTSS_ELEMENT_ATTRIBUTE_QUOTE,

    //
    // Meaning:     Element attribute value data was found after a
    //              quote of some variety.
    //
    // Rawtoken:    A run of any thing that's not the following:
    //                  NTXML_RAWTOKEN_LT
    //                  NTXML_RAWTOKEN_QUOTE (unless this quote is not the same
    //                                        as the quote in 
    //                                          XTSS_ELEMENT_ATTRIBUTE_QUOTE)
    //
    // N.B.:        See special rules on handling entities in text.
    //
    XTSS_ELEMENT_ATTRIBUTE_VALUE,
    XTSS_ELEMENT_ATTRIBUTE_OPEN,
    XTSS_ELEMENT_ATTRIBUTE_CLOSE,

    //
    // Meaning:     Whitespace was found in the element tag at this point
    //
    // Rawtoken:    NTXML_RAWTOKEN_WHITESPACE
    //
    XTSS_ELEMENT_WHITESPACE,



    
    ////////////////////////////////////////////
    //
    // END ELEMENT SPECIFIC STATES
    //
    ////////////////////////////////////////////

    //
    // Meaning:     The start of an "end element" was found
    //
    // Rawtoken:    NTXML_RAWTOKEN_LT NTXML_RAWTOKEN_FORWARDSLASH
    //
    XTSS_ENDELEMENT_OPEN,

    //
    // Meaning:     The name of an end element was found
    //
    // Rawtoken:    See rules for XTSS_ELEMENT_NAME
    //
    XTSS_ENDELEMENT_NAME,

    //
    // Meaning:     We're in the whitespace portion of the end element
    //
    // Rawtoken:    NTXML_RAWTOKEN_WHITESPACE
    //
    XTSS_ENDELEMENT_WHITESPACE,

    //
    // Meaning:     The close of an endelement tag was found
    //
    // Rawtoken:    NTXML_RAWTOKEN_GT
    //
    XTSS_ENDELEMENT_CLOSE,

    //
    // Namespace prefix on the endelement name
    //
    XTSS_ENDELEMENT_NS_PREFIX,

    //
    // Colon after the namespace prefix in the endelement tag
    //
    XTSS_ENDELEMENT_NS_COLON,



    ////////////////////////////////////////////
    //
    // XML PROCESSING INSTRUCTION STATES
    //
    ////////////////////////////////////////////

    //
    // Meaning:     The start of an xml processing instruction was found
    //
    // Rawtokens:   NTXML_RAWTOKEN_LT NTXML_RAWTOKEN_QUESTIONMARK
    //
    XTSS_PI_OPEN,

    //
    // Meaning:     The end of an XML processing instruction was found
    //
    // Rawtokens:   NTXML_RAWTOKEN_QUESTIONMARK NTXML_RAWTOKEN_GT
    //
    XTSS_PI_CLOSE,

    //
    // Meaning:     The processing instruction name was found
    //
    // Rawtokens:   A nonempty stream of tokens identifying a name.  See the
    //              rules for XTSS_ELEMENT_NAME for details.
    //
    XTSS_PI_TARGET,

    //
    // Meaning:     Some processing instruction metadata was found.
    //
    // Rawtokens:   Anything except the sequence
    //                  NTXML_RAWTOKEN_QUESTIONMARK NTXML_RAWTOKEN_GT
    //
    XTSS_PI_VALUE,

    //
    // Meaning:     Whitespace between the target and the value was found
    //
    // Rawtokens:   NTXML_RAWTOKEN_WHITESPACE
    //
    XTSS_PI_WHITESPACE,



    ////////////////////////////////////////////
    //
    // XML PROCESSING INSTRUCTION STATES
    //
    ////////////////////////////////////////////

    //
    // Meaning:     Start of a comment block
    //
    // Rawtokens:   NTXML_RAWTOKEN_LT NTXML_RAWTOKEN_BANG NTXML_RAWTOKEN_DASH NTXML_RAWTOKEN_DASH
    //
    XTSS_COMMENT_OPEN,

    //
    // Meaning:     Commentary data, should be ignored by a good processor
    //
    // Rawtokens:   Anything except the sequence:
    //                  NTXML_RAWTOKEN_DASH NTXML_RAWTOKEN_DASH
    //
    XTSS_COMMENT_COMMENTARY,

    //
    // Meaning:     Comment close tag
    //
    // Rawtokens:   NTXML_RAWTOKEN_DASH NTXML_RAWTOKEN_DASH NTXML_RAWTOKEN_GT
    //
    XTSS_COMMENT_CLOSE,


    ////////////////////////////////////////////
    //
    // XML PROCESSING INSTRUCTION STATES
    //
    ////////////////////////////////////////////

    //
    // Meaning:     Opening of a CDATA block
    //
    // Rawtokens:   NTXML_RAWTOKEN_LT 
    //              NTXML_RAWTOKEN_BRACE
    //              NTXML_RAWTOKEN_BANG 
    //              NTXML_RAWTOKEN_TEXT (CDATA) 
    //              NTXML_RAWTOKEN_BRACE
    //
    XTSS_CDATA_OPEN,

    //
    // Meaning:     Unparseable CDATA stuff
    //
    // Rawtokens:   Anything except the sequence
    //                  NTXML_RAWTOKEN_BRACE
    //                  NTXML_RAWTOKEN_BRACE
    //                  NTXML_RAWTOKEN_GT
    //
    XTSS_CDATA_CDATA,

    //
    // Meaning:     End of a CDATA block
    //
    XTSS_CDATA_CLOSE,


    ////////////////////////////////////////////
    //
    // XMLDECL (<?xml) states
    //
    ////////////////////////////////////////////

    XTSS_XMLDECL_OPEN,
    XTSS_XMLDECL_CLOSE,
    XTSS_XMLDECL_WHITESPACE,
    XTSS_XMLDECL_EQUALS,
    XTSS_XMLDECL_ENCODING,
    XTSS_XMLDECL_STANDALONE,
    XTSS_XMLDECL_VERSION,
    XTSS_XMLDECL_VALUE_OPEN,
    XTSS_XMLDECL_VALUE,
    XTSS_XMLDECL_VALUE_CLOSE,



} XML_TOKENIZATION_SPECIFIC_STATE;


//
// Another, similar XML token structure for the 'cooked' XML bits.
//
typedef struct _XML_TOKEN {

    //
    // Pointer and length of the data in the token
    //
    XML_EXTENT      Run;

    //
    // What state are we in at the moment
    //
    XML_TOKENIZATION_SPECIFIC_STATE State;

    //
    // Was there an error gathering up this state?
    //
    BOOLEAN fError;

} 
XML_TOKEN, *PXML_TOKEN;

typedef const struct _XML_TOKEN *PCXML_TOKEN;

typedef enum {
    XML_STRING_COMPARE_EQUALS = 0,
    XML_STRING_COMPARE_GT = 1,
    XML_STRING_COMPARE_LT = -1
}
XML_STRING_COMPARE;


    
//
// This function knows how to compare a pvoid and a length against
// a 7-bit ascii string
//
typedef NTSTATUS (*NTXMLSPECIALSTRINGCOMPARE)(
    struct _XML_TOKENIZATION_STATE      *pState,
    const struct _XML_EXTENT            *pRawToken,
    const struct _XML_SPECIAL_STRING    *pSpecialString,
    XML_STRING_COMPARE                  *pfResult
    );



//
// Compare two extents
//
typedef NTSTATUS (*NTXMLCOMPARESTRINGS)(
    struct _XML_TOKENIZATION_STATE *TokenizationState,
    PXML_EXTENT pLeft,
    PXML_EXTENT pRight,
    XML_STRING_COMPARE *pfEquivalent);


typedef NTSTATUS (*RTLXMLCALLBACK)(
    PVOID                           pvCallbackContext,
    struct _XML_TOKENIZATION_STATE *State,
    PCXML_TOKEN                     Token,
    PBOOLEAN                        StopTokenization
    );
    

//
// Now let's address the 'cooked' tokenization
// methodology.
//
typedef struct _XML_TOKENIZATION_STATE {

    //
    // Core tokenization state data
    //
    XML_RAWTOKENIZATION_STATE RawTokenState;

    //
    // State values
    //
    XML_TOKENIZATION_SPECIFIC_STATE PreviousState;

    //
    // Scratch pad for holding tokens
    //
    XML_RAW_TOKEN RawTokenScratch[20];

    //
    // Ways to compare two strings
    //
    NTXMLCOMPARESTRINGS pfnCompareStrings;

    //
    // Compare an extent against a 'magic' string
    //
    NTXMLSPECIALSTRINGCOMPARE pfnCompareSpecialString;

    //
    // Scratch space for the opening quote rawtoken name, if we're in
    // a quoted string (ie: attribute value, etc.)
    //
    NTXML_RAW_TOKEN         QuoteTemp;

    //
    // Callback
    //
    PVOID                  prgXmlTokenCallbackContext;
    RTLXMLCALLBACK         prgXmlTokenCallback;

}
XML_TOKENIZATION_STATE, *PXML_TOKENIZATION_STATE;



NTSTATUS
RtlXmlAdvanceTokenization(
    PXML_TOKENIZATION_STATE pState,
    PXML_TOKEN pToken
    );



NTSTATUS
RtlXmlDetermineStreamEncoding(
    PXML_TOKENIZATION_STATE pState,
    PSIZE_T pulBytesOfEncoding,
    PXML_EXTENT EncodingName
    );


NTSTATUS
RtlXmlInitializeTokenization(
    PXML_TOKENIZATION_STATE     pState,
    PVOID                       pvData,
    SIZE_T                      cbData,
    NTXMLRAWNEXTCHARACTER       pfnNextCharacter,
    NTXMLSPECIALSTRINGCOMPARE   pfnSpecialStringComparison,
    NTXMLCOMPARESTRINGS         pfnNormalStringComparison
    );

NTSTATUS
RtlXmlCloneRawTokenizationState(
    const PXML_RAWTOKENIZATION_STATE pStartState,
    PXML_RAWTOKENIZATION_STATE pTargetState
    );


NTSTATUS
RtlXmlCloneTokenizationState(
    const PXML_TOKENIZATION_STATE pStartState,
    PXML_TOKENIZATION_STATE pTargetState
    );


NTSTATUS
RtlXmlNextToken(
    PXML_TOKENIZATION_STATE pState,
    PXML_TOKEN              pToken,
    BOOLEAN                 fAdvanceState
    );


NTSTATUS
RtlXmlCopyStringOut(
    PXML_TOKENIZATION_STATE pState,
    PXML_EXTENT             pExtent,
    PWSTR                   pwszTarget,
    SIZE_T                 *pCchResult
    );

NTSTATUS
RtlXmlDefaultCompareStrings(
    PXML_TOKENIZATION_STATE pState,
    PCXML_EXTENT pLeft,
    PCXML_EXTENT pRight,
    XML_STRING_COMPARE *pfEqual
    );


NTSTATUS
RtlXmlIsExtentWhitespace(
    PXML_TOKENIZATION_STATE pState,
    PCXML_EXTENT            Run,
    PBOOLEAN                pfIsWhitespace
    );

NTXML_RAW_TOKEN FORCEINLINE FASTCALL
_RtlpDecodeCharacter(ULONG ulCharacter);


#define STATUS_NTXML_INVALID_FORMAT         (0xc0100000)


#ifndef NUMBER_OF
#define NUMBER_OF(q) (sizeof(q)/sizeof((q)[0]))
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\signature.h ===
#pragma once
#ifdef __cplusplus
extern "C" {
#endif


typedef enum {
    eXmlSig_DocumentDamaged,            // The document has been damaged - hash mismatch
    eXmlSig_NoSignature,                // No signature in document
    eXmlSig_InvalidSignature,           // Signature present, but not valid
    eXmlSig_UnknownCanonicalization,    // Unknown canonicalization type
    eXmlSig_UnknownSignatureMethod,     // Unknown method of signing document
    eXmlSig_UnknownHashType,            // Unknown hash type
    eXmlSig_OtherUnknown,               // Some other unknown parameter
    eXmlSig_Valid                       // Signature was valid
} XMLSIG_RESULT, *PXMLSIG_RESULT;

NTSTATUS
RtlXmlValidateSignatureEx(
    IN ULONG                ulFlags,
    IN PVOID                pvXmlDocument,
    IN SIZE_T               cbDocument,
    OUT PRTL_GROWING_LIST   SignersInfo,
    OUT PRTL_STRING_POOL    StringPool,
    OUT PULONG              ulSigners
    );

#ifdef __cplusplus
}; // Extern C
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\skiplist.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _RTL_GROWING_LIST_CHUNK {

    //
    // Pointer back to the parent list
    //
    struct _RTL_GROWING_LIST *pGrowingListParent;

    //
    // Pointer to the next chunk in the list
    //
    struct _RTL_GROWING_LIST_CHUNK *pNextChunk;

}
RTL_GROWING_LIST_CHUNK, *PRTL_GROWING_LIST_CHUNK;

#define GROWING_LIST_FLAG_IS_SORTED     (0x00000001)

typedef struct _RTL_GROWING_LIST {

    //
    // Any flags about this list?
    //
    ULONG ulFlags;

    //
    // How many total elments are in this growing list?
    //
    ULONG cTotalElements;

    //
    // How big is each element in this list?
    //
    SIZE_T cbElementSize;

    //
    // How many to allocate per list chunk?  As each piece of the growing list
    // fills up, this is the number of elements to allocate to the new chunk
    // of the list.
    //
    ULONG cElementsPerChunk;

    //
    // How many are in the initial internal list?
    //
    ULONG cInternalElements;

    //
    // Pointer to the intial "internal" list, if specified by the caller
    //
    PVOID pvInternalList;

    //
    // The allocation-freeing context and function pointers
    //
    RTL_ALLOCATOR Allocator;

    //
    // First chunk
    //
    PRTL_GROWING_LIST_CHUNK pFirstChunk;

    //
    // Last chunk (quick access)
    //
    PRTL_GROWING_LIST_CHUNK pLastChunk;

}
RTL_GROWING_LIST, *PRTL_GROWING_LIST;



NTSTATUS
RtlInitializeGrowingList(
    PRTL_GROWING_LIST       pList,
    SIZE_T                  cbElementSize,
    ULONG                   cElementsPerChunk,
    PVOID                   pvInitialListBuffer,
    SIZE_T                  cbInitialListBuffer,
    PRTL_ALLOCATOR          Allocator
    );

NTSTATUS
RtlIndexIntoGrowingList(
    PRTL_GROWING_LIST       pList,
    ULONG                   ulIndex,
    PVOID                  *ppvPointerToSpace,
    BOOLEAN                 fGrowingAllowed
    );

NTSTATUS
RtlDestroyGrowingList(
    PRTL_GROWING_LIST       pList
    );

//
// The growing list control structure can be placed anywhere in the allocation
// that's optimal (on cache boundaries, etc.)
//
#define RTL_INIT_GROWING_LIST_EX_FLAG_LIST_ANYWHERE     (0x00000001)


NTSTATUS
RtlInitializeGrowingListEx(
    ULONG                   ulFlags,
    PVOID                   pvBlob,
    SIZE_T                  cbBlobSpace,
    SIZE_T                  cbElementSize,
    ULONG                   cElementsPerChunk,
    PRTL_ALLOCATOR          Allocator,
    PRTL_GROWING_LIST      *ppBuiltListPointer,
    PVOID                   pvReserved
    );

NTSTATUS
RtlCloneGrowingList(
    ULONG                   ulFlags,
    PRTL_GROWING_LIST       pDestination,
    PRTL_GROWING_LIST       pSource,
    ULONG                   ulCount
    );


NTSTATUS
RtlAllocateGrowingList(
    PRTL_GROWING_LIST          *ppGrowingList,
    SIZE_T                      cbThingSize,
    PRTL_ALLOCATOR              Allocator
    );

typedef NTSTATUS (__cdecl *PFN_LIST_COMPARISON_CALLBACK)(
    PRTL_GROWING_LIST HostList,
    PVOID Left,
    PVOID Right,
    PVOID Context,
    int *Result
    );

NTSTATUS
RtlSortGrowingList(
    PRTL_GROWING_LIST pGrowingList,
    ULONG ItemCount,
    PFN_LIST_COMPARISON_CALLBACK SortCallback,
    PVOID SortContext
    );

NTSTATUS
RtlSearchGrowingList(
    PRTL_GROWING_LIST TheList,
    ULONG ItemCount,
    PFN_LIST_COMPARISON_CALLBACK SearchCallback,
    PVOID SearchTarget,
    PVOID SearchContext,
    PVOID *pvFoundItem
    );
    

#ifdef __cplusplus
}; // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\stringpool.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#define RTL_STRING_POOL_FRAME_FLAG_REGION_INLINE            (0x00000001)

typedef struct _RTL_STRING_POOL_FRAME {
    ULONG ulFlags;
    PVOID pvRegion;
    SIZE_T cbRegionAvailable;
    PVOID pvNextAvailable;
}
RTL_STRING_POOL_FRAME, *PRTL_STRING_POOL_FRAME;


typedef struct _RTL_STRING_POOL {

    ULONG ulFramesCount;

    RTL_GROWING_LIST FrameList;

    RTL_ALLOCATOR Allocator;

    SIZE_T cbBytesInNewRegion;
}
RTL_STRING_POOL, *PRTL_STRING_POOL;


#define RTL_STRING_POOL_CREATE_INITIAL_REGION_SPLIT         (0x00000001)
#define RTL_STRING_POOL_CREATE_INITIAL_REGION_IS_LIST       (0x00000002)
#define RTL_STRING_POOL_CREATE_INITIAL_REGION_IS_STRINGS    (0x00000003)
#define RTL_STRING_POOL_CREATE_INITIAL_REGION_MASK          (0x0000000f)


NTSTATUS
RtlCreateStringPool(
    ULONG ulFlags,
    PRTL_STRING_POOL ppStringPool,
    SIZE_T cbBytesInFrames,
    PRTL_ALLOCATOR Allocation,
    PVOID pvOriginalRegion,
    SIZE_T cbOriginalRegion
    );

NTSTATUS
RtlAllocateStringInPool(
    ULONG ulFlags,
    PRTL_STRING_POOL pStringPool,
    PUNICODE_STRING pusOutbound,
    SIZE_T ulByteCount
    );

NTSTATUS
RtlDestroyStringPool(
    PRTL_STRING_POOL pStringPool
    );

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\sxs-rtl.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#define STATUS_MANIFEST_MISSING_XML_DECL            (0xc0100001)
#define STATUS_MANIFEST_NOT_STANDALONE              (0xc0100002)
#define STATUS_MANIFEST_NOT_VERSION_1_0             (0xc0100003)
#define STATUS_MANIFEST_ASSEMBLY_NOT_AT_ROOT        (0xc0100004)
#define STATUS_MANIFEST_MULTIPLE_ROOT_IDENTITIES    (0xc0100005)
#define STATUS_MANIFEST_MISSING_ROOT_IDENTITY       (0xc0100006)
#define STATUS_MANIFEST_FILE_TAG_MISSING_NAME       (0xc0100007)
#define STATUS_MANIFEST_COMCLASS_MISSING_CLSID      (0xc0100008)
#define STATUS_MANIFEST_PCDATA_NOT_ALLOWED_HERE     (0xc0100009)
#define STATUS_MANIFEST_UNEXPECTED_CHILD_ELEMENT    (0xc010000a)
#define STATUS_MANIFEST_UNKNOWN_ATTRIBUTES          (0xc010000b)
#define STATUS_MANIFEST_WRONG_ROOT_ELEMENT          (0xc010000c)


#define RTL_INSTALL_ASM_FLAT_TYPE_MASK                  (0x0000000F)
#define RTL_INSTALL_ASM_FLAG_TYPE_OS_INSTALLATION       (0x00000001)

#define RTL_INSTALL_ASM_FLAG_ACTION_MASK                (0000000FF0)
#define RTL_INSTALL_ASM_FLAG_ACTION_REPLACE_EXISTING    (0x00000010)
#define RTL_INSTALL_ASM_FLAG_ACTION_MOVE_FROM_SOURCE    (0x00000020)
#define RTL_INSTALL_ASM_FLAG_ACTION_TRANSACTIONAL       (0000000040)

typedef struct _RTL_ALLOCATOR 
{
    NTSTATUS (FASTCALL *pfnAlloc)(SIZE_T, PVOID*, PVOID);
    
    NTSTATUS (FASTCALL *pfnFree)(PVOID, PVOID);
    
    PVOID pvContext;
    
} RTL_ALLOCATOR, *PRTL_ALLOCATOR;

EXTERN_C RTL_ALLOCATOR g_DefaultAllocator;

typedef struct _RTL_INSTALL_ASSEMBLY {

    //
    // Flags indicating the type of installation we're performing
    //


    //
    // Path to the manifest that we're installing
    //
    UNICODE_STRING ucsManifestPath;

    //
    // Path to the codebase that we're installing from, for recovery purposes
    //
    UNICODE_STRING ucsCodebaseName;

} RTL_INSTALL_ASSEMBLY, *PRTL_INSTALL_ASSEMBLY;



NTSTATUS
RtlInstallAssembly(
    ULONG ulFlags,
    PCWSTR pcwszManifestPath
    );

NTSTATUS
RtlOpenAndMapEntireFile(
    PCWSTR pcwszFilePath,
    PVOID      *ppvMappedView,
    PSIZE_T     pcbFileSize
    );

NTSTATUS
RtlUnmapViewOfFile(
    PVOID pvBase
    );


#define RTLIMS_GATHER_FILES                 (0x00000001)
#define RTLIMS_GATHER_COMCLASSES            (0x00000002)
#define RTLIMS_GATHER_WINDOWCLASSES         (0x00000004)
#define RTLIMS_GATHER_TYPELIBRARIES         (0x00000008)
#define RTLIMS_GATHER_INTERFACEPROXIES      (0x00000010)
#define RTLIMS_GATHER_EXTERNALPROXIES       (0x00000020)
#define RTLIMS_GATHER_DEPENDENCIES          (0x00000040)
#define RTLIMS_GATHER_COMCLASS_PROGIDS      (0x00000080)
#define RTLIMS_GATHER_SIGNATURES            (0x00000100)

#define CONTENT_FILTER_MASK                 (RTLIMS_GATHER_SIGNATURES | RTLIMS_GATHER_COMCLASS_PROGIDS | RTLIMS_GATHER_FILES | RTLIMS_GATHER_COMCLASSES | RTLIMS_GATHER_WINDOWCLASSES | RTLIMS_GATHER_TYPELIBRARIES | RTLIMS_GATHER_INTERFACEPROXIES | RTLIMS_GATHER_EXTERNALPROXIES | RTLIMS_GATHER_DEPENDENCIES)


#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif

#ifndef MAX_ULONG
#define MAX_ULONG ((ULONG)-1)
#endif

typedef struct _tagRTL_MINI_HEAP {
    PVOID   pvNextAvailableByte;
    PVOID   pvAllocationBase;
    SIZE_T  cbOriginalSize;
    SIZE_T  cbAvailableBytes;
} RTL_MINI_HEAP, *PRTL_MINI_HEAP;

#define DEFAULT_MINI_HEAP_SIZE        (2048)

NTSTATUS FASTCALL
RtlMiniHeapAlloc(
    SIZE_T  cb,
    PVOID  *ppvAllocated,
    PVOID   pvContext
    );

NTSTATUS FASTCALL
RtlMiniHeapFree(
    PVOID   pvAllocation,
    PVOID   pvContext
    );

NTSTATUS FASTCALL
RtlInitializeMiniHeap(
    PRTL_MINI_HEAP MiniHeap,
    PVOID pvTargetRegion,
    SIZE_T cbRegionSize
    );

NTSTATUS FASTCALL
RtlInitializeMiniHeapInPlace(
    PVOID   pvRegion,
    SIZE_T  cbOriginalSize,
    PRTL_MINI_HEAP *ppMiniHeap
    );

typedef struct _MINI_BUFFER {
    PVOID pvNext;
    SIZE_T cbRemains;
} MINI_BUFFER, *PMINI_BUFFER;

#ifndef ROUND_UP_COUNT
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~(((LONG)(Pow2))-1)) )
#endif

#ifndef POINTER_IS_ALIGNED
#define POINTER_IS_ALIGNED(Ptr,Pow2) \
        ( ( ( ((ULONG_PTR)(Ptr)) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )
#endif

#define RtlMiniBufferInit(mb, pv, cb) do { \
    (mb)->pvNext = (pv); \
    (mb)->cbRemains = (cb); \
} while (0)

#define RtlMiniBufferSpaceLeft(mb) ((mb)->cbRemains)
#define RtlMiniBufferAllocate(mb, type, pvtgt) RtlMiniBufferAllocateBytes((mb), sizeof(type), (PVOID*)(pvtgt))

#define ALIGNMENT_VALUE     (sizeof(PVOID)*2)

NTSTATUS FORCEINLINE
RtlMiniBufferAllocateBytes(PMINI_BUFFER Buffer, SIZE_T Bytes, PVOID* pvTarget)
{
    const SIZE_T AllocatedSize = ROUND_UP_COUNT(Bytes, ALIGNMENT_VALUE);
    ASSERT(POINTER_IS_ALIGNED(Buffer->pvNext, ALIGNMENT_VALUE));
        
    if (Buffer->cbRemains >= AllocatedSize) {
        *pvTarget = Buffer->pvNext;        
        Buffer->pvNext = (PVOID)(((ULONG_PTR)Buffer->pvNext) + AllocatedSize);
        Buffer->cbRemains -= AllocatedSize;
        return STATUS_SUCCESS;
    }
    else {
        *pvTarget = NULL;
        return STATUS_BUFFER_TOO_SMALL;
    }
}

#define RtlMiniBufferAllocateCount(mb, type, count, pvtgt) \
    (RtlMiniBufferAllocateBytes(mb, (sizeof(type) * (count)), (PVOID*)pvtgt))

typedef enum {
    HashType_Sha1,
    HashType_Sha256,
    HashType_Sha384,
    HashType_Sha512,
    HashType_MD5,
    HashType_MD4,
    HashType_MD2,
} HashType;

typedef enum {
    DigestType_Imports          = 0x1,
    DigestType_Resources        = 0x2,
    DigestType_Code             = 0x3,
    DigestType_FullFile         = 0x4,
    DigestType_Default          = (DigestType_Imports | DigestType_Resources | DigestType_Code),
} DigestType;   


NTSTATUS
RtlpConvertHexStringToBytes(
    PUNICODE_STRING pSourceString,
    PUCHAR pbTarget,
    SIZE_T cbTarget
    );

NTSTATUS
RtlBase64Encode(
    PVOID   pvBuffer,
    SIZE_T  cbBuffer,
    PWSTR   pwszEncoded,
    PSIZE_T pcchEncoded
    );

#ifndef offsetof
#define offsetof(s, m) ((SIZE_T)(&((s *)NULL)->m))
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\sxsapi.h ===
#pragma once

#include <sxstypes.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Opaque ASSEMBLY_IDENTITY structure
//

typedef struct _ASSEMBLY_IDENTITY *PASSEMBLY_IDENTITY;
typedef const struct _ASSEMBLY_IDENTITY *PCASSEMBLY_IDENTITY;

//
//  The types of assembly identities.
//
//  Definitions may not include wildcard attributes; definitions
//  match only if they are exactly equal.  A wildcard matches
//  a definition if for all the non-wildcarded attributes,
//  there is an exact match.  References may not contain
//  wildcarded attributes but may contain a different set of
//  attributes than a definition that they match.  (Example:
//  definitions carry the full public key of the publisher, but
//  references usually carry just the "strong name" which is
//  the first 8 bytes of the SHA-1 hash of the public key.)
//

#define ASSEMBLY_IDENTITY_TYPE_DEFINITION (1)
#define ASSEMBLY_IDENTITY_TYPE_REFERENCE (2)
#define ASSEMBLY_IDENTITY_TYPE_WILDCARD (3)

#define SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE L"urn:schemas-microsoft-com:asm.v1"
#define SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE_CCH (32)

#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY                     L"assembly"
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_CCH                 (8)
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_IDENTITY            L"assemblyIdentity"
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_IDENTITY_CCH        (16)

#define SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION L"configuration"
#define SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION_CCH (13)

#define SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION           L"manifestVersion"
#define SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION_CCH       (15)

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME                       L"name"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME_CCH                   (4)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION                    L"version"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION_CCH                (7)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE                   L"language"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE_CCH               (8)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY                 L"publicKey"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_CCH             (9)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN           L"publicKeyToken"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN_CCH       (14)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE     L"processorArchitecture"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE_CCH (21)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE                       L"type"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE_CCH                   (4)

// Pseudo-value used in some places when the language= attribute is missing from the identity.
// An identity that does not have language is implicitly "worldwide".

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE          L"x-ww"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE_CCH      (4)

//
//  All win32 assemblies must have "win32" as their type.
//

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_TYPE_VALUE_WIN32                L"win32"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_TYPE_VALUE_WIN32_CCH            (5)

#define SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING      (0x00000001)

//
//  SXS_ASSEMBLY_IDENTITY_FLAG_FROZEN means that the assembly
//  identity's contents are frozen and are not subject to additional
//  change.
//

#define ASSEMBLY_IDENTITY_FLAG_FROZEN           (0x80000000)

//
//  ASSEMBLY_IDENTITY_ATTRIBUTE structure
//

typedef struct _ASSEMBLY_IDENTITY_ATTRIBUTE {
    ULONG   Flags;
    SIZE_T  NamespaceCch;
    SIZE_T  NameCch;
    SIZE_T  ValueCch;
    const WCHAR *Namespace;
    const WCHAR *Name;
    const WCHAR *Value;
} ASSEMBLY_IDENTITY_ATTRIBUTE, *PASSEMBLY_IDENTITY_ATTRIBUTE;

typedef const struct _ASSEMBLY_IDENTITY_ATTRIBUTE *PCASSEMBLY_IDENTITY_ATTRIBUTE;

typedef enum _ASSEMBLY_IDENTITY_INFORMATION_CLASS {
    AssemblyIdentityBasicInformation = 1,
} ASSEMBLY_IDENTITY_INFORMATION_CLASS;

typedef struct _ASSEMBLY_IDENTITY_BASIC_INFORMATION {
    ULONG Flags;
    ULONG Type;
    ULONG Hash;
    ULONG AttributeCount;
} ASSEMBLY_IDENTITY_BASIC_INFORMATION, *PASSEMBLY_IDENTITY_BASIC_INFORMATION;

#define SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE    (0x00000001)

#define SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF (0x00000001)

#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE    (0x00000001)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME         (0x00000002)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE        (0x00000004)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED   (0x00000008)

#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE    (0x00000001)
#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME         (0x00000002)
#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE        (0x00000004)

#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_INVALID          (0)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN        (1)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL            (2)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN     (3)

#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE     (0x00000001)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME          (0x00000002)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE         (0x00000004)

#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE       (0x00000001)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME            (0x00000002)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE           (0x00000004)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS    (0x00000008)


//
//  Rather than making "n" heap allocations, the pattern for SxsGetAssemblyIdentityAttributeByOrdinal()
//  is to call once with BufferSize = 0 or some reasonable fixed number to get the size of the
//  buffer required, allocate the buffer if the buffer passed in was too small and call again.
//
//  The strings returned in the ASSEMBLY_IDENTITY_ATTRIBUTE are *not*
//  dynamically allocated, but are instead expected to fit in the buffer passed in.
//

#define SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE         (0x00000001)
#define SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL     (0x00000002)

#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE (0x00000001)
#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME      (0x00000002)
#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE     (0x00000004)

//
//  Assembly Identity encoding:
//
//  Assembly identities may be encoded in various forms.  The two usual ones
//  are either a binary stream, suitable for embedding in other data structures
//  or for persisting or a textual format that looks like:
//
//      name;[ns1,]n1="v1";[ns2,]n2="v2"[;...]
//

#define SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY (1)
#define SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL (2)

#define SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE        (0x00000001)

typedef VOID (* PRTLSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE)(
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN PVOID Context
    );


#define STATUS_SXS_UNKNOWN_ENCODING_GROUP                   (0xc0100010)
#define STATUS_SXS_UNKNOWN_ENCODING                         (0xc0100011)
#define STATUS_SXS_INVALID_XML_NAMESPACE_URI                (0xc0100012)
#define STATUS_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME (0xc0100013)
#define STATUS_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE      (0xc0100014)

#ifdef __cplusplus
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\sxsid.h ===
#if !defined(_FUSION_INC_SXSID_H_INCLUDED_)
#define _FUSION_INC_SXSID_H_INCLUDED_

#pragma once

#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>

typedef struct _SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE
{
    const WCHAR *Namespace;
    SIZE_T NamespaceCch;
    const WCHAR *Name;
    SIZE_T NameCch;
} SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE, *PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE;

typedef const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE *PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE;

#define SXS_DEFINE_ATTRIBUTE_REFERENCE_EX(_id, _ns, _n) EXTERN_C __declspec(selectany) const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE _id = { _ns, (sizeof(_ns) / sizeof(_ns[0])) - 1, _n, (sizeof(_n) / sizeof(_n[0])) - 1 };
#define SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(_id, _n) EXTERN_C __declspec(selectany) const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE _id = { NULL, 0, _n, (sizeof(_n) / sizeof(_n[0])) - 1 };

SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_name, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_type, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_version, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_processorArchitecture, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_publicKey, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_publicKeyToken, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_language, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE)


//
//  This header defines the "semi-public" assembly identity functions.
//
//  The public ones are in sxsapi.h; these are not private to the identity
//  implementation directly but are private to sxs.dll.
//

NTSTATUS
RtlSxsIsAssemblyIdentityAttributePresent(
    ULONG Flags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    BOOLEAN *pfFound
    );

#define SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING (0x00000001)

NTSTATUS
RtlSxspSetAssemblyIdentityAttributeValue(
    ULONG Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    PCWSTR pszValue,
    SIZE_T cchValue
    );

#define SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS (0x00000001)

NTSTATUS
RtlSxspRemoveAssemblyIdentityAttribute(
    ULONG Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference
    );

#define SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL (0x00000001)

NTSTATUS
RtlSxspGetAssemblyIdentityAttributeValue(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT PCWSTR *ValuePointer,
    OUT SIZE_T *ValueCch
    );

NTSTATUS
RtlSxspDbgPrintAssemblyIdentity(
    ULONG dwflags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity
    );

#define SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION (0x00000001)

NTSTATUS
RtlSxspMapAssemblyIdentityToPolicyIdentity(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT PASSEMBLY_IDENTITY *PolicyIdentity
    );

#define SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION (0x00000001)

NTSTATUS
RtlSxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
    ULONG Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    UNICODE_STRING rbuffEncodedIdentity,
    PASSEMBLY_IDENTITY *PolicyIdentity OPTIONAL
    );

NTSTATUS
RtlSxspHashAssemblyIdentityForPolicy(
    IN ULONG dwFlags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT ULONG *IdentityHash);


NTSTATUS
RtlSxsDuplicateAssemblyIdentity(
    ULONG Flags,
    PCASSEMBLY_IDENTITY Source,
    PASSEMBLY_IDENTITY *Destination
    );

NTSTATUS
RtlSxsDestroyAssemblyIdentity(
    PASSEMBLY_IDENTITY pIdentity
    );

NTSTATUS
RtlSxsHashAssemblyIdentity(
    ULONG dwFlags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    ULONG * pulPseudoKey
    );

NTSTATUS
RtlSxsInsertAssemblyIdentityAttribute(
    ULONG Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttribute
    );

NTSTATUS
RtlSxsRemoveAssemblyIdentityAttributesByOrdinal(
    ULONG Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG Ordinal,
    ULONG Count
    );

NTSTATUS
RtlSxsFindAssemblyIdentityAttribute(
    ULONG Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    ULONG *OrdinalOut,
    ULONG *CountOut OPTIONAL
    );

#endif // !defined(_FUSION_INC_SXSID_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\xmlassert.h ===
#pragma once


#ifdef ASSERT
#undef ASSERT
#endif

#ifdef DBG
#define ASSERT(q) ( (q) ? TRUE : (DbgBreakPoint(), FALSE) )
#else
#define ASSERT(q) (TRUE)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inc\xmlstructure.h ===
#ifdef __cplusplus
extern "C" {
#endif


enum XMLDOC_THING_TYPE {
    XMLDOC_THING_ERROR,
    XMLDOC_THING_END_OF_STREAM,
    XMLDOC_THING_XMLDECL,
    XMLDOC_THING_ELEMENT,
    XMLDOC_THING_END_ELEMENT,
    XMLDOC_THING_PROCESSINGINSTRUCTION,
    XMLDOC_THING_ATTRIBUTE,
    XMLDOC_THING_HYPERSPACE,
    XMLDOC_THING_CDATA,
};

typedef enum {
    XMLERROR_XMLDECL_NOT_FIRST_THING,
    XMLERROR_PI_TARGET_NOT_FOUND,
    XMLERROR_PI_EOF_BEFORE_CLOSE,
    XMLERROR_PI_CONTENT_ERROR,                      // There was a problem with the content of the processing instruction
    XMLERROR_ELEMENT_NS_PREFIX_MISSING_COLON,
    XMLERROR_ELEMENT_NAME_NOT_FOUND,                // < binky="bleep"> or <foo: /> - element name not found
    XMLERROR_ATTRIBUTE_NAME_NOT_FOUND,              // <binky foo:=""> or <binky =""/> - Attribute name part not found
    XMLERROR_ATTRIBUTE_NS_PREFIX_MISSING_COLON,     // <bingy foo="ham"> - Somehow we got into a state where we thought we had a namespace prefix, but it wasn't followed by a colon
    XMLERROR_XMLDECL_INVALID_FORMAT,                // Something rotten in the <?xml?>
    XMLERROR_ENDELEMENT_NAME_NOT_FOUND,             // Missing the name part of a </> tag.
    XMLERROR_ENDELEMENT_MALFORMED_NAME,             // The name was malformed .. ns missing or something like that
    XMLERROR_ENDELEMENT_MALFORMED,                  // EOF before end of element found, or other problem
    XMLERROR_CDATA_MALFORMED,                       // CDATA not properly formed?
} LOGICAL_XML_ERROR;

typedef struct _XMLDOC_ELEMENT {
    //
    // Name of this element tag
    //
    XML_EXTENT Name;
    
    //
    // Namespace prefix
    //
    XML_EXTENT NsPrefix;
    
    //
    // How many attributes are there?
    //
    ULONG ulAttributeCount;
    
    //
    // Is this element empty?
    //
    BOOLEAN fElementEmpty;
    
}
XMLDOC_ELEMENT, *PXMLDOC_ELEMENT;

typedef struct _XMLDOC_ERROR {
    //
    // The erroneous extent
    //
    XML_EXTENT  BadExtent;
    
    //
    // What was the error?
    //
    LOGICAL_XML_ERROR   Code;
}
XMLDOC_ERROR, *PXMLDOC_ERROR;

typedef struct _XMLDOC_ATTRIBUTE {
    //
    // Name of this attribute
    //
    XML_EXTENT Name;
    
    //
    // Namespace prefix thereof
    //
    XML_EXTENT NsPrefix;
    
    //
    // The value of this attribute
    //
    XML_EXTENT Value;
}
XMLDOC_ATTRIBUTE, *PXMLDOC_ATTRIBUTE;

typedef struct _XMLDOC_ENDELEMENT {
    //
    // End-element namespace prefix
    //
    XML_EXTENT NsPrefix;
    
    //
    // End-element tag name
    //
    XML_EXTENT Name;

    //
    // Original element pointer
    //
    XMLDOC_ELEMENT OpeningElement;
    
}
XMLDOC_ENDELEMENT, *PXMLDOC_ENDELEMENT;

typedef struct _XMLDOC_XMLDECL {
    XML_EXTENT  Encoding;
    XML_EXTENT  Version;
    XML_EXTENT  Standalone;
}
XMLDOC_XMLDECL, *PXMLDOC_XMLDECL;

typedef struct _XMLDOC_PROCESSING {
    XML_EXTENT Target;
    XML_EXTENT Instruction;
}
XMLDOC_PROCESSING, *PXMLDOC_PROCESSING;

typedef struct _XMLDOC_THING {

    //
    // What kind of thing is this?
    //
    enum XMLDOC_THING_TYPE ulThingType;

    //
    // How deep down the document is it?
    //
    ULONG ulDocumentDepth;


    //
    // Have the namespaces been fixed up yet?
    //
    BOOLEAN fNamespacesExpanded;

    //
    // The caller should be passing in a pointer to an attribute
    // list that they have initialized to contain XMLDOC_ATTRIBUTE
    // objects.
    //
    PRTL_GROWING_LIST AttributeList;

    //
    // The total extent of this thing in the document
    //
    XML_EXTENT TotalExtent;

    union {

        XMLDOC_ERROR Error;

        XMLDOC_ELEMENT Element;

        //
        // The </close> tag
        //
        XMLDOC_ENDELEMENT EndElement;

        //
        // The pcdata that was found in this segment of the document
        //
        XML_EXTENT CDATA;

        //
        // The hyperspace found in this section of the document
        //
        XML_EXTENT Hyperspace;

        //
        // Information about the <?xml?> section of the document
        //
        XMLDOC_XMLDECL XmlDecl;

        //
        // A processing instruction has a target and an actual instruction
        //
        XMLDOC_PROCESSING ProcessingInstruction;
    };

}
XMLDOC_THING, *PXMLDOC_THING;


typedef NTSTATUS (*PFN_CALLBACK_PER_LOGICAL_XML)(
    struct _tagXML_LOGICAL_STATE*       pLogicalState,
    PXMLDOC_THING                       pLogicalThing,
    PRTL_GROWING_LIST                   pAttributes,    
    PVOID                               pvCallbackContext
    );



typedef struct _tagXML_LOGICAL_STATE{

    //
    // The overall state of parsing
    //
    XML_TOKENIZATION_STATE ParseState;

    //
    // Have we found the first element yet?
    //
    BOOLEAN fFirstElementFound;

    //
    // When sifting through the document, this is the thing that we found
    // indicating the encoding.  We should process and set the values in
    // ParseState before going too far, but for the moment we just hold
    // onto it.
    //
    XML_EXTENT EncodingMarker;

    //
    // Depth of the 'element stack' that we're building up.
    //
    ULONG ulElementStackDepth;

    //
    // Growing list that backs up the stack of elements. 
    //
    RTL_GROWING_LIST ElementStack;

    //
    // Inline stuff to save some heap allocations.
    //
    XMLDOC_THING InlineElements[20];


}
XML_LOGICAL_STATE, *PXML_LOGICAL_STATE;


typedef struct _XML_ATTRIBUTE_DEFINITION {
    PCXML_SPECIAL_STRING Namespace;
    XML_SPECIAL_STRING Name;
} XML_ATTRIBUTE_DEFINITION, *PXML_ATTRIBUTE_DEFINITION;

typedef const XML_ATTRIBUTE_DEFINITION *PCXML_ATTRIBUTE_DEFINITION;



NTSTATUS
RtlXmlInitializeNextLogicalThing(
    PXML_LOGICAL_STATE pParseState,
    PVOID pvDataPointer,
    SIZE_T cbData,
    PRTL_ALLOCATOR Allocator
    );

//
// This mini-tokenizer allows you to pick up the logical analysis
// from any arbitrary point in another document (handy for when you
// want to go back and re-read something, like in xmldsig...).  If you
// are cloning an active logical parse, then it's imperative that
// you pass along the same namespace management object.
// 
NTSTATUS
RtlXmlInitializeNextLogicalThingEx(
    OUT PXML_LOGICAL_STATE pParseState,
    IN PXML_TOKENIZATION_STATE pBaseTokenizationState,
    IN PVOID pvDataPointer,
    IN SIZE_T cbData,
    PRTL_ALLOCATOR Allocator
    );

NTSTATUS
RtlXmlNextLogicalThing(
    PXML_LOGICAL_STATE pParseState,
    PNS_MANAGER pNamespaceManager,
    PXMLDOC_THING pDocumentPiece,
    PRTL_GROWING_LIST pAttributeList
    );

NTSTATUS
RtlXmlDestroyNextLogicalThing(
    PXML_LOGICAL_STATE pState
    );

NTSTATUS
RtlXmlExtentToString(
    PXML_RAWTOKENIZATION_STATE pParseState,
    PXML_EXTENT             pExtent,
    PUNICODE_STRING         pString,
    PSIZE_T                 pchString
    );

NTSTATUS
RtlXmlMatchLogicalElement(
    IN  PXML_TOKENIZATION_STATE     pState,
    IN  PXMLDOC_ELEMENT             pElement,
    IN  PCXML_SPECIAL_STRING        pNamespace,
    IN  PCXML_SPECIAL_STRING        pElementName,
    OUT PBOOLEAN                    pfMatches
    );

NTSTATUS
RtlXmlFindAttributesInElement(
    IN  PXML_TOKENIZATION_STATE     pState,
    IN  PRTL_GROWING_LIST           pAttributeList,
    IN  ULONG                       ulAttributeCountInElement,
    IN  ULONG                       ulFindCount,
    IN  PCXML_ATTRIBUTE_DEFINITION  pAttributeNames,
    OUT PXMLDOC_ATTRIBUTE          *ppAttributes,
    OUT PULONG                      pulUnmatchedAttributes
    );

NTSTATUS
RtlXmlSkipElement(
    PXML_LOGICAL_STATE pState,
    PXMLDOC_ELEMENT TheElement
    );

NTSTATUS
RtlXmlMatchAttribute(
    IN PXML_TOKENIZATION_STATE      State,
    IN PXMLDOC_ATTRIBUTE            Attribute,
    IN PCXML_SPECIAL_STRING         Namespace,
    IN PCXML_SPECIAL_STRING         AttributeName,
    OUT XML_STRING_COMPARE         *CompareResult
    );

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inspection\analyzerxmldsig.h ===
#pragma once

EXTERN_C const XML_SPECIAL_STRING sc_ss_xmldsignamespace;

NTSTATUS
Rtl_InspectManifest_Signature(
    PXML_LOGICAL_STATE          pLogicalState,
    PRTL_MANIFEST_CONTENT_RAW   pManifestContent,
    PXMLDOC_THING               pDocThing,
    PRTL_GROWING_LIST           pAttributes,
    MANIFEST_ELEMENT_CALLBACK_REASON Reason,
    const struct _XML_ELEMENT_DEFINITION *pElementDefinition
    );

DECLARE_ELEMENT(Signature);


typedef enum {
    DsigKey_DSA,
    DsigKey_RSA
} XmlDsigKeyType;

#define XMLDSIG_FLAG_SIGNATURE_DATA_PRESENT     (0x00000001)
#define XMLDSIG_FLAG_SIGNATURE_METHOD_PRESENT   (0x00000002)
#define XMLDSIG_FLAG_DIGEST_METHOD_PRESENT      (0x00000004)
#define XMLDSIG_FLAG_DIGEST_VALUE_PRESENT       (0x00000008)
#define XMLDSIG_FLAG_KEY_NAME_PRESENT           (0x00000010)

#define XMLDSIG_FLAG_DSAKEY_P_PRESENT           (0x00010000)
#define XMLDSIG_FLAG_DSAKEY_Q_PRESENT           (0x00020000)
#define XMLDSIG_FLAG_DSAKEY_G_PRESENT           (0x00040000)
#define XMLDSIG_FLAG_DSAKEY_Y_PRESENT           (0x00080000)
#define XMLDSIG_FLAG_DSAKEY_J_PRESENT           (0x00100000)
#define XMLDSIG_FLAG_DSAKEY_SEED_PRESENT        (0x00200000)
#define XMLDSIG_FLAG_DSAKEY_PGENCOUNTER_PRESENT (0x00400000)

#define XMLDSIG_FLAG_RSAKEY_MODULUS_PRESENT     (0x00010000)
#define XMLDSIG_FLAG_RSAKEY_EXPONENT_PRESENT    (0x00020000)

typedef struct _XML_DSIG_BLOCK
{
    ULONG ulFlags;
    
    XML_EXTENT DsigDocumentExtent;
    XML_EXTENT ParentElement;

    //
    // Everything to know about the signature itself.
    //
    struct {
        XML_EXTENT SignedInfoBlock;
        XML_EXTENT CanonicalizationMethod;
        XML_EXTENT SignatureMethod;
        XML_EXTENT DigestMethod;
        XML_EXTENT DigestValueData;
    } SignedInfoData;

    //
    // The base-64 encoded value of the signature of the SignedInfo block
    //
    XML_EXTENT SignatureData;

    //
    // Key data right now is just the name of the key and the
    // actual key bits.  At some point in the future we'll
    // consider using X509 as well, but for now since it's not
    // available in-kernel, we're out of luck.
    //
    struct 
    {
        XML_EXTENT KeyName;
        XmlDsigKeyType Type;

        //
        // As more key types become available, they should be
        // added here.
        //
        union 
        {            
            struct 
            {
                ULONG Flags;
                XML_EXTENT P, Q, G, Y, J, Seed, PgenCounter;
            } DSAValue;

            struct 
            {
                ULONG Flags;
                XML_EXTENT Modulus, Exponent;
            } RSAValue;            
        } KeyData;
        
    } KeyInfo;
}
XML_DSIG_BLOCK, *PXML_DSIG_BLOCK;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inspection\signature.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "fasterxml.h"
#include "xmlassert.h"
#include "sxs-rtl.h"
#include "skiplist.h"
#include "namespacemanager.h"
#include "xmlstructure.h"
#include "stringpool.h"
#include "signature.h"

const XML_SPECIAL_STRING c_ss_Signature         = MAKE_SPECIAL_STRING("Signature");
const XML_SPECIAL_STRING c_ss_SignedInfo        = MAKE_SPECIAL_STRING("SignedInfo");
const XML_SPECIAL_STRING c_ss_SignatureValue    = MAKE_SPECIAL_STRING("SignatureValue");
const XML_SPECIAL_STRING c_ss_KeyInfo           = MAKE_SPECIAL_STRING("KeyInfo");
const XML_SPECIAL_STRING c_ss_Object            = MAKE_SPECIAL_STRING("Object");
const XML_SPECIAL_STRING c_ss_XmlNsSignature    = MAKE_SPECIAL_STRING("http://www.w3.org/2000/09/xmldsig#");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inspection\manifestinspection.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "sxs-rtl.h"
#include "fasterxml.h"
#include "skiplist.h"
#include "namespacemanager.h"
#include "xmlstructure.h"
#include "xmlassert.h"
#include "manifestinspection.h"
#include "analyzerxmldsig.h"
#include "manifestcooked.h"
#include "ntrtlstringandbuffer.h"
#include "stdlib.h"
#include "limits.h"

NTSTATUS
RtlpValidateXmlDeclaration(
    PXML_TOKENIZATION_STATE pState,
    PXMLDOC_THING pDocThing
    );

//
// Some strings that we'll need later
//
const XML_SPECIAL_STRING sc_ss_xmldecl_version_10   = MAKE_SPECIAL_STRING("1.0");
const XML_SPECIAL_STRING sc_ss_xmldecl_yes          = MAKE_SPECIAL_STRING("yes");
const XML_SPECIAL_STRING sc_ss_xmlnamespace_default = MAKE_SPECIAL_STRING("urn:schemas-microsoft-com:asm.v1");


NTSTATUS
Rtl_InspectManifest_AssemblyIdentity(
    PXML_LOGICAL_STATE          pLogicalState,
    PRTL_MANIFEST_CONTENT_RAW   pManifestContent,
    PXMLDOC_THING               pDocumentThing,
    PRTL_GROWING_LIST           pAttributes,
    MANIFEST_ELEMENT_CALLBACK_REASON Reason,
    const struct _XML_ELEMENT_DEFINITION *pElementDefinition
    );


NTSTATUS
Rtl_InspectManifest_Assembly(
    PXML_LOGICAL_STATE          pLogicalState,
    PRTL_MANIFEST_CONTENT_RAW   pManifestContent,
    PXMLDOC_THING               pDocumentThing,
    PRTL_GROWING_LIST           pAttributes,
    MANIFEST_ELEMENT_CALLBACK_REASON Reason,
    const struct _XML_ELEMENT_DEFINITION *pElementDefinition
    );

NTSTATUS
Rtl_InspectManifest_File(
    PXML_LOGICAL_STATE          pLogicalState,
    PRTL_MANIFEST_CONTENT_RAW   pManifestContent,
    PXMLDOC_THING               pDocumentThing,
    PRTL_GROWING_LIST           pAttributes,
    MANIFEST_ELEMENT_CALLBACK_REASON Reason,
    const struct _XML_ELEMENT_DEFINITION *pElementDefinition
    );


DECLARE_ELEMENT(assembly);
DECLARE_ELEMENT(assembly_file);
DECLARE_ELEMENT(assembly_assemblyIdentity);
DECLARE_ELEMENT(assembly_description);


//
// The "assembly" root document element
//
enum {
    eAttribs_assembly_manifestVersion = 0,
    eAttribs_assembly_Count
};


XML_ELEMENT_DEFINITION rgs_Element_assembly =
{
    XML_ELEMENT_FLAG_ALLOW_ANY_CHILDREN,
    eManifestState_assembly,
    NULL,
    &sc_ss_xmlnamespace_default,
    MAKE_SPECIAL_STRING("assembly"),
    &Rtl_InspectManifest_Assembly,
    rgs_Element_assembly_Children,
    eAttribs_assembly_Count,
    {
        { XML_ATTRIBUTE_FLAG_REQUIRED, NULL, MAKE_SPECIAL_STRING("manifestVersion") },
    }
};

PCXML_ELEMENT_DEFINITION rgs_Element_assembly_Children[] = {
    ELEMENT_NAMED(assembly_file),
    ELEMENT_NAMED(assembly_assemblyIdentity),
    NULL
};

//
// The "file" element
//
enum {
    eAttribs_assembly_file_digestMethod,
    eAttribs_assembly_file_hash,
    eAttribs_assembly_file_hashalg,
    eAttribs_assembly_file_loadFrom,
    eAttribs_assembly_file_name,
    eAttribs_assembly_file_size,
    eAttribs_assembly_file_Count
};

ELEMENT_DEFINITION_DEFNS(assembly, file, Rtl_InspectManifest_File, XML_ELEMENT_FLAG_ALLOW_ANY_CHILDREN)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(digestMethod),
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(hash),
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(hashalg),
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(loadFrom),
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(name),
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(size),
ELEMENT_DEFINITION_DEFNS_END();

ELEMENT_DEFINITION_CHILD_ELEMENTS(assembly, file)
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();

int unscrew_si[] = {3};

//
// Assembly identities
//
enum {
    eAttribs_assembly_assemblyIdentity_language = 0,
    eAttribs_assembly_assemblyIdentity_name,
    eAttribs_assembly_assemblyIdentity_processorArchitecture,
    eAttribs_assembly_assemblyIdentity_publicKeyToken,
    eAttribs_assembly_assemblyIdentity_type,
    eAttribs_assembly_assemblyIdentity_version,
    eAttribs_assembly_assemblyIdentity_Count
};

ELEMENT_DEFINITION_DEFNS(assembly, assemblyIdentity, Rtl_InspectManifest_AssemblyIdentity, XML_ELEMENT_FLAG_NO_ELEMENTS | XML_ELEMENT_FLAG_ALLOW_ANY_ATTRIBUTES)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(empty),
ELEMENT_DEFINITION_DEFNS_END();

// This is an "extendo-element" - all attributes here are legal, some are just more legal than others.
ELEMENT_DEFINITION_CHILD_ELEMENTS(assembly, assemblyIdentity)
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();


// Please leave this in ... my poor editor has issues with the above for some reason
int unconfuse_sourceinsight[] = {4};

PCXML_ELEMENT_DEFINITION
RtlpFindElementInDefinition(
    PCXML_ELEMENT_DEFINITION CurrentNode,
    PXML_TOKENIZATION_STATE TokenizerState,
    PXMLDOC_ELEMENT FoundElement
    )
{
    ULONG i = 0;
    PCXML_ELEMENT_DEFINITION ThisChild;
    BOOLEAN fMatches;
    NTSTATUS status;

    //
    // Technically this isn't an error, but let's not give them any ideas
    //
    if (CurrentNode->ChildElements == NULL)
        return NULL;

    while (TRUE) {
        ThisChild = CurrentNode->ChildElements[i];

        if (ThisChild == NULL)
            break;

        status = RtlXmlMatchLogicalElement(
            TokenizerState, 
            FoundElement, 
            ThisChild->Namespace, 
            &ThisChild->Name,
            &fMatches);

        if (!NT_SUCCESS(status)) {
            return NULL;
        }
        else if (fMatches) {
            break;
        }

        i++;
    }

    return (fMatches ? CurrentNode->ChildElements[i] : NULL);
}




//
// The meat of the matter
//
NTSTATUS
RtlInspectManifestStream(
    ULONG                           ulFlags,
    PVOID                           pvManifest,
    SIZE_T                          cbManifest,
    PRTL_MANIFEST_CONTENT_RAW       pContent,
    PXML_TOKENIZATION_STATE         pTargetTokenState
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    XML_LOGICAL_STATE       ParseState;
    BOOLEAN                 fFoundAssemblyTag = FALSE;
    NS_MANAGER              Namespaces;
    RTL_GROWING_LIST        Attributes;
    ULONG                   ulHitElement;
    XMLDOC_THING            LogicalPiece;
    PCXML_ELEMENT_DEFINITION CurrentElement = NULL;
    PCXML_ELEMENT_DEFINITION DocumentRoot = ELEMENT_NAMED(assembly);
    PCXML_ELEMENT_DEFINITION FloatingElementParent = NULL;
    PCXML_ELEMENT_DEFINITION FloatingElement = NULL;

    //
    // Must give us a pointer to the manifest, a content structure to fill out, and a
    // hashing context w/callback.
    //
    if ((pvManifest == NULL) || (pContent == NULL))
        return STATUS_INVALID_PARAMETER;

    //
    // Do normal startup-type stuff
    //
    status = RtlXmlInitializeNextLogicalThing(&ParseState, pvManifest, cbManifest, &g_DefaultAllocator);
    if (!NT_SUCCESS(status))
        goto Exit;

    status = RtlInitializeGrowingList(&Attributes, sizeof(XMLDOC_ATTRIBUTE), 20, NULL, 0, &g_DefaultAllocator);
    if (!NT_SUCCESS(status))
        goto Exit;

    status = RtlNsInitialize(&Namespaces, RtlXmlDefaultCompareStrings, &ParseState.ParseState, &g_DefaultAllocator);
    if (!NT_SUCCESS(status))
        goto Exit;

    //
    // See if we've got an xmldecl
    //
    status = RtlXmlNextLogicalThing(&ParseState, &Namespaces, &LogicalPiece, &Attributes);
    if (!NT_SUCCESS(status))
        goto Exit;

    //
    // Validate the first thing in the document.  It's either an xmldecl or the <assembly> element,
    // both of which are validatable.
    //
    if (LogicalPiece.ulThingType == XMLDOC_THING_XMLDECL) {
        status = RtlpValidateXmlDeclaration(&ParseState.ParseState, &LogicalPiece);
        if (!NT_SUCCESS(status))
            goto Exit;
    }
    //
    // If it's an element, then it must be the <assembly> element.
    //
    else if (LogicalPiece.ulThingType == XMLDOC_THING_ELEMENT) {
        fFoundAssemblyTag = TRUE;
    }

    //
    // If we've found the assembly tag, then we should set our original document state to
    // being the Assembly state, rather than the DocumentRoot state.
    //
    if (fFoundAssemblyTag) {
        CurrentElement = DocumentRoot;
    }

    //
    // Now let's zip through all the elements we find, using the filter along the way.
    //
    while (TRUE) {

        status = RtlXmlNextLogicalThing(&ParseState, &Namespaces, &LogicalPiece, &Attributes);
        if (!NT_SUCCESS(status))
            goto Exit;

        if (LogicalPiece.ulThingType == XMLDOC_THING_ELEMENT) {

            // Special case - this is the first element we've found, so we have to make sure
            // it matches the supposed document root
            if (CurrentElement == NULL) {
                
                CurrentElement = DocumentRoot;
                
                if (CurrentElement->pfnWorkerCallback) {
                    
                    status = (*CurrentElement->pfnWorkerCallback)(
                        &ParseState,
                        pContent,
                        &LogicalPiece,
                        &Attributes,
                        eElementNotify_Open,
                        CurrentElement);

                    if (!NT_SUCCESS(status))
                        goto Exit;
                }
            }
            else {
                PCXML_ELEMENT_DEFINITION NextElement;

                NextElement = RtlpFindElementInDefinition(
                    CurrentElement,
                    &ParseState.ParseState,
                    &LogicalPiece.Element);

                //
                // Look in the small list of valid "floating" fragments
                //                    
                if ((NextElement == NULL) && (FloatingElementParent == NULL)) {
                    PCXML_ELEMENT_DEFINITION SignatureElement = ELEMENT_NAMED(Signature);
                    BOOLEAN fMatches = FALSE;
                    
                    status = RtlXmlMatchLogicalElement(
                        &ParseState.ParseState, 
                        &LogicalPiece.Element, 
                        SignatureElement->Namespace, 
                        &SignatureElement->Name,
                        &fMatches);

                    if (!NT_SUCCESS(status))
                        goto Exit;

                    if (fMatches) {
                        FloatingElementParent = CurrentElement;
                        FloatingElement = SignatureElement;
                        NextElement = SignatureElement;
                    }
                }

                //
                // If we didn't find an element, this might be the 'signature' element.  
                // See if we're looking for signatures, and if so, set the "next element" to be
                // the Signature element and continue looping.
                //
                if (NextElement == NULL) {

                    if (CurrentElement->ulFlags & XML_ELEMENT_FLAG_ALLOW_ANY_CHILDREN) {
                        // TODO: There ought to be some default callback, but for now, skip ahead
                        // in the document until we find the close of this new child, then continue
                        // in the current context as if nothing happened.
                        status = RtlXmlSkipElement(&ParseState, &LogicalPiece.Element);
                        if (!NT_SUCCESS(status))
                            goto Exit;
                    }
                    else {
                        // TODO: Report an error here
                        status = STATUS_UNSUCCESSFUL;
                        goto Exit;
                    }
                }
                //
                // Otherwise, this is a valid child element, so call its worker
                //
                else {

                    if (NextElement->pfnWorkerCallback) {
                        
                        status = (*NextElement->pfnWorkerCallback)(
                            &ParseState,
                            pContent,
                            &LogicalPiece,
                            &Attributes,
                            eElementNotify_Open,
                            NextElement);
                        
                        if (!NT_SUCCESS(status)) {
                            // TODO: Report an error here
                            goto Exit;
                        }
                    }

                    //
                    // Spiffy, let's go move into this new state, if that's
                    // what we're supposed to do.  Empty elements don't affect
                    // the state of the world at all.
                    //
                    if (!LogicalPiece.Element.fElementEmpty)
                        CurrentElement = NextElement;
                    else
                    {
                        //
                        // Notify this element that we're closing it.
                        //
                        if (NextElement->pfnWorkerCallback) {
                            
                            status = (*NextElement->pfnWorkerCallback)(
                                &ParseState,
                                pContent,
                                &LogicalPiece,
                                &Attributes,
                                eElementNotify_Close,
                                NextElement);
                            
                            if (!NT_SUCCESS(status)) {
                                // TODO: Log an error here saying the callback failed
                                goto Exit;
                            }
                        }
                    }
                }
            }
        }
        // Found the end of the current element.  "Pop" it by walking up one on
        // the stack
        else if (LogicalPiece.ulThingType == XMLDOC_THING_END_ELEMENT) {

            if ((CurrentElement->ParentElement == NULL) && (FloatingElementParent == NULL)) {
                // TODO: We found the end of this document structure, stop
                // looking for more elements.
                break;
            }
            else {
                
                if (CurrentElement->pfnWorkerCallback) {
                    
                    status = (*CurrentElement->pfnWorkerCallback)(
                        &ParseState,
                        pContent,
                        &LogicalPiece,
                        &Attributes,
                        eElementNotify_Close,
                        CurrentElement);
                    
                    if (!NT_SUCCESS(status)) {
                        // TODO: Log an error here saying the callback failed
                        goto Exit;
                    }
                }

                if (FloatingElementParent && (CurrentElement == FloatingElement)) {
                    CurrentElement = FloatingElementParent;
                    FloatingElementParent = NULL;
                    FloatingElement = NULL;
                }
                else {
                    CurrentElement = CurrentElement->ParentElement;
                }
            }
            
        }
        // PCData in the input?  Ok, if the element allows it
        else if (LogicalPiece.ulThingType == XMLDOC_THING_HYPERSPACE) {
            
            if (CurrentElement && CurrentElement->ulFlags & XML_ELEMENT_FLAG_NO_PCDATA) {
                
                // TODO: Issue an error here
                status = STATUS_UNSUCCESSFUL;
                goto Exit;
            }
            else {
                if (CurrentElement && (CurrentElement->pfnWorkerCallback)) {
                    status = (*CurrentElement->pfnWorkerCallback)(
                        &ParseState,
                        pContent,
                        &LogicalPiece,
                        &Attributes,
                        eElementNotify_Hyperspace,
                        CurrentElement);

                    if (!NT_SUCCESS(status)) {
                        // TODO: Log an error here saying the callback failed
                        goto Exit;
                    }
                }
            }
        }
        // Error in the input stream?  Ok, stop.
        else if (LogicalPiece.ulThingType == XMLDOC_THING_ERROR) {
            // TODO: Issue an error here
            status = LogicalPiece.Error.Code;
            goto Exit;
        }
        // End of stream? Spiffy, we're done
        else if (LogicalPiece.ulThingType == XMLDOC_THING_END_OF_STREAM) {
            
            break;
            
        }
    }
        
    
    status = RtlXmlCloneTokenizationState(&ParseState.ParseState, pTargetTokenState);
    if (!NT_SUCCESS(status))
        goto Exit;
    
Exit:
    RtlXmlDestroyNextLogicalThing(&ParseState);
    RtlDestroyGrowingList(&Attributes);


    return status;
}



NTSTATUS
RtlpValidateXmlDeclaration(
    PXML_TOKENIZATION_STATE pState,
    PXMLDOC_THING pDocThing
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    XML_STRING_COMPARE fMatch;

    if ((pState == NULL) || (pDocThing == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }
    else if (pDocThing->ulThingType != XMLDOC_THING_XMLDECL) {
        return STATUS_MANIFEST_MISSING_XML_DECL;
    }


    status = pState->pfnCompareSpecialString(
        pState,
        &pDocThing->XmlDecl.Standalone,
        &sc_ss_xmldecl_yes,
        &fMatch);

    if (!NT_SUCCESS(status)) {
        return status;
    }
    else if (fMatch != XML_STRING_COMPARE_EQUALS) {
        return STATUS_MANIFEST_NOT_STANDALONE;
    }


    status = pState->pfnCompareSpecialString(
        pState,
        &pDocThing->XmlDecl.Version,
        &sc_ss_xmldecl_version_10,
        &fMatch);

    if (!NT_SUCCESS(status)) {
        return status;
    }
    else if (fMatch != XML_STRING_COMPARE_EQUALS) {
        return STATUS_MANIFEST_NOT_VERSION_1_0;
    }


    return STATUS_SUCCESS;
}

typedef struct _SEARCH_ATTRIBUTES_CONTEXT {
    PXML_TOKENIZATION_STATE State;
    PXMLDOC_ATTRIBUTE SearchKey;
} SEARCH_ATTRIBUTES_CONTEXT;

typedef int (__cdecl *bsearchcompare)(const void*, const void*);

int __cdecl SearchForAttribute(
    const SEARCH_ATTRIBUTES_CONTEXT* Context,
    PCXML_VALID_ELEMENT_ATTRIBUTE ValidAttribute
    )
{
    XML_STRING_COMPARE Compare;

    RtlXmlMatchAttribute(
        Context->State, 
        Context->SearchKey, 
        ValidAttribute->Attribute.Namespace, 
        &ValidAttribute->Attribute.Name,
        &Compare);

    //
    // Note: this logic is intentionally backwards.
    //
    return -(int)Compare;
}

NTSTATUS
RtlValidateAttributesAndOrganize(
    PXML_TOKENIZATION_STATE         State,
    PXMLDOC_ELEMENT                 Element,
    PRTL_GROWING_LIST               Attributes,
    PCXML_ELEMENT_DEFINITION        ThisElement,
    PXMLDOC_ATTRIBUTE              *OrderedList
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ul;
    BOOLEAN Compare;
    PXMLDOC_ATTRIBUTE pThisAttribute;
    SEARCH_ATTRIBUTES_CONTEXT SearchContext = { State };

    RtlZeroMemory(OrderedList, ThisElement->AttributeCount * sizeof(PXMLDOC_ATTRIBUTE));

    for (ul = 0; ul < Element->ulAttributeCount; ul++) {

        PCXML_VALID_ELEMENT_ATTRIBUTE MatchingAttribute = NULL;

        status = RtlIndexIntoGrowingList(
            Attributes,
            ul,
            (PVOID*)&SearchContext.SearchKey,
            FALSE);

        if (!NT_SUCCESS(status))
            goto Exit;

        MatchingAttribute = bsearch(
            &SearchContext, 
            ThisElement->AttributeList, 
            ThisElement->AttributeCount,
            sizeof(ThisElement->AttributeList[0]),
            (bsearchcompare)SearchForAttribute);

        if (MatchingAttribute) {
            // TODO: Fix this up a little bit so that we can call off to the validator
            OrderedList[MatchingAttribute - ThisElement->AttributeList] = SearchContext.SearchKey;
        }
    }

    status = STATUS_SUCCESS;
Exit:
    return status;
}
    





static XML_SPECIAL_STRING s_us_ValidManifestVersions[] = {
    MAKE_SPECIAL_STRING("1.0"),
    MAKE_SPECIAL_STRING("1.5")
};




NTSTATUS
Rtl_InspectManifest_Assembly(
    PXML_LOGICAL_STATE          pLogicalState,
    PRTL_MANIFEST_CONTENT_RAW   pManifestContent,
    PXMLDOC_THING               pDocumentThing,
    PRTL_GROWING_LIST           pAttributes,
    MANIFEST_ELEMENT_CALLBACK_REASON Reason,
    const struct _XML_ELEMENT_DEFINITION *pElementDefinition
    )
{
    NTSTATUS status;
    ULONG    u;

    PXMLDOC_ATTRIBUTE FoundAttributes[eAttribs_assembly_Count];

    //
    // Potentially this should be an ASSERT with an INTERNAL_ERROR_CHECK, since this function
    // has internal-only linkage.
    //
    if (!pLogicalState || !pManifestContent || !pDocumentThing || !pAttributes || !pElementDefinition)
        return STATUS_INVALID_PARAMETER;

    //
    // We don't care about  anything other than 'open' tha
    //
    if (Reason != eElementNotify_Open)
        return STATUS_SUCCESS;

    ASSERT(pDocumentThing->ulThingType == XMLDOC_THING_ELEMENT);

    status = RtlValidateAttributesAndOrganize(
        &pLogicalState->ParseState,
        &pDocumentThing->Element,
        pAttributes,
        pElementDefinition,
        FoundAttributes);

    //
    // Log a parse error here
    //
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    status = STATUS_SUCCESS;
Exit:
    return status;
}



NTSTATUS
Rtl_InspectManifest_File(
    PXML_LOGICAL_STATE          pLogicalState,
    PRTL_MANIFEST_CONTENT_RAW   pManifestContent,
    PXMLDOC_THING               pDocumentThing,
    PRTL_GROWING_LIST           pAttributes,
    MANIFEST_ELEMENT_CALLBACK_REASON Reason,
    const struct _XML_ELEMENT_DEFINITION *pElementDefinition
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ulLeftovers;

    union {
        PXMLDOC_ATTRIBUTE   File[eAttribs_assembly_file_Count];
    } Attributes;

    if (Reason != eElementNotify_Open)
        return STATUS_SUCCESS;

    ASSERT(pDocumentThing->ulThingType == XMLDOC_THING_ELEMENT);
    if (pDocumentThing->ulThingType != XMLDOC_THING_ELEMENT)
        return STATUS_INTERNAL_ERROR;

    if (pElementDefinition == ELEMENT_NAMED(assembly_file)) {
        
        ULONG ulIndex = pManifestContent->ulFileMembers;
        PASSEMBLY_MEMBER_FILE_RAW pNewFile = NULL;

        status = RtlValidateAttributesAndOrganize(
            &pLogicalState->ParseState,
            &pDocumentThing->Element,
            pAttributes,
            pElementDefinition,
            Attributes.File);

        // Log a parse error here
        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        // Log a parse error here as well
        if (Attributes.File[eAttribs_assembly_file_name] == NULL) {
            status = STATUS_MANIFEST_FILE_TAG_MISSING_NAME;
            goto Exit;
        }

        status = RtlIndexIntoGrowingList(&pManifestContent->FileMembers, ulIndex, (PVOID*)&pNewFile, TRUE);
        if (!NT_SUCCESS(status))
            goto Exit;

        RtlZeroMemory(pNewFile, sizeof(*pNewFile));

        if (Attributes.File[eAttribs_assembly_file_name])
            pNewFile->FileName = Attributes.File[eAttribs_assembly_file_name]->Value;

        if (Attributes.File[eAttribs_assembly_file_hashalg])
            pNewFile->HashAlg = Attributes.File[eAttribs_assembly_file_hashalg]->Value;

        if (Attributes.File[eAttribs_assembly_file_size])
            pNewFile->Size = Attributes.File[eAttribs_assembly_file_size]->Value;

        if (Attributes.File[eAttribs_assembly_file_hash])
            pNewFile->HashValue = Attributes.File[eAttribs_assembly_file_hash]->Value;

        if (Attributes.File[eAttribs_assembly_file_loadFrom])
            pNewFile->LoadFrom = Attributes.File[eAttribs_assembly_file_loadFrom]->Value;

        if (Attributes.File[eAttribs_assembly_file_digestMethod])
            pNewFile->DigestMethod = Attributes.File[eAttribs_assembly_file_digestMethod]->Value;

        pManifestContent->ulFileMembers++;
    }

    status = STATUS_SUCCESS;
Exit:
    return status;
}



NTSTATUS
Rtl_InspectManifest_AssemblyIdentity(
    PXML_LOGICAL_STATE          pLogicalState,
    PRTL_MANIFEST_CONTENT_RAW   pManifestContent,
    PXMLDOC_THING               pDocumentThing,
    PRTL_GROWING_LIST           pAttributes,
    MANIFEST_ELEMENT_CALLBACK_REASON Reason,
    const struct _XML_ELEMENT_DEFINITION *pElementDefinition
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PXMLDOC_ATTRIBUTE AsmIdentAttribs[eAttribs_assembly_assemblyIdentity_Count];
    ULONG ulThisIdentity, ulThisAttribute, i;

    if (Reason != eElementNotify_Open)
        return STATUS_SUCCESS;

    ASSERT(pDocumentThing && (pDocumentThing->ulThingType == XMLDOC_THING_ELEMENT));
    if (!pDocumentThing || (pDocumentThing->ulThingType != XMLDOC_THING_ELEMENT))
        return STATUS_INTERNAL_ERROR;

    if (pElementDefinition == ELEMENT_NAMED(assembly_assemblyIdentity)) {
        if (pManifestContent->ulRootIdentityIndex != INVALID_ASSEMBLY_IDENTITY_INDEX) {
            // TODO: Log a parse error
            status = STATUS_UNSUCCESSFUL;
            goto Exit;
        }
    }

    //
    // Use local copies - we'll update the values in the raw content when we've
    // added them all.
    //
    ulThisIdentity = pManifestContent->ulAssemblyIdentitiesFound;
    ulThisAttribute = pManifestContent->ulAssemblyIdentityAttributes;

    //
    // For each, create slots to hold the assembly identities
    //
    for (i = 0; i < pDocumentThing->Element.ulAttributeCount; i++) {

        PXMLDOC_ATTRIBUTE pThisAttribute = NULL;
        PASSEMBLY_IDENTITY_ATTRIBUTE_RAW pRawIdent = NULL;

        status = RtlIndexIntoGrowingList(pAttributes, i, (PVOID*)&pThisAttribute, FALSE);
        if (!NT_SUCCESS(status))
            goto Exit;
        
        status = RtlIndexIntoGrowingList(
            &pManifestContent->AssemblyIdentityAttributes,
            ulThisAttribute++,
            (PVOID*)&pRawIdent,
            TRUE);

        if (!NT_SUCCESS(status))
            goto Exit;

        pRawIdent->Namespace = pThisAttribute->NsPrefix;
        pRawIdent->Attribute = pThisAttribute->Name;
        pRawIdent->Value = pThisAttribute->Value;
        pRawIdent->ulIdentityIndex = ulThisIdentity;
    }

    //
    // Whee, we got to the end and added them all - update stuff in the raw content
    // so that it knows all about this new identity, and mark it as root if it is.
    //
    if (pElementDefinition == ELEMENT_NAMED(assembly_assemblyIdentity)) {
        pManifestContent->ulRootIdentityIndex = ulThisIdentity;
    }
    
    pManifestContent->ulAssemblyIdentitiesFound++;
    pManifestContent->ulAssemblyIdentityAttributes = ulThisAttribute;

    status = STATUS_SUCCESS;
Exit:
    return status;
}



NTSTATUS
RtlSxsInitializeManifestRawContent(
    ULONG                           ulRequestedContent,
    PRTL_MANIFEST_CONTENT_RAW      *pRawContentOut,
    PVOID                           pvOriginalBuffer,
    SIZE_T                          cbOriginalBuffer
    )
{
    PRTL_MANIFEST_CONTENT_RAW   pContent = NULL;
    PRTL_MINI_HEAP   pExtraContent = NULL;
    
    PVOID       pvBufferUsed = NULL;
    SIZE_T      cbBufferUsed = 0;
    NTSTATUS    status = STATUS_SUCCESS;
    RTL_ALLOCATOR MiniAllocator = { RtlMiniHeapAlloc, RtlMiniHeapFree };

    if (pRawContentOut)
        *pRawContentOut = NULL;

    if (!pRawContentOut || (!pvOriginalBuffer && cbOriginalBuffer))
        return STATUS_INVALID_PARAMETER;

    if (pvOriginalBuffer == NULL) {

        //
        // If you get a compile error on this line, you'll need to increase the size
        // of the 'default' allocation size above.
        //
        C_ASSERT(DEFAULT_MINI_HEAP_SIZE >= (sizeof(RTL_MANIFEST_CONTENT_RAW) + sizeof(RTL_MINI_HEAP)));
        
        cbBufferUsed = DEFAULT_MINI_HEAP_SIZE;
        status = g_DefaultAllocator.pfnAlloc(DEFAULT_MINI_HEAP_SIZE, &pvBufferUsed, g_DefaultAllocator.pvContext);
        
        if (!NT_SUCCESS(status))
            return status;
    }
    else {
        pvBufferUsed = pvOriginalBuffer;
        cbBufferUsed = cbOriginalBuffer;
    }

    //
    // Ensure there's enough space for the raw content data, as well as the extra content
    //
    if (cbBufferUsed < (sizeof(RTL_MANIFEST_CONTENT_RAW) + sizeof(RTL_MINI_HEAP))) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Set up the content structure and the extra turdlet content at
    // the end properly
    //
    pContent = (PRTL_MANIFEST_CONTENT_RAW)pvBufferUsed;

    status = RtlInitializeMiniHeapInPlace(
        (PRTL_MINI_HEAP)(pContent + 1),
        cbBufferUsed - sizeof(*pContent),
        &pExtraContent);

    if (!NT_SUCCESS(status))
        goto Exit;

    //
    // Now let's go initialize the content data
    //
    RtlZeroMemory(pContent, sizeof(*pContent));

    pContent->ulFlags = MANIFEST_CONTENT_SELF_ALLOCATED;
    pContent->ulRootIdentityIndex = MAX_ULONG;

    MiniAllocator.pvContext = pExtraContent;

    status = RtlInitializeGrowingList(
        &pContent->FileMembers, 
        sizeof(ASSEMBLY_MEMBER_FILE_RAW), 
        8, 
        NULL, 
        0, 
        &MiniAllocator);
    
    if (!NT_SUCCESS(status))
        goto Exit;

    //
    // Always also need the assembly identity at the root
    //
    status = RtlInitializeGrowingList(
        &pContent->AssemblyIdentityAttributes,
        sizeof(ASSEMBLY_IDENTITY_ATTRIBUTE_RAW),
        8,
        NULL,
        0,
        &MiniAllocator);

    if (!NT_SUCCESS(status))
        goto Exit;

    //
    // Want the COM class data?
    //
    if (ulRequestedContent & RTLIMS_GATHER_COMCLASSES) {

        status = RtlAllocateGrowingList(
            &pContent->pComClasses,
            sizeof(COMCLASS_REDIRECTION_RAW), 
            &MiniAllocator);
        
        if (!NT_SUCCESS(status))
            goto Exit;
    }

    //
    // Want the window class data?
    //
    if (ulRequestedContent & RTLIMS_GATHER_WINDOWCLASSES) {

        status = RtlAllocateGrowingList(
            &pContent->pWindowClasses, 
            sizeof(WINDOWCLASS_REDIRECTION_RAW), 
            &MiniAllocator);
        
        if (!NT_SUCCESS(status))
            goto Exit;
    }

    //
    // Want the prog ids?
    //
    if (ulRequestedContent & RTLIMS_GATHER_COMCLASS_PROGIDS) {

        status = RtlAllocateGrowingList(
            &pContent->pProgIds, 
            sizeof(COMCLASS_PROGID_RAW), 
            &MiniAllocator);
        
        if (!NT_SUCCESS(status))
            goto Exit;
    }

    //
    // Want the dependencies?
    //
    if (ulRequestedContent & RTLIMS_GATHER_DEPENDENCIES) {

        status = RtlAllocateGrowingList(
            &pContent->pComClasses, 
            sizeof(COMCLASS_REDIRECTION_RAW), 
            &MiniAllocator);
        
        if (!NT_SUCCESS(status))
            goto Exit;
    }

    //
    // Want the external proxy stubs?
    //
    if (ulRequestedContent & RTLIMS_GATHER_EXTERNALPROXIES) {

        status = RtlAllocateGrowingList(
            &pContent->pExternalInterfaceProxyStubs, 
            sizeof(COMINTERFACE_REDIRECTION_RAW), 
            &MiniAllocator);
        
        if (!NT_SUCCESS(status))
            goto Exit;
    }
    //
    // Want the internal proxy stubs?
    //
    if (ulRequestedContent & RTLIMS_GATHER_INTERFACEPROXIES) {

        status = RtlAllocateGrowingList(
            &pContent->pInterfaceProxyStubs, 
            sizeof(COMINTERFACE_REDIRECTION_RAW), 
            &MiniAllocator);
        
        if (!NT_SUCCESS(status))
            goto Exit;
    }
    //
    // Want the type libraries?
    //
    if (ulRequestedContent & RTLIMS_GATHER_TYPELIBRARIES) {

        status = RtlAllocateGrowingList(
            &pContent->pTypeLibraries, 
            sizeof(TYPELIB_REDIRECT_RAW), 
            &MiniAllocator);
        
        if (!NT_SUCCESS(status))
            goto Exit;
    }

    if (ulRequestedContent & RTLIMS_GATHER_SIGNATURES) {
        
        status = RtlAllocateGrowingList(
            &pContent->pManifestSignatures,
            sizeof(XML_DSIG_BLOCK),
            &MiniAllocator);

        if (!NT_SUCCESS(status))
            goto Exit;
    }

    *pRawContentOut = pContent;
    
Exit:
    if (!NT_SUCCESS(status) && pvBufferUsed && (pvBufferUsed != pvOriginalBuffer)) {
        g_DefaultAllocator.pfnFree(pvBufferUsed, NULL);
    }

    return status;
    
}

NTSTATUS
RtlSxsDestroyManifestContent(
    PRTL_MANIFEST_CONTENT_RAW       pRawContent
    )
{
    if (!pRawContent)
        return STATUS_INVALID_PARAMETER;

    if (pRawContent->pComClasses) {
        RtlDestroyGrowingList(pRawContent->pComClasses);
        pRawContent->pComClasses = NULL;
    }

    if (pRawContent->pExternalInterfaceProxyStubs) {
        RtlDestroyGrowingList(pRawContent->pExternalInterfaceProxyStubs);
        pRawContent->pExternalInterfaceProxyStubs = NULL;
    }

    if (pRawContent->pInterfaceProxyStubs) {
        RtlDestroyGrowingList(pRawContent->pInterfaceProxyStubs);
        pRawContent->pInterfaceProxyStubs = NULL;
    }

    if (pRawContent->pManifestSignatures) {
        RtlDestroyGrowingList(pRawContent->pManifestSignatures);
        pRawContent->pManifestSignatures = NULL;
    }

    if (pRawContent->pProgIds) {
        RtlDestroyGrowingList(pRawContent->pProgIds);
        pRawContent->pProgIds = NULL;
    }

    if (pRawContent->pTypeLibraries) {
        RtlDestroyGrowingList(pRawContent->pTypeLibraries);
        pRawContent->pTypeLibraries = NULL;
    }

    if (pRawContent->pWindowClasses) {
        RtlDestroyGrowingList(pRawContent->pWindowClasses);
        pRawContent->pWindowClasses = NULL;
    }

    RtlDestroyGrowingList(&pRawContent->FileMembers);
    RtlDestroyGrowingList(&pRawContent->AssemblyIdentityAttributes);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlpAllocateAndExtractString(
    PXML_EXTENT                 pXmlExtent,
    PUNICODE_STRING             pusTargetString,
    PXML_RAWTOKENIZATION_STATE  pState,
    PMINI_BUFFER                pTargetBuffer
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    MINI_BUFFER mb;

    if (!ARGUMENT_PRESENT(pXmlExtent) || !ARGUMENT_PRESENT(pusTargetString) ||
        !ARGUMENT_PRESENT(pState) || !ARGUMENT_PRESENT(pTargetBuffer))
    {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(pusTargetString, sizeof(*pusTargetString));
    mb = *pTargetBuffer;

	//
	// ISSUE:jonwis-2002-04-19: We need to clamp this max length elsewhere - we should not
	// be allowing arbitrarily-large attributes and whatnot.  Unfortunately, this exposes
	// "implementation details", so this clamp should be on our side of the wall, /not/
	// in the XML parser itself.
	//
	pusTargetString->Length = 0;
	pusTargetString->MaximumLength = (USHORT)pXmlExtent->ulCharacters * sizeof(WCHAR);
	
    status = RtlMiniBufferAllocateBytes(&mb, pusTargetString->MaximumLength, &pusTargetString->Buffer);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlXmlExtentToString(pState, pXmlExtent, pusTargetString, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    *pTargetBuffer = mb;

    return STATUS_SUCCESS;
}



NTSTATUS
RtlpAllocateAndExtractString2(
    PXML_EXTENT                 pXmlExtent,
    PUNICODE_STRING            *ppusTargetString,
    PXML_RAWTOKENIZATION_STATE  pState,
    PMINI_BUFFER                pTargetBuffer
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    MINI_BUFFER mb;

    if (!ARGUMENT_PRESENT(pXmlExtent) || !ARGUMENT_PRESENT(ppusTargetString) ||
        !ARGUMENT_PRESENT(pState) || !ARGUMENT_PRESENT(pTargetBuffer))
    {
        return STATUS_INVALID_PARAMETER;
    }

    *ppusTargetString = NULL;
    mb = *pTargetBuffer;

    status = RtlMiniBufferAllocate(&mb, UNICODE_STRING, ppusTargetString);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlpAllocateAndExtractString(
        pXmlExtent,
        *ppusTargetString,
        pState,
        pTargetBuffer);

    return status;
}

//
// These help keep things aligned
//
#define ALIGN_SIZE(type) ROUND_UP_COUNT(sizeof(type))

NTSTATUS
RtlpCalculateCookedManifestContentSize(
    PRTL_MANIFEST_CONTENT_RAW   pRawContent,
    PXML_RAWTOKENIZATION_STATE  pState,
    PSIZE_T                     pcbRequired
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T cbRequired;
    ULONG ul = 0;
    ULONG ulNamespacesFound = 0;    

    if (ARGUMENT_PRESENT(pcbRequired)) {
        *pcbRequired = 0;
    }
        

    if (!ARGUMENT_PRESENT(pRawContent) || !ARGUMENT_PRESENT(pState) || !ARGUMENT_PRESENT(pcbRequired)) {
        return STATUS_INVALID_PARAMETER;
    }

    cbRequired = ROUND_UP_COUNT(sizeof(MANIFEST_COOKED_DATA), ALIGNMENT_VALUE);

    //
    // For each file, gather up the data in the raw object.
    //
    cbRequired += ROUND_UP_COUNT(sizeof(MANIFEST_COOKED_FILE) * pRawContent->ulFileMembers, ALIGNMENT_VALUE);
    
    for (ul = 0; ul < pRawContent->ulFileMembers; ul++) {
        PASSEMBLY_MEMBER_FILE_RAW pRawFile = NULL;

        status = RtlIndexIntoGrowingList(&pRawContent->FileMembers, ul, (PVOID*)&pRawFile, FALSE);
        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        if (pRawFile->FileName.pvData != NULL) {
            cbRequired += ROUND_UP_COUNT(pRawFile->FileName.ulCharacters * sizeof(WCHAR), ALIGNMENT_VALUE);
        }

        if (pRawFile->LoadFrom.pvData != NULL) {
            cbRequired += ROUND_UP_COUNT(pRawFile->LoadFrom.ulCharacters * sizeof(WCHAR), ALIGNMENT_VALUE);
        }

        //
        // Each two characters in the hash value string represents one byte.
        //
        if (pRawFile->HashValue.pvData != NULL) {
            cbRequired += ROUND_UP_COUNT(pRawFile->HashValue.ulCharacters / 2, ALIGNMENT_VALUE);
        }
    }

    //
    // For now, we're none too bright about pooling namespaces on identity values. Luckily,
    // values in different namespaces are now not the norm, so life gets easier.
    //
    cbRequired += ROUND_UP_COUNT(sizeof(MANIFEST_IDENTITY_TABLE), ALIGNMENT_VALUE);
    cbRequired += ROUND_UP_COUNT(sizeof(MANIFEST_COOKED_IDENTITY) * pRawContent->ulAssemblyIdentitiesFound, ALIGNMENT_VALUE);
    cbRequired += ROUND_UP_COUNT(sizeof(MANIFEST_COOKED_IDENTITY_PAIR) * pRawContent->ulAssemblyIdentityAttributes, ALIGNMENT_VALUE);
    
    for (ul = 0; ul < pRawContent->ulAssemblyIdentityAttributes; ul++) {
        PASSEMBLY_IDENTITY_ATTRIBUTE_RAW pRawAttribute = NULL;
        ULONG ul2 = 0;

        status = RtlIndexIntoGrowingList(&pRawContent->AssemblyIdentityAttributes, ul, (PVOID*)&pRawAttribute, FALSE);
        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        //
        // We need this much extra space to to store the data
        //
        cbRequired += ROUND_UP_COUNT(pRawAttribute->Attribute.ulCharacters * sizeof(WCHAR), ALIGNMENT_VALUE);
        cbRequired += ROUND_UP_COUNT(pRawAttribute->Value.ulCharacters * sizeof(WCHAR), ALIGNMENT_VALUE);
        cbRequired += ROUND_UP_COUNT(pRawAttribute->Namespace.ulCharacters * sizeof(WCHAR), ALIGNMENT_VALUE);
    }

    *pcbRequired = cbRequired;
    status = STATUS_SUCCESS;
Exit:
    return status;    
}



NTSTATUS FORCEINLINE
pExpandBuffer(
    PUNICODE_STRING strTarget, 
    PVOID pvBaseBuffer, 
    SIZE_T cchCount
    )
{
    NTSTATUS status;
    const USHORT usRequiredCb = (USHORT)(cchCount * sizeof(WCHAR));
    if (strTarget->MaximumLength >= usRequiredCb) {
        return STATUS_SUCCESS;
    }
    else {
        if ((strTarget->Buffer != pvBaseBuffer) && (strTarget->Buffer != NULL)) {
            if (!NT_SUCCESS(status = g_DefaultAllocator.pfnFree(strTarget->Buffer, NULL)))
                return status;
        }
        if (!NT_SUCCESS(status = g_DefaultAllocator.pfnAlloc(usRequiredCb, (PVOID*)&strTarget->Buffer, NULL))) {
            strTarget->Buffer = NULL;
            strTarget->MaximumLength = strTarget->Length = 0;
            return status;
        }
        strTarget->MaximumLength = usRequiredCb;
        strTarget->Length = 0;
        return STATUS_SUCCESS;
    }
}


#define pFreeBuffer(buff, pvBase) do { \
    if (((buff)->Buffer != pvBase) && ((buff)->Buffer != NULL)) { \
        RtlDefaultFreer((buff)->Buffer, NULL); \
        (buff)->Buffer = NULL; (buff)->MaximumLength = 0; } \
} while (0)



struct {
    const UNICODE_STRING Text;
    DigestType DigestValue;
} g_rgsHashDigests[] = {
    { RTL_CONSTANT_STRING(L"fullfile"), DigestType_FullFile }
};

struct {
    const UNICODE_STRING Text;
    HashType HashAlgValue;
} g_rgsHashAlgs[] = {
    { RTL_CONSTANT_STRING(L"sha1"),     HashType_Sha1 },
    { RTL_CONSTANT_STRING(L"sha"),      HashType_Sha1 },
    { RTL_CONSTANT_STRING(L"sha-256"),  HashType_Sha256 },
    { RTL_CONSTANT_STRING(L"sha-384"),  HashType_Sha384 },
    { RTL_CONSTANT_STRING(L"sha-512"),  HashType_Sha512 },
    { RTL_CONSTANT_STRING(L"md5"),      HashType_MD5 },
    { RTL_CONSTANT_STRING(L"md4"),      HashType_MD4 },
    { RTL_CONSTANT_STRING(L"md2"),      HashType_MD4 },
};

NTSTATUS
RtlpParseDigestMethod(
    PUNICODE_STRING pText,
    DigestType *pDigestType
    )
{
    ULONG ul;
    
    if (pDigestType != NULL)
        *pDigestType = 0;

    if (!ARGUMENT_PRESENT(pDigestType) || !ARGUMENT_PRESENT(pText)) {
        return STATUS_INVALID_PARAMETER;
    }

    for (ul = 0; ul < NUMBER_OF(g_rgsHashDigests); ul++) {
        if (RtlCompareUnicodeString(pText, &g_rgsHashDigests[ul].Text, TRUE) == 0) {
            *pDigestType = g_rgsHashDigests[ul].DigestValue;
            return STATUS_SUCCESS;
        }        
    }

    return STATUS_NOT_FOUND;
}


NTSTATUS
RtlpParseHashAlg(
    PUNICODE_STRING pText,
    HashType       *pHashType
    )
{
    ULONG ul;
    
    if (pHashType != NULL)
        *pHashType = 0;

    if (!ARGUMENT_PRESENT(pHashType) || !ARGUMENT_PRESENT(pText)) {
        return STATUS_INVALID_PARAMETER;
    }

    for (ul = 0; ul < NUMBER_OF(g_rgsHashAlgs); ul++) {
        if (RtlCompareUnicodeString(pText, &g_rgsHashAlgs[ul].Text, TRUE) == 0) {
            *pHashType = g_rgsHashAlgs[ul].HashAlgValue;
            return STATUS_SUCCESS;
        }        
    }

    return STATUS_NOT_FOUND;
}


NTSTATUS
RtlpAddRawIdentitiesToCookedContent(
    PRTL_MANIFEST_CONTENT_RAW   pRawContent,
    PMANIFEST_COOKED_DATA       pCookedContent,
    PXML_RAWTOKENIZATION_STATE  pState,
    PMINI_BUFFER                TargetBuffer
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ul = 0;
    PMANIFEST_IDENTITY_TABLE IdentityTable = NULL;
    PMANIFEST_COOKED_IDENTITY IdentityList = NULL;
    PMANIFEST_COOKED_IDENTITY_PAIR NameValueList = NULL;
        
    //
    // Start off by allocating space for the table of identities, and the
    // table of individual identities
    //
    status = RtlMiniBufferAllocate(TargetBuffer, MANIFEST_IDENTITY_TABLE, &IdentityTable);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    status = RtlMiniBufferAllocateCount(TargetBuffer, MANIFEST_COOKED_IDENTITY, pRawContent->ulAssemblyIdentitiesFound, &IdentityList);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    RtlZeroMemory(IdentityList, sizeof(*IdentityList) * pRawContent->ulAssemblyIdentitiesFound);

    IdentityTable->ulIdentityCount = pRawContent->ulAssemblyIdentitiesFound;
    IdentityTable->ulRootIdentityIndex = ULONG_MAX;
    IdentityTable->CookedIdentities = IdentityList;


    //
    // Now allocate the right number of identity components
    //
    status = RtlMiniBufferAllocateCount(TargetBuffer, MANIFEST_COOKED_IDENTITY_PAIR, pRawContent->ulAssemblyIdentityAttributes, &NameValueList);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    RtlZeroMemory(NameValueList, sizeof(*NameValueList) * pRawContent->ulAssemblyIdentityAttributes);

    //
    // Spiffy - now, we start adding identity components into the list.  We'll assert that the
    // array of components' indexes increases monotomically.
    //
    for (ul = 0; ul < pRawContent->ulAssemblyIdentityAttributes; ul++) {
        PASSEMBLY_IDENTITY_ATTRIBUTE_RAW RawValue = NULL;
        PMANIFEST_COOKED_IDENTITY pThisIdentity = IdentityList + ul;

        status = RtlIndexIntoGrowingList(
            &pRawContent->AssemblyIdentityAttributes,
            ul,
            (PVOID*)&RawValue,
            FALSE);

        if (!NT_SUCCESS(status))
            goto Exit;

        ASSERT(RawValue->ulIdentityIndex < pRawContent->ulAssemblyIdentitiesFound);
        pThisIdentity = IdentityList + RawValue->ulIdentityIndex;

        //
        // If this is unset to start, then set it
        //
        if (pThisIdentity->pIdentityPairs == NULL) {
            pThisIdentity->pIdentityPairs = NameValueList + ul;
        }

        //
        // Allocate enough space to hold the namespace, name, etc.
        //
        if (RawValue->Namespace.pvData) {
            status = RtlpAllocateAndExtractString(
                &RawValue->Namespace,
                &NameValueList[ul].Namespace,
                pState,
                TargetBuffer);
            
            if (!NT_SUCCESS(status))
                goto Exit;
        }


        status = RtlpAllocateAndExtractString(
            &RawValue->Attribute,
            &NameValueList[ul].Name,
            pState,
            TargetBuffer);

        if (!NT_SUCCESS(status))
            goto Exit;

        status = RtlpAllocateAndExtractString(
            &RawValue->Value,
            &NameValueList[ul].Value,
            pState,
            TargetBuffer);

        if (!NT_SUCCESS(status))
            goto Exit;


        pThisIdentity->ulIdentityComponents++;        
    }

    pCookedContent->pManifestIdentity = IdentityTable;
    pCookedContent->ulFlags |= COOKEDMANIFEST_HAS_IDENTITIES;

Exit:
    return status;
}


NTSTATUS
RtlpAddRawFilesToCookedContent(
    PRTL_MANIFEST_CONTENT_RAW   pRawContent,
    PMANIFEST_COOKED_DATA       pCookedContent,
    PXML_RAWTOKENIZATION_STATE  pState,
    PMINI_BUFFER                TargetBuffer
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ul;
    MINI_BUFFER OurMiniBuffer;
    RTL_UNICODE_STRING_BUFFER TempStringBuffer;
    UCHAR TempStringBufferStatic[64];

    if (!ARGUMENT_PRESENT(pRawContent) || !ARGUMENT_PRESENT(pState) || !ARGUMENT_PRESENT(TargetBuffer)) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlInitUnicodeStringBuffer(&TempStringBuffer, TempStringBufferStatic, sizeof(TempStringBufferStatic));

    //
    // Copy buffer state - if we succeed, we'll write the updated buffer back
    // into the one that's tracking stuff in the caller.
    //
    OurMiniBuffer = *TargetBuffer;
    pCookedContent->ulFileCount = pRawContent->ulFileMembers;

    if (pRawContent->ulFileMembers == 0) {
        
        pCookedContent->pCookedFiles = NULL;
        
    }
    else {

        PASSEMBLY_MEMBER_FILE_RAW pRawFile = NULL;


        status = RtlMiniBufferAllocateCount(
            &OurMiniBuffer, 
            MANIFEST_COOKED_FILE, 
            pCookedContent->ulFileCount,
            &pCookedContent->pCookedFiles);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Now for each one, allocate the necessary UNICODE_STRINGs
        //
        for (ul = 0; ul < pRawContent->ulFileMembers; ul++) {

            PMANIFEST_COOKED_FILE pFile = pCookedContent->pCookedFiles + ul;

            pFile->ulFlags = 0;

            status = RtlIndexIntoGrowingList(&pRawContent->FileMembers, ul, (PVOID*)&pRawFile, FALSE);
            if (!NT_SUCCESS(status)) {
                return status;
            }

            //
            // If this fails, stop trying
            //
            if (pRawFile->FileName.pvData != NULL) {

                status = RtlpAllocateAndExtractString(
                    &pRawFile->FileName,
                    &pFile->FileName,
                    pState,
                    &OurMiniBuffer);

                if (!NT_SUCCESS(status))
                    goto Exit;
                
                pFile->ulFlags |= COOKEDFILE_NAME_VALID;

            }


            if (pRawFile->LoadFrom.pvData != NULL) {

                status = RtlpAllocateAndExtractString(
                    &pRawFile->LoadFrom,
                    &pFile->LoadFrom,
                    pState,
                    &OurMiniBuffer);

                if (!NT_SUCCESS(status))
                    goto Exit;

                pFile->ulFlags |= COOKEDFILE_LOADFROM_VALID;                
            }


            //
            // Get the digest method.  We don't store this anywhere, but we need to get it out
            // into a UNICODE_STRING for our parsing purposes
            //
            if (pRawFile->DigestMethod.pvData != NULL) {

                status = RtlEnsureUnicodeStringBufferSizeBytes(
                    &TempStringBuffer, 
                    pRawFile->DigestMethod.ulCharacters * sizeof(WCHAR)
                    );

                if (!NT_SUCCESS(status))
                    goto Exit;

                status = RtlXmlExtentToString(pState, &pRawFile->DigestMethod, &TempStringBuffer.String, NULL);
                if (!NT_SUCCESS(status)) {
                    goto Exit;
                }

                status = RtlpParseDigestMethod(&TempStringBuffer.String, &pFile->usDigestAlgorithm);
                if (!NT_SUCCESS(status)) {
                    goto Exit;
                }
                
                pFile->ulFlags |= COOKEDFILE_DIGEST_ALG_VALID;
            }


            if (pRawFile->HashAlg.pvData != NULL) {
                
                status = RtlEnsureUnicodeStringBufferSizeChars(
                    &TempStringBuffer, 
                    pRawFile->HashAlg.ulCharacters
                    );

                if (!NT_SUCCESS(status))
                    goto Exit;

                status = RtlXmlExtentToString(pState, &pRawFile->HashAlg, &TempStringBuffer.String, NULL);
                if (!NT_SUCCESS(status)) {
                    goto Exit;
                }

                status = RtlpParseHashAlg(&TempStringBuffer.String, &pFile->usHashAlgorithm);
                if (!NT_SUCCESS(status)) {
                    goto Exit;
                }

                pFile->ulFlags |= COOKEDFILE_HASH_ALG_VALID;
            }


            //
            // Special case here - we should extract the hash string, and then turn it into
            // bytes.
            // 
            if (pRawFile->HashValue.pvData != NULL) {

                status = RtlEnsureUnicodeStringBufferSizeChars(
                    &TempStringBuffer,
                    pRawFile->HashValue.ulCharacters);

                if (!NT_SUCCESS(status))
                    goto Exit;

                status = RtlXmlExtentToString(pState, &pRawFile->HashValue, &TempStringBuffer.String, NULL);
                if (!NT_SUCCESS(status))
                    goto Exit;

                if ((pRawFile->HashValue.ulCharacters % sizeof(WCHAR)) != 0) {
                    status = STATUS_INVALID_PARAMETER;
                    goto Exit;
                }
                else {
                    // Two characters per byte, high/low nibble
                    pFile->ulHashByteCount = pRawFile->HashValue.ulCharacters / 2;
                }

                status = RtlMiniBufferAllocateBytes(
                    &OurMiniBuffer, 
                    pFile->ulHashByteCount, 
                    &pFile->bHashData);

                if (!NT_SUCCESS(status)) {
                    goto Exit;
                }

                status = RtlpConvertHexStringToBytes(
                    &TempStringBuffer.String,
                    pFile->bHashData,
                    pFile->ulHashByteCount
                    );

                if (!NT_SUCCESS(status)) {
                    goto Exit;
                }

                pFile->ulFlags |= COOKEDFILE_HASHDATA_VALID;
            }

        }
        
    }

    pCookedContent->ulFlags |= COOKEDMANIFEST_HAS_FILES;
    *TargetBuffer = OurMiniBuffer;
    status = STATUS_SUCCESS;
Exit:
    RtlFreeUnicodeStringBuffer(&TempStringBuffer);
    
    return STATUS_SUCCESS;
}




NTSTATUS
RtlConvertRawToCookedContent(
    PRTL_MANIFEST_CONTENT_RAW   pRawContent,
    PXML_RAWTOKENIZATION_STATE  pState,
    PVOID                       pvOriginalRegion,
    SIZE_T                      cbRegionSize,
    PSIZE_T                     pcbRequired
    )
{
    PVOID                   pvCursor;
    ULONG                   ul;
    SIZE_T                  cbRemains = 0;
    SIZE_T                  cbRequired = 0;
    NTSTATUS                status = STATUS_SUCCESS;
    MINI_BUFFER             OutputBuffer;
    PMANIFEST_COOKED_DATA   pCookedContent = NULL;

    if (pcbRequired)
        *pcbRequired = 0;

    //
    // Giving a NULL output buffer means you have zero bytes.  Don't claim otherwise.
    //
    if (!pvOriginalRegion && (cbRegionSize != 0)) {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // No output buffer, you have to let us tell you how much space you need.
    //
    else if ((pvOriginalRegion == NULL) && (pcbRequired == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // See how much we really need.  I'm thinking we could do this in a single pass,
    // and we'll probably want to for perf reasons, but for now we calculate, and then
    // copy data around.
    //
    status = RtlpCalculateCookedManifestContentSize(
        pRawContent,
        pState,
        &cbRequired);

    //
    // Too big - write the output size into the required space and return.
    //
    if (cbRequired > cbRegionSize) {        
        if (pcbRequired) *pcbRequired = cbRequired;
        return STATUS_BUFFER_TOO_SMALL;
    }


    //
    // Now, let's start writing data into the blob!
    //
    RtlMiniBufferInit(&OutputBuffer, pvOriginalRegion, cbRegionSize);
    status = RtlMiniBufferAllocate(&OutputBuffer, MANIFEST_COOKED_DATA, &pCookedContent);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    pCookedContent->cbTotalSize = cbRequired;
    pCookedContent->ulFlags = 0;

    status = RtlpAddRawFilesToCookedContent(
        pRawContent, 
        pCookedContent, 
        pState, 
        &OutputBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlpAddRawIdentitiesToCookedContent(
        pRawContent,
        pCookedContent,
        pState,
        &OutputBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inspection\hashers.cpp ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "hashers.h"
#include "sha.h"
#include "sha2.h"

CSha1HashObject::CSha1HashObject() : Finalized(false) { }
CSha1HashObject::~CSha1HashObject() { }

CEnv::StatusCode CSha1HashObject::Initialize() 
{ 
    Finalized = false; 
    ZeroMemory(FinalResult, sizeof(FinalResult));
    A_SHAInit(this);
    return CEnv::SuccessCode;
}

CEnv::StatusCode 
CSha1HashObject::Hash(const CEnv::CConstantByteRegion& region)
{
    if (Finalized)
        return CEnv::InvalidParameter;
    
    A_SHAUpdate(this, const_cast<unsigned char*>(region.GetPointer()), region.GetCount());
    return CEnv::SuccessCode;
}

CEnv::StatusCode CSha1HashObject::Finalize()
{
    if (!Finalized)
    {
        A_SHAFinal(this, FinalResult);
        Finalized = true;
    }

    return CEnv::SuccessCode;
}

CEnv::StatusCode 
CSha1HashObject::GetValue(CEnv::CConstantByteRegion &pBytes) const
{
    pBytes.SetPointerAndCount(NULL, 0);
    
    if (!Finalized)
        return CEnv::InvalidParameter;

    pBytes.SetPointerAndCount(FinalResult, sizeof(FinalResult));
    return CEnv::SuccessCode;
}

const CEnv::CConstantByteRegion CSha1HashObject::s_Sha1Oid = CEnv::CConstantByteRegion(NULL, 0);
const CEnv::CConstantUnicodeStringPair CSha1HashObject::s_Sha1AlgName = CEnv::CConstantUnicodeStringPair(L"SHA1", 4);

void *CHashObject::operator new(size_t cb)
{
    return HeapAlloc(GetProcessHeap(), 0, cb);
}

void CHashObject::operator delete(void *p)
{
    HeapFree(GetProcessHeap(), 0, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\inspection\analyzerxmldsig.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "sxs-rtl.h"
#include "skiplist.h"
#include "fasterxml.h"
#include "namespacemanager.h"
#include "xmlstructure.h"
#include "manifestinspection.h"
#include "analyzerxmldsig.h"

//
// This is all the stuff required to do XMLDSIG for us
//
DECLARE_ELEMENT(Signature);
DECLARE_ELEMENT(Signature_SignatureValue);
DECLARE_ELEMENT(Signature_SignedInfo);
DECLARE_ELEMENT(Signature_KeyInfo);
DECLARE_ELEMENT(Signature_KeyInfo_KeyName);
DECLARE_ELEMENT(Signature_KeyInfo_KeyValue);
DECLARE_ELEMENT(Signature_KeyInfo_KeyValue_DSAKeyValue);
DECLARE_ELEMENT(Signature_KeyInfo_KeyValue_RSAKeyValue);
//DECLARE_ELEMENT(Signature_Object);
DECLARE_ELEMENT(Signature_SignedInfo_CanonicalizationMethod);
DECLARE_ELEMENT(Signature_SignedInfo_SignatureMethod);
DECLARE_ELEMENT(Signature_SignedInfo_Reference);
DECLARE_ELEMENT(Signature_SignedInfo_Reference_Transforms);
DECLARE_ELEMENT(Signature_SignedInfo_Reference_DigestMethod);
DECLARE_ELEMENT(Signature_SignedInfo_Reference_DigestValue);


const XML_SPECIAL_STRING sc_ss_xmldsignamespace     = MAKE_SPECIAL_STRING("http://www.w3.org/2000/09/xmldsig#");


XML_ELEMENT_DEFINITION rgs_Element_Signature =
{
    XML_ELEMENT_FLAG_ALLOW_ANY_CHILDREN,
    eManifestState_Signature,
    NULL,
    &sc_ss_xmldsignamespace,
    MAKE_SPECIAL_STRING("Signature"),
    &Rtl_InspectManifest_Signature,
    rgs_Element_Signature_Children,
    0,
    { 0 }
};

PCXML_ELEMENT_DEFINITION rgs_Element_Signature_Children[] = {
    ELEMENT_NAMED(Signature_SignatureValue),
    ELEMENT_NAMED(Signature_SignedInfo),
    ELEMENT_NAMED(Signature_KeyInfo),
//    ELEMENT_NAMED(Signature_Object),
};

/*
Signature::
<!ELEMENT SignatureValue (#PCDATA) >
<!ATTLIST SignatureValue  
         Id  ID      #IMPLIED>
*/
enum {
    eAttribs_Signature_SignatureValue_Id = 0,
    eAttribs_Signature_SignatureValue_Count
};

ELEMENT_DEFINITION_NS(Signature, SignatureValue, sc_ss_xmldsignamespace, Rtl_InspectManifest_Signature, XML_ELEMENT_FLAG_ALLOW_ANY_CHILDREN | XML_ELEMENT_FLAG_ALLOW_ANY_ATTRIBUTES)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT_OPTIONAL(Id),
ELEMENT_DEFINITION_DEFNS_END();

ELEMENT_DEFINITION_CHILD_ELEMENTS(Signature, SignatureValue)
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();

/*
<!ELEMENT SignedInfo (CanonicalizationMethod, SignatureMethod,  Reference+)  >
<!ATTLIST SignedInfo  Id   ID      #IMPLIED>
*/
enum {
    eAttribs_Signature_SignedInfo_Id = 0,
    eAttribs_Signature_SignedInfo_Count
};
ELEMENT_DEFINITION_NS(Signature, SignedInfo, sc_ss_xmldsignamespace, Rtl_InspectManifest_Signature, XML_ELEMENT_FLAG_ALLOW_ANY_CHILDREN)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT_OPTIONAL(Id),
ELEMENT_DEFINITION_DEFNS_END();

ELEMENT_DEFINITION_CHILD_ELEMENTS(Signature, SignedInfo)
    ELEMENT_NAMED(Signature_SignedInfo_CanonicalizationMethod),
    ELEMENT_NAMED(Signature_SignedInfo_SignatureMethod),
    ELEMENT_NAMED(Signature_SignedInfo_Reference),
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();

/*
Signature::SignedInfo
<!ELEMENT CanonicalizationMethod (#PCDATA %Method.ANY;)* > 
<!ATTLIST CanonicalizationMethod 
    Algorithm CDATA #REQUIRED >
*/
enum {
    eAttribs_Signature_SignedInfo_CanonicalizationMethod_Algorithm = 0,
    eAttribs_Signature_SignedInfo_CanonicalizationMethod_Count
};
ELEMENT_DEFINITION_NS(Signature_SignedInfo, CanonicalizationMethod, sc_ss_xmldsignamespace, Rtl_InspectManifest_Signature, XML_ELEMENT_FLAG_NO_ELEMENTS)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(Algorithm),
ELEMENT_DEFINITION_DEFNS_END();

ELEMENT_DEFINITION_CHILD_ELEMENTS(Signature_SignedInfo, CanonicalizationMethod)
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();

/*
Signature::SignedInfo
<!ELEMENT SignatureMethod (#PCDATA|HMACOutputLength %Method.ANY;)* >
<!ATTLIST SignatureMethod 
    Algorithm CDATA #REQUIRED >
*/
enum {
    eAttribs_Signature_SignedInfo_SignatureMethod_Algorithm = 0,
    eAttribs_Signature_SignedInfo_SignatureMethod_Count
};

ELEMENT_DEFINITION_NS(Signature_SignedInfo, SignatureMethod, sc_ss_xmldsignamespace, Rtl_InspectManifest_Signature, XML_ELEMENT_FLAG_ALLOW_ANY_CHILDREN)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(Algorithm),
ELEMENT_DEFINITION_DEFNS_END();

ELEMENT_DEFINITION_CHILD_ELEMENTS(Signature_SignedInfo, SignatureMethod)
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();

/*
Signature::SignedInfo
<!ELEMENT Reference (Transforms?, DigestMethod, DigestValue)  >
<!ATTLIST Reference  
    Id  ID  #IMPLIED
    URI CDATA   #IMPLIED
    Type    CDATA   #IMPLIED>
*/
enum {
    eAttribs_Signature_SignedInfo_Reference_Id = 0,
    eAttribs_Signature_SignedInfo_Reference_Type,
    eAttribs_Signature_SignedInfo_Reference_URI,
    eAttribs_Signature_SignedInfo_Reference_Count
};
ELEMENT_DEFINITION_NS(Signature_SignedInfo, Reference, sc_ss_xmldsignamespace, Rtl_InspectManifest_Signature, 0)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT_OPTIONAL(Id),
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT_OPTIONAL(Type),
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT_OPTIONAL(URI),
ELEMENT_DEFINITION_DEFNS_END();

ELEMENT_DEFINITION_CHILD_ELEMENTS(Signature_SignedInfo, Reference)
//    ELEMENT_NAMED(Signature_SignedInfo_Reference_Transforms),
    ELEMENT_NAMED(Signature_SignedInfo_Reference_DigestMethod),
    ELEMENT_NAMED(Signature_SignedInfo_Reference_DigestValue),
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();

/*
Signature::SignedInfo::Reference
<!ELEMENT DigestMethod (#PCDATA %Method.ANY;)* >
<!ATTLIST DigestMethod
    Algorithm       CDATA   #REQUIRED >
*/
enum {
    eAttribs_Signature_SignedInfo_Reference_DigestMethod_Algorithm = 0,
    eAttribs_Signature_SignedInfo_Reference_DigestMethod_Count    
};
ELEMENT_DEFINITION_NS(Signature_SignedInfo_Reference, DigestMethod, sc_ss_xmldsignamespace, Rtl_InspectManifest_Signature, 0)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(Algorithm)
ELEMENT_DEFINITION_DEFNS_END();

ELEMENT_DEFINITION_CHILD_ELEMENTS(Signature_SignedInfo_Reference, DigestMethod)
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();

/*
Signature::SignedInfo::Reference
<!ELEMENT DigestValue  (#PCDATA)  >
*/
enum {
    eAttribs_Signature_SignedInfo_Reference_DigestValue_Count = 0
};
ELEMENT_DEFINITION_NS(Signature_SignedInfo_Reference, DigestValue, sc_ss_xmldsignamespace, Rtl_InspectManifest_Signature, 0)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(unused)
ELEMENT_DEFINITION_DEFNS_END();

ELEMENT_DEFINITION_CHILD_ELEMENTS(Signature_SignedInfo_Reference, DigestValue)
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();
    

/*
Signature::
<!ELEMENT KeyInfo (#PCDATA|KeyName|KeyValue|RetrievalMethod|
               X509Data|PGPData|SPKIData|MgmtData %KeyInfo.ANY;)* >
<!ATTLIST KeyInfo  
    Id  ID   #IMPLIED >
*/
enum {
    eAttribs_Signature_KeyInfo_Id = 0,
    eAttribs_Signature_KeyInfo_Count
};

ELEMENT_DEFINITION_NS(Signature, KeyInfo, sc_ss_xmldsignamespace, Rtl_InspectManifest_Signature, 0)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT_OPTIONAL(Id),
ELEMENT_DEFINITION_DEFNS_END();

// For now we only support keyname and keyvalue
ELEMENT_DEFINITION_CHILD_ELEMENTS(Signature, KeyInfo)
    ELEMENT_NAMED(Signature_KeyInfo_KeyName),
//    ELEMENT_NAMED(Signature_KeyInfo_KeyValue),
//    ELEMENT_NAMED(Signature_KeyInfo_RetrievalMethod),
//    ELEMENT_NAMED(Signature_KeyInfo_X509Data),
//    ELEMENT_NAMED(Signature_KeyInfo_PGPData),
//    ELEMENT_NAMED(Signature_KeyInfo_SPKIData),
//    ELEMENT_NAMED(Signature_KeyInfo_MgmtData)
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();


/*
Signature::KeyInfo
<!ELEMENT KeyName (#PCDATA) >
*/
enum {
    eAttribs_Signature_KeyInfo_KeyName_Count = 0
};
ELEMENT_DEFINITION_NS(Signature_KeyInfo, KeyName, sc_ss_xmldsignamespace, Rtl_InspectManifest_Signature, XML_ELEMENT_FLAG_NO_ELEMENTS)
    ATTRIBUTE_DEFINITION_NONS_NODEFAULT(empty),
ELEMENT_DEFINITION_DEFNS_END();

ELEMENT_DEFINITION_CHILD_ELEMENTS(Signature_KeyInfo, KeyName)
ELEMENT_DEFINITION_CHILD_ELEMENTS_END();

static int q[] = {0};

NTSTATUS
Rtl_InspectManifest_Signature(
    PXML_LOGICAL_STATE          pLogicalState,
    PRTL_MANIFEST_CONTENT_RAW   pManifestContent,
    PXMLDOC_THING               pDocThing,
    PRTL_GROWING_LIST           pAttributes,
    MANIFEST_ELEMENT_CALLBACK_REASON Reason,
    const struct _XML_ELEMENT_DEFINITION *pElementDefinition
    )
{
    PXML_DSIG_BLOCK pCurrentBlock = NULL;
    ULONG ulBlockIndex = 0;
    NTSTATUS status;

    //
    // Might not want signatures
    //
    if (!pManifestContent->pManifestSignatures)
        return STATUS_SUCCESS;

    ulBlockIndex = pManifestContent->ulDocumentSignatures;    

    //
    // Top-level <Signature> tag encountered
    //
    if (pElementDefinition == ELEMENT_NAMED(Signature)) {

        status = RtlIndexIntoGrowingList(
            pManifestContent->pManifestSignatures, 
            ulBlockIndex, 
            (PVOID*)&pCurrentBlock, 
            (Reason == eElementNotify_Open));

        if (!NT_SUCCESS(status))
            goto Exit;

        //
        // Opening the Signature tag requires that we reserve another slot in the signature
        // array now before doing anything else.
        //
        if (Reason == eElementNotify_Open) {

            RtlZeroMemory(pCurrentBlock, sizeof(*pCurrentBlock));

            //
            // Track this opening element as the entire contents of the <Signature> blob
            // that will get hashed later on.  In the close, we'll adjust the size of the
            // element to account for the entire data run.
            //
            pCurrentBlock->DsigDocumentExtent = pDocThing->TotalExtent;
        }
        //
        // As we close this element, we bump up the number of signatures found in the
        // raw content and reset the "whole signature block" value
        //
        else if (Reason == eElementNotify_Close) {
            pManifestContent->ulDocumentSignatures++;

            //
            // We only care about end elements - the above is already sufficient for
            // empty elements.
            //
            if (pDocThing->ulThingType == XMLDOC_THING_END_ELEMENT) {
                ULONG_PTR ulpStartLocation = (ULONG_PTR)pCurrentBlock->DsigDocumentExtent.pvData;
                ULONG_PTR ulpThisEnding = ((ULONG_PTR)pDocThing->TotalExtent.pvData) + pDocThing->TotalExtent.cbData;
                pCurrentBlock->DsigDocumentExtent.cbData = ulpThisEnding - ulpStartLocation;
            }
            
        }
    }
    //
    // Always get the 'active' block, we'll need it for all the operations below,
    // but don't grow in case we're out of range.
    //
    else {
        
        status = RtlIndexIntoGrowingList(pManifestContent->pManifestSignatures, ulBlockIndex, (PVOID*)&pCurrentBlock, FALSE);
        if (!NT_SUCCESS(status))
            goto Exit;
    }

    //
    // Now do something useful with this block
    //
    ASSERT(pCurrentBlock != NULL);
    if (pCurrentBlock == NULL) {
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    //
    // Signature values are only hyperspace, and only one of them at that.
    //
    if (pElementDefinition == ELEMENT_NAMED(Signature_SignatureValue)) {

        if (Reason == eElementNotify_Hyperspace) {            
            if ((pCurrentBlock->ulFlags & XMLDSIG_FLAG_SIGNATURE_DATA_PRESENT) == 0) {
                pCurrentBlock->ulFlags |= XMLDSIG_FLAG_SIGNATURE_DATA_PRESENT;
                pCurrentBlock->SignatureData = pDocThing->Hyperspace;
            }
            else {
                // TODO: Log an error here about duplicate <SignatureData>'s being invalid
                status = STATUS_UNSUCCESSFUL;
                goto Exit;
            }
        }
    }
    //
    // Signature methods get tacked into the current block as well
    //
    else if (pElementDefinition == ELEMENT_NAMED(Signature_SignedInfo_SignatureMethod)) {

        PXMLDOC_ATTRIBUTE OrganizedAttributes[eAttribs_Signature_SignedInfo_SignatureMethod_Count];
        
        if (Reason == eElementNotify_Open) {

            status = RtlValidateAttributesAndOrganize(
                &pLogicalState->ParseState,
                &pDocThing->Element,
                pAttributes,
                pElementDefinition,
                OrganizedAttributes);

            if (OrganizedAttributes[eAttribs_Signature_SignedInfo_SignatureMethod_Algorithm]) {
                if ((pCurrentBlock->ulFlags & XMLDSIG_FLAG_SIGNATURE_METHOD_PRESENT) == 0) {
                    pCurrentBlock->SignedInfoData.SignatureMethod = OrganizedAttributes[eAttribs_Signature_SignedInfo_SignatureMethod_Algorithm]->Value;
                    pCurrentBlock->ulFlags |= XMLDSIG_FLAG_SIGNATURE_METHOD_PRESENT;
                }
                else {
                    // TODO: Log a message here about duplicated SignatureMethod.Algorithm values
                    status = STATUS_UNSUCCESSFUL;
                    goto Exit;
                }
            }
            else {
                // TODO: Algorithm is required on this element
                status = STATUS_UNSUCCESSFUL;
                goto Exit;
            }
        }
    }
    
    status = STATUS_SUCCESS;
Exit:    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\sxsident\identhandles.c ===
#include "stdinc.h"
#include <setupapi.h>
#include <sxsapi.h>
#include "identhandles.h"

NTSTATUS
RtlAllocateIdentityHandle(
    PRTLSXS_ASM_IDENT_HANDLE_TABLE pHandleTable,
    PHANDLE pHandle,
    PASSEMBLY_IDENTITY pIdentity
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PRTLSXS_ASM_IDENT_HANDLE_TABLE_SLOT pTargetSlot = NULL;
    ULONG ul = 0;

    for (ul = 0; ul < pHandleTable->ulInlineCount; ul++) {

        if (pHandleTable->InlineList[ul].pIdentity == NULL) {
            pTargetSlot = pHandleTable->InlineList + ul;
            break;
        }
    }

    if ((pTargetSlot == NULL) && pHandleTable->HeapList) {

        for (ul = 0; ul < pHandleTable->ulHeapCount; ul++) {

            if (pHandleTable->HeapList[ul].pIdentity == NULL) {
                pTargetSlot = pHandleTable->HeapList + ul;
                break;
            }
        }
    }

    //
    // Still no slot found?  Resize the heap list
    //
    if (pTargetSlot == NULL) {
    }


    if (pTargetSlot == NULL) {
    }

    return status;
}

NTSTATUS
RtlFreeIdentityHandle(
    PRTLSXS_ASM_IDENT_HANDLE_TABLE pHandleTable,
    PHANDLE pHandle,
    )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
RtlDerefIdentityHandle(
    PRTLSXS_ASM_IDENT_HANDLE_TABLE pHandleTable,
    HANDLE hHandle,
    PASSEMBLY_IDENTITY *ppAsmIdent
    )
{
    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\sxsident\idp.h ===
#if !defined(_FUSION_ID_IDP_H_INCLUDED_)
#define _FUSION_ID_IDP_H_INCLUDED_

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    idp.h

Abstract:

    private definitions for assembly identity

Author:

    Michael Grier (MGrier) 7/27/2000

Revision History:

--*/

#pragma once

#include <sxstypes.h>
#include <sxsapi.h>

//
//  Power of two to which to round the number of allocated attribute
//  pointers.
//

#define ROUNDING_FACTOR_BITS (3)

#define WILDCARD_CHAR '*'

//
//  Note! Do not change this algorithm lightly.  Encoded identities stored in the
//  filesystem contain hashes using it.  Actually, just do not change it.
//

#define HASH_ALGORITHM HASH_STRING_ALGORITHM_X65599

typedef struct _ASSEMBLY_IDENTITY_NAMESPACE {
    ULONG Hash;
    ULONG Flags;
    SIZE_T NamespaceCch;
    const WCHAR *Namespace;
} ASSEMBLY_IDENTITY_NAMESPACE, *PASSEMBLY_IDENTITY_NAMESPACE;

typedef const ASSEMBLY_IDENTITY_NAMESPACE *PCASSEMBLY_IDENTITY_NAMESPACE;

//
//  Internal-use ASSEMBLY_IDENTITY_ATTRIBUTE struct that
//  also contains the hash of the attribute definition.
//

typedef struct _INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE {
    // NOTE!!! It is very important that the Attribute member appear first in this struct;
    // there are several places in the code that make this assumption.  If it is not true,
    // the code will break!
    // Note also that the Attribute's namespace string is actually allocated in common
    // for all attributes with the same namespace.
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace;
    ULONG NamespaceAndNameHash;
    ULONG WholeAttributeHash;
} INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, *PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE;

C_ASSERT(FIELD_OFFSET(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, Attribute) == 0);

typedef const INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE;

#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION   (0x00000001)
#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_SINGLE_ALLOCATION_FOR_EVERYTHING            (0x00000002)
#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION   (0x00000004)

//
//  Revelation of the ASSEMBLY_IDENTITY struct:
//

typedef struct _ASSEMBLY_IDENTITY {
    ULONG Flags;
    ULONG InternalFlags;
    ULONG Type;
    ULONG Hash;
    ULONG AttributeCount;
    ULONG AttributeArraySize; // preallocated a little larger so that we don't have to keep growing
    ULONG NamespaceCount;
    ULONG NamespaceArraySize;
    BOOLEAN  HashDirty;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray;
} ASSEMBLY_IDENTITY;

//
//  Header for encoded/serialized assembly identities:
//

#define ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC ((ULONG) 'dIAE')

//
//  Encoded assembly identity layout:
//
//      ENCODED_ASSEMBLY_IDENTITY_HEADER
//      <AttributeCount hashes of the attributes, sorted by the hash value>
//      <NamespaceCount ENCODED_ASSEMBLY_IDENTITY_NAMESPACE_HEADER headers, each
//          followed by the unicode namespace value>
//      <AttributeCount ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER headers, each
//          followed by the unicode attribute name and value>
//
//
//      e.g.
//
//      <begin ENCODED_ASSEMBLY_IDENTITY_HEADER>
//      00000000:   00000038            HeaderSize == sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER)
//      00000004:   'EAId'              Magic (ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC)
//      00000008:   0000014C            TotalSize
//      0000000C:   00000000            Flags
//      00000010:   00000001            Type (1 = ASSEMBLY_IDENTITY_TYPE_DEFINITION)
//      00000014:   00000000            EncodingFlags
//      00000018:   00000001            HashAlgorithm (1 = HASH_STRING_ALGORITHM_X65599)
//      0000001C:   ????????            Logical hash value of entire identity based on hash algorithm
//                                      (algorithm described in more detail below...)
//      00000020:   00000003            AttributeCount
//      00000024:   00000002            NamespaceCount
//      00000028:   00000000            ReservedMustBeZero1
//      0000002C:   00000000            ReservedMustBeZero2
//      00000030:   00000000 00000000   ReservedMustBeZero3
//      00000038:   00000000 00000000   ReservedMustBeZero4
//      <end ENCODED_ASSEMBLY_IDENTITY_HEADER>
//      <begin sorted attribute hash list>
//      00000040:   xxxxxxxx            hash of attribute #1
//      00000044:   yyyyyyyy            hash of attribute #0 - note that yyyyyyyy >= xxxxxxxx
//      00000048:   zzzzzzzz            hash of attribute #2 - note that zzzzzzzz >= yyyyyyyy
//      <end sorted attribute hash list>
//      <begin namespace length list>
//      0000004C:   00000015            length (in Unicode chars) of namespace #1 - "http://www.amazon.com" - 21 chars = 0x00000015
//      00000050:   00000018            length (in Unicode chars) of namespace #2 - "http://www.microsoft.com" - 24 chars = 0x00000018
//      <end namespace length list>
//      <begin attribute headers>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      00000054:   00000001            NamespaceIndex: 1 (http://www.amazon.com)
//      00000058:   00000004            Name length ("name" - 4 chars = 0x00000004)
//      0000005C:   00000006            Value length ("foobar" - 6 chars = 0x00000006)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      00000060:   00000002            NamespaceIndex: 2 (http://www.microsoft.com)
//      00000064:   00000004            Name length ("guid" - 4 chars = 0x00000004)
//      00000068:   00000026            Value length ("{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" - 38 chars = 0x00000026)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      0000006C:   00000002            NamespaceIndex: 2 (http://www.microsoft.com)
//      00000070:   00000004            Name length ("type" - 4 chars = 0x00000004)
//      00000074:   00000005            Value length ("win32" - 5 chars = 0x00000005)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <end attribute headers>
//      <begin namespace strings>
//      00000078:   "http://www.amazon.com"
//      000000A2:   "http://www.microsoft.com"
//      <end namespace strings>
//      <begin attribute values - names and values for each attribute in series>
//      000000D2:   "name"
//      000000DA:   "foobar"
//      000000E6:   "guid"
//      000000EE:   "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
//      0000013A:   "type"
//      00000142:   "win32"
//      <end attribute values>
//      0000014C:
//
//  Computing the whole identity hash:
//
//      The hash of the entire encoded identity is not the hash of the binary form, but
//      rather is a combination of the hashes for the various components.
//
//      For any Unicode character string, its hash is computed according to HashAlgorithm.
//      Currently this must be HASH_STRING_ALGORITHM_X65599 which is a multiply-and-
//      accumulate algorithm, implemented essentially as follows:
//
//          HashValue = 0;
//          for (i=0; i<Chars; i++)
//              HashValue = (HashValue * 65599) + OptionalToUpper(String[i]);
//
//      Note that the characters are converted to upper case.  This is somewhat in
//      conflict with the Unicode recommendation to convert to lower case for case
//      insensitive operations, but it is what the rest of the Windows NT system
//      does, so consistency matters more than doing the "right thing".
//
//      Note also that no trailing null characters are included in the hash.  This
//      is significant because of the fact that applying the loop to another character
//      even though its value is zero will significantly change the hash value.
//
//      Namespaces and attribute names are case sensitive, derived from the fact
//      that they appear in case sensitive contexts in the real world.  This is
//      unfortunate, but simpler in many ways.
//
//      Assembly identity attributes are composed of a triple of:
//          - Namespace URI (e.g. http://www.microsoft.com/schemas/side-by-side)
//          - Name (e.g. "publicKey")
//          - Value (case insensitive Unicode string)
//
//      The hash of an attribute is computed by computing the hash of the three
//      strings, and then combining them as:
//
//          AttributeHashValue = (((NamespaceHash * 65599) + NameHash) * 65599) + ValueHash
//
//      Now, sort the attributes based first on namespace, then on name then on
//      value (case sensitive, case sensitive and case insensitive respectively),
//      and combine their hashes as follows:
//
//          IdentityHash = 0;
//          for (i=0; i<AttributeCount; i++)
//              IdentityHash = (IdentityHash * 65599) + AttributeHashes[i];
//
//      IdentityHash is the value stored in the encoded header.
//
//      The attribute hash array stored in the encoded data is the attribute
//      hashes as described above.  The interesting thing is that they are stored
//      in order of ascending hash value, not in the canonical ordering for
//      attributes.
//
//      This is because a common scenario is to find an identity which has a
//      superset of a given identity.  While the actual attributes have to
//      be consulted to verify that the candidate is a true subset, non-
//      matches can be very quickly found by sorting both lists of hash
//      values and first looping over the smaller reference list, then
//      in a single pass walking the larger definition list.  Attributes present
//      in one but not in the other will be immediately noticable due to
//      the missing hashes.
//
//      As always with hashes, just because an encoded identity contains a
//      superset of the hash values in your candidate assembly reference,
//      it does not mean that the actual values appear and you must perform
//      real character string comparisons to verify containment.
//

#include <pshpack4.h>

typedef struct _ENCODED_ASSEMBLY_IDENTITY_HEADER {
    ULONG HeaderSize;           // bytes just in the header
    ULONG Magic;
    ULONG TotalSize;            // bytes for the whole encoded thing
    ULONG Flags;                // as defined for assembly identity flags
    ULONG Type;                 // type of identity - def, ref or wildcard
    ULONG EncodingFlags;        // flags describing the encoding itself
    ULONG HashAlgorithm;        // Algorithm ID for the hashes stored in the identity
    ULONG Hash;                 // Hash value of the entire identity
    ULONG AttributeCount;       // number of attributes
    ULONG NamespaceCount;       // number of distinct namespaces
    ULONG ReservedMustBeZero1;
    ULONG ReservedMustBeZero2;
    ULONGLONG ReservedMustBeZero3;
    ULONGLONG ReservedMustBeZero4;
} ENCODED_ASSEMBLY_IDENTITY_HEADER, *PENCODED_ASSEMBLY_IDENTITY_HEADER;

typedef const ENCODED_ASSEMBLY_IDENTITY_HEADER *PCENCODED_ASSEMBLY_IDENTITY_HEADER;

typedef struct _ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER {
    ULONG NamespaceIndex;       // number of the namespace for this attribute
    ULONG NameCch;              // size in Unicode characters of the name immediately following the
                                // namespace
    ULONG ValueCch;             // size in Unicode characters of the value immediately following the
                                // name.
} ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER, *PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER;

typedef const ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER *PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER;

#include <poppack.h>

#define SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL (0x00000001)

NTSTATUS
RtlSxspValidateAssemblyIdentity(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity
    );

NTSTATUS
RtlSxspValidateAssemblyIdentityAttributeNamespace(
    IN ULONG Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch
    );

NTSTATUS
RtlSxspValidateAssemblyIdentityAttributeName(
    IN ULONG Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch
    );

#define SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED (0x00000001)

NTSTATUS
RtlSxspValidateAssemblyIdentityAttributeValue(
    IN ULONG Flags,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch
    );

NTSTATUS
RtlSxspComputeInternalAssemblyIdentityAttributeBytesRequired(
    IN ULONG Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT SIZE_T *BytesRequiredOut
    );

NTSTATUS
RtlSxspComputeAssemblyIdentityAttributeBytesRequired(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Source,
    OUT SIZE_T *BytesRequiredOut
    );

#define SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND (0x00000001)

NTSTATUS
RtlSxspFindAssemblyIdentityNamespaceInArray(
    IN ULONG Flags,
    IN OUT PCASSEMBLY_IDENTITY_NAMESPACE **NamespacePointerArrayPtr,
    IN OUT ULONG *NamespaceArraySizePtr,
    IN OUT ULONG *NamespaceCountPtr,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

#define SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND (0x00000001)

NTSTATUS
RtlSxspFindAssemblyIdentityNamespace(
    IN ULONG Flags,
    IN struct _ASSEMBLY_IDENTITY* AssemblyIdentity,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

NTSTATUS
RtlSxspAllocateAssemblyIdentityNamespace(
    IN ULONG Flags,
    IN const WCHAR *NamespaceString,
    IN SIZE_T NamespaceCch,
    IN ULONG NamespaceHash,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

VOID
RtlSxspDeallocateAssemblyIdentityNamespace(
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    );

NTSTATUS
RtlSxspPopulateInternalAssemblyIdentityAttribute(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Destination
    );

NTSTATUS
RtlSxspAllocateInternalAssemblyIdentityAttribute(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Destination
    );

VOID
RtlSxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(
    IN ULONG Flags,
    IN struct _ASSEMBLY_IDENTITY* AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    );

VOID
RtlSxspDeallocateInternalAssemblyIdentityAttribute(
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

int
__cdecl
RtlSxspCompareInternalAttributesForQsort(
    const void *elem1,
    const void *elem2
    );

int
__cdecl
RtlSxspCompareULONGsForQsort(
    const void *elem1,
    const void *elem2
    );

NTSTATUS
RtlSxspCompareAssemblyIdentityAttributeLists(
    ULONG Flags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List1,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List2,
    ULONG *ComparisonResultOut
    );

NTSTATUS
RtlSxspHashInternalAssemblyIdentityAttributes(
    ULONG Flags,
    ULONG Count,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes,
    ULONG *HashOut
    );

NTSTATUS
RtlSxspCopyInternalAssemblyIdentityAttributeOut(
    ULONG Flags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE DestinationBuffer,
    SIZE_T *BytesCopiedOrRequired
    );

NTSTATUS
RtlSxspIsInternalAssemblyIdentityAttribute(
    IN ULONG Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    OUT BOOLEAN *EqualsOut
    );

#define SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY (0x00000001)
#define SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES (0x00000002)

NTSTATUS
RtlSxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
    IN ULONG Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT SIZE_T *BytesOut
    );

#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE   (0x00000001)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME        (0x00000002)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE       (0x00000004)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL (0x00000008)

NTSTATUS
RtlSxspLocateInternalAssemblyIdentityAttribute(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *InternalAttributeOut,
    OUT ULONG *LastIndexSearched OPTIONAL
    );

NTSTATUS
RtlSxspComputeQuotedStringSize(
    IN ULONG Flags,
    IN const WCHAR *StringIn,
    IN SIZE_T Cch,
    OUT SIZE_T *BytesOut
    );

VOID
RtlSxspDbgPrintInternalAssemblyIdentityAttribute(
    ULONG dwflags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

VOID
RtlSxspDbgPrintInternalAssemblyIdentityAttributes(
    ULONG dwflags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    );

VOID
RtlSxspDbgPrintAssemblyIdentityAttribute(
    ULONG dwflags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

VOID
RtlSxspDbgPrintAssemblyIdentityAttributes(
    ULONG dwflags,
    ULONG AttributeCount,
    PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    );

NTSTATUS
RtlSxspEnsureAssemblyIdentityHashIsUpToDate(
    ULONG dwFlags,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    );

NTSTATUS
RtlSxspHashUnicodeString(
    PCWSTR String,
    SIZE_T cch,
    PULONG HashValue,
    BOOLEAN fCaseInsensitive
    );



NTSTATUS
RtlSxspDbgPrintEx(
    ULONG dwFlags,
    CHAR *pcszFormatString,
    ...);

SIZE_T
RtlStringComplimentSpan(
    PCWSTR pcwszStart,
    PCWSTR pcwszEnd,
    PCWSTR pcwszMarkers
    );

LONG FORCEINLINE
RtlSxspCompareStrings(
    PCWSTR pcwsz1,
    SIZE_T cch1,
    PCWSTR pcwsz2,
    SIZE_T cch2,
    BOOLEAN fInsensitive
    );

#endif

NTSTATUS
RtlSxspValidateXMLName(
    PCWSTR psz,
    SIZE_T cch,
    BOOLEAN *prfValid
    );


#ifndef PARAMETER_CHECK
#define PARAMETER_CHECK(q) if (!(q)) { return STATUS_INVALID_PARAMETER; }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\sxsident\id.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    id.cpp

Abstract:

    Implementation of the assembly identity data type.

Author:

    Michael Grier (MGrier) 7/20/2000

Revision History:

--*/
#include "stdinc.h"
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>

#include "idp.h"
#include <identhandles.h>

LONG FORCEINLINE
RtlSxspCompareStrings(
    PCWSTR pcwsz1,
    SIZE_T cch1,
    PCWSTR pcwsz2,
    SIZE_T cch2,
    BOOLEAN fInsensitive
    )
{
    //
    // Note that these are initialized with the deconstified pcwsz,
    // but the underlying RtlCompareUnicodeString functions doesn't
    // modify the const input structures at all.  I couldn't get this
    // to work out without this cast, even though it's ugly.
    //
    const UNICODE_STRING a = { 
        (USHORT)cch1, 
        (USHORT)cch1, 
        (PWSTR)pcwsz1
    };

    const UNICODE_STRING b = { 
        (USHORT)cch2, 
        (USHORT)cch2, 
        (PWSTR)pcwsz2
    };

    return RtlCompareUnicodeString(&a, &b, fInsensitive ? TRUE : FALSE);
}

//
//  Power of two to which to round the number of allocated attribute
//  pointers.
//

#define ROUNDING_FACTOR_BITS (3)

#define WILDCARD_CHAR '*'

#define ENTRY(x) { x, NUMBER_OF(x) - 1 },

const static struct
{
    const WCHAR *String;
    SIZE_T Cch;
} s_rgLegalNamesNotInANamespace[] =
{
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE)
};

#undef ENTRY

NTSTATUS
RtlSxspValidateAssemblyIdentity(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    if ((Flags & ~SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL) != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    if (AssemblyIdentity == NULL)
    {
        if (!(Flags & SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL)) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        const ULONG IdentityType = AssemblyIdentity->Type;

        if ((IdentityType != ASSEMBLY_IDENTITY_TYPE_DEFINITION) &&
            (IdentityType != ASSEMBLY_IDENTITY_TYPE_REFERENCE) &&
            (IdentityType != ASSEMBLY_IDENTITY_TYPE_WILDCARD)) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    return STATUS_SUCCESS;
}

//
//  Note!
//
//  We currently are very very restrictive on the legal characters in namespaces.
//
//  This is because the various rules for equivalences of namespaces are extremely
//  complex w.r.t. when "a" == "A" and "%Ab" == "%aB" etc.
//
//  We're side-stepping this issue by requireing everything to be lower case and
//  not permitting the "%" character.
//

const WCHAR s_rgLegalNamespaceChars[] = L"abcdefghijklmnopqrstuvwxyz0123456789.-_/\\:";
NTSTATUS
RtlSxspValidateAssemblyIdentityAttributeNamespace(
    IN ULONG Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch
    )
{
    SIZE_T i;

    if ((Flags != 0) || ((Namespace == NULL) && (NamespaceCch != 0))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We really should ensure that the namespace is a well-formed URI
    //
    for (i=0; i<NamespaceCch; i++)
    {
        if (wcschr(s_rgLegalNamespaceChars, Namespace[i]) == NULL) {
            return STATUS_SXS_INVALID_XML_NAMESPACE_URI;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlSxspValidateAssemblyIdentityAttributeName(
    IN ULONG Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN fNameWellFormed = FALSE;

    if ((Flags != 0) || ((Name == NULL) && (NameCch != 0))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We should ensure that Name is a well-formed XML identifier
    //
    if (!NT_SUCCESS(status = RtlSxspValidateXMLName(Name, NameCch, &fNameWellFormed))) {
        return status;
    }

    if (!fNameWellFormed) {
        status = STATUS_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME;
    }

    return status;
}

NTSTATUS
RtlSxspValidateAssemblyIdentityAttributeValue(
    IN ULONG Flags,
    IN const WCHAR *wch,
    SIZE_T ValueCch
    )
{
    if ((Flags & ~SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED) != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlSxsValidateAssemblyIdentityAttribute(
    ULONG Flags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    if ((Flags & ~(
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED)) != 0) {

        return STATUS_INVALID_PARAMETER;
    }
    else if (Attribute == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  apply useful defaults.  Note that by default, wildcards are not permitted.
    //

    if (Flags == 0)
    {
        Flags =
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
    }

    // No attribute flags defined or permitted at this time.
    if (Attribute->Flags != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE) {
        status = RtlSxspValidateAssemblyIdentityAttributeNamespace(0, Attribute->Namespace, Attribute->NamespaceCch);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }


    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME) {
        status = RtlSxspValidateAssemblyIdentityAttributeName(0, Attribute->Name, Attribute->NameCch);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE) {
        status = RtlSxspValidateAssemblyIdentityAttributeValue(
                        (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED) ?
                            SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED : 0,
                         Attribute->Value,
                         Attribute->ValueCch);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    if ((Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE) &&
        (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME) &&
        (Attribute->NamespaceCch == 0))
    {
        SIZE_T i;
        // There is only a small set of legal attribute names when the namespace is omitted.

        for (i=0; i<NUMBER_OF(s_rgLegalNamesNotInANamespace); i++)
        {
            if (Attribute->NameCch == s_rgLegalNamesNotInANamespace[i].Cch)
            {
                if (RtlCompareMemory(Attribute->Name, s_rgLegalNamesNotInANamespace[i].String, Attribute->NameCch * sizeof(WCHAR)) == 0)
                    break;
            }
        }

        if (i == NUMBER_OF(s_rgLegalNamesNotInANamespace))
        {
            // Someone had an attribute on the <assemblyIdentity> element which was not in a namespace and
            // was not listed as a builtin attribute.  Boom.
            return STATUS_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE;
        }
    }

    return STATUS_SUCCESS;

}

NTSTATUS
RtlSxsHashAssemblyIdentityAttribute(
    ULONG Flags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    ULONG *HashOut
    )
{
    NTSTATUS status;
    ULONG Hash = 0;
    ULONG TempHash = 0;

    if (HashOut != NULL)
        *HashOut = 0;

    if (Flags == 0)
        Flags = SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE |
                SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME |
                SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE;

    if ((Flags & ~(SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE |
                  SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME |
                  SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE)) != 0) 
    {

        return STATUS_INVALID_PARAMETER;
    }

    // if hash value, must hash name, if hash name, must hash namespace
    if (((Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE) && (
        (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) == 0)) ||
        ((Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) && (
        (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE) == 0))) {
        return STATUS_INVALID_PARAMETER;
    }

    if ((Attribute == NULL) || (HashOut == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE) {
        status = RtlSxspHashUnicodeString(Attribute->Namespace, Attribute->NamespaceCch, &TempHash, TRUE);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        Hash = TempHash;
    }
    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) {
        status = RtlSxspHashUnicodeString(Attribute->Name, Attribute->NameCch, &TempHash, TRUE);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        Hash = (Hash * 65599) + TempHash;
    }

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE) {
        status = RtlSxspHashUnicodeString(Attribute->Value, Attribute->ValueCch, &TempHash, TRUE);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        Hash = (Hash * 65599) + TempHash;
    }

    *HashOut = Hash;

    return status;
}

NTSTATUS
RtlSxspComputeInternalAssemblyIdentityAttributeBytesRequired(
    IN ULONG Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT SIZE_T *BytesRequiredOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T BytesNeeded = 0;

    if (BytesRequiredOut != NULL)
        *BytesRequiredOut = 0;

    if ((Flags != 0) || 
        (BytesRequiredOut == NULL) || 
        ((NameCch != 0) && (Name == NULL)) ||
        ((ValueCch != 0) && (Value == NULL))) {
        return STATUS_INVALID_PARAMETER;
    }

    BytesNeeded = sizeof(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE);

    // Note that we do not account for the namespace length because namespaces are pooled
    // for the identity object and come from a separate allocation.

    if ((Name != NULL) && (NameCch != 0))
        BytesNeeded += ((NameCch + 1) * sizeof(WCHAR));

    if ((Value != NULL) && (ValueCch != 0))
        BytesNeeded += ((ValueCch + 1) * sizeof(WCHAR));

    *BytesRequiredOut = BytesNeeded;

    return status;
}

NTSTATUS
RtlSxspComputeAssemblyIdentityAttributeBytesRequired(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Source,
    OUT SIZE_T *BytesRequiredOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T BytesNeeded = 0;

    if (BytesRequiredOut != NULL)
        *BytesRequiredOut = 0;

    if ((Flags != 0) || (Source == NULL) || (BytesRequiredOut == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    BytesNeeded = sizeof(ASSEMBLY_IDENTITY_ATTRIBUTE);

    // We do account for the namespace length here because we're presumably about
    // to copy into an ASSEMBLY_IDENTITY_ATTRIBUTE where the namespace isn't pooled.

    if (Source->NamespaceCch != 0)
        BytesNeeded += ((Source->NamespaceCch + 1) * sizeof(WCHAR));

    if (Source->NameCch != 0)
        BytesNeeded += ((Source->NameCch + 1) * sizeof(WCHAR));

    if (Source->ValueCch != 0)
        BytesNeeded += ((Source->ValueCch + 1) * sizeof(WCHAR));

    *BytesRequiredOut = BytesNeeded;

    return status;
}

NTSTATUS
RtlSxspFindAssemblyIdentityNamespaceInArray(
    IN ULONG Flags,
    IN OUT PCASSEMBLY_IDENTITY_NAMESPACE **NamespacePointerArrayPtr,
    IN OUT ULONG *NamespaceArraySizePtr,
    IN OUT ULONG *NamespaceCountPtr,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG i, j;
    ULONG NamespaceHash = 0;
    ULONG NamespaceCount;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray;
    ULONG NewNamespaceArraySize = 0;
    PCASSEMBLY_IDENTITY_NAMESPACE *NewNamespacePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE NewNamespacePointer = NULL;
    ULONG NamespaceArraySize = 0;
    LONG Comparison;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND)) == 0);
    PARAMETER_CHECK(NamespacePointerArrayPtr != NULL);
    PARAMETER_CHECK(NamespaceCountPtr != NULL);
    PARAMETER_CHECK(NamespaceArraySizePtr != NULL);
    PARAMETER_CHECK((NamespaceCch == 0) || (Namespace != NULL));

    NamespacePointerArray = *NamespacePointerArrayPtr;
    NamespaceCount = *NamespaceCountPtr;
    NamespaceArraySize = *NamespaceArraySizePtr;

    if (!NT_SUCCESS(status = RtlSxspHashUnicodeString(Namespace, NamespaceCch, &NamespaceHash, FALSE))) {
        return STATUS_INVALID_PARAMETER;
    }

    for (i=0; i<NamespaceCount; i++)
    {
        if (NamespaceHash <= NamespacePointerArray[i]->Hash)
            break;
    }

    // Loop through the duplicate hash values seeing if we have a match.
    while ((i < NamespaceCount) && (NamespacePointerArray[i]->Hash == NamespaceHash) && (NamespacePointerArray[i]->NamespaceCch == NamespaceCch))
    {
        NamespacePointer = NamespacePointerArray[i];

        Comparison = memcmp(Namespace, NamespacePointerArray[i]->Namespace, NamespaceCch * sizeof(WCHAR));
        if (Comparison == 0)
            break;

        NamespacePointer = NULL;
        i++;
    }

    if ((NamespacePointer == NULL) && (Flags & SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND))
    {
        // We didn't find a match.  Allocate a new one and push it into the array at the
        // appropriate location.  If the namespace isn't null.
        if (NamespaceCch != 0)
        {
            status = RtlSxspAllocateAssemblyIdentityNamespace(0, Namespace, NamespaceCch, NamespaceHash, &NewNamespacePointer);
            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            // the "i" variable is where we want to insert this one.
            if (i >= NamespaceArraySize)
            {
                NewNamespaceArraySize = NamespaceArraySize + 8;

                NewNamespacePointerArray = (PCASSEMBLY_IDENTITY_NAMESPACE*)RtlAllocateHeap(
                    RtlProcessHeap(), 
                    HEAP_ZERO_MEMORY,
                    sizeof(ASSEMBLY_IDENTITY_NAMESPACE) * NewNamespaceArraySize);

                if (NewNamespacePointerArray == NULL) {
                    status = STATUS_NO_MEMORY;
                    goto Exit;
                }

                for (j=0; j<NamespaceCount; j++)
                    NewNamespacePointerArray[j] = NamespacePointerArray[j];

                while (j < NewNamespaceArraySize)
                    NewNamespacePointerArray[j++] = NULL;

                RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)NamespacePointerArray);
                NamespacePointerArray = NULL;

                *NamespacePointerArrayPtr = NewNamespacePointerArray;
                *NamespaceArraySizePtr = NewNamespaceArraySize;

                NamespacePointerArray = NewNamespacePointerArray;
                NamespaceArraySize = NewNamespaceArraySize;

                NewNamespacePointerArray = NULL;
                NewNamespaceArraySize = 0;
            }

            ASSERT(i < NamespaceArraySize);

            for (j = NamespaceCount; j > i; j--)
                NamespacePointerArray[j] = NamespacePointerArray[j-1];

            ASSERT(j == i);

            NamespacePointerArray[i] = NewNamespacePointer;
            NamespacePointer = NewNamespacePointer;
            NewNamespacePointer = NULL;

            *NamespaceCountPtr = NamespaceCount + 1;
        }
    }

    if (NamespaceOut != NULL)
        *NamespaceOut = NamespacePointer;

Exit:
    if (NewNamespacePointer != NULL)
        RtlSxspDeallocateAssemblyIdentityNamespace(NewNamespacePointer);

    if (NewNamespacePointerArray != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)NewNamespacePointerArray);
        NewNamespacePointerArray = NULL;
    }

    return status;
}

NTSTATUS
RtlSxspFindAssemblyIdentityNamespace(
    IN ULONG Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(NamespaceOut != NULL);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));

    if (!NT_SUCCESS(status = RtlSxspValidateAssemblyIdentity(0, AssemblyIdentity))) {
        return status;
    }

    status = RtlSxspFindAssemblyIdentityNamespaceInArray(
            (Flags & SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND) ?
                SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND : 0,
            &AssemblyIdentity->NamespacePointerArray,
            &AssemblyIdentity->NamespaceArraySize,
            &AssemblyIdentity->NamespaceCount,
            Namespace,
            NamespaceCch,
            &NamespacePointer);

    *NamespaceOut = NamespacePointer;

    return status;
}

NTSTATUS
RtlSxspAllocateAssemblyIdentityNamespace(
    IN ULONG Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN ULONG NamespaceHash,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PASSEMBLY_IDENTITY_NAMESPACE NewNamespace = NULL;
    SIZE_T BytesRequired = 0;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(NamespaceOut != NULL);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceHash == 0));
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));

    BytesRequired = sizeof(ASSEMBLY_IDENTITY_NAMESPACE);

    if (NamespaceCch != 0)
        BytesRequired += (NamespaceCch + 1) * sizeof(WCHAR);

    NewNamespace = (PASSEMBLY_IDENTITY_NAMESPACE)RtlAllocateHeap(
        RtlProcessHeap(),
        HEAP_ZERO_MEMORY,
        BytesRequired);

    if (NewNamespace == NULL) {
        status = STATUS_NO_MEMORY;
        goto Exit;
    }

    NewNamespace->Flags = 0;

    if (NamespaceCch != 0)
    {
        NewNamespace->Namespace = (PWSTR) (NewNamespace + 1);
        NewNamespace->NamespaceCch = NamespaceCch;

        memcpy(
            (PVOID) NewNamespace->Namespace,
            Namespace,
            NamespaceCch * sizeof(WCHAR));

        ((PWSTR) NewNamespace->Namespace) [NamespaceCch] = L'\0';
        NewNamespace->NamespaceCch = NamespaceCch;
    }
    else
    {
        NewNamespace->Namespace = NULL;
        NewNamespace->NamespaceCch = 0;
    }

    NewNamespace->Hash = NamespaceHash;

    *NamespaceOut = NewNamespace;
    NewNamespace = NULL;

    status = STATUS_SUCCESS;
Exit:
    if (NewNamespace != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, NewNamespace);
        NewNamespace = NULL;
    }

    return status;
}

VOID
RtlSxspDeallocateAssemblyIdentityNamespace(
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    )
{
    ASSERT(Namespace != NULL);

    if (Namespace != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)Namespace);
        Namespace = NULL;
    }
}

NTSTATUS
RtlSxspPopulateInternalAssemblyIdentityAttribute(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Destination
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PVOID Cursor = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Destination != NULL);

    Destination->Attribute.Flags = 0;
    Destination->Namespace = Namespace;

    Cursor = (PVOID) (Destination + 1);

    if (Namespace != NULL)
    {
        Destination->Attribute.Namespace = Namespace->Namespace;
        Destination->Attribute.NamespaceCch = Namespace->NamespaceCch;
    }
    else
    {
        Destination->Attribute.Namespace = NULL;
        Destination->Attribute.NamespaceCch = 0;
    }

    if ((Name != NULL) && (NameCch != 0))
    {
        Destination->Attribute.Name = (PWSTR) Cursor;
        memcpy(
            Cursor,
            Name,
            NameCch * sizeof(WCHAR));
        ((PWSTR) Destination->Attribute.Name) [NameCch] = L'\0';
        Destination->Attribute.NameCch = NameCch;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((NameCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        Destination->Attribute.Name = NULL;
        Destination->Attribute.NameCch = 0;
    }

    if ((Value != NULL) && (ValueCch != 0))
    {
        Destination->Attribute.Value = (PWSTR) Cursor;
        memcpy(
            Cursor,
            Value,
            ValueCch * sizeof(WCHAR));
        ((PWSTR) Destination->Attribute.Value)[ValueCch] = L'\0';
        Destination->Attribute.ValueCch = ValueCch;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((ValueCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        Destination->Attribute.Value = NULL;
        Destination->Attribute.ValueCch = 0;
    }

    status = RtlSxsHashAssemblyIdentityAttribute(0, &Destination->Attribute, &Destination->WholeAttributeHash);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    status = RtlSxsHashAssemblyIdentityAttribute(SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE | SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME,
                                &Destination->Attribute, &Destination->NamespaceAndNameHash);

    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

Exit:
    return status;
}

NTSTATUS
RtlSxspAllocateInternalAssemblyIdentityAttribute(
    IN ULONG Flags,
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Destination
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T BytesNeeded = 0;
    PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NewAttribute = NULL;

    if (Destination != NULL)
        *Destination = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Destination != NULL);
    PARAMETER_CHECK((NameCch == 0) || (Name != NULL));
    PARAMETER_CHECK((ValueCch == 0) || (Value != NULL));

    status = RtlSxspComputeInternalAssemblyIdentityAttributeBytesRequired(
        0, 
        Name, 
        NameCch, 
        Value, 
        ValueCch, 
        &BytesNeeded);

    if (!NT_SUCCESS(status)) {
        goto Exit;
    }


    NewAttribute = (PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE)RtlAllocateHeap(
        RtlProcessHeap(),
        0,
        BytesNeeded);

    if (NewAttribute == NULL) {
        status = STATUS_NO_MEMORY;
        goto Exit;
    }


    status = RtlSxspPopulateInternalAssemblyIdentityAttribute(0, Namespace, Name, NameCch, Value, ValueCch, NewAttribute);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    *Destination = NewAttribute;
    NewAttribute = NULL;

Exit:
    if (NewAttribute != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, NewAttribute);
        NewAttribute = NULL;
    }

    return status;
}

VOID
RtlSxspDeallocateInternalAssemblyIdentityAttribute(
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    )
{
    if (Attribute != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)Attribute);
        Attribute = NULL;
    }
}

NTSTATUS
RtlSxsCompareAssemblyIdentityAttributes(
    ULONG Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute1,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute2,
    OUT ULONG *ComparisonResult
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    LONG Comparison = 0, Comparison1, Comparison2, Comparison3;

    if (Flags == 0)
        Flags = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE |
                SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME |
                SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;

    PARAMETER_CHECK((Flags & ~(SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE |
                    SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME |
                    SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE)) == 0);
    PARAMETER_CHECK(Attribute1 != NULL);
    PARAMETER_CHECK(Attribute2 != NULL);
    PARAMETER_CHECK(ComparisonResult != NULL);

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE) {
        Comparison1 = RtlSxspCompareStrings(Attribute1->Namespace, Attribute1->NamespaceCch, Attribute2->Namespace, Attribute2->NamespaceCch, FALSE);
        if (Comparison1 != 0) { // we have get the result
            Comparison = Comparison1 ;
            goto done;
        }
    }

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME) {
        Comparison2 = RtlSxspCompareStrings(Attribute1->Name, Attribute1->NameCch, Attribute2->Name, Attribute2->NameCch, FALSE);
        if (Comparison2 != 0) { // we have get the result
            Comparison = Comparison2;
            goto done;
        }
    }

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE){
        Comparison3 = RtlSxspCompareStrings(Attribute1->Value, Attribute1->ValueCch, Attribute2->Value, Attribute2->ValueCch, TRUE);
        if (Comparison3 != 0) { // we have get the result
            Comparison = Comparison3;
            goto done;
        }
    }
    Comparison = 0;
done:
    if (Comparison < 0)
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN;
    else if (Comparison == 0)
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL;
    else
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN;

    status = STATUS_SUCCESS;
    return status;
}

int
__cdecl
RtlSxspCompareInternalAttributesForQsort(
    const void *elem1,
    const void *elem2
    )
{
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE * p1 = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *)elem1;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE patt1 = *p1;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE * p2 = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *)elem2;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE patt2 = *p2;
    LONG Comparison;

    Comparison = RtlSxspCompareStrings(patt1->Attribute.Namespace, patt1->Attribute.NamespaceCch, patt2->Attribute.Namespace, patt2->Attribute.NamespaceCch, FALSE);
    if (Comparison == 0)
        Comparison = RtlSxspCompareStrings(patt1->Attribute.Name, patt1->Attribute.NameCch, patt2->Attribute.Name, patt2->Attribute.NameCch, FALSE);
    if (Comparison == 0)
        Comparison = RtlSxspCompareStrings(patt1->Attribute.Value, patt1->Attribute.ValueCch, patt2->Attribute.Value, patt2->Attribute.ValueCch, TRUE);
    return Comparison;
}

int
__cdecl
RtlSxspCompareULONGsForQsort(
    const void *elem1,
    const void *elem2
    )
{
    ULONG *pul1 = (ULONG *) elem1;
    ULONG *pul2 = (ULONG *) elem2;

    return ((LONG) *pul1) - ((LONG) *pul2);
}

NTSTATUS
RtlSxspCompareAssemblyIdentityAttributeLists(
    ULONG Flags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List1,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List2,
    ULONG *ComparisonResultOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL;
    ULONG i;

    if ((Flags != 0) ||
        ((AttributeCount != 0) &&
         ((List1 == NULL) ||
          (List2 == NULL))) ||
        (ComparisonResultOut == NULL))
    {
        return STATUS_INVALID_PARAMETER;
    }

    for (i=0; i<AttributeCount; i++)
    {
        status = RtlSxsCompareAssemblyIdentityAttributes(0, &List1[i]->Attribute, &List2[i]->Attribute, &ComparisonResult);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL){
            break;
        }
    }

    *ComparisonResultOut = ComparisonResult;
    return status;
}

NTSTATUS
RtlSxspHashInternalAssemblyIdentityAttributes(
    ULONG Flags,
    ULONG Count,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes,
    ULONG *HashOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG Hash = 0;
    ULONG i;

    if (HashOut != NULL)
        *HashOut = 0;

    if ((Flags != 0) ||
        ((Count != 0) && (Attributes == NULL)) ||
        (HashOut == NULL))
    {
        return STATUS_INVALID_PARAMETER;
    }

    for (i=0; i<Count; i++)
        Hash = (Hash * 65599) + Attributes[i]->WholeAttributeHash;

    *HashOut = Hash;

    return STATUS_SUCCESS;
}

VOID SxspDbgPrintInternalAssemblyIdentityAttribute(ULONG dwflags, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute)
{
    RtlSxspDbgPrintEx(dwflags, "Attribute: \n"
        "\tNamespace = %S, \tNamespaceCch = %d\n"
        "\tAttributeName = %S, \tAttributeNameCch = %d\n"
        "\tAttributeValue = %S, \tAttributeValueCch = %d\n\n",
        Attribute->Attribute.Namespace == NULL ? L"" : Attribute->Attribute.Namespace, Attribute->Attribute.NamespaceCch,
        Attribute->Attribute.Name == NULL ? L"" : Attribute->Attribute.Name, Attribute->Attribute.NameCch,
        Attribute->Attribute.Value == NULL ? L"" : Attribute->Attribute.Value, Attribute->Attribute.ValueCch);

    return;
}
VOID
RtlSxspDbgPrintInternalAssemblyIdentityAttributes(ULONG dwflags, ULONG AttributeCount, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes)
{
    ULONG i;

    for (i = 0; i < AttributeCount; i++) {
        RtlSxspDbgPrintInternalAssemblyIdentityAttribute(dwflags, Attributes[i]);
    }
    return;
}
VOID SxspDbgPrintAssemblyIdentity(ULONG dwflags, PCASSEMBLY_IDENTITY pAssemblyIdentity){
    if ( pAssemblyIdentity) {
        RtlSxspDbgPrintInternalAssemblyIdentityAttributes(dwflags, pAssemblyIdentity->AttributeCount,
            pAssemblyIdentity->AttributePointerArray);
    }
    return;
}

VOID SxspDbgPrintAssemblyIdentityAttribute(ULONG dwflags, PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute)
{
    RtlSxspDbgPrintEx(dwflags, "Attribute: \n"
        "\tNamespace = %S, \tNamespaceCch = %d\n"
        "\tAttributeName = %S, \tAttributeNameCch = %d\n"
        "\tAttributeValue = %S, \tAttributeValueCch = %d\n\n",
        Attribute->Namespace == NULL ? L"" : Attribute->Namespace, Attribute->NamespaceCch,
        Attribute->Name == NULL ? L"" : Attribute->Name, Attribute->NameCch,
        Attribute->Value == NULL ? L"" : Attribute->Value, Attribute->ValueCch);

    return;
}
VOID
RtlSxspDbgPrintAssemblyIdentityAttributes(ULONG dwflags, ULONG AttributeCount, PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes)
{
    ULONG i;
    for (i=0;i<AttributeCount;i++){
        RtlSxspDbgPrintAssemblyIdentityAttribute(dwflags, Attributes[i]);
    }
}







NTSTATUS
RtlSxsCreateAssemblyIdentity(
    ULONG Flags,
    ULONG Type,
    PASSEMBLY_IDENTITY *AssemblyIdentityOut,
    ULONG AttributeCount,
    PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG AttributeArraySize = 0;
    SIZE_T BytesNeeded = 0;
    ULONG i;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;
    ULONG NamespaceArraySize = 0;
    ULONG NamespaceCount = 0;

#if DBG
    RtlSxspDbgPrintAssemblyIdentityAttributes(0x4, AttributeCount, Attributes);
#endif

    if (AssemblyIdentityOut != NULL)
        *AssemblyIdentityOut = NULL;

    if (((Flags & ~(SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)) != 0) ||
        ((Type != ASSEMBLY_IDENTITY_TYPE_DEFINITION) &&
         (Type != ASSEMBLY_IDENTITY_TYPE_REFERENCE) &&
         (Type != ASSEMBLY_IDENTITY_TYPE_WILDCARD)) ||
         ((AttributeCount != 0) && (Attributes == NULL)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Validate all our inputs before we get started...
    for (i=0; i<AttributeCount; i++)
    {
        status = RtlSxsValidateAssemblyIdentityAttribute(0, Attributes[i]);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    //  If we were told that this is a frozen assembly identity, we could be super-smart and
    //  have a single allocation for the whole thing.  Instead we'll leave that optimization
    //  for a future maintainer.  We'll at least be smart enough to allocate both the
    //  assembly identity and the array of attribute pointers in a single whack tho'.
    //

    if (Flags & SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        AttributeArraySize = AttributeCount;
    }
    else
    {
        // For non-frozen identities, we'll add a rounding factor and round up for the number of
        // array elements.
        AttributeArraySize = (AttributeCount + (1 << ROUNDING_FACTOR_BITS)) & ~((1 << ROUNDING_FACTOR_BITS) - 1);
    }

    // allocate everything except namespace array
    BytesNeeded = sizeof(ASSEMBLY_IDENTITY) + (AttributeArraySize * sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));

    AssemblyIdentity = (PASSEMBLY_IDENTITY)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, BytesNeeded);
    if (AssemblyIdentity == NULL) {
        status = STATUS_NO_MEMORY;
        goto Exit;
    }

    if (AttributeArraySize != 0)
    {
        AttributePointerArray = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *) (AssemblyIdentity + 1);

        // Initialize the pointers so we can clean up non-NULL ones in the error path
        for (i=0; i<AttributeArraySize; i++)
            AttributePointerArray[i] = NULL;
    }

    for (i=0; i<AttributeCount; i++)
    {
        PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;

        status = RtlSxspFindAssemblyIdentityNamespaceInArray(
                    SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND,
                    &NamespacePointerArray,
                    &NamespaceArraySize,
                    &NamespaceCount,
                    Attributes[i]->Namespace,
                    Attributes[i]->NamespaceCch,
                    &NamespacePointer);

        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        status = RtlSxspAllocateInternalAssemblyIdentityAttribute(
                0,
                NamespacePointer,
                Attributes[i]->Name,
                Attributes[i]->NameCch,
                Attributes[i]->Value,
                Attributes[i]->ValueCch,
                &AttributePointerArray[i]);

        if (!NT_SUCCESS(status)) {
            goto Exit;
        }
    }

    // sort 'em.
    qsort((PVOID) AttributePointerArray, AttributeCount, sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE), RtlSxspCompareInternalAttributesForQsort);

    AssemblyIdentity->AttributeArraySize = AttributeArraySize;
    AssemblyIdentity->AttributeCount = AttributeCount;
    AssemblyIdentity->AttributePointerArray = AttributePointerArray;
    AssemblyIdentity->NamespaceArraySize = NamespaceArraySize;
    AssemblyIdentity->NamespaceCount = NamespaceCount;
    AssemblyIdentity->NamespacePointerArray = NamespacePointerArray;
    AssemblyIdentity->Flags = 0;
    AssemblyIdentity->InternalFlags = ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION; // namespace is allocated sperately
    AssemblyIdentity->Type = Type;
    AssemblyIdentity->HashDirty = TRUE;

    AttributePointerArray = NULL;
    NamespacePointerArray = NULL;

    status = RtlSxspEnsureAssemblyIdentityHashIsUpToDate(0, AssemblyIdentity);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    if (Flags & SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

Exit:
    if ((AttributePointerArray != NULL) && (AttributeCount != 0))
    {
        for (i=0; i<AttributeCount; i++)
            RtlSxspDeallocateInternalAssemblyIdentityAttribute(AttributePointerArray[i]);
    }

    if ((NamespacePointerArray != NULL) && (NamespaceCount != 0))
    {
        for (i=0; i<NamespaceCount; i++)
            RtlSxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);

        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)NamespacePointerArray);
    }

    if (AssemblyIdentity != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, AssemblyIdentity);
    }

    return status;
}

NTSTATUS
RtlSxsFreezeAssemblyIdentity(
    ULONG Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    if ((Flags != 0) ||
        (AssemblyIdentity == NULL))
    {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // We could possibly do something really interesting like realloc the whole thing but
    // instead we'll just set the flag that stops future modifications.

    AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

Exit:
    return status;
}

VOID
RtlSxsDestroyAssemblyIdentity(
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    ULONG i;

    if (AssemblyIdentity == NULL)
        return;

    //
    // An identity that's created frozen (whether created new or copied from an existing identity)
    // uses a single allocation for everything.  Only free the suballocations if we're not
    // in this state.
    //

    if (!(AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_SINGLE_ALLOCATION_FOR_EVERYTHING))
    {
        const ULONG AttributeCount = AssemblyIdentity->AttributeCount;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = AssemblyIdentity->AttributePointerArray;
        const ULONG NamespaceCount = AssemblyIdentity->NamespaceCount;
        PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

        for (i=0; i<AttributeCount; i++)
        {
            RtlSxspDeallocateInternalAssemblyIdentityAttribute((PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) AttributePointerArray[i]);
            AttributePointerArray[i] = NULL;
        }

        for (i=0; i<NamespaceCount; i++)
        {
            RtlSxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);
            NamespacePointerArray[i] = NULL;
        }

        if (AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)AttributePointerArray);
            AssemblyIdentity->AttributePointerArray = NULL;
        }

        if (AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)NamespacePointerArray);
            AssemblyIdentity->NamespacePointerArray = NULL;
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)AssemblyIdentity);
}

NTSTATUS
RtlSxspCopyInternalAssemblyIdentityAttributeOut(
    ULONG Flags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE DestinationBuffer,
    SIZE_T *BytesCopiedOrRequired
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T BytesRequired = 0;
    PVOID Cursor;

    if (BytesCopiedOrRequired != NULL)
        *BytesCopiedOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (DestinationBuffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesCopiedOrRequired != NULL));

    status = RtlSxspComputeAssemblyIdentityAttributeBytesRequired(0, &Attribute->Attribute, &BytesRequired);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    if (BufferSize < BytesRequired)
    {
        if (BytesCopiedOrRequired != NULL)
            *BytesCopiedOrRequired = BytesRequired;

        status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    // We must be in the clear...
    DestinationBuffer->Flags = 0;

    Cursor = (PVOID) (DestinationBuffer + 1);

    if (Attribute->Attribute.NamespaceCch != 0)
    {
        DestinationBuffer->Namespace = (PWSTR) Cursor;
        DestinationBuffer->NamespaceCch = Attribute->Attribute.NamespaceCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        memcpy(
            Cursor,
            Attribute->Attribute.Namespace,
            (Attribute->Attribute.NamespaceCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.NamespaceCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Namespace = NULL;
        DestinationBuffer->NamespaceCch = 0;
    }

    if (Attribute->Attribute.NameCch != 0)
    {
        DestinationBuffer->Name = (PWSTR) Cursor;
        DestinationBuffer->NameCch = Attribute->Attribute.NameCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        memcpy(
            Cursor,
            Attribute->Attribute.Name,
            (Attribute->Attribute.NameCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.NameCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Name = NULL;
        DestinationBuffer->NameCch = 0;
    }

    if (Attribute->Attribute.ValueCch != 0)
    {
        DestinationBuffer->Value = (PWSTR) Cursor;
        DestinationBuffer->ValueCch = Attribute->Attribute.ValueCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        memcpy(
            Cursor,
            Attribute->Attribute.Value,
            (Attribute->Attribute.ValueCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.ValueCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Value = NULL;
        DestinationBuffer->ValueCch = 0;
    }

    if (BytesCopiedOrRequired != NULL)
    {
        *BytesCopiedOrRequired = (((ULONG_PTR) Cursor) - ((ULONG_PTR) DestinationBuffer));
    }

Exit:
    return status;
}

NTSTATUS
RtlSxspLocateInternalAssemblyIdentityAttribute(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *InternalAttributeOut,
    OUT ULONG *LastIndexSearched OPTIONAL
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    ULONG i = 0;
    ULONG AttributeCount = 0;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ULONG LowIndex = 0;
    ULONG HighIndexPlusOne = 0;
    ULONG CompareAttributesFlags = 0;

    if (InternalAttributeOut != NULL)
        *InternalAttributeOut = NULL;

    if (LastIndexSearched != NULL)
        *LastIndexSearched = 0;

    if (((Flags & ~(SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL)) != 0) ||
        (AssemblyIdentity == NULL) ||
        (Attribute == NULL) ||
        (InternalAttributeOut == NULL))
    {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) &&
        !(Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE))
    {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE) &&
        !(Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME))
    {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)
    {
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
    {
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
    {
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    AttributeCount = AssemblyIdentity->AttributeCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;

    LowIndex = 0;
    HighIndexPlusOne = AttributeCount;
    i = 0;

    while (LowIndex < HighIndexPlusOne)
    {
        i = (LowIndex + HighIndexPlusOne) / 2;

        if (i == HighIndexPlusOne)
        {
            i = LowIndex;
        }

        status = RtlSxsCompareAssemblyIdentityAttributes(
                CompareAttributesFlags,
                Attribute,
                &AttributePointerArray[i]->Attribute,
                &ComparisonResult);

        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        if ((ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL) &&
            (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN) &&
            (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN)) 
        {
            ASSERT(TRUE);
            status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
        {
            InternalAttribute = AttributePointerArray[i];
            break;
        }
        else if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN)
        {
            if ( HighIndexPlusOne == i){
                i--;
                break;
            }
            else
                HighIndexPlusOne = i;
        }
        else if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN)
        {
            if ( LowIndex == i){
                i++;
                break;
            }
            else
                LowIndex = i;
        }
    }

    // If it's equal, there's no guarantee it's the first.  Back up to find the first non-equal match
    if (InternalAttribute != NULL)
    {
        while (i > 0)
        {
            status = RtlSxsCompareAssemblyIdentityAttributes(
                    CompareAttributesFlags,
                    Attribute,
                    &AttributePointerArray[i - 1]->Attribute,
                    &ComparisonResult);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                break;

            i--;
            InternalAttribute = AttributePointerArray[i];
        }
    }

    if (InternalAttribute != NULL)
        *InternalAttributeOut = InternalAttribute;

    if (LastIndexSearched != NULL)
        *LastIndexSearched = i;

    // If we didn't find it, return ERROR_NOT_FOUND.
    if (((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL) == 0) &&
        (InternalAttribute == NULL))
    {
#if DBG
        SxspDbgPrintAssemblyIdentityAttribute(0x4, Attribute);
#endif
        status = STATUS_NOT_FOUND;
    }

Exit:
    return status;
}

NTSTATUS
RtlSxsInsertAssemblyIdentityAttribute(
    ULONG Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttribute
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NewInternalAttribute = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *NewAttributePointerArray = NULL;
    ULONG NewAttributeArraySize = 0;
    ULONG i;
    ULONG LastIndexSearched;

    PARAMETER_CHECK((Flags & ~(SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AssemblyIdentityAttribute != NULL);

    status = RtlSxspValidateAssemblyIdentity(0, AssemblyIdentity);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    status = RtlSxsValidateAssemblyIdentityAttribute(0, AssemblyIdentityAttribute);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    if ((AssemblyIdentity->Flags & ASSEMBLY_IDENTITY_FLAG_FROZEN) != 0) {
        ASSERT(TRUE);
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    status = RtlSxspFindAssemblyIdentityNamespace(
            SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND,
            AssemblyIdentity,
            AssemblyIdentityAttribute->Namespace,
            AssemblyIdentityAttribute->NamespaceCch,
            &Namespace);

    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    // Let's see if we can find it.
    status = RtlSxspLocateInternalAssemblyIdentityAttribute(
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            AssemblyIdentityAttribute,
            &InternalAttribute,
            &LastIndexSearched);

    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    if (InternalAttribute != NULL)
    {
        if (Flags & SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING)
        {
            // Ok, replace it!
            status = RtlSxspAllocateInternalAssemblyIdentityAttribute(
                    0,
                    Namespace,
                    AssemblyIdentityAttribute->Name,
                    AssemblyIdentityAttribute->NameCch,
                    AssemblyIdentityAttribute->Value,
                    AssemblyIdentityAttribute->ValueCch,
                    &NewInternalAttribute);

            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            AssemblyIdentity->AttributePointerArray[LastIndexSearched] = NewInternalAttribute;
            NewInternalAttribute = NULL;

            RtlSxspDeallocateInternalAssemblyIdentityAttribute(InternalAttribute);
        }
        else
        {
            // We actually wanted it to fail...
            status = STATUS_DUPLICATE_NAME;
            goto Exit;
        }
    }
    else
    {
        status = RtlSxspAllocateInternalAssemblyIdentityAttribute(
                0,
                Namespace,
                AssemblyIdentityAttribute->Name,
                AssemblyIdentityAttribute->NameCch,
                AssemblyIdentityAttribute->Value,
                AssemblyIdentityAttribute->ValueCch,
                &NewInternalAttribute);

        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        // Now we have it and we even know where to put it.  Grow the array if we need to.
        if (AssemblyIdentity->AttributeCount == AssemblyIdentity->AttributeArraySize)
        {
            NewAttributeArraySize = AssemblyIdentity->AttributeCount + 8;

            NewAttributePointerArray = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *) RtlAllocateHeap(
                RtlProcessHeap(),
                HEAP_ZERO_MEMORY,
                sizeof(PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) * NewAttributeArraySize);

            if (NewAttributePointerArray == NULL) {
                status = STATUS_NO_MEMORY;
                goto Exit;
            }

            // Instead of copying the data and then shuffling, we'll copy the stuff before the insertion
            // point, fill in at the insertion point and then copy the rest.

            for (i=0; i<LastIndexSearched; i++)
                NewAttributePointerArray[i] = AssemblyIdentity->AttributePointerArray[i];

            for (i=LastIndexSearched; i<AssemblyIdentity->AttributeCount; i++)
                NewAttributePointerArray[i+1] = AssemblyIdentity->AttributePointerArray[i];

            if (AssemblyIdentity->AttributePointerArray != NULL)
                RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)AssemblyIdentity->AttributePointerArray);

            AssemblyIdentity->AttributePointerArray = NewAttributePointerArray;
            AssemblyIdentity->AttributeArraySize = NewAttributeArraySize;
        }
        else
        {
            // The array's big enough; shuffle the ending part of the array down one.
            for (i=AssemblyIdentity->AttributeCount; i>LastIndexSearched; i--)
                AssemblyIdentity->AttributePointerArray[i] = AssemblyIdentity->AttributePointerArray[i-1];
        }

        AssemblyIdentity->AttributePointerArray[LastIndexSearched] = NewInternalAttribute;
        NewInternalAttribute = NULL;

        AssemblyIdentity->AttributeCount++;
    }

    AssemblyIdentity->HashDirty = TRUE;

Exit:
    if (NewInternalAttribute != NULL)
        RtlSxspDeallocateInternalAssemblyIdentityAttribute(NewInternalAttribute);

    return status;
}

NTSTATUS
RtlSxsRemoveAssemblyIdentityAttributesByOrdinal(
    ULONG Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG Ordinal,
    ULONG Count
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG AttributeCount;
    ULONG i;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG StopIndex;

    if ((Flags != 0) ||
        (AssemblyIdentity == NULL) ||
        (Count == 0))
    {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    status = RtlSxspValidateAssemblyIdentity(0, AssemblyIdentity);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    AttributeCount = AssemblyIdentity->AttributeCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;

    // We can't delete outside the bounds of [0 .. AttributeCount - 1]
    if ((Ordinal >= AssemblyIdentity->AttributeCount) ||
        (Count > AssemblyIdentity->AttributeCount) ||
        ((Ordinal + Count) > AssemblyIdentity->AttributeCount))
    {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    StopIndex = Ordinal + Count;

    // Let's get rid of them!  We're going to go through the array twice; it's somewhat
    // unnecessary but in the first run, we're going to NULL out any attribute pointers
    // that we're removing and clean up namespaces that aren't in use any more.  On the
    // second pass, we'll compress the array down.  This is somewhat wasteful, but
    // in the alternative case, we end up doing "Count" shifts down of the tail of the array.

    for (i = Ordinal; i < StopIndex; i++)
    {
        PCASSEMBLY_IDENTITY_NAMESPACE Namespace = NULL;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AttributePointerArray[i];

        // If this is the last use of this namespace, keep track of it so we can
        // clean it up.

        if ((i + 1) < AttributeCount)
        {
            // If the next attribute has a different namespace, there's some possibility
            // that this attribute was the last one that used it, so we'll delete the
            // attribute then ask to get rid of the namespace if there aren't any more
            // attributes using it.
            if (AttributePointerArray[i+1]->Namespace != InternalAttribute->Namespace)
                Namespace = InternalAttribute->Namespace;
        }

        AttributePointerArray[i] = NULL;

        RtlSxspDeallocateInternalAssemblyIdentityAttribute(InternalAttribute);

        if (Namespace != NULL)
            RtlSxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(0, AssemblyIdentity, Namespace);
    }

    for (i = StopIndex; i < AttributeCount; i++)
    {
        AttributePointerArray[i - Count] = AttributePointerArray[i];
        AttributePointerArray[i] = NULL;
    }

    AssemblyIdentity->AttributeCount -= Count;
    AssemblyIdentity->HashDirty = TRUE;

Exit:
    return status;
}

NTSTATUS
RtlSxsFindAssemblyIdentityAttribute(
    ULONG Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    ULONG *OrdinalOut,
    ULONG *CountOut OPTIONAL
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ValidateAttributeFlags = 0;
    ULONG LocateAttributeFlags = 0;
    ULONG CompareAttributesFlags = 0;
    ULONG Ordinal;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ULONG AttributeCount = 0;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG i;
    ULONG ComparisonResult;

    if (OrdinalOut != NULL)
        *OrdinalOut = 0;

    if (CountOut != NULL)
        *CountOut = 0;

    if (((Flags & ~(SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)) != 0) ||
        (AssemblyIdentity == NULL) ||
        (Attribute == NULL))
    {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Flags == 0)
        Flags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE;

    PARAMETER_CHECK(
        ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) == 0) ||
        ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE) != 0));

    PARAMETER_CHECK((Flags &
                        (SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE |
                         SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                         SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)) != 0);

    PARAMETER_CHECK(
        ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE) == 0) ||
        (((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) != 0) &&
         ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE) != 0)));

    status = RtlSxspValidateAssemblyIdentity(0, AssemblyIdentity);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    ValidateAttributeFlags = 0;

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    status = RtlSxsValidateAssemblyIdentityAttribute(ValidateAttributeFlags, Attribute);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL;

    status = RtlSxspLocateInternalAssemblyIdentityAttribute(LocateAttributeFlags, AssemblyIdentity, Attribute, &InternalAttribute, &Ordinal);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    if ((InternalAttribute == NULL) && !(Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)) {
        ASSERT(FALSE);
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    if (InternalAttribute != NULL)
    {
        if (CountOut != NULL)
        {
            // We found it, now let's look for how many matches we have.  We'll separately handle the three levels
            // of specificity:

            AttributeCount = AssemblyIdentity->AttributeCount;
            AttributePointerArray = AssemblyIdentity->AttributePointerArray;

            for (i = (Ordinal + 1); i<AttributeCount; i++)
            {
                PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE AnotherInternalAttribute = AttributePointerArray[i];

                if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
                {
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->WholeAttributeHash != InternalAttribute->WholeAttributeHash)
                        break;
                }
                else if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
                {
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->NamespaceAndNameHash != InternalAttribute->NamespaceAndNameHash)
                        break;
                }
                else
                {
                    if ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE) == 0) {
                        status = STATUS_INTERNAL_ERROR;
                        goto Exit;
                    }
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->Namespace->Hash != InternalAttribute->Namespace->Hash)
                        break;
                }

                status = RtlSxsCompareAssemblyIdentityAttributes(
                        CompareAttributesFlags,
                        Attribute,
                        &AnotherInternalAttribute->Attribute,
                        &ComparisonResult);

                if (!NT_SUCCESS(status)) {
                    goto Exit;
                }

                if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                    break;
            }

            *CountOut = i - Ordinal;
        }

        if (OrdinalOut != NULL)
            *OrdinalOut = Ordinal;
    }

Exit:
    return status;
}

VOID
RtlSxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(
    ULONG Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    )
{
    ASSERT(AssemblyIdentity != NULL);
    ASSERT(Flags == 0);

    if ((AssemblyIdentity != NULL) && (Namespace != NULL))
    {
        const ULONG AttributeCount = AssemblyIdentity->AttributeCount;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = AssemblyIdentity->AttributePointerArray;
        ULONG i;

        // We could do some sort of binary search here based on the text string of the namespace since
        // the attributes are sorted first on namespace, but my guess is that a single text comparison
        // is worth a few dozen simple pointer comparisons, so the attribute array would have to be
        // pretty darned huge for the k1*O(log n) to be faster than the k2*(n) algorithm to actually
        // dominate.
        for (i=0; i<AttributeCount; i++)
        {
            const PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AttributePointerArray[i];

            if ((InternalAttribute != NULL) &&
                (InternalAttribute->Namespace == Namespace))
                break;
        }

        if (i == AttributeCount)
        {
            // We fell through; it must be orphaned.
            const ULONG NamespaceCount = AssemblyIdentity->NamespaceCount;
            PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

            for (i=0; i<NamespaceCount; i++)
            {
                if (NamespacePointerArray[i] == Namespace)
                    break;
            }

            // This assert should only fire if the namespace isn't actually present.
            ASSERT(i != NamespaceCount);

            if (i != NamespaceCount)
            {
                ULONG j;

                for (j=(i+1); j<NamespaceCount; j++)
                    NamespacePointerArray[j-1] = NamespacePointerArray[j];

                NamespacePointerArray[NamespaceCount - 1] = NULL;

                RtlSxspDeallocateAssemblyIdentityNamespace(Namespace);

                AssemblyIdentity->NamespaceCount--;
            }
        }
    }

    AssemblyIdentity->HashDirty = TRUE;
}

NTSTATUS
RtlSxsGetAssemblyIdentityAttributeByOrdinal(
    ULONG Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG Ordinal,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttributeBuffer,
    SIZE_T *BytesWrittenOrRequired
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (AssemblyIdentityAttributeBuffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesWrittenOrRequired != NULL));
    PARAMETER_CHECK(Ordinal < AssemblyIdentity->AttributeCount);

    status = RtlSxspCopyInternalAssemblyIdentityAttributeOut(
            0,
            AssemblyIdentity->AttributePointerArray[Ordinal],
            BufferSize,
            AssemblyIdentityAttributeBuffer,
            BytesWrittenOrRequired);

    return status;
}

NTSTATUS
RtlSxsDuplicateAssemblyIdentity(
    ULONG Flags,
    PCASSEMBLY_IDENTITY Source,
    PASSEMBLY_IDENTITY *Destination
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PASSEMBLY_IDENTITY NewIdentity = NULL;
    ULONG CreateAssemblyIdentityFlags = 0;

    if (Destination != NULL)
        *Destination = NULL;

    PARAMETER_CHECK((Flags & ~(SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE | SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL)) == 0);
    PARAMETER_CHECK(((Flags & SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL) != 0) || (Source != NULL));
    PARAMETER_CHECK(Destination != NULL);

    if (Flags & SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        CreateAssemblyIdentityFlags |= SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE;

    //
    //  We depend on the Attribute field being first in the internal attribute
    //  structure below where we callously cast a pointer to an array of
    //  internal attribute pointers into a pointer to an array of attribute pointers.
    //

    ASSERT(FIELD_OFFSET(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, Attribute) == 0);

    if (Source != NULL)
    {
        status = RtlSxsCreateAssemblyIdentity(
                        CreateAssemblyIdentityFlags,
                        Source->Type,
                        &NewIdentity,
                        Source->AttributeCount,
                        (PASSEMBLY_IDENTITY_ATTRIBUTE const *) Source->AttributePointerArray);
    }

    *Destination = NewIdentity;
    NewIdentity = NULL;

    if (NewIdentity != NULL)
        RtlSxsDestroyAssemblyIdentity(NewIdentity);

    return status;
}

NTSTATUS
RtlSxsQueryAssemblyIdentityInformation(
    ULONG Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PVOID Buffer,
    SIZE_T BufferSize,
    ASSEMBLY_IDENTITY_INFORMATION_CLASS AssemblyIdentityInformationClass
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AssemblyIdentityInformationClass == AssemblyIdentityBasicInformation);

    status = RtlSxspValidateAssemblyIdentity(0, AssemblyIdentity);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    switch (AssemblyIdentityInformationClass)
    {
        case AssemblyIdentityBasicInformation: {
            PASSEMBLY_IDENTITY_BASIC_INFORMATION BasicBuffer = NULL;

            if (BufferSize < sizeof(ASSEMBLY_IDENTITY_BASIC_INFORMATION)) {
                status = STATUS_BUFFER_TOO_SMALL;
                goto Exit;
            }

            BasicBuffer = (PASSEMBLY_IDENTITY_BASIC_INFORMATION) Buffer;

            BasicBuffer->Flags = AssemblyIdentity->Flags;
            BasicBuffer->Type = AssemblyIdentity->Type;
            BasicBuffer->AttributeCount = AssemblyIdentity->AttributeCount;
            BasicBuffer->Hash = AssemblyIdentity->Hash;

            break;
        }
    }

Exit:
    return status;
}

NTSTATUS
RtlSxsEnumerateAssemblyIdentityAttributes(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN PRTLSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE EnumerationRoutine,
    IN PVOID Context
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG AttributeCount;
    ULONG i;
    ULONG ValidateFlags = 0;
    ULONG CompareFlags = 0;

    if (((Flags & ~(SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE |
                    SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME |
                    SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)) != 0) ||
        ((Flags & (SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE |
                   SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME |
                   SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)) &&
         (Attribute == NULL)) ||
        (AssemblyIdentity == NULL) ||
        (EnumerationRoutine == NULL))
    {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    status = RtlSxspValidateAssemblyIdentity(0, AssemblyIdentity);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    status = RtlSxsValidateAssemblyIdentityAttribute(ValidateFlags, Attribute);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    AttributeCount = AssemblyIdentity->AttributeCount;

    for (i=0; i<AttributeCount; i++)
    {
        PCASSEMBLY_IDENTITY_ATTRIBUTE CandidateAttribute = &AssemblyIdentity->AttributePointerArray[i]->Attribute;
        ULONG ComparisonResult = 0;

        if (CompareFlags != 0)
        {
            status = RtlSxsCompareAssemblyIdentityAttributes(
                    CompareFlags,
                    Attribute,
                    CandidateAttribute,
                    &ComparisonResult);

            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            // If they're not equal, skip it!
            if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                continue;
        }

        (*EnumerationRoutine)(
            AssemblyIdentity,
            CandidateAttribute,
            Context);
    }

Exit:
    return status;
}

NTSTATUS
RtlSxspIsInternalAssemblyIdentityAttribute(
    IN ULONG Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    OUT BOOLEAN *EqualsOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    if (EqualsOut != NULL)
        *EqualsOut = FALSE;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(Namespace != NULL || NamespaceCch == 0);
    PARAMETER_CHECK(Name != NULL || NameCch == 0);
    PARAMETER_CHECK(EqualsOut != NULL);

    if ((NamespaceCch == Attribute->Attribute.NamespaceCch) &&
        (NameCch == Attribute->Attribute.NameCch))
    {
        if ((NamespaceCch == 0) ||
            (memcmp(Attribute->Attribute.Namespace, Namespace, NamespaceCch * sizeof(WCHAR)) == 0))
        {
            if ((NameCch == 0) ||
                (memcmp(Attribute->Attribute.Name, Name, NameCch * sizeof(WCHAR)) == 0))
            {
                *EqualsOut = TRUE;
            }
        }
    }

    return status;
}


NTSTATUS
RtlSxspHashUnicodeString(
    PCWSTR String,
    SIZE_T cch,
    PULONG HashValue,
    BOOLEAN fCaseInsensitive
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG TmpHashValue = 0;

    if (HashValue != NULL)
        *HashValue = 0;

    if (HashValue == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Note that if you change this implementation, you have to have the implementation inside
    //  ntdll change to match it.  Since that's hard and will affect everyone else in the world,
    //  DON'T CHANGE THIS ALGORITHM NO MATTER HOW GOOD OF AN IDEA IT SEEMS TO BE!  This isn't the
    //  most perfect hashing algorithm, but its stability is critical to being able to match
    //  previously persisted hash values.
    //

    if (fCaseInsensitive)
    {
        while (cch-- != 0)
        {
            WCHAR Char = *String++;
            TmpHashValue = (TmpHashValue * 65599) + RtlUpcaseUnicodeChar(Char);
        }
    }
    else
    {
        while (cch-- != 0)
            TmpHashValue = (TmpHashValue * 65599) + *String++;
    }

    *HashValue = TmpHashValue;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\sxsident\encdec.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sxsasmidencdec.c

Abstract:

    Implementation of the encoding/decoding support for the assembly identity data type.

Author:

    Michael Grier (MGrier) 7/28/2000

Revision History:

--*/
#include "stdinc.h"
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>
#include "idp.h"
static const WCHAR s_rgHexChars[] = L"0123456789abcdef";

typedef struct _CHARPAIR
{
    WCHAR wchStart;
    WCHAR wchEnd;
} CHARPAIR, *PCHARPAIR;

typedef const CHARPAIR *PCCHARPAIR;

const CHARPAIR s_rgXMLBaseChar[] =
{
    { 0x0041, 0x005a },
    { 0x0061, 0x007a },
    { 0x00c0, 0x00d6 },
    { 0x00d8, 0x00f6 },
    { 0x00f8, 0x00ff },
    { 0x0100, 0x0131 },
    { 0x0134, 0x013e },
    { 0x0141, 0x0148 },
    { 0x014a, 0x017e },
    { 0x0180, 0x01c3 },
    { 0x01cd, 0x01f0 },
    { 0x01f4, 0x01f5 },
    { 0x01fa, 0x0217 },
    { 0x0250, 0x02a8 },
    { 0x02bb, 0x02c1 },
    { 0x0386, 0x0386 },
    { 0x0388, 0x038a },
    { 0x038c, 0x038c },
    { 0x038e, 0x03a1 },
    { 0x03a3, 0x03ce },
    { 0x03d0, 0x03d6 },
    { 0x03da, 0x03da },
    { 0x03dc, 0x03dc },
    { 0x03de, 0x03de },
    { 0x03e0, 0x03e0 },
    { 0x03e2, 0x03f3 },
    { 0x0401, 0x040c },
    { 0x040e, 0x044f },
    { 0x0451, 0x045c },
    { 0x045e, 0x0481 },
    { 0x0490, 0x04c4 },
    { 0x04c7, 0x04c8 },
    { 0x04cb, 0x04cc },
    { 0x04d0, 0x04eb },
    { 0x04ee, 0x04f5 },
    { 0x04f8, 0x04f9 },
    { 0x0531, 0x0556 },
    { 0x0559, 0x0559 },
    { 0x0561, 0x0586 },
    { 0x05d0, 0x05ea },
    { 0x05f0, 0x05f2 },
    { 0x0621, 0x063a },
    { 0x0641, 0x064a },
    { 0x0671, 0x06b7 },
    { 0x06ba, 0x06be },
    { 0x06c0, 0x06ce },
    { 0x06d0, 0x06d3 },
    { 0x06d5, 0x06d5 },
    { 0x06e5, 0x06e6 },
    { 0x0905, 0x0939 },
    { 0x093d, 0x093d },
    { 0x0958, 0x0961 },
    { 0x0985, 0x098c },
    { 0x098f, 0x0990 },
    { 0x0993, 0x09a8 },
    { 0x09aa, 0x09b0 },
    { 0x09b2, 0x09b2 },
    { 0x09b6, 0x09b9 },
    { 0x09dc, 0x09dd },
    { 0x09df, 0x09e1 },
    { 0x09f0, 0x09f1 },
    { 0x0a05, 0x0a0a },
    { 0x0a0f, 0x0a10 },
    { 0x0a13, 0x0a28 },
    { 0x0a2a, 0x0a30 },
    { 0x0a32, 0x0a33 },
    { 0x0a35, 0x0a36 },
    { 0x0a38, 0x0a39 },
    { 0x0a59, 0x0a5c },
    { 0x0a5e, 0x0a5e },
    { 0x0a72, 0x0a74 },
    { 0x0a85, 0x0a8b },
    { 0x0a8d, 0x0a8d },
    { 0x0a8f, 0x0a91 },
    { 0x0a93, 0x0aa8 },
    { 0x0aaa, 0x0ab0 },
    { 0x0ab2, 0x0ab3 },
    { 0x0ab5, 0x0ab9 },
    { 0x0abd, 0x0abd },
    { 0x0ae0, 0x0ae0 },
    { 0x0b05, 0x0b0c },
    { 0x0b0f, 0x0b10 },
    { 0x0b13, 0x0b28 },
    { 0x0b2a, 0x0b30 },
    { 0x0b32, 0x0b33 },
    { 0x0b36, 0x0b39 },
    { 0x0b3d, 0x0b3d },
    { 0x0b5c, 0x0b5d },
    { 0x0b5f, 0x0b61 },
    { 0x0b85, 0x0b8a },
    { 0x0b8e, 0x0b90 },
    { 0x0b92, 0x0b95 },
    { 0x0b99, 0x0b9a },
    { 0x0b9c, 0x0b9c },
    { 0x0b9e, 0x0b9f },
    { 0x0ba3, 0x0ba4 },
    { 0x0ba8, 0x0baa },
    { 0x0bae, 0x0bb5 },
    { 0x0bb7, 0x0bb9 },
    { 0x0c05, 0x0c0c },
    { 0x0c0e, 0x0c10 },
    { 0x0c12, 0x0c28 },
    { 0x0c2a, 0x0c33 },
    { 0x0c35, 0x0c39 },
    { 0x0c60, 0x0c61 },
    { 0x0c85, 0x0c8c },
    { 0x0c8e, 0x0c90 },
    { 0x0c92, 0x0ca8 },
    { 0x0caa, 0x0cb3 },
    { 0x0cb5, 0x0cb9 },
    { 0x0cde, 0x0cde },
    { 0x0ce0, 0x0ce1 },
    { 0x0d05, 0x0d0c },
    { 0x0d0e, 0x0d10 },
    { 0x0d12, 0x0d28 },
    { 0x0d2a, 0x0d39 },
    { 0x0d60, 0x0d61 },
    { 0x0e01, 0x0e2e },
    { 0x0e30, 0x0e30 },
    { 0x0e32, 0x0e33 },
    { 0x0e40, 0x0e45 },
    { 0x0e81, 0x0e82 },
    { 0x0e84, 0x0e84 },
    { 0x0e87, 0x0e88 },
    { 0x0e8a, 0x0e8a },
    { 0x0e8d, 0x0e8d },
    { 0x0e94, 0x0e97 },
    { 0x0e99, 0x0e9f },
    { 0x0ea1, 0x0ea3 },
    { 0x0ea5, 0x0ea5 },
    { 0x0ea7, 0x0ea7 },
    { 0x0eaa, 0x0eab },
    { 0x0ead, 0x0eae },
    { 0x0eb0, 0x0eb0 },
    { 0x0eb2, 0x0eb3 },
    { 0x0ebd, 0x0ebd },
    { 0x0ec0, 0x0ec4 },
    { 0x0f40, 0x0f47 },
    { 0x0f49, 0x0f69 },
    { 0x10a0, 0x10c5 },
    { 0x10d0, 0x10f6 },
    { 0x1100, 0x1100 },
    { 0x1102, 0x1103 },
    { 0x1105, 0x1107 },
    { 0x1109, 0x1109 },
    { 0x110b, 0x110c },
    { 0x110e, 0x1112 },
    { 0x113c, 0x113c },
    { 0x113e, 0x113e },
    { 0x1140, 0x1140 },
    { 0x114c, 0x114c },
    { 0x114e, 0x114e },
    { 0x1150, 0x1150 },
    { 0x1154, 0x1155 },
    { 0x1159, 0x1159 },
    { 0x115f, 0x1161 },
    { 0x1163, 0x1163 },
    { 0x1165, 0x1165 },
    { 0x1167, 0x1167 },
    { 0x1169, 0x1169 },
    { 0x116d, 0x116e },
    { 0x1172, 0x1173 },
    { 0x1175, 0x1175 },
    { 0x119e, 0x119e },
    { 0x11a8, 0x11a8 },
    { 0x11ab, 0x11ab },
    { 0x11ae, 0x11af },
    { 0x11b7, 0x11b8 },
    { 0x11ba, 0x11ba },
    { 0x11bc, 0x11c2 },
    { 0x11eb, 0x11eb },
    { 0x11f0, 0x11f0 },
    { 0x11f9, 0x11f9 },
    { 0x1e00, 0x1e9b },
    { 0x1ea0, 0x1ef9 },
    { 0x1f00, 0x1f15 },
    { 0x1f18, 0x1f1d },
    { 0x1f20, 0x1f45 },
    { 0x1f48, 0x1f4d },
    { 0x1f50, 0x1f57 },
    { 0x1f59, 0x1f59 },
    { 0x1f5b, 0x1f5b },
    { 0x1f5d, 0x1f5d },
    { 0x1f5f, 0x1f7d },
    { 0x1f80, 0x1fb4 },
    { 0x1fb6, 0x1fbc },
    { 0x1fbe, 0x1fbe },
    { 0x1fc2, 0x1fc4 },
    { 0x1fc6, 0x1fcc },
    { 0x1fd0, 0x1fd3 },
    { 0x1fd6, 0x1fdb },
    { 0x1fe0, 0x1fec },
    { 0x1ff2, 0x1ff4 },
    { 0x1ff6, 0x1ffc },
    { 0x2126, 0x2126 },
    { 0x212a, 0x212b },
    { 0x212e, 0x212e },
    { 0x2180, 0x2182 },
    { 0x3041, 0x3094 },
    { 0x30a1, 0x30fa },
    { 0x3105, 0x312c },
    { 0xac00, 0xd7a3 },
};

NTSTATUS
RtlSxsComputeAssemblyIdentityEncodedSize(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL,
    IN ULONG EncodingFormat,
    OUT SIZE_T *SizeOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T Size = 0;
    ULONG i;
    ULONG AttributeCount, NamespaceCount;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;

    if (SizeOut != NULL)
        *SizeOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(SizeOut != NULL);

    if (EncodingGroup != NULL) {
        status = STATUS_SXS_UNKNOWN_ENCODING_GROUP;
        goto Exit;
    }

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL)) {
        status = STATUS_SXS_UNKNOWN_ENCODING;
        goto Exit;
    }

    status = RtlSxspValidateAssemblyIdentity(0, AssemblyIdentity);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    AttributeCount = AssemblyIdentity->AttributeCount;
    NamespaceCount = AssemblyIdentity->NamespaceCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;
    NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

    switch (EncodingFormat)
    {
    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY:
        // First, we know we need a header.

        Size = sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);

        // Then a ULONG hash per attribute:
        Size += (AssemblyIdentity->AttributeCount * sizeof(ULONG));

        // Then a USHORT per namespace...
        Size += (AssemblyIdentity->NamespaceCount * sizeof(ULONG));

        // Then we need an attribute header per attribute:

        Size += AssemblyIdentity->AttributeCount * sizeof(ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER);

        // Then come the namespace strings...

        for (i=0; i<NamespaceCount; i++)
            Size += NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR);

        // Then we need space for each of the attributes' names and value.

        AttributePointerArray = AssemblyIdentity->AttributePointerArray;

        for (i=0; i<AttributeCount; i++)
        {
            if(AttributePointerArray[i] == NULL) {
                status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }

            Size += AttributePointerArray[i]->Attribute.NameCch * sizeof(WCHAR);
            Size += AttributePointerArray[i]->Attribute.ValueCch * sizeof(WCHAR);
        }

        // We should at least be byte aligned here...
        ASSERT((Size % 2) == 0);

        // And finally pad out to a multiple of four if we are not...
        Size = (Size + 3) & ~3;

        break;

    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL:
        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute = AttributePointerArray[i];
            BOOLEAN IsAssemblyName = FALSE;
            SIZE_T BytesThisAttribute = 0;

            if (Attribute == NULL) {
                status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }

            status = RtlSxspIsInternalAssemblyIdentityAttribute(
                                0,
                                Attribute,
                                NULL,
                                0,
                                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
                                NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME) - 1,
                                &IsAssemblyName);

            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            // It's the attribute name.  Just account for the size of the encoded value string
            status = RtlSxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
                            IsAssemblyName 
                                ? SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY |
                                    SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES
                                : 0,
                            Attribute,
                            &BytesThisAttribute);

            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            // Account for the separator character
            if (i != 0)
                Size += sizeof(WCHAR);

            Size += BytesThisAttribute;
        }

        break;
    }

    *SizeOut = Size;

Exit:
    return status;
}

NTSTATUS
RtlSxspComputeQuotedStringSize(
    IN ULONG Flags,
    IN const WCHAR *StringIn,
    IN SIZE_T Cch,
    OUT SIZE_T *BytesOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T Bytes = 0;

    if (BytesOut != NULL)
        *BytesOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(StringIn != NULL || Cch == 0);
    PARAMETER_CHECK(BytesOut != NULL);

    while (Cch != 0)
    {
        const WCHAR wch = *StringIn++;

        if (((wch >= L'A') && (wch <= L'Z')) ||
            ((wch >= L'a') && (wch <= L'z')) ||
            ((wch >= L'0') && (wch <= L'9')) ||
            (wch == L'.') ||
            (wch == L'-') ||
            (wch == L'_'))
        {
            Bytes += sizeof(WCHAR);
        }
        else
        {
            switch (wch)
            {
            case L'&':
                // &amp;
                Bytes += (5 * sizeof(WCHAR));
                break;

            case L'"':
                // &quot;
                Bytes += (6 * sizeof(WCHAR));
                break;

            case L'<':
                // &lt;
                Bytes += (4 * sizeof(WCHAR));
                break;

            case L'>':
                // &gt;
                Bytes += (4 * sizeof(WCHAR));
                break;

            case L'\'':
                // &apos;
                Bytes += (6 * sizeof(WCHAR));
                break;

            default:
                // Otherwise, it's going to be &#xn;
                if (wch < 0x10)
                    Bytes += (5 * sizeof(WCHAR));
                else if (wch < 0x100)
                    Bytes += (6 * sizeof(WCHAR));
                else if (wch < 0x1000)
                    Bytes += (7 * sizeof(WCHAR));
                else
                    Bytes += (8 * sizeof(WCHAR));
                break;
            }
        }

        Cch--;
    }

    *BytesOut = Bytes;

    return status;
}



NTSTATUS
RtlSxspDequoteString(
    IN ULONG dwFlags,
    IN PCWSTR pcwszStringIn,
    IN SIZE_T cchStringIn,
    OUT PWSTR pwszStringOut,
    OUT SIZE_T *pcchStringOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PCWSTR pcwszInputCursor = pcwszStringIn;
    PWSTR pwszOutputCursor = pwszStringOut;
    PCWSTR pcwszInputCursorEnd = pcwszStringIn + cchStringIn;
    SIZE_T cchOutputRemaining = 0;
    BOOLEAN fInsufficient = FALSE;

    PARAMETER_CHECK(dwFlags == 0);

    if (pcchStringOut != NULL)
    {
        cchOutputRemaining = *pcchStringOut;
        *pcchStringOut = 0;
    }

    if (pwszStringOut != NULL)
        pwszStringOut[0] = UNICODE_NULL;

    PARAMETER_CHECK(pcchStringOut != NULL);

    //
    // reserve one wchar for trailing NULL
    //
#define APPEND_OUTPUT_CHARACTER( toadd ) { \
        if ( cchOutputRemaining > 1 ) { \
            *pwszOutputCursor++ = (toadd); \
            cchOutputRemaining--; \
            (*pcchStringOut)++; \
        } else fInsufficient = TRUE; \
    }

#define CONTAINS_TAG(tag) (RtlSxspCompareStrings(pcwszInputCursor, cchToNextSemicolon, (tag), NUMBER_OF(tag)-1, FALSE) == 0)

#define REPLACE_TAG( tag, newchar ) if ( CONTAINS_TAG(tag) ) { APPEND_OUTPUT_CHARACTER(newchar) }

    //
    // Zing through the input string until there's nothing left
    //
    while ((pcwszInputCursor < pcwszInputCursorEnd) && (!fInsufficient))
    {
        const WCHAR wchCurrent = *pcwszInputCursor;

        // Something we know and love?
        if (wchCurrent == L'&')
        {
            SIZE_T cchToNextSemicolon;
            PCWSTR pcwszSemicolon = NULL;

            pcwszInputCursor++;
            cchToNextSemicolon = RtlStringComplimentSpan(
                pcwszInputCursor,
                pcwszInputCursorEnd,
                L";");
            pcwszSemicolon = pcwszInputCursor + cchToNextSemicolon;

            REPLACE_TAG(L"amp", L'&')
            else REPLACE_TAG(L"quot", L'"')
            else REPLACE_TAG(L"lt", L'<')
            else REPLACE_TAG(L"gt", L'>')
            else REPLACE_TAG(L"apos", L'\'')
            // This might be an encoded character...
            else if ( cchToNextSemicolon >= 2 )
            {
                BOOLEAN fIsHexString = FALSE;
                WCHAR wchReplacement = 0;

                // The only non-chunk think accepted is the # character
                PARAMETER_CHECK(*pcwszInputCursor == L'#');

                // which means we've skipped one
                pcwszInputCursor++;

                fIsHexString = (*pcwszInputCursor == L'x') || (*pcwszInputCursor == 'X');
                if (fIsHexString) {
                    pcwszInputCursor++;
                }

                while ( pcwszInputCursor != pcwszSemicolon )
                {
                    if ( fIsHexString )
                    {
                        wchReplacement <<= 4;
                        switch ( *pcwszInputCursor++ ) {
                        case L'0' : break;
                        case L'1' : wchReplacement += 0x1; break;
                        case L'2' : wchReplacement += 0x2; break;
                        case L'3' : wchReplacement += 0x3; break;
                        case L'4' : wchReplacement += 0x4; break;
                        case L'5' : wchReplacement += 0x5; break;
                        case L'6' : wchReplacement += 0x6; break;
                        case L'7' : wchReplacement += 0x7; break;
                        case L'8' : wchReplacement += 0x8; break;
                        case L'9' : wchReplacement += 0x9; break;
                        case L'a': case L'A': wchReplacement += 0xA; break;
                        case L'b': case L'B': wchReplacement += 0xB; break;
                        case L'c': case L'C': wchReplacement += 0xC; break;
                        case L'd': case L'D': wchReplacement += 0xD; break;
                        case L'e': case L'E': wchReplacement += 0xE; break;
                        case L'f': case L'F': wchReplacement += 0xF; break;
                        default:
                            PARAMETER_CHECK(FALSE && L"wchReplacement contains a non-hex digit");
                            break;
                        }
                    }
                    else
                    {
                        wchReplacement *= 10;
                        switch ( *pcwszInputCursor++ ) {
                        case L'0' : break;
                        case L'1' : wchReplacement += 0x1; break;
                        case L'2' : wchReplacement += 0x2; break;
                        case L'3' : wchReplacement += 0x3; break;
                        case L'4' : wchReplacement += 0x4; break;
                        case L'5' : wchReplacement += 0x5; break;
                        case L'6' : wchReplacement += 0x6; break;
                        case L'7' : wchReplacement += 0x7; break;
                        case L'8' : wchReplacement += 0x8; break;
                        case L'9' : wchReplacement += 0x9; break;
                        default:
                            PARAMETER_CHECK(FALSE && "wchReplacement contains a non-decimal digit");
                            break;
                        }
                    }
                }

                APPEND_OUTPUT_CHARACTER(wchReplacement);
            }

            if (!fInsufficient) 
                pcwszInputCursor = pcwszSemicolon + 1;
        }
        // Otherwise, simply copy the character to the output string
        else
        {
            APPEND_OUTPUT_CHARACTER(wchCurrent);
            if (!fInsufficient) 
                pcwszInputCursor++;
        }
    }

    if (fInsufficient) {
        status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    pwszStringOut[*pcchStringOut] = L'\0';

Exit:
    return status;
}

NTSTATUS
RtlSxspQuoteString(
    IN ULONG Flags,
    IN const WCHAR *StringIn,
    IN SIZE_T Cch,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT SIZE_T *BytesWrittenOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    WCHAR *Cursor;
    SIZE_T BytesWritten = 0;
    SIZE_T BytesLeft = BufferSize;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(StringIn != NULL || Cch == 0);
    PARAMETER_CHECK(Buffer != NULL || BufferSize == 0);

    Cursor = (WCHAR *) Buffer;
    BytesWritten = 0;

    while (Cch != 0)
    {
        const WCHAR wch = *StringIn++;

        if (((wch >= L'A') && (wch <= L'Z')) ||
            ((wch >= L'a') && (wch <= L'z')) ||
            ((wch >= L'0') && (wch <= L'9')) ||
            (wch == L'.') ||
            (wch == L'-') ||
            (wch == L'_'))
        {
            if (BytesLeft < sizeof(WCHAR)) {
                status = STATUS_BUFFER_TOO_SMALL;
                goto Exit;
            }

            *Cursor++ = wch;
            BytesLeft -= sizeof(WCHAR);
            BytesWritten += sizeof(WCHAR);
        }
        else
        {

#define HANDLE_CASE(_wch, _wstr) \
            case _wch: \
            { \
            ULONG i; \
            if (BytesLeft < (sizeof(_wstr) - sizeof(WCHAR))) {\
            status = STATUS_BUFFER_TOO_SMALL; goto Exit; }\
            for (i=0; i<(NUMBER_OF(_wstr) - 1); i++) \
                *Cursor++ = _wstr[i]; \
            BytesLeft -= (sizeof(_wstr) - sizeof(WCHAR)); \
            BytesWritten += (sizeof(_wstr) - sizeof(WCHAR)); \
            break; \
            }

            switch (wch)
            {
            HANDLE_CASE(L'"', L"&quot;")
            HANDLE_CASE(L'&', L"&amp;")
            HANDLE_CASE(L'<', L"&lt;")
            HANDLE_CASE(L'>', L"&gt;")
            HANDLE_CASE(L'\'', L"&apos;")

            default:
                if (wch < 0x10)
                {
                    if (BytesLeft < (5 * sizeof(WCHAR))) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        goto Exit;
                    }

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[wch];
                    *Cursor++ = L';';

                    BytesWritten += (5 * sizeof(WCHAR));
                    BytesLeft -= (5 * sizeof(WCHAR));
                }
                else if (wch < 0x100)
                {
                    if (BytesLeft < (6 * sizeof(WCHAR))) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        goto Exit;
                    }

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (6 * sizeof(WCHAR));
                    BytesLeft -= (6 * sizeof(WCHAR));
                }
                else if (wch < 0x1000)
                {
                    if (BytesLeft < (7 * sizeof(WCHAR))) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        goto Exit;
                    }

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 8) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (7 * sizeof(WCHAR));
                    BytesLeft -= (7 * sizeof(WCHAR));
                }
                else
                {
                    if (wch > 0xffff) {
                        status = STATUS_INTERNAL_ERROR;
                        goto Exit;
                    }

                    if (BytesLeft < (8 * sizeof(WCHAR))) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        goto Exit;
                    }

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 12) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 8) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (8 * sizeof(WCHAR));
                    BytesLeft -= (8 * sizeof(WCHAR));
                }

                break;
            }

        }

        Cch--;
    }

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = BytesWritten;

Exit:
    return status;
}

NTSTATUS
RtlSxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
    IN ULONG Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT SIZE_T *BytesOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T Bytes = 0;
    SIZE_T BytesTemp = 0;

    if (BytesOut != NULL)
        *BytesOut = 0;

    PARAMETER_CHECK((Flags & ~(
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY |
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES)) == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(BytesOut != NULL);

    Bytes = 0;
    if ((Flags & SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY) == 0)
    {
        if (Attribute->Attribute.NamespaceCch != 0)
        {
            // Figure out the ns:n= part
            status = RtlSxspComputeQuotedStringSize(0, Attribute->Attribute.Namespace, Attribute->Attribute.NamespaceCch, &BytesTemp);
            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            Bytes += BytesTemp;
            Bytes += sizeof(WCHAR); // the ":"
        }

        status = RtlSxspComputeQuotedStringSize(0, Attribute->Attribute.Name, Attribute->Attribute.NameCch, &BytesTemp);
        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        Bytes += BytesTemp;
        Bytes += sizeof(WCHAR); // the "="
    }

    status = RtlSxspComputeQuotedStringSize(0, Attribute->Attribute.Value, Attribute->Attribute.ValueCch, &BytesTemp);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    Bytes += BytesTemp;

    if ((Flags & SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES) == 0)
        Bytes += 2 * sizeof(WCHAR); // the beginning and ending quotes

    *BytesOut = Bytes;

Exit:
    return status;
}

NTSTATUS
RtlSxspEncodeInternalAssemblyIdentityAttributeAsText(
    IN ULONG Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PVOID Buffer,
    SIZE_T *BytesWrittenOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T BytesWritten = 0;
    SIZE_T BytesLeft = 0;
    SIZE_T BytesThisSegment;
    WCHAR *Cursor;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK((Buffer != NULL) || (BufferSize == 0));

    BytesWritten = 0;
    BytesLeft = BufferSize;
    Cursor = (PWSTR)Buffer;

    if (Attribute->Attribute.NamespaceCch != 0)
    {
        status = RtlSxspQuoteString(0, Attribute->Namespace->Namespace, Attribute->Namespace->NamespaceCch, BytesLeft, Cursor, &BytesThisSegment);
        if (!NT_SUCCESS(status)) {
            goto Exit;
        }


        if (BytesThisSegment > BytesLeft) {
            status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
        BytesLeft -= BytesThisSegment;
        BytesWritten += BytesThisSegment;

        if (BytesLeft < sizeof(WCHAR)) {
            status = STATUS_BUFFER_TOO_SMALL;
            goto Exit;
        }

        *Cursor++ = L':';
        BytesLeft -= sizeof(WCHAR);
        BytesWritten += sizeof(WCHAR);
    }

    status = RtlSxspQuoteString(0, Attribute->Attribute.Name, Attribute->Attribute.NameCch, BytesLeft, Cursor, &BytesThisSegment);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    if (BytesThisSegment > BytesLeft) {
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
    BytesLeft -= BytesThisSegment;
    BytesWritten += BytesThisSegment;

    if (BytesLeft < (2 * sizeof(WCHAR))) {
        status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    *Cursor++ = L'=';
    *Cursor++ = L'"';
    BytesLeft -= (2 * sizeof(WCHAR));
    BytesWritten += (2 * sizeof(WCHAR));

    status = RtlSxspQuoteString(0, Attribute->Attribute.Value, Attribute->Attribute.ValueCch, BytesLeft, Cursor, &BytesThisSegment);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    if (BytesThisSegment > BytesLeft) {
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
    BytesLeft -= BytesThisSegment;
    BytesWritten += BytesThisSegment;

    if (BytesLeft < sizeof(WCHAR)) {
        status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    *Cursor++ = L'"';
    BytesLeft -= sizeof(WCHAR);
    BytesWritten += sizeof(WCHAR);

    *BytesWrittenOut = BytesWritten;

Exit:
    return status;
}

NTSTATUS
RtlSxspEncodeAssemblyIdentityTextually(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT SIZE_T *BytesWrittenOut)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG AttributeCount, NamespaceCount;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes;
    PCASSEMBLY_IDENTITY_NAMESPACE *Namespaces;
    ULONG i;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NameInternalAttribute = NULL;
    SIZE_T BytesLeft;
    SIZE_T BytesWritten;
    PVOID Cursor;
    SIZE_T TempBytesWritten;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(BufferSize != 0);
    PARAMETER_CHECK(Buffer != NULL);
    PARAMETER_CHECK(BytesWrittenOut != NULL);

    Cursor = Buffer;
    BytesLeft = BufferSize;
    BytesWritten = 0;

    // The root assembly identity is actually totally empty, so we'll short-circuit that case.
    AttributeCount = AssemblyIdentity->AttributeCount;
    if (AttributeCount != 0)
    {
        NamespaceCount = AssemblyIdentity->NamespaceCount;
        Attributes = AssemblyIdentity->AttributePointerArray;
        Namespaces = AssemblyIdentity->NamespacePointerArray;

        // First, let's look for the "name" attribute.
        Attribute.Flags = 0;
        Attribute.Namespace = NULL;
        Attribute.NamespaceCch = 0;
        Attribute.Name = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME;
        Attribute.NameCch = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME) - 1;

        status = RtlSxspLocateInternalAssemblyIdentityAttribute(
                SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME,
                AssemblyIdentity,
                &Attribute,
                &NameInternalAttribute,
                NULL);
        if (!NT_SUCCESS(status)) {
            goto Exit;
        } else if (NameInternalAttribute == NULL) {
            status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        status = RtlSxspQuoteString(0, NameInternalAttribute->Attribute.Value, NameInternalAttribute->Attribute.ValueCch, BytesLeft, Cursor, &TempBytesWritten);
        if (!NT_SUCCESS(status)) {
            goto Exit;
        }
        else if (TempBytesWritten > BytesLeft) {
            status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + TempBytesWritten);
        BytesLeft -= TempBytesWritten;
        BytesWritten += TempBytesWritten;

        for (i=0; i<AttributeCount; i++)
        {
            // Skip the standard "name" attribute
            if (Attributes[i] == NameInternalAttribute)
                continue;

            if (BytesLeft < sizeof(WCHAR)) {
                status = STATUS_BUFFER_TOO_SMALL;
                goto Exit;
            }

            *((WCHAR *) Cursor) = L',';
            Cursor = (PVOID) (((ULONG_PTR) Cursor) + sizeof(WCHAR));
            BytesLeft -= sizeof(WCHAR);
            BytesWritten += sizeof(WCHAR);

            status = RtlSxspEncodeInternalAssemblyIdentityAttributeAsText(0, Attributes[i], BytesLeft, Cursor, &TempBytesWritten);
            if (!NT_SUCCESS(status)) {
                goto Exit;
            }
            else if (TempBytesWritten > BytesLeft) {
                status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }

            Cursor = (PVOID) (((ULONG_PTR) Cursor) + TempBytesWritten);
            BytesLeft -= TempBytesWritten;
            BytesWritten += TempBytesWritten;
        }
    }

    *BytesWrittenOut = BytesWritten;

Exit:
    return status;
}

#define IFNTFAILED_EXIT(q) do { status = (q); if (!NT_SUCCESS(status)) { goto Exit; } } while (0)


NTSTATUS
RtlSxsEncodeAssemblyIdentity(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    OUT PVOID Buffer,
    OUT SIZE_T *BytesWrittenOrRequired
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T TotalSize = 0;
    PVOID Cursor = NULL;
    SIZE_T i;
    PENCODED_ASSEMBLY_IDENTITY_HEADER EncodedAssemblyIdentityHeader = NULL;
    PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER EncodedAssemblyIdentityAttributeHeader = NULL;
    ULONG *TempULONGArrayPointer;
    SIZE_T BytesWritten = 0;
    ULONG AttributeCount, NamespaceCount;

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (Buffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesWrittenOrRequired != NULL));

    if (EncodingGroup != NULL) {
        status = STATUS_SXS_UNKNOWN_ENCODING_GROUP;
        goto Exit;
    }

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL))
    {
        status = STATUS_SXS_UNKNOWN_ENCODING_GROUP;
        goto Exit;
    }

    IFNTFAILED_EXIT(RtlSxspValidateAssemblyIdentity(0, AssemblyIdentity));
    IFNTFAILED_EXIT(RtlSxsComputeAssemblyIdentityEncodedSize(0, AssemblyIdentity, EncodingGroup, EncodingFormat, &TotalSize));

    if (TotalSize > BufferSize)
    {
        if (BytesWrittenOrRequired != NULL)
            *BytesWrittenOrRequired = TotalSize;

        status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    AttributeCount = AssemblyIdentity->AttributeCount;
    NamespaceCount = AssemblyIdentity->NamespaceCount;

    //
    //  Let's start filling it in.
    //

    switch (EncodingFormat)
    {
    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY:
        BytesWritten = 0;
        Cursor = Buffer;

        EncodedAssemblyIdentityHeader = (PENCODED_ASSEMBLY_IDENTITY_HEADER) Cursor;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER));
        BytesWritten += sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);

        EncodedAssemblyIdentityHeader->HeaderSize = sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);
        EncodedAssemblyIdentityHeader->Magic = ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC;
        EncodedAssemblyIdentityHeader->TotalSize = (ULONG)TotalSize;
        // turn off any flags not relevant to persisted state
        EncodedAssemblyIdentityHeader->Type = AssemblyIdentity->Type;
        EncodedAssemblyIdentityHeader->Flags = AssemblyIdentity->Flags & ~(ASSEMBLY_IDENTITY_FLAG_FROZEN);
        EncodedAssemblyIdentityHeader->EncodingFlags = 0;
        EncodedAssemblyIdentityHeader->AttributeCount = AttributeCount;
        EncodedAssemblyIdentityHeader->NamespaceCount = NamespaceCount;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero1 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero2 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero3 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero4 = 0;

        TempULONGArrayPointer = (ULONG *) Cursor;
        Cursor = (PVOID) (TempULONGArrayPointer + AttributeCount);
        BytesWritten += (AttributeCount * sizeof(ULONG));

        for (i=0; i<AttributeCount; i++)
            TempULONGArrayPointer[i] = AssemblyIdentity->AttributePointerArray[i]->WholeAttributeHash;

        // sort 'em...
        qsort(TempULONGArrayPointer, AttributeCount, sizeof(ULONG), &RtlSxspCompareULONGsForQsort);

        TempULONGArrayPointer = (ULONG *) Cursor;
        Cursor = (PVOID) (TempULONGArrayPointer + NamespaceCount);
        BytesWritten += (sizeof(ULONG) * NamespaceCount);

        for (i=0; i<NamespaceCount; i++)
            TempULONGArrayPointer[i] = (ULONG)(AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch);

        EncodedAssemblyIdentityAttributeHeader = (PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER) Cursor;
        Cursor = (PVOID) (EncodedAssemblyIdentityAttributeHeader + AttributeCount);
        BytesWritten += (AttributeCount * sizeof(ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER));

        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AssemblyIdentity->AttributePointerArray[i];
            ULONG NamespaceIndex;

            // Totally gross linear search to determine the namespace index.  Fortunately the common case
            // will be a single namespace for all attributes.
            for (NamespaceIndex = 0; NamespaceIndex < NamespaceCount; NamespaceIndex++)
            {
                if (AssemblyIdentity->NamespacePointerArray[NamespaceIndex] == InternalAttribute->Namespace)
                    break;
            }

            // If this assert fires, the attribute refers to a namespace that's not in the identity; bad!
            if((InternalAttribute->Namespace != NULL) && (NamespaceIndex >= NamespaceCount)) {
                status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }

            EncodedAssemblyIdentityAttributeHeader[i].NamespaceIndex = NamespaceIndex + 1;
            EncodedAssemblyIdentityAttributeHeader[i].NameCch = (ULONG)(InternalAttribute->Attribute.NameCch);
            EncodedAssemblyIdentityAttributeHeader[i].ValueCch = (ULONG)(InternalAttribute->Attribute.ValueCch);
        }

        // so much for the fixed length stuff; write the namespaces.
        for (i=0; i<NamespaceCount; i++)
        {
            PWSTR psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + (AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR)));

            BytesWritten += (AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR));

            memcpy(
                psz,
                AssemblyIdentity->NamespacePointerArray[i]->Namespace,
                AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR));
        }

        // And the attributes...
        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AssemblyIdentity->AttributePointerArray[i];
            PWSTR psz;

            psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + (InternalAttribute->Attribute.NameCch * sizeof(WCHAR)));
            BytesWritten += (InternalAttribute->Attribute.NameCch * sizeof(WCHAR));

            memcpy(
                psz,
                InternalAttribute->Attribute.Name,
                InternalAttribute->Attribute.NameCch * sizeof(WCHAR));

            psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + InternalAttribute->Attribute.ValueCch * sizeof(WCHAR));
            BytesWritten += InternalAttribute->Attribute.ValueCch * sizeof(WCHAR);

            memcpy(
                psz,
                InternalAttribute->Attribute.Value,
                InternalAttribute->Attribute.ValueCch * sizeof(WCHAR));
        }

        if ((BytesWritten % 4) != 0) {
            ASSERT((BytesWritten % 4) == sizeof(USHORT));

            *((USHORT *) Cursor) = 0;
            BytesWritten += sizeof(USHORT);
        }

        break;

    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL:
        IFNTFAILED_EXIT(RtlSxspEncodeAssemblyIdentityTextually(0, AssemblyIdentity, BufferSize, Buffer, &BytesWritten));
        break;
    }

    if (BytesWritten != TotalSize) {
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = BytesWritten;

Exit:
    return status;
}

NTSTATUS
RtlSxsDecodeAssemblyIdentity(
    ULONG Flags,
    IN const GUID *EncodingGroup,
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    IN const VOID *Buffer,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentityOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PCENCODED_ASSEMBLY_IDENTITY_HEADER EncodedAssemblyIdentityHeader = NULL;
    PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER EncodedAssemblyIdentityAttributeHeader = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    ULONG AttributeCount = 0;
    ULONG NamespaceCount = 0;
    ULONG AttributeArraySize = 0;
    ULONG NamespaceArraySize = 0;
    ULONG i;
    const ULONG *NamespaceLengthArray = NULL;
    const ULONG *AttributeHashArray = NULL;
    const WCHAR *UnicodeStringArray = NULL;

    if (AssemblyIdentityOut != NULL)
        *AssemblyIdentityOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)) == 0);
    PARAMETER_CHECK(BufferSize >= sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER));
    PARAMETER_CHECK(Buffer != NULL);
    PARAMETER_CHECK(AssemblyIdentityOut != NULL);

    if (EncodingGroup != NULL) {
        status = STATUS_SXS_UNKNOWN_ENCODING_GROUP;
        goto Exit;
    }

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL)) {

        status = STATUS_SXS_UNKNOWN_ENCODING;
        goto Exit;
    }

    EncodedAssemblyIdentityHeader = (PCENCODED_ASSEMBLY_IDENTITY_HEADER) Buffer;

    if ((EncodedAssemblyIdentityHeader->HeaderSize != sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER)) ||
        (EncodedAssemblyIdentityHeader->Magic != ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC) ||
        (EncodedAssemblyIdentityHeader->TotalSize > BufferSize) ||
        (EncodedAssemblyIdentityHeader->Flags != 0) ||
        ((EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_DEFINITION) &&
         (EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_REFERENCE) &&
         (EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_WILDCARD)) ||
        (EncodedAssemblyIdentityHeader->EncodingFlags != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero1 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero2 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero3 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero4 != 0)) {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    AssemblyIdentity = (PASSEMBLY_IDENTITY)RtlAllocateHeap(
        RtlProcessHeap(), 
        HEAP_ZERO_MEMORY, 
        sizeof(ASSEMBLY_IDENTITY));

    if (AssemblyIdentity == NULL) {
        status = STATUS_NO_MEMORY;
        goto Exit;
    }

    NamespaceCount = EncodedAssemblyIdentityHeader->NamespaceCount;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        NamespaceArraySize = NamespaceCount;
    }
    else if (NamespaceCount == 0)
    {
        NamespaceArraySize = 8;
    }
    else
    {
        NamespaceArraySize = (NamespaceCount + 7) & ~7;
    }

    if (NamespaceArraySize != 0)
    {
        NamespacePointerArray = (PCASSEMBLY_IDENTITY_NAMESPACE*)RtlAllocateHeap(
            RtlProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(PCASSEMBLY_IDENTITY_NAMESPACE) * NamespaceArraySize);

        for (i=0; i<NamespaceArraySize; i++)
            NamespacePointerArray[i] = NULL;
    }

    AttributeCount = EncodedAssemblyIdentityHeader->AttributeCount;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        // If we're going to freeze, just perform an exact allocation.
        AttributeArraySize = AttributeCount;
    }
    else if (AttributeCount == 0)
    {
        AttributeArraySize = 8;
    }
    else
    {
        AttributeArraySize = (AttributeCount + 7) & ~7;
    }

    if (AttributeArraySize != 0)
    {
        AttributePointerArray = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE*)RtlAllocateHeap(
            RtlProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) * AttributeArraySize);

        for (i=0; i<AttributeArraySize; i++)
            AttributePointerArray[i] = NULL;
    }

    AttributeHashArray = (const ULONG *) (EncodedAssemblyIdentityHeader + 1);
    NamespaceLengthArray = (const ULONG *) (AttributeHashArray + AttributeCount);
    EncodedAssemblyIdentityAttributeHeader = (PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER) (NamespaceLengthArray + NamespaceCount);
    UnicodeStringArray = (const WCHAR *) (EncodedAssemblyIdentityAttributeHeader + AttributeCount);

    // Start by building up those namespaces...
    for (i=0; i<NamespaceCount; i++)
    {
        ULONG NamespaceHash = 0;
        IFNTFAILED_EXIT(RtlSxspHashUnicodeString(UnicodeStringArray, NamespaceLengthArray[i], &NamespaceHash, FALSE));
        IFNTFAILED_EXIT(RtlSxspAllocateAssemblyIdentityNamespace(0, UnicodeStringArray, NamespaceLengthArray[i], NamespaceHash, &NamespacePointerArray[i]));
        UnicodeStringArray += NamespaceLengthArray[i];
    }

    if (AttributeCount != 0)
    {
        // and now those attributes...
        for (i=0; i<AttributeCount; i++)
        {
            const ULONG NamespaceIndex = EncodedAssemblyIdentityAttributeHeader[i].NamespaceIndex;
            const ULONG NameCch = EncodedAssemblyIdentityAttributeHeader[i].NameCch;
            const ULONG ValueCch = EncodedAssemblyIdentityAttributeHeader[i].ValueCch;
            const WCHAR * const Name = UnicodeStringArray;
            const WCHAR * const Value = &UnicodeStringArray[NameCch];

            UnicodeStringArray = &Value[ValueCch];

            IFNTFAILED_EXIT(RtlSxspAllocateInternalAssemblyIdentityAttribute(
                    0,
                    NamespacePointerArray[NamespaceIndex],
                    Name,
                    NameCch,
                    Value,
                    ValueCch,
                    &AttributePointerArray[i]));
        }

        // sort 'em...
        qsort((PVOID) AttributePointerArray, AttributeCount, sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE), &RtlSxspCompareInternalAttributesForQsort);
    }

    IFNTFAILED_EXIT(RtlSxspHashInternalAssemblyIdentityAttributes(0, AttributeCount, AttributePointerArray, &AssemblyIdentity->Hash));

    AssemblyIdentity->Flags = 0;
    AssemblyIdentity->Type = EncodedAssemblyIdentityHeader->Type;
    AssemblyIdentity->InternalFlags = ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION | ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION;
    AssemblyIdentity->AttributePointerArray = AttributePointerArray;
    AssemblyIdentity->AttributeCount = AttributeCount;
    AssemblyIdentity->AttributeArraySize = AttributeArraySize;
    AssemblyIdentity->NamespacePointerArray = NamespacePointerArray;
    AssemblyIdentity->NamespaceCount = NamespaceCount;
    AssemblyIdentity->NamespaceArraySize = NamespaceArraySize;

    AttributePointerArray = NULL;
    NamespacePointerArray = NULL;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

Exit:
    //
    // REVIEW: Should this be an SxsDestroyAssemblyIdentity
    //
    if (AssemblyIdentity != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)AssemblyIdentity);

    if ((AttributeCount != 0) && (AttributePointerArray != NULL))
    {
        for (i=0; i<AttributeCount; i++)
        {
            if (AttributePointerArray[i] != NULL)
            {
                RtlSxspDeallocateInternalAssemblyIdentityAttribute(AttributePointerArray[i]);
                AttributePointerArray[i] = NULL;
            }
        }

        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)AttributePointerArray );
    }

    if ((NamespaceCount != 0) && (NamespacePointerArray != NULL))
    {
        for (i=0; i<NamespaceCount; i++)
        {
            if (NamespacePointerArray[i] != NULL)
            {
                RtlSxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);
                NamespacePointerArray[i] = NULL;
            }
        }

        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)NamespacePointerArray);
    }

    return status;
}

int __cdecl
RtlSxspCharPairArrayComparisonCallback(
    const void *pelem1,
    const void *pelem2
    )
{
    PCCHARPAIR pcp1 = (PCCHARPAIR) pelem1;
    PCCHARPAIR pcp2 = (PCCHARPAIR) pelem2;

    if (pcp1->wchEnd < pcp2->wchStart)
        return -1;

    if (pcp2->wchEnd < pcp1->wchStart)
        return 1;

    return 0;
}

BOOLEAN
RtlSxspIsCharInCharPairArray(
    WCHAR wch,
    PCCHARPAIR prg,
    SIZE_T n
    )
{
    CHARPAIR cp = { wch, wch };
    return (bsearch(&cp, prg, n, sizeof(CHARPAIR), &RtlSxspCharPairArrayComparisonCallback) != NULL);
}

BOOLEAN
RtlSxspIsCharXMLBaseChar(
    WCHAR wch
    )
{
    return RtlSxspIsCharInCharPairArray(wch, s_rgXMLBaseChar, NUMBER_OF(s_rgXMLBaseChar));
}

BOOLEAN
RtlSxspIsCharXMLIdeographic(
    WCHAR wch
    )
{
    return (
        (wch >= 0x4e00 && wch <= 0x9fa5) ||
        (wch == 0x3007) ||
        (wch >= 0x3021 && wch <= 0x3029)
        );
}

BOOLEAN
RtlSxspIsCharXMLLetter(
    WCHAR wch
    )
{
    return
        RtlSxspIsCharXMLBaseChar(wch) ||
        RtlSxspIsCharXMLIdeographic(wch);
}

BOOLEAN
RtlSxspIsCharXMLCombiningChar(
    WCHAR wch
    )
{
    return (
        (wch >= 0x0300 && wch <= 0x0345) ||
        (wch >= 0x0360 && wch <= 0x0361) ||
        (wch >= 0x0483 && wch <= 0x0486) ||
        (wch >= 0x0591 && wch <= 0x05a1) ||
        (wch >= 0x05a3 && wch <= 0x05b9) ||
        (wch >= 0x05bb && wch <= 0x05bd) ||
        wch == 0x05bf ||
        (wch >= 0x05c1 && wch <= 0x05c2) ||
        wch == 0x05c4 ||
        (wch >= 0x064b && wch <= 0x0652) ||
        wch == 0x0670 ||
        (wch >= 0x06d6 && wch <= 0x06dc) ||
        (wch >= 0x06dd && wch <= 0x06df) ||
        (wch >= 0x06e0 && wch <= 0x06e4) ||
        (wch >= 0x06e7 && wch <= 0x06e8) ||
        (wch >= 0x06ea && wch <= 0x06ed) ||
        (wch >= 0x0901 && wch <= 0x0903) ||
        wch == 0x093c ||
        (wch >= 0x093e && wch <= 0x094c) ||
        wch == 0x094d ||
        (wch >= 0x0951 && wch <= 0x0954) ||
        (wch >= 0x0962 && wch <= 0x0963) ||
        (wch >= 0x0981 && wch <= 0x0983) ||
        wch == 0x09bc ||
        wch == 0x09be ||
        wch == 0x09bf ||
        (wch >= 0x09c0 && wch <= 0x09c4) ||
        (wch >= 0x09c7 && wch <= 0x09c8) ||
        (wch >= 0x09cb && wch <= 0x09cd) ||
        wch == 0x09d7 ||
        (wch >= 0x09e2 && wch <= 0x09e3) ||
        wch == 0x0a02 ||
        wch == 0x0a3c ||
        wch == 0x0a3e ||
        wch == 0x0a3f ||
        (wch >= 0x0a40 && wch <= 0x0a42) ||
        (wch >= 0x0a47 && wch <= 0x0a48) ||
        (wch >= 0x0a4b && wch <= 0x0a4d) ||
        (wch >= 0x0a70 && wch <= 0x0a71) ||
        (wch >= 0x0a81 && wch <= 0x0a83) ||
        wch == 0x0abc ||
        (wch >= 0x0abe && wch <= 0x0ac5) ||
        (wch >= 0x0ac7 && wch <= 0x0ac9) ||
        (wch >= 0x0acb && wch <= 0x0acd) ||
        (wch >= 0x0b01 && wch <= 0x0b03) ||
        wch == 0x0b3c ||
        (wch >= 0x0b3e && wch <= 0x0b43) ||
        (wch >= 0x0b47 && wch <= 0x0b48) ||
        (wch >= 0x0b4b && wch <= 0x0b4d) ||
        (wch >= 0x0b56 && wch <= 0x0b57) ||
        (wch >= 0x0b82 && wch <= 0x0b83) ||
        (wch >= 0x0bbe && wch <= 0x0bc2) ||
        (wch >= 0x0bc6 && wch <= 0x0bc8) ||
        (wch >= 0x0bca && wch <= 0x0bcd) ||
        wch == 0x0bd7 ||
        (wch >= 0x0c01 && wch <= 0x0c03) ||
        (wch >= 0x0c3e && wch <= 0x0c44) ||
        (wch >= 0x0c46 && wch <= 0x0c48) ||
        (wch >= 0x0c4a && wch <= 0x0c4d) ||
        (wch >= 0x0c55 && wch <= 0x0c56) ||
        (wch >= 0x0c82 && wch <= 0x0c83) ||
        (wch >= 0x0cbe && wch <= 0x0cc4) ||
        (wch >= 0x0cc6 && wch <= 0x0cc8) ||
        (wch >= 0x0cca && wch <= 0x0ccd) ||
        (wch >= 0x0cd5 && wch <= 0x0cd6) ||
        (wch >= 0x0d02 && wch <= 0x0d03) ||
        (wch >= 0x0d3e && wch <= 0x0d43) ||
        (wch >= 0x0d46 && wch <= 0x0d48) ||
        (wch >= 0x0d4a && wch <= 0x0d4d) ||
        wch == 0x0d57 ||
        wch == 0x0e31 ||
        (wch >= 0x0e34 && wch <= 0x0e3a) ||
        (wch >= 0x0e47 && wch <= 0x0e4e) ||
        wch == 0x0eb1 ||
        (wch >= 0x0eb4 && wch <= 0x0eb9) ||
        (wch >= 0x0ebb && wch <= 0x0ebc) ||
        (wch >= 0x0ec8 && wch <= 0x0ecd) ||
        (wch >= 0x0f18 && wch <= 0x0f19) ||
        wch == 0x0f35 ||
        wch == 0x0f37 ||
        wch == 0x0f39 ||
        wch == 0x0f3e ||
        wch == 0x0f3f ||
        (wch >= 0x0f71 && wch <= 0x0f84) ||
        (wch >= 0x0f86 && wch <= 0x0f8b) ||
        (wch >= 0x0f90 && wch <= 0x0f95) ||
        wch == 0x0f97 ||
        (wch >= 0x0f99 && wch <= 0x0fad) ||
        (wch >= 0x0fb1 && wch <= 0x0fb7) ||
        wch == 0x0fb9 ||
        (wch >= 0x20d0 && wch <= 0x20dc) ||
        wch == 0x20e1 ||
        (wch >= 0x302a && wch <= 0x302f) ||
        wch == 0x3099 ||
        wch == 0x309a
        );
}

BOOLEAN
RtlSxspIsCharXMLDigit(
    WCHAR wch
    )
{
    return (
        (wch >= 0x0030 && wch <= 0x0039) ||
        (wch >= 0x0660 && wch <= 0x0669) ||
        (wch >= 0x06f0 && wch <= 0x06f9) ||
        (wch >= 0x0966 && wch <= 0x096f) ||
        (wch >= 0x09e6 && wch <= 0x09ef) ||
        (wch >= 0x0a66 && wch <= 0x0a6f) ||
        (wch >= 0x0ae6 && wch <= 0x0aef) ||
        (wch >= 0x0b66 && wch <= 0x0b6f) ||
        (wch >= 0x0be7 && wch <= 0x0bef) ||
        (wch >= 0x0c66 && wch <= 0x0c6f) ||
        (wch >= 0x0ce6 && wch <= 0x0cef) ||
        (wch >= 0x0d66 && wch <= 0x0d6f) ||
        (wch >= 0x0e50 && wch <= 0x0e59) ||
        (wch >= 0x0ed0 && wch <= 0x0ed9) ||
        (wch >= 0x0f20 && wch <= 0x0f29)
        );
}

BOOLEAN
RtlSxspIsCharXMLExtender(
    WCHAR wch
    )
{
    return (
        wch == 0x00b7 ||
        wch == 0x02d0 ||
        wch == 0x02d1 ||
        wch == 0x0387 ||
        wch == 0x0640 ||
        wch == 0x0e46 ||
        wch == 0x0ec6 ||
        wch == 0x3005 ||
        (wch >= 0x3031 && wch <= 0x3035) ||
        (wch >= 0x309d && wch <= 0x309e) ||
        (wch >= 0x30fc && wch <= 0x30fe)
        );
}

NTSTATUS
RtlSxspValidateXMLName(
    PCWSTR psz,
    SIZE_T cch,
    BOOLEAN *prfValid
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    SIZE_T i;

    PARAMETER_CHECK(psz != NULL);
    PARAMETER_CHECK((cch == 0) || (psz != NULL));
    PARAMETER_CHECK(prfValid != NULL);

    *prfValid = FALSE;

    // [4]  NameChar ::=  Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender 
    // [5]  Name ::=  (Letter | '_' | ':') (NameChar)* 

    if (cch >= 1)
    {
        WCHAR wch = psz[0];

        if (RtlSxspIsCharXMLLetter(wch) ||
            (wch == L'_') ||
            (wch == L':'))
        {
            for (i=1; i<cch; i++)
            {
                wch = psz[i];

                if (!RtlSxspIsCharXMLLetter(wch) &&
                    !RtlSxspIsCharXMLDigit(wch) &&
                    (wch != L'.') &&
                    (wch != L'-') &&
                    (wch != L'_') &&
                    (wch != L':') &&
                    !RtlSxspIsCharXMLCombiningChar(wch) &&
                    !RtlSxspIsCharXMLExtender(wch))
                    break;
            }

            if (i == cch)
                *prfValid = TRUE;
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\sxsident\policy.c ===
#include "stdinc.h"

#include "idp.h"
#include "sxsapi.h"
#include "sxsid.h"

#define IFNTFAILED_EXIT(q) do { status = (q); if (!NT_SUCCESS(status)) goto Exit; } while (0)

NTSTATUS
RtlSxspMapAssemblyIdentityToPolicyIdentity(
    ULONG Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PASSEMBLY_IDENTITY *PolicyIdentity
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PCWSTR pszTemp;
    SIZE_T cchTemp;
    PASSEMBLY_IDENTITY NewIdentity = NULL;
    RTL_UNICODE_STRING_BUFFER NameBuffer;
    UCHAR wchNameBuffer[200];
    static const UNICODE_STRING strTemp = { 7, 7, L"Policy" };


    BOOLEAN fFirst;
    const BOOLEAN fOmitEntireVersion = ((Flags & SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION) != 0);

    PolicyIdentity = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != 0);
    PARAMETER_CHECK(PolicyIdentity != NULL);

    IFNTFAILED_EXIT(RtlSxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_type,
            &pszTemp,
            &cchTemp));

    PARAMETER_CHECK(
        (cchTemp == 5) &&
        (RtlSxspCompareStrings(
            pszTemp,
            5,
            L"win32",
            5,
            TRUE) == 0));

    RtlInitUnicodeStringBuffer(&NameBuffer, wchNameBuffer, sizeof(wchNameBuffer));

    // Ok, we know we have a win32 assembly reference.  Let's change the type to win32-policy
    IFNTFAILED_EXIT(RtlSxsDuplicateAssemblyIdentity(
            0,
            AssemblyIdentity,
            &NewIdentity));

    IFNTFAILED_EXIT(RtlSxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            NewIdentity,
            &s_IdentityAttribute_type,
            L"win32-policy",
            12));

    IFNTFAILED_EXIT(RtlAssignUnicodeStringBuffer(&NameBuffer, &strTemp));

    if (!fOmitEntireVersion)
    {
        IFNTFAILED_EXIT(RtlSxspGetAssemblyIdentityAttributeValue(
                0,
                AssemblyIdentity,
                &s_IdentityAttribute_version,
                &pszTemp,
                &cchTemp));

        fFirst = TRUE;

        while (cchTemp != 0)
        {
            if (pszTemp[--cchTemp] == L'.')
            {
                if (!fFirst)
                    break;

                fFirst = FALSE;
            }
        }

        // This should not be zero; someone prior to this should have validated the version format
        // to include three dots.
        if (cchTemp == 0) {
            status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }


        IFNTFAILED_EXIT(RtlEnsureUnicodeStringBufferSizeBytes(
            &NameBuffer,
            NameBuffer.String.Length + (sizeof(WCHAR) * (cchTemp + 1))
            ));

        IFNTFAILED_EXIT(RtlAppendUnicodeToString(
            &NameBuffer.String,
            pszTemp));
    }

    IFNTFAILED_EXIT(RtlSxspGetAssemblyIdentityAttributeValue(
            0,
            AssemblyIdentity,
            &s_IdentityAttribute_name,
            &pszTemp,
            &cchTemp));
    
    IFNTFAILED_EXIT(RtlEnsureUnicodeStringBufferSizeBytes(
        &NameBuffer,
        NameBuffer.String.Length + (sizeof(WCHAR) * (cchTemp))));

    IFNTFAILED_EXIT(RtlAppendUnicodeToString(
        &NameBuffer.String,
        pszTemp));
    
    IFNTFAILED_EXIT(
        RtlSxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            NewIdentity,
            &s_IdentityAttribute_name,
            NameBuffer.String.Buffer,
            NameBuffer.String.Length));

    // finally we whack the version...

    IFNTFAILED_EXIT(
        RtlSxspRemoveAssemblyIdentityAttribute(
            SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS,
            NewIdentity,
            &s_IdentityAttribute_version));

    *PolicyIdentity = NewIdentity;
    NewIdentity = NULL;

Exit:
    if (NewIdentity != NULL)
    {
        RtlSxsDestroyAssemblyIdentity(NewIdentity);
        NewIdentity = NULL;
    }

    return status;

}

/*
BOOL
RtlSxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
    ULONG Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    CBaseStringBuffer &rbuffEncodedIdentity,
    PASSEMBLY_IDENTITY *PolicyIdentityOut
    )
{
    BOOLEAN fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY PolicyIdentity = NULL;
    SIZE_T EncodedIdentityBytes = 0;
    CStringBufferAccessor acc;
    ULONG dwMapFlags = 0;
    SIZE_T BytesWritten;

    if (PolicyIdentityOut != NULL)
        *PolicyIdentityOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (Flags & SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION)
        dwMapFlags |= SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION;

    IFNTFAILED_EXIT(RtlSxspMapAssemblyIdentityToPolicyIdentity(dwMapFlags, AssemblyIdentity, PolicyIdentity));

    IFNTFAILED_EXIT(
        RtlSxsComputeAssemblyIdentityEncodedSize(
            0,
            PolicyIdentity,
            NULL,
            SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
            &EncodedIdentityBytes));

    INTERNAL_ERROR_CHECK((EncodedIdentityBytes % sizeof(WCHAR)) == 0);

    IFNTFAILED_EXIT(rbuffEncodedIdentity.Win32ResizeBuffer((EncodedIdentityBytes / sizeof(WCHAR)) + 1, eDoNotPreserveBufferContents));

    acc.Attach(&rbuffEncodedIdentity);

    IFNTFAILED_EXIT(
        RtlSxsEncodeAssemblyIdentity(
            0,
            PolicyIdentity,
            NULL,
            SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
            acc.GetBufferCb(),
            acc.GetBufferPtr(),
            &BytesWritten));

    INTERNAL_ERROR_CHECK((BytesWritten % sizeof(WCHAR)) == 0);
    INTERNAL_ERROR_CHECK(BytesWritten <= EncodedIdentityBytes);

    acc.GetBufferPtr()[BytesWritten / sizeof(WCHAR)] = L'\0';

    acc.Detach();

    if (PolicyIdentityOut != NULL)
    {
        *PolicyIdentityOut = PolicyIdentity;
        PolicyIdentity = NULL; // so we don't try to clean it up in the exit path
    }

    fSuccess = TRUE;
Exit:
    if (PolicyIdentity != NULL)
        SxsDestroyAssemblyIdentity(PolicyIdentity);

    return fSuccess;
}
*/


//
// the difference between this func and SxsHashAssemblyIdentity() is that for policy,
// version should not be calcaulated as part of hash
//
NTSTATUS
RtlSxspHashAssemblyIdentityForPolicy(
    IN ULONG dwFlags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT ULONG *pulIdentityHash)
{
    NTSTATUS status = STATUS_SUCCESS;

    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;

    IFNTFAILED_EXIT(RtlSxsDuplicateAssemblyIdentity(
            SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE,
            AssemblyIdentity,
            &pAssemblyIdentity));

    IFNTFAILED_EXIT(RtlSxspRemoveAssemblyIdentityAttribute(
            SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS,
            pAssemblyIdentity,
            &s_IdentityAttribute_version));

    IFNTFAILED_EXIT(RtlSxsHashAssemblyIdentity(0, pAssemblyIdentity, pulIdentityHash));

Exit:
    if (pAssemblyIdentity != NULL)
        RtlSxsDestroyAssemblyIdentity(pAssemblyIdentity);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\sxsident\stdinc.h ===
#pragma once
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#define MAXDWORD (~(DWORD)0)


#ifndef NUMBER_OF
#define NUMBER_OF(q) (sizeof(q)/sizeof(*q))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\utils\generichandles.h ===
#pragma once


typedef struct _tagGENERIC_HANDLE_SLOT {

    USHORT usGenerationFlag;

    ULONG ulRefCount;

    union {
        PVOID pvThisHandle;
        struct _tagGENERIC_HANDLE_SLOT *pNextFree;
    };
}
GENERIC_HANDLE_SLOT, *PGENERIC_HANDLE_SLOT;

typedef NTSTATUS (FASTCALL* PFNHANDLETABLEALLOC)(SIZE_T, PVOID*);
typedef NTSTATUS (FASTCALL* PFNHANDLETABLEFREE)(PVOID);

typedef struct _tagGENERIC_HANDLE_TABLE {
    
    ULONG ulFlags;

    USHORT usSlotCount;

    PGENERIC_HANDLE_SLOT pSlots;

    PGENERIC_HANDLE_SLOT pFirstFreeSlot;

    USHORT usInlineHandleSlots;

    PGENERIC_HANDLE_SLOT pInlineHandleSlots;

    PFNHANDLETABLEALLOC pfnAlloc;
    PFNHANDLETABLEFREE pfnFree;
}
GENERIC_HANDLE_TABLE, *PGENERIC_HANDLE_TABLE;

NTSTATUS
RtlDereferenceHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    PVOID                   pvGenericHandle,
    PVOID                  *ppvObjectPointer
    );

NTSTATUS
RtlAddRefGenericHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    PVOID                   pvGenericHandle
    );

NTSTATUS
RtlReleaseGenericHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    PVOID                   pvGenericHandle
    );

NTSTATUS
RtlAddGenericHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    ULONG                   ulFlags,
    PVOID                   pvObject,
    PVOID                  *ppvObjectHandle
    );

NTSTATUS
RtlRemoveGenericHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    ULONG                   ulFlags,
    PVOID                   pvObjectHandle
    );

NTSTATUS
RtlCreateGenericHandleTable(
    ULONG                   ulFlags,
    PGENERIC_HANDLE_TABLE   pCreatedTable,
    PFNHANDLETABLEALLOC     pfnAlloc,
    PFNHANDLETABLEFREE      pfnFree,
    SIZE_T                  cbOriginalBlob,
    PVOID                   pvOriginalBlob
    );

NTSTATUS
RtlCreateGenericHandleTableInPlace(
    ULONG                   ulFlags,
    SIZE_T                  cbInPlace,
    PVOID                   pvPlace,
    PFNHANDLETABLEALLOC     pfnAlloc,
    PFNHANDLETABLEFREE      pfnFree,
    PGENERIC_HANDLE_TABLE  *ppCreatedTable
    );


NTSTATUS
RtlDestroyGenericHandleTable(
    PGENERIC_HANDLE_TABLE   pTable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\sxsident\sxsid.c ===
#include "stdinc.h"
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>

#include "idp.h"
#include "sxsid.h"
#include "xmlassert.h"

#define IFNTFAILED_EXIT(q) do { status = (q); if (!NT_SUCCESS(status)) goto Exit; } while (0)


ASSEMBLY_IDENTITY_ATTRIBUTE
RtlSxsComposeAssemblyIdentityAttribute(
    PCWSTR pszNamespace,    SIZE_T cchNamespace,
    PCWSTR pszName,         SIZE_T cchName,
    PCWSTR pszValue,        SIZE_T cchValue)
{
    ASSEMBLY_IDENTITY_ATTRIBUTE anattribute;

    anattribute.Flags         = 0; // reserved flags : must be 0;
    anattribute.NamespaceCch  = cchNamespace;
    anattribute.NameCch       = cchName;
    anattribute.ValueCch      = cchValue;
    anattribute.Namespace     = pszNamespace;
    anattribute.Name          = pszName;
    anattribute.Value         = pszValue;

    return anattribute;
}

NTSTATUS
RtlSxsAssemblyIdentityIsAttributePresent(
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    PCWSTR pszNamespace,
    SIZE_T cchNamespace,
    PCWSTR pszName,
    SIZE_T cchName,
    BOOLEAN *prfFound)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG Count = 0;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    ULONG dwFindFlags;

    PARAMETER_CHECK(pszName != NULL);
    PARAMETER_CHECK(prfFound != NULL);

    *prfFound = FALSE;
    if ( pAssemblyIdentity == NULL)
    {
        goto Exit;
    }
    // in the case of a NULL namespace, we must set the flag, too ? xiaoyuw@09/11/00
    dwFindFlags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;
    Attribute = RtlSxsComposeAssemblyIdentityAttribute(pszNamespace, cchNamespace, pszName, cchName, NULL, 0);

    if (pAssemblyIdentity){
        IFNTFAILED_EXIT(
            RtlSxsFindAssemblyIdentityAttribute( // find attribute by "namespace" and "name"
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                    SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                    SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS,
                pAssemblyIdentity,
                &Attribute,
                NULL,
                &Count));
        if ( Count >0 ) { // found
            *prfFound = TRUE;
        }
    }

Exit:
    return status;
}

NTSTATUS
RtlSxspSetAssemblyIdentityAttributeValue(
    ULONG Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    const WCHAR *Value,
    SIZE_T ValueCch
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    ULONG FlagsToRealInsert = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);
    PARAMETER_CHECK(Value != NULL || ValueCch == 0);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;
    Attribute.Value = Value;
    Attribute.ValueCch = ValueCch;

    if (Flags & SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING)
        FlagsToRealInsert |= SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING;

    IFNTFAILED_EXIT(RtlSxsInsertAssemblyIdentityAttribute(FlagsToRealInsert, AssemblyIdentity, &Attribute));

Exit:
    return status;
}

/////////////////////////////////////////////////////////////////////////////
// Action :
// 1. if (namespace, name) is provided, remove all attributes with such (namespace, name)
// 2. if (namespace, name, value), remove at most 1 attribute from assembly-identity
///////////////////////////////////////////////////////////////////////////////
NTSTATUS
RtlSxspRemoveAssemblyIdentityAttribute(
    ULONG Flags,
    PASSEMBLY_IDENTITY pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    ULONG Ordinal;
    ULONG Count;
    ULONG dwFindAttributeFlags = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)) == 0);
    PARAMETER_CHECK(pAssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;

    dwFindAttributeFlags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;

    // If it's OK for the attribute not to exist, set the flag in the call to find it.
    if (Flags & SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)
        dwFindAttributeFlags |= SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS;

    IFNTFAILED_EXIT(
        RtlSxsFindAssemblyIdentityAttribute(
            dwFindAttributeFlags,
            pAssemblyIdentity,
            &Attribute,
            &Ordinal,
            &Count));

    if (Count > 1) {
        status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    if (Count > 0)
    {
        IFNTFAILED_EXIT(
            RtlSxsRemoveAssemblyIdentityAttributesByOrdinal(
                0,                  //  ULONG Flags,
                pAssemblyIdentity,
                Ordinal,
                Count));
    }

Exit:
    return status;
}
/////////////////////////////////////////////////////////////////////////////
// if no such attribure with such (namespace and name), return FALSE with
// ::SetLastError(ERROR_NOT_FOUND);
///////////////////////////////////////////////////////////////////////////////
NTSTATUS
RtlSxspGetAssemblyIdentityAttributeValue(
    ULONG Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT PCWSTR *StringOut,
    OUT SIZE_T *CchOut OPTIONAL
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    ULONG dwLocateFlags = SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;

    if (StringOut != NULL)
        *StringOut = NULL;

    if (CchOut != NULL)
        *CchOut = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;

    if (Flags & SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL)
        dwLocateFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL;

    IFNTFAILED_EXIT(
        RtlSxspLocateInternalAssemblyIdentityAttribute(
            dwLocateFlags,
            AssemblyIdentity,
            &Attribute,
            &InternalAttribute,
            NULL));

    if (InternalAttribute != NULL)
    {
        if (StringOut != NULL)
            *StringOut = InternalAttribute->Attribute.Value;

        if (CchOut != NULL)
            *CchOut = InternalAttribute->Attribute.ValueCch;
    }

Exit:
    return status;
}

NTSTATUS
RtlSxspUpdateAssemblyIdentityHash(
    ULONG dwFlags,
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (AssemblyIdentity->HashDirty)
    {
        IFNTFAILED_EXIT(RtlSxspHashInternalAssemblyIdentityAttributes(
                            0,
                            AssemblyIdentity->AttributeCount,
                            AssemblyIdentity->AttributePointerArray,
                            &AssemblyIdentity->Hash));

        AssemblyIdentity->HashDirty = FALSE;
    }

Exit:
    return status;
}

NTSTATUS
RtlSxspEnsureAssemblyIdentityHashIsUpToDate(
    ULONG dwFlags,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (AssemblyIdentity->HashDirty)
        IFNTFAILED_EXIT(RtlSxspUpdateAssemblyIdentityHash(0, (PASSEMBLY_IDENTITY)AssemblyIdentity));

Exit:
    return status;
}


NTSTATUS
RtlSxsHashAssemblyIdentity(
    ULONG dwFlags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    ULONG * pulPseudoKey
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    ULONG ulPseudoKey;

    if (pulPseudoKey)
        *pulPseudoKey = 0;

    PARAMETER_CHECK(dwFlags == 0);

    if (pAssemblyIdentity == NULL)
        ulPseudoKey = 0;
    else
    {
        IFNTFAILED_EXIT(RtlSxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity));
        ulPseudoKey = pAssemblyIdentity->Hash;
    }

    if (pulPseudoKey != NULL)
        *pulPseudoKey = ulPseudoKey;

Exit:
    return status;
}

// just to find whether Equal or Not
NTSTATUS
RtlSxsAreAssemblyIdentitiesEqual(
    ULONG dwFlags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity1,
    PCASSEMBLY_IDENTITY pAssemblyIdentity2,
    BOOLEAN *EqualOut
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN Equal = FALSE;

    if (EqualOut != NULL)
        *EqualOut = FALSE;

    PARAMETER_CHECK((dwFlags & ~(SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF)) == 0);
    PARAMETER_CHECK(pAssemblyIdentity1 != NULL);
    PARAMETER_CHECK(pAssemblyIdentity2 != NULL);
    PARAMETER_CHECK(EqualOut != NULL);

    // get hash for each assembly identity
    IFNTFAILED_EXIT(RtlSxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity1));
    IFNTFAILED_EXIT(RtlSxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity2));

    // compare hash value of two identity; it's a quick way to determine they're not equal.
    if (pAssemblyIdentity2->Hash == pAssemblyIdentity1->Hash)
    {
        // Note that two identities which differ only in their internal flags are still semantically
        // equal.
        if ((pAssemblyIdentity1->Flags ==  pAssemblyIdentity2->Flags) &&
            (pAssemblyIdentity1->Hash ==  pAssemblyIdentity2->Hash) &&
            (pAssemblyIdentity1->NamespaceCount ==  pAssemblyIdentity2->NamespaceCount) &&
            (pAssemblyIdentity1->AttributeCount ==  pAssemblyIdentity2->AttributeCount))
        {
            if (dwFlags & SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF)
            {
                if (((pAssemblyIdentity1->Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
                     (pAssemblyIdentity1->Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE)) &&
                    ((pAssemblyIdentity2->Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
                     (pAssemblyIdentity2->Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE)))
                {
                    // They match sufficiently...
                    Equal = TRUE;
                }
            }
            else
                Equal = (pAssemblyIdentity1->Type == pAssemblyIdentity2->Type);

            if (Equal)
            {
                ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_INVALID;

                // Reset our assumption...
                Equal = FALSE;

                IFNTFAILED_EXIT(
                    RtlSxspCompareAssemblyIdentityAttributeLists(
                        0,
                        pAssemblyIdentity1->AttributeCount,
                        pAssemblyIdentity1->AttributePointerArray,
                        pAssemblyIdentity2->AttributePointerArray,
                        &ComparisonResult));

                if (!(
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN) ||
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL) ||
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN))) {

                    status = STATUS_INTERNAL_ERROR;
                    goto Exit;
                }

                if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                    Equal = TRUE;
            }
        }
    }

    *EqualOut = Equal;

Exit:
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\utils\generichandles.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "generichandles.h"



NTSTATUS
RtlpGenericTableAddSlots(
    PGENERIC_HANDLE_TABLE   pCreatedTable,
    PGENERIC_HANDLE_SLOT    pSlots,
    USHORT                  usSlots
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    USHORT us;

    ASSERT(pCreatedTable != NULL);
    ASSERT(pSlots != NULL);
    ASSERT(usSlots > 0);

    RtlZeroMemory(pSlots, sizeof(GENERIC_HANDLE_SLOT) * usSlots);

    //
    // Next, next, next
    //
    for (us = 0; us < (usSlots - 1); us++) {
        pSlots[us].pNextFree = pSlots + (us + 1);
    }


    //
    // If there were no free slots, set this run as the new list of free
    // slots.  Otherwise, set this as the "next available" free slot
    //
    if (pCreatedTable->pFirstFreeSlot != NULL) {
        pCreatedTable->pFirstFreeSlot->pNextFree = pSlots;
    }

    //
    // Add these to the list of slots
    //
    pCreatedTable->usSlotCount += usSlots;

    //
    // If there was no set of slots on the table already, then add these as the 
    // current list of slots
    //
    if (pCreatedTable->pSlots == NULL) {
        pCreatedTable->pSlots = pSlots;
    }

    pCreatedTable->pFirstFreeSlot = pSlots;

    return status;
}






NTSTATUS
RtlCreateGenericHandleTable(
    ULONG                   ulFlags,
    PGENERIC_HANDLE_TABLE   pCreatedTable,
    PFNHANDLETABLEALLOC     pfnAlloc,
    PFNHANDLETABLEFREE      pfnFree,
    SIZE_T                  ulcbOriginalBlob,
    PVOID                   pvOriginalBlob
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    if ((ulFlags != 0) || (pCreatedTable == NULL) || (ulcbOriginalBlob && !pvOriginalBlob)) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(pCreatedTable, sizeof(*pCreatedTable));

    pCreatedTable->pfnAlloc = pfnAlloc;
    pCreatedTable->pfnFree = pfnFree;
    pCreatedTable->ulFlags = ulFlags;
    pCreatedTable->usInlineHandleSlots = (USHORT)(ulcbOriginalBlob / sizeof(GENERIC_HANDLE_SLOT));

    //
    // If there were slots handed to us, then initialize the table to use those first
    //
    if (pCreatedTable->usInlineHandleSlots > 0) {

        pCreatedTable->pInlineHandleSlots = (PGENERIC_HANDLE_SLOT)pvOriginalBlob;

        //
        // Now, add the slots that we were handed into the free list
        //
        status = RtlpGenericTableAddSlots(
            pCreatedTable,
            pCreatedTable->pSlots,
            pCreatedTable->usInlineHandleSlots);
    }
    //
    // Otherwise, everything is zero-initted already, so just bop out
    //

    return status;
}




NTSTATUS
RtlCreateGenericHandleTableInPlace(
    ULONG                   ulFlags,
    SIZE_T                  cbInPlace,
    PVOID                   pvPlace,
    PFNHANDLETABLEALLOC     pfnAlloc,
    PFNHANDLETABLEFREE      pfnFree,
    PGENERIC_HANDLE_TABLE  *ppCreatedTable
    )
{
    NTSTATUS status;

    if ((pvPlace == NULL) || (cbInPlace && !pvPlace) || !ppCreatedTable) {
        return STATUS_INVALID_PARAMETER;
    }
    else if (cbInPlace < sizeof(GENERIC_HANDLE_TABLE)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *ppCreatedTable = (PGENERIC_HANDLE_TABLE)pvPlace;

    status = RtlCreateGenericHandleTable(
        ulFlags,
        *ppCreatedTable,
        pfnAlloc,
        pfnFree,
        cbInPlace - sizeof(GENERIC_HANDLE_TABLE),
        *ppCreatedTable + 1);

    return status;
}


#define HANDLE_TABLE_SLOT_MASK          (0x0000FFFF)
#define HANDLE_TABLE_GEN_FLAG_SHIFT     (16)
#define HANDLE_TABLE_IN_USE_FLAG        (0x8000)
#define HANDLE_TABLE_GENERATION_MASK    (~HANDLE_TABLE_IN_USE_FLAG)


NTSTATUS
RtlpFindSlotForHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    PVOID                   pvHandle,
    PGENERIC_HANDLE_SLOT   *ppSlot
    )
{

    PGENERIC_HANDLE_SLOT pSlot;
    USHORT usSlotEntry = (USHORT)((ULONG_PTR)pvHandle & HANDLE_TABLE_SLOT_MASK);
    USHORT usGeneration = (USHORT)((ULONG_PTR)pvHandle >> HANDLE_TABLE_GEN_FLAG_SHIFT);

    pSlot = pHandleTable->pSlots + usSlotEntry;

    //
    // Generation flag not in use, gen mismatch, or not in the table?  Oops.
    //
    if (((usGeneration & HANDLE_TABLE_IN_USE_FLAG) == 0) || 
        (usSlotEntry >= pHandleTable->usSlotCount) ||
        (pSlot->usGenerationFlag != usGeneration)) {
        return STATUS_NOT_FOUND;
    }
    //
    // Return that the slot was found
    //
    else {
        *ppSlot = pSlot;
        return STATUS_SUCCESS;
    }
}


NTSTATUS
RtlAddRefGenericHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    PVOID                   pvGenericHandle
    )
{
    PGENERIC_HANDLE_SLOT    pSlot;
    NTSTATUS status;

    if (pHandleTable == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    status = RtlpFindSlotForHandle(pHandleTable, pvGenericHandle, &pSlot);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    pSlot->ulRefCount++;
    return STATUS_SUCCESS;
}



NTSTATUS
RtlReleaseGenericHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    PVOID                   pvGenericHandle
    )
{
    PGENERIC_HANDLE_SLOT    pSlot;
    NTSTATUS status;

    if (pHandleTable == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    status = RtlpFindSlotForHandle(pHandleTable, pvGenericHandle, &pSlot);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    pSlot->ulRefCount--;
    return STATUS_SUCCESS;
}





NTSTATUS
RtlRemoveGenericHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    ULONG                   ulFlags,
    PVOID                   pvObjectHandle
    )
{
    PGENERIC_HANDLE_SLOT    pSlot = NULL;
    NTSTATUS status;

    if ((pHandleTable == NULL) || (ulFlags != 0)) {
        return STATUS_INVALID_PARAMETER;
    }

    status = RtlpFindSlotForHandle(pHandleTable, pvObjectHandle, &pSlot);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Flip the in-use flag
    //
    pSlot->usGenerationFlag &= ~HANDLE_TABLE_IN_USE_FLAG;

    pSlot->pNextFree = pHandleTable->pFirstFreeSlot;
    pHandleTable->pFirstFreeSlot = pSlot;

    return STATUS_SUCCESS;
}







NTSTATUS
RtlDereferenceHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    PVOID                   pvGenericHandle,
    PVOID                  *ppvObjectPointer
    )
{
    USHORT                  usSlotEntry;
    NTSTATUS                status;
    PGENERIC_HANDLE_SLOT    pSlot = NULL;

    if ((pHandleTable == NULL) || (pvGenericHandle == NULL) || (ppvObjectPointer == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    *ppvObjectPointer = NULL;

    status = RtlpFindSlotForHandle(pHandleTable, pvGenericHandle, &pSlot);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    *ppvObjectPointer = pSlot->pvThisHandle;

    return STATUS_SUCCESS;
}



NTSTATUS
RtlpExpandGenericHandleTable(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    ULONG                   ulNewSlotCount
    )
{
    PGENERIC_HANDLE_SLOT    pNewSlots = NULL;
    NTSTATUS                status;

    //
    // New slot count is 0?  Make it 20 instead.
    //
    if (ulNewSlotCount == 0) {
        ulNewSlotCount = pHandleTable->usSlotCount + 20;
    }

    //
    // Did we fly out of range?
    //
    if (ulNewSlotCount > 0xFFFF) {

        ulNewSlotCount = 0xFFFF;

        //
        // Can't allocate more, the table is full
        //
        if (ulNewSlotCount == pHandleTable->usSlotCount) {
            return STATUS_NO_MEMORY;
        }
    }



    //
    // Don't ever do this if there are free slots left in the table
    //
    ASSERT(pHandleTable->pFirstFreeSlot == NULL);

    status = pHandleTable->pfnAlloc(sizeof(GENERIC_HANDLE_SLOT) * ulNewSlotCount, (PVOID*)&pNewSlots);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    return status;
}




NTSTATUS
RtlAddGenericHandle(
    PGENERIC_HANDLE_TABLE   pHandleTable,
    ULONG                   ulFlags,
    PVOID                   pvObject,
    PVOID                  *ppvObjectHandle
    )
{
    PGENERIC_HANDLE_SLOT    pSlot = NULL;
    NTSTATUS                status;

    if (ppvObjectHandle)
        *ppvObjectHandle = NULL;

    if ((pHandleTable == NULL) || (ulFlags != 0) || (pvObject != NULL) || (ppvObjectHandle == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (pHandleTable->pFirstFreeSlot == NULL) {
        status = RtlpExpandGenericHandleTable(pHandleTable, (pHandleTable->usSlotCount * 3) / 2);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    ASSERT(pHandleTable->pFirstFreeSlot != NULL);

    //
    // Adjust free list
    //
    pSlot = pHandleTable->pFirstFreeSlot;
    pHandleTable->pFirstFreeSlot = pSlot->pNextFree;

    //
    // Set up the various flags.
    //
    ASSERT((pSlot->usGenerationFlag & HANDLE_TABLE_IN_USE_FLAG) == 0);

    //
    // Increment the generation flag, set the in-use flag
    //
    pSlot->usGenerationFlag = (pSlot->usGenerationFlag & HANDLE_TABLE_GENERATION_MASK) + 1;
    pSlot->usGenerationFlag |= HANDLE_TABLE_IN_USE_FLAG;
    pSlot->ulRefCount = 0;

    //
    // Record the object pointer
    //
    pSlot->pvThisHandle = pvObject;

    //
    // The object handle is composed of 16 bits of generation mask plus the top-bit set
    // (which nicely avoids people casting it to a pointer that they can use), and
    // the lower 16 bits of "slot number", or an index into the handle table.
    //
    *ppvObjectHandle = (PVOID)((ULONG_PTR)(
        (pSlot->usGenerationFlag << HANDLE_TABLE_GEN_FLAG_SHIFT) | 
        ((pSlot - pHandleTable->pInlineHandleSlots) & HANDLE_TABLE_SLOT_MASK)));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\utils\stringpool.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntrtl.h"
#include "sxs-rtl.h"
#include "skiplist.h"
#include "stringpool.h"


NTSTATUS
RtlAllocateStringInPool(
    ULONG ulFlags,
    PRTL_STRING_POOL pStringPool,
    PUNICODE_STRING pusOutbound,
    SIZE_T ulByteCount
    )
{
    NTSTATUS status;
    ULONG idx;
    PRTL_STRING_POOL_FRAME pFrameWithFreeSpace = NULL;

    RtlZeroMemory(pusOutbound, sizeof(*pusOutbound));

    if (!ARGUMENT_PRESENT(pStringPool) || !ARGUMENT_PRESENT(pusOutbound) || (ulByteCount >= 0xFFFF) ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Zing through frames in the string pool looking for a frame with
    // enough bytes open
    //
    for (idx = 0; idx < pStringPool->ulFramesCount; idx++) {

        status = RtlIndexIntoGrowingList(
            &pStringPool->FrameList,
            idx,
            (PVOID*)&pFrameWithFreeSpace,
            FALSE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // There's space in this frame!
        //
        if (pFrameWithFreeSpace->cbRegionAvailable >= ulByteCount) {
            break;
        }
    }

    //
    // Frame not found, index one past the current limit, implicitly (potentially)
    // allocating into the growing list
    //
    if (pFrameWithFreeSpace == NULL) {

        status = RtlIndexIntoGrowingList(
            &pStringPool->FrameList,
            pStringPool->ulFramesCount,
            (PVOID*)&pFrameWithFreeSpace,
            TRUE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Requested byte count is larger than the bytes in a new region?  Bump up the
        // size of new regions to twice this size
        //
        if (ulByteCount > pStringPool->cbBytesInNewRegion) {
            pStringPool->cbBytesInNewRegion = ulByteCount * 2;
        }

        status = pStringPool->Allocator.pfnAlloc(
            pStringPool->cbBytesInNewRegion, 
            (PVOID*)&pFrameWithFreeSpace->pvRegion,
            pStringPool->Allocator.pvContext);

        if (!NT_SUCCESS(status)) {
            return STATUS_NO_MEMORY;
        }

        pFrameWithFreeSpace->pvNextAvailable = pFrameWithFreeSpace->pvRegion;
        pFrameWithFreeSpace->cbRegionAvailable = pStringPool->cbBytesInNewRegion;
    }

    //
    // Sanity checking
    //
    ASSERT(pFrameWithFreeSpace != NULL);
    ASSERT(pFrameWithFreeSpace->cbRegionAvailable >= ulByteCount);

    //
    // Bookkeeping in the frame
    //
    pFrameWithFreeSpace->cbRegionAvailable -= ulByteCount;
    pFrameWithFreeSpace->pvNextAvailable = (PVOID)(((ULONG_PTR)pFrameWithFreeSpace->pvNextAvailable) + ulByteCount);

    //
    // Set up the outbound thing
    //
    pusOutbound->Buffer = pFrameWithFreeSpace->pvNextAvailable;
    pusOutbound->MaximumLength = (USHORT)ulByteCount;
    pusOutbound->Length = 0;

    return STATUS_SUCCESS;
}




NTSTATUS
RtlDestroyStringPool(
    PRTL_STRING_POOL pStringPool
    )
{
    NTSTATUS status;
    PRTL_STRING_POOL_FRAME pFrame = NULL;
    ULONG ul;

    //
    // Zing through frames and deallocate those that weren't allocated
    // inline with the pool
    //
    for (ul = 0; ul < pStringPool->ulFramesCount; ul++) {

        status = RtlIndexIntoGrowingList(
            &pStringPool->FrameList,
            ul,
            (PVOID*)&pFrame,
            FALSE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if ((pFrame->ulFlags & RTL_STRING_POOL_FRAME_FLAG_REGION_INLINE) == 0) {

            status = pStringPool->Allocator.pfnFree(pFrame->pvRegion, pStringPool->Allocator.pvContext);
            pFrame->pvRegion = NULL;
            pFrame->pvNextAvailable = NULL;
            pFrame->cbRegionAvailable = 0;

        }
    }

    //
    // We're done, destroy the list itself
    //
    status = RtlDestroyGrowingList(&pStringPool->FrameList);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // No frames, list destroyed
    //
    pStringPool->ulFramesCount = 0;

    //
    // Great.
    //
    return STATUS_SUCCESS;
}




NTSTATUS
RtlCreateStringPool(
    ULONG ulFlags,
    PRTL_STRING_POOL pStringPool,
    SIZE_T cbBytesInFrames,
    PRTL_ALLOCATOR Allocator,
    PVOID pvOriginalRegion,
    SIZE_T cbOriginalRegion
    )
{
    NTSTATUS status;

    //
    // Ick.  Heap allocation all the way
    //
    if ((cbOriginalRegion == 0) || (pvOriginalRegion == NULL)) {
        status = RtlInitializeGrowingList(
            &pStringPool->FrameList,
            sizeof(RTL_STRING_POOL_FRAME),
            20,
            NULL,
            0,
            Allocator);

        pStringPool->ulFramesCount = 0;
        pStringPool->Allocator = *Allocator;
        pStringPool->cbBytesInNewRegion = cbBytesInFrames;
        
        return STATUS_SUCCESS;
    }
    //
    // Good, space for at least one frame, donate the remainder to the list
    //
    else if (cbOriginalRegion >= sizeof(RTL_STRING_POOL_FRAME)) {

        RTL_STRING_POOL_FRAME* pFirstFrame = NULL;

        status = RtlInitializeGrowingList(
            &pStringPool->FrameList,
            sizeof(RTL_STRING_POOL_FRAME),
            20,
            pvOriginalRegion,
            sizeof(RTL_STRING_POOL_FRAME),
            Allocator);

        pStringPool->ulFramesCount = pStringPool->FrameList.cInternalElements;
        pStringPool->Allocator = *Allocator;
        pStringPool->cbBytesInNewRegion = cbBytesInFrames;

        if (pStringPool->ulFramesCount) {
            status = RtlIndexIntoGrowingList(
                &pStringPool->FrameList,
                0,
                (PVOID*)&pFirstFrame,
                FALSE);

            //
            // Wierd...
            //
            if ((status == STATUS_NO_MEMORY) || (status == STATUS_NOT_FOUND)) {
                pStringPool->ulFramesCount = 0;
            }
            else {
                pFirstFrame->pvRegion = pFirstFrame->pvNextAvailable = 
                    (PVOID)(((ULONG_PTR)pvOriginalRegion) + sizeof(RTL_STRING_POOL_FRAME));
                pFirstFrame->cbRegionAvailable = cbOriginalRegion - sizeof(RTL_STRING_POOL_FRAME);
                pFirstFrame->ulFlags = RTL_STRING_POOL_FRAME_FLAG_REGION_INLINE;
            }
        }

        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\utils\skiplist.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "sxs-rtl.h"
#include "skiplist.h"
#include "xmlassert.h"

typedef unsigned char *PBYTE;


NTSTATUS
RtlpFindChunkForElementIndex(
    PRTL_GROWING_LIST        pList,
    ULONG                    ulIndex,
    PRTL_GROWING_LIST_CHUNK *ppListChunk,
    SIZE_T                  *pulChunkOffset
    )
/*++


  Purpose:

    Finds the chunk for the given index.  This could probably be made faster if
    and when we start using skiplists.  As it stands, we just have to walk through
    the list until the index looked for is inside one of the lists.

  Parameters:

    pList - Growing list management structure

    ulIndex - Index requested by the caller

    ppListChunk - Pointer to a pointer to a list chunk.  On return, points to
        the list chunk containing the index.

    pulChunkOffset - Offset into the chunk (in elements) that was requested

  Returns:

    STATUS_SUCCESS - Chunk was found, ppListChunk and pulChunkOffset point to
        the values listed in the 'parameters' section.

    STATUS_NOT_FOUND - The index was beyond the end of the chunk sections.

--*/
{
    PRTL_GROWING_LIST_CHUNK pHere = NULL;

    //
    // Is the index in the internal list?
    //
    ASSERT(ulIndex >= pList->cInternalElements);
    ASSERT(pList != NULL);
    ASSERT(ppListChunk != NULL);

    *ppListChunk = NULL;

    if (pulChunkOffset) {
        *pulChunkOffset = 0;
    }

    //
    // Chop off the number of elements in the internal list
    //
    ulIndex -= pList->cInternalElements;


    //
    // Move through list chunks until the index is inside one
    // of them.  A smarter bear would have made all the chunks the
    // same size and could then have just skipped ahead the right
    // number, avoiding comparisons.
    //
    pHere = pList->pFirstChunk;

    while ((ulIndex >= pList->cElementsPerChunk) && pHere) {
        pHere = pHere->pNextChunk;
        ulIndex -= pList->cElementsPerChunk;
    }

    //
    // Set pointer over
    //
    if (ulIndex < pList->cElementsPerChunk) {
        *ppListChunk = pHere;
    }

    //
    // And if the caller cared what chunk this was in, then tell them.
    //
    if (pulChunkOffset && *ppListChunk) {
        *pulChunkOffset = ulIndex;
    }

    return pHere ? STATUS_SUCCESS : STATUS_NOT_FOUND;
}




NTSTATUS
RtlInitializeGrowingList(
    PRTL_GROWING_LIST       pList,
    SIZE_T                  cbElementSize,
    ULONG                   cElementsPerChunk,
    PVOID                   pvInitialListBuffer,
    SIZE_T                  cbInitialListBuffer,
    PRTL_ALLOCATOR          Allocation
    )
{

    if ((pList == NULL) ||
        (cElementsPerChunk == 0) ||
        (cbElementSize == 0))
    {
        return STATUS_INVALID_PARAMETER;
    }
        

    RtlZeroMemory(pList, sizeof(*pList));

    pList->cbElementSize        = cbElementSize;
    pList->cElementsPerChunk    = cElementsPerChunk;
    pList->Allocator            = *Allocation;

    //
    // Set up  the initial list pointer
    //
    if (pvInitialListBuffer != NULL) {

        pList->pvInternalList = pvInitialListBuffer;

        // Conversion downwards to a ulong, but it's still valid, right?
        pList->cInternalElements = (ULONG)(cbInitialListBuffer / cbElementSize);

        pList->cTotalElements = pList->cInternalElements;

    }

    return STATUS_SUCCESS;
}





NTSTATUS
RtlpExpandGrowingList(
    PRTL_GROWING_LIST       pList,
    ULONG                   ulMinimalIndexCount
    )
/*++

  Purpose:

    Given a growing list, expand it to be able to contain at least
    ulMinimalIndexCount elements.  Does this by allocating chunks via the
    allocator in the list structure and adding them to the growing list
    chunk set.

  Parameters:

    pList - Growing list structure to be expanded

    ulMinimalIndexCount - On return, the pList will have at least enough
        slots to contain this many elements.

  Return codes:

    STATUS_SUCCESS - Enough list chunks were allocated to hold the
        requested number of elements.

    STATUS_NO_MEMORY - Ran out of memory during allocation.  Any allocated
        chunks were left allocated and remain owned by the growing list
        until destruction.

    STATUS_INVALID_PARAMETER - pList was NULL or invalid.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ulNecessaryChunks = 0;
    ULONG ulExtraElements = ulMinimalIndexCount;
    SIZE_T BytesInChunk;

    if ((pList == NULL) || (pList->Allocator.pfnAlloc == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Already got enough elements in the list?  Great.  The caller
    // was a bit overactive.
    //
    if (pList->cTotalElements > ulMinimalIndexCount) {
        return STATUS_SUCCESS;
    }

    //
    // Whack off the number of elements already on the list.
    //
    ulExtraElements -= pList->cTotalElements;
    
    //
    // How many chunks is that?  Remember to round up.
    //
    ulNecessaryChunks = ulExtraElements / pList->cElementsPerChunk;
    ulNecessaryChunks++;

    //
    // Let's go allocate them, one by one
    //
    BytesInChunk = (pList->cbElementSize * pList->cElementsPerChunk) +
        sizeof(RTL_GROWING_LIST_CHUNK);

    while (ulNecessaryChunks--) {

        PRTL_GROWING_LIST_CHUNK pNewChunk = NULL;

        //
        // Allocate some memory for the chunk
        //
        status = pList->Allocator.pfnAlloc(BytesInChunk, (PVOID*)&pNewChunk, pList->Allocator.pvContext);
        if (!NT_SUCCESS(status)) {
            return STATUS_NO_MEMORY;
        }

        //
        // Set up the new chunk
        //
        pNewChunk->pGrowingListParent = pList;
        pNewChunk->pNextChunk = NULL;

        if (pList->pLastChunk) {
            //
            // Swizzle the list of chunks to include this one
            //
            pList->pLastChunk->pNextChunk = pNewChunk;
        }

        pList->pLastChunk = pNewChunk;
        pList->cTotalElements += pList->cElementsPerChunk;

        //
        // If there wasn't a first chunk, this one is.
        //
        if (pList->pFirstChunk == NULL) {
            pList->pFirstChunk = pNewChunk;
        }
    }

    return STATUS_SUCCESS;

}







NTSTATUS
RtlIndexIntoGrowingList(
    PRTL_GROWING_LIST       pList,
    ULONG                   ulIndex,
    PVOID                  *ppvPointerToSpace,
    BOOLEAN                 fGrowingAllowed
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    if ((pList == NULL) || (ppvPointerToSpace == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    *ppvPointerToSpace = NULL;

    //
    // If the index is beyond the current total number of elements, but we're
    // not allowing growing, then say it wasn't found.  Otherwise, we'll always
    // grow the array as necessary to contain the index passed.
    //
    if ((ulIndex >= pList->cTotalElements) && !fGrowingAllowed) {
        return STATUS_NOT_FOUND;
    }

    //
    // This element is in the internal list, so just figure out where
    // and point at it.  Do this only if there's an internal element
    // list.
    //
    if ((ulIndex < pList->cInternalElements) && pList->cInternalElements) {

        //
        // The pointer to the space they want is ulIndex*pList->cbElementSize 
        // bytes down the pointer pList->pvInternalList
        //
        *ppvPointerToSpace = ((PBYTE)(pList->pvInternalList)) + (ulIndex * pList->cbElementSize);
        return STATUS_SUCCESS;
    }
    //
    // Otherwise, the index is outside the internal list, find out which one
    // it was supposed to be in.
    //
    else {

        PRTL_GROWING_LIST_CHUNK pThisChunk = NULL;
        SIZE_T ulNewOffset = 0;
        PBYTE pbData = NULL;

        status = RtlpFindChunkForElementIndex(pList, ulIndex, &pThisChunk, &ulNewOffset);

        //
        // Success! Go move the chunk pointer past the header of the growing list
        // chunk, and then index off it to find the right place.
        //
        if (NT_SUCCESS(status)) {

            pbData = ((PBYTE)(pThisChunk + 1)) + (pList->cbElementSize * ulNewOffset);

        }
        //
        // Otherwise, the chunk wasn't found, so we have to go allocate some new
        // chunks to hold it, then try again.
        //
        else if (status == STATUS_NOT_FOUND) {

            //
            // Expand the list
            //
            if (!NT_SUCCESS(status = RtlpExpandGrowingList(pList, ulIndex))) {
                goto Exit;
            }

            //
            // Look again
            //
            status = RtlpFindChunkForElementIndex(pList, ulIndex, &pThisChunk, &ulNewOffset);
            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            //
            // Adjust pointers
            //
            pbData = ((PBYTE)(pThisChunk + 1)) + (pList->cbElementSize * ulNewOffset);


        }
        else {
            goto Exit;
        }

        //
        // One of the above should have set the pbData pointer to point at the requested
        // grown-list space.
        //
        *ppvPointerToSpace = pbData;

    
    }


Exit:
    return status;
}







NTSTATUS
RtlDestroyGrowingList(
    PRTL_GROWING_LIST       pList
    )
/*++

  Purpose:

    Destroys (deallocates) all the chunks that had been allocated to this
    growing list structure.  Returns the list to the "fresh" state of having
    only the 'internal' element count.

  Parameters:

    pList - List structure to be destroyed

  Returns:

    STATUS_SUCCESS - Structure was completely cleaned out

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    if ((pList == NULL) || (pList->Allocator.pfnFree == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Zing through and kill all the list bits
    //
    while (pList->pFirstChunk != NULL) {

        PRTL_GROWING_LIST_CHUNK pHere;

        pHere = pList->pFirstChunk;
        pList->pFirstChunk = pList->pFirstChunk->pNextChunk;

        if (!NT_SUCCESS(status = pList->Allocator.pfnFree(pHere, pList->Allocator.pvContext))) {
            return status;
        }

        pList->cTotalElements -= pList->cElementsPerChunk;

    }

    ASSERT(pList->pFirstChunk == NULL);

    //
    // Reset the things that change as we expand the list
    //
    pList->pLastChunk = pList->pFirstChunk = NULL;
    pList->cTotalElements = pList->cInternalElements;

    return status;
}


NTSTATUS
RtlCloneGrowingList(
    ULONG                   ulFlags,
    PRTL_GROWING_LIST       pDestination,
    PRTL_GROWING_LIST       pSource,
    ULONG                   ulSourceCount
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ul;
    PVOID pvSourceCursor, pvDestCursor;
    SIZE_T cbBytes;
    
    //
    // No flags, no null values, element byte size has to match,
    // and the source/dest can't be the same.
    //
    if (((ulFlags != 0) || !pDestination || !pSource) ||
        (pDestination->cbElementSize != pSource->cbElementSize) ||
        (pDestination == pSource))
        return STATUS_INVALID_PARAMETER;

    cbBytes = pDestination->cbElementSize;

    //
    // Now copy bytes around
    //
    for (ul = 0; ul < ulSourceCount; ul++) {
        status = RtlIndexIntoGrowingList(pSource, ul, &pvSourceCursor, FALSE);
        if (!NT_SUCCESS(status))
            goto Exit;

        status = RtlIndexIntoGrowingList(pDestination, ul, &pvDestCursor, TRUE);
        if (!NT_SUCCESS(status))
            goto Exit;

        RtlCopyMemory(pvDestCursor, pvSourceCursor, cbBytes);
    }

    status = STATUS_SUCCESS;
Exit:
    return status;
}




NTSTATUS
RtlAllocateGrowingList(
    PRTL_GROWING_LIST  *ppGrowingList,
    SIZE_T              cbThingSize,
    PRTL_ALLOCATOR      Allocation
    )
{
    PRTL_GROWING_LIST pvWorkingList = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    if (ppGrowingList != NULL)
        *ppGrowingList = NULL;
    else
        return STATUS_INVALID_PARAMETER;

    if (!Allocation)
        return STATUS_INVALID_PARAMETER_3;

    //
    // Allocate space
    //
    status = Allocation->pfnAlloc(sizeof(RTL_GROWING_LIST), &pvWorkingList, Allocation->pvContext);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    //
    // Set up the structure
    //
    status = RtlInitializeGrowingList(
        pvWorkingList, 
        cbThingSize, 
        8, 
        NULL, 
        0,
        Allocation);

    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    *ppGrowingList = pvWorkingList;
    pvWorkingList = NULL;
    status = STATUS_SUCCESS;
Exit:
    if (pvWorkingList) {
        Allocation->pfnFree(pvWorkingList, Allocation->pvContext);
    }
    
    return status;
        
}





NTSTATUS
RtlSearchGrowingList(
    PRTL_GROWING_LIST TheList,
    ULONG ItemCount,
    PFN_LIST_COMPARISON_CALLBACK SearchCallback,
    PVOID SearchTarget,
    PVOID SearchContext,
    PVOID *pvFoundItem
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ul;
    int CompareResult = 0;

    if (pvFoundItem)
        *pvFoundItem = NULL;

//    if (TheList->ulFlags & GROWING_LIST_FLAG_IS_SORTED) {
    if (0) {
    }
    else {

        ULONG uTemp = ItemCount;
        ULONG uOffset = 0;
        PRTL_GROWING_LIST_CHUNK Chunklet;
        
        ul = 0;

        //
        // Scan the internal item list.
        //
        while ((ul < ItemCount) && (ul < TheList->cInternalElements)) {
            
            PVOID pvHere = (PVOID)(((ULONG_PTR)TheList->pvInternalList) + uOffset);

            status = SearchCallback(TheList, SearchTarget, pvHere, SearchContext, &CompareResult);
            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            if (CompareResult == 0) {
                if (pvFoundItem)
                    *pvFoundItem = pvHere;
                status = STATUS_SUCCESS;
                goto Exit;
            }

            uOffset += TheList->cbElementSize;
            ul++;
        }

        //
        // Ok, we ran out of internal elements, do the same thing here but on the chunk list
        //
        Chunklet = TheList->pFirstChunk;
        while ((ul < ItemCount) && Chunklet) {

            PVOID Data = (PVOID)(Chunklet + 1);
            ULONG ulHighOffset = TheList->cElementsPerChunk * TheList->cbElementSize;
            
            uOffset = 0;

            //
            // Spin through the items in this chunklet
            //
            while (uOffset < ulHighOffset) {
                
                PVOID pvHere = (PVOID)(((ULONG_PTR)Data) + uOffset);

                status = SearchCallback(TheList, SearchTarget, pvHere, SearchContext, &CompareResult);
                if (!NT_SUCCESS(status)) {
                    goto Exit;
                }

                if (CompareResult == 0) {
                    if (pvFoundItem)
                        *pvFoundItem = pvHere;
                    status = STATUS_SUCCESS;
                    goto Exit;
                }

                uOffset += TheList->cbElementSize;
            }
            
        }

        //
        // If we got here, we didn't find it in either the internal list or the external one.
        //
        status = STATUS_NOT_FOUND;        
        if (pvFoundItem)
            *pvFoundItem = NULL;
        
    }
    
Exit:
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\xmllib\fasterxml.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "sxs-rtl.h"
#include "fasterxml.h"
#include "xmlassert.h"

#define ADVANCE_PVOID(pv, offset) ((pv) = (PVOID)(((ULONG_PTR)(pv)) + (offset)))
#define REWIND_PVOID(pv, offset) ((pv) = (PVOID)(((ULONG_PTR)(pv)) - (offset)))

#define SPECIALSTRING(str) { L##str, NUMBER_OF(L##str) - 1 }

XML_SPECIAL_STRING xss_CDATA        = SPECIALSTRING("CDATA");
XML_SPECIAL_STRING xss_xml          = SPECIALSTRING("xml");
XML_SPECIAL_STRING xss_encoding     = SPECIALSTRING("encoding");
XML_SPECIAL_STRING xss_standalone   = SPECIALSTRING("standalone");
XML_SPECIAL_STRING xss_version      = SPECIALSTRING("version");
XML_SPECIAL_STRING xss_xmlns        = SPECIALSTRING("xmlns");


NTSTATUS
RtlXmlDefaultCompareStrings(
    PXML_TOKENIZATION_STATE pState,
    PCXML_EXTENT pLeft,
    PCXML_EXTENT pRight,
    XML_STRING_COMPARE *pfEqual
    )
{
    SIZE_T cbLeft, cbRight;
    PVOID pvLeft, pvRight, pvOriginal;
    NTSTATUS status = STATUS_SUCCESS;

    if (!ARGUMENT_PRESENT(pLeft) || !ARGUMENT_PRESENT(pRight) || !ARGUMENT_PRESENT(pfEqual)) {
        return STATUS_INVALID_PARAMETER;
    }

    *pfEqual = XML_STRING_COMPARE_EQUALS;

    pvOriginal = pState->RawTokenState.pvCursor;
    pvLeft = pLeft->pvData;
    pvRight = pRight->pvData;

    //
    // Loop through the data until we run out
    //
    for (cbLeft = 0, cbRight = 0; (cbLeft < pLeft->cbData) && (cbRight < pRight->cbData); )
    {
        ULONG chLeft, chRight;
        int iResult;

        //
        // Set the left cursor, gather a character out of it, advance it
        //
        pState->RawTokenState.pvCursor = pvLeft;

        chLeft = pState->RawTokenState.pfnNextChar(&pState->RawTokenState);

        pvLeft = (PBYTE)pvLeft + pState->RawTokenState.cbBytesInLastRawToken;
        cbLeft += pState->RawTokenState.cbBytesInLastRawToken;

        //
        // Failure?
        //
        if ((chLeft == 0) && !NT_SUCCESS(pState->RawTokenState.NextCharacterResult)) {
            status = pState->RawTokenState.NextCharacterResult;
            goto Exit;
        }

        //
        // Reset
        //
        if (pState->RawTokenState.cbBytesInLastRawToken != pState->RawTokenState.DefaultCharacterSize) {
            pState->RawTokenState.cbBytesInLastRawToken = pState->RawTokenState.DefaultCharacterSize;
        }


        //
        // Set the right cursor, gather a character, etc.
        //
        pState->RawTokenState.pvCursor = pvRight;

        chRight = pState->RawTokenState.pfnNextChar(&pState->RawTokenState);

        pvRight = (PBYTE)pvRight + pState->RawTokenState.cbBytesInLastRawToken;
        cbRight += pState->RawTokenState.cbBytesInLastRawToken;

        if ((chRight == 0) && !NT_SUCCESS(pState->RawTokenState.NextCharacterResult)) {
            status = pState->RawTokenState.NextCharacterResult;
            goto Exit;
        }

        if (pState->RawTokenState.cbBytesInLastRawToken != pState->RawTokenState.DefaultCharacterSize) {
            pState->RawTokenState.cbBytesInLastRawToken = pState->RawTokenState.DefaultCharacterSize;
        }

        //
        // Are they equal?
        //
        iResult = chLeft - chRight;
        if (iResult == 0) {
            continue;
        }
        //
        // Nope, left is larger
        //
        else if (iResult > 0) {
            *pfEqual = XML_STRING_COMPARE_GT;
            goto Exit;
        }
        //
        // Right is larger
        //
        else {
            *pfEqual = XML_STRING_COMPARE_LT;
            goto Exit;
        }
    }

    //
    // There was data left in the right thing
    //
    if (cbRight < pRight->cbData) {
        *pfEqual = XML_STRING_COMPARE_LT;
    }
    //
    // There was data left in the left thing
    //
    else if (cbLeft < pLeft->cbData) {
        *pfEqual = XML_STRING_COMPARE_GT;
    }
    //
    // Otherwise, it's still equal
    //

Exit:
    pState->RawTokenState.pvCursor = pvOriginal;
    return status;
}






NTSTATUS
RtlXmlDefaultSpecialStringCompare(
    PXML_TOKENIZATION_STATE     pState,
    PCXML_EXTENT           pToken,
    PCXML_SPECIAL_STRING   pSpecialString,
    XML_STRING_COMPARE         *pfMatches
    )
{
    PVOID pvOriginal = NULL;
    SIZE_T ulGathered = 0;
    ULONG cchCompareStringIdx = 0;

    if (!ARGUMENT_PRESENT(pState) || !ARGUMENT_PRESENT(pToken) || !ARGUMENT_PRESENT(pSpecialString) ||
        !ARGUMENT_PRESENT(pfMatches)) {

        return STATUS_INVALID_PARAMETER;
    }

    pvOriginal = pState->RawTokenState.pvCursor;

    //
    // Rewire the input cursor
    //
    pState->RawTokenState.pvCursor = pToken->pvData;

    for (ulGathered = 0; 
         (ulGathered < pToken->cbData) && (cchCompareStringIdx < pSpecialString->cchwszStringText); 
         ulGathered) 
    {
    
        ULONG ulChar = pState->RawTokenState.pfnNextChar(&pState->RawTokenState);
        int iDiff;

        if ((ulChar == 0) && !NT_SUCCESS(pState->RawTokenState.NextCharacterResult)) {
            return pState->RawTokenState.NextCharacterResult;
        }

        //
        // Out of our range, ick
        //
        if (ulChar > 0xFFFF) {

            return STATUS_INTEGER_OVERFLOW;

        } 
        //
        // Not matching characters?
        //

        iDiff = ulChar - pSpecialString->wszStringText[cchCompareStringIdx++];

        if (iDiff > 0) {
            *pfMatches = XML_STRING_COMPARE_LT;
            goto Exit;
        }
        else if (iDiff < 0) {
            *pfMatches = XML_STRING_COMPARE_GT;
            goto Exit;
        }

        //
        // Account for the bytes that we gathered, advancing the pointer
        //
        ADVANCE_PVOID(pState->RawTokenState.pvCursor, pState->RawTokenState.cbBytesInLastRawToken);
        ulGathered += pState->RawTokenState.cbBytesInLastRawToken;

        if (pState->RawTokenState.cbBytesInLastRawToken != pState->RawTokenState.DefaultCharacterSize) {
            pState->RawTokenState.cbBytesInLastRawToken = pState->RawTokenState.DefaultCharacterSize;
        }


    }

    if (ulGathered < pToken->cbData) {
     *pfMatches = XML_STRING_COMPARE_LT;
    }
    else if (cchCompareStringIdx < pSpecialString->cchwszStringText) {
     *pfMatches = XML_STRING_COMPARE_GT;
    }
    else {
     *pfMatches = XML_STRING_COMPARE_EQUALS;
    }
     
Exit:
    if (pState->RawTokenState.cbBytesInLastRawToken != pState->RawTokenState.DefaultCharacterSize) {
        pState->RawTokenState.cbBytesInLastRawToken = pState->RawTokenState.DefaultCharacterSize;
    }

    pState->RawTokenState.pvCursor = pvOriginal;

    return STATUS_SUCCESS;
}



#define VALIDATE_XML_STATE(pState) \
    (((pState == NULL) || \
     ((pState->pvCursor == NULL) && (pState->pvXmlData == NULL)) || \
     (((SIZE_T)((PBYTE)pState->pvCursor - (PBYTE)pState->pvXmlData)) >= pState->Run.cbData)) ? STATUS_INVALID_PARAMETER : STATUS_SUCCESS)

//
// Each byte in this table has this property:
// - The lower nibble indicates the number of total bytes in this entity
// - The upper nibble indicates the number of bits in the start byte
//
static const BYTE s_UtfTrailCountFromHighNibble[16] =
{
    // No high bits set in a nibble for the first 8.
    1, 1, 1, 1, 1, 1, 1, 1, 
    // Technically, having only one high bit set is invalid
    0, 0, 0, 0,
    // These are actual utf8 high-nibble settings
    2 | (5 << 4), // 110xxxxx
    2 | (4 << 4), // 1100xxxx
    3 | (4 << 4), // 1110xxxx
    4 | (3 << 4), // 11110xxx
};

#define MAKE_UTF8_FIRSTBYTE_BITMASK_FROM_HIGHNIBBLE(q) ((1 << ((s_UtfTrailCountFromHighNibble[(q) >> 4] & 0xf0) >> 4)) - 1)
#define MAKE_UTF8_TOTAL_BYTE_COUNT_FROM_HIGHNIBBLE(q) (s_UtfTrailCountFromHighNibble[(q) >> 4] & 0x0f)

ULONG FASTCALL
RtlXmlDefaultNextCharacter_UTF8(
    PXML_RAWTOKENIZATION_STATE pContext
    )
{
    PBYTE pb = (PBYTE)pContext->pvCursor;
    const BYTE b = pb[0];

    if ((b & 0x80) == 0) {
        return b;
    }
    //
    // Decode the UTF data - look at the top bits to determine
    // how many bytes are left in the input stream. This uses
    // the standard UTF-8 decoding mechanism.
    //
    // This is at least a two-byte encoding.  
    else {

        const BYTE FirstByteMask = MAKE_UTF8_FIRSTBYTE_BITMASK_FROM_HIGHNIBBLE(b);
        BYTE ByteCount = MAKE_UTF8_TOTAL_BYTE_COUNT_FROM_HIGHNIBBLE(b);        
        ULONG ulResult = b & FirstByteMask;

        //
        // Are there enough bytes in the input left?
        //
        if (((PVOID)(((ULONG_PTR)pb) + ByteCount)) >= pContext->pvDocumentEnd)
        {
            pContext->NextCharacterResult = STATUS_END_OF_FILE;
            return 0;
        }

        //
        // For each byte in the input, shift the current bits upwards
        // and or in the lower 6 bits of the next thing.  Start off at the
        // first trail byte.  Not exactly Duff's device, but it's close.
        //
        pb++;
        switch (ByteCount)
        {
        case 4:
            ulResult = (ulResult << 6) | ((*pb++) & 0x3f);
        case 3:
            ulResult = (ulResult << 6) | ((*pb++) & 0x3f);
        case 2:
            ulResult = (ulResult << 6) | ((*pb++) & 0x3f);
        }

        pContext->cbBytesInLastRawToken = ByteCount;
        return ulResult;

    }
}


ULONG __fastcall
RtlXmlDefaultNextCharacter(
    PXML_RAWTOKENIZATION_STATE pContext
    )
{
    ULONG ulResult = 0;

    ASSERT(pContext->cbBytesInLastRawToken == pContext->DefaultCharacterSize);
    ASSERT(pContext->NextCharacterResult == STATUS_SUCCESS);

    if (!ARGUMENT_PRESENT(pContext)) {
        return STATUS_INVALID_PARAMETER;
    }


    switch (pContext->EncodingFamily) {
    case XMLEF_UNKNOWN:
    case XMLEF_UTF_8_OR_ASCII:
        return RtlXmlDefaultNextCharacter_UTF8(pContext);
        break;

    case XMLEF_UTF_16_LE:
        {
            ulResult = *((WCHAR*)pContext->pvCursor);
            pContext->cbBytesInLastRawToken = 2;
        }
        break;

    case XMLEF_UTF_16_BE:
        {
            ulResult = (*((PBYTE)pContext->pvCursor) << 8) | (*((PBYTE)pContext->pvCursor));
            pContext->cbBytesInLastRawToken = 2;
        }
        break;
    }

    return ulResult;
}


BOOLEAN FORCEINLINE
_RtlRawXmlTokenizer_QuickReturnCheck(
    PXML_RAWTOKENIZATION_STATE pState,
    PXML_RAW_TOKEN pToken
    )
{
    if (pState->pvCursor >= pState->pvDocumentEnd) {
        pToken->Run.cbData = 0;
        pToken->Run.pvData = pState->pvDocumentEnd;
        pToken->Run.Encoding = pState->EncodingFamily;
        pToken->Run.ulCharacters = 0;
        pToken->TokenName = NTXML_RAWTOKEN_END_OF_STREAM;
        return TRUE;
    }
    else if (pState->pvLastCursor == pState->pvCursor) {
        *pToken = pState->LastTokenCache;
        return TRUE;
    }
    return FALSE;
}



//
// For now, we're dumb.
//
#define _RtlIsCharacterText(x) (TRUE)

BOOLEAN FORCEINLINE
RtlpIsCharacterLetter(ULONG ulCharacter) 
{
    //
    // BUGBUG: For now, we only care about the US english alphabet
    //
    return (((ulCharacter >= L'a') && (ulCharacter <= L'z')) || ((ulCharacter >= L'A') && (ulCharacter <= L'Z')));
}

BOOLEAN FORCEINLINE
RtlpIsCharacterDigit(ULONG ulCharacter) 
{
    return (ulCharacter >= '0') && (ulCharacter <= '9');
}

BOOLEAN FORCEINLINE
RtlpIsCharacterCombiner(ULONG ulCharacter)
{
    return FALSE;
}

BOOLEAN FORCEINLINE
RtlpIsCharacterExtender(ULONG ulCharacter)
{
    return FALSE;
}


NTXML_RAW_TOKEN FORCEINLINE FASTCALL
_RtlpDecodeCharacter(ULONG ulCharacter) {

    NTXML_RAW_TOKEN RetVal;

    switch (ulCharacter) {
    case L'-':  RetVal = NTXML_RAWTOKEN_DASH;            break;
    case L'.':  RetVal = NTXML_RAWTOKEN_DOT;             break;
    case L'=':  RetVal = NTXML_RAWTOKEN_EQUALS;          break;
    case L'/':  RetVal = NTXML_RAWTOKEN_FORWARDSLASH;    break;
    case L'>':  RetVal = NTXML_RAWTOKEN_GT;              break;
    case L'<':  RetVal = NTXML_RAWTOKEN_LT;              break;
    case L'?':  RetVal = NTXML_RAWTOKEN_QUESTIONMARK;    break;
    case L'\"': RetVal = NTXML_RAWTOKEN_DOUBLEQUOTE;     break;
    case L'\'': RetVal = NTXML_RAWTOKEN_QUOTE;           break;
    case L'[':  RetVal = NTXML_RAWTOKEN_OPENBRACKET;     break;
    case L']':  RetVal = NTXML_RAWTOKEN_CLOSEBRACKET;    break;
    case L'!':  RetVal = NTXML_RAWTOKEN_BANG;            break;
    case L'{':  RetVal = NTXML_RAWTOKEN_OPENCURLY;       break;
    case L'}':  RetVal = NTXML_RAWTOKEN_CLOSECURLY;      break;
    case L':':  RetVal = NTXML_RAWTOKEN_COLON;           break;
    case L';':  RetVal = NTXML_RAWTOKEN_SEMICOLON;       break;
    case L'_':  RetVal = NTXML_RAWTOKEN_UNDERSCORE;      break;
    case L'&':  RetVal = NTXML_RAWTOKEN_AMPERSTAND;      break;
    case L'#':  RetVal = NTXML_RAWTOKEN_POUNDSIGN;       break;
    case 0x09:
    case 0x0a:
    case 0x0d:
    case 0x20:  RetVal = NTXML_RAWTOKEN_WHITESPACE;      break;

    default:
        if (_RtlIsCharacterText(ulCharacter))
            RetVal = NTXML_RAWTOKEN_TEXT;
        else
            RetVal = NTXML_RAWTOKEN_ERROR;
    }

    return RetVal;
}


NTSTATUS FASTCALL
RtlRawXmlTokenizer_SingleToken(
    PXML_RAWTOKENIZATION_STATE pState,
    PXML_RAW_TOKEN pToken
    )
{
    ULONG ulToken;

    //
    // Determine if this hits the single-item cache, or we're at the end
    // of the document
    //
    if (pState->pvCursor >= pState->pvDocumentEnd) {
        pToken->Run.cbData = 0;
        pToken->Run.pvData = pState->pvDocumentEnd;
        pToken->Run.Encoding = pState->EncodingFamily;
        pToken->Run.ulCharacters = 0;
        pToken->TokenName = NTXML_RAWTOKEN_END_OF_STREAM;
        return STATUS_SUCCESS;
    }

    //
    // Look at the single next input token
    //
    ASSERT(pState->NextCharacterResult == STATUS_SUCCESS);
    ASSERT(pState->cbBytesInLastRawToken == pState->DefaultCharacterSize);

    ulToken = pState->pfnNextChar(pState);

    if ((ulToken == 0) && !NT_SUCCESS(pState->NextCharacterResult)) {
        return pState->NextCharacterResult;
    }

    //
    // Set up returns
    //
    pToken->Run.pvData = pState->pvCursor;
    pToken->Run.cbData = pState->cbBytesInLastRawToken;
    pToken->Run.Encoding = pState->EncodingFamily;
    pToken->Run.ulCharacters = 1;
    pToken->TokenName = _RtlpDecodeCharacter(ulToken);

    if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
        pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
    }

    //
    // Update cache
    //
    pState->pvLastCursor = pState->pvCursor;
    pState->LastTokenCache = *pToken;

    return STATUS_SUCCESS;
}






NTSTATUS FASTCALL
RtlRawXmlTokenizer_GatherWhitespace(
    PXML_RAWTOKENIZATION_STATE pState,
    PXML_RAW_TOKEN pWhitespace,
    PXML_RAW_TOKEN pTerminator
    )
{
    ULONG ulCharacter;
    ULONG ulCharCount = 0;
    NTXML_RAW_TOKEN NextToken;

    if (pState->pvCursor >= pState->pvDocumentEnd) {
        RtlZeroMemory(pState, sizeof(*pState));
        RtlZeroMemory(pTerminator, sizeof(*pTerminator));
        return STATUS_SUCCESS;
    }

    //
    // Record starting point
    //
    pWhitespace->Run.pvData = pState->pvCursor;

    ASSERT(pState->NextCharacterResult == STATUS_SUCCESS);
    ASSERT(pState->cbBytesInLastRawToken == pState->DefaultCharacterSize);

    do
    {
        //
        // Gather a character
        //
        ulCharacter = pState->pfnNextChar(pState);
        
        //
        // If this is tab, space, cr or lf, then continue.  Otherwise,
        // quit.
        //
        switch (ulCharacter) {
        case 0:
            if (!NT_SUCCESS(pState->NextCharacterResult)) {
                pState->pvCursor = pWhitespace->Run.pvData;
                return pState->NextCharacterResult;
            }
            else {
                goto SetTerminator;
            }
            break;

        case 0x9:
        case 0xa:
        case 0xd:
        case 0x20:
            ulCharCount++;
            break;
        default:
SetTerminator:
            if (pTerminator) {
                pTerminator->Run.pvData = pState->pvCursor;
                pTerminator->Run.cbData = pState->cbBytesInLastRawToken;
                pTerminator->Run.Encoding = pState->EncodingFamily;
                pTerminator->Run.ulCharacters = 1;
                pTerminator->TokenName = _RtlpDecodeCharacter(ulCharacter);
            }
            goto Done;
            break;
        }

        //
        // Advance cursor
        //
        ADVANCE_PVOID(pState->pvCursor, pState->cbBytesInLastRawToken);

        if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
            pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
        }
    }
    while (pState->pvCursor < pState->pvDocumentEnd);

    //
    // Hit the end of the document during whitespace?
    //
    if (pTerminator && (pState->pvCursor == pState->pvDocumentEnd)) {
        pTerminator->Run.cbData = 0;
        pTerminator->Run.pvData = pState->pvDocumentEnd;
        pTerminator->Run.ulCharacters = 0;
        pTerminator->Run.Encoding = pState->EncodingFamily;
        pTerminator->TokenName = NTXML_RAWTOKEN_END_OF_STREAM;
    }

    //
    // This label is here b/c if we terminated b/c of not-a-whitespace-thing,
    // then don't bother to compare against the end of the document.
    //
Done:


    //
    // Set up the other stuff in the output.
    //
    pWhitespace->Run.cbData = (PBYTE)pState->pvCursor - (PBYTE)pWhitespace->Run.pvData;
    pWhitespace->Run.ulCharacters = ulCharCount;
    pWhitespace->Run.Encoding = pState->EncodingFamily;        
    pWhitespace->TokenName = NTXML_RAWTOKEN_WHITESPACE;

    //
    // Rewind the cursor back to where we started from
    //
    pState->pvCursor = pWhitespace->Run.pvData;

    return STATUS_SUCCESS;
}


NTSTATUS FASTCALL
RtlRawXmlTokenizer_GatherPCData(
    PXML_RAWTOKENIZATION_STATE pState,
    PXML_RAW_TOKEN pPcData,
    PXML_RAW_TOKEN pNextRawToken
    )
/*++

  Purpose:

    Gathers PCDATA (anything that's not a <, &, ]]>, or end of stream) until there's
    no more.

--*/
{
    ULONG ulCbPcData = 0;
    ULONG ulCharCount = 0;

    pPcData->Run.cbData = 0;
    pPcData->Run.Encoding = pState->EncodingFamily;
    pPcData->Run.ulCharacters = 0;
    
    if (pState->pvCursor >= pState->pvDocumentEnd) {
        pPcData->Run.pvData = pState->pvDocumentEnd;
        pPcData->TokenName = NTXML_RAWTOKEN_END_OF_STREAM;
        return STATUS_SUCCESS;
    }

    pPcData->Run.pvData = pState->pvCursor;
    pPcData->TokenName = NTXML_RAWTOKEN_TEXT;

    do {

        ASSERT(pState->NextCharacterResult == STATUS_SUCCESS);
        ASSERT(pState->cbBytesInLastRawToken == pState->DefaultCharacterSize);

        switch (pState->pfnNextChar(pState)) {

            //
            // < terminates PCData, as it's probably the start of
            // a new element.
            //
        case L'<':
            if (pNextRawToken != NULL) {
                pNextRawToken->Run.cbData = pState->cbBytesInLastRawToken;
                pNextRawToken->Run.pvData = pState->pvCursor;
                pNextRawToken->Run.Encoding = pState->EncodingFamily;
                pNextRawToken->Run.ulCharacters = 1;
                pNextRawToken->TokenName = NTXML_RAWTOKEN_LT;
            }
            goto NoMore;
        case L'&':
            if (pNextRawToken != NULL) {
                pNextRawToken->Run.cbData = pState->cbBytesInLastRawToken;
                pNextRawToken->Run.pvData = pState->pvCursor;
                pNextRawToken->Run.Encoding = pState->EncodingFamily;
                pNextRawToken->Run.ulCharacters = 1;
                pNextRawToken->TokenName = NTXML_RAWTOKEN_AMPERSTAND;
            }
            goto NoMore;

            //
            // Everything else is just normal pcdata to use
            //
        default:
            ulCharCount++;
            break;

            //
            // The next-char thing returned zero, this might be a failure.
            //
        case 0:
            if (pState->NextCharacterResult != STATUS_SUCCESS) {
                return pState->NextCharacterResult;
            }
            break;
        }

        //
        // Move the cursor along
        //
        ADVANCE_PVOID(pState->pvCursor, pState->cbBytesInLastRawToken);

        //
        // If the size was different, then reset it
        //
        if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
            pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
        }
    }
    while (pState->pvCursor < pState->pvDocumentEnd);

NoMore:
    if (pNextRawToken && (pState->pvCursor >= pState->pvDocumentEnd)) {
        pNextRawToken->Run.cbData = 0;
        pNextRawToken->Run.pvData = pState->pvDocumentEnd;
        pNextRawToken->Run.Encoding = pState->EncodingFamily;
        pNextRawToken->Run.ulCharacters = 0;        
        pNextRawToken->TokenName = NTXML_RAWTOKEN_END_OF_STREAM;
    }

    pPcData->Run.cbData = (PBYTE)pState->pvCursor - (PBYTE)pPcData->Run.pvData;
    pPcData->Run.ulCharacters = ulCharCount;
    pState->pvCursor = pPcData->Run.pvData;

    if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
        pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
    }

    return STATUS_SUCCESS;
}



NTSTATUS FASTCALL
RtlRawXmlTokenizer_GatherNTokens(
    PXML_RAWTOKENIZATION_STATE pState,
    PXML_RAW_TOKEN pTokens,
    ULONG ulTokenCount
    )
{
    PVOID pvStart = pState->pvCursor;

    //
    // If we're at the document end, set all the tokens to the "end" state
    // and return immediately.
    //
    if ((ulTokenCount == 0) || (pState->pvCursor >= pState->pvDocumentEnd)) {
        goto FillEndOfDocumentTokens;
    }

    //
    // While we've got tokens left, and we're not at the end of the
    // document, start grabbing chunklets
    //
    do {

        ULONG ulCharacter;

        ASSERT(pState->NextCharacterResult == STATUS_SUCCESS);
        ASSERT(pState->cbBytesInLastRawToken == pState->DefaultCharacterSize);

        ulCharacter = pState->pfnNextChar(pState);

        //
        // If this was a zero character, then there might have been an error - 
        // see if the status was set, and if so, return
        //
        if ((ulCharacter == 0) && (pState->NextCharacterResult != STATUS_SUCCESS)) {
            return pState->NextCharacterResult;
        }

        //
        // Decode the name
        //
        pTokens->TokenName = _RtlpDecodeCharacter(ulCharacter);
        pTokens->Run.cbData = pState->cbBytesInLastRawToken;
        pTokens->Run.pvData = pState->pvCursor;
        pTokens->Run.ulCharacters = 1;
        pTokens->Run.Encoding = pState->EncodingFamily;

        //
        // If this was multibyte, reset the count back
        //
        if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
            pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
        }

        ADVANCE_PVOID(pState->pvCursor, pTokens->Run.cbData);
        pTokens++;

    }
    while (ulTokenCount-- && (pState->pvCursor < pState->pvDocumentEnd));

    if (ulTokenCount == -1) {
        ulTokenCount = 0;
    }

    //
    // Rewind input cursor
    //
    pState->pvCursor = pvStart;

    //
    // Did we find the end of the document before we ran out of tokens from the
    // input?  Then fill the remainder with the "end of document" token
    //
FillEndOfDocumentTokens:
    while (ulTokenCount--) {
        pTokens->Run.pvData = pState->pvDocumentEnd;
        pTokens->Run.cbData = 0;
        pTokens->Run.Encoding = pState->EncodingFamily;
        pTokens->Run.ulCharacters = 0;
        pTokens->TokenName = NTXML_RAWTOKEN_END_OF_STREAM;
        pTokens++;
    }

    if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
        pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
    }

    return STATUS_SUCCESS;
}








NTSTATUS FASTCALL
RtlRawXmlTokenizer_GatherIdentifier(
    PXML_RAWTOKENIZATION_STATE pState,
    PXML_RAW_TOKEN pIdentifier,
    PXML_RAW_TOKEN pStoppedOn
    )
{
    PVOID pvOriginal = pState->pvCursor;
    SIZE_T cbName = 0;
    NTXML_RAW_TOKEN TokenName;
    BOOLEAN fFirstCharFound = FALSE;
    ULONG ulCharacter;
    ULONG ulCharCount = 0;


    pIdentifier->Run.cbData = 0;
    pIdentifier->Run.ulCharacters = 0;
    pIdentifier->Run.Encoding = pState->EncodingFamily;

    if (pState->pvCursor >= pState->pvDocumentEnd) {
        pIdentifier->Run.pvData = pState->pvDocumentEnd;
        pIdentifier->TokenName = NTXML_RAWTOKEN_END_OF_STREAM;
        return STATUS_SUCCESS;
    }

    ASSERT(pState->cbBytesInLastRawToken == pState->DefaultCharacterSize);
    ASSERT(pState->NextCharacterResult == STATUS_SUCCESS);

    //
    // Start up
    //
    pIdentifier->Run.pvData = pvOriginal;
    pIdentifier->TokenName = NTXML_RAWTOKEN_ERROR;

    //
    // Start with the first character at the cursor
    ulCharacter = pState->pfnNextChar(pState);

    //
    // Badly formatted name - stop before we get too far.
    //
    if ((ulCharacter == 0) && !NT_SUCCESS(pState->NextCharacterResult)) {
        return pState->NextCharacterResult;
    }
    //
    // Not a _ or a character is a bad identifier
    //
    else if ((ulCharacter != L'_') && !RtlpIsCharacterLetter(ulCharacter)) {

        if (pStoppedOn) {
            pStoppedOn->Run.cbData = pState->cbBytesInLastRawToken;
            pStoppedOn->Run.pvData = pState->pvCursor;
            pStoppedOn->Run.ulCharacters = 1;
            pStoppedOn->Run.Encoding = pState->EncodingFamily;
            pStoppedOn->TokenName = _RtlpDecodeCharacter(ulCharacter);
        }

        if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
            pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
        }

        return STATUS_SUCCESS;
    }

    ulCharCount = 1;
    cbName = pState->cbBytesInLastRawToken;

    //
    // Reset character size if necessary
    //
    if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
        pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
    }

    //
    // Advance cursor, now just look for name characters
    //
    ADVANCE_PVOID(pState->pvCursor, pState->cbBytesInLastRawToken);

    //
    // Was that the last character in the input?
    //
    if (pStoppedOn && (pState->pvCursor >= pState->pvDocumentEnd)) {

        pStoppedOn->Run.cbData = pState->cbBytesInLastRawToken;
        pStoppedOn->Run.pvData = pState->pvCursor;
        pStoppedOn->Run.ulCharacters = 1;
        pStoppedOn->Run.Encoding = pState->EncodingFamily;
        pStoppedOn->TokenName = NTXML_RAWTOKEN_END_OF_STREAM;

        goto DoneLooking;
    }


    do {

        ulCharacter = pState->pfnNextChar(pState);

        //
        // dots, dashes, and underscores are fine
        //
        switch (ulCharacter) {
        case '.':
        case '_':
        case '-':
            break;

            //
            // If this wasn't a letter, digit, combiner, or extender, stop looking
            //
        default:
            if ((ulCharacter == 0) && !NT_SUCCESS(pState->NextCharacterResult)) {
                return pState->NextCharacterResult;
            }
            else if (!RtlpIsCharacterLetter(ulCharacter) && !RtlpIsCharacterDigit(ulCharacter) &&
                !RtlpIsCharacterCombiner(ulCharacter) && !RtlpIsCharacterExtender(ulCharacter)) {

                if (pStoppedOn) {
                    pStoppedOn->Run.cbData = pState->cbBytesInLastRawToken;
                    pStoppedOn->Run.pvData = pState->pvCursor;
                    pStoppedOn->Run.ulCharacters = 1;
                    pStoppedOn->Run.Encoding = pState->EncodingFamily;
                    pStoppedOn->TokenName = _RtlpDecodeCharacter(ulCharacter);
                }
                goto DoneLooking;
            }
            break;
        }

        ulCharCount++;

        ADVANCE_PVOID(pState->pvCursor, pState->cbBytesInLastRawToken);
        cbName += pState->cbBytesInLastRawToken;

        if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
            pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
        }

    }
    while (pState->pvCursor < pState->pvDocumentEnd);



DoneLooking:

    if (pStoppedOn && (pState->pvCursor >= pState->pvDocumentEnd)) {
        pStoppedOn->Run.cbData = 0;
        pStoppedOn->Run.pvData = pState->pvDocumentEnd;
        pStoppedOn->Run.ulCharacters = 0;
        pStoppedOn->Run.Encoding = pState->EncodingFamily;        
        pStoppedOn->TokenName = NTXML_RAWTOKEN_END_OF_STREAM;
    }

    if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
        pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
    }

    pState->pvCursor = pvOriginal;
    pIdentifier->Run.cbData = cbName;
    pIdentifier->Run.pvData = pvOriginal;
    pIdentifier->Run.ulCharacters = ulCharCount;
    pIdentifier->Run.Encoding = pState->EncodingFamily;
    pIdentifier->TokenName = NTXML_RAWTOKEN_TEXT;

    return STATUS_SUCCESS;
}









NTSTATUS FASTCALL
RtlRawXmlTokenizer_GatherUntil(
    PXML_RAWTOKENIZATION_STATE pState,
    PXML_RAW_TOKEN pGathered,
    NTXML_RAW_TOKEN StopOn,
    PXML_RAW_TOKEN pTokenFound
    )
{
    PVOID pvOriginal = pState->pvCursor;
    SIZE_T cbChunk = 0;
    ULONG ulDecoded;
    ULONG ulCharCount = 0;

    pGathered->Run.cbData = 0;
    pGathered->Run.pvData = pvOriginal;
    pGathered->Run.Encoding = pState->EncodingFamily;
    pGathered->Run.ulCharacters = 0;

    if (pState->pvCursor >= pState->pvDocumentEnd) {
        pGathered->Run.pvData = pState->pvDocumentEnd;
        pGathered->TokenName = NTXML_RAWTOKEN_END_OF_STREAM;
        return STATUS_SUCCESS;
    }

    if (pTokenFound) {
        RtlZeroMemory(pTokenFound, sizeof(*pTokenFound));
    }

    ASSERT(pState->NextCharacterResult == STATUS_SUCCESS);
    ASSERT(pState->cbBytesInLastRawToken == pState->DefaultCharacterSize);

    do 
    {
        ULONG ulCharacter = pState->pfnNextChar(pState);

        //
        // Zero character, and error?  Oops.
        //
        if ((ulCharacter == 0) && !NT_SUCCESS(pState->NextCharacterResult)) {
            pState->pvCursor = pvOriginal;
            return pState->NextCharacterResult;
        }
        //
        // Found the character we were looking for? Neat.
        //
        else if ((ulDecoded = _RtlpDecodeCharacter(ulCharacter)) == StopOn) {

            if (pTokenFound) {
                pTokenFound->Run.cbData = pState->cbBytesInLastRawToken;
                pTokenFound->Run.pvData = pState->pvCursor;
                pTokenFound->TokenName = ulDecoded;
            }

            break;
        }
        //
        // Otherwise, add on the bytes in token
        //
        else {
            cbChunk += pState->cbBytesInLastRawToken;
            ulCharCount++;
        }

        ADVANCE_PVOID(pState->pvCursor, pState->cbBytesInLastRawToken);

        if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
            pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
        }
    }
    while (pState->pvCursor < pState->pvDocumentEnd);

    //
    // If we fell off the document, say we did so.
    //
    if ((pState->pvCursor >= pState->pvDocumentEnd) && pTokenFound) {
        pTokenFound->Run.cbData = 0;
        pTokenFound->Run.pvData = pState->pvDocumentEnd;
        pTokenFound->Run.ulCharacters = 0;
        pTokenFound->Run.Encoding = pState->EncodingFamily;
        pTokenFound->TokenName = NTXML_RAWTOKEN_ERROR;
    }

    if (pState->cbBytesInLastRawToken != pState->DefaultCharacterSize) {
        pState->cbBytesInLastRawToken = pState->DefaultCharacterSize;
    }

    //
    // Indicate we're done
    //
    pState->pvCursor = pvOriginal;
    
    pGathered->Run.cbData = cbChunk;
    pGathered->Run.ulCharacters = ulCharCount;

    return STATUS_SUCCESS;
}







#define STATUS_NTXML_INVALID_FORMAT         (0xc0100000)
/*++


    At a high level in tokenization, we have a series of base states
    and places we can go next based on what kind of input we start
    getting.

--*/
NTSTATUS
RtlXmlNextToken(
    PXML_TOKENIZATION_STATE pState,
    PXML_TOKEN              pToken,
    BOOLEAN                 fAdvanceState
    )
{
    XML_STRING_COMPARE              fCompare = XML_STRING_COMPARE_LT;
    PVOID                           pvStarterCursor = NULL;
    NTSTATUS                        success = STATUS_SUCCESS;
    XML_RAW_TOKEN                   RawToken;
    XML_TOKENIZATION_SPECIFIC_STATE PreviousState;
    XML_TOKENIZATION_SPECIFIC_STATE NextState = XTSS_ERRONEOUS;
    SIZE_T                          cbTotalTokenLength = 0;
    XML_RAW_TOKEN                   NextRawToken;

    if (!ARGUMENT_PRESENT(pState)) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (!ARGUMENT_PRESENT(pToken)) {
        return STATUS_INVALID_PARAMETER_2;
    }

    //
    // Set this up
    //
    pToken->Run.cbData = 0;
    pToken->Run.pvData = pState->RawTokenState.pvCursor;
    pToken->Run.ulCharacters = 0;
    pToken->Run.Encoding = pState->RawTokenState.EncodingFamily;
    pToken->fError = FALSE;


    if (pState->PreviousState == XTSS_STREAM_END) {
        //
        // A little short circuiting - if we're in the "end of stream" logical
        // state, then we can't do anything else - just return success.
        //
        pToken->State = XTSS_STREAM_END;
        return STATUS_SUCCESS;
    }


    //
    // Stash this for later diffs
    //
    pvStarterCursor = pState->RawTokenState.pvCursor;



    //
    // Copy these onto the stack for faster lookup during token
    // processing and state detection.
    //
    PreviousState = pState->PreviousState;

    //
    // Set the outbound thing
    //
    pToken->State = PreviousState;

    switch (PreviousState)
    {

        //
        // If we just closed a state, or we're at the start of a stream, or
        // we're in hyperspace, we have to figure out what the next state
        // should be based on the raw token.
        //
    case XTSS_XMLDECL_CLOSE:
    case XTSS_ELEMENT_CLOSE:
    case XTSS_ELEMENT_CLOSE_EMPTY:
    case XTSS_ENDELEMENT_CLOSE:
    case XTSS_CDATA_CLOSE:
    case XTSS_PI_CLOSE:
    case XTSS_COMMENT_CLOSE:
    case XTSS_STREAM_START:
    case XTSS_STREAM_HYPERSPACE:

        //
        // We always need a token here to see what our next state is
        //
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            pToken->fError = TRUE;
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;


        //
        // Oh, end of stream.  Goody.
        //
        if (RawToken.TokenName == NTXML_RAWTOKEN_END_OF_STREAM) {
            NextState = XTSS_STREAM_END;
        }
        //
        // The < starts a gross bunch of detection code
        //
        else if (RawToken.TokenName == NTXML_RAWTOKEN_LT) {

            //
            // Acquire the next thing from the input stream, see what it claims to be
            //
            ADVANCE_PVOID(pState->RawTokenState.pvCursor, RawToken.Run.cbData);
            if (!NT_SUCCESS(success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken))) {
                return success;
            }



            switch (RawToken.TokenName) {

                //
                // </ is the start of an end-element
                //
            case NTXML_RAWTOKEN_FORWARDSLASH:
                cbTotalTokenLength += RawToken.Run.cbData;
                NextState = XTSS_ENDELEMENT_OPEN;
                break;




                //
                // Potentially, this could either be "xml" or just another
                // name token.  Let's see what the next token is, just to
                // be sure.
                //
            case NTXML_RAWTOKEN_QUESTIONMARK:
                {
                    cbTotalTokenLength += RawToken.Run.cbData;

                    //
                    // Defaultwise, this is just a PI opening
                    //
                    NextState = XTSS_PI_OPEN;

                    //
                    // Find the identifier out of the input
                    //
                    ADVANCE_PVOID(pState->RawTokenState.pvCursor, RawToken.Run.cbData);
                    success = RtlRawXmlTokenizer_GatherIdentifier(&pState->RawTokenState, &RawToken, NULL);
                    if (!NT_SUCCESS(success)) {
                        return success;
                    }

                    //
                    // If we got data from the identifier lookup, and the thing found was text, then maybe
                    // it's the 'xml' special PI
                    //
                    if ((RawToken.Run.cbData != 0) && (RawToken.TokenName == NTXML_RAWTOKEN_TEXT)) {

                        XML_STRING_COMPARE fMatching;

                        success = pState->pfnCompareSpecialString(
                            pState,
                            &RawToken.Run,
                            &xss_xml,
                            &fMatching);

                        if (!NT_SUCCESS(success)) {
                            return success;
                        }

                        //
                        // If these two match, then we're really in the XMLDECL
                        // element
                        //
                        if (fMatching == XML_STRING_COMPARE_EQUALS) {
                            NextState = XTSS_XMLDECL_OPEN;
                            cbTotalTokenLength += RawToken.Run.cbData;
                        }
                    }
                }
                break;



                //
                // Must be followed by two dashes
                //
            case NTXML_RAWTOKEN_BANG:
                {
                    cbTotalTokenLength += RawToken.Run.cbData;

                    //
                    // Sniff the next two raw tokens to see if they're dash-dash
                    //
                    ADVANCE_PVOID(pState->RawTokenState.pvCursor, RawToken.Run.cbData);
                    if (!NT_SUCCESS(success = RtlRawXmlTokenizer_SingleToken(
                        &pState->RawTokenState, 
                        pState->RawTokenScratch))) {
                        return success;
                    }

                    //
                    // First dash?
                    //
                    if (pState->RawTokenScratch[0].TokenName == NTXML_RAWTOKEN_DASH) {

                        ADVANCE_PVOID(pState->RawTokenState.pvCursor, pState->RawTokenScratch[0].Run.cbData);
                        if (!NT_SUCCESS(success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, pState->RawTokenScratch + 1))) {
                            return success;
                        }

                        //
                        // Second dash?
                        //
                        if (pState->RawTokenScratch[1].TokenName == NTXML_RAWTOKEN_DASH) {
                            NextState = XTSS_COMMENT_OPEN;
                            cbTotalTokenLength += 
                                pState->RawTokenScratch[0].Run.cbData +
                                pState->RawTokenScratch[1].Run.cbData;
                        }
                    }

                    //
                    // If there was <! without <!--, then that's an error.
                    //
                    if (NextState != XTSS_COMMENT_OPEN) {
                        pToken->fError = TRUE;
                    }
                }
                break;



                //
                // An open brace must be followed by !CDATA[ (bang text brace)
                //
            case NTXML_RAWTOKEN_OPENBRACKET:
                NextState = XTSS_CDATA_OPEN;
                //
                // BUGBUG - fix me, please!
                //
                break;



                //
                // Everything else starts an element section.  The next pass will decide
                // if it's valid.  Adjust the size backwards a little.
                //
            default:
                cbTotalTokenLength = RawToken.Run.cbData;
                NextState = XTSS_ELEMENT_OPEN;
                break;
            }
        }
        //
        // Otherwise, we're back in hyperspace, gather some more tokens until we find something
        // interesting - a <, 
        //
        else {
            success = RtlRawXmlTokenizer_GatherPCData(
                &pState->RawTokenState,
                &RawToken,
                &NextRawToken);

            cbTotalTokenLength = RawToken.Run.cbData;

            NextState = XTSS_STREAM_HYPERSPACE;
        }
        break;



        //
        // The open-tag can only be followed by whitespace.  Gather it up, but error out if
        // there wasn't any.
        //
    case XTSS_XMLDECL_OPEN:
        success = RtlRawXmlTokenizer_GatherWhitespace(&pState->RawTokenState, &RawToken, NULL);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;
        if ((RawToken.Run.cbData > 0) && (RawToken.TokenName == NTXML_RAWTOKEN_WHITESPACE)) {
            NextState = XTSS_XMLDECL_WHITESPACE;
        }
        else {
            pToken->fError = TRUE;
        }
        break;


        //
        // Each of these has to be followed by an equals sign
        //
    case XTSS_XMLDECL_ENCODING:
    case XTSS_XMLDECL_STANDALONE:
    case XTSS_XMLDECL_VERSION:
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;
        if (RawToken.TokenName == NTXML_RAWTOKEN_EQUALS) {
            NextState = XTSS_XMLDECL_EQUALS;
        }
        else {
            pToken->fError = TRUE;
        }
        break;







        //
        // If the next thing is a quote, then record it, otherwise
        // error out.
        //
    case XTSS_XMLDECL_EQUALS:

        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if ((RawToken.TokenName == NTXML_RAWTOKEN_QUOTE) || (RawToken.TokenName == NTXML_RAWTOKEN_DOUBLEQUOTE)) {

            pState->QuoteTemp = RawToken.TokenName;
            NextState = XTSS_XMLDECL_VALUE_OPEN;

        }
        else {
            pToken->fError = TRUE;
        }
        break;






        //
        // Values can only be followed by another quote
        //
    case XTSS_XMLDECL_VALUE:
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.TokenName == pState->QuoteTemp) {
            NextState = XTSS_XMLDECL_VALUE_CLOSE;
        }
        //
        // Otherwise, something odd was present in the input stream...
        //
        else {
            pToken->fError = TRUE;
        }

        break;





        //
        // Value-open is followed by N tokens until a close is found
        //
    case XTSS_XMLDECL_VALUE_OPEN:

        success = RtlRawXmlTokenizer_GatherUntil(&pState->RawTokenState, &RawToken, pState->QuoteTemp, &NextRawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        //
        // With luck, we'll always hit this state.  Found the closing quote value
        //
        if (NextRawToken.TokenName == pState->QuoteTemp) {
            cbTotalTokenLength = RawToken.Run.cbData;
            NextState = XTSS_XMLDECL_VALUE;
        }
        //
        // Otherwise, we found something odd (end of stream, maybe)
        else {
            pToken->fError = TRUE;
        }

        break;





        //
        // Whitespace and value-close can only be followed by more whitespace
        // or the close-PI tag
        //
    case XTSS_XMLDECL_VALUE_CLOSE:
    case XTSS_XMLDECL_WHITESPACE:

        success = RtlRawXmlTokenizer_GatherWhitespace(&pState->RawTokenState, &RawToken, &NextRawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        if ((RawToken.Run.cbData > 0) && (RawToken.TokenName == NTXML_RAWTOKEN_WHITESPACE)) {
            cbTotalTokenLength = RawToken.Run.cbData;
            NextState = XTSS_XMLDECL_WHITESPACE;
        }
        //
        // Maybe there wasn't whitespace, but the next thing was a questionmark
        //
        else if (NextRawToken.TokenName == NTXML_RAWTOKEN_QUESTIONMARK) {

            cbTotalTokenLength = NextRawToken.Run.cbData;

            ADVANCE_PVOID(pState->RawTokenState.pvCursor, NextRawToken.Run.cbData);

            success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
            if (!NT_SUCCESS(success)) {
                return success;
            }

            cbTotalTokenLength += RawToken.Run.cbData;

            //
            // ? must be followed by > in an xmldecl.
            //
            if (RawToken.TokenName == NTXML_RAWTOKEN_GT) {
                NextState = XTSS_XMLDECL_CLOSE;
            }
            else {
                pToken->fError = TRUE;
            }
        }
        //
        // If we're on whitespace, and the next raw token is a textual thing, then we can
        // probably gather up an attribute from the input.
        //
        else if ((NextRawToken.TokenName == NTXML_RAWTOKEN_TEXT) && (PreviousState == XTSS_XMLDECL_WHITESPACE)) {
            XML_STRING_COMPARE fMatching = XML_STRING_COMPARE_LT;
            ULONG u;

            static const struct {
                PXML_SPECIAL_STRING             ss;
                XML_TOKENIZATION_SPECIFIC_STATE state;
            } ComparisonStates[] = {
                { &xss_encoding,    XTSS_XMLDECL_ENCODING },
                { &xss_version,     XTSS_XMLDECL_VERSION },
                { &xss_standalone,  XTSS_XMLDECL_STANDALONE }
            };

            //
            // Snif the actual full identifier from the input stream
            //
            success = RtlRawXmlTokenizer_GatherIdentifier(&pState->RawTokenState, &RawToken, NULL);
            if (!NT_SUCCESS(success)) {
                return success;
            }

            //
            // This had better be text again
            //
            ASSERT(RawToken.TokenName == NTXML_RAWTOKEN_TEXT);
            cbTotalTokenLength = RawToken.Run.cbData;

            //
            // Look to see if it's any of the known XMLDECL attributes
            //
            for (u = 0; u < NUMBER_OF(ComparisonStates); u++) {

                success = pState->pfnCompareSpecialString(
                    pState,
                    &RawToken.Run,
                    ComparisonStates[u].ss,
                    &fMatching);

                if (!NT_SUCCESS(success)) {
                    return success;
                }

                if (fMatching == XML_STRING_COMPARE_EQUALS) {
                    NextState = ComparisonStates[u].state;
                    break;
                }

            }

            //
            // No match found means unknown xmldecl attribute name.
            //
            if (fMatching != XML_STRING_COMPARE_EQUALS) {
                pToken->fError = TRUE;
            }
        }
        else {
            pToken->fError = TRUE;
        }
        break;






        //
        // After a PI opening <?, there should come a name
        //
    case XTSS_PI_OPEN:

        success = RtlRawXmlTokenizer_GatherIdentifier(&pState->RawTokenState, &RawToken, NULL);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        //
        // Found an identifier
        //
        if ((RawToken.Run.cbData > 0) && (RawToken.TokenName == NTXML_RAWTOKEN_TEXT)) {
            NextState = XTSS_PI_TARGET;
        }
        else {
            pToken->fError = TRUE;
        }

        break;






        //
        // After a value should only come a ?> combo.
        //
    case XTSS_PI_VALUE:

        success = RtlRawXmlTokenizer_GatherNTokens(
            &pState->RawTokenState,
            pState->RawTokenScratch,
            2);

        if (!NT_SUCCESS(success)) {
            return success;
        }

        //
        // Set these up to start with
        //
        cbTotalTokenLength = pState->RawTokenScratch[0].Run.cbData + pState->RawTokenScratch[1].Run.cbData;

        //
        // After a PI must come a ?> pair
        //
        if ((pState->RawTokenScratch[0].TokenName == NTXML_RAWTOKEN_QUESTIONMARK) &&
            (pState->RawTokenScratch[1].TokenName == NTXML_RAWTOKEN_GT)) {

            NextState = XTSS_PI_CLOSE;
        }
        //
        // Otherwise, error out
        //
        else {
            pToken->fError = TRUE;
        }
        
        break;


        //
        // After a target must come either whitespace or a ?> pair.
        //
    case XTSS_PI_TARGET:

        success = RtlRawXmlTokenizer_GatherWhitespace(&pState->RawTokenState, &RawToken, &NextRawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        //
        // Whitespace present?  Dandy
        //
        if ((RawToken.Run.cbData != 0) && (RawToken.TokenName == NTXML_RAWTOKEN_WHITESPACE)) {
            NextState = XTSS_PI_WHITESPACE;
        }
        //
        // If this was a questionmark, then gather the next two items.
        //
        else if (NextRawToken.TokenName == NTXML_RAWTOKEN_QUESTIONMARK) {

            success = RtlRawXmlTokenizer_GatherNTokens(&pState->RawTokenState, pState->RawTokenScratch, 2);
            if (!NT_SUCCESS(success)) {
                return success;
            }

            cbTotalTokenLength = pState->RawTokenScratch[0].Run.cbData + pState->RawTokenScratch[1].Run.cbData;

            //
            // ?> -> PI close
            //
            if ((pState->RawTokenScratch[0].TokenName == NTXML_RAWTOKEN_QUESTIONMARK) &&
                (pState->RawTokenScratch[1].TokenName == NTXML_RAWTOKEN_GT)) {

                NextState = XTSS_PI_CLOSE;
            }
            //
            // ? just hanging out there is an error
            //
            else {
                pToken->fError = TRUE;
            }
        }
        //
        // Not starting with whitespace or a questionmark after a value name is illegal.
        //
        else {
            pToken->fError = TRUE;
        }
        break;



        //
        // After the whitespace following a PI target comes random junk until a ?> is found.
        //
    case XTSS_PI_WHITESPACE:

        cbTotalTokenLength = 0;

        do
        {
            SIZE_T cbThisChunklet = 0;

            success = RtlRawXmlTokenizer_GatherUntil(
                &pState->RawTokenState, 
                &RawToken, 
                NTXML_RAWTOKEN_QUESTIONMARK,
                &NextRawToken);

            cbThisChunklet = RawToken.Run.cbData;
            ADVANCE_PVOID(pState->RawTokenState.pvCursor, RawToken.Run.cbData);

            //
            // Found a questionmark, see if this is really ?>
            //
            if (NextRawToken.TokenName == NTXML_RAWTOKEN_QUESTIONMARK) {

                ADVANCE_PVOID(pState->RawTokenState.pvCursor, NextRawToken.Run.cbData);

                success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
                if (!NT_SUCCESS(success)) {
                    return success;
                }

                //
                // Wasn't ?> - simply forward the cursor past the two and continue
                //
                if (RawToken.TokenName != NTXML_RAWTOKEN_GT) {
                    cbThisChunklet = NextRawToken.Run.cbData + RawToken.Run.cbData;
                    ADVANCE_PVOID(pState->RawTokenState.pvCursor, cbThisChunklet);
                    continue;
                }
                else {
                    NextState = XTSS_PI_VALUE;
                }
            }
            //
            // Otherwise, was this maybe end of stream?  We'll just stop looking
            //
            else if (NextRawToken.TokenName == NTXML_RAWTOKEN_END_OF_STREAM) {
                NextState = XTSS_ERRONEOUS;
            }

            //
            // Advance the cursor and append the data to the current chunklet
            //
            cbTotalTokenLength += cbThisChunklet;
        }
        while (NextState == XTSS_ERRONEOUS);

        break;




        //
        // We gather data here until we find -- in the input stream.
        //
    case XTSS_COMMENT_OPEN:

        NextState = XTSS_ERRONEOUS;

        do 
        {
            SIZE_T cbChunk = 0;

            success = RtlRawXmlTokenizer_GatherUntil(&pState->RawTokenState, &RawToken, NTXML_RAWTOKEN_DASH, &NextRawToken);
            if (!NT_SUCCESS(success)) {
                return success;
            }

            cbChunk = RawToken.Run.cbData;

            if (NextRawToken.TokenName == NTXML_RAWTOKEN_DASH) {
                //
                // Go past the text and the dash
                //
                ADVANCE_PVOID(pState->RawTokenState.pvCursor, cbChunk + NextRawToken.Run.cbData);

                success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
                if (!NT_SUCCESS(success)) {
                    return success;
                }

                //
                // That was a dash as well - we don't want to add that to the run, but we
                // should stop looking.  Skip backwards the length of the "next" we found
                // above.
                //
                if (RawToken.TokenName == NTXML_RAWTOKEN_DASH) {
                    NextState = XTSS_COMMENT_COMMENTARY;
                    REWIND_PVOID(pState->RawTokenState.pvCursor, NextRawToken.Run.cbData);
                }
                //
                // Add the dash and the non-dash as well
                //
                else {
                    ADVANCE_PVOID(pState->RawTokenState.pvCursor, RawToken.Run.cbData);
                    cbChunk += NextRawToken.Run.cbData + RawToken.Run.cbData;
                }
            }
            //
            // End of stream found means "end of commentary" - next call through
            // here will detect the badness and return
            //
            else if (NextRawToken.TokenName == NTXML_RAWTOKEN_END_OF_STREAM) {
                NextState = XTSS_COMMENT_COMMENTARY;
            }

            cbTotalTokenLength += cbChunk;
        }
        while (NextState == XTSS_ERRONEOUS);

        break;





        //
        // After commentary can only come -->, so gather three tokens
        // and see if they're all there
        //
    case XTSS_COMMENT_COMMENTARY:
        

        //
        // Grab three tokens
        //
        success = RtlRawXmlTokenizer_GatherNTokens(
            &pState->RawTokenState,
            pState->RawTokenScratch,
            3);

        if (!NT_SUCCESS(success)) {
            return success;
        }

        //
        // Store their size
        //
        cbTotalTokenLength = 
            pState->RawTokenScratch[0].Run.cbData +
            pState->RawTokenScratch[1].Run.cbData +
            pState->RawTokenScratch[2].Run.cbData;

        //
        // If this is -->, then great.
        //
        if ((pState->RawTokenScratch[0].TokenName == NTXML_RAWTOKEN_DASH) &&
            (pState->RawTokenScratch[1].TokenName == NTXML_RAWTOKEN_DASH) &&
            (pState->RawTokenScratch[2].TokenName == NTXML_RAWTOKEN_GT)) {

            NextState = XTSS_COMMENT_CLOSE;
        }
        //
        // Otherwise, bad format.
        //
        else {
            pToken->fError = TRUE;
        }

        break;





        //
        // We had found the opening of an "end" element.  Find out
        // what it's supposed to be.
        //
    case XTSS_ENDELEMENT_OPEN:

        success = RtlRawXmlTokenizer_GatherIdentifier(
            &pState->RawTokenState,
            &RawToken,
            &NextRawToken);

        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;        

        //
        // No data in the token?  Malformed identifier
        //
        if (RawToken.Run.cbData == 0) {
            pToken->fError = TRUE;
        }
        //
        // Is the next thing a colon?  Then we got a prefix.  Otherwise,
        // we got a name.
        //
        else {
            NextState = (NextRawToken.TokenName == NTXML_RAWTOKEN_COLON) 
                ? XTSS_ENDELEMENT_NS_PREFIX
                : XTSS_ENDELEMENT_NAME;
        }

        break;



        //
        // Whitespace and endelement-name must be followed by a >
        //
    case XTSS_ENDELEMENT_NAME:
    case XTSS_ENDELEMENT_WHITESPACE:
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.TokenName == NTXML_RAWTOKEN_GT) {
            NextState = XTSS_ENDELEMENT_CLOSE;
        }
        //
        // More whitespace?  Odd, gather it and continue
        //
        else if (RawToken.TokenName == XTSS_ENDELEMENT_WHITESPACE) {

            success = RtlRawXmlTokenizer_GatherWhitespace(&pState->RawTokenState, &RawToken, NULL);
            if (!NT_SUCCESS(success)) {
                return success;
            }

            cbTotalTokenLength = RawToken.Run.cbData;
            NextState = XTSS_ENDELEMENT_WHITESPACE;
        }
        else {
            pToken->fError = TRUE;
        }
        break;







        //
        // We're in an element, so look at the next thing
        //
    case XTSS_ELEMENT_OPEN:

        success = RtlRawXmlTokenizer_GatherIdentifier(&pState->RawTokenState, &RawToken, &NextRawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }
        
        cbTotalTokenLength = RawToken.Run.cbData;
        
        //
        // Was there data in the identifier?
        //
        if (RawToken.Run.cbData > 0) {
            NextState = (NextRawToken.TokenName == NTXML_RAWTOKEN_COLON)
                ? XTSS_ELEMENT_NAME_NS_PREFIX
                : XTSS_ELEMENT_NAME;
        }
        //
        // Otherwise, there was erroneous data there
        //
        else {
            pToken->fError = TRUE;
        }

        break;





        //
        // After a prefix should only come a colon
        //
    case XTSS_ELEMENT_NAME_NS_PREFIX:
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.TokenName == NTXML_RAWTOKEN_COLON) {
            NextState = XTSS_ELEMENT_NAME_NS_COLON;
        }
        else {
            pToken->fError = TRUE;
        }
        break;





        //
        // After a colon can only come a name piece
        //
    case XTSS_ELEMENT_NAME_NS_COLON:


        success = RtlRawXmlTokenizer_GatherIdentifier(&pState->RawTokenState, &RawToken, NULL);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        //
        // If there was data in the name
        //
        if (RawToken.Run.cbData > 0) {
            NextState = XTSS_ELEMENT_NAME;
        }
        //
        // Otherwise, we found something else, error
        //
        else {
            pToken->fError = TRUE;
        }

        break;



        
        //
        // We're in the name portion of an element  Here, we should get ether
        // whitespace, /> or >.  Let's gather whitespace and see what the next token
        // after it is.
        //
    case XTSS_ELEMENT_NAME:

        success = RtlRawXmlTokenizer_GatherWhitespace(&pState->RawTokenState, &RawToken, &NextRawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.Run.cbData > 0) {
            NextState = XTSS_ELEMENT_WHITESPACE;
        }
        else {

            //
            // If the next raw token is a gt symbol, then gather it (again... ick)
            // and say we're at the end of an element
            //
            if (NextRawToken.TokenName == NTXML_RAWTOKEN_GT) {

                cbTotalTokenLength += NextRawToken.Run.cbData;
                NextState = XTSS_ELEMENT_CLOSE;
            }
            //
            // A forwardslash has to be followed by a >
            //
            else if (NextRawToken.TokenName == NTXML_RAWTOKEN_FORWARDSLASH) {

                success = RtlRawXmlTokenizer_GatherNTokens(&pState->RawTokenState, pState->RawTokenScratch, 2);
                if (!NT_SUCCESS(success)) {
                    return success;
                }

                ASSERT(pState->RawTokenScratch[0].TokenName == NTXML_RAWTOKEN_FORWARDSLASH);

                cbTotalTokenLength = 
                    pState->RawTokenScratch[0].Run.cbData + 
                    pState->RawTokenScratch[1].Run.cbData;

                //
                // /> -> close-empty
                //
                if ((pState->RawTokenScratch[1].TokenName == NTXML_RAWTOKEN_GT) &&
                    (pState->RawTokenScratch[0].TokenName == NTXML_RAWTOKEN_FORWARDSLASH)) {

                    NextState = XTSS_ELEMENT_CLOSE_EMPTY;
                }
                //
                // /* -> Oops.
                //
                else {
                    pToken->fError = TRUE;
                }
            }
            //
            // Otherwise, we got something after a name that wasn't whitespace, or
            // part of a clsoe, so that's an error
            //
            else {
                pToken->fError = TRUE;
            }
        }

        break;





        //
        // After an attribute name, the only legal thing is an equals
        // sign.
        //
    case XTSS_ELEMENT_ATTRIBUTE_NAME:
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);;
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.TokenName == NTXML_RAWTOKEN_EQUALS) {
            NextState = XTSS_ELEMENT_ATTRIBUTE_EQUALS;
        } else {
            pToken->fError = TRUE;
        }
        break;






        //
        // After an equals can only come a quote and a set of value data.  We
        // record the opening quote and gather data until the closing quote.
        //
    case XTSS_ELEMENT_ATTRIBUTE_EQUALS:
        
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        //
        // Quote or doublequote starts an attribute value
        //
        if ((RawToken.TokenName == NTXML_RAWTOKEN_QUOTE) ||
            (RawToken.TokenName == NTXML_RAWTOKEN_DOUBLEQUOTE)) {

            pState->QuoteTemp = RawToken.TokenName;
            NextState = XTSS_ELEMENT_ATTRIBUTE_OPEN;
        }
        else {
            pToken->fError = TRUE;
        }
        break;




        //
        // We gather stuff until we find the close-quote
        //
    case XTSS_ELEMENT_ATTRIBUTE_OPEN:

        ASSERT((pState->QuoteTemp == NTXML_RAWTOKEN_QUOTE) || (pState->QuoteTemp == NTXML_RAWTOKEN_DOUBLEQUOTE));

        success = RtlRawXmlTokenizer_GatherUntil(&pState->RawTokenState, &RawToken, pState->QuoteTemp, NULL);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;
        NextState = XTSS_ELEMENT_ATTRIBUTE_VALUE;

        break;






        //
        // Only followed by the same quote that opened it
        //
    case XTSS_ELEMENT_ATTRIBUTE_VALUE:

        ASSERT((pState->QuoteTemp == NTXML_RAWTOKEN_QUOTE) || (pState->QuoteTemp == NTXML_RAWTOKEN_DOUBLEQUOTE));

        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;
            
        if (RawToken.TokenName == pState->QuoteTemp) {
            NextState = XTSS_ELEMENT_ATTRIBUTE_CLOSE;
        }
        else {
            pToken->fError = TRUE;
        }
        
        break;


        
        
        
        //
        // After an attribute namespace prefix should only come a colon.
        //
    case XTSS_ELEMENT_ATTRIBUTE_NAME_NS_PREFIX:

        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.TokenName == NTXML_RAWTOKEN_COLON) {
            NextState = XTSS_ELEMENT_ATTRIBUTE_NAME_NS_COLON;
        }
        else {
            pToken->fError = TRUE;
        }
        break;




        //
        // After a colon should come only more name bits
        //
    case XTSS_ELEMENT_ATTRIBUTE_NAME_NS_COLON:

        success = RtlRawXmlTokenizer_GatherIdentifier(&pState->RawTokenState, &RawToken, NULL);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.Run.cbData > 0) {
            NextState = XTSS_ELEMENT_ATTRIBUTE_NAME;
        }
        else {
            pToken->fError = TRUE;
        }

        break;



        //
        // Attribute end-of-value and whitespace both have the same transitions to
        // the next state.
        //
    case XTSS_ELEMENT_ATTRIBUTE_CLOSE:
    case XTSS_ELEMENT_XMLNS_VALUE_CLOSE:
    case XTSS_ELEMENT_WHITESPACE:

        success = RtlRawXmlTokenizer_GatherWhitespace(&pState->RawTokenState, &RawToken, &NextRawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        if (RawToken.Run.cbData > 0) {
            cbTotalTokenLength = RawToken.Run.cbData;
            NextState = XTSS_ELEMENT_WHITESPACE;
        }
        //
        // Just a >? Then we're at "element close"
        //
        else if (NextRawToken.TokenName == NTXML_RAWTOKEN_GT) {

            cbTotalTokenLength += NextRawToken.Run.cbData;
            NextState = XTSS_ELEMENT_CLOSE;
            
        }
        //
        // Forwardslash?  See if there's a > after it
        //
        else if (NextRawToken.TokenName == NTXML_RAWTOKEN_FORWARDSLASH) {
            success = RtlRawXmlTokenizer_GatherNTokens(&pState->RawTokenState, pState->RawTokenScratch, 2);
            if (!NT_SUCCESS(success)) {
                return success;
            }

            cbTotalTokenLength = pState->RawTokenScratch[0].Run.cbData + pState->RawTokenScratch[1].Run.cbData;

            ASSERT(pState->RawTokenScratch[0].TokenName == NTXML_RAWTOKEN_FORWARDSLASH);

            if ((pState->RawTokenScratch[0].TokenName == NTXML_RAWTOKEN_FORWARDSLASH) &&
                (pState->RawTokenScratch[1].TokenName == NTXML_RAWTOKEN_GT)) {

                NextState = XTSS_ELEMENT_CLOSE_EMPTY;
            }
            else {
                pToken->fError = TRUE;
            }
        }
        //
        // Otherwise try to gather an identifier (attribute name) from the stream
        //
        else {
            success = RtlRawXmlTokenizer_GatherIdentifier(&pState->RawTokenState, &RawToken, &NextRawToken);
            if (!NT_SUCCESS(success)) {
                return success;
            }

            cbTotalTokenLength = RawToken.Run.cbData;

            //
            // Found an identifier.  Is it 'xmlns'?
            //
            if (RawToken.Run.cbData > 0) {

                success = pState->pfnCompareSpecialString(pState, &RawToken.Run, &xss_xmlns, &fCompare);
                if (!NT_SUCCESS(success)) {
                    return success;
                }

                if (fCompare == XML_STRING_COMPARE_EQUALS) {
                    switch (NextRawToken.TokenName) {
                    case NTXML_RAWTOKEN_COLON:
                        NextState = XTSS_ELEMENT_XMLNS;
                        break;
                    case NTXML_RAWTOKEN_EQUALS:
                        NextState = XTSS_ELEMENT_XMLNS_DEFAULT;
                        break;
                    default:
                        NextState = XTSS_ERRONEOUS;
                    }
                }
                else {
                    switch (NextRawToken.TokenName) {
                    case NTXML_RAWTOKEN_COLON:
                        NextState = XTSS_ELEMENT_ATTRIBUTE_NAME_NS_PREFIX;
                        break;
                    case NTXML_RAWTOKEN_EQUALS:
                        NextState = XTSS_ELEMENT_ATTRIBUTE_NAME;
                        break;
                    default:
                        NextState = XTSS_ERRONEOUS;
                    }
                }
            }
            else {
                pToken->fError = TRUE;
            }
        }
        break;


        //
        // Followed by a colon only
        //
    case XTSS_ELEMENT_XMLNS:
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.TokenName == NTXML_RAWTOKEN_COLON) {
            NextState = XTSS_ELEMENT_XMLNS_COLON;
        }
        else {
            pToken->fError = TRUE;
        }
        break;

        //
        // Followed only by an identifier
        //
    case XTSS_ELEMENT_XMLNS_COLON:
        success = RtlRawXmlTokenizer_GatherIdentifier(
            &pState->RawTokenState,
            &RawToken,
            &NextRawToken);

        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.Run.cbData > 0) {
            NextState = XTSS_ELEMENT_XMLNS_ALIAS;
        }
        else {
            pToken->fError = TRUE;
        }
        break;

        //
        // Alias followed by equals
        //
    case XTSS_ELEMENT_XMLNS_ALIAS:
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.TokenName == NTXML_RAWTOKEN_EQUALS) {
            NextState = XTSS_ELEMENT_XMLNS_EQUALS;
        }
        else {
            pToken->fError = TRUE;
        }
        break;


        //
        // Equals followed by quote
        //
    case XTSS_ELEMENT_XMLNS_EQUALS:
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if ((RawToken.TokenName == NTXML_RAWTOKEN_QUOTE) ||
            (RawToken.TokenName == NTXML_RAWTOKEN_DOUBLEQUOTE)) {

            pState->QuoteTemp = RawToken.TokenName;
            NextState = XTSS_ELEMENT_XMLNS_VALUE_OPEN;
        }
        else {
            pToken->fError = TRUE;
        }
        break;


        //
        // Value open starts the value, which continues until either the
        // end of the document or the close quote is found.  We just return
        // all the data we found, and assume the pass for XTSS_ELEMENT_XMLNS_VALUE
        // will detect the 'end of file looking for quote' error.
        //
    case XTSS_ELEMENT_XMLNS_VALUE_OPEN:
        success = RtlRawXmlTokenizer_GatherUntil(
            &pState->RawTokenState,
            &RawToken,
            pState->QuoteTemp,
            &NextRawToken);

        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;
        NextState = XTSS_ELEMENT_XMLNS_VALUE;
        break;



        //
        // Must find a quote that matches the quote we found before
        //
    case XTSS_ELEMENT_XMLNS_VALUE:
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.TokenName == pState->QuoteTemp) {
            NextState = XTSS_ELEMENT_XMLNS_VALUE_CLOSE;
        }
        else {
            pToken->fError = TRUE;
        }
        break;



        //
        // Must be followed by an equals
        //
    case XTSS_ELEMENT_XMLNS_DEFAULT:
        success = RtlRawXmlTokenizer_SingleToken(&pState->RawTokenState, &RawToken);
        if (!NT_SUCCESS(success)) {
            return success;
        }

        cbTotalTokenLength = RawToken.Run.cbData;

        if (RawToken.TokenName == NTXML_RAWTOKEN_EQUALS) {
            NextState = XTSS_ELEMENT_XMLNS_EQUALS;
        }
        else {
            pToken->fError = TRUE;
        }
        break;




        //
        // Wierd, some unhandled state.
        //
    default:
        pToken->fError = TRUE;
        break;
    }




    //
    // Reset the state of the raw tokenizer back to the original incoming state,
    // as the caller is the one that has to do the "advance"
    //
    pState->RawTokenState.pvCursor = pvStarterCursor;

    pToken->Run.cbData = cbTotalTokenLength;
    pToken->Run.pvData = pvStarterCursor;
    pToken->State = NextState;
    pToken->Run.ulCharacters = RawToken.Run.ulCharacters;
    pToken->Run.Encoding = RawToken.Run.Encoding;

    if (NT_SUCCESS(success) && pState->prgXmlTokenCallback) {
        BOOLEAN fStop = FALSE;
        
        success = (*pState->prgXmlTokenCallback)(pState->prgXmlTokenCallbackContext, pState, pToken, &fStop);
    }

    if (NT_SUCCESS(success) && fAdvanceState) {
        ADVANCE_PVOID(pState->RawTokenState.pvCursor, pToken->Run.cbData);
        pState->PreviousState = NextState;
    }

    return success;
}


NTSTATUS
RtlXmlAdvanceTokenization(
    PXML_TOKENIZATION_STATE pState,
    PXML_TOKEN pToken
    )
{
    if (!ARGUMENT_PRESENT(pState)) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (!ARGUMENT_PRESENT(pToken)) {
        return STATUS_INVALID_PARAMETER_2;
    }

    //
    // Advance the XML pointer, and advance the state
    //
    ADVANCE_PVOID(pState->RawTokenState.pvCursor, pToken->Run.cbData);
    pState->PreviousState = pToken->State;

    return STATUS_SUCCESS;
}



NTSTATUS
RtlXmlInitializeTokenization(
    PXML_TOKENIZATION_STATE     pState,
    PVOID                       pvData,
    SIZE_T                      cbData,
    NTXMLRAWNEXTCHARACTER       pfnNextCharacter,
    NTXMLSPECIALSTRINGCOMPARE   pfnSpecialStringComparison,
    NTXMLCOMPARESTRINGS         pfnNormalStringComparison
    )
{
    NTSTATUS success = STATUS_SUCCESS;

    if (!ARGUMENT_PRESENT(pState)) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (!ARGUMENT_PRESENT(pvData)) {
        return STATUS_INVALID_PARAMETER_2;
    }

    RtlZeroMemory(pState, sizeof(*pState));

    pState->RawTokenState.OriginalDocument.cbData = cbData;
    pState->RawTokenState.OriginalDocument.pvData = pState->RawTokenState.pvCursor = pvData;
    pState->RawTokenState.pvDocumentEnd = pvData;
    ADVANCE_PVOID(pState->RawTokenState.pvDocumentEnd, cbData);
    pState->RawTokenState.pfnNextChar = pfnNextCharacter ? pfnNextCharacter : RtlXmlDefaultNextCharacter;
    pState->pfnCompareSpecialString = pfnSpecialStringComparison ? pfnSpecialStringComparison : RtlXmlDefaultSpecialStringCompare;
    pState->pfnCompareStrings = pfnNormalStringComparison ? pfnNormalStringComparison : RtlXmlDefaultCompareStrings;
    pState->PreviousState = XTSS_STREAM_START;

    return success;
}

NTSTATUS
RtlXmlDetermineStreamEncoding(
    PXML_TOKENIZATION_STATE pState,
    PSIZE_T pulBytesOfEncoding,
    PXML_EXTENT pEncodingMarker
    )
/*++

  Purpose:

    Sniffs the input stream to find a BOM, an '<?xml encoding="', etc. to know
    what the encoding of this stream is.  On return the various members of
    pState that describe the stream's encoding will be set properly.

  Returns:

    STATUS_SUCCESS - Correctly determined the encoding of the XML stream.

    STATUS_INVALID_PARAMETER - If pState is NULL, or various bits of the
        state structure are set up improperly.

--*/
{
    PVOID pvCursor;
    PVOID pSense;
    XML_ENCODING_FAMILY Family = XMLEF_UTF_8_OR_ASCII;
    NTSTATUS status = STATUS_SUCCESS;
    SIZE_T t;
    XML_TOKENIZATION_STATE PrivateState;
    XML_TOKEN Token;


    static BYTE s_rgbUTF16_big_BOM[]    = { 0xFE, 0xFF };
    static BYTE s_rgbUTF16_little_BOM[] = { 0xFF, 0xFE };
    static BYTE s_rgbUCS4_big[]         = { 0x00, 0x00, 0x00, 0x3c };
    static BYTE s_rgbUCS4_little[]      = { 0x3c, 0x00, 0x00, 0x00 };
    static BYTE s_rgbUTF16_big[]        = { 0x00, 0x3C, 0x00, 0x3F };
    static BYTE s_rgbUTF16_little[]     = { 0x3C, 0x00, 0x3F, 0x00};
    static BYTE s_rgbUTF8_or_mixed[]    = { 0x3C, 0x3F, 0x78, 0x6D};
    static BYTE s_rgbUTF8_with_bom[]    = { 0xEF, 0xBB, 0xBF };

    //
    // These values for 'presumed' encoding families found at
    // http://www.xml.com/axml/testaxml.htm (Appendix F)
    //
    static struct {
        PBYTE pbSense;
        SIZE_T cbSense;
        XML_ENCODING_FAMILY Family;
        SIZE_T cbToDiscard;
        NTXMLRAWNEXTCHARACTER pfnFastDecoder;
    } EncodingCorrelation[] = {
        { s_rgbUTF16_big_BOM, NUMBER_OF(s_rgbUTF16_big_BOM),        XMLEF_UTF_16_BE, 2 },
        { s_rgbUTF16_little_BOM, NUMBER_OF(s_rgbUTF16_little_BOM),  XMLEF_UTF_16_LE, 2 },
        { s_rgbUTF16_big, NUMBER_OF(s_rgbUTF16_big),                XMLEF_UTF_16_BE, 0 },
        { s_rgbUTF16_little, NUMBER_OF(s_rgbUTF16_little),          XMLEF_UTF_16_LE, 0 },
        { s_rgbUCS4_big, NUMBER_OF(s_rgbUCS4_big),                  XMLEF_UCS_4_BE, 0 },
        { s_rgbUCS4_little, NUMBER_OF(s_rgbUCS4_little),            XMLEF_UCS_4_LE, 0 },
        { s_rgbUTF8_with_bom, NUMBER_OF(s_rgbUTF8_with_bom),        XMLEF_UTF_8_OR_ASCII, 3 },
        { s_rgbUTF8_or_mixed, NUMBER_OF(s_rgbUTF8_or_mixed),        XMLEF_UTF_8_OR_ASCII, 0 }
    };

    if (!ARGUMENT_PRESENT(pState) ||
        (pState->RawTokenState.OriginalDocument.pvData == NULL) ||
        (pulBytesOfEncoding == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!NT_SUCCESS(status = RtlXmlCloneTokenizationState(pState, &PrivateState))) {
        return status;
    }

    pvCursor = PrivateState.RawTokenState.pvCursor;
    *pulBytesOfEncoding = 0;
    RtlZeroMemory(pEncodingMarker, sizeof(*pEncodingMarker));

    //
    // Reset the cursor to the top of the XML, as that's where all this stuff is going
    // to be.
    //
    pSense = PrivateState.RawTokenState.pvCursor = PrivateState.RawTokenState.OriginalDocument.pvData;

    //
    // Since we're reading user data, we have to be careful.
    //
    __try {

        if (PrivateState.RawTokenState.OriginalDocument.cbData >= 4) {

            for (t = 0; t < NUMBER_OF(EncodingCorrelation); t++) {

                if (memcmp(EncodingCorrelation[t].pbSense, pSense, EncodingCorrelation[t].cbSense) == 0) {
                    Family = EncodingCorrelation[t].Family;
                    *pulBytesOfEncoding = EncodingCorrelation[t].cbToDiscard;
                    break;
                }
            }

        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        goto Exit;
    }

    //
    // Are we using the default next character implementation?  If so, and the
    // encoding is UTF8, then we have a faster version of the decoder.
    //
    if ((pState->RawTokenState.pfnNextChar == RtlXmlDefaultNextCharacter) && (Family == XMLEF_UTF_8_OR_ASCII)) {

        pState->RawTokenState.pfnNextChar = RtlXmlDefaultNextCharacter_UTF8;
        pState->RawTokenState.DefaultCharacterSize = pState->RawTokenState.cbBytesInLastRawToken = 1;

        PrivateState.RawTokenState.pfnNextChar = RtlXmlDefaultNextCharacter_UTF8;
        PrivateState.RawTokenState.DefaultCharacterSize = PrivateState.RawTokenState.cbBytesInLastRawToken = 1;
    }

    //
    // Now let's gather the first token from the input stream.  If it's
    // not XTSS_XMLDECL_OPEN, then quit out.  Otherwise, we need to do a little
    // work to determine the encoding - keep gathering values until the 'encoding'
    // string is found.  Advance only if there were BOM bytes.
    //
    if (*pulBytesOfEncoding != 0) {
        ADVANCE_PVOID(PrivateState.RawTokenState.pvCursor, *pulBytesOfEncoding);
    }


    if (NT_SUCCESS(status = RtlXmlNextToken(&PrivateState, &Token, TRUE))) {

        BOOLEAN fNextValueIsEncoding = FALSE;

        //
        // Didn't find the XMLDECL opening, or we found an error during
        // tokenization?  Stop looking... return success, assume the caller
        // will do the Right Thing when it calls RtlXmlNextToken itself.
        //
        if ((Token.State != XTSS_XMLDECL_OPEN) || Token.fError) {
            goto Exit;
        }

        //
        // Let's look until we find the close of the XMLDECL, the end of
        // the document, or an error, for the encoding value
        //
        do {

            status = RtlXmlNextToken(&PrivateState, &Token, TRUE);
            if (!NT_SUCCESS(status)) {
                break;
            }

            //
            // Hmm... something odd, quit looking
            //
            if (Token.fError || (Token.State == XTSS_ERRONEOUS) ||
                (Token.State == XTSS_XMLDECL_CLOSE) || (Token.State == XTSS_STREAM_END)) {
                break;
            }
            //
            // Otherwise, is this the 'encoding' marker?
            //
            else if (Token.State == XTSS_XMLDECL_ENCODING) {
                fNextValueIsEncoding = TRUE;
            }
            //
            // The caller will know how to deal with this.
            //
            else if ((Token.State == XTSS_XMLDECL_VALUE) && fNextValueIsEncoding) {
                *pEncodingMarker = Token.Run;
                break;
            }
        }
        while (TRUE);
    }

Exit:
    return status;
}


/*
\\jonwis02\h\fullbase\base\crts\langapi\undname\utf8.h
\\jonwis02\h\fullbase\com\complus\src\txf\txfaux\txfutil.cpp
*/

NTSTATUS
RtlXmlCloneRawTokenizationState(
    const PXML_RAWTOKENIZATION_STATE pStartState,
    PXML_RAWTOKENIZATION_STATE pTargetState
    )
{
    if (!pStartState || !pTargetState) {
        return STATUS_INVALID_PARAMETER;
    }

    *pTargetState = *pStartState;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlXmlCloneTokenizationState(
    const PXML_TOKENIZATION_STATE pStartState,
    PXML_TOKENIZATION_STATE pTargetState
    )
{
    if (!ARGUMENT_PRESENT(pStartState) || !ARGUMENT_PRESENT(pTargetState)) {
        return STATUS_INVALID_PARAMETER;
    }

    *pTargetState = *pStartState;

    return STATUS_SUCCESS;
}



NTSTATUS
RtlXmlCopyStringOut(
    PXML_TOKENIZATION_STATE pState,
    PXML_EXTENT             pExtent,
    PWSTR                   pwszTarget,
    SIZE_T                 *pCchResult
    )
{
    SIZE_T                      cchTotal = 0;
    SIZE_T                      cchRemains = 0;
    ULONG                       ulCharacter = 0;
    SIZE_T                      cbSoFar = 0;
    PXML_RAWTOKENIZATION_STATE  pRawState = NULL;
    PVOID                       pvOriginal = NULL;
    NTSTATUS                    status = STATUS_SUCCESS;


    if (!pState || !pExtent || !pCchResult || ((*pCchResult > 0) && !pwszTarget)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (pwszTarget) {
        *pwszTarget = UNICODE_NULL;
    }

    //
    // If the supplied space was too small, then set the outbound size
    // and complain.
    //
    if (*pCchResult < pExtent->ulCharacters) {
        *pCchResult = pExtent->ulCharacters;
        return STATUS_BUFFER_TOO_SMALL;
    }
    

    pRawState = &pState->RawTokenState;
    pvOriginal = pRawState->pvCursor;
    cchRemains = *pCchResult;

    ASSERT(pRawState->cbBytesInLastRawToken == pRawState->DefaultCharacterSize);
    ASSERT(NT_SUCCESS(pRawState->NextCharacterResult));

    //
    // Gather characters
    //
    pRawState->pvCursor = pExtent->pvData;

    for (cbSoFar = 0; cbSoFar < pExtent->cbData; cbSoFar) {

        ulCharacter = pRawState->pfnNextChar(pRawState);

        if ((ulCharacter == 0) && !NT_SUCCESS(pRawState->NextCharacterResult)) {
            status = pRawState->NextCharacterResult;
            goto Exit;
        }
        else if (ulCharacter > 0xFFFF) {
            status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        
        if (pwszTarget && (cchRemains > 0)) {
            pwszTarget[cchTotal] = (WCHAR)ulCharacter;
            cchRemains--;
        }

        cchTotal++;

        pRawState->pvCursor = (PBYTE)pRawState->pvCursor + pRawState->cbBytesInLastRawToken;
        cbSoFar += pRawState->cbBytesInLastRawToken;

        if (pRawState->cbBytesInLastRawToken != pRawState->DefaultCharacterSize) {
            pRawState->cbBytesInLastRawToken = pRawState->DefaultCharacterSize;
        }
    }

    if (*pCchResult < cchTotal) {
        status = STATUS_BUFFER_TOO_SMALL;
    }

    *pCchResult = cchTotal;

Exit:
    pState->RawTokenState.pvCursor = pvOriginal;

    return status;
}


NTSTATUS
RtlXmlIsExtentWhitespace(
    PXML_TOKENIZATION_STATE pState,
    PCXML_EXTENT            Run,
    PBOOLEAN                pfIsWhitespace
    )
{
    PVOID   pvOriginalCursor = NULL;
    SIZE_T  cbRemains;
    NTSTATUS status = STATUS_SUCCESS;
    
    if (pfIsWhitespace)
        *pfIsWhitespace = TRUE;

    if (!pState || !pfIsWhitespace)
        return STATUS_INVALID_PARAMETER;

    pvOriginalCursor = pState->RawTokenState.pvCursor;
    
    ASSERT(pState->RawTokenState.cbBytesInLastRawToken == pState->RawTokenState.DefaultCharacterSize);
    ASSERT(NT_SUCCESS(pState->RawTokenState.NextCharacterResult));
    
    if (pState->RawTokenState.cbBytesInLastRawToken != pState->RawTokenState.DefaultCharacterSize)
        pState->RawTokenState.cbBytesInLastRawToken = pState->RawTokenState.DefaultCharacterSize;

    for (cbRemains = 0; cbRemains < Run->cbData; cbRemains) {
        ULONG ulCh;

        //
        // Get character, verify result
        //
        ulCh = pState->RawTokenState.pfnNextChar(&pState->RawTokenState);
        if ((ulCh == 0) && !NT_SUCCESS(pState->RawTokenState.NextCharacterResult)) {
            status = pState->RawTokenState.NextCharacterResult;
            goto Exit;
        }

        //
        // Advance pointer
        //
        pState->RawTokenState.pvCursor = (PUCHAR)pState->RawTokenState.pvCursor + pState->RawTokenState.cbBytesInLastRawToken;

        //
        // Reset character size
        //
        if (pState->RawTokenState.cbBytesInLastRawToken != pState->RawTokenState.DefaultCharacterSize) {
            pState->RawTokenState.cbBytesInLastRawToken = pState->RawTokenState.DefaultCharacterSize;
        }

        //
        // Is this whitespace?
        //
        if (_RtlpDecodeCharacter(ulCh) != NTXML_RAWTOKEN_WHITESPACE) {
            status  = STATUS_SUCCESS;
            goto Exit;
        }
    }

    //
    // Yes, it was all whitespace
    //
    *pfIsWhitespace = TRUE;

Exit:
    pState->RawTokenState.pvCursor = pvOriginalCursor;
    return status;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\xmllib\xmlstructure.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "fasterxml.h"
#include "sxs-rtl.h"
#include "skiplist.h"
#include "namespacemanager.h"
#include "xmlstructure.h"
#include "xmlassert.h"


NTSTATUS
RtlXmlDestroyNextLogicalThing(
    PXML_LOGICAL_STATE pState
    )
{
    NTSTATUS status;

    status = RtlDestroyGrowingList(&pState->ElementStack);

    return status;

}


NTSTATUS
RtlXmlInitializeNextLogicalThing(
    PXML_LOGICAL_STATE pParseState,
    PVOID pvDataPointer,
    SIZE_T cbData,
    PRTL_ALLOCATOR Allocator
    )
{
    NTSTATUS status;
    SIZE_T cbEncodingBOM;

    RtlZeroMemory(pParseState, sizeof(*pParseState));

    status = RtlXmlInitializeTokenization(
        &pParseState->ParseState,
        pvDataPointer,
        cbData,
        NULL,
        NULL,
        NULL);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlInitializeGrowingList(
        &pParseState->ElementStack,
        sizeof(XMLDOC_THING),
        40,
        pParseState->InlineElements,
        sizeof(pParseState->InlineElements),
        Allocator);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlXmlDetermineStreamEncoding(
        &pParseState->ParseState,
        &cbEncodingBOM,
        &pParseState->EncodingMarker);

    pParseState->ParseState.RawTokenState.pvCursor =
        (PBYTE)pParseState->ParseState.RawTokenState.pvCursor + cbEncodingBOM;

    return status;
}




NTSTATUS
_RtlpFixUpNamespaces(
    XML_LOGICAL_STATE   *pState,
    PNS_MANAGER             pNsManager,
    PRTL_GROWING_LIST       pAttributes,
    PXMLDOC_THING           pThing,
    ULONG                   ulDocumentDepth
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ul = 0;
    PXMLDOC_ATTRIBUTE pAttribute = NULL;
    XML_EXTENT FoundNamespace;

    //
    // The element itself and the attributes may have namespace prefixes.  If
    // they do, then we should find the matching namespace and set that into the
    // element/attributes presented.
    //
    if (pNsManager == NULL) {
        goto Exit;
    }

    //
    // We can only deal with elements and end-elements
    //
    if ((pThing->ulThingType != XMLDOC_THING_ELEMENT) &&
        (pThing->ulThingType != XMLDOC_THING_END_ELEMENT)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check the element itself first
    //
    status = RtlNsGetNamespaceForAlias(
        pNsManager,
        ulDocumentDepth,
        (pThing->ulThingType == XMLDOC_THING_ELEMENT) 
            ? &pThing->Element.NsPrefix
            : &pThing->EndElement.NsPrefix,
        &FoundNamespace);

    if (NT_SUCCESS(status)) {
        if (pThing->ulThingType == XMLDOC_THING_ELEMENT) {
            pThing->Element.NsPrefix = FoundNamespace;
        }
        else {
            pThing->EndElement.NsPrefix = FoundNamespace;
        }
    }
    else if (status != STATUS_NOT_FOUND) {
        goto Exit;
    }

    if (pAttributes && (pThing->ulThingType == XMLDOC_THING_ELEMENT)) {

        //
        // Now for each element, find the namespace it lives in
        //
        for (ul = 0; ul < pThing->Element.ulAttributeCount; ul++) {

            status = RtlIndexIntoGrowingList(
                pAttributes,
                ul,
                (PVOID*)&pAttribute,
                FALSE);

            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            //
            // No namespace?  Don't look it up, don't look it up, don't look it up ...
            //
            if (pAttribute->NsPrefix.cbData != 0) {

                status = RtlNsGetNamespaceForAlias(
                    pNsManager,
                    ulDocumentDepth,
                    &pAttribute->NsPrefix,
                    &FoundNamespace);

                //
                // Good, mark as the namespace
                //
                if (NT_SUCCESS(status)) {
                    pAttribute->NsPrefix = FoundNamespace;
                }
                //
                // Not found namespace?  Strictly, that's an error... but, ohwell
                //
                else if (status != STATUS_NOT_FOUND) {
                    goto Exit;
                }
            }
        }
    }

    status = STATUS_SUCCESS;

Exit:
    return status;
}



NTSTATUS
RtlXmlNextLogicalThing(
    PXML_LOGICAL_STATE pParseState,
    PNS_MANAGER pNamespaceManager,
    PXMLDOC_THING pDocumentPiece,
    PRTL_GROWING_LIST pAttributeList
    )
{
    XML_TOKEN TokenWorker;
    NTSTATUS status;
    BOOLEAN fQuitLooking = FALSE;

    if (!ARGUMENT_PRESENT(pParseState) ||
        !ARGUMENT_PRESENT(pDocumentPiece)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the attribute list is there, it better have slots that are at least this big
    //
    if ((pAttributeList != NULL) && (pAttributeList->cbElementSize < sizeof(XMLDOC_ATTRIBUTE))) {
        return STATUS_INVALID_PARAMETER;
    }

TryAgain:

    RtlZeroMemory(pDocumentPiece, sizeof(*pDocumentPiece));


    status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
    if (!NT_SUCCESS(status) || TokenWorker.fError) {
        status = STATUS_UNSUCCESSFUL;
        return status;
    }

    pDocumentPiece->TotalExtent.pvData = TokenWorker.Run.pvData;
    pDocumentPiece->ulDocumentDepth = pParseState->ulElementStackDepth;
    
    //
    // The cursor should only be at a few certain points when we're called here.
    //
    switch (TokenWorker.State) {
        

        //
        // The 'next thing' thing ignores comments, as they're mostly useless.
        //
    case XTSS_COMMENT_OPEN:
        do {

            status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
            if (!NT_SUCCESS(status) ||
                TokenWorker.fError ||
                (TokenWorker.State == XTSS_COMMENT_CLOSE)) {
                break;
            }
        }
        while (TRUE);

        //
        // Stopped, let's go look again for the next thing that's not a comment
        //
        if ((TokenWorker.State == XTSS_COMMENT_CLOSE) && !TokenWorker.fError && NT_SUCCESS(status)) {
            goto TryAgain;
        }

        break;




    case XTSS_STREAM_HYPERSPACE:
        pDocumentPiece->ulThingType = XMLDOC_THING_HYPERSPACE;
        pDocumentPiece->Hyperspace = TokenWorker.Run;
        break;



        //
        // CDATA is just returned as-is
        //
    case XTSS_CDATA_OPEN:
        {
            pDocumentPiece->ulThingType   = XMLDOC_THING_CDATA;
            RtlZeroMemory(&pDocumentPiece->CDATA, sizeof(pDocumentPiece->CDATA));

            do {
                status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                if (!NT_SUCCESS(status)) {
                    goto Exit;
                } 
                else if  (TokenWorker.fError) {
                    goto MalformedCData;
                }
                else if (TokenWorker.State == XTSS_CDATA_CDATA) {
                    pDocumentPiece->CDATA = TokenWorker.Run;
                }
                else if (TokenWorker.State == XTSS_CDATA_CLOSE) {
                    break;
                }
                else {
                    goto MalformedCData;
                }
                
            } while (TRUE);

            break;

        MalformedCData:
            pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
            pDocumentPiece->Error.BadExtent = TokenWorker.Run;
            pDocumentPiece->Error.Code = XMLERROR_CDATA_MALFORMED;
            ;
        }
        break;



        //
        // Starting an xmldecl
        //
    case XTSS_XMLDECL_OPEN:
        {
            PXML_EXTENT pTargetExtent = NULL;
            
            if (pParseState->fFirstElementFound) {
                pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                pDocumentPiece->Error.Code = XMLERROR_XMLDECL_NOT_FIRST_THING;
                pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                goto Exit;
            }
            
            pDocumentPiece->ulThingType = XMLDOC_THING_XMLDECL;
            
            do {
                status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                if (!NT_SUCCESS(status)) {
                    return status;
                }
                
                if (TokenWorker.fError ||
                    (TokenWorker.State == XTSS_STREAM_END) ||
                    (TokenWorker.State == XTSS_XMLDECL_CLOSE) ||
                    (TokenWorker.State == XTSS_ERRONEOUS)) {
                    
                    break;
                }
                
                switch (TokenWorker.State) {
                case XTSS_XMLDECL_VERSION: 
                    pTargetExtent = &pDocumentPiece->XmlDecl.Version;
                    break;
                    
                case XTSS_XMLDECL_STANDALONE:
                    pTargetExtent = &pDocumentPiece->XmlDecl.Standalone;
                    break;
                    
                case XTSS_XMLDECL_ENCODING:
                    pTargetExtent = &pDocumentPiece->XmlDecl.Encoding;
                    break;
                    
                    //
                    // Put the value where it's supposed to go.  Don't do this
                    // if we don't have a target extent known.  Silently ignore
                    // (this maybe should be an error?  I think the lower-level
                    // tokenizer knows about this) unknown xmldecl instructions.
                    // 
                case XTSS_XMLDECL_VALUE:
                    if (pTargetExtent) {
                        *pTargetExtent = TokenWorker.Run;
                        pTargetExtent = NULL;
                    }
                    break;
                }
            }
            while (TRUE);
            
            //
            // We stopped for some other reason
            //
            if (TokenWorker.State != XTSS_XMLDECL_CLOSE) {
                pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                pDocumentPiece->Error.Code = XMLERROR_XMLDECL_INVALID_FORMAT;
            }
            
            fQuitLooking = TRUE;
        }
        break;
        
        
        
        //
        // A processing instruction was found.  Record it in the returned blibbet
        //
    case XTSS_PI_OPEN:
        {
            //
            // Acquire the following token
            //
            status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
            if (!NT_SUCCESS(status) || TokenWorker.fError || (TokenWorker.State != XTSS_PI_TARGET)) {
                pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                pDocumentPiece->Error.Code = XMLERROR_PI_TARGET_NOT_FOUND;
                pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                goto Exit;
            }
            
            //
            // At this point, it's a processing instruction.  Record the target name
            // and mark up the return structure
            //
            pDocumentPiece->ulThingType = XMLDOC_THING_PROCESSINGINSTRUCTION;
            pDocumentPiece->ProcessingInstruction.Target = TokenWorker.Run;
            
            //
            // Look for all the PI stuff ... if you find the end before finding the
            // value, that's fine.  Otherwise, mark the value as being 'the value'
            //
            do {
                
                status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                if (!NT_SUCCESS(status) || TokenWorker.fError) {
                    pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                    pDocumentPiece->Error.Code = XMLERROR_PI_CONTENT_ERROR;
                    pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                    goto Exit;
                }
                
                if (TokenWorker.State == XTSS_PI_VALUE) {
                    pDocumentPiece->ProcessingInstruction.Instruction = TokenWorker.Run;
                }
                //
                // Found the end of the PI
                //
                else if (TokenWorker.State == XTSS_PI_CLOSE) {
                    break;
                }
                //
                // Found end of stream instead?
                //
                else if (TokenWorker.State == XTSS_STREAM_END) {
                    pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                    pDocumentPiece->Error.Code = XMLERROR_PI_EOF_BEFORE_CLOSE;
                    pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                    break;
                }
            }
            while (TRUE);
            
        }
        break;
        
        //
        // We're starting an element.  Gather together all the attributes for the
        // element.
        //
    case XTSS_ELEMENT_OPEN:
        {
            PXMLDOC_ATTRIBUTE pElementAttribute = NULL;
            PXML_EXTENT pTargetValue = NULL;
            PXMLDOC_THING pStackElement = NULL;
            
            //
            // See what the first token after the open part is.  If it's a namespace
            // prefix, or a name, then we can deal with it.  Otherwise, it's a problem
            // for us.
            //
            status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
            if (!NT_SUCCESS(status) || TokenWorker.fError || 
                ((TokenWorker.State != XTSS_ELEMENT_NAME) && 
                (TokenWorker.State != XTSS_ELEMENT_NAME_NS_PREFIX ))) {
                
                pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                pDocumentPiece->Error.Code = XMLERROR_ELEMENT_NAME_NOT_FOUND;
                pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                goto Exit;
            }
            
            pDocumentPiece->ulThingType = XMLDOC_THING_ELEMENT;
            
            //
            // If this was a namespace prefix, save it off and skip the colon afterwards
            // to position TokenWorker at the name of the element itself
            //
            if (TokenWorker.State == XTSS_ELEMENT_NAME_NS_PREFIX) {
                
                pDocumentPiece->Element.NsPrefix = TokenWorker.Run;
                
                //
                // Consume the colon
                //
                status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                if (!NT_SUCCESS(status) || 
                    TokenWorker.fError || 
                    (TokenWorker.State != XTSS_ELEMENT_NAME_NS_COLON)) {
                    
                    pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                    pDocumentPiece->Error.Code = XMLERROR_ELEMENT_NS_PREFIX_MISSING_COLON;
                    pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                    goto Exit;
                }
                
                //
                // Fill TokenWorker with the name part
                //
                status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                if (!NT_SUCCESS(status) ||
                    TokenWorker.fError ||
                    (TokenWorker.State != XTSS_ELEMENT_NAME)) {
                    
                    pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                    pDocumentPiece->Error.Code = XMLERROR_ELEMENT_NAME_NOT_FOUND;
                    pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                    goto Exit;
                }
            }
            
            //
            // Great, we found the name of this element.
            //
            pDocumentPiece->Element.Name = TokenWorker.Run;
            pDocumentPiece->Element.ulAttributeCount = 0;
            
            //
            // Now let's go finding name/value pairs (yippee!)
            //
            do {
                status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                
                //
                // If we found a close of this element tag, then quit.
                //
                if ((TokenWorker.State == XTSS_ELEMENT_CLOSE) ||
                    (TokenWorker.State == XTSS_ELEMENT_CLOSE_EMPTY) ||
                    (TokenWorker.State == XTSS_STREAM_END) ||
                    TokenWorker.fError ||
                    !NT_SUCCESS(status)) {
                    break;
                }
                
                switch (TokenWorker.State) {

                    //
                    // Found just <foo xmlns="..."> - gather the equals and the value.
                    //
                case XTSS_ELEMENT_XMLNS_DEFAULT:
                    {
                        if (!pNamespaceManager) {
                            break;
                        }

                        do {
                            status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                            if (!NT_SUCCESS(status) || TokenWorker.fError) {
                                pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                                pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                                goto Exit;
                            }

                            //
                            // Found the xmlns value part, set it as the default
                            //
                            if (TokenWorker.State == XTSS_ELEMENT_XMLNS_VALUE) {
                                status = RtlNsInsertDefaultNamespace(
                                    pNamespaceManager,
                                    pDocumentPiece->ulDocumentDepth + 1,
                                    &TokenWorker.Run);

                                if (!NT_SUCCESS(status)) {
                                    return status;
                                }

                                break;
                            }
                        }
                        while (TokenWorker.State != XTSS_STREAM_END);
                    }
                    break;

                    //
                    // Found a <foo xmlns:beep="..."> thing
                    //
                case XTSS_ELEMENT_XMLNS_ALIAS:
                    {
                        XML_EXTENT ExtPrefix = TokenWorker.Run;

                        if (!pNamespaceManager) {
                            break;
                        }
            
                        do {
                            status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                            if (!NT_SUCCESS(status) || TokenWorker.fError) {
                                pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                                pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                                goto Exit;
                            }

                            if (TokenWorker.State == XTSS_ELEMENT_XMLNS_VALUE) {
                                status = RtlNsInsertNamespaceAlias(
                                    pNamespaceManager,
                                    pDocumentPiece->ulDocumentDepth + 1,
                                    &TokenWorker.Run,
                                    &ExtPrefix);

                                if (!NT_SUCCESS(status)) {
                                    return status;
                                }

                                break;
                            }
                        }
                        while (TokenWorker.State != XTSS_STREAM_END);
                    }
                    break;



                    //
                    // We found an attribute name, or a namespace prefix.  Allocate a new
                    // attribute off the list and set it up
                    // 
                case XTSS_ELEMENT_ATTRIBUTE_NAME_NS_PREFIX:
                case XTSS_ELEMENT_ATTRIBUTE_NAME:
                    {
                        //
                        // Skip forward if the caller didn't provide us an attribute
                        // list to fill out.
                        //
                        if (!pAttributeList) {
                            break;
                        }

                        status = RtlIndexIntoGrowingList(
                            pAttributeList,
                            pDocumentPiece->Element.ulAttributeCount,
                            (PVOID*)&pElementAttribute,
                            TRUE);
                        
                        if (!NT_SUCCESS(status)) {
                            return status;
                        }
                        
                        RtlZeroMemory(pElementAttribute, sizeof(*pElementAttribute));
                        
                        //
                        // If this was an ns prefix, write it into the attribute, discard
                        // the colon, and point TokenWorker at the actual name part.
                        //
                        if (TokenWorker.State == XTSS_ELEMENT_ATTRIBUTE_NAME_NS_PREFIX) {
                            pElementAttribute->NsPrefix = TokenWorker.Run;
                            
                            status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                            
                            //
                            // Not a colon?
                            //
                            if (!NT_SUCCESS(status) || 
                                TokenWorker.fError || 
                                (TokenWorker.State != XTSS_ELEMENT_ATTRIBUTE_NAME_NS_COLON)) {
                                
                                pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                                pDocumentPiece->Error.Code = XMLERROR_ATTRIBUTE_NS_PREFIX_MISSING_COLON;
                                pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                                goto Exit;
                            }
                            
                            //
                            // Find the attribute name itself
                            //
                            status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                            if (!NT_SUCCESS(status) ||
                                TokenWorker.fError ||
                                (TokenWorker.State != XMLERROR_ATTRIBUTE_NAME_NOT_FOUND)) {
                                
                                pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                                pDocumentPiece->Error.Code = XMLERROR_ATTRIBUTE_NAME_NOT_FOUND;
                                pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                                goto Exit;
                            }
                        }
                        
                        //
                        // TokenWorker.Run points at the part of the name that's the
                        // element name
                        //
                        pElementAttribute->Name = TokenWorker.Run;
                        
                        //
                        // The target that we're writing into is the value part of this
                        // attribute.
                        //
                        pTargetValue = &pElementAttribute->Value;
                    }
                    break;
                    
                    
                case XTSS_ELEMENT_ATTRIBUTE_VALUE:
                    //
                    // Write into the target that we had set before
                    //
                    if (pTargetValue != NULL) {
                        *pTargetValue = TokenWorker.Run;
                    }
                    //
                    // Otherwise, we found a value without a target to write it into,
                    // so that's an error.
                    //
                    else {
                        pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                        pDocumentPiece->Error.Code = XMLERROR_ATTRIBUTE_NAME_NOT_FOUND;
                        pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                        goto Exit;
                    }

                    pDocumentPiece->Element.ulAttributeCount++;
                    break;
                }
            }
            while (TRUE);
         
            //
            // Now that we're all done, go put this element on the stack
            //
            if (!TokenWorker.fError && NT_SUCCESS(status)) {
    
                ULONG ulNewDepth = pParseState->ulElementStackDepth;

                //
                // Fix up namespaces first
                //
                if (pNamespaceManager) {
                    status = _RtlpFixUpNamespaces(
                        pParseState,
                        pNamespaceManager,
                        pAttributeList,
                        pDocumentPiece,
                        pDocumentPiece->ulDocumentDepth + 1);
                }

                if (!NT_SUCCESS(status)) {
                    return status;
                }

                //
                // This is an empty element (no children), and the namespace depth frame
                // has to be left as well
                //
                if (TokenWorker.State == XTSS_ELEMENT_CLOSE_EMPTY) {
                    pDocumentPiece->Element.fElementEmpty = TRUE;

                    if (pNamespaceManager) {
                        status = RtlNsLeaveDepth(pNamespaceManager, pDocumentPiece->ulDocumentDepth + 1);
                    }
                }
                else {
                    status = RtlIndexIntoGrowingList(
                        &pParseState->ElementStack,
                        pDocumentPiece->ulDocumentDepth,
                        (PVOID*)&pStackElement,
                        TRUE);
                    
                    if (!NT_SUCCESS(status)) {
                        return status;
                    }

                    //
                    // Open tag, increment depth
                    //
                    pParseState->ulElementStackDepth++;

                    *pStackElement = *pDocumentPiece;
                }
            }

 
        }
        break;

        




        //
        // We're ending an element run, so we have to pop an item off the stack.
        //
    case XTSS_ENDELEMENT_OPEN:
        {
            PXMLDOC_THING pLastElement = NULL;

            status = RtlIndexIntoGrowingList(
                &pParseState->ElementStack,
                --pParseState->ulElementStackDepth,
                (PVOID*)&pLastElement,
                FALSE);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            //
            // Now get the current element in the stream
            //
            status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
            if (!NT_SUCCESS(status) || TokenWorker.fError || 
                ((TokenWorker.State != XTSS_ENDELEMENT_NAME) && (TokenWorker.State != XTSS_ENDELEMENT_NS_PREFIX))) {
                pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                pDocumentPiece->Error.Code = XMLERROR_ENDELEMENT_NAME_NOT_FOUND;
            }
            else {

                //
                // A namespace prefix must get recorded, and then the colon has to be skipped
                //
                if (TokenWorker.State == XTSS_ENDELEMENT_NS_PREFIX) {

                    pDocumentPiece->EndElement.NsPrefix = TokenWorker.Run;

                    //
                    // Ensure that a colon was found
                    //
                    status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                    if (!NT_SUCCESS(status) || TokenWorker.fError || (TokenWorker.State != XTSS_ENDELEMENT_NS_COLON)) {
MalformedEndElementName:
                        pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                        pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                        pDocumentPiece->Error.Code = XMLERROR_ENDELEMENT_MALFORMED_NAME;
                        goto Exit;
                    }

                    //
                    // We must get an element name
                    //
                    status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);
                    if (!NT_SUCCESS(status) || TokenWorker.fError || (TokenWorker.State != XTSS_ENDELEMENT_NAME)) {
                        goto MalformedEndElementName;
                    }
                }

                //
                // Save the name, and the opening element (which we found on the stack)
                //
                pDocumentPiece->EndElement.Name = TokenWorker.Run;
                pDocumentPiece->EndElement.OpeningElement = pLastElement->Element;
                pDocumentPiece->ulThingType = XMLDOC_THING_END_ELEMENT;
                pDocumentPiece->ulDocumentDepth--;

                //
                // And consume elements until we hit the close of an element
                //
                do {
                    status = RtlXmlNextToken(&pParseState->ParseState, &TokenWorker, TRUE);

                    if (!NT_SUCCESS(status) || TokenWorker.fError || (TokenWorker.State == XTSS_STREAM_END)) {
                        pDocumentPiece->ulThingType = XMLDOC_THING_ERROR;
                        pDocumentPiece->Error.BadExtent = TokenWorker.Run;
                        pDocumentPiece->Error.Code = XMLERROR_ENDELEMENT_MALFORMED;
                        goto Exit;
                    }
                    else if (TokenWorker.State == XTSS_ENDELEMENT_CLOSE) {
                        break;
                    }

                }
                while (TRUE);

                //
                // Fix up namespaces before returning
                //
                if (pNamespaceManager != NULL)
                {
                    status = _RtlpFixUpNamespaces(
                        pParseState,
                        pNamespaceManager,
                        NULL,
                        pDocumentPiece,
                        pLastElement->ulDocumentDepth + 1);

                    if (!NT_SUCCESS(status))
                        goto Exit;

                    status = RtlNsLeaveDepth(pNamespaceManager, pLastElement->ulDocumentDepth + 1);
                    if (!NT_SUCCESS(status))
                        goto Exit;
                }
            }

        }
        break;
        







        //
        // Oo, the end of the stream!
        //
    case XTSS_STREAM_END:
        pDocumentPiece->ulThingType = XMLDOC_THING_END_OF_STREAM;
        break;
    }


    //
    // Adjust namespace management stuff
    //
    if (pNamespaceManager) {

        //
        // Run through the element and see if there's an 'xmlns' entry
        //
        if (pDocumentPiece->ulThingType == XMLDOC_THING_ELEMENT) {

        }
    }

Exit:
    pDocumentPiece->TotalExtent.cbData = (PBYTE) pParseState->ParseState.RawTokenState.pvCursor -
        (PBYTE)pDocumentPiece->TotalExtent.pvData;

    return status;
}
    
NTSTATUS
RtlXmlExtentToString(
    PXML_RAWTOKENIZATION_STATE   pParseState,
    PXML_EXTENT             pExtent,
    PUNICODE_STRING         pString,
    PSIZE_T                 pchString
    )
{
    ULONG                       ulCharacter;
    SIZE_T                      cbData;
    SIZE_T                      chChars = 0;
    PVOID                       pvOriginal;
    NTSTATUS                    status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pchString)) {
        *pchString = 0;
    }

    ASSERT(pParseState->cbBytesInLastRawToken == 
        pParseState->DefaultCharacterSize);
    ASSERT(NT_SUCCESS(pParseState->NextCharacterResult));

    //
    // One of these has to be there
    //
    if (!ARGUMENT_PRESENT(pchString) && !ARGUMENT_PRESENT(pString)) {
        return STATUS_INVALID_PARAMETER;
    }
    else if (!ARGUMENT_PRESENT(pExtent) || !ARGUMENT_PRESENT(pParseState)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Cache some information about the raw state of the world, which we'll
    // restore on function exit.  This avoids a "copy" of the xml tokenization
    // state, which is very stack-hungry
    //
    pvOriginal = pParseState->pvCursor;
    pParseState->pvCursor = pExtent->pvData;

    for (cbData = 0; cbData < pExtent->cbData; cbData) {

        ulCharacter = pParseState->pfnNextChar(pParseState);

        if ((ulCharacter == 0) && !NT_SUCCESS(pParseState->NextCharacterResult)) {
            status = pParseState->NextCharacterResult;
            goto Exit;
        }

        //
        // If the string is given, and there's characters left in the buffer, then
        // append this char to it
        //
        if (pString && ((chChars * sizeof(WCHAR)) <= pString->MaximumLength)) {
            pString->Buffer[chChars] = (WCHAR)ulCharacter;
        }

        //
        // Up the char count found
        //
        chChars++;

        //
        // Advance the string cursor
        //
        pParseState->pvCursor = (PVOID)(((ULONG_PTR)pParseState->pvCursor) + pParseState->cbBytesInLastRawToken);

        //
        // If this was a nonstandard character, then reset the size back to the standard
        // size.
        //
        cbData += pParseState->cbBytesInLastRawToken;

        if (pParseState->cbBytesInLastRawToken != pParseState->DefaultCharacterSize) {
            pParseState->cbBytesInLastRawToken = pParseState->DefaultCharacterSize;
        }

    }

    //
    // All done.  Record the length - if it was too much, cap it at the "max length" 
    // of the string - otherwise, set it to how many characters we used.
    //
    if (ARGUMENT_PRESENT(pString)) {
        if (((chChars * sizeof(WCHAR)) > pString->MaximumLength)) {
            pString->Length = pString->MaximumLength;
        }
        else {
            pString->Length = (USHORT)(chChars * sizeof(WCHAR));
        }
    }

    if (ARGUMENT_PRESENT(pchString))
        *pchString = chChars;
    
Exit:
    pParseState->pvCursor = pvOriginal;
    return status;
}


NTSTATUS
RtlXmlMatchAttribute(
    IN PXML_TOKENIZATION_STATE      State,
    IN PXMLDOC_ATTRIBUTE            Attribute,
    IN PCXML_SPECIAL_STRING         Namespace,
    IN PCXML_SPECIAL_STRING         AttributeName,
    OUT XML_STRING_COMPARE         *CompareResult
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    if (CompareResult)
        *CompareResult = XML_STRING_COMPARE_LT;

    if (!CompareResult || !State || !Attribute || !AttributeName)
        return STATUS_INVALID_PARAMETER;

    //
    // If they asked for a namespace, then the attribute has to have
    // a namespace, and vice-versa.
    //
    if ((Namespace == NULL) != (Attribute->NsPrefix.cbData == 0)) {
        if (Namespace == NULL) {
            *CompareResult = XML_STRING_COMPARE_LT;
        }
        else {
            *CompareResult = XML_STRING_COMPARE_GT;
        }
    }

    if (Namespace != NULL) {

        status = State->pfnCompareSpecialString(
            State,
            &Attribute->NsPrefix,
            Namespace,
            CompareResult);

        if (!NT_SUCCESS(status) || (*CompareResult != XML_STRING_COMPARE_EQUALS))
            goto Exit;
    }

    status = State->pfnCompareSpecialString(
        State,
        &Attribute->Name,
        AttributeName,
        CompareResult);

    if (!NT_SUCCESS(status) || (*CompareResult != XML_STRING_COMPARE_EQUALS))
        goto Exit;

    *CompareResult = XML_STRING_COMPARE_EQUALS;
Exit:
    return status;
        
}



NTSTATUS
RtlXmlMatchLogicalElement(
    IN  PXML_TOKENIZATION_STATE     pState,
    IN  PXMLDOC_ELEMENT             pElement,
    IN  PCXML_SPECIAL_STRING        pNamespace,
    IN  PCXML_SPECIAL_STRING        pElementName,
    OUT PBOOLEAN                    pfMatches
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    XML_STRING_COMPARE Compare;

    if (pfMatches)
        *pfMatches = FALSE;

    if (!pState || !pElement || !pElementName || !pfMatches)
        return STATUS_INVALID_PARAMETER;

    if ((pNamespace == NULL) != (pElement->NsPrefix.cbData == 0))
        goto Exit;

    if (pNamespace != NULL) {

        status = pState->pfnCompareSpecialString(pState, &pElement->NsPrefix, pNamespace, &Compare);
        if (!NT_SUCCESS(status) || (Compare != XML_STRING_COMPARE_EQUALS)) {
            goto Exit;
        }
    }

    status = pState->pfnCompareSpecialString(pState, &pElement->Name, pElementName, &Compare);
    if (!NT_SUCCESS(status) || (Compare != XML_STRING_COMPARE_EQUALS))
        goto Exit;

    *pfMatches = TRUE;
Exit:
    return status;
}







NTSTATUS
RtlXmlFindAttributesInElement(
    IN  PXML_TOKENIZATION_STATE     pState,
    IN  PRTL_GROWING_LIST           pAttributeList,
    IN  ULONG                       ulAttributeCountInElement,
    IN  ULONG                       ulFindCount,
    IN  PCXML_ATTRIBUTE_DEFINITION  pAttributeNames,
    OUT PXMLDOC_ATTRIBUTE          *ppAttributes,
    OUT PULONG                      pulUnmatchedAttributes
    )
{
    NTSTATUS            status;
    PXMLDOC_ATTRIBUTE   pAttrib;
    ULONG               ul = 0;
    ULONG               attr = 0;
    XML_STRING_COMPARE  Compare;

    if (pulUnmatchedAttributes)
        *pulUnmatchedAttributes = 0;

    if (!pAttributeNames && (ulFindCount != 0))
        return STATUS_INVALID_PARAMETER;

    //
    // NULL the outbound array members appropriately
    //
    for (ul = 0; ul < ulFindCount; ul++)
        ppAttributes[ul] = NULL;

    //
    // For each attribute in the element...
    //
    for (attr = 0; attr < ulAttributeCountInElement; attr++) {

        //
        // Find this element
        //
        status = RtlIndexIntoGrowingList(pAttributeList, attr, (PVOID*)&pAttrib, FALSE);
        if (!NT_SUCCESS(status))
            goto Exit;

        //
        // Compare it to all the attributes we're looking for
        //
        for (ul = 0; ul < ulFindCount; ul++) {

            //
            // If there was a namespace, then see if it matches first
            //
            if (pAttributeNames[ul].Namespace != NULL) {

                status = pState->pfnCompareSpecialString(
                    pState,
                    &pAttrib->NsPrefix,
                    pAttributeNames[ul].Namespace,
                    &Compare);

                if (!NT_SUCCESS(status))
                    goto Exit;

                if (Compare != XML_STRING_COMPARE_EQUALS)
                    continue;
            }
            
            status = pState->pfnCompareSpecialString(
                pState,
                &pAttrib->Name,
                &pAttributeNames[ul].Name,
                &Compare);

            if (!NT_SUCCESS(status))
                goto Exit;

            if (Compare == XML_STRING_COMPARE_EQUALS) {
                ppAttributes[ul] = pAttrib;
                break;
            }
        }

        if ((ul == ulFindCount) && pulUnmatchedAttributes) {
            (*pulUnmatchedAttributes)++;
        }
    }

    status = STATUS_SUCCESS;
Exit:    
    return status;        
}

NTSTATUS
RtlXmlSkipElement(
    PXML_LOGICAL_STATE pState,
    PXMLDOC_ELEMENT TheElement
    )
{
    XMLDOC_THING TempThing;
    NTSTATUS status;
    
    if (!pState || !TheElement)
        return STATUS_INVALID_PARAMETER;
    
    if (TheElement->fElementEmpty)
        return STATUS_SUCCESS;

    while (TRUE) {
        
        status = RtlXmlNextLogicalThing(pState, NULL, &TempThing, NULL);
        if (!NT_SUCCESS(status))
            goto Exit;

        // See if the end element we found is the same as the element we're
        // looking for.
        if (TempThing.ulThingType == XMLDOC_THING_END_ELEMENT) {
            
            // If these point at the same thing, then this really is the close of this element
            if (TempThing.EndElement.OpeningElement.Name.pvData == TheElement->Name.pvData) {
                break;
            }
        }
        // The caller can deal with end of stream on their next call to
        // the logical xml advancement routine...
        else if (TempThing.ulThingType == XMLDOC_THING_END_OF_STREAM) {
            break;
        }
    }

    status = STATUS_SUCCESS;
Exit:
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\bigpath.cpp ===
#include "stdinc.h"
#include "debmacro.h"
#include "util.h"

//
// used by tools\copy_bigpath and tools\mkdir_bigpath
//

BOOL
FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer)
{
    FN_PROLOG_WIN32

    SIZE_T i = 0;
    SIZE_T j = 0;
    PWSTR FilePart = NULL;
    BOOL Unc = FALSE;

    PARAMETER_CHECK(Path != NULL);
    PARAMETER_CHECK(Path[0] != 0);
    PARAMETER_CHECK(Buffer != NULL);
    PARAMETER_CHECK(BufferSize != 0);

    if (::FusionpIsPathSeparator(Path[0])
        && ::FusionpIsPathSeparator(Path[1])
        && Path[2] == '?')
    {
        i = 1 + ::wcslen(Path);
        if (i >= BufferSize)
        {
            ::FusionpSetLastWin32Error(ERROR_BUFFER_OVERFLOW);
            goto Exit;
        }
        CopyMemory(Buffer, Path, i * sizeof(WCHAR));
        FN_SUCCESSFUL_EXIT();
    }
    else if (::FusionpIsPathSeparator(Path[0])
        && FusionpIsPathSeparator(Path[1])
        )
    {
        Unc = TRUE;
        if (BufferSize <= NUMBER_OF(L"\\\\?\\UN\\m\\s"))
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(BufferTooSmall, ERROR_BUFFER_OVERFLOW);
        }
        ::wcscpy(Buffer, L"\\\\?\\UN");
    }
    else
    {
        Unc = FALSE;
        if (BufferSize <= NUMBER_OF(L"\\\\?\\c:\\"))
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(BufferTooSmall, ERROR_BUFFER_OVERFLOW);
        }
        ::wcscpy(Buffer, L"\\\\?\\");
    }
    i = ::wcslen(Buffer);
    IFW32FALSE_ORIGINATE_AND_EXIT((j = GetFullPathNameW(Path, static_cast<ULONG>(BufferSize - i), Buffer + i, &FilePart)));
    if ((j + i + 1) >= BufferSize)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(BufferTooSmall, ERROR_BUFFER_OVERFLOW);
    }
    if (Unc)
        Buffer[i] = 'C';

    FN_EPILOG
}

BOOL
FusionpSkipBigPathRoot(PCWSTR s, OUT SIZE_T* RootLengthOut)
{
    FN_PROLOG_WIN32
    SIZE_T i = 0;

    PARAMETER_CHECK(s != NULL);
    PARAMETER_CHECK(s[0] != 0);
    PARAMETER_CHECK(memcmp(s, L"\\\\?\\", sizeof(L"\\\\?\\") - sizeof(WCHAR)) == 0);
    PARAMETER_CHECK(RootLengthOut != NULL);

    if (s[NUMBER_OF(L"\\\\?\\c:") - 2] == ':')
    {
        i += NUMBER_OF(L"\\\\?\\c:\\") - 2;
        i +=  wcsspn(s + i, L"\\/");
    }
    else
    {
        i += NUMBER_OF(L"\\\\?\\unc\\") - 1;
        i +=  wcsspn(s + i, L"\\/"); // skip "\\"
        i += wcscspn(s + i, L"\\/"); // skip "\\computer"
        i +=  wcsspn(s + i, L"\\/"); // skip "\\computer\"
        i += wcscspn(s + i, L"\\/"); // skip "\\computer\share"
        i +=  wcsspn(s + i, L"\\/"); // skip "\\computer\share\"
    }
    *RootLengthOut += i;

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\utils\sxs-rtl.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntrtl.h"
#include "ntosp.h"
#include "stdio.h"

#include "sxs-rtl.h"
#include "fasterxml.h"
#include "skiplist.h"
#include "namespacemanager.h"
#include "xmlstructure.h"
#include "sxsid.h"
#include "xmlassert.h"
#include "manifestinspection.h"

void 
RtlTraceNtSuccessFailure(
    PCSTR pcszStatement,
    NTSTATUS FailureCode,
    PCSTR pcszFileName,
    LONG LineNumber
    )
{
    CHAR SmallBuffer[512];
    STRING s;
    s.Buffer = SmallBuffer;
    s.Length = s.MaximumLength = (USHORT)_snprintf(
        "%s(%d): NTSTATUS 0x%08lx from '%s'\n",
        NUMBER_OF(SmallBuffer),
        pcszFileName,
        LineNumber,
        FailureCode,
        pcszStatement);

#if 0 // When we move to kernel mode, we should turn this on - for now, let's just use OutputDebugStringA
    DebugPrint(&s, 0, 0);
#else
    printf(SmallBuffer);
#endif
    
}


#undef NT_SUCCESS
#define NT_SUCCESS(q) (((status = (q)) < 0) ? (RtlTraceNtSuccessFailure(#q, status, __FILE__, __LINE__), FALSE) : TRUE)




NTSTATUS
RtlpGenerateIdentityFromAttributes(
    IN PXML_TOKENIZATION_STATE  pState,
    IN PXMLDOC_ATTRIBUTE        pAttributeList,
    IN ULONG                    ulAttributes,
    IN OUT PUNICODE_STRING      pusDiskName,
    IN OUT PUNICODE_STRING      pusTextualIdentity
    )
/*++

Parameters:

    pState - State of xml tokenization/parsing that can be used to extract strings
        and other stuff from the attributes in pAttributeList

    pAttributeList - Array of pointers to PXMLDOC_ATTRIBUTE structures that
        represent the identity attributes

    ulAttributes - Number of attributes in pAttributeList

    pusDiskName - Pointer to a UNICODE_STRING whose MaxLength is enough to contain
        104 wchars.  On exit, pusDiskName->Buffer will contain the on-disk identity
        of this set of attributes, and pusDiskName->Length will be the length of
        said data. (Not null terminated!)

    pusTextualIdentity - Pointer to a UNICODE_STRING which will be filled out on
        exit with the 'textual identity' of this set of attributes.
        
--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ulHash = 0;

    return status;
}



NTSTATUS
RtlGetSxsAssemblyRoot(
    ULONG           ulFlags,
    PUNICODE_STRING pusTempPathname,
    PUSHORT         pulRequiredChars
    )
{
    static const UNICODE_STRING s_us_WinSxsRoot = RTL_CONSTANT_STRING(L"\\WinSxS\\");
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING NtSystemRoot;
    USHORT usLength;

    //
    // If there was a buffer, zero out the length so a naive caller won't
    // accidentally use it.
    //
    if (pusTempPathname) {
        pusTempPathname->Length = 0;
    }

    RtlInitUnicodeString(&NtSystemRoot, USER_SHARED_DATA->NtSystemRoot);
    usLength = NtSystemRoot.Length + s_us_WinSxsRoot.Length;

    if (pulRequiredChars)
        *pulRequiredChars = usLength;

    // No buffer, or it's too small completely, then oops        
    if (!pusTempPathname || (pusTempPathname->MaximumLength < usLength)) {
        status = STATUS_BUFFER_TOO_SMALL;
    }
    // Otherwise, start copying    
    else {
        PWCHAR pwszCursor = pusTempPathname->Buffer;
        
        RtlCopyMemory(pwszCursor, NtSystemRoot.Buffer, NtSystemRoot.Length);
        RtlCopyMemory((PCHAR)pwszCursor + NtSystemRoot.Length, s_us_WinSxsRoot.Buffer, s_us_WinSxsRoot.Length);
        pusTempPathname->Length = usLength;        
    }

    return status;
}



// Installtemp identifiers are a combination of the current system time in
// a "nicely formatted" format, plus some 16-bit hex uniqueness value
#define CHARS_IN_INSTALLTEMP_IDENT      (NUMBER_OF("yyyymmddhhmmssllll.xxxx") - 1)





NTSTATUS
RtlpCreateWinSxsTempPath(
    ULONG           ulFlags,
    PUNICODE_STRING pusTempPath,
    WCHAR           wchStatic,
    USHORT          uscchStatus
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    USHORT ulLength = 0;

    if ((pusTempPath == NULL) || (ulFlags != 0)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get the length of the root path
    //
    status = RtlGetSxsAssemblyRoot(0, NULL, &ulLength);
    if (!NT_SUCCESS(status) && (status != STATUS_BUFFER_TOO_SMALL)) {
        return status;
    }
    
    ulLength += 1 + CHARS_IN_INSTALLTEMP_IDENT;

    //
    // Ensure there's space
    //
    if (ulLength >= pusTempPath->MaximumLength) {
        pusTempPath->MaximumLength = ulLength;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Get it again.
    //
    status = RtlGetSxsAssemblyRoot(0, pusTempPath, &ulLength);
    return status;
    
}




NTSTATUS
RtlpPrepareForAssemblyInstall(
    ULONG           ulFlags,
    PUNICODE_STRING pusTempPathname
    )
{
    NTSTATUS        status  = STATUS_SUCCESS;
    USHORT          ulRequired = 0;

    // Find out how long the 'root' path is.
    status = RtlGetSxsAssemblyRoot(0, NULL, &ulRequired);

    // Now let's find out how long our id is going to be

    return status;
}


const static WCHAR s_rgchBase64Encoding[] = {
    L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H', L'I', L'J', L'K', // 11
    L'L', L'M', L'N', L'O', L'P', L'Q', L'R', L'S', L'T', L'U', L'V', // 22
    L'W', L'X', L'Y', L'Z', L'a', L'b', L'c', L'd', L'e', L'f', L'g', // 33
    L'h', L'i', L'j', L'k', L'l', L'm', L'n', L'o', L'p', L'q', L'r', // 44
    L's', L't', L'u', L'v', L'w', L'x', L'y', L'z', L'0', L'1', L'2', // 55
    L'3', L'4', L'5', L'6', L'7', L'8', L'9', L'+', L'/'              // 64
};


NTSTATUS
RtlBase64Encode(
    PVOID   pvBuffer,
    SIZE_T  cbBuffer,
    PWSTR   pwszEncoded,
    PSIZE_T pcchEncoded
    )
{
    SIZE_T  cchRequiredEncodingSize;
    SIZE_T  iInput, iOutput;
    
    //
    // Null input buffer, null output size pointer, and a nonzero
    // encoded size with a null output buffer are all invalid
    // parameters
    //
    if (!pvBuffer  || !pcchEncoded || ((*pcchEncoded > 0) && !pwszEncoded)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the buffer is large enough
    //
    cchRequiredEncodingSize = ((cbBuffer + 2) / 3) * 4;

    if (*pcchEncoded < cchRequiredEncodingSize) {
        *pcchEncoded = cchRequiredEncodingSize;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Convert the input buffer bytes through the encoding table and
    // out into the output buffer.
    //
    iInput = iOutput = 0;
    while (iInput < cbBuffer) {
        const UCHAR uc0 = ((PUCHAR)pvBuffer)[iInput++];
        const UCHAR uc1 = (iInput < cbBuffer) ? ((PUCHAR)pvBuffer)[iInput++] : 0;
        const UCHAR uc2 = (iInput < cbBuffer) ? ((PUCHAR)pvBuffer)[iInput++] : 0;

        pwszEncoded[iOutput++] = s_rgchBase64Encoding[uc0 >> 2];
        pwszEncoded[iOutput++] = s_rgchBase64Encoding[((uc0 << 4) & 0x30) | ((uc1 >> 4) & 0xf)];
        pwszEncoded[iOutput++] = s_rgchBase64Encoding[((uc1 << 2) & 0x3c) | ((uc2 >> 6) & 0x3)];
        pwszEncoded[iOutput++] = s_rgchBase64Encoding[uc2 & 0x3f];
    }

    //
    // Fill in leftover bytes at the end
    //
    switch(cbBuffer % 3) {
        case 0:
            break;
            //
            // One byte out of three, add padding and fall through
            //
        case 1:
            pwszEncoded[iOutput - 2] = L'=';
            //
            // Two bytes out of three, add padding.
        case 2:
            pwszEncoded[iOutput - 1] = L'=';
            break;
    }

    return STATUS_SUCCESS;
}





NTSTATUS
RtlInstallAssembly(
    ULONG ulFlags,
    PCWSTR pcwszManifestPath
    )
{
    SIZE_T                              cbFileSize;
    PVOID                               pvFileBase = 0;
    NTSTATUS                            status;
    PRTL_MANIFEST_CONTENT_RAW           pRawContent = NULL;
    XML_TOKENIZATION_STATE              TokenizationStateUsed;
    UNICODE_STRING                      usFilePath;

    status = RtlSxsInitializeManifestRawContent(RTLIMS_GATHER_FILES, &pRawContent, NULL, 0);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    //
    // Get ahold of the file
    //
    status = RtlOpenAndMapEntireFile(pcwszManifestPath, &pvFileBase, &cbFileSize);
    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    //
    // We should have found some files
    //
    status = RtlInspectManifestStream(
        RTLIMS_GATHER_FILES, 
        pvFileBase, 
        cbFileSize, 
        pRawContent, 
        &TokenizationStateUsed);
    
    if (!NT_SUCCESS(status))
        goto Exit;

    //
    // Validate that the assembly

Exit:
    if (pRawContent) {
        RtlSxsDestroyManifestContent(pRawContent);
    }
    RtlUnmapViewOfFile(pvFileBase);

    return status;
}


BOOLEAN
RtlDosPathNameToNtPathName_Ustr(
    IN PCUNICODE_STRING DosFileNameString,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME_U RelativeName OPTIONAL
    );


NTSTATUS
RtlOpenAndMapEntireFile(
    PCWSTR pcwszFilePath,
    PVOID      *ppvMappedView,
    PSIZE_T     pcbFileSize
    )
{
    HANDLE                      SectionHandle   = INVALID_HANDLE_VALUE;
    HANDLE                      FileHandle      = INVALID_HANDLE_VALUE;
    UNICODE_STRING              ObjectName;
    OBJECT_ATTRIBUTES           ObjA;
    POBJECT_ATTRIBUTES          pObjA;
    ACCESS_MASK                 DesiredAccess;
    ULONG                       ulAllocationAttributes;
    NTSTATUS                    status;
    IO_STATUS_BLOCK             IOStatusBlock;
    BOOLEAN                        Translation;
    SIZE_T                      FileSize;
    FILE_STANDARD_INFORMATION   Info;

    if (pcbFileSize) {
        *pcbFileSize = 0;
    }

    if (ppvMappedView) {
        *ppvMappedView = NULL;
    }

    if (!ARGUMENT_PRESENT(pcwszFilePath)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!ARGUMENT_PRESENT(pcbFileSize)) {
        return STATUS_INVALID_PARAMETER;
    }
        
    if (!ARGUMENT_PRESENT(ppvMappedView)) {
        return STATUS_INVALID_PARAMETER;
    }

    Translation = RtlDosPathNameToNtPathName_U(
        pcwszFilePath,
        &ObjectName,
        NULL,
        NULL);

    if (!Translation) {
        return STATUS_NOT_FOUND;
    }


    //
    // Open the file requested
    //
    InitializeObjectAttributes(
        &ObjA,
        &ObjectName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtOpenFile(
        &FileHandle,
        FILE_GENERIC_READ,
        &ObjA,
        &IOStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_DELETE,
        FILE_NON_DIRECTORY_FILE);

    if (!NT_SUCCESS(status)) {
        goto ErrorExit;
    }

    status = NtQueryInformationFile(
        FileHandle,
        &IOStatusBlock,
        &Info,
        sizeof(Info),
        FileStandardInformation);

    if (!NT_SUCCESS(status)) {
        goto ErrorExit;
    }

    *pcbFileSize = (SIZE_T)Info.EndOfFile.QuadPart;

    status = NtCreateSection(
        &SectionHandle,
        SECTION_MAP_READ | SECTION_QUERY,
        NULL,
        NULL,
        PAGE_READONLY,
        SEC_COMMIT,
        FileHandle);

    if (!NT_SUCCESS(status)) {
        goto ErrorExit;
    }

    //
    // Don't need the file object anymore, unmap it
    //
    status = NtClose(FileHandle);
    FileHandle = INVALID_HANDLE_VALUE;;

    *ppvMappedView = NULL;

    //
    // Map the whole file
    //
    status = NtMapViewOfSection(
        SectionHandle,
        NtCurrentProcess(),
        ppvMappedView,
        0,                  // Zero bits
        0,                  // Committed size
        NULL,               // SectionOffset
        pcbFileSize,        // Size of this file, in bytes
        ViewShare,
        0,
        PAGE_READONLY);

    status = NtClose(SectionHandle);
    SectionHandle = INVALID_HANDLE_VALUE;

    //
    // Reset this - the NtMapViewOfSection allocates on page granularity
    //
    *pcbFileSize = (SIZE_T)Info.EndOfFile.QuadPart;

Exit:
    return status;


ErrorExit:
    if (FileHandle != INVALID_HANDLE_VALUE) {
        NtClose(FileHandle);
        FileHandle = INVALID_HANDLE_VALUE;
    }

    if (SectionHandle != INVALID_HANDLE_VALUE) {
        NtClose(SectionHandle);
        SectionHandle = INVALID_HANDLE_VALUE;
    }

    if (ppvMappedView && (*ppvMappedView != NULL)) {
        NTSTATUS newstatus = NtUnmapViewOfSection(NtCurrentProcess(), *ppvMappedView);

        //
        // Failed while failing
        //
        if (!NT_SUCCESS(newstatus)) {
        }

        *pcbFileSize = 0;
    }

    goto Exit;
}



NTSTATUS
RtlUnmapViewOfFile(
    PVOID pvBase
    )
{
    NTSTATUS status;

    status = NtUnmapViewOfSection(
        NtCurrentProcess(),
        pvBase);

    return status;
}


NTSTATUS FASTCALL
RtlMiniHeapAlloc(
    SIZE_T  cb,
    PVOID  *ppvAllocated,
    PVOID   pvContext
    )
{
    PRTL_MINI_HEAP pContent = (PRTL_MINI_HEAP)pvContext;

    if ((pContent == NULL) || (ppvAllocated == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (pContent->cbAvailableBytes < cb) {
        return g_DefaultAllocator.pfnAlloc(cb, ppvAllocated, NULL);
    }
    else {
        *ppvAllocated = pContent->pvNextAvailableByte;
        pContent->cbAvailableBytes -= cb;
        pContent->pvNextAvailableByte = (PUCHAR)pContent->pvNextAvailableByte + cb;

        return STATUS_SUCCESS;
    }
}

NTSTATUS FASTCALL
RtlMiniHeapFree(
    PVOID   pvAllocation,
    PVOID   pvContext
    )
{
    PRTL_MINI_HEAP pContent = (PRTL_MINI_HEAP)pvContext;

    if ((pvAllocation < pContent->pvAllocationBase) ||
        (pvAllocation >= (PVOID)((PUCHAR)pContent->pvAllocationBase + pContent->cbOriginalSize)))
    {
        return g_DefaultAllocator.pfnFree(pvAllocation, NULL);
    }
    else {
        return STATUS_SUCCESS;
    }
}


NTSTATUS FASTCALL
RtlInitializeMiniHeap(
    PRTL_MINI_HEAP MiniHeap,
    PVOID pvTargetRegion,
    SIZE_T cbRegionSize
    )
{
    if (!MiniHeap || !(pvTargetRegion || (cbRegionSize == 0))) {
        return STATUS_INVALID_PARAMETER;
    }

    MiniHeap->pvNextAvailableByte = pvTargetRegion;
    MiniHeap->pvAllocationBase = pvTargetRegion;
    MiniHeap->cbAvailableBytes = cbRegionSize;
    MiniHeap->cbOriginalSize = cbRegionSize;

    return STATUS_SUCCESS;    
}

NTSTATUS FASTCALL
RtlInitializeMiniHeapInPlace(
    PVOID   pvRegion,
    SIZE_T  cbOriginalSize,
    PRTL_MINI_HEAP *ppMiniHeap
    )
{
    PRTL_MINI_HEAP pMiniHeapTemp = NULL;
    
    if (!ppMiniHeap)
        return STATUS_INVALID_PARAMETER;

    *ppMiniHeap = NULL;

    if (!(pvRegion || (cbOriginalSize == 0))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (cbOriginalSize < sizeof(RTL_MINI_HEAP)) {
        return STATUS_NO_MEMORY;
    }

    pMiniHeapTemp = (PRTL_MINI_HEAP)pvRegion;
    pMiniHeapTemp->cbAvailableBytes = cbOriginalSize - sizeof(RTL_MINI_HEAP);
    pMiniHeapTemp->cbOriginalSize = pMiniHeapTemp->cbAvailableBytes;
    pMiniHeapTemp->pvAllocationBase = pMiniHeapTemp + 1;
    pMiniHeapTemp->pvNextAvailableByte = pMiniHeapTemp->pvAllocationBase;

    *ppMiniHeap = pMiniHeapTemp;
    return STATUS_SUCCESS;    
}



NTSTATUS
RtlpConvertHexStringToBytes(
    PUNICODE_STRING pSourceString,
    PBYTE pbTarget,
    SIZE_T cbTarget
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PCWSTR pcSource = pSourceString->Buffer;
    ULONG ul = 0;

    if (cbTarget < (pSourceString->Length / (2 * sizeof(WCHAR)))) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    else if ((pSourceString->Length % sizeof(WCHAR)) != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    for (ul = 0; ul < (pSourceString->Length / sizeof(pSourceString->Buffer[0])); ul += 2) {

        BYTE bvLow, bvHigh;
        const WCHAR wchFirst = *pcSource++;
        const WCHAR wchSecond = *pcSource++;

        //
        // Set the high nibble
        //
        switch (wchFirst) {
        case L'0': case L'1': case L'2': case L'3':
        case L'4': case L'5': case L'6': case L'7':
        case L'8': case L'9':
            bvHigh = wchFirst - L'0';
            break;

        case L'a': case L'b': case L'c':
        case L'd': case L'e': case L'f':
            bvHigh = (wchFirst - L'a') + 0x10;
            break;

        case L'A': case L'B': case L'C':
        case L'D': case L'E': case L'F':
            bvHigh = (wchFirst - L'A') + 0x10;
            break;

        default:
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Set the high nibble
        //
        switch (wchSecond) {
        case L'0': case L'1': case L'2': case L'3':
        case L'4': case L'5': case L'6': case L'7':
        case L'8': case L'9':
            bvLow = wchSecond - L'0';
            break;

        case L'a': case L'b': case L'c':
        case L'd': case L'e': case L'f':
            bvLow = (wchSecond - L'a') + 0x10;
            break;

        case L'A': case L'B': case L'C':
        case L'D': case L'E': case L'F':
            bvLow = (wchSecond - L'A') + 0x10;
            break;

        default:
            return STATUS_INVALID_PARAMETER;
        }

        pbTarget[ul / 2] = (bvHigh << 4) | bvLow;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\checksetupmode.cpp ===
#include "stdinc.h"
#include "FusionBuffer.h"
#include "Util.h"
#include "FusionHandle.h"

// NTRAID#NTBUG9 - 574025 - jonwis - 2002/04/25 - Initialize to NULL for safety
HKEY s_hkeySystemSetup;
#if DBG
#if defined(__cplusplus)
extern "C"
{
#endif
BOOL g_fForceInOsSetupMode;
BOOL g_fForceInMiniSetupMode;
#if defined(__cplusplus)
}
#endif
#endif

BOOL
WINAPI
FusionpAreWeInOSSetupModeMain(
    HINSTANCE Module,
    DWORD Reason,
    PVOID Reserved
    )
{
    FN_PROLOG_WIN32
    LONG lRegOp = 0;

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        {
        BOOL fOpenKeyFail = FALSE;
        IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS2(
            ::RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"System\\Setup", 0, KEY_READ | FUSIONP_KEY_WOW64_64KEY, &s_hkeySystemSetup),
            LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_ACCESS_DENIED),
            fOpenKeyFail);
        }
        break;

    case DLL_PROCESS_DETACH:
        if (s_hkeySystemSetup != NULL)
        {
            if (Reserved == NULL)
            {
                if ((lRegOp = RegCloseKey(s_hkeySystemSetup)) != ERROR_SUCCESS)
                {
                    ::FusionpSetLastWin32Error(lRegOp);
                    TRACE_WIN32_FAILURE(RegCloseKey);
                    // but eat the error
                }
            }
            s_hkeySystemSetup = NULL;
        }
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }
    
    FN_EPILOG
}

BOOL
FusionpAreWeInSpecifiedSetupMode(
    BOOL* pfIsInSetup,
#if DBG
    BOOL* pfGlobalOverride,
#endif
    PCWSTR pszValueName
    )
{
    //
    // Queries to see if we're currently in OS-setup mode.  This is required to avoid
    // some trickiness in the SFC protection system, where we don't want to validate
    // hashes and catalogs during setup.  We just assume that whoever is installing us
    // is really a nice guy and won't muck up the assemblies.
    //
    FN_PROLOG_WIN32;
    DWORD   dwType = 0;
    DWORD   dwData = 0;
    DWORD   cbData = sizeof(dwData);
    bool    fRegFileNotFound;

    PARAMETER_CHECK(pfIsInSetup != NULL);

    if (s_hkeySystemSetup == NULL)
    {
        *pfIsInSetup = FALSE;
        FN_SUCCESSFUL_EXIT();
    }
#if DBG
    if (*pfGlobalOverride)
    {
        *pfIsInSetup = TRUE;
        FN_SUCCESSFUL_EXIT();
    }
#endif

    *pfIsInSetup = FALSE;

    cbData = sizeof(dwData);

    IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS2(
        ::RegQueryValueExW(
                        s_hkeySystemSetup,
                        pszValueName,
                        NULL,
                        &dwType,
                        reinterpret_cast<PBYTE>(&dwData),
                        &cbData
                        ),
        { ERROR_FILE_NOT_FOUND },
        fRegFileNotFound
        );
    if (fRegFileNotFound)
    {
        FN_SUCCESSFUL_EXIT();
    }
    if (dwType != REG_DWORD)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(RegQueryValueExW, ERROR_DATATYPE_MISMATCH);
    }

    if (dwData != 0)
        *pfIsInSetup = TRUE;

    FN_EPILOG;
}

BOOL
FusionpAreWeInOSSetupMode(
    BOOL* pfIsInSetup
    )
{
    return
        FusionpAreWeInSpecifiedSetupMode(
            pfIsInSetup,
#if DBG
            &g_fForceInOsSetupMode,
#endif
            L"SystemSetupInProgress"
        );
}

BOOL
FusionpAreWeInMiniSetupMode(
    BOOL* pfIsInSetup
    )
{
    return
        FusionpAreWeInSpecifiedSetupMode(
            pfIsInSetup,
#if DBG
            &g_fForceInMiniSetupMode,
#endif
            L"MiniSetupInProgress"
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\xmllib\xmllib\namespacemanager.c ===
#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "fasterxml.h"
#include "sxs-rtl.h"
#include "skiplist.h"
#include "namespacemanager.h"
#include "xmlassert.h"

NTSTATUS
RtlNsInitialize(
    PNS_MANAGER             pManager,
    PFNCOMPAREEXTENTS       pCompare,
    PVOID                   pCompareContext,
    PRTL_ALLOCATOR          Allocation
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    RtlZeroMemory(pManager, sizeof(pManager));


    status = RtlInitializeGrowingList(
        &pManager->DefaultNamespaces,
        sizeof(NS_NAME_DEPTH),
        50,
        pManager->InlineDefaultNamespaces,
        sizeof(pManager->InlineDefaultNamespaces),
        Allocation);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlInitializeGrowingList(
        &pManager->Aliases,
        sizeof(NS_ALIAS),
        50,
        pManager->InlineAliases,
        sizeof(pManager->InlineAliases),
        Allocation);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    pManager->pvCompareContext = pCompareContext;
    pManager->pfnCompare = pCompare;
    pManager->ulAliasCount = 0;

    //
    // Should be golden at this point, everything else is zero-initialized, so that's
    // just dandy.
    //
    return status;
}



NTSTATUS
RtlNsDestroy(
    PNS_MANAGER pManager
    )
{
    return STATUS_NOT_IMPLEMENTED;
}



NTSTATUS
RtlNsInsertNamespaceAlias(
    PNS_MANAGER     pManager,
    ULONG           ulDepth,
    PXML_EXTENT     Namespace,
    PXML_EXTENT     Alias
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PNS_NAME_DEPTH pNameDepth = NULL;
    PNS_ALIAS pNsAliasSlot = NULL;
    PNS_ALIAS pNsFreeSlot = NULL;
    ULONG ul = 0;
    XML_STRING_COMPARE Equals = XML_STRING_COMPARE_EQUALS;


    //
    // Run through all the aliases we currently have, see if any of them are
    // the one we've got - in which case, we push-down a new namespace on that
    // alias.  As we're going, track to find a free slot, in case we don't find
    // it in the list
    //
    for (ul = 0; ul < pManager->ulAliasCount; ul++) {

        status = RtlIndexIntoGrowingList(
            &pManager->Aliases,
            ul,
            (PVOID*)&pNsAliasSlot,
            FALSE);

        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        //
        // If we found a hole, stash it
        //
        if (!pNsAliasSlot->fInUse) {

            if (pNsFreeSlot == NULL)
                pNsFreeSlot = pNsAliasSlot;

        }
        //
        // Does this alias match?
        //
        else {

            status = pManager->pfnCompare(
                pManager->pvCompareContext,
                Alias,
                &pNsAliasSlot->AliasName,
                &Equals);

            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            //
            // Not equals, continue
            //
            if (Equals != XML_STRING_COMPARE_EQUALS) {
                pNsAliasSlot = NULL;
            }
            //
            // Otherwise, stop
            //
            else {
                break;
            }
        };
    }


    //
    // We didn't find the alias slot that this fits in to, so see if we can
    // find a free one and initialize it.
    //
    if (pNsAliasSlot == NULL) {

        //
        // Didn't find a free slot, either - add a new entry to the list
        // and go from there
        //
        if (pNsFreeSlot == NULL) {

            status = RtlIndexIntoGrowingList(
                &pManager->Aliases,
                pManager->ulAliasCount++,
                (PVOID*)&pNsFreeSlot,
                TRUE);

            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            //
            // Init this, it just came out of the 'really free' list
            //
            RtlZeroMemory(pNsFreeSlot, sizeof(*pNsFreeSlot));

            status = RtlInitializeGrowingList(
                &pNsFreeSlot->NamespaceMaps,
                sizeof(NS_NAME_DEPTH),
                20,
                pNsFreeSlot->InlineNamespaceMaps,
                sizeof(pNsFreeSlot->InlineNamespaceMaps),
                &pManager->Aliases.Allocator);

            if (!NT_SUCCESS(status)) {
                goto Exit;
            }
        }

        ASSERT(pNsFreeSlot != NULL);

        pNsAliasSlot = pNsFreeSlot;

        //
        // Zero init this one
        //
        pNsAliasSlot->fInUse = TRUE;
        pNsAliasSlot->ulNamespaceCount = 0;
        pNsAliasSlot->AliasName = *Alias;
    }


    //
    // At this point, pNsAliasSlot points at the alias slot for which
    // we want to add a new depth thing.
    //
    status = RtlIndexIntoGrowingList(
        &pNsAliasSlot->NamespaceMaps,
        pNsAliasSlot->ulNamespaceCount++,
        (PVOID*)&pNameDepth,
        TRUE);

    if (!NT_SUCCESS(status)) {
        goto Exit;
    }

    //
    // Good - now write the depth and the name into the
    // name-at-depth thing
    //
    pNameDepth->Depth = ulDepth;
    pNameDepth->Name = *Namespace;

Exit:
    return status;
}



NTSTATUS
RtlNsInsertDefaultNamespace(
    PNS_MANAGER     pManager,
    ULONG           ulDepth,
    PXML_EXTENT     pNamespace
    )
/*++

  Purpose:

    Adds the namespace mentioned in Namespace as the 'default' namespace
    for the depth given.  If a namespace already exists for the depth,
    it replaces it with this one.

  Parameters:

    pManager - Namespace management object to be updated.

    ulDepth - Depth at which this namespace should be active
    
    Namespace - Extent of the namespace name in the original XML document

  Returns:

    STATUS_SUCCESS - Namespace was correctly made active at the depth in
        question.

    STATUS_NO_MEMORY - Unable to access the stack at that depth, possibly
        unable to extend the pseudostack of elements.

    STATUS_UNSUCCESSFUL - Something else went wrong

    STATUS_INVALID_PARAMETER - pManager was NULL.

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    ULONG           ulStackTop;
    PNS_NAME_DEPTH  pCurrentStackTop;

    if ((pManager == NULL) || (ulDepth == 0)) {
        return STATUS_INVALID_PARAMETER;
    }

    ulStackTop = pManager->ulDefaultNamespaceDepth;

    if (ulStackTop == 0) {
        //
        // Simple push.
        //
        status = RtlIndexIntoGrowingList(
            &pManager->DefaultNamespaces,
            0,
            (PVOID*)&pCurrentStackTop,
            TRUE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Great, we now have an entry on the stack
        //
        pManager->ulDefaultNamespaceDepth++;
    }
    else {

        //
        // Find the current stack top in the list of namespaces.
        //
        status = RtlIndexIntoGrowingList(
            &pManager->DefaultNamespaces,
            ulStackTop - 1,
            (PVOID*)&pCurrentStackTop,
            FALSE);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Potential coding error?
        //
        ASSERT(pCurrentStackTop->Depth <= ulDepth);

        //
        // If the depth at the top of the stack is more shallow than the new 
        // depth requested, then insert a new stack item instead.
        //
        if (pCurrentStackTop->Depth < ulDepth) {

            status = RtlIndexIntoGrowingList(
                &pManager->DefaultNamespaces,
                ulStackTop,
                (PVOID*)&pCurrentStackTop,
                TRUE);

            if (!NT_SUCCESS(status)) {
                return status;
            }
            
            pManager->ulDefaultNamespaceDepth++;;
        }
    }

    //
    // At this point, pCurrentStackTop should be non-null, and we
    // should be ready to write the new namespace element into the
    // stack just fine.
    //
    ASSERT(pCurrentStackTop != NULL);

    pCurrentStackTop->Depth = ulDepth;
    pCurrentStackTop->Name = *pNamespace;

    return status;
}



NTSTATUS
RtlpRemoveDefaultNamespacesAboveDepth(
    PNS_MANAGER pManager,
    ULONG       ulDepth
    )
/*++

  Purpose:

    Cleans out all default namespaces that are above a certain depth in the
    namespace manager.  It does this iteratively, deleteing each one at the top
    of the stack until it finds one that's below the stack top.

  Parameters:

    pManager - Manager object to be cleaned out

    ulDepth - Depth at which and above the namespaces should be cleaned out.

  Returns:

    STATUS_SUCCESS - Default namespace stack has been cleared out.

    * - Unknown failures in RtlIndexIntoGrowingList

--*/
{
    NTSTATUS        status;
    PNS_NAME_DEPTH  pNsAtDepth = NULL;
    
    do
    {
        status = RtlIndexIntoGrowingList(
            &pManager->DefaultNamespaces,
            pManager->ulDefaultNamespaceDepth - 1,
            (PVOID*)&pNsAtDepth,
            FALSE);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Ok, found one that has to be toasted.  Delete it from the stack.
        //
        if (pNsAtDepth->Depth >= ulDepth) {
            pManager->ulDefaultNamespaceDepth--;
        }
        //
        // Otherwise, we're out of the deep water, so stop looking.
        //
        else {
            break;
        }
    }
    while (pManager->ulDefaultNamespaceDepth > 0);

    return status;
}




NTSTATUS
RtlpRemoveNamespaceAliasesAboveDepth(
    PNS_MANAGER pManager,
    ULONG       ulDepth
    )
/*++

  Purpose:

    Looks through the list of namespace aliases in this manager and removes the
    ones that are above a given depth.

  Parameters:

    pManager - Manager object from which the extra namespaces should be deleted

    ulDepth - Depth above which namespace aliases should be removed.

  Returns:

    STATUS_SUCCESS - Correctly removed aliases above the specified depth

    * - Something else happened, potentially in RtlpIndexIntoGrowingList

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG idx = 0;

    //
    // Note that the alias list is constructed such that it continually
    // grows, but deleteing namespace aliases can leave holes in the
    // list that can be filled in.  The ulAliasCount member of the namespace
    // manager is there to know what the high water mark of namespaces is,
    // above which we don't need to go to find valid aliases.  This value
    // is maintained in RtlNsInsertNamespaceAlias, but never cleared up.
    // A "potentially bad" situation could arise when a document with a lot of
    // namespace aliases at the second-level appears.
    //
    for (idx = 0; idx < pManager->ulAliasCount; idx++) {

        

    }
    

    return status;
}




NTSTATUS
RtlNsLeaveDepth(
    PNS_MANAGER pManager,
    ULONG       ulDepth
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    if (pManager == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Meta-question.  Should we try to clean up both the alias list as well
    // as the default namespace list before we return failure to the caller?
    // I suppose we should, but a failure in either of these is bad enough to
    // leave the namespace manager in a bad way.
    //
    if (pManager->ulDefaultNamespaceDepth > 0) {
        status = RtlpRemoveDefaultNamespacesAboveDepth(pManager, ulDepth);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    if (pManager->ulAliasCount > 0) {
        status = RtlpRemoveNamespaceAliasesAboveDepth(pManager, ulDepth);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    return status;
}



NTSTATUS
RtlpNsFindMatchingAlias(
    PNS_MANAGER     pManager,
    PXML_EXTENT     pAliasName,
    PNS_ALIAS      *pAlias
    )
{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       idx = 0;
    PNS_ALIAS   pThisAlias = NULL;
    XML_STRING_COMPARE     Matches = XML_STRING_COMPARE_EQUALS;

    *pAlias = NULL;
    
    for (idx = 0; idx < pManager->ulAliasCount; idx++) {
        
        status = RtlIndexIntoGrowingList(
            &pManager->Aliases,
            idx,
            (PVOID*)&pThisAlias,
            FALSE);
        
        //
        // If this slot is in use...
        //
        if (pThisAlias->fInUse) {
            
            status = pManager->pfnCompare(
                pManager->pvCompareContext,
                &pThisAlias->AliasName,
                pAliasName,
                &Matches);
            
            if (!NT_SUCCESS(status)) {
                return status;
            }
            
            //
            // This alias matches the alias in the list
            //
            if (Matches != XML_STRING_COMPARE_EQUALS) {
                break;
            }
        }
    }

    if (Matches == XML_STRING_COMPARE_EQUALS) {
        ASSERT(pThisAlias && pThisAlias->fInUse);
        *pAlias = pThisAlias;
    }
    else {
        status = STATUS_NOT_FOUND;
    }

    return status;
}






NTSTATUS
RtlNsGetNamespaceForAlias(
    PNS_MANAGER     pManager,
    ULONG           ulDepth,
    PXML_EXTENT     Alias,
    PXML_EXTENT     pNamespace
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    if ((pManager == NULL) || (Alias == NULL) || (pNamespace == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(pNamespace, sizeof(*pNamespace));

    //
    // No prefix, get the active default namespace
    //
    if (Alias->cbData == 0) {

        PNS_NAME_DEPTH pDefault = NULL;

        //
        // There's default namespaces
        //
        if (pManager->ulDefaultNamespaceDepth != 0) {

            status = RtlIndexIntoGrowingList(
                &pManager->DefaultNamespaces,
                pManager->ulDefaultNamespaceDepth - 1,
                (PVOID*)&pDefault,
                FALSE);

            if (!NT_SUCCESS(status)) {
                goto Exit;
            }

            //
            // Coding error - asking for depths below the depth at the top of
            // the default stack
            //
            ASSERT(pDefault->Depth <= ulDepth);
        }

        //
        // We've found a default namespace that suits us
        //
        if (pDefault != NULL) {
            *pNamespace = pDefault->Name;
        }

        status = STATUS_SUCCESS;

    }
    //
    // Otherwise, look through the list of aliases active
    //
    else {

        PNS_ALIAS pThisAlias = NULL;
        PNS_NAME_DEPTH pNamespaceFound = NULL;

        //
        // This can return "status not found", which is fine
        //
        status = RtlpNsFindMatchingAlias(pManager, Alias, &pThisAlias);
        if (!NT_SUCCESS(status)) {
            goto Exit;
        }
            

        //
        // The one we found must be in use, and may not be empty
        //
        ASSERT(pThisAlias->fInUse && pThisAlias->ulNamespaceCount);

        //
        // Look at the topmost aliased namespace
        //
        status = RtlIndexIntoGrowingList(
            &pThisAlias->NamespaceMaps,
            pThisAlias->ulNamespaceCount - 1,
            (PVOID*)&pNamespaceFound,
            FALSE);

        if (!NT_SUCCESS(status)) {
            goto Exit;
        }

        //
        // Coding error, asking for stuff that's below the depth found
        //
        ASSERT(pNamespaceFound && (pNamespaceFound->Depth <= ulDepth));

        //
        // Outbound
        //
        *pNamespace = pNamespaceFound->Name;

        status = STATUS_SUCCESS;
    }

Exit:
    return status;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\culture.cpp ===
#include "stdinc.h"
#include "util.h"

typedef struct _SXS_CULTURE_INFO
{
    LANGID ParentLangID;
    LANGID ChildLangID;
    USHORT CultureStringCch;
    PCWSTR CultureString;
} SXS_CULTURE_INFO, *PSXS_CULTURE_INFO;

typedef const struct _SXS_CULTURE_INFO *PCSXS_CULTURE_INFO;

static const SXS_CULTURE_INFO s_rgCultures[] =
{
    { 0x0001, 0x0000, 2, L"ar" },
    { 0x0002, 0x0000, 2, L"bg" },
    { 0x0003, 0x0000, 2, L"ca" },
    { 0x0004, 0x0000, 6, L"zh-CHS" },
    { 0x0005, 0x0000, 2, L"cs" },
    { 0x0006, 0x0000, 2, L"da" },
    { 0x0007, 0x0000, 2, L"de" },
    { 0x0008, 0x0000, 2, L"el" },
    { 0x0009, 0x0000, 2, L"en" },
    { 0x000a, 0x0000, 2, L"es" },
    { 0x000b, 0x0000, 2, L"fi" },
    { 0x000c, 0x0000, 2, L"fr" },
    { 0x000d, 0x0000, 2, L"he" },
    { 0x000e, 0x0000, 2, L"hu" },
    { 0x000f, 0x0000, 2, L"is" },
    { 0x0010, 0x0000, 2, L"it" },
    { 0x0011, 0x0000, 2, L"ja" },
    { 0x0012, 0x0000, 2, L"ko" },
    { 0x0013, 0x0000, 2, L"nl" },
    { 0x0014, 0x0000, 2, L"no" },
    { 0x0015, 0x0000, 2, L"pl" },
    { 0x0016, 0x0000, 2, L"pt" },
    { 0x0018, 0x0000, 2, L"ro" },
    { 0x0019, 0x0000, 2, L"ru" },
    { 0x001a, 0x0000, 2, L"hr" },
    { 0x001b, 0x0000, 2, L"sk" },
    { 0x001c, 0x0000, 2, L"sq" },
    { 0x001d, 0x0000, 2, L"sv" },
    { 0x001e, 0x0000, 2, L"th" },
    { 0x001f, 0x0000, 2, L"tr" },
    { 0x0020, 0x0000, 2, L"ur" },
    { 0x0021, 0x0000, 2, L"id" },
    { 0x0022, 0x0000, 2, L"uk" },
    { 0x0023, 0x0000, 2, L"be" },
    { 0x0024, 0x0000, 2, L"sl" },
    { 0x0025, 0x0000, 2, L"et" },
    { 0x0026, 0x0000, 2, L"lv" },
    { 0x0027, 0x0000, 2, L"lt" },
    { 0x0029, 0x0000, 2, L"fa" },
    { 0x002a, 0x0000, 2, L"vi" },
    { 0x002b, 0x0000, 2, L"hy" },
    { 0x002c, 0x0000, 2, L"az" },
    { 0x002d, 0x0000, 2, L"eu" },
    { 0x002f, 0x0000, 2, L"mk" },
    { 0x0036, 0x0000, 2, L"af" },
    { 0x0037, 0x0000, 2, L"ka" },
    { 0x0038, 0x0000, 2, L"fo" },
    { 0x0039, 0x0000, 2, L"hi" },
    { 0x003e, 0x0000, 2, L"ms" },
    { 0x003f, 0x0000, 2, L"kk" },
    { 0x0040, 0x0000, 2, L"ky" },
    { 0x0041, 0x0000, 2, L"sw" },
    { 0x0043, 0x0000, 2, L"uz" },
    { 0x0044, 0x0000, 2, L"tt" },
    { 0x0046, 0x0000, 2, L"pa" },
    { 0x0047, 0x0000, 2, L"gu" },
    { 0x0049, 0x0000, 2, L"ta" },
    { 0x004a, 0x0000, 2, L"te" },
    { 0x004b, 0x0000, 2, L"kn" },
    { 0x004e, 0x0000, 2, L"mr" },
    { 0x004f, 0x0000, 2, L"sa" },
    { 0x0050, 0x0000, 2, L"mn" },
    { 0x0056, 0x0000, 2, L"gl" },
    { 0x0057, 0x0000, 3, L"kok" },
    { 0x005a, 0x0000, 3, L"syr" },
    { 0x0065, 0x0000, 3, L"div" },
    { 0x0401, 0x0001, 5, L"ar-SA" },
    { 0x0402, 0x0002, 5, L"bg-BG" },
    { 0x0403, 0x0003, 5, L"ca-ES" },
    { 0x0404, 0x7c04, 5, L"zh-TW" },
    { 0x0405, 0x0005, 5, L"cs-CZ" },
    { 0x0406, 0x0006, 5, L"da-DK" },
    { 0x0407, 0x0007, 5, L"de-DE" },
    { 0x0408, 0x0008, 5, L"el-GR" },
    { 0x0409, 0x0009, 5, L"en-US" },
    { 0x040b, 0x000b, 5, L"fi-FI" },
    { 0x040c, 0x000c, 5, L"fr-FR" },
    { 0x040d, 0x000d, 5, L"he-IL" },
    { 0x040e, 0x000e, 5, L"hu-HU" },
    { 0x040f, 0x000f, 5, L"is-IS" },
    { 0x0410, 0x0010, 5, L"it-IT" },
    { 0x0411, 0x0011, 5, L"ja-JP" },
    { 0x0412, 0x0012, 5, L"ko-KR" },
    { 0x0413, 0x0013, 5, L"nl-NL" },
    { 0x0414, 0x0014, 5, L"nb-NO" },
    { 0x0415, 0x0015, 5, L"pl-PL" },
    { 0x0416, 0x0016, 5, L"pt-BR" },
    { 0x0418, 0x0018, 5, L"ro-RO" },
    { 0x0419, 0x0019, 5, L"ru-RU" },
    { 0x041a, 0x001a, 5, L"hr-HR" },
    { 0x041b, 0x001b, 5, L"sk-SK" },
    { 0x041c, 0x001c, 5, L"sq-AL" },
    { 0x041d, 0x001d, 5, L"sv-SE" },
    { 0x041e, 0x001e, 5, L"th-TH" },
    { 0x041f, 0x001f, 5, L"tr-TR" },
    { 0x0420, 0x0020, 5, L"ur-PK" },
    { 0x0421, 0x0021, 5, L"id-ID" },
    { 0x0422, 0x0022, 5, L"uk-UA" },
    { 0x0423, 0x0023, 5, L"be-BY" },
    { 0x0424, 0x0024, 5, L"sl-SI" },
    { 0x0425, 0x0025, 5, L"et-EE" },
    { 0x0426, 0x0026, 5, L"lv-LV" },
    { 0x0427, 0x0027, 5, L"lt-LT" },
    { 0x0429, 0x0029, 5, L"fa-IR" },
    { 0x042a, 0x002a, 5, L"vi-VN" },
    { 0x042b, 0x002b, 5, L"hy-AM" },
    { 0x042c, 0x002c, 10, L"az-AZ-Latn" },
    { 0x042d, 0x002d, 5, L"eu-ES" },
    { 0x042f, 0x002f, 5, L"mk-MK" },
    { 0x0436, 0x0036, 5, L"af-ZA" },
    { 0x0437, 0x0037, 5, L"ka-GE" },
    { 0x0438, 0x0038, 5, L"fo-FO" },
    { 0x0439, 0x0039, 5, L"hi-IN" },
    { 0x043e, 0x003e, 5, L"ms-MY" },
    { 0x043f, 0x003f, 5, L"kk-KZ" },
    { 0x0440, 0x0040, 5, L"ky-KZ" },
    { 0x0441, 0x0041, 5, L"sw-KE" },
    { 0x0443, 0x0043, 10, L"uz-UZ-Latn" },
    { 0x0444, 0x0044, 5, L"tt-RU" },
    { 0x0446, 0x0046, 5, L"pa-IN" },
    { 0x0447, 0x0047, 5, L"gu-IN" },
    { 0x0449, 0x0049, 5, L"ta-IN" },
    { 0x044a, 0x004a, 5, L"te-IN" },
    { 0x044b, 0x004b, 5, L"kn-IN" },
    { 0x044e, 0x004e, 5, L"mr-IN" },
    { 0x044f, 0x004f, 5, L"sa-IN" },
    { 0x0450, 0x0050, 5, L"mn-MN" },
    { 0x0456, 0x0056, 5, L"gl-ES" },
    { 0x0457, 0x0057, 6, L"kok-IN" },
    { 0x045a, 0x005a, 6, L"syr-SY" },
    { 0x0465, 0x0065, 6, L"div-MV" },
    { 0x0801, 0x0001, 5, L"ar-IQ" },
    { 0x0804, 0x0004, 5, L"zh-CN" },
    { 0x0807, 0x0007, 5, L"de-CH" },
    { 0x0809, 0x0009, 5, L"en-GB" },
    { 0x080a, 0x000a, 5, L"es-MX" },
    { 0x080c, 0x000c, 5, L"fr-BE" },
    { 0x0810, 0x0010, 5, L"it-CH" },
    { 0x0813, 0x0013, 5, L"nl-BE" },
    { 0x0814, 0x0014, 5, L"nn-NO" },
    { 0x0816, 0x0016, 5, L"pt-PT" },
    { 0x081a, 0x001a, 10, L"sr-SP-Latn" },
    { 0x081d, 0x001d, 5, L"sv-FI" },
    { 0x082c, 0x002c, 10, L"az-AZ-Cyrl" },
    { 0x083e, 0x003e, 5, L"ms-BN" },
    { 0x0843, 0x0043, 10, L"uz-UZ-Cyrl" },
    { 0x0c01, 0x0001, 5, L"ar-EG" },
    { 0x0c04, 0x7c04, 5, L"zh-HK" },
    { 0x0c07, 0x0007, 5, L"de-AT" },
    { 0x0c09, 0x0009, 5, L"en-AU" },
    { 0x0c0a, 0x000a, 5, L"es-ES" },
    { 0x0c0c, 0x000c, 5, L"fr-CA" },
    { 0x0c1a, 0x001a, 10, L"sr-SP-Cyrl" },
    { 0x1001, 0x0001, 5, L"ar-LY" },
    { 0x1004, 0x0004, 5, L"zh-SG" },
    { 0x1007, 0x0007, 5, L"de-LU" },
    { 0x1009, 0x0009, 5, L"en-CA" },
    { 0x100a, 0x000a, 5, L"es-GT" },
    { 0x100c, 0x000c, 5, L"fr-CH" },
    { 0x1401, 0x0001, 5, L"ar-DZ" },
    { 0x1404, 0x0004, 5, L"zh-MO" },
    { 0x1407, 0x0007, 5, L"de-LI" },
    { 0x1409, 0x0009, 5, L"en-NZ" },
    { 0x140a, 0x000a, 5, L"es-CR" },
    { 0x140c, 0x000c, 5, L"fr-LU" },
    { 0x1801, 0x0001, 5, L"ar-MA" },
    { 0x1809, 0x0009, 5, L"en-IE" },
    { 0x180a, 0x000a, 5, L"es-PA" },
    { 0x180c, 0x000c, 5, L"fr-MC" },
    { 0x1c01, 0x0001, 5, L"ar-TN" },
    { 0x1c09, 0x0009, 5, L"en-ZA" },
    { 0x1c0a, 0x000a, 5, L"es-DO" },
    { 0x2001, 0x0001, 5, L"ar-OM" },
    { 0x2009, 0x0009, 5, L"en-JM" },
    { 0x200a, 0x000a, 5, L"es-VE" },
    { 0x2401, 0x0001, 5, L"ar-YE" },
    { 0x2409, 0x0009, 5, L"en-CB" },
    { 0x240a, 0x000a, 5, L"es-CO" },
    { 0x2801, 0x0001, 5, L"ar-SY" },
    { 0x2809, 0x0009, 5, L"en-BZ" },
    { 0x280a, 0x000a, 5, L"es-PE" },
    { 0x2c01, 0x0001, 5, L"ar-JO" },
    { 0x2c09, 0x0009, 5, L"en-TT" },
    { 0x2c0a, 0x000a, 5, L"es-AR" },
    { 0x3001, 0x0001, 5, L"ar-LB" },
    { 0x3009, 0x0009, 5, L"en-ZW" },
    { 0x300a, 0x000a, 5, L"es-EC" },
    { 0x3401, 0x0001, 5, L"ar-KW" },
    { 0x3409, 0x0009, 5, L"en-PH" },
    { 0x340a, 0x000a, 5, L"es-CL" },
    { 0x3801, 0x0001, 5, L"ar-AE" },
    { 0x380a, 0x000a, 5, L"es-UY" },
    { 0x3c01, 0x0001, 5, L"ar-BH" },
    { 0x3c0a, 0x000a, 5, L"es-PY" },
    { 0x4001, 0x0001, 5, L"ar-QA" },
    { 0x400a, 0x000a, 5, L"es-BO" },
    { 0x440a, 0x000a, 5, L"es-SV" },
    { 0x480a, 0x000a, 5, L"es-HN" },
    { 0x4c0a, 0x000a, 5, L"es-NI" },
    { 0x500a, 0x000a, 5, L"es-PR" },
    { 0x7c04, 0x0000, 6, L"zh-CHT" },
};

int __cdecl bsearch_callback(const void *pv1, const void *pv2)
{
    PCSXS_CULTURE_INFO p1 = (PCSXS_CULTURE_INFO) pv1;
    PCSXS_CULTURE_INFO p2 = (PCSXS_CULTURE_INFO) pv2;

    if (p1->ParentLangID < p2->ParentLangID)
        return -1;
    else if (p1->ParentLangID == p2->ParentLangID)
        return 0;

    return 1;
}


BOOL
SxspMapLANGIDToCultures(
    LANGID langid,
    CBaseStringBuffer &rbuffGeneric,
    CBaseStringBuffer &rbuffSpecific
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SXS_CULTURE_INFO Key;
    PCSXS_CULTURE_INFO p1 = NULL;
    PCSXS_CULTURE_INFO p2 = NULL;

    rbuffGeneric.Clear();
    rbuffSpecific.Clear();

    Key.ParentLangID = langid;

    p1 = (PCSXS_CULTURE_INFO) bsearch(&Key, s_rgCultures, NUMBER_OF(s_rgCultures), sizeof(SXS_CULTURE_INFO), &bsearch_callback);
    if (p1 != NULL)
    {
        Key.ParentLangID = p1->ChildLangID;
        p2 = (PCSXS_CULTURE_INFO) bsearch(&Key, s_rgCultures, NUMBER_OF(s_rgCultures), sizeof(SXS_CULTURE_INFO), &bsearch_callback);
    }

    if (p1 != NULL)
        IFW32FALSE_EXIT(rbuffSpecific.Win32Assign(p1->CultureString, p1->CultureStringCch));

    if (p2 != NULL)
        IFW32FALSE_EXIT(rbuffGeneric.Win32Assign(p2->CultureString, p2->CultureStringCch));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspMapCultureToLANGID(
    PCWSTR pcwszCultureString,
    LANGID &lid,
    PBOOL pfFound
    )
{
    FN_PROLOG_WIN32

    ULONG ul;

    PARAMETER_CHECK(pcwszCultureString != NULL);

    if ( pfFound ) *pfFound = TRUE;
    lid = 0x0;

    for ( ul = 0; ul < NUMBER_OF(s_rgCultures); ul++ )
    {
        if (lstrcmpiW(pcwszCultureString, s_rgCultures[ul].CultureString) == 0)
        {
            lid = s_rgCultures[ul].ParentLangID;
            break;
        }   
    }

    if ( ul == NUMBER_OF(s_rgCultures) && pfFound )
        *pfFound = FALSE;

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\formatting.cpp ===
#include "stdinc.h"
#include <stdio.h>
#include <stdarg.h>
#include "debmacro.h"
#include "fusionbuffer.h"
#include "util.h"

BOOL
FusionpFormatFlags(
    DWORD dwFlagsToFormat,
    bool fUseLongNames,
    SIZE_T cMapEntries,
    PCFUSION_FLAG_FORMAT_MAP_ENTRY prgMapEntries,
    CBaseStringBuffer &rbuff
    )
{
    FN_PROLOG_WIN32;

    CSmallStringBuffer buffTemp;
    SIZE_T i;

    rbuff.Clear();

    for (i=0; i<cMapEntries; i++)
    {
        // What the heck does a flag mask of 0 mean?
        INTERNAL_ERROR_CHECK(prgMapEntries[i].m_dwFlagMask != 0);

        if ((prgMapEntries[i].m_dwFlagMask != 0) &&
            ((dwFlagsToFormat & prgMapEntries[i].m_dwFlagMask) == prgMapEntries[i].m_dwFlagMask))
        {
            // we have a winner...
            if (buffTemp.Cch() != 0)
            {
                if (fUseLongNames)
                    IFW32FALSE_EXIT(buffTemp.Win32Append(L" | ", 3));
                else
                    IFW32FALSE_EXIT(buffTemp.Win32Append(L", ", 2));
            }

            if (fUseLongNames)
                IFW32FALSE_EXIT(buffTemp.Win32Append(prgMapEntries[i].m_pszString, prgMapEntries[i].m_cchString));
            else
                IFW32FALSE_EXIT(buffTemp.Win32Append(prgMapEntries[i].m_pszShortString, prgMapEntries[i].m_cchShortString));

            if (prgMapEntries[i].m_dwFlagsToTurnOff != 0)
                dwFlagsToFormat &= ~(prgMapEntries[i].m_dwFlagsToTurnOff);
            else
                dwFlagsToFormat &= ~(prgMapEntries[i].m_dwFlagMask);
        }
    }

    if (dwFlagsToFormat != 0)
    {
        const static WCHAR comma[] = L", ";
        WCHAR rgwchHexBuffer[16];

        int nCharsWritten = ::_snwprintf(rgwchHexBuffer, NUMBER_OF(rgwchHexBuffer), L"0x%08lx", dwFlagsToFormat);
        rgwchHexBuffer[NUMBER_OF(rgwchHexBuffer) - 1] = L'\0';

        if (nCharsWritten < 0) 
            nCharsWritten = 0;

        rgwchHexBuffer[nCharsWritten] = L'\0';

        if (buffTemp.Cch() != 0)
            IFW32FALSE_EXIT(buffTemp.Win32Append(comma, NUMBER_OF(comma) - 1));

        IFW32FALSE_EXIT(buffTemp.Win32Append(rgwchHexBuffer, nCharsWritten));
    }

    // if we didn't write anything; at least say that.
    if (buffTemp.Cch() == 0)
    {
        const static WCHAR none[] = L"<none>";
        IFW32FALSE_EXIT(rbuff.Win32Assign(none, NUMBER_OF(none) - 1));
    }
    else
        IFW32FALSE_EXIT(rbuff.Win32Assign(buffTemp));

    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\debug.cpp ===
#include "stdinc.h"
#include "debmacro.h"
#include <stdio.h>
#include <stdarg.h>
#include "fusionbuffer.h"
#include "setupapi.h"
#include "shlwapi.h"
#if !defined(NT_INCLUDED)
#define DPFLTR_FUSION_ID 54
#endif

extern "C" { const extern char FusionpIsPrint_Data[256]; }
#define PRINTABLE(_ch) (FusionpIsPrint_Data[(_ch) & 0xff] ? (_ch) : '.')

#if !defined(FUSION_DEFAULT_DBG_LEVEL_MASK)
#define FUSION_DEFAULT_DBG_LEVEL_MASK (0x00000000)
#endif

extern "C" DWORD kd_fusion_mask = (FUSION_DEFAULT_DBG_LEVEL_MASK & ~DPFLTR_MASK);
extern "C" DWORD kd_kernel_fusion_mask = 0;
extern "C" bool g_FusionEnterExitTracingEnabled = false;

typedef ULONG (NTAPI* RTL_V_DBG_PRINT_EX_FUNCTION)(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );

typedef ULONG (*RTL_V_DBG_PRINT_EX_WITH_PREFIX_FUNCTION)(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );

RTL_V_DBG_PRINT_EX_FUNCTION g_pfnvDbgPrintEx;
RTL_V_DBG_PRINT_EX_WITH_PREFIX_FUNCTION g_pfnvDbgPrintExWithPrefix;

VOID
FusionpvDbgPrintToSetupLog(
    IN LogSeverity Severity,
    IN PCSTR Format,
    IN va_list ap
    );

void
FusionpReportCondition(
    bool fBreak,
    PCSTR pszFormat,
    ...
    )
{
    char rgach[128];
    char rgach2[128];
    FRAME_INFO FrameInfo;

    va_list ap;
    va_start(ap, pszFormat);

    ::_vsnprintf(rgach, NUMBER_OF(rgach), pszFormat, ap);
    rgach[NUMBER_OF(rgach) - 1] = '\0';

    ::FusionpGetActiveFrameInfo(FrameInfo);

    ::_snprintf(
        rgach2,
        NUMBER_OF(rgach2),
        "%s(%d): Break-in requested:\n"
        "   %s\n",
        FrameInfo.pszFile,
        FrameInfo.nLine,
        rgach);

    rgach2[NUMBER_OF(rgach2) - 1] = '\0';

    if (::IsDebuggerPresent())
    {
        ::OutputDebugStringA(rgach2);
    }
    if (fBreak)
    {
#if DBG
        ::FusionpRtlAssert(
            const_cast<PVOID>(reinterpret_cast<const void*>("Break-in requested")),
            const_cast<PVOID>(reinterpret_cast<const void*>(FrameInfo.pszFile)),
            FrameInfo.nLine,
            const_cast<PSTR>(rgach));
#endif
    }

    va_end(ap);
    return;
}

#if DBG

bool
FusionpAssertionFailed(
    const FRAME_INFO &rFrameInfo,
    PCSTR pszExpression,
    PCSTR pszText
    )
{
    CSxsPreserveLastError ple;

    if (::IsDebuggerPresent())
    {
        char rgach[512];
        // c:\foo.cpp(35): Assertion Failure.  Expression: "m_cch != 0".  Text: "Must have nonzero length"
        static const char szFormatWithText[] = "%s(%d): Assertion failure in %s. Expression: \"%s\". Text: \"%s\"\n";
        static const char szFormatNoText[] = "%s(%d): Assertion failure in %s. Expression: \"%s\".\n";
        PCSTR pszFormat = ((pszText == NULL) || (pszText == pszExpression)) ? szFormatNoText : szFormatWithText;

        ::_snprintf(
            rgach,
            NUMBER_OF(rgach),
            pszFormat,
            rFrameInfo.pszFile,
            rFrameInfo.nLine,
            rFrameInfo.pszFunction,
            pszExpression,
            pszText);
        rgach[NUMBER_OF(rgach) - 1] = '\0';
        ::OutputDebugStringA(rgach);

        ple.Restore();
        return true;
    }

    ::FusionpRtlAssert(
        const_cast<PVOID>(reinterpret_cast<const void*>(pszExpression)),
        const_cast<PVOID>(reinterpret_cast<const void*>(rFrameInfo.pszFile)),
        rFrameInfo.nLine,
        const_cast<PSTR>(pszText));

    ple.Restore();
    return false;
}


bool
FusionpAssertionFailed(
    PCSTR pszFile,
    PCSTR pszFunctionName,
    INT nLine,
    PCSTR pszExpression,
    PCSTR pszText
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpPopulateFrameInfo(FrameInfo, pszFile, pszFunctionName, nLine);
    return ::FusionpAssertionFailed(FrameInfo, pszExpression, pszText);
}

#endif // DBG

VOID
FusionpSoftAssertFailed(
    const FRAME_INFO &rFrameInfo,
    PCSTR pszExpression,
    PCSTR pszMessage
    )
{
    CSxsPreserveLastError ple;
    char rgach[256];
    // c:\foo.cpp(35): [Fusion] Soft Assertion Failure.  Expression: "m_cch != 0".  Text: "Must have nonzero length"
    static const char szFormatWithText[] = "%s(%d): Soft Assertion Failure in %s! Log a bug!\n   Expression: %s\n   Message: %s\n";
    static const char szFormatNoText[] = "%s(%d): Soft Assertion Failure in %s! Log a bug!\n   Expression: %s\n";
    PCSTR pszFormat = ((pszMessage == NULL) || (pszMessage == pszExpression)) ? szFormatNoText : szFormatWithText;

    ::_snprintf(rgach, NUMBER_OF(rgach), pszFormat, rFrameInfo.pszFile, rFrameInfo.nLine, rFrameInfo.pszFunction, pszExpression, pszMessage);
    rgach[NUMBER_OF(rgach) - 1] = '\0';

    ::OutputDebugStringA(rgach);

    ple.Restore();
}

VOID
FusionpSoftAssertFailed(
    PCSTR pszFile,
    PCSTR pszFunction,
    INT nLine,
    PCSTR pszExpression,
    PCSTR pszMessage
    )
{
    FRAME_INFO FrameInfo;

    ::FusionpPopulateFrameInfo(FrameInfo, pszFile, pszFunction, nLine);
    ::FusionpSoftAssertFailed(FrameInfo, pszExpression, pszMessage);
}

VOID
FusionpSoftAssertFailed(
    PCSTR pszExpression,
    PCSTR pszMessage
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpGetActiveFrameInfo(FrameInfo);
    ::FusionpSoftAssertFailed(FrameInfo, pszExpression, pszMessage);
}

ULONG
FusionpvDbgPrintExNoNTDLL(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    )
{
    if ((ComponentId == DPFLTR_FUSION_ID) &&
        (((Level < 32) &&
          (((1 << Level) & kd_fusion_mask) != 0)) ||
         ((Level >= 32) &&
          ((Level & kd_fusion_mask) != 0))))
    {
        CSxsPreserveLastError ple;
        CHAR rgchBuffer[512];
        ULONG n = ::_vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer), Format, arglist);
        rgchBuffer[NUMBER_OF(rgchBuffer) - 1] = '\0';
        ::OutputDebugStringA(rgchBuffer);
        ple.Restore();
        return n;
    }

    return 0;
}

HMODULE g_setupapiDll = NULL;

typedef BOOL (WINAPI * PSETUPCLOSELOG_ROUTINE)(
    );

typedef BOOL (WINAPI * PSETUPLOGERRORA_ROUTINE)(
    IN LPCSTR MessageString,
    IN LogSeverity Severity
    );

typedef BOOL (WINAPI * PSETUPLOGERRORW_ROUTINE)(
    IN LPCWSTR MessageString,
    IN LogSeverity Severity
    );

typedef BOOL (WINAPI * PSETUPOPENLOG_ROUTINE)(
    BOOL Erase
    );

PSETUPLOGERRORA_ROUTINE g_pfnSetupLogError;
PSETUPCLOSELOG_ROUTINE g_pfnSetupCloseLog;

BOOL
WINAPI
DllStartup_SetupLog(
    HINSTANCE   Module,
    DWORD       Reason,
    PVOID       Reserved
    )
{
    BOOL fSuccess = FALSE;

    if ((Reason == DLL_PROCESS_DETACH) &&
        (g_setupapiDll != NULL))
    {
        if (Reserved != NULL)
        {
            if (g_pfnSetupCloseLog != NULL)
            {
                (*g_pfnSetupCloseLog)();
            }
            if (!FreeLibrary(g_setupapiDll))
            {
                ::FusionpDbgPrint("SXS.DLL : FreeLibrary failed to free setupapi.dll with LastError = %d\n", ::FusionpGetLastWin32Error());
            }
        }
        g_pfnSetupCloseLog = NULL;
        g_pfnSetupLogError = NULL;
        g_setupapiDll = NULL;
    }

    fSuccess = TRUE;
    return fSuccess;
}

VOID
FusionpvDbgPrintToSetupLog(
    IN LogSeverity Severity,
    IN PCSTR Format,
    IN va_list ap
    )
{
    //
    // first, let us check whether this is ActCtxGen (by csrss.exe) or Setup Installation(by setup.exe)
    // during GUI mode setup; do not log for ActCtxGen, only setup
    //
    if (::GetModuleHandleW(L"csrss.exe") != NULL)
        return;

    static BOOL s_fEverBeenCalled = FALSE;
    PCSTR ProcName = "";

    if ((g_pfnSetupLogError == NULL) && !s_fEverBeenCalled)
    {
        g_setupapiDll = ::LoadLibraryW(L"SETUPAPI.DLL");
        if (g_setupapiDll == NULL)
        {
            ::FusionpDbgPrint("SXS.DLL : Loadlibrary Failed to load setupapi.dll with LastError = %d\n", ::FusionpGetLastWin32Error());
            goto Exit;
        }

        ProcName = "SetupOpenLog";
        PSETUPOPENLOG_ROUTINE pfnOpenSetupLog = (PSETUPOPENLOG_ROUTINE) ::GetProcAddress(g_setupapiDll, ProcName);
        if (pfnOpenSetupLog == NULL)
        {
            goto GetProcAddressFailed;
        }
        ProcName = "SetupLogErrorA";
        PSETUPLOGERRORA_ROUTINE pfnSetupLogError = (PSETUPLOGERRORA_ROUTINE) ::GetProcAddress(g_setupapiDll, ProcName);
        if (pfnSetupLogError == NULL)
        {
            goto GetProcAddressFailed;
        }
        ProcName = "SetupCloseLog";
        PSETUPCLOSELOG_ROUTINE pfnSetupCloseLog = (PSETUPCLOSELOG_ROUTINE) ::GetProcAddress(g_setupapiDll, "SetupCloseLog");
        if (pfnSetupLogError == NULL)
        {
            goto GetProcAddressFailed;
        }

        if (!(*pfnOpenSetupLog)(FALSE))
        {
            ::FusionpDbgPrint("SXS.DLL : SetupOpenLog failed with LastError = %d\n", ::FusionpGetLastWin32Error());
            goto Exit;
        }

        g_pfnSetupCloseLog = pfnSetupCloseLog;
        g_pfnSetupLogError = pfnSetupLogError;
    }

    if (g_pfnSetupLogError != NULL)
    {
        CHAR rgchBuffer[512];

        ::_vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer), Format, ap);

        rgchBuffer[NUMBER_OF(rgchBuffer) - 1] = '\0';

        if (!(*g_pfnSetupLogError)(rgchBuffer, Severity))
        {
            ::FusionpDbgPrint("SXS.DLL : SetupLogErrorA failed with LastError = %d\n", ::FusionpGetLastWin32Error());
        }
    }
    return;
Exit:
    s_fEverBeenCalled = TRUE;
    return;

GetProcAddressFailed:
    ::FusionpDbgPrint("SXS.DLL : %s failed to be located in setupapi.dll with LastError = %d\n", ProcName, ::FusionpGetLastWin32Error());
    goto Exit;
}

ULONG
FusionpvDbgPrintEx(
    ULONG Level,
    PCSTR Format,
    va_list ap
    )
{
    CSxsPreserveLastError ple;
    ULONG ulResult = 0;

    if (g_pfnvDbgPrintEx == NULL)
    {
        HINSTANCE hInstNTDLL = ::GetModuleHandleW(L"NTDLL.DLL");
        if (hInstNTDLL != NULL)
            g_pfnvDbgPrintEx = (RTL_V_DBG_PRINT_EX_FUNCTION)(::GetProcAddress(hInstNTDLL, "vDbgPrintEx"));

        if (g_pfnvDbgPrintEx == NULL)
            g_pfnvDbgPrintEx = &::FusionpvDbgPrintExNoNTDLL;
    }

    if (g_pfnvDbgPrintEx)
    {
        ulResult = (*g_pfnvDbgPrintEx)(
            DPFLTR_FUSION_ID,
            Level,
            const_cast<PSTR>(Format),
            ap);
    }

    if (::IsDebuggerPresent())
    {
        ulResult = ::FusionpvDbgPrintExNoNTDLL(DPFLTR_FUSION_ID, Level, const_cast<PSTR>(Format), ap);
        // Gross, but msdev chokes under too much debug output
        if (ulResult != 0)
            ::Sleep(10);
    }

    // Special handling of reflection out to the setup log...
    if (Level & FUSION_DBG_LEVEL_SETUPLOG & ~DPFLTR_MASK)
        ::FusionpvDbgPrintToSetupLog(
            (Level== FUSION_DBG_LEVEL_ERROR) || (Level & FUSION_DBG_LEVEL_ERROR & ~DPFLTR_MASK) ? LogSevError : LogSevInformation,
            Format, ap);

    ple.Restore();

    return ulResult;
}

ULONG
FusionpDbgPrintEx(
    ULONG Level,
    PCSTR Format,
    ...
    )
{
    ULONG rv = 0;
    va_list ap;
    va_start(ap, Format);
    if ((Level & FUSION_DBG_LEVEL_SETUPLOG) || (::FusionpDbgWouldPrintAtFilterLevel(Level)))
    {
        rv = ::FusionpvDbgPrintEx(Level, Format, ap);
    }
    va_end(ap);
    return rv;
}

// Finds out whether or not the given level would print, given our
// current mask.  Knows to look at kd_fusion_mask both in nt as well
// as in the current process.

#define RECHECK_INTERVAL (1000)

#if DBG
EXTERN_C BOOL g_fIgnoreSystemLevelFilterMask = FALSE;
#endif

bool
FusionpDbgWouldPrintAtFilterLevel(
    ULONG Level
    )
{
    // The time quanta here is milliseconds (1000 per second)

#if DBG
    if ( !g_fIgnoreSystemLevelFilterMask )
    {
#endif
        static ULONG s_ulNextTimeToCheck;
        ULONG ulCapturedNextTimeToCheck = s_ulNextTimeToCheck;

        ULONG ulCurrentTime = NtGetTickCount();

        // Look for either the tick count to have wrapped or to be over the next time to check.
        // There's some opportunity for loss here if we only run this function every 49 days but
        // that's pretty darned unlikely.
        if ((ulCurrentTime >= ulCapturedNextTimeToCheck) ||
            ((ulCapturedNextTimeToCheck > RECHECK_INTERVAL) &&
             (ulCurrentTime < (ulCapturedNextTimeToCheck - RECHECK_INTERVAL))))
        {
            DWORD dwNewFusionMask = 0;
            ULONG i;

            // Time to check again...
            for (i=0; i<31; i++)
            {
                if (::FusionpNtQueryDebugFilterState(DPFLTR_FUSION_ID, (DPFLTR_MASK | (1 << i))) == TRUE)
                    dwNewFusionMask |= (1 << i);
            }

            if (s_ulNextTimeToCheck == ulCapturedNextTimeToCheck)
            {
                // Check again in 1000ms (1 second)
                s_ulNextTimeToCheck = (ulCurrentTime + RECHECK_INTERVAL);

                // Nobody got in before us.  Let's write it...
                kd_kernel_fusion_mask = dwNewFusionMask;

                g_FusionEnterExitTracingEnabled = (((kd_fusion_mask | kd_kernel_fusion_mask) & FUSION_DBG_LEVEL_ENTEREXIT) != 0);
            }
        }
#if DBG
    }
#endif

    ULONG mask = Level;
    // If level < 32, it's actually a single-bit test
    if (Level < 32)
        mask = (1 << Level);

    // Are these bits set in our mask?
    return (((kd_fusion_mask | kd_kernel_fusion_mask) & mask) != 0);
}


VOID
FusionppDbgPrintBlob(
    ULONG Level,
    PVOID Data,
    SIZE_T Length,
    PCWSTR PerLinePrefix
    )
{
    ULONG Offset = 0;

    if (PerLinePrefix == NULL)
        PerLinePrefix = L"";

    // we'll output in 8-byte chunks as shown:
    //
    //  [prefix]   00000000: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //  [prefix]   00000008: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //  [prefix]   00000010: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //

    while (Length >= 16)
    {
        BYTE *pb = (BYTE *) (((ULONG_PTR) Data) + Offset);

        ::FusionpDbgPrintEx(
            Level,
            "%S%08lx: %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x (%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c)\n",
            PerLinePrefix,
            Offset,
            pb[0], pb[1], pb[2], pb[3], pb[4], pb[5], pb[6], pb[7],
            pb[8], pb[9], pb[10], pb[11], pb[12], pb[13], pb[14], pb[15],
            PRINTABLE(pb[0]),
            PRINTABLE(pb[1]),
            PRINTABLE(pb[2]),
            PRINTABLE(pb[3]),
            PRINTABLE(pb[4]),
            PRINTABLE(pb[5]),
            PRINTABLE(pb[6]),
            PRINTABLE(pb[7]),
            PRINTABLE(pb[8]),
            PRINTABLE(pb[9]),
            PRINTABLE(pb[10]),
            PRINTABLE(pb[11]),
            PRINTABLE(pb[12]),
            PRINTABLE(pb[13]),
            PRINTABLE(pb[14]),
            PRINTABLE(pb[15]));

        Offset += 16;
        Length -= 16;
    }

    if (Length != 0)
    {
        WCHAR wchLeft[64], wchRight[64];
        WCHAR rgTemp2[16]; // arbitrary big enough size
        bool First = true;
        ULONG i;
        BYTE *pb = (BYTE *) (((ULONG_PTR) Data) + Offset);

        // init output buffers
        wchLeft[0] = 0;
        ::wcscpy( wchRight, L" (" );

        for (i=0; i<16; i++)
        {
            if (Length > 0)
            {
                // left
                ::_snwprintf(rgTemp2, NUMBER_OF(rgTemp2), L"%ls%02x", First ? L" " : L"-", pb[i]);
                rgTemp2[NUMBER_OF(rgTemp2) - 1] = L'\0';

                First = false;
                ::wcscat(wchLeft, rgTemp2);

                // right
                ::_snwprintf(rgTemp2, NUMBER_OF(rgTemp2), L"%c", PRINTABLE(pb[i]));
                rgTemp2[NUMBER_OF(rgTemp2) - 1] = L'\0';

                wcscat(wchRight, rgTemp2);
                Length--;
            }
            else
            {
                ::wcscat(wchLeft, L"   ");
            }
        }

        ::wcscat(wchRight, L")");

        ::FusionpDbgPrintEx(
            Level,
            "%S   %08lx:%ls%ls\n",
            PerLinePrefix,
            Offset,
            wchLeft,
            wchRight);

    }
}

VOID
FusionpDbgPrintBlob(
    ULONG Level,
    PVOID Data,
    SIZE_T Length,
    PCWSTR PerLinePrefix
    )
{
    //
    // This extra function reduces stack usage when the data
    // isn't actually printed (and increases stack usage slightly otherwise).
    //
    if (!::FusionpDbgWouldPrintAtFilterLevel(Level))
        return;
    ::FusionppDbgPrintBlob(Level, Data, Length, PerLinePrefix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\fusionhashstring.cpp ===
#include "stdinc.h"
#include "debmacro.h"
#include "util.h"
#include "fusiontrace.h"

BOOL
FusionpHashUnicodeString(
    PCWSTR String,
    SIZE_T Cch,
    ULONG *pHash,
    bool CaseInsensitive
    )
{
    if (CaseInsensitive)
        *pHash = ::FusionpHashUnicodeStringCaseInsensitive(String, Cch);
    else
        *pHash = ::FusionpHashUnicodeStringCaseSensitive(String, Cch);

    return TRUE;
}

ULONG
__fastcall
FusionpHashUnicodeStringCaseSensitive(
    PCWSTR String,
    SIZE_T cch
    )
{
    ULONG TmpHashValue = 0;

    //
    //  Note that if you change this implementation, you have to have the implementation inside
    //  ntdll change to match it.  Since that's hard and will affect everyone else in the world,
    //  DON'T CHANGE THIS ALGORITHM NO MATTER HOW GOOD OF AN IDEA IT SEEMS TO BE!  This isn't the
    //  most perfect hashing algorithm, but its stability is critical to being able to match
    //  previously persisted hash values.
    //

    while (cch-- != 0)
        TmpHashValue = (TmpHashValue * 65599) + *String++;

    return TmpHashValue;
}

ULONG
__fastcall
FusionpHashUnicodeStringCaseInsensitive(
    PCWSTR String,
    SIZE_T cch
    )
{
    ULONG TmpHashValue = 0;

    //
    //  Note that if you change this implementation, you have to have the implementation inside
    //  ntdll change to match it.  Since that's hard and will affect everyone else in the world,
    //  DON'T CHANGE THIS ALGORITHM NO MATTER HOW GOOD OF AN IDEA IT SEEMS TO BE!  This isn't the
    //  most perfect hashing algorithm, but its stability is critical to being able to match
    //  previously persisted hash values.
    //

    while (cch-- != 0)
    {
        WCHAR Char = *String++;

        if (Char < 128)
        {
            if ((Char >= L'a') && (Char <= L'z'))
                Char = (WCHAR) ((Char - L'a') + L'A');
        }
        else
            Char = ::FusionpRtlUpcaseUnicodeChar(Char);

        TmpHashValue = (TmpHashValue * 65599) + Char;
    }

    return TmpHashValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\fusioninitializecriticalsection.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusioninitializecriticalsection.cpp

Abstract:

    non throwing replacements for InitializeCriticalSection and InitializeCriticalAndSpinCount

Author:

    Jay Krell (JayKrell) November 2001

Revision History:

--*/
#include "stdinc.h"
#include "fusioninitializecriticalsection.h"
#include "sxsexceptionhandling.h"

#define FUSIONP_INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT (0x00000001)

BOOL
FusionpInitializeCriticalSectionCommon(
    ULONG               Flags,
    LPCRITICAL_SECTION  CriticalSection,
    DWORD               SpinCount
    )
{
    BOOL Result = FALSE;
#if defined(FUSION_WIN2000)
    typedef BOOL (WINAPI * PFN)(LPCRITICAL_SECTION CriticalSection, DWORD SpinCount);
    static PFN s_pfn;
    static BOOL s_initialized;
#endif

    __try
    {
        if ((Flags & FUSIONP_INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT) != 0)
        {
#if defined(FUSION_WIN)
            Result = ::InitializeCriticalSectionAndSpinCount(CriticalSection, SpinCount);
#elif defined(FUSION_WIN2000)
            if (!s_initialized)
            {
                HMODULE Kernel32Dll = ::LoadLibraryW(L"Kernel32.dll");
                if (Kernel32Dll == NULL && ::GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                {
                    Kernel32Dll = ::LoadLibraryA("Kernel32.dll");
                }
                if (Kernel32Dll != NULL)
                {
                    s_pfn = reinterpret_cast<PFN>(GetProcAddress(Kernel32Dll, "InitializeCriticalSectionAndSpinCount"));
                }
                s_initialized = TRUE;
            }
            if (s_pfn != NULL)
            {
                Result = (*s_pfn)(CriticalSection, SpinCount);
            }
            else
            {
                ::InitializeCriticalSection(CriticalSection);
                Result = TRUE;
            }
#else
#error
#endif
        }
        else
        {
            ::InitializeCriticalSection(CriticalSection);
            Result = TRUE;
        }
    }
    __except(SXSP_EXCEPTION_FILTER())
    {
        SXS_REPORT_SEH_EXCEPTION("", false);
        ::FusionpSetLastWin32Error(
#if FUSION_STATIC_NTDLL
            ::RtlNtStatusToDosErrorNoTeb(GetExceptionCode())
#else
            ERROR_OUTOFMEMORY
#endif
            );
    }
//Exit:
    return Result;
}

BOOL
FusionpInitializeCriticalSectionAndSpinCount(
    LPCRITICAL_SECTION  CriticalSection,
    DWORD               SpinCount
    )
{
    return FusionpInitializeCriticalSectionCommon(
        FUSIONP_INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT,
        CriticalSection,
        SpinCount
        );
}

BOOL
FusionpInitializeCriticalSection(
    LPCRITICAL_SECTION CriticalSection
    )
{
    return FusionpInitializeCriticalSectionCommon(
        0,
        CriticalSection,
        0
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\fusionreg.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "util.h"
#include "fusionhandle.h"

#define MAX_REG_RETRY_COUNT     (10)

#define FIND_ERROR_IN_ACCEPTABLE_LIST(err, tgtlasterror, vcount) do { \
    SIZE_T i; \
    va_list ap; \
    va_start(ap, vcount); \
    (tgtlasterror) = (err); \
    for (i = 0; i < (vcount); i++) { \
        if ((err) == va_arg(ap, LONG)) \
            break; \
    } \
    va_end(ap); \
    if (i == (vcount)) { \
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: %s(%d) Err 0x%08lx not acceptable", __FUNCTION__, __LINE__, (err)); \
        ORIGINATE_WIN32_FAILURE_AND_EXIT(__FUNCTION__, err); \
    } \
} while (0)


BOOL
FusionpRegQueryBinaryValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CFusionArray<BYTE> &rbBuffer,
    DWORD &rdwLastError,
    SIZE_T cExceptionalLastErrors,
    ...
    )
{
    FN_PROLOG_WIN32

    LONG lResult = NO_ERROR;
    DWORD dwType = 0;
    DWORD dwChances;

    lResult = rdwLastError = ERROR_SUCCESS;

    PARAMETER_CHECK((dwFlags & ~FUSIONP_REG_QUERY_BINARY_NO_FAIL_IF_NON_BINARY) == 0);
    PARAMETER_CHECK(hKey != NULL);
    PARAMETER_CHECK(lpValueName != NULL);

    for (dwChances = 0; dwChances < MAX_REG_RETRY_COUNT; dwChances++)
    {
        DWORD dwDataSize = rbBuffer.GetSizeAsDWORD();
        LPBYTE pvData = rbBuffer.GetArrayPtr();

        lResult = ::RegQueryValueExW(
            hKey,
            lpValueName,
            NULL,
            &dwType,
            pvData,
            &dwDataSize);

        // If we are to fail because the type is wrong (ie: don't magically convert
        // from a reg-sz to a binary blob), then fail.

        //
        // HACKHACK: This is to get around a spectacular bug in RegQueryValueEx,
        // which is even documented as 'correct' in MSDN.
        //
        // RegQueryValueEx returns ERROR_SUCCESS when the data target pointer
        // was NULL but the size value was "too small."  So, we'll just claim
        // ERROR_MORE_DATA instead, and go around again, letting the buffer
        // get resized.
        //
        if ((pvData == NULL) && (lResult == ERROR_SUCCESS))
        {
            //
            // Yes, but if there's no data we need to stop and quit looking -
            // zero-length binary strings are a gotcha here.
            //
            if ( dwDataSize == 0 )
                break;
                
            lResult = ERROR_MORE_DATA;
        }
        
        if (lResult == ERROR_SUCCESS)
        {
            if ((dwFlags & FUSIONP_REG_QUERY_BINARY_NO_FAIL_IF_NON_BINARY) == 0)
                PARAMETER_CHECK(dwType == REG_BINARY);

            break;
        }
        else if (lResult == ERROR_MORE_DATA)
        {
            IFW32FALSE_EXIT(
                rbBuffer.Win32SetSize(
                    dwDataSize, 
                    CFusionArray<BYTE>::eSetSizeModeExact));
        }
        else
        {
            break; // must break from for loop
        }
    }

    if (lResult != ERROR_SUCCESS)
    {
        SIZE_T i = 0;
        va_list ap;
        va_start(ap, cExceptionalLastErrors);

        ::SetLastError(lResult);
        rdwLastError = lResult;

        for (i=0; i<cExceptionalLastErrors; i++)
        {                
            if (lResult == va_arg(ap, LONG))
                break;
        }
        va_end(ap);

        if (i == cExceptionalLastErrors)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(%ls)\n",
                __FUNCTION__,
                lpValueName
                );
            ORIGINATE_WIN32_FAILURE_AND_EXIT(RegQueryValueExW, lResult);
        }
    }

    FN_EPILOG
}


BOOL
FusionpRegQueryBinaryValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CFusionArray<BYTE> &rbBuffer
    )
{
    DWORD dwLastError = NO_ERROR;
    return ::FusionpRegQueryBinaryValueEx(dwFlags, hKey, lpValueName, rbBuffer, dwLastError, 0);
}


BOOL
FusionpRegQuerySzValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CBaseStringBuffer &rBuffer,
    DWORD &rdwLastError,
    SIZE_T cExceptionalLastErrorValues,
    ...
    )
{
    FN_PROLOG_WIN32
    LONG lResult = ERROR_SUCCESS;
    CStringBufferAccessor acc;
    DWORD cbBuffer;
    DWORD dwType = 0;

    rdwLastError = ERROR_SUCCESS;
    rBuffer.Clear();

    PARAMETER_CHECK((dwFlags & ~(FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING)) == 0);

    acc.Attach(&rBuffer);

    if (acc.GetBufferCb() > MAXDWORD)
    {
        cbBuffer = MAXDWORD;
    }
    else 
    {
        //
        // ISSUE:2002-3-29:jonwis - Shouldn't we have done something smarter here? Shouldn't we have
        //      adjusted for the terminating NULL character?
        //
        cbBuffer = static_cast<DWORD>(acc.GetBufferCb()) - sizeof(WCHAR);
    }

    lResult = ::RegQueryValueExW(hKey, lpValueName, NULL, &dwType, (LPBYTE) acc.GetBufferPtr(), &cbBuffer);

    //
    // The value wasn't found, but the flag to just return a NULL string was set.  Set the length
    // of the string to zero (stick a NULL as the first character) and return.
    //
    if ((lResult == ERROR_FILE_NOT_FOUND) && (dwFlags & FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING))
    {
        FN_SUCCESSFUL_EXIT();
    }
    //
    // If we got back "more data", expand out to the size that they want, and try again
    //
    else if (lResult == ERROR_MORE_DATA)
    {
        //
        // Resize the buffer to contain the string plus a NULL terminator.
        //
        acc.Detach();
        IFW32FALSE_EXIT(rBuffer.Win32ResizeBuffer(1 + (cbBuffer / sizeof(WCHAR)), eDoNotPreserveBufferContents));
        acc.Attach(&rBuffer);

        if (acc.GetBufferCb() > MAXDWORD)
        {
            cbBuffer = MAXDWORD;
        }
        else
        {
            cbBuffer = static_cast<DWORD>(acc.GetBufferCb());
        }
        lResult = ::RegQueryValueExW(hKey, lpValueName, NULL, &dwType, (LPBYTE)acc.GetBufferPtr(), &cbBuffer);
    }

    if (lResult != ERROR_SUCCESS)
    {
        FIND_ERROR_IN_ACCEPTABLE_LIST(lResult, rdwLastError, cExceptionalLastErrorValues);
    }
    else
    {
        if (dwType != REG_SZ)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(RegistryValueNotREG_SZ, ERROR_INVALID_DATA);
    }

    FN_EPILOG
}

BOOL
FusionpRegQuerySzValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CBaseStringBuffer &rBuffer
    )
{
    DWORD dw = 0;
    return ::FusionpRegQuerySzValueEx(dwFlags, hKey, lpValueName, rBuffer, dw, 0);
}

BOOL
FusionpRegQueryDwordValueEx(
    DWORD   dwFlags,
    HKEY    hKey,
    PCWSTR  wszValueName,
    PDWORD  pdwValue,
    DWORD   dwDefaultValue
    )
{
    FN_PROLOG_WIN32

    BOOL    bMissingValueOk = TRUE;
    DWORD   dwType = 0;
    DWORD   dwSize = 0;
    ULONG   ulResult = 0;

    if (pdwValue != NULL)
        *pdwValue = dwDefaultValue;

    PARAMETER_CHECK(pdwValue != NULL);
    PARAMETER_CHECK((dwFlags & ~FUSIONP_REG_QUERY_DWORD_MISSING_VALUE_IS_FAILURE) == 0);
    PARAMETER_CHECK(hKey != NULL);

    bMissingValueOk = ((dwFlags & FUSIONP_REG_QUERY_DWORD_MISSING_VALUE_IS_FAILURE) != 0);

    ulResult = ::RegQueryValueExW(
        hKey,
        wszValueName,
        NULL,
        &dwType,
        (PBYTE)pdwValue,
        &(dwSize = sizeof(*pdwValue)));

    //
    // If the user said that missing values are not an error, then fake up some
    // state stuff and continue.
    //
    if ((ulResult == ERROR_FILE_NOT_FOUND) && bMissingValueOk)
    {
        *pdwValue = dwDefaultValue;
        dwType = REG_DWORD;
        ulResult = ERROR_SUCCESS;
    }

    //
    // Got an error? Send it back
    //
    if (ulResult != ERROR_SUCCESS)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(RegQueryValueExW, ulResult);
    }

    //
    // If the type wasn't a dword, then that's a problem.
    //
    if ((dwType != REG_DWORD) || (dwSize != sizeof(*pdwValue)))
    {
        *pdwValue = dwDefaultValue;
        ORIGINATE_WIN32_FAILURE_AND_EXIT(RegQueryValueExW, ERROR_INVALID_DATA);
    }

    FN_EPILOG
}



BOOL
CRegKey::DestroyKeyTree()
{
    FN_PROLOG_WIN32

    CStringBuffer buffTemp;

    //
    // First go down and delete all our child subkeys
    //

    while (true)
    {
        BOOL fFlagTemp = FALSE;
        CRegKey hkSubKey;
    
        IFW32FALSE_EXIT( this->EnumKey( 0, buffTemp, NULL, &fFlagTemp ) );

        if ( fFlagTemp )
            break;

        //
        // There's more to delete than meets the eye.  But don't follow links
        // while wandering the registry.
        //
        IFW32FALSE_EXIT( this->OpenSubKey(
            hkSubKey, 
            buffTemp, KEY_ALL_ACCESS | FUSIONP_KEY_WOW64_64KEY, REG_OPTION_OPEN_LINK) );

        if (hkSubKey == this->GetInvalidValue())
        {
            continue;
        }

        IFW32FALSE_EXIT( hkSubKey.DestroyKeyTree() );

        //
        // Delete the key, ignore errors
        //
        IFW32FALSE_EXIT_UNLESS( this->DeleteKey( buffTemp ),
            ( ::FusionpGetLastWin32Error() == ERROR_PATH_NOT_FOUND ) ||
            ( ::FusionpGetLastWin32Error() == ERROR_FILE_NOT_FOUND ),
            fFlagTemp );

    }

    // Clear out the entries in the key as well - values as well
    while ( true )
    {
        BOOL fFlagTemp = FALSE;
        
        IFW32FALSE_EXIT( this->EnumValue( 0, buffTemp, NULL, &fFlagTemp ) );

        if ( fFlagTemp )
        {
            break;
        }

        IFW32FALSE_EXIT_UNLESS( this->DeleteValue( buffTemp ),
            ( ::FusionpGetLastWin32Error() == ERROR_PATH_NOT_FOUND ) ||
            ( ::FusionpGetLastWin32Error() == ERROR_FILE_NOT_FOUND ),
            fFlagTemp );
    }

    FN_EPILOG
}

BOOL
CRegKey::DeleteValue(
    IN PCWSTR pcwszValueName,
    OUT DWORD &rdwWin32Error,
    IN SIZE_T cExceptionalWin32Errors,
    ...
    ) const
{
    FN_PROLOG_WIN32
    LONG l;
	
	rdwWin32Error = ERROR_SUCCESS;
	l = ::RegDeleteValueW(*this, pcwszValueName);

    if (l != ERROR_SUCCESS)
    {
        FIND_ERROR_IN_ACCEPTABLE_LIST(l, rdwWin32Error, cExceptionalWin32Errors);
    }
    
    FN_EPILOG
}

BOOL
CRegKey::DeleteValue(
    IN PCWSTR pcwszValueName
    ) const
{
    DWORD dw;
    return this->DeleteValue(pcwszValueName, dw, 0);
}

BOOL
CRegKey::SetValue(
    IN PCWSTR pcwszValueName,
    IN DWORD dwValue
    ) const
{
    return this->SetValue(pcwszValueName, REG_DWORD, (PBYTE) &dwValue, sizeof(dwValue));
}


BOOL
CRegKey::SetValue(
    IN PCWSTR pcwszValueName,
    IN const CBaseStringBuffer &rcbuffValueValue
    ) const
{
    return this->SetValue(
        pcwszValueName,
        REG_SZ,
        (PBYTE) (static_cast<PCWSTR>(rcbuffValueValue)), 
        rcbuffValueValue.GetCbAsDWORD() + sizeof(WCHAR));
}

BOOL
CRegKey::SetValue(
    IN PCWSTR pcwszValueName,
    IN DWORD dwRegType,
    IN const BYTE *pbData,
    IN SIZE_T cbData
    ) const
{
    FN_PROLOG_WIN32

    IFREGFAILED_ORIGINATE_AND_EXIT(
		::RegSetValueExW(
	        *this,
		    pcwszValueName,
			0,
			dwRegType,
			pbData,
			(DWORD)cbData));

    FN_EPILOG
}

BOOL
CRegKey::GetValue(
    IN const CBaseStringBuffer &rbuffValueName,
    OUT CBaseStringBuffer &rbuffValueData
    )
{
    return this->GetValue(static_cast<PCWSTR>(rbuffValueName), rbuffValueData);
}

BOOL
CRegKey::GetValue(
    IN  PCWSTR pcwszValueName,
    OUT CBaseStringBuffer &rbuffValueData
    )
{
    return FusionpRegQuerySzValueEx(0, *this, pcwszValueName, rbuffValueData);
}

BOOL
CRegKey::GetValue(
    IN const CBaseStringBuffer &rbuffValueName,
    CFusionArray<BYTE> &rbBuffer
    )
{
    return this->GetValue(static_cast<PCWSTR>(rbuffValueName), rbBuffer);
}

BOOL
CRegKey::GetValue(
    IN PCWSTR pcwszValueName,
    CFusionArray<BYTE> &rbBuffer
    )
{
    return ::FusionpRegQueryBinaryValueEx(0, *this, pcwszValueName, rbBuffer);
}

BOOL
CRegKey::EnumValue(
    IN DWORD dwIndex, 
    OUT CBaseStringBuffer &rbuffValueName, 
    OUT LPDWORD lpdwType, 
    OUT PBOOL pfDone
    )
{
    FN_PROLOG_WIN32

    DWORD dwMaxRequiredValueNameLength = 0;
    DWORD dwMaxRequiredDataLength = 0;
    CStringBufferAccessor sbaValueNameAccess;
    DWORD dwError = 0;
    bool fRetried = false;

    if ( pfDone != NULL )
        *pfDone = FALSE;

Again:
    sbaValueNameAccess.Attach( &rbuffValueName );

    IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS(
        ::RegEnumValueW(
            *this,
            dwIndex,
            sbaValueNameAccess.GetBufferPtr(),
            &(dwMaxRequiredValueNameLength = sbaValueNameAccess.GetBufferCbAsDWORD()),
            NULL,
            lpdwType,
            NULL,
            NULL),
        LIST_2(ERROR_NO_MORE_ITEMS, ERROR_MORE_DATA),
        dwError);

    if ((dwError == ERROR_MORE_DATA) && !fRetried)
    {
        sbaValueNameAccess.Detach();
        IFW32FALSE_EXIT(
            rbuffValueName.Win32ResizeBuffer(
                dwMaxRequiredValueNameLength + 1, 
                eDoNotPreserveBufferContents));
        
        fRetried = true;
        goto Again;
    }
    //
    // Otherwise, if the error is "nothing more"
    //
    else if (dwError == ERROR_NO_MORE_ITEMS)
    {
        if (pfDone != NULL)
            *pfDone = TRUE;
    }
    //
    // Uhoh, we might have failed a second time through or we failed for some other reason -
    // originate and exit.
    //
    else if (dwError != ERROR_SUCCESS)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(RegEnumValueW, dwError);
    }

    FN_EPILOG
}

BOOL
CRegKey::LargestSubItemLengths(
    PDWORD pdwSubkeyLength, 
    PDWORD pdwValueLength
    ) const
{
    FN_PROLOG_WIN32

    IFREGFAILED_ORIGINATE_AND_EXIT( ::RegQueryInfoKeyW(
        *this,                  // hkey
        NULL,                   // lpclass
        NULL,                   // lpcbclass
        NULL,                   // lpreserved
        NULL,                   // lpcSubKeys
        pdwSubkeyLength,      // lpcbMaxSubkeyLength
        NULL,                   // lpcbMaxClassLength
        NULL,                   // lpcValues
        pdwValueLength,       // lpcbMaxValueNameLength
        NULL,
        NULL,
        NULL));
    
    FN_EPILOG
}


BOOL
CRegKey::EnumKey(
    IN DWORD dwIndex,
    OUT CBaseStringBuffer &rbuffKeyName,
    OUT PFILETIME pftLastWriteTime,
    OUT PBOOL pfDone
    ) const
{
    FN_PROLOG_WIN32

    CStringBufferAccessor sba;
    DWORD dwLargestKeyName = 0;
    BOOL fOutOfItems;

    if (pfDone != NULL)
        *pfDone = FALSE;

    //
    // ISSUE: jonwis 3/12/2002 - In a posting to win32prg, it's been noted that on NT/2k/XP
    //          the RegEnumKeyExW will return ERROR_MORE_DATA when the lpName buffer is
    //          too small.  So, this gross "get longest length, resize" hack can be
    //          removed, and we can use the normal "attempt, if too small resize reattempt"
    //          pattern.
    //
    IFW32FALSE_EXIT(this->LargestSubItemLengths(&dwLargestKeyName, NULL));
    if (dwLargestKeyName >= rbuffKeyName.GetBufferCch())
        IFW32FALSE_EXIT(
			rbuffKeyName.Win32ResizeBuffer(
				dwLargestKeyName + 1,
				eDoNotPreserveBufferContents));

    sba.Attach(&rbuffKeyName);

    IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS2(
        ::RegEnumKeyExW(
            *this,
            dwIndex,
            sba.GetBufferPtr(),
            &(dwLargestKeyName = sba.GetBufferCbAsDWORD()),
            NULL,
            NULL,
            NULL,
            pftLastWriteTime ),
            {ERROR_NO_MORE_ITEMS},
            fOutOfItems );

        
    if ( fOutOfItems && ( pfDone != NULL ) )
    {
        *pfDone = TRUE;
    }

    FN_EPILOG
}


BOOL 
CRegKey::OpenOrCreateSubKey( 
    OUT CRegKey &Target, 
    IN PCWSTR SubKeyName, 
    IN REGSAM rsDesiredAccess,
    IN DWORD dwOptions, 
    IN PDWORD pdwDisposition, 
    IN PWSTR pwszClass 
    ) const
{
    FN_PROLOG_WIN32

    HKEY hKeyNew = NULL;

    IFREGFAILED_ORIGINATE_AND_EXIT(
		::RegCreateKeyExW(
			*this,
			SubKeyName,
			0,
			pwszClass,
			dwOptions,
			rsDesiredAccess | FUSIONP_KEY_WOW64_64KEY,
			NULL,
			&hKeyNew,
			pdwDisposition));

    Target = hKeyNew;

    FN_EPILOG
}


BOOL
CRegKey::OpenSubKey(
    OUT CRegKey &Target,
    IN PCWSTR SubKeyName,
    IN REGSAM rsDesiredAccess,
    IN DWORD ulOptions
    ) const
{
    FN_PROLOG_WIN32

    BOOL fFilePathNotFound;
    HKEY hKeyNew = NULL;

    IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS2( ::RegOpenKeyExW(
        *this,
        SubKeyName,
        ulOptions,
        rsDesiredAccess | FUSIONP_KEY_WOW64_64KEY,
        &hKeyNew),
        LIST_2(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND),
        fFilePathNotFound );

    if (fFilePathNotFound)
        hKeyNew = this->GetInvalidValue();

    Target = hKeyNew;

    FN_EPILOG
}


BOOL
CRegKey::DeleteKey(
    IN PCWSTR pcwszSubkeyName
    )
{
    FN_PROLOG_WIN32
#if !defined(FUSION_WIN)
    IFREGFAILED_ORIGINATE_AND_EXIT(::RegDeleteKeyW(*this, pcwszSubkeyName));
#else
    //
    // Be sure to delete out of the native (64bit) registry.
    // The Win32 call doesn't have a place to pass the flag.
    //
    CRegKey ChildKey;
    NTSTATUS Status = STATUS_SUCCESS;

    IFW32FALSE_EXIT(this->OpenSubKey(ChildKey, pcwszSubkeyName, DELETE));

    //
    // make sure that the Key does exist, OpenSubKey return TRUE for non-existed Key
    //
    if (ChildKey != this->GetInvalidValue()) 
    {
        
        if (!NT_SUCCESS(Status = NtDeleteKey(ChildKey)))
        {
            RtlSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
            goto Exit;
        }
    }
#endif
    FN_EPILOG
}

BOOL
CRegKey::Save(
    IN PCWSTR pcwszTargetFilePath,
    IN DWORD dwFlags,
    IN LPSECURITY_ATTRIBUTES pSAttrs
    )
{
    FN_PROLOG_WIN32
    IFREGFAILED_ORIGINATE_AND_EXIT(::RegSaveKeyExW(*this, pcwszTargetFilePath, pSAttrs, dwFlags));
    FN_EPILOG
}

BOOL
CRegKey::Restore(
    IN PCWSTR pcwszSourceFileName,
    IN DWORD dwFlags
    )
{
    FN_PROLOG_WIN32
    IFREGFAILED_ORIGINATE_AND_EXIT(::RegRestoreKeyW(*this, pcwszSourceFileName, dwFlags));
    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\fusionsha1.cpp ===
#include "stdinc.h"
#include "debmacro.h"
#include "fusionsha1.h"

/*
SHA-1 in C
By Steve Reid <steve@edmweb.com>
100% Public Domain

Test Vectors (from FIPS PUB 180-1)
"abc"
  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
A million repetitions of "a"
  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
*/

#define LITTLE_ENDIAN
#define SHA1HANDSOFF


#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))

/* blk0() and blk() perform the initial expand. */
/* I got the idea of expanding during the round function from SSLeay */
#ifdef LITTLE_ENDIAN
#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
    |(rol(block->l[i],8)&0x00FF00FF))
#else
#define blk0(i) block->l[i]
#endif
#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
    ^block->l[(i+2)&15]^block->l[i&15],1))

/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);


/* Hash a single 512-bit block. This is the core of the algorithm. */

BOOL
CSha1Context::Transform(const unsigned char *buffer)
{
    FN_PROLOG_WIN32

    DWORD a, b, c, d, e;
    typedef union {
        unsigned char c[64];
        DWORD l[16];
    } CHAR64LONG16;

    CHAR64LONG16* block = reinterpret_cast<CHAR64LONG16*>(m_workspace);
    memcpy(block, buffer, 64);

    /* Copy context->state[] to working vars */
    a = this->state[0];
    b = this->state[1];
    c = this->state[2];
    d = this->state[3];
    e = this->state[4];
    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
    /* Add the working vars back into context.state[] */
    this->state[0] += a;
    this->state[1] += b;
    this->state[2] += c;
    this->state[3] += d;
    this->state[4] += e;
    /* Wipe variables */
    a = b = c = d = e = 0;

    FN_EPILOG
}


/* A_SHAInit - Initialize new context */

BOOL
CSha1Context::Initialize()
{
    FN_PROLOG_WIN32
    /* A_SHA initialization constants */
    this->state[0] = 0x67452301;
    this->state[1] = 0xEFCDAB89;
    this->state[2] = 0x98BADCFE;
    this->state[3] = 0x10325476;
    this->state[4] = 0xC3D2E1F0;
    this->count[0] = this->count[1] = 0;
    FN_EPILOG
}


/* Run your data through this. */

BOOL
CSha1Context::Update(const unsigned char* data, SIZE_T len)
{
    FN_PROLOG_WIN32
    
    SIZE_T i, j;

    j = (this->count[0] >> 3) & 63;
    if ((this->count[0] += len << 3) < (len << 3)) this->count[1]++;
    this->count[1] += (len >> 29);
    if ((j + len) > 63) {
        memcpy(&this->buffer[j], data, (i = 64-j));
        this->Transform(this->buffer);
        for ( ; i + 63 < len; i += 64) {
            this->Transform(&data[i]);
        }
        j = 0;
    }
    else i = 0;
    memcpy(&this->buffer[j], &data[i], len - i);
    FN_EPILOG
}


/* Add padding and return the message digest. */

BOOL 
CSha1Context::GetDigest(
    unsigned char *digest, 
    SIZE_T *len
    )
{
    FN_PROLOG_WIN32

    SIZE_T i, j;
    unsigned char finalcount[8];

    if ( !digest || (len && (*len < A_SHA_DIGEST_LEN)) || !len)
    {
        if (len != NULL)
            *len = A_SHA_DIGEST_LEN;

        // don't originate like normal to reduce noise level
        ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    *len = A_SHA_DIGEST_LEN;

    for (i = 0; i < 8; i++) {
        finalcount[i] = (unsigned char)((this->count[(i >= 4 ? 0 : 1)]
         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
    }
    this->Update((unsigned char *)"\200", 1);
    while ((this->count[0] & 504) != 448) {
        this->Update((unsigned char *)"\0", 1);
    }
    this->Update(finalcount, 8);  /* Should cause a A_SHATransform() */
    for (i = 0; i < 20; i++) {
        digest[i] = (unsigned char)
         ((this->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
    }
    /* Wipe variables */
    i = j = 0;
    memset(this->buffer, 0, sizeof(this->buffer));
    memset(this->state, 0, sizeof(this->state));
    memset(this->count, 0, sizeof(this->count));
    memset(finalcount, 0, sizeof(finalcount));
#ifdef SHA1HANDSOFF  /* make SHA1Transform overwrite it's own static vars */
    this->Transform(this->buffer);
#endif

    FN_EPILOG
}

BOOL
CFusionHash::GetIsValid()
{
    //
    // Not initialized at all
    //
    if (!m_fInitialized)
        return FALSE;

    //
    // Validity is known if the alg is SHA1 and the crypt handle is NULL, or if the
    // alg is not SHA1 and the crypt handle is non-null.
    //
    if (((m_aid == CALG_SHA1) && (this->m_hCryptHash == INVALID_CRYPT_HASH)) ||
         ((m_aid != CALG_SHA1) && (this->m_hCryptHash != INVALID_CRYPT_HASH)))
        return TRUE;
    else
        return FALSE;
}

BOOL
CFusionHash::Win32Initialize(
    ALG_ID aid
    )
{
    FN_PROLOG_WIN32

    if ( aid == CALG_SHA1 )
    {
        IFW32FALSE_EXIT(this->m_Sha1Context.Initialize());
    }
    else
    {
        HCRYPTPROV hProvider;
        IFW32FALSE_EXIT(::SxspAcquireGlobalCryptContext(&hProvider));
        IFW32FALSE_ORIGINATE_AND_EXIT(::CryptCreateHash(hProvider, aid, NULL, 0, &this->m_hCryptHash));
    }

    this->m_aid = aid;
    this->m_fInitialized = TRUE;
    
    FN_EPILOG
}

BOOL
CFusionHash::Win32HashData(
    const BYTE *pbBuffer,
    SIZE_T cbBuffer
    )
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(this->GetIsValid());

    if (m_hCryptHash != INVALID_CRYPT_HANDLE)
    {
        while (cbBuffer > MAXDWORD)
        {
            IFW32FALSE_ORIGINATE_AND_EXIT(::CryptHashData(this->m_hCryptHash, pbBuffer, MAXDWORD, 0));
            cbBuffer -= MAXDWORD;
        }

        IFW32FALSE_ORIGINATE_AND_EXIT(::CryptHashData(this->m_hCryptHash, pbBuffer, static_cast<DWORD>(cbBuffer), 0));
    }
    else
    {
        IFW32FALSE_EXIT(this->m_Sha1Context.Update(pbBuffer, cbBuffer));
    }

    FN_EPILOG
    
}

BOOL 
CFusionHash::Win32GetValue( 
    OUT CFusionArray<BYTE> &out 
    )
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(this->GetIsValid());

    for (;;)
    {
        SIZE_T len = out.GetSize();
        BOOL fMoreData;
        PBYTE pbData = out.GetArrayPtr();

        if ( m_hCryptHash == INVALID_CRYPT_HANDLE )
        {
            IFW32FALSE_EXIT_UNLESS( 
                this->m_Sha1Context.GetDigest(pbData, &len),
                ::FusionpGetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER,
                fMoreData);
        }
        else
        {
            DWORD dwNeedSize;
            DWORD dwValueSize;
            IFW32FALSE_ORIGINATE_AND_EXIT(
                ::CryptGetHashParam( 
                    this->m_hCryptHash, 
                    HP_HASHSIZE, 
                    (PBYTE)&dwNeedSize,
                    &(dwValueSize = sizeof(dwNeedSize)),
                    0));

            if ( dwNeedSize > len )
            {
                fMoreData = TRUE;
                len = dwNeedSize;
            }
            else
            {
                fMoreData = FALSE;
                IFW32FALSE_ORIGINATE_AND_EXIT(
                    ::CryptGetHashParam(
                        this->m_hCryptHash,
                        HP_HASHVAL,
                        pbData,
                        &(dwValueSize = out.GetSizeAsDWORD()),
                        0));
            }
        }
        
        if ( fMoreData )
            IFW32FALSE_EXIT(out.Win32SetSize(len, CFusionArray<BYTE>::eSetSizeModeExact));
        else
            break;
    }

    FN_EPILOG
}


HCRYPTPROV g_hGlobalCryptoProvider = INVALID_CRYPT_HANDLE;

BOOL
SxspAcquireGlobalCryptContext(
    HCRYPTPROV *pContext
    )
{
    BOOL        fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    HCRYPTPROV  hNewProvider = INVALID_CRYPT_HANDLE;

    if (pContext != NULL)
        *pContext = INVALID_CRYPT_HANDLE;

    PARAMETER_CHECK(pContext != NULL);

    //
    // Pointer reads are atomic.
    //
    hNewProvider = g_hGlobalCryptoProvider;
    if (hNewProvider != INVALID_CRYPT_HANDLE)
    {
        *pContext = hNewProvider;

        FN_SUCCESSFUL_EXIT();
    }

    //
    // Acquire the crypto context that's only for verification purposes.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::CryptAcquireContextW(
            &hNewProvider,
            NULL,
            NULL,
            PROV_RSA_FULL,
            CRYPT_SILENT | CRYPT_VERIFYCONTEXT));

    if (::InterlockedCompareExchangePointer(
        (PVOID*)&g_hGlobalCryptoProvider,
        (PVOID)hNewProvider,
        (PVOID)INVALID_CRYPT_HANDLE
       ) != (PVOID)INVALID_CRYPT_HANDLE)
    {
        //
        // We lost the race.
        //
        ::CryptReleaseContext(hNewProvider, 0);
        hNewProvider = g_hGlobalCryptoProvider;
    }

    *pContext = hNewProvider;

    FN_EPILOG
}


BOOL
WINAPI
FusionpCryptoContext_DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID pvReserved
    )
{
    BOOL        fSuccess = FALSE;

    switch (dwReason)
    {
    case DLL_PROCESS_DETACH:
        {
            if (pvReserved != NULL)
            {
                HCRYPTPROV  hProvider;
                HCRYPTPROV* pghProvider = &g_hGlobalCryptoProvider;
                //
                // Swap out the global context with the invalid value, readying our context to be
                // nuked.
                //
                hProvider = (HCRYPTPROV)(InterlockedExchangePointer((PVOID*)pghProvider, (PVOID)INVALID_CRYPT_HANDLE));
                if (hProvider != INVALID_CRYPT_HANDLE && pvReserved != NULL)
                {
                    ::CryptReleaseContext(hProvider, 0);
                }
            }
            else
            {
                g_hGlobalCryptoProvider = INVALID_CRYPT_HANDLE;
            }
        }
        break;
    default:
        break;
    }

    fSuccess = TRUE;
//Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\fusionheap.cpp ===
#include "stdinc.h"
#include "fusionheap.h"
#include "fusionbuffer.h"
#include "debmacro.h"
#include "numberof.h"

#define MAX_VTBL_ENTRIES         256

FUSION_HEAP_HANDLE g_hHeap = NULL;

#if FUSION_DEBUG_HEAP

FUSION_HEAP_HANDLE g_hDebugInfoHeap = NULL;
LONG g_FusionHeapAllocationCount = 0;
LONG g_FusionHeapAllocationToBreakOn = 0;
PVOID g_FusionHeapDeallocationPtrToBreakOn = NULL;
PVOID g_FusionHeapAllocationPtrToBreakOn = NULL;

WCHAR g_FusionModuleNameUnknown[] = L"(Unknown module)";

// NTRAID#NTBUG9 - 589824 - 2002/03/26 - xiaoyuw:
//  This is used to support uitl.lib on win98 because HeapXXX is not avaiable on win98.
//  FusionpHeapLock is defined to replace HeapLock to work around for certain codepath,
//  and there would be some problem if debug heap is enabled, for example, HeapWalk is 
//  always upsupported at win9x.
//
//  we could consider to remove this someday. and just set FUSION_DEBUG_HEAP to be 0 if 
//  the system is a win9x. FUSION_DISABLE_DEBUG_HEAP_ON_WIN98 is has already been provided. 

#if defined(FUSION_WIN2000)
CRITICAL_SECTION g_FusionpWin9xHeapLock;
#endif

//
//  g_FusionHeapOperationCount is used to keep track of the total number of
//  allocations and deallocations; the heap is verified each
//  g_FusionHeapCheckFrequency operations.  Set it to zero to disable any
//  non-explicit checks.
//

LONG g_FusionHeapOperationCount = 0;
LONG g_FusionHeapCheckFrequency = 1;

// Set g_FusionUsePrivateHeap to TRUE in your DllMain prior to
// calling FusionpInitializeHeap() to get a private heap for this DLL.
BOOL g_FusionUsePrivateHeap = FALSE;

//
// Setting this boolean enables stack-back-tracing for allocations.  This
// will make your life infinitely easier when trying to debug leaks.  However,
// it will eat piles more debug heap.  Set it via a breakin or in your DllMain.
//
// ABSOLUTELY DO NOT CHECK THIS IN WITH STACK TRACKING ENABLED!!!!!
//
BOOL g_FusionHeapTrackStackTraces = FALSE;

//  g_FusionHeapPostAllocationBytes is the number of extra bytes
//  to allocate and write a pattern on to watch for people overwriting
//  their allocations.
LONG g_FusionHeapPostAllocationBytes = 8;

UCHAR g_FusionHeapPostAllocationChar = 0xf0;

UCHAR g_FusionHeapAllocationPoisonChar = 0xfa;
UCHAR g_FusionHeapDeallocationPoisonChar = 0xfd;

// HINSTANCE used when initializing the heap; we use it later to report the
// dll name.
HINSTANCE g_FusionHeapHInstance;

#endif // FUSION_DEBUG_HEAP

BOOL
FusionpInitializeHeap(
    HINSTANCE hInstance
    )
{
#if FUSION_DEBUG_HEAP
    BOOL fSuccess = FALSE;

#if defined(FUSION_WIN2000)
    if (!FusionpInitializeCriticalSection(&g_FusionpWin9xHeapLock))
    {
        goto Exit;
    }
#endif

#if FUSION_PRIVATE_HEAP
    g_hHeap = (FUSION_HEAP_HANDLE) ::HeapCreate(0, 0, 0);
    if (g_hHeap == NULL)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS: Failed to create private heap.  FusionpGetLastWin32Error() = %d\n", ::FusionpGetLastWin32Error());
        goto Exit;
    }

#else
    if (g_FusionUsePrivateHeap)
    {
        g_hHeap = (FUSION_HEAP_HANDLE) ::HeapCreate(0, 0, 0);

        if (g_hHeap == NULL)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS: Failed to create private heap.  FusionpGetLastWin32Error() = %d\n", ::FusionpGetLastWin32Error());
            goto Exit;
        }
    }
    else
    {
        g_hHeap = (FUSION_HEAP_HANDLE) ::GetProcessHeap();

        if (g_hHeap == NULL)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS: Failed to get process default heap.  FusionpGetLastWin32Error() = %d\n", ::FusionpGetLastWin32Error());
            goto Exit;
        }
    }
#endif

    g_hDebugInfoHeap = (FUSION_HEAP_HANDLE) ::HeapCreate(0, 0, 0);
    if (g_hDebugInfoHeap == NULL)
    {
        goto Exit;
    }

    g_FusionHeapHInstance = hInstance;

    fSuccess = TRUE;
Exit:
    return fSuccess;
#else
    g_hHeap = (FUSION_HEAP_HANDLE) ::GetProcessHeap();
    return TRUE;
#endif
}

VOID
FusionpUninitializeHeap()
{
#if FUSION_DEBUG_HEAP
    BOOL fHeapLocked = FALSE;
    BOOL fDebugHeapLocked = FALSE;
    PROCESS_HEAP_ENTRY phe;
    WCHAR DllName[MAX_PATH / sizeof(WCHAR)]; // keep stack frame to ~MAX_PATH bytes

    if (g_hHeap == NULL || g_hDebugInfoHeap == NULL)
        goto Exit;

    DllName[0] = 0;
    if (g_FusionHeapHInstance != NULL)
    {
        DWORD dwLen;
        dwLen = ::GetModuleFileNameW(g_FusionHeapHInstance, DllName, NUMBER_OF(DllName));
        if (dwLen >= NUMBER_OF(DllName))
            dwLen = NUMBER_OF(DllName) - 1;
        
        DllName[dwLen] = UNICODE_NULL;
    }

    if (!::HeapLock(g_hHeap))
        goto ReportError;

    fHeapLocked = TRUE;

    if (!::HeapLock(g_hDebugInfoHeap))
        goto ReportError;

    fDebugHeapLocked = TRUE;

    // Walk the debug heap looking for allocations...
    phe.lpData = NULL;

    while (::HeapWalk(g_hDebugInfoHeap, &phe))
    {
        if (!(phe.wFlags & PROCESS_HEAP_ENTRY_BUSY))
            continue;

        PFUSION_HEAP_ALLOCATION_TRACKER pTracker = (PFUSION_HEAP_ALLOCATION_TRACKER) phe.lpData;

        if (pTracker == NULL)
            continue;

        if (pTracker->Prefix == NULL)
            continue;

        // Stop the prefix from pointing at the debug info; we're doing to destroy the debug heap.
        pTracker->Prefix->Tracker = NULL;
    }

    //
    // On invalid function, meaning HeapWalk is not defined, just exit.
    // Same for no-more-items, meaning the end of the list is nigh.  We
    // make the assumption that none of the other functions in the loop
    // can fail with E_N_M_I or E_I_F - this may be a fallacy for later.
    //
    switch (::FusionpGetLastWin32Error())
    {
    case ERROR_INVALID_FUNCTION:
    case ERROR_NO_MORE_ITEMS:
        goto Exit;
    default:
        goto ReportError;
    }
    // Original code:
    //
    // if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_ITEMS)
    //    goto ReportError;
    //

    goto Exit;

ReportError:
    ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "%s: FusionpUninitializeHeap() encountered an error; FusionpGetLastWin32Error() = %d\n", DllName, ::FusionpGetLastWin32Error());

Exit:
    if (fDebugHeapLocked)
        ::HeapUnlock(g_hDebugInfoHeap);

    if (fHeapLocked)
        ::HeapUnlock(g_hHeap);

    if (g_hDebugInfoHeap != NULL)
        ::HeapDestroy(g_hDebugInfoHeap);

    g_hHeap = NULL;
    g_hDebugInfoHeap = NULL;

#if defined(FUSION_WIN2000)
    DeleteCriticalSection(&g_FusionpWin9xHeapLock);
#endif
#endif
}

#if FUSION_DEBUG_HEAP

VOID
FusionpDumpHeap(
    PCWSTR PerLinePrefixWithoutSpaces
    )
{
    BOOL fHeapLocked = FALSE;
    BOOL fDebugHeapLocked = FALSE;
    PROCESS_HEAP_ENTRY phe;
    WCHAR DllName[MAX_PATH / sizeof(WCHAR) / 2];
    WCHAR PerLinePrefix[MAX_PATH / sizeof(WCHAR) / 2]; // only MAX_PATH bytes for prev two variables
    const static WCHAR PerLineSpacesPrefix[] = L"   ";
    DWORD dwLen;

    if (g_hHeap == NULL || g_hDebugInfoHeap == NULL)
        goto Exit;

    // sprintf is overkill, but convenient, and it lets us reuse the buffer size support..
    ::_snwprintf(PerLinePrefix, NUMBER_OF(PerLinePrefix), L"%s%s", PerLinePrefixWithoutSpaces, PerLineSpacesPrefix);
    PerLinePrefix[NUMBER_OF(PerLinePrefix) - 1] = L'\0';

    DllName[0] = 0;
    dwLen = ::GetModuleFileNameW(g_FusionHeapHInstance, DllName, NUMBER_OF(DllName));
    if (dwLen >= NUMBER_OF(DllName))
        dwLen = NUMBER_OF(DllName) - 1;
    DllName[dwLen] = UNICODE_NULL;

    try
    {
        if (!::HeapLock(g_hHeap))
            goto ReportError;

        fHeapLocked = TRUE;

        if (!::HeapLock(g_hDebugInfoHeap))
            goto ReportError;

        fDebugHeapLocked = TRUE;

        // Walk the debug heap looking for allocations...
        phe.lpData = NULL;

        while (::HeapWalk(g_hDebugInfoHeap, &phe))
        {
            PCSTR HeapString;
            SIZE_T cbToShow;

            if (!(phe.wFlags & PROCESS_HEAP_ENTRY_BUSY))
                continue;

            PFUSION_HEAP_ALLOCATION_TRACKER pTracker = (PFUSION_HEAP_ALLOCATION_TRACKER) phe.lpData;

            if (pTracker == NULL)
                continue;

            if (pTracker->Prefix == NULL)
                continue;

            // If the caller wanted us to not report this allocation as being leaky, don't.
            if (pTracker->Flags & FUSION_HEAP_DO_NOT_REPORT_LEAKED_ALLOCATION)
                continue;

            if (pTracker->Heap == g_hHeap)
                HeapString = "default heap";
            else
                HeapString = "custom heap";

            cbToShow = pTracker->RequestedSize;

            if (cbToShow > 64)
                cbToShow = 64;

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "%s(%u): Memory allocation leaked!\n", pTracker->FileName, pTracker->Line);

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "%SLeaked %S allocation #%u (0x%lx) at %p \"%s\" (tracked by %p; allocated from heap %p - %s)\n"
                "%S   Requested bytes/Allocated bytes: %Iu / %Iu (dumping %Iu bytes)\n",
                PerLinePrefix, DllName, pTracker->SequenceNumber, pTracker->SequenceNumber, pTracker->Prefix, pTracker->Expression, pTracker, pTracker->Heap, HeapString,
                PerLinePrefix, pTracker->RequestedSize, pTracker->AllocationSize, cbToShow);
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "%s   Allocated at line %u of %s\n",
                PerLinePrefix, pTracker->Line, pTracker->FileName);

#if FUSION_ENABLE_FROZEN_STACK
            if (pTracker->pvFrozenStack)
                ::FusionpOutputFrozenStack(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS",
                    (PFROZEN_STACK)pTracker->pvFrozenStack);
#endif

            ::FusionpDbgPrintBlob(
                FUSION_DBG_LEVEL_ERROR,
                pTracker->Prefix + 1,
                cbToShow,
                PerLinePrefix);
        }

        //
        // On invalid function, meaning HeapWalk is not defined, just exit.
        // Same for no-more-items, meaning the end of the list is nigh.  We
        // make the assumption that none of the other functions in the loop
        // can fail with E_N_M_I or E_I_F - this may be a fallacy for later.
        //
        switch (::FusionpGetLastWin32Error())
        {
        case ERROR_INVALID_FUNCTION:
        case ERROR_NO_MORE_ITEMS:
            goto Exit;
        default:
            goto ReportError;
        }
        // Original code:
        //
        // if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_ITEMS)
        //    goto ReportError;
        //
    }
    catch(...)
    {
    }

    goto Exit;

ReportError:
    ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "%S: FusionpDumpHeap() encountered an error; FusionpGetLastWin32Error() = %d\n", DllName, ::FusionpGetLastWin32Error());

Exit:
    if (fDebugHeapLocked)
        ::HeapUnlock(g_hDebugInfoHeap);

    if (fHeapLocked)
        ::HeapUnlock(g_hHeap);
}

VOID
FusionpValidateHeap(
    FUSION_HEAP_HANDLE hFusionHeap
    )
{
    FN_TRACE();

    BOOL fHeapLocked = FALSE;
    BOOL fDebugHeapLocked = FALSE;
    PROCESS_HEAP_ENTRY phe;
    SIZE_T i;
    WCHAR DllName[MAX_PATH / sizeof(WCHAR)]; // keep stack frame to ~MAX_PATH bytes
    PCWSTR DllNamePointer = DllName;
    DWORD dwCallStatus;
    HANDLE hHeap = (HANDLE) hFusionHeap;

    DllName[0] = 0;

    if (g_hDebugInfoHeap == NULL)
        goto Exit;

    //
    // Get the current module's name, but don't print garbage if it fails.
    //
    dwCallStatus = ::GetModuleFileNameW(g_FusionHeapHInstance, DllName, NUMBER_OF(DllName));
    if (!dwCallStatus)
    {
#if defined(FUSION_WIN2000)
        if ((GetVersion() & 0x80000000) != 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
        {
            DllNamePointer = L"Win9x..";
        }
        else
#endif
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "FusionpValidateHeap() was unable to get the current module name, code = %d\n",
                ::FusionpGetLastWin32Error());

            //
            // Blank the name, insert something relevant.
            //
            DllNamePointer = g_FusionModuleNameUnknown;
        }
    }
    try
    {
        if (hHeap != NULL)
        {
            if (!::HeapLock(hHeap))
                goto ReportError;

            fHeapLocked = TRUE;
        }

        if (!::HeapLock(g_hDebugInfoHeap))
            goto ReportError;

        fDebugHeapLocked = TRUE;

        // Walk the debug heap looking for allocations...
        phe.lpData = NULL;

        while (::HeapWalk(g_hDebugInfoHeap, &phe))
        {
            PCSTR HeapString;
            SIZE_T cbToShow;

            if (!(phe.wFlags & PROCESS_HEAP_ENTRY_BUSY))
                continue;

            PFUSION_HEAP_ALLOCATION_TRACKER pTracker = (PFUSION_HEAP_ALLOCATION_TRACKER) phe.lpData;

            if (pTracker == NULL)
                continue;

            if (pTracker->Prefix == NULL)
                continue;

            // If we're checking only a particular heap, skip...
            if ((hHeap != NULL) && (pTracker->Heap != hHeap))
                continue;

            if (pTracker->PostAllocPoisonArea == NULL)
                continue;

            // The area should have been NULL if the count of bytes was nonzero...
            ASSERT(pTracker->PostAllocPoisonBytes != 0);

            PUCHAR PostAllocPoisonArea = pTracker->PostAllocPoisonArea;
            const UCHAR PostAllocPoisonChar = pTracker->PostAllocPoisonChar;
            const ULONG PostAllocPoisonBytes = pTracker->PostAllocPoisonBytes;

            for (i=0; i<PostAllocPoisonBytes; i++)
            {
                if (PostAllocPoisonArea[i] != PostAllocPoisonChar)
                    break;
            }

            // The poison area looks good; skip...
            if (i == PostAllocPoisonBytes)
                continue;

            if (pTracker->Heap == g_hHeap)
                HeapString = "default heap";
            else
                HeapString = "custom heap";

            cbToShow = pTracker->RequestedSize;

            if (cbToShow > 64)
                cbToShow = 64;

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "Wrote past end of %S allocation #%u (0x%lx) at %p \"%s\" (tracked by %p; allocated from heap %p - %s)\n"
                "   Requested bytes/Allocated bytes: %Iu / %Iu (dumping %Iu bytes)\n",
                DllNamePointer, pTracker->SequenceNumber, pTracker->SequenceNumber, pTracker->Prefix, pTracker->Expression, pTracker, pTracker->Heap, HeapString,
                pTracker->RequestedSize, pTracker->AllocationSize, cbToShow);
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "   Allocated at line %u of %s\n",
                pTracker->Line, pTracker->FileName);

            ::FusionpDbgPrintBlob(
                FUSION_DBG_LEVEL_ERROR,
                pTracker->Prefix + 1,
                cbToShow,
                L"");

            ::FusionpDbgPrintBlob(
                FUSION_DBG_LEVEL_ERROR,
                pTracker->PostAllocPoisonArea,
                pTracker->PostAllocPoisonBytes,
                L"");
        }

        //
        // On invalid function, meaning HeapWalk is not defined, just exit.
        // Same for no-more-items, meaning the end of the list is nigh.  We
        // make the assumption that none of the other functions in the loop
        // can fail with E_N_M_I or E_I_F - this may be a fallacy for later.
        //
        switch (::FusionpGetLastWin32Error())
        {
        case ERROR_INVALID_FUNCTION:
        case ERROR_NO_MORE_ITEMS:
            goto Exit;
        default:
            goto ReportError;
        }
        // Original code:
        //
        // if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_ITEMS)
        //    goto ReportError;
        //
    }
    catch(...)
    {
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "%S: Exception while validating heap.\n", DllNamePointer);
    }

    goto Exit;

ReportError:
    ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "%S: FusionpValidateHeap() encountered an error; FusionpGetLastWin32Error() = %d\n", DllNamePointer, ::FusionpGetLastWin32Error());

Exit:
    if (fDebugHeapLocked)
        ::HeapUnlock(g_hDebugInfoHeap);

    if (fHeapLocked)
        ::HeapUnlock(hHeap);
}

#if defined(FUSION_WIN)

#define FusionpHeapLock HeapLock
#define FusionpHeapUnlock HeapUnlock

#elif defined(FUSION_WIN2000)

BOOL
FusionpHeapLock(
    HANDLE hHeap
    )
{
    if ((GetVersion() & 0x80000000) == 0)
    { // NT
        return HeapLock(hHeap);
    }
    else
    { // Win9x
        EnterCriticalSection(&g_FusionpWin9xHeapLock);
        return TRUE;
    }
}

BOOL
FusionpHeapUnlock(
    HANDLE hHeap
    )
{
    if ((GetVersion() & 0x80000000) == 0)
    { // NT
        return HeapUnlock(hHeap);
    }
    else
    { // Win9x
        LeaveCriticalSection(&g_FusionpWin9xHeapLock);
        return TRUE;
    }
}

#else

#error

#endif

PVOID
FusionpDbgHeapAlloc(
    FUSION_HEAP_HANDLE hHeap,
    DWORD dwHeapAllocFlags,
    SIZE_T cb,
    PCSTR pszFile,
    INT nLine,
    PCSTR pszExpression,
    DWORD dwFusionFlags
    )
{
    FN_TRACE();

    BOOL fSuccess = FALSE;
    BOOL fDebugHeapLocked = FALSE;
    SIZE_T cbAdditionalBytes = 0;
#if FUSION_ENABLE_FROZEN_STACK

//    BOOL bShouldTraceStack = (g_FusionHeapTrackStackTraces && (::TlsGetValue(g_FusionHeapTrackingDisabledDepthTLSIndex) == 0));
    BOOL bShouldTraceStack = g_FusionHeapTrackStackTraces;
    FROZEN_STACK Prober = { 0 };
#endif

    ASSERT(hHeap != NULL);
    LONG lAllocationSequenceNumber = ::InterlockedIncrement(&g_FusionHeapAllocationCount);

    if ((g_FusionHeapAllocationToBreakOn != 0) &&
        (lAllocationSequenceNumber == g_FusionHeapAllocationToBreakOn))
    {
        // Break in to the debugger, even if we're not in a checked build.
        FUSION_DEBUG_BREAK_IN_FREE_BUILD();
    }

    LONG lOperationSequenceNumber = ::InterlockedIncrement(&g_FusionHeapOperationCount);
    if ((g_FusionHeapCheckFrequency != 0) && ((lOperationSequenceNumber % g_FusionHeapCheckFrequency) == 0))
    {
        // Check the active heap allocations for correct post-block signatures...
        // NTRAID#NTBUG9 - 589824 - 2002/03/26 - xiaoyuw:
        // this call is very reasonable except costly, why we disable it?
       // ::FusionpValidateHeap(NULL);
    }

    PSTR psz = NULL;
    SIZE_T cbFile = (pszFile == NULL) ? 0 : ::strlen(pszFile) + 1;
    SIZE_T cbExpression = (pszExpression == NULL) ? 0 : ::strlen(pszExpression) + 1;
    PFUSION_HEAP_ALLOCATION_TRACKER pTracker = NULL;

    // Make a copy of the global variable so that if someone breaks in in the debugger
    // and changes it while we're in the middle of this code we don't die horribly.
    const ULONG cbPostAllocationBytes = g_FusionHeapPostAllocationBytes;
    const UCHAR chPostAllocationChar = g_FusionHeapPostAllocationChar;

    const SIZE_T cbToAllocate = (sizeof(FUSION_HEAP_PREFIX) + cb + cbPostAllocationBytes);
    const PFUSION_HEAP_PREFIX pPrefix = reinterpret_cast<PFUSION_HEAP_PREFIX>(::HeapAlloc(hHeap, dwHeapAllocFlags, cbToAllocate));
    if (pPrefix == NULL)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "%s(%d): [SXS.DLL] Heap allocation failure allocating %Iu (really %Iu) bytes\n", pszFile, nLine, cb, cbToAllocate);
        ::SetLastError(FUSION_WIN32_ALLOCFAILED_ERROR);
        return NULL;
    }

    // lock the debug info heap to allocate memory for pTracker
    if (!::FusionpHeapLock(g_hDebugInfoHeap))
        goto Exit;

    fDebugHeapLocked = TRUE;

    //
    // Are we tracing the stack?  If so, then we need to allocate some extra bytes
    // on the end of this tracker to store the context.
    //
#if FIXBEFORECHECKIN
    if (bShouldTraceStack)
    {
        BOOL bSuccess = ::FusionpFreezeStack(NULL, 0, &Prober);

        if (!bSuccess && (::FusionpGetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)) {
            cbAdditionalBytes = sizeof(FROZEN_STACK) + (sizeof(TRACECONTEXT) * Prober.ulMaxDepth);
        } else {
            cbAdditionalBytes = 0;
            bShouldTraceStack = FALSE;
        }
    }
    else
#endif // FIXBEFORECHECKIN
        cbAdditionalBytes = 0;

    pTracker = reinterpret_cast<PFUSION_HEAP_ALLOCATION_TRACKER>(::HeapAlloc(
        g_hDebugInfoHeap,
        0,
        sizeof(FUSION_HEAP_ALLOCATION_TRACKER)
            + FUSION_HEAP_ROUND_SIZE(cbFile)
            + FUSION_HEAP_ROUND_SIZE(cbExpression)
            + FUSION_HEAP_ROUND_SIZE(cbAdditionalBytes)));

    if (pTracker == NULL)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "%s(%d): [SXS.DLL] Heap allocation failure allocating tracker for %lu bytes\n", pszFile, nLine, cb);
        ::HeapFree(hHeap, 0, pPrefix);
        ::SetLastError(FUSION_WIN32_ALLOCFAILED_ERROR);
        goto Exit;
    }

    pPrefix->Tracker = pTracker;
    pTracker->Prefix = pPrefix;

    pTracker->Heap = hHeap;
    pTracker->SequenceNumber = lAllocationSequenceNumber;
    pTracker->PostAllocPoisonBytes = cbPostAllocationBytes;

    if (cbPostAllocationBytes != 0)
    {
        const PUCHAR pb = (UCHAR *) (((ULONG_PTR) (pPrefix + 1)) + cb);
        ULONG i;

        pTracker->PostAllocPoisonArea = (PUCHAR) pb;
        pTracker->PostAllocPoisonChar = chPostAllocationChar;

        for (i=0; i<cbPostAllocationBytes; i++)
            pb[i] = chPostAllocationChar;
    }
    else
    {
        pTracker->PostAllocPoisonArea = NULL;
    }

    psz = (PSTR) (pTracker + 1);

    if (cbFile != 0)
    {
        pTracker->FileName = psz;
        memcpy(psz, pszFile, cbFile);
        psz += FUSION_HEAP_ROUND_SIZE(cbFile);
    }
    else
        pTracker->FileName = NULL;

    if (cbExpression != 0)
    {
        pTracker->Expression = psz;
        memcpy(psz, pszExpression, cbExpression);
        psz += FUSION_HEAP_ROUND_SIZE(cbExpression);
    }
    else
        pTracker->Expression = NULL;

#if FUSION_ENABLE_FROZEN_STACK

    //
    // Set up our stack tracker
    //
    if (bShouldTraceStack)
    {
        PFROZEN_STACK pStack = (PFROZEN_STACK)psz;
        pTracker->pvFrozenStack = pStack;

        pStack->ulDepth = 0;
        pStack->ulMaxDepth = Prober.ulMaxDepth;

        if (!::FusionpFreezeStack(0, pStack))
            pTracker->pvFrozenStack = NULL;
    }
    //
    // Otherwise, no stack for you.
    //
    else
    {
        pTracker->pvFrozenStack = NULL;
    }
#endif

    pTracker->Line = nLine;
    pTracker->Flags = dwFusionFlags;
    pTracker->RequestedSize = cb;
    pTracker->AllocationSize = cb + sizeof(FUSION_HEAP_PREFIX);

    // poison the allocation...
    memset((pPrefix + 1), g_FusionHeapAllocationPoisonChar, cb);

    // NTRAID#NTBUG9 - 589824 - 2002/03/26 - xiaoyuw:
    // shouldn't pPrefix be reset after memset is called?
    if ((g_FusionHeapAllocationPtrToBreakOn != 0) &&
        ((pPrefix + 1) == g_FusionHeapAllocationPtrToBreakOn))
    {
        // Break in to the debugger, even if we're not in a checked build.
        FUSION_DEBUG_BREAK_IN_FREE_BUILD();
    }


    fSuccess = TRUE;
Exit:
    if (fDebugHeapLocked){
        // NTRAID#NTBUG9 - 589824 - 2002/03/26 - xiaoyuw:
        // (1) use CSxsPreserveLastError instead, 
        // (2) in the case of failure call of FusionpHeapUnlock, we stil want to keep the error if fSuccess == TRUE at this moment.
        DWORD dwLastError = ::FusionpGetLastWin32Error();
        ::FusionpHeapUnlock(g_hDebugInfoHeap);
        ::SetLastError(dwLastError);
    }

    if (fSuccess)
        return (PVOID) (pPrefix + 1);
    else
        return NULL;
}

BOOL
FusionpDbgHeapFree(
    FUSION_HEAP_HANDLE hHeap,
    DWORD dwHeapFreeFlags,
    PVOID pv
    )
{
    FN_TRACE();

    PFUSION_HEAP_ALLOCATION_TRACKER pTracker;
    BOOL fResult = FALSE;

    ASSERT(hHeap != NULL);

    if (pv == NULL)
        return FALSE;

    if ((g_FusionHeapDeallocationPtrToBreakOn != NULL) &&
        (pv == g_FusionHeapDeallocationPtrToBreakOn))
    {
        // Break in to the debugger, even if we're not in a checked build.
        FUSION_DEBUG_BREAK_IN_FREE_BUILD();
    }

    // Let's see if its one of our funky ones...
    PFUSION_HEAP_PREFIX p = (PFUSION_HEAP_PREFIX) (((ULONG_PTR) pv) - sizeof(FUSION_HEAP_PREFIX));

    if (!::HeapValidate(hHeap, 0, p)) {
        // HeapValidate failed. Fatal. Just leak the memory for now...
        // ASSERT(0);
        return FALSE;
    }
    if (!::HeapValidate(g_hDebugInfoHeap, 0, p->Tracker)) {
        // HeapValidate failed. Fatal. Just leak the memory for now...
        // ASSERT(0);
        return FALSE;
    }

    pTracker = p->Tracker;

    ASSERT(pTracker->Heap == hHeap);

    p->Tracker->Prefix = NULL;

    // poison the deallocation...
    memset(p, g_FusionHeapDeallocationPoisonChar, pTracker->AllocationSize);

    ::HeapFree(g_hDebugInfoHeap, 0, pTracker);
    fResult = ::HeapFree(hHeap, dwHeapFreeFlags, p);

    return fResult;
}

VOID
FusionpDeallocateTracker(
    PFUSION_HEAP_PREFIX p
    )
{
    CSxsPreserveLastError ple;
    PFUSION_HEAP_ALLOCATION_TRACKER pTracker = p->Tracker;

    ::HeapFree(g_hDebugInfoHeap, 0, pTracker);
    p->Tracker = NULL;
    ple.Restore();
}

VOID *
FusionpGetFakeVTbl()
{
    VOID                  *pvHeap;
    // Always allocate the fake vtbl from the process heap so that it survives us nomatter what.
    pvHeap = HeapAlloc(::GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_VTBL_ENTRIES * sizeof(void *));
    return pvHeap;
}

VOID
FusionpDontTrackBlk(
    VOID *pv
    )
{
    PFUSION_HEAP_PREFIX              p;
    p = (PFUSION_HEAP_PREFIX) (((ULONG_PTR)pv) - sizeof(FUSION_HEAP_PREFIX));
    ::FusionpDeallocateTracker(p);
    p->Tracker = NULL;
}

#else // FUSION_DEBUG_HEAP

LPVOID
WINAPI
FusionpHeapAlloc(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN SIZE_T dwBytes
    )
{
    LPVOID p = ::HeapAlloc(hHeap, dwFlags, dwBytes);
    if (p == NULL)
    {
        ::SetLastError(FUSION_WIN32_ALLOCFAILED_ERROR);
    }
    return p;
}

LPVOID
WINAPI
FusionpHeapReAlloc(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPVOID lpMem,
    IN SIZE_T dwBytes
    )
{
    LPVOID p = ::HeapReAlloc(hHeap, dwFlags, lpMem, dwBytes);
    if (p == NULL)
    {
        ::SetLastError(FUSION_WIN32_ALLOCFAILED_ERROR);
    }
    return p;
}

#endif // FUSION_DEBUG_HEAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\fusionreg2.cpp ===
#include "stdinc.h"
#include "util.h"
#include "fusionhandle.h"
#include "win32oneshot.h"
#include "win32simplelock.h"
#include "lhport.h"

//
// Comparison of unsigned numbers by subtraction does NOT work!
//
#define COMPARE_NUMBER(x, y) \
    (((x) < (y)) ? -1 : ((x) > (y)) ? +1 : 0)

class CRegistryTypeInformation
{
public:
    DWORD     Dword;
    PCWSTR    String;
    PCWSTR    PreferredString;
};

class CRegistryRootInformation
{
public:
    union
    {
        HKEY      PseudoHandle;
        ULONG_PTR PseudoHandleInteger;
    };
    PCWSTR String;
};

typedef BYTE CRegistryTypeInformationIndex;
typedef BYTE CRegistryRootInformationIndex;

const CRegistryTypeInformation RegistryTypeInformation[] =
{
#define ENTRY(x) { x, L###x },
#define ENTRY2(x,y) { x, L###x, L###x },
    ENTRY(REG_NONE)
    ENTRY(REG_SZ)
    ENTRY(REG_EXPAND_SZ)
    ENTRY(REG_BINARY)
    ENTRY2(REG_DWORD, REG_DWORD)
    ENTRY2(REG_DWORD_LITTLE_ENDIAN, REG_DWORD)
    ENTRY(REG_DWORD_BIG_ENDIAN)
    ENTRY(REG_LINK)
    ENTRY(REG_MULTI_SZ)
    ENTRY(REG_RESOURCE_LIST)
    ENTRY(REG_FULL_RESOURCE_DESCRIPTOR)
    ENTRY(REG_RESOURCE_REQUIREMENTS_LIST)
    ENTRY2(REG_QWORD, REG_QWORD)
    ENTRY2(REG_QWORD_LITTLE_ENDIAN, REG_QWORD)
#undef ENTRY
#undef ENTRY2
};

const CRegistryRootInformation RegistryRootInformation[] =
{
#define ENTRY(x) { x, L###x },
    ENTRY(HKEY_CLASSES_ROOT)
    ENTRY(HKEY_CURRENT_USER)
    ENTRY(HKEY_LOCAL_MACHINE)
    ENTRY(HKEY_USERS)
    ENTRY(HKEY_PERFORMANCE_DATA)
    ENTRY(HKEY_PERFORMANCE_TEXT)
    ENTRY(HKEY_PERFORMANCE_NLSTEXT)
    ENTRY(HKEY_CURRENT_CONFIG)
    ENTRY(HKEY_DYN_DATA)
#undef ENTRY
};

CRegistryTypeInformationIndex RegistryTypeInformation_IndexedByDword[NUMBER_OF(RegistryTypeInformation)];
CRegistryTypeInformationIndex RegistryTypeInformation_IndexedByString[NUMBER_OF(RegistryTypeInformation)];

CRegistryRootInformationIndex RegistryRootInformation_IndexedByPseudoHandle[NUMBER_OF(RegistryRootInformation)];
CRegistryRootInformationIndex RegistryRootInformation_IndexedByString[NUMBER_OF(RegistryRootInformation)];

void InitializeIndexArray(BYTE * Index, BYTE Count)
{
    BYTE i = 0;
    for ( i = 0 ; i != Count ; ++i)
    {
        Index[i] = i;
    }
}

int
__cdecl
RegistryTypeInformation_IndexedByDword_Compare_qsort(
    const void * VoidElem1,
    const void * VoidElem2
    )
{
    const CRegistryTypeInformationIndex * Index1 = reinterpret_cast<const CRegistryTypeInformationIndex*>(VoidElem1);
    const CRegistryTypeInformationIndex * Index2 = reinterpret_cast<const CRegistryTypeInformationIndex*>(VoidElem2);

    return COMPARE_NUMBER(RegistryTypeInformation[*Index1].Dword, RegistryTypeInformation[*Index2].Dword);
}

int
__cdecl
RegistryTypeInformation_IndexedByString_Compare_qsort(
    const void * VoidElem1,
    const void * VoidElem2
    )
{
    const CRegistryTypeInformationIndex * Index1 = reinterpret_cast<const CRegistryTypeInformationIndex*>(VoidElem1);
    const CRegistryTypeInformationIndex * Index2 = reinterpret_cast<const CRegistryTypeInformationIndex*>(VoidElem2);

    return FusionpStrCmpI(RegistryTypeInformation[*Index1].String, RegistryTypeInformation[*Index2].String);
}

int
__cdecl
RegistryTypeInformation_IndexedByDword_Compare_bsearch(
    const void * VoidKey,
    const void * VoidElem
    )
{
    const CRegistryTypeInformation * Key = reinterpret_cast<const CRegistryTypeInformation*>(VoidKey);
    const CRegistryTypeInformationIndex * Index = reinterpret_cast<const CRegistryTypeInformationIndex*>(VoidElem);

    return COMPARE_NUMBER(Key->Dword, RegistryTypeInformation[*Index].Dword);
}

int
__cdecl
RegistryTypeInformation_IndexedByString_Compare_bsearch(
    const void * VoidKey,
    const void * VoidElem
    )
{
    const CRegistryTypeInformation * Key = reinterpret_cast<const CRegistryTypeInformation*>(VoidKey);
    const CRegistryTypeInformationIndex * Index = reinterpret_cast<const CRegistryTypeInformationIndex*>(VoidElem);

    return FusionpStrCmpI(Key->String, RegistryTypeInformation[*Index].String);
}

int
__cdecl
RegistryRootInformation_IndexedByPseudoHandle_Compare_qsort(
    const void * VoidElem1,
    const void * VoidElem2
    )
{
    const CRegistryRootInformationIndex * Index1 = reinterpret_cast<const CRegistryRootInformationIndex*>(VoidElem1);
    const CRegistryRootInformationIndex * Index2 = reinterpret_cast<const CRegistryRootInformationIndex*>(VoidElem2);

    return COMPARE_NUMBER(RegistryRootInformation[*Index1].PseudoHandleInteger, RegistryRootInformation[*Index2].PseudoHandleInteger);
}

int
__cdecl
RegistryRootInformation_IndexedByString_Compare_qsort(
    const void * VoidElem1,
    const void * VoidElem2
    )
{
    const CRegistryRootInformationIndex * Index1 = reinterpret_cast<const CRegistryRootInformationIndex*>(VoidElem1);
    const CRegistryRootInformationIndex * Index2 = reinterpret_cast<const CRegistryRootInformationIndex*>(VoidElem2);

    return FusionpStrCmpI(RegistryRootInformation[*Index1].String, RegistryRootInformation[*Index2].String);
}

int
__cdecl
RegistryRootInformation_IndexedByPseudoHandle_Compare_bsearch(
    const void * VoidKey,
    const void * VoidElem
    )
{
    const CRegistryRootInformation * Key = reinterpret_cast<const CRegistryRootInformation*>(VoidKey);
    const CRegistryRootInformationIndex * Index = reinterpret_cast<const CRegistryRootInformationIndex*>(VoidElem);

    return COMPARE_NUMBER(Key->PseudoHandleInteger, RegistryRootInformation[*Index].PseudoHandleInteger);
}

int
__cdecl
RegistryRootInformation_IndexedByString_Compare_bsearch(
    const void * VoidKey,
    const void * VoidElem
    )
{
    const CRegistryRootInformation * Key = reinterpret_cast<const CRegistryRootInformation*>(VoidKey);
    const CRegistryRootInformationIndex * Index = reinterpret_cast<const CRegistryRootInformationIndex*>(VoidElem);

    return FusionpStrCmpI(Key->String, RegistryRootInformation[*Index].String);
}

WIN32_ONE_SHOT_OPAQUE_STATIC_STATE InitializeRegistryTypeInformation_Oneshot;

void InitializeRegistryTypeInformation()
{
    //
    // More than one init is ok, but multiple concurrent inits are not.
    // Contention could be reduced by copying into a local, sort local, copy back.
    //
    if (Win32EnterOneShotW(WIN32_ENTER_ONE_SHOT_FLAG_EXACTLY_ONCE, &InitializeRegistryTypeInformation_Oneshot))
    {
        __try
        {
            InitializeIndexArray(RegistryTypeInformation_IndexedByDword, NUMBER_OF(RegistryTypeInformation_IndexedByDword));
            CopyMemory(&RegistryTypeInformation_IndexedByString, &RegistryTypeInformation_IndexedByDword, sizeof(RegistryTypeInformation_IndexedByDword));

            qsort(
                RegistryTypeInformation_IndexedByDword,
                NUMBER_OF(RegistryTypeInformation_IndexedByDword),
                sizeof(RegistryTypeInformation_IndexedByDword[0]),
                RegistryTypeInformation_IndexedByDword_Compare_qsort
                );

            qsort(
                RegistryTypeInformation_IndexedByString,
                NUMBER_OF(RegistryTypeInformation_IndexedByString),
                sizeof(RegistryTypeInformation_IndexedByString[0]),
                RegistryTypeInformation_IndexedByString_Compare_qsort
                );

            //Win32RegisterDllNotification(Cleanup);
        }
        __finally
        {
            Win32LeaveOneShotW(0, &InitializeRegistryTypeInformation_Oneshot);
        }
    }
    else
    {
        ASSERT_NTC(F::GetLastWin32Error() == NO_ERROR);
    }
}

// oneshot vs. simplelock just for variety/coverage
CWin32SimpleLock InitializeRegistryRootInformation_Lock = WIN32_INIT_SIMPLE_LOCK;

void InitializeRegistryRootInformation()
{
    CWin32SimpleLockHolder lock(&InitializeRegistryRootInformation_Lock);
    if (lock.m_Result & WIN32_ACQUIRE_SIMPLE_LOCK_WAS_FIRST_ACQUIRE)
    {
        InitializeIndexArray(RegistryRootInformation_IndexedByPseudoHandle, NUMBER_OF(RegistryRootInformation_IndexedByPseudoHandle));
        CopyMemory(&RegistryRootInformation_IndexedByString, &RegistryRootInformation_IndexedByPseudoHandle, sizeof(RegistryRootInformation_IndexedByPseudoHandle));

        qsort(
            RegistryRootInformation_IndexedByPseudoHandle,
            NUMBER_OF(RegistryRootInformation_IndexedByPseudoHandle),
            sizeof(RegistryRootInformation_IndexedByPseudoHandle[0]),
            RegistryRootInformation_IndexedByPseudoHandle_Compare_qsort
            );

        qsort(
            RegistryRootInformation_IndexedByString,
            NUMBER_OF(RegistryRootInformation_IndexedByString),
            sizeof(RegistryRootInformation_IndexedByString[0]),
            RegistryRootInformation_IndexedByString_Compare_qsort
            );
    }
}

const CRegistryTypeInformation *
FindRegistryType(
    const CRegistryTypeInformation * Key,
    const CRegistryTypeInformationIndex * Array,
    int (__cdecl * ComparisonFunction)(const void *, const void *)
    )
{
    InitializeRegistryTypeInformation();

    const CRegistryTypeInformationIndex * Index = reinterpret_cast<const CRegistryTypeInformationIndex *>(
        bsearch(
            Key,
            Array,
            sizeof(RegistryTypeInformation_IndexedByDword),
            sizeof(RegistryTypeInformation_IndexedByDword[0]),
            ComparisonFunction
            ));
    if (Index == NULL)
    {
        F::SetLastWin32Error(ERROR_NOT_FOUND);
        return NULL;
    }
    return &RegistryTypeInformation[*Index];
}

BOOL F::RegistryTypeDwordToString(DWORD Dword, PCWSTR & String)
{
    FN_PROLOG_WIN32;
    const CRegistryTypeInformation * TypeInfo = NULL;
    CRegistryTypeInformation Key;
    Key.Dword = Dword;

    IFW32NULL_EXIT(TypeInfo = FindRegistryType(
            &Key,
            RegistryTypeInformation_IndexedByDword,
            RegistryTypeInformation_IndexedByDword_Compare_bsearch));
    if (TypeInfo->PreferredString != NULL)
        String = TypeInfo->PreferredString;
    else
        String = TypeInfo->String;
    FN_EPILOG;
}

BOOL F::RegistryTypeStringToDword(PCWSTR String, DWORD & Dword)
{
    FN_PROLOG_WIN32;
    const CRegistryTypeInformation * TypeInfo = NULL;
    CRegistryTypeInformation Key;
    Key.String = String;

    IFW32NULL_EXIT(TypeInfo = FindRegistryType(
            &Key,
            RegistryTypeInformation_IndexedByString,
            RegistryTypeInformation_IndexedByString_Compare_bsearch));
    Dword = TypeInfo->Dword;
    FN_EPILOG;
}

const CRegistryRootInformation *
FindRegistryRoot(
    const CRegistryRootInformation * Key,
    const CRegistryRootInformationIndex * Array,
    int (__cdecl * ComparisonFunction)(const void *, const void *)
    )
{
    InitializeRegistryRootInformation();

    const CRegistryRootInformationIndex * Index = reinterpret_cast<const CRegistryRootInformationIndex *>(
        bsearch(
            Key,
            Array,
            sizeof(RegistryRootInformation_IndexedByPseudoHandle),
            sizeof(RegistryRootInformation_IndexedByPseudoHandle[0]),
            ComparisonFunction
            ));
    if (Index == NULL)
    {
        ::SetLastError(ERROR_NOT_FOUND);
        return NULL;
    }
    return &RegistryRootInformation[*Index];
}

BOOL F::RegistryBuiltinRootToString(HKEY PseudoHandle, PCWSTR & String)
{
    FN_PROLOG_WIN32;
    const CRegistryRootInformation * RootInfo = NULL;
    CRegistryRootInformation Key;
    Key.PseudoHandle = PseudoHandle;

    IFW32NULL_EXIT(RootInfo = FindRegistryRoot(
            &Key,
            RegistryRootInformation_IndexedByString,
            RegistryRootInformation_IndexedByString_Compare_bsearch));
    String = RootInfo->String;
    FN_EPILOG;
}

BOOL F::RegistryBuiltinStringToRoot(PCWSTR String, HKEY & PseudoHandle)
{
    FN_PROLOG_WIN32;
    const CRegistryRootInformation * RootInfo = NULL;
    CRegistryRootInformation Key;
    Key.String = String;

    IFW32NULL_EXIT(RootInfo = FindRegistryRoot(
            &Key,
            RegistryRootInformation_IndexedByString,
            RegistryRootInformation_IndexedByString_Compare_bsearch));
    PseudoHandle = RootInfo->PseudoHandle;
    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\getfilesizeex.c ===
#include "windows.h"

#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFF)

#if defined(__cplusplus)
extern "C"
{
#endif

BOOL
WINAPI
FusionpGetFileSizeEx(
    HANDLE         FileHandle,
    PLARGE_INTEGER FileSize
    )
{
    if ((FileSize->LowPart = GetFileSize(FileHandle, (DWORD*)&FileSize->HighPart)) == INVALID_FILE_SIZE && GetLastError() != NO_ERROR)
        return FALSE;
    return TRUE;
}

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\helpers.cpp ===
#include "stdinc.h"
#include "util.h"
#include "fusionbuffer.h"
#include "xmlparser.h"
#include "fusionhandle.h"

// deliberately no surrounding parens or trailing comma
#define STRING_AND_LENGTH(x) (x), (NUMBER_OF(x) - 1)

#define MAXIMUM_PROCESSOR_ARCHITECTURE_NAME_LENGTH (sizeof("amd64") - 1)

const static struct
{
    USHORT ProcessorArchitecture;
    WCHAR  String[MAXIMUM_PROCESSOR_ARCHITECTURE_NAME_LENGTH+1];
    SIZE_T Cch;
} gs_rgPAMap[] =
{
    { PROCESSOR_ARCHITECTURE_INTEL, STRING_AND_LENGTH(L"x86") },
    { PROCESSOR_ARCHITECTURE_AMD64, STRING_AND_LENGTH(L"AMD64") },
    { PROCESSOR_ARCHITECTURE_IA64, STRING_AND_LENGTH(L"IA64") },
    { PROCESSOR_ARCHITECTURE_SHX, STRING_AND_LENGTH(L"SHX") },
    { PROCESSOR_ARCHITECTURE_ARM, STRING_AND_LENGTH(L"ARM") },
    { PROCESSOR_ARCHITECTURE_MSIL, STRING_AND_LENGTH(L"MSIL") },
    { PROCESSOR_ARCHITECTURE_IA32_ON_WIN64, STRING_AND_LENGTH(L"WOW64") },
    { PROCESSOR_ARCHITECTURE_UNKNOWN, STRING_AND_LENGTH(L"Data") },
};

//
// ISSUE: jonwis 3/12/2002 - Calling GetLocaleInfoW three times can't be cheap.  Apparently
//          GLIW will only tell you how long the buffer should be if you pass zero as the
//          cch parameter, which is disappointing.  Of course, we want to speed up the
//          success case, but I'm concerned that we'll more-often-than-not hit the failure,
//          call, allocate, call pattern.
//
static BOOL
FusionpGetLocaleInfo(
    LANGID LangID,
    CBaseStringBuffer *Buffer,
    LCTYPE lcType,
    SIZE_T *CchWritten = NULL
    )
{
    LCID locale = MAKELCID(LangID, SORT_DEFAULT);

    CStringBufferAccessor BufferAccessor;

    BufferAccessor.Attach(Buffer);

    INT i = GetLocaleInfoW(locale, lcType, BufferAccessor.GetBufferPtr(),  static_cast<INT>(BufferAccessor.GetBufferCch()));
    if (i != 0)
    {
        goto Exit;
    }
    if (::FusionpGetLastWin32Error() != ERROR_INSUFFICIENT_BUFFER)
    {
        goto Exit;
    }
    i =  GetLocaleInfoW(locale, lcType, NULL, 0);
    if (i == 0)
    {
        goto Exit;
    }
    if (!Buffer->Win32ResizeBuffer(i, eDoNotPreserveBufferContents))
    {
        i = 0;
        goto Exit;
    }
    i = GetLocaleInfoW(locale, lcType, BufferAccessor.GetBufferPtr(),  static_cast<INT>(BufferAccessor.GetBufferCch()));
Exit:
    if (i != 0 && CchWritten != NULL)
    {
        *CchWritten = i;
    }
    return TRUE;
}

BOOL
FusionpFormatEnglishLanguageName(
    LANGID LangID,
    CBaseStringBuffer *Buffer,
    SIZE_T *CchWritten
    )
{
    return ::FusionpGetLocaleInfo(LangID, Buffer, LOCALE_SENGLANGUAGE, CchWritten);
}

BOOL
FusionpParseProcessorArchitecture(
    PCWSTR String,
    SIZE_T Cch,
    USHORT *ProcessorArchitecture,
    bool &rfValid
    )
{
    ULONG i;
    BOOL fSuccess = FALSE;

    rfValid = false;

    // We'll let ProcessorArchitecture be NULL if the caller just wants to
    // test whether there is a match.

    for (i=0; i<NUMBER_OF(gs_rgPAMap); i++)
    {
        if (::FusionpCompareStrings(
                gs_rgPAMap[i].String,
                gs_rgPAMap[i].Cch,
                String,
                Cch,
                true) == 0)
        {
            if (ProcessorArchitecture != NULL)
                *ProcessorArchitecture = gs_rgPAMap[i].ProcessorArchitecture;

            break;
        }
    }

    if (i != NUMBER_OF(gs_rgPAMap))
        rfValid = true;

    fSuccess = TRUE;

// Exit:
    return fSuccess;
}


BOOL
FusionpFormatProcessorArchitecture(
    USHORT ProcessorArchitecture,
    CBaseStringBuffer &rBuffer
    )
{
    FN_PROLOG_WIN32;
    ULONG i;

    rBuffer.Clear();

    for (i=0; i<NUMBER_OF(gs_rgPAMap); i++)
    {
        if (gs_rgPAMap[i].ProcessorArchitecture == ProcessorArchitecture)
            break;
    }

    PARAMETER_CHECK(i != NUMBER_OF(gs_rgPAMap));

    IFW32FALSE_EXIT(rBuffer.Win32Assign(gs_rgPAMap[i].String, gs_rgPAMap[i].Cch));

    FN_EPILOG;
}

DWORD
FusionpHRESULTToWin32(
    HRESULT hr
    )
{
    DWORD dwWin32ErrorCode = ERROR_INTERNAL_ERROR;

    if ((HRESULT_FACILITY(hr) != FACILITY_WIN32) &&
        (FAILED(hr)))
    {
        switch (hr)
        {
        default:
            break;
#define X(x,y) case x: hr = HRESULT_FROM_WIN32(y); break;

        X(E_UNEXPECTED, ERROR_INTERNAL_ERROR)
        X(E_FAIL, ERROR_FUNCTION_FAILED)

        X(STG_E_PATHNOTFOUND, ERROR_PATH_NOT_FOUND)
        X(STG_E_FILENOTFOUND, ERROR_FILE_NOT_FOUND)
        X(STG_E_ACCESSDENIED, ERROR_ACCESS_DENIED)
        X(STG_E_INVALIDHANDLE, ERROR_INVALID_HANDLE)
        X(STG_E_INSUFFICIENTMEMORY, ERROR_NOT_ENOUGH_MEMORY) // or ERROR_OUTOFMEMORY
        X(STG_E_TOOMANYOPENFILES, ERROR_TOO_MANY_OPEN_FILES)
        X(STG_E_NOMOREFILES, ERROR_NO_MORE_FILES)
        X(STG_E_WRITEFAULT, ERROR_WRITE_FAULT)
        X(STG_E_READFAULT, ERROR_READ_FAULT)
        X(STG_E_SHAREVIOLATION, ERROR_SHARING_VIOLATION)
        X(STG_E_LOCKVIOLATION, ERROR_LOCK_VIOLATION)
        X(STG_E_INVALIDPARAMETER, ERROR_INVALID_PARAMETER)
        X(STG_E_MEDIUMFULL, ERROR_DISK_FULL) // or ERROR_HANDLE_DISK_FULL
        // There's more, but I doubt we really need most of this.
#undef X
        }
    }
    if ((HRESULT_FACILITY(hr) == FACILITY_WIN32) &&
        (FAILED(hr)))
    {
        dwWin32ErrorCode = HRESULT_CODE(hr);

        if (FAILED(hr) && (dwWin32ErrorCode == ERROR_SUCCESS))
        {
            dwWin32ErrorCode = ERROR_INTERNAL_ERROR;
        }
    }
    else
    {
#if DBG        
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SXS.DLL: " __FUNCTION__ " HRESULT 0x%08x - facility is not Win32; setting to ERROR_SXS_UNTRANSLATABLE_HRESULT\n",
            hr);
#endif
        dwWin32ErrorCode = ERROR_SXS_UNTRANSLATABLE_HRESULT;
    }

    return dwWin32ErrorCode;
}

VOID
FusionpSetLastErrorFromHRESULT(
    HRESULT hr
    )
{
    ::SetLastError(::FusionpHRESULTToWin32(hr));
}

VOID
FusionpConvertCOMFailure(HRESULT & __hr)
{
/*
    XML_E_PARSEERRORBASE = 0xC00CE500L,

    // character level error codes.
    XML_E_ENDOFINPUT            = XML_E_PARSEERRORBASE,
    XML_E_MISSINGEQUALS,            // 1
    XML_E_MISSINGQUOTE,             // 2
    XML_E_COMMENTSYNTAX,            // 3
    XML_E_BADSTARTNAMECHAR,         // 4
    XML_E_BADNAMECHAR,              // 5
    XML_E_BADCHARINSTRING,          // 6
                                    // under 256
*/
    if ((__hr & XML_E_PARSEERRORBASE) == XML_E_PARSEERRORBASE)
    {
        //
        // for normal XML ERROR,we convert hresult to a better-understanding hresult
        // xiaoyuw@01/08/2001
        //
#define MAP_XML_HRESULT(x) case(x) : dwWin32Error = ERROR_SXS_## x; break
        DWORD dwWin32Error;

        switch (__hr)
        {
            MAP_XML_HRESULT(XML_E_MISSINGEQUALS);
            MAP_XML_HRESULT(XML_E_MISSINGQUOTE);
            MAP_XML_HRESULT(XML_E_COMMENTSYNTAX);
            MAP_XML_HRESULT(XML_E_BADSTARTNAMECHAR);
            MAP_XML_HRESULT(XML_E_BADNAMECHAR);
            MAP_XML_HRESULT(XML_E_BADCHARINSTRING);
            MAP_XML_HRESULT(XML_E_XMLDECLSYNTAX);
            MAP_XML_HRESULT(XML_E_BADCHARDATA);
            MAP_XML_HRESULT(XML_E_MISSINGWHITESPACE);
            MAP_XML_HRESULT(XML_E_EXPECTINGTAGEND);
            MAP_XML_HRESULT(XML_E_MISSINGSEMICOLON);
            MAP_XML_HRESULT(XML_E_UNBALANCEDPAREN);
            MAP_XML_HRESULT(XML_E_INTERNALERROR);
            MAP_XML_HRESULT(XML_E_UNEXPECTED_WHITESPACE);
            MAP_XML_HRESULT(XML_E_INCOMPLETE_ENCODING);
            MAP_XML_HRESULT(XML_E_MISSING_PAREN);
            MAP_XML_HRESULT(XML_E_EXPECTINGCLOSEQUOTE);
            MAP_XML_HRESULT(XML_E_MULTIPLE_COLONS);
            MAP_XML_HRESULT(XML_E_INVALID_DECIMAL);
            MAP_XML_HRESULT(XML_E_INVALID_HEXIDECIMAL);
            MAP_XML_HRESULT(XML_E_INVALID_UNICODE);
            MAP_XML_HRESULT(XML_E_WHITESPACEORQUESTIONMARK);
            MAP_XML_HRESULT(XML_E_UNEXPECTEDENDTAG);
            MAP_XML_HRESULT(XML_E_UNCLOSEDTAG);
            MAP_XML_HRESULT(XML_E_DUPLICATEATTRIBUTE);
            MAP_XML_HRESULT(XML_E_MULTIPLEROOTS);
            MAP_XML_HRESULT(XML_E_INVALIDATROOTLEVEL);
            MAP_XML_HRESULT(XML_E_BADXMLDECL);
            MAP_XML_HRESULT(XML_E_MISSINGROOT);
            MAP_XML_HRESULT(XML_E_UNEXPECTEDEOF);
            MAP_XML_HRESULT(XML_E_BADPEREFINSUBSET);
            MAP_XML_HRESULT(XML_E_UNCLOSEDSTARTTAG);
            MAP_XML_HRESULT(XML_E_UNCLOSEDENDTAG);
            MAP_XML_HRESULT(XML_E_UNCLOSEDSTRING);
            MAP_XML_HRESULT(XML_E_UNCLOSEDCOMMENT);
            MAP_XML_HRESULT(XML_E_UNCLOSEDDECL);
            MAP_XML_HRESULT(XML_E_UNCLOSEDCDATA);
            MAP_XML_HRESULT(XML_E_RESERVEDNAMESPACE);
            MAP_XML_HRESULT(XML_E_INVALIDENCODING);
            MAP_XML_HRESULT(XML_E_INVALIDSWITCH);
            MAP_XML_HRESULT(XML_E_BADXMLCASE);
            MAP_XML_HRESULT(XML_E_INVALID_STANDALONE);
            MAP_XML_HRESULT(XML_E_UNEXPECTED_STANDALONE);
            MAP_XML_HRESULT(XML_E_INVALID_VERSION);
            default:
                dwWin32Error=(ERROR_SXS_MANIFEST_PARSE_ERROR);
            break;
        } // end of switch
        __hr = HRESULT_FROM_WIN32(dwWin32Error);
    } //end of if
    return;
}

BOOL
FusionpGetActivationContextFromFindResult(
    PCACTCTX_SECTION_KEYED_DATA askd,
    HANDLE * phActCtx
    )
{
    FN_PROLOG_WIN32;
    HANDLE hActCtx = NULL;

    if (phActCtx != NULL)
        *phActCtx = NULL;
    PARAMETER_CHECK(askd != NULL);
    PARAMETER_CHECK(phActCtx != NULL);
    PARAMETER_CHECK(RTL_CONTAINS_FIELD(askd, askd->cbSize, hActCtx));
    PARAMETER_CHECK(RTL_CONTAINS_FIELD(askd, askd->cbSize, ulFlags));

    hActCtx = askd->hActCtx;
    if (hActCtx == ACTCTX_PROCESS_DEFAULT)
    {
        switch (askd->ulFlags
            & (
                ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_PROCESS_DEFAULT
                | ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_SYSTEM_DEFAULT
                ))
        {
        case ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_PROCESS_DEFAULT:
            break;
        case ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_SYSTEM_DEFAULT:
            hActCtx = ACTCTX_SYSTEM_DEFAULT;
            break;
        default:
            TRACE_PARAMETER_CHECK(askd->ulFlags);
            break;
        }
    }
    *phActCtx = hActCtx;
    FN_EPILOG;
}

BOOL
FusionpSearchPath(
    ULONG               ulFusionFlags,
    LPCWSTR             lpPath,
    LPCWSTR             lpFileName,         // file name
    LPCWSTR             lpExtension,        // file extension
    CBaseStringBuffer & StringBuffer,
    SIZE_T *            lpFilePartOffset,   // file component
    HANDLE              hActCtx
)
{
    FN_PROLOG_WIN32;
    ULONG_PTR ulActCookie = 0;
    PWSTR lpFilePart = NULL;
    CFusionActCtxScope ActCtxScope;

    if (lpFilePartOffset != NULL)
        *lpFilePartOffset = 0;

    StringBuffer.Clear();
    PARAMETER_CHECK((ulFusionFlags & ~(FUSIONP_SEARCH_PATH_ACTCTX)) == 0);

    if ((ulFusionFlags & FUSIONP_SEARCH_PATH_ACTCTX) != 0)
    {
        IFW32FALSE_EXIT(ActCtxScope.Win32Activate(hActCtx));
    }
    if (StringBuffer.GetBufferCch() == 0)
        IFW32FALSE_EXIT(StringBuffer.Win32ResizeBuffer(MAX_PATH, eDoNotPreserveBufferContents));
    for (;;)
    {
        DWORD dw = 0;
        {
            CStringBufferAccessor StringBufferAccessor(&StringBuffer);
        
            IFW32FALSE_EXIT((dw = ::SearchPathW(
                lpPath,
                lpFileName,
                lpExtension,
                StringBufferAccessor.GetBufferCchAsDWORD(),
                StringBufferAccessor,
                &lpFilePart
                )) != 0);
            if (dw < StringBuffer.GetBufferCch())
            {
                // lpFilePart equals NULL if filename ends in a slash, or somesuch..
                if (lpFilePartOffset != NULL && lpFilePart != NULL)
                {
                    *lpFilePartOffset = (lpFilePart - static_cast<PWSTR>(StringBufferAccessor));
                }
                break;
            }
        }
        IFW32FALSE_EXIT(StringBuffer.Win32ResizeBuffer(dw + 1, eDoNotPreserveBufferContents));
    }

    FN_EPILOG;
}

BOOL
FusionpGetModuleFileName(
    ULONG               ulFusionFlags,
    HMODULE             hmodDll,
    CBaseStringBuffer & StringBuffer
    )
/* note that GetModuleFileName is an unusual truncating API,
   that's why we fudge the buffer size
   if GetModuleFileName returns buffersize - 1, it may be a truncated result
 */
{
    FN_PROLOG_WIN32;

    StringBuffer.Clear();
    PARAMETER_CHECK(ulFusionFlags == 0);

    if (StringBuffer.GetBufferCch() < 2)
        IFW32FALSE_EXIT(StringBuffer.Win32ResizeBuffer(MAX_PATH, eDoNotPreserveBufferContents));
    for (;;)
    {
        DWORD dw = 0;
        {
            CStringBufferAccessor StringBufferAccessor(&StringBuffer);
        
            IFW32FALSE_EXIT((dw = ::GetModuleFileNameW(
                hmodDll,
                StringBufferAccessor,
                StringBufferAccessor.GetBufferCchAsDWORD()
                )) != 0);
            if (dw < (StringBuffer.GetBufferCch() - 1))
            {
                break;
            }
        }
        /* we don't know what to grow to, so grow by a slightly big chunk */
        IFW32FALSE_EXIT(StringBuffer.Win32ResizeBuffer(dw + 64, eDoNotPreserveBufferContents));
    }

    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\getvolumepathnamesforvolumename.c ===
#include "windows.h"

#if defined(__cplusplus)
extern "C"
{
#endif

typedef
BOOL 
(WINAPI *
PFN_GET_VOLUME_PATHNAMES_FOR_VOLUME_NAME_A)(
    LPCSTR lpszVolumeName,
    LPSTR lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    );

typedef
BOOL 
(WINAPI *
PFN_GET_VOLUME_PATHNAMES_FOR_VOLUME_NAME_W)(
    LPCWSTR lpszVolumeName,
    LPWSTR lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    );

typedef
BOOL 
(WINAPI *
PFN_GET_VOLUME_PATHNAMES_FOR_VOLUME_NAME_VOID)(
    const void * lpszVolumeName,
    void * lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    );

BOOL 
WINAPI
FusionpGetVolumePathNamesForVolumeNameGeneric(
    const void * lpszVolumeName,
    void * lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength,

    const char *                                    Name,
    PFN_GET_VOLUME_PATHNAMES_FOR_VOLUME_NAME_VOID * FunctionPointer,
    DWORD *                                         Error
    )
{
    DWORD LocalError;
    PFN_GET_VOLUME_PATHNAMES_FOR_VOLUME_NAME_VOID LocalFunctionPointer;

    if ((LocalError = *Error) != NO_ERROR)
    {
        SetLastError(LocalError);
        return FALSE;
    }

    if (*FunctionPointer == NULL)
    {
        HMODULE Kernel32 = LoadLibraryW(L"Kernel32.dll");
        if (Kernel32 == NULL)
        {
            if ((*Error = GetLastError()) == NO_ERROR)
                *Error = ERROR_PROC_NOT_FOUND;
            return FALSE;
        }
        LocalFunctionPointer = *FunctionPointer = (PFN_GET_VOLUME_PATHNAMES_FOR_VOLUME_NAME_VOID)GetProcAddress(Kernel32, Name);
        if (LocalFunctionPointer == NULL)
        {
            if ((*Error = GetLastError()) == NO_ERROR)
                *Error = ERROR_PROC_NOT_FOUND;
            return FALSE;
        }
    }
    return (**FunctionPointer)(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
}

BOOL 
WINAPI
FusionpGetVolumePathNamesForVolumeNameA(
    LPCSTR lpszVolumeName,
    LPSTR lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    )
{
    static PFN_GET_VOLUME_PATHNAMES_FOR_VOLUME_NAME_VOID FunctionPointer;
    static DWORD Error;

    return FusionpGetVolumePathNamesForVolumeNameGeneric(
        lpszVolumeName,
        lpszVolumePathNames,
        cchBufferLength,
        lpcchReturnLength,

        "FusionpGetVolumePathNamesForVolumeNameA",
        &FunctionPointer,
        &Error
        );
}

BOOL 
WINAPI
FusionpGetVolumePathNamesForVolumeNameW(
    LPCWSTR lpszVolumeName,
    LPWSTR lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    )
{
    static PFN_GET_VOLUME_PATHNAMES_FOR_VOLUME_NAME_VOID FunctionPointer;
    static DWORD Error;

    return FusionpGetVolumePathNamesForVolumeNameGeneric(
        lpszVolumeName,
        lpszVolumePathNames,
        cchBufferLength,
        lpcchReturnLength,

        "FusionpGetVolumePathNamesForVolumeNameW",
        &FunctionPointer,
        &Error
        );
}

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\io.cpp ===
#include "stdinc.h"
#include "FusionBuffer.h"
#include "Util.h"
#include "FusionHandle.h"

#define SXSP_MOVE_FILE_FLAG_COMPRESSION_AWARE 1

BOOL
SxspDoesFileExist(
    DWORD dwFlags,
    PCWSTR pszFileName,
    bool &rfExists
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    const bool fCheckFileOnly = ((dwFlags & SXSP_DOES_FILE_EXIST_FLAG_CHECK_FILE_ONLY) != 0);
    const bool fCheckDirectoryOnly = ((dwFlags & SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY) != 0);
    DWORD dwFileOrDirectoryExists = 0;
    DWORD dwFlags2 = 0;

    if (&rfExists != NULL)
    {
        rfExists = false;
    }
    PARAMETER_CHECK(pszFileName != NULL);
    PARAMETER_CHECK(&rfExists != NULL);
    PARAMETER_CHECK((dwFlags & ~(SXSP_DOES_FILE_EXIST_FLAG_COMPRESSION_AWARE | SXSP_DOES_FILE_EXIST_FLAG_INCLUDE_NETWORK_ERRORS | SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY | SXSP_DOES_FILE_EXIST_FLAG_CHECK_FILE_ONLY)) == 0);
    //
    // one or neither of these can be set, but not both
    //
    PARAMETER_CHECK(!(fCheckFileOnly && fCheckDirectoryOnly));

    if ((dwFlags & SXSP_DOES_FILE_EXIST_FLAG_COMPRESSION_AWARE) != 0)
        dwFlags2 |= SXSP_DOES_FILE_OR_DIRECTORY_EXIST_FLAG_COMPRESSION_AWARE;
    if ((dwFlags & SXSP_DOES_FILE_EXIST_FLAG_INCLUDE_NETWORK_ERRORS) != 0)
        dwFlags2 |= SXSP_DOES_FILE_OR_DIRECTORY_EXIST_FLAG_INCLUDE_NETWORK_ERRORS;
        
    IFW32FALSE_EXIT(SxspDoesFileOrDirectoryExist(dwFlags2, pszFileName, dwFileOrDirectoryExists));

    if (fCheckFileOnly)
    {
        rfExists = (dwFileOrDirectoryExists == SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_FILE_EXISTS);
    }
    else if (fCheckDirectoryOnly)
    {
        rfExists = (dwFileOrDirectoryExists == SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_DIRECTORY_EXISTS);
    }
    else
    {
        rfExists = (dwFileOrDirectoryExists != SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_NEITHER_EXISTS);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspDoesFileOrDirectoryExist(
    DWORD dwFlags,
    PCWSTR pszFileName,
    OUT DWORD &rdwDisposition
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PWSTR pszActualSource = NULL;
    DWORD dwFileOrDirectoryExists = 0;

    if (&rdwDisposition != NULL)
    {
        rdwDisposition = SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_NEITHER_EXISTS;
    }
    PARAMETER_CHECK(&rdwDisposition != NULL);
    PARAMETER_CHECK(pszFileName != NULL);
    PARAMETER_CHECK((dwFlags & ~(SXSP_DOES_FILE_OR_DIRECTORY_EXIST_FLAG_COMPRESSION_AWARE | SXSP_DOES_FILE_OR_DIRECTORY_EXIST_FLAG_INCLUDE_NETWORK_ERRORS)) == 0);

    if (dwFlags & SXSP_DOES_FILE_OR_DIRECTORY_EXIST_FLAG_COMPRESSION_AWARE)
    {
        DWORD dwTemp = 0;
        DWORD dwSourceFileSize = 0;
        DWORD dwTargetFileSize = 0;
        UINT uiCompressionType = 0;

        dwTemp = ::SetupGetFileCompressionInfoW(
            pszFileName,
            &pszActualSource,
            &dwSourceFileSize,
            &dwTargetFileSize,
            &uiCompressionType);

        if (pszActualSource != NULL)
        {
            ::LocalFree((HLOCAL) pszActualSource);
            pszActualSource = NULL;
        }
        //
        // don't care about ERROR_PATH_NOT_FOUND or network errors here?
        //
        if (dwTemp == ERROR_FILE_NOT_FOUND)
        {
            // This case is OK.  No error to return...
        }
        else if (dwTemp != ERROR_SUCCESS)
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(SetupGetFileCompressionInfoW, dwTemp);
        }
        else
        {
            rdwDisposition = SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_FILE_EXISTS;
        }
    }
    else
    {
        const DWORD dwAttribute = ::GetFileAttributesW(pszFileName);
        if (dwAttribute == INVALID_FILE_ATTRIBUTES)
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();
            const bool fUseNetwork = ((dwFlags & SXSP_DOES_FILE_OR_DIRECTORY_EXIST_FLAG_INCLUDE_NETWORK_ERRORS) != 0);

            //
            // Apologies for the wierd logic, but this was simpler to write.
            //
            if ((dwLastError == ERROR_SUCCESS) ||
                (dwLastError == ERROR_FILE_NOT_FOUND) ||
                (dwLastError == ERROR_PATH_NOT_FOUND) ||
                (fUseNetwork && (dwLastError == ERROR_BAD_NETPATH)) ||
                (fUseNetwork && (dwLastError == ERROR_BAD_NET_NAME)))
            {
                //
                // ok, do nothing
                //
            }
            else
            {
                ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFileAttributesW, dwLastError);
            }
        }
        else
        {           
            if ((dwAttribute & FILE_ATTRIBUTE_DIRECTORY) != 0)
            {
                rdwDisposition = SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_DIRECTORY_EXISTS;
            }
            else
            {
                rdwDisposition = SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_FILE_EXISTS;
            }
        }
    }

    fSuccess = TRUE;
Exit:
    if (pszActualSource != NULL)
    {
        CSxsPreserveLastError ple;
        ::LocalFree((HLOCAL) pszActualSource);
        ple.Restore();
    }

    return fSuccess;
}

// NTRAID#NTBUG9 - 589828 - 2002/03/26 - xiaoyuw:
// the current implementation assumes that the input path always begins with "c:\" or "\\machinename"
// So if we want to support path beginning with "\\?\", more code need added....
BOOL
FusionpCreateDirectories(
    PCWSTR pszDirectory,
    SIZE_T cchDirectory
    )
/*-----------------------------------------------------------------------------
like ::CreateDirectoryW, but will create the parent directories as needed;
origin of this code
\\lang5\V5.PRO\src\ide5\shell\path.cpp ("MakeDirectory")
\\kingbird\vseedev\src\vsee98\vsee\pkgs\scc\path.cpp ("MakeDirectory")
then ported to \\kingbird\vseedev\src\vsee70\pkgs\scc\path.cpp ("MakeDirectory")
then moved to \vsee\lib\io\io.cpp, converted to use exceptions ("NVseeLibIo::FCreateDirectories")
then copied to fusion\dll\whistler\util.cpp, exceptions converted to BOOL/LastError ("SxspCreateDirectories")
-----------------------------------------------------------------------------*/
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    CStringBuffer strBuffer;
    DWORD dwAttribs = 0;

    PARAMETER_CHECK(pszDirectory != NULL);
    PARAMETER_CHECK(cchDirectory != 0);

    IFW32FALSE_EXIT(strBuffer.Win32Assign(pszDirectory, cchDirectory));

    //::CreateDirectoryW will do the wrong thing if strBuffer has a trailing slash,
    //so we'll strip it off if it's there. (see bug VS7:31319) [MSantoro]
    IFW32FALSE_EXIT(strBuffer.Win32RemoveTrailingPathSeparators());

    // cover the two common cases of its parent exists or it exists
    if ((!::CreateDirectoryW(strBuffer, NULL)) && (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS))
    {
        CStringBufferAccessor sbaBuffer;

        // now the slow path

        //
        // Try to create the subdirectories (if any) named in the path.
        //

        sbaBuffer.Attach(&strBuffer);

        WCHAR* pStart = sbaBuffer.GetBufferPtr();
        WCHAR* pCurr = pStart;

        // skip the leading drive or \\computer\share
        // this way we don't try to create C: in trying to create C:\
        // or \\computer\share in trying to create \\computer\share\dir
        // FUTURE This is not ideal.. (need NVseeLibPath)
        if (pCurr[0] != 0)
        {
            const static WCHAR rgchAZaz[] = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            C_ASSERT(NUMBER_OF(rgchAZaz) == 53);
            if ((pCurr[1] == L':') &&
                CUnicodeCharTraits::IsPathSeparator(pCurr[2]) &&
                (wcschr(rgchAZaz, pCurr[0]) != NULL))
            {
                pCurr += 3;
            }
            else if (CUnicodeCharTraits::IsPathSeparator(pCurr[0]) &&
                     CUnicodeCharTraits::IsPathSeparator(pCurr[1]))
            {
                // skip to after the share, since we presumably can't create shares with CreateDirectory
                pCurr +=  wcsspn(pCurr, CUnicodeCharTraits::PathSeparators()); // skip leading two slashes
                pCurr += wcscspn(pCurr, CUnicodeCharTraits::PathSeparators()); // skip computer name
                pCurr +=  wcsspn(pCurr, CUnicodeCharTraits::PathSeparators()); // skip slashes after computer name
                pCurr += wcscspn(pCurr, CUnicodeCharTraits::PathSeparators()); // skip share name
                pCurr +=  wcsspn(pCurr, CUnicodeCharTraits::PathSeparators()); // skip slashes after share name
            }
        }

        while (*pCurr != L'\0')
        {
            pCurr += wcscspn(pCurr, CUnicodeCharTraits::PathSeparators()); // skip to next slash
            if (*pCurr != 0)
            {
                // [a-JayK, JayKrell April 2000] Why not just assume it's a backslash?
                WCHAR chSaved = *pCurr;
                *pCurr = 0;
                if (!::CreateDirectoryW(pStart, NULL))
                {
                    // In trying to create c:\foo\bar,
                    // we try to create c:\foo, which fails, but is ok.
                    const DWORD dwLastError = ::FusionpGetLastWin32Error();
                    bool fExist;
                    IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY, pStart, fExist));
                    if (!fExist)
                    {
                        ::SetLastError(ERROR_PATH_NOT_FOUND);
                        goto Exit;
                    }
                }

            *pCurr = chSaved;
            pCurr += 1;
            }
        }

        IFW32FALSE_ORIGINATE_AND_EXIT(::CreateDirectoryW(pStart, NULL));
    }

    //
    // Try again to see if the given directory exists and
    // return true if successful.
    //

    bool fExist;
    IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY, strBuffer, fExist));
    if (!fExist)
    {
        ::SetLastError(ERROR_PATH_NOT_FOUND);
        goto Exit;
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

VOID
CFusionDirectoryDifference::DbgPrint(
    PCWSTR dir1,
    PCWSTR dir2
    )
{
#if DBG // { {
    switch (m_e)
    {
    case eEqual:
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: The directories %ls and %ls match size-wise recursively\n",
            dir1,
            dir2);
        break;
    case eExtraOrMissingFile:
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: The directories %ls and %ls mismatch, the file %ls is only in one of them.\n",
            dir1,
            dir2,
            static_cast<PCWSTR>(*m_pstrExtraOrMissingFile));
        break;
    case eMismatchedFileSize:
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: The directories %ls and %ls mismatch, file:%ls, size:%I64d, file:%ls, size:%I64d.\n",
            dir1,
            dir2,
            static_cast<PCWSTR>(*m_pstrMismatchedSizeFile1),
            m_nMismatchedFileSize1,
            static_cast<PCWSTR>(*m_pstrMismatchedSizeFile2),
            m_nMismatchedFileSize2);
        break;
    case eMismatchedFileCount:
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: The directories %ls and %ls mismatch in number of files,"
            "subdirectory %ls has %I64d files, subdirectory %ls has %I64d files\n",
            dir1,
            dir2,
            static_cast<PCWSTR>(*m_pstrMismatchedCountDir1),
            m_nMismatchedFileCount1,
            static_cast<PCWSTR>(*m_pstrMismatchedCountDir2),
            m_nMismatchedFileCount2);
        break;
    case eFileDirectoryMismatch:
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: The directories %ls and %ls mismatch, "
            "%ls is a file, %ls is a directory.\n",
            dir1,
            dir2,
            static_cast<PCWSTR>(*m_pstrFile),
            static_cast<PCWSTR>(*m_pstrDirectory));
        break;
    }
#endif // } }
}

/*-----------------------------------------------------------------------------*/
// NTRAID#NTBUG9 - 589828 - 2002/03/26 - xiaoyuw:
// if an input path containing both "\" and "/", the implementation would take it as 
// a valid path; 
int __cdecl
CFusionFilePathAndSize::QsortComparePath(
    const void* pvx,
    const void* pvy
    )
{
    const CFusionFilePathAndSize* px = reinterpret_cast<const CFusionFilePathAndSize*>(pvx);
    const CFusionFilePathAndSize* py = reinterpret_cast<const CFusionFilePathAndSize*>(pvy);
    int i =
        ::FusionpCompareStrings(
            px->m_path,
            px->m_path.Cch(),
            py->m_path,
            py->m_path.Cch(),
            TRUE);
    return i;
}

int __cdecl
CFusionFilePathAndSize::QsortIndirectComparePath(
    const void* ppvx,
    const void* ppvy
    )
{
    const void* pv = *reinterpret_cast<void const* const*>(ppvx);
    const void* py = *reinterpret_cast<void const* const*>(ppvy);
    int i = QsortComparePath(pv, py);
    return i;
}

/*-----------------------------------------------------------------------------
See FusionpCompareDirectoriesSizewiseRecursively for what this does;
this function exists to reduce the stack usage of
FusionpCompareDirectoriesSizewiseRecursively.
-----------------------------------------------------------------------------*/
static BOOL
FusionpCompareDirectoriesSizewiseRecursivelyHelper(
    CFusionDirectoryDifference *pResult,
    CBaseStringBuffer &rdir1,
    CBaseStringBuffer &rdir2,
    WIN32_FIND_DATAW &rwfd
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

// either or both directories can be on FAT, we can't assume that FindFirstFile
// returns entries in any particular order, so we first enumerate one directory
// entirely, storing the leaf names in an array, sort the array, then
// walk the second directory doing a binary search in the first array
// if the file is not in the array, we have an extra on one side
// we count the elements in both directories, if the counts don't match,
// we have a mismatch
    typedef CFusionArray<CFusionFilePathAndSize> CDirEntries;
    CDirEntries dir1Entries;
    typedef CFusionArray<CFusionFilePathAndSize*> CIndirectDirEntries;
    CIndirectDirEntries indirectDir1Entries;
    CFusionFilePathAndSize*   pFoundDirEntry = NULL;
    CFusionFilePathAndSize** ppFoundDirEntry = NULL;
    CFindFile findFile;
    const SIZE_T dirSlash1Length = rdir1.Cch();
    const SIZE_T dirSlash2Length = rdir2.Cch();
    CFusionFilePathAndSize  pathAndSize;
    CFusionFilePathAndSize* pPathAndSize = &pathAndSize;
    INT count1 = 0; // seperate from the array, because this includes directories, and the array does not
    INT count2 = 0;
    DWORD dwAttributes = 0;

    IFW32FALSE_EXIT(rdir1.Win32Append(L"*", 1));
    IFW32FALSE_EXIT(findFile.Win32FindFirstFile(rdir1, &rwfd));

    do
    {
        if (FusionpIsDotOrDotDot(rwfd.cFileName))
            continue;

        ++count1;
        if ((rwfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
        {
            rdir1.Left(dirSlash1Length);
            rdir2.Left(dirSlash2Length);
            IFW32FALSE_EXIT(rdir1.Win32Append(rwfd.cFileName, ::wcslen(rwfd.cFileName)));
            IFW32FALSE_EXIT(rdir1.Win32EnsureTrailingPathSeparator());
            IFW32FALSE_EXIT(rdir2.Win32Append(rwfd.cFileName, ::wcslen(rwfd.cFileName)));

            bool fExist;
            IFW32FALSE_EXIT(SxspDoesFileExist(0, rdir2, fExist));
            if (!fExist)
            {
                IFW32FALSE_EXIT(pResult->m_str1.Win32Assign(rdir1, dirSlash1Length));
                IFW32FALSE_EXIT(pResult->m_str1.Win32Append(rwfd.cFileName, ::wcslen(rwfd.cFileName)));
                pResult->m_e = CFusionDirectoryDifference::eExtraOrMissingFile;
                fSuccess = TRUE;
                goto Exit;
            }

            IFW32FALSE_EXIT(SxspGetFileAttributesW(rdir2, dwAttributes));
            if ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                SIZE_T cchTemp = ::wcslen(rwfd.cFileName);
                IFW32FALSE_EXIT(pResult->m_pstrDirectory->Win32Assign(rdir1, dirSlash1Length));
                IFW32FALSE_EXIT(pResult->m_pstrDirectory->Win32Append(rwfd.cFileName, cchTemp));
                IFW32FALSE_EXIT(pResult->m_pstrFile->Win32Assign(rdir2, dirSlash2Length));
                IFW32FALSE_EXIT(pResult->m_pstrFile->Win32Append(rwfd.cFileName, cchTemp));
                pResult->m_e = CFusionDirectoryDifference::eFileDirectoryMismatch;
                fSuccess = TRUE;
                goto Exit;
            }

            IFW32FALSE_EXIT(rdir2.Win32EnsureTrailingPathSeparator());

            IFW32FALSE_EXIT(
                ::FusionpCompareDirectoriesSizewiseRecursivelyHelper(
                    pResult,
                    rdir1,
                    rdir2,
                    rwfd));

            if (pResult->m_e != CFusionDirectoryDifference::eEqual)
            {
                fSuccess = TRUE;
                goto Exit;
            }
        }
        else
        {
            IFW32FALSE_EXIT(pathAndSize.m_path.Win32Assign(rwfd.cFileName, ::wcslen(rwfd.cFileName)));
            pathAndSize.m_size = ::FusionpFileSizeFromFindData(rwfd);
            IFW32FALSE_EXIT(dir1Entries.Win32Append(pathAndSize));
        }
    } while (FindNextFileW(findFile, &rwfd));

    if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
    {
        goto Exit;
    }

    // dir1Entries cannot be sorted directly because it contains CStringBuffers.
    // first initialize the index to be an identity
    IFW32FALSE_EXIT(indirectDir1Entries.Win32SetSize(dir1Entries.GetSize()));

    ULONG i;
    for (i = 0 ; i != dir1Entries.GetSize() ; ++i)
    {
        indirectDir1Entries[i] = &dir1Entries[i];
    }

    qsort(
        &*indirectDir1Entries.Begin(),
        indirectDir1Entries.GetSize(),
        sizeof(CIndirectDirEntries::ValueType),
        CFusionFilePathAndSize::QsortIndirectComparePath);

    IFW32FALSE_EXIT(findFile.Win32Close());

    rdir2.Left(dirSlash2Length);

    IFW32FALSE_EXIT(rdir2.Win32Append(L"*", 1));

    IFW32FALSE_EXIT(findFile.Win32FindFirstFile(rdir2, &rwfd));

    do
    {
        if (::FusionpIsDotOrDotDot(rwfd.cFileName))
            continue;

        ++count2;
        if ((rwfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
            continue;

        IFW32FALSE_EXIT(pathAndSize.m_path.Win32Assign(rwfd.cFileName, ::wcslen(rwfd.cFileName)));

        pathAndSize.m_size = ::FusionpFileSizeFromFindData(rwfd);

        ppFoundDirEntry = reinterpret_cast<CFusionFilePathAndSize**>(::bsearch(
            &pPathAndSize,
            &*indirectDir1Entries.Begin(),
            indirectDir1Entries.GetSize(),
            sizeof(CIndirectDirEntries::ValueType),
            CFusionFilePathAndSize::QsortIndirectComparePath));

        pFoundDirEntry = (ppFoundDirEntry != NULL) ? *ppFoundDirEntry : NULL;
        if (pFoundDirEntry == NULL)
        {
            IFW32FALSE_EXIT(pResult->m_str1.Win32Assign(rdir2, dirSlash2Length));
            IFW32FALSE_EXIT(pResult->m_str1.Win32Append(rwfd.cFileName, ::wcslen(rwfd.cFileName)));
            pResult->m_e = CFusionDirectoryDifference::eExtraOrMissingFile;
            fSuccess = TRUE;
            goto Exit;
        }

        if (pFoundDirEntry->m_size != pathAndSize.m_size)
        {
            SIZE_T cchTemp = ::wcslen(rwfd.cFileName);

            IFW32FALSE_EXIT(pResult->m_str1.Win32Assign(rdir1, dirSlash1Length));
            IFW32FALSE_EXIT(pResult->m_str1.Win32Append(rwfd.cFileName, cchTemp));
            pResult->m_nMismatchedFileSize1 = pFoundDirEntry->m_size;

            IFW32FALSE_EXIT(pResult->m_str2.Win32Assign(rdir2, dirSlash2Length));
            IFW32FALSE_EXIT(pResult->m_str2.Win32Append(rwfd.cFileName, cchTemp));
            pResult->m_nMismatchedFileSize2 = pathAndSize.m_size;

            pResult->m_e = CFusionDirectoryDifference::eMismatchedFileSize;
            fSuccess = TRUE;
            goto Exit;
        }
    } while (::FindNextFileW(findFile, &rwfd));

    if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
        goto Exit;

    if (count1 != count2)
    {
        IFW32FALSE_EXIT(pResult->m_str1.Win32Assign(rdir1, dirSlash1Length - 1));
        IFW32FALSE_EXIT(pResult->m_str2.Win32Assign(rdir2, dirSlash2Length - 1));
        pResult->m_nMismatchedFileCount1 = count1;
        pResult->m_nMismatchedFileCount2 = count2;
        pResult->m_e = CFusionDirectoryDifference::eMismatchedFileCount;

        fSuccess = TRUE;
        goto Exit;
    }

    IFW32FALSE_EXIT(findFile.Win32Close());

    pResult->m_e = CFusionDirectoryDifference::eEqual;
    fSuccess = TRUE;
Exit:
    // restore the paths for our caller
    rdir1.Left(dirSlash1Length);
    rdir2.Left(dirSlash2Length);

    return fSuccess;
}

/*-----------------------------------------------------------------------------
walk dirSlash1 and dirSlash2 recursively
for each file in either tree, see if it is in the other tree
at the same analogous position, and has the same size

if all files are present in both trees, no extra in either tree,
all with same size, return true

if any files are in one tree but not the other, or vice versa, or any
sizes mis match, return false

the algorithm short circuits
but it also does a depth first recursion
-----------------------------------------------------------------------------*/
BOOL
FusionpCompareDirectoriesSizewiseRecursively(
    CFusionDirectoryDifference*  pResult,
    const CBaseStringBuffer &rdir1,
    const CBaseStringBuffer &rdir2
    )
{
/*
security issue marker
large frame -- over 1500 bytes
and worse than that, indefinite recursion
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

// only hog one stack frame with these large variables, rather than
// putting them in the recursive function
    WIN32_FIND_DATAW wfd = {0};
    CStringBuffer mutableDir1;
    CStringBuffer mutableDir2;

    pResult->m_e = pResult->eEqual;

    IFW32FALSE_EXIT(mutableDir1.Win32Assign(rdir1, rdir1.Cch()));
    IFW32FALSE_EXIT(mutableDir1.Win32EnsureTrailingPathSeparator());
    IFW32FALSE_EXIT(mutableDir2.Win32Assign(rdir2, rdir2.Cch()));
    IFW32FALSE_EXIT(mutableDir2.Win32EnsureTrailingPathSeparator());

    // if either directory is a subdirectory of the other,
    // (or a subdir of a subdir, any generation descendant)
    // return an error; we could also interpret this as unequal,
    // since they can't be equal, or we could do the comparison
    // but not recurse on the subdir that is also a root;
    //
    // must do this check after the slashes are in place, because
    // "c:\food" is not a subdir of "c:\foo", but "c:\foo\d" is a subdir of "c:\foo\"
    // (quotes avoid backslash line continuation)
    PARAMETER_CHECK(_wcsnicmp(mutableDir1, mutableDir2, mutableDir1.Cch()) != 0);
    PARAMETER_CHECK(_wcsnicmp(mutableDir1, mutableDir2, mutableDir2.Cch()) != 0);

    IFW32FALSE_EXIT(
        ::FusionpCompareDirectoriesSizewiseRecursivelyHelper(
            pResult,
            mutableDir1,
            mutableDir2,
            wfd));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

static BOOL
IsStarOrStarDotStar(
    PCWSTR str
    )
{
    // NTRAID#NTBUG9 - 589828 - 2002/03/26 - xiaoyuw:
    // better use WCHAR instead of CHAR for the following char constant.
    return (str[0] == '*'
        && (str[1] == 0 || (str[1] == '.' && str[2] == '*' && str[3] == 0)));
}

CDirWalk::ECallbackResult
CDirWalk::WalkHelper(
    )
{
#if DBG
#define SET_LINE() Line = __LINE__
    ULONG Line = 0;
#else
#define SET_LINE() /* nothing */
#endif
    const PCWSTR* fileFilter = NULL;
    BOOL      fGotAll       = FALSE;
    BOOL      fThisIsAll    = FALSE;
    CFindFile hFind;
    SIZE_T directoryLength = m_strParent.Cch();
    ECallbackResult result = eKeepWalking;
    DWORD dwWalkDirFlags = 0;

    ::ZeroMemory(&m_fileData, sizeof(m_fileData));
    result |= m_callback(eBeginDirectory, this, dwWalkDirFlags);
    if (result & (eError | eSuccess))
    {
        SET_LINE();
        goto Exit;
    }

    if ((result & eStopWalkingFiles) == 0)
    {
        for (fileFilter = m_fileFiltersBegin ; fileFilter != m_fileFiltersEnd ; ++fileFilter)
        {
            //
            // FindFirstFile equates *.* with *, so we do too.
            //
            fThisIsAll = ::IsStarOrStarDotStar(*fileFilter);
            fGotAll = fGotAll || fThisIsAll;
            if (!m_strParent.Win32EnsureTrailingPathSeparator())
                goto Error;
            if (!m_strParent.Win32Append(*fileFilter, (*fileFilter != NULL) ? ::wcslen(*fileFilter) : 0))
                goto Error;
            hFind = ::FindFirstFileW(m_strParent, &m_fileData);
            m_strParent.Left(directoryLength);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                do
                {
                    if (::FusionpIsDotOrDotDot(m_fileData.cFileName))
                        continue;

                    if (!m_strLastObjectFound.Win32Assign(m_fileData.cFileName, ::wcslen(m_fileData.cFileName)))
                    {
                        SET_LINE();
                        goto Error;
                    }

                    //
                    // we recurse on directories only if we are getting all of them
                    // otherwise we do them afterward
                    //
                    // the order directories are visited is therefore inconsistent, but
                    // most applications should be happy enough with the eEndDirectory
                    // notification (to implement rd /q/s)
                    //
                    if (m_fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        if (fThisIsAll && (result & eStopWalkingDirectories) == 0)
                        {
                            if (!m_strParent.Win32Append("\\", 1))
                            {
                                SET_LINE();
                                goto Error;
                            }
                            if (!m_strParent.Win32Append(m_fileData.cFileName, ::wcslen(m_fileData.cFileName)))
                            {
                                SET_LINE();
                                goto Error;
                            }
                            result |= WalkHelper();
                        }
                    }
                    else
                    {
                        if ((result & eStopWalkingFiles) == 0)
                        {
                            dwWalkDirFlags |= SXSP_DIR_WALK_FLAGS_FIND_AT_LEAST_ONE_FILEUNDER_CURRENTDIR;
                            result |= m_callback(eFile, this, dwWalkDirFlags);
                            if(result == (eStopWalkingFiles | eStopWalkingDirectories))
                                dwWalkDirFlags |= SXSP_DIR_WALK_FLAGS_INSTALL_ASSEMBLY_UNDER_CURRECTDIR_SUCCEED;

                        }
                    }
                    m_strParent.Left(directoryLength);
                    if (result & (eError | eSuccess))
                    {
                        SET_LINE();
                        goto Exit;
                    }
                    if (fThisIsAll)
                    {
                        if ((result & eStopWalkingDirectories) &&
                            (result & eStopWalkingFiles))
                        {
                            if (!hFind.Win32Close())
                            {
                                SET_LINE();
                                goto Error;
                            }
                            SET_LINE();
                            goto StopWalking;
                        }
                    }
                    else
                    {
                        if (result & eStopWalkingFiles)
                        {
                            if (!hFind.Win32Close())
                            {
                                SET_LINE();
                                goto Error;
                            }
                            SET_LINE();
                            goto StopWalking;
                        }
                    }
                } while(::FindNextFileW(hFind, &m_fileData));
                if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
                {
                    SET_LINE();
                    goto Error;
                }
                if (!hFind.Win32Close())
                {
                    SET_LINE();
                    goto Error;
                }
            }
        }
    }
StopWalking:;
    //
    // make another pass with * to get all directories, if we haven't already
    //
    if (!fGotAll && (result & eStopWalkingDirectories) == 0)
    {
        if (!m_strParent.Win32Append("\\*", 2))
        {
            SET_LINE();
            goto Error;
        }
        hFind = ::FindFirstFileW(m_strParent, &m_fileData);
        m_strParent.Left(directoryLength);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (::FusionpIsDotOrDotDot(m_fileData.cFileName))
                    continue;

                if (!m_strLastObjectFound.Win32Assign(m_fileData.cFileName, ::wcslen(m_fileData.cFileName)))
                {
                    SET_LINE();
                    goto Error;
                }

                if ((m_fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                    continue;
                if (!m_strParent.Win32Append("\\", 1))
                {
                    SET_LINE();
                    goto Error;
                }
                if (!m_strParent.Win32Append(m_fileData.cFileName, ::wcslen(m_fileData.cFileName)))
                {
                    SET_LINE();
                    goto Error;
                }
                result |= WalkHelper();
                m_strParent.Left(directoryLength);

                if (result & (eError | eSuccess))
                {
                    SET_LINE();
                    goto Exit;
                }
                if (result & eStopWalkingDirectories)
                {
                    SET_LINE();
                    goto StopWalkingDirs;
                }
            } while(::FindNextFileW(hFind, &m_fileData));
            if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
            {
                SET_LINE();
                goto Error;
            }
StopWalkingDirs:
            if (!hFind.Win32Close())
            {
                SET_LINE();
                goto Error;
            }
        }
    }
    ::ZeroMemory(&m_fileData, sizeof(m_fileData));
    result |= m_callback(eEndDirectory, this, dwWalkDirFlags);
    if (result & (eError | eSuccess))
    {
        SET_LINE();
        goto Exit;
    }

    result = eKeepWalking;
Exit:
    if ((result & eStopWalkingDeep) == 0)
    {
        result &= ~(eStopWalkingFiles | eStopWalkingDirectories);
    }
    if (result & eError)
    {
        result |= (eStopWalkingFiles | eStopWalkingDirectories | eStopWalkingDeep);
#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "%s(%lu): %s\n", __FILE__, Line, __FUNCTION__);
#endif
    }
    return result;
Error:
    result |= eError;
    goto Exit;
#undef SET_LINE
}

CDirWalk::CDirWalk()
{
    const static PCWSTR defaultFileFilter[] =  { L"*" };

    m_fileFiltersBegin = defaultFileFilter;
    m_fileFiltersEnd = defaultFileFilter + NUMBER_OF(defaultFileFilter);
}

BOOL
CDirWalk::Walk()
{
    BOOL fSuccess = FALSE;

    //
    // Save off the original path length before we go twiddling m_strParent
    //
    m_cchOriginalPath = m_strParent.Cch();

    ECallbackResult result = WalkHelper();
    if (result & eError)
    {        
        if (::FusionpGetLastWin32Error() == ERROR_SUCCESS) // forget to set lasterror ?            
            ::SetLastError(ERROR_INSTALL_FAILURE);
        goto Exit;        
    }
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

/*-----------------------------------------------------------------------------
helper function to reduce recursive stack size
-----------------------------------------------------------------------------*/

static VOID
SxspDeleteDirectoryHelper(
    CBaseStringBuffer &dir,
    WIN32_FIND_DATAW &wfd,
    DWORD &dwFirstError
    )
{
    //
    // the reason to add this call here is that if installation ends successfully, the directory
    // would be 
    //    C:\WINDOWS\WINSXS\INSTALLTEMP\15349016
    //                                      +---Manifests
    //
    // and they are "empty" directories (no files). Manifests is a SH dir so set it to be 
    // FILE_ATTRIBUTE_NORMAL be more efficient.
    //
    //                 

    ::SetFileAttributesW(dir, FILE_ATTRIBUTE_NORMAL);
    if (RemoveDirectoryW(dir)) // empty dir
        return;        

    //
    // this is the *only* "valid" reason for DeleteDirectory fail
    // but I am not sure about "only"
    //
    DWORD dwLastError = ::FusionpGetLastWin32Error(); 
    if ( dwLastError != ERROR_DIR_NOT_EMPTY)
    {
        if (dwFirstError == 0)
            dwFirstError = dwLastError;
        return;
    }

    const static WCHAR SlashStar[] = L"\\*";
    SIZE_T length = dir.Cch();
    CFindFile findFile;

    if (!dir.Win32Append(SlashStar, NUMBER_OF(SlashStar) - 1))
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::FusionpGetLastWin32Error();
        goto Exit;
    }

    if (!findFile.Win32FindFirstFile(dir, &wfd))
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::FusionpGetLastWin32Error();
        goto Exit;
    }

    do
    {
        if (::FusionpIsDotOrDotDot(wfd.cFileName))
            continue;

        DWORD dwFileAttributes = wfd.dwFileAttributes;

        // Trim back to the slash...
        dir.Left(length + 1);

        if (dir.Win32Append(wfd.cFileName, ::wcslen(wfd.cFileName)))
        {
            if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                // recurse
                ::SxspDeleteDirectoryHelper(dir, wfd, dwFirstError); 
            }
            else
            {
                if (!DeleteFileW(dir))
                {
                    ::SetFileAttributesW(dir, FILE_ATTRIBUTE_NORMAL);
                    if (!DeleteFileW(dir))
                    {
                        if (dwFirstError == NO_ERROR)
                        {
                            //
                            // continue even in delete file ( delete files as much as possible)
                            // and record the errorCode for first failure
                            //
                            dwFirstError = ::FusionpGetLastWin32Error();
                        }
                    }
                }
            }
        }
    } while (::FindNextFileW(findFile, &wfd));
    if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::FusionpGetLastWin32Error();
    }
Exit:
    if (!findFile.Win32Close()) // otherwise RemoveDirectory fails
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::FusionpGetLastWin32Error();

    dir.Left(length);

    if (!RemoveDirectoryW(dir)) // the dir must be empty and NORMAL_ATTRIBUTE : ready to delete
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::FusionpGetLastWin32Error();
    }
}

/*-----------------------------------------------------------------------------
delete a directory recursively, continues upon errors, but returns
FALSE if there were any.
-----------------------------------------------------------------------------*/
BOOL
SxspDeleteDirectory(
    const CBaseStringBuffer &dir
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer mutableDir;

    WIN32_FIND_DATAW wfd = {0};
    DWORD dwFirstError = ERROR_SUCCESS;

    IFW32FALSE_EXIT(mutableDir.Win32Assign(dir));

    IFW32FALSE_EXIT(mutableDir.Win32RemoveTrailingPathSeparators());

    ::SxspDeleteDirectoryHelper(
        mutableDir,
        wfd,
        dwFirstError);

    //
    // Set wFirstError to Teb->LastWin32Error
    //
    if (dwFirstError != ERROR_SUCCESS)
        goto Exit;

    fSuccess = TRUE;

    //
    // Oops, the walker will end up out here with ERROR_NO_MORE_FILES,
    // which is a plainly 'good' error.  Mask it.
    //
    FusionpSetLastWin32Error(ERROR_SUCCESS);

Exit:
    return fSuccess;
}

BOOL
SxspGetFileAttributesW(
   PCWSTR lpFileName,
   DWORD &rdwFileAttributes,
   DWORD &rdwWin32Error,
   SIZE_T cExceptionalWin32Errors,
   ...
   )
{
    FN_PROLOG_WIN32

    rdwWin32Error = ERROR_SUCCESS;

    if ((rdwFileAttributes = ::GetFileAttributesW(lpFileName)) == ((DWORD) -1))
    {
        SIZE_T i = 0;
        va_list ap;
        const DWORD dwLastError = ::FusionpGetLastWin32Error();

        va_start(ap, cExceptionalWin32Errors);

        for (i=0; i<cExceptionalWin32Errors; i++)
        {
            if (dwLastError == va_arg(ap, DWORD))
            {
                rdwWin32Error = dwLastError;
                break;
            }
        }

        va_end(ap);

        if (i == cExceptionalWin32Errors)
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT_EX(dwLastError, ("%s(%ls)", "GetFileAttributesW", lpFileName));
        }
    }

    FN_EPILOG
}

BOOL
SxspGetFileAttributesW(
   PCWSTR lpFileName,
   DWORD &rdwFileAttributes
   )
{
    DWORD dw = 0;
    return ::SxspGetFileAttributesW(lpFileName, rdwFileAttributes, dw, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\regenumvalues.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    regenumkeys.cpp

Abstract:
    ported from vsee\lib\reg\cenumvalues.cpp
 
Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/
#include "stdinc.h"
#include "fusionregenumvalues.h"
#include "fusionregkey2.h"
#include "vseeport.h"

/*-----------------------------------------------------------------------------
Name: CRegEnumValues::CRegEnumValues

@mfunc
 
@owner
-----------------------------------------------------------------------------*/
F::CRegEnumValues::CRegEnumValues
(
    HKEY hKey
) throw(CErr)
:
    m_hKey(hKey),
    m_dwIndex(0),
    m_cValues(0),
    m_cchMaxValueNameLength(0),
    m_cbMaxValueDataLength(0),
    m_cbCurrentValueDataLength(0),
    m_dwType(0)
{
    VSEE_ASSERT_CAN_THROW();
    F::CRegKey2::ThrQueryValuesInfo(hKey, &m_cValues, &m_cchMaxValueNameLength, &m_cbMaxValueDataLength);

    // we keep this the max size the whole time
    if (!m_rgbValueData.Win32SetSize(m_cbMaxValueDataLength + 2*sizeof(WCHAR)))
        CErr::ThrowWin32(F::GetLastWin32Error());

    if (*this)
    {
        ThrGet();
    }
}

/*-----------------------------------------------------------------------------
Name: CRegEnumValues::operator bool

@mfunc
are we done yet?

@owner
-----------------------------------------------------------------------------*/
F::CRegEnumValues::operator bool
(
) const /*throw()*/
{
    return (m_dwIndex < m_cValues);
}

/*-----------------------------------------------------------------------------
Name: CRegEnumValues::ThrGet

@mfunc
get the current value name and data, called by operator++ and constructor
 
@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegEnumValues::ThrGet
(
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();

    DWORD cchValueNameLength = m_cchMaxValueNameLength;

    cchValueNameLength += 1; // count room for terminal nul

    CStringW_CFixedSizeBuffer nameBuffer(&m_strValueName, cchValueNameLength);

    m_cbCurrentValueDataLength = static_cast<DWORD>(m_rgbValueData.GetSize());

    // CONSIDER
    // Other places we have an "actual buffer size" and a smaller size we claim to the Reg API.
    // Here the actual and claimed are the same.
    F::CRegKey2::ThrEnumValue
    (
        m_hKey,
        m_dwIndex,
        nameBuffer,
        &cchValueNameLength,
        &m_dwType,
        m_rgbValueData.GetArrayPtr(),
        &m_cbCurrentValueDataLength
    );

}

/*-----------------------------------------------------------------------------
Name: CRegEnumValues::ThrNext

@mfunc
move to the next value
 
@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegEnumValues::ThrNext
(
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    ++m_dwIndex;
    if (*this)
    {
        ThrGet();
    }
}

/*-----------------------------------------------------------------------------
Name: CRegEnumValues::operator++

@mfunc
move to the next value
 
@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegEnumValues::operator++
(
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    ThrNext();
}

/*-----------------------------------------------------------------------------
Name: CRegEnumValues::operator++

@mfunc
move to the next value
 
@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegEnumValues::operator++
(
    int
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    ThrNext();
}

/*-----------------------------------------------------------------------------
Name: CRegEnumValues::GetType

@mfunc
get the type of the current value
 
@owner
-----------------------------------------------------------------------------*/
DWORD
F::CRegEnumValues::GetType
(
) const /*throw()*/
{
    VSEE_NO_THROW();
    return m_dwType;
}


/*-----------------------------------------------------------------------------
Name: CRegEnumValues::GetValuesCount

@mfunc
Returns the number of values under this key
 
@owner AlinC
-----------------------------------------------------------------------------*/
DWORD
F::CRegEnumValues::GetValuesCount
(
) const /*throw()*/
{
    VSEE_NO_THROW();
    return m_cValues;
}


/*-----------------------------------------------------------------------------
Name: CRegEnumValues::GetValueName

@mfunc
get the name of the current value
 
@owner
-----------------------------------------------------------------------------*/
const F::CBaseStringBuffer&
F::CRegEnumValues::GetValueName
(
) const /*throw()*/
{
    VSEE_NO_THROW();
    return m_strValueName;
}

/*-----------------------------------------------------------------------------
Name: CRegEnumValues::GetValueData

@mfunc
get the current value data
 
@owner
-----------------------------------------------------------------------------*/
const BYTE*
F::CRegEnumValues::GetValueData
(
) const /*throw()*/
{
    VSEE_NO_THROW();
    return m_rgbValueData.GetArrayPtr();
}

/*-----------------------------------------------------------------------------
Name: CRegEnumValues::GetValueDataSize

@mfunc
get the number of bytes in the current value data
 
@owner
-----------------------------------------------------------------------------*/
DWORD
F::CRegEnumValues::GetValueDataSize
(
) const /*throw()*/
{
    VSEE_NO_THROW();
    return m_cbCurrentValueDataLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\parser.cpp ===
#include "stdinc.h"
#include "debmacro.h"
#include "ntdef.h"
#include "fusionparser.h"
#include "shlwapi.h"

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))
#endif



BOOL
CFusionParser::ParseVersion(
    ASSEMBLY_VERSION &rav,
    PCWSTR sz,
    SIZE_T cch,
    bool &rfSyntaxValid
    )
{
    FN_PROLOG_WIN32
    
    ULONG cDots = 0;
    PCWSTR pszTemp;
    SIZE_T cchLeft;
    ULONG ulTemp = 0;
    ASSEMBLY_VERSION avTemp;
    PCWSTR pszLast;
    bool fSyntaxValid = true;

    rfSyntaxValid = false;

    PARAMETER_CHECK((sz != NULL) || (cch == 0));

    avTemp.Major = 0;
    avTemp.Minor = 0;
    avTemp.Revision = 0;
    avTemp.Build = 0;

    while ((cch != 0) && (sz[cch - 1] == L'\0'))
        cch--;

    // Unfortunately there isn't a StrChrN(), so we'll look for the dots ourselves...
    pszTemp = sz;
    cchLeft = cch;

    while (cchLeft-- != 0)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'.')
        {
            cDots++;

            if (cDots >= 4)
            {
                fSyntaxValid = false;
                break;
            }
        }
        else if ((wch < L'0') || (wch > L'9'))
        {
            fSyntaxValid = false;
            break;
        }
    }

    if (fSyntaxValid && (cDots < 3))
        fSyntaxValid = false;

    //
    // CODECLEANUP:2002-3-29:jonwis - I think we could be better here if we used a
    //          slightly smarter parsing logic, like "knowing which version slot we're
    //          parsing for" rather than four for(;;) loops...  In the current world,
    //          we're probably likely to fall off the end of our allocation at some
    //          point or another..
    //
    // NTRAID#NTBUG9 - 538512 - jonwis - 2002/04/25 - Request for smarter parser
    if (fSyntaxValid)
    {
        pszTemp = sz;
        pszLast = sz + cch;

        ulTemp = 0;
        for (;;)
        {
            WCHAR wch = *pszTemp++;

            if (wch == L'.')
                break;

            ulTemp = (ulTemp * 10) + (wch - L'0');

            if (ulTemp > 65535)
            {
                // rfSyntaxValid implicitly false
                ASSERT(!rfSyntaxValid);
                FN_SUCCESSFUL_EXIT();
            }
        }

        avTemp.Major = (USHORT) ulTemp;

        ulTemp = 0;
        for (;;)
        {
            WCHAR wch = *pszTemp++;

            if (wch == L'.')
                break;

            ulTemp = (ulTemp * 10) + (wch - L'0');

            if (ulTemp > 65535)
            {
                // rfSyntaxValid implicitly false
                ASSERT(!rfSyntaxValid);
                FN_SUCCESSFUL_EXIT();
            }
        }

        avTemp.Minor = (USHORT) ulTemp;

        ulTemp = 0;
        for (;;)
        {
            WCHAR wch = *pszTemp++;

            if (wch == L'.')
                break;

            ulTemp = (ulTemp * 10) + (wch - L'0');

            if (ulTemp > 65535)
            {
                // rfSyntaxValid implicitly false
                ASSERT(!rfSyntaxValid);
                FN_SUCCESSFUL_EXIT();
            }
        }
        avTemp.Revision = (USHORT) ulTemp;

        // Now the tricky bit.  We aren't necessarily null-terminated, so we
        // have to just look for hitting the end.
        ulTemp = 0;
        while (pszTemp < pszLast)
        {
            WCHAR wch = *pszTemp++;
            ulTemp = (ulTemp * 10) + (wch - L'0');

            if (ulTemp > 65535)
            {
                // rfSyntaxValid implicitly false
                ASSERT(!rfSyntaxValid);
                FN_SUCCESSFUL_EXIT();
            }
        }
        avTemp.Build = (USHORT) ulTemp;

        rav = avTemp;
    }

    rfSyntaxValid = fSyntaxValid;

    FN_EPILOG
}


BOOL
CFusionParser::ParseULONG(
    ULONG &rul,
    PCWSTR sz,
    SIZE_T cch,
    ULONG Radix
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG ulTemp = 0;

    PARAMETER_CHECK((Radix >= 2) && (Radix <= 36));

    while (cch != 0)
    {
        const WCHAR wch = *sz++;
        ULONG Digit = 0;
        cch--;

        if ((wch >= L'0') && (wch <= L'9'))
            Digit = (wch - L'0');
        else if ((wch >= L'a') && (wch <= L'z'))
            Digit = (10 + wch - L'a');
        else if ((wch >= L'A') && (wch <= L'Z'))
            Digit = (10 + wch - L'A');
        else
            ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidDigit, ERROR_SXS_MANIFEST_PARSE_ERROR);

        if (Digit >= Radix)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidDigitForRadix, ERROR_SXS_MANIFEST_PARSE_ERROR);

        //
        // Simple overflow detection - if the new number is less than the current, oops.
        //
        // NTRAID#NTBUG9 - 538512 - jonwis - 2002/04/25 - Better overflow detection requested
        if (((ulTemp * Radix) + Digit) < ulTemp)
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(CFusionParser::ParseULONG::Overflow, ERROR_ARITHMETIC_OVERFLOW);
        }

        ulTemp = (ulTemp * Radix) + Digit;
    }

    rul = ulTemp;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
FusionDupString(
    LPWSTR *ppszOut,
    PCWSTR szIn,
    SIZE_T cchIn
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (ppszOut != NULL)
        *ppszOut = NULL;

    PARAMETER_CHECK((cchIn == 0) || (szIn != NULL));
    PARAMETER_CHECK(ppszOut != NULL);

    IFALLOCFAILED_EXIT(*ppszOut = FUSION_NEW_ARRAY(WCHAR, cchIn + 1));

    if (cchIn != 0)
        memcpy(*ppszOut, szIn, cchIn * sizeof(WCHAR));

    (*ppszOut)[cchIn] = L'\0';

    fSuccess = TRUE;
Exit:
    return fSuccess;
}



int SxspHexDigitToValue(WCHAR wch)
{
    if ((wch >= L'a') && (wch <= L'f'))
        return 10 + (wch - L'a');
    else if ((wch >= L'A') && (wch <= 'F'))
        return 10 + (wch - L'A');
    else if (wch >= '0' && wch <= '9')
        return (wch - L'0');
    else
        return -1;
}

bool SxspIsHexDigit(WCHAR wch)
{
    return (((wch >= L'0') && (wch <= L'9')) ||
            ((wch >= L'a') && (wch <= L'f')) ||
            ((wch >= L'A') && (wch <= L'F')));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\regenumkeys.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    regenumkeys.cpp

Abstract:
    ported from vsee\lib\reg\cenumkeys.cpp
 
Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/
#include "stdinc.h"
#include "vseeport.h"
#include "fusionregenumkeys.h"

namespace F
{

/*-----------------------------------------------------------------------------
Name: CRegEnumKeys::CRegEnumKeys

@mfunc
 
@owner
-----------------------------------------------------------------------------*/
F::CRegEnumKeys::CRegEnumKeys
(
    HKEY hKey
) throw(CErr)
:
    m_hKey(hKey),
    m_dwIndex(0),
    m_cSubKeys(0),
    m_cchMaxSubKeyNameLength(0)
{
    VSEE_ASSERT_CAN_THROW();
    F::CRegKey2::ThrQuerySubKeysInfo(hKey, &m_cSubKeys, &m_cchMaxSubKeyNameLength);
    if (*this)
    {
        ThrGet();
    }
}

/*-----------------------------------------------------------------------------
Name: CRegEnumKeys::operator bool

@mfunc
are we done yet?

@owner
-----------------------------------------------------------------------------*/
F::CRegEnumKeys::operator bool
(
) const /*throw()*/
{
    return (m_dwIndex < m_cSubKeys);
}

/*-----------------------------------------------------------------------------
Name: CRegEnumKeys::ThrGet

@mfunc
get the current subkey name, called by operator++ and constructor

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegEnumKeys::ThrGet
(
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();

    while (TRUE)
    {
        DWORD cchSubKeyNameLength = m_cchMaxSubKeyNameLength;

        CStringW_CFixedSizeBuffer buffer(&m_strSubKeyName, cchSubKeyNameLength);

        cchSubKeyNameLength += 1; // count room for terminal nul

        LONG lRes = F::CRegKey2::RegEnumKey(m_hKey, m_dwIndex, buffer, &cchSubKeyNameLength);
        switch (lRes)
        {
        case ERROR_SUCCESS:
            return;
        default:
            NVseeLibError_VThrowWin32(lRes);
        case ERROR_MORE_DATA:
            // RegQueryInfo(maximum key length) doesn't always work.
            m_cchMaxSubKeyNameLength = (m_cchMaxSubKeyNameLength + 1) * 2;
            break;
        }
    }
}

/*-----------------------------------------------------------------------------
Name: CRegEnumKeys::ThrNext

@mfunc
move to the next subkey
 
@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegEnumKeys::ThrNext
(
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    ++m_dwIndex;
    if (*this)
    {
        ThrGet();
    }
}

/*-----------------------------------------------------------------------------
Name: CRegEnumKeys::operator++

@mfunc
move to the next subkey
 
@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegEnumKeys::operator++
(
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    ThrNext();
}

/*-----------------------------------------------------------------------------
Name: CRegEnumKeys::operator++

@mfunc
move to the next subkey

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegEnumKeys::operator++
(
    int
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    ThrNext();
}

/*-----------------------------------------------------------------------------
Name: CRegEnumKeys::operator const F::CBaseStringBuffer&

@mfunc
get the name of the current subkey
 
@owner
-----------------------------------------------------------------------------*/
F::CRegEnumKeys::operator const F::CBaseStringBuffer&
(
) const /*throw()*/
{
    VSEE_NO_THROW();
    return m_strSubKeyName;
}

/*-----------------------------------------------------------------------------
Name: CRegEnumKeys::operator PCWSTR

@mfunc
get the name of the current subkey
 
@owner
-----------------------------------------------------------------------------*/
F::CRegEnumKeys::operator PCWSTR
(
) const /*throw()*/
{
    VSEE_NO_THROW();
    return operator const F::CBaseStringBuffer&();
}

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\ntdllwrap.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#define dllimport /* nothing */
#include "debmacro.h"
#include "util.h"
#include "fusionntdll.h"
#if !FUSION_STATIC_NTDLL
#include "win32simplelock.h"
#endif

#if !FUSION_URT

//
// ISSUE:2002-03-14:jonwis - Wow, this is bogus.  We should fix this so that we error out
//          on large input strings (ie: numerical overflow, etc.)  As it is, we'll either
//          wrap around when comparing, or we'll do something else equally gross and maybe
//          miscompare strings.  (Consider "foo" vs. "[32k of whatever]foo" - they should
//          compare equal in this case.)  We really should revamp this so that the comparison
//          result is an OUT, and so this can 'fail' on bad input parameters.
//
int
FusionpCompareStrings(
    PCWSTR psz1,
    SIZE_T cch1,
    PCWSTR psz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    )
{
    UNICODE_STRING s1, s2;

    s1.Buffer = const_cast<PWSTR>(psz1);
    s1.Length = static_cast<USHORT>(cch1 * sizeof(WCHAR));
    s1.MaximumLength = s1.Length;

    s2.Buffer = const_cast<PWSTR>(psz2);
    s2.Length = static_cast<USHORT>(cch2 * sizeof(WCHAR));
    s2.MaximumLength = s2.Length;

    return ::FusionpRtlCompareUnicodeString(&s1, &s2, fCaseInsensitive);
}

//
// This is not inline in the headers because CGenericBaseStringBuffer 
// is not defined early enough; it is only forward declared.
//  2002-05-16:Jaykrell
//
int
FusionpCompareStrings(
    const CBaseStringBuffer &rbuff1,
    PCWSTR psz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    )
{
    return ::FusionpCompareStrings(rbuff1, rbuff1.Cch(), psz2, cch2, fCaseInsensitive);
}

//
// This is not inline in the headers because CGenericBaseStringBuffer 
// is not defined early enough; it is only forward declared.
//  2002-05-16:Jaykrell
//
int
FusionpCompareStrings(
    PCWSTR psz1,
    SIZE_T cch1,
    const CBaseStringBuffer &rbuff2,
    bool fCaseInsensitive
    )
{
    return ::FusionpCompareStrings(psz1, cch1, rbuff2, rbuff2.Cch(), fCaseInsensitive);
}

//
// This is not inline in the headers because CGenericBaseStringBuffer 
// is not defined early enough; it is only forward declared.
//  2002-05-16:Jaykrell
//
int
FusionpCompareStrings(
    const CBaseStringBuffer &rbuff1,
    const CBaseStringBuffer &rbuff2,
    bool fCaseInsensitive
    )
{
    return ::FusionpCompareStrings(rbuff1, rbuff1.Cch(), rbuff2, rbuff2.Cch(), fCaseInsensitive);
}

//
// This is not inline in the headers because CGenericBaseStringBuffer 
// is not defined early enough; it is only forward declared.
//  2002-05-16:Jaykrell
//
// FUTURE:2002-03-14:jonwis - Consider removing the I versions of these functions entirely.
bool
FusionpEqualStringsI(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    PCWSTR psz2,
    SIZE_T cch2
    )
{
    return ::FusionpEqualStringsI(static_cast<PCWSTR>(rbuff1), rbuff1.Cch(), psz2, cch2);
}

//
// This is not inline in the headers because CGenericBaseStringBuffer 
// is not defined early enough; it is only forward declared.
//  2002-05-16:Jaykrell
//
bool
FusionpEqualStringsI(
    PCWSTR psz1,
    SIZE_T cch1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2
    )
{
    return ::FusionpEqualStringsI(psz1, cch1, static_cast<PCWSTR>(rbuff2), rbuff2.Cch());
}

//
// This is not inline in the headers because CGenericBaseStringBuffer 
// is not defined early enough; it is only forward declared.
//  2002-05-16:Jaykrell
//
bool
FusionpEqualStringsI(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2
    )
{
    return ::FusionpEqualStringsI(static_cast<PCWSTR>(rbuff1), rbuff1.Cch(),
                                static_cast<PCWSTR>(rbuff2), rbuff2.Cch());
}

//
// This is not inline in the headers because CGenericBaseStringBuffer 
// is not defined early enough; it is only forward declared.
//  2002-06-18:Jaykrell
//
bool
FusionpEqualStrings(
    PCWSTR psz1,
    SIZE_T cch1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2,
    bool fCaseInsensitive
    )
{
    return ::FusionpEqualStrings(psz1, cch1,
                               static_cast<PCWSTR>(rbuff2), rbuff2.Cch(),
                               fCaseInsensitive);
}

//
// This is not inline in the headers because CGenericBaseStringBuffer 
// is not defined early enough; it is only forward declared.
//  2002-06-18:Jaykrell
//
bool
FusionpEqualStrings(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    PCWSTR psz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    )
{
    return ::FusionpEqualStrings(static_cast<PCWSTR>(rbuff1), rbuff1.Cch(),
                               psz2, cch2,
                               fCaseInsensitive);
}

#endif

#if !FUSION_STATIC_NTDLL

// ISSUE:
#define INIT_WITH_DOWNLEVEL(rettype, calltype, api, argsin, argsout) \
rettype calltype Fusionp ## api ## _Init argsin; \
rettype calltype Fusionp ## api ## _DownlevelFallback argsin; \
rettype (calltype * g_Fusionp ## api) argsin = &::Fusionp ## api ## _Init; \
rettype \
calltype \
Fusionp ## api ## _Init argsin \
{ \
    InterlockedExchangePointer((PVOID *) &g_Fusionp ## api, ::GetProcAddress(::GetModuleHandleW(L"NTDLL.DLL"), #api)); \
    if (g_Fusionp ## api == NULL) \
        InterlockedExchangePointer((PVOID *) &g_Fusionp ## api, &::Fusionp ## api ## _DownlevelFallback); \
    return (*g_Fusionp ## api) argsout; \
}

__declspec(noreturn)
void FusionpFailNtdllDynlink(const char* s)
{
    DWORD dwLastError = ::GetLastError();
    char buf[64];
    buf[sizeof(buf) - 1] = 0;
    ::_snprintf(buf, NUMBER_OF(buf) - 1, "SXS2000: Ntdll dynlink %s failed\n", s);
    ::OutputDebugStringA(buf);
    ::TerminateProcess(GetCurrentProcess(), dwLastError);
}

#define INIT_NO_DOWNLEVEL(rettype, calltype, api, argsin, argsout) \
rettype calltype Fusionp ## api ## _Init argsin; \
rettype (calltype * g_Fusionp ## api) argsin = &::Fusionp ## api ## _Init; \
rettype \
calltype \
Fusionp ## api ## _Init argsin \
{ \
    InterlockedExchangePointer((PVOID *) &g_Fusionp ## api, ::GetProcAddress(::GetModuleHandleW(L"NTDLL.DLL"), #api)); \
    if (g_Fusionp ## api == NULL) \
        ::FusionpFailNtdllDynlink(#api); \
    return (*g_Fusionp ## api) argsout; \
}

INIT_WITH_DOWNLEVEL(WCHAR, NTAPI, RtlUpcaseUnicodeChar, (WCHAR wch), (wch))
INIT_NO_DOWNLEVEL(WCHAR, NTAPI, RtlDowncaseUnicodeChar, (WCHAR wch), (wch))
INIT_WITH_DOWNLEVEL(NTSTATUS, NTAPI, NtQueryDebugFilterState, (ULONG ComponentId, ULONG Level), (ComponentId, Level))
INIT_WITH_DOWNLEVEL(LONG, NTAPI, RtlCompareUnicodeString, (PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive), (String1, String2, CaseInSensitive))
INIT_NO_DOWNLEVEL(LONG, NTAPI, RtlUnhandledExceptionFilter, (struct _EXCEPTION_POINTERS *ExceptionInfo), (ExceptionInfo))
INIT_NO_DOWNLEVEL(NTSTATUS, NTAPI, NtAllocateLocallyUniqueId, (PLUID Luid), (Luid))
INIT_WITH_DOWNLEVEL(ULONG, NTAPI, vDbgPrintExWithPrefix, (PCSTR Prefix, IN ULONG ComponentId, IN ULONG Level, IN PCSTR Format, va_list arglist), (Prefix, ComponentId, Level, Format, arglist))
INIT_NO_DOWNLEVEL(DWORD, NTAPI, RtlNtStatusToDosError, (NTSTATUS st), (st))
INIT_WITH_DOWNLEVEL(NTSTATUS, NTAPI, RtlHashUnicodeString, (const UNICODE_STRING *String, BOOLEAN CaseInSensitive, ULONG HashAlgorithm, PULONG HashValue), (String, CaseInSensitive, HashAlgorithm, HashValue))
INIT_NO_DOWNLEVEL(NTSTATUS, NTAPI, RtlExpandEnvironmentStrings_U, (PVOID Environment, PUNICODE_STRING Source, PUNICODE_STRING Destination, PULONG ReturnedLength), (Environment, Source, Destination, ReturnedLength))
INIT_NO_DOWNLEVEL(VOID, NTAPI, RtlAssert, (PVOID FailedAssertion, PVOID FileName, ULONG LineNumber, PCSTR Message), (FailedAssertion, FileName, LineNumber, Message))

INIT_WITH_DOWNLEVEL(VOID, NTAPI, RtlAcquirePebLock, (VOID), ())
INIT_WITH_DOWNLEVEL(VOID, NTAPI, RtlReleasePebLock, (VOID), ())

//
// Note:
//  actually, ntdll.dll of win2k and winxp implement this function,
//  but win9x does not(we use this func on win98 for FusionWin32_msi_installed 
//  assembly : however win9x does not support unicode at all, so this is just 
//  a simple version
//
WCHAR FusionpRtlUpcaseUnicodeChar_DownlevelFallback(
    IN WCHAR wch)
{
    if (((wch) >=  'a') && ((wch) <=  'z'))
        return ((wch) - ('a'-'A'));
    else
        return wch;
}
LONG
FusionpRtlCompareUnicodeString_DownlevelFallback(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )
{
    WCHAR c1 = 0;
    WCHAR c2 = 0;

    PCWSTR s1 = String1->Buffer;
    PCWSTR s2 = String2->Buffer;
    const LONG n1 = String1->Length;
    const LONG n2 = String2->Length;

    ASSERT_NTC((n1 & 1) == 0);
    ASSERT_NTC((n2 & 1) == 0);
    ASSERT_NTC(!(((((ULONG_PTR)s1 & 1) != 0) || (((ULONG_PTR)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

    PCWSTR Limit = (PWCHAR)((PCHAR)s1 + (n1 <= n2 ? n1 : n2));
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {

                //
                // Note that this needs to reference the translation table!
                //

                c1 = ::FusionpRtlUpcaseUnicodeChar_DownlevelFallback(c1);
                c2 = ::FusionpRtlUpcaseUnicodeChar_DownlevelFallback(c2);
                if (c1 != c2) {
                    return (LONG)(c1) - (LONG)(c2);
                }
            }
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                return (LONG)(c1) - (LONG)(c2);
            }
        }
    }

    return n1 - n2;
}


//
// BUGBUG:jonwis:2002-03-14 - The original code here had several bugs, see #577148
//
ULONG
NTAPI
FusionpvDbgPrintExWithPrefix_DownlevelFallback(PCSTR Prefix, IN ULONG ComponentId, IN ULONG Level, IN PCSTR Format, va_list arglist)
{
    CHAR Buffer[512]; // same as code in rtl 4/23/2001

    const SSIZE_T cb = ::strlen(Prefix);
    
    if (cb > (NUMBER_OF(Buffer) - 1))
        return (ULONG)STATUS_INVALID_PARAMETER; 
    
    ::_vsnprintf(Buffer + cb , NUMBER_OF(Buffer) - cb - 1, Format, arglist);
    Buffer[NUMBER_OF(Buffer) - 1] = 0;
        
    ::OutputDebugStringA(Buffer);
    return STATUS_SUCCESS;
}

NTSTATUS
NTAPI
FusionpRtlHashUnicodeString_DownlevelFallback(
    const UNICODE_STRING *String,
    BOOLEAN CaseInSensitive,
    ULONG HashAlgorithm,
    PULONG HashValue
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG TmpHashValue = 0;
    ULONG Chars = 0;
    PCWSTR Buffer = NULL;

    if ((String == NULL) ||
        (HashValue == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Buffer = String->Buffer;

    *HashValue = 0;
    Chars = String->Length / sizeof(WCHAR);

    switch (HashAlgorithm)
    {
    default:
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
        break;

    case HASH_STRING_ALGORITHM_DEFAULT:
    case HASH_STRING_ALGORITHM_X65599:
        if (CaseInSensitive)
        {
            while (Chars-- != 0)
            {
                WCHAR Char = *Buffer++;
                TmpHashValue = (TmpHashValue * 65599) + ::FusionpRtlUpcaseUnicodeChar(Char);
            }
        }
        else
        {
            while (Chars-- != 0)
                TmpHashValue = (TmpHashValue * 65599) + *Buffer++;
        }

        break;
    }

    *HashValue = TmpHashValue;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
FusionpNtQueryDebugFilterState_DownlevelFallback(ULONG ComponentId, ULONG Level)
{
    return FALSE; // total abuse of NTSTATUS API but it's how NtQueryDebugFilterState is written...
}

CWin32SimpleLock g_DownlevelPeblock = WIN32_INIT_SIMPLE_LOCK;

VOID
NTAPI
FusionpRtlAcquirePebLock_DownlevelFallback(
    )
{
    g_DownlevelPeblock.Acquire();
}

VOID
NTAPI
FusionpRtlReleasePebLock_DownlevelFallback(
    )
{
    g_DownlevelPeblock.Release();
}

#undef ASSERT
#define ASSERT(x) /* nothing */
#undef RTL_VERIFY
#define RTL_VERIFY(exp) ((exp) ? TRUE : FALSE)
#define _NTOS_
#undef LOBYTE
#undef HIBYTE
extern "C"
{
#include "ntrtlp.h"
#define RtlDowncaseUnicodeChar FusionpRtlDowncaseUnicodeChar
#include "rtlfindcharinunicodestring.c"
#include "rtlvalidateunicodestring.c"
}
#endif // #if !FUSION_STATIC_NTDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\isprint.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    isprint.c

Abstract:

Author:

    Jay Krell (JayKrell) November 2001

Revision History:

--*/

//
// FUTURE:2003-03-12:jonwis - We could reduce our final size if we packed these into
//          DWORDs rather than a char array.  This is 256 bytes, the DWORD array
//          would be (256/32) = 8 dwords long, for 256 bits (32 bytes).  The code
//          to introspect on this array is in debug.cpp in one place, so we'd probably
//          end up using ~64 bytes (32 + extra code) rather than 256.  Not sure if
//          it's worth it.
//
const extern char FusionpIsPrint_Data[256] =
{
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\setfilepointerex.c ===
#include "windows.h"

#define INVALID_SET_FILE_POINTER ((DWORD)-1)

#if defined(__cplusplus)
extern "C"
{
#endif

BOOL
WINAPI
FusionpSetFilePointerEx(
    HANDLE         File,
    LARGE_INTEGER  DistanceToMove,
    PLARGE_INTEGER NewFilePointer,
    DWORD          MoveMethod
    )
{
    DWORD NewPositionLow = SetFilePointer(File, (LONG)DistanceToMove.LowPart, &DistanceToMove.HighPart, MoveMethod);

    if (NewPositionLow == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR)
        return FALSE;

    if (NewFilePointer != NULL)
    {
        NewFilePointer->LowPart =  NewPositionLow;
        NewFilePointer->HighPart = DistanceToMove.HighPart;
    }
    return TRUE;
}

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\regkey2.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusionreg.h

Abstract:
    ported from vsee\lib\reg\ckey.cpp
    CRegKey2
 
Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/
#include "stdinc.h"
#include <wchar.h>
#include "vseeport.h"
#include "fusionregkey2.h"
#include "fusionarray.h"

/*-----------------------------------------------------------------------------
Name: CRegKey2::~CRegKey2

@mfunc
destructor; call RegCloseKey if the CRegKey2 is valid

@owner
-----------------------------------------------------------------------------*/
F::CRegKey2::~CRegKey2
(
)
{
    if (m_fValid)
    {
        LONG lResult = RegCloseKey(m_hKey);
        ASSERT_NTC(lResult == ERROR_SUCCESS);
    }
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::CRegKey2

@mfunc
default constructor

@owner
-----------------------------------------------------------------------------*/
F::CRegKey2::CRegKey2
(
)
:
    m_fValid(false),
    m_fMaxValueLengthValid(false),

    // just in case
    m_hKey(reinterpret_cast<HKEY>(INVALID_HANDLE_VALUE)),
    m_cbMaxValueLength(0),
    m_fKnownSam(false),
    m_samDesired(0)
{
    VSEE_NO_THROW();
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::CRegKey2

@mfunc
construct a CRegKey2 from an HKEY

@owner
-----------------------------------------------------------------------------*/
F::CRegKey2::CRegKey2
(
    HKEY hKey
)
:
    m_hKey(hKey),
    m_fValid(true),
    m_fKnownSam(false),
    m_samDesired(0)
{
    VSEE_NO_THROW();
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::operator=

@mfunc
assign an HKEY to a CRegKey2; throws if the CRegKey2 already has a valid HKEY
 
@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::operator=
(
    HKEY hKey
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    VsVerifyThrow(!m_fValid, "only 'single assignment' please.");
    m_hKey = hKey;
    m_fValid = true;
    m_fKnownSam = false;
    m_samDesired = 0;
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrAttach

@mfunc
same as operator=

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::ThrAttach
(
    HKEY hKey
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    (*this) = hKey;
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::Detach

@mfunc

@owner
-----------------------------------------------------------------------------*/
HKEY
F::CRegKey2::Detach
(
) throw(CErr)
{
    HKEY key = NULL;
    if (m_fValid)
    {
        key = operator HKEY();
        m_fValid = FALSE;
    }
    return key;
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::operator HKEY

@mfunc
return the held HKEY, or throws if not valid
the const version has protected access, because it doesn't
enforce logical const

@owner
-----------------------------------------------------------------------------*/
F::CRegKey2::operator HKEY
(
) const throw(CErr)
{
    return *const_cast<CRegKey2*>(this);
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::operator HKEY

@mfunc
return the held HKEY, or throws if not valid

@owner
-----------------------------------------------------------------------------*/
F::CRegKey2::operator HKEY
(
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    VsVerifyThrow(m_fValid, __FUNCTION__);
    return m_hKey;
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::HrOpen

@mfunc
call RegOpenKeyEx

@owner
-----------------------------------------------------------------------------*/
HRESULT
F::CRegKey2::HrOpen
(
    HKEY    hKeyParent, // @parm same as ::RegOpenKeyEx
    LPCWSTR pszKeyName, // @parm same as ::RegOpenKeyEx
    REGSAM  samDesired // = KEY_READ // @parm same as ::RegOpenKeyEx
)
{
    VSEE_NO_THROW();

    // REVIEW or should we call Close like ATL?
    if (m_fValid)
    {
        return E_UNEXPECTED;
    }

    HKEY hKey = NULL;
    LONG lRes = ::RegOpenKeyExW(hKeyParent, pszKeyName, 0/*ULONG reserved*/, samDesired, &hKey);
    if (lRes != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(lRes);
    }
    // ATL calls Close here.
    m_hKey = hKey;
    m_fValid = true;
    m_fKnownSam = true;
    m_samDesired = samDesired;
    return S_OK;
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrOpen

@mfunc
call RegOpenKeyEx

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::ThrOpen
(
    HKEY    hKeyParent, // @parm same as ::RegOpenKeyEx
    LPCWSTR pszKeyName, // @parm same as ::RegOpenKeyEx
    REGSAM  samDesired // = KEY_READ // @parm same as ::RegOpenKeyEx
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    NVseeLibError_VCheck(HrOpen(hKeyParent, pszKeyName, samDesired));
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::Create

@mfunc
call RegCreateKeyEx

@rvalue dwDisposition | from RegCreateKeyEx
@rvalue REG_CREATED_NEW_KEY | The key did not exist and was created.
@rvalue REG_OPENED_EXISTING_KEY | The key existed and was simply opened
 without being changed.

@owner
-----------------------------------------------------------------------------*/
DWORD
F::CRegKey2::Create
(
    HKEY    hKeyParent, // @parm same as ::RegCreateKeyEx
    PCWSTR  pszKeyName, // @parm same as ::RegCreateKeyEx
    REGSAM  samDesired // = KEY_ALL_ACCESS// @parm same as ::RegCreateKeyEx
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();

    // REVIEW or should we call Close like ATL?
    VsVerifyThrow(!m_fValid, "only 'single assignment' please");

    DWORD dwDisposition = 0;
    HKEY hKey = NULL;
    LONG lRes =
        ::RegCreateKeyExW
        (
            hKeyParent,
            pszKeyName,
            0, // DWORD reserved
            NULL, // LPCWSTR class
            REG_OPTION_NON_VOLATILE, // DWORD options
            samDesired,
            NULL, // security
            &hKey,
            &dwDisposition
        );
    if (lRes != ERROR_SUCCESS)
    {
        NVseeLibError_VThrowWin32(lRes);
    }
    // ATL calls Close here.
    m_hKey = hKey;
    m_fValid = true;
    m_fKnownSam = true;
    m_samDesired = samDesired;
    return dwDisposition;
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrSetValue

@mfunc
call RegSetValueEx

@owner AlinC
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::ThrSetValue
(
    PCWSTR pszValueName, // @parm [in]  same as RegSetValueEx
    const DWORD& dwValue
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    VSASSERT(!m_fKnownSam || (m_samDesired & KEY_SET_VALUE), "Attempt to set value when key not opened with KEY_SET_VALUE");
    VsVerifyThrow(m_fValid, __FUNCTION__);

    LONG lRes =
        ::RegSetValueExW
        (
            *this,
            pszValueName,
            0, // DWORD reserved
            REG_DWORD,
            reinterpret_cast<const BYTE*>(&dwValue),
            sizeof(DWORD)
        );
    if (lRes != ERROR_SUCCESS)
    {
        NVseeLibError_VThrowWin32(lRes);
    }
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrSetValue

@mfunc
call RegSetValueEx

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::ThrSetValue
(
    PCWSTR pszValueName, // @parm [in]  same as RegSetValueEx
    const F::CBaseStringBuffer& strValue
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    VsVerifyThrow(m_fValid, __FUNCTION__);
    VSASSERT(!m_fKnownSam || (m_samDesired & KEY_SET_VALUE), "Attempt to set value when key not opened with KEY_SET_VALUE");

    DWORD cbSize = static_cast<DWORD>((strValue.Cch()+1) * sizeof(WCHAR));
    LPCWSTR szData = (LPCWSTR)strValue;

    LONG lRes =
        ::RegSetValueExW
        (
            *this,
            pszValueName,
            0, // DWORD reserved
            REG_SZ,
            reinterpret_cast<const BYTE*>(szData),
            cbSize
        );
    if (lRes != ERROR_SUCCESS)
    {
        NVseeLibError_VThrowWin32(lRes);
    }
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrQueryValue

@mfunc
call RegQueryValueEx

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::ThrQueryValue
(
    PCWSTR pszValueName, // @parm [in]  same as RegQueryValueEx
    DWORD* pdwType,         // @parm [out] same as RegQueryValueEx
    BYTE*  pbData,         // @parm [out] same as RegQueryValueEx
    DWORD* pcbData         // @parm [out] same as RegQueryValueEx
) const throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    VsVerifyThrow(m_fValid, __FUNCTION__);

    DWORD cbActualBufferSize = 0;
    if (pcbData != NULL)
    {
        cbActualBufferSize = *pcbData;
    }
    if (pbData != NULL && cbActualBufferSize != 0)
    {
        if (cbActualBufferSize > 0)
            pbData[0] = 0;
        if (cbActualBufferSize > 1)
        {
            pbData[1] = 0;
            pbData[cbActualBufferSize - 1] = 0;
        }
        if (cbActualBufferSize > 2)
        {
            pbData[cbActualBufferSize - 2] = 0;
        }
        ZeroMemory(pbData, cbActualBufferSize); // temporary aggressiveness
    }

    LONG lRes =
        ::RegQueryValueExW
        (
            m_hKey,
            pszValueName,
            NULL, // DWORD* reserved
            pdwType,
            pbData,
            pcbData
        );
    if (pdwType != NULL)
    {
        FixBadRegistryStringValue(m_hKey, pszValueName, cbActualBufferSize, lRes, *pdwType, pbData, pcbData);
    }
    if (lRes != ERROR_SUCCESS)
    {
        NVseeLibError_VThrowWin32(lRes);
    }
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrQueryValue

@mfunc
call RegQueryValueEx

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::ThrQueryValue
(
    PCWSTR pszValueName, // @parm [in]  same as RegQueryValueEx
    F::CBaseStringBuffer* pstrData
) const throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    VsVerifyThrow(m_fValid, __FUNCTION__);

    DWORD cbActualBufferSize = 0;
    DWORD dwType;
    LONG lRes =
        ::RegQueryValueExW
        (
            m_hKey,
            pszValueName,
            NULL, // DWORD* reserved
            &dwType,
            NULL,
            &cbActualBufferSize
        );
    if (REG_SZ != dwType)
        VsOriginateError(E_FAIL);

    cbActualBufferSize += 2 * sizeof(WCHAR); // fudge

    CFusionArray<WCHAR> szTempValue;
    if (!szTempValue.Win32SetSize(cbActualBufferSize /* more fudge */ + sizeof(WCHAR)))
        FusionpOutOfMemory();

    lRes =
        ::RegQueryValueExW
        (
            m_hKey,
            pszValueName,
            NULL, // DWORD* reserved
            &dwType,
            reinterpret_cast<BYTE*>(static_cast<PWSTR>(szTempValue.GetArrayPtr())),
            &cbActualBufferSize
        );
    if (lRes != ERROR_SUCCESS)
    {
        NVseeLibError_VThrowWin32(lRes);
    }
    // missing FixBadRegistryStringValue here
    pstrData->ThrAssign(szTempValue.GetArrayPtr(), StringLength(szTempValue.GetArrayPtr()));
}

// for diagnostic purposes only
void
F::CRegKey2::GetKeyNameForDiagnosticPurposes(
    HKEY Key,
    CUnicodeBaseStringBuffer & buff
    )
{
    struct
    {
        KEY_NAME_INFORMATION KeyNameInfo;
        WCHAR                NameBuffer[MAX_PATH];
    } s;
    NTSTATUS Status = 0;
    ULONG LengthOut = 0;
    buff.Clear();
    if (!NT_SUCCESS(Status = NtQueryKey(Key, KeyNameInformation, &s, sizeof(s), &LengthOut)))
        return;
    buff.Win32Assign(s.KeyNameInfo.Name, s.KeyNameInfo.NameLength / sizeof(WCHAR));
}

/*-----------------------------------------------------------------------------
Name: FixBadRegistryStringValue

@mfunc
I'm seeing strings come back with an odd number of bytes, and without terminal
nuls. Apply some fixup here. We are dependent on the fact that our caller
overallocates its buffer to fit the terminal nul, but we do check this
at runtime via cbActualBufferSize.

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::FixBadRegistryStringValue
(
    HKEY   Key,                 // @parm [in] for diagnostic purposes
    PCWSTR ValueName,           // @parm [in] for diagnostic purposes

    DWORD  cbActualBufferSize,  // @parm [in] the size of the buffer pbData points to
                                // this value might be larger than the value
                                // passed to RegQueryValuEx, like if we want to reserve
                                // space to append a nul beyond what RegQueryValuEx
                                // gives us
    LONG   lRes,                // @parm [in] the result of a RegQueryValueEx
                                // or RegEnumValue call
    DWORD  dwType,                // @parm [in] the type returned from a RegQueryValueEx
                                // or RegEnumValue call
    BYTE*  pbData,                // @parm [in out] the data returned from a RegQueryValueEx
                                // or RegEnumValue call, we possibly append a Unicode nul to it
    DWORD* pcbData                // @parm [in out] the size returned from RegQueryValueEx
                                // or RegEnumValue; we possibly round it to even
                                // or grow it for a terminal nul
)
{
    VSEE_NO_THROW();
    C_ASSERT(sizeof(WCHAR) == 2);

    CTinyUnicodeStringBuffer KeyNameForDiagnosticPurposes;
    if
    (
            lRes == ERROR_SUCCESS
        &&    (dwType == REG_SZ || dwType == REG_EXPAND_SZ)
        &&    pcbData != NULL
    )
    {
        DWORD& rcbData = *pcbData;
        WCHAR* pchData = reinterpret_cast<WCHAR*>(pbData);

        UNICODE_STRING NtUnicodeString;
        NtUnicodeString.Length = static_cast<USHORT>(rcbData);
        NtUnicodeString.Buffer = reinterpret_cast<PWSTR>(pbData);

        // can assert but not fixup in this case
        if (pbData == NULL || cbActualBufferSize < sizeof(WCHAR))
        {
            VSASSERT((rcbData % sizeof(WCHAR)) == 0, "bad registry data: odd number of bytes in a string");
            return;
        }

        // no chars at all? just put in a terminal nul
        if (rcbData < sizeof(WCHAR))
        {
            GetKeyNameForDiagnosticPurposes(Key, KeyNameForDiagnosticPurposes);
            FusionpDbgPrint(
                "fusion_regkey2: bad registry data: string with 0 or 1 byte, Key=%ls ValueName=%ls, ValueDataLength=0x%lx, PossiblyExpectedValueDataLength=0x%Ix, ValueData=%wZ\n",
                static_cast<PCWSTR>(KeyNameForDiagnosticPurposes),
                ValueName,
                rcbData,
                sizeof(WCHAR),
                &NtUnicodeString
                );

            // just put one terminal nul in
            pchData[0] = 0;
            rcbData = sizeof(WCHAR);
        }
        else
        {
            // first round down odd rcbData if already nul terminated,
            // because these cases otherwise look non nul terminated, since
            // the extra byte isn't nul.
            // I see this a lot, ThreadingModel = Apartment, rcbData = 21
            if (rcbData > sizeof(WCHAR) && (rcbData % sizeof(WCHAR)) != 0)
            {
                // usually the terminal nul is at
                // pbData[rcbData - 1] and pbData[rcbData - 2], but we look back one byte.
                if (pbData[rcbData - 2] == 0 && pbData[rcbData - 3] == 0)
                {
                    // BUG elsewhere in the product
                    //VSASSERT(false, "bad registry data: odd number of bytes in a string");
                    GetKeyNameForDiagnosticPurposes(Key, KeyNameForDiagnosticPurposes);
                    FusionpDbgPrint(
                        "fusion_regkey2: bad registry data: odd number of bytes in a string, Key=%ls ValueName=%ls, ValueDataLength=0x%lx PossiblyExpectedValueDataLength=0x%lx, ValueData=%wZ\n",
                        static_cast<PCWSTR>(KeyNameForDiagnosticPurposes),
                        ValueName,
                        rcbData,
                        rcbData - 1,
                        &NtUnicodeString
                        );
                    rcbData -= 1;
                }
            }

            // check for embedded / terminal nul
            DWORD  cchData = rcbData / sizeof(WCHAR);
            WCHAR* pchNul = wmemchr(pchData, L'\0', cchData);
            WCHAR* pchNul2 = wmemchr(pchData, L'\0', cbActualBufferSize / sizeof(WCHAR));
            if (pchNul != (pchData + cchData - 1))
            {
                if (pchNul == NULL)
                {
                    GetKeyNameForDiagnosticPurposes(Key, KeyNameForDiagnosticPurposes);
                    if (pchNul2 == NULL)
                    {
                        FusionpDbgPrint(
                            "fusion_regkey2: bad registry data: string contains no nuls, Key=%ls ValueName=%ls, ValueDataLength=0x%lx, ValueData=%wZ\n",
                            static_cast<PCWSTR>(KeyNameForDiagnosticPurposes),
                            ValueName,
                            rcbData,
                            &NtUnicodeString
                            );
                    }
                    else
                    {
                        FusionpDbgPrint(
                            "fusion_regkey2: bad registry data: string contains no nuls, Key=%ls ValueName=%ls, ValueDataLength=0x%lx, PossiblyExpectedValueDataLength=0x%lx, ValueData=%wZ\n",
                            static_cast<PCWSTR>(KeyNameForDiagnosticPurposes),
                            ValueName,
                            rcbData,
                            (pchNul2 - pchData + 1) * sizeof(WCHAR),
                            &NtUnicodeString
                            );
                    }
                }
                else
                {
                    // BUG elsewhere in the product
                    //VSASSERT(false, "bad registry data: string contains embedded nul");
                    GetKeyNameForDiagnosticPurposes(Key, KeyNameForDiagnosticPurposes);

                    SIZE_T sizetcbData = (::wcslen(reinterpret_cast<PCWSTR>(pbData)) + 1) * sizeof(WCHAR);

                    FusionpDbgPrint(
                        "fusion_regkey2: bad registry data: string contains embedded nul%s, Key=%ls ValueName=%ls, ValueDataLength=0x%lx PossiblyExpectedValueDataLength=0x%Ix, ValueData=%wZ\n",
                        (pbData[rcbData - 1] == 0 && pbData[rcbData - 2] == 0) ? "" : " and no terminal nul at claimed length",
                        static_cast<PCWSTR>(KeyNameForDiagnosticPurposes),
                        ValueName,
                        rcbData,
                        sizetcbData,
                        &NtUnicodeString
                        );

                    // just reset the length down..
                    if (sizetcbData > MAXULONG)
                    {
                        VsOriginateError(ERROR_INSUFFICIENT_BUFFER);
                    }
                    rcbData = static_cast<ULONG>(sizetcbData);

                    // REVIEW should we set
                    // rcbData approx = (pchNul - pbData)..
                    // here and skip the next block?
                }
                // put in a terminal nul either way, in case a caller expects it, if there is room
                if (cbActualBufferSize >= sizeof(WCHAR))
                {
                    pchData[(cbActualBufferSize / sizeof(WCHAR)) - 1] = 0;
                }
            }
        }
    }
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::HrQueryValue

@mfunc
call RegQueryValueEx, expecting [REG_SZ, REG_EXPAND_SZ]
throws E_FAIL on type mismatch or returned FILE_NOT_FOUND is value doesn't exist

@owner AllenD
-----------------------------------------------------------------------------*/
HRESULT
F::CRegKey2::HrQueryValue
(
    PCWSTR    pszValueName, // @parm [in]  same as RegQueryValueEx
    F::CBaseStringBuffer* pstrValue    // @parm [out] 
) const throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    VsVerifyThrow(m_fValid, __FUNCTION__);

    if (!m_fMaxValueLengthValid)
    {
        ThrQueryValuesInfo
        (
            NULL, // pcValues,
            NULL, // pcchMaxValueNameLength,
            &m_cbMaxValueLength
        );
        m_fMaxValueLengthValid = true;
    }

    // first try with possibly invalid m_cbMaxValueLength
    { // scope to destroy bufferValue

        CStringW_CFixedSizeBuffer bufferValue(pstrValue, m_cbMaxValueLength / sizeof(WCHAR));
        DWORD dwType = REG_DWORD; // initialize to other than a type we want

        DWORD cbActualBufferSize = m_cbMaxValueLength;
        // Adjust down by one WCHAR so we have room to add a nul;
        // our own QueryValue already increased it by two WCHARs, so this is safe.
        DWORD cbData = cbActualBufferSize - sizeof(WCHAR);
        BYTE* pbData = reinterpret_cast<BYTE*>(static_cast<PWSTR>(bufferValue));

        ZeroMemory(pbData, cbActualBufferSize); // temporary aggressiveness
        bufferValue[0] = 0; // preset it to an empty string in case of bogosity
        bufferValue[cbData / sizeof(WCHAR)] = 0;

        LONG lRes = // and make the actual call
            ::RegQueryValueExW
            (
                m_hKey,
                pszValueName,
                NULL, // DWORD* reserved
                &dwType,
                pbData,
                &cbData
            );
        FixBadRegistryStringValue(m_hKey, pszValueName, cbActualBufferSize, lRes, dwType, pbData, &cbData);

        if (lRes != ERROR_SUCCESS && lRes != ERROR_MORE_DATA)
        {
            return HRESULT_FROM_WIN32(lRes);
        }
        // type check
        VsVerifyThrow
        (
            dwType == REG_SZ || dwType == REG_EXPAND_SZ,
            "registry type mismatch in VQueryValue(F::CBaseStringBuffer*)"
        );
        if (lRes == ERROR_SUCCESS)
        {
            return S_OK;
        }
        // lRes == ERROR_MORE_DATA
        // try once with larger buffer
        m_cbMaxValueLength = NVseeLibAlgorithm_RkMaximum(m_cbMaxValueLength, cbData);
        m_fMaxValueLengthValid = true;
    }

    // try again, copy/paste/edit above code
    // edit: we don't check for ERROR_MORE_DATA again
    // Race condition: if registry is being modified, growing, while we read it,
    // we fail to grow our buffer more than once.
    CStringW_CFixedSizeBuffer bufferValue(pstrValue, m_cbMaxValueLength / sizeof(WCHAR));
    DWORD dwType = REG_DWORD; // initialize to other than a type we want
    DWORD cbActualBufferSize = m_cbMaxValueLength;
    DWORD cbData = cbActualBufferSize - sizeof(WCHAR);
    BYTE* pbData = reinterpret_cast<BYTE*>(static_cast<PWSTR>(bufferValue));

    ZeroMemory(pbData, cbActualBufferSize); // temporary aggressiveness
    bufferValue[0] = 0; // preset it to an empty string in case of bogosity
    bufferValue[cbData / sizeof(WCHAR)] = 0;

    LONG lRes = // and make the actual call
        ::RegQueryValueExW
        (
            m_hKey,
            pszValueName,
            NULL, // DWORD* reserved
            &dwType,
            pbData,
            &cbData
        );
    FixBadRegistryStringValue(m_hKey, pszValueName, cbActualBufferSize, lRes, dwType, pbData, &cbData);
    // any error other than more data, throw without a type check
    if (lRes != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(lRes);
    }
    // type check
    VsVerifyThrow
    (
        dwType == REG_SZ || dwType == REG_EXPAND_SZ,
        "registry type mismatch in VQueryValue(F::CBaseStringBuffer*)"
    );

    return S_OK;
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::HrQueryValue

@mfunc
call RegQueryValueEx, expecting [REG_DWORD]
throws E_FAIL on type mismatch or returned FILE_NOT_FOUND is value doesn't exist

@owner a-peteco
-----------------------------------------------------------------------------*/
HRESULT
F::CRegKey2::HrQueryValue
(
    PCWSTR pszValueName,    // @parm [in]  same as RegQueryValueEx
    DWORD* pdwValue            // @parm [out] same as RegQueryValueEx for dwtype==REG_DWORD
) const throw(CErr)
{
    FN_PROLOG_HR;

    VsVerifyThrow(m_fValid, __FUNCTION__);
    VsVerifyThrow(pdwValue, __FUNCTION__);

    DWORD dwType = REG_SZ; // initialize to other than a type we want
    DWORD cbData = sizeof(DWORD);
    BYTE* pbData = reinterpret_cast<BYTE*>(pdwValue);

    IFREGFAILED_ORIGINATE_AND_EXIT(::RegQueryValueExW
        (
            m_hKey,
            pszValueName,
            NULL, // DWORD* reserved
            &dwType,
            pbData,
            &cbData
        ));

    // type check
    ASSERT2(dwType == REG_DWORD, "registry type mismatch in VQueryValue(F::CBaseStringBuffer*)");

    FN_EPILOG;
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrQueryInfo

@mfunc
this is a wrapper of ::RegQueryInfoExW, with its entire confusing
huge parameter list, including class, reserved, security, filetime..
it adds
 - throw
 - Win95 bug fix
 - pessimism over the possibility of REG_SZ missing terminal nul

@owner
-----------------------------------------------------------------------------*/
/*static*/ VOID
F::CRegKey2::ThrQueryInfo
(
    HKEY      hKey,
    WCHAR*    pClass,
    DWORD*    pcbClass,
    DWORD*    pReserved,
    DWORD*    pcSubKeys,
    DWORD*    pcchMaxSubKeyLength,
    DWORD*    pcchMaxClassLength,
    DWORD*    pcValues,
    DWORD*    pcchMaxValueNameLength,
    DWORD*      pcbMaxValueDataLength,
    DWORD*    pcbSecurityDescriptorLength,
    FILETIME* pftLastWriteTime
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    // all parameters can be NULL
    LONG lRes =
        ::RegQueryInfoKeyW
        (
            hKey,
            pClass,
            pcbClass,
            pReserved,
            pcSubKeys,
            pcchMaxSubKeyLength,
            pcchMaxClassLength,
            pcValues,
            pcchMaxValueNameLength,
            pcbMaxValueDataLength,
            pcbSecurityDescriptorLength,
            pftLastWriteTime
        );
    if (lRes != ERROR_SUCCESS)
    {
        NVseeLibError_VThrowWin32(lRes);
    }
    /* 
    This is supposedly required if the call is made on a remote Windows95 machine.
    It was done in \vs\src\vsee\pkgs\va\vsa\WizCompD.cpp, and the NT4sp3 code looks like:
        //
        // Check for a downlevel Win95 server, which requires
        // us to work around their BaseRegQueryInfoKey bugs.
        // They do not account for Unicode correctly.
        //
        if (IsWin95Server(DereferenceRemoteHandle(hKey),dwVersion)) {
            //
            // This is a Win95 server.
            // Double the maximum value name length and
            // maximum value data length to account for
            // the Unicode translation that Win95 forgot
            // to account for.
            //
            cbMaxValueNameLen *= sizeof(WCHAR);
            cbMaxValueLen *= sizeof(WCHAR);
        }
    notice they don't touch cbMaxSubKeyLen
    */
    if (pcchMaxSubKeyLength != NULL)
    {
        *pcchMaxSubKeyLength *= sizeof(WCHAR);

        // fudge some more
        *pcchMaxSubKeyLength += 3 * sizeof(WCHAR);
    }

    // Some REG_SZ values are missing their terminal nul, so add room for
    // some here so anyone that allocates a buffer based on this has room to add
    // the terminal nul. Add a second out of paranoia.
    if (pcbMaxValueDataLength != NULL)
    {
        *pcbMaxValueDataLength += 3 * sizeof(WCHAR);
    }
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrQueryValuesInfo

@mfunc
a subset of RegQueryInfoKey, that only returns information about values;
this is useful for users of RegEnumValue / CEnumValues

@owner
-----------------------------------------------------------------------------*/
/*static*/ VOID
F::CRegKey2::ThrQueryValuesInfo
(
    HKEY   hKey,                    // @parm [in] the HKEY to query value info rom
    DWORD* pcValues,                // @parm [out] can be NULL, parameter to RegQueryInfoKey
    DWORD* pcchMaxValueNameLength,  // @parm [out] can be NULL, parameter to RegQueryInfoKey
    DWORD* pcbMaxValueDataLength    // @parm [out] can be NULL, parameter to RegQueryInfoKey
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    ThrQueryInfo
    (
        hKey,
        NULL, // pClass,
        NULL, // pcbClass,
        NULL, // pReserved,
        NULL, // pcSubKeys,
        NULL, // pcchMaxSubKeyLength,
        NULL, // pcchMaxClassLength,
        pcValues,
        pcchMaxValueNameLength,
        pcbMaxValueDataLength,
        NULL, // pcbSecurityDescriptorLength,
        NULL  // pftLastWriteTime
    );
    // fudge them up a bit
    if (pcchMaxValueNameLength != NULL)
    {
        *pcchMaxValueNameLength += 3 * sizeof(WCHAR);
    }
    if (pcbMaxValueDataLength != NULL)
    {
        *pcbMaxValueDataLength += 3 * sizeof(WCHAR);
    }
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrQuerySubKeysInfo

@mfunc
a subset of RegQueryInfoKey, that only returns information about subkeys;
this is useful for users of RegEnumKeyEx / CEnumKeys

@owner
-----------------------------------------------------------------------------*/
/*static*/ VOID
F::CRegKey2::ThrQuerySubKeysInfo
(
    HKEY   hKey,                    // @parm [in] the HKEY to query value info rom
    DWORD* pcSubKeys,                // @parm [out] can be NULL, parameter to RegQueryInfoKey
    DWORD* pcchMaxSubKeyLength   // @parm [out] can be NULL, parameter to RegQueryInfoKey
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    ThrQueryInfo
    (
        hKey,
        NULL, // pClass,
        NULL, // pcbClass,
        NULL, // pReserved,
        pcSubKeys,
        pcchMaxSubKeyLength,
        NULL, // pcchMaxClassLength,
        NULL, // pcValues,
        NULL, // pcchMaxValueNameLength,
        NULL, // pcbMaxValueDataLength,
        NULL, // pcbSecurityDescriptorLength,
        NULL  // pftLastWriteTime
    );
    // fudge them up a bit
    if (pcchMaxSubKeyLength != NULL)
    {
        *pcchMaxSubKeyLength += 3 * sizeof(WCHAR);
    }
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrQueryValuesInfo

@mfunc
a subset of RegQueryInfoKey, that only returns information about values;
this is useful for users of RegEnumValue / CEnumValues

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::ThrQueryValuesInfo
(
    DWORD* pcValues,                // @parm [out] can be NULL, parameter to RegQueryInfoKey
    DWORD* pcchMaxValueNameLength,  // @parm [out] can be NULL, parameter to RegQueryInfoKey
    DWORD* pcbMaxValueLength            // @parm [out] can be NULL, parameter to RegQueryInfoKey
) const throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    ThrQueryValuesInfo(*this, pcValues, pcchMaxValueNameLength, pcbMaxValueLength);
}


/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrEnumValue

@mfunc
call RegEnumValue; consumed by CEnumValues

@owner
-----------------------------------------------------------------------------*/
/*static*/ VOID
F::CRegKey2::ThrEnumValue
(
    HKEY hKey,                      // @parm [in] parameter to RegEnumValue
    DWORD  dwIndex,                 // @parm [in] parameter to RegEnumValue
    PWSTR  pszValueName,            // @parm [in] can be NULL, parameter to RegEnumValue
    DWORD* pcchValueNameLength,     // @parm [out] can be NULL, parameter to RegEnumValue
    DWORD* pdwType,                 // @parm [out] can be NULL, parameter to RegEnumValue
    BYTE*  pbData,                  // @parm [out] can be NULL, parameter to RegEnumValue
    DWORD* pcbData                  // @parm [in out] can be NULL, parameter to RegEnumValue
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    DWORD cbActualBufferSize = 0;
    if (pcbData != NULL)
    {
        cbActualBufferSize = *pcbData;
    }
    LONG lRes =
        ::RegEnumValueW
        (
            hKey,
            dwIndex,
            pszValueName,
            pcchValueNameLength,
            NULL, // DWORD* reserved,
            pdwType,
            pbData,
            pcbData
        );
    if (pdwType != NULL && pcbData != NULL)
    {
        FixBadRegistryStringValue(hKey, pszValueName, cbActualBufferSize, lRes, *pdwType, pbData, pcbData);
    }
    if (lRes != ERROR_SUCCESS)
    {
        NVseeLibError_VThrowWin32(lRes);
    }
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::RegEnumKey

@mfunc
call RegEnumKeyEx; consumed by CEnumKeys

@owner
-----------------------------------------------------------------------------*/
/*static*/ LONG
F::CRegKey2::RegEnumKey
(
    HKEY   hKey,                // @parm [in] parameter to RegEnumKeyEx
    DWORD  dwIndex,             // @parm [in] parameter to RegEnumKeyEx
    PWSTR  pszSubKeyName,       // @parm [out] parameter to RegEnumKeyEx
    DWORD* pcchSubKeyNameLength // @parm [out] parameter to RegEnumKeyEx
) throw(CErr)
{
    VSEE_ASSERT_CAN_THROW();
    FILETIME ftIgnoreLastWriteTime = { 0, 0 };
    LONG lRes =
        ::RegEnumKeyExW
        (
            hKey,
            dwIndex,
            pszSubKeyName,
            pcchSubKeyNameLength,
            NULL, // reserved
            NULL, // class
            NULL, // cbClass
            &ftIgnoreLastWriteTime
        );
    return lRes;
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrEnumKey

@mfunc
call RegEnumKeyEx; consumed by CEnumKeys

@owner
-----------------------------------------------------------------------------*/
/*static*/ VOID
F::CRegKey2::ThrEnumKey
(
    HKEY   hKey,                // @parm [in] parameter to RegEnumKeyEx
    DWORD  dwIndex,             // @parm [in] parameter to RegEnumKeyEx
    PWSTR  pszSubKeyName,       // @parm [out] parameter to RegEnumKeyEx
    DWORD* pcchSubKeyNameLength // @parm [out] parameter to RegEnumKeyEx
) throw(CErr)
{
    LONG lRes = RegEnumKey(hKey, dwIndex, pszSubKeyName, pcchSubKeyNameLength);
    if (lRes != ERROR_SUCCESS)
    {
        NVseeLibError_VThrowWin32(lRes);
    }
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::ThrRecurseDeleteKey

@mfunc
Recursively deletes a subkey.

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::ThrRecurseDeleteKey(LPCWSTR lpszKey)
{
    VSEE_ASSERT_CAN_THROW();
    VsVerifyThrowHr(lpszKey != NULL, "lpszKey is NULL", E_UNEXPECTED);
    VSASSERT(!m_fKnownSam || (m_samDesired & KEY_WRITE), "Attempt to delete key contents when key not opened with KEY_WRITE");

    F::CRegKey2 key;
    key.ThrOpen(m_hKey, lpszKey, KEY_READ | KEY_WRITE);

    FILETIME time;
    DWORD dwSize = 256;
    WCHAR szBuffer[256];
    while (::RegEnumKeyExW(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
        &time)==ERROR_SUCCESS)
    {
        key.ThrRecurseDeleteKey(szBuffer);
        dwSize = 256;
    }
    DeleteSubKey(lpszKey);
}

/*-----------------------------------------------------------------------------
Name: CRegKey2::DeleteSubKey

@mfunc
Deletes a subkey underneath the current key.  Basically a wrapper for RegDeleteKey.
Used by ThrRecurseDeleteKey

@owner
-----------------------------------------------------------------------------*/
VOID
F::CRegKey2::DeleteSubKey(LPCWSTR lpszSubKey)
{
    VSEE_ASSERT_CAN_THROW();
    VsVerifyThrowHr(lpszSubKey != NULL, "lpszSubKey is NULL", E_UNEXPECTED);
    VsVerifyThrowHr(m_hKey != NULL, "m_hKey is NULL", E_UNEXPECTED);
    VSASSERT(!m_fKnownSam || (m_samDesired & KEY_SET_VALUE), "Attempt to set value when key not opened with KEY_SET_VALUE");

    ::RegDeleteKeyW(m_hKey, lpszSubKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

MAJORCOMP=fusion
MINORCOMP=utils

TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)utils
TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)

INCLUDES= \
 ..; \
 $(FUSION_INC_PATH); \
 $(FUSION_PATH)\inc; \
 $(FUSION_PATH)\external\inc; \
 $(FUSION_PATH)\directdb\inc; \
 $(FUSION_PATH)\directdb\inc\$(O); \
 $(FUSION_PATH)\idl\$(O); \
 $(FUSION_PATH)\eventlog\whistler\$(O); \
 $(INCLUDES); \
 $(COM_INC_PATH); \
 $(PROJECT_ROOT)\ntos\rtl; \
 $(PROJECT_ROOT)\ntos\inc; \

SOURCES= \
 ..\culture.cpp \
 ..\helpers.cpp \
 ..\SxsExceptionHandling.cpp \
 ..\debug.cpp \
 ..\formatting.cpp \
 ..\fusionhashstring.cpp \
 ..\fusionheap.cpp \
 ..\fusionreg.cpp \
 ..\fusionreg2.cpp \
 ..\io.cpp \
 ..\ntdllwrap.cpp \
 ..\parser.cpp \
 ..\regenumkeys.cpp \
 ..\regenumvalues.cpp \
 ..\regkey2.cpp \
 ..\trace.cpp \
 ..\parser.cpp \
 ..\xmlns.cpp \
 ..\fusionsha1.cpp \
 ..\bigpath.cpp \
 ..\checkSetupMode.cpp \
 ..\fusioninitializecriticalsection.cpp \
 ..\isprint.c \
 ..\vseeport.cpp \

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\vseeport.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    vseeport.cpp

Abstract:
    for porting code from vsee
 
Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/
#include "stdinc.h"
#include "vseeport.h"

void NVseeLibError_VCheck(HRESULT hr)
{
    if (SUCCEEDED(hr))
        return;
    FN_PROLOG_VOID_THROW;
    ORIGINATE_COM_FAILURE_AND_EXIT(NVseeLibError_VCheck, hr);
    FN_EPILOG_THROW;
}

void NVseeLibError_VThrowWin32(DWORD dw)
{
    FN_PROLOG_VOID_THROW;
    ORIGINATE_WIN32_FAILURE_AND_EXIT(NVseeLibError_VThrowWin32, dw);
    FN_EPILOG_THROW;
}

void VsOriginateError(HRESULT hr)
{
    FN_PROLOG_VOID_THROW;
    ORIGINATE_COM_FAILURE_AND_EXIT(VsOriginateError, hr);
    FN_EPILOG_THROW;
}

void FusionpOutOfMemory()
{
    FN_PROLOG_VOID_THROW;
    ORIGINATE_WIN32_FAILURE_AND_EXIT(FusionpOutOfMemory, FUSION_WIN32_ALLOCFAILED_ERROR);
    FN_EPILOG_THROW;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\sxsexceptionhandling.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsexceptionhandling.cpp

Abstract:

Author:

    Jay Krell (a-JayK, JayKrell) October 2000

Revision History:

--*/
#include "stdinc.h"
#include <stdio.h>

LONG
SxspExceptionFilter(
    PEXCEPTION_POINTERS ExceptionPointers,
    PCSTR Function
    )
{

    // add handling for unhandled status in RtlUnhandledExceptionFilter

    switch ( ExceptionPointers->ExceptionRecord->ExceptionCode )
    {
    case STATUS_NO_MEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        return EXCEPTION_EXECUTE_HANDLER;
    default:
        break;
    }

#if defined(FUSION_WIN)
    INT i = ::FusionpRtlUnhandledExceptionFilter(ExceptionPointers);
    if (i == EXCEPTION_CONTINUE_SEARCH)
    {
        i = EXCEPTION_EXECUTE_HANDLER;
    }
    return i;
#else
    // ISSUE:2002-03-14:jonwis It always seemed to me like you should do snprintf and then
    //      stomp in the null termination, rather than the other way around.
    char buf[64];
    buf[RTL_NUMBER_OF(buf) - 1] = 0;
    ::_snprintf(buf, RTL_NUMBER_OF(buf) - 1, "** Unhandled exception 0x%x\n", ExceptionPointers->ExceptionRecord->ExceptionCode);
    ::OutputDebugStringA(buf);
#if DBG
    ::_snprintf(buf, RTL_NUMBER_OF(buf) - 1, "** .exr %p\n", ExceptionPointers->ExceptionRecord);
    ::OutputDebugStringA(buf);
    ::_snprintf(buf, RTL_NUMBER_OF(buf) - 1, "** .cxr %p\n", ExceptionPointers->ContextRecord);
    ::OutputDebugStringA(buf);
    ::DebugBreak();
#endif
    return EXCEPTION_EXECUTE_HANDLER;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\uuid\fusion_uuid.c ===
typedef int pragma_warning_disable_4206_nonstandard_extension_used_translation_unit_is_empty;
#include <fusion_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\stdinc.h ===
#pragma once
#include "excpt.h"
#include <stdarg.h>

#if !defined(FUSION_STATIC_NTDLL)
#if FUSION_WIN
#define FUSION_STATIC_NTDLL 1
#else
#define FUSION_STATIC_NTDLL 0
#endif // FUSION_WIN
#endif // !defined(FUSION_STATIC_NTDLL)
#if !FUSION_STATIC_NTDLL
#include "ntdef.h"
#undef NTSYSAPI
#define NTSYSAPI /* nothing */
#endif

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include "fusionntdll.h"

#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define MAXDWORD (~(DWORD)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\xmlns.cpp ===
#include "stdinc.h"
#include "debmacro.h"
#include "xmlns.h"
#include "fusionheap.h"
#include "smartptr.h"

CXMLNamespaceManager::CXMLNamespaceManager(
    ) : m_CurrentDepth(0),
        m_DefaultNamespacePrefix(NULL)
{
}

CXMLNamespaceManager::~CXMLNamespaceManager()
{
    CSxsPreserveLastError ple;
    CNamespacePrefix *pCurrent = m_DefaultNamespacePrefix;

    // Clean up any namespace prefixes hanging around...
    while (pCurrent != NULL)
    {
        CNamespacePrefix *pNext = pCurrent->m_Previous;
        FUSION_DELETE_SINGLETON(pCurrent);
        pCurrent = pNext;
    }

    m_DefaultNamespacePrefix = NULL;

    CStringPtrTableIter<CNamespacePrefix, CUnicodeCharTraits> iter(m_NamespacePrefixes);

    for (iter.Reset(); iter.More(); iter.Next())
        iter.Delete();

    ple.Restore();
}

BOOL
CXMLNamespaceManager::Initialize()
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT(m_NamespacePrefixes.Initialize());
    FN_EPILOG
}

HRESULT
CXMLNamespaceManager::OnCreateNode(
    IXMLNodeSource *pSource,
    PVOID pNodeParent,
    USHORT cNumRecs,
    XML_NODE_INFO **apNodeInfo
    )
{
    FN_PROLOG_HR

    USHORT i;
    CSmartPtr<CNamespacePrefix> NamespacePrefix;

    if ((cNumRecs != 0) &&
        (apNodeInfo[0]->dwType == XML_ELEMENT))
    {
        m_CurrentDepth++;

        for (i=0; i<cNumRecs; i++)
        {
            XML_NODE_INFO *Node = apNodeInfo[i];
            if (Node->dwType == XML_ATTRIBUTE)
            {
                if (Node->ulLen >= 5)
                {
                    PCWSTR pwcText = Node->pwcText;

                    // if it's not prefixed by "xmlns", we're not interested.
                    if ((pwcText[0] != L'x') ||
                        (pwcText[1] != L'm') ||
                        (pwcText[2] != L'l') ||
                        (pwcText[3] != L'n') ||
                        (pwcText[4] != L's'))
                        continue;

                    // If it's longer than 5 characters and the next character isn't
                    // a colon, it's not interesting.
                    if ((Node->ulLen > 5) && (pwcText[5] != L':'))
                        continue;

                    IFW32FALSE_EXIT(NamespacePrefix.Win32Allocate(__FILE__, __LINE__));

                    // walk the subsequent nodes, concatenating the values...

                    i++;

                    while (i < cNumRecs)
                    {
                        if (apNodeInfo[i]->dwType != XML_PCDATA)
                            break;

                        IFW32FALSE_EXIT(NamespacePrefix->m_NamespaceURI.Win32Append(apNodeInfo[i]->pwcText, apNodeInfo[i]->ulLen));
                        i++;
                    }

                    i--;

                    NamespacePrefix->m_Depth = m_CurrentDepth;

                    if (Node->ulLen == 5)
                    {
                        NamespacePrefix->m_Previous = m_DefaultNamespacePrefix;
                        m_DefaultNamespacePrefix = NamespacePrefix.Detach();
                    }
                    else
                    {
                        CSmallStringBuffer TextBuffer;
                        
                        // Unfortunately, we need the node name in a null terminated buffer.  I tried modifying the hash
                        // table code to handle more than one parameter for a key being passed through, but it ended
                        // up being too much work.
                        IFW32FALSE_EXIT(TextBuffer.Win32Assign(pwcText + 6, Node->ulLen - 6));

                        IFW32FALSE_EXIT(
                            m_NamespacePrefixes.InsertOrUpdateIf<CXMLNamespaceManager>(
                                TextBuffer,
                                NamespacePrefix.Detach(),
                                this,
                                &CXMLNamespaceManager::InsertOrUpdateIfCallback));
                    }
                }
            }
        }
    }

    FN_EPILOG
}

HRESULT
CXMLNamespaceManager::OnBeginChildren(
    IXMLNodeSource *pSource,
    XML_NODE_INFO *pNodeInfo
    )
{
    // Nothing to do today, but we'll still have people reflect it through us so that we can do something
    // in the future if we need to.
    return S_OK;
}

HRESULT
CXMLNamespaceManager::OnEndChildren(
    IXMLNodeSource *pSource,
    BOOL fEmpty,
    XML_NODE_INFO *pNodeInfo
    )
{
    FN_PROLOG_HR;

    // Pop everything relevant off for this depth...

    if (m_DefaultNamespacePrefix != NULL)
    {
        if (m_DefaultNamespacePrefix->m_Depth == m_CurrentDepth)
        {
            CNamespacePrefix *Previous = m_DefaultNamespacePrefix->m_Previous;
            FUSION_DELETE_SINGLETON(m_DefaultNamespacePrefix);
            m_DefaultNamespacePrefix = Previous;
        }
    }

    CStringPtrTableIter<CNamespacePrefix, CUnicodeCharTraits> iter(m_NamespacePrefixes);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        CNamespacePrefix *NamespacePrefix = iter;

        if (NamespacePrefix->m_Depth == m_CurrentDepth)
        {
            if (NamespacePrefix->m_Previous != NULL)
                iter.Update(NamespacePrefix->m_Previous);
            else{
                iter.Delete();
                NamespacePrefix = NULL;
            }

            FUSION_DELETE_SINGLETON(NamespacePrefix);
        }
    }

    m_CurrentDepth--;

    FN_EPILOG
}

HRESULT
CXMLNamespaceManager::Map(
    DWORD dwMapFlags,
    const XML_NODE_INFO *pNodeInfo,
    CBaseStringBuffer *pbuffNamespace,
    SIZE_T *pcchNamespacePrefix
    )
{
    HRESULT hr = E_FAIL;
    FN_TRACE_HR(hr);
    SIZE_T iColon;
    SIZE_T ulLen;
    PCWSTR pwcText;
    CNamespacePrefix *NamespacePrefix = NULL;

    if (pcchNamespacePrefix != NULL)
        *pcchNamespacePrefix = 0;

    PARAMETER_CHECK((dwMapFlags & ~(CXMLNamespaceManager::eMapFlag_DoNotApplyDefaultNamespace)) == 0);
    PARAMETER_CHECK(pNodeInfo != NULL);
    PARAMETER_CHECK(pbuffNamespace != NULL);
    PARAMETER_CHECK(pcchNamespacePrefix != NULL);

    ulLen = pNodeInfo->ulLen;
    pwcText = pNodeInfo->pwcText;

    // First let's see if there's a colon in the name.  We can't use wcschr() since it's not
    // null terminated.
    for (iColon=0; iColon<ulLen; iColon++)
    {
        if (pwcText[iColon] == L':')
            break;
    }

    // If there was no namespace prefix, apply the default, if there is one.
    if (iColon == ulLen)
    {
        // Unless they asked us not to, apply the default namespace...
        if ((dwMapFlags & CXMLNamespaceManager::eMapFlag_DoNotApplyDefaultNamespace) == 0)
            NamespacePrefix = m_DefaultNamespacePrefix;
    }
    else
    {
        // Ok, so there was a namespace prefix.  Look it up in the table...
        CCountedStringHolder<CUnicodeCharTraits> key;

        key.m_psz = pwcText;
        key.m_cch = iColon;

        if (!m_NamespacePrefixes.Find(key, NamespacePrefix))
        {
            hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
            goto Exit;
        }
    }

    if (NamespacePrefix != NULL)
        IFW32FALSE_EXIT(pbuffNamespace->Win32Assign(NamespacePrefix->m_NamespaceURI));

    if ((pcchNamespacePrefix != NULL) && (iColon != ulLen))
        *pcchNamespacePrefix = iColon;

    hr = NOERROR;

Exit:
    return hr;
}

BOOL
CXMLNamespaceManager::InsertOrUpdateIfCallback(
    CNamespacePrefix *NewNamespacePrefix,
    CNamespacePrefix * const &rpOldNamespacePrefix,
    InsertOrUpdateIfDisposition &Disposition
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(rpOldNamespacePrefix != NULL);
    INTERNAL_ERROR_CHECK(NewNamespacePrefix != NULL);

    NewNamespacePrefix->m_Previous = rpOldNamespacePrefix;
    Disposition = eUpdateValue;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


CXMLNamespaceManager::CNamespacePrefix::CNamespacePrefix(
    ) :
    m_Depth(0),
    m_Previous(NULL)
{
}

CXMLNamespaceManager::CNamespacePrefix::~CNamespacePrefix()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\uuid\fuspriv_uuid.c ===
typedef int pragma_warning_disable_4206_nonstandard_extension_used_translation_unit_is_empty;
#include <fuspriv_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\utils\trace.cpp ===
#include "stdinc.h"
#include <limits.h>
#include "fusiontrace.h"
#include <stdio.h>
#include "fusionheap.h"
#include "imagehlp.h"
#include "debmacro.h"
#include "util.h"

//
// ISSUE: jonwis 3/12/2002 - We use an awful lot of stack in some places.  Whenever we form up
//          strings to pass to OutputDebugStringA, we tend to use 256/512-char buffers.  However,
//          OutputDebugStringA -also- contains a 512-byte buffer in its __except handler when
//          no debugger is attached.  So, we'll suck up stack like crazy here on the error path,
//          which if we're under stress could cause us to fail printing diagnostic information
//
// ISSUE: jonwis 3/12/2002 - Seems like there's three implementations for each of the 'trace failure'
//          functions.  The one that does the work (takes a FRAME_INFO), the one that takes the
//          information in a parameter list and converts into a FRAME_INFO, and the one that takes
//          some simple parameter and uses the current FRAME_INFO plus that parameter for tracking.
//          What if we collapsed a few of these, or moved them into a header file for inlining
//          purposes?
//
// ISSUE: jonwis 3/12/2002 - Seems like there's N copies of code like FusionpTraceWin32FailureNoFormatting,
//          each of which are very slightly different (a different param here or there, calling
//          a different function, etc.)  I wonder if they could be merged into a single function with
//          more verbose parameters...
//
#if !defined(FUSION_BREAK_ON_BAD_PARAMETERS)
#define FUSION_BREAK_ON_BAD_PARAMETERS false
#endif // !defined(FUSION_BREAK_ON_BAD_PARAMETERS);

bool g_FusionBreakOnBadParameters = FUSION_BREAK_ON_BAD_PARAMETERS;

//
// ISSUE: jonwis 3/12/2002 - This file handle never gets CreateFile'd or CloseHandle'd anywhere
//          in current source.  There's a lot of code that relies on this handle being valid or
//          invalid to run.  Should we maybe get rid of this?
//
static HANDLE s_hFile; // trace file handle

#if DBG
#define FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(hr) /* nothing */
#else
bool FusionpSuppressErrorReportInOsSetup(HRESULT hr)
{
    //
    // Some of these are unfortunately expected (early) in guimode setup, actually
    // concurrent with early guimode setup, but not otherwise.
    //
    if (   hr != HRESULT_FROM_WIN32(ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED)
        && hr != HRESULT_FROM_WIN32(ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED)
        )
        return false;
    BOOL fAreWeInOSSetupMode = FALSE;
    //
    // If we can't determine this, then let the first error through.
    //
    if (!::FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode))
        return false;
    if (!fAreWeInOSSetupMode)
        return false;
    return true;
}
#define FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(hr) if (FusionpSuppressErrorReportInOsSetup(hr)) return;
#endif

// ISSUE-03/26/2002-xiaoyuw
//  FusionpGetActiveFrameInfo could call FusionpPopulateFrameInfo after it gets value of ptaf, 
//  instead of repeat the same code.

bool
__fastcall
FusionpGetActiveFrameInfo(
    FRAME_INFO &rFrameInfo
    )
{
    bool fFoundAnyData = false;

    rFrameInfo.pszFile = "";
    rFrameInfo.pszFunction = "";
    rFrameInfo.nLine = 0;

    const PTEB_ACTIVE_FRAME ptaf =
#if FUSION_WIN
        ::RtlGetFrame();
#else
        NULL;
#endif

    const PTEB_ACTIVE_FRAME_EX ptafe =
        ((ptaf != NULL) && (ptaf->Flags & TEB_ACTIVE_FRAME_FLAG_EXTENDED)) ? 
            reinterpret_cast<PTEB_ACTIVE_FRAME_EX>(ptaf) : NULL;

    if (ptaf != NULL)
    {
        if (ptaf->Context != NULL)
        {
            if (ptaf->Context->FrameName != NULL)
            {
                rFrameInfo.pszFunction = ptaf->Context->FrameName;
                fFoundAnyData = true;
            }

            if (ptaf->Context->Flags & TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED)
            {
                const PCTEB_ACTIVE_FRAME_CONTEXT_EX ptafce =
                    reinterpret_cast<PCTEB_ACTIVE_FRAME_CONTEXT_EX>(ptaf->Context);

                if (ptafce->SourceLocation != NULL)
                {
                    rFrameInfo.pszFile = ptafce->SourceLocation;
                    fFoundAnyData = true;
                }
            }
        }
    }

    // If this is one of our frames, we can even downcast and get the line number...
    if ((ptafe != NULL) && (ptafe->ExtensionIdentifier == (PVOID) (' sxS')))
    {
        const CFrame *pFrame = static_cast<CFrame *>(ptafe);
        if (pFrame->m_nLine != 0)
        {
            rFrameInfo.nLine = pFrame->m_nLine;
            fFoundAnyData = true;
        }
    }

    return fFoundAnyData;
}

bool
__fastcall
FusionpPopulateFrameInfo(
    FRAME_INFO &rFrameInfo,
    PCTEB_ACTIVE_FRAME ptaf
    )
{
    bool fFoundAnyData = false;

    rFrameInfo.pszFile = "";
    rFrameInfo.pszFunction = "";
    rFrameInfo.nLine = 0;

    const PCTEB_ACTIVE_FRAME_EX ptafe =
        ((ptaf != NULL) && (ptaf->Flags & TEB_ACTIVE_FRAME_FLAG_EXTENDED)) ? 
            reinterpret_cast<PCTEB_ACTIVE_FRAME_EX>(ptaf) : NULL;

    if (ptaf != NULL)
    {
        if (ptaf->Context != NULL)
        {
            if (ptaf->Context->FrameName != NULL)
            {
                rFrameInfo.pszFunction = ptaf->Context->FrameName;
                fFoundAnyData = true;
            }

            if (ptaf->Context->Flags & TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED)
            {
                const PCTEB_ACTIVE_FRAME_CONTEXT_EX ptafce =
                    reinterpret_cast<PCTEB_ACTIVE_FRAME_CONTEXT_EX>(ptaf->Context);

                if (ptafce->SourceLocation != NULL)
                {
                    rFrameInfo.pszFile = ptafce->SourceLocation;
                    fFoundAnyData = true;
                }
            }
        }
    }

    // If this is one of our frames, we can even downcast and get the line number...
    if ((ptafe != NULL) && (ptafe->ExtensionIdentifier == ((PVOID) (' sxS'))))
    {
        const CFrame *pFrame = static_cast<const CFrame *>(ptafe);
        if (pFrame->m_nLine != 0)
        {
            rFrameInfo.nLine = pFrame->m_nLine;
            fFoundAnyData = true;
        }
    }

    return fFoundAnyData;
}

bool
FusionpPopulateFrameInfo(
    FRAME_INFO &rFrameInfo,
    PCSTR pszFile,
    PCSTR pszFunction,
    INT nLine
    )
{
    bool fFoundAnyData = false;

    if (pszFile != NULL)
    {
        rFrameInfo.pszFile = pszFile;
        fFoundAnyData = true;
    }
    else
        rFrameInfo.pszFile = NULL;

    if (nLine != 0)
        fFoundAnyData = true;

    rFrameInfo.nLine = nLine;

    if (pszFunction != NULL)
    {
        rFrameInfo.pszFunction = pszFunction;
        fFoundAnyData = true;
    }
    else
        rFrameInfo.pszFunction = NULL;

    return fFoundAnyData;
}

int STDAPIVCALLTYPE _DebugTraceA(LPCSTR pszMsg, ...)
{
    int iResult;
    va_list ap;
    va_start(ap, pszMsg);
    iResult = _DebugTraceExVaA(0, TRACETYPE_INFO, NOERROR, pszMsg, ap);
    va_end(ap);
    return iResult;
}

int STDAPICALLTYPE
_DebugTraceVaA(LPCSTR pszMsg, va_list ap)
{
    return _DebugTraceExVaA(0, TRACETYPE_INFO, NOERROR, pszMsg, ap);
}

int STDAPIVCALLTYPE
_DebugTraceExA(DWORD dwFlags, TRACETYPE tt, HRESULT hr, LPCSTR pszMsg, ...)
{
    int iResult;
    va_list ap;
    va_start(ap, pszMsg);
    iResult = _DebugTraceExVaA(dwFlags, tt, hr, pszMsg, ap);
    va_end(ap);
    return iResult;
}

int STDAPICALLTYPE
_DebugTraceExVaA(DWORD dwFlags, TRACETYPE tt, HRESULT hr, LPCSTR pszMsg, va_list ap)
{
    CSxsPreserveLastError ple;
    CHAR szBuffer[512];
    CHAR szMsgBuffer[512];
    static const char szFormat_Info_NoFunc[] = "%s(%d): Message: \"%s\"\n";
    static const char szFormat_Info_Func[] = "%s(%d): Function %s. Message: \"%s\"\n";
    static const char szFormat_CallEntry[] = "%s(%d): Entered %s\n";
    static const char szFormat_CallExitVoid[] = "%s(%d): Exited %s\n";
    static const char szFormat_CallExitHRESULT[] = "%s(%d): Exited %s with HRESULT 0x%08lx\n";

    FRAME_INFO FrameInfo;

    szMsgBuffer[0] = '\0';

    if (pszMsg != NULL)
    {
        ::_vsnprintf(szMsgBuffer, NUMBER_OF(szMsgBuffer), pszMsg, ap);
        szMsgBuffer[NUMBER_OF(szMsgBuffer) - 1] = '\0';
    }

    ::FusionpGetActiveFrameInfo(FrameInfo);

    switch (tt)
    {
    default:
    case TRACETYPE_INFO:
        //ISSUE-03/26/2002-xiaoyuw
        //  FrameInfo.pszFunction is set to be "\0", never NULL by FusionpGetActiveFrameInfo
        if (FrameInfo.pszFunction != NULL)
            ::_snprintf(szBuffer, NUMBER_OF(szBuffer), szFormat_Info_Func, FrameInfo.pszFile, FrameInfo.nLine, FrameInfo.pszFunction, szMsgBuffer);
        else
            ::_snprintf(szBuffer, NUMBER_OF(szBuffer), szFormat_Info_NoFunc, FrameInfo.pszFile, FrameInfo.nLine, szMsgBuffer);
        break;

    case TRACETYPE_CALL_START:
        ::_snprintf(szBuffer, NUMBER_OF(szBuffer), szFormat_CallEntry, FrameInfo.pszFile, FrameInfo.nLine, FrameInfo.pszFunction);
        break;

    case TRACETYPE_CALL_EXIT_NOHRESULT:
        ::_snprintf(szBuffer, NUMBER_OF(szBuffer), szFormat_CallExitVoid, FrameInfo.pszFile, FrameInfo.nLine, FrameInfo.pszFunction);
        break;

    case TRACETYPE_CALL_EXIT_HRESULT:
        ::_snprintf(szBuffer, NUMBER_OF(szBuffer), szFormat_CallExitHRESULT, FrameInfo.pszFile, FrameInfo.nLine, FrameInfo.pszFunction, hr);
        break;
    }

    szBuffer[NUMBER_OF(szBuffer) - 1] = '\0';

    ::OutputDebugStringA(szBuffer);

    ple.Restore();
    return 0;
}

VOID
FusionpTraceAllocFailure(
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    PCSTR pszExpression
    )
{
    CSxsPreserveLastError ple;
    CHAR szBuffer[512];
    ::_snprintf(szBuffer, NUMBER_OF(szBuffer), "%s(%d): Memory allocation failed in function %s\n   Expression: %s\n", pszFile, nLine, pszFunction, pszExpression);
    szBuffer[NUMBER_OF(szBuffer) - 1] = '\0';
    ::OutputDebugStringA(szBuffer);
    ple.Restore();
}

VOID
FusionpTraceAllocFailure(
    PCSTR pszExpression
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpGetActiveFrameInfo(FrameInfo);
    ::FusionpTraceAllocFailure(FrameInfo.pszFile, FrameInfo.nLine, FrameInfo.pszFunction, pszExpression);
}

VOID
FusionpTraceNull(
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    PCSTR pszExpression
    )
{
    CSxsPreserveLastError ple;
    CHAR szBuffer[512];
    ::_snprintf(szBuffer, NUMBER_OF(szBuffer), "%s(%d): Expression evaluated to NULL in function %s\n   Expression: %s\n", pszFile, nLine, pszFunction, pszExpression);
    szBuffer[NUMBER_OF(szBuffer) - 1] = '\0';
    ::OutputDebugStringA(szBuffer);
    ple.Restore();
}

VOID
FusionpTraceNull(
    PCSTR pszExpression
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpGetActiveFrameInfo(FrameInfo);
    ::FusionpTraceNull(FrameInfo.pszFile, FrameInfo.nLine, FrameInfo.pszFunction, pszExpression);
}

VOID
FusionpTraceZero(
    PCSTR pszFile,
    int nLine,
    PCSTR pszFunction,
    PCSTR pszExpression
    )
{
    CSxsPreserveLastError ple;
    CHAR szBuffer[512];
    ::_snprintf(szBuffer, NUMBER_OF(szBuffer), "%s(%d): Expression evaluated to zero in function %s\n   Expression: %s\n", pszFile, nLine, pszFunction, pszExpression);
    szBuffer[NUMBER_OF(szBuffer) - 1] = '\0';
    ::OutputDebugStringA(szBuffer);
    ple.Restore();
}

VOID
FusionpTraceZero(
    PCSTR pszExpression
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpGetActiveFrameInfo(FrameInfo);
    ::FusionpTraceZero(FrameInfo.pszFile, FrameInfo.nLine, FrameInfo.pszFunction, pszExpression);
}

VOID
FusionpTraceParameterCheck(
    const FRAME_INFO &rFrameInfo,
    PCSTR pszExpression
    )
{
    CSxsPreserveLastError ple;
    CHAR szBuffer[512];
    ::_snprintf(
        szBuffer,
        NUMBER_OF(szBuffer),
        "%s(%d): Input parameter validation failed in function %s\n   Validation expression: %s\n",
        rFrameInfo.pszFile,
        rFrameInfo.nLine,
        rFrameInfo.pszFunction,
        pszExpression);
    szBuffer[NUMBER_OF(szBuffer) - 1] = '\0';
    ::OutputDebugStringA(szBuffer);
    if (g_FusionBreakOnBadParameters)
        FUSION_DEBUG_BREAK_IN_FREE_BUILD();
    ple.Restore();
}

VOID
FusionpTraceParameterCheck(
    PCSTR pszFile,
    PCSTR pszFunction,
    int nLine,
    PCSTR pszExpression
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpPopulateFrameInfo(FrameInfo, pszFile, pszFunction, nLine);
    ::FusionpTraceParameterCheck(FrameInfo, pszExpression);
}

VOID
FusionpTraceParameterCheck(
    PCSTR pszExpression
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpGetActiveFrameInfo(FrameInfo);
    ::FusionpTraceParameterCheck(FrameInfo, pszExpression);
}

VOID
FusionpTraceInvalidFlags(
    const FRAME_INFO &rFrameInfo,
    DWORD dwFlagsPassed,
    DWORD dwFlagsExpected
    )
{
    CSxsPreserveLastError ple;

    //
    // ISSUE: jonwis 3/12/2002 - Places like this.  Why not throttle this back to print only the first
    //          N characters of the function name and the N last characters of the file name?  Then 
    //          we'd at least have a bounded number of characters to print ... 
    //
    CHAR szBuffer[512];

    ::_snprintf(
        szBuffer,
        NUMBER_OF(szBuffer),
        "%s(%d): Function %s received invalid flags\n"
        "   Flags passed:  0x%08lx\n"
        "   Flags allowed: 0x%08lx\n",
        rFrameInfo.pszFile, rFrameInfo.nLine, rFrameInfo.pszFunction,
        dwFlagsPassed,
        dwFlagsExpected);

    szBuffer[NUMBER_OF(szBuffer) - 1] = '\0';

    ::OutputDebugStringA(szBuffer);

    ple.Restore();
}

VOID
FusionpTraceInvalidFlags(
    PCSTR pszFile,
    PCSTR pszFunction,
    INT nLine,
    DWORD dwFlagsPassed,
    DWORD dwFlagsExpected
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpPopulateFrameInfo(FrameInfo, pszFile, pszFunction, nLine);
    ::FusionpTraceInvalidFlags(FrameInfo, dwFlagsPassed, dwFlagsExpected);
}

VOID
FusionpTraceInvalidFlags(
    DWORD dwFlagsPassed,
    DWORD dwFlagsExpected
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpGetActiveFrameInfo(FrameInfo);
    ::FusionpTraceInvalidFlags(FrameInfo, dwFlagsPassed, dwFlagsExpected);
}

void
FusionpGetProcessImageFileName(
    PUNICODE_STRING ProcessImageFileName
    )
{
#if !defined(FUSION_WIN)
    ProcessImageFileName->Length = 0;
#else
    USHORT PrefixLength;
    *ProcessImageFileName = NtCurrentPeb()->ProcessParameters->ImagePathName;

    if (NT_SUCCESS(RtlFindCharInUnicodeString(
            RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
            ProcessImageFileName,
            &RtlDosPathSeperatorsString,
            &PrefixLength)))
    {
        PrefixLength += sizeof(ProcessImageFileName->Buffer[0]);
        ProcessImageFileName->Length = static_cast<USHORT>(ProcessImageFileName->Length - PrefixLength);
        ProcessImageFileName->Buffer += PrefixLength / sizeof(ProcessImageFileName->Buffer[0]);
    }
#endif
}

class CFusionProcessImageFileName : public UNICODE_STRING
{
public:
    CFusionProcessImageFileName()
    {
        ::FusionpGetProcessImageFileName(this);
    }
};

//
// ISSUE: jonwis 3/12/2002 - Any good reason why we copy the CALL_SITE_INFO input struct into a
//          local?  Also, the call to snprintf to do string copying/concatenation seems very
//          overpowering.  Any reason that an strncpy won't work?  I thought snprintf did a
//          lot more work than necessary, up to and including having its own large stack
//          buffer(s)...
//
void __fastcall FusionpTraceWin32LastErrorFailureExV(const CALL_SITE_INFO &rCallSiteInfo, PCSTR Format, va_list Args)
{
    CSxsPreserveLastError ple;
    CHAR Buffer[256];
    CALL_SITE_INFO CallSiteInfo = rCallSiteInfo;
    CallSiteInfo.pszApiName = Buffer;
    SIZE_T i = 1;

    Buffer[0] = '\0';
    if (rCallSiteInfo.pszApiName != NULL && rCallSiteInfo.pszApiName[0] != '\0')
    {
        ::_snprintf(Buffer, NUMBER_OF(Buffer) - i, "%s", rCallSiteInfo.pszApiName);
        Buffer[NUMBER_OF(Buffer) - 1] = '\0';
        i = 1 + ::StringLength(Buffer);
    }
    if (i < NUMBER_OF(Buffer))
    {
        ::_vsnprintf(&Buffer[i - 1], NUMBER_OF(Buffer) - i, Format, Args);
        Buffer[NUMBER_OF(Buffer) - 1] = '\0';
    }

    ::FusionpTraceWin32LastErrorFailure(CallSiteInfo);

    ple.Restore();
}

//
// See above issue about copying the callsite locally.
//
void __fastcall FusionpTraceWin32LastErrorFailureOriginationExV(const CALL_SITE_INFO &rCallSiteInfo, PCSTR Format, va_list Args)
{
    CSxsPreserveLastError ple;
    CHAR Buffer[128];
    CALL_SITE_INFO CallSiteInfo = rCallSiteInfo;
    CallSiteInfo.pszApiName = Buffer;

    Buffer[0] = '\0';
    ::_vsnprintf(Buffer, NUMBER_OF(Buffer) - 1, Format, Args);
    Buffer[NUMBER_OF(Buffer) - 1] = '\0';

    ::FusionpTraceWin32LastErrorFailureOrigination(CallSiteInfo);

    ple.Restore();
}

void __fastcall FusionpTraceCOMFailure(const CALL_SITE_INFO &rSite, HRESULT hrLastError)
{
    CSxsPreserveLastError ple;
    CHAR szErrorBuffer[128];
    PCSTR pszFormatString = NULL;
    const DWORD dwThreadId = ::GetCurrentThreadId();
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(hrLastError);
    CFusionProcessImageFileName ProcessImageFileName;

    szErrorBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            hrLastError,                  // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable HRESULT %d (0x%08lx)>",
            hrLastError, hrLastError);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    if (rSite.pszApiName != NULL)
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] COM Error %d (%s) %s\n";
    else
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] COM Error %d (%s)\n";

    ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROREXITPATH, pszFormatString, rSite.pszFile, rSite.nLine,
        rSite.pszFunction, sizeof(PVOID) * CHAR_BIT, &ProcessImageFileName, dwThreadId,
        hrLastError, szErrorBuffer, rSite.pszApiName);

    ple.Restore();
}


void __fastcall
FusionpTraceWin32LastErrorFailure(
    const CALL_SITE_INFO &rSite
    )
{
    CSxsPreserveLastError ple;
    CHAR szErrorBuffer[128];
    PCSTR pszFormatString = NULL;
    const DWORD dwThreadId = ::GetCurrentThreadId();
    const DWORD dwWin32Status = ::FusionpGetLastWin32Error();
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(HRESULT_FROM_WIN32(dwWin32Status));
    CFusionProcessImageFileName ProcessImageFileName;

    szErrorBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            dwWin32Status,                  // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable Win32 status %d (0x%08lx)>",
            dwWin32Status, dwWin32Status);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    if (rSite.pszApiName != NULL)
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] Win32 Error %d (%s) %s\n";
    else
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] Win32 Error %d (%s)\n";

    ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROREXITPATH, pszFormatString, rSite.pszFile, rSite.nLine,
        rSite.pszFunction, sizeof(PVOID) * CHAR_BIT, &ProcessImageFileName, dwThreadId,
        dwWin32Status, szErrorBuffer, rSite.pszApiName);

    ple.Restore();
}



void __fastcall FusionpTraceCOMFailureOrigination(const CALL_SITE_INFO &rSite, HRESULT hrLastError)
{

    CSxsPreserveLastError ple;
    CHAR szErrorBuffer[128];
    PCSTR pszFormatString = NULL;
    const DWORD dwThreadId = ::GetCurrentThreadId();
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(hrLastError);
    CFusionProcessImageFileName ProcessImageFileName;

    szErrorBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            hrLastError,                  // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable HRESULT 0x%08lx>",
            hrLastError);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    if (rSite.pszApiName != NULL)
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx (%s) %s\n";
    else
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx (%s)\n";

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR, // FUSION_DBG_LEVEL_ERROR vs. FUSION_DBG_LEVEL_ERROREXITPATH
                                // is the difference between "origination" or not
                                // origination always prints in DBG, the point is to get only one line
                                // or the stack trace only one
        pszFormatString,
        rSite.pszFile,
        rSite.nLine,
        rSite.pszFunction,
        sizeof(PVOID)*CHAR_BIT,
        &ProcessImageFileName,
        dwThreadId,
        hrLastError,
        szErrorBuffer,
        rSite.pszApiName);

    ple.Restore();}



void
__fastcall
FusionpTraceWin32LastErrorFailureOrigination(
    const CALL_SITE_INFO &rSite
    )
{
    CSxsPreserveLastError ple;
    CHAR szErrorBuffer[128];
    PCSTR pszFormatString = NULL;
    const DWORD dwThreadId = ::GetCurrentThreadId();
    const DWORD dwWin32Status = ::FusionpGetLastWin32Error();
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(HRESULT_FROM_WIN32(dwWin32Status));
    CFusionProcessImageFileName ProcessImageFileName;

    szErrorBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            dwWin32Status,                  // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable Win32 status %d (0x%08lx)>",
            dwWin32Status, dwWin32Status);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    if (rSite.pszApiName != NULL)
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] Win32 Error %d (%s) %s\n";
    else
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] Win32 Error %d (%s)\n";

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR, // FUSION_DBG_LEVEL_ERROR vs. FUSION_DBG_LEVEL_ERROREXITPATH
                                // is the difference between "origination" or not
                                // origination always prints in DBG, the point is to get only one line
                                // or the stack trace only one
        pszFormatString,
        rSite.pszFile,
        rSite.nLine,
        rSite.pszFunction,
        sizeof(PVOID)*CHAR_BIT,
        &ProcessImageFileName,
        dwThreadId,
        dwWin32Status,
        szErrorBuffer,
        rSite.pszApiName);

    ple.Restore();
}

void
FusionpTraceWin32FailureNoFormatting(
    const FRAME_INFO &rFrameInfo,
    DWORD dwWin32Status,
    PCSTR pszMessage
    )
{
    CSxsPreserveLastError ple;
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(HRESULT_FROM_WIN32(dwWin32Status));
    CHAR szErrorBuffer[128];
    PCSTR pszFormatString = NULL;
    const DWORD dwThreadId = ::GetCurrentThreadId();
    CFusionProcessImageFileName ProcessImageFileName;

    szErrorBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            dwWin32Status,                  // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable Win32 status %d (0x%08lx)>",
            dwWin32Status, dwWin32Status);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    if (pszMessage != NULL)
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] Win32 Error %d (%s) %s\n";
    else
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] Win32 Error %d (%s)\n";

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROREXITPATH, pszFormatString, rFrameInfo.pszFile, rFrameInfo.nLine,
        rFrameInfo.pszFunction, sizeof(PVOID)*CHAR_BIT, &ProcessImageFileName, dwThreadId, dwWin32Status,
        szErrorBuffer, pszMessage
        );

    ple.Restore();
}

void
FusionpTraceWin32FailureOriginationNoFormatting(
    const FRAME_INFO &rFrameInfo,
    DWORD dwWin32Status,
    PCSTR pszMessage
    )
{
    CSxsPreserveLastError ple;
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(HRESULT_FROM_WIN32(dwWin32Status));
    CHAR szErrorBuffer[128];
    PCSTR pszFormatString = NULL;
    const DWORD dwThreadId = ::GetCurrentThreadId();
    CFusionProcessImageFileName ProcessImageFileName;

    szErrorBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            dwWin32Status,                  // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable Win32 status %d (0x%08lx)>",
            dwWin32Status, dwWin32Status);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    if (pszMessage != NULL)
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] Win32 Error %d (%s) %s\n";
    else
        pszFormatString = "%s(%lu): [function %s %Iubit process %wZ tid 0x%lx] Win32 Error %d (%s)\n";

    ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, pszFormatString, rFrameInfo.pszFile, rFrameInfo.nLine,
        rFrameInfo.pszFunction, sizeof(PVOID) * CHAR_BIT, &ProcessImageFileName, dwThreadId,
        dwWin32Status, szErrorBuffer, pszMessage);

    ple.Restore();
}

void
FusionpTraceWin32Failure(
    DWORD dwWin32Status,
    LPCSTR pszMsg,
    ...
    )
{
    va_list ap;
    va_start(ap, pszMsg);
    ::FusionpTraceWin32FailureVa(dwWin32Status, pszMsg, ap);
    va_end(ap);
}

void
FusionpTraceWin32FailureVa(
    const FRAME_INFO &rFrameInfo,
    DWORD dwWin32Status,
    LPCSTR pszMsg,
    va_list ap
    )
{
    CSxsPreserveLastError ple;

    CHAR szMessageBuffer[128];

    szMessageBuffer[0] = '\0';

    if (pszMsg != NULL)
        ::_vsnprintf(szMessageBuffer, NUMBER_OF(szMessageBuffer), pszMsg, ap);
    else
        szMessageBuffer[0] = '\0';

    szMessageBuffer[NUMBER_OF(szMessageBuffer) - 1] = '\0';

    ::FusionpTraceWin32FailureNoFormatting(rFrameInfo, dwWin32Status, szMessageBuffer);

    ple.Restore();
}

void
FusionpTraceWin32FailureVa(
    DWORD dwWin32Status,
    LPCSTR pszMsg,
    va_list ap
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpGetActiveFrameInfo(FrameInfo);
    ::FusionpTraceWin32FailureVa(FrameInfo, dwWin32Status, pszMsg, ap);
}

void
FusionpTraceWin32FailureVa(
    PCSTR pszFile,
    PCSTR pszFunction,
    INT nLine,
    DWORD dwWin32Status,
    LPCSTR pszMsg,
    va_list ap
    )
{
    FRAME_INFO FrameInfo;
    ::FusionpPopulateFrameInfo(FrameInfo, pszFile, pszFunction, nLine);
    ::FusionpTraceWin32FailureVa(FrameInfo, dwWin32Status, pszMsg, ap);
}

void
FusionpTraceCallCOMSuccessfulExit(
    HRESULT hrIn,
    PCSTR pszFormat,
    ...
    )
{
    va_list ap;
    va_start(ap, pszFormat);
    ::FusionpTraceCallCOMSuccessfulExitVa(hrIn, pszFormat, ap);
    va_end(ap);
}

void
FusionpTraceCallCOMSuccessfulExitSmall(
    HRESULT hrIn
    )
{
    /*
    This is a forked version of FusionpTraceCOMSuccessfulExitVaBig that we expect to get called.
    This function uses about 256 bytes of stack.
    FusionpTraceCOMSuccessfulExitVaBug uses about 1k of stack.
    */
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(hrIn);
    CHAR szErrorBuffer[256];
    const DWORD dwThreadId = ::GetCurrentThreadId();
    CFusionProcessImageFileName ProcessImageFileName;

    szErrorBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            hrIn,                           // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable(non-existed or too long) HRESULT: 0x%08lx>",
            hrIn);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    PCSTR pszFormatString = "%s(%d): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx\n";

    FRAME_INFO FrameInfo;
    ::FusionpGetActiveFrameInfo(FrameInfo);

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ENTEREXIT,
        pszFormatString,
        FrameInfo.pszFile,
        FrameInfo.nLine,
        FrameInfo.pszFunction,
        sizeof(PVOID) * CHAR_BIT,
        &ProcessImageFileName,
        dwThreadId,
        hrIn,
        szErrorBuffer);
}

void
FusionpTraceCallCOMSuccessfulExitVaBig(
    HRESULT hrIn,
    LPCSTR pszMsg,
    va_list ap
    )
{
    /*
    This is a forked version of FusionpTraceCOMSuccessfulExitVaSmall that we don't expect to get called.
    FusionpTraceCOMSuccessfulExitVaSmall uses about 256 bytes of stack.
    This function uses about 1k of stack.
    */
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(hrIn);
    CHAR szMsgBuffer[128];
    CHAR szErrorBuffer[128];
    CHAR szOutputBuffer[256];
    PCSTR pszFormatString = NULL;
    const DWORD dwThreadId = ::GetCurrentThreadId();
    FRAME_INFO FrameInfo;
    CFusionProcessImageFileName ProcessImageFileName;

    szMsgBuffer[0] = '\0';
    szErrorBuffer[0] = '\0';
    szOutputBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            hrIn,                           // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable(non-existed or too long) HRESULT: 0x%08lx>",
            hrIn);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    szMsgBuffer[0] = '\0';

    if (pszMsg != NULL)
    {
        pszFormatString = "%s(%d): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx (%s) %s\n";
        ::_vsnprintf(szMsgBuffer, NUMBER_OF(szMsgBuffer), pszMsg, ap);
        szMsgBuffer[NUMBER_OF(szMsgBuffer) - 1] = '\0';
    }
    else
        pszFormatString = "%s(%d): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx (%s)\n";

    ::FusionpGetActiveFrameInfo(FrameInfo);

    ::_snprintf(szOutputBuffer, NUMBER_OF(szOutputBuffer), pszFormatString, FrameInfo.pszFile,
        FrameInfo.nLine, FrameInfo.pszFunction, sizeof(PVOID) * CHAR_BIT, &ProcessImageFileName, dwThreadId,
        hrIn, szErrorBuffer, szMsgBuffer);

    szOutputBuffer[NUMBER_OF(szOutputBuffer) - 1] = '\0';

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ENTEREXIT,
        "%s",
        szOutputBuffer);

    if ((s_hFile != NULL) && (s_hFile != INVALID_HANDLE_VALUE))
    {
        DWORD cBytesWritten = 0;
        if (!::WriteFile(s_hFile, szOutputBuffer, static_cast<DWORD>((::strlen(szOutputBuffer) + 1) * sizeof(CHAR)), &cBytesWritten, NULL))
        {
            // Avoid infinite loop if s_hFile is trashed...
            HANDLE hFileSaved = s_hFile;
            s_hFile = NULL;
            TRACE_WIN32_FAILURE_ORIGINATION(WriteFile);
            s_hFile = hFileSaved;
        }
    }
}

void
FusionpTraceCallCOMSuccessfulExitVa(
    HRESULT hrIn,
    LPCSTR pszMsg,
    va_list ap
    )
{
    /*
    This function has been split into FusionpTraceCOMSuccessfulExitVaBig and FusionpTraceCOMSuccessfulExitVaSmall, so that
    the usual case uses about 768 fewer bytes on the stack.
    */
    if ((pszMsg == NULL) &&
        ((s_hFile == NULL) ||
         (s_hFile == INVALID_HANDLE_VALUE)))
    {
        ::FusionpTraceCallCOMSuccessfulExitVaBig(hrIn, pszMsg, ap);
    }
    else
    {
        ::FusionpTraceCallCOMSuccessfulExitSmall(hrIn);
    }
}

void
FusionpTraceCOMFailure(
    HRESULT hrIn,
    LPCSTR pszMsg,
    ...
    )
{
    va_list ap;
    va_start(ap, pszMsg);
    ::FusionpTraceCOMFailureVa(hrIn, pszMsg, ap);
    va_end(ap);
}

void
FusionpTraceCOMFailureSmall(
    HRESULT hrIn
    )
{
    /*
    This is a forked version of FusionpTraceCOMFailureVaBig that we expect to get called.
    This function uses about 256 bytes of stack.
    FusionpTraceCOMFailureVaBug uses about 1k of stack.
    */
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(hrIn);
    CHAR szErrorBuffer[256];
    const DWORD dwThreadId = ::GetCurrentThreadId();
    CFusionProcessImageFileName ProcessImageFileName;

    szErrorBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            hrIn,                           // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable(non-existed or too long) HRESULT: 0x%08lx>",
            hrIn);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    PCSTR pszFormatString = "%s(%d): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx\n";

    FRAME_INFO FrameInfo;
    ::FusionpGetActiveFrameInfo(FrameInfo);

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROREXITPATH,
        pszFormatString,
        FrameInfo.pszFile,
        FrameInfo.nLine,
        FrameInfo.pszFunction,
        sizeof(PVOID) * CHAR_BIT,
        &ProcessImageFileName,
        dwThreadId,
        hrIn,
        szErrorBuffer);
}

void
FusionpTraceCOMFailureVaBig(
    HRESULT hrIn,
    LPCSTR pszMsg,
    va_list ap
    )
{
    /*
    This is a forked version of FusionpTraceCOMFailureVaSmall that we don't expect to get called.
    FusionpTraceCOMFailureVaSmall uses about 256 bytes of stack.
    This function uses about 1k of stack.
    */
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(hrIn);
    CHAR szMsgBuffer[256];
    CHAR szErrorBuffer[256];
    CHAR szOutputBuffer[512];
    PCSTR pszFormatString = NULL;
    const DWORD dwThreadId = ::GetCurrentThreadId();
    FRAME_INFO FrameInfo;
    CFusionProcessImageFileName ProcessImageFileName;

    szMsgBuffer[0] = '\0';
    szErrorBuffer[0] = '\0';
    szOutputBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            hrIn,                           // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable(non-existed or too long) HRESULT: 0x%08lx>",
            hrIn);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    szMsgBuffer[0] = '\0';

    if (pszMsg != NULL)
    {
        pszFormatString = "%s(%d): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx (%s) %s\n";
        ::_vsnprintf(szMsgBuffer, NUMBER_OF(szMsgBuffer), pszMsg, ap);
        szMsgBuffer[NUMBER_OF(szMsgBuffer) - 1] = '\0';
    }
    else
        pszFormatString = "%s(%d): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx (%s)\n";

    ::FusionpGetActiveFrameInfo(FrameInfo);

    ::_snprintf(szOutputBuffer, NUMBER_OF(szOutputBuffer), pszFormatString, FrameInfo.pszFile,
        FrameInfo.nLine, FrameInfo.pszFunction, sizeof(PVOID) * CHAR_BIT, &ProcessImageFileName,
        dwThreadId, hrIn, szErrorBuffer, szMsgBuffer);

    szOutputBuffer[NUMBER_OF(szOutputBuffer) - 1] = '\0';

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROREXITPATH,
        "%s",
        szOutputBuffer);

    if ((s_hFile != NULL) && (s_hFile != INVALID_HANDLE_VALUE))
    {
        DWORD cBytesWritten = 0;
        if (!::WriteFile(s_hFile, szOutputBuffer, static_cast<DWORD>((::strlen(szOutputBuffer) + 1) * sizeof(CHAR)), &cBytesWritten, NULL))
        {
            // Avoid infinite loop if s_hFile is trashed...
            HANDLE hFileSaved = s_hFile;
            s_hFile = NULL;
            TRACE_WIN32_FAILURE_ORIGINATION(WriteFile);
            s_hFile = hFileSaved;
        }
    }
}

void
FusionpTraceCOMFailureVa(
    HRESULT hrIn,
    LPCSTR pszMsg,
    va_list ap
    )
{
    /*
    This function has been split into FusionpTraceCOMFailureVaBig and FusionpTraceCOMFailureVaSmall, so that
    the usual case uses about 768 fewer bytes on the stack.
    */
    if ((pszMsg == NULL) &&
        ((s_hFile == NULL) ||
         (s_hFile == INVALID_HANDLE_VALUE)))
    {
        ::FusionpTraceCOMFailureVaBig(hrIn, pszMsg, ap);
    }
    else
    {
        ::FusionpTraceCOMFailureSmall(hrIn);
    }
}

void
FusionpTraceCOMFailureOrigination(
    HRESULT hrIn,
    LPCSTR pszMsg,
    ...
    )
{
    va_list ap;
    va_start(ap, pszMsg);
    ::FusionpTraceCOMFailureOriginationVa(hrIn, pszMsg, ap);
    va_end(ap);
}

void
FusionpTraceCOMFailureOriginationSmall(
    HRESULT hrIn
    )
{
    /*
    This is a forked version of FusionpTraceCOMFailureVaBig that we expect to get called.
    This function uses about 256 bytes of stack.
    FusionpTraceCOMFailureVaBug uses about 1k of stack.
    */
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(hrIn);
    CHAR szErrorBuffer[256];
    const DWORD dwThreadId = ::GetCurrentThreadId();
    CFusionProcessImageFileName ProcessImageFileName;

    szErrorBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            hrIn,                           // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable(non-existed or too long) HRESULT: 0x%08lx>",
            hrIn);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    PCSTR pszFormatString = "%s(%d): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx\n";

    FRAME_INFO FrameInfo;
    ::FusionpGetActiveFrameInfo(FrameInfo);

    ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, pszFormatString, FrameInfo.pszFile,
        FrameInfo.nLine, FrameInfo.pszFunction, sizeof(PVOID) * CHAR_BIT, &ProcessImageFileName,
        dwThreadId, hrIn, szErrorBuffer);
}

void
FusionpTraceCOMFailureOriginationVaBig(
    HRESULT hrIn,
    LPCSTR pszMsg,
    va_list ap
    )
{
    /*
    This is a forked version of FusionpTraceCOMFailureVaSmall that we don't expect to get called.
    FusionpTraceCOMFailureVaSmall uses about 256 bytes of stack.
    This function uses about 1k of stack.
    */
    FUSIONP_SUPPRESS_ERROR_REPORT_IN_OS_SETUP(hrIn);
    CHAR szMsgBuffer[256];
    CHAR szErrorBuffer[256];
    CHAR szOutputBuffer[512];
    PCSTR pszFormatString = NULL;
    const DWORD dwThreadId = ::GetCurrentThreadId();
    FRAME_INFO FrameInfo;
    CFusionProcessImageFileName ProcessImageFileName;

    szMsgBuffer[0] = '\0';
    szErrorBuffer[0] = '\0';
    szOutputBuffer[0] = '\0';

    DWORD dwTemp = ::FormatMessageA(
                            FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK,     // dwFlags
                            NULL,                           // lpSource - not used with system messages
                            hrIn,                           // dwMessageId
                            0,                              // langid - 0 uses system default search path of languages
                            szErrorBuffer,                  // lpBuffer
                            NUMBER_OF(szErrorBuffer),       // nSize
                            NULL);                          // Arguments
    if (dwTemp == 0)
    {
        ::_snprintf(
            szErrorBuffer,
            NUMBER_OF(szErrorBuffer),
            "<Untranslatable(non-existed or too long) HRESULT: 0x%08lx>",
            hrIn);
        szErrorBuffer[NUMBER_OF(szErrorBuffer) - 1] = '\0';
    }

    szMsgBuffer[0] = '\0';

    if (pszMsg != NULL)
    {
        pszFormatString = "%s(%d): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx (%s) %s\n";
        ::_vsnprintf(szMsgBuffer, NUMBER_OF(szMsgBuffer), pszMsg, ap);
        szMsgBuffer[NUMBER_OF(szMsgBuffer) - 1] = '\0';
    }
    else
        pszFormatString = "%s(%d): [function %s %Iubit process %wZ tid 0x%lx] COM Error 0x%08lx (%s)\n";

    ::FusionpGetActiveFrameInfo(FrameInfo);

    ::_snprintf(szOutputBuffer, NUMBER_OF(szOutputBuffer), pszFormatString, FrameInfo.pszFile,
        FrameInfo.nLine, FrameInfo.pszFunction, sizeof(PVOID) * CHAR_BIT, &ProcessImageFileName,
        dwThreadId, hrIn, szErrorBuffer, szMsgBuffer);

    szOutputBuffer[NUMBER_OF(szOutputBuffer) - 1] = '\0';

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "%s",
        szOutputBuffer);

    if ((s_hFile != NULL) && (s_hFile != INVALID_HANDLE_VALUE))
    {
        DWORD cBytesWritten = 0;
        if (!::WriteFile(s_hFile, szOutputBuffer, static_cast<DWORD>((::strlen(szOutputBuffer) + 1) * sizeof(CHAR)), &cBytesWritten, NULL))
        {
            // Avoid infinite loop if s_hFile is trashed...
            HANDLE hFileSaved = s_hFile;
            s_hFile = NULL;
            TRACE_WIN32_FAILURE_ORIGINATION(WriteFile);
            s_hFile = hFileSaved;
        }
    }
}


void
__fastcall
FusionpTraceCOMFailureOrigination(const CALL_SITE_INFO &rSite)
{
}


void
FusionpTraceCOMFailureOriginationVa(
    HRESULT hrIn,
    LPCSTR pszMsg,
    va_list ap
    )
{
    /*
    This function has been split into FusionpTraceCOMFailureVaBig and FusionpTraceCOMFailureVaSmall, so that
    the usual case uses about 768 fewer bytes on the stack.
    */
    if ((pszMsg == NULL) &&
        ((s_hFile == NULL) ||
         (s_hFile == INVALID_HANDLE_VALUE)))
    {
        ::FusionpTraceCOMFailureOriginationVaBig(hrIn, pszMsg, ap);
    }
    else
    {
        ::FusionpTraceCOMFailureOriginationSmall(hrIn);
    }
}

struct ILogFile;

void
FusionpTraceCallEntry()
{
    FRAME_INFO FrameInfo;

    if (::FusionpGetActiveFrameInfo(FrameInfo))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ENTEREXIT,
            "%s(%d): Entered %s\n",
            FrameInfo.pszFile,
            FrameInfo.nLine,
            FrameInfo.pszFunction);
    }
}

void
FusionpTraceCallExit()
{
    FRAME_INFO FrameInfo;

    if (::FusionpGetActiveFrameInfo(FrameInfo))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ENTEREXIT,
            "%s(%d): Exited %s\n",
            FrameInfo.pszFile,
            FrameInfo.nLine,
            FrameInfo.pszFunction);
    }
}

void
FusionpTraceCallSuccessfulExitVa(
    PCSTR szFormat,
    va_list ap
    )
{
    FRAME_INFO FrameInfo;

    if (::FusionpGetActiveFrameInfo(FrameInfo))
    {
        CHAR Buffer[256];

        Buffer[0] = '\0';

        if (szFormat != NULL)
        {
            ::_vsnprintf(Buffer, NUMBER_OF(Buffer), szFormat, ap);
            Buffer[NUMBER_OF(Buffer) - 1] = '\0';
        }

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ENTEREXIT,
            "%s(%d): Successfully exiting %s%s%s\n",
            FrameInfo.pszFile,
            FrameInfo.nLine,
            FrameInfo.pszFunction,
            Buffer[0] == '\0' ? "" : " - ",
            Buffer);
    }
}

void
FusionpTraceCallSuccessfulExit(
    PCSTR szFormat,
    ...
    )
{
    va_list ap;
    va_start(ap, szFormat);
    ::FusionpTraceCallSuccessfulExitVa(szFormat, ap);
    va_end(ap);
}

void
FusionpTraceCallWin32UnsuccessfulExitVa(
    DWORD dwError,
    PCSTR szFormat,
    va_list ap
    )
{
    FRAME_INFO FrameInfo;

    if (::FusionpGetActiveFrameInfo(FrameInfo))
    {
        ::FusionpTraceWin32FailureVa(
            FrameInfo,
            dwError,
            szFormat,
            ap);
    }
}

void
FusionpTraceCallWin32UnsuccessfulExit(
    DWORD dwError,
    PCSTR szFormat,
    ...
    )
{
    va_list ap;
    va_start(ap, szFormat);
    ::FusionpTraceCallWin32UnsuccessfulExitVa(dwError, szFormat, ap);
    va_end(ap);
}

void
FusionpTraceCallCOMUnsuccessfulExitVa(
    HRESULT hrError,
    PCSTR szFormat,
    va_list ap
    )
{
    ::FusionpTraceCOMFailureVa(
        hrError,
        szFormat,
        ap);
}

void
FusionpTraceCallCOMUnsuccessfulExit(
    HRESULT hrError,
    PCSTR szFormat,
    ...
    )
{
    va_list ap;
    va_start(ap, szFormat);
    ::FusionpTraceCallCOMUnsuccessfulExitVa(hrError, szFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\uuid\oleaut_uuid.c ===
#include "guiddef.h"
#include "fusionguids.h"

extern const CLSID CLSID_PSDispatch     = OLEAUT_IDISPATCH_PROXY_STUB_CLSID_structInit;
extern const CLSID CLSID_PSAutomation   = OLEAUT_PROXY_STUB_CLSID_structInit;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\uuid\sxsapi_uuid.c ===
typedef int pragma_warning_disable_4206_nonstandard_extension_used_translation_unit_is_empty;
#include <initguid.h>
#include <sxsapi_guids.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\win32oneshot\win32oneshot.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    win32oneshot.c

Abstract:

    one time initialization
    per process or per user or per machine
    optionally thread safe, if per process
    get code out of dllmain(dll_process_attach)
    get code out of setup (eliminate setup) (like, don't populate registry with defaults)

Author:

    Jay Krell (JayKrell) August 2001
    design per discussion with Michael Grier (MGrier)

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "windows.h"
#include "win32oneshot.h"
#include "fusionntdll.h"

#define INTERLOCKED_INCREMENT_OR_INCREMENT(f, pl) ((f) ? InterlockedIncrement(pl) : (++*pl))

//
// internally, we may expand this signature to allow for per-oneshot spinlocks or critical sections
//
VOID
Win32OneShot_TakeLock(
    PVOID* LockCookie
    )
{
    FusionpLdrLockLoaderLock(0, NULL, LockCookie);
}

VOID
Win32OneShot_ReleaseLock(
    PVOID LockCookie
    )
{
    if (LockCookie != NULL)
        FusionpLdrUnlockLoaderLock(0, LockCookie);
}

VOID
Win32OneShot_GetDetailedResults(
    ULONG                       Flags,
    LONG                        NumberOfSuccesses,
    LONG                        NumberOfFailures,
    PWIN32_ONE_SHOT_CALL_OUT    out
    )
{
    if (NumberOfSuccesses != 0)
        Flags |= WIN32_ONE_SHOT_CALL_FLAG_OUT_ANY_CALLBACKS_SUCCEEDED;
    if (NumberOfSuccesses > 1)
        Flags |= WIN32_ONE_SHOT_CALL_FLAG_OUT_MULTIPLE_CALLBACKS_SUCCEEDED;
    if (NumberOfFailures != 0)
        Flags |= WIN32_ONE_SHOT_CALL_FLAG_OUT_ANY_CALLBACKS_FAILED;
    if (NumberOfFailures > 1)
        Flags |= WIN32_ONE_SHOT_CALL_FLAG_OUT_MULTIPLE_CALLBACKS_FAILED;
    out->dwFlagsOut |= Flags | WIN32_ONE_SHOT_CALL_FLAG_OUT_DETAILED_RESULTS_VALID;
}

BOOL
WINAPI
Win32OneShotW(
    PWIN32_ONE_SHOT_CALL_IN  in,
    PWIN32_ONE_SHOT_CALL_OUT out
    )
{
    BOOL    Result = FALSE;
    PVOID   LockCookie;
    LONG    NumberOfSuccesses = 0;
    LONG    NumberOfFailures = 0;
    ULONG   OutFlags;
    BOOL    NeedInterlocked;
    BOOL    ExactlyOnce;
    BOOL    RetryOnFailure = FALSE;
    BOOL    WantDetailedResults;
    BOOL    Done = FALSE;
    PWIN32_ONE_SHOT_OPAQUE_STATIC_STATE StaticState;
    ULONG   FlagsIn;

    //
    // optimize the usual case a lot
    //
    StaticState = in->lpOpaqueStaticState;
    FlagsIn     = in->dwFlagsIn;
    WantDetailedResults = ((FlagsIn & WIN32_ONE_SHOT_CALL_FLAG_IN_ALWAYS_WANT_DETAILED_RESULTS) != 0);
    NumberOfSuccesses = StaticState->u.s.WinbasePrivate_NumberOfSuccesses;

    if (NumberOfSuccesses != 0) {
        Done = TRUE;
        Result = TRUE;
    }
    else {
        NumberOfFailures = StaticState->u.s.WinbasePrivate_NumberOfFailures;
        RetryOnFailure = ((FlagsIn & WIN32_ONE_SHOT_CALL_FLAG_IN_RETRY_ON_FAILURE) != 0);

        if (NumberOfFailures != 0 && !RetryOnFailure) {
            Result = FALSE;
            Done = TRUE;
        }
    }
    if (Done) {
        out->dwUserDefinedDisposition = in->lpOpaqueStaticState->u.s.WinbasePrivate_UserDefinedDisposition;
        if (WantDetailedResults) {
            out->dwFlagsOut = 0;
            Win32OneShot_GetDetailedResults(
                0,
                NumberOfSuccesses,
                Result ? StaticState->u.s.WinbasePrivate_NumberOfFailures : NumberOfFailures,
                out
                );
        }
        return Result;
    }

    //
    // now some slower cases
    //

    Result = FALSE;
    LockCookie = 0;
    OutFlags = 0;

    // parameter validation here

    // out init
    out->dwFlagsOut = 0;
    out->dwUserDefinedDisposition = 0;

    ExactlyOnce = ((FlagsIn & WIN32_ONE_SHOT_CALL_FLAG_IN_EXACTLY_ONCE) != 0);

    if (ExactlyOnce) {
        NeedInterlocked = FALSE;
        Win32OneShot_TakeLock(&LockCookie);
    } else {
        NeedInterlocked = TRUE;
    }

    __try {
        if (ExactlyOnce) {
            NumberOfFailures = StaticState->u.s.WinbasePrivate_NumberOfFailures;
            NumberOfSuccesses = StaticState->u.s.WinbasePrivate_NumberOfSuccesses;

            if (NumberOfSuccesses != 0) {
                out->dwUserDefinedDisposition = StaticState->u.s.WinbasePrivate_UserDefinedDisposition;
                Result = TRUE;
                goto Exit;
            }
            if (NumberOfFailures != 0 && !RetryOnFailure) {
                goto Exit;
            }
        }

        Result = (*in->lpfnUserDefinedInitializer)(in, out);
        OutFlags |= WIN32_ONE_SHOT_CALL_FLAG_OUT_THIS_TIME_RAN_CALLBACK;
        if (NumberOfFailures != 0)
            OutFlags |= WIN32_ONE_SHOT_CALL_FLAG_OUT_THIS_TIME_RAN_CALLBACK_RETRIED;

        if (Result) {
            OutFlags |= WIN32_ONE_SHOT_CALL_FLAG_OUT_THIS_TIME_CALLBACK_SUCCEEDED;
            NumberOfSuccesses = INTERLOCKED_INCREMENT_OR_INCREMENT(NeedInterlocked, &StaticState->u.s.WinbasePrivate_NumberOfSuccesses);
        } else {
            OutFlags |= WIN32_ONE_SHOT_CALL_FLAG_OUT_THIS_TIME_CALLBACK_FAILED;
            NumberOfFailures = INTERLOCKED_INCREMENT_OR_INCREMENT(NeedInterlocked, &StaticState->u.s.WinbasePrivate_NumberOfFailures);
        }
Exit:
        Win32OneShot_GetDetailedResults(
            OutFlags,
            NumberOfSuccesses,
            NumberOfFailures,
            out
            );
    } __finally {
        Win32OneShot_ReleaseLock(LockCookie);
    }
    return Result;
}

BOOL
WINAPI
Win32EnterOneShotW(
    ULONG                               Flags,
    PWIN32_ONE_SHOT_OPAQUE_STATIC_STATE Oneshot
    )
{
    ULONG NumberOfEntries;
    ULONG OnceFlag;
    PVOID LockCookie = NULL;
    BOOL  Result = FALSE;

    __try {
        if ((Flags & ~(
                WIN32_ENTER_ONE_SHOT_FLAG_EXACTLY_ONCE
                | WIN32_ENTER_ONE_SHOT_FLAG_AT_LEAST_ONCE)) != 0) {
            goto InvalidParameter;
        }

        OnceFlag = Flags & (WIN32_ENTER_ONE_SHOT_FLAG_EXACTLY_ONCE | WIN32_ENTER_ONE_SHOT_FLAG_AT_LEAST_ONCE);
        switch (OnceFlag)
        {
        default:
            goto InvalidParameter;
        case WIN32_ENTER_ONE_SHOT_FLAG_EXACTLY_ONCE:
        case WIN32_ENTER_ONE_SHOT_FLAG_AT_LEAST_ONCE:
            break;
        }

        NumberOfEntries = Oneshot->u.s2.WinbasePrivate_NumberOfEntries;
        if (NumberOfEntries != 0) {
            while (!Oneshot->u.s2.WinbasePrivate_Done) {
                /* SPIN */
                Sleep(0);
            }
            SetLastError(NO_ERROR);
            Result = FALSE;
            __leave;
        }
        if (OnceFlag == WIN32_ENTER_ONE_SHOT_FLAG_AT_LEAST_ONCE) {
            InterlockedIncrement(&Oneshot->u.s2.WinbasePrivate_NumberOfEntries);
            Result = TRUE;
            __leave;
        }

        Win32OneShot_TakeLock(&LockCookie);
        NumberOfEntries = Oneshot->u.s2.WinbasePrivate_NumberOfEntries;
        if (NumberOfEntries != 0) {
            Win32OneShot_ReleaseLock(LockCookie);
            LockCookie = NULL;
            /* ASSERT(Oneshot->u.s2.WinbasePrivate_Done); */
            while (!Oneshot->u.s2.WinbasePrivate_Done) {
                /* SPIN */
                Sleep(0);
            }
            SetLastError(NO_ERROR);
            Result = FALSE;
            __leave;
        }
        Oneshot->u.s2.WinbasePrivate_LockCookie = LockCookie;
        LockCookie = NULL;
        Result = TRUE;
        Oneshot->u.s2.WinbasePrivate_NumberOfEntries += 1;
        __leave;

InvalidParameter:
        SetLastError(ERROR_INVALID_PARAMETER);
        Result = FALSE;
        __leave;
    } __finally {
        Win32OneShot_ReleaseLock(LockCookie);
    }
    return Result;
}

VOID
WINAPI
Win32LeaveOneShotW(
    DWORD                               Flags,
    PWIN32_ONE_SHOT_OPAQUE_STATIC_STATE Oneshot
    )
{
    Win32OneShot_ReleaseLock(Oneshot->u.s2.WinbasePrivate_LockCookie);
    Oneshot->u.s2.WinbasePrivate_LockCookie = NULL;
    Oneshot->u.s2.WinbasePrivate_Done |= 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\win32oneshot\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)win32oneshot
TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)

INCLUDES=\
 $(INCLUDES); \
 $(FUSION_PATH)\inc

SOURCES=\
 win32oneshot.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\win32simplelock\win32simplelock.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    win32simplelock.c

Abstract:

    works downlevel to Win95/NT3.
        The only dependencies are InterlocedIncrement, IncrementDecrement, Sleep.
        The old Interlocked semantics are good enough.
    can be statically initialized, but not with all zeros.
    never runs out of memory
    does not wait or boost-upon-exit efficiently.
    must be held for only short periods of time.
    should perhaps be called spinlock
    can be taken recursively.
    can only be taken exclusively, NOT reader/writer.
    acquire has a "SleepCount" parameter:
        0 is like TryEnterCriticalSection
        INFINITE is like EnterCriticalSection
    SHOULD have a spincount to scale hot locks on multiprocs

Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/

#include "windows.h"
#include "win32simplelock.h"

DWORD
Win32AcquireSimpleLock(PWIN32_SIMPLE_LOCK Lock, DWORD SleepCount)
{
    DWORD Result = 0;
    BOOL IncrementedWaiters = FALSE;
    // ASSERT(Lock->Size != 0);
Retry:
    if (InterlockedIncrement(&Lock->Lock) == 0)
    {
        //
        // I got it.
        //
        Lock->OwnerThreadId = GetCurrentThreadId();
        if (Lock->EntryCount == 0)
        {
            Result |= WIN32_ACQUIRE_SIMPLE_LOCK_WAS_FIRST_ACQUIRE;
        }
        if (Lock->EntryCount+1 != 0) /* avoid rollover */
            Lock->EntryCount += 1;
        if (IncrementedWaiters)
            InterlockedDecrement(&Lock->Waiters);
        Result |= WIN32_ACQUIRE_SIMPLE_LOCK_WAS_NOT_RECURSIVE_ACQUIRE;
        return Result;
    }
    else if (Lock->OwnerThreadId == GetCurrentThreadId())
    {
        //
        // I got it recursively.
        //
        Result |= WIN32_ACQUIRE_SIMPLE_LOCK_WAS_RECURSIVE_ACQUIRE;
        return Result;
    }
    InterlockedDecrement(&Lock->Lock);
    if (SleepCount == 0)
        return 0;
    //
    // Someone else has it, wait for them to finish.
    //
    if (!IncrementedWaiters)
    {
        InterlockedIncrement(&Lock->Waiters);
        IncrementedWaiters = TRUE;
    }
    if (SleepCount == INFINITE)
    {
        while (Lock->OwnerThreadId != 0)
            Sleep(0);
    }
    else
    {
        while (Lock->OwnerThreadId != 0 && SleepCount--)
            Sleep(0);
    }
    goto Retry;
}

DWORD
Win32ReleaseSimpleLock(PWIN32_SIMPLE_LOCK Lock)
{
    // ASSERT(Lock->Size != 0);
    DWORD Result = 0;
    if (InterlockedDecrement(&Lock->Lock) < 0)
    {
        // I'm done with it (recursively).
        Lock->OwnerThreadId = 0;

        // Give any waiters a slightly better chance than me.
        // This is "racy", but that's ok.
        if (Lock->Waiters != 0)
            Sleep(0);

        Result |= WIN32_RELEASE_SIMPLE_LOCK_WAS_NOT_RECURSIVE_RELEASE;
    }
    else
    {
        Result |= WIN32_RELEASE_SIMPLE_LOCK_WAS_RECURSIVE_RELEASE;
    }
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xml\dumptree.cpp ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <sxsapi.h>
#include "fusionxml.h"
#include "debmacro.h"
#include "fusionbuffer.h"
#include "util.h"

void
SxspCopyXmlStringToBuffer(
    PCSXS_XML_DOCUMENT Document,
    ULONG String,
    CBaseStringBuffer *Buffer
    )
{
    if (String != 0)
    {
        if (String < Document->StringCount)
        {
            Buffer->Win32Assign(L"\"", 1);
            Buffer->Win32Append(Document->Strings[String].Buffer, Document->Strings[String].Length / sizeof(WCHAR));
            Buffer->Win32Append(L"\"", 1);
        }
        else
        {
            Buffer->Win32Assign(L"invalid index", 13);
        }
    }
    else
    {
        Buffer->Win32Assign(L"none", 4);
    }
}

void
SxspDumpXmlAttributes(
    PCWSTR PerLinePrefix,
    PCSXS_XML_DOCUMENT Document,
    ULONG AttributeCount,
    PCSXS_XML_ATTRIBUTE Attributes
    );

void
SxspDumpXmlSubTree(
    PCWSTR PerLinePrefix,
    PCSXS_XML_DOCUMENT Document,
    PCSXS_XML_NODE Node
    )
{
    if (Node == NULL)
    {
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_XMLTREE, "%lsSXS_XML_NODE (NULL)\n");
    }
    else
    {
        CSmallStringBuffer buffFlags;
        CStringBuffer buffType;
        const SIZE_T cchPLP = (PerLinePrefix != NULL) ? wcslen(PerLinePrefix) : 0;

#define TYPE_ENTRY(x) case x: buffType.Win32Assign(L ## #x, NUMBER_OF( #x ) - 1); break;

        switch (Node->Type)
        {
        default: buffType.Win32Assign(L"unknown", 7); break;
        TYPE_ENTRY(SXS_XML_NODE_TYPE_XML_DECL)
        TYPE_ENTRY(SXS_XML_NODE_TYPE_ELEMENT)
        TYPE_ENTRY(SXS_XML_NODE_TYPE_PCDATA)
        TYPE_ENTRY(SXS_XML_NODE_TYPE_CDATA)
        }
#undef TYPE_ENTRY

        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_XMLTREE,
            "%lsSXS_XML_NODE (%p) (Flags, Type, Parent) = (%08lx : %ls, %ls , %p)\n",
            PerLinePrefix, Node, Node->Flags, static_cast<PCWSTR>(buffFlags), static_cast<PCWSTR>(buffType), Node->Parent);

        switch (Node->Type)
        {
        default:
            break;

        case SXS_XML_NODE_TYPE_XML_DECL:
            if (Node->XMLDecl.AttributeCount == 0)
            {
                FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_XMLTREE,
                    "%ls   XMLDecl.AttributeCount: %lu\n",
                    PerLinePrefix, Node->XMLDecl.AttributeCount);
            }
            else
            {
                CStringBuffer buffNewPLP;

                buffNewPLP.Win32Assign(PerLinePrefix, cchPLP);
                buffNewPLP.Win32Append(L"   ", 3);

                SxspDumpXmlAttributes(buffNewPLP, Document, Node->XMLDecl.AttributeCount, Node->XMLDecl.Attributes);
            }
            break;

        case SXS_XML_NODE_TYPE_ELEMENT:
            {
                CStringBuffer buffNewPLP;
                CStringBuffer buffNS, buffN;
                LIST_ENTRY *ple = NULL;

                buffNewPLP.Win32Assign(PerLinePrefix, cchPLP);
                buffNewPLP.Win32Append(L"   ", 3);

                SxspCopyXmlStringToBuffer(Document, Node->Element.NamespaceString, &buffNS);
                SxspCopyXmlStringToBuffer(Document, Node->Element.NameString, &buffN);

                FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_XMLTREE,
                    "%ls   Element (.Namespace, .Name): ( %ls , %ls )\n",
                    PerLinePrefix, static_cast<PCWSTR>(buffNS), static_cast<PCWSTR>(buffN));

                if (Node->Element.AttributeCount != 0)
                    SxspDumpXmlAttributes(buffNewPLP, Document, Node->Element.AttributeCount, Node->Element.Attributes);

                ple = Node->Element.ChildListHead.Flink;

                while (ple != &Node->Element.ChildListHead)
                {
                    SxspDumpXmlSubTree(buffNewPLP, Document, reinterpret_cast<PSXS_XML_NODE>(CONTAINING_RECORD(ple, SXS_XML_NODE, SiblingLink)));
                    ple = ple->Flink;
                }

                break;
            }

        case SXS_XML_NODE_TYPE_PCDATA:
            {
                CStringBuffer buff;

                SxspCopyXmlStringToBuffer(Document, Node->PCDataString, &buff);

                FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_XMLTREE,
                    "%ls   PCDataString: %lu (%ls)\n",
                    PerLinePrefix, Node->PCDataString, static_cast<PCWSTR>(buff));

                break;
            }

        case SXS_XML_NODE_TYPE_CDATA:
            {
                CStringBuffer buff;

                SxspCopyXmlStringToBuffer(Document, Node->CDataString, &buff);

                FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_XMLTREE,
                    "%ls   CDataString: %lu (%ls)\n",
                    PerLinePrefix, Node->CDataString, static_cast<PCWSTR>(buff));

                break;
            }
        }
    }
}

void
SxspDumpXmlTree(
    ULONG Flags,
    PCSXS_XML_DOCUMENT Document
    )
{
    LIST_ENTRY *ple = Document->ElementListHead.Flink;

    while (ple != &Document->ElementListHead)
    {
        SxspDumpXmlSubTree(L"", Document, CONTAINING_RECORD(ple, SXS_XML_NODE, SiblingLink));
        ple = ple->Flink;
    }
}

void
SxspDumpXmlAttributes(
    PCWSTR PerLinePrefix,
    PCSXS_XML_DOCUMENT Document,
    ULONG AttributeCount,
    PCSXS_XML_ATTRIBUTE Attributes
    )
{
    ULONG i;
    CStringBuffer buffNS, buffN, buffV;

    for (i=0; i<AttributeCount; i++)
    {
        SxspCopyXmlStringToBuffer(Document, Attributes[i].NamespaceString, &buffNS);
        SxspCopyXmlStringToBuffer(Document, Attributes[i].NameString, &buffN);
        SxspCopyXmlStringToBuffer(Document, Attributes[i].ValueString, &buffV);

        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_XMLTREE,
            "%lsSXS_XML_ATTRIBUTE %lu of %lu (at %p): Flags: %08lx; (NS, N, V) = (%ls , %ls , %ls)\n",
            PerLinePrefix, i + 1, AttributeCount, &Attributes[i], Attributes[i].Flags, static_cast<PCWSTR>(buffNS), static_cast<PCWSTR>(buffN), static_cast<PCWSTR>(buffV));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\winthrow\makefile.inc ===
# makefile.inc

!if "$(DEBUG_GENTHUNK)" == "1"
GENTHUNK_FLAGS=$(GENTHUNK_FLAGS) -d -w -G
!else
GENTHUNK_FLAGS=-w -G
!endif

!if "$(DEBUG_THUNKGEN)" == "1"
SORTPP_FLAGS=$(SORTPP_FLAGS) -l
!else
SORTPP_FLAGS=$(SORTPP_FLAGS)
!endif

PPMFILE=$(FUSION_PATH)\cgen\$(O)\winincs.ppm
PPMFILE_PRIVATE=$(FUSION_PATH)\cgen\$(O)\winincs_private.ppm

TPL_FILES=winthrow.tpl winthrow_err.tpl winthrow_specialcases.tpl winthrow_names.tpl winthrow_yuck.tpl
DASH_TPL_FILES=-t$(TPL_FILES: = -t)
APILIST=apilist.txt
DASH_APILIST=-E$(APILIST)

THUNK_DEPS=$(THUNK_DEPS) $(PPMFILE) $(TPL_FILES) $(APILIST)
GENTHUNK_FLAGS=-LessTrailingWhitespace $(GENTHUNK_FLAGS) $(DASH_TPL_FILES) $(DASH_APILIST)

$(FUSION_PATH)\inc\$(O)\winthrow_private.h : $(O)\winthrow_private.h
    if not exist $@\.. mkdir $@\..
    copy $** $@

$(FUSION_PATH)\inc\$(O)\winthrow.h : $(O)\winthrow.h
    if not exist $@\.. mkdir $@\..
    copy $** $@

$(O)\winthrow_private.h: $(PPMFILE_PRIVATE) winthrow_private.tpl
    fusion_genthnk.exe -m$(PPMFILE_PRIVATE) $(GENTHUNK_FLAGS) -twinthrow_private.tpl -c$(@):winthrow_h

$(O)\winthrow_private.cpp: $(THUNK_DEPS) winthrow_private.tpl
    fusion_genthnk.exe -m$(PPMFILE_PRIVATE) $(GENTHUNK_FLAGS) -twinthrow_private.tpl -c$(@):winthrow_cpp

$(O)\winthrow.h: $(PPMFILE) $(THUNK_DEPS) winthrow_public.tpl
    fusion_genthnk.exe -m$(PPMFILE) $(GENTHUNK_FLAGS) -twinthrow_public.tpl -c$(@):winthrow_h

$(O)\winthrow.cpp: $(PPMFILE) $(THUNK_DEPS) winthrow_public.tpl
    fusion_genthnk.exe -m$(PPMFILE) $(GENTHUNK_FLAGS) -twinthrow_public.tpl -c$(@):winthrow_cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xml\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:  Danpo Zhang

!ENDIF

MAJORCOMP=fusion
MINORCOMP=xml

TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)xml
TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)

INCLUDES=\
    ..;\
    $(FUSION_INC_PATH);\
    $(FUSION_PATH)\eventlog\whistler\$(O); \
    $(INCLUDES)

SOURCES= \
    ..\dumptree.cpp \
    ..\xmltree.cpp

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xml\xmltree.cpp ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <sxsapi.h>
#include "debmacro.h"
#include "fusiontrace.h"

BOOL
SxspFindNextSibling(
    ULONG Flags,
    PCSXS_XML_DOCUMENT Document,
    const LIST_ENTRY *ChildList,
    PCSXS_XML_NODE CurrentChild,
    PCSXS_XML_NAMED_REFERENCE Reference,
    PCSXS_XML_NODE &rpChild
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    LIST_ENTRY *pNext;
    PCSXS_XML_NODE pChild = NULL;

    rpChild = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(ChildList != NULL);
    PARAMETER_CHECK(CurrentChild != NULL);
    PARAMETER_CHECK(Reference != NULL);

    pNext = CurrentChild->SiblingLink.Flink;

    while (pNext != ChildList)
    {
        pChild = CONTAINING_RECORD(pNext, SXS_XML_NODE, SiblingLink);
        PCSXS_XML_STRING NamespaceString = &Document->Strings[pChild->Element.NamespaceString];
        PCSXS_XML_STRING NameString = &Document->Strings[pChild->Element.NameString];

        if ((Reference->NamespaceLength == NamespaceString->Length) &&
            (Reference->NameLength == NameString->Length) &&
            ((Reference->NamespaceLength == 0) ||
             (memcmp(Reference->Namespace, NamespaceString->Buffer, Reference->NamespaceLength) == 0)) &&
            ((Reference->NameLength == 0) ||
             (memcmp(Reference->Name, NameString->Buffer, Reference->NameLength) == 0)))
        {
            break;
        }

        pNext = pNext->Flink;
    }

    if (pNext != ChildList)
    {
        // Goodness, we found one!
        rpChild = pChild;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFindChild(
    ULONG Flags,
    PCSXS_XML_DOCUMENT Document,
    const LIST_ENTRY *ChildList,
    PCSXS_XML_NAMED_REFERENCE Reference,
    PCSXS_XML_NODE &rpChild
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    rpChild = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(ChildList != NULL);
    PARAMETER_CHECK(Reference != NULL);

    IFW32FALSE_EXIT(::SxspFindNextSibling(0, Document, ChildList, CONTAINING_RECORD(ChildList, SXS_XML_NODE, SiblingLink), Reference, rpChild));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspEnumXmlNodes(
    ULONG Flags,
    PCSXS_XML_DOCUMENT Document,
    const LIST_ENTRY *CurrentChildList,
    PCSXS_XML_NODE_PATH PathToMatch,
    ULONG NextElementPathIndex,
    PSXS_ENUM_XML_NODES_CALLBACK Callback,
    PVOID CallbackContext,
    BOOL *ContinueEnumerationOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    const LIST_ENTRY *pNext = CurrentChildList;
    PCSXS_XML_NODE pChild;
    PCSXS_XML_NAMED_REFERENCE pReference;

    if (ContinueEnumerationOut != NULL)
        *ContinueEnumerationOut = TRUE;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Document != NULL);
    PARAMETER_CHECK(CurrentChildList != NULL);
    PARAMETER_CHECK(PathToMatch != NULL);
    PARAMETER_CHECK(NextElementPathIndex < PathToMatch->ElementCount);
    PARAMETER_CHECK(Callback != NULL);
    PARAMETER_CHECK(ContinueEnumerationOut != NULL);

    pReference = PathToMatch->Elements[NextElementPathIndex++];

    for (;;)
    {
        // find the next matching sibling at this level of the tree
        IFW32FALSE_EXIT(::SxspFindNextSibling(0, Document, CurrentChildList, CONTAINING_RECORD(pNext, SXS_XML_NODE, SiblingLink), pReference, pChild));
        if (pChild == NULL)
            break;

        INTERNAL_ERROR_CHECK(pChild->Type == SXS_XML_NODE_TYPE_ELEMENT);

        // If we're at the leaves of the reference path to match, call the callback.
        if (NextElementPathIndex == PathToMatch->ElementCount)
            (*Callback)(CallbackContext, pChild, ContinueEnumerationOut);
        else
            IFW32FALSE_EXIT(::SxspEnumXmlNodes(0, Document, &pChild->Element.ChildListHead, PathToMatch, NextElementPathIndex, Callback, CallbackContext, ContinueEnumerationOut));

        // If the callback said to stop, bail out.
        if (!*ContinueEnumerationOut)
            break;
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}


BOOL
SxsEnumXmlNodes(
    ULONG Flags,
    PCSXS_XML_DOCUMENT Document,
    PCSXS_XML_NODE_PATH PathToMatch,
    PSXS_ENUM_XML_NODES_CALLBACK Callback,
    PVOID CallbackContext
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL ContinueEnumeration;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(PathToMatch != NULL);
    PARAMETER_CHECK(Callback != NULL);

    IFW32FALSE_EXIT(::SxspEnumXmlNodes(0, Document, &Document->ElementListHead, PathToMatch, 0, Callback, CallbackContext, &ContinueEnumeration));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\bufferedstream.cxx ===
/////////////////////////////////////////////////////////////////////////////////
//
// fusion\xmlparser\BufferedStream.cxx
//
/////////////////////////////////////////////////////////////////////////////////

#include "stdinc.h"
#include "core.hxx"
#pragma hdrstop

#include <memory.h> 
//#include <shlwapip.h>   
#include <ole2.h>
#include <xmlparser.h>

#include "bufferedstream.hxx"
#include "xmlstream.hxx"
#include "encodingstream.hxx"
#include "xmlhelper.hxx" 

const long BLOCK_SIZE = 4096;
// no point remembering a line buffer longer than this because client
// probably can't deal with that anyway.
const long MAX_LINE_BUFFER = 512;

BufferedStream::BufferedStream(XMLStream *pXMLStream)
{
    _pchBuffer = NULL;
    _lSize = 0;
    _pXMLStream = pXMLStream;
    init();
}
/////////////////////////////////////////////////////////////////////////////
void BufferedStream::init()
{
    _lCurrent = _lUsed = _lMark = 0;
    _lLine			= 1; // lines start at 1.
    _lMarkedline	= 1;
    _lLinepos		= 0;
    _lMarkedlinepos = 0;
    _chLast		= 0;
    _lStartAt		= 0;
    _fEof			= false;
    _lLockedPos	= -1;
    _lLastWhiteSpace = -1;
    _lLockCount	= 0;
    _fNotified		= false;
    _fFrozen		= false;
	_pPendingEncoding = NULL;
}
/////////////////////////////////////////////////////////////////////////////
BufferedStream::~BufferedStream()
{
    delete [] _pchBuffer;
    _pStmInput = NULL;
	delete _pPendingEncoding;
    _pPendingEncoding = NULL;


}
/////////////////////////////////////////////////////////////////////////////
HRESULT BufferedStream::Reset()
{
    init();

    delete[] _pchBuffer;
    _pchBuffer = NULL;
    _lSize = 0;
    _pStmInput = NULL;
    _lLockedPos = -1;
    _lLockCount = 0;
    _fFrozen = false;
    delete _pPendingEncoding;
    _pPendingEncoding = NULL;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT  
BufferedStream::Load( 
        /* [unique][in] */ EncodingStream __RPC_FAR *pStm)
{
    if (pStm != NULL)
    {
        init();
        _pStmInput = pStm;
        return S_OK;
    }
    else
    {
        _pStmInput = NULL;
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
BufferedStream::AppendData( const BYTE* in, ULONG length, BOOL lastBuffer)
{
    HRESULT hr;

    if (_fEof)
    {
        init();
    }

    if (!_pStmInput)
    {
        EncodingStream* stream = (EncodingStream*)EncodingStream::newEncodingStream(NULL); 
        if (stream == NULL)
            return E_OUTOFMEMORY;
        _pStmInput = stream;
        stream->Release(); // Smart pointer is holding a ref
    }

    checkhr2(_pStmInput->AppendData(in, length, lastBuffer));

    return S_OK;

}
/////////////////////////////////////////////////////////////////////////////
HRESULT  
BufferedStream::nextChar( 
        /* [out] */  WCHAR* ch,
        /* [out] */ bool* fEOF)
{
    HRESULT hr;

    if (_lCurrent >= _lUsed)
    {
        if (_fEof)
        {
            *fEOF = true;
            return S_OK;
        }
        if (! _fNotified && _lUsed > 0)
        {
            _fNotified = true;          // notify data available BEFORE blowing

            // NOTE: this code approximates what prepareForInput does
            // in order to accurately predict when the buffer is about to
            // be re-allocated.

            long shift = _fFrozen ? 0 : getNewStart(); // is data about to shift?
            long used = _lUsed - shift; // this is how much is really used after shift
            if (_lSize - used < BLOCK_SIZE + 1) // +1 for null termination.
            {
                // we will reallocate !!  So return a special
                // return code
                hr = E_DATA_REALLOCATE;
            }
            else
                hr = E_DATA_AVAILABLE;    // away the old data so parser can save it if need be.
            checkhr2( _pXMLStream->ErrorCallback(hr) );
        }                   

        checkhr2( fillBuffer() );
        if (_fEof)
        {
            *fEOF = true;
            return S_OK;
        }
        _fNotified = false;
    }

    WCHAR result = _pchBuffer[_lCurrent++];

    switch (result)
    {
    case 0xa:
    case 0xd:
        if (result == 0xd || _chLast != 0xd)
            _lLine++; 
        _lLinepos = _lCurrent;
        _chLast = result;
        _lLastWhiteSpace = _lCurrent;
        break;
    case 0x20:
    case 0x9:
        _lLastWhiteSpace = _lCurrent;
        break;
    case 0xfffe:
	case 0xffff:
    //case 0xfeff:
		::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: XML Parser found either 0xfffe or 0xffff\n");

        return XML_E_BADCHARDATA;
    }

    *ch = result;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT BufferedStream::scanPCData( 
    /* [out] */ WCHAR* ch,
    /* [out] */ bool* fWhitespace)
{
    WCHAR result;
    bool foundNonWhiteSpace = false;

    if (! isWhiteSpace(*ch))
        foundNonWhiteSpace = true;

    // Then skip the data until we find '<', '>' or '&'
    while (_lCurrent < _lUsed)
    {
        result = _pchBuffer[_lCurrent++];

        switch (result)
        {
        case ']':  // xiaoyu : the specified chars can be changed for our own purpose
        case '>':
        case '<':
        case '&':
        case '\'':  // so this can be used to scan attribute values also.
        case '"':   // so this can be used to scan attribute values also.
            *ch = result;
            if (foundNonWhiteSpace)
                *fWhitespace = false;
            return S_OK;
            break;

        case 0xa:
        case 0xd:
            if (result == 0xd || _chLast != 0xd)
                _lLine++; 
            _lLinepos = _lCurrent;
            _chLast = result;
            _lLastWhiteSpace = _lCurrent;
            break;
        case 0x20:
        case 0x9:
            _lLastWhiteSpace = _lCurrent;
            break;
        case 0xfffe:
        case 0xffff:
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: XML Parser found either 0xfffe or 0xffff\n");

            return XML_E_BADCHARDATA;
        default:
            foundNonWhiteSpace = true;
            break;
        }
    }

    // And just return E_PENDING if we run out of buffer.
    if (foundNonWhiteSpace)
        *fWhitespace = false;
    return E_PENDING;
}
/////////////////////////////////////////////////////////////////////////////
long BufferedStream::getLine() 
{ 
    return _lMarkedline; 
}
/////////////////////////////////////////////////////////////////////////////
long BufferedStream::getLinePos() 
{
    // _lMarkedlinepos is the position of the beginning of the marked line
    // relative to the beginning of the buffer, and _lMark is the 
    // position of the marked token relative to the beginning of the
    // buffer, So the position of the marked token relative to the 
    // current line is the difference between the two.
    // We also return a 1-based position so that the start of the
    // line = column 1.  This is consistent with the line numbers
    // which are also 1-based.
    return (_lMarkedlinepos > _lMark+1) ? 0 : _lMark+1-_lMarkedlinepos; 
}
/////////////////////////////////////////////////////////////////////////////
long BufferedStream::getInputPos()
{
    return _lStartAt+_lMark;
}
/////////////////////////////////////////////////////////////////////////////
WCHAR* BufferedStream::getLineBuf(ULONG* len, ULONG* startpos)
{
    *len = 0;
    if (_pchBuffer == NULL)
        return NULL;

    WCHAR* result = &_pchBuffer[_lMarkedlinepos];

    ULONG i = 0;
    // internal _pchBuffer is guarenteed to be null terminated.
    WCHAR ch = result[i];
    while (ch != 0 && ch != L'\n' && ch != L'\r')
    {
        i++;
        ch = result[i];
    }
    *len = i;
    // also return the line position relative to start of
    // returned buffer.
    *startpos = (_lMarkedlinepos > _lMark+1) ? 0 : _lMark+1-_lMarkedlinepos; 
    return result;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT BufferedStream::switchEncoding(const WCHAR * charset, ULONG len)
{
    HRESULT hr = S_OK;

    if (!_pStmInput)
    {
        hr = E_FAIL;
        goto CleanUp;
    }
    else
    {
        _pPendingEncoding = Encoding::newEncoding(charset, len, false, false);
        if (_pPendingEncoding == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }

        if (! _fFrozen)
        {
             hr = doSwitchEncoding();
        }
    }
CleanUp:
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT BufferedStream::doSwitchEncoding()
{
    Encoding* encoding = _pPendingEncoding;
    _pPendingEncoding = NULL;

    HRESULT hr = _pStmInput->switchEncodingAt(encoding, _lStartAt + _lCurrent);
    if (hr == S_FALSE)
    {
        // need to re-read to force re-decode into new encoding.
        // In other words we have to forget that we read past this
        // position already so that the next call to nextChar
        // will call FillBuffer again.
        // (+1 so that nextChar works correctly).
        _lUsed = _lStartAt + _lCurrent;
        hr = S_OK;
    }
    else if (FAILED(hr))
    {
        hr = (hr == E_INVALIDARG) ? XML_E_INVALIDENCODING : XML_E_INVALIDSWITCH;
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
// Returns a pointer to a contiguous block of text accumulated 
// from the last time Mark() was called up to but not including
// the last character read. (This allows a parser to have a
// lookahead character that is not included in the token).
HRESULT  
BufferedStream::getToken(const WCHAR**p, long* len)
{
    if (_pchBuffer == NULL)
        return E_FAIL;

    if (_lCurrent != _lCurrent2)
    {
        // need to fix up buffer since it is no
        // out of sync since we've been compressing
        // whitespace.

    }
    *p = &_pchBuffer[_lMark];
    *len = getTokenLength();
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
void 
BufferedStream::Lock()
{
    // We allow nested locking - where the outer lock wins - unlock only 
    // really unlocks when the outer lock is unlocked.
    if (++_lLockCount == 1)
    {
        _lLockedPos = _lMark;
        _lLockedLine = _lMarkedline;
        _lLockedLinePos = _lMarkedlinepos;
    }
}
/////////////////////////////////////////////////////////////////////////////
void 
BufferedStream::UnLock()
{
    if (--_lLockCount == 0)
    {
        _lMark = _lLockedPos;
        _lMarkedline = _lLockedLine;
        _lMarkedlinepos = _lLockedLinePos;
        _lLockedPos = -1;
    }
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
BufferedStream::Freeze()
{
    HRESULT hr;
    if (_lCurrent > _lMidPoint)
    {
        // Since we freeze the buffer a lot now (any time we're inside
        // a tag) we need to shift the bytes down in the buffer more
        // frequently in order to guarentee we have space in the buffer
        // when we need it.  Otherwize the buffer would tend to just
        // keep growing and growing.  So we shift the buffer when we
        // go past the midpoint.
        checkhr2( prepareForInput() ); 
        
    }
    _fFrozen = true;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
BufferedStream::UnFreeze()
{
    _fFrozen = false;
    if (_pPendingEncoding)
    {
        return doSwitchEncoding();
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
BufferedStream::fillBuffer()
{
    HRESULT hr;
    
    checkhr2( prepareForInput() ); 

    if (_pStmInput)
    {
        long space = _lSize - _lUsed - 1; // reserve 1 for NULL termination

        //
        // If this is negative, do we care?  Seems like it's an underflow
        //
        if (space < 0)
        {
            return E_PENDING;
        }

        // get more bytes.
        ULONG read = 0;
        HRESULT rc = _pStmInput->Read(&_pchBuffer[_lUsed], space*sizeof(WCHAR), &read);

        //
        // This isn't really an invalid argument, it's just invalid read amounts
        //
        if ((read % sizeof(WCHAR)) != 0)
            rc = E_INVALIDARG;
        
        if (FAILED(rc))
            return rc;

        _lUsed += read/sizeof(WCHAR); // stream must return unicode characters.
        _pchBuffer[_lUsed] = 0; // NULL terminate the _pchBuffer.

        if (read == 0)
        {
            _fEof = true;
            // increment _lCurrent, so that getToken returns
            // last character in file.
            _lCurrent++; _lCurrent2++;
        }
    }
    else
    {
        // SetInput or AppendData hasn't been called yet.
        return E_PENDING;
    }

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
BufferedStream::prepareForInput()
{
    // move the currently used section of the _pchBuffer 
    // (buf[mark] to buf[used]) down to the beginning of
    // the _pchBuffer.

    long newstart = 0;

    // BUGBUG - if this code is changed BufferedStream::nextChar has to
    // be updated also so that they stay in sync, otherwise we might
    // re-allocated the buffer without generating an E_DATA_REALLOCATE
    // notification - which would be very bad (causes GPF's in the parser).

    if (! _fFrozen)  // can't shift bits if the buffer is frozen.
    {
        newstart = getNewStart();

        if (newstart > 0)
        {
            WCHAR* src = &_pchBuffer[newstart];
            _lUsed -= newstart;
            _lStartAt += newstart;
            ::memmove(_pchBuffer,src,_lUsed*sizeof(WCHAR));
            _lCurrent -= newstart;
            _lCurrent2 -= newstart;
            _lLastWhiteSpace -= newstart;
            _lLinepos = (_lLinepos > newstart) ? _lLinepos-newstart : 0;
            _lMarkedlinepos = (_lLinepos > newstart) ? _lMarkedlinepos-newstart : 0;
            _lMark -= newstart;
            _lLockedLinePos = (_lLockedLinePos > newstart) ? _lLockedLinePos-newstart : 0;
            _lLockedPos -= newstart;
        }
    }

    // make sure we have a reasonable amount of space
    // left in the _pchBuffer.
    long space = _lSize - _lUsed; 
    if (space > 0) space--; // reserve 1 for NULL termination
    if (_pchBuffer == NULL || space < BLOCK_SIZE)
    {
        // double the size of the buffer.
		long newsize = (_lSize == 0) ? BLOCK_SIZE : (_lSize*2);

        WCHAR* newbuf = NEW (WCHAR[newsize]);
        if (newbuf == NULL)
        {
            // try more conservative allocation.
            newsize = _lSize + BLOCK_SIZE;
            newbuf = NEW (WCHAR[newsize]);
        }
        if (newbuf == NULL && space == 0)
            return E_OUTOFMEMORY;

        if (newbuf != NULL)
        {
            if (_pchBuffer != NULL)
            {
                // copy old bytes to new _pchBuffer.
                ::memcpy(newbuf,_pchBuffer,_lUsed*sizeof(WCHAR));
                delete [] _pchBuffer;
            }
            newbuf[_lUsed] = 0; // make sure it's null terminated.
            _pchBuffer = newbuf;
            _lSize = newsize;
            _lMidPoint = newsize / 2;

        }
    }

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
long
BufferedStream::getNewStart()
{
    long newstart = 0;

    // Unless the buffer is frozen, in which case we just reallocate and
    // do no shifting of data.
    if (_lLockedPos > 0)
    {
        // and try and preserve the beginning of the marked line if we can
        if (_lLockedLinePos < _lLockedPos && 
            _lLockedPos - _lLockedLinePos < MAX_LINE_BUFFER)
        {
            newstart = _lLockedLinePos;
        }
    }
    else if (_lMark > 0)
    {
        // and try and preserve the beginning of the marked line if we can
        newstart = _lMark;
        if (_lMarkedlinepos < _lMark && 
            _lMark - _lMarkedlinepos < MAX_LINE_BUFFER) // watch out for long lines
        {
            newstart = _lMarkedlinepos;
        }
    }
    return newstart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:  Michael Grier

!ENDIF

TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)xmlparser
TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)

INCLUDES=\
    ..;\
    $(FUSION_PATH)\idl\$(O);\
    $(FUSION_PATH)\id;\
    $(FUSION_PATH)\sxs;\
    $(FUSION_PATH)\dll\whistler;\
    $(FUSION_INC_PATH);\
    $(FUSION_PATH)\eventlog\whistler\$(O);\
    $(INCLUDES); \
    $(COM_INC_PATH)

SOURCES= \
    ..\bufferedstream.cxx \
    ..\charencoder.cxx \
    ..\encodingstream.cxx \
    ..\xmlhelper.cxx \
    ..\xmlparser.cxx \
    ..\xmlstream.cxx \
    ..\_rawstack.cxx \
    ..\_reference.cxx \
    ..\xmlparsertest.cxx

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\encodingstream.cxx ===
/*
 * @(#)EncodingStream.cxx 1.0 6/10/97
 * 
* Copyright (c) 1997 - 1999 Microsoft Corporation. All rights reserved. * 
 */
#include "stdinc.h"
#include "core.hxx"
#include "xmlhelper.hxx"
#include "encodingstream.hxx"
#pragma hdrstop

const int EncodingStream::BUFFERSIZE = 4096*sizeof(WCHAR);
//////////////////////////////////////////////////////////////////////////////////
EncodingStream::EncodingStream(IStream * pStream): 
    stream(pStream), encoding(NULL), buf(NULL), pfnWideCharFromMultiByte(NULL),
    btotal(0), bnext(0), startAt(0), lastBuffer(false), bufsize(0), _fEOF(false),
    _fReadStream(true), _fUTF8BOM(false), _dwMode(0), codepage(CP_UNDEFINED)
{
}

//////////////////////////////////////////////////////////////////////////////////
/**
 * Builds the EncodingStream for input.
 * Reads the first two bytes of the InputStream * in order to make a guess
 * as to the character encoding of the file.
 */
IStream * EncodingStream::newEncodingStream(IStream * pStream)
{
    EncodingStream * es = NEW (EncodingStream(pStream));
    if (es == NULL)
        return NULL;

    //
    // REVIEW REVIEW:
    // Shouldn't this rewind the stream cursor back to a known good point?  The
    // comment above is useless, too - there's no data reading at all here.
    //

    es->AddRef(); // xwu@@ : check this addRef()!

    es->isInput = true;
    es->buf = NULL;

    return es;
}
//////////////////////////////////////////////////////////////////////////////////
EncodingStream::~EncodingStream()
{
    if (buf)
    {
        delete [] buf;
        buf = NULL;
    }
    
    if (encoding != NULL)
    {
        delete encoding;
        encoding = NULL;
    }

    stream = NULL; // smart pointer
}
//////////////////////////////////////////////////////////////////////////////////
/**
 * Reads characters from stream and encode it to Unicode
 */
HRESULT STDMETHODCALLTYPE EncodingStream::Read(void * pv, ULONG cb, ULONG * pcbRead)
{
    HRESULT hr;
    
    ULONG num = 0;

    if (pcbRead != NULL)
        *pcbRead = 0;

    if (btotal == 0 && _fEOF)          // we already hit EOF - so return right away.
        return S_OK;

    // Calculate how many UNICODE chars we are allowed to return, 
    // xiaoyu : which is the same as the number of BYTES read from the file
    cb /= sizeof(WCHAR);    
    checkhr2(prepareForInput(cb));

    if (stream && _fReadStream)
    {
        // btotal = number of bytes already in start of buffer.
        if (cb > btotal)
        {
            hr = stream->Read(buf + btotal, cb - btotal, &num);

            // Let's show what we've seen in the debugger so that we can diagnose bad manifests
            // more easily.  mgrier 12/28/2000

            if (::FusionpDbgWouldPrintAtFilterLevel(FUSION_DBG_LEVEL_XMLSTREAM))
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_XMLSTREAM,
                    "SXS.DLL: Read %lu bytes from XML stream; HRESULT returned = 0x%08lx\n", num, hr);

                if (num > 0)
                {
                    ::FusionpDbgPrintBlob(
                        FUSION_DBG_LEVEL_XMLSTREAM,
                        buf + btotal,
                        num,
                        L"   ");
                }
            }

            if ((hr == E_PENDING) && (num > 0))
            {
                // in which case we ignore the error, and continue on !!.
                // BUGBUG - this may be a problem.since we are changing the
                // return code returned from the stream.  This may mean we
                // should not ever hand out this stream outside of MSXML.
                hr = 0;
            }
            if (FAILED(hr))
            {
                return hr;
            }
            if (btotal == 0 && num == 0)
            {
                _fEOF = true;
                return hr;
            }
        }
        else
        {
            hr = S_OK;
        }
    }
    else if (btotal == 0)
    {
    	return (lastBuffer) ? S_FALSE : E_PENDING;
    }

    btotal += num;
    UINT b = btotal, utotal = cb;

    if (b > cb)
    {
        // If we have more bytes in our buffer than the caller has
        // room for, then only return the number of bytes the caller
        // asked for -- otherwise pfnWideCharFromMultiByte will write
        // off the end of the caller's buffer.
        b = cb;
    }
    if (pfnWideCharFromMultiByte == NULL) // first read() call
    {
        checkhr2(autoDetect());
        if (pfnWideCharFromMultiByte == NULL) // failed to fully determine encoding
            return (lastBuffer) ? S_FALSE : E_PENDING;
        b -= bnext;
        startAt -= bnext;
    }
    hr = (this->pfnWideCharFromMultiByte)(&_dwMode, codepage, buf + bnext, &b, (WCHAR *)pv, &utotal);
    if (hr != S_OK)
        return hr;	
    if (b == 0 && num == 0 && (stream || lastBuffer))
    {
        // stream says we're at the end, but pfnWideCharFromMultiByte
        // disagrees !!
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: XML Parser found incomplete encoding\n");

        return XML_E_INCOMPLETE_ENCODING;
    }
    bnext += b;
    if (pcbRead != NULL)
        *pcbRead = utotal*sizeof(WCHAR);
    return (utotal == 0) ? E_PENDING : S_OK;
} 
//////////////////////////////////////////////////////////////////////////////////
/**
 * Checks the first two/four bytes of the input Stream in order to 
 * detect UTF-16/UCS-4 or UTF-8 encoding;
 * otherwise assume it is UTF-8

 * xiaoyu : since only UCS-2 and UTF-8 are support, we do not deal with others...
 */
HRESULT EncodingStream::autoDetect()
{
    // wait until we have enough to be sure.
    if (btotal < 2)
        return S_OK;

    unsigned int guess = (((unsigned char)buf[0]) << 8) + ((unsigned char)buf[1]);
    HRESULT hr;

    if (guess == 0xFEFF || guess == 0xFFFE) // BOM found
    {
        // wait until we have enough to be sure.
        if (btotal < 4)
            return S_OK;
		
        unsigned int guess1 = (((unsigned char)buf[2]) << 8) + ((unsigned char)buf[3]);
        if (guess == guess1)
        {			
            /*
			if (!encoding)
            {
                static const WCHAR* wchUCS4 = TEXT("UCS-4");
                encoding = Encoding::newEncoding(wchUCS4, 5, (0xFFFE == guess), true);
            }
            bnext = 4;	
			*/
			// FUSION_XML_PARSER does not support UCS4
			return XML_E_INVALIDENCODING;
        }
        else
        {
            if (!encoding)
            {   
                static const WCHAR wchUCS2[] = L"UCS-2";
                encoding = Encoding::newEncoding(wchUCS2, LENGTH(wchUCS2), (0xFFFE == guess), true);
            }
            bnext = 2;
        }

        if (NULL == encoding)
            return E_OUTOFMEMORY;       
        encoding->littleendian =  (0xFFFE == guess);
    }
    else
    {
        if (!encoding)
        {
            encoding = Encoding::newEncoding(L"UTF-8", 5, false, false);
            if (NULL == encoding)
                return E_OUTOFMEMORY;
        }

        // In some system, such as win2k, there is BOM 0xEF BB BF for UTF8
        if (guess == 0xEFBB)
        {
            if (btotal < 3)
                return S_OK;
			
            if (buf[2] == 0xBF)
                _fUTF8BOM = true; 
			
            bnext = 3; 
        }
        else
        {
            encoding->byteOrderMark = false;
        }
    }

    checkhr2(CharEncoder::getWideCharFromMultiByteInfo(encoding, &codepage, &pfnWideCharFromMultiByte, &maxCharSize));
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////////////////
/**
 * Switchs the character encoding of the input stream
 * Returns:
 *         S_OK: succeeded, and do not need re-read
 *         S_FALSE: succeeded, needs to re-read from <code> newPosition </code>
 *         Otherwise: error code
 * Notice: 
 *         This method only works for input stream, newPosition starts with 1
 */
HRESULT EncodingStream::switchEncodingAt(Encoding * newEncoding, int newPosition)
{
    // Ignore encoding information in the document when charset information is set from outside
	// xwu: fusion xml parsed does not use Charset
    //if (_fSetCharset)
    //    return S_OK;


    int l = newPosition - startAt;
    if (l < 0 || l > (int)bnext) 
    {
        // out of range
        delete newEncoding;
        return E_INVALIDARG;
    }

    UINT newcodepage;
    UINT newCharSize;
    //
    // get and check charset information
    //
    WideCharFromMultiByteFunc * pfn;
    HRESULT hr = CharEncoder::getWideCharFromMultiByteInfo(newEncoding, &newcodepage, &pfn, &newCharSize);
    if (hr != S_OK)
    {
        delete newEncoding;
        return E_INVALIDARG;
    }
    if (codepage == newcodepage)
    {
        delete newEncoding;
        return S_OK;
    }

    // Now if we are in UCS-2/UCS-4 we cannot switch out of UCS-2/UCS-4 and if we are
    // not in UCS-2/UCS-4 we cannot switch into UCS-2/UCS-4.
    // Also if UTF-8 BOM is presented, we cannot switch away
    if ((codepage != CP_UCS_2 && newcodepage == CP_UCS_2) ||
        (codepage == CP_UCS_2 && newcodepage != CP_UCS_2) ||
        (codepage == CP_UTF_8 && newcodepage != CP_UTF_8 && _fUTF8BOM))
    {
        delete newEncoding;
        return E_FAIL;
    }

    // Ok, then, let's make the switch.
    if (encoding)
    {
        delete encoding;
    }
    
    encoding = newEncoding;
    maxCharSize = newCharSize;
    codepage = newcodepage;
    pfnWideCharFromMultiByte = pfn;

    // Because the XML declaration is encoded in UTF-8, 
    // Mapping input characters to wide characters is one-to-one mapping
    if ((int)bnext != l)
    {
        bnext = l;
        return S_FALSE;
    }
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////
// minlen is the number of UNICODE, which is the same number of byte we read from the file 
HRESULT EncodingStream::prepareForInput(ULONG minlen)
{
    Assert(btotal >= bnext);
    btotal -= bnext;

    if (bufsize < minlen)
    {
        BYTE* newbuf = NEW (BYTE[minlen]);
        if (newbuf == NULL) { 
            return E_OUTOFMEMORY;
        }

        if (buf){
            ::memcpy(newbuf, buf+bnext, btotal);
            delete[] buf;
        }

        buf = newbuf;
        bufsize = minlen;
    }
    else if (bnext > 0 && btotal > 0)
    {
        // Shift remaining bytes down to beginning of buffer.
        ::memmove(buf, buf + bnext, btotal);          
    }

    startAt += bnext;
    bnext = 0; 
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////
// xiaoyu : here it assumes that it is a BYTE buffer, not a WCHAR byte, so it can be copied directly
HRESULT EncodingStream::AppendData( const BYTE* buffer, ULONG length, BOOL fLastBuffer)
{
    Assert(btotal >= bnext);
    lastBuffer = (fLastBuffer != FALSE);
    HRESULT hr;
    ULONG minlen = length + (btotal - bnext); // make sure we don't loose any data
    if (minlen < BUFFERSIZE)
        minlen = BUFFERSIZE;
    checkhr2( prepareForInput(minlen)); // guarantee enough space in the array
    
    if (length > 0 && buffer != NULL){
        // Copy raw data into new buffer.
        ::memcpy(buf + btotal, buffer, length);
        btotal += length;
    }
	if (pfnWideCharFromMultiByte == NULL) // first AppendData call
    {
        checkhr2(autoDetect());
    }
    

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////
HRESULT EncodingStream::BufferData()
{
    HRESULT hr = S_OK;
    checkhr2(prepareForInput(0)); // 0 is used just for shift down (so bnext=0).

    if (_fEOF)          // already hit the end of the stream.
        return S_FALSE;

    const DWORD BUFSIZE = 4096;

    DWORD dwRead = 1;

    while (S_OK == hr && dwRead > 0)
    {
        // if we cannot fit another buffer full, then re-allocate.
        DWORD minsize = (btotal+BUFSIZE > bufsize) ? bufsize + BUFSIZE : bufsize;
        checkhr2( prepareForInput(minsize)); // make space available.

        dwRead = 0;
        hr = stream->Read(buf + btotal, BUFSIZE, &dwRead);
        btotal += dwRead;
    }

    if (SUCCEEDED(hr) && dwRead == 0)
    {
        _fEOF = true;
        hr = S_FALSE; // return S_FALSE when at eof.
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\codepage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
// Copyright (c) 1994 - 1999 Microsoft Corporation. All rights reserved.*///
//  File:       intl.hxx
//
//  Contents:   Codepage definitions
//
//----------------------------------------------------------------------------

#ifndef _CODEPAGE_H_
#define _CODEPAGE_H_
#pragma once

typedef UINT CODEPAGE;              // Codepage corresponds to Mlang ID

#define CP_UNDEFINED    CODEPAGE(-1)
#define CP_UCS_2        1200

#define CP_UTF_8        65001
#define CP_UCS_4        12000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\charencoder.cxx ===
/*
 * @(#)CharEncoder.cxx 1.0 6/10/97
 * 
* Copyright (c) 1997 - 1999 Microsoft Corporation. All rights reserved. * 
 */
#include "stdinc.h"
#include "core.hxx"
#pragma hdrstop

#include "charencoder.hxx"

//
// Delegate other charsets to mlang
//
const EncodingEntry CharEncoder::charsetInfo [] = 
{
    { CP_UCS_2, L"UTF-16", 2, wideCharFromUcs2Bigendian },
    { CP_UCS_2, L"UCS-2", 2, wideCharFromUcs2Bigendian },
    { CP_UTF_8, L"UTF-8", 3, wideCharFromUtf8 },
};

Encoding * Encoding::newEncoding(const WCHAR * s, ULONG len, bool endian, bool mark)
{
    //Encoding * e = new Encoding();
	Encoding * e = NEW (Encoding());
    if (e == NULL)
        return NULL;
    e->charset = NEW (WCHAR[len + 1]);
    if (e->charset == NULL)
    {
        delete e;
        return NULL;
    }
    ::memcpy(e->charset, s, sizeof(WCHAR) * len);
    e->charset[len] = 0; // guarentee NULL termination.
    e->littleendian = endian;
    e->byteOrderMark = mark;
    return e;
}

Encoding::~Encoding()
{
    if (charset != NULL)
    {
        delete [] charset;
    }
}

int CharEncoder::getCharsetInfo(const WCHAR * charset, CODEPAGE * pcodepage, UINT * mCharSize)
{
    for (int i = LENGTH(charsetInfo) - 1; i >= 0; i--)
    {
        if (::FusionpCompareStrings(charset, ::wcslen(charset), charsetInfo[i].charset, ::wcslen(charsetInfo[i].charset), true) == 0)
        {             
            *pcodepage = charsetInfo[i].codepage;
            *mCharSize = charsetInfo[i].maxCharSize;
            return i;
        } // end of if
    }// end of for

    return -2;
}

/**
 * get information about a code page identified by <code> encoding </code>
 */
HRESULT CharEncoder::getWideCharFromMultiByteInfo(Encoding * encoding, CODEPAGE * pcodepage, WideCharFromMultiByteFunc ** pfnWideCharFromMultiByte, UINT * mCharSize)
{
    HRESULT hr = S_OK;

    int i = getCharsetInfo(encoding->charset, pcodepage, mCharSize);
    if (i >= 0) // in our short list
    {
        switch (*pcodepage)
        {
        case CP_UCS_2:
            if (encoding->littleendian)
                *pfnWideCharFromMultiByte = wideCharFromUcs2Littleendian;
            else
                *pfnWideCharFromMultiByte = wideCharFromUcs2Bigendian;
            break;
        default:
            *pfnWideCharFromMultiByte = charsetInfo[i].pfnWideCharFromMultiByte;
            break;
        }
    }
    else // invalid encoding
    {
        hr = E_FAIL;
    }
    return hr;
}


/**
 * Scans rawbuffer and translates UTF8 characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUtf8(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, WCHAR * buffer, UINT * cch)
{

	UNUSED(pdwMode);
	UNUSED(codepage);

    UINT remaining = *cb;
    UINT count = 0;
    UINT max = *cch;
    ULONG ucs4;

    // UTF-8 multi-byte encoding.  See Appendix A.2 of the Unicode book for more info.
    //
    // Unicode value    1st byte    2nd byte    3rd byte    4th byte
    // 000000000xxxxxxx 0xxxxxxx
    // 00000yyyyyxxxxxx 110yyyyy    10xxxxxx
    // zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
    // 110110wwwwzzzzyy+ 11110uuu   10uuzzzz    10yyyyyy    10xxxxxx
    // 110111yyyyxxxxxx, where uuuuu = wwww + 1
    WCHAR c;
    bool valid = true;

    while (remaining > 0 && count < max)
    {
        // This is an optimization for straight runs of 7-bit ascii 
        // inside the UTF-8 data.
        c = *bytebuffer;
        if (c & 0x80)   // check 8th-bit and get out of here
            break;      // so we can do proper UTF-8 decoding.
        *buffer++ = c;
        bytebuffer++;
        count++;
        remaining--;
    }

    while (remaining > 0 && count < max)
    {
        UINT bytes = 0;
        for (c = *bytebuffer; c & 0x80; c <<= 1)
            bytes++;

        if (bytes == 0) 
            bytes = 1;

        if (remaining < bytes)
        {
            break;
        }
         
        c = 0;
        switch ( bytes )
        {
            case 6: bytebuffer++;    // We do not handle ucs4 chars
            case 5: bytebuffer++;    // except those on plane 1
                    valid = false;
                    // fall through
            case 4: 
                    // Do we have enough buffer?
                    if (count >= max - 1)
                        goto Cleanup;

                    // surrogate pairs
                    ucs4 = ULONG(*bytebuffer++ & 0x07) << 18;
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    ucs4 |= ULONG(*bytebuffer++ & 0x3f) << 12;
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    ucs4 |= ULONG(*bytebuffer++ & 0x3f) << 6;
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;                    
                    ucs4 |= ULONG(*bytebuffer++ & 0x3f);

                    // For non-BMP code values of ISO/IEC 10646, 
                    // only those in plane 1 are valid xml characters
                    if (ucs4 > 0x10ffff)
                        valid = false;

                    if (valid)
                    {
                        // first ucs2 char
                        *buffer++ = static_cast<WCHAR>((ucs4 - 0x10000) / 0x400 + 0xd800);
                        count++;
                        // second ucs2 char
                        c = static_cast<WCHAR>((ucs4 - 0x10000) % 0x400 + 0xdc00);
                    }
                    break;

            case 3: c  = WCHAR(*bytebuffer++ & 0x0f) << 12;    // 0x0800 - 0xffff
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    // fall through
            case 2: c |= WCHAR(*bytebuffer++ & 0x3f) << 6;     // 0x0080 - 0x07ff
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    c |= WCHAR(*bytebuffer++ & 0x3f);
                    break;
                    
            case 1:
                c = WCHAR(*bytebuffer++);                      // 0x0000 - 0x007f
                break;

            default:
                valid = false; // not a valid UTF-8 character.
                break;
        }

        // If the multibyte sequence was illegal, store a FFFF character code.
        // The Unicode spec says this value may be used as a signal like this.
        // This will be detected later by the parser and an error generated.
        // We don't throw an exception here because the parser would not yet know
        // the line and character where the error occurred and couldn't produce a
        // detailed error message.

        if (! valid)
        {
            c = 0xffff;
            valid = true;
        }

        *buffer++ = c;
        count++;
        remaining -= bytes;
    }

Cleanup:
    // tell caller that there are bytes remaining in the buffer to
    // be processed next time around when we have more data.
    *cb -= remaining;
    *cch = count;
    return S_OK;
}


/**
 * Scans bytebuffer and translates UCS2 big endian characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUcs2Bigendian(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, WCHAR * buffer, UINT * cch)
{
	UNUSED(codepage); 
	UNUSED(pdwMode);

    UINT num = *cb >> 1; 
    if (num > *cch)
        num = *cch;
    for (UINT i = num; i > 0; i--)
    {
        *buffer++ = ((*bytebuffer) << 8) | (*(bytebuffer + 1));
        bytebuffer += 2;
    }
    *cch = num;
    *cb = num << 1;
    return S_OK;
}


/**
 * Scans bytebuffer and translates UCS2 little endian characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUcs2Littleendian(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, WCHAR * buffer, UINT * cch)
{
	UNUSED(codepage); 
	UNUSED(pdwMode);

    UINT num = *cb / 2; // Ucs2 is two byte unicode.
    if (num > *cch)
        num = *cch;


    // Optimization for windows platform where little endian maps directly to WCHAR.
    // (This increases overall parser performance by 5% for large unicode files !!)
    ::memcpy(buffer, bytebuffer, num * sizeof(WCHAR));

    *cch = num;
    *cb = num * 2;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\stdinc.h ===
#pragma once
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include "fusionunused.h"
#define MAXDWORD (~(DWORD)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\xmlparser.cxx ===
/////////////////////////////////////////////////////////////////////////////////
//
// fusion\xmlparser\xmlparser.cxx
// just commend "SysFreeString" and SysAllocString()
//
/////////////////////////////////////////////////////////////////////////////////

#include "stdinc.h"
#include "core.hxx"
#include "xmlhelper.hxx"
#pragma hdrstop
#include "xmlparser.hxx"
#include "xmlstream.hxx"
#include <objbase.h>
#include "fusioninitializecriticalsection.h"

const USHORT STACK_INCREMENT=10;

#define PUSHNODEINFO(pNodeInfo)\
    if (_cNodeInfoAllocated == _cNodeInfoCurrent)\
    {\
        checkhr2(GrowNodeInfo());\
    }\
    _paNodeInfo[_cNodeInfoCurrent++] = _pCurrent;



/////////////////////////////////////////////////////////////////////////////
XMLParser::XMLParser()
:   _pDownloads(1),
    _pStack(STACK_INCREMENT),
    _pTokenizer(NULL),
    _pCurrent(NULL),
    _lCurrentElement(0),
    _paNodeInfo(NULL),
    _cNodeInfoAllocated(0),
    _cNodeInfoCurrent(0),
    _pdc(NULL),
    _usFlags(NULL),
    _fCaseInsensitive(false),
    _bstrError(NULL),
    _fRunEntryCount(0),
    _fInsideRun(false),
    _cAttributes(0),
    _pRoot(NULL),
    _fLastError(S_OK),
    _fStopped(false),
    _fSuspended(false),
    _fStarted(false),
    _fWaiting(false),
    _dwSafetyOptions(0)
{
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::HrInitialize()
{
    HRESULT hr = NOERROR;
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
XMLParser::~XMLParser()
{
    Reset();

    // Cleanup tagname buffers in context for good this time...
    for (long i = _pStack.size()-1; i>=0; i--)
    {
        MY_XML_NODE_INFO* pNodeInfo = _pStack[i];
        if (pNodeInfo->_pwcTagName != NULL)
        {
            delete [] pNodeInfo->_pwcTagName;
            pNodeInfo->_pwcTagName = NULL;
            pNodeInfo->_ulBufLen = 0;
        }
        // NULL out the node pointer in case it point's to a GC'd object :-)
        pNodeInfo->pNode = NULL;
    }

    delete[] _paNodeInfo;        
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::QueryInterface(REFIID riid, void ** ppvObject)
{
    // Since this one class implements both IXMLNodeSource and
    // IXMLParser, we must override QueryInterface since the
    // IUnknown template doesn't know about the IXMLNodeSource
    // interface.

    if (ppvObject == NULL)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    if (riid == IID_IXMLNodeSource || riid == IID_Parser)
    {
        *ppvObject = static_cast<IXMLNodeSource*>(this);        
        AddRef();
    }
    else
    {
        hr = _unknown<IXMLParser, &IID_IXMLParser>::QueryInterface(riid, ppvObject);
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE
XMLParser::AddRef(void)
{
    return _unknown<IXMLParser, &IID_IXMLParser>::AddRef();
}
/////////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE
XMLParser::Release(void)
{
    return _unknown<IXMLParser, &IID_IXMLParser>::Release();
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::SetInput(IUnknown *pStm)
{
    if (pStm == NULL)
        return E_INVALIDARG;

    if (_pDownloads.used() == 0)
        init();
    HRESULT hr = S_OK;

    checkhr2(PushTokenizer());

    // Get the url path
    // Continue even if we cannot get it
    IStream * pStream = NULL;
    hr = pStm->QueryInterface(IID_IStream, (void**)&pStream);
    if (SUCCEEDED(hr))
    {
        hr = PushStream(pStream, false);       
        pStream->Release(); 
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::PushData(
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer)
{
    return E_NOTIMPL;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::SetFactory(IXMLNodeFactory __RPC_FAR *pNodeFactory)
{
    //STACK_ENTRY;

    _pFactory = pNodeFactory;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::GetFactory(IXMLNodeFactory** ppNodeFactory)
{
    if (ppNodeFactory == NULL) return E_INVALIDARG;
    if (_pFactory)
    {
        *ppNodeFactory = _pFactory;
        (*ppNodeFactory)->AddRef();
    }
    else
    {
        *ppNodeFactory = NULL;
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::Run(long lChars)
{
    HRESULT hr = NOERROR;

    FN_TRACE_HR(hr);

    XML_NODE_INFO   info;
    XML_NODE_INFO*  aNodeInfo[1];

    USHORT          numRecs;

    bool            fIsAttribute = false;
    bool            stop = false;

    if (_fSuspended)
        _fSuspended = FALSE; // caller must want to resume.

    if (_pFactory == NULL)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: XMLParser::Run() failing because _pFactory is NULL\n");

        hr = E_FAIL;
        goto Exit; 
    }

    if (_fStopped)
    {        
		::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: XMLParser::Run() failing because _fStopped is set\n");

        hr = XML_E_STOPPED;
        goto Exit;
    }

    if (_pTokenizer == NULL) 
    {
        if (_fLastError != S_OK)
		{
			::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: XMLParser::Run() failing because _pTokenizer == NULL and _fLastError != S_OK (== 0x%08lx)\n", _fLastError);

            hr =  _fLastError;
            goto Exit;
		}
        else
		{
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: XMLParser::Run() failing because _pTokenizer == NULL and _fLastError == S_OK\n");

            // must be _fStarted == false
            hr = XMLPARSER_IDLE;
            goto Exit;
		}
    }

    // Check for recurrsive entry and whether caller actually
    // wants anything parsed.
    if (_fInsideRun || lChars == 0)
	{
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: XMLParser::Run() failing because _fInsideRun is set or lChars == 0\n");

        hr = E_PENDING;
        goto Exit;
	}
    {
    BoolLock flock(&_fInsideRun);

    if (_fLastError != 0)
    {
        // one more chance to cleanup the parser stack.
        hr = _fLastError;
        goto cleanup_stack;
    }

    if (! _fStarted)
    {
        _fStarted = true;
        hr = _pFactory->NotifyEvent(this, XMLNF_STARTDOCUMENT);
        if (_fStopped){      // watch for onReadyStateChange handlers 
            hr = S_OK;    // fussing with the parser state.
            goto Exit;
        }
    }

    _fWaiting = false;
    if (_fPendingBeginChildren)
    {
        _fPendingBeginChildren = false;
        hr = _pFactory->BeginChildren(this, (XML_NODE_INFO*)_pCurrent);
    }
    if (_fPendingEndChildren)
    {
        _fPendingEndChildren = false;
        hr = _pFactory->EndChildren(this, TRUE, (XML_NODE_INFO*)_pCurrent);
        if (FAILED(hr))
            hr = pop(); // no match needed
    }

    info.dwSize = sizeof(XML_NODE_INFO);
    info.dwType = XMLStream::XML_PENDING;
    info.dwSubType = 0;
    info.pwcText = NULL;
    info.ulLen = 0;
    info.ulNsPrefixLen = 0;
    info.pNode = NULL;
    info.pReserved = NULL;
    aNodeInfo[0] = &info;

more:
    _fRunEntryCount++; // count of callers inside this loop...

    while (hr == 0 && ! _fSuspended)
    {
        info.dwSubType = 0;

        // The XMLStream error codes have been aligned with the
        // XMLParser error code so no mapping is necessary.
        hr = _pTokenizer->GetNextToken(&info.dwType, (const WCHAR  **)&info.pwcText, (long*)&info.ulLen, (long*)&info.ulNsPrefixLen);
        if (hr == E_PENDING)
        {
            _fWaiting = true;
            break;
        }

        if (! _fFoundNonWS &&
                info.dwType != XMLStream::XML_PENDING &&
                info.dwType != XML_WHITESPACE &&
                info.dwType != XML_XMLDECL)
        {
            _fFoundNonWS = true;
        }

        // Now the NodeType is the same as the XMLToken value.  We set
        // this up by aligning the two enums.
        switch (info.dwType)
        {
        case 0:
            break;
            // --------- Container Nodes -------------------
        case XML_XMLDECL:
            if (_fFoundNonWS)
            {
                hr = XML_E_BADXMLDECL;
                break;
            }
            goto containers;

        case XML_ATTRIBUTE:
            fIsAttribute = true;
            goto containers; 

        case XML_VERSION:
            info.dwSubType = info.dwType;
            info.dwType = XML_ATTRIBUTE;
            _fGotVersion = true;
            fIsAttribute = true;
            goto containers;

        case XML_STANDALONE:
        case XML_ENCODING:
            if (! _fGotVersion && _pDownloads.used() == 1)
            {
                hr = XML_E_EXPECTING_VERSION;
                break;
            }
            if (info.dwType == XML_STANDALONE)
            {
                if (_pDownloads.used() > 1)
                {
                    hr = XML_E_UNEXPECTED_STANDALONE;
                    break;
                }
            }
            info.dwSubType = info.dwType;
            info.dwType = XML_ATTRIBUTE;
            fIsAttribute = true;
            goto containers;
            // fall through
        case XML_ELEMENT:
containers:
            if (_fRootLevel)
            {
                // Special rules apply for root level tags.
                if (info.dwType == XML_ELEMENT)
                {
                     // This is a root level element.
                     if (! _fFoundRoot)
                     {
                         _fFoundRoot = true;
                     }
                     else
                     {
                         ::FusionpDbgPrintEx(
                             FUSION_DBG_LEVEL_ERROR,
                             "SXS.DLL: XML Parser has found multiple roots in the document which is an error.\n");

                         hr = XML_E_MULTIPLEROOTS;
                         break;
                     }
                }
                else if (info.dwType != XML_PI &&
                         info.dwType != XML_XMLDECL &&
                         info.dwType != XML_DOCTYPE)
                {
                     ::FusionpDbgPrintEx(
                         FUSION_DBG_LEVEL_ERROR,
                         "SXS.DLL: XML Parser has found an initial element which is not valid at the root level.\n");

                    hr = XML_E_INVALIDATROOTLEVEL;
                    break;
                }
            }

            info.fTerminal = FALSE;

            if (fIsAttribute)
            {
                breakhr( pushAttribute(info));
                fIsAttribute = false;
            }
            else
            {
                breakhr( push(info));
            }
            break;
        case XML_PCDATA:
        case XML_CDATA:
terminals:
            // Special rules apply for root level tags.
            if (_fRootLevel)
            {
                 ::FusionpDbgPrintEx(
                     FUSION_DBG_LEVEL_ERROR,
                     "SXS.DLL: XML Parser has found PCDATA at the root level which is not valid XML.\n");

                hr = XML_E_INVALIDATROOTLEVEL;
                break;
            }
            // fall through
        case XML_COMMENT:
        case XML_WHITESPACE:
tcreatenode:
            info.fTerminal = TRUE;
            if (_cAttributes != 0)
            {
                // We are inside the attribute list, so we need to push this.
                hr = pushAttributeValue(info);
                break;
            }
            hr = _pFactory->CreateNode(this, _pNode, 1, aNodeInfo);
            info.pNode = NULL;
            break;

        case XML_ENTITYREF:
            if (_fRootLevel)
            {
                hr = XML_E_INVALIDATROOTLEVEL;
                break;
            }

            // We handle builtin entities and char entities in xmlstream
            // so these must be user defined entity, so treat it like a regular terminal node.
            goto terminals;
            break;

        case XMLStream::XML_BUILTINENTITYREF:
        case XMLStream::XML_HEXENTITYREF:
        case XMLStream::XML_NUMENTITYREF:
            // pass real entityref type as subtype so we can publish these
            // subtypes eventually.
            info.dwSubType = info.dwType; // XML_ENTITYREF;
            info.dwType = XML_PCDATA;

            if (_cAttributes == 0)
            {
                goto tcreatenode;
            }

            // We are inside the attribute list, so we need to push this.
            info.fTerminal = TRUE;
            hr = pushAttributeValue(info);
            if (SUCCEEDED(hr))
            {
                hr = CopyText(_pCurrent);
            }
            break;
        
        case XMLStream::XML_TAGEND:     // ">"
            numRecs = 1+_cAttributes;
            if (_cAttributes != 0)  // this is safe because _rawstack does NOT reclaim
            {                       // the popped stack entries.
                popAttributes();
            }
            hr = _pFactory->CreateNode(this, _pNode, numRecs, (XML_NODE_INFO **)&_paNodeInfo[_lCurrentElement]);
            _pNode = _pCurrent->pNode;
            if (FAILED(hr))
            {
                _fPendingBeginChildren = true;
                break;
            }
            breakhr( _pFactory->BeginChildren(this, (XML_NODE_INFO*)_pCurrent));
            break;

			// The ENDXMLDECL is like EMPTYENDTAGs since we've been
            // buffering up their attributes, and we have still got to call CreateNode.
		case XMLStream::XML_ENDXMLDECL:
            _fGotVersion = false; // reset back to initial state.
            // fall through.
        case XMLStream::XML_EMPTYTAGEND:
            numRecs = 1+_cAttributes;
            if (_cAttributes != 0)
            {
                popAttributes();
            }
            hr = _pFactory->CreateNode(this, _pNode, numRecs, (XML_NODE_INFO **)&_paNodeInfo[_lCurrentElement]);
            if (FAILED(hr))
            {
                _fPendingEndChildren = true;
                break;
            }
            breakhr(_pFactory->EndChildren(this, TRUE, (XML_NODE_INFO*)_pCurrent));
            breakhr(pop()); // no match needed
            break;

        case XMLStream::XML_ENDTAG:     // "</"
            if (_pStack.used() == 0)
            {
                 ::FusionpDbgPrintEx(
                     FUSION_DBG_LEVEL_ERROR,
                     "SXS.DLL: XML Parser has found an unexpected end tag.\n");

                hr = XML_E_UNEXPECTEDENDTAG;
            }
            else
            {
                XML_NODE_INFO* pCurrent = (XML_NODE_INFO*)_pCurrent; // save current record
                breakhr(pop(info.pwcText, info.ulLen)); // check tag/match
                breakhr(_pFactory->EndChildren(this, FALSE, (XML_NODE_INFO*)pCurrent));
            }
            break;
        
        case XMLStream::XML_ENDPROLOG:
            // For top level document only, (not for DTD's or
            // entities), call EndProlog on the node factory.
            if (_fRootLevel && ! _pdc->_fEntity && ! _pdc->_fDTD)
                breakhr( _pFactory->NotifyEvent(this, XMLNF_ENDPROLOG));
            break;

        default:
            hr = E_FAIL;
            break; // break from switch()
        }
    }
    _fRunEntryCount--;

    stop = false;
    if (hr == static_cast<HRESULT>(XML_E_ENDOFINPUT))
    {
        hr = S_OK;
        bool inDTD = _pdc->_fDTD;
        bool inEntity = _pdc->_fEntity;
        bool inPEReference = _pdc->_fPEReference;

        if (inEntity && _pdc->_fDepth != _pStack.used())
        {
           ::FusionpDbgPrintEx(
                 FUSION_DBG_LEVEL_ERROR,
                 "SXS.DLL: XML Parser found unclosed tags at the end of the input stream.\n");

            // Entity itself was unbalanced.
            hr = ReportUnclosedTags(_pdc->_fDepth);
        }
        else if (PopDownload() == S_OK)
        {
            // then we must have just finished a DTD and we still have more to do
            // BUGBUG -- need to check that entity is well formed, i.e. no tags
            // left open.

            if (!inPEReference)
            {
                if (inEntity)
                {
                    hr = _pFactory->NotifyEvent(this, XMLNF_ENDENTITY);
                }
                else if (inDTD)
                {
                    hr = _pFactory->NotifyEvent(this, XMLNF_ENDDTD);                    
                }
            }
            if (FAILED(hr))
            {
                goto cleanup_stack;
            }

            // In a synchronous DTD download, there is another parser
            // parser Run() call on the stack above us, so let's return
            // back to that Run method so we don't complete the parsing
            // out from under it.
            if (_fRunEntryCount > 0){
                hr = S_OK;
                goto Exit;
            }

            if (_fStopped){
                hr = S_OK;
                goto Exit;
            }
            goto more;
        }
        else
        {
            if (_pStack.used() > 0)
            {
                hr = ReportUnclosedTags(0);
            }
            else if (! _fFoundRoot)
            {
             ::FusionpDbgPrintEx(
                 FUSION_DBG_LEVEL_ERROR,
                 "SXS.DLL: XML Parser has found no root in the document.\n");

                hr = XML_E_MISSINGROOT;
            }
            stop = true;
        }
    }

cleanup_stack:

    if (hr != S_OK && hr != E_PENDING)
    {
        stop = true;
        _fLastError = hr;

        // Pass all the XML_NODE_INFO structs to the Error function so the client
        // gets a chance to cleanup the PVOID pNode fields.
        HRESULT edr = _pFactory->Error(this, hr,
            (USHORT)(_paNodeInfo ? _lCurrentElement+1 : 0), (XML_NODE_INFO**)_paNodeInfo);
        if (edr != 0)
            _fLastError = hr;
    }

    if (stop && ! _fStopped)
    {
        //TraceTag((tagParserError, "Parser stopping with hr %x", hr));
        _fLastError = hr;
        _fStopped = true;
        _fStarted = false;
        HRESULT edr;
        edr = _pFactory->NotifyEvent(this, XMLNF_ENDDOCUMENT);
        if (edr != 0)
        {
            hr = edr; // allow factory to change error code (except to S_OK)
            if (S_OK == _fLastError)
            {
                // Make sure the node factory always finds out about errors.
                edr = _pFactory->Error(this, hr, 0, NULL);
                if (edr != 0)
                    hr = edr;
            }
            _fLastError = hr;
        }
    }
    }
Exit:
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::popAttributes()
{
    // Now I pop all the attributes that were pushed for this tag.
    // I know we have at least one attribute.
    
    while (_cAttributes > 0)
    {
        popAttribute(); // no match needed
    }
    Assert(_pStack.used() == _lCurrentElement+1);

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::GetParserState(void)
{
    if (_fLastError != 0)
        return static_cast<HRESULT>(XMLPARSER_ERROR);

    if (_fStopped)
        return static_cast<HRESULT>(XMLPARSER_STOPPED);

    if (_fSuspended)
        return static_cast<HRESULT>(XMLPARSER_SUSPENDED);

    if (! _fStarted)
        return static_cast<HRESULT>(XMLPARSER_IDLE);

    if (_fWaiting)
        return static_cast<HRESULT>(XMLPARSER_WAITING);

    return static_cast<HRESULT>(XMLPARSER_BUSY);
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::Abort(
            /* [in] */ BSTR bstrErrorInfo)
{
    _fStopped = true;
    _fSuspended = true; // force Run to terminate...

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::Suspend( void)
{
    _fSuspended = true; // force Run to suspend
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::Reset( void)
{
    init();

    _pRoot = NULL;
    _pFactory = NULL;
    _pNode = NULL;
    _bstrError = NULL;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE
XMLParser::GetLineNumber(void)
{
    if (_pTokenizer)  return _pTokenizer->GetLine();
	else return 0;
}
/////////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE
XMLParser::GetLinePosition( void)
{
    if (_pTokenizer) return _pTokenizer->GetLinePosition();
    else return 0;
}
/////////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE
XMLParser::GetAbsolutePosition( void)
{
    if (_pTokenizer) return _pTokenizer->GetInputPosition();
    else return 0;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::GetLineBuffer(
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos)
{
    if (pulLen == NULL || pulStartPos == NULL) return E_INVALIDARG;

    //STACK_ENTRY;

    if (_pTokenizer)
    {
        return _pTokenizer->GetLineBuffer(ppwcBuf, pulLen, pulStartPos);
    }
    *ppwcBuf = NULL;
    *pulLen = 0;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::GetLastError( void)
{
    return _fLastError;
}

//------------ PRIVATE METHODS --------------------------------------------------
HRESULT
//XMLParser::PushTokenizer(
//				  URLStream* stream)
XMLParser::PushTokenizer()
{
    _pTokenizer = NEW (XMLStream(this));
    if (_pTokenizer == NULL)
        return E_OUTOFMEMORY;

    _pTokenizer->SetFlags(_usFlags);
//    _fTokenizerChanged = true;

    //HRESULT hr= PushDownload(stream, _pTokenizer);
    HRESULT hr= PushDownload(_pTokenizer);
    if (FAILED(hr))
    {
        delete _pTokenizer;
        _pTokenizer = NULL;
        return hr;
    }
    return S_OK; 
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
//XMLParser::PushDownload(URLStream* stream, XMLStream* tokenizer)
XMLParser::PushDownload(XMLStream* tokenizer)
{
    // NOTE: tokenizer can be null, in the case of a parameter entity download.

    _pdc = _pDownloads.push();
    if (_pdc == NULL)
    {
        return E_OUTOFMEMORY;
    }
    if (_pDownloads.used() > 1)
        _fRootLevel = false;

    _pdc->_pTokenizer = tokenizer;
    _pdc->_fDTD = false;
    _pdc->_fEntity = false;
    _pdc->_fAsync = false;
    _pdc->_fFoundNonWS = _fFoundNonWS;
    _pdc->_fFoundRoot = _fFoundRoot;
    _pdc->_fRootLevel = _fRootLevel;
    _pdc->_fDepth = _pStack.used();

    _fFoundNonWS = false;
    _fFoundRoot = false;

    _fRootLevel = (_pStack.used() == 0 && _pDownloads.used() == 1);

    HRESULT hr = S_OK;

    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
XMLParser::PushStream(IStream* pStm, bool fpe)
{
    EncodingStream* stream = (EncodingStream*)EncodingStream::newEncodingStream(pStm); // refcount = 1
    if (stream == NULL)
        return E_OUTOFMEMORY;
/*
    if (_usFlags & XMLFLAG_RUNBUFFERONLY)
        stream->setReadStream(false);
*/
    _pdc->_pEncodingStream = stream;
    stream->Release(); // Smart pointer is holding a ref

    HRESULT hr = _pTokenizer->PushStream(stream, fpe);
    if (hr == E_PENDING)
    {
        _fWaiting = true;
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::PopDownload()
{
    // NOTE: tokenizer can be null, in the case of a parameter entity download.
    HRESULT hr = S_OK;

    if (_pdc != NULL)
    {
        if (_pdc->_pTokenizer)
        {
            _pdc->_pTokenizer->Reset();
            delete _pdc->_pTokenizer;
            _pdc->_pTokenizer = NULL;
        }
        _pdc->_pEncodingStream = NULL;

        // restore saved value of foundnonws.
        _fFoundNonWS = _pdc->_fFoundNonWS;
        _pdc = _pDownloads.pop();
    }
    if (_pdc != NULL)
    {
        if (_pdc->_pTokenizer != NULL)
        {
            _pTokenizer = _pdc->_pTokenizer;
        }
    }
    else
    {
        _pTokenizer = NULL;
        hr = S_FALSE;
    }

    if (_pStack.used() == 0 && _pDownloads.used() == 1)
        _fRootLevel = true;

    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::GrowNodeInfo()
{
    USHORT newsize = _cNodeInfoAllocated + STACK_INCREMENT;
    MY_XML_NODE_INFO** pNewArray = NEW (PMY_XML_NODE_INFO[newsize]);
    if (pNewArray == NULL)
        return E_OUTOFMEMORY;
    // Now since STACK_INCREMENT is the same for _pStack then _pStack
    // has also re-allocated.  Therefore we need to re-initialize all
    // the pointers in this array - since they point into the _pStack's memory.
    for (int i = _pStack.used() - 1; i >= 0; i--)
    {
        pNewArray[i] = _pStack[i];
    }
    delete[] _paNodeInfo;
    _paNodeInfo = pNewArray;
    _cNodeInfoAllocated = newsize;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::GrowBuffer(PMY_XML_NODE_INFO pNodeInfo, long newlen)
{
    delete [] pNodeInfo->_pwcTagName;
    pNodeInfo->_pwcTagName = NULL;
    // add 50 characters to avoid too many reallocations.
    pNodeInfo->_pwcTagName = NEW (WCHAR[ newlen ]);
    if (pNodeInfo->_pwcTagName == NULL)
        return E_OUTOFMEMORY;
    pNodeInfo->_ulBufLen = newlen;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::push(XML_NODE_INFO& info)
{
    HRESULT hr;
    _lCurrentElement = _pStack.used();

    _pCurrent = _pStack.push();
    if (_pCurrent == NULL)
        return E_OUTOFMEMORY;

    *((XML_NODE_INFO*)_pCurrent) = info;
    PUSHNODEINFO(_pCurrent);

    _fRootLevel = false;

    // Save the tag name into the private buffer so it sticks around until the
    // close tag </foo> which could be anywhere down the road after the
    // BufferedStream been overwritten

    // THIS CODE IS OPTIMIZED FOR PERFORMANCE WHICH IS WHY IT IS NOT
    // CALLING THE CopyText METHOD.

    
	if (_pCurrent->_ulBufLen < info.ulLen+1)
    {
        checkhr2(GrowBuffer(_pCurrent, info.ulLen + 50));
    }
    Assert(info.ulLen >= 0);
    ::memcpy(_pCurrent->_pwcTagName, info.pwcText, info.ulLen*sizeof(WCHAR));
    _pCurrent->_pwcTagName[info.ulLen] = L'\0';

    // And make the XML_NODE_INFO point to private buffer.
    _pCurrent->pwcText = _pCurrent->_pwcTagName;

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::pushAttribute(XML_NODE_INFO& info)
{
    HRESULT hr;
    if (_cAttributes != 0)
    {
        // Attributes are special in that they are supposed to be unique.
        // So here we actually check this.
        for (long i = _pStack.used()-1; i > _lCurrentElement; i--)
        {
            XML_NODE_INFO* ptr = _pStack[i];

            if (ptr->dwType != XML_ATTRIBUTE)
                continue; // ignore attribute values.

            if (ptr->ulLen != info.ulLen)
            {
                continue; // we're ok with this one
            }

            // Optimized for the normal case where there is no match
            if (::memcmp(ptr->pwcText, info.pwcText, info.ulLen*sizeof(WCHAR)) == 0)
            {
                if (! _fCaseInsensitive)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS.DLL: XML Parser found a duplicate attribute\n");

                    return XML_E_DUPLICATEATTRIBUTE;
                }
                //else if (StrCmpNI(ptr->pwcText, info.pwcText, info.ulLen) == 0)
                else if (::FusionpCompareStrings(ptr->pwcText, ::wcslen(ptr->pwcText), info.pwcText, info.ulLen, true) == 0)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS.DLL: XML Parser found a duplicate attribute (#2)\n");

                    // Duplicate attributes are allowed in IE4 mode!!
                    // But only the latest one shows up
                    // So we have to delete the previous duplication
                    return XML_E_DUPLICATEATTRIBUTE;
                }
            }
        }
    }

    _cAttributes++;

    _pCurrent = _pStack.push();
    if (_pCurrent == NULL)
        return E_OUTOFMEMORY;

    *((XML_NODE_INFO*)_pCurrent) = info;
    PUSHNODEINFO(_pCurrent);

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::pushAttributeValue(XML_NODE_INFO& info)
{
    HRESULT hr;
    // Attributes are saved in the BufferedStream so we can point to the
    // real text in the buffered stream instead of copying it !!

    _pCurrent = _pStack.push();
    if (_pCurrent == NULL)
        return E_OUTOFMEMORY;

    // store attribute value quote character in the pReserved field.
    info.pReserved = (PVOID)_pTokenizer->getAttrValueQuoteChar();

    *((XML_NODE_INFO*)_pCurrent) = info;
    PUSHNODEINFO(_pCurrent);

    // this is really the count of nodes on the stack, not just attributes.
    _cAttributes++;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::pop(const WCHAR* tag, ULONG len)
{
    HRESULT hr = S_OK;

    if (_pCurrent == NULL || _pStack.used() == 0)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: XML Parser found an unexpected end tag.\n");

        hr = XML_E_UNEXPECTEDENDTAG;
        goto Cleanup;
    }
    if (len != 0)
    {
        if (_pCurrent->ulLen != len)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: XML Parser found an end tag mismatch\n");

            hr = XML_E_ENDTAGMISMATCH;
        }
        // Optimized for the normal case where there is no match
        else if (::memcmp(_pCurrent->pwcText, tag, len*sizeof(WCHAR)) != 0)
        {
            if (! _fCaseInsensitive)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: XML Parser found an end tag mismatch.\n");

                hr = XML_E_ENDTAGMISMATCH;
            }
            else if (::FusionpCompareStrings(_pCurrent->pwcText, len, tag, len, true) != 0)
            {
                hr = XML_E_ENDTAGMISMATCH;
            }
        }
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    // We don't delete the fTagName because we're going to reuse this field
    // later to avoid lots of memory allocations.

    _pCurrent = _pStack.pop();
    _cNodeInfoCurrent--;

    if (_pCurrent == 0)
    {
        _pNode = _pRoot;
        if (_pDownloads.used() == 1)
            _fRootLevel = true;
    }
    else
    {
        _pNode = _pCurrent->pNode;
    }

Cleanup:
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT XMLParser::pop()
{
    // We don't delete the fTagName because we're going to reuse this field
    // later to avoid lots of memory allocations.

    _pCurrent = _pStack.pop();
    _cNodeInfoCurrent--;

    if (_pCurrent == 0)
    {
        _pNode = _pRoot;
        if (_pDownloads.used() == 1)
            _fRootLevel = true;
    }
    else
    {
        _pNode = _pCurrent->pNode;
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
void XMLParser::popAttribute()
{
    Assert(_pStack.used() > 0);

    _pCurrent = _pStack.pop();
    _cNodeInfoCurrent--;

    Assert(_pCurrent != 0);

    _cAttributes--;

}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::CopyText(PMY_XML_NODE_INFO pNodeInfo)
{
    HRESULT hr = S_OK;
    if (pNodeInfo->_pwcTagName != pNodeInfo->pwcText)
    {
        ULONG len = pNodeInfo->ulLen;

        // Copy the current text into the buffer.
        if (pNodeInfo->_ulBufLen < len+1)
        {
            checkhr2(GrowBuffer(pNodeInfo, len + 50));
        }
        if (len > 0)
        {
            ::memcpy(pNodeInfo->_pwcTagName, pNodeInfo->pwcText, len*sizeof(WCHAR));
        }
        pNodeInfo->_pwcTagName[len] = L'\0';

        // And make the XML_NODE_INFO point to private buffer.
        pNodeInfo->pwcText = pNodeInfo->_pwcTagName;
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::CopyContext()
{
    // For performance reasons we try not to copy the data for attributes
    // and their values when we push them on the stack.  We can do this
    // because the tokenizer tries to freeze the internal buffers while
    // parsing attributes and thereby guarentee that the pointers stay
    // good.  But occasionally the BufferedStream has to reallocate when
    // the attributes are right at the end of the buffer.

    long last = _pStack.used();
    for (long i = _cAttributes; i > 0 ; i--)
    {
        long index = last - i;
        MY_XML_NODE_INFO* ptr = _pStack[index];
        CopyText(ptr);
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT XMLParser::ReportUnclosedTags(int start)
{
    HRESULT hr = XML_E_UNCLOSEDTAG;
    // Build a string containing the list of unclosed tags and format an error
    // message containing this text.
    int tags = _pStack.used();

    WCHAR* buffer = NULL;
    WCHAR* msgbuf = NULL;
    unsigned long size = 0;
    unsigned long used = 0;

    for (long i = start; i < tags; i++)
    {
        XML_NODE_INFO* ptr = _pStack[i];
        if (ptr->dwType == XML_ATTRIBUTE)
            break;

        if (used + ptr->ulLen + 3 > size) // +3 for '<','>' and '\0'
        {
            long newsize = used + ptr->ulLen + 500;
            WCHAR* newbuf = NEW (WCHAR[newsize]);
            if (newbuf == NULL)
            {
                goto nomem;
            }
            if (buffer != NULL)
            {
                //
                // Used appears to be the number of -characters- that are
                // being allocated, not the number of -bytes-.  So, we need
                // to multiply it by the size of a character.
                //
                ::memcpy(newbuf, buffer, used * sizeof(WCHAR));
                delete[] buffer;
            }

            size = newsize;
            buffer = newbuf;
        }
        if (i > start)
        {
            buffer[used++] = ',';
            buffer[used++] = ' ';
        }
        ::memcpy(&buffer[used], ptr->pwcText, sizeof(WCHAR) * ptr->ulLen);
        used += ptr->ulLen;
        buffer[used] = '\0';
    }
    goto cleanup; 

nomem:
    hr = E_OUTOFMEMORY;

cleanup:    

    delete [] buffer;
    delete [] msgbuf;

    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT XMLParser::init()
{
    _fLastError = 0;
    _fStopped = false;
    _fSuspended = false;
    _pNode = _pRoot;
    _fStarted = false;
    _fStopped = false;
    _fWaiting = false;
    _fFoundRoot = false;
    _fFoundNonWS = false;
    _pTokenizer = NULL;
    _fGotVersion = false;
    _fRootLevel = true;
    _cAttributes = 0;
    

    _fPendingBeginChildren = false;
    _fPendingEndChildren = false;

    while (_pCurrent != NULL)
    {
        _pCurrent = _pStack.pop();
    }

    _cNodeInfoCurrent = 0;
    _lCurrentElement = 0;

    // cleanup downloads
    while (_pdc != NULL)
    {
        PopDownload();
    }

    _pCurrent = NULL;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
XMLParser::ErrorCallback(HRESULT hr)
{
    Assert(hr == XMLStream::XML_DATAAVAILABLE ||
           hr == XMLStream::XML_DATAREALLOCATE);

    if (hr == static_cast<HRESULT>(XMLStream::XML_DATAREALLOCATE))
    {
        // This is more serious.  We have to actually save away the
        // context because the buffers are about to be reallocated.
        checkhr2(CopyContext());
    }
    checkhr2(_pFactory->NotifyEvent(this, XMLNF_DATAAVAILABLE));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\xmlhelper.cxx ===
#include "stdinc.h"
#include <windows.h>
#include <shlwapi.h>
#include <wchar.h>
#include <string.h>
#include <stdio.h> 
#include <ole2.h>
#include <xmlparser.h>

#include "xmlhelper.hxx"

bool isCharAlphaW(WCHAR wChar)
{
    FN_TRACE();

    WORD ctype1info;

    if (!GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info)) {
        //
        // GetStringTypeW returned an error!  IsCharAlphaW has no
        // provision for returning an error...  The best we can do
        // is to return FALSE
        //
        //UserAssert(FALSE);
		ASSERT(FALSE);
        return FALSE;
    }
    if (ctype1info & C1_ALPHA) {
        return TRUE;
    } else {
        return FALSE;
    }
}
//////////////////////////////////////////////////////////////////////////////
bool isDigit(WCHAR ch)
{
    return (ch >= 0x30 && ch <= 0x39);
}
//////////////////////////////////////////////////////////////////////////////
bool isHexDigit(WCHAR ch)
{
    return (ch >= '0' && ch <= '9' ) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');
}
//////////////////////////////////////////////////////////////////////////////
bool isLetter(WCHAR ch)
{
    return (ch >= 'a') && ::isCharAlphaW(ch);
}
//////////////////////////////////////////////////////////////////////////////
int isStartNameChar(WCHAR ch)
{
    return  (ch < TABLE_SIZE) ? (g_anCharType[ch] & (FLETTER | FSTARTNAME))
        : (isLetter(ch) || (ch == '_' || ch == ':'));
        
}
//////////////////////////////////////////////////////////////////////////////
bool isCombiningChar(WCHAR ch)
{
	UNUSED(ch);
    return false;
}
//////////////////////////////////////////////////////////////////////////////
bool isExtender(WCHAR ch)
{
    return (ch == 0xb7);
}
//////////////////////////////////////////////////////////////////////////////
bool isAlphaNumeric(WCHAR ch)
{
    return (ch >= '0' && ch <= '9') || ((ch >= 'a') && isCharAlphaW(ch));
}
//////////////////////////////////////////////////////////////////////////////
int isNameChar(WCHAR ch)
{
    return  (ch < TABLE_SIZE ? (g_anCharType[ch] & (FLETTER | FDIGIT | FMISCNAME | FSTARTNAME)) :
              ( isAlphaNumeric(ch) || 
                ch == '-' ||  
                ch == '_' ||
                ch == '.' ||
                ch == ':' ||
                isCombiningChar(ch) ||
                isExtender(ch)));
}
//////////////////////////////////////////////////////////////////////////////
int isCharData(WCHAR ch)
{
    // it is in the valid range if it is greater than or equal to
    // 0x20, or it is white space.
    return (ch < TABLE_SIZE) ?  (g_anCharType[ch] & FCHARDATA)
        : ((ch < 0xD800 && ch >= 0x20) ||   // Section 2.2 of spec.
            (ch >= 0xE000 && ch < 0xfffe));
}
//==============================================================================
WCHAR BuiltinEntity(const WCHAR* text, ULONG len)
{
    ULONG ulength =  len * sizeof(WCHAR); // Length in chars
    switch (len)
    {
    case 4:
        if (::memcmp(L"quot", text, ulength) == 0)
        {
            return '\"';
        }
        else if (::memcmp(L"apos", text, ulength) == 0)
        {
            return '\'';
        }
        break;
    case 3:
        if (::memcmp(L"amp", text, ulength) == 0)
        {
            return '&';
        }
        break;
    case 2:
        if (::memcmp(L"lt", text, ulength) == 0)
        {
            return '<';
        }
        else if (::memcmp(L"gt", text, ulength) == 0)
        {
            return '>';
        }
        break;
    }
    return 0;
}
// Since we cannot use the SHLWAPI wnsprintfA function...
int DecimalToBuffer(long value, char* buffer, int j, long maxdigits)
{
    long max = 1;
    for (int k = 0; k < maxdigits; k++)
        max = max * 10;
    if (value > (max*10)-1)
        value = (max*10)-1;
    max = max/10;
    for (int i = 0; i < maxdigits; i++)
    {
        long digit = (value / max);
        value -= (digit * max);
        max /= 10;
        buffer[i+j] = char('0' + (char)digit);
    }
    buffer[i+j]=0;

    return i+j;
}
/////////////////////////////////////////////////////////////////////
int StrToBuffer(const WCHAR* str, WCHAR* buffer, int j)
{
    while (*str != UNICODE_NULL)
    {
        buffer[j++] = *str++;
    }
    return j;
}
//==============================================================================
const ULONG MAXWCHAR = 0xFFFF;
HRESULT DecimalToUnicode(const WCHAR* text, ULONG len, WCHAR& ch)
{
    ULONG result = 0;
    for (ULONG i = 0; i < len; i++)
    {
        ULONG digit = 0;
        if (text[i] >= L'0' && text[i] <= L'9')
        {
            digit = (text[i] - L'0');
        }
        else
            return XML_E_INVALID_DECIMAL;

        // Last unicode value (MAXWCHAR) is reserved as "invalid value"
        if (result >= (MAXWCHAR - digit) /10)       // result is about to overflow
            return XML_E_INVALID_UNICODE;          // the maximum 4 byte value.

        result = (result*10) + digit;
    }
    if (result == 0)    // zero is also invalid.
        return XML_E_INVALID_UNICODE;

    ch = (WCHAR)result;
    return S_OK;
}
//==============================================================================
HRESULT HexToUnicode(const WCHAR* text, ULONG len, WCHAR& ch)
{
    ULONG result = 0;
    for (ULONG i = 0; i < len; i++)
    {
        ULONG digit = 0;
        if (text[i] >= L'a' && text[i] <= L'f')
        {
            digit = 10 + (text[i] - L'a');
        }
        else if (text[i] >= L'A' && text[i] <= L'F')
        {
            digit = 10 + (text[i] - L'A');
        }
        else if (text[i] >= L'0' && text[i] <= L'9')
        {
            digit = (text[i] - L'0');
        }
        else
            return XML_E_INVALID_HEXIDECIMAL;

        // Last unicode value (MAXWCHAR) is reserved as "invalid value"
        if (result >= (MAXWCHAR - digit)/16)       // result is about to overflow
            return XML_E_INVALID_UNICODE;  // the maximum 4 byte value.

        result = (result*16) + digit;
    }
    if (result == 0)    // zero is also invalid.
        return XML_E_INVALID_UNICODE;
    ch = (WCHAR)result;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\_reference.cxx ===
/*
 * @(#)_reference.cxx 1.0 6/3/97
 *
* Copyright (c) 1997 - 1999 Microsoft Corporation. All rights reserved. *
 */
#include "stdinc.h"
#include "core.hxx"
#pragma hdrstop

void _assign(IUnknown ** ppref, IUnknown * pref)
{
    IUnknown *punkRef = *ppref;

    // NTRAID#NTBUG9 - 571792 - jonwis - 2002/04/25 - Dead code removal
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	if (pref) ((Object *)pref)->AddRef();
		(*ppref) = (Object *)pref;
#else // fusion xml parser
    if (pref) pref->AddRef();
    (*ppref) = pref;

#endif

    if (punkRef) punkRef->Release();
}

void _release(IUnknown ** ppref)
{
    if (*ppref)
    {
        (*ppref)->Release();
        *ppref = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\_rawstack.cxx ===
/*
 * @(#)_rawstack.cxx 1.0 3/30/98
 *
*  Copyright (C) 1998,1999 Microsoft Corporation. All rights reserved. *
 */
#include "stdinc.h"
#include "core.hxx"
#pragma hdrstop

#include "_rawstack.hxx"

//===========================================================================
RawStack::RawStack(long entrySize, long growth)
    : _lEntrySize(entrySize), _lGrowth(growth), _pStack(NULL), _ncUsed(0), _ncSize(0)
{
}

RawStack::~RawStack()
{
    if (_pStack != NULL)
    {
        delete _pStack;
        _pStack = NULL;
    }            
}

char*
RawStack::__push()
{
    // No magic object construction -- user has to do this.
    // NTRAID#NTBUG9 - 571792 - jonwis - 2002/04/25 - Dead code removal
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	char* newStack = new_ne char[_lEntrySize * ( _ncSize + _lGrowth) ];
#else
	char* newStack = NEW (char[_lEntrySize * ( _ncSize + _lGrowth) ]);
#endif
    if (newStack == NULL)
    {
        return NULL;
    }
    ::memset(newStack, 0, _lEntrySize * (_ncSize + _lGrowth));
    if (_ncUsed > 0)
    {
        ::memcpy(newStack, _pStack, _lEntrySize * _ncUsed);
    }
    _ncSize += _lGrowth;
    delete _pStack;
    _pStack = newStack;

    return &_pStack[_lEntrySize * _ncUsed++];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\inc\base.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    base.h

Abstract:

    This include file defines the type and constant definitions that are
    shared by the client and server portions of the BASE portion of the
    Windows subsystem.

Author:

    Steve Wood (stevewo) 25-Oct-1990

Revision History:

--*/

#if !defined(_WINDOWS_BASE)
#define _WINDOWS_BASE 1

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winbasep.h>
#include <string.h>
#include <stdarg.h>

//
// Define debugging flag as false if not defined already.
//

#ifndef DBG
#define DBG 0
#endif


//
// Define IF_DEBUG macro that can be used to enable debugging code that is
// optimized out if the debugging flag is false.
//

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

//
// Include Windows Subsystem common definitions
//

#include <conroute.h>

//
// Include definitions for the runtime DLL shared between the client and
// server portions of the Base portion of the Windows subsystem
//

#define WIN32_SS_PIPE_FORMAT_STRING    "\\Device\\NamedPipe\\Win32Pipes.%08x.%08x"

//
// Macros for interoperability between 32bit and 64bit code.

#if defined(BUILD_WOW6432)

#define BASE_SHARED_PTR(TYPE_NAME)  ULONGLONG
#define BASE_SHARED_STRING UNICODE_STRING64 

#define UStr64ToUStr(dst, src) ( (dst)->Length = (src)->Length, \
                                 (dst)->MaximumLength = (src)->MaximumLength, \
                                 (dst)->Buffer = (PWSTR) ((src)->Buffer), \
                                 (dst) \
                               )

#define UStrToUStr64(dst, src) ( (dst)->Length = (src)->Length, \
                                 (dst)->MaximumLength = (src)->MaximumLength, \
                                 (dst)->Buffer = (ULONGLONG) ((src)->Buffer), \
                                 (dst) \
                               )

// In the 32BIT kernel32, on NT64 multiple the index by 2 since pointer 
// are twice are large.
#define BASE_SHARED_SERVER_DATA (NtCurrentPeb()->ReadOnlyStaticServerData[BASESRV_SERVERDLL_INDEX*2]) 
#define BASE_SERVER_STR_TO_LOCAL_STR(d,s) UStr64ToUStr(d,s)
#define BASE_READ_REMOTE_STR_TEMP(temp) UNICODE_STRING temp
#define BASE_READ_REMOTE_STR(str,temp) (UStr64ToUStr(&(temp),&(str)))

#else

#define BASE_SHARED_PTR(TYPE_NAME) TYPE_NAME
#define BASE_SHARED_STRING UNICODE_STRING 

#define BASE_SHARED_SERVER_DATA (NtCurrentPeb()->ReadOnlyStaticServerData[BASESRV_SERVERDLL_INDEX])
#define BASE_SERVER_STR_TO_LOCAL_STR(d,s) *(d)=*(s)
#define BASE_READ_REMOTE_STR_TEMP(temp) 
#define BASE_READ_REMOTE_STR(str,temp) (&(str))

#endif

#if defined(BUILD_WOW6432) || defined(_WIN64)
#define BASE_SYSINFO (SysInfo)
#else
#define BASE_SYSINFO (BaseStaticServerData->SysInfo)
#endif

//
// These structures are kept in the global shared memory section created
// in the server and mapped readonly into each client address space when
// they connect to the server.
//

typedef struct _INIFILE_MAPPING_TARGET {
    BASE_SHARED_PTR(struct _INIFILE_MAPPING_TARGET *) Next;
    BASE_SHARED_STRING RegistryPath;
} INIFILE_MAPPING_TARGET, *PINIFILE_MAPPING_TARGET;

typedef struct _INIFILE_MAPPING_VARNAME {
    BASE_SHARED_PTR(struct _INIFILE_MAPPING_VARNAME *) Next;
    BASE_SHARED_STRING Name;
    ULONG MappingFlags;
    BASE_SHARED_PTR(PINIFILE_MAPPING_TARGET) MappingTarget;
} INIFILE_MAPPING_VARNAME, *PINIFILE_MAPPING_VARNAME;

#define INIFILE_MAPPING_WRITE_TO_INIFILE_TOO    0x00000001
#define INIFILE_MAPPING_INIT_FROM_INIFILE       0x00000002
#define INIFILE_MAPPING_READ_FROM_REGISTRY_ONLY 0x00000004
#define INIFILE_MAPPING_APPEND_BASE_NAME        0x10000000
#define INIFILE_MAPPING_APPEND_APPLICATION_NAME 0x20000000
#define INIFILE_MAPPING_SOFTWARE_RELATIVE       0x40000000
#define INIFILE_MAPPING_USER_RELATIVE           0x80000000

typedef struct _INIFILE_MAPPING_APPNAME {
    BASE_SHARED_PTR(struct _INIFILE_MAPPING_APPNAME *) Next;
    BASE_SHARED_STRING Name;
    BASE_SHARED_PTR(PINIFILE_MAPPING_VARNAME) VariableNames;
    BASE_SHARED_PTR(PINIFILE_MAPPING_VARNAME) DefaultVarNameMapping;
} INIFILE_MAPPING_APPNAME, *PINIFILE_MAPPING_APPNAME;
typedef CONST INIFILE_MAPPING_APPNAME* PCINIFILE_MAPPING_APPNAME;

typedef struct _INIFILE_MAPPING_FILENAME {
    BASE_SHARED_PTR(struct _INIFILE_MAPPING_FILENAME *) Next;
    BASE_SHARED_STRING Name;
    BASE_SHARED_PTR(PINIFILE_MAPPING_APPNAME) ApplicationNames;
    BASE_SHARED_PTR(PINIFILE_MAPPING_APPNAME) DefaultAppNameMapping;
} INIFILE_MAPPING_FILENAME, *PINIFILE_MAPPING_FILENAME;
typedef CONST INIFILE_MAPPING_FILENAME* PCINIFILE_MAPPING_FILENAME;

typedef struct _INIFILE_MAPPING {
    BASE_SHARED_PTR(PINIFILE_MAPPING_FILENAME) FileNames;
    BASE_SHARED_PTR(PINIFILE_MAPPING_FILENAME) DefaultFileNameMapping;
    BASE_SHARED_PTR(PINIFILE_MAPPING_FILENAME) WinIniFileMapping;
    ULONG Reserved;
} INIFILE_MAPPING, *PINIFILE_MAPPING;
typedef CONST INIFILE_MAPPING* PCINIFILE_MAPPING;

//
// NLS Information.
//

#define NLS_INVALID_INFO_CHAR  0xffff       /* marks cache string as invalid */

#define MAX_REG_VAL_SIZE       80           /* max size of registry value */

#define NLS_CACHE_MUTANT_NAME  L"NlsCacheMutant"  /* Name of NLS mutant cache */

typedef struct _NLS_USER_INFO {
    WCHAR sAbbrevLangName[MAX_REG_VAL_SIZE];
    WCHAR iCountry[MAX_REG_VAL_SIZE];
    WCHAR sCountry[MAX_REG_VAL_SIZE];
    WCHAR sList[MAX_REG_VAL_SIZE];
    WCHAR iMeasure[MAX_REG_VAL_SIZE];
    WCHAR iPaperSize[MAX_REG_VAL_SIZE];
    WCHAR sDecimal[MAX_REG_VAL_SIZE];
    WCHAR sThousand[MAX_REG_VAL_SIZE];
    WCHAR sGrouping[MAX_REG_VAL_SIZE];
    WCHAR iDigits[MAX_REG_VAL_SIZE];
    WCHAR iLZero[MAX_REG_VAL_SIZE];
    WCHAR iNegNumber[MAX_REG_VAL_SIZE];
    WCHAR sNativeDigits[MAX_REG_VAL_SIZE];
    WCHAR iDigitSubstitution[MAX_REG_VAL_SIZE];
    WCHAR sCurrency[MAX_REG_VAL_SIZE];
    WCHAR sMonDecSep[MAX_REG_VAL_SIZE];
    WCHAR sMonThouSep[MAX_REG_VAL_SIZE];
    WCHAR sMonGrouping[MAX_REG_VAL_SIZE];
    WCHAR iCurrDigits[MAX_REG_VAL_SIZE];
    WCHAR iCurrency[MAX_REG_VAL_SIZE];
    WCHAR iNegCurr[MAX_REG_VAL_SIZE];
    WCHAR sPosSign[MAX_REG_VAL_SIZE];
    WCHAR sNegSign[MAX_REG_VAL_SIZE];
    WCHAR sTimeFormat[MAX_REG_VAL_SIZE];
    WCHAR sTime[MAX_REG_VAL_SIZE];
    WCHAR iTime[MAX_REG_VAL_SIZE];
    WCHAR iTLZero[MAX_REG_VAL_SIZE];
    WCHAR iTimeMarkPosn[MAX_REG_VAL_SIZE];
    WCHAR s1159[MAX_REG_VAL_SIZE];
    WCHAR s2359[MAX_REG_VAL_SIZE];
    WCHAR sShortDate[MAX_REG_VAL_SIZE];
    WCHAR sDate[MAX_REG_VAL_SIZE];
    WCHAR iDate[MAX_REG_VAL_SIZE];
    WCHAR sYearMonth[MAX_REG_VAL_SIZE];
    WCHAR sLongDate[MAX_REG_VAL_SIZE];
    WCHAR iCalType[MAX_REG_VAL_SIZE];
    WCHAR iFirstDay[MAX_REG_VAL_SIZE];
    WCHAR iFirstWeek[MAX_REG_VAL_SIZE];
    WCHAR sLocale[MAX_REG_VAL_SIZE];
    LCID  UserLocaleId;
    LUID  InteractiveUserLuid;
    ULONG ulCacheUpdateCount; 
} NLS_USER_INFO, *PNLS_USER_INFO;

typedef struct _BASE_STATIC_SERVER_DATA {
                BASE_SHARED_STRING WindowsDirectory;
                BASE_SHARED_STRING WindowsSystemDirectory;
                BASE_SHARED_STRING NamedObjectDirectory;
                USHORT WindowsMajorVersion;
                USHORT WindowsMinorVersion;
                USHORT BuildNumber;
                USHORT CSDNumber;
                USHORT RCNumber;
                WCHAR CSDVersion[ 128 ];
#if (!defined(BUILD_WOW6432) && !defined(_WIN64))
                SYSTEM_BASIC_INFORMATION SysInfo;
#endif
                SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;
                BASE_SHARED_PTR(PINIFILE_MAPPING) IniFileMapping;
                NLS_USER_INFO NlsUserInfo;
                BOOLEAN DefaultSeparateVDM;
                BOOLEAN ForceDos;
                BASE_SHARED_STRING WindowsSys32x86Directory;
                BOOLEAN fTermsrvAppInstallMode;
                TIME_ZONE_INFORMATION tziTermsrvClientTimeZone;
                KSYSTEM_TIME ktTermsrvClientBias;
                ULONG TermsrvClientTimeZoneId;
                BOOLEAN LUIDDeviceMapsEnabled;

} BASE_STATIC_SERVER_DATA, *PBASE_STATIC_SERVER_DATA;

//
//Hydra Specific globals and prototypes
//
#define MAX_SESSION_PATH  256
#define SESSION_ROOT L"\\Sessions"
ULONG SessionId;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\xmlparsertest.cxx ===
#include "stdinc.h"
#include "fusioneventlog.h"
#include "xmlparsertest.hxx"
#include "stdio.h"
#include "FusionEventLog.h"
#include "xmlparser.hxx"

VOID PrintTreeFromRoot(SXS_XMLTreeNode * Root)
{
    SXS_XMLTreeNode * pChild;
    SXS_XMLTreeNode * pNext;

    if (Root == NULL) 
        return; 

    Root->PrintSelf(); 
    pChild = Root->m_pFirstChild; 
    if (pChild == NULL)
        return; 
    FusionpDbgPrint("BeginChildren\n");
    while (pChild)
    { 
        pNext = pChild->m_pSiblingNode;                
        PrintTreeFromRoot(pChild); 
        pChild = pNext;      
    }    
    FusionpDbgPrint("EndChildren\n");
    return; 
}
    
HRESULT XMLParserTestFactory::Initialize()
{
    HRESULT hr = NOERROR;

    if ((m_Tree != NULL) || (m_pNamespaceManager != NULL))
    {
        hr = E_FAIL;
        goto Exit;
    }
    
    if ((m_Tree != NULL) || (m_pNamespaceManager != NULL))
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    m_Tree = new SXS_XMLDOMTree;
    if (m_Tree == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    m_pNamespaceManager = new CXMLNamespaceManager;
    if (m_pNamespaceManager == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }    
    if (!m_pNamespaceManager->Initialize())
    {
         hr = HRESULT_FROM_WIN32(::GetLastError());
         goto Exit;
    }
    hr = NOERROR;
Exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT
STDMETHODCALLTYPE
XMLParserTestFactory::NotifyEvent( 
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ XML_NODEFACTORY_EVENT iEvt)
{

    UNUSED(pSource);
    UNUSED(iEvt);
    switch (iEvt)
    {
    case XMLNF_STARTDTDSUBSET:
        FusionpDbgPrint(" [");
        //_fNLPending = true;
        break;
    case XMLNF_ENDDTDSUBSET:
        FusionpDbgPrint("]");
        //_fNLPending = true;
        break;
    }
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT
STDMETHODCALLTYPE
XMLParserTestFactory::BeginChildren( 
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ XML_NODE_INFO *pNodeInfo)
{
    UNUSED(pSource);
    UNUSED(pNodeInfo); 
    HRESULT hr = NOERROR; 

    FusionpDbgPrint("BeginChildren\n");   
    hr = m_pNamespaceManager->OnBeginChildren(pSource,pNodeInfo);
    m_Tree->SetChildCreation();
    return hr;

}
//---------------------------------------------------------------------------
HRESULT
STDMETHODCALLTYPE
XMLParserTestFactory::EndChildren( 
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ BOOL fEmptyNode,
    /* [in] */ XML_NODE_INFO *pNodeInfo)
{
    UNUSED(pSource);
    UNUSED(fEmptyNode);
    UNUSED(pNodeInfo);
    HRESULT hr = NOERROR; 

    FusionpDbgPrint("EndChildren"); 
    hr= m_pNamespaceManager->OnEndChildren(pSource, fEmptyNode, pNodeInfo);    

    if ( fEmptyNode ) { 
        FusionpDbgPrint("(fEmpty=TRUE)\n");
    }else{
        m_Tree->ReturnToParent();
        //m_Tree->TurnOffFirstChildFlag();
        FusionpDbgPrint("\n");
    }

    return hr;
}
//---------------------------------------------------------------------------
HRESULT
STDMETHODCALLTYPE
XMLParserTestFactory::CreateNode( 
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ PVOID pNode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO* * apNodeInfo)
{
    HRESULT hr = NOERROR;

    FN_TRACE_HR(hr);
  
//    XML_NODE_INFO* pNodeInfo = *apNodeInfo; // generates c4189: 'pNodeInfo' : local variable is initialized but not referenced
    DWORD i;

    // use of namespace
    CSmallStringBuffer buffNamespace; 
    SIZE_T cchNamespacePrefix;

    UNUSED(pSource);
    UNUSED(pNode);
    UNUSED(apNodeInfo);
    UNUSED(cNumRecs);

    
    if ( apNodeInfo[0]->dwType == XML_ELEMENT || apNodeInfo[0]->dwType == XML_PCDATA) 
        m_Tree->AddNode(cNumRecs, apNodeInfo);


    FusionpDbgPrint("CreateNode\n");
    for( i = 0; i < cNumRecs; i++) {
        switch(apNodeInfo[i]->dwType) {
            case XML_CDATA:
                ::FusionpDbgPrint("\t\t XML_CDATA: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_COMMENT : 
                ::FusionpDbgPrint("\t\t XML_COMMENT: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;  
            case XML_WHITESPACE : 
                ::FusionpDbgPrint("\t\t XML_WHITESPACE: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;  
            case XML_ELEMENT : 
                ::FusionpDbgPrint("\t\t XML_ELEMENT: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;  
            case XML_ATTRIBUTE : 
                ::FusionpDbgPrint("\t\t XML_ATTRIBUTE: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;  
            case XML_PCDATA : 
                ::FusionpDbgPrint("\t\t XML_PCDATA: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_PI:
                ::FusionpDbgPrint("\t\t XML_PI: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_XMLDECL : 
                ::FusionpDbgPrint("\t\t XML_XMLDECL: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_DOCTYPE : 
                ::FusionpDbgPrint("\t\t XML_DOCTYPE: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_ENTITYDECL :
                ::FusionpDbgPrint("\t\t XML_ENTITYDECL: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_ELEMENTDECL :
                ::FusionpDbgPrint("\t\t XML_ELEMENTDECL: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_ATTLISTDECL :
                ::FusionpDbgPrint("\t\t XML_ATTLISTDECL: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_NOTATION :
                ::FusionpDbgPrint("\t\t XML_NOTATION: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_ENTITYREF :
                ::FusionpDbgPrint("\t\t XML_ENTITYREF: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_DTDATTRIBUTE:
                ::FusionpDbgPrint("\t\t XML_DTDATTRIBUTE: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_GROUP :
                ::FusionpDbgPrint("\t\t XML_GROUP: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break; 
            case XML_INCLUDESECT : 
                ::FusionpDbgPrint("\t\t XML_INCLUDESECT: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_NAME :     
                ::FusionpDbgPrint("\t\t XML_NAME: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_NMTOKEN :  
                ::FusionpDbgPrint("\t\t XML_NMTOKEN: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_STRING :
                ::FusionpDbgPrint("\t\t XML_STRING: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_PEREF :
                ::FusionpDbgPrint("\t\t XML_PEREF: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_MODEL :  
                ::FusionpDbgPrint("\t\t XML_MODEL: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_ATTDEF : 
                ::FusionpDbgPrint("\t\t XML_ATTDEF: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_ATTTYPE :
                ::FusionpDbgPrint("\t\t XML_ATTTYPE: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_ATTPRESENCE :
                ::FusionpDbgPrint("\t\t XML_ATTPRESENCE: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_DTDSUBSET :
                ::FusionpDbgPrint("\t\t XML_DTDSUBSET: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            case XML_LASTNODETYPE :
                ::FusionpDbgPrint("\t\t XML_LASTNODETYPE: [%.*ls]\n", apNodeInfo[i]->ulLen, apNodeInfo[i]->pwcText);
                break;
            default : 
                ::FusionpDbgPrint("UNKNOWN TYPE! ERROR!!\n");
        } // end of switch
    }
    if (apNodeInfo[0]->dwType != XML_ELEMENT)
    {
        hr = NOERROR;
        goto Exit;
    }

    hr = m_pNamespaceManager->OnCreateNode(
            pSource, pNode, cNumRecs, apNodeInfo);
    if ( FAILED(hr))
        goto Exit;

    for( i=0; i<cNumRecs; i++) 
    {
        if ((apNodeInfo[i]->dwType == XML_ELEMENT) || (apNodeInfo[i]->dwType == XML_ATTRIBUTE ))
        {
            IFCOMFAILED_EXIT(m_pNamespaceManager->Map(0, apNodeInfo[i], &buffNamespace, &cchNamespacePrefix));
            //FusionpDbgPrint("Namespace is %ls with length=%Id\n", static_cast<PCWSTR>(buffNamespace), cchNamespace);
            buffNamespace.Clear();
        }
    }
Exit:
    return hr;
}
//---------------------------------------------------------------------------
HRESULT XMLParserTest(PCWSTR filename)
{
    HRESULT                    hr = S_OK;  
    CSmartRef<IXMLParser> pIXMLParser;
    CSmartRef<XMLParserTestFactory> factory; 
    CSmartRef<XMLParserTestFileStream> filestream; 

    filestream = NEW (XMLParserTestFileStream());
    if (filestream == NULL)
    { 
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFileStream, out of memory\n");

        hr = E_OUTOFMEMORY; 
        goto Exit; 

    }
    filestream->AddRef(); // refCount = 1;

    if (!filestream->open(filename))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to call XMLParserTestFileStream::open\n");

        hr = E_UNEXPECTED; 
        goto Exit; 
    }
    
    factory = new XMLParserTestFactory;
    if (factory == NULL)
    { 
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFactory, out of memory\n");

        hr = E_OUTOFMEMORY; 
        goto Exit; 
    }
    factory->AddRef(); // RefCount = 1 
    hr = factory->Initialize();
    if (FAILED(hr))
        goto Exit;
    
    pIXMLParser = NEW(XMLParser);
    if (pIXMLParser == NULL)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Attempt to instantiate XML parser failed\n");
        goto Exit;
    }
    pIXMLParser->AddRef(); // refCount = 1 ; 

    hr = pIXMLParser->SetInput(filestream); // filestream's RefCount=2
    if (!SUCCEEDED(hr)) 
        goto Exit;

    hr = pIXMLParser->SetFactory(factory); // factory's RefCount=2
    if (!SUCCEEDED(hr)) 
        goto Exit;

    hr = pIXMLParser->Run(-1);
    if (FAILED(hr))
        goto Exit; 

    PrintTreeFromRoot(factory->GetTreeRoot());

Exit:  
    // at this point, pIXMLParser's RefCount = 1 ; 
    //  factory's RefCount = 2; 
    // filestream's RefCount = 2 ;  
    return hr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\xmlparser\xmlstream.cxx ===
/*
* 
* Copyright (c) 1998,1999 Microsoft Corporation. All rights reserved.
* EXEMPT: copyright change only, no build required
* 
*/
#include "stdinc.h"
#include "core.hxx"
#pragma hdrstop

#include "xmlhelper.hxx"
#include "xmlstream.hxx"
#include "bufferedstream.hxx"
#include "xmlparser.hxx"

const long BLOCK_SIZE = 512;
const long STACK_INCREMENT = 10;

// macros used in this file
#define INTERNALERROR       return XML_E_INTERNALERROR;
#define checkeof(a,b)       if (_fEOF) return b;
#define ADVANCE             hr = _pInput->nextChar(&_chLookahead, &_fEOF); if (hr != S_OK) return hr;
#define ADVANCETO(a)        hr = AdvanceTo(a);  if (hr != S_OK) return hr;
#define ISWHITESPACE(ch)    _pInput->isWhiteSpace(ch) 
#define STATE(state)        { _sSubState = state; return S_OK; }
#define GOTOSTART(state)    { _sSubState = state; goto Start; }
#define DELAYMARK(hr)       ((hr == S_OK) || ((hr >= static_cast<HRESULT>(XML_E_TOKEN_ERROR)) && (hr < static_cast<HRESULT>(XML_E_LASTERROR))))
#define XML_E_FOUNDPEREF    0x8000e5ff


// The tokenizer has special handling for the following attribute types.
// These values are derived from the XML_AT_XXXX types provided in SetType
// and are also calculated during parsing of an ATTLIST for parsing of
// default values.
typedef enum 
{
    XMLTYPE_CDATA,       // the default.
    XMLTYPE_NAME,
    XMLTYPE_NAMES,
    XMLTYPE_NMTOKEN,
    XMLTYPE_NMTOKENS,
} XML_ATTRIBUTE_TYPE;

//==============================================================================
// xiaoyu : a simplified table : only deal with comments, not include DOCTYPE, NotationDecl, EntityDecl and ElementDecl.
// Parse an <!^xxxxxxxx Declaration.
const StateEntry g_DeclarationTable[] =
{
// 0    '<' ^ '!' 
    { OP_CHAR, L"!", 1, (DWORD)XML_E_INTERNALERROR,  },                    
// 1    '<!' ^ '-'
    { OP_PEEK, L"-", 2, 4, 0 },                    
// 2    '<!-'
    { OP_COMMENT,  NULL, 3,   },                 
// 3    done !!
    { OP_POP,  NULL, 0, 0 },

// 4    '<!' ^ '['
    { OP_PEEK, L"[", 5, (DWORD)XML_E_BADDECLNAME, 0 }, //xiaoyu : we do not consider others <!XXX, which is a DTD subset
// 5    '<![...'
    { OP_CONDSECT,  NULL, 3,   }
 
};

//==============================================================================
// Parse an <?xml or <?xml:namespace declaration.
const StateEntry g_XMLDeclarationTable[] =
{
// 0    must be xml declaration - and not xml namespace declaration        
    { OP_TOKEN, NULL, 1, XML_XMLDECL, 0 },
// 1    '<?xml' ^ S version="1.0" ...
    { OP_OWS, NULL, 2 },
// 2    '<?xml' S ^ version="1.0" ...
    { OP_SNCHAR, NULL, 3, (DWORD)XML_E_XMLDECLSYNTAX },	
// 3    '<?xml' S ^ version="1.0" ...
    { OP_NAME, NULL, 4, },
// 4    '<?xml' S version^="1.0" ...
    { OP_STRCMP, L"version", 5, 12, XML_VERSION },
// 5
    { OP_EQUALS, NULL, 6 },
// 6    '<?xml' S version = ^ "1.0" ...
    { OP_ATTRVAL, NULL, 32, 0},
// 7    '<?xml' S version '=' value ^ 
    { OP_TOKEN, NULL, 8, XML_PCDATA, -1 },
// 8    ^ are we done ?
    { OP_CHARWS, L"?", 28, 9 },    // must be '?' or whitespace.
// 9    ^ S? [encoding|standalone] '?>'
    { OP_OWS, NULL, 10 },
// 10
    { OP_CHAR, L"?", 28, 33 },    // may have '?' after skipping whitespace.
// 11    ^ [encoding|standalone] '?>'
    { OP_NAME, NULL, 12, },
// 12
    { OP_STRCMP, L"standalone", 23, 13, XML_STANDALONE },
// 13
    { OP_STRCMP, L"encoding", 14, (DWORD)XML_E_UNEXPECTED_ATTRIBUTE, XML_ENCODING },
// 14
    { OP_EQUALS, NULL, 15 },
// 15   
    { OP_ATTRVAL, NULL, 16, 0 },
// 16
    { OP_ENCODING, NULL, 17, 0, -1 },
// 17
    { OP_TOKEN, NULL, 18, XML_PCDATA, -1 },

// 18    ^ are we done ?
    { OP_CHARWS, L"?", 28, 19 },    // must be '?' or whitespace.
// 19    ^ S? standalone '?>'
    { OP_OWS, NULL, 20 },
// 20
    { OP_CHAR, L"?", 28, 34 },    // may have '?' after skipping whitespace.
// 21    ^ standalone '?>'
    { OP_NAME, NULL, 22, },
// 22 
    { OP_STRCMP, L"standalone", 23, (DWORD)XML_E_UNEXPECTED_ATTRIBUTE, 
XML_STANDALONE },
// 23
    { OP_EQUALS, NULL, 24 },
// 24
    { OP_ATTRVAL, NULL, 25, 0 },
// 25   
    { OP_STRCMP, L"yes", 31, 30, -1  },

// 26    <?xml ....... ^ '?>'   -- now expecting just the closing '?>' chars
    { OP_OWS, NULL, 27 },
// 27    
    { OP_CHAR, L"?", 28, (DWORD)XML_E_XMLDECLSYNTAX, 0 },
// 28   
    { OP_CHAR, L">", 29, (DWORD)XML_E_XMLDECLSYNTAX, 0 },
// 29    done !!
    { OP_POP,  NULL, 0, XMLStream::XML_ENDXMLDECL },

//----------------------- check standalone values  "yes" or "no"
// 30
    { OP_STRCMP, L"no", 31, (DWORD)XML_E_INVALID_STANDALONE, -1  },
// 31
    { OP_TOKEN, NULL, 26, XML_PCDATA, -1 },
    
//----------------------- check version = "1.0"
// 32
    { OP_STRCMP, L"1.0", 7, (DWORD)XML_E_INVALID_VERSION, -1 },
// 33 
    { OP_SNCHAR, NULL, 11, (DWORD)XML_E_XMLDECLSYNTAX },   
// 34 
    { OP_SNCHAR, NULL, 21, (DWORD)XML_E_XMLDECLSYNTAX },  
};

static const WCHAR* g_pstrCDATA = L"CDATA";
////////////////////////////////////////////////////////////////////////
XMLStream::XMLStream(XMLParser * pXMLParser)
:   _pStack(1), _pStreams(1)
{   
    // precondition: 'func' is never NULL
    _fnState = &XMLStream::init;
    _pInput = NULL;
    _pchBuffer = NULL;
    _fDTD = false;
	//_fInternalSubset = false;
    _cStreamDepth = 0;
    _pXMLParser = pXMLParser;

    _init();
    SetFlags(0);
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::init()
{
    HRESULT hr = S_OK;

    if (_pInput == NULL) 
	{
		//haven' called put-stream yet
        return XML_E_ENDOFINPUT;
	}
    
    _init();
    _fnState =  &XMLStream::parseContent;

    checkhr2(push(&XMLStream::firstAdvance,0));

    return hr;
}
////////////////////////////////////////////////////////////////////////
void
XMLStream::_init()
{
    _fEOF = false;
    _chLookahead	= 0;
    _nToken			= XML_PENDING;
    _chTerminator	= 0;
    _lLengthDelta	= 0;
	_lNslen = _lNssep = 0;
    _sSubState		= 0;
    _lMarkDelta		= 0;
    _fUsingBuffer	= false;
    _lBufLen		= 0;
    delete[] _pchBuffer;
    _pchBuffer		= NULL;
    _lBufSize		= 0;
    _fDelayMark		= false;
    _fFoundWhitespace = false;
    _fFoundNonWhitespace = false;
    _fWasUsingBuffer = false;
    _chNextLookahead = 0;

	_fParsingAttDef = false;
    _fFoundFirstElement = false;
    _fReturnAttributeValue = true;
	//_fHandlePE = true;

    _pTable = NULL;
}
////////////////////////////////////////////////////////////////////////
XMLStream::~XMLStream()
{
    delete _pInput;
    delete[] _pchBuffer;

    _pInput = NULL;
    _pchBuffer = NULL;

    InputInfo* pi = _pStreams.peek();
    while (pi != NULL)
    {
        // Previous stream is finished also, so
        // pop it and continue on.
        delete pi->_pInput;
        pi = _pStreams.pop();
    }
}
////////////////////////////////////////////////////////////////////////
HRESULT  
XMLStream::AppendData( 
    /* [in] */ const BYTE  *buffer,
    /* [in] */ long  length,
    /* [in] */ BOOL  last)
{
    if (_pInput == NULL)
    {
        _pInput = NEW (BufferedStream(this));
        if (_pInput == NULL)
            return E_OUTOFMEMORY;
        init();
    }

    HRESULT hr = _pInput->AppendData(buffer, length, last);

    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT  
XMLStream::Reset( void)
{
    init();
    delete _pInput;
    _pInput = NULL;

    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT  
XMLStream::PushStream( 
        /* [unique][in] */ EncodingStream  *p,
        /* [in] */ bool fExternalPE)
{
	UNUSED(fExternalPE);

    if (_pStreams.used() == 0 && _pInput == NULL)
        init();

    _cStreamDepth++;

    if (_fDelayMark && _pInput != NULL)
    {
        mark(_lMarkDelta);
        _lMarkDelta = 0;
        _fDelayMark = false;
    }

    // Save current input stream.
    if (_pInput != NULL)
    {
        InputInfo* pi = _pStreams.push();
        if (pi == NULL)
            return E_OUTOFMEMORY;
 
        pi->_pInput = _pInput;
        pi->_chLookahead = _chLookahead;
        //pi->_fPE = true; // assume this is a parameter entity.
        //pi->_fExternalPE = fExternalPE;
        //pi->_fInternalSubset = _fInternalSubset;
        if (&XMLStream::skipWhiteSpace == _fnState  && _pStack.used() > 0) {
            StateInfo* pSI = _pStack.peek();
            pi->_fnState = pSI->_fnState;
        }
        else
            pi->_fnState = _fnState;
        

        // and prepend pe text with space as per xml spec.
        _chLookahead = L' ';
        _chNextLookahead = _chLookahead;
        _pInput = NULL;
    }

    _pInput = NEW (BufferedStream(this));
    if (_pInput == NULL)
        return E_OUTOFMEMORY;

    if (p != NULL)
        _pInput->Load(p);
    
    if (_chLookahead == L' ')
        _pInput->setWhiteSpace(); // _pInput didn't see this space char.
    
	return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::PopStream()
{
    // This method has to pop all streams until it finds a stream that
    // can deliver the next _chLookahead character.

    HRESULT hr = S_OK;

    InputInfo* pi = NULL;

    pi = _pStreams.peek();
    if (pi == NULL) return S_FALSE;

    _chLookahead = pi->_chLookahead;

    // Found previous stream, so we can continue.
    _fEOF = false;

    // Ok, so we actually got the next character, so
    // we can now safely throw away the previous 
    // lookahead character and return the next
    // non-whitespace character from the previous stream.
    delete _pInput;

    _pInput = pi->_pInput;
    if (_chLookahead == L' ')
        _pInput->setWhiteSpace();

    // BUGBUG: we need to clear this so that the parser does not
    // try and pop a download in the internalPE case (when handling XML_E_ENDOFINPUT in run())
    // but this means that internal PEs never get XMLNF_ENDENTITY notifications generated.
    // The DTDNodeFactory requires this behaviour currently (incorrectly)
    _pStreams.pop();

    _cStreamDepth--;

    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT  
XMLStream::GetNextToken( 
        /* [out] */ DWORD  *t,
        /* [out] */ const WCHAR  **text,
        /* [out] */ long  *length,
        /* [out] */ long  *nslen)
{
    HRESULT hr;

    if (_fDTD)
        return E_UNEXPECTED;

    if (_fDelayMark)
    {
        mark(_lMarkDelta);
        _lMarkDelta = 0;
        _fDelayMark = false;
    }

    hr = (this->*_fnState)();
    while (hr == S_OK && _nToken == XML_PENDING)
        hr = (this->*_fnState)();
    
    if (hr == S_OK)
        *t = _nToken;
    else if (hr == E_PENDING) {
        *t = XML_PENDING;
        *length = *nslen = 0;
        *text = NULL;
        goto CleanUp;
    }
    else
        *t = XML_PENDING;
    
    // At this point hr == S_OK or it is some error.  So we
    // want to return the text of the current token, since this
    // is useful in both cases.

    if (! _fUsingBuffer)
    {
        getToken(text,length);
        if (_lLengthDelta != 0)
        { // xiaoyu : IF STOP WITHIN, HAVE A CAREFUL LOOK : in ParsingAttributeValue, we have to read ahead of one char '"'
            *length += _lLengthDelta;
            _lLengthDelta = 0;
        }
// This can only happen in the context of a DTD.
//        if (_fWasUsingBuffer)
//        {
//            _fUsingBuffer = _fWasUsingBuffer;
//            _fWasUsingBuffer = false;
//        }
    }
    else
    { // xiaoyu : IF STOP WITHIN, HAVE A CAREFUL LOOK
        *text = _pchBuffer;
        *length = _lBufLen;
        _fUsingBuffer = false;
        _fFoundWhitespace = false;
        _lBufLen = 0;
        _lLengthDelta = 0;
    }
    
    if (DELAYMARK(hr))
    {
        // Mark next time around so that error information points to the
        // beginning of this token.
        _fDelayMark = true;
    }
    else 
    {  // xiaoyu : IF STOP WITHIN, HAVE A CAREFUL LOOK
        // otherwise mark this spot right away so we point to the exact
        // source of the error.
        mark(_lMarkDelta);
        _lMarkDelta = 0;
    }
    
    _nToken = XML_PENDING;
    *nslen = _lNslen;
    _lNslen = _lNssep = 0;

CleanUp:
    return hr;
}
////////////////////////////////////////////////////////////////////////
ULONG  
XMLStream::GetLine()    
{
    BufferedStream* input = getCurrentStream();
    if (input != NULL)
        return input->getLine();
    return 0;
}
////////////////////////////////////////////////////////////////////////
ULONG  
XMLStream::GetLinePosition( )
{
    BufferedStream* input = getCurrentStream();
    if (input != NULL)
        return input->getLinePos();
    return 0;
}
////////////////////////////////////////////////////////////////////////
ULONG  
XMLStream::GetInputPosition( )
{
    BufferedStream* input = getCurrentStream();
    if (input != NULL)
        return input->getInputPos();
    return 0;
}
////////////////////////////////////////////////////////////////////////
HRESULT  
XMLStream::GetLineBuffer( 
    /* [out] */ const WCHAR  * *buf, ULONG* len, ULONG* startpos)
{
    if (buf) *buf = NULL;
    if (len) *len = 0;
    if (startpos) *startpos = 0;
    
    if (buf == NULL || len == NULL)
        return E_INVALIDARG;

    *buf = NULL;
    BufferedStream* input = getCurrentStream();
    if (input)
        *buf = input->getLineBuf(len, startpos);
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
BufferedStream* 
XMLStream::getCurrentStream()
{
    // Return the most recent stream that
    // actually has somthing to return.
    BufferedStream* input = _pInput;
    if (!_pInput)
    {
        return NULL;
    }
    int i = _pStreams.used()-1;    
    do 
    {
        ULONG len = 0, pos = 0;
//      const WCHAR* buf = input->getLineBuf(&len, &pos); // generates C4189: 'buf' local variable is initialized but not referenced
        (void) input->getLineBuf(&len, &pos);
        if (len > 0)
            return input;

        if (i >= 0)
            input = _pStreams[i--]->_pInput;
        else
            break;
    }
    while (input != NULL);
    return NULL;
}
////////////////////////////////////////////////////////////////////////
void 
XMLStream::SetFlags( unsigned short usFlags)
{
    _usFlags = usFlags;
    // And break out the flags for performance reasons.
    //_fFloatingAmp = (usFlags & XMLFLAG_FLOATINGAMP) != 0;
    _fShortEndTags = (usFlags & XMLFLAG_SHORTENDTAGS) != 0;
    _fCaseInsensitive = (usFlags & XMLFLAG_CASEINSENSITIVE) != 0;
    _fNoNamespaces = (usFlags & XMLFLAG_NONAMESPACES) != 0;
    //_fNoWhitespaceNodes = false; // this is now bogus.  (usFlags & XMLFLAG_NOWHITESPACE) != 0;
    //_fIE4Quirks = (_usFlags & XMLFLAG_IE4QUIRKS) != 0;
    //_fNoDTDNodes = (_usFlags & XMLFLAG_NODTDNODES) != 0;
}
////////////////////////////////////////////////////////////////////////
unsigned short 
XMLStream::GetFlags()
{
    return _usFlags;
}
////////////////////////////////////////////////////////////////////////


//======================================================================
// Real Implementation
HRESULT 
XMLStream::firstAdvance()
{
    HRESULT hr;

    ADVANCE;
    checkhr2(pop(false));

    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseContent()
{
    HRESULT hr = S_OK;

    if (_fEOF)
        return XML_E_ENDOFINPUT;

    switch (_chLookahead){
    case L'<':
        ADVANCE;
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        switch (_chLookahead)
        {
        case L'!':
            checkhr2(_pInput->Freeze()); // stop shifting data until '>'
            return pushTable( 0, g_DeclarationTable, (DWORD)XML_E_UNCLOSEDDECL);
        case L'?':
            checkhr2(push( &XMLStream::parsePI ));
            return parsePI();
        case L'/':
            checkhr2(push(&XMLStream::parseEndTag));
            return parseEndTag();
        default:
            checkhr2(push( &XMLStream::parseElement )); // push ParseContent, and _fnState = parseElement
            if (_fFoundFirstElement)
            {
                return parseElement();
            }
            else
            {
                // Return special end prolog token and then continue with 
                // with parseElement.
                _fFoundFirstElement = true;
                _nToken = XML_ENDPROLOG;
            }
        }
        break;

    default:
        checkhr2(push(&XMLStream::parsePCData));
        return parsePCData();
        break;
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::skipWhiteSpace()
{
    HRESULT hr = S_OK;

    while (ISWHITESPACE(_chLookahead) && ! _fEOF)
    {
        ADVANCE;        
    }
    checkhr2(pop(false));
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseElement()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        checkhr2(_pInput->Freeze()); // stop shifting data until '>'
        checkhr2(push( &XMLStream::parseName, 1));
        checkhr2(parseName());
        _sSubState = 1;
        // fall through
    case 1:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        _nToken = XML_ELEMENT;
        // and then try and parse the attributes, and return
        // to state 2 to finish up.  With an optimization
        // for the case where there are no attributes.
        if (_chLookahead == L'/' || _chLookahead == L'>')
        {
            _sSubState = 2;
        }
		else {
			if (!ISWHITESPACE(_chLookahead))
			{
				return XML_E_BADNAMECHAR;
			}
			
			_chEndChar = L'/'; // for empty tags. //xiaoyu : used to match ENDTAG
			checkhr2(push(&XMLStream::parseAttributes,2));
		}	
        
        return S_OK;
        break;

    case 2: // finish up with start tag.
        mark(); // only return '>' or '/>' in _nToken text
        if (_chLookahead == L'/')
        {
            // must be empty tag sequence '/>'.
            ADVANCE;
            _nToken = XML_EMPTYTAGEND;
        } 
        else if (_chLookahead == L'>')
        {
            _nToken = XML_TAGEND;
        }
        else if (ISWHITESPACE(_chLookahead))
        {
            return XML_E_UNEXPECTED_WHITESPACE;
        }
        else
            return XML_E_EXPECTINGTAGEND;

        _sSubState = 3;
        // fall through
    case 3:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        if (_chLookahead != L'>')
        {
            if (ISWHITESPACE(_chLookahead))
                return XML_E_UNEXPECTED_WHITESPACE;
            else 
                return XML_E_EXPECTINGTAGEND;
        }
        ADVANCE; 
        mark();
        checkhr2(pop());// return to parseContent.

        return _pInput->UnFreeze(); 
        break;

    case 4: // swollow up bad tag
        // Allow the weird CDF madness <PRECACHE="YES"/>
        // For total compatibility we fake out the parser by returning
        // XML_EMPTYTAGEND, this way the rest of the tag becomes PCDATA.
        // YUK -- but it works.
        _nToken = XML_EMPTYTAGEND;
        mark();
        checkhr2(pop());// return to parseContent.
        return _pInput->UnFreeze(); 
        break;

    default:
        INTERNALERROR;
    }
    //return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseEndTag()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        ADVANCE; // soak up the '/'
        mark(); 
        // SHORT END TAG SUPPORT, IE4 Compatibility Mode only.
        if (! _fShortEndTags || _chLookahead != L'>') 
        {
            checkhr2(push( &XMLStream::parseName, 1));
            checkhr2(parseName());
        }
        _sSubState = 1;
        // fall through
        
    case 1: // finish parsing end tag
        checkeof(_chLookahead, XML_E_UNCLOSEDENDTAG);
        _nToken = XML_ENDTAG;
        checkhr2(push(&XMLStream::skipWhiteSpace, 2));
        return S_OK;

    case 2:
        checkeof(_chLookahead, XML_E_UNCLOSEDENDTAG);
        if (_chLookahead != L'>')
        {
            return XML_E_BADNAMECHAR;
        }
        ADVANCE;
        mark();
        checkhr2(pop());// return to parseContent.
        break;

    default:
        INTERNALERROR;
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parsePI()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        //_fWasDTD = _fDTD; // as far as Advance is concerned, the contents
        //_fHandlePE = false;    // of a PI are not special.
        ADVANCE;
        checkhr2(_pInput->Freeze()); // stop shifting data until '?>'
        mark(); // don't include '?' in tag name.
        if (_chLookahead == L'x' || _chLookahead == L'X')
        {
            // perhaps this is the magic <?xml version="1.0"?> declaration.
            STATE(7);  // jump to state 7.
        }
        // fall through
        _sSubState = 1;
    case 1:
        checkhr2(push( &XMLStream::parseName, 2));
        checkhr2(parseName()); 
        _sSubState = 2;
        // fall through
    case 2:
        checkeof(_chLookahead, XML_E_UNCLOSEDPI);
        if (_chLookahead != L'?' && ! ISWHITESPACE(_chLookahead))
        { 
            return XML_E_BADNAMECHAR;
        }
        _nToken = XML_PI;
        STATE(3);   // found startpi _nToken and return to _sSubState 3
        break;

    case 3: // finish with rest of PI
        if (_chLookahead == L'?')
        {
            ADVANCE;
            if (_chLookahead == L'>')
            {
                STATE(6);
            }
            else
            {
                return XML_E_EXPECTINGTAGEND;
            }
        }

        checkhr2(push(&XMLStream::skipWhiteSpace, 4));
        checkhr2( skipWhiteSpace() );
        _sSubState = 4;
        // fall through

    case 4: // support for normalized whitespace
        mark(); // strip whitespace from beginning of PI data, since this is
                // just the separator between the PI target name and the PI  data.
        _sSubState = 5;
        // fallthrough

    case 5:
        while (! _fEOF )
        {
            if (_chLookahead == L'?')
            {
                ADVANCE;
                break;
            }
            if (! isCharData(_chLookahead))
                return XML_E_PIDECLSYNTAX;
            ADVANCE;
        }
        _sSubState = 6; // go to next state
        // fall through.
    case 6:
        checkeof(_chLookahead, XML_E_UNCLOSEDPI);
        if (_chLookahead == L'>')
        {
            ADVANCE;
            _lLengthDelta = -2; // don't include '?>' in PI CDATA.
        }
        else
        {
            // Hmmm.  Must be  a lone '?' so go back to state 5.
            STATE(5);
        }
        _nToken = XML_ENDPI;
        //_fHandlePE = true;
        checkhr2(pop());
        return _pInput->UnFreeze();
        break;      

    case 7: // recognize 'm' in '<?xml' declaration
        ADVANCE;
        if (_chLookahead != L'm' && _chLookahead != L'M')
        {
            STATE(11); // not 'xml' so jump to state 11 to parse name
        }
        _sSubState = 8;
        // fall through                

    case 8: // recognize L'l' in '<?xml' declaration
        ADVANCE;
        if (_chLookahead != L'l' && _chLookahead != L'L')
        {
            STATE(11); // not 'xml' so jump to state 11 to parse name
        }
        _sSubState = 9;
        // fall through                

    case 9: // now need whitespace or ':' or '?' to terminate name.
        ADVANCE;
        if (ISWHITESPACE(_chLookahead))
        {
            if (! _fCaseInsensitive)
            {
                const WCHAR* t = NULL;
                long len =0; // for prefix bug : xiaoyuw@08/28/00
                getToken(&t,&len);
                //if (! StringEquals(L"xml",t,3,false)) // case sensitive
                if (::FusionpCompareStrings(L"xml", 3, t, 3, false)!=0) // not equal 
                    return XML_E_BADXMLCASE;
            }
            return pushTable(10, g_XMLDeclarationTable, (DWORD)XML_E_UNCLOSEDPI);
        }
        if (isNameChar(_chLookahead) || _chLookahead == ':')  
        {
            STATE(11); // Hmmm.  Must be something else then so continue parsing name
        }
        else
        {
            return XML_E_XMLDECLSYNTAX;
        }
        break;

    case 10:
        //_fHandlePE = true;
        checkhr2(pop());
        return _pInput->UnFreeze();
        break;

    case 11:
        if (_chLookahead == ':')
            ADVANCE;
        _sSubState = 12;
        // fall through
    case 12:
        if (isNameChar(_chLookahead))
        {
            checkhr2(push( &XMLStream::parseName, 2));
            _sSubState = 1; // but skip IsStartNameChar test
            checkhr2(parseName());
            return S_OK;
        } 
        else
        {
            STATE(2);
        }
        break;

    default:
        INTERNALERROR;
    }

    //return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseComment()
{
    // ok, so '<!-' has been parsed so far
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        //_fWasDTD = _fDTD; // as far as the DTD is concerned, the contents
        //_fHandlePE = false;    // of a COMMENT are not special.
        ADVANCE; // soak up first '-'
        checkeof(_chLookahead, XML_E_UNCLOSEDCOMMENT);
        if (_chLookahead != L'-')
        {
            return XML_E_COMMENTSYNTAX;
        }
        _sSubState = 1;
        // fall through
    case 1:
        ADVANCE; // soak up second '-'
        mark(); // don't include '<!--' in comment text
        _sSubState = 2;
        // fall through;
    case 2:
        while (! _fEOF)
        {
            if (_chLookahead == L'-')
            {
                ADVANCE; // soak up first closing L'-'                
                break;
            }
            if (! isCharData(_chLookahead))
                return XML_E_BADCHARDATA;
            ADVANCE;
        }
        checkeof(_chLookahead, XML_E_UNCLOSEDCOMMENT);
        _sSubState = 3; // advance to next state        
        // fall through.
    case 3:
        if (_chLookahead != L'-')
        {
            // Hmmm, must have been a floating L'-' so go back to state 2
            STATE(2);
        }
        ADVANCE; // soak up second closing L'-'
        _sSubState = 4; 
        // fall through
    case 4:
        checkeof(_chLookahead, XML_E_UNCLOSEDCOMMENT);
        //if (_chLookahead != L'>' && ! _fIE4Quirks)
		if (_chLookahead != L'>')
        {
            // cannot have floating L'--' unless we are in compatibility mode.
            return XML_E_COMMENTSYNTAX;
        }
        ADVANCE; // soak up closing L'>'
        _lLengthDelta = -3; // don't include L'-->' in PI CDATA.
        _nToken = XML_COMMENT;
        checkhr2(pop());
        //_fHandlePE = true;
        break;

    default:
        INTERNALERROR;
    }    
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseName()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        if (! isStartNameChar(_chLookahead))
        {
            if (ISWHITESPACE(_chLookahead))
                hr = XML_E_UNEXPECTED_WHITESPACE;
            else
                hr = XML_E_BADSTARTNAMECHAR;
            goto CleanUp;
        }
        mark(); 
        _sSubState = 1;
        // fall through

    case 1:
		_lNslen = _lNssep = 0;
        while (isNameChar(_chLookahead) && !_fEOF)
        {
            ADVANCE;
        }
        hr = pop(false); // return to the previous state
        break;

    default:
        INTERNALERROR;
    }

CleanUp:
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseAttributes()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        //_nAttrType = XMLTYPE_CDATA;
        _fCheckAttribute = false;
        checkhr2(push(&XMLStream::skipWhiteSpace, 1));
        checkhr2( skipWhiteSpace() );
        _sSubState = 1;
        // fall through
    case 1:
        if (_chLookahead == _chEndChar || _chLookahead == L'>' )
        {
            checkhr2(pop()); // no attributes.
            return S_OK;
        }
        checkhr2( push( &XMLStream::parseName, 2 ) );
        checkhr2( parseName() );

        if (!ISWHITESPACE(_chLookahead) && _chLookahead != L'=')
        {
            return XML_E_BADNAMECHAR;
        }
        _sSubState = 2;
        // fall through
    case 2:
        if (ISWHITESPACE(_chLookahead))
        {
            // Eq ::= S? '=' S?
            STATE(7);
        }

        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        _nToken = XML_ATTRIBUTE;    
        _sSubState = 3;
        return S_OK;
        break;

    case 3:
        if (ISWHITESPACE(_chLookahead))
            return XML_E_UNEXPECTED_WHITESPACE;
        _fWhitespace = false;
        _sSubState = 4;
        // fall through

    case 4:
        if (_chLookahead != L'=')
        {
            return XML_E_MISSINGEQUALS;
        }
        ADVANCE;
        if (ISWHITESPACE(_chLookahead))
        {
            // allow whitespace between '=' and attribute value.
            checkhr2(push(&XMLStream::skipWhiteSpace, 5));
            checkhr2( skipWhiteSpace() );            
        }
        _sSubState = 5;
        // fall through

    case 5:
        if (ISWHITESPACE(_chLookahead))
            return XML_E_UNEXPECTED_WHITESPACE;
        if (_chLookahead != L'"' && _chLookahead != L'\'')
        {
            return XML_E_MISSINGQUOTE;
        }
        _chTerminator = _chLookahead;
        ADVANCE;
        mark(); 
        return push(&XMLStream::parseAttrValue, 6);
        //_sSubState = 6;
    // fall through;

    case 6:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        if (_chLookahead == _chEndChar || _chLookahead == L'>')
        {
            checkhr2(pop());
            return S_OK;
        }
        if (! ISWHITESPACE(_chLookahead) )
        {
            return XML_E_MISSINGWHITESPACE;
        }
        STATE(0); // go back to state 0
        break;

    case 7:
        // allow whitespace between attribute and '='
        _lLengthDelta = _pInput->getTokenLength();
        checkhr2(push(&XMLStream::skipWhiteSpace, 8));
        checkhr2( skipWhiteSpace() );       
        _sSubState = 8;
        // fall through

    case 8:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        _lLengthDelta -= _pInput->getTokenLength();
        STATE(2);
        break;

    default:
        INTERNALERROR;
    }
    //return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT XMLStream::parseAttrValue()
{
    HRESULT hr = S_OK;

    switch (_sSubState)
    {
    case 0: 
        _fParsingAttDef = true;        
        // mark beginning of attribute data           
        _sSubState =  2;
        // fall through;

    case 2:
        while ( _chLookahead != _chTerminator && 
                _chLookahead != L'<' &&
                ! _fEOF  ) 
        {
            if (_chLookahead == L'&')
            {
                // then parse entity ref and then return
                // to state 2 to continue with PCDATA.
                return push(&XMLStream::parseEntityRef,2);
            }
            hr = _pInput->scanPCData(&_chLookahead, &_fWhitespace);
            if (FAILED(hr))
            {
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                    ADVANCE;
                }
                return hr;
            }
        }
        _sSubState = 3;
        // fall through
    case 3:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTRING);
        if (_chLookahead == _chTerminator)
        {
            ADVANCE;
            if (_fReturnAttributeValue)
            {
                // return what we have so far - if anything.
                if ((_fUsingBuffer && _lBufLen > 0) ||
                    _pInput->getTokenLength() > 1)
                {
                    _lLengthDelta = -1; // don't include string _chTerminator.
                    _nToken = XML_PCDATA;
                }
            }
            else
            {
                _fReturnAttributeValue = true; // reset to default value.
            }
            _fParsingAttDef = false;
            checkhr2(pop());
            return S_OK;
        } 
        else
        {
            return XML_E_BADCHARINSTRING;
        }        
        break;

    default:
        INTERNALERROR;
    }
    //return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::ScanHexDigits()
{
    HRESULT hr = S_OK;
    while (! _fEOF && _chLookahead != L';')
    {
        if (! isHexDigit(_chLookahead))
        {
            return ISWHITESPACE(_chLookahead) ? XML_E_UNEXPECTED_WHITESPACE : XML_E_BADCHARINENTREF;
        }
        ADVANCE;
    }
    checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::ScanDecimalDigits()
{
    HRESULT hr = S_OK;
    while (! _fEOF && _chLookahead != L';')
    {
        if (! isDigit(_chLookahead))
        {
            return ISWHITESPACE(_chLookahead) ? XML_E_UNEXPECTED_WHITESPACE : XML_E_BADCHARINENTREF;
        }
        ADVANCE;
    }
    checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parsePCData()
{
    HRESULT hr = S_OK;

    switch (_sSubState)
    {
    case 0:
        _fWhitespace = true;
        _sSubState = 1;
        // fall through;

    case 1:
        // This state is used when we are not normalizing white space.  This
        // is a separate state for performance reasons.  
        // Normalizing whitespace is about 11% slower.
        while (_chLookahead != L'<' && ! _fEOF )
        {
             if (_chLookahead == L'&')
            {
                // then parse entity ref and then return
                // to state 1 to continue with PCDATA.
                return push(&XMLStream::parseEntityRef,1);
            }

            if (_chLookahead == L'>')
            {
                WCHAR* pText = NULL;
                long len = 0;
                _pInput->getToken((const WCHAR**)&pText, &len);
                //if (len >= 2 && StrCmpN(L"]]", pText + len - 2, 2) == 0)
                if ((len >= 2) && (::FusionpCompareStrings(L"]]", 2, pText + len - 2, 2, false)==0))
		             return XML_E_INVALID_CDATACLOSINGTAG;               
            }
// This slows us down too much.
//            else if (! isCharData(_chLookahead))
//            {
//                return XML_E_BADCHARDATA;
//            }

            hr = _pInput->scanPCData(&_chLookahead, &_fWhitespace);
            if (FAILED(hr))
            {
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                    ADVANCE;
                }
                return hr;
            }
            checkhr2(hr);
        }
        _sSubState = 2;
        // fall through

    case 2:
        if (_pInput->getTokenLength() > 0 || _fUsingBuffer)
        {
            _nToken = _fWhitespace ? XML_WHITESPACE : XML_PCDATA;
        }
        checkhr2(pop());
        break;

    default:
        INTERNALERROR;
    }   
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseEntityRef()
{
    HRESULT hr = S_OK;
    long entityLen = 0, lLen = 1;
    const WCHAR* t = NULL; 
    long len = 0;

Start:
    switch (_sSubState)
    {
    case 0: // ^ ( '&#' [0-9]+ ) | ('&#X' [0-9a-fA-F]+) | ('&' Name) ';'
        _nPreToken = XML_PENDING;
        _lEntityPos = _pInput->getTokenLength(); // record entity position.
        _fPCDataPending = (_lEntityPos > 0);

        if (PreEntityText())
        {
            // remember the pending text before parsing the entity.
            _nPreToken = _nToken;
            _nToken = XML_PENDING;
        }
        _sSubState = 1;
        // fall through
    case 1:
        ADVANCE; // soak up the '&'
        _sSubState = 2;
        // fall through
    case 2:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead == L'#')
        {
            ADVANCE;
            _sSubState = 3;
            // fall through
        }
        else
        {
            // Loose entity parsing allows "...&6..."
            if (! isStartNameChar(_chLookahead))
            {
				/*
                if (_fFloatingAmp)
                {
                    // then it isn't an entity reference, so go back to PCDATA
                    if (_fUsingBuffer)
                    {
                        // this in case we are normalizing white space.
                        PushChar(L'&');
                    }
                    _fWhitespace = false;
                    checkhr2(pop());
                    return S_OK;
                }
                else */
				if (ISWHITESPACE(_chLookahead))
                    return XML_E_UNEXPECTED_WHITESPACE;
                else
                    return XML_E_BADSTARTNAMECHAR;
            }
            checkhr2(push(&XMLStream::parseName, 6));
            _sSubState = 1; // avoid doing a mark() so we can return PCDATA if necessary.
            return parseName();
        }
        break;

        // ------------- Numeric entity references --------------------
    case 3:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead == L'x')
        {
            // hex character reference.
            ADVANCE;
            STATE(5); // go to state 5
        }
        _sSubState = 4;
        // fall through

    case 4: // '&#' ^ [0-9]+ ';'
        checkhr2(ScanDecimalDigits());
        if (_chLookahead != L';')
        {
            STATE(9);
        }

        entityLen = _pInput->getTokenLength() - _lEntityPos;
        getToken(&t, &len);
        checkhr2(DecimalToUnicode(t + _lEntityPos + 2, entityLen - 2, _wcEntityValue));
        lLen = 2;
        _nToken = XML_NUMENTITYREF;
        GOTOSTART(10); // have to use GOTOSTART() because we want to use the values of t and len
        break;

    case 5: // '&#X' ^ [0-9a-fA-F]+
        checkhr2(ScanHexDigits());
        if (_chLookahead != L';')
        {
            STATE(9);
        }

        entityLen = _pInput->getTokenLength() - _lEntityPos;
        getToken(&t, &len);
        checkhr2(HexToUnicode(t + _lEntityPos + 3, entityLen - 3, _wcEntityValue));
        lLen = 3;
        _nToken = XML_HEXENTITYREF;
        GOTOSTART(10);  // have to use GOTOSTART() because we want to use the values of t and len
        break;
        
        // ------------- Named Entity References --------------------
    case 6: // '&' Name ^ ';'
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead != L';')
        {
            STATE(9);
        }

        // If parseName found a namespace then we need to calculate the
        // real nslen taking the pending PC data and '&' into account
        // and remember this in case we have to return the PCDATA.
        _nEntityNSLen = (_lNslen > 0) ? _lNslen - _lEntityPos - 1 : 0;
        _fUsingBuffer = false;

        entityLen = _pInput->getTokenLength() - _lEntityPos;
        getToken(&t, &len);

        if (0 != (_wcEntityValue = BuiltinEntity(t + _lEntityPos + 1, entityLen - 1))) //||
            //(_fIE4Quirks && 0xFFFF != (_wcEntityValue = LookupBuiltinEntity(t + _lEntityPos + 1, entityLen - 1))))
        {
            lLen = 1;
            _nToken = XML_BUILTINENTITYREF;
            GOTOSTART(10);  // have to use GOTOSTART() because we want to use the values of t and len
        }
        else //xiaoyu : Fusion XML Parser does not support external ref, 
			 // so, if it is not a builtIn ref, we would return error
			return XML_E_MISSINGSEMICOLON;
		break; 
		//xiaoyu : Fusion XML Parser does not support external ref
		/*
			if (_nPreToken != XML_PENDING)
        {
            // Return previous token (XML_PCDATA or XML_WHITESPACE)
            _lLengthDelta = -entityLen;
            _lMarkDelta = entityLen - 1; // don't include '&' in _nToken.
            _nToken = _nPreToken;
            STATE(7);
        }

        mark(entityLen-1); // don't include '&' in _nToken.
        _sSubState = 7;
        // fall through

    case 7:
        ADVANCE; // soak up the ';'
        _nToken = XML_ENTITYREF;
        _lNslen = _nEntityNSLen;
        _lLengthDelta = -1; // don't include the ';'
        STATE(8); // return token and resume in state 8.
        break;
    */
    case 8:
        mark();
        checkhr2(pop());
        return S_OK;
	/*
    case 9:
        // Soft entity handling - we just continue with PCDATA in 
        // this case.
		
        if (_fFloatingAmp)
        {
            if (_fUsingBuffer)
            {
                // this in case we are normalizing white space.  In this case
                // we have to copy what we have so far to the normalized buffer.
                long endpos = _pInput->getTokenLength();
                const WCHAR* t; long len;
                getToken(&t, &len);
                for (long i = _lEntityPos; i < endpos; i++)
                    PushChar(t[i]);
            }
            _fWhitespace = false;
            checkhr2(pop());
            return S_OK;
        }
        else
		
            return XML_E_MISSINGSEMICOLON;
        break;
	*/

    case 10:
        // Return the text before builtin or char entityref as XML_PCDATA
        if (_nPreToken)
        {
            _nPreToken = _nToken;
            _nToken = XML_PCDATA;
            _lLengthDelta = -entityLen;
            _lMarkDelta = entityLen - lLen; // don't include '&' in _nToken.
            STATE(11);  // return token and resume in state 12.
        }
        else
        {
            _nPreToken = _nToken;
            mark(entityLen - lLen);
            GOTOSTART(11);
        }
        break;

    case 11:
        // push the builtin entity
        _fUsingBuffer = true;
        PushChar(_wcEntityValue);
        _nToken = _nPreToken;
        STATE(12); // return token and resume in state 12.
        break;

    case 12:
        ADVANCE; // soak up the ';'
        STATE(8); // resume in state 8.
        break;

    default:
        INTERNALERROR;
    }   
    return S_OK;      
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::pushTable(short substate, const StateEntry* table, DWORD le)
{
    HRESULT hr = S_OK;

    checkhr2(push(&XMLStream::parseTable, substate));
	_pTable = table;
	UNUSED(le);
    //_lEOFError = le;
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::push(StateFunc f, short s)
{
    StateInfo* pSI = _pStack.push();
    if (pSI == NULL)
        return E_OUTOFMEMORY;

    pSI->_sSubState = s;
    pSI->_fnState = _fnState;
	pSI->_pTable = _pTable;
	pSI->_cStreamDepth = _cStreamDepth;


    _sSubState = 0;
    _fnState = f;

    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT
XMLStream::pop(bool boundary)
{
    StateInfo* pSI = _pStack.peek();

    // prefix bug fix : xiaoyuw@08/29/00
    ASSERT_NTC(pSI != NULL);

    if (_fDTD && 
        ! (_fParsingAttDef) && boundary && _cStreamDepth != pSI->_cStreamDepth) // _fParsingNames || 
    {
        // If we are in a PE and we are popping out to a state that is NOT in a PE
        // and this is a pop where we need to check this condition, then return an error.
        // For example, the following is not well formed because the parameter entity
        // pops us out of the ContentModel state in which the PE was found:
        // <!DOCTYPE foo [
        //      <!ENTITY % foo "a)">
        //      <!ELEMENT bar ( %foo; >
        //  ]>...
        return XML_E_PE_NESTING;
    }

    _fnState	= pSI->_fnState;
    _sSubState	= pSI->_sSubState;
    _pTable		= pSI->_pTable;
    //_lEOFError	= pSI->_lEOFError;
    _pStack.pop();

    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::switchTo(StateFunc f)
{
    HRESULT hr;

    // Make sure we keep the old stream depth.
    StateInfo* pSI = _pStack.peek();

    // prefix bug fix : xiaoyuw@08/29/00
    ASSERT_NTC(pSI != NULL);
    int currentDepth = _cStreamDepth;
    _cStreamDepth = pSI->_cStreamDepth;

    checkhr2(pop(false));
    checkhr2(push(f,_sSubState)); // keep return to _sSubState the same

    _cStreamDepth = currentDepth;

    return (this->*f)();
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseCondSect()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        ADVANCE; // soak up the '[' character
        //if (_fFoundPEREf) return S_OK;
        _sSubState = 1;
        // fall through
    case 1: // now match magic '[CDATA[' sequence.     
        checkeof(_chLookahead, XML_E_UNCLOSEDMARKUPDECL);
        if (_chLookahead == L'C')
        {
            _pchCDataState = g_pstrCDATA;
            STATE(5); // goto state 5
        }
        _sSubState = 2;   // must be IGNORE, INCLUDE or %pe;
        // fall through

    case 2: // must be DTD markup declaration
        // '<![' ^ S? ('INCLUDE' | 'IGNORE' | %pe;) S? [...]]> or 
        // skip optional whitespace
        //if (_fInternalSubset)
        //    return XML_E_CONDSECTINSUBSET;
        checkeof(_chLookahead, XML_E_EXPECTINGOPENBRACKET);
        checkhr2(push(&XMLStream::skipWhiteSpace, 3));
        return skipWhiteSpace(); // must return because of %pe;

    case 3:
        checkeof(_chLookahead, XML_E_UNCLOSEDMARKUPDECL);
        checkhr2(push(&XMLStream::parseName,4));
        return parseName();

    case 4: // scanned 'INCLUDE' or 'IGNORE'
        {
            const WCHAR* t = NULL;
            long len = 0;
            getToken(&t,&len); 
            //if (StringEquals(L"IGNORE",t,len,false))
            //{
            //    return switchTo(&XMLStream::parseIgnoreSect);
            //}
            //else if (StringEquals(L"INCLUDE",t,len,false))
            //{
            //    return switchTo(&XMLStream::parseIncludeSect);
            //}
            //else
                return XML_E_BADENDCONDSECT;
        }
        break;

    case 5: // parse CDATA name
        while (*_pchCDataState != 0 && _chLookahead == *_pchCDataState && ! _fEOF)
        {
            ADVANCE;            // advance first, before incrementing _pchCDataState
            _pchCDataState++;   // so that this state is re-entrant in the E_PENDING case.
            checkeof(_chLookahead, XML_E_UNCLOSEDMARKUPDECL);
        }
        if (*_pchCDataState != 0)
        {
            // must be INCLUDE or IGNORE section so go to state 2.
            _sSubState = 2;
        } 
        else if (_chLookahead != L'[')
        {
            return XML_E_EXPECTINGOPENBRACKET;
        }
        else if (_fDTD)
            return XML_E_CDATAINVALID;
        else
            return switchTo(&XMLStream::parseCData);

        return S_OK;
        break;        

    default:
        INTERNALERROR;
    }
    return S_OK;
}

////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseCData()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        ADVANCE; // soak up the '[' character.
        mark(); // don't include 'CDATA[' in CDATA text
        _sSubState = 1;
        // fall through
    case 1:
        while (_chLookahead != L']' && ! _fEOF)
        {
            // scanPCData will stop when it sees a ']' character.
            hr = _pInput->scanPCData(&_chLookahead, &_fWhitespace);
            if (FAILED(hr))
            {
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                    ADVANCE;
                }
                return hr;
            }
        }
        checkeof(_chLookahead, XML_E_UNCLOSEDCDATA);
        _sSubState = 2;
        // fall through
    case 2:
        ADVANCE; // soak up first L']' character.
        checkeof(_chLookahead, XML_E_UNCLOSEDCDATA);
        if (_chLookahead != L']')
        {
            // must have been floating ']' character, so
            // return to state 1.
            STATE(1); 
        }
        _sSubState = 3;
        // fall through
    case 3:
        ADVANCE; // soak up second ']' character.
        checkeof(_chLookahead, XML_E_UNCLOSEDCDATA);
        if (_chLookahead == L']')
        {
            // Ah, an extra ']' character, tricky !!  
            // In this case we stay in state 3 until we find a non ']' character
            // so you can terminate a CDATA section with ']]]]]]]]]]]]]]]]>'
            // and everying except the final ']]>' is treated as CDATA.
            STATE(3);
        }
        else if (_chLookahead != L'>')
        {
            // must have been floating "]]" pair, so
            // return to state 1.
            STATE(1);
        }
        _sSubState = 4;
        // fall through
    case 4:
        ADVANCE; // soak up the '>'
        _nToken = XML_CDATA;
        _lLengthDelta = -3; // don't include terminating ']]>' in text.
        checkhr2(pop()); // return to parseContent.
        return S_OK;
        break;

    default:
        INTERNALERROR;
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT
XMLStream::parseEquals()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0: // Eq ::= S? '=' S? 
        if (ISWHITESPACE(_chLookahead))
        {
            // allow whitespace between attribute and '='
            checkhr2(push(&XMLStream::skipWhiteSpace, 1));
            checkhr2( skipWhiteSpace() );            
        }
        _sSubState = 1;
        // fall through

    case 1:
        if (_chLookahead != L'=')
        {
            return XML_E_MISSINGEQUALS;
        }
        ADVANCE;
        if (ISWHITESPACE(_chLookahead))
        {
            // allow whitespace between '=' and attribute value.
            checkhr2(push(&XMLStream::skipWhiteSpace, 2));
            checkhr2( skipWhiteSpace() );            
        }
        _sSubState = 2;
        // fall through

    case 2:
        checkhr2(pop(false));
        break;

    default:
        INTERNALERROR;

    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseTable()
{
    HRESULT hr = S_OK;

    while (hr == S_OK && _nToken == XML_PENDING)
    {
        const StateEntry* pSE = &_pTable[_sSubState];

        DWORD newState = pSE->_sGoto;

        switch (pSE->_sOp)
        {
        case OP_WS:
            //checkeof(_chLookahead, _lEOFError);
            if (! ISWHITESPACE(_chLookahead))
                return XML_E_MISSINGWHITESPACE;
            // fall through
        case OP_OWS:
            //checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::skipWhiteSpace, (short)newState));
            checkhr2(skipWhiteSpace());
            //if (_fFoundPEREf) return XML_E_FOUNDPEREF;
            break;
        case OP_CHARWS:
            //if (_fFoundPEREf) return S_OK;
            mark();
            //checkeof(_chLookahead, _lEOFError);
            if (_chLookahead == pSE->_pch[0])
            {
                ADVANCE;
                newState = pSE->_sGoto;
                _nToken = pSE->_lDelta;
            }
            else if (! ISWHITESPACE(_chLookahead))
            {
                return XML_E_WHITESPACEORQUESTIONMARK;
            }
            else
                newState = pSE->_sArg1;
            break;
        case OP_CHAR:
            //if (_fFoundPEREf) return S_OK;
            mark();
        case OP_CHAR2:
            //if (_fFoundPEREf) return S_OK;
            //checkeof(_chLookahead, _lEOFError);
            if (_chLookahead == pSE->_pch[0])
            {
                ADVANCE;
                newState = pSE->_sGoto;
                _nToken = pSE->_lDelta;
                //if (_nToken == XML_GROUP)
                    //_nAttrType = XMLTYPE_NMTOKEN;
            }
            else
            {
                newState = pSE->_sArg1;
                if (newState >= XML_E_PARSEERRORBASE &&
                    ISWHITESPACE(_chLookahead))
                    return XML_E_UNEXPECTED_WHITESPACE;
            }
            break;
        case OP_PEEK:
            //if (_fFoundPEREf) return S_OK;
            //checkeof(_chLookahead, _lEOFError);
            if (_chLookahead == pSE->_pch[0])
            {
                newState = pSE->_sGoto;
            }
            else
                newState = pSE->_sArg1;
            break;

        case OP_NAME:
            //if (_fFoundPEREf) return S_OK;
            //checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::parseName, (short)newState));
            checkhr2(parseName());
            break;
        case OP_TOKEN:
            _nToken = pSE->_sArg1;
            _lLengthDelta = pSE->_lDelta;  
            break;
        case OP_POP:
            _lLengthDelta = pSE->_lDelta;
            if (_lLengthDelta == 0) mark();
            // The _lDelta field contains a boolean flag to tell us whether this
            // pop needs to check for parameter entity boundary or not.
            checkhr2(pop(pSE->_lDelta == 0)); // we're done !
            _nToken = pSE->_sArg1;
            //_nAttrType = XMLTYPE_CDATA;
            return S_OK;
        case OP_STRCMP:
            {
                const WCHAR* t = NULL;
                long len = 0;
                getToken(&t,&len);
                long delta = (pSE->_lDelta < 0) ? pSE->_lDelta : 0;
                //if (StringEquals(pSE->_pch,t,len+delta,_fCaseInsensitive))
                if (::FusionpCompareStrings(pSE->_pch, len+delta, t, len+delta, _fCaseInsensitive)==0)
                {
                    if (pSE->_lDelta > 0) 
                    {
                        _nToken = pSE->_lDelta;
                        _lLengthDelta = 0;
                    }

					newState = pSE->_sGoto;
                }
                else
                    newState = pSE->_sArg1;
             }
             break;

        case OP_COMMENT:
            return push(&XMLStream::parseComment, (short)newState);
            break;

        case OP_CONDSECT:
            //if (_fFoundPEREf) return S_OK;
            // parse <![CDATA[...]]> or <![IGNORE[...]]>
            return push(&XMLStream::parseCondSect, (short)newState);

        case OP_SNCHAR:
            //checkeof(_chLookahead, _lEOFError);
            if (isStartNameChar(_chLookahead))
            {
                newState = pSE->_sGoto;
            }
            else
                newState = pSE->_sArg1;
            break;
        case OP_EQUALS:
            //if (_fFoundPEREf) return S_OK;
            //checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::parseEquals, (short)newState));
            checkhr2(parseEquals());
            break;
        case OP_ENCODING:
            {
                const WCHAR* t = NULL; // prefix bug fix, xiaoyuw@08/29/00
                long len = 0; // prefix bug fix, xiaoyuw@08/29/00
                checkhr2(_pInput->getToken(&t,&len));
                checkhr2(_pInput->switchEncoding(t, len+pSE->_lDelta));
            }
            break;

        case OP_ATTRVAL:
            //if (_fFoundPEREf) return S_OK;
            if (_chLookahead != L'"' && _chLookahead != L'\'')
            {
                return XML_E_MISSINGQUOTE;
            }  
            _chTerminator = _chLookahead;
            ADVANCE; 
            mark();
            _fReturnAttributeValue = (pSE->_sArg1 == 1);
            //checkeof(_chLookahead, _lEOFError);
            return push(&XMLStream::parseAttrValue, (short)newState);
            break;

        } // end of switch
        if (_fnState != &XMLStream::parseTable)
            return S_OK;

        if (newState >= XML_E_PARSEERRORBASE)
            return (HRESULT)newState;
        else
            _sSubState = (short)newState;
    } // end of while

    if (_nToken == XMLStream::XML_ENDDECL)
    {
        return _pInput->UnFreeze();
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT    
XMLStream::_PushChar(WCHAR ch) 
{
    // buffer needs to grow.
    long   newsize =  (_lBufSize+512)*2 ;
    WCHAR* newbuf = NEW ( WCHAR[newsize]);
    if (newbuf == NULL)
        return E_OUTOFMEMORY;

    if (_pchBuffer != NULL){
        ::memcpy(newbuf, _pchBuffer, sizeof(WCHAR)*_lBufLen);
        delete[] _pchBuffer;
    }

    _lBufSize = newsize;
    _pchBuffer = newbuf;   
    _pchBuffer[_lBufLen++] = ch;
    
	return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::AdvanceTo(short substate)
{
    // This method combines and advance with a state switch in one
    // atomic operation that handles the E_PENDING case properly.

    _sSubState = substate;

    //HRESULT hr = (!_fDTD) ? _pInput->nextChar(&_chLookahead, &_fEOF) : DTDAdvance(); 
	HRESULT hr = _pInput->nextChar(&_chLookahead, &_fEOF); 
    if ((hr == static_cast<HRESULT>(E_PENDING)) ||
        (hr == static_cast<HRESULT>(E_DATA_AVAILABLE)) ||
        (hr == static_cast<HRESULT>(E_DATA_REALLOCATE)) ||
        (hr == static_cast<HRESULT>(XML_E_FOUNDPEREF)))
    {
        // Then we must do an advance next time around before continuing
        // with previous state.  Push will save the _sSubState and return
        // to it.
        push(&XMLStream::firstAdvance,substate);
    }    
    return hr;
}
////////////////////////////////////////////////////////////////////////
bool
XMLStream::PreEntityText()
{
    // This is a helper function that calculates whether or not to
    // return some PCDATA or WHITEPACE before an entity reference.
    if (_fPCDataPending)
    {
        // return what we have so far.
        //if (_fWhitespace && ! _fIE4Quirks) // in IE4 mode we do not have WHITESPACE nodes
                                           // and entities are always resolved, so return
                                           // the leading whitespace as PCDATA.
		if (_fWhitespace )
            _nToken = XML_WHITESPACE;                                
        else                               
            _nToken = XML_PCDATA;

        long entityLen = _pInput->getTokenLength() - _lEntityPos;
        _lLengthDelta = -entityLen;
        _lMarkDelta = entityLen;
        _fPCDataPending = false;
        _fWhitespace = true;
        return true;
    }

    return false;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::ErrorCallback(HRESULT hr)
{
    if (hr == static_cast<HRESULT>(E_DATA_AVAILABLE))
        hr = static_cast<HRESULT>(XML_DATAAVAILABLE);
    else if (hr == static_cast<HRESULT>(E_DATA_REALLOCATE))
        hr = static_cast<HRESULT>(XML_DATAREALLOCATE);
    return _pXMLParser->ErrorCallback(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\args.h ===
/*
** args.h - Globals and prototypes for args.c.
**
** Author:  DavidDi
*/


// Globals
///////////

extern BOOL bDoRename,     // flag for performing compressed file renaming
            bDisplayHelp,  // flag for displaying help information
            bTargetIsDir,  // flag telling whether or not files are being
                           // compressed to a directory
            bUpdateOnly,   // flag for conditional compression based on
                           // existing target file's date/time stamp relative
                           // to source file.
            bNoLogo;       // flag to suppress printing copyright info.

extern INT nNumFileSpecs,  // number of non-switch command-line arguments
           iTarget;        // argv[] index of target directory argument

extern BOOL bDoListFiles;  // flag for displaying list of files from a CAB
                           // (instead of actually expanding them)
extern CHAR ARG_PTR *pszSelectiveFilesSpec; // name of file(s) to expand from a CAB

#ifdef COMPRESS
extern BYTE byteAlgorithm; // compression / expansion algorithm to use
#endif


// Prototypes
//////////////

extern BOOL ParseArguments(INT argc, CHAR ARG_PTR *argv[]);
extern BOOL CheckArguments(VOID);
extern INT GetNextFileArg(CHAR ARG_PTR *argv[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\inc\basevdm.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basevdm.h

Abstract:

    This module contains private function prototypes
    and types for vdm support.

Author:

    Sudeep Bharati (sudeepb) 15-Sep-1991

Revision History:

--*/

#define ROUND_UP(n,size)        (((ULONG)(n) + (size - 1)) & ~(size - 1))

// Update VDM entry indexes

#define UPDATE_VDM_UNDO_CREATION    0
#define UPDATE_VDM_PROCESS_HANDLE   1
#define UPDATE_VDM_HOOKED_CTRLC     2


// Undo VDM Creation States

#define VDM_PARTIALLY_CREATED       1
#define VDM_FULLY_CREATED           2
#define VDM_BEING_REUSED            4
#define VDM_CREATION_SUCCESSFUL     8

// Defines for BinaryType

#define BINARY_TYPE_DOS             0x10
#define BINARY_TYPE_WIN16           0x20
#define BINARY_TYPE_SEPWOW          0x40
#define BINARY_TYPE_INJWOW          0x80

#define BINARY_SUBTYPE_MASK         0xF
#define BINARY_TYPE_DOS_EXE         01
#define BINARY_TYPE_DOS_COM         02
#define BINARY_TYPE_DOS_PIF         03

#define IS_SHARED_WOW_BINARY(VdmBinaryType) \
(BINARY_TYPE_WIN16 & (VdmBinaryType))

#define IS_WOW_BINARY(VdmBinaryType) \
((BINARY_TYPE_WIN16 | BINARY_TYPE_SEPWOW) & (VdmBinaryType))



// Defines for VDMState

#define VDM_NOT_PRESENT             1
#define VDM_PRESENT_NOT_READY       2
#define VDM_PRESENT_AND_READY       4

#define VDM_STATE_MASK              7


#define EXIT_VDM                    1
#define EXIT_VDM_NOTIFICATION       2

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\inc\basemsg.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basemsg.h

Abstract:

    This include file defines the message formats used to communicate
    between the client and server portions of the BASE portion of the
    Windows subsystem.

Author:

    Steve Wood (stevewo) 25-Oct-1990

Revision History:

--*/

#ifndef _WINDOWS_BASEMSG_
#define _WINDOWS_BASEMSG_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Message format for messages sent from the client to the server
//

typedef enum _BASESRV_API_NUMBER {
    BasepCreateProcess = BASESRV_FIRST_API_NUMBER,
    BasepCreateThread,
    BasepGetTempFile,
    BasepExitProcess,
    BasepDebugProcess,
    BasepCheckVDM,
    BasepUpdateVDMEntry,
    BasepGetNextVDMCommand,
    BasepExitVDM,
    BasepIsFirstVDM,
    BasepGetVDMExitCode,
    BasepSetReenterCount,
    BasepSetProcessShutdownParam,
    BasepGetProcessShutdownParam,
    BasepNlsSetUserInfo,
    BasepNlsSetMultipleUserInfo,
    BasepNlsCreateSection,
    BasepSetVDMCurDirs,
    BasepGetVDMCurDirs,
    BasepBatNotification,
    BasepRegisterWowExec,
    BasepSoundSentryNotification,
    BasepRefreshIniFileMapping,
    BasepDefineDosDevice,
    BasepSetTermsrvAppInstallMode,
    BasepNlsUpdateCacheCount,
    BasepSetTermsrvClientTimeZone,
    BasepSxsCreateActivationContext,
    BasepDebugProcessStop,
    BasepRegisterThread,
    BasepCheckApplicationCompatibility,
    BasepNlsGetUserInfo,
    BasepMaxApiNumber
} BASESRV_API_NUMBER, *PBASESRV_API_NUMBER;

#ifndef NTOSKRNL_WMI      // Don't include this in kernel mode WMI code

typedef struct _BASE_NLS_SET_USER_INFO_MSG {
    LCTYPE   LCType;
    LPWSTR pData;
    ULONG DataLength;
} BASE_NLS_SET_USER_INFO_MSG, *PBASE_NLS_SET_USER_INFO_MSG;

typedef struct _BASE_NLS_GET_USER_INFO_MSG {
    PNLS_USER_INFO  pData;
    ULONG   DataLength;
} BASE_NLS_GET_USER_INFO_MSG, *PBASE_NLS_GET_USER_INFO_MSG;

typedef struct _BASE_NLS_SET_MULTIPLE_USER_INFO_MSG {
    ULONG Flags;
    ULONG DataLength;
    LPWSTR pPicture;
    LPWSTR pSeparator;
    LPWSTR pOrder;
    LPWSTR pTLZero;
    LPWSTR pTimeMarkPosn;
} BASE_NLS_SET_MULTIPLE_USER_INFO_MSG, *PBASE_NLS_SET_MULTIPLE_USER_INFO_MSG;

typedef struct _BASE_NLS_CREATE_SECTION_MSG {
    HANDLE hNewSection;
    UINT uiType;
    LCID Locale;
} BASE_NLS_CREATE_SECTION_MSG, *PBASE_NLS_CREATE_SECTION_MSG;
#define NLS_CREATE_SECTION_UNICODE 1
#define NLS_CREATE_SECTION_LOCALE  2
#define NLS_CREATE_SECTION_CTYPE   3
#define NLS_CREATE_SECTION_SORTKEY 4
#define NLS_CREATE_SECTION_SORTTBLS 5
#define NLS_CREATE_SECTION_DEFAULT_OEMCP 6
#define NLS_CREATE_SECTION_DEFAULT_ACP   7
#define NLS_CREATE_SECTION_LANG_EXCEPT   8
#define NLS_CREATE_SORT_SECTION 9
#define NLS_CREATE_LANG_EXCEPTION_SECTION 10
#define NLS_CREATE_CODEPAGE_SECTION 11
#define NLS_CREATE_SECTION_GEO 12

typedef struct _BASE_NLS_UPDATE_CACHE_COUNT_MSG {
  ULONG Reserved;
} BASE_NLS_UPDATE_CACHE_COUNT_MSG, *PBASE_NLS_UPDATE_CACHE_COUNT_MSG;

typedef struct _BASE_SHUTDOWNPARAM_MSG {
    ULONG ShutdownLevel;
    ULONG ShutdownFlags;
} BASE_SHUTDOWNPARAM_MSG, *PBASE_SHUTDOWNPARAM_MSG;

// NONE must be 0 due to RtlZeroMemory use.
#define BASE_MSG_PATHTYPE_NONE             (0)
#define BASE_MSG_PATHTYPE_FILE             (1)
#define BASE_MSG_PATHTYPE_URL              (2)
#define BASE_MSG_PATHTYPE_OVERRIDE         (3)

// NONE must be 0 due to RtlZeroMemory use.
#define BASE_MSG_FILETYPE_NONE             (0)
#define BASE_MSG_FILETYPE_XML              (1)
#define BASE_MSG_FILETYPE_PRECOMPILED_XML  (2)

// NONE must be 0 due to RtlZeroMemory use.
#define BASE_MSG_HANDLETYPE_NONE           (0)
#define BASE_MSG_HANDLETYPE_PROCESS        (1)
#define BASE_MSG_HANDLETYPE_CLIENT_PROCESS (2)
#define BASE_MSG_HANDLETYPE_SECTION        (3)

#define BASE_MSG_SXS_MANIFEST_PRESENT                                   (0x0001)
#define BASE_MSG_SXS_POLICY_PRESENT                                     (0x0002)
#define BASE_MSG_SXS_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT   (0x0004)
#define BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT                  (0x0008)
#define BASE_MSG_SXS_APP_RUNNING_IN_SAFEMODE                            (0x0010)


#define SXS_APPCOMPACT_FLAG_APP_RUNNING_SAFEMODE    (0x0001)

typedef struct _BASE_MSG_SXS_STREAM {
    IN UCHAR          FileType;
    IN UCHAR          PathType;
    IN UCHAR          HandleType;
    IN UNICODE_STRING Path;
    IN HANDLE         FileHandle;
    IN HANDLE         Handle;
    IN ULONGLONG      Offset; // big enough to hold file offsets in the future
    IN SIZE_T         Size;
} BASE_MSG_SXS_STREAM, *PBASE_MSG_SXS_STREAM;
typedef const BASE_MSG_SXS_STREAM* PCBASE_MSG_SXS_STREAM;

typedef struct _BASE_SXS_CREATEPROCESS_MSG {
    IN ULONG               Flags;
    IN BASE_MSG_SXS_STREAM Manifest;
    IN BASE_MSG_SXS_STREAM Policy;
    IN UNICODE_STRING AssemblyDirectory;
} BASE_SXS_CREATEPROCESS_MSG, *PBASE_SXS_CREATEPROCESS_MSG;
typedef const BASE_SXS_CREATEPROCESS_MSG* PCBASE_SXS_CREATEPROCESS_MSG;

typedef struct _BASE_CREATEPROCESS_MSG {
    HANDLE ProcessHandle;
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
    ULONG CreationFlags;
    ULONG VdmBinaryType;
    ULONG VdmTask;
    HANDLE hVDM;
    BASE_SXS_CREATEPROCESS_MSG Sxs;
    ULONGLONG Peb;
    ULONG_PTR RealPeb;
    USHORT ProcessorArchitecture;
} BASE_CREATEPROCESS_MSG, *PBASE_CREATEPROCESS_MSG;

#endif

typedef struct _BASE_CREATETHREAD_MSG {
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
} BASE_CREATETHREAD_MSG, *PBASE_CREATETHREAD_MSG;

#ifndef NTOSKRNL_WMI      // Don't include this in kernel mode WMI code

typedef struct _BASE_GETTEMPFILE_MSG {
    UINT uUnique;
} BASE_GETTEMPFILE_MSG, *PBASE_GETTEMPFILE_MSG;

typedef struct _BASE_EXITPROCESS_MSG {
    UINT uExitCode;
} BASE_EXITPROCESS_MSG, *PBASE_EXITPROCESS_MSG;

typedef struct _BASE_DEBUGPROCESS_MSG {
    DWORD dwProcessId;
    CLIENT_ID DebuggerClientId;
    PVOID AttachCompleteRoutine;
} BASE_DEBUGPROCESS_MSG, *PBASE_DEBUGPROCESS_MSG;

typedef struct _BASE_CHECKVDM_MSG {
    ULONG  iTask;
    HANDLE ConsoleHandle;
    ULONG  BinaryType;
    HANDLE WaitObjectForParent;
    HANDLE StdIn;
    HANDLE StdOut;
    HANDLE StdErr;
    ULONG  CodePage;
    ULONG  dwCreationFlags;
    PCHAR  CmdLine;
    PCHAR  AppName;
    PCHAR  PifFile;
    PCHAR  CurDirectory;
    PCHAR  Env;
    ULONG  EnvLen;
    LPSTARTUPINFOA StartupInfo;
    PCHAR  Desktop;
    ULONG  DesktopLen;
    PCHAR  Title;
    ULONG  TitleLen;
    PCHAR  Reserved;
    ULONG  ReservedLen;
    USHORT CmdLen;
    USHORT AppLen;
    USHORT PifLen;
    USHORT CurDirectoryLen;
    USHORT CurDrive;
    USHORT VDMState;
    PLUID  UserLuid;
} BASE_CHECKVDM_MSG, *PBASE_CHECKVDM_MSG;

typedef struct _BASE_UPDATE_VDM_ENTRY_MSG {
    ULONG  iTask;
    ULONG  BinaryType;
    HANDLE ConsoleHandle;
    HANDLE VDMProcessHandle;
    HANDLE WaitObjectForParent;
    WORD   EntryIndex;
    WORD   VDMCreationState;
} BASE_UPDATE_VDM_ENTRY_MSG, *PBASE_UPDATE_VDM_ENTRY_MSG;

typedef struct _BASE_GET_NEXT_VDM_COMMAND_MSG {
    ULONG  iTask;
    HANDLE ConsoleHandle;
    HANDLE WaitObjectForVDM;
    HANDLE StdIn;
    HANDLE StdOut;
    HANDLE StdErr;
    ULONG  CodePage;
    ULONG  dwCreationFlags;
    ULONG  ExitCode;
    PCHAR  CmdLine;
    PCHAR  AppName;
    PCHAR  PifFile;
    PCHAR  CurDirectory;
    PCHAR  Env;
    ULONG  EnvLen;
    LPSTARTUPINFOA StartupInfo;
    PCHAR  Desktop;
    ULONG  DesktopLen;
    PCHAR  Title;
    ULONG  TitleLen;
    PCHAR  Reserved;
    ULONG  ReservedLen;
    USHORT CurrentDrive;
    USHORT CmdLen;
    USHORT AppLen;
    USHORT PifLen;
    USHORT CurDirectoryLen;
    USHORT VDMState;
    BOOLEAN fComingFromBat;
} BASE_GET_NEXT_VDM_COMMAND_MSG, *PBASE_GET_NEXT_VDM_COMMAND_MSG;

typedef struct _BASE_EXIT_VDM_MSG {
    HANDLE ConsoleHandle;
    ULONG  iWowTask;
    HANDLE WaitObjectForVDM;
} BASE_EXIT_VDM_MSG, *PBASE_EXIT_VDM_MSG;

typedef struct _BASE_SET_REENTER_COUNT {
    HANDLE ConsoleHandle;
    ULONG  fIncDec;
} BASE_SET_REENTER_COUNT_MSG, *PBASE_SET_REENTER_COUNT_MSG;

typedef struct _BASE_IS_FIRST_VDM_MSG {
    BOOL    FirstVDM;
} BASE_IS_FIRST_VDM_MSG, *PBASE_IS_FIRST_VDM_MSG;

typedef struct _BASE_GET_VDM_EXIT_CODE_MSG {
    HANDLE ConsoleHandle;
    HANDLE hParent;
    ULONG  ExitCode;
} BASE_GET_VDM_EXIT_CODE_MSG, *PBASE_GET_VDM_EXIT_CODE_MSG;

typedef struct _BASE_GET_SET_VDM_CUR_DIRS_MSG {
    HANDLE ConsoleHandle;
    PCHAR  lpszzCurDirs;
    ULONG  cchCurDirs;
} BASE_GET_SET_VDM_CUR_DIRS_MSG, *PBASE_GET_SET_VDM_CUR_DIRS_MSG;

typedef struct _BASE_BAT_NOTIFICATION_MSG {
    HANDLE ConsoleHandle;
    ULONG  fBeginEnd;
} BASE_BAT_NOTIFICATION_MSG, *PBASE_BAT_NOTIFICATION_MSG;

typedef struct _BASE_REGISTER_WOWEXEC_MSG {
    HANDLE hwndWowExec;
    HANDLE ConsoleHandle;
} BASE_REGISTER_WOWEXEC_MSG, *PBASE_REGISTER_WOWEXEC_MSG;

typedef struct _BASE_SOUNDSENTRY_NOTIFICATION_MSG {
    ULONG  VideoMode;
} BASE_SOUNDSENTRY_NOTIFICATION_MSG, *PBASE_SOUNDSENTRY_NOTIFICATION_MSG;

typedef struct _BASE_REFRESHINIFILEMAPPING_MSG {
    UNICODE_STRING IniFileName;
} BASE_REFRESHINIFILEMAPPING_MSG, *PBASE_REFRESHINIFILEMAPPING_MSG;

typedef struct _BASE_DEFINEDOSDEVICE_MSG {
    ULONG Flags;
    UNICODE_STRING DeviceName;
    UNICODE_STRING TargetPath;
} BASE_DEFINEDOSDEVICE_MSG, *PBASE_DEFINEDOSDEVICE_MSG;

typedef struct _BASE_SET_TERMSRVAPPINSTALLMODE {
    BOOL bState;
} BASE_SET_TERMSRVAPPINSTALLMODE, *PBASE_SET_TERMSRVAPPINSTALLMODE;

//struct for transferring time zone information
typedef struct _BASE_SET_TERMSRVCLIENTTIMEZONE {
    BOOL    fFirstChunk; //TRUE if it is first chunk of information
                         //(StandardX values)
    LONG    Bias; //current bias
    WCHAR   Name[32];//StandardName or DaylightName
    SYSTEMTIME Date;//StandardDate or DaylightDate
    LONG    Bias1; //StandardBias  or DaylightBias
    KSYSTEM_TIME RealBias; //current bias which is used in GetLocalTime etc.
    ULONG   TimeZoneId;
} BASE_SET_TERMSRVCLIENTTIMEZONE, *PBASE_SET_TERMSRVCLIENTTIMEZONE;

typedef struct _BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG {
    IN ULONG               Flags;
    IN USHORT              ProcessorArchitecture;
    IN LANGID              LangId;
    IN BASE_MSG_SXS_STREAM Manifest;
    IN BASE_MSG_SXS_STREAM Policy;
    IN UNICODE_STRING      AssemblyDirectory;
    IN UNICODE_STRING      TextualAssemblyIdentity;
    //
    // Csrss writes a PVOID through this PVOID.
    // It assumes the PVOID to write is of native size;
    // for a while it was. Now, it often is not, so
    // we do some manual marshalling in base\win32\client\csrsxs.c
    // to make it right. We leave this as plain PVOID
    // instead of say PVOID* (as it was for a while) to
    // defeat the wow64 thunk generator.
    //
    // The thunks can be seen in
    // base\wow64\whbase\obj\ia64\whbase.c
    //
    PVOID                  ActivationContextData;
} BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG, *PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG;
typedef const BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG* PCBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG;

typedef struct _BASE_CHECK_APPLICATION_COMPATIBILITY_MSG {
    IN UNICODE_STRING FileName;
    IN HANDLE         FileHandle;
    IN DWORD          CacheCookie;
    IN USHORT         ExeType;
    IN PVOID          pEnvironment;
    IN ULONG          EnvironmentSize;

    OUT PVOID         pAppCompatData;
    OUT DWORD         cbAppCompatData;
    OUT PVOID         pSxsData;
    OUT DWORD         cbSxsData;
    OUT BOOL          bRunApp;
    OUT DWORD         FusionFlags;

} BASE_CHECK_APPLICATION_COMPATIBILITY_MSG, *PBASE_CHECK_APPLICATION_COMPATIBILITY_MSG;


#endif

typedef struct _BASE_API_MSG {
    PORT_MESSAGE h;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CSR_API_NUMBER ApiNumber;
    ULONG ReturnValue;
    ULONG Reserved;
    union {
#ifndef NTOSKRNL_WMI      // Don't include this in kernel mode WMI code
        BASE_NLS_SET_USER_INFO_MSG NlsSetUserInfo;
        BASE_NLS_GET_USER_INFO_MSG NlsGetUserInfo;
        BASE_NLS_SET_MULTIPLE_USER_INFO_MSG NlsSetMultipleUserInfo;
        BASE_NLS_UPDATE_CACHE_COUNT_MSG NlsCacheUpdateCount;
        BASE_NLS_CREATE_SECTION_MSG NlsCreateSection;
        BASE_SHUTDOWNPARAM_MSG ShutdownParam;
        BASE_CREATEPROCESS_MSG CreateProcess;
#endif
        BASE_CREATETHREAD_MSG CreateThread;
#ifndef NTOSKRNL_WMI      // Don't include this in kernel mode WMI code
        BASE_GETTEMPFILE_MSG GetTempFile;
        BASE_EXITPROCESS_MSG ExitProcess;
        BASE_DEBUGPROCESS_MSG DebugProcess;
        BASE_CHECKVDM_MSG CheckVDM;
        BASE_UPDATE_VDM_ENTRY_MSG UpdateVDMEntry;
        BASE_GET_NEXT_VDM_COMMAND_MSG GetNextVDMCommand;
        BASE_EXIT_VDM_MSG ExitVDM;
        BASE_IS_FIRST_VDM_MSG IsFirstVDM;
        BASE_GET_VDM_EXIT_CODE_MSG GetVDMExitCode;
        BASE_SET_REENTER_COUNT_MSG SetReenterCount;
        BASE_GET_SET_VDM_CUR_DIRS_MSG GetSetVDMCurDirs;
        BASE_BAT_NOTIFICATION_MSG BatNotification;
        BASE_REGISTER_WOWEXEC_MSG RegisterWowExec;
        BASE_SOUNDSENTRY_NOTIFICATION_MSG SoundSentryNotification;
        BASE_REFRESHINIFILEMAPPING_MSG RefreshIniFileMapping;
        BASE_DEFINEDOSDEVICE_MSG DefineDosDeviceApi;
        BASE_SET_TERMSRVAPPINSTALLMODE SetTermsrvAppInstallMode;
        BASE_SET_TERMSRVCLIENTTIMEZONE SetTermsrvClientTimeZone;
        BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG SxsCreateActivationContext;
        BASE_CHECK_APPLICATION_COMPATIBILITY_MSG CheckApplicationCompatibility;
#endif
    } u;
} BASE_API_MSG, *PBASE_API_MSG;

#if !defined(SORTPP_PASS) // The Wow64 thunk generation tools don't like this.
C_ASSERT(sizeof(BASE_API_MSG) <= sizeof(CSR_API_MSG));
#endif

#endif //_WINDOWS_BASEMSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\messages.h ===
/*
** messages.h - Messages displayed by LZA file compression / expansion
**              programs.
**
** These messages follow printf() formatting conventions.  This module is
** included twice - once for COMPRESS (COMPRESS defined) and once for EXPAND
** (COMPRESS not defined).
**
** Converted to stringtable, FloydR, 2/10/93
*/


// Constants
/////////////

/***************************** COMMON MESSAGES *****************************/

#define SID_INSUFF_MEM		1
#define SID_NOT_A_DIR		2
#define SID_BAD_SWITCH		3
#define SID_NO_FILE_SPECS	4
#define SID_NO_OVERWRITE	5
#define SID_NO_OPEN_INPUT	6
#define SID_NO_READ_INPUT	7
#define SID_NO_OPEN_OUTPUT	8
#define SID_OUT_OF_SPACE	9
#define SID_BANNER_TEXT		10
#define SID_GEN_FAILURE		11
#define SID_COLLISION		12
#define SID_FILE_REPORT		13
#define SID_EMPTY_FILE_REPORT	14
#define	SID_TOTAL_REPORT	15
#define	SID_INSTRUCTIONS	16
#define	SID_INSTRUCTIONS2   17
#define	SID_INSTRUCTIONS3   18
#define SID_BAD_SWITCH2     19

#ifdef COMPRESS

/**************************** COMPRESS MESSAGES ****************************/

#define SID_COMPRESSING         20
#define SID_COMPRESSING_MSZIP   21
#define SID_COMPRESSING_QUANTUM 22
#define SID_COMPRESSING_LZX     23
#define SID_INVALID_LIST_FILE   24

#else // EXPAND

/***************************** EXPAND Messages *****************************/

#define	SID_EXPANDING		20
#define	SID_COPYING		21
#define	SID_COPY_REPORT		22
#define	SID_FORMAT_ERROR	23
#define	SID_UNKNOWN_ALG		24
#define SID_UNEXP_TARGET        25
#define SID_LISTING             26
#define SID_TOTAL_COUNT         27
#define SID_NO_MATCHES          28
#define SID_DEST_REQUIRED       29
#define SID_FILESPEC_REQUIRED   30

#endif

extern	TCHAR	ErrorMsg[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\main.h ===
/*
** main.h - Constants and globals used in LZA file compression program.
**
** Author:  DavidDi
*/


// Constants
/////////////

#define EXIT_SUCCESS       0           // main() return codes
#define EXIT_FAILURE       1

#define FAIL               (-1)

#define chHELP_SWITCH      '?'         // help switch character
#define chRENAME_SWITCH    'R'         // rename switch character
#define chUPDATE_SWITCH    'D'         // update-only switch character
#define chLIST_SWITCH      'D'         // CAB directory listing switch character
#define chNO_LOGO_SWITCH   'S'         // suppress copyright print switch char
#define chSELECTIVE_SWITCH 'F'         // CAB selective extract switch character

#ifdef COMPRESS
#define chALG_SWITCH       'Z'         // use diamond
#define MSZIP_ALG          (ALG_FIRST + 128)
#define QUANTUM_ALG        (ALG_FIRST + 129)
#define LZX_ALG            (ALG_FIRST + 130)
#endif

#define DEFAULT_ALG        ALG_FIRST   // compression algorithm to use if
                                       // none is specified


// Globals
///////////
extern CHAR ARG_PTR *pszInFileName,    // input file name
                    *pszOutFileName,   // output file name
                    *pszTargetName;    // target path name
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\compress\compress.c ===
/*
** main.c - Main module for DOS command-line LZA file compression / expansion
**          programs.
**
** Author: DavidDi
**
** This module is compiled twice - once for COMPRESS (COMPRESS defined) and
** once for EXPAND (COMPRESS not defined).
*/


// Headers
///////////

#include <malloc.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <share.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"

#include "args.h"
#include "main.h"
#include "messages.h"

#include <diamondc.h>
#include "mydiam.h"

// Globals
///////////

CHAR ARG_PTR *pszInFileName,     // input file name
             *pszOutFileName,    // output file name
             *pszTargetName;     // target path name

TCHAR   ErrorMsg[1024];


// Module Variables
////////////////////

#ifndef COMPRESS
static BOOL bCopyingFile;        // Is current file being copied or expanded?
#endif


// Local Prototypes
////////////////////

static VOID DisplayErrorMessage(INT fError);
static VOID MakeDestFileName(CHAR ARG_PTR *argv[], CHAR ARG_PTR *pszDest);
static BOOL GetCanonicalName(LPSTR lpszFileName, LPSTR lpszCanonicalBuf);
static BOOL ActuallyTheSameFile(CHAR ARG_PTR *pszFile1,
                                CHAR ARG_PTR *pszFile2);
static BOOL ProcessNotification(CHAR ARG_PTR *pszSource,
                                CHAR ARG_PTR *pszDest, WORD wNotification);


/*
** static void DisplayErrorMessage(int fError);
**
** Display error message for given error condition.
**
** Arguments:  LZERROR_ code
**
** Returns:    void
**
** Globals:    none
*/
static VOID DisplayErrorMessage(INT fError)
{
   switch(fError)
   {
      case LZERROR_BADINHANDLE:
         LoadString(NULL, SID_NO_OPEN_INPUT, ErrorMsg, 1024);
         printf(ErrorMsg, pszInFileName);
         break;

      case LZERROR_BADOUTHANDLE:
         LoadString(NULL, SID_NO_OPEN_OUTPUT, ErrorMsg, 1024);
         printf(ErrorMsg, pszOutFileName);
         break;

      case LZERROR_READ:
         LoadString(NULL, SID_NO_READ_INPUT, ErrorMsg, 1024);
         printf(ErrorMsg, pszInFileName);
         break;

      case LZERROR_WRITE:
         LoadString(NULL, SID_OUT_OF_SPACE, ErrorMsg, 1024);
         printf(ErrorMsg, pszOutFileName);
         break;

      case BLANK_ERROR:
         break;

      default:
         LoadString(NULL, SID_GEN_FAILURE, ErrorMsg, 1024);
         printf(ErrorMsg, pszInFileName, pszOutFileName);
         break;
   }
}


/*
** static void MakeDestFileName(char ARG_PTR *argv[], char ARG_PTR *pszDest);
**
** Create the appropriate destination file name.
**
** Arguments:  argv    - like argument to main()
**             pszDest - pointer to destination file name buffer to be filled
**                       in
**
** Returns:    void
**
** Globals:    none
*/
static VOID MakeDestFileName(CHAR ARG_PTR *argv[], CHAR ARG_PTR *pszDest)
{
   CHAR ARG_PTR *pszDestFile;

   if (nNumFileSpecs == 2 && bTargetIsDir == FALSE && bDoRename == FALSE)
      // Compress a single input file to a single output file.  N.b., we must
      // be careful to eat up the output file name command-line argument so
      // it doesn't get processed like another input file!
      STRCPY(pszDest, argv[GetNextFileArg(argv)]);
   else if (bTargetIsDir == TRUE)
   {
      // Prepend output file name with destination directory path name.
      STRCPY(pszDest, pszTargetName);

      // Isolate source file name from source file specification.
      pszDestFile = ExtractFileName(pszInFileName);

      // Add destination file name to destination directory path
      // specification.
      MakePathName(pszDest, pszDestFile);
   }
   else
      // Destination file name same as source file name.  N.b., this is an
      // error condition if (bDoRename == FALSE).
      STRCPY(pszDest, pszInFileName);
}


/*
** static BOOL GetCanonicalName(LPSTR lpszFileName, LPSTR lpszCanonicalBuf);
**
** Gets the canonical name for a given file specification.
**
** Arguments:  pszFileName    - file specification
**             szCanonicalBuf - buffer to be filled with canonical name
**
** Returns:    TRUE if successful.  FALSE if unsuccessful.
**
** N.b., szCanonicalBuf must be at least 128 bytes long.  The contents of
** szCanonicalBuf are only defined if the funstion returns TRUE.
**
*/
static BOOL GetCanonicalName(LPSTR lpszFileName, LPSTR lpszCanonicalBuf)
{
   BOOL bRetVal = FALSE;
   LPSTR lpszLastComp;

   return((BOOL) GetFullPathName(lpszFileName, MAX_PATH, lpszCanonicalBuf,  &lpszLastComp));
}


/*
** static BOOL ActuallyTheSameFile(char ARG_PTR *pszFile1,
**                                 char ARG_PTR *pszFile2);
**
** Checks to see if two file specifications point to the same physical file.
**
** Arguments:  pszFile1 - first file specification
**             pszFile2 - second file specification
**
** Returns:    BOOL - TRUE if the file specifications point to the same
**                    physical file.  FALSE if not.
**
** Globals:    none
*/
static BOOL ActuallyTheSameFile(CHAR ARG_PTR *pszFile1,
                                CHAR ARG_PTR *pszFile2)
{
   CHAR szCanonicalName1[MAX_PATH],
        szCanonicalName2[MAX_PATH];

   if (GetCanonicalName(pszFile1, szCanonicalName1) &&
       GetCanonicalName(pszFile2, szCanonicalName2))
   {
      if (! lstrcmpiA(szCanonicalName1, szCanonicalName2))
         return(TRUE);
   }

   return(FALSE);
}


/*
** static BOOL ProcessNotification(char ARG_PTR *pszSource,
**                                 char ARG_PTR *pszDest,
**                                 WORD wNotification);
**
** Callback function during file processing.
**
** Arguments:  pszSource     - source file name
**             pszDest       - destination file name
**             wNotification - process type query
**
** Returns:    BOOL - (wNotification == NOTIFY_START_*):
**                         TRUE if the source file should be "processed" into
**                         the destination file.  FALSE if not.
**                    else
**                         TRUE.
**
** Globals:    none
*/
static BOOL ProcessNotification(CHAR ARG_PTR *pszSource,
                                CHAR ARG_PTR *pszDest, WORD wNotification)
{
   switch(wNotification)
   {
      case NOTIFY_START_COMPRESS:
      {
         // Fail if the source and destination files are identical.
         if (ActuallyTheSameFile(pszSource, pszDest))
         {
            LoadString(NULL, SID_COLLISION, ErrorMsg, 1024);
            printf(ErrorMsg, pszSource);
            return(FALSE);
         }

         // Display start message.
         switch (byteAlgorithm)
         {
         case LZX_ALG:
             LoadString(
                NULL,
                SID_COMPRESSING_LZX,
                ErrorMsg,
                1024
                );
             printf(ErrorMsg, pszSource, pszDest,
                        CompressionMemoryFromTCOMP(DiamondCompressionType)
                        );
             break;

         case QUANTUM_ALG:
             LoadString(
                NULL,
                SID_COMPRESSING_QUANTUM,
                ErrorMsg,
                1024
                );
             printf(ErrorMsg, pszSource, pszDest,
                        CompressionLevelFromTCOMP(DiamondCompressionType),
                        CompressionMemoryFromTCOMP(DiamondCompressionType)
                        );
             break;

         default:
             LoadString(
                NULL,
                (byteAlgorithm == MSZIP_ALG) ? SID_COMPRESSING_MSZIP : SID_COMPRESSING,
                ErrorMsg,
                1024
                );
             printf(ErrorMsg, pszSource, pszDest);
         }
      }
         break;

      default:
         break;
   }

   return(TRUE);
}


//
//  static BOOL FileTimeIsNewer( const char* pszFile1, const char* pszFile2 );
//
//  Return value is TRUE if time stamp on pszFile1 is newer than the
//  time stamp on pszFile2.  If either of the two files do not exist,
//  the return value is also TRUE (for indicating that pszFile2 should
//  be update from pszFile1).  Otherwise, the return value is FALSE.
//

static BOOL FileTimeIsNewer( const char* pszFile1, const char* pszFile2 ) {

    struct _stat StatBufSource,
                 StatBufDest;

    if (( _stat( pszFile2, &StatBufDest   )) ||
        ( _stat( pszFile1, &StatBufSource )) ||
        ( StatBufSource.st_mtime > StatBufDest.st_mtime ))
        return TRUE;

    return FALSE;

    }


LPSTR
ValidListEntry(
    LPSTR szArg
    )
{
    // Check for special character at front of file
    if ( '@' == szArg[0] )
        return szArg + 1;
    else
        return NULL;
}

BOOL
GetNextFileListFile(
    const LPSTR szFileList,
    char **pszSource,
    char **pszDest
    )
{
    static char szList[MAX_PATH] = {0},
                szSource[MAX_PATH] = {0},
                szDest[MAX_PATH] = {0};
    static BOOL bParsingFile = FALSE;
    static FILE *hFile;
    static int  dEntryNum = 1;
    int dRetVal;

    // Initialize out paramters to NULL
    *pszSource = *pszDest = NULL;

    // Open file if we are not currently parsing another one
    if ( !bParsingFile ) {
        // Do not reopen last file used as this is our signal to stop
        if ( !_stricmp( szFileList, szList ) ) {
            return TRUE;
        }

        // Attempt to open specified file
        hFile = fopen( szFileList, "rt" );
        if ( NULL == hFile ) {
            LoadString( NULL, SID_NO_OPEN_INPUT, ErrorMsg, 1024 );
            printf( ErrorMsg, szFileList );
            return FALSE;
        }

        // Store new file name in static buffer
        strcpy( szList, szFileList );

        bParsingFile = TRUE;
    }

    dRetVal = fscanf( hFile, "%s %s", szSource, szDest );
    if ( EOF == dRetVal ) {
        fclose( hFile );
        bParsingFile = FALSE;
        return TRUE;
    }
    else if ( 0 == dRetVal ) {
        LoadString( NULL, SID_INVALID_LIST_FILE, ErrorMsg, 1024 );
        printf( ErrorMsg, dEntryNum );
        return FALSE;
    }

    // Point to new source and destination entries
    *pszSource = szSource;
    *pszDest = szDest;
    // Track entry
    dEntryNum++;

    return TRUE;
}
/*
** int main(int argc, char *argv[]);
**
** Run command-line file compression program.
**
** Arguments:  figure it out
**
** Returns:    int - EXIT_SUCCESS if compression finished successfully,
**                   EXIT_FAILURE if not.
**
** Globals:    none
*/
INT __cdecl main(INT argc, CHAR *argv[])
{
   INT iSourceFileName,
       fError,
       nTotalFiles = 0,
       nReturnCode = EXIT_SUCCESS;
   CHAR ARG_PTR pszDestFileName[MAX_PATH];
   CHAR chTargetFileName[ MAX_PATH ];
   LONG cblTotInSize = 0L,
        cblTotOutSize = 0L;

   PLZINFO pLZI;

   USHORT wLanguageId = LANGIDFROMLCID(GetThreadLocale());

   if ((LANG_JAPANESE == PRIMARYLANGID(wLanguageId)) ||
       (LANG_KOREAN   == PRIMARYLANGID(wLanguageId)) ||
       (LANG_CHINESE  == PRIMARYLANGID(wLanguageId)))
   {
      //
      // This used to be #ifdef DBCS. Now a runtime check.
      //
      DWORD dw = GetConsoleOutputCP();

      switch (dw) {
          case 932:
          case 936:
          case 949:
          case 950:
             SetThreadLocale(MAKELCID(
                                MAKELANGID(
                                   PRIMARYLANGID(GetSystemDefaultLangID()),
                                   SUBLANG_ENGLISH_US),
                                SORT_DEFAULT));
             break;
          default:
             SetThreadLocale(MAKELCID(
                                MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                SORT_DEFAULT ) );
             break;
      }
   }

   // Parse command-line arguments.
   if (ParseArguments(argc, argv) != TRUE)
      return(EXIT_FAILURE);

   // Display sign-on banner.
   if ( bNoLogo == FALSE ) {
     LoadString(NULL, SID_BANNER_TEXT, ErrorMsg, 1024);
     printf(ErrorMsg);
   }

   // Set up global target path name.
   pszTargetName = argv[iTarget];

   if (bDisplayHelp == TRUE)
   {
      // User asked for help.
      LoadString(NULL, SID_INSTRUCTIONS, ErrorMsg, 1024);
      printf(ErrorMsg);
      LoadString(NULL, SID_INSTRUCTIONS2, ErrorMsg, 1024);
      printf(ErrorMsg);
      LoadString(NULL, SID_INSTRUCTIONS3, ErrorMsg, 1024);
      printf(ErrorMsg);
      return(EXIT_SUCCESS);
   }

   // Check for command line problems.
   if (CheckArguments() == FALSE)
      return(EXIT_FAILURE);

   // Set up ring buffer and I/O buffers.
   pLZI = InitGlobalBuffersEx();
   if (!pLZI)
   {
      LoadString(NULL, SID_INSUFF_MEM, ErrorMsg, 1024);
      printf(ErrorMsg);
      return(EXIT_FAILURE);
   }

   // Process each source file.
   while ((iSourceFileName = GetNextFileArg(argv)) != FAIL)
   {
      char *pszFileList = NULL,
           *pszCurFile,
           *pszCurDestFile;

      // Determine if this is a directive file
      if ( pszFileList = ValidListEntry( argv[iSourceFileName] ) ) {
          if ( !GetNextFileListFile( pszFileList, &pszCurFile, &pszCurDestFile ) ) {
              return (EXIT_FAILURE);
          }
          
          // Handle empty directive lists
          if ( NULL == pszCurFile ) continue;
      }
      // Otherwise use current argument as file to compress
      else {
           pszCurFile = argv[iSourceFileName];
      }
      
      do {
          // Set up global input file name.
          pszInFileName = CharLowerA(pszCurFile);

          // Set up global output file name.
          if ( NULL == pszFileList ) {
              MakeDestFileName(argv, pszDestFileName);
              pszOutFileName = CharLowerA(pszDestFileName);
          }
          else {
              pszOutFileName = CharLowerA(pszCurDestFile);
          }

          strcpy( chTargetFileName, pszOutFileName );

          if ( bDoRename )
              MakeCompressedName( chTargetFileName );

          if (( ! bUpdateOnly ) ||
              ( FileTimeIsNewer( pszInFileName, chTargetFileName ))) {

              if(DiamondCompressionType) {
                 fError = DiamondCompressFile(ProcessNotification,pszInFileName,
                                                pszOutFileName,bDoRename,pLZI);
              } else {
                 fError = Compress(ProcessNotification, pszInFileName,
                                     pszOutFileName, byteAlgorithm, bDoRename, pLZI);
              }

              if(fError != TRUE)
                 // Deal with returned error codes.
                 DisplayErrorMessage(nReturnCode = fError);
              else
              {
                 nTotalFiles++;

                 if (pLZI && pLZI->cblInSize && pLZI->cblOutSize) {

                    // Keep track of cumulative statistics.
                    cblTotInSize += pLZI->cblInSize;
                    cblTotOutSize += pLZI->cblOutSize;

                    // Display report for each file.
                    LoadString(NULL, SID_FILE_REPORT, ErrorMsg, 1024);
                    printf(ErrorMsg, pszInFileName, pLZI->cblInSize, pLZI->cblOutSize,
                       (INT)(100 - ((100 * (LONGLONG) pLZI->cblOutSize) / pLZI->cblInSize)));

                 }
                 else {
                    LoadString(NULL, SID_EMPTY_FILE_REPORT, ErrorMsg, 1024);
                    printf(ErrorMsg, pszInFileName, 0, 0);
                 }

              }
              // Separate individual file processing message blocks by a blank line.
              printf("\n");
          }

          // If we are processing a directive file, get the next arguments
          if ( NULL != pszFileList ) {
              if ( !GetNextFileListFile( pszFileList, &pszCurFile, &pszCurDestFile ) ) {
                  return (EXIT_FAILURE);
              }
          }

       } while ( NULL != pszFileList && NULL != pszCurFile );
   }

   // Free memory used by ring buffer and I/O buffers.
   FreeGlobalBuffers(pLZI);

   // Display cumulative report for multiple files.
   if (nTotalFiles > 1) {

      // Scale results to get accurate %
      LONG cblAdjInSize = cblTotInSize,
           cblAdjOutSize = cblTotOutSize;
      while (cblAdjInSize > 100000) {
        cblAdjInSize /= 2;
        cblAdjOutSize /= 2;
        }
      cblAdjOutSize += (cblAdjInSize / 200);    // round off (+0.5%)
      if (cblAdjOutSize < 0) {
        cblAdjOutSize = 0;
        }

      LoadString(NULL, SID_TOTAL_REPORT, ErrorMsg, 1024);
      printf(ErrorMsg, nTotalFiles, cblTotInSize, cblTotOutSize,
             (INT)(100 - 100 * cblAdjOutSize / cblAdjInSize));
   }

   return(nReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\compress\args.c ===
/*
** args.c - Command-line argument manipulation functions.
**
** Author:  DavidDi
**
** N.b., setargv.obj must be linked with this module for the command-line
** parsing to function properly.
*/


// Headers
///////////

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "lz_common.h"
#include "lz_header.h"

#include "args.h"
#include "main.h"
#include "messages.h"
#include <diamondc.h>
#include "mydiam.h"

extern BOOL PathType(LPSTR lpszFileString);   /* WIN32 MOD*/

// Globals
///////////

// All the globals defined in this module are set by ParseArguments().

BOOL bDoRename,      // flag for performing compressed file renaming
     bDisplayHelp,   // flag for displaying help information
     bTargetIsDir,   // flag telling whether or not files are being
                     // compressed to a directory
     bDirectives,    // One or more directive files on command-line
     bUpdateOnly,    // flag for conditional compression based on
                     // existing target file's date/time stamp relative
                     // to source file.
     bNoLogo;        // flag to suppress printing copyright information

INT nNumFileSpecs,   // number of non-switch, non-directory command-line
                     // arguments, assumed to be file specifications
    iTarget;         // argv[] index of target directory argument, or FAIL if
                     // none present

BYTE byteAlgorithm;  // compression / expansion algorithm to use
TCOMP DiamondCompressionType;  // 0 if not diamond (ie, LZ)


/*
** BOOL ParseArguments(int argc, char ARG_PTR *argv[]);
**
** Parse command-line arguments.
**
** Arguments:  like arguments to main()
**
** Returns:    TRUE if command-line arguments parsed successfully.  FALSE if
**             not.
**
** Globals:    All globals defined in this module are set in this function,
**             as described above.
*/


BOOL ParseArguments(INT argc, CHAR ARG_PTR *argv[])
{
   INT i;
   CHAR chSwitch;
   TCOMP Level;
   TCOMP Mem;
   CHAR *p;

   // Set up default values for globals.
   bDoRename = FALSE;
   bDisplayHelp = FALSE;
   bTargetIsDir = FALSE;
   bDirectives = FALSE;
   bNoLogo = FALSE;
   nNumFileSpecs = 0;
   iTarget = FAIL;
   byteAlgorithm = DEFAULT_ALG;
   DiamondCompressionType = 0;

   // Look at each command-line argument.
   for (i = 1; i < argc; i++)
      if (ISSWITCH(*(argv[i])))
      {
         // Get switch character.
         chSwitch = *(argv[i] + 1);

         //for bad DBCS argument
         if( IsDBCSLeadByte(chSwitch) )
         {
            CHAR work[3];
            lstrcpyn(work, argv[i] + 1, 3);
            LoadString(NULL, SID_BAD_SWITCH2, ErrorMsg, 1024);
            printf(ErrorMsg, work);
            return(FALSE);
         }

         // Classify switch.
         if (toupper(chSwitch) == toupper(chRENAME_SWITCH))
            bDoRename = TRUE;
         else if (toupper(chSwitch) == toupper(chHELP_SWITCH))
            bDisplayHelp = TRUE;
         else if (toupper(chSwitch) == toupper(chUPDATE_SWITCH))
            bUpdateOnly = TRUE;
         else if (toupper(chSwitch) == toupper(chNO_LOGO_SWITCH))
            bNoLogo= TRUE;
         else if (toupper(chSwitch) == toupper(chALG_SWITCH)) {

            switch(*(argv[i] + 2)) {

            case 'x':
            case 'X':
                //
                // LZX. Also set memory.
                //
                Mem = (TCOMP)atoi(argv[i] + 3);

                if((Mem < (tcompLZX_WINDOW_LO >> tcompSHIFT_LZX_WINDOW))
                || (Mem > (tcompLZX_WINDOW_HI >> tcompSHIFT_LZX_WINDOW))) {

                    Mem = (tcompLZX_WINDOW_LO >> tcompSHIFT_LZX_WINDOW);
                }

                byteAlgorithm = LZX_ALG;
                DiamondCompressionType = TCOMPfromLZXWindow( Mem );
                break;

            case 'q':
            case 'Q':
                //
                // Quantum. Also set level.
                //
                Level = (TCOMP)atoi(argv[i] + 3);
                Mem = (p = strchr(argv[i]+3,',')) ? (TCOMP)atoi(p+1) : 0;

                if((Level < (tcompQUANTUM_LEVEL_LO >> tcompSHIFT_QUANTUM_LEVEL))
                || (Level > (tcompQUANTUM_LEVEL_HI >> tcompSHIFT_QUANTUM_LEVEL))) {

                    Level = ((tcompQUANTUM_LEVEL_HI - tcompQUANTUM_LEVEL_LO) / 2)
                          + tcompQUANTUM_LEVEL_LO;

                    Level >>= tcompSHIFT_QUANTUM_LEVEL;
                }

                if((Mem < (tcompQUANTUM_MEM_LO >> tcompSHIFT_QUANTUM_MEM))
                || (Mem > (tcompQUANTUM_MEM_HI >> tcompSHIFT_QUANTUM_MEM))) {

                    Mem = ((tcompQUANTUM_MEM_HI - tcompQUANTUM_MEM_LO) / 2)
                        + tcompQUANTUM_MEM_LO;

                    Mem >>= tcompSHIFT_QUANTUM_MEM;
                }

                byteAlgorithm = QUANTUM_ALG;
                DiamondCompressionType = TCOMPfromTypeLevelMemory(
                                            tcompTYPE_QUANTUM,
                                            Level,
                                            Mem
                                            );
                break;

            case 'l':
            case 'L':
                DiamondCompressionType = 0;
                byteAlgorithm = DEFAULT_ALG;
                break;

            default:
                DiamondCompressionType = tcompTYPE_MSZIP;
                byteAlgorithm = MSZIP_ALG;
                break;
            }
         } else
         {
            // Unrecognized switch.
            LoadString(NULL, SID_BAD_SWITCH, ErrorMsg, 1024);
            printf(ErrorMsg, chSwitch);
            return(FALSE);
         }
      }
      else
      {
         // Keep track of last non-switch command-line argument as
         // destination argument.
         iTarget = i;

         // Determine if this is a directive file
         if ( '@' == argv[i][0] )
             bDirectives = TRUE;
         else if (IsDir((LPSTR)argv[i]) == FALSE)
            // Non-switch arguments are assumed to be file specifications.
            nNumFileSpecs++;
      }

   // Set bTargetIsDir.
   if (iTarget != FAIL)
      bTargetIsDir = IsDir((LPSTR)argv[iTarget]);

   // Command-line arguments parsed successsfully.
   return(TRUE);
}


/*
** BOOL CheckArguments(void);
**
** Check command-line arguments for error conditions.
**
** Arguments:  void
**
** Returns:    BOOL - TRUE if no problems found.  FALSE if problem found.
**
** Globals:    none
*/
BOOL CheckArguments(VOID)
{
   if (nNumFileSpecs < 1 && !bDirectives )
   {
      // No file specifications given.
      LoadString(NULL, SID_NO_FILE_SPECS, ErrorMsg, 1024);
      printf(ErrorMsg);
      return(FALSE);
   }
   else if (nNumFileSpecs == 1 && bDoRename == FALSE && bTargetIsDir == FALSE)
   {
      // We don't want to process a source file on to itself.
      LoadString(NULL, SID_NO_OVERWRITE, ErrorMsg, 1024);
      printf(ErrorMsg, pszTargetName);
      return(FALSE);
   }
   else if (nNumFileSpecs >  2 && bDoRename == FALSE && bTargetIsDir == FALSE)
   {
      // There are multiple files to process, and the destination
      // specification argument is not a directory.  But we weren't told to
      // rename the output files.  Bail out since we don't want to wipe out
      // the input files.
      LoadString(NULL, SID_NOT_A_DIR, ErrorMsg, 1024);
      printf(ErrorMsg, pszTargetName);
      return(FALSE);
   }
   else
      // No problems encountered.
      return(TRUE);
}


/*
** int GetNextFileArg(char ARG_PTR *argv[]);
**
** Find the next file name argument on the command-line.
**
** Arguments:  like argument to main()
**
** Returns:    int - Index in argv[] of next file name argument.  FAIL if
**                   none found.
**
** Globals:    none
*/
INT GetNextFileArg(CHAR ARG_PTR *argv[])
{
   INT i;
   static INT iLastArg = 0;

   for (i = iLastArg + 1; i <= iTarget; i++)
      if (! ISSWITCH(*(argv[i])) &&
          (i < iTarget || bTargetIsDir == FALSE)
          && (! IsDir((LPSTR)argv[i])))
         return(iLastArg = i);

   return(FAIL);
}

/* WIN32 MODS   */

/* returns 0 if not directory, 1 if so */
INT IsDir(LPSTR lpszTestString)
{

    BOOL bRetVal;

    bRetVal = PathType(lpszTestString);
	 if(bRetVal == 0){		/*assert*/
		bRetVal++;				/* this is because if lpszTestString file doesnt exist*/
									/* API returns 0, so I increment to 1, cause is NOT directory*/
    }
	 return(--bRetVal);       /* because returns 2 if dir, 1 if not*/

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\expand\mydiam.h ===
PTSTR
StringRevChar(
    IN PTSTR String,
    IN TCHAR Char
    );

BOOL
InitDiamond(
    VOID
    );

VOID
TermDiamond(
    VOID
    );

BOOL
IsDiamondFile(
    IN PSTR FileName,
    OUT PBOOL ContainsMultipleFiles
    );

INT
ExpandDiamondFile(
    IN  NOTIFYPROC ExpandNotify,
    IN  PSTR       SourceFileName,
    IN  PSTR       TargetFileName,
    IN  BOOL       RenameTarget,
    IN  PSTR       SelectiveFilesSpec,
    OUT PLZINFO    pLZI
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\expand\args.c ===
/*
** args.c - Command-line argument manipulation functions.
**
** Author:  DavidDi
**
** N.b., setargv.obj must be linked with this module for the command-line
** parsing to function properly.
*/


// Headers
///////////

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#include "lz_common.h"

#include "args.h"
#include "main.h"
#include "messages.h"

extern BOOL PathType(LPSTR lpszFileString);   /* WIN32 MOD*/

// Globals
///////////

// All the globals defined in this module are set by ParseArguments().

BOOL bDoRename,      // flag for performing compressed file renaming
     bDisplayHelp,   // flag for displaying help information
     bTargetIsDir;   // flag telling whether or not files are being
                     // compressed to a directory

INT nNumFileSpecs,   // number of non-switch, non-directory command-line
                     // arguments, assumed to be file specifications
    iTarget;         // argv[] index of target directory argument, or FAIL if
                     // none present

BOOL bDoListFiles;   // flag for displaying list of files from a CAB
                     // (instead of actually expanding them)
CHAR ARG_PTR *pszSelectiveFilesSpec; // name of file(s) to expand from a CAB


/*
** BOOL ParseArguments(int argc, char ARG_PTR *argv[]);
**
** Parse command-line arguments.
**
** Arguments:  like arguments to main()
**
** Returns:    TRUE if command-line arguments parsed successfully.  FALSE if
**             not.
**
** Globals:    All globals defined in this module are set in this function,
**             as described above.
*/

BOOL ParseArguments(INT argc, CHAR ARG_PTR *argv[])
{
   INT i;
   CHAR chSwitch;

   // Set up default values for globals.
   bDoRename = FALSE;
   bDisplayHelp = FALSE;
   bTargetIsDir = FALSE;
   nNumFileSpecs = 0;
   iTarget = FAIL;
   bDoListFiles = FALSE;
   pszSelectiveFilesSpec = NULL;

   // Look at each command-line argument.
   for (i = 1; i < argc; i++)
      if (ISSWITCH(*(argv[i])))
      {
         // Get switch character.
         chSwitch = *(argv[i] + 1);

         //for bad DBCS argument
         if( IsDBCSLeadByte(chSwitch) )
         {
            CHAR work[3];
            lstrcpyn(work, argv[i] + 1, 3);
            LoadString(NULL, SID_BAD_SWITCH2, ErrorMsg, 1024);
            printf(ErrorMsg, work);
            return(FALSE);
         }

         // Classify switch.
         if (toupper(chSwitch) == toupper(chRENAME_SWITCH))
            bDoRename = TRUE;
         else if (toupper(chSwitch) == toupper(chHELP_SWITCH))
            bDisplayHelp = TRUE;
         else if (toupper(chSwitch) == toupper(chLIST_SWITCH))
            bDoListFiles = bDoRename = TRUE;
         else if ((toupper(chSwitch) == toupper(chSELECTIVE_SWITCH)) &&
                  (argv[i][2] == ':') &&
                  (argv[i][3] != '\0') &&
                  (pszSelectiveFilesSpec == NULL))
            pszSelectiveFilesSpec = &argv[i][3];
         else
         {
            // Unrecognized switch.
	    LoadString(NULL, SID_BAD_SWITCH, ErrorMsg, 1024);
            // WARNING: Cannot call CharToOemW  with src=dest
            CharToOem(ErrorMsg, ErrorMsg);
            printf(ErrorMsg, chSwitch);
            return(FALSE);
         }
      }
      else
      {
         // Keep track of last non-switch command-line argument as
         // destination argument.
         iTarget = i;

         if (IsDir((LPSTR)argv[i]) == FALSE)
            // Non-switch arguments are assumed to be file specifications.
            nNumFileSpecs++;
      }

   // Set bTargetIsDir.
   if (iTarget != FAIL)
      bTargetIsDir = IsDir((LPSTR)argv[iTarget]);

   // Command-line arguments parsed successsfully.
   return(TRUE);
}



/*
** BOOL CheckArguments(void);
**
** Check command-line arguments for error conditions.
**
** Arguments:  void
**
** Returns:    BOOL - TRUE if no problems found.  FALSE if problem found.
**
** Globals:    none
*/
BOOL CheckArguments(VOID)
{
   if (nNumFileSpecs < 1)
   {
      // No file specifications given.
      LoadString(NULL, SID_NO_FILE_SPECS, ErrorMsg, 1024);
      // WARNING: Cannot call CharToOemW  with src=dest
      CharToOem(ErrorMsg, ErrorMsg);
      fputs(ErrorMsg, stdout);
      return(FALSE);
   }
   else if (nNumFileSpecs == 1 && bDoRename == FALSE && bTargetIsDir == FALSE && bDoListFiles == FALSE)
   {
      // We don't want to process a source file on to itself.
      LoadString(NULL, SID_NO_OVERWRITE, ErrorMsg, 1024);
      // WARNING: Cannot call CharToOemW  with src=dest
      CharToOem(ErrorMsg, ErrorMsg);
      printf(ErrorMsg, pszTargetName);
      return(FALSE);
   }
   else if (nNumFileSpecs >  2 && bDoRename == FALSE && bTargetIsDir == FALSE && bDoListFiles == FALSE)
   {
      // There are multiple files to process, and the destination
      // specification argument is not a directory.  But we weren't told to
      // rename the output files.  Bail out since we don't want to wipe out
      // the input files.
      LoadString(NULL, SID_NOT_A_DIR, ErrorMsg, 1024);
      // WARNING: Cannot call CharToOemW  with src=dest
      CharToOem(ErrorMsg, ErrorMsg);
      printf(ErrorMsg, pszTargetName);
      return(FALSE);
   }
   else if (bDoListFiles && bTargetIsDir == TRUE)
   {
      // Requested only a listing of the files from the source CAB, but then
      // supplied a destination directory.  There is no destination when we're
      // only displaying names.  Bail out because he must be confused.
      LoadString(NULL, SID_UNEXP_TARGET, ErrorMsg, 1024);
      // WARNING: Cannot call CharToOemW  with src=dest
      CharToOem(ErrorMsg, ErrorMsg);
      printf(ErrorMsg, pszTargetName);
      return(FALSE);
   }
   else
      // No problems encountered.
      return(TRUE);
}


/*
** int GetNextFileArg(char ARG_PTR *argv[]);
**
** Find the next file name argument on the command-line.
**
** Arguments:  like argument to main()
**
** Returns:    int - Index in argv[] of next file name argument.  FAIL if
**                   none found.
**
** Globals:    none
*/
INT GetNextFileArg(CHAR ARG_PTR *argv[])
{
   INT i;
   static INT iLastArg = 0;

   for (i = iLastArg + 1; i <= iTarget; i++)
      if (! ISSWITCH(*(argv[i])) &&
          (i < iTarget || bTargetIsDir == FALSE)
          && (! IsDir((LPSTR)argv[i])))
         return(iLastArg = i);

   return(FAIL);
}

/* WIN32 MODS   */

/* returns 0 if not directory, 1 if so */
INT IsDir(LPSTR lpszTestString)
{

    BOOL bRetVal;

    bRetVal = PathType(lpszTestString);
	 if(bRetVal == 0){		/*assert*/
		bRetVal++;				/* this is because if lpszTestString file doesnt exist*/
									/* API returns 0, so I increment to 1, cause is NOT directory*/  
    }              
	 return(--bRetVal);       /* because returns 2 if dir, 1 if not*/    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\expand\diamond.c ===
#include <windows.h>
#include <fcntl.h>

//
// lz headers
//
#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"

//
// diamond headers
//
#include <diamondd.h>
#include "mydiam.h"


HFDI FdiContext;
ERF FdiError;

INT DiamondLastIoError;

BOOL
PatternMatch(
    IN PCSTR pszString,
    IN PCSTR pszPattern,
    IN BOOL fImplyDotAtEnd
    );

INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    );

int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    );

typedef struct _DIAMOND_INFO {

    //
    // A read handle to the source file.
    //
    INT_PTR SourceFileHandle;

    //
    // File names.
    //
    PSTR SourceFileName;
    PSTR TargetFileName;

    //
    // Flag indicating whether to rename the target file.
    //
    BOOL RenameTargetFile;

    //
    // Pointer to LZ information structure.
    // We'll fill in some of the fields to fool expand.
    //
    PLZINFO pLZI;

    //
    // Expand callback/notification.
    //
    NOTIFYPROC ExpandNotify;

    //
    // Selective extraction file spec, ie, "aic*.sys" or NULL
    //
    PSTR SelectiveFilesSpec;

} DIAMOND_INFO, *PDIAMOND_INFO;


PTSTR
StringRevChar(
    IN PTSTR String,
    IN TCHAR Char
    )
{
    //
    // Although not the most efficient possible algoeithm in each case,
    // this algorithm is correct for unicode, sbcs, or dbcs.
    //
    PTCHAR Occurrence,Next;

    //
    // Check each character in the string and remember
    // the most recently encountered occurrence of the desired char.
    //
    for(Occurrence=NULL,Next=CharNext(String); *String; ) {

        if(!memcmp(String,&Char,(int)((PUCHAR)Next-(PUCHAR)String))) {
            Occurrence = String;
        }

        String = Next;
        Next = CharNext(Next);
    }

    //
    // Return address of final occurrence of the character
    // (will be NULL if not found at all).
    //
    return(Occurrence);
}


#define WILDCARD    '*'     /* zero or more of any character */
#define WILDCHAR    '?'     /* one of any character (does not match END) */
#define END         '\0'    /* terminal character */
#define DOT         '.'     /* may be implied at end ("hosts" matches "*.") */


static int __inline Lower(c)
{
    if ((c >= 'A') && (c <= 'Z'))
    {
        return(c + ('a' - 'A'));
    }
    else
    {
        return(c);
    }
}


static int __inline CharacterMatch(char chCharacter, char chPattern)
{
    if (Lower(chCharacter) == Lower(chPattern))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


BOOL
PatternMatch(
    PCSTR pszString,
    PCSTR pszPattern,
    IN BOOL fImplyDotAtEnd
    )
{
    /* RECURSIVE */

    //
    //  This function does not deal with 8.3 conventions which might
    //  be expected for filename comparisons.  (In an 8.3 environment,
    //  "alongfilename.html" would match "alongfil.htm")
    //
    //  This code is NOT MBCS-enabled
    //

    for ( ; ; )
    {
        switch (*pszPattern)
        {

        case END:

            //
            //  Reached end of pattern, so we're done.  Matched if
            //  end of string, no match if more string remains.
            //

            return(*pszString == END);

        case WILDCHAR:

            //
            //  Next in pattern is a wild character, which matches
            //  anything except end of string.  If we reach the end
            //  of the string, the implied DOT would also match.
            //

            if (*pszString == END)
            {
                if (fImplyDotAtEnd == TRUE)
                {
                    fImplyDotAtEnd = FALSE;
                }
                else
                {
                    return(FALSE);
                }
            }
            else
            {
                pszString++;
            }

            pszPattern++;

            break;

        case WILDCARD:

            //
            //  Next in pattern is a wildcard, which matches anything.
            //  Find the required character that follows the wildcard,
            //  and search the string for it.  At each occurence of the
            //  required character, try to match the remaining pattern.
            //
            //  There are numerous equivalent patterns in which multiple
            //  WILDCARD and WILDCHAR are adjacent.  We deal with these
            //  before our search for the required character.
            //
            //  Each WILDCHAR burns one non-END from the string.  An END
            //  means we have a match.  Additional WILDCARDs are ignored.
            //

            for ( ; ; )
            {
                pszPattern++;

                if (*pszPattern == END)
                {
                    return(TRUE);
                }
                else if (*pszPattern == WILDCHAR)
                {
                    if (*pszString == END)
                    {
                        if (fImplyDotAtEnd == TRUE)
                        {
                            fImplyDotAtEnd = FALSE;
                        }
                        else
                        {
                            return(FALSE);
                        }
                    }
                    else
                    {
                        pszString++;
                    }
                }
                else if (*pszPattern != WILDCARD)
                {
                    break;
                }
            }

            //
            //  Now we have a regular character to search the string for.
            //

            while (*pszString != END)
            {
                //
                //  For each match, use recursion to see if the remainder
                //  of the pattern accepts the remainder of the string.
                //  If it does not, continue looking for other matches.
                //

                if (CharacterMatch(*pszString, *pszPattern) == TRUE)
                {
                    if (PatternMatch(pszString + 1, pszPattern + 1, fImplyDotAtEnd) == TRUE)
                    {
                        return(TRUE);
                    }
                }

                pszString++;
            }

            //
            //  Reached end of string without finding required character
            //  which followed the WILDCARD.  If the required character
            //  is a DOT, consider matching the implied DOT.
            //
            //  Since the remaining string is empty, the only pattern which
            //  could match after the DOT would be zero or more WILDCARDs,
            //  so don't bother with recursion.
            //

            if ((*pszPattern == DOT) && (fImplyDotAtEnd == TRUE))
            {
                pszPattern++;

                while (*pszPattern != END)
                {
                    if (*pszPattern != WILDCARD)
                    {
                        return(FALSE);
                    }

                    pszPattern++;
                }

                return(TRUE);
            }

            //
            //  Reached end of the string without finding required character.
            //

            return(FALSE);
            break;

        default:

            //
            //  Nothing special about the pattern character, so it
            //  must match source character.
            //

            if (CharacterMatch(*pszString, *pszPattern) == FALSE)
            {
                if ((*pszPattern == DOT) &&
                    (*pszString == END) &&
                    (fImplyDotAtEnd == TRUE))
                {
                    fImplyDotAtEnd = FALSE;
                }
                else
                {
                    return(FALSE);
                }
            }

            if (*pszString != END)
            {
                pszString++;
            }

            pszPattern++;
        }
    }
}


INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    switch(Operation) {

    case fdintCABINET_INFO:
    case fdintPARTIAL_FILE:
    default:

        //
        // Cabinet management functions which we don't use.
        // Return success.
        //
        return(0);

    case fdintNEXT_CABINET:
        return (-1);        // We don't support multiple cabinets.

    case fdintCOPY_FILE:

        //
        // Diamond is asking us whether we want to copy the file.
        //
        {
            PDIAMOND_INFO Info = (PDIAMOND_INFO)Parameters->pv;
            HFILE h;

            //
            // If we were given a filespec, see if the name matches.
            //

            if (Info->SelectiveFilesSpec != NULL) {

                //
                //  Call PatternMatch(), fAllowImpliedDot TRUE if
                //  there is no '.' in the file's base name.
                //

                BOOL fAllowImpliedDot = TRUE;
                PSTR p;

                for (p = Parameters->psz1; *p != '\0'; p++) {
                    if (*p == '.') {
                        fAllowImpliedDot = FALSE;
                    } else if (*p == '\\') {
                        fAllowImpliedDot = TRUE;
                    }
                }
                
                if (PatternMatch(
                        Parameters->psz1,
                        Info->SelectiveFilesSpec,
                        fAllowImpliedDot) == FALSE) {

                    return(0);     // skip this file
                }
            }

            //
            // If we need to rename the target file, do that here.
            // The name stored in the cabinet file will be used as
            // the uncompressed name.
            //
            if(Info->RenameTargetFile) {

                PSTR p,q;

                //
                // Find the start of the filename part of the target.
                //
                if(p = StringRevChar(Info->TargetFileName,'\\')) {
                    p++;
                } else {
                    p = Info->TargetFileName;
                }

                //
                // Find the start of the filename part of the name in the cabinet.
                //
                if(q = StringRevChar(Parameters->psz1,'\\')) {
                    q++;
                } else {
                    q = Parameters->psz1;
                }

                //
                // Copy the filename part of the name in the cabinet over
                // the filename part of the name in the target spec.
                //
                lstrcpy(p,q);
            }

            //
            // Inform the expand callback what we are doing.
            //
            if(!Info->ExpandNotify(Info->SourceFileName,Info->TargetFileName,NOTIFY_START_EXPAND)) {
                return(0);  // skip this file.
            }

            //
            // Remember the uncompressed size and open the file.
            // Returns -1 if an error occurs opening the file.
            //
            Info->pLZI->cblOutSize += Parameters->cb;
            h = _lcreat(Info->TargetFileName,0);
            if(h == HFILE_ERROR) {
                DiamondLastIoError = LZERROR_BADOUTHANDLE;
                return(-1);
            }
            return(h);
        }

    case fdintCLOSE_FILE_INFO:

        //
        // Diamond is done with the target file and wants us to close it.
        // (ie, this is the counterpart to fdint_COPY_FILE).
        //
        {
            PDIAMOND_INFO Info = (PDIAMOND_INFO)Parameters->pv;
            HANDLE TargetFileHandle;
            FILETIME ftLocal, ftUTC;

            _lclose((HFILE)Parameters->hf);

            //
            // Set the target file's date/time stamp from the value inside
            // the CAB.
            //
            TargetFileHandle = CreateFile(Info->TargetFileName,
					   GENERIC_READ | GENERIC_WRITE,
					   0,
					   NULL,
					   OPEN_EXISTING,
					   0,
					   NULL);

            if (TargetFileHandle != INVALID_HANDLE_VALUE)
            {
                if (DosDateTimeToFileTime(Parameters->date, Parameters->time, &ftLocal) &&
                    LocalFileTimeToFileTime(&ftLocal, &ftUTC))
                {
                    SetFileTime(TargetFileHandle, NULL, NULL, &ftUTC);
                }

                CloseHandle(TargetFileHandle);
            }
        }
        return(TRUE);    

    }

}



PVOID
DIAMONDAPI
SpdFdiAlloc(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by FDICopy to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return((PVOID)LocalAlloc(LMEM_FIXED,NumberOfBytes));
}


VOID
DIAMONDAPI
SpdFdiFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by FDICopy to free a memory block.
    The block must have been allocated with SpdFdiAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    LocalFree((HLOCAL)Block);
}


INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )

/*++

Routine Description:

    Callback used by FDICopy to open files.

Arguments:

    FileName - supplies name of file to be opened.

    oflag - supplies flags for open.

    pmode - supplies additional flags for open.

Return Value:

    Handle to open file or -1 if error occurs.

--*/

{
    HFILE h;
    int OpenMode;

    if(oflag & _O_WRONLY) {
        OpenMode = OF_WRITE;
    } else {
        if(oflag & _O_RDWR) {
            OpenMode = OF_READWRITE;
        } else {
            OpenMode = OF_READ;
        }
    }

    h = _lopen(FileName,OpenMode | OF_SHARE_DENY_WRITE);

    if(h == HFILE_ERROR) {
        DiamondLastIoError = LZERROR_BADINHANDLE;
        return(-1);
    }

    return((INT_PTR)h);
}


UINT
DIAMONDAPI
SpdFdiRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to read from a file.

Arguments:

    Handle - supplies handle to open file to be read from.

    pv - supplies pointer to buffer to receive bytes we read.

    ByteCount - supplies number of bytes to read.

Return Value:

    Number of bytes read (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;

    rc = _lread((HFILE)Handle,pv,ByteCount);

    if(rc == HFILE_ERROR) {
        rc = (UINT)(-1);
        DiamondLastIoError = LZERROR_READ;
    }

    return(rc);
}


UINT
DIAMONDAPI
SpdFdiWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to write to a file.

Arguments:

    Handle - supplies handle to open file to be written to.

    pv - supplies pointer to buffer containing bytes to write.

    ByteCount - supplies number of bytes to write.

Return Value:

    Number of bytes written (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;

    rc = _lwrite((HFILE)Handle,pv,ByteCount);

    if(rc == HFILE_ERROR) {

        DiamondLastIoError = (GetLastError() == ERROR_DISK_FULL) ? LZERROR_WRITE : LZERROR_BADOUTHANDLE;

    } else {

        if(rc != ByteCount) {
            //
            // let caller interpret return value but record last error just in case
            //
            DiamondLastIoError = LZERROR_WRITE;
        }
    }

    return(rc);
}


int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    )

/*++

Routine Description:

    Callback used by FDICopy to close files.

Arguments:

    Handle - handle of file to close.

Return Value:

    0 (success).

--*/

{
    _lclose((HFILE)Handle);
    return(0);
}


LONG
DIAMONDAPI
SpdFdiSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    )

/*++

Routine Description:

    Callback used by FDICopy to seek files.

Arguments:

    Handle - handle of file to close.

    Distance - supplies distance to seek. Interpretation of this
        parameter depends on the value of SeekType.

    SeekType - supplies a value indicating how Distance is to be
        interpreted; one of SEEK_SET, SEEK_CUR, SEEK_END.

Return Value:

    New file offset or -1 if an error occurs.

--*/

{
    LONG rc;

    rc = _llseek((HFILE)Handle,Distance,SeekType);

    if(rc == HFILE_ERROR) {
        DiamondLastIoError = LZERROR_BADINHANDLE;
        rc = -1L;
    }

    return(rc);
}


INT
ExpandDiamondFile(
    IN  NOTIFYPROC ExpandNotify,
    IN  PSTR       SourceFileName,
    IN  PSTR       TargetFileName,
    IN  BOOL       RenameTarget,
    IN  PSTR       SelectiveFilesSpec,
    OUT PLZINFO    pLZI
    )
{
    BOOL b;
    INT rc;
    INT_PTR h;
    DIAMOND_INFO DiamondInfo;

    if(!FdiContext) {
        return(LZERROR_BADVALUE);
    }

    DiamondLastIoError = TRUE;

    //
    // Get a handle to the source to use to
    // copy the date and time stamp.
    //
    h = SpdFdiOpen(SourceFileName,_O_RDONLY,0);
    if(h == -1) {
        return(LZERROR_BADINHANDLE);
    }

    pLZI->cblInSize = GetFileSize((HANDLE)h,NULL);
    if(pLZI->cblInSize == -1) {
        SpdFdiClose(h);
        return(LZERROR_BADINHANDLE);
    }

    DiamondInfo.SourceFileHandle = h;
    DiamondInfo.SourceFileName = SourceFileName;
    DiamondInfo.TargetFileName = TargetFileName;
    DiamondInfo.RenameTargetFile = RenameTarget;
    DiamondInfo.ExpandNotify = ExpandNotify;
    DiamondInfo.SelectiveFilesSpec = SelectiveFilesSpec;
    DiamondInfo.pLZI = pLZI;

    b = FDICopy(
            FdiContext,
            SourceFileName,             // pass the whole path as the name
            "",                         // don't bother with the path part
            0,                          // flags
            DiamondNotifyFunction,
            NULL,                       // no decryption
            &DiamondInfo
            );

    if(b) {

        rc = TRUE;

    } else {

        switch(FdiError.erfOper) {

        case FDIERROR_CORRUPT_CABINET:
        case FDIERROR_UNKNOWN_CABINET_VERSION:
        case FDIERROR_BAD_COMPR_TYPE:
            rc = LZERROR_READ;              // causes SID_FORMAT_ERROR message
            break;

        case FDIERROR_ALLOC_FAIL:
            rc = LZERROR_GLOBALLOC;
            break;

        case FDIERROR_TARGET_FILE:
        case FDIERROR_USER_ABORT:
            rc = DiamondLastIoError;
            break;

        default:
            //
            // The rest of the errors are not handled specially.
            //
            rc = LZERROR_BADVALUE;
            break;
        }

        //
        // Remove the partial target file.
        //
        DeleteFile(TargetFileName);
    }

    SpdFdiClose(h);

    return(rc);
}


BOOL
IsDiamondFile(
    IN PSTR FileName,
    OUT PBOOL ContainsMultipleFiles
    )
{
    FDICABINETINFO CabinetInfo;
    BOOL b;
    INT_PTR h;

    *ContainsMultipleFiles = FALSE;

    if(!FdiContext) {
        return(FALSE);
    }

    //
    // Open the file such that the handle is valid for use
    // in the diamond context (ie, seek, read routines above).
    //
    h = SpdFdiOpen(FileName,_O_RDONLY,0);
    if(h == -1) {
        return(FALSE);
    }

    b = FDIIsCabinet(FdiContext,h,&CabinetInfo);

    SpdFdiClose(h);

    if (b && (CabinetInfo.cFiles > 1)) {
        *ContainsMultipleFiles = TRUE;
    }

    return(b);
}


BOOL
InitDiamond(
    VOID
    )
{
    if(FdiContext == NULL) {

        FdiContext = FDICreate(
                        SpdFdiAlloc,
                        SpdFdiFree,
                        SpdFdiOpen,
                        SpdFdiRead,
                        SpdFdiWrite,
                        SpdFdiClose,
                        SpdFdiSeek,
                        cpuUNKNOWN,
                        &FdiError
                        );
    }

    return(FdiContext != NULL);
}


VOID
TermDiamond(
    VOID
    )
{
    if(FdiContext) {
        FDIDestroy(FdiContext);
        FdiContext = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\compress\mydiam.h ===
INT
DiamondCompressFile(
    IN  NOTIFYPROC CompressNotify,
    IN  PSTR       SourceFile,
    IN  PSTR       TargetFile,
    IN  BOOL       Rename,
    OUT PLZINFO    pLZI
    );

extern TCOMP DiamondCompressionType;  // 0 if not diamond (ie, LZ)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\buffers.c ===
/*
** buffers.c - Routines dealing with I/O and expansion buffers for LZCopy()
**             and DOS command-line programs.
**
** Author:  DavidDi
*/


// Headers
///////////

#ifndef LZA_DLL

#include <dos.h>
#include <fcntl.h>

#endif

#include "lz_common.h"
#include "lz_buffers.h"

/*
** int ReadInBuf(BYTE ARG_PTR *pbyte, int doshSource);
**
** Read input file into input buffer.
**
** Arguments:  pbyte      - pointer to storage for first byte read from file
**                          into buffer
**             doshSource - DOS file handle to open input file
**
** Returns:    int - TRUE or END_OF_INPUT if successful.  LZERROR_BADINHANDLE
**                   if not.
**
** Globals:    rgbyteInBuf[0] - holds last byte from previous buffer
**             pbyteInBufEnd  - set to point to first byte beyond end of data
**                              in input buffer
**             bLastUsed      - reset to FALSE if currently TRUE
*/
INT ReadInBuf(BYTE ARG_PTR *pbyte, INT doshSource, PLZINFO pLZI)
{
   DWORD ucbRead;          // number of bytes actually read

   // !!! Assumes pLZI parm is valid.  No sanity check (should be done above in caller).

   pLZI->rgbyteInBuf[0] = *(pLZI->pbyteInBufEnd - 1);

   if ((ucbRead = FREAD(doshSource, &pLZI->rgbyteInBuf[1], pLZI->ucbInBufLen))
       != pLZI->ucbInBufLen)
   {
#ifdef LZA_DLL
      if (ucbRead == (DWORD)(-1)) {
#else
      if (_error != 0U) {
#endif
         // We were handed a bad input file handle.
         return(LZERROR_BADINHANDLE);
      }
      else if (ucbRead > 0U)
         // Read last ucbRead bytes of input file.  Change input buffer end
         // to account for shorter read.
         pLZI->pbyteInBufEnd = &pLZI->rgbyteInBuf[1] + ucbRead;
      else  { // (ucbRead == 0U) {
         // We couldn't read any bytes from input file (EOF reached).
         return(END_OF_INPUT);
      }
   }

   // Reset read pointer to beginning of input buffer.
   pLZI->pbyteInBuf = &pLZI->rgbyteInBuf[1];

   // Was an UnreadByte() done at the beginning of the last buffer?
   if (pLZI->bLastUsed)
   {
      // Return the last byte from the previous input buffer
      *pbyte = pLZI->rgbyteInBuf[0];
      pLZI->bLastUsed = FALSE;
   }
   else
      // Return the first byte from the new input buffer.
      *pbyte = *pLZI->pbyteInBuf++;

   return(TRUE);
}


/*
** int WriteOutBuf(BYTE byteNext, int doshDest);
**
** Dumps output buffer to output file.  Prompts for new floppy disk if the
** old one if full.  Continues dumping to output file of same name on new
** floppy disk.
**
** Arguments:  byteNext - first byte to be added to empty buffer after buffer
**                        is written
**             doshDest - output DOS file handle
**
** Returns:    int - TRUE if successful.  LZERROR_BADOUTHANDLE or
**                   LZERROR_WRITE if unsuccessful.
**
** Globals:    pbyteOutBuf - reset to point to free byte after byteNext in
**                           rgbyteOutBuf
*/
INT WriteOutBuf(BYTE byteNext, INT doshDest, PLZINFO pLZI)
{
   DWORD ucbToWrite,       // number of bytes to write from buffer
            ucbWritten,       // number of bytes actually written
            ucbTotWritten;    // total number of bytes written to output

   // !!! Assumes pLZI parm is valid.  No sanity check (should be done above in caller).

   // How much of the buffer should be written to the output file?
   ucbTotWritten = ucbToWrite = (DWORD)(pLZI->pbyteOutBuf - pLZI->rgbyteOutBuf);
   // Reset pointer to beginning of buffer.
   pLZI->pbyteOutBuf = pLZI->rgbyteOutBuf;

   // Write to ouput file.
   if (doshDest != NO_DOSH &&
       (ucbWritten = FWRITE(doshDest, pLZI->pbyteOutBuf, ucbToWrite)) != ucbToWrite)
   {
#ifdef LZA_DLL
      if (ucbWritten == (DWORD)(-1)) {
#else
      if (_error != 0U) {
#endif
         // Bad DOS file handle.
         return(LZERROR_BADOUTHANDLE);
      }
      else {
         // Insufficient space on destination drive.
         return(LZERROR_WRITE);
      }
   }

   // Add the next byte to the buffer.
   *pLZI->pbyteOutBuf++ = byteNext;

   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\compress\diamond.c ===
/*++

Module Name:

    diamond.c

Abstract:

    Diamond compression interface.

    This module contains functions to compress a file using
    the mszip compression library.

Author:

    Ted Miller

Environment:

    Windows

--*/


#include <windows.h>
#include <stdio.h>

#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"

#include <io.h>
#include <fcntl.h>
#include <errno.h>

#include "main.h"
#include <diamondc.h>
#include "mydiam.h"


typedef struct _DIAMOND_INFO {
    DWORD SourceFileSize;
    DWORD CompressedSize;
    FILETIME SourceFileCreationTime;
    FILETIME SourceFileModifiedTime;
    FILETIME SourceFileAccessedTime;
} DIAMOND_INFO, *PDIAMOND_INFO;

//
// Callback functions to perform memory allocation, io, etc.
// We pass addresses of these functions to diamond.
//
int
DIAMONDAPI
fciFilePlacedCB(
    OUT PCCAB Cabinet,
    IN  PSTR  FileName,
    IN  LONG  FileSize,
    IN  BOOL  Continuation,
    IN  PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to indicate that a file has been
    comitted to a cabinet.

    No action is taken and success is returned.

Arguments:

    Cabinet - cabinet structure to fill in.

    FileName - name of file in cabinet

    FileSize - size of file in cabinet

    Continuation - TRUE if this is a partial file, continuation
        of compression begun in a different cabinet.

    Context - supplies context information.

Return Value:

    0 (success).

--*/

{
    UNREFERENCED_PARAMETER(Cabinet);
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(FileSize);
    UNREFERENCED_PARAMETER(Continuation);
    UNREFERENCED_PARAMETER(Context);

    return(0);
}



PVOID
DIAMONDAPI
fciAllocCB(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by diamond to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return((PVOID)LocalAlloc(LMEM_FIXED,NumberOfBytes));
}


VOID
DIAMONDAPI
fciFreeCB(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by diamond to free a memory block.
    The block must have been allocated with fciAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    LocalFree((HLOCAL)Block);
}



FNFCIGETTEMPFILE(fciTempFileCB)
{
    CHAR TempPath[MAX_PATH];
    DWORD cchTemp;

    cchTemp = GetTempPath(sizeof(TempPath), TempPath);
    if ((cchTemp == 0) || (cchTemp >= sizeof(TempPath))) {
        TempPath[0] = '.';
        TempPath[1] = '\0';
    }

    if(GetTempFileNameA(TempPath,"dc",0,pszTempName)) {
        DeleteFileA(pszTempName);
    }

    return(TRUE);
}


BOOL
DIAMONDAPI
fciNextCabinetCB(
    OUT PCCAB Cabinet,
    IN  DWORD CabinetSizeEstimate,
    IN  PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to request a new cabinet file.
    This functionality is not used in our implementation as
    we deal only with single-file cabinets.

Arguments:

    Cabinet - cabinet structure to be filled in.

    CabinetSizeEstimate - estimated size of cabinet.

    Context - supplies context information.

Return Value:

    FALSE (failure).

--*/

{
    UNREFERENCED_PARAMETER(Cabinet);
    UNREFERENCED_PARAMETER(CabinetSizeEstimate);
    UNREFERENCED_PARAMETER(Context);

    return(FALSE);
}


BOOL
DIAMONDAPI
fciStatusCB(
    IN UINT  StatusType,
    IN DWORD Count1,
    IN DWORD Count2,
    IN PVOID Context
    )

/*++

Routine Description:

    Callback used by diamond to give status on file compression
    and cabinet operations, etc.

Arguments:

    Status Type - supplies status type.

        0 = statusFile   - compressing block into a folder.
                              Count1 = compressed size
                              Count2 = uncompressed size

        1 = statusFolder - performing AddFilder.
                              Count1 = bytes done
                              Count2 = total bytes

    Context - supplies context info.

Return Value:

    TRUE (success).

--*/

{
    PDIAMOND_INFO context;

    UNREFERENCED_PARAMETER(Count2);

    context = (PDIAMOND_INFO)Context;

    if(StatusType == statusFile) {

        //
        // Track compressed size.
        //
        context->CompressedSize += Count1;
    }

    return(TRUE);
}



FNFCIGETOPENINFO(fciOpenInfoCB)
{
    int h;
    WIN32_FIND_DATAA FindData;
    HANDLE FindHandle;
    PDIAMOND_INFO context;
    FILETIME ftLocal;

    context = pv;

    FindHandle = FindFirstFileA(pszName,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        return(-1);
    }
    FindClose(FindHandle);

    context->SourceFileSize = FindData.nFileSizeLow;
    context->SourceFileCreationTime = FindData.ftCreationTime;
    context->SourceFileModifiedTime = FindData.ftLastWriteTime;
    context->SourceFileAccessedTime = FindData.ftLastAccessTime;

    FileTimeToLocalFileTime(&FindData.ftLastWriteTime, &ftLocal);
    FileTimeToDosDateTime(&ftLocal, pdate, ptime);
    *pattribs = (WORD)(FindData.dwFileAttributes &
            ( FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN |
              FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE ));

    h = _open(pszName,_O_RDONLY | _O_BINARY);
    if(h == -1) {
        return(-1);
    }

    return(h);
}


FNFCIOPEN(fciOpen)
{
    int result;

    result = _open(pszFile, oflag, pmode);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}

FNFCIREAD(fciRead)
{
    UINT result;

    result = (UINT) _read((HFILE)hf, memory, cb);

    if (result != cb) {
        *err = errno;
    }

    return(result);
}

FNFCIWRITE(fciWrite)
{
    UINT result;

    result = (UINT) _write((HFILE)hf, memory, cb);

    if (result != cb) {
        *err = errno;
    }

    return(result);
}

FNFCICLOSE(fciClose)
{
    int result;

    result = _close((HFILE)hf);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}

FNFCISEEK(fciSeek)
{
    long result;

    result = _lseek((HFILE)hf, dist, seektype);

    if (result == -1) {
        *err = errno;
    }

    return(result);

}

FNFCIDELETE(fciDelete)
{
    int result;

    result = _unlink(pszFile);

    if (result == -1) {
        *err = errno;
    }

    return(result);
}


INT
DiamondCompressFile(
    IN  NOTIFYPROC CompressNotify,
    IN  PSTR       SourceFile,
    IN  PSTR       TargetFile,
    IN  BOOL       Rename,
    OUT PLZINFO    pLZI
    )
{
    BOOL b;
    PSTR SourceFilenamePart,p;
    HFCI FciContext;
    ERF  FciError;
    CCAB ccab;
    CHAR targetFile[MAX_PATH];
    DIAMOND_INFO Context;
    INT Status;

    __try {

        //
        // Isolate the filename part of the source file.
        //
        if(SourceFilenamePart = strrchr(SourceFile,'\\')) {
            SourceFilenamePart++;
        } else {
            SourceFilenamePart = SourceFile;
        }
    
        //
        // Form the actual name of the target file.
        //
        lstrcpy(targetFile,TargetFile);
        if(Rename) {
            MakeCompressedName(targetFile);
        }
    
        //
        // Fill in the cabinet structure.
        //
        ZeroMemory(&ccab,sizeof(ccab));
    
        lstrcpyA(ccab.szCabPath,targetFile);
        if(p=strrchr(ccab.szCabPath,'\\')) {
            lstrcpyA(ccab.szCab,++p);
            *p = 0;
        } else {
            lstrcpyA(ccab.szCab,targetFile);
            ccab.szCabPath[0] = 0;
        }
    
        //
        // Call the notification function to see whether we are really
        // supposed to compress this file.
        //
        if(!CompressNotify(SourceFile,targetFile,NOTIFY_START_COMPRESS)) {
            Status = BLANK_ERROR;
            __leave;
        }
    
        ZeroMemory(&Context,sizeof(Context));
    
        //
        // Compress the file.
        //
        FciContext = FCICreate(
                        &FciError,
                        fciFilePlacedCB,
                        fciAllocCB,
                        fciFreeCB,
                        fciOpen,
                        fciRead,
                        fciWrite,
                        fciClose,
                        fciSeek,
                        fciDelete,
                        fciTempFileCB,
                        &ccab,
                        &Context
                        );
    
        if(FciContext) {
    
            b = FCIAddFile(
                    FciContext,
                    SourceFile,         // file to add to cabinet.
                    SourceFilenamePart, // filename part, name to store in cabinet.
                    FALSE,
                    fciNextCabinetCB,   // routine for next cabinet (always fails)
                    fciStatusCB,
                    fciOpenInfoCB,
                    DiamondCompressionType
                    );
    
            if(b) {
    
                b = FCIFlushCabinet(
                        FciContext,
                        FALSE,
                        fciNextCabinetCB,
                        fciStatusCB
                        );
    
                if(b) {
    
                    HANDLE FindHandle;
                    WIN32_FIND_DATA FindData;
    
                    //
                    // Context.CompressedSize does not include headers
                    // and any other file overhead.
                    //
                    FindHandle = FindFirstFile(targetFile,&FindData);
                    if(FindHandle == INVALID_HANDLE_VALUE) {
                        pLZI->cblOutSize = (LONG)Context.CompressedSize;
                    } else {
                        pLZI->cblOutSize = (LONG)FindData.nFileSizeLow;
                        FindClose(FindHandle);
                    }
    
                    pLZI->cblInSize = (LONG)Context.SourceFileSize;
    
                    FindHandle = CreateFile(targetFile,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
                    if (FindHandle != INVALID_HANDLE_VALUE)
                    {
                        SetFileTime(FindHandle,
                            &Context.SourceFileCreationTime,
                            &Context.SourceFileAccessedTime,
                            &Context.SourceFileModifiedTime);
    
                        CloseHandle(FindHandle);
                    }
                }
            }
    
            if(b) {
                Status = TRUE;
            } else {
    
                switch(FciError.erfOper) {
    
                case FCIERR_OPEN_SRC:
                    Status = LZERROR_BADINHANDLE;
                    break;
    
                case FCIERR_READ_SRC:
                    Status = LZERROR_READ;
                    break;
    
                case FCIERR_CAB_FILE:
                    Status = LZERROR_WRITE;
                    break;
    
                case FCIERR_ALLOC_FAIL:
                    Status = LZERROR_GLOBALLOC;
                    break;
    
                case FCIERR_TEMP_FILE:
                case FCIERR_BAD_COMPR_TYPE:
                case FCIERR_USER_ABORT:
                case FCIERR_MCI_FAIL:
                default:
                    Status = FALSE;
                }
            }
    
            FCIDestroy(FciContext);
        } else {
            Status = LZERROR_GLOBALLOC;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
          Status = GetLastError();
    }


    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\tools\expand\expand.c ===
/*
** main.c - Main module for DOS command-line LZA file compression / expansion
**          programs.
**
** Author: DavidDi
**
** This module is compiled twice - once for COMPRESS (COMPRESS defined) and
** once for EXPAND (COMPRESS not defined).
*/


// Headers
///////////

#include <malloc.h>
#include <stdio.h>
#include <string.h>

#include <ntverp.h>

#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"

#include "args.h"
#include "main.h"
#include "messages.h"

//
// diamond routines
//
#include "mydiam.h"

// Globals
///////////

CHAR ARG_PTR *pszInFileName,     // input file name
             *pszOutFileName,    // output file name
             *pszTargetName;     // target path name

TCHAR   ErrorMsg[2048];

BOOL    bContainsMultipleFiles;  // Is source file a multi-file CAB?
INT     nLocalFiles, nTotalFiles = 0;  // number of files listed/expanded


// Module Variables
////////////////////

#ifndef COMPRESS
static BOOL bCopyingFile;        // Is current file being copied or expanded?
#endif


// Local Prototypes
////////////////////

static VOID DisplayErrorMessage(INT fError);
static VOID MakeDestFileName(CHAR ARG_PTR *argv[], CHAR ARG_PTR *pszDest);
static BOOL GetCanonicalName(LPSTR lpszFileName, LPSTR lpszCanonicalBuf);
static BOOL ActuallyTheSameFile(CHAR ARG_PTR *pszFile1,
                                CHAR ARG_PTR *pszFile2);
static BOOL ProcessNotification(CHAR ARG_PTR *pszSource,
                                CHAR ARG_PTR *pszDest, WORD wNotification);


/*
** static void DisplayErrorMessage(int fError);
**
** Display error message for given error condition.
**
** Arguments:  LZERROR_ code
**
** Returns:    void
**
** Globals:    none
*/
static VOID DisplayErrorMessage(INT fError)
{

   switch(fError)
   {
      case LZERROR_BADINHANDLE:
         LoadString(NULL, SID_NO_OPEN_INPUT, ErrorMsg, 2048);
         // WARNING: Cannot call CharToOemW  with src=dest
         CharToOem(ErrorMsg, ErrorMsg);
         printf(ErrorMsg, pszInFileName);
         break;

      case LZERROR_BADOUTHANDLE:
         LoadString(NULL, SID_NO_OPEN_OUTPUT, ErrorMsg, 2048);
         // WARNING: Cannot call CharToOemW  with src=dest
         CharToOem(ErrorMsg, ErrorMsg);
         printf(ErrorMsg, pszOutFileName);
         break;

      case LZERROR_READ:
         LoadString(NULL, SID_FORMAT_ERROR, ErrorMsg, 2048);
         // WARNING: Cannot call CharToOemW  with src=dest
         CharToOem(ErrorMsg, ErrorMsg);
         printf(ErrorMsg, pszInFileName);
         break;

      case LZERROR_WRITE:
         LoadString(NULL, SID_OUT_OF_SPACE, ErrorMsg, 2048);
         // WARNING: Cannot call CharToOemW  with src=dest
         CharToOem(ErrorMsg, ErrorMsg);
         printf(ErrorMsg, pszOutFileName);
         break;

      case LZERROR_UNKNOWNALG:
         LoadString(NULL, SID_UNKNOWN_ALG, ErrorMsg, 2048);
         // WARNING: Cannot call CharToOemW  with src=dest
         CharToOem(ErrorMsg, ErrorMsg);
         printf(ErrorMsg, pszInFileName);
         break;

      case BLANK_ERROR:
         break;

      default:
         LoadString(NULL, SID_GEN_FAILURE, ErrorMsg, 2048);
         // WARNING: Cannot call CharToOemW  with src=dest
         CharToOem(ErrorMsg, ErrorMsg);
         printf(ErrorMsg, pszInFileName, pszOutFileName);
         break;
   }
}


/*
** static void MakeDestFileName(char ARG_PTR *argv[], char ARG_PTR *pszDest);
**
** Create the appropriate destination file name.
**
** Arguments:  argv    - like argument to main()
**             pszDest - pointer to destination file name buffer to be filled
**                       in
**
** Returns:    void
**
** Globals:    none
*/
static VOID MakeDestFileName(CHAR ARG_PTR *argv[], CHAR ARG_PTR *pszDest)
{
   CHAR ARG_PTR *pszDestFile;

   if (nNumFileSpecs == 2 && bTargetIsDir == FALSE && bDoRename == FALSE)
      // Compress a single input file to a single output file.  N.b., we must
      // be careful to eat up the output file name command-line argument so
      // it doesn't get processed like another input file!
      STRCPY(pszDest, argv[GetNextFileArg(argv)]);
   else if (bTargetIsDir == TRUE)
   {
      // Prepend output file name with destination directory path name.
      STRCPY(pszDest, pszTargetName);

      // Isolate source file name from source file specification.
      pszDestFile = ExtractFileName(pszInFileName);

      // Add destination file name to destination directory path
      // specification.
      MakePathName(pszDest, pszDestFile);
   }
   else
      // Destination file name same as source file name.  N.b., this is an
      // error condition if (bDoRename == FALSE).
      STRCPY(pszDest, pszInFileName);
}


/*
** static BOOL GetCanonicalName(LPSTR lpszFileName, LPSTR lpszCanonicalBuf);
**
** Gets the canonical name for a given file specification.
**
** Arguments:  pszFileName    - file specification
**             szCanonicalBuf - buffer to be filled with canonical name
**
** Returns:    TRUE if successful.  FALSE if unsuccessful.
**
** N.b., szCanonicalBuf must be at least 128 bytes long.  The contents of
** szCanonicalBuf are only defined if the funstion returns TRUE.
**
*/
static BOOL GetCanonicalName(LPSTR lpszFileName, LPSTR lpszCanonicalBuf)
{
   BOOL bRetVal = FALSE;
   LPSTR lpszLastComp;

   return((BOOL) GetFullPathName(lpszFileName, MAX_PATH, lpszCanonicalBuf,  &lpszLastComp));
}


/*
** static BOOL ActuallyTheSameFile(char ARG_PTR *pszFile1,
**                                 char ARG_PTR *pszFile2);
**
** Checks to see if two file specifications point to the same physical file.
**
** Arguments:  pszFile1 - first file specification
**             pszFile2 - second file specification
**
** Returns:    BOOL - TRUE if the file specifications point to the same
**                    physical file.  FALSE if not.
**
** Globals:    none
*/
static BOOL ActuallyTheSameFile(CHAR ARG_PTR *pszFile1,
                                CHAR ARG_PTR *pszFile2)
{
   CHAR szCanonicalName1[MAX_PATH],
        szCanonicalName2[MAX_PATH];

   if (GetCanonicalName(pszFile1, szCanonicalName1) &&
       GetCanonicalName(pszFile2, szCanonicalName2))
   {
      if (! lstrcmpiA(szCanonicalName1, szCanonicalName2))
         return(TRUE);
   }

   return(FALSE);
}


/*
** static BOOL ProcessNotification(char ARG_PTR *pszSource,
**                                 char ARG_PTR *pszDest,
**                                 WORD wNotification);
**
** Callback function during file processing.
**
** Arguments:  pszSource     - source file name
**             pszDest       - destination file name
**             wNotification - process type query
**
** Returns:    BOOL - (wNotification == NOTIFY_START_*):
**                         TRUE if the source file should be "processed" into
**                         the destination file.  FALSE if not.
**                    else
**                         TRUE.
**
** Globals:    none
*/
static BOOL ProcessNotification(CHAR ARG_PTR *pszSource,
                                CHAR ARG_PTR *pszDest, WORD wNotification)
{
   switch(wNotification)
   {
      case NOTIFY_START_EXPAND:
      case NOTIFY_START_COPY:
      {
         // If we're listing files, display the name then tell caller to skip.

         if (bDoListFiles == TRUE)
         {
            PSTR p;

            //
            // Display just the base name from the target.  The prefix of the
            // target path is garbage (the source path.)
            //
            if(p = StringRevChar(pszDest,'\\')) {
               p++;
            } else {
               p = pszDest;
            }

            LoadString(NULL, SID_LISTING, ErrorMsg, 2048);
            CharToOem(ErrorMsg, ErrorMsg);
            printf(ErrorMsg, pszSource, p);

            nLocalFiles++;    // count files listed
            nTotalFiles++;    // count files listed

            return(FALSE);    // always skip file
         }

         // Fail if the source and destination files are identical.
         if (ActuallyTheSameFile(pszSource, pszDest))
         {
            LoadString(NULL, SID_COLLISION, ErrorMsg, 2048);
            // WARNING: Cannot call CharToOemW  with src=dest
            CharToOem(ErrorMsg, ErrorMsg);
            printf(ErrorMsg, pszSource);
            return(FALSE);
         }

         nLocalFiles++;    // count files expanded
         nTotalFiles++;    // count files expanded

         // Display start message.
         if (wNotification == NOTIFY_START_EXPAND) {
            LoadString(NULL, SID_EXPANDING, ErrorMsg, 2048);
            // WARNING: Cannot call CharToOemW  with src=dest
            CharToOem(ErrorMsg, ErrorMsg);
            printf(ErrorMsg, pszSource, pszDest);
         }
         else // NOTIFY_START_COPY
         {
            bCopyingFile = TRUE;
            LoadString(NULL, SID_COPYING, ErrorMsg, 2048);
            // WARNING: Cannot call CharToOemW  with src=dest
            CharToOem(ErrorMsg, ErrorMsg);
            printf(ErrorMsg, pszSource, pszDest);
         }
         break;
      }

      default:
         break;
   }

   return(TRUE);
}


/*
** int main(int argc, char *argv[]);
**
** Run command-line file compression program.
**
** Arguments:  figure it out
**
** Returns:    int - EXIT_SUCCESS if compression finished successfully,
**                   EXIT_FAILURE if not.
**
** Globals:    none
*/
INT __cdecl main(INT argc, CHAR *argv[])
{
   INT iSourceFileName,
       fError,
       nReturnCode = EXIT_SUCCESS;
   CHAR ARG_PTR pszDestFileName[MAX_PATH];
   LONG cblTotInSize = 0L,
        cblTotOutSize = 0L;
   PLZINFO pLZI;
   BOOL fIsDiamondFile;
   CHAR ARG_PTR *pszFilesSpec;
   BOOL fReportStats = TRUE;  // cleared if any multi-file CABs or listing

   USHORT wLanguageId = LANGIDFROMLCID(GetThreadLocale());

   if ((LANG_JAPANESE == PRIMARYLANGID(wLanguageId)) ||
       (LANG_KOREAN   == PRIMARYLANGID(wLanguageId)) ||
       (LANG_CHINESE  == PRIMARYLANGID(wLanguageId)))
   {
       //
       // This used to be #ifdef DBCS.  Now a runtime check.
       //
       DWORD dw = GetConsoleOutputCP();

       // WARNING: in product 1.1 we need to uncomment the SetConsole above
       // LoadString will return Ansi and printf will just pass it on
       // This will let cmd interpret the characters it gets.
       //   SetConsoleOutputCP(GetACP());

       switch (dw) {
          case 932:
          case 936:
          case 949:
          case 950:
             SetThreadLocale(MAKELCID(
                                MAKELANGID(
                                   PRIMARYLANGID(GetSystemDefaultLangID()),
                                   SUBLANG_ENGLISH_US),
                                SORT_DEFAULT));
             break;
          default:
             SetThreadLocale(MAKELCID(
                                MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                SORT_DEFAULT));
             break;
       }
   }

   // Display sign-on banner.
   LoadString(NULL, SID_BANNER_TEXT, ErrorMsg, 2048);
   // WARNING: Cannot call CharToOemW  with src=dest
   CharToOem(ErrorMsg, ErrorMsg);
   printf(ErrorMsg, VER_PRODUCTVERSION_STR);

   // Parse command-line arguments.
   if (ParseArguments(argc, argv) != TRUE)
      return(EXIT_FAILURE);

   // Set up global target path name.
   pszTargetName = argv[iTarget];

   if (bDisplayHelp == TRUE)
   {
      // User asked for help.
      LoadString(NULL, SID_INSTRUCTIONS, ErrorMsg, 2048);
      // WARNING: Cannot call CharToOemW  with src=dest
      CharToOem(ErrorMsg, ErrorMsg);
      fputs(ErrorMsg, stdout);
      return(EXIT_SUCCESS);
   }

   // Check for command line problems.
   if (CheckArguments() == FALSE)
      return(EXIT_FAILURE);

   // Set up ring buffer and I/O buffers.
   pLZI = InitGlobalBuffersEx();
   if (!pLZI || !InitDiamond())
   {
      LoadString(NULL, SID_INSUFF_MEM, ErrorMsg, 2048);
      // WARNING: Cannot call CharToOemW  with src=dest
      CharToOem(ErrorMsg, ErrorMsg);
      fputs(ErrorMsg, stdout);
      return(EXIT_FAILURE);
   }

   // Process each source file.
   while ((iSourceFileName = GetNextFileArg(argv)) != FAIL)
   {
      nLocalFiles = 0;
      pLZI->cblOutSize = 0;

      // Set up global input file name.
      pszInFileName = CharLowerA(argv[iSourceFileName]);

      // Set up global output file name.
      MakeDestFileName(argv, pszDestFileName);
      pszOutFileName = CharLowerA(pszDestFileName);

      // Assume current file will be expanded.  The ProcessNotification()
      // callback will change this module global to TRUE if the file is being
      // copied instead of expanded.
      bCopyingFile = FALSE;

      //
      // Determine whether the file was compressed with diamond.
      // If so, we need to expand it specially.
      //
      fIsDiamondFile = IsDiamondFile(pszInFileName, &bContainsMultipleFiles);
      if (fIsDiamondFile) {
         
         if (bContainsMultipleFiles) {

            if (nNumFileSpecs == 1 && (bDoListFiles == FALSE)) {

               //
               // The source file is a multi-file CAB, and is the only file
               // on the command line.  We'll require an explicit filespec
               // which names the file(s) desired from within the CAB.
               // The Files specification may contain wildcards.
               //
               // If the user included multiple source files on the command
               // line, we'll assume they're expecting a lot of output, and
               // we'll default to all files.  It would be pointless to put
               // up a message anyway, since the screen will be scrolling.
               //

               if (pszSelectiveFilesSpec == NULL) {

                  LoadString(NULL, SID_FILESPEC_REQUIRED, ErrorMsg, 2048);
                  // WARNING: Cannot call CharToOemW  with src=dest
                  CharToOem(ErrorMsg, ErrorMsg);
                  fputs(ErrorMsg, stdout);
                  continue;   // skip this (the only) source file
               }
            }

            if (!bTargetIsDir && (bDoListFiles == FALSE)) {

               //
               // The source file is a multi-file CAB, and the target is
               // a single file.  Now this just isn't going to work.  We'll
               // display this warning, and hope the user notices it.  If
               // a multiple sources were specified, they're going to get
               // a mess anyway.  We just won't contribute to it.
               //

               LoadString(NULL, SID_DEST_REQUIRED, ErrorMsg, 2048);
               // WARNING: Cannot call CharToOemW  with src=dest
               CharToOem(ErrorMsg, ErrorMsg);
               printf(ErrorMsg, pszInFileName);
               continue;   // skip this source file
            }

            pszFilesSpec = pszSelectiveFilesSpec;

            //
            // Don't try to interpret final stats if multi-file CABs are seen.
            // (Because of selective extract and other issues, you'll get silly
            // reports like "20000000 bytes expanded to 16320 bytes".)
            //

            fReportStats = FALSE;

         } else {

            //
            // Legacy: no selective expand from single-file CABs
            //

            pszFilesSpec = NULL;
         }

         //
         // Make sure renaming is ON if this is a multi-file CAB.
         //

         fError = ExpandDiamondFile(ProcessNotification,pszInFileName,
                           pszOutFileName,(bDoRename || bContainsMultipleFiles),
                           pszFilesSpec,pLZI);
      } else {
         fError = Expand(ProcessNotification, pszInFileName,
                           pszOutFileName, bDoRename, pLZI);
      }

      if (fError != TRUE) {
         // Deal with returned error codes.
         DisplayErrorMessage(nReturnCode = fError);

      } else if (bContainsMultipleFiles) {

         if (nLocalFiles == 0) {

            LoadString(NULL, SID_NO_MATCHES, ErrorMsg, 2048);
            // WARNING: Cannot call CharToOemW  with src=dest
            CharToOem(ErrorMsg, ErrorMsg);
            printf(ErrorMsg, pszInFileName, pszSelectiveFilesSpec);
         }

      } else {

         if (pLZI && pLZI->cblInSize && pLZI->cblOutSize) {

            // Keep track of cumulative statistics.
            cblTotInSize += pLZI->cblInSize;
            cblTotOutSize += pLZI->cblOutSize;

            if (bCopyingFile) {
               LoadString(NULL, SID_COPY_REPORT, ErrorMsg, 2048);
               // WARNING: Cannot call CharToOemW  with src=dest
               CharToOem(ErrorMsg, ErrorMsg);
               printf(ErrorMsg, pszInFileName, pLZI->cblInSize);
            }
            else {

               LoadString(NULL, SID_FILE_REPORT, ErrorMsg, 2048);
               // WARNING: Cannot call CharToOemW  with src=dest
               CharToOem(ErrorMsg, ErrorMsg);
               printf(ErrorMsg, pszInFileName, pLZI->cblInSize, pLZI->cblOutSize,
                      (INT)(((100 * (LONGLONG) pLZI->cblOutSize) / pLZI->cblInSize) - 100));
            }
         }
      }

      // Separate individual file processing message blocks by a blank line.
      printf("\n");
   }

   // Free memory used by ring buffer and I/O buffers.
   FreeGlobalBuffers(pLZI);

   TermDiamond();

   if (!fReportStats || bDoListFiles) {

      if (nTotalFiles > 1) {

         LoadString(NULL, SID_TOTAL_COUNT, ErrorMsg, 2048);
         // WARNING: Cannot call CharToOemW  with src=dest
         CharToOem(ErrorMsg, ErrorMsg);
         printf(ErrorMsg, nTotalFiles);
      }

   } else {

      // Display cumulative report for multiple files.
      if ((nTotalFiles > 1) && (cblTotInSize != 0)) {

         // Scale results to get accurate %
         LONG cblAdjInSize = cblTotInSize,
              cblAdjOutSize = cblTotOutSize;
         while (cblAdjInSize > 100000) {
           cblAdjInSize /= 2;
           cblAdjOutSize /= 2;
           }
         cblAdjOutSize += (cblAdjInSize / 200);    // round off (+0.5%)
         if (cblAdjOutSize < 0) {
           cblAdjOutSize = 0;
           }

         LoadString(NULL, SID_TOTAL_REPORT, ErrorMsg, 2048);
         // WARNING: Cannot call CharToOemW  with src=dest
         CharToOem(ErrorMsg, ErrorMsg);
         printf(ErrorMsg, nTotalFiles, cblTotInSize, cblTotOutSize,
                (INT)(100 * cblAdjOutSize / cblAdjInSize - 100));
      }

   }

   return(nReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\compress.c ===
/*
** compress.c - Main compression routine for LZA file compression program.
**
** Author: DavidDi
*/


// Headers
///////////

#ifndef LZA_DLL

#include <dos.h>
#include <errno.h>
#include <io.h>
#include <stdio.h>
#include <string.h>

#endif

#include "lz_common.h"
#include "lzcommon.h"
#include "lz_buffers.h"
#include "lz_header.h"


/*
** N.b., one reason DOS file handles are used for file references in this
** module is that using FILE *'s for file references poses a problem.
** fclose()'ing a file which was fopen()'ed in write "w" or append "a" mode
** stamps the file with the current date.  This undoes the intended effect of
** CopyDateTimeStamp().  We could also get around this fclose() problem by
** first fclose()'ing the file, and then fopen()'ing it again in read "r"
** mode.
**
** Using file handles also allows us to bypass stream buffering, so reads and
** writes may be done with whatever buffer size we choose.  Also, the
** lower-level DOS file handle functions are faster than their stream
** counterparts.
*/


/*
** int Compress(char ARG_PTR *pszSource, char ARG_PTR *pszDest,
**              BYTE byteAlgorithm, BYTE byteExtensionChar);
**
** Compress one file to another.
**
** Arguments:  pszSource         - name of file to compress
**             pszDest           - name of compressed output file
**             byteAlgorithm     - compression algorithm to use
**             byteExtensionChar - compressed file name extension character
**
** Returns:    int - TRUE if compression finished successfully.  One of the
**                   LZERROR_ codes if not.
**
** Globals:    none
*/
INT Compress(
   NOTIFYPROC pfnNotify,
   CHAR ARG_PTR *pszSource,
   CHAR ARG_PTR *pszDest,
   BYTE byteAlgorithm,
   BOOL bDoRename,
   PLZINFO pLZI)
{
   INT doshSource,            // input file handle
       doshDest,              // output file handle
       nRetVal = TRUE;
   FH FHOut;                  // compressed header info struct
   CHAR szDestFileName[MAX_PATH];
   BYTE byteExtensionChar;

   // Sanity check
   if (!pLZI) {
      return(LZERROR_GLOBLOCK);
   }

   // Set up input file handle. Set cblInSize to length of input file.
   if ((nRetVal = GetIOHandle(pszSource, READ_IT, & doshSource, &pLZI->cblInSize)) != TRUE)
      return(nRetVal);

   // Rewind input file.
   if (FSEEK(doshSource, 0L, SEEK_SET) != 0L)
   {
      FCLOSE(doshSource);
      return(LZERROR_BADINHANDLE);
   }

   // Create destination file name.

   lstrcpyn(szDestFileName, pszDest, sizeof(szDestFileName)/sizeof(szDestFileName[0]));

   if (bDoRename == TRUE)
      // Rename output file.
      byteExtensionChar = MakeCompressedName(szDestFileName);
   else
      byteExtensionChar = '\0';

   // Ask if we should compress this file.
   if (! (*pfnNotify)(pszSource, szDestFileName, NOTIFY_START_COMPRESS))
   {
      // Don't compress file.    This error condition should be handled in
      // pfnNotify, so indicate that it is not necessary for the caller to
      // display an error message.
      FCLOSE(doshSource);
      return(BLANK_ERROR);
   }

   // Set up output file handle.
   if ((nRetVal = GetIOHandle(szDestFileName, WRITE_IT, & doshDest, &pLZI->cblInSize)) != TRUE)
   {
      FCLOSE(doshSource);
      return(nRetVal);
   }

   // Fill in compressed file header.
   MakeHeader(& FHOut, byteAlgorithm, byteExtensionChar, pLZI);

   // Write compressed file header to output file.
   if ((nRetVal = WriteHdr(& FHOut, doshDest, pLZI)) != TRUE)
      goto COMPRESS_EXIT;

   // Compress input file into output file.
   switch (byteAlgorithm)
   {
      case ALG_FIRST:
#if 0
      case ALG_LZ:
#endif
         nRetVal = LZEncode(doshSource, doshDest, pLZI);
         break;

      default:
         nRetVal = LZERROR_UNKNOWNALG;
         break;
   }

   if (nRetVal != TRUE)
      goto COMPRESS_EXIT;

   // Copy date and time stamp from source file to destination file.
   nRetVal = CopyDateTimeStamp(doshSource, doshDest);

COMPRESS_EXIT:
   // Close files.
   FCLOSE(doshSource);
   FCLOSE(doshDest);

   return(nRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\init.c ===
/*
** init.c - Routines dealing with I/O and expansion buffers for LZCOPY() and
**          DOS command-line programs.
**
** Author:  DavidDi
*/


// Headers
///////////

#ifndef LZA_DLL

#include <dos.h>
#include <fcntl.h>
#include <io.h>
#include <malloc.h>
#include <stdio.h>

#endif

#include "lz_common.h"
#include "lz_buffers.h"
#include "lzcommon.h"

PLZINFO InitGlobalBuffers(
   DWORD dwOutBufSize,
   DWORD dwRingBufSize,
   DWORD dwInBufSize)
{
   PLZINFO pLZI;

   if (!(pLZI = (PLZINFO)LocalAlloc(LPTR, sizeof(LZINFO)))) {
      return(NULL);
   }

   // Set up ring buffer.  N.b., extra (cbStrMax - 1) bytes used to
   // facilitate string comparisons near end of ring buffer.
   // (The size allocated for the ring buffer may be at most 4224, since
   //  that's the ring buffer length embedded in the LZFile structs in
   //  lzexpand.h.)

   if (dwRingBufSize == 0) {
      dwRingBufSize = MAX_RING_BUF_LEN;
   }

   if ((pLZI->rgbyteRingBuf = (BYTE FAR *)FALLOC(dwRingBufSize * sizeof(BYTE))) == NULL)
      // Bail out, since without the ring buffer, we can't decode anything.
      return(NULL);


   if (dwInBufSize == 0) {
      dwInBufSize = MAX_IN_BUF_SIZE;
   }

   if (dwOutBufSize == 0) {
      dwOutBufSize = MAX_OUT_BUF_SIZE;
   }

   for (pLZI->ucbInBufLen = dwInBufSize, pLZI->ucbOutBufLen = dwOutBufSize;
      pLZI->ucbInBufLen > 0U && pLZI->ucbOutBufLen > 0U;
      pLZI->ucbInBufLen -= IN_BUF_STEP, pLZI->ucbOutBufLen -= OUT_BUF_STEP)
   {
      // Try to set up input buffer.  N.b., extra byte because rgbyteInBuf[0]
      // will be used to hold last byte from previous input buffer.
      if ((pLZI->rgbyteInBuf = (BYTE *)FALLOC(pLZI->ucbInBufLen + 1U)) == NULL)
         continue;

      // And try to set up output buffer...
      if ((pLZI->rgbyteOutBuf = (BYTE *)FALLOC(pLZI->ucbOutBufLen)) == NULL)
      {
         FFREE(pLZI->rgbyteInBuf);
         continue;
      }

      return(pLZI);
   }

   // Insufficient memory for I/O buffers.
   FFREE(pLZI->rgbyteRingBuf);
   return(NULL);
}

PLZINFO InitGlobalBuffersEx()
{
   return(InitGlobalBuffers(MAX_OUT_BUF_SIZE, MAX_RING_BUF_LEN, MAX_IN_BUF_SIZE));
}

VOID FreeGlobalBuffers(
   PLZINFO pLZI)
{

   // Sanity check

   if (!pLZI) {
      return;
   }

   if (pLZI->rgbyteRingBuf)
   {
      FFREE(pLZI->rgbyteRingBuf);
      pLZI->rgbyteRingBuf = NULL;
   }

   if (pLZI->rgbyteInBuf)
   {
      FFREE(pLZI->rgbyteInBuf);
      pLZI->rgbyteInBuf = NULL;
   }

   if (pLZI->rgbyteOutBuf)
   {
      FFREE(pLZI->rgbyteOutBuf);
      pLZI->rgbyteOutBuf = NULL;
   }

   // Buffers deallocated ok.

   // reset thread info
   LocalFree(pLZI);
}


/*
** int GetIOHandle(char ARG_PTR *pszFileName, BOOL bRead, int ARG_PTR *pdosh);
**
** Opens input and output files.
**
** Arguments:  pszFileName - source file name
**             bRead       - mode for opening file TRUE for read and FALSE
**                           for write
**             pdosh       - pointer to buffer for DOS file handle to be
**                           filled in
**
** Returns:    int - TRUE if file opened successfully.  LZERROR_BADINHANDLE
**                   if input file could not be opened.  LZERROR_BADOUTHANDLE
**                   if output file could not be opened.  Fills in
**                   *pdosh with open DOS file handle, or NO_DOSH if
**                   pszFileName is NULL.
**
** Globals:    cblInSize  - set to length of input file
*/
INT GetIOHandle(CHAR ARG_PTR *pszFileName, BOOL bRead, INT ARG_PTR *pdosh, LONG *pcblInSize)
{
   if (pszFileName == NULL)
      *pdosh = NO_DOSH;
   else if (bRead == WRITE_IT)
   {
      // Set up output DOS file handle.
      if ((*pdosh = FCREATE(pszFileName)) == -1)
         return(LZERROR_BADOUTHANDLE);
   }
   else // (bRead == READ_IT)
   {
      if ((*pdosh = FOPEN(pszFileName)) == -1)
         return(LZERROR_BADINHANDLE);

      // Move to the end of the input file to find its length,
      // then return to the beginning.
      if ((*pcblInSize = FSEEK(*pdosh, 0L, SEEK_END)) < 0L ||
          FSEEK(*pdosh, 0L, SEEK_SET) != 0L)
      {
         FCLOSE(*pdosh);
         return(LZERROR_BADINHANDLE);
      }
   }

   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\expand.c ===
/*
** expand.c - Main expansion routine for LZA file expansion program.
**
** Author: DavidDi
*/


// Headers
///////////

#ifndef LZA_DLL

#include <dos.h>
#include <errno.h>
#include <io.h>
#include <stdio.h>
#include <string.h>

#endif

#include "lz_common.h"
#include "lzcommon.h"
#include "lz_buffers.h"
#include "lz_header.h"


/*
** N.b., one reason DOS file handles are used for file references in this
** module is that using FILE *'s for file references poses a problem.
** fclose()'ing a file which was fopen()'ed in write "w" or append "a" mode
** stamps the file with the current date.  This undoes the intended effect of
** CopyDateTimeStamp().  We could also get around this fclose() problem by
** first fclose()'ing the file, and then fopen()'ing it again in read "r"
** mode.
**
** Using file handles also allows us to bypass stream buffering, so reads and
** writes may be done with whatever buffer size we choose.  Also, the
** lower-level DOS file handle functions are faster than their stream
** counterparts.
*/


/*
** int CopyFile(int doshSource, int doshDest);
**
** Copy file.
**
** Arguments:  doshSource  - source DOS file handle
**             doshDest    - destination DOS file handle
**
** Returns:    int - TRUE if successful.  One of the LZERROR_ codes if
**                   unsuccessful.
**
** Globals:    none
*/
/* WIN32 MOD, CopyFile is a win32 API!*/
INT lz_CopyFile(INT doshSource, INT doshDest, PLZINFO pLZI)
{
   DWORD ucbRead, ucbWritten;

   // !!! Assumes pLZI parm is valid.  No sanity check (should be done above in caller).

   // Rewind input file again.
   if (FSEEK(doshSource, 0L, SEEK_SET) != 0L) {
      return(LZERROR_BADINHANDLE);
   }

   // Rewind output file.
   if (doshDest != NO_DOSH &&
       FSEEK(doshDest, 0L, SEEK_SET) != 0L) {
      return( LZERROR_BADOUTHANDLE );
   }

   // Set up a fresh buffer state.
   ResetBuffers();

   while ((ucbRead = FREAD(doshSource, pLZI->rgbyteInBuf, pLZI->ucbInBufLen)) > 0U &&
#ifdef LZA_DLL
           ucbRead != (DWORD)(-1))
#else
           FERROR() == 0)
#endif
   {
      if ((ucbWritten = FWRITE(doshDest, pLZI->rgbyteInBuf, ucbRead)) != ucbRead)
#ifdef LZA_DLL
         if (ucbWritten != (DWORD)(-1)) {
#else
         if (FERROR() != 0) {
#endif
            return(LZERROR_BADOUTHANDLE);
         }
         else {
            return(LZERROR_WRITE);
         }

      pLZI->cblOutSize += ucbWritten;

      if (ucbRead != pLZI->ucbInBufLen)
         break;
   }

#ifdef LZA_DLL
   // here, ucbRead ==  0,    EOF (proper loop termination)
   //               == -1,    bad DOS handle
   if (ucbRead == (DWORD)(-1)) {
#else
   // here, FERROR() == 0U,   EOF (proper loop termination)
   //                != 0U,   bad DOS handle
   if (FERROR() != 0U) {
#endif
      return(LZERROR_BADINHANDLE);
   }

   // Copy successful - return number of bytes copied.
   return(TRUE);
}


/*
** int ExpandOrCopyFile(int doshDource, int doshDest);
**
** Expands one file to another.
**
** Arguments:  doshSource - source DOS file handle
**             doshDest   - destination DOS file handle
**
** Returns:    int - TRUE if expansion finished successfully.  One of the
**                   LZERROR_ codes if not.
**
** Globals:    none
*/
INT ExpandOrCopyFile(INT doshSource, INT doshDest, PLZINFO pLZI)
{
   INT f;
   FH FHInfo;                 // compressed header info struct
   BOOL bExpandingFile;

   // !!! Assumes pLZI parm is valid.  No sanity check (should be done above in caller).

   // Get compressed file header.
   if (GetHdr(&FHInfo, doshSource, &pLZI->cblInSize) != TRUE
       && pLZI->cblInSize >= (LONG)HEADER_LEN)
      // read error occurred
      return(LZERROR_BADINHANDLE);

   // Expand or copy input file to output file.
   bExpandingFile = (IsCompressed(& FHInfo) == TRUE);

   if (bExpandingFile)
   {
      switch (FHInfo.byteAlgorithm)
      {
         case ALG_FIRST:
            f = LZDecode(doshSource, doshDest, (LONG)FHInfo.cbulUncompSize - 1L,
               TRUE, TRUE, pLZI);
            break;

#if 0
         case ALG_LZ:
            f = LZDecode(doshSource, doshDest, (LONG)FHInfo.cbulUncompSize - 1L,
               TRUE, FALSE, pLZI);
            break;
#endif

         default:
            f = LZERROR_UNKNOWNALG;
            break;
      }
   }
   else
      f = lz_CopyFile(doshSource, doshDest, pLZI);

   if (f != TRUE)
      return(f);

   // Flush output buffer to file.
   if ((f = FlushOutputBuffer(doshDest, pLZI)) != TRUE)
      return(f);

   // Copy date and time stamp from source file to destination file.
   if ((f = CopyDateTimeStamp(doshSource, doshDest)) != TRUE)
      return(f);

   // Did we expand the exact number of bytes we expected to from the
   // compressed file header entry?
   if (bExpandingFile &&
       (DWORD)pLZI->cblOutSize != FHInfo.cbulUncompSize)
      return(LZERROR_READ);

   // Expansion / copying finished successfully.
   return(TRUE);
}


/*
** int Expand(char ARG_PTR *pszSource, char ARG_PTR *pszDest, BOOL bDoRename);
**
** Expands one file to another.
**
** Arguments:  pszSource - name of file to compress
**             pszDest   - name of compressed output file
**             bDoRename - flag for output file renaming
**
** Returns:    int - TRUE if expansion finished successfully.  One of the
**                   LZERROR_ codes if not.
**
** Globals:    none
*/
INT Expand(
   NOTIFYPROC pfnNotify,
   CHAR ARG_PTR *pszSource,
   CHAR ARG_PTR *pszDest,
   BOOL bDoRename,
   PLZINFO pLZI)
{
   INT doshSource,            // input file handle
       doshDest,              // output file handle
       f;
   FH FHInfo;                 // compressed header info struct
   CHAR szDestFileName[MAX_PATH];

   // Sanity check
   if (!pLZI) {
      return(LZERROR_GLOBLOCK);
   }

   // Set up input file handle. Set cblInSize to length of input file.
   if ((f = GetIOHandle(pszSource, READ_IT, & doshSource, &pLZI->cblInSize)) != TRUE)
      return(f);

   if (GetHdr(&FHInfo, doshSource, &pLZI->cblInSize) != TRUE &&
       pLZI->cblInSize >= (LONG)HEADER_LEN)
   {
      // Read error occurred.
      FCLOSE(doshSource);
      return(LZERROR_BADINHANDLE);
   }

   // Create destination file name.

   lstrcpyn(szDestFileName, pszDest, sizeof(szDestFileName)/sizeof(szDestFileName[0]));

#if 0
   if (bDoRename == TRUE && FHInfo.byteAlgorithm != ALG_FIRST)
#else
   if (bDoRename == TRUE)
#endif
   {
      // Rename output file using expanded file name extension character
      // stored in compressed file header.
      MakeExpandedName(szDestFileName, FHInfo.byteExtensionChar);
   }

   // Ask if we should compress this file.
   if (! (*pfnNotify)(pszSource, szDestFileName, (WORD)
                      (IsCompressed(&FHInfo) ?  NOTIFY_START_EXPAND : NOTIFY_START_COPY)))
   {
      // Don't expand / copy file.  This error condition should be handled in
      // pfnNotify, so indicate that it is not necessary for the caller to
      // display an error message.
      FCLOSE(doshSource);
      return(BLANK_ERROR);
   }

   // Set up output file handle.
   if ((f = GetIOHandle(szDestFileName, WRITE_IT, & doshDest, &pLZI->cblInSize)) != TRUE)
   {
      FCLOSE(doshSource);
      return(f);
   }

   // Expand or copy input file into output file.
   f = ExpandOrCopyFile(doshSource, doshDest, pLZI);

   // Close files.
   FCLOSE(doshSource);
   FCLOSE(doshDest);

   return(f);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\lzcommon.h ===
/*
** lzcommon.h - Shared information for LZ modules.
**
** Author:  DavidDi
*/


// Constants
/////////////

#define RING_BUF_LEN       4096        // size of ring buffer
#define MAX_RING_BUF_LEN   4224        // size of ring buffer - from LZFile
                                       // struct declaration in lzexpand.h

#define NIL                RING_BUF_LEN   // flag index used in binary search
                                          // trees

#define BUF_CLEAR_BYTE     ((BYTE) ' ')   // rgbyteRingBuf[] initializer

#define MAX_LITERAL_LEN    2           // encode string into position and
                                       // length if match length greater than
                                       // this value (== # of bytes required
                                       // to encode position and length)

#define FIRST_MAX_MATCH_LEN   0x10     // ALG_FIRST used this length
#define LZ_MAX_MATCH_LEN      (0x10 + MAX_LITERAL_LEN)
#define LZA_MAX_MATCH_LEN     64
                                       // upper limit for match length
                                       // (n.b., assume length field implies
                                       // length += 3)

// Maximum number of bytes LZDecode() and LZADecode() will expand beyond
// position requested.
#define MAX_OVERRUN        ((long)pLZI->cbMaxMatchLen)


// Globals
///////////

extern INT iCurMatch,      // index of longest match (set by LZInsertNode())
           cbCurMatch;     // length of longest match (set by LZInsertNode())

extern DWORD uFlags;    // LZ decoding description byte

extern INT iCurRingBufPos; // ring buffer offset

// Prototypes
//////////////

// lzcommon.c
extern BOOL LZInitTree(PLZINFO pLZI);
extern VOID LZFreeTree(PLZINFO pLZI);
extern VOID LZInsertNode(INT nodeToInsert, BOOL bDoArithmeticInsert, PLZINFO pLZI);
extern VOID LZDeleteNode(INT nodeToDelete, PLZINFO pLZI);

// lzcomp.c
extern INT LZEncode(INT doshSource, INT doshDest, PLZINFO pLZI);

// lzexp.c
extern INT LZDecode(INT doshSource, INT doshDest, LONG cblExpandedLength,
                    BOOL bRestartDecoding, BOOL bFirstAlg, PLZINFO pLZI);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\header.c ===
/*
** header.c - Routines used to access compressed file header information.
**
** written by DavidDi
*/


// Headers
///////////

#ifndef LZA_DLL

#include <io.h>
#include <dos.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>

#endif

#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"


/*
** int WriteHdr(PFH pFH, int doshDest);
**
** Write compressed file header to output file.
**
** Arguments:  pFH      - pointer to source header information structure
**             doshDest - DOS file handle of open output file
**
** Returns:    int - TRUE if successful.  LZERROR_BADOUTHANDLE if
**                   unsuccessful.
**
** Globals:    none
**
** header format:
**                8 bytes  -->   compressed file signature
**                1 byte   -->   algorithm label
**                1 byte   -->   extension char
**                4 bytes  -->   uncompressed file size (LSB to MSB)
**
**       length = 14 bytes
*/
INT WriteHdr(PFH pFH, INT doshDest, PLZINFO pLZI)
{
   INT i, j;
   DWORD ucbWritten;
   BYTE rgbyteHeaderBuf[HEADER_LEN];   // temporary storage for next header byte to write

   // Sanity check
   if (!pLZI) {
      return(LZERROR_GLOBLOCK);
   }

   // Copy the compressed file signature.
   for (i = 0; i < COMP_SIG_LEN; i++)
      rgbyteHeaderBuf[i] = pFH->rgbyteMagic[i];

   // Copy the algorithm label and file name extension character.
   rgbyteHeaderBuf[i++] = pFH->byteAlgorithm;
   rgbyteHeaderBuf[i++] = pFH->byteExtensionChar;

   // Copy input file size (long ==> 4 bytes),
   // LSB first to MSB last.
   for (j = 0; j < 4; j++)
      rgbyteHeaderBuf[i++] = (BYTE)((pFH->cbulUncompSize >> (8 * j)) &
                                    (DWORD)BYTE_MASK);

   // Write header to file.
   if ((ucbWritten = FWRITE(doshDest, rgbyteHeaderBuf, HEADER_LEN)) != HEADER_LEN)
   {
#ifdef LZA_DLL
      if (ucbWritten == (DWORD)(-1))
#else
      if (_error != 0U)
#endif
         // Bad DOS file handle.
         return(LZERROR_BADOUTHANDLE);
      else
         // Insufficient space on destination drive.
         return(LZERROR_WRITE);
   }

   // Keep track of bytes written.
   pLZI->cblOutSize += (LONG)ucbWritten;

   // Header written ok.
   return(TRUE);
}


/*
** int GetHdr(PFH pFH, int doshSource);
**
** Get compressed file header.
**
** Arguments:  pFH        - pointer to destination header information structure
**             doshSource - DOS file handle of open input file
**
** Returns:    int - TRUE if compressed file header read successfully.  One
**                   the LZERROR_ codes if not.
**
** Globals:    none
*/
INT GetHdr(PFH pFH, INT doshSource, LONG *pcblInSize)
{
   DWORD ucbRead;
   BYTE rgbyteHeaderBuf[HEADER_LEN];
   INT i, j;

   // Get input file length and move back to beginning of input file.
   if ((*pcblInSize = FSEEK(doshSource, 0L, SEEK_END)) <  0L ||
       FSEEK(doshSource, 0L, SEEK_SET) != 0L)
      return(LZERROR_BADINHANDLE);

   if ((ucbRead = FREAD(doshSource, rgbyteHeaderBuf, HEADER_LEN))
       != HEADER_LEN)
   {
#ifdef LZA_DLL
      if (ucbRead == (DWORD)(-1))
#else
      if (_error != 0U)
#endif
         // We were handed a bad input file handle.
         return((INT)LZERROR_BADINHANDLE);
      else
         // Input file shorter than compressed header size.
         return(LZERROR_READ);
   }

   // Put compressed file signature into rgbyteMagic[] of header info struct.
   for (i = 0; i < COMP_SIG_LEN; i++)
      pFH->rgbyteMagic[i] = rgbyteHeaderBuf[i];

   // Get algorithm label and file name extension character.
   pFH->byteAlgorithm = rgbyteHeaderBuf[i++];
   pFH->byteExtensionChar = rgbyteHeaderBuf[i++];

   // Extract uncompressed file size, LSB --> MSB (4 bytes in long).
   pFH->cbulUncompSize = 0UL;
   for (j = 0; j < 4; j++)
      pFH->cbulUncompSize |= ((DWORD)(rgbyteHeaderBuf[i++]) << (8 * j));

   // Stick compressed file size into header info struct.
   pFH->cbulCompSize = (DWORD)*pcblInSize;

   // File header read ok.
   return(TRUE);
}


/*
** BOOL IsCompressed(PFH pFHIn);
**
** See if a file is in compressed form by comparing its file signature with
** the expected compressed file signature.
**
** Arguments:  pFHIn - pointer to header info struct to check
**
** Returns:    BOOL - TRUE if file signature matches expected compressed file
**                    signature.  FALSE if not.
**
** Globals:    none
*/
BOOL IsCompressed(PFH pFHIn)
{
   INT i;
   // storage for FHIn's compressed file signature (used to make it an sz)
   CHAR rgchBuf[COMP_SIG_LEN + 1];

   // Copy file info struct's compressed file signature into rgchBuf[] to
   // make it an sz.
   for (i = 0; i < COMP_SIG_LEN; i++)
      rgchBuf[i] = pFHIn->rgbyteMagic[i];

   rgchBuf[i] = '\0';

   return((STRCMP(rgchBuf, COMP_SIG) == 0) ? TRUE : FALSE);
}


/*
** void MakeHeader(PFH pFHBlank, BYTE byteAlgorithm,
**                 BYTE byteExtensionChar);
**
** Arguments:  pFHBlank          - pointer to compressed file header struct
**                                 that is to be filled in
**             byteAlgorithm     - algorithm label
**             byteExtensionChar - uncompressed file name extension character
**
** Returns:    void
**
** Globals:    none
**
** Global cblInSize is used to fill in expanded file length field.
** Compressed file length field is set to 0 since it isn't written.
**
*/
VOID MakeHeader(PFH pFHBlank, BYTE byteAlgorithm,
                BYTE byteExtensionChar, PLZINFO pLZI)
{
   INT i;

   // !!! Assumes pLZI parm is valid.  No sanity check (should be done above in caller).

   // Fill in compressed file signature.
   for (i = 0; i < COMP_SIG_LEN; i++)
      pFHBlank->rgbyteMagic[i] = (BYTE)(*(COMP_SIG + i));

   // Fill in algorithm and extesion character.
   pFHBlank->byteAlgorithm = byteAlgorithm;
   pFHBlank->byteExtensionChar = byteExtensionChar;

   // Fill in file sizes.  (cbulCompSize not written to compressed file
   // header, so just set it to 0UL.)
   pFHBlank->cbulUncompSize = (DWORD)pLZI->cblInSize;
   pFHBlank->cbulCompSize = 0UL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\lzcomp.c ===
/*
** lzcomp.c - Routines used in Lempel-Ziv compression (a la 1977 article).
**
** Author:  DavidDi
*/


// Headers
///////////

#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"
#include "lzcommon.h"


/*
** int LZEncode(int doshSource, int doshDest);
**
** Compress input file into output file.
**
** Arguments:  doshSource    - open DOS file handle of input file
**             doshDest      - open DOS file handle of output file
**
** Returns:    int - TRUE if compression was successful.  One of the LZERROR_
**                   codes if the compression failed.
**
** Globals:
*/
INT LZEncode(INT doshSource, INT doshDest, PLZINFO pLZI)
{
   INT   i, len, f,
         iCurChar,      // current ring buffer position
         iCurString,    // start of current string in ring buffer
         iCodeBuf,      // index of next open buffer position
         cbLastMatch;   // length of last match
   BYTE byte,           // temporary storage for next byte to write
        byteMask,       // bit mask (and counter) for eight code units
        codeBuf[1 + 8 * MAX_LITERAL_LEN]; // temporary storage for encoded data

#if 0
   pLZI->cbMaxMatchLen = LZ_MAX_MATCH_LEN;
#else
   pLZI->cbMaxMatchLen = FIRST_MAX_MATCH_LEN;
#endif

   ResetBuffers();

   pLZI->cblOutSize += HEADER_LEN;

   // Initialize encoding trees.
   if (!LZInitTree(pLZI)) {
      return( LZERROR_GLOBALLOC );
   }

   // CodeBuf[1..16] saves eight units of code, and CodeBuf[0] works as eight
   // flags.  '1' representing that the unit is an unencoded letter (1 byte),
   // '0' a position-and-length pair (2 bytes).  Thus, eight units require at
   // most 16 bytes of code, plus the one byte of flags.
   codeBuf[0] = (BYTE)0;
   byteMask = (BYTE)1;
   iCodeBuf = 1;

   iCurString = 0;
   iCurChar = RING_BUF_LEN - pLZI->cbMaxMatchLen;

   for (i = 0; i < RING_BUF_LEN - pLZI->cbMaxMatchLen; i++)
      pLZI->rgbyteRingBuf[i] = BUF_CLEAR_BYTE;

   // Read bytes into the last cbMaxMatchLen bytes of the buffer.
   for (len = 0; len < pLZI->cbMaxMatchLen && ((f = ReadByte(byte)) != END_OF_INPUT);
        len++)
   {
      if (f != TRUE) {
         return( f );
      }

      pLZI->rgbyteRingBuf[iCurChar + len] = byte;
   }

   // Insert the cbMaxMatchLen strings, each of which begins with one or more
   // 'space' characters.  Note the order in which these strings are inserted.
   // This way, degenerate trees will be less likely to occur.
   for (i = 1; i <= pLZI->cbMaxMatchLen; i++)
      LZInsertNode(iCurChar - i, FALSE, pLZI);

   // Finally, insert the whole string just read.  The global variables
   // cbCurMatch and iCurMatch are set.
   LZInsertNode(iCurChar, FALSE, pLZI);

   do // while (len > 0)
   {
      // cbCurMatch may be spuriously long near the end of text.
      if (pLZI->cbCurMatch > len)
         pLZI->cbCurMatch = len;

      if (pLZI->cbCurMatch <= MAX_LITERAL_LEN)
      {
         // This match isn't long enough to encode, so copy it directly.
         pLZI->cbCurMatch = 1;
         // Set 'one uncoded byte' bit flag.
         codeBuf[0] |= byteMask;
         // Write literal byte.
         codeBuf[iCodeBuf++] = pLZI->rgbyteRingBuf[iCurChar];
      }
      else
      {
         // This match is long enough to encode.  Send its position and
         // length pair.  N.b., pLZI->cbCurMatch > MAX_LITERAL_LEN.
         codeBuf[iCodeBuf++] = (BYTE)pLZI->iCurMatch;
         codeBuf[iCodeBuf++] = (BYTE)((pLZI->iCurMatch >> 4 & 0xf0) |
                                      (pLZI->cbCurMatch - (MAX_LITERAL_LEN + 1)));
      }

      // Shift mask left one bit.
      if ((byteMask <<= 1) == (BYTE)0)
      {
         // Send at most 8 units of code together.
         for (i = 0; i < iCodeBuf; i++)
            if ((f = WriteByte(codeBuf[i])) != TRUE) {
               return( f );
            }

         // Reset flags and mask.
         codeBuf[0] = (BYTE)0;
         byteMask = (BYTE)1;
         iCodeBuf = 1;
      }

      cbLastMatch = pLZI->cbCurMatch;

      for (i = 0; i < cbLastMatch && ((f = ReadByte(byte)) != END_OF_INPUT);
           i++)
      {
         if (f != TRUE) {
            return( f );
         }

         // Delete old string.
         LZDeleteNode(iCurString, pLZI);
         pLZI->rgbyteRingBuf[iCurString] = byte;

         // If the start position is near the end of buffer, extend the
         // buffer to make string comparison easier.
         if (iCurString < pLZI->cbMaxMatchLen - 1)
            pLZI->rgbyteRingBuf[iCurString + RING_BUF_LEN] = byte;

         // Increment position in ring buffer modulo RING_BUF_LEN.
         iCurString = (iCurString + 1) & (RING_BUF_LEN - 1);
         iCurChar = (iCurChar + 1) & (RING_BUF_LEN - 1);

         // Register the string in rgbyteRingBuf[r..r + cbMaxMatchLen - 1].
         LZInsertNode(iCurChar, FALSE, pLZI);
      }

      while (i++ < cbLastMatch)
      {
         // No need to read after the end of the input, but the buffer may
         // not be empty.
         LZDeleteNode(iCurString, pLZI);
         iCurString = (iCurString + 1) & (RING_BUF_LEN - 1);
         iCurChar = (iCurChar + 1) & (RING_BUF_LEN - 1);
         if (--len)
            LZInsertNode(iCurChar, FALSE, pLZI);
      }
   } while (len > 0);   // until there is no input to process

   if (iCodeBuf > 1)
      // Send remaining code.
      for (i = 0; i < iCodeBuf; i++)
         if ((f = WriteByte(codeBuf[i])) != TRUE) {
            return( f );
         }

   // Flush output buffer to file.
   if ((f = FlushOutputBuffer(doshDest, pLZI)) != TRUE) {
      return( f );
   }

   LZFreeTree(pLZI);
   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\lzcommon.c ===
/*
** lzcommon.c - Routines common to LZ compression / expansion.
**
** Author:  DavidDi
*/


// Headers
///////////

#include "lz_common.h"
#include "lz_buffers.h"
#include "lzcommon.h"

/*
** bool LZInitTree(void);
**
** Initializes trees used in LZ compression.
**
** Arguments:  none
**
** Returns:    true/false
**
** Globals:    RightChild[] and Parent[] arrays reset to NIL to begin
**             encoding.
*/
BOOL LZInitTree(PLZINFO pLZI)
{
   INT i;

   /*
   ** For i = 0 to RING_BUF_LEN - 1, rightChild[i] and leftChild[i] will be the
   ** right and left children of node i.  These nodes need not be initialized.
   ** Also, parent[i] is the parent of node i.  These are initialized to
   ** NIL (= N), which stands for 'not used.'
   ** For i = 0 to 255, rightChild[RING_BUF_LEN + i + 1] is the root of the tree
   ** for strings that begin with character i.  These are initialized to NIL.
   ** n.b., there are 256 trees.
   */

   if (!pLZI->rightChild) {
      if (!(pLZI->rightChild = (INT*)LocalAlloc(LPTR, (RING_BUF_LEN + 257) * sizeof(INT)))) {
         return(FALSE);
      }
   }

   if (!pLZI->leftChild) {
      if (!(pLZI->leftChild = (INT*)LocalAlloc(LPTR, (RING_BUF_LEN + 1) * sizeof(INT)))) {
         return(FALSE);
      }
   }

   if (!pLZI->parent) {
      if (!(pLZI->parent = (INT*)LocalAlloc(LPTR, (RING_BUF_LEN + 1) * sizeof(INT)))) {
         return(FALSE);
      }
   }

   for (i = RING_BUF_LEN + 1; i <= RING_BUF_LEN + 256; i++)
      pLZI->rightChild[i] = NIL;

   for (i = 0; i < RING_BUF_LEN; i++)
      pLZI->parent[i] = NIL;

   return(TRUE);
}

VOID
LZFreeTree(PLZINFO pLZI)
{
   // Sanity check
   if (!pLZI) {
      return;
   }

   if (pLZI->rightChild) {
      LocalFree((HLOCAL)pLZI->rightChild);
      pLZI->rightChild = NULL;
   }

   if (pLZI->leftChild) {
      LocalFree((HLOCAL)pLZI->leftChild);
      pLZI->leftChild = NULL;
   }

   if (pLZI->parent) {
      LocalFree((HLOCAL)pLZI->parent);
      pLZI->parent = NULL;
   }
}

/*
** void LZInsertNode(int nodeToInsert, BOOL bDoArithmeticInsert);
**
** Inserts a new tree into the forest.  Inserts string of length
** cbMaxMatchLen, rgbyteRingBuf[r..r + cbMaxMatchLen - 1], into one of the trees
** (rgbyteRingBuf[r]'th tree).
**
** Arguments:  nodeToInsert        - start of string in ring buffer to insert
**                                   (also, associated tree root)
**             bDoArithmeticInsert - flag for performing regular LZ node
**                                   insertion or arithmetic encoding node
**                                   insertion
**
** Returns:    void
**
** Globals:    cbCurMatch - set to length of longest match
**             iCurMatch  - set to start index of longest matching string in
**                          ring buffer
**
** N.b., if cbCurMatch == cbMaxMatchLen, we remove the old node in favor of
** the new one, since the old node will be deleted sooner.
*/
VOID LZInsertNode(INT nodeToInsert, BOOL bDoArithmeticInsert, PLZINFO pLZI)
{
   INT  i, p, cmp, temp;
   BYTE FAR *key;

   // Sanity check
   if (!pLZI) {
      return;
   }

   cmp = 1;

   key = pLZI->rgbyteRingBuf + nodeToInsert;
   p = RING_BUF_LEN + 1 + key[0];

   pLZI->rightChild[nodeToInsert] = pLZI->leftChild[nodeToInsert] = NIL;
   pLZI->cbCurMatch = 0;

   FOREVER
   {
      if (cmp >= 0)
      {
         if (pLZI->rightChild[p] != NIL)
            p = pLZI->rightChild[p];
         else
         {
            pLZI->rightChild[p] = nodeToInsert;
            pLZI->parent[nodeToInsert] = p;
            return;
         }
      }
      else
      {
         if (pLZI->leftChild[p] != NIL)
            p = pLZI->leftChild[p];
         else
         {
            pLZI->leftChild[p] = nodeToInsert;
            pLZI->parent[nodeToInsert] = p;
            return;
         }
      }

      for (i = 1; i < pLZI->cbMaxMatchLen; i++)
         if ((cmp = key[i] - pLZI->rgbyteRingBuf[p + i]) != 0)
            break;

      if (bDoArithmeticInsert == TRUE)
      {
         // Do node insertion for arithmetic encoding.
         if (i > MAX_LITERAL_LEN)
         {
            if (i > pLZI->cbCurMatch)
            {
               pLZI->iCurMatch = (nodeToInsert - p) & (RING_BUF_LEN - 1);
               if ((pLZI->cbCurMatch = i) >= pLZI->cbMaxMatchLen)
                  break;
            }
            else if (i == pLZI->cbCurMatch)
            {
               if ((temp = (nodeToInsert - p) & (RING_BUF_LEN - 1)) < pLZI->iCurMatch)
                  pLZI->iCurMatch = temp;
            }
         }
      }
      else
      {
         // Do node insertion for LZ.
         if (i > pLZI->cbCurMatch)
         {
            pLZI->iCurMatch = p;
            if ((pLZI->cbCurMatch = i) >= pLZI->cbMaxMatchLen)
               break;
         }
      }
   }

   pLZI->parent[nodeToInsert] = pLZI->parent[p];
   pLZI->leftChild[nodeToInsert] = pLZI->leftChild[p];
   pLZI->rightChild[nodeToInsert] = pLZI->rightChild[p];

   pLZI->parent[pLZI->leftChild[p]] = nodeToInsert;
   pLZI->parent[pLZI->rightChild[p]] = nodeToInsert;

   if (pLZI->rightChild[pLZI->parent[p]] == p)
      pLZI->rightChild[pLZI->parent[p]] = nodeToInsert;
   else
      pLZI->leftChild[pLZI->parent[p]] = nodeToInsert;

   // Remove p.
   pLZI->parent[p] = NIL;

   return;
}


/*
** void LZDeleteNode(int nodeToDelete);
**
** Delete a tree from the forest.
**
** Arguments:  nodeToDelete - tree to delete from forest
**
** Returns:    void
**
** Globals:    Parent[], RightChild[], and LeftChild[] updated to reflect the
**             deletion of nodeToDelete.
*/
VOID LZDeleteNode(INT nodeToDelete, PLZINFO pLZI)
{
   INT  q;

   // Sanity check
   if (!pLZI) {
      return;
   }

   if (pLZI->parent[nodeToDelete] == NIL)
      // Tree nodeToDelete is not in the forest.
      return;

   if (pLZI->rightChild[nodeToDelete] == NIL)
      q = pLZI->leftChild[nodeToDelete];
   else if (pLZI->leftChild[nodeToDelete] == NIL)
      q = pLZI->rightChild[nodeToDelete];
   else
   {
      q = pLZI->leftChild[nodeToDelete];
      if (pLZI->rightChild[q] != NIL)
      {
         do
         {
            q = pLZI->rightChild[q];
         } while (pLZI->rightChild[q] != NIL);

         pLZI->rightChild[pLZI->parent[q]] = pLZI->leftChild[q];
         pLZI->parent[pLZI->leftChild[q]] = pLZI->parent[q];
         pLZI->leftChild[q] = pLZI->leftChild[nodeToDelete];
         pLZI->parent[pLZI->leftChild[nodeToDelete]] = q;
      }
      pLZI->rightChild[q] = pLZI->rightChild[nodeToDelete];
      pLZI->parent[pLZI->rightChild[nodeToDelete]] = q;
   }
   pLZI->parent[q] = pLZI->parent[nodeToDelete];

   if (pLZI->rightChild[pLZI->parent[nodeToDelete]] == nodeToDelete)
      pLZI->rightChild[pLZI->parent[nodeToDelete]] = q;
   else
      pLZI->leftChild[pLZI->parent[nodeToDelete]] = q;

   // Remove nodeToDelete.
   pLZI->parent[nodeToDelete] = NIL;

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\lzdos.h ===
#include <lzexpand.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\lzexp.c ===
/*
** lzexp.c - Routines used in Lempel-Ziv (from their 1977 article) expansion.
**
** Author:  DavidDi
*/


// Headers
///////////

#ifndef LZA_DLL
#include <io.h>
#endif

#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"
#include "lzcommon.h"


/*
** int LZDecode(int doshSource, int doshDest, long cblExpandedLength,
**              BOOL bRestartDecoding, BOOL bFirstAlg);
**
** Expand input file to output file.
**
** Arguments:  doshSource        - DOS file handle of open input file
**             doshDest          - DOS file handle of open output file
**             cblExpandedLength - amount of output file to expand
**             bRestartDecoding  - flag indicating whether or not to start
**                                 decoding from scratch
**             bFirstAlg         - flag indicating whether to use ALG_FIRST
**                                 or ALG_LZ
**
** Returns:    int - TRUE if expansion was successful.  One of the LZERROR_
**                   codes if the expansion failed.
**
** Globals:
**
** The number of bytes actually expanded will be >= cblExpandedLength.  The
** number of bytes actually expanded may be calculated as
** (pbyteOutBuf - rgbyteOutBuf).  The expansion will overrun the
** cblExpandedLength request by at most (cbMaxMatchLen - 1) bytes.
*/
INT LZDecode(
   INT doshSource,
   INT doshDest,
   LONG cblExpandedLength,
   BOOL bRestartDecoding,
   BOOL bFirstAlg,
   PLZINFO pLZI)
{
   INT i,
       cb,                          // number of bytes to unpack
       f;                           // holds ReadByte() return values
   INT oStart;                      // buffer offset for unpacking
   BYTE byte1, byte2;               // input byte holders


   // !!! Assumes parm pLZI is always valid

#if 0
   if (bFirstAlg == TRUE)
      pLZI->cbMaxMatchLen = FIRST_MAX_MATCH_LEN;
   else
      pLZI->cbMaxMatchLen = LZ_MAX_MATCH_LEN;
#else
   pLZI->cbMaxMatchLen = FIRST_MAX_MATCH_LEN;
#endif

   // Start decoding from scratch?
   if (bRestartDecoding == TRUE)
   {
      // Rewind the compressed input file to just after the compressed file
      // header.
      if (FSEEK(doshSource, (LONG)HEADER_LEN, SEEK_SET) != (LONG)HEADER_LEN) {
         return(LZERROR_BADINHANDLE);
      }

      // Rewind output file.
      if (doshDest != NO_DOSH &&
          FSEEK(doshDest, 0L, SEEK_SET) != 0L) {
         return(LZERROR_BADOUTHANDLE);
      }

      // Set up a fresh buffer state.
      ResetBuffers();

      // Initialize ring buffer.
      for (i = 0; i < RING_BUF_LEN - pLZI->cbMaxMatchLen; i++)
         pLZI->rgbyteRingBuf[i] = BUF_CLEAR_BYTE;

      // Initialize decoding globals.
      pLZI->uFlags = 0U;
      pLZI->iCurRingBufPos = RING_BUF_LEN - pLZI->cbMaxMatchLen;
   }

   if ((f = ReadByte(byte1)) != TRUE && f != END_OF_INPUT) {
      return(f);
   }

   // Decode one encoded unit at a time.
   FOREVER
   {
      if (f == END_OF_INPUT)  // EOF reached
         break;

      // Have we expanded enough data yet?
      if (pLZI->cblOutSize > cblExpandedLength)    // Might want to make this >=.
      {
         UnreadByte();
         return(TRUE);
      }

      // High order byte counts the number of bits used in the low order
      // byte.
      if (((pLZI->uFlags >>= 1) & 0x100) == 0)
      {
         // Set bit mask describing the next 8 bytes.
         pLZI->uFlags = ((DWORD)byte1) | 0xff00;

         if ((f = ReadByte(byte1)) != TRUE) {
            return(LZERROR_READ);
         }
      }

      if (pLZI->uFlags & 1)
      {
         // Just store the literal byte in the buffer.
         if ((f = WriteByte(byte1)) != TRUE) {
            return(f);
         }

         pLZI->rgbyteRingBuf[pLZI->iCurRingBufPos++] = byte1;
         pLZI->iCurRingBufPos &= RING_BUF_LEN - 1;
      }
      else
      {
         // Extract the offset and count to copy from the ring buffer.
         if ((f = ReadByte(byte2)) != TRUE) {
            return(LZERROR_READ);
         }

         cb = (INT)byte2;
         oStart = (cb & 0xf0) << 4 | (INT)byte1;
         cb = (cb & 0x0f) + MAX_LITERAL_LEN;

         for (i = 0; i <= cb; i++)
         {
            byte1 = pLZI->rgbyteRingBuf[(oStart + i) & (RING_BUF_LEN - 1)];

            if ((f = WriteByte(byte1)) != TRUE) {
               return( f );
            }

            pLZI->rgbyteRingBuf[pLZI->iCurRingBufPos++] = byte1;
            pLZI->iCurRingBufPos &= RING_BUF_LEN - 1;
         }
      }

      if ((f = ReadByte(byte1)) != TRUE && f != END_OF_INPUT) {
         return(f);
      }
   }

   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\lz_buffers.h ===
/*
** buffers.h - Function prototypes and global variables used to manipulate
** buffers used in I/O and expansion.
**
** Author:  DavidDi
*/


// Constants
/////////////

// N.b., rgbyteInBuf[] allocated with one extra byte for UnreadByte().
#define MAX_IN_BUF_SIZE    32768U   // maximum size of input buffer
#define MAX_OUT_BUF_SIZE   32768U   // maximum size of output buffer

#define IN_BUF_STEP        1024U    // decrement sizes used in I/O buffer
#define OUT_BUF_STEP       1024U    // allocation in InitBuffers()

#define FLUSH_BYTE         ((BYTE) 'F')   // dummy character used to flush
                                          // rgbyteOutBuf[] to output file

#define END_OF_INPUT       500      // ReadInBuf() EOF flag for input file

// DOS file handle flag indicating that the compression savings should be
// computed, but no output file written.
#define NO_DOSH            (-2)

#define READ_IT            TRUE     // GetIOHandle() bRead flag values
#define WRITE_IT           FALSE


// Macros
//////////

// Read a byte (buffered) from input file.  Stores byte read in argument.
// Returns TRUE if successful, or one of ReadInBuf()'s error codes if
// unsuccessful.
//-protect-
#define ReadByte(byte)         ((pLZI->pbyteInBuf < pLZI->pbyteInBufEnd) ? \
                               ((byte = *pLZI->pbyteInBuf++), TRUE) : \
                               ReadInBuf((BYTE ARG_PTR *)&byte, doshSource, pLZI))

// Put at most one byte back into the buffered input.  N.b., may be used at
// most (pbyteInBuf - &rgbyteInBuf[1]) times.  E.g., may be used only once at
// beginning of buffer.  Return value is always TRUE.
//-protect-
#define UnreadByte()          ((pLZI->pbyteInBuf == &pLZI->rgbyteInBuf[1]) ? \
                               (pLZI->bLastUsed = TRUE) : \
                               (--pLZI->pbyteInBuf, TRUE))

// Write a byte (buffered) to output file.  Returns TRUE if successful, or
// one of WriteOutBuf()'s error codes if unsuccessful.  ALWAYS increments
// cblOutSize.
#define WriteByte(byte)        ((pLZI->pbyteOutBuf < pLZI->pbyteOutBufEnd) ? \
                               ((*pLZI->pbyteOutBuf++ = byte), pLZI->cblOutSize++, TRUE) : \
                               (pLZI->cblOutSize++, WriteOutBuf(byte, doshDest, pLZI)))

// Flush output buffer.  DOES NOT increment cblOutSize.  N.b., you cannot
// perform a valid UnreadByte() immediately after FlushOutputBuffer() because
// the byte kept will be the bogus FLUSH_BYTE.
#define FlushOutputBuffer(dosh, pLZI)  WriteOutBuf(FLUSH_BYTE, dosh, pLZI)

// Reset buffer pointers to empty buffer state.
//-protect-
#define ResetBuffers()        {  pLZI->pbyteInBufEnd = &pLZI->rgbyteInBuf[1] + pLZI->ucbInBufLen; \
                                 pLZI->pbyteInBuf = &pLZI->rgbyteInBuf[1] + pLZI->ucbInBufLen; \
                                 pLZI->bLastUsed = FALSE; \
                                 pLZI->pbyteOutBufEnd = pLZI->rgbyteOutBuf + pLZI->ucbOutBufLen; \
                                 pLZI->pbyteOutBuf = pLZI->rgbyteOutBuf; \
                                 pLZI->cblOutSize = 0L; \
                              }

// The buffer pointers are initialized to NULL to indicate the buffers have
// not yet been allocated.  init.c!InitGlobalBuffers() allocates the buffers
// and sets the buffers' base pointers.  buffers.h!ResetBufferPointers() sets
// the buffers' current position and end position pointers.

// Prototypes
//////////////

// buffers.c
extern INT ReadInBuf(BYTE ARG_PTR *pbyte, INT doshSource, PLZINFO pLZI);
extern INT WriteOutBuf(BYTE byteNext, INT doshDest, PLZINFO pLZI);

// init.c
extern PLZINFO InitGlobalBuffers(DWORD dwOutBufSize, DWORD dwRingBufSize, DWORD dwInBufSize);
extern PLZINFO InitGlobalBuffersEx();
extern VOID FreeGlobalBuffers(PLZINFO);

extern INT GetIOHandle(CHAR ARG_PTR *pszFileName, BOOL bRead, INT ARG_PTR *pdosh,
   LONG *pcblInSize);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\lz_common.h ===
/*
** common.h - housekeeping for Lempel-Ziv compression / expansion DOS
**            command-line programs, DOS static library module, and Windows
**            DLL
**
** Author:  DavidDi
*/


// Headers
///////////

#ifdef LZA_DLL
#include <windows.h>
#include <port1632.h>
#endif

#include <lzdos.h>
#include "translat.h"


// Set up type for function argument pointers.
#ifdef LZA_DLL
#define ARG_PTR         FAR
#else
#define ARG_PTR         // nada
#endif


// Constants
/////////////

#define chEXTENSION_CHAR      '_'
#define pszEXTENSION_STR      "_"
#define pszNULL_EXTENSION     "._"

#define NOTIFY_START_COMPRESS 0        // file processing notifications
#define NOTIFY_START_EXPAND   1        //
#define NOTIFY_START_COPY     2        //

#define BLANK_ERROR           0        // error condition requiring no error
                                       // message display


// Types
/////////

// Callback notification procedure.
typedef BOOL (*NOTIFYPROC)(CHAR ARG_PTR *pszSource, CHAR ARG_PTR *pszDest,
                           WORD wProcessFlag);

// Flag indicating whether or not rgbyteInBuf[0], which holds the last byte
// from the previous input buffer, should be read as the next input byte.
// (Only used so that at least one unReadUChar() can be done at all input
// buffer positions.)

typedef struct tagLZI {
   BYTE *rgbyteRingBuf;  // ring buffer for expansion
   BYTE *rgbyteInBuf;    // input buffer for reads
   BYTE *pbyteInBufEnd;  // pointer past end of rgbyteInBuf[]
   BYTE *pbyteInBuf;     // pointer to next byte to read from
   BYTE *rgbyteOutBuf;   // output buffer for writes
   BYTE *pbyteOutBufEnd; // pointer past end of rgbyteOutBuf[]
   BYTE *pbyteOutBuf;    // pointer to last byte to write from
   // Flag indicating whether or not rgbyteInBuf[0], which holds the last byte
   // from the previous input buffer, should be read as the next input byte.
   // (Only used so that at least one unReadUChar() can be done at all input
   // buffer positions.)
   BOOL bLastUsed;
   // Actually, rgbyteInBuf[] has length (ucbInBufLen + 1) since rgbyteInBuf[0]
   // is used when bLastUsed is TRUE.
   INT cbMaxMatchLen;         // longest match length for current algorithm
   LONG cblInSize,       // size in bytes of input file
        cblOutSize;      // size in bytes of output file
   DWORD ucbInBufLen,    // length of input buffer
        ucbOutBufLen;    // length of output buffer
   DWORD uFlags;        // LZ decoding description byte
   INT iCurRingBufPos;     // ring buffer offset
   INT *leftChild;      // parents and left and right
   INT *rightChild;     // children that make up the
   INT *parent;         // binary search trees

   INT iCurMatch,          // index of longest match (set by LZInsertNode())
       cbCurMatch;         // length of longest match (set by LZInsertNode())

} LZINFO;


typedef LZINFO *PLZINFO;


// Macros
//////////

#define FOREVER   for(;;)

#ifndef MAX
#define MAX(a, b)             (((a) > (b)) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a, b)             (((a) < (b)) ? (a) : (b))
#endif


// Prototypes
//////////////

// compress.c
extern INT Compress(NOTIFYPROC pfnNotify, CHAR ARG_PTR *pszSource,
                    CHAR ARG_PTR *pszDest, BYTE byteAlgorithm,
                    BOOL bDoRename, PLZINFO pLZI);

// expand.c
extern INT Expand(NOTIFYPROC pfnNotify, CHAR ARG_PTR *pszSource,
                  CHAR ARG_PTR *pszDest, BOOL bDoRename, PLZINFO pLZI);
extern INT ExpandOrCopyFile(INT doshSource, INT doshDest, PLZINFO pLZI);

// dosdir.asm
extern INT GetCurDrive(VOID);
extern INT GetCurDir(LPSTR lpszDirBuf);
extern INT SetDrive(INT wDrive);
extern INT SetDir(LPSTR lpszDirName);
extern INT IsDir(LPSTR lpszDir);
extern INT IsRemoveable(INT wDrive);

// utils.c
extern CHAR ARG_PTR *ExtractFileName(CHAR ARG_PTR *pszPathName);
extern CHAR ARG_PTR *ExtractExtension(CHAR ARG_PTR *pszFileName);
extern VOID MakePathName(CHAR ARG_PTR *pszPath, CHAR ARG_PTR *pszFileName);
extern CHAR MakeCompressedName(CHAR ARG_PTR *pszFileName);
extern LPWSTR ExtractFileNameW(LPWSTR pszPathName);
extern LPWSTR ExtractExtensionW(LPWSTR pszFileName);
extern WCHAR MakeCompressedNameW(LPWSTR pszFileName);
extern VOID MakeExpandedName(CHAR ARG_PTR *pszFileName,
                             BYTE byteExtensionChar);
extern INT CopyDateTimeStamp(INT_PTR doshFrom, INT_PTR doshTo);

extern BOOL  LZIsCharLowerA(char cChar);
extern BOOL  LZIsCharUpperA(char cChar);
extern LPSTR LZCharNextA(LPCSTR lpCurrentChar);
extern LPSTR LZCharPrevA(LPCSTR lpStart, LPCSTR lpCurrentChar);

#undef IsCharLower
#undef IsCharUpper
#undef CharNext
#undef CharPrev
#define IsCharLower LZIsCharLowerA
#define IsCharUpper LZIsCharUpperA
#define CharNext    LZCharNextA
#define CharPrev    LZCharPrevA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\lz_header.h ===
/*
** header.h - Common information used in compressed file header manipulation.
**
** Author:  DavidDi
*/


// Constants
/////////////

// compressed file signature: "SZDD'3"
#define COMP_SIG        "SZDD\x88\xf0\x27\x33"

#define COMP_SIG_LEN    8              // length of signature (bytes)
                                       // (no '\0' terminator)

#define ALG_FIRST       ((BYTE) 'A')   // first version algorithm label for
                                       // Lempel-Ziv
#define ALG_LZ          ((BYTE) 'B')   // new Lempel-Ziv algorithm label
#define ALG_LZA         ((BYTE) 'C')   // Lempel-Ziv with arithmetic encoding
                                       // algorithm label

// length of entire compressed file header (used as offset to start of
// compressed data)
#define HEADER_LEN      14
// (14 == cbCompSigLength + algorithm + extension character
//        + uncompressed length)

#define BYTE_MASK       0xff           // mask used to isolate low-order byte


// Types
/////////

// Declare compressed file header information structure.  N.b., the
// compressed file header does not contain the file size of the compressed
// file since this is readily obtainable through filelength() or lseek().
// The file info structure, however, does contain the compressed file size,
// which is used when expanding the file.
typedef struct tagFH
{
   BYTE rgbyteMagic[COMP_SIG_LEN];  // array of compressed file signature
                                    // (magic bytes)

   BYTE byteAlgorithm;              // algorithm label
   BYTE byteExtensionChar;          // last extension character
                                    // (always 0 for ALG_FIRST)

   // The file sizes are unsigned longs instead of signed longs for backward
   // compatibilty with version 1.00.
   DWORD cbulUncompSize;    // uncompressed file size
   DWORD cbulCompSize;      // compressed file size (not stored in
                                    // header)
} FH;
typedef struct tagFH *PFH;


// Macros
//////////

#if 0
#define RecognizeCompAlg(chAlg)  ((chAlg) == ALG_FIRST || \
                                  (chAlg) == ALG_LZ    || \
                                  (chAlg) == ALG_LZA)
#else
#define RecognizeCompAlg(chAlg)  ((chAlg) == ALG_FIRST)
#endif


// Prototypes
//////////////

// header.c
extern INT WriteHdr(PFH pFH, INT doshDest, PLZINFO pLZI);
extern INT GetHdr(PFH pFH, INT doshSource, LONG * pcblInSize);
extern BOOL IsCompressed(PFH pFHIn);
extern VOID MakeHeader(PFH pFHBlank, BYTE byteAlgorithm, BYTE byteExtensionChar,
   PLZINFO pLZI);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\translat.h ===
/*
** translat.h - Translation macros for common DOS / Windows functions.
**
** Author:  DavidDi (stolen from ToddLa)
*/


#ifndef WM_USER

/********************************* DOS code ********************************/

// Globals
///////////

INT _ret;
INT _error;


// Types
/////////

typedef  unsigned CHAR   BYTE;
typedef unsigned SHORT  WORD;
typedef unsigned LONG   DWORD;
typedef INT             BOOL;
typedef CHAR *          PSTR;
typedef CHAR NEAR *     NPSTR;
typedef CHAR FAR *      LPSTR;
typedef INT  FAR *      LPINT;


// Constants
/////////////

// NULL

#ifndef NULL
   #if (_MSC_VER >= 600)
      #define NULL ((void *)0)
   #elif (defined(M_I86SM) || defined(M_I86MM))
      #define NULL 0
   #else
      #define NULL 0L
   #endif
#endif

// modifiers

#define FAR    FAR
#define NEAR   near
#define LONG   long
#define VOID   void
#define PASCAL PASCAL

// Boolean values

#define FALSE  0
#define TRUE   1


// Macros
//////////

// byte manipulation

#define LOWORD(l)       ((WORD)(l))
#define HIWORD(l)       ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)       ((BYTE)(w))
#define HIBYTE(w)       (((WORD)(w) >> 8) & 0xFF)
#define MAKELONG(a, b)  ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))

// file i/o

//-protect-
#define FOPEN(psz)               (                                              \
                                    (_ret = -1),                                \
                                    (_error = _dos_open(psz, O_RDONLY, &_ret)), \
                                    _ret                                        \
                                 )

//-protect-
#define FCREATE(psz)             (                                                \
                                    (_ret = -1),                                  \
                                    (_error = _dos_creat(psz, _A_NORMAL, &_ret)), \
                                    _ret                                          \
                                 )

#define FCLOSE(dosh)             (_error = _dos_close(dosh))

//-protect-
#define FREAD(dosh, buf, len)    (                                               \
                                    (_error = _dos_read(dosh, buf, len, &_ret)), \
                                    _ret                                         \
                                 )

//-protect-
#define FWRITE(dosh, buf, len)   (                                                \
                                    (_error = _dos_write(dosh, buf, len, &_ret)), \
                                    _ret                                          \
                                 )

#define FSEEK(dosh, off, i)      lseek(dosh, (long)(off), i)

#define FERROR()                 _error

// near heap memory management

#define ALLOC(n)                 malloc(n)
#define FREE(p)                  free(p)
#define SIZE(p)                  _msize(p)
#define REALLOC(p, n)            realloc(p,n)

// FAR heap memory management

#define FALLOC(n)                _fmalloc(n)
#define FFREE(n)                 _ffree(n)

// string manipulation

#define STRCAT(psz1, psz2)       strcat(psz1, psz2)
#define STRCMP(psz1, psz2)       strcmp(psz1, psz2)
#define STRCMPI(psz1, psz2)      strcmpi(psz1, psz2)
#define STRCPY(psz1, psz2)       strcpy(psz1, psz2)
#define STRLEN(psz)              strlen(psz)
#define STRLWR(psz)              strlwr(psz)
#define STRUPR(psz)              strupr(psz)

// character classification

#define ISALPHA(c)               isalpha(c)
#define ISALPHANUMERIC(c)        isalnum(c)
#define ISLOWER(c)               islower(c)
#define ISUPPER(c)               isupper(c)

#else

/******************************* Windows code ******************************/

// file i/o

#ifdef ORGCODE
#define FOPEN(psz)               _lopen(psz, READ)
#else
#define FOPEN(psz)               _lopen(psz, OF_READ)
#endif
#define FCREATE(psz)             _lcreat(psz, 0)
#define FCLOSE(dosh)             _lclose(dosh)
#define FREAD(dosh, buf, len)    _lread(dosh, buf, len)
#define FWRITE(dosh, buf, len)   _lwrite(dosh, buf, len)
#define FSEEK(dosh, off, i)      _llseek(dosh, (DWORD)off, i)
#define FERROR()                 0

// near heap memory management

#define ALLOC(n)                 (VOID *)LocalAlloc(LPTR, n)
#define FREE(p)                  LocalFree(p)
#define SIZE(p)                  LocalSize(p)
#define REALLOC(p, n)            LocalRealloc(p, n, LMEM_MOVEABLE)

// FAR heap memory management

#ifdef ORGCODE
#define FALLOC(n)                (VOID FAR *)MAKELONG(0, GlobalAlloc(GPTR, (DWORD)n))
#define FFREE(n)                 GlobalFree((HANDLE)HIWORD((LONG)n))
#else
#define FALLOC(n)                GlobalAlloc(GPTR, (DWORD)n)
#define FFREE(n)                 GlobalFree((HANDLE)n)
#endif	
// string manipulation

#define STRCAT(psz1, psz2)       lstrcat(psz1, psz2)
#define STRCMP(psz1, psz2)       lstrcmp(psz1, psz2)
#define STRCMPI(psz1, psz2)      lstrcmpi(psz1, psz2)
#define STRCPY(psz1, psz2)       lstrcpy(psz1, psz2)
#define STRLEN(psz)              lstrlen(psz)
#define STRLWR(psz)              AnsiLower(psz)
#define STRUPR(psz)              AnsiUpper(psz)

// character classification

#define ISALPHA(c)               IsCharAlpha(c)
#define ISALPHANUMERIC(c)        IsCharAlphaNumeric(c)
#define ISLOWER(c)               IsCharLower(c)
#define ISUPPER(c)               IsCharUpper(c)

#endif

/******************************* common code *******************************/


// Constants
/////////////

#define SEP_STR   "\\"

#define EQUAL     '='
#define SPACE     ' '
#define COLON     ':'
#define PERIOD    '.'

#define LF        0x0a
#define CR        0x0d
#define CTRL_Z    0x1a

// flags for _lseek

#define SEEK_SET  0
#define SEEK_CUR  1
#define SEEK_END  2


// Macros
//////////

// character classification

#define ISWHITE(c)      ((c) == ' '  || (c) == '\t' || (c) == '\n' || (c) == '\r')
#define ISFILL(c)       ((c) == ' '  || (c) == '\t')
#define ISEOL(c)        ((c) == '\n' || (c) == '\r' || (c) == '\0' || (c) == CTRL_Z)
#define ISCRLF(c)       ((c) == '\n' || (c) == '\r')
#define ISDIGIT(c)      ((c) >= '0'  && (c) <= '9')
#define ISLETTER(c)     (((c) >= 'A' && (c) <= 'Z') || ((c) >= 'a' && (c) <= 'z'))
#define ISSWITCH(c)     ((c) == '/' || (c) == '-')
#define ISSLASH(c)      ((c) == '/' || (c) == '\\')

// character manipulation

#define TOUPPERCASE(c)  ((c) >= 'a' && (c) <= 'z' ? (c) - 'a' + 'A' : (c))
#define TOLOWERCASE(c)  ((c) >= 'A' && (c) <= 'Z' ? (c) - 'A' + 'a' : (c))
#define HEXVALUE(c)     (ISDIGIT(c) ? (c) - '0' : TOUPPERCASE(c) - 'A' + 10)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\shstart.c ===
/*
 * pmdos.c
 *
 *  Copyright (c) 1991,  Microsoft Corporation
 *
 *  DESCRIPTION
 *
 *              This file is for support of program manager under NT Windows.
 *              This file is/was ported from pmdos.asm (program manager).
 *              It was in x86 asm code, and now is in ansi C.
 *              Some functions will be removed, due to they are only needed
 *              by DOS Windows.
 *
 *  MODIFICATION HISTORY
 *      Initial Version: x/x/90 Author Unknown, since he didn't feel
 *                                                              like commenting the code...
 *
 *      NT 32b Version:  1/9/91 Jeff Pack
 *                                                              Intitial port to begin.
 *
 *  WARNING:  since this is NOT for DOS, I'm making it soley 32bit aware.
 *                        Following functions not ported
 *                                      IsRemovable() is in pmcomman.c (already ifdef'd in asm code)
 *                                      IsRemote()  is in pmcomman.c   (ditto!)
 *
 */


#ifndef ORGCODE
#include <io.h>
#include <string.h>
#include <ctype.h>
#endif
#include "windows.h"
#include <port1632.h>

BOOL PathType(LPSTR);
DWORD FileTime(HFILE);
DWORD GetDOSErrorCode(VOID);
int GetCurrentDrive(VOID);
int w_GetCurrentDirectory(int, LPSTR);
int w_SetCurrentDirectory(LPSTR);
int DosDelete(LPSTR);
LPSTR lmemmove(LPSTR, LPSTR, WORD);
BOOL  FAR PASCAL IsRemoteDrive(int);
BOOL  FAR PASCAL IsRemovableDrive(int);

#define LOCALBUFFERSIZE 128


/*** PathType --        Determines if string denotes a directory or not.
 *
 *
 *
 * BOOL PathType(LPSTR pszFileString)
 *
 * ENTRY -      LPSTR pszFileString     - pointer to string to use to determine if directory
 *                                                               or not.
 *                                                window, with focus.
 * EXIT  -      int iReturnValue        - 2 = is directory   1 = Is Not directory
 *
 * SYNOPSIS -  This function takes a pointer to a string, calls OS to determine
 *                              if string is, or is not a directory.
 * WARNINGS -  Cna't even see where this is called!
 * EFFECTS  -
 *
 */


BOOL PathType(LPSTR lpszFileString)
{

        LPSTR   lpszLocalBuffer;                                /*local buffer for AnsiToOem()*/
        DWORD   dwReturnedAttributes;
        DWORD   nBufferLength;

        nBufferLength = strlen(lpszFileString) + 1;
        /*alloc local, non-moveable, zero filled buffer*/
        lpszLocalBuffer = LocalAlloc(LMEM_ZEROINIT, nBufferLength);
        if(lpszLocalBuffer == NULL){
#if DBG
                OutputDebugString("<PathType> LocalAlloc FAILed\n");
#endif /* DBG */
                return 0;
        }

        AnsiToOem(lpszFileString, lpszLocalBuffer);

        /*get attributes of filestring*/
        dwReturnedAttributes = GetFileAttributes(lpszLocalBuffer);
        if(dwReturnedAttributes == -1){
#if DBG
                OutputDebugString("<PathType> - GetFileAttributes() FAILed!\n");
#endif /* DBG */
                LocalFree(lpszLocalBuffer);
                return(0);
        }
        else{
                /*and with directory attribute*/
                dwReturnedAttributes = dwReturnedAttributes & FILE_ATTRIBUTE_DIRECTORY;
                switch(dwReturnedAttributes){

                        case FILE_ATTRIBUTE_DIRECTORY:
                                LocalFree(lpszLocalBuffer);
                                return(2);
                                break;

                        default:
                                LocalFree(lpszLocalBuffer);
                                return(1);
                }

        }

}


/*** FileTime --        Gets time of last modification.
 *
 *
 *
 * DWORD FileTime(HFILE hFile)
 *
 * ENTRY -      int hFile       - file handle to access
 *
 * EXIT  -      LPWORD   - which is gotten from lpTimeStamp = 0 (ERROR).
 *                                         or lpTimeStamp != 0 (value of timestamp)
 *
 * SYNOPSIS -  calls GetFileTime() to get timestamp. If error, then
 *                              lpTimeStamp = 0, else contains TimeStamp for file.
 * WARNINGS -
 * EFFECTS  -
 *
 */

DWORD FileTime(
    HFILE hFile)
{
        BOOL            bReturnCode;
        FILETIME        CreationTime;
        FILETIME        LastAccessTime;
        FILETIME        LastWriteTime;
        WORD            FatTime = 0;
        WORD            FatDate;

        bReturnCode = GetFileTime(LongToHandle(hFile), &CreationTime, &LastAccessTime,
            &LastWriteTime);

        /*
     * Test return code
     */
        if (bReturnCode == FALSE) {
                return 0;               /*set to zero, for error*/
        }

        /*
     * Now convert 64bit time to DOS 16bit time
     */
        FileTimeToDosDateTime( &LastWriteTime, &FatDate, &FatTime);
        return FatTime;
}


/*** IsReadOnly --      determines if file is readonly or not.
 *
 *
 *
 * BOOL IsReadOnly(LPSTR lpszFileString)
 *
 * ENTRY -      LPSTR lpszFileString    - file name to use
 *
 * EXIT  -      BOOL xxx - returns (0) = not readonly  (1) = read only
 *                                         or lpTimeStamp != 0 (value of timestamp)
 *
 * SYNOPSIS -  calls GetAttributes, then tests if file is read only.
 * WARNINGS -
 * EFFECTS  -
 *
 */


BOOL IsReadOnly(LPSTR lpszFileString)
{

        DWORD   dwReturnedAttributes;
        LPSTR   lpszLocalBuffer;                                /*local buffer for AnsiToOem()*/
        DWORD   nBufferLength;

        nBufferLength = strlen(lpszFileString) + 1;
        /*alloc local, non-moveable, zero filled buffer*/
        lpszLocalBuffer = LocalAlloc(LMEM_ZEROINIT, nBufferLength);
        if(lpszLocalBuffer == NULL){
#if DBG
                OutputDebugString("<IsReadOnly> LocalAlloc FAILed\n");
#endif /* DBG */
                return 0;
        }

        AnsiToOem(lpszFileString, lpszLocalBuffer);

        /*get attributes of filestring*/
        dwReturnedAttributes = GetFileAttributes(lpszLocalBuffer);
        if(dwReturnedAttributes == -1){
#if DBG
            OutputDebugString("<IsReadOnly> - GetFileAttributes() FAILed!\n");
#endif /* DBG */
            LocalFree(lpszLocalBuffer);
            return FALSE;
        } else {
                /*AND with read_only attribute*/
                dwReturnedAttributes = dwReturnedAttributes & FILE_ATTRIBUTE_READONLY;
                switch(dwReturnedAttributes){

                        case FILE_ATTRIBUTE_READONLY:
                                LocalFree(lpszLocalBuffer);
                                return TRUE;
                                break;

                        default:
                                LocalFree(lpszLocalBuffer);
                                return FALSE;
                }

        }

}

/*** GetDOSErrorCode -- returns extended error code
 *
 *
 *
 * DWORD GetDOSErrorCode(VOID)
 *
 * ENTRY -      VOID
 *
 * EXIT  -      DWORD - returned extended code.
 *
 * SYNOPSIS - calls GetLastError() to get error code from OS
 * WARNINGS -
 * EFFECTS  -
 *
 */

DWORD GetDOSErrorCode(VOID)
{

        return( (int) GetLastError());

        /*BUG BUG, pmgseg.c uses this from _lcreat() to determine if returned
                5 (access denied) or 13 (invalid_data).  So this need be tested
                to see if win32 returns these.*/

}

/*** GetCurrentDrive -- get current drive number.
 *
 *
 *
 * int GetCurrentDrive(VOID)
 *
 * ENTRY -      VOID
 *
 * EXIT  -      int CurrentDrive - drive number of current drive (0=a, etc).
 *
 * SYNOPSIS - calls GetCurrentDirectory, must parse returned string
 *                              for either drive letter, or UNC path.  If UNC I gotta
 *                              somehow, covert UNC path to drive letter to drive number.
 * WARNINGS -
 * EFFECTS  -
 *
 */

int GetCurrentDrive(VOID)
{
        /*BUG BUG, not DBCS aware!*/

        DWORD   nBufferLength = LOCALBUFFERSIZE;
        DWORD   dwReturnCode;
        LPSTR   lpszLocalBuffer;
        int             iDriveNumber;

        /*alloc local, non-moveable, zero filled buffer*/
        lpszLocalBuffer = LocalAlloc(LMEM_ZEROINIT, nBufferLength);
        if(lpszLocalBuffer == NULL){
#if DBG
            OutputDebugString("<GetCurrentDrive> LocalAlloc FAILed\n");
#endif /* DBG */
            return 0;
        }

GetCurDrive1:
        dwReturnCode = GetCurrentDirectory(nBufferLength, lpszLocalBuffer);

        /*failed for reason other than bufferlength too small*/
        if(dwReturnCode == 0){
#if DBG
                OutputDebugString("<GetCurrentDrive>  GetCurrentDirectory() FAILed\n");
#endif /* DBG */
                LocalFree(lpszLocalBuffer);
                return 0;
        }
        /*test for success, if dwReturnCode is > buffer, then need increase buffer*/
        if(dwReturnCode > nBufferLength){
            PVOID pv = LocalReAlloc(lpszLocalBuffer, nBufferLength + LOCALBUFFERSIZE, LMEM_ZEROINIT | LMEM_MOVEABLE);
            if (!pv) {
#if DBG
                OutputDebugString("<GetCurrentDrive> LocalAlloc FAILed\n");
#endif /* DBG */
                LocalFree(lpszLocalBuffer);
                return 0;
            } else {
                lpszLocalBuffer = pv;
                nBufferLength += LOCALBUFFERSIZE;
            }
            goto GetCurDrive1;
        }

        /*finally lpszLocalBuffer has string containing current directory*/
        /* now must parse string for ":" or "\\" for drive letter or UNC*/
        /*if : then get drive letter, and convert to number a=0, b=1, etc.*/
        /*if \\ then gotta enumerate net drives, to learn what drive letter*/
        /*corresponds to that UNC path*/

        /*check for drive letter*/
        if(lpszLocalBuffer[1] == ':'){
                /*is drive letter, proceed*/
                if(isupper(lpszLocalBuffer[0])){
                        iDriveNumber = lpszLocalBuffer[0] - 'A';        /*convert letter > number*/
                }
                else{
                        iDriveNumber = lpszLocalBuffer[0] - 'a';        /*convert letter > number*/
                }
        }
        else{
                /*must be UNC path*/

                /*BUG BUG need write code to convert UNC path   */
#if DBG
                OutputDebugString("<GetCurrentDrive> Got UNC path, didnt expect, and no code!\n");
#endif /* DBG */
        }

        LocalFree(lpszLocalBuffer);
        return(iDriveNumber);
}

/*** SetCurrentDrive -- set current drive.
 *
 *
 *
 * int SetCurrentDrive(int iDrive)
 *
 * ENTRY -      int iDrive - drive number to set as current drive
 *
 * EXIT  -      int xxx - under DOS would have returned # of logical drives.
 *              I can do this, but it's not used, if fact, no error
 *              checks are done on this return value.
 *
 * SYNOPSIS - calls SetCurrentDirectory to set current drive.
 * WARNINGS -  ALWAYS sets to root directory, since can't get cur dir
 *                              on other than current working drive.
 * EFFECTS  -
 *
 */

int SetCurrentDrive(int iDrive)
{

        char    cLocalBuffer[LOCALBUFFERSIZE] = "C:\\";
        char    cDriveLetter;

        /*convert drive number (zero based) to letter*/
        cDriveLetter = (char) iDrive + (char)'A';
        cLocalBuffer[0] = cDriveLetter;         /*set new drive in string*/

        if(!SetCurrentDirectory(cLocalBuffer)){
                /*call failed*/
#if DBG
                OutputDebugString("<SetCurrentDrive> SetCurrentDirectory FAILed!\n");
#endif /* DBG */
                return 0;
        }
        return(0);
}

/*** w_GetCurrentDirectory -- GetCurrent Working Directory
 *
 *
 *
 * int w_GetCurrentDirectory(int iDrive, LPSTR lpszCurrentDirectory)
 *
 * ENTRY -      int iDrive - drive number to use as current drive.
 *                      LPSTR lpszCurrentDirectory - pointer to return data to.
 *
 * EXIT  -      int iReturnCode - returns (0) if success
 *                      LPSTR lpszCurrentDirectory - has curretn directory.
 *
 * SYNOPSIS - calls GetCurrentDirectory to get current directory.
 *                              the original asm code, checked idrive for zero, if so
 *                              then calls GetCurrentDrive.  Under win32, is not neccessary,
 *                              since GetCUrrentDirectory()     returns current drive.
 *                              Since it checks this, it means then that other than current
 *                              drive can be checked, yet win32 doesnt allow this, so I have to
 *                              code in a debug check, if iDrive != current drive.
 * WARNINGS -   win32 doesn't allow multiple cur dirs across drives.
 * EFFECTS  -
 *
 */

int w_GetCurrentDirectory(int iDrive, LPSTR lpszCurrentDirectory)
{
        /*first see if iDrive == 0, if so then only need call GetCurrentDirectory*/
        /*if non-zero, then could be current drive, OR another drive.*/
        /*THIS IS NOT ALLOWED!*/

        /*BUG BUG, not DBCS aware!*/

        DWORD   nBufferLength = LOCALBUFFERSIZE;
        DWORD   dwReturnCode;
        LPSTR   lpszLocalBuffer;
        int             iDriveNumber;

        /*alloc local, non-moveable, zero filled buffer*/
        lpszLocalBuffer = LocalAlloc(LMEM_ZEROINIT, nBufferLength);
        if(lpszLocalBuffer == NULL){
#if DBG
                OutputDebugString("<w_GetCurrentDirectory> LocalAlloc FAILed\n");
#endif /* DBG */
                return(1);
        }

GetCurDir1:
        dwReturnCode = GetCurrentDirectory(nBufferLength, lpszLocalBuffer);

        /*failed for reason other than bufferlength too small*/
        if(dwReturnCode == 0){
#if DBG
                OutputDebugString("<w_GetCurrentDirectory>  GetCurrentDirectory() FAILed\n");
#endif /* DBG */
                LocalFree(lpszLocalBuffer);
                return(1);
        }
        /*test for success, if dwReturnCode is > buffer, then need increase buffer*/
        if(dwReturnCode > nBufferLength){
            PVOID pv = LocalReAlloc(lpszLocalBuffer, nBufferLength + LOCALBUFFERSIZE, LMEM_ZEROINIT | LMEM_MOVEABLE);
            if (!pv) {
#if DBG
                OutputDebugString("<w_GetCurrentDirectory> LocalAlloc FAILed\n");
#endif /* DBG */
                LocalFree(lpszLocalBuffer);
                return(1);
            } else {
                lpszLocalBuffer = pv;
                nBufferLength += LOCALBUFFERSIZE;
            }
            goto GetCurDir1;
        }

        /*now I have string that contains EITHER current drive in a drive letter*/
        /*or current drive by a UNC name*/
        /*BUG BUG UNC name check uncoded, since I have to go from UNC name to drive letter*/

        /*debug code, to make sure iDrive == current drive*/
        /*see if drive letter based string*/
        if(lpszLocalBuffer[1] == ':'){
                /*is Drive letter based!*/
                /*never know case of returned string from kernel*/
                if(isupper(lpszLocalBuffer[0])){
                        iDriveNumber = lpszLocalBuffer[0] - 'A';
                }
                else{
                        iDriveNumber = lpszLocalBuffer[0] - 'a';
                }
                /*DEBUG make sure that we are indeed setting a new drive */
                /* remember that iDrive == 0 means use current drive!*/
                if(iDrive == iDriveNumber || iDrive == 0){
                        /*is current drive and drive letter based, set to after "x:\"*/
                        strcpy(lpszCurrentDirectory, lpszLocalBuffer);  /*copy directory to pointer*/
                }
                else{   /* is different drive, or not using current drive (== 0)*/
                        SetCurrentDrive(iDriveNumber);  /*set new drive "<iDrive>:\"   */
                        /*now that new drive/dir is set, return current dir*/
                        /* BUG BUG, because setting drive, overides cur dir, I return*/
                        /* "<newdrive>:\"     */
                        strcpy(lpszCurrentDirectory, "c:\\");
                        lpszCurrentDirectory[0]  = (char) (iDriveNumber + 'a'); /*set new drive*/
                }
        }
        else{
                /*is NOT drive letter based*/
                /* BUG BUG need write code to parse UNC, and return only the path*/

                /* BUG BUGalso need check to see if iDrive == UNC drive, so I gotta*/
                /* convert UNC path to drive, and compare*/

#if DBG
                OutputDebugString("<w_GetCurrentDirectory> Took path for UNC, and no code!\n");
#endif /* DBG */
                LocalFree(lpszLocalBuffer);
                return(1);
        }

        LocalFree(lpszLocalBuffer);
        return(0);                      /*success*/
}

/*** w_SetCurrentDirectory -- SetCurrent Working Directory and drive
 *
 * int w_SetCurrentDirectory(LPSTR lpszCurrentDirectory)
 *
 * ENTRY -      LPSTR lpszCurrentDirectory - string to set current drive/dir to
 *
 * EXIT  -      int iReturnCode - returns (0) if success
 *
 * SYNOPSIS - calls SetCurrentDirectory to set current directory and drive.
 * WARNINGS -
 * EFFECTS  -
 *
 */

int w_SetCurrentDirectory(LPSTR lpszCurrentDirectory)
{

        DWORD   dwReturnCode;

        dwReturnCode = SetCurrentDirectory(lpszCurrentDirectory);
        if(dwReturnCode == 0){
#if DBG
            OutputDebugString("<w_SetCurrentDirectory> SetCurrentDirectory FAILed!\n");
#endif /* DBG */
            return(1);
        }

        return(0);                      /*success*/
}

/*** DosDelete -- Delete named file.
 *
 * int DosDelete(LPSTR lpszFileToDelete)
 *
 * ENTRY -      LPSTR lpszFileToDelete - filename to delete.
 *
 * EXIT  -      int xxx - returns (0) if success
 *
 * SYNOPSIS - calls win32 DeleteFile.
 * WARNINGS -
 * EFFECTS  -
 *
 */

int DosDelete(LPSTR lpszFileToDelete)
{

        BOOL    bReturnCode;
        LPSTR   lpszLocalBuffer;                                /*local buffer for AnsiToOem()*/
        DWORD   nBufferLength;

        nBufferLength = strlen(lpszFileToDelete) + 1;
        /*alloc local, non-moveable, zero filled buffer*/
        lpszLocalBuffer = LocalAlloc(LMEM_ZEROINIT, nBufferLength);
        if(lpszLocalBuffer == NULL){
#if DBG
                OutputDebugString("<DosDelete> LocalAlloc FAILed\n");
#endif /* DBG */
                return 1;
        }


        AnsiToOem(lpszFileToDelete, lpszLocalBuffer);


        bReturnCode = DeleteFile(lpszLocalBuffer);
        LocalFree(lpszLocalBuffer);
        if(bReturnCode){
                return(0);
        }
        else{
                return(1);
        }
}

/*** DosRename -- Rename file.
 *
 * int DosRename(LPSTR lpszOrgFileName, LPSTR lpszNewFileName)
 *
 * ENTRY -      LPSTR lpszOrgFileName - origianl filename.
 *                      LPSTR lpszNewFileName - New filename.
 *
 * EXIT  -      int xxx - returns (0) if success
 *
 * SYNOPSIS - calls win32 MoveFile.
 * WARNINGS -
 * EFFECTS  -
 *
 */

int DosRename(LPSTR lpszOrgFileName, LPSTR lpszNewFileName)
{

        BOOL    bReturnCode;
        LPSTR   lpszLocalBuffer;                                /*local buffer for AnsiToOem()*/
        LPSTR   lpszLocalBuffer1;                               /*local buffer for AnsiToOem()*/
        DWORD   nBufferLength;
        DWORD   nBufferLength1;

        nBufferLength = strlen(lpszOrgFileName) + 1;
        nBufferLength1 = strlen(lpszNewFileName) + 1;
        /*alloc local, non-moveable, zero filled buffer*/
        lpszLocalBuffer = LocalAlloc(LMEM_ZEROINIT, nBufferLength);
        if(lpszLocalBuffer == NULL){
#if DBG
                OutputDebugString("<DosRename> LocalAlloc FAILed\n");
#endif /* DBG */
                return 1;
        }
        lpszLocalBuffer1 = LocalAlloc(LMEM_ZEROINIT, nBufferLength1);
        if(lpszLocalBuffer1 == NULL){
            OutputDebugString("<DosRename> LocalAlloc FAILed\n");
            LocalFree(lpszLocalBuffer);
            return 1;
        }

        AnsiToOem(lpszOrgFileName, lpszLocalBuffer);
        AnsiToOem(lpszNewFileName, lpszLocalBuffer1);

        /*rename file*/
        bReturnCode = MoveFile(lpszLocalBuffer, lpszLocalBuffer1);

        LocalFree(lpszLocalBuffer);
        LocalFree(lpszLocalBuffer1);

        if(bReturnCode){
                return(0);
        }
        else{
                return(1);
        }
}

/*** lmemmove -- move memory.
 *
 * LPSTR lmemmove(LPSTR lpszDst, LPSTR lpszSrc, WORD wCount)
 *
 * ENTRY -      LPSTR lpszDst - destination
 *                      LPSTR lpszSrc - source
 *                      WORD wCount     - number of chars to move.
 *
 * EXIT  -      LPSTR lpszDst - returns lpszDst.
 *
 * SYNOPSIS - calls c runtime.  Done cause they hacked lmemove to asm.
 * WARNINGS -
 * EFFECTS  -
 *
 */

LPSTR lmemmove(LPSTR lpszDst, LPSTR lpszSrc, WORD wCount)
{
    return(memmove(lpszDst, lpszSrc, wCount));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\utilsnls.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define FE_SB
#define IS_DBCS_ENABLED() (!!NLS_MB_CODE_PAGE_TAG)


/***************************************************************************\
* IsCharLowerA (API)
*
* History:
* 14-Jan-1991 mikeke from win 3.0
* 22-Jun-1991 GregoryW   Modified to support code page 1252 (Windows ANSI
*                        code page).  This is for the PDK only.  After the
*                        PDK this routine will be rewritten to use the
*                        NLSAPI.
* 02-Feb-1992 GregoryW   Modified to use NLS API.
\***************************************************************************/

BOOL  LZIsCharLowerA(
    char cChar)
{
    WORD ctype1info = 0;
    WCHAR wChar = 0;

#ifdef FE_SB // IsCharLowerA()
    /*
     * if only DBCS Leadbyte was passed, just return FALSE.
     * Same behavior as Windows 3.1J and Windows 95 FarEast version.
     */
    if (IS_DBCS_ENABLED() && IsDBCSLeadByte(cChar)) {
        return FALSE;
    }
#endif // FE_SB

    /*
     * The following 2 calls cannot fail here
     */
    RtlMultiByteToUnicodeN(&wChar, sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
    GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info);
    return (ctype1info & C1_LOWER) == C1_LOWER;
}


/***************************************************************************\
* IsCharUpperA (API)
*
* History:
* 22-Jun-1991 GregoryW   Created to support code page 1252 (Windows ANSI
*                        code page).  This is for the PDK only.  After the
*                        PDK this routine will be rewritten to use the
*                        NLSAPI.
* 02-Feb-1992 GregoryW   Modified to use NLS API.
\***************************************************************************/

BOOL  LZIsCharUpperA(
    char cChar)
{
    WORD ctype1info = 0;
    WCHAR wChar = 0;

#ifdef FE_SB // IsCharUpperA()
    /*
     * if only DBCS Leadbyte was passed, just return FALSE.
     * Same behavior as Windows 3.1J and Windows 95 FarEast version.
     */
    if (IS_DBCS_ENABLED() && IsDBCSLeadByte(cChar)) {
        return FALSE;
    }
#endif // FE_SB

    /*
     * The following 2 calls cannot fail here
     */
    RtlMultiByteToUnicodeN(&wChar, sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
    GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info);
    return (ctype1info & C1_UPPER) == C1_UPPER;
}

/***************************************************************************\
* CharNextA (API)
*
* Move to next character in string unless already at '\0' terminator
* DOES NOT WORK CORRECTLY FOR DBCS (eg: Japanese)
*
* History:
* 12-03-90 IanJa        Created non-NLS version.
* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.
*                       AnsiNext is now a #define which resolves to this
*                       routine.  This routine is only intended to support
*                       code page 1252 for the PDK release.
\***************************************************************************/

LPSTR LZCharNextA(
    LPCSTR lpCurrentChar)
{
#ifdef FE_SB // CharNextA(): dbcs enabling
    if (IS_DBCS_ENABLED() && IsDBCSLeadByte(*lpCurrentChar)) {
        lpCurrentChar++;
    }
    /*
     * if we have only DBCS LeadingByte, we will point string-terminaler.
     */
#endif // FE_SB

    if (*lpCurrentChar) {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;
}


/***************************************************************************\
* CharPrevA (API)
*
* Move to previous character in string, unless already at start
* DOES NOT WORK CORRECTLY FOR DBCS (eg: Japanese)
*
* History:
* 12-03-90 IanJa        Created non-NLS version.
* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.
*                       AnsiPrev is now a #define which resolves to this
*                       routine.  This routine is only intended to support
*                       code page 1252 for the PDK release.
\***************************************************************************/

LPSTR  LZCharPrevA(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar)
{
#ifdef FE_SB // CharPrevA : dbcs enabling
    if (lpCurrentChar > lpStart) {
        if (IS_DBCS_ENABLED()) {
            LPCSTR lpChar;
            BOOL bDBC = FALSE;

            for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
                if (!IsDBCSLeadByte(*lpChar))
                    break;
                bDBC = !bDBC;
            }

            if (bDBC)
                lpCurrentChar--;
        }
        else
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
#else
    if (lpCurrentChar > lpStart) {
        lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
#endif // FE_SB
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\lz32\winlza\utils.c ===
/*
** utils.c - Miscellaneous utility routines used in compression / expansion
**           modules.  Theoretically these functions are DBCS-enabled.
**
** Author:  DavidDi
*/


// Headers
///////////

#ifndef LZA_DLL
   #include <ctype.h>
   #include <string.h>
#endif

#include "lz_common.h"


/*
** char ARG_PTR *ExtractFileName(char ARG_PTR pszPathName);
**
** Find the file name in a fully specified path name.
**
** Arguments:  pszPathName - path string from which to extract file name
**
** Returns:    char ARG_PTR * - Pointer to file name in pszPathName.
**
** Globals:    none
*/
LPWSTR
ExtractFileNameW(
    LPWSTR pszPathName)
{
   LPWSTR pszLastComponent, psz;

   for (pszLastComponent = psz = pszPathName; *psz != L'\0'; psz++)
   {
      if (*psz == L'\\' || *psz == L':')
         pszLastComponent = psz + 1;
   }

   return(pszLastComponent);
}


CHAR ARG_PTR *ExtractFileName(CHAR ARG_PTR *pszPathName)
{
   CHAR ARG_PTR *pszLastComponent, ARG_PTR *psz;

   for (pszLastComponent = psz = pszPathName; *psz != '\0'; psz = CharNext(psz))
   {
      if (! IsDBCSLeadByte(*psz) && (ISSLASH(*psz) || *psz == COLON))
         pszLastComponent = CharNext(psz);
   }

   return(pszLastComponent);
}


/*
** char ARG_PTR *ExtractExtension(char ARG_PTR *pszFileName);
**
** Find the extension of a file name.
**
** Arguments:  pszFileName - file name to examine
**
** Returns:    char ARG_PTR * - Pointer to file name extension if one exists.
**                              NULL if the file name doesn't include an
**                              extension.
**
** Globals:    none
*/
LPWSTR
ExtractExtensionW(
    LPWSTR pszFileName)
{
   WCHAR *psz;

   // Make sure we have an isolated file name.
   psz = ExtractFileNameW(pszFileName);

   while (*psz != L'\0' && *psz != L'.')
      psz++;

   if (*psz == L'.')
      return(psz + 1);
   else
      return(NULL);
}


CHAR ARG_PTR *ExtractExtension(CHAR ARG_PTR *pszFileName)
{
   CHAR ARG_PTR *psz;

   // Make sure we have an isolated file name.
   psz = ExtractFileName(pszFileName);

   while (IsDBCSLeadByte(*psz) || (*psz != '\0' && *psz != PERIOD))
      psz = CharNext(psz);

   if (*psz == PERIOD)
      return(psz + 1);
   else
      return(NULL);
}


/*
** void MakePathName(char ARG_PTR *pszPath, char ARG_PTR *pszFileName);
**
** Append a filename to a path string.
**
** Arguments:  pszPath     - path string to which pszFileName will be appended
**             pszFileName - file name to append
**
** Returns:    void
**
** Globals:    none
*/
VOID MakePathName(CHAR ARG_PTR *pszPath, CHAR ARG_PTR *pszFileName)
{
   CHAR chLastPathChar;

   // Make sure we have an isolated file name.
   pszFileName = ExtractFileName(pszFileName);

   // Dont append to a NULL string or a single ".".
   if (*pszFileName != '\0' &&
       ! (! IsDBCSLeadByte(pszFileName[0]) && pszFileName[0] == PERIOD &&
          ! IsDBCSLeadByte(pszFileName[1]) && pszFileName[1] == '\0'))
   {
      chLastPathChar = *CharPrev(pszPath, pszPath + STRLEN(pszPath));

      //NTRAID:MSKKBUG #3411    Nov.09.93   v-hajimy
      if (! ISSLASH(chLastPathChar) && chLastPathChar != COLON)
         STRCAT(pszPath, SEP_STR);

      STRCAT(pszPath, pszFileName);
   }
}


/*
** char MakeCompressedName(char ARG_PTR *pszFileName);
**
** Make a file name into the corresponding compressed file name.
**
** Arguments:  pszOriginalName - file name to convert to compressed file name
**
** Returns:    char - Uncompressed file name extension character that was
**                    replaced.  '\0' if no character needed to be replaced.
**
** Globals:    none
**
** N.b., assumes pszFileName's buffer is long enough to hold an extra two
** characters ("._").
**
** For DBCS filenames, we know we can have at most one DBCS character in the
** extension.  So instead of just blindly replacing the last character of a
** three-byte extension with an underscore, we replace the last single-byte
** character with an underscore.
*/

#define chEXTENSION_CHARW      L'_'
#define pszEXTENSION_STRW      L"_"
#define pszNULL_EXTENSIONW     L"._"

WCHAR
MakeCompressedNameW(
    LPWSTR pszFileName)
{
   WCHAR chReplaced = L'\0';
   WCHAR ARG_PTR *pszExt;

   if ((pszExt = ExtractExtensionW(pszFileName)) != NULL)
   {
      if (lstrlenW(pszExt) >= 3)
      {
         chReplaced = pszExt[lstrlenW(pszExt) - 1];
         pszExt[lstrlenW(pszExt) - 1] = chEXTENSION_CHARW;
      }
      else
         lstrcatW(pszExt, pszEXTENSION_STRW);
   }
   else
      lstrcatW(pszFileName, pszNULL_EXTENSIONW);

   return(chReplaced);
}



CHAR MakeCompressedName(CHAR ARG_PTR *pszFileName)
{
    CHAR chReplaced = '\0';
    ULONG NameLength = STRLEN( pszFileName );
    ULONG DotIndex   = NameLength;

    while (( DotIndex > 0 ) && ( pszFileName[ --DotIndex ] != '.' )) {
        if (( pszFileName[ DotIndex ] == '\\' ) ||
            ( pszFileName[ DotIndex ] == ':' )) {   // end of filename part of path
            DotIndex = 0;                       // name has no extension
            break;
            }
        }

    if ( DotIndex > 0 ) {                       // name has an extension
        if (( NameLength - DotIndex ) <= 3 ) {  // extension less than 3 chars
            pszFileName[ NameLength++ ] = '_';  // append '_' to extension
            pszFileName[ NameLength ] = 0;      // terminate
            }
        else {                                  // extension more than 3 chars
            chReplaced = pszFileName[ NameLength - 1 ]; // return original
            pszFileName[ NameLength - 1 ] = '_';   // replace last char with '_'
            }
        }
    else {                                      // name has no extension
        pszFileName[ NameLength++ ] = '.';      // append '.'
        pszFileName[ NameLength++ ] = '_';      // append '_'
        pszFileName[ NameLength ] = 0;          // terminate
        }

    return(chReplaced);
}


/*
** void MakeExpandedName(char ARG_PTR *pszFileName, BYTE byteExtensionChar);
**
** Create expanded output file name.
**
** Arguments:  pszFileName       - expanded file name to change
**             byteExtensionChar - expanded file name extension character to
**                                 use
**
** Returns:    void
**
** Globals:    none
*/
VOID MakeExpandedName(CHAR ARG_PTR *pszFileName, BYTE byteExtensionChar)
{
   CHAR ARG_PTR *pszExt;
   INT nExtLen;

   // Is there any extension to change?
   if ((pszExt = ExtractExtension(pszFileName)) != NULL)
   {
      // Determine case of extension character.  Match case of first non-DB
      // character in name.  If all characters are DB, leave case alone.

      if (ISLETTER(byteExtensionChar))
      {
         // Find first alphabetic character in name.
         while (*pszFileName)
         {
            if (IsDBCSLeadByte(*pszFileName))
               pszFileName += 2;
            else if (ISLETTER(*pszFileName))
               break;
            else
               pszFileName++;
         }

         // Here pszFileName points to the first alphabetic character in the
         // name or to the null terminator.  Set the case of the extension
         // character.

         if (ISLOWER(*pszFileName))
            byteExtensionChar = (BYTE)TOLOWERCASE(byteExtensionChar);
         else if (ISUPPER(*pszFileName))
            byteExtensionChar = (BYTE)TOUPPERCASE(byteExtensionChar);
      }

      if ((nExtLen = STRLEN(pszExt)) > 0)
      {
         // Find the underscore character to replace, if it exists.

         // Assert: The underscore is either the last character in the
         // extension, or it is the first character in the extension followed
         // by a double-byte character.

         if (! IsDBCSLeadByte(*pszExt) && *pszExt == chEXTENSION_CHAR &&
             IsDBCSLeadByte(pszExt[1]))
            // Here the underscore is followed by a double-byte character.
            *pszExt = byteExtensionChar;
         else
         {
            // Here the underscore is the last character in the extension, if
            // there is an underscore at all.
            CHAR ARG_PTR *psz, *pszPrevious;

            for (psz = pszPrevious = pszExt; *psz != '\0'; psz = CharNext(psz))
               pszPrevious = psz;

            if (! IsDBCSLeadByte(*pszPrevious) &&
                *pszPrevious == chEXTENSION_CHAR)
               *pszPrevious = byteExtensionChar;
         }
      }

      // Get rid of trailing dot with no extension.
      if (*pszExt == '\0' && *(pszExt - 1) == PERIOD)
         *(pszExt - 1) = '\0';
   }
}


/*
** int CopyDateTimeStamp(INT_PTR doshFrom, INT_PTR doshTo);
**
** Copy date and time stamp from one file to another.
**
** Arguments:  doshFrom - date and time stamp source DOS file handle
**             doshTo   - target DOS file handle
**
** Returns:    TRUE if successful.  LZERROR_BADINHANDLE or
**             LZERROR_BADOUTHANDLE if unsuccessful.
**
** Globals:    none
**
** N.b., stream-style I/O routines like fopen() and fclose() may counter the
** intended effect of this function.  fclose() writes the current date to any
** file it's called with which was opened in write "w" or append "a" mode.
** One way to get around this in order to modify the date of a file opened
** for writing or appending by fopen() is to fclose() the file and fopen() it
** again in read "r" mode.  Then set its date and time stamp with
** CopyDateTimeStamp().
*/
INT CopyDateTimeStamp(INT_PTR doshFrom, INT_PTR doshTo)
{
#ifdef ORGCODE
   // DOS prototypes from <dos.h>
   extern DWORD _dos_getftime(INT dosh, DWORD *puDate, DWORD *puTime);
   extern DWORD _dos_setftime(INT dosh, DWORD uDate, DWORD uTime);

#ifdef LZA_DLL
   static
#endif
   DWORD uFrom_date,    // temporary storage for date
         uFrom_time;    // and time stamps

   if (_dos_getftime(doshFrom, &uFrom_date, &uFrom_time) != 0u)
      return((INT)LZERROR_BADINHANDLE);

   if (_dos_setftime(doshTo, uFrom_date, uFrom_time) != 0u)
      return((INT)LZERROR_BADOUTHANDLE);
#else

    FILETIME lpCreationTime, lpLastAccessTime, lpLastWriteTime;

   if(!GetFileTime((HANDLE) doshFrom, &lpCreationTime, &lpLastAccessTime,
                    &lpLastWriteTime)){
      return((INT)LZERROR_BADINHANDLE);
   }
   if(!SetFileTime((HANDLE) doshTo, &lpCreationTime, &lpLastAccessTime,
                    &lpLastWriteTime)){
      return((INT)LZERROR_BADINHANDLE);
   }

#endif
   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\basesrv.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basesrv.h

Abstract:

    This is the main include file for the Windows 32-bit Base API Server
    DLL.

Author:

    Steve Wood (stevewo) 10-Oct-1990

Revision History:


--*/

//
// Include Common Definitions.
//

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntos.h"
#include <base.h>

//
// Include server definitions for CSR
//

#include "ntcsrsrv.h"

//
// Include message definitions for communicating between client and server
// portions of the Base portion of the Windows subsystem
//

#include "basemsg.h"

#include "sxsapi.h"

//
//
//  WX86 needs to be enabled on the server side, since it
//  may be enabled in a 32bit dll such as kernel32.dll
//  that reads from the csrss shared memory.

#if defined(_AXP64_) && !defined(WX86)
#define WX86 1
#endif

//
// Routines and data defined in srvinit.c
//


UNICODE_STRING BaseSrvWindowsDirectory;
UNICODE_STRING BaseSrvWindowsSystemDirectory;
#if defined(WX86)
UNICODE_STRING BaseSrvWindowsSys32x86Directory;
#endif
PBASE_STATIC_SERVER_DATA BaseSrvpStaticServerData;


NTSTATUS
ServerDllInitialization(
    PCSR_SERVER_DLL LoadedServerDll
    );

NTSTATUS
BaseClientConnectRoutine(
    IN PCSR_PROCESS Process,
    IN OUT PVOID ConnectionInfo,
    IN OUT PULONG ConnectionInfoLength
    );

VOID
BaseClientDisconnectRoutine(
    IN PCSR_PROCESS Process
    );

ULONG
BaseSrvDefineDosDevice(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

//
// Routines defined in srvbeep.c
//

NTSTATUS
BaseSrvInitializeBeep( VOID );

ULONG
BaseSrvBeep(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


//
// Routines defined in srvtask.c
//

typedef BOOL (*PFNNOTIFYPROCESSCREATE)(DWORD,DWORD,DWORD,DWORD);
extern PFNNOTIFYPROCESSCREATE UserNotifyProcessCreate;

WORD BaseSrvGetTempFileUnique;

ULONG
BaseSrvCreateProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvDebugProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvDebugProcessStop(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvExitProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvCreateThread(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvGetTempFile(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvSetProcessShutdownParam(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvGetProcessShutdownParam(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvRegisterThread(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


//
// Routines defined in srvnls.c
//

NTSTATUS
BaseSrvNLSInit(
    PBASE_STATIC_SERVER_DATA pStaticServerData
    );

NTSTATUS
BaseSrvNlsConnect(
    PCSR_PROCESS Process,
    PVOID pConnectionInfo,
    PULONG pConnectionInfoLength
    );

NTSTATUS
BaseSrvNlsGetUserInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


ULONG
BaseSrvNlsSetUserInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvNlsSetMultipleUserInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvNlsCreateSection(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvNlsUpdateCacheCount(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

//
// Routines defined in srvini.c
//

NTSTATUS
BaseSrvInitializeIniFileMappings(
    PBASE_STATIC_SERVER_DATA StaticServerData
    );

ULONG
BaseSrvRefreshIniFileMapping(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


//
// Terminal Server specific defines
//
#define GLOBAL_SYM_LINK   L"Global"
#define LOCAL_SYM_LINK    L"Local"
#define SESSION_SYM_LINK  L"Session"

ULONG
BaseSrvSetTermsrvAppInstallMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
BaseSrvSetTermsrvClientTimeZone(
    IN PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

//
// Routines defined in srvaccess.c
//

ULONG
BaseSrvSoundSentryNotification(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

//
// Routines defined in srvcmpat.c
//

NTSTATUS
BaseSrvCheckApplicationCompatibility(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
BaseSrvDelayLoadApphelp(
    VOID
    );

typedef BOOL
(STDAPICALLTYPE *PFNCheckRunApp)(
    IN HANDLE FIleHandle,
    IN LPCWSTR lpApplicationName,
    IN PVOID   pEnvironment,
    IN USHORT  ExeType,
    IN OUT PDWORD pdwCacheCookie,
    OUT PVOID* ppAppCompatData,
    OUT PDWORD pcbAppCompatData,
    OUT PVOID* ppSxsData,
    OUT PDWORD pcbSxsData,
    OUT PDWORD pdwFusionFlags
    );

extern PFNCheckRunApp pfnCheckRunApp;


//
//  Routines defined in srvsxs.c
//

union _BASE_SRV_SXS_STREAM_UNION_WITH_VTABLE;
typedef union _BASE_SRV_SXS_STREAM_UNION_WITH_VTABLE* PBASE_SRV_SXS_STREAM_UNION_WITH_VTABLE;

NTSTATUS
BaseSrvSxsInit(
    VOID
    );

ULONG
BaseSrvSxsCreateActivationContext(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
BaseSrvSxsGetActivationContextGenerationFunction(
    OUT PSXS_GENERATE_ACTIVATION_CONTEXT_FUNCTION* Function,
    OUT PDWORD_PTR Cookie
    );

NTSTATUS
BaseSrvSxsReleaseActivationContextGenerationFunction(
    IN DWORD_PTR Cookie
    );

NTSTATUS
BaseSrvSxsCreateProcess(
    HANDLE CsrClientProcess,
    HANDLE NewProcess,
    IN OUT PCSR_API_MSG CsrMessage,
    PPEB   NewProcessPeb
    );

struct _BASE_SRV_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT;

typedef struct _BASE_SRV_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT {
    HANDLE               Section;
    const UNICODE_STRING ProcessorArchitectureString;
    const ULONG          ProcessorArchitecture;
} BASE_SRV_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT, *PBASE_SRV_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT;

NTSTATUS
BaseSrvSxsInvalidateSystemDefaultActivationContextCache(
    VOID
    );

NTSTATUS
BaseSrvSxsGetCachedSystemDefaultActivationContext(
    IN USHORT ProcessorArchitecture,
    OUT PBASE_SRV_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT *SystemDefaultActivationContext
    );

NTSTATUS
BaseSrvSxsCreateMemoryStream(
    HANDLE                                     CsrClientProcess,
    IN PCBASE_MSG_SXS_STREAM                   MsgStream,
    OUT PBASE_SRV_SXS_STREAM_UNION_WITH_VTABLE StreamUnion,
    const IID*                                 IIDStream,
    OUT PVOID*                                 OutIStream
    );

NTSTATUS
BaseSrvSxsDoSystemDefaultActivationContext(
    USHORT   ProcessorArchitecture,
    HANDLE   NewProcess,
    PPEB     NewPeb
    );

// validates pointers
ULONG
BaseSrvSxsCreateActivationContextFromMessage(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

// assumes pointers are valid
NTSTATUS
BaseSrvSxsCreateActivationContextFromStruct(
    HANDLE                                  CsrClientProcess,
    HANDLE                                  SxsClientProcess,
    IN OUT PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Struct,
    OUT HANDLE*                             OutSection OPTIONAL
    );

NTSTATUS
BaseSrvSxsMapViewOfSection(
    OUT PVOID*   Address,
    IN HANDLE    Process,
    IN HANDLE    Section,
    IN ULONGLONG Offset,
    IN SIZE_T    Size,
    IN ULONG     Protect,
    IN ULONG     AllocationType
    );

NTSTATUS
BaseSrvSxsValidateMessageStrings(
    IN CONST CSR_API_MSG* Message,
    IN ULONG NumberOfStrings,
    IN CONST PCUNICODE_STRING* Strings
    );

#define MEDIUM_PATH (64)

PVOID BaseSrvSharedHeap;
ULONG BaseSrvSharedTag;

#define MAKE_SHARED_TAG( t ) (RTL_HEAP_MAKE_TAG( BaseSrvSharedTag, t ))
#define INIT_TAG 0
#define INI_TAG 1

PVOID BaseSrvHeap;
ULONG BaseSrvTag;

#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( BaseSrvTag, t ))

#define TMP_TAG 0
#define VDM_TAG 1
#define SXS_TAG 2

#include <vdmapi.h>
#include "srvvdm.h"
#include "basevdm.h"
#include <stdio.h>
#include "winnlsp.h"

extern HANDLE BaseSrvKernel32DllHandle;
extern PGET_NLS_SECTION_NAME pGetNlsSectionName;
extern PGET_DEFAULT_SORTKEY_SIZE pGetDefaultSortkeySize;
extern PGET_LINGUIST_LANG_SIZE pGetLinguistLangSize;
extern PVALIDATE_LOCALE pValidateLocale;
extern PVALIDATE_LCTYPE pValidateLCType;
extern POPEN_DATA_FILE pOpenDataFile;
extern PNLS_CONVERT_INTEGER_TO_STRING pNlsConvertIntegerToString;
typedef LANGID (WINAPI* PGET_USER_DEFAULT_LANG_ID)(VOID);
extern PGET_USER_DEFAULT_LANG_ID pGetUserDefaultLangID;
extern PGET_CP_FILE_NAME_FROM_REGISTRY pGetCPFileNameFromRegistry;
extern PCREATE_NLS_SECURITY_DESCRIPTOR pCreateNlsSecurityDescriptor;

NTSTATUS
BaseSrvDelayLoadKernel32(
    VOID
    );

extern UNICODE_STRING BaseSrvSxsDllPath;

#define BASESRV_UNLOAD_SXS_DLL DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvcmpat.c ===
#include "basesrv.h"
#include "ahcache.h"

#define SHIM_CACHE_NOT_FOUND 0x00000001
#define SHIM_CACHE_BYPASS    0x00000002 // bypass cache (either removable media or temp dir)
#define SHIM_CACHE_LAYER_ENV 0x00000004 // layer env variable set
#define SHIM_CACHE_MEDIA     0x00000008
#define SHIM_CACHE_TEMP      0x00000010
#define SHIM_CACHE_NOTAVAIL  0x00000020

#define SHIM_CACHE_UPDATE    0x00020000
#define SHIM_CACHE_ACTION    0x00010000


//
// Parameters:
// ExePath
// Environment Block (need __PROCESS_HISTORY and __COMPAT_LAYER)
// File Handle
//

BOOL
BasepSrvShimCacheUpdate(
    IN  PUNICODE_STRING FileName,
    IN  HANDLE          FileHandle
    )
/*++
    Return: TRUE if we have a cache hit, FALSE otherwise.

    Desc:   Search the cache, return TRUE if we have a cache hit
            pIndex will receive an index into the rgIndex array that contains
            the entry which has been hit
            So that if entry 5 contains the hit, and rgIndexes[3] == 5 then
            *pIndex == 3
--*/
{
    NTSTATUS Status;
    AHCACHESERVICEDATA Data;

    Data.FileName   = *FileName;
    Data.FileHandle = FileHandle;

    Status = NtApphelpCacheControl(ApphelpCacheServiceUpdate,
                                   &Data);
    return NT_SUCCESS(Status);
}

BOOL
BasepSrvShimCacheRemoveEntry(
    IN PUNICODE_STRING FileName
    )
/*++
    Return: TRUE.

    Desc:   Remove the entry from the cache.
            We remove the entry by placing it as the last lru entry
            and emptying the path. This routine assumes that the index
            passed in is valid.
--*/
{
    AHCACHESERVICEDATA Data;
    NTSTATUS           Status;

    Data.FileName   = *FileName;
    Data.FileHandle = INVALID_HANDLE_VALUE;

    Status = NtApphelpCacheControl(ApphelpCacheServiceRemove,
                                   &Data);


    return NT_SUCCESS(Status);
}

NTSTATUS
BasepSrvMarshallAppCompatData(
    PBASE_CHECK_APPLICATION_COMPATIBILITY_MSG pMsg,
    HANDLE ClientProcessHandle,
    PVOID  pAppCompatData,
    SIZE_T cbAppCompatData,
    PVOID  pSxsData,
    SIZE_T cbSxsData,
    SIZE_T FusionFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SIZE_T   cbData;
    //
    //
    //

    if (pAppCompatData) {

        cbData = cbAppCompatData;
        Status = NtAllocateVirtualMemory(ClientProcessHandle,
                                         (PVOID*)&pMsg->pAppCompatData,
                                         0,
                                         &cbData,
                                         MEM_COMMIT,
                                         PAGE_READWRITE);
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        // we got the memory allocated, copy our data
        Status = NtWriteVirtualMemory(ClientProcessHandle,
                                      pMsg->pAppCompatData,
                                      pAppCompatData,
                                      cbAppCompatData,
                                      NULL);
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        pMsg->cbAppCompatData = (DWORD)cbAppCompatData;
    }


    if (pSxsData) {

        cbData = cbSxsData;
        Status = NtAllocateVirtualMemory(ClientProcessHandle,
                                         (PVOID*)&pMsg->pSxsData,
                                         0,
                                         &cbData,
                                         MEM_COMMIT,
                                         PAGE_READWRITE);
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        // we got the memory allocated, copy our data
        Status = NtWriteVirtualMemory(ClientProcessHandle,
                                      pMsg->pSxsData,
                                      pSxsData,
                                      cbSxsData,
                                      NULL);
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        pMsg->cbSxsData = (DWORD)cbSxsData;

    }

    pMsg->FusionFlags = (DWORD)FusionFlags;

Cleanup:

    if (!NT_SUCCESS(Status)) {

        if (pMsg->pAppCompatData) {
            NtFreeVirtualMemory(ClientProcessHandle,
                                (PVOID*)&pMsg->pAppCompatData,
                                &cbAppCompatData,
                                MEM_RELEASE);
            pMsg->pAppCompatData  = NULL;
            pMsg->cbAppCompatData = 0;
        }

        if (pMsg->pAppCompatData) {
            NtFreeVirtualMemory(ClientProcessHandle,
                                (PVOID*)&pMsg->pSxsData,
                                &cbSxsData,
                                MEM_RELEASE);
            pMsg->pSxsData  = NULL;
            pMsg->cbSxsData = 0;
        }

    }

    if (pAppCompatData) {
        RtlFreeHeap(RtlProcessHeap(), 0, pAppCompatData);
    }

    if (pSxsData) {
        RtlFreeHeap(RtlProcessHeap(), 0, pSxsData);
    }

    return Status;
}


NTSTATUS
BaseSrvCheckApplicationCompatibility(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_CHECK_APPLICATION_COMPATIBILITY_MSG pMsg = (PBASE_CHECK_APPLICATION_COMPATIBILITY_MSG)&m->u.ApiMessageData;
    NTSTATUS    Status;
    BOOL        bSuccess;
    PCSR_THREAD ClientThread;
    HANDLE      ClientProcessHandle;
    HANDLE      FileHandle      = INVALID_HANDLE_VALUE;
    BOOL        bRunApp         = TRUE;
    PVOID       pAppCompatData  = NULL;
    DWORD       cbAppCompatData = 0;
    PVOID       pSxsData        = NULL;
    DWORD       cbSxsData       = 0;
    DWORD       dwFusionFlags   = 0;

    WCHAR       szEmptyEnvironment[] = { L'\0', L'\0' };

    //
    // first we have to check the message buffer to make sure it is good
    //
    if (!CsrValidateMessageBuffer(m,
                                  &pMsg->FileName.Buffer,
                                  pMsg->FileName.MaximumLength/sizeof(WCHAR),
                                  sizeof(WCHAR))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // do more validation here please
    //
    if (pMsg->pEnvironment != NULL) {
        if (!CsrValidateMessageBuffer(m,
                                      &pMsg->pEnvironment,
                                      pMsg->EnvironmentSize/sizeof(WCHAR),
                                      sizeof(WCHAR))) {
            return STATUS_INVALID_PARAMETER;
        }

        // check that the environment ends in two 00
        if (pMsg->EnvironmentSize < sizeof(szEmptyEnvironment) ||
            *((PWCHAR)pMsg->pEnvironment + (pMsg->EnvironmentSize/sizeof(WCHAR) - 1)) != L'\0' ||
            *((PWCHAR)pMsg->pEnvironment + (pMsg->EnvironmentSize/sizeof(WCHAR) - 2)) != L'\0') {
            return STATUS_INVALID_PARAMETER;
        }

    }

    Status = BaseSrvDelayLoadApphelp();
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // check environment buffer
    //
    ClientThread = CSR_SERVER_QUERYCLIENTTHREAD();
    ClientProcessHandle = ClientThread->Process->ProcessHandle;

    //
    // Calling CsrImpersonateClient before NtDuplicateObject to
    // make auditing work better.
    //
    if (!CsrImpersonateClient(NULL)) {
        //
        // we could not impersonate the caller, fail this alltogether then
        //
        return STATUS_BAD_IMPERSONATION_LEVEL;
    }

    if (pMsg->FileHandle != INVALID_HANDLE_VALUE) {

        Status = NtDuplicateObject(ClientProcessHandle,
                                   pMsg->FileHandle,
                                   NtCurrentProcess(),
                                   &FileHandle,
                                   0,
                                   0,
                                   DUPLICATE_SAME_ACCESS);
        if (!NT_SUCCESS(Status)) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // next - check application compatibility setting by invoking apphelp.dll
    //
    bRunApp = pfnCheckRunApp(FileHandle,
                             pMsg->FileName.Buffer,
                             pMsg->pEnvironment == NULL ?
                                 (PVOID)szEmptyEnvironment : pMsg->pEnvironment,
                             pMsg->ExeType,
                             &pMsg->CacheCookie,
                             &pAppCompatData,
                             &cbAppCompatData,
                             &pSxsData,
                             &cbSxsData,
                             &dwFusionFlags);
    //
    // revert to self
    //
    CsrRevertToSelf();

    //
    // if we got compat data back -- marshal the pointers across
    //
    Status = BasepSrvMarshallAppCompatData(pMsg,
                                           ClientProcessHandle,
                                           pAppCompatData,
                                           cbAppCompatData,
                                           pSxsData,
                                           cbSxsData,
                                           dwFusionFlags);

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    if (bRunApp && (pMsg->CacheCookie & SHIM_CACHE_ACTION)) {
        if (pMsg->CacheCookie & SHIM_CACHE_UPDATE) {
            Status = BasepSrvShimCacheUpdate(&pMsg->FileName, FileHandle);
        } else {
            Status = BasepSrvShimCacheRemoveEntry(&pMsg->FileName);
        }
    }

Cleanup:

    //
    //  check for the handle please
    //
    if (FileHandle != INVALID_HANDLE_VALUE) {
        NtClose(FileHandle);
    }

    pMsg->bRunApp = bRunApp;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\mmapstm.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mmapstm.h

Abstract:

    IStream over a memory-mapped file, derived (in the C++ sense) from
    RTL_MEMORY_STREAM. Note the semantics and implementation here
    of IStream::Stat are specialized for use by sxs.

Author:

    Jay Krell (a-JayK) June 2000

Revision History:

--*/

#include "nturtl.h"

typedef struct _BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE {
    RTL_MEMORY_STREAM_WITH_VTABLE MemStream;
    HANDLE                        FileHandle;
} BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE, *PBASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE;

VOID
STDMETHODCALLTYPE
BaseSrvInitMemoryMappedStream(
    PBASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE MmapStream
    );

VOID
STDMETHODCALLTYPE
BaseSrvFinalReleaseMemoryMappedStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemStream
    );

//
// We mostly just inherit the RtlMemoryStream implementation.
// "Declare" that by providing names for our virtual member functions
// whose first parameter is of the correct type.
//
#define BaseSrvAddRefMemoryMappedStream \
    ((PRTL_ADDREF_STREAM1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlAddRefMemoryStream)

#define BaseSrvReleaseMemoryMappedStream \
    ((PRTL_RELEASE_STREAM1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlReleaseMemoryStream)

#define BaseSrvQueryInterfaceMemoryMappedStream \
    ((PRTL_QUERYINTERFACE_STREAM1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlQueryInterfaceMemoryStream)

#define BaseSrvReadMemoryMappedStream \
    ((PRTL_READ_STREAM1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlReadMemoryStream)

#define BaseSrvWriteMemoryMappedStream \
    ((PRTL_WRITE_STREAM1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlWriteMemoryStream)

#define BaseSrvSeekMemoryMappedStream \
    ((PRTL_SEEK_STREAM1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlSeekMemoryStream)

#define BaseSrvSetMemoryMappedStreamSize \
    ((PRTL_SET_STREAM_SIZE1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlSetMemoryStreamSize)

#define BaseSrvCopyMemoryMappedStreamTo \
    ((PRTL_COPY_STREAM_TO1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlCopyMemoryStreamTo)

#define BaseSrvCommitMemoryMappedStream \
    ((PRTL_COMMIT_STREAM1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlCommitMemoryStream)

#define BaseSrvRevertMemoryMappedStream \
    ((PRTL_REVERT_STREAM1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlRevertMemoryStream)

#define BaseSrvLockMemoryMappedStreamRegion \
    ((PRTL_LOCK_STREAM_REGION1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlLockMemoryStreamRegion)

#define BaseSrvUnlockMemoryMappedStreamRegion \
    ((PRTL_UNLOCK_STREAM_REGION1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlUnlockMemoryStreamRegion)

// override
HRESULT
STDMETHODCALLTYPE
BaseSrvStatMemoryMappedStream(
    PBASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE MmapStream,
    STATSTG* Stat,
    DWORD    Flags
    );

#define BaseSrvCloneMemoryMappedStream \
    ((PRTL_CLONE_STREAM1(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE))RtlCloneMemoryStream)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvacces.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvacces.c

Abstract:

    This file contains the Access Pack support routines

Author:

    Gregory Wilson (gregoryw) 28-Jul-1993

Revision History:

--*/

#include "basesrv.h"

BOOL
FirstSoundSentry(
    UINT uVideoMode
    );

BOOL (*_UserSoundSentry)(
    UINT uVideoMode
    ) = FirstSoundSentry;

BOOL
FailSoundSentry(
    UINT uVideoMode
    )
{
    //
    // If the real user soundsentry routine cannot be found, deny access
    //
    return( FALSE );
}

BOOL
FirstSoundSentry(
    UINT uVideoMode
    )
{
UNICODE_STRING WinSrvString = RTL_CONSTANT_STRING(L"winsrv");
        STRING UserSoundSentryString = RTL_CONSTANT_STRING("_UserSoundSentry");
    HANDLE UserServerModuleHandle;
    NTSTATUS Status;
    BOOL (*pfnSoundSentryProc)(UINT) = FailSoundSentry; // default to failure

    Status = LdrGetDllHandle(
                NULL,
                NULL,
                &WinSrvString,
                &UserServerModuleHandle
                );

    if ( NT_SUCCESS(Status) ) {
        Status = LdrGetProcedureAddress(
                        UserServerModuleHandle,
                        &UserSoundSentryString,
                        0L,
                        (PVOID *)&pfnSoundSentryProc
                        );
    }
    _UserSoundSentry = pfnSoundSentryProc;
    return( _UserSoundSentry( uVideoMode ) );
}

//
// There are no uses of this, so remove it regardless of the ifdef.
//
#if 0 // defined(CONSOLESOUNDSENTRY)

CONST STRING ConsoleSoundSentryString = RTL_CONSTANT_STRING("_ConsoleSoundSentry");

BOOL
FirstConsoleSoundSentry(
    UINT uVideoMode
    );

BOOL (*_ConsoleSoundSentry)(
    UINT uVideoMode
    ) = FirstConsoleSoundSentry;

BOOL
FirstConsoleSoundSentry(
    UINT uVideoMode
    )
{
    HANDLE ConsoleServerModuleHandle;
    NTSTATUS Status;
    BOOL (*pfnSoundSentryProc)(UINT) = FailSoundSentry; // default to failure

    Status = LdrGetDllHandle(
                NULL,
                NULL,
                &WinSrvString,
                (PVOID *)&ConsoleServerModuleHandle
                );

    if ( NT_SUCCESS(Status) ) {
        Status = LdrGetProcedureAddress(
                        ConsoleServerModuleHandle,
                        &ConsoleSoundSentryString,
                        0L,
                        (PVOID *)&pfnSoundSentryProc
                        );
    }

    _ConsoleSoundSentry = pfnSoundSentryProc;
    return( _ConsoleSoundSentry( uVideoMode ) );
}
#endif

ULONG
BaseSrvSoundSentryNotification(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_SOUNDSENTRY_NOTIFICATION_MSG a =
            (PBASE_SOUNDSENTRY_NOTIFICATION_MSG)&m->u.ApiMessageData;
    BOOL SoundSentryStatus;

    //
    // The possible values for a->VideoMode are:
    //     0 : windows mode
    //     1 : full screen mode
    //     2 : full screen graphics mode
    //
    SoundSentryStatus = _UserSoundSentry( a->VideoMode );

    if (SoundSentryStatus) {
        return( (ULONG)STATUS_SUCCESS );
    } else {
        return( (ULONG)STATUS_ACCESS_DENIED );
    }

    ReplyStatus;    // get rid of unreferenced parameter warning message
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvatom.c ===
This whole while is dead.

///*++

//Copyright (c) 1990  Microsoft Corporation

//Module Name:

//    srvatom.c

//Abstract:

//    This file contains the Global Atom manager API routines

//Author:

//    Steve Wood (stevewo) 29-Oct-1990

//Revision History:

//--*/

//#include "basesrv.h"

////
//// Pointer to User function that returns a pointer to the
//// global atom table associated with the windowstation
//// userd by the specified thread.
////

//NTSTATUS (*_UserGetGlobalAtomTable)(
//    HANDLE hThread,
//    PVOID *GlobalAtomTable
//    );

////
//// Pointer to User function that sets a pointer to the
//// global atom table into the windowstation associated
//// with the specified thread.
////

//NTSTATUS (*_UserSetGlobalAtomTable)(
//    HANDLE hThread,
//    PVOID GlobalAtomTable
//    );

//NTSTATUS
//BaseSrvGetGlobalAtomTable(
//    PVOID *GlobalAtomTable
//    )
//{
//    STRING ProcedureName;
//    ANSI_STRING DllName;
//    UNICODE_STRING DllName_U;
//    HANDLE UserServerModuleHandle;
//    static BOOL fInit = FALSE;
//    NTSTATUS Status;

//    if ( _UserGetGlobalAtomTable == NULL ) {

//        if ( fInit == TRUE ) {

//            //
//            // If the exported atom routines cannot be found, deny access
//            //

//            return( STATUS_ACCESS_DENIED );
//            }

//        fInit = TRUE;

//        //
//        // Load pointers to the functions in winsrv.dll
//        //

//        RtlInitAnsiString( &DllName, "winsrv" );
//        RtlAnsiStringToUnicodeString( &DllName_U, &DllName, TRUE );
//        Status = LdrGetDllHandle(
//                    UNICODE_NULL,
//                    NULL,
//                    &DllName_U,
//                    (PVOID *)&UserServerModuleHandle
//                    );

//        RtlFreeUnicodeString( &DllName_U );

//        if ( NT_SUCCESS(Status) ) {

//                //
//                // Now get the routined to query and set the 
//                // atom table pointer.
//                //

//                RtlInitString( &ProcedureName, "_UserGetGlobalAtomTable" );
//                Status = LdrGetProcedureAddress(
//                                (PVOID)UserServerModuleHandle,
//                                &ProcedureName,
//                                0L,
//                                (PVOID *)&_UserGetGlobalAtomTable
//                                );

//                RtlInitString( &ProcedureName, "_UserSetGlobalAtomTable" );
//                Status = LdrGetProcedureAddress(
//                                (PVOID)UserServerModuleHandle,
//                                &ProcedureName,
//                                0L,
//                                (PVOID *)&_UserSetGlobalAtomTable
//                                );
//        }

//        //
//        // Deny access upon failure
//        //

//        if ( !NT_SUCCESS(Status) )
//            return( STATUS_ACCESS_DENIED );
//    }

//    Status = (*_UserGetGlobalAtomTable)(
//            CSR_SERVER_QUERYCLIENTTHREAD()->ThreadHandle,
//            GlobalAtomTable);
//    if ( !NT_SUCCESS(Status) ) {
//        return Status;
//        }
//    
//    //
//    // Lock the heap until the call is complete.
//    //

//    RtlLockHeap( BaseSrvHeap );

//    //
//    // If there is an atom table, return it.
//    //

//    if ( *GlobalAtomTable ) {
//        return STATUS_SUCCESS;
//        }

//    Status =  BaseRtlCreateAtomTable( 37,
//                                      (USHORT)~MAXINTATOM,
//                                      GlobalAtomTable
//                                      );

//    if ( NT_SUCCESS(Status) ) {
//        Status = (*_UserSetGlobalAtomTable)(
//                CSR_SERVER_QUERYCLIENTTHREAD()->ThreadHandle,
//                *GlobalAtomTable);
//        if ( !NT_SUCCESS(Status) ) {
//            BaseRtlDestroyAtomTable( *GlobalAtomTable );
//            }
//        }

//    if ( !NT_SUCCESS(Status) ) {
//        RtlUnlockHeap( BaseSrvHeap );
//        }

//    return Status;
//}

//ULONG
//BaseSrvDestroyGlobalAtomTable(
//    IN OUT PCSR_API_MSG m,
//    IN OUT PCSR_REPLY_STATUS ReplyStatus
//    )
//{
//    PBASE_DESTROYGLOBALATOMTABLE_MSG a = (PBASE_DESTROYGLOBALATOMTABLE_MSG)&m->u.ApiMessageData;

//    return BaseRtlDestroyAtomTable(a->GlobalAtomTable);
//}

//ULONG
//BaseSrvGlobalAddAtom(
//    IN OUT PCSR_API_MSG m,
//    IN OUT PCSR_REPLY_STATUS ReplyStatus
//    )
//{
//    PBASE_GLOBALATOMNAME_MSG a = (PBASE_GLOBALATOMNAME_MSG)&m->u.ApiMessageData;
//    PVOID GlobalAtomTable;
//    NTSTATUS Status;
//    UNICODE_STRING AtomName;

//    AtomName = a->AtomName;
//    if (a->AtomNameInClient) {
//        AtomName.Buffer = RtlAllocateHeap( BaseSrvHeap,
//                                           MAKE_TAG( TMP_TAG ),
//                                           AtomName.Length
//                                         );
//        if (AtomName.Buffer == NULL) {
//            return (ULONG)STATUS_NO_MEMORY;
//            }

//        Status = NtReadVirtualMemory( CSR_SERVER_QUERYCLIENTTHREAD()->Process->ProcessHandle,
//                                      a->AtomName.Buffer,
//                                      AtomName.Buffer,
//                                      AtomName.Length,
//                                      NULL
//                                    );
//        }
//    else {
//        Status = STATUS_SUCCESS;
//        }

//    if (NT_SUCCESS( Status )) {
//        Status = BaseSrvGetGlobalAtomTable(&GlobalAtomTable);
//        if (NT_SUCCESS( Status )) {
//            Status = BaseRtlAddAtomToAtomTable( GlobalAtomTable,
//                                                &AtomName,
//                                                NULL,
//                                                &a->Atom
//                                              );
//            RtlUnlockHeap( BaseSrvHeap );
//            }
//        }

//    if (a->AtomNameInClient) {
//        RtlFreeHeap( BaseSrvHeap, 0, AtomName.Buffer );
//        }

//    return( (ULONG)Status );
//    ReplyStatus;    // get rid of unreferenced parameter warning message
//}


//ULONG
//BaseSrvGlobalFindAtom(
//    IN OUT PCSR_API_MSG m,
//    IN OUT PCSR_REPLY_STATUS ReplyStatus
//    )
//{
//    PBASE_GLOBALATOMNAME_MSG a = (PBASE_GLOBALATOMNAME_MSG)&m->u.ApiMessageData;
//    PVOID GlobalAtomTable;
//    UNICODE_STRING AtomName;
//    NTSTATUS Status;

//    AtomName = a->AtomName;
//    if (a->AtomNameInClient) {
//        AtomName.Buffer = RtlAllocateHeap( BaseSrvHeap,
//                                           MAKE_TAG( TMP_TAG ),
//                                           AtomName.Length
//                                         );
//        if (AtomName.Buffer == NULL) {
//            return (ULONG)STATUS_NO_MEMORY;
//            }

//        Status = NtReadVirtualMemory( CSR_SERVER_QUERYCLIENTTHREAD()->Process->ProcessHandle,
//                                      a->AtomName.Buffer,
//                                      AtomName.Buffer,
//                                      AtomName.Length,
//                                      NULL
//                                    );
//        }
//    else {
//        Status = STATUS_SUCCESS;
//        }

//    if (NT_SUCCESS( Status )) {
//        Status = BaseSrvGetGlobalAtomTable(&GlobalAtomTable);
//        if (NT_SUCCESS( Status )) {
//            Status = BaseRtlLookupAtomInAtomTable( GlobalAtomTable,
//                                                   &AtomName,
//                                                   NULL,
//                                                   &a->Atom
//                                                 );
//            RtlUnlockHeap( BaseSrvHeap );
//            }
//        }

//    if (a->AtomNameInClient) {
//        RtlFreeHeap( BaseSrvHeap, 0, AtomName.Buffer );
//        }

//    return( (ULONG)Status );
//    ReplyStatus;    // get rid of unreferenced parameter warning message
//}

//ULONG
//BaseSrvGlobalDeleteAtom(
//    IN OUT PCSR_API_MSG m,
//    IN OUT PCSR_REPLY_STATUS ReplyStatus
//    )
//{
//    PBASE_GLOBALDELETEATOM_MSG a = (PBASE_GLOBALDELETEATOM_MSG)&m->u.ApiMessageData;
//    PVOID GlobalAtomTable;
//    NTSTATUS Status;

//    Status = BaseSrvGetGlobalAtomTable(&GlobalAtomTable);
//    if (NT_SUCCESS( Status )) {
//        Status = BaseRtlDeleteAtomFromAtomTable( GlobalAtomTable,
//                                                 a->Atom
//                                               );
//        RtlUnlockHeap( BaseSrvHeap );
//        }

//    return( (ULONG)Status );
//    ReplyStatus;    // get rid of unreferenced parameter warning message
//}

//ULONG
//BaseSrvGlobalGetAtomName(
//    IN OUT PCSR_API_MSG m,
//    IN OUT PCSR_REPLY_STATUS ReplyStatus
//    )
//{
//    PBASE_GLOBALATOMNAME_MSG a = (PBASE_GLOBALATOMNAME_MSG)&m->u.ApiMessageData;
//    UNICODE_STRING AtomName;
//    PVOID GlobalAtomTable;
//    NTSTATUS Status;

//    AtomName = a->AtomName;
//    if (a->AtomNameInClient) {
//        AtomName.Buffer = RtlAllocateHeap( BaseSrvHeap,
//                                           MAKE_TAG( TMP_TAG ),
//                                           AtomName.MaximumLength
//                                         );
//        if (AtomName.Buffer == NULL) {
//            return (ULONG)STATUS_NO_MEMORY;
//            }
//        }

//    Status = BaseSrvGetGlobalAtomTable(&GlobalAtomTable);
//    if (NT_SUCCESS( Status )) {
//        Status = BaseRtlQueryAtomInAtomTable( GlobalAtomTable,
//                                              a->Atom,
//                                              &AtomName,
//                                              NULL,
//                                              NULL
//                                            );

//        a->AtomName.Length = AtomName.Length;
//        if (NT_SUCCESS( Status ) && a->AtomNameInClient) {
//            Status = NtWriteVirtualMemory( CSR_SERVER_QUERYCLIENTTHREAD()->Process->ProcessHandle,
//                                           a->AtomName.Buffer,
//                                           AtomName.Buffer,
//                                           AtomName.Length,
//                                           NULL
//                                         );
//            }
//        RtlUnlockHeap( BaseSrvHeap );
//        }

//    if (a->AtomNameInClient) {
//        RtlFreeHeap( BaseSrvHeap, 0, AtomName.Buffer );
//        }

//    return( (ULONG)Status );
//    ReplyStatus;    // get rid of unreferenced parameter warning message
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvgmem.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvgmem.c

Abstract:

    This file contains the Global Memory manager API routines

Author:

    Steve Wood (stevewo) 29-Oct-1990

Revision History:

--*/

#include "basesrv.h"

#ifdef ENABLE_SHARED_MEMORY
NTSTATUS
BaseSrvInitializeGlobalHeap( VOID )
{
    NTSTATUS Status;
    LARGE_INTEGER SectionSize;
    ULONG ViewSize;

    BaseSrvGlobalMemorySize = 4 * 1024;     // 4kb
    SectionSize.LowPart = BaseSrvGlobalMemorySize;
    SectionSize.HighPart = 0;
    Status = NtCreateSection( &BaseSrvGlobalSection,
                              SECTION_ALL_ACCESS,
                              (POBJECT_ATTRIBUTES) NULL,
                              &SectionSize,
                              PAGE_EXECUTE_READWRITE,
                              SEC_BASED | SEC_RESERVE,
                              (HANDLE) NULL
                            );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    ViewSize = 0;
    BaseSrvGlobalMemoryBase = NULL;
    Status = NtMapViewOfSection( BaseSrvGlobalSection,
                                 NtCurrentProcess(),
                                 &BaseSrvGlobalMemoryBase,
                                 0,     // Zerobits?
                                 0,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 MEM_TOP_DOWN,
                                 PAGE_EXECUTE_READWRITE
                               );
    if (!NT_SUCCESS( Status )) {
        NtClose( BaseSrvGlobalSection );
        return( Status );
        }

    BaseSrvGlobalHeap = RtlCreateHeap( HEAP_ZERO_MEMORY,
                                       BaseSrvGlobalMemoryBase,
                                       ViewSize,
                                       4*1024,
                                       0,
                                       0
                                     );
    if (BaseSrvGlobalHeap == NULL) {
        NtUnmapViewOfSection( NtCurrentProcess(),
                              BaseSrvGlobalMemoryBase
                            );
        NtClose( BaseSrvGlobalSection );
        return( STATUS_UNSUCCESSFUL );
        }

#if 0
    DbgPrint( "    Shared Memory Region: [%lX .. %lX)\n",
              BaseSrvGlobalMemoryBase,
              (ULONG)BaseSrvGlobalMemoryBase + BaseSrvGlobalMemorySize
            );
#endif

    return( STATUS_SUCCESS );
}


NTSTATUS
BaseSrvAttachGlobalHeap(
    IN HANDLE Process
    )
{
    NTSTATUS Status;
    ULONG ViewSize;

    ViewSize = 0;
    Status = NtMapViewOfSection( BaseSrvGlobalSection,
                                 Process,
                                 &BaseSrvGlobalMemoryBase,
                                 0,     // Zerobits?
                                 0,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 0,
                                 PAGE_EXECUTE_READWRITE
                               );
    return( Status );
}


ULONG
BaseSrvGlobalAlloc(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_GLOBALALLOC_MSG a = (PBASE_GLOBALALLOC_MSG)&m->u.ApiMessageData;
    PVOID Memory;
    PULONG p;
    ULONG Flags;

    Flags = HEAP_NO_EXCEPTIONS | HEAP_SERIALIZE;
    if (a->uFlags & GMEM_ZEROINIT) {
        Flags |= HEAP_ZERO_MEMORY;
        }

    Memory = RtlExAllocateHeap( BaseSrvGlobalHeap, Flags, a->dwBytes );
    if (Memory != NULL) {
        if (a->uFlags & GMEM_ZEROINIT) {
            RtlZeroMemory( Memory, a->dwBytes );
            }
#if DBG
        else {
            p = (PULONG)Memory;
            *p = 0xABCDEF01;
            }
#endif
        }

    return( (ULONG)Memory );
    ReplyStatus;    // get rid of unreferenced parameter warning message
}


ULONG
BaseSrvGlobalReAlloc(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_GLOBALREALLOC_MSG a = (PBASE_GLOBALREALLOC_MSG)&m->u.ApiMessageData;
    PVOID Memory;
    ULONG OldSize;
    ULONG Flags;

    Flags = HEAP_NO_EXCEPTIONS | HEAP_SERIALIZE;
    if (a->uFlags & GMEM_ZEROINIT) {
        Flags |= HEAP_ZERO_MEMORY;
        }

    if (a->uFlags & GMEM_MOVEABLE) {
        Flags |= HEAP_GROWTH_ALLOWED;
        }

    if (a->uFlags & GMEM_MODIFY) {
        Memory = a->hMem;
        }
    else {
        Memory = RtlExReAllocateHeap( BaseSrvGlobalHeap, Flags, a->hMem, a->dwBytes );
        }

    return( (ULONG)Memory );
    ReplyStatus;    // get rid of unreferenced parameter warning message
}

ULONG
BaseSrvGlobalSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_GLOBALSIZE_MSG a = (PBASE_GLOBALSIZE_MSG)&m->u.ApiMessageData;
    ULONG Flags;

    Flags = HEAP_NO_EXCEPTIONS | HEAP_SERIALIZE;

    return( RtlExSizeHeap( BaseSrvGlobalHeap, Flags, a->hMem ) );
    ReplyStatus;    // get rid of unreferenced parameter warning message
}

ULONG
BaseSrvGlobalFlags(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_GLOBALFLAGS_MSG a = (PBASE_GLOBALFLAGS_MSG)&m->u.ApiMessageData;

    return( GMEM_DDESHARE );
    ReplyStatus;    // get rid of unreferenced parameter warning message
}

ULONG
BaseSrvGlobalFree(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_GLOBALFREE_MSG a = (PBASE_GLOBALFREE_MSG)&m->u.ApiMessageData;
    ULONG Flags;

    Flags = HEAP_NO_EXCEPTIONS | HEAP_SERIALIZE;
    return( (ULONG)RtlExFreeHeap( BaseSrvGlobalHeap, Flags, a->hMem ) );
    ReplyStatus;    // get rid of unreferenced parameter warning message
}
#endif // ENABLE_SHARED_MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\mmapstm.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mmapstm.c

Abstract:

    IStream over a memory-mapped file, derived (in the C++ sense) from
    RTL_MEMORY_STREAM. Note the semantics and implementation here
    of IStream::Stat are specialized for use by sxs.

Author:

    Jay Krell (a-JayK) June 2000

Revision History:

--*/

#include "basesrv.h"
#include "nturtl.h"
#include "mmapstm.h"

// REVIEW
#define BASE_SRV_HRESULT_FROM_STATUS(x) HRESULT_FROM_WIN32(RtlNtStatusToDosErrorNoTeb(x))
//#define BASE_SRV_HRESULT_FROM_STATUS(x) HRESULT_FROM_WIN32(RtlNtStatusToDosError(x))
//#define BASE_SRV_HRESULT_FROM_STATUS(x)   HRESULT_FROM_NT(x)

#define DPFLTR_LEVEL_HRESULT(x) (SUCCEEDED(x) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)
#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) || x == STATUS_SXS_CANT_GEN_ACTCTX) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

const static RTL_STREAM_VTABLE_TEMPLATE(BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE)
MmapStreamVTable =
{
    BaseSrvQueryInterfaceMemoryMappedStream,
    BaseSrvAddRefMemoryMappedStream,
    BaseSrvReleaseMemoryMappedStream,
    BaseSrvReadMemoryMappedStream,
    BaseSrvWriteMemoryMappedStream,
    BaseSrvSeekMemoryMappedStream,
    BaseSrvSetMemoryMappedStreamSize,
    BaseSrvCopyMemoryMappedStreamTo,
    BaseSrvCommitMemoryMappedStream,
    BaseSrvRevertMemoryMappedStream,
    BaseSrvLockMemoryMappedStreamRegion,
    BaseSrvUnlockMemoryMappedStreamRegion,
    BaseSrvStatMemoryMappedStream,
    BaseSrvCloneMemoryMappedStream
};

VOID
STDMETHODCALLTYPE
BaseSrvInitMemoryMappedStream(
    PBASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE MmapStream
    )
{
    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() beginning\n", __FUNCTION__));

    // call the base class constructor
    RtlInitMemoryStream(&MmapStream->MemStream);

    // replace the base vtable with our own
    MmapStream->MemStream.StreamVTable = (IStreamVtbl*)&MmapStreamVTable;

    // replace the virtual destructor with our own
    MmapStream->MemStream.Data.FinalRelease = BaseSrvFinalReleaseMemoryMappedStream;

    // initialize our extra data
    MmapStream->FileHandle = NULL;

    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() exiting\n", __FUNCTION__));
}

HRESULT
STDMETHODCALLTYPE
BaseSrvStatMemoryMappedStream(
    PBASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE MmapStream,
    STATSTG* Stat,
    DWORD    Flags
    )
{
//
// We should be able to merge RTL_FILE_STREAM and RTL_MEMORY_STREAM somehow,
// but RTL_FILE_STREAM so far we aren't using and it doesn't implement Stat, so..
//
    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT Hr = NOERROR;
    FILE_BASIC_INFORMATION FileBasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;

    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() beginning\n", __FUNCTION__));

    if (Stat == NULL) {
        // You would expect this to be E_INVALIDARG,
        // but IStream docs say to return STG_E_INVALIDPOINTER.
        Hr = STG_E_INVALIDPOINTER;
        goto Exit;
    }

    // we don't support returning the string because
    // we don't have ole32.dll for CoTaskMem*
    Stat->pwcsName = NULL;
    ASSERT(Flags & STATFLAG_NONAME);

    if (MmapStream->FileHandle != NULL) {
        Status = NtQueryInformationFile(
            MmapStream->FileHandle,
            &IoStatusBlock,
            &FileBasicInfo,
            sizeof(FileBasicInfo),
            FileBasicInformation
            );
        if (!NT_SUCCESS(Status)) {
            Hr = BASE_SRV_HRESULT_FROM_STATUS(Status);
            goto Exit;
        }
    } else {
        // NOTE: This is acceptable for the sxs consumer.
        // It is not necessarily acceptable to everyone.
        // Do not change it without consulting sxs.
        RtlZeroMemory(&FileBasicInfo, sizeof(FileBasicInfo));
    }

    Stat->type = STGTY_LOCKBYTES;

    // NOTE we do not report the size of the file, but the size
    // of the mapped view; if we implemented IStream::Stat for RTL_MEMORY_STREAM,
    // it would return the same thing here.
    // (to get file times and size, use FileNetworkOpenInformation)
    Stat->cbSize.QuadPart = (MmapStream->MemStream.Data.End - MmapStream->MemStream.Data.Begin);

    Stat->mtime.dwLowDateTime = FileBasicInfo.LastWriteTime.LowPart;
    Stat->mtime.dwHighDateTime = FileBasicInfo.LastWriteTime.HighPart;
    Stat->ctime.dwLowDateTime = FileBasicInfo.CreationTime.LowPart;
    Stat->ctime.dwHighDateTime = FileBasicInfo.CreationTime.HighPart;
    Stat->atime.dwLowDateTime = FileBasicInfo.LastAccessTime.LowPart;
    Stat->atime.dwHighDateTime = FileBasicInfo.LastAccessTime.HighPart; 

    // there is FileAccessInformation, but this hardcoding should suffice
    Stat->grfMode = STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE;

    Stat->grfLocksSupported = 0;
    Stat->clsid = CLSID_NULL;
    Stat->grfStateBits  = 0;
    Stat->reserved = 0;

    Hr = NOERROR;
Exit:
#if !DBG
    if (DPFLTR_LEVEL_STATUS(Status) == DPFLTR_ERROR_LEVEL)
#endif
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_HRESULT(Hr), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Hr);
    return Hr;
}

VOID
STDMETHODCALLTYPE
BaseSrvFinalReleaseMemoryMappedStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemStream
    )
{
    NTSTATUS Status;
    PBASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE MmapStream;

    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() beginning\n", __FUNCTION__));

    MmapStream = CONTAINING_RECORD(MemStream, BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE, MemStream);

    if (MemStream->Data.Begin != NULL) {
        Status = NtUnmapViewOfSection(NtCurrentProcess(), MemStream->Data.Begin);
        RTL_SOFT_ASSERT(NT_SUCCESS(Status));

        // REVIEW Should we provide RtlFinalReleaseMemoryStream and move these
        // lines there?
        MemStream->Data.Begin = NULL;
        MemStream->Data.End = NULL;
        MemStream->Data.Current = NULL;
    }
    if (MmapStream->FileHandle != NULL) {
        Status = NtClose(MmapStream->FileHandle);
        RTL_SOFT_ASSERT(NT_SUCCESS(Status));
        MmapStream->FileHandle = NULL;
    }

    // RtlFinalReleaseMemoryStream(MemStream);

    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() exiting\n", __FUNCTION__));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvini.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvini.c

Abstract:

    This is the initialization file for the Windows 32-bit Base Ini File
    Mapping code.  It loads the INI file mapping data from the registry and
    places it in a data structure stored in the shared memory section that is
    visible as read-only data to all Win32 applications.

Author:

    Steve Wood (stevewo) 10-Nov-1993

Revision History:

--*/

#include "basesrv.h"

PINIFILE_MAPPING BaseSrvIniFileMapping;
PINIFILE_MAPPING_TARGET BaseSrvMappingTargetHead;

NTSTATUS
BaseSrvSaveIniFileMapping(
    IN PINIFILE_MAPPING_FILENAME FileNameMapping,
    IN HANDLE Key
    );

BOOLEAN
BaseSrvSaveFileNameMapping(
    IN PUNICODE_STRING FileName,
    OUT PINIFILE_MAPPING_FILENAME *ReturnedFileNameMapping
    );

BOOLEAN
BaseSrvSaveAppNameMapping(
    IN OUT PINIFILE_MAPPING_FILENAME FileNameMapping,
    IN PUNICODE_STRING ApplicationName OPTIONAL,
    OUT PINIFILE_MAPPING_APPNAME *ReturnedAppNameMapping
    );

BOOLEAN
BaseSrvSaveVarNameMapping(
    IN PINIFILE_MAPPING_FILENAME FileNameMapping,
    IN OUT PINIFILE_MAPPING_APPNAME AppNameMapping,
    IN PUNICODE_STRING VariableName OPTIONAL,
    IN PWSTR RegistryPath,
    OUT PINIFILE_MAPPING_VARNAME *ReturnedVarNameMapping
    );

PINIFILE_MAPPING_TARGET
BaseSrvSaveMappingTarget(
    IN PWSTR RegistryPath,
    OUT PULONG MappingFlags
    );


NTSTATUS
BaseSrvInitializeIniFileMappings(
    PBASE_STATIC_SERVER_DATA StaticServerData
    )
{
    NTSTATUS Status;
    HANDLE IniFileMappingRoot;
    PINIFILE_MAPPING_FILENAME FileNameMapping, *pp;
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    PINIFILE_MAPPING_VARNAME VarNameMapping;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR Buffer[ 512 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    PKEY_BASIC_INFORMATION KeyInformation;
    ULONG ResultLength;
    HANDLE SubKeyHandle;
    ULONG SubKeyIndex;
    UNICODE_STRING ValueName;
    UNICODE_STRING SubKeyName;
    UNICODE_STRING WinIniFileName;
    UNICODE_STRING NullString;

    RtlInitUnicodeString( &WinIniFileName, L"win.ini" );
    RtlInitUnicodeString( &NullString, NULL );

    BaseSrvIniFileMapping = RtlAllocateHeap( BaseSrvSharedHeap,
                              MAKE_SHARED_TAG( INI_TAG ) | HEAP_ZERO_MEMORY,
                              sizeof( *BaseSrvIniFileMapping )
                            );
    if (BaseSrvIniFileMapping == NULL) {
        KdPrint(( "BASESRV: Unable to allocate memory in shared heap for IniFileMapping\n" ));
        return STATUS_NO_MEMORY;
        }
    StaticServerData->IniFileMapping = BaseSrvIniFileMapping;

    RtlInitUnicodeString( &KeyName,
                          L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping"
                        );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &IniFileMappingRoot,
                        GENERIC_READ,
                        &ObjectAttributes
                      );
    if (!NT_SUCCESS( Status )) {
        KdPrint(( "BASESRV: Unable to open %wZ key - Status == %0x\n", &KeyName, Status ));
        return Status;
        }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
    RtlInitUnicodeString( &ValueName, NULL );
    Status = NtQueryValueKey( IniFileMappingRoot,
                              &ValueName,
                              KeyValuePartialInformation,
                              KeyValueInformation,
                              sizeof( Buffer ),
                              &ResultLength
                            );
    if (NT_SUCCESS( Status )) {
        if (BaseSrvSaveFileNameMapping( &NullString, &BaseSrvIniFileMapping->DefaultFileNameMapping )) {
            if (BaseSrvSaveAppNameMapping( BaseSrvIniFileMapping->DefaultFileNameMapping, &NullString, &AppNameMapping )) {
                if (BaseSrvSaveVarNameMapping( BaseSrvIniFileMapping->DefaultFileNameMapping,
                                               AppNameMapping,
                                               &NullString,
                                               (PWSTR)(KeyValueInformation->Data),
                                               &VarNameMapping
                                             )
                   ) {
                    VarNameMapping->MappingFlags |= INIFILE_MAPPING_APPEND_BASE_NAME |
                                                    INIFILE_MAPPING_APPEND_APPLICATION_NAME;
                    }
                }
            }
        }
    else {
        Status = STATUS_SUCCESS;
        }

    //
    // Enumerate node's children and load mappings for each one
    //

    pp = &BaseSrvIniFileMapping->FileNames;
    *pp = NULL;
    KeyInformation = (PKEY_BASIC_INFORMATION)Buffer;
    for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
        Status = NtEnumerateKey( IniFileMappingRoot,
                                 SubKeyIndex,
                                 KeyBasicInformation,
                                 KeyInformation,
                                 sizeof( Buffer ),
                                 &ResultLength
                               );

        if (Status == STATUS_NO_MORE_ENTRIES) {
            Status = STATUS_SUCCESS;
            break;
            }
        else
        if (!NT_SUCCESS( Status )) {
            KdPrint(( "BASESRV: NtEnumerateKey failed - Status == %08lx\n", Status ));
            break;
            }

        SubKeyName.Buffer = (PWSTR)&(KeyInformation->Name[0]);
        SubKeyName.Length = (USHORT)KeyInformation->NameLength;
        SubKeyName.MaximumLength = (USHORT)KeyInformation->NameLength;
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    IniFileMappingRoot,
                                    NULL
                                  );

        Status = NtOpenKey( &SubKeyHandle,
                            GENERIC_READ,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status )) {
            if (!BaseSrvSaveFileNameMapping( &SubKeyName, &FileNameMapping )) {
                Status = STATUS_NO_MEMORY;
                }
            else {
                Status = BaseSrvSaveIniFileMapping( FileNameMapping, SubKeyHandle );
                if (NT_SUCCESS( Status )) {
                    if (RtlEqualUnicodeString( &FileNameMapping->Name, &WinIniFileName, TRUE )) {
                        BaseSrvIniFileMapping->WinIniFileMapping = FileNameMapping;
                        }

                    *pp = FileNameMapping;
                    pp = &FileNameMapping->Next;
                    }
                else {
                    KdPrint(( "BASESRV: Unable to load mappings for %wZ - Status == %x\n",
                              &FileNameMapping->Name, Status
                           ));
                    RtlFreeHeap( BaseSrvSharedHeap, 0, FileNameMapping );
                    FileNameMapping = NULL;
                    }
                }
            NtClose( SubKeyHandle );
            }
        }

    NtClose( IniFileMappingRoot );

    //
    // NT64: this function used to fall off the end without explicitly returning
    //       a value.  from examining the object code generated, the returned
    //       value was typically the result of NtClose(), e.g. STATUS_SUCCESS.
    //
    //       In order to get the compiler to stop complaining *and* to avoid
    //       changing existing functionality, I've made this return value
    //       explicit.  However it is almost certainly the case that the
    //       intention was to return the value of Status.
    //
    //       At any rate this should be reviewed by someone more familiar
    //       with the code.
    //

    return STATUS_SUCCESS;
}


NTSTATUS
BaseSrvSaveIniFileMapping(
    IN PINIFILE_MAPPING_FILENAME FileNameMapping,
    IN HANDLE Key
    )
{
    NTSTATUS Status;
    WCHAR Buffer[ 512 ];
    PKEY_BASIC_INFORMATION KeyInformation;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    PINIFILE_MAPPING_VARNAME VarNameMapping;
    HANDLE SubKeyHandle;
    ULONG SubKeyIndex;
    UNICODE_STRING ValueName;
    UNICODE_STRING SubKeyName;
    UNICODE_STRING NullString;
    ULONG ResultLength;
    ULONG ValueIndex;

    RtlInitUnicodeString( &NullString, NULL );
    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;
    for (ValueIndex = 0; TRUE; ValueIndex++) {
        Status = NtEnumerateValueKey( Key,
                                      ValueIndex,
                                      KeyValueFullInformation,
                                      KeyValueInformation,
                                      sizeof( Buffer ),
                                      &ResultLength
                                    );
        if (Status == STATUS_NO_MORE_ENTRIES) {
            break;
            }
        else
        if (!NT_SUCCESS( Status )) {
            KdPrint(( "BASESRV: NtEnumerateValueKey failed - Status == %08lx\n", Status ));
            break;
            }

        ValueName.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
        ValueName.Length = (USHORT)KeyValueInformation->NameLength;
        ValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;
        if (KeyValueInformation->Type != REG_SZ) {
            KdPrint(( "BASESRV: Ignoring %wZ mapping, invalid type == %u\n",
                      &ValueName, KeyValueInformation->Type
                   ));
            }
        else
        if (BaseSrvSaveAppNameMapping( FileNameMapping, &ValueName, &AppNameMapping )) {
            if (BaseSrvSaveVarNameMapping( FileNameMapping,
                                           AppNameMapping,
                                           &NullString,
                                           (PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset),
                                           &VarNameMapping
                                         )
               ) {
                if (ValueName.Length == 0) {
                    VarNameMapping->MappingFlags |= INIFILE_MAPPING_APPEND_APPLICATION_NAME;
                    }
                }
            }
        }

    //
    // Enumerate node's children and apply ourselves to each one
    //

    KeyInformation = (PKEY_BASIC_INFORMATION)Buffer;
    for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
        Status = NtEnumerateKey( Key,
                                 SubKeyIndex,
                                 KeyBasicInformation,
                                 KeyInformation,
                                 sizeof( Buffer ),
                                 &ResultLength
                               );

        if (Status == STATUS_NO_MORE_ENTRIES) {
            Status = STATUS_SUCCESS;
            break;
            }
        else
        if (!NT_SUCCESS( Status )) {
            KdPrint(( "BASESRV: NtEnumerateKey failed - Status == %08lx\n", Status ));
            break;
            }

        SubKeyName.Buffer = (PWSTR)&(KeyInformation->Name[0]);
        SubKeyName.Length = (USHORT)KeyInformation->NameLength;
        SubKeyName.MaximumLength = (USHORT)KeyInformation->NameLength;
        InitializeObjectAttributes( &ObjectAttributes,
                                    &SubKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    Key,
                                    NULL
                                  );

        Status = NtOpenKey( &SubKeyHandle,
                            GENERIC_READ,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status ) &&
            BaseSrvSaveAppNameMapping( FileNameMapping, &SubKeyName, &AppNameMapping )
           ) {
            KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;
            for (ValueIndex = 0; AppNameMapping != NULL; ValueIndex++) {
                Status = NtEnumerateValueKey( SubKeyHandle,
                                              ValueIndex,
                                              KeyValueFullInformation,
                                              KeyValueInformation,
                                              sizeof( Buffer ),
                                              &ResultLength
                                            );
                if (Status == STATUS_NO_MORE_ENTRIES) {
                    break;
                    }
                else
                if (!NT_SUCCESS( Status )) {
                    KdPrint(( "BASESRV: NtEnumerateValueKey failed - Status == %08lx\n", Status ));
                    break;
                    }

                ValueName.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
                ValueName.Length = (USHORT)KeyValueInformation->NameLength;
                ValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;
                if (KeyValueInformation->Type != REG_SZ) {
                    KdPrint(( "BASESRV: Ignoring %wZ mapping, invalid type == %u\n",
                              &ValueName, KeyValueInformation->Type
                           ));
                    }
                else {
                    BaseSrvSaveVarNameMapping( FileNameMapping,
                                               AppNameMapping,
                                               &ValueName,
                                               (PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset),
                                               &VarNameMapping
                                             );
                    }
                }

            NtClose( SubKeyHandle );
            }
        }

    return Status;
}


BOOLEAN
BaseSrvSaveFileNameMapping(
    IN PUNICODE_STRING FileName,
    OUT PINIFILE_MAPPING_FILENAME *ReturnedFileNameMapping
    )
{
    PINIFILE_MAPPING_FILENAME FileNameMapping;

    FileNameMapping = RtlAllocateHeap( BaseSrvSharedHeap,
                                       MAKE_SHARED_TAG( INI_TAG ) | HEAP_ZERO_MEMORY,
                                       sizeof( *FileNameMapping ) +
                                         FileName->MaximumLength
                                     );
    if (FileNameMapping == NULL) {
        return FALSE;
        }

    if (FileName->Length != 0) {
        FileNameMapping->Name.Buffer = (PWSTR)(FileNameMapping + 1);
        FileNameMapping->Name.MaximumLength = FileName->MaximumLength;
        RtlCopyUnicodeString( &FileNameMapping->Name, FileName );
        }

    *ReturnedFileNameMapping = FileNameMapping;
    return TRUE;
}


BOOLEAN
BaseSrvSaveAppNameMapping(
    IN OUT PINIFILE_MAPPING_FILENAME FileNameMapping,
    IN PUNICODE_STRING ApplicationName,
    OUT PINIFILE_MAPPING_APPNAME *ReturnedAppNameMapping
    )
{
    PINIFILE_MAPPING_APPNAME AppNameMapping, *pp;

    if (ApplicationName->Length != 0) {
        pp = &FileNameMapping->ApplicationNames;
        while (AppNameMapping = *pp) {
            if (RtlEqualUnicodeString( ApplicationName, &AppNameMapping->Name, TRUE )) {
                break;
                }

            pp = &AppNameMapping->Next;
            }
        }
    else {
        pp = &FileNameMapping->DefaultAppNameMapping;
        AppNameMapping = *pp;
        }

    if (AppNameMapping != NULL) {
        KdPrint(( "BASESRV: Duplicate application name mapping [%ws] %ws\n",
                  &FileNameMapping->Name,
                  &AppNameMapping->Name
               ));
        return FALSE;
        }

    AppNameMapping = RtlAllocateHeap( BaseSrvSharedHeap,
                                      MAKE_SHARED_TAG( INI_TAG ) | HEAP_ZERO_MEMORY,
                                      sizeof( *AppNameMapping ) +
                                        ApplicationName->MaximumLength
                                    );
    if (AppNameMapping == NULL) {
        return FALSE;
        }

    if (ApplicationName->Length != 0) {
        AppNameMapping->Name.Buffer = (PWSTR)(AppNameMapping + 1);
        AppNameMapping->Name.MaximumLength = ApplicationName->MaximumLength;
        RtlCopyUnicodeString( &AppNameMapping->Name, ApplicationName );
        }

    *pp = AppNameMapping;
    *ReturnedAppNameMapping = AppNameMapping;
    return TRUE;
}


BOOLEAN
BaseSrvSaveVarNameMapping(
    IN PINIFILE_MAPPING_FILENAME FileNameMapping,
    IN OUT PINIFILE_MAPPING_APPNAME AppNameMapping,
    IN PUNICODE_STRING VariableName,
    IN PWSTR RegistryPath,
    OUT PINIFILE_MAPPING_VARNAME *ReturnedVarNameMapping
    )
{
    PINIFILE_MAPPING_TARGET MappingTarget;
    PINIFILE_MAPPING_VARNAME VarNameMapping, *pp;
    ULONG MappingFlags;

    if (VariableName->Length != 0) {
        pp = &AppNameMapping->VariableNames;
        while (VarNameMapping = *pp) {
            if (RtlEqualUnicodeString( VariableName, &VarNameMapping->Name, TRUE )) {
                break;
                }

            pp = &VarNameMapping->Next;
            }
        }
    else {
        pp = &AppNameMapping->DefaultVarNameMapping;
        VarNameMapping = *pp;
        }

    if (VarNameMapping != NULL) {
        KdPrint(( "BASESRV: Duplicate variable name mapping [%ws] %ws . %ws\n",
                  &FileNameMapping->Name,
                  &AppNameMapping->Name,
                  &VarNameMapping->Name
               ));
        return FALSE;
        }

    MappingTarget = BaseSrvSaveMappingTarget( RegistryPath, &MappingFlags );
    if (MappingTarget == NULL) {
        return FALSE;
        }

    VarNameMapping = RtlAllocateHeap( BaseSrvSharedHeap,
                                      MAKE_SHARED_TAG( INI_TAG ) | HEAP_ZERO_MEMORY,
                                      sizeof( *VarNameMapping ) +
                                        VariableName->MaximumLength
                                    );
    if (VarNameMapping == NULL) {
        return FALSE;
        }

    VarNameMapping->MappingFlags = MappingFlags;
    VarNameMapping->MappingTarget = MappingTarget;
    if (VariableName->Length != 0) {
        VarNameMapping->Name.Buffer = (PWSTR)(VarNameMapping + 1);
        VarNameMapping->Name.MaximumLength = VariableName->MaximumLength;
        RtlCopyUnicodeString( &VarNameMapping->Name, VariableName );
        }

    *pp = VarNameMapping;
    *ReturnedVarNameMapping = VarNameMapping;
    return TRUE;
}


PINIFILE_MAPPING_TARGET
BaseSrvSaveMappingTarget(
    IN PWSTR RegistryPath,
    OUT PULONG MappingFlags
    )
{
    BOOLEAN RelativePath;
    UNICODE_STRING RegistryPathString;
    PWSTR SaveRegistryPath;
    PINIFILE_MAPPING_TARGET MappingTarget, *pp;
    ULONG Flags;

    Flags = 0;
    SaveRegistryPath = RegistryPath;
    while (TRUE) {
        if (*RegistryPath == L'!') {
            Flags |= INIFILE_MAPPING_WRITE_TO_INIFILE_TOO;
            RegistryPath += 1;
            }
        else
        if (*RegistryPath == L'#') {
            Flags |= INIFILE_MAPPING_INIT_FROM_INIFILE;
            RegistryPath += 1;
            }
        else
        if (*RegistryPath == L'@') {
            Flags |= INIFILE_MAPPING_READ_FROM_REGISTRY_ONLY;
            RegistryPath += 1;
            }
        else
        if (!_wcsnicmp( RegistryPath, L"USR:", 4 )) {
            Flags |= INIFILE_MAPPING_USER_RELATIVE;
            RegistryPath += 4;
            break;
            }
        else
        if (!_wcsnicmp( RegistryPath, L"SYS:", 4 )) {
            Flags |= INIFILE_MAPPING_SOFTWARE_RELATIVE;
            RegistryPath += 4;
            break;
            }
        else {
            break;
            }
        }

    if (Flags & (INIFILE_MAPPING_USER_RELATIVE | INIFILE_MAPPING_SOFTWARE_RELATIVE)) {
        RelativePath = TRUE;
        }
    else {
        RelativePath = FALSE;
        }

    if ((RelativePath && *RegistryPath != OBJ_NAME_PATH_SEPARATOR) ||
        (!RelativePath && *RegistryPath == OBJ_NAME_PATH_SEPARATOR)
       ) {
        RtlInitUnicodeString( &RegistryPathString, RegistryPath );
        }
    else
    if (!RelativePath && *RegistryPath == UNICODE_NULL) {
        RtlInitUnicodeString( &RegistryPathString, NULL );
        }
    else {
        KdPrint(( "BASESRV: Ignoring invalid mapping target - %ws\n",
                  SaveRegistryPath
               ));
        return NULL;
        }

    pp = &BaseSrvMappingTargetHead;
    while (MappingTarget = *pp) {
        if (RtlEqualUnicodeString( &RegistryPathString, &MappingTarget->RegistryPath, TRUE )) {
            *MappingFlags = Flags;
            return MappingTarget;
            }

        pp = &MappingTarget->Next;
        }

    MappingTarget = RtlAllocateHeap( BaseSrvSharedHeap,
                                     MAKE_SHARED_TAG( INI_TAG ) | HEAP_ZERO_MEMORY,
                                     sizeof( *MappingTarget ) +
                                       RegistryPathString.MaximumLength
                                   );
    if (MappingTarget != NULL) {
        *MappingFlags = Flags;
        *pp = MappingTarget;
        if (RegistryPathString.Length != 0) {
            MappingTarget->RegistryPath.Buffer = (PWSTR)(MappingTarget + 1);
            MappingTarget->RegistryPath.Length = 0;
            MappingTarget->RegistryPath.MaximumLength = RegistryPathString.MaximumLength;
            RtlCopyUnicodeString( &MappingTarget->RegistryPath, &RegistryPathString );
            }
        }
    else {
        KdPrint(( "BASESRV: Unable to allocate memory for mapping target - %ws\n", RegistryPath ));
        }

    return MappingTarget;
}


BOOLEAN
BaseSrvEqualVarNameMappings(
    PINIFILE_MAPPING_VARNAME VarNameMapping1,
    PINIFILE_MAPPING_VARNAME VarNameMapping2
    )
{
    if (VarNameMapping1 == NULL) {
        if (VarNameMapping2 == NULL) {
            return TRUE;
            }
        else {
            return FALSE;
            }
        }
    else
    if (VarNameMapping2 == NULL) {
        return FALSE;
        }

    if (RtlEqualUnicodeString( &VarNameMapping1->Name,
                               &VarNameMapping2->Name,
                               TRUE
                             ) &&
        VarNameMapping1->MappingFlags == VarNameMapping2->MappingFlags &&
        VarNameMapping1->MappingTarget == VarNameMapping2->MappingTarget &&
        BaseSrvEqualVarNameMappings( VarNameMapping1->Next,
                                     VarNameMapping2->Next
                                   )
       ) {
        return TRUE;
        }
    else {
        return FALSE;
        }
}


BOOLEAN
BaseSrvEqualAppNameMappings(
    PINIFILE_MAPPING_APPNAME AppNameMapping1,
    PINIFILE_MAPPING_APPNAME AppNameMapping2
    )
{
    if (AppNameMapping1 == NULL) {
        if (AppNameMapping2 == NULL) {
            return TRUE;
            }
        else {
            return FALSE;
            }
        }
    else
    if (AppNameMapping2 == NULL) {
        return FALSE;
        }

    if (RtlEqualUnicodeString( &AppNameMapping1->Name,
                               &AppNameMapping2->Name,
                               TRUE
                             ) &&
        BaseSrvEqualVarNameMappings( AppNameMapping1->VariableNames,
                                     AppNameMapping2->VariableNames
                                   ) &&
        BaseSrvEqualVarNameMappings( AppNameMapping1->DefaultVarNameMapping,
                                     AppNameMapping2->DefaultVarNameMapping
                                   ) &&
        BaseSrvEqualAppNameMappings( AppNameMapping1->Next,
                                     AppNameMapping2->Next
                                   )
       ) {
        return TRUE;
        }
    else {
        return FALSE;
        }
}


BOOLEAN
BaseSrvEqualFileMappings(
    PINIFILE_MAPPING_FILENAME FileNameMapping1,
    PINIFILE_MAPPING_FILENAME FileNameMapping2
    )
{
    if (RtlEqualUnicodeString( &FileNameMapping1->Name,
                               &FileNameMapping2->Name,
                               TRUE
                             ) &&
        BaseSrvEqualAppNameMappings( FileNameMapping1->ApplicationNames,
                                     FileNameMapping2->ApplicationNames
                                   ) &&
        BaseSrvEqualAppNameMappings( FileNameMapping1->DefaultAppNameMapping,
                                     FileNameMapping2->DefaultAppNameMapping
                                   )
       ) {
        return TRUE;
        }
    else {
        return FALSE;
        }
}


VOID
BaseSrvFreeVarNameMapping(
    PINIFILE_MAPPING_VARNAME VarNameMapping
    )
{
    if (VarNameMapping != NULL) {
        BaseSrvFreeVarNameMapping( VarNameMapping->Next );
        RtlFreeHeap( BaseSrvSharedHeap, HEAP_NO_SERIALIZE, VarNameMapping );
        }

    return;
}


VOID
BaseSrvFreeAppNameMapping(
    PINIFILE_MAPPING_APPNAME AppNameMapping
    )
{
    if (AppNameMapping != NULL) {
        BaseSrvFreeVarNameMapping( AppNameMapping->VariableNames );
        BaseSrvFreeVarNameMapping( AppNameMapping->DefaultVarNameMapping );
        BaseSrvFreeAppNameMapping( AppNameMapping->Next );
        RtlFreeHeap( BaseSrvSharedHeap, HEAP_NO_SERIALIZE, AppNameMapping );
        }

    return;
}


VOID
BaseSrvFreeFileMapping(
    PINIFILE_MAPPING_FILENAME FileNameMapping
    )
{
    if (FileNameMapping != NULL) {
        BaseSrvFreeAppNameMapping( FileNameMapping->ApplicationNames );
        BaseSrvFreeAppNameMapping( FileNameMapping->DefaultAppNameMapping );
        RtlFreeHeap( BaseSrvSharedHeap, HEAP_NO_SERIALIZE, FileNameMapping );
        }

    return;
}


ULONG
BaseSrvRefreshIniFileMapping(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_REFRESHINIFILEMAPPING_MSG a = (PBASE_REFRESHINIFILEMAPPING_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    HANDLE IniFileMappingRoot;
    PINIFILE_MAPPING_FILENAME FileNameMapping, FileNameMapping1, *pp;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE SubKeyHandle;
    UNICODE_STRING WinIniFileName;
    UNICODE_STRING NullString;

    Status = STATUS_SUCCESS;

    if (!CsrValidateMessageBuffer(m, &a->IniFileName.Buffer, a->IniFileName.Length, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlInitUnicodeString( &WinIniFileName, L"win.ini" );
    RtlInitUnicodeString( &NullString, NULL );

    RtlInitUnicodeString( &KeyName,
                          L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping"
                        );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &IniFileMappingRoot,
                        GENERIC_READ,
                        &ObjectAttributes
                      );
    if (!NT_SUCCESS( Status )) {
        KdPrint(( "BASESRV: Unable to open %wZ key - Status == %0x\n", &KeyName, Status ));
        return (ULONG)Status;
        }

    InitializeObjectAttributes( &ObjectAttributes,
                                &a->IniFileName,
                                OBJ_CASE_INSENSITIVE,
                                IniFileMappingRoot,
                                NULL
                              );

    Status = NtOpenKey( &SubKeyHandle,
                        GENERIC_READ,
                        &ObjectAttributes
                      );
    if (NT_SUCCESS( Status )) {
        if (!BaseSrvSaveFileNameMapping( &a->IniFileName, &FileNameMapping )) {
            Status = STATUS_NO_MEMORY;
            }
        else {
            Status = BaseSrvSaveIniFileMapping( FileNameMapping, SubKeyHandle );
            if (NT_SUCCESS( Status )) {
                RtlLockHeap( BaseSrvSharedHeap );
                try {
                    pp = &BaseSrvIniFileMapping->FileNames;
                    while (FileNameMapping1 = *pp) {
                        if (RtlEqualUnicodeString( &FileNameMapping1->Name, &a->IniFileName, TRUE )) {
                            if (BaseSrvEqualFileMappings( FileNameMapping, FileNameMapping1 )) {
                                //
                                // If old and new mappings the same, free up new and return
                                //

                                BaseSrvFreeFileMapping( FileNameMapping );
                                FileNameMapping = NULL;
                                }
                            else {
                                //
                                // Remove found mapping from list
                                //

                                *pp = FileNameMapping1->Next;
                                FileNameMapping1->Next = NULL;
                                }
                            break;
                            }
                        else {
                            pp = &FileNameMapping1->Next;
                            }
                        }

                    if (FileNameMapping != NULL) {
                        //
                        // Insert new (or different) mapping into list (at end if not found)
                        //

                        FileNameMapping->Next = *pp;
                        *pp = FileNameMapping;
                        }
                    }
                except( EXCEPTION_EXECUTE_HANDLER ) {
                    Status = GetExceptionCode();
                    }

                RtlUnlockHeap( BaseSrvSharedHeap );

                if (NT_SUCCESS( Status ) && FileNameMapping != NULL) {
                    if (RtlEqualUnicodeString( &FileNameMapping->Name, &WinIniFileName, TRUE )) {
                        BaseSrvIniFileMapping->WinIniFileMapping = FileNameMapping;
                        }
                    }
                }
            else {
                KdPrint(( "BASESRV: Unable to load mappings for %wZ - Status == %x\n",
                          &FileNameMapping->Name, Status
                       ));
                RtlFreeHeap( BaseSrvSharedHeap, 0, FileNameMapping );
                }
            }

        NtClose( SubKeyHandle );
        }

    NtClose( IniFileMappingRoot );

    return (ULONG)Status;
    ReplyStatus;    // get rid of unreferenced parameter warning message
}


NTSTATUS NtCreateAdminsSid( PSID *ppAdminSid )
{
    NTSTATUS Status;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    ASSERT(ppAdminSid != NULL);

    Status = RtlAllocateAndInitializeSid(
            &SidAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &pSid
            );

    if (NT_SUCCESS(Status))
    {
        *ppAdminSid = pSid;
    }

    return(Status);
}

NTSTATUS NtCreateSystemSid( PSID *ppSystemSid )
{
    NTSTATUS Status;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    ASSERT(ppSystemSid != NULL);

    Status = RtlAllocateAndInitializeSid(
            &SidAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pSid
            );

    if (NT_SUCCESS(Status))
    {
        *ppSystemSid = pSid;
    }

    return(Status);
}


BOOL  IsCallerAdminsOrSystem( VOID )
{
    
    HANDLE   ClientToken;
    ULONG    i;
    ULONG    RequiredLength=0;
    NTSTATUS Status = STATUS_SUCCESS;
    PSID    pAdminsSID=0;
    PSID    pSystemSID=0;
    BOOL    callerIsAdminsOrSystem = FALSE;

    Status = NtCreateAdminsSid( &pAdminsSID );
    if (!NT_SUCCESS(Status))
        goto Error;

    Status = NtCreateSystemSid( &pSystemSID );
    if (!NT_SUCCESS(Status))
        goto Error;

    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_QUERY,
                TRUE,      // use the impersonation context
                &ClientToken
                );

    if (!NT_SUCCESS(Status))
        goto Error;

    // call it once to get the size of buffer we need from RequiredLength
    Status = NtQueryInformationToken(
                 ClientToken,
                 TokenGroups,
                 NULL,
                 0,
                 &RequiredLength );

    if (RequiredLength > 0)
    {
        PTOKEN_GROUPS    TokenGroupInformation = NULL;

        //
        // Allocate enough memory
        //
        TokenGroupInformation = (PTOKEN_GROUPS) RtlAllocateHeap ( RtlProcessHeap(),
                                                 MAKE_TAG( TMP_TAG ),  // what tag to use ???
                                                 RequiredLength );

        if (NULL==TokenGroupInformation)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token for the group memberships
        //

        Status = NtQueryInformationToken(
                    ClientToken,
                    TokenGroups,
                    TokenGroupInformation,
                    RequiredLength,
                    &RequiredLength
                    );

       for (i=0;i<TokenGroupInformation->GroupCount;i++)
       {
            if(RtlEqualSid(TokenGroupInformation->Groups[i].Sid, pAdminsSID ))
            {
                callerIsAdminsOrSystem= TRUE;
                break;
            }
            else if (RtlEqualSid(TokenGroupInformation->Groups[i].Sid, pSystemSID ))
            {
                callerIsAdminsOrSystem= TRUE;
                break;
            }
       }

       RtlFreeHeap( RtlProcessHeap(), 0, TokenGroupInformation );

    }

Error:
    if (pAdminsSID)
    {
        RtlFreeSid( pAdminsSID );
    }

    if (pSystemSID)
    {
        RtlFreeSid( pSystemSID );
    }

    return callerIsAdminsOrSystem;

}


ULONG
BaseSrvSetTermsrvAppInstallMode(IN OUT PCSR_API_MSG m,
                         IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    BOOL        RevertToSelfNeeded;

    PBASE_SET_TERMSRVAPPINSTALLMODE b = (PBASE_SET_TERMSRVAPPINSTALLMODE)&m->u.ApiMessageData;

    try {

        RevertToSelfNeeded = CsrImpersonateClient( NULL );  // This stacks client contexts

        if( RevertToSelfNeeded == FALSE ) {
            Status = STATUS_BAD_IMPERSONATION_LEVEL;
            leave;
        }
        else
        {
            if ( IsCallerAdminsOrSystem () )
            {
                if ( b->bState )
                    BaseSrvpStaticServerData->fTermsrvAppInstallMode = TRUE;
                else
                    BaseSrvpStaticServerData->fTermsrvAppInstallMode = FALSE;
            }
        }
    }
    finally
    {
        if ( RevertToSelfNeeded )
        {
            CsrRevertToSelf();    
        }
    }


    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvinit.c

Abstract:

    This is the main initialization file for the Windows 32-bit Base API
    Server DLL.

Author:

    Steve Wood (stevewo) 10-Oct-1990

Revision History:

--*/

#include "basesrv.h"

//
// needed for definitions of structures when broadcasting a message to all
// the windows that have the caller's LUID
//
#include <dbt.h>

//
//  TS broadcast support
//
#include <winsta.h>

#define NT_DRIVE_LETTER_PATH_LENGTH   8   // "\??\X:<NULL>" = 7 chars

// Protection mode for named objects
ULONG   ProtectionMode = 0;

UNICODE_STRING BaseSrvCSDString;
ULONG BaseSrvCSDNumber;
UNICODE_STRING BaseSrvKernel32DllPath;
UNICODE_STRING BaseSrvSxsDllPath;
UNICODE_STRING UnexpandedSystemRootString = RTL_CONSTANT_STRING(L"%SystemRoot%");

RTL_QUERY_REGISTRY_TABLE BaseServerRegistryConfigurationTable[] = {
    {NULL,                      RTL_QUERY_REGISTRY_DIRECT,
     L"CSDVersion",             &BaseSrvCSDString,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}
};

RTL_QUERY_REGISTRY_TABLE BaseServerRegistryConfigurationTable1[] = {
    {NULL,                      RTL_QUERY_REGISTRY_DIRECT,
     L"CSDVersion",             &BaseSrvCSDNumber,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}
};

CONST PCSR_API_ROUTINE BaseServerApiDispatchTable[BasepMaxApiNumber + 1] = {
    BaseSrvCreateProcess,              // BasepCreateProcess
    BaseSrvCreateThread,               // BasepCreateThread
    BaseSrvGetTempFile,                // BasepGetTempFile
    BaseSrvExitProcess,                // BasepExitProcess
    BaseSrvDebugProcess,               // BasepDebugProcess
    BaseSrvCheckVDM,                   // BasepCheckVDM
    BaseSrvUpdateVDMEntry,             // BasepUpdateVDMEntry
    BaseSrvGetNextVDMCommand,          // BasepGetNextVDMCommand
    BaseSrvExitVDM,                    // BasepExitVDM
    BaseSrvIsFirstVDM,                 // BasepIsFirstVDM
    BaseSrvGetVDMExitCode,             // BasepGetVDMExitCode
    BaseSrvSetReenterCount,            // BasepSetReenterCount
    BaseSrvSetProcessShutdownParam,    // BasepSetProcessShutdownParam
    BaseSrvGetProcessShutdownParam,    // BasepGetProcessShutdownParam
    BaseSrvNlsSetUserInfo,             // BasepNlsSetUserInfo
    BaseSrvNlsSetMultipleUserInfo,     // BasepNlsSetMultipleUserInfo
    BaseSrvNlsCreateSection,           // BasepNlsCreateSection
    BaseSrvSetVDMCurDirs,              // BasepSetVDMCurDirs
    BaseSrvGetVDMCurDirs,              // BasepGetVDMCurDirs
    BaseSrvBatNotification,            // BasepBatNotification
    BaseSrvRegisterWowExec,            // BasepRegisterWowExec
    BaseSrvSoundSentryNotification,    // BasepSoundSentryNotification
    BaseSrvRefreshIniFileMapping,      // BasepRefreshIniFileMapping
    BaseSrvDefineDosDevice,            // BasepDefineDosDevice
    BaseSrvSetTermsrvAppInstallMode,   // BasepSetTermsrvAppInstallMode
    BaseSrvNlsUpdateCacheCount,        // BasepNlsUpdateCacheCount
    BaseSrvSetTermsrvClientTimeZone,   // BasepSetTermsrvClientTimeZone
    BaseSrvSxsCreateActivationContext, // BasepSxsCreateActivationContext
    BaseSrvDebugProcessStop,           // BasepDebugProcessStop
    BaseSrvRegisterThread,             // BasepRegisterThread
    BaseSrvCheckApplicationCompatibility, // BasepCheckApplicationCompatibility
    BaseSrvNlsGetUserInfo,             // BaseSrvNlsGetUserInfo
    NULL                               // BasepMaxApiNumber
};

BOOLEAN BaseServerApiServerValidTable[BasepMaxApiNumber + 1] = {
    TRUE,    // SrvCreateProcess,
    TRUE,    // SrvCreateThread,
    TRUE,    // SrvGetTempFile,
    FALSE,   // SrvExitProcess,
    FALSE,   // SrvDebugProcess,
    TRUE,    // SrvCheckVDM,
    TRUE,    // SrvUpdateVDMEntry
    TRUE,    // SrvGetNextVDMCommand
    TRUE,    // SrvExitVDM
    TRUE,    // SrvIsFirstVDM
    TRUE,    // SrvGetVDMExitCode
    TRUE,    // SrvSetReenterCount
    TRUE,    // SrvSetProcessShutdownParam
    TRUE,    // SrvGetProcessShutdownParam
    TRUE,    // SrvNlsSetUserInfo
    TRUE,    // SrvNlsSetMultipleUserInfo
    TRUE,    // SrvNlsCreateSection
    TRUE,    // SrvSetVDMCurDirs
    TRUE,    // SrvGetVDMCurDirs
    TRUE,    // SrvBatNotification
    TRUE,    // SrvRegisterWowExec
    TRUE,    // SrvSoundSentryNotification
    TRUE,    // SrvRefreshIniFileMapping
    TRUE,    // SrvDefineDosDevice
    TRUE,    // SrvSetTermsrvAppInstallMode
    TRUE,    // SrvNlsUpdateCacheCount,
    TRUE,    // SrvSetTermsrvClientTimeZone
    TRUE,    // SrvSxsCreateActivationContext
    TRUE,    // SrvDebugProcessStop
    TRUE,    // SrvRegisterThread,
    TRUE,    // SrvCheckApplicationCompatibility
    TRUE,    // BaseSrvNlsGetUserInfo
    FALSE
};

#if DBG
CONST PSZ BaseServerApiNameTable[BasepMaxApiNumber + 1] = {
    "BaseCreateProcess",
    "BaseCreateThread",
    "BaseGetTempFile",
    "BaseExitProcess",
    "BaseDebugProcess",
    "BaseCheckVDM",
    "BaseUpdateVDMEntry",
    "BaseGetNextVDMCommand",
    "BaseExitVDM",
    "BaseIsFirstVDM",
    "BaseGetVDMExitCode",
    "BaseSetReenterCount",
    "BaseSetProcessShutdownParam",
    "BaseGetProcessShutdownParam",
    "BaseNlsSetUserInfo",
    "BaseNlsSetMultipleUserInfo",
    "BaseNlsCreateSection",
    "BaseSetVDMCurDirs",
    "BaseGetVDMCurDirs",
    "BaseBatNotification",
    "BaseRegisterWowExec",
    "BaseSoundSentryNotification",
    "BaseSrvRefreshIniFileMapping"
    "BaseDefineDosDevice",
    "BaseSrvSetTermsrvAppInstallMode",
    "BaseSrvNlsUpdateCacheCount",
    "BaseSrvSetTermsrvClientTimeZone",
    "BaseSrvSxsCreateActivationContext",
    "BaseSrvDebugProcessStop",
    "BaseRegisterThread",
    "BaseCheckApplicationCompatibility",
    "BaseNlsGetUserInfo",
    NULL
};
#endif // DBG

HANDLE BaseSrvNamedObjectDirectory;
HANDLE BaseSrvRestrictedObjectDirectory;
RTL_CRITICAL_SECTION BaseSrvDosDeviceCritSec;

#if defined(_WIN64)
SYSTEM_BASIC_INFORMATION SysInfo;
#endif

//
// With LUID Device Maps,
// Use BroadCastSystemMessageEx to broadcast the message to all the windows
// with the LUID
// Function pointer to BroadCastSystemMessageEx
//
long (WINAPI *PBROADCASTSYSTEMMESSAGEEXW)( DWORD, LPDWORD, UINT, WPARAM, LPARAM, PBSMINFO ) = NULL;

//
// Data structures and functions used for broadcast drive letter
// change to application and the desktop with the caller's LUID
//
typedef struct _DDD_BSM_REQUEST *PDDD_BSM_REQUEST;

typedef struct _DDD_BSM_REQUEST {
    PDDD_BSM_REQUEST pNextRequest;
    LUID Luid;
    DWORD iDrive;
    BOOLEAN DeleteRequest;
} DDD_BSM_REQUEST, *PDDD_BSM_REQUEST;

PDDD_BSM_REQUEST BSM_Request_Queue = NULL;

PDDD_BSM_REQUEST BSM_Request_Queue_End = NULL;

RTL_CRITICAL_SECTION BaseSrvDDDBSMCritSec;

LONG BaseSrvpBSMThreadCount = 0;

#define BaseSrvpBSMThreadMax 1

#define PREALLOCATE_EVENT_MASK 0x80000000

//
//  TS broadcast support
//
#define DEFAULT_BROADCAST_TIME_OUT 5

typedef LONG (*FP_WINSTABROADCASTSYSTEMMESSAGE)(HANDLE  hServer,
                                                BOOL    sendToAllWinstations,
                                                ULONG   sessionID,
                                                ULONG   timeOut,
                                                DWORD   dwFlags,
                                                DWORD   *lpdwRecipients,
                                                ULONG   uiMessage,
                                                WPARAM  wParam,
                                                LPARAM  lParam,
                                                LONG    *pResponse);

NTSTATUS
SendWinStationBSM (
    DWORD dwFlags,
    LPDWORD lpdwRecipients,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam
    );
//
//  END: TS broadcast support
//

NTSTATUS
AddBSMRequest(
    IN DWORD iDrive,
    IN BOOLEAN DeleteRequest,
    IN PLUID pLuid
    );

NTSTATUS
CreateBSMThread();

NTSTATUS
BaseSrvBSMThread(
    PVOID pJunk
    );

BOOLEAN
CheckForGlobalDriveLetter (
    DWORD iDrive
    );
//
// END: broadcast drive letter change
//

WORD
ConvertUnicodeToWord( PWSTR s );

NTSTATUS
CreateBaseAcls( PACL *Dacl, PACL *RestrictedDacl );

NTSTATUS
IsGlobalSymbolicLink(
    IN HANDLE hSymLink,
    OUT PBOOLEAN pbGlobalSymLink);

NTSTATUS
GetCallerLuid (
    OUT PLUID pLuid);

NTSTATUS
BroadcastDriveLetterChange(
    IN DWORD iDrive,
    IN BOOLEAN DeleteRequest,
    IN PLUID pLuid);

WORD
ConvertUnicodeToWord( PWSTR s )
{
    NTSTATUS Status;
    ULONG Result;
    UNICODE_STRING UnicodeString;

    while (*s && *s <= L' ') {
        s += 1;
        }

    RtlInitUnicodeString( &UnicodeString, s );
    Status = RtlUnicodeStringToInteger( &UnicodeString,
                                        10,
                                        &Result
                                      );
    if (!NT_SUCCESS( Status )) {
        Result = 0;
        }


    return (WORD)Result;
}



NTSTATUS
ServerDllInitialization(
    PCSR_SERVER_DLL LoadedServerDll
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    PSECURITY_DESCRIPTOR PrimarySecurityDescriptor;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    PVOID p;
    WCHAR ValueBuffer[ 400 ];
    UNICODE_STRING NameString, ValueString;
    HANDLE KeyHandle;
    PWSTR s, s1;
    PACL Dacl, RestrictedDacl;
    WCHAR szObjectDirectory[MAX_SESSION_PATH];
    HANDLE SymbolicLinkHandle;
    UNICODE_STRING LinkTarget;
    ULONG attributes = OBJ_CASE_INSENSITIVE | OBJ_OPENIF;
    ULONG LUIDDeviceMapsEnabled;


    //
    // Id of the Terminal Server Session to which this CSRSS belongs.
    // SessionID == 0 is always console session (Standard NT).
    //
    SessionId = NtCurrentPeb()->SessionId;

    //
    // Object directories are only permanent for the console session
    //
    if (SessionId == 0) {

        attributes |= OBJ_PERMANENT;

    }


    BaseSrvHeap = RtlProcessHeap();
    BaseSrvTag = RtlCreateTagHeap( BaseSrvHeap,
                                   0,
                                   L"BASESRV!",
                                   L"TMP\0"
                                   L"VDM\0"
                                   L"SXS\0"
                                 );

    BaseSrvSharedHeap = LoadedServerDll->SharedStaticServerData;
    BaseSrvSharedTag = RtlCreateTagHeap( BaseSrvSharedHeap,
                                         0,
                                         L"BASESHR!",
                                         L"INIT\0"
                                         L"INI\0"
                                       );

    LoadedServerDll->ApiNumberBase = BASESRV_FIRST_API_NUMBER;
    LoadedServerDll->MaxApiNumber = BasepMaxApiNumber;
    LoadedServerDll->ApiDispatchTable = BaseServerApiDispatchTable;
    LoadedServerDll->ApiServerValidTable = BaseServerApiServerValidTable;
#if DBG
    LoadedServerDll->ApiNameTable = BaseServerApiNameTable;
#endif
    LoadedServerDll->PerProcessDataLength = 0;
    LoadedServerDll->ConnectRoutine = BaseClientConnectRoutine;
    LoadedServerDll->DisconnectRoutine = BaseClientDisconnectRoutine;

    Status = RtlInitializeCriticalSection (&BaseSrvDosDeviceCritSec);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ValueString.Buffer = ValueBuffer;
    ValueString.Length = 0;
    ValueString.MaximumLength = sizeof( ValueBuffer );
    Status = RtlExpandEnvironmentStrings_U( NULL,
                                            &UnexpandedSystemRootString,
                                            &ValueString,
                                            NULL
                                          );

    //
    // RtlCreateUnicodeString includes a terminal nul.
    // It makes a heap allocated copy.
    // These strings are never freed.
    //
    ASSERT( NT_SUCCESS( Status ) );
    ValueBuffer[ ValueString.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
    if (!RtlCreateUnicodeString( &BaseSrvWindowsDirectory, ValueBuffer ))
        goto OutOfMemory;

    wcscat(ValueBuffer, L"\\system32" );
    if (!RtlCreateUnicodeString( &BaseSrvWindowsSystemDirectory, ValueBuffer ))
        goto OutOfMemory;

    wcscat(ValueBuffer, L"\\kernel32.dll" );
    if (!RtlCreateUnicodeString( &BaseSrvKernel32DllPath, ValueBuffer ))
        goto OutOfMemory;

    wcscpy(ValueBuffer, BaseSrvWindowsSystemDirectory.Buffer);
    wcscat(ValueBuffer, L"\\sxs.dll");
    if (!RtlCreateUnicodeString( &BaseSrvSxsDllPath, ValueBuffer ))
        goto OutOfMemory;

#ifdef WX86
    wcscpy(ValueBuffer, BaseSrvWindowsDirectory.Buffer);
    wcscat(ValueBuffer, L"\\Sys32x86" );
    if (!RtlCreateUnicodeString( &BaseSrvWindowsSys32x86Directory, ValueBuffer))
        goto OutOfMemory;
#endif


    //
    // need to synch this w/ user's desktop concept
    //


    if (SessionId == 0) {
       //
       // Console Session
       //

       wcscpy(szObjectDirectory,L"\\BaseNamedObjects" );

    } else {

       swprintf(szObjectDirectory,L"%ws\\%ld\\BaseNamedObjects",
                                                 SESSION_ROOT,SessionId);

    }

    RtlInitUnicodeString(&UnicodeString,szObjectDirectory);
    //
    // initialize base static server data
    //

    BaseSrvpStaticServerData = RtlAllocateHeap( BaseSrvSharedHeap,
                                                MAKE_SHARED_TAG( INIT_TAG ),
                                                sizeof( BASE_STATIC_SERVER_DATA )
                                              );
    if ( !BaseSrvpStaticServerData ) {
        return STATUS_NO_MEMORY;
    }
    LoadedServerDll->SharedStaticServerData = (PVOID)BaseSrvpStaticServerData;

    BaseSrvpStaticServerData->TermsrvClientTimeZoneId=TIME_ZONE_ID_INVALID;

    Status = NtQuerySystemInformation(
                SystemTimeOfDayInformation,
                (PVOID)&BaseSrvpStaticServerData->TimeOfDay,
                sizeof(BaseSrvpStaticServerData->TimeOfDay),
                NULL
                );
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    //
    // windows directory
    //

    BaseSrvpStaticServerData->WindowsDirectory = BaseSrvWindowsDirectory;
    p = RtlAllocateHeap( BaseSrvSharedHeap,
                         MAKE_SHARED_TAG( INIT_TAG ),
                         BaseSrvWindowsDirectory.MaximumLength
                       );
    if ( !p ) {
        return STATUS_NO_MEMORY;
    }

    RtlCopyMemory(p,BaseSrvpStaticServerData->WindowsDirectory.Buffer,BaseSrvWindowsDirectory.MaximumLength);
    BaseSrvpStaticServerData->WindowsDirectory.Buffer = p;

    //
    // windows system directory
    //

    BaseSrvpStaticServerData->WindowsSystemDirectory = BaseSrvWindowsSystemDirectory;
    p = RtlAllocateHeap( BaseSrvSharedHeap,
                         MAKE_SHARED_TAG( INIT_TAG ),
                         BaseSrvWindowsSystemDirectory.MaximumLength
                       );
    if ( !p ) {
        return STATUS_NO_MEMORY;
    }
    RtlCopyMemory(p,BaseSrvpStaticServerData->WindowsSystemDirectory.Buffer,BaseSrvWindowsSystemDirectory.MaximumLength);
    BaseSrvpStaticServerData->WindowsSystemDirectory.Buffer = p;

    BaseSrvpStaticServerData->WindowsSys32x86Directory.Buffer = NULL;
    BaseSrvpStaticServerData->WindowsSys32x86Directory.Length = 0;
    BaseSrvpStaticServerData->WindowsSys32x86Directory.MaximumLength = 0;

    //
    // named object directory
    //

    BaseSrvpStaticServerData->NamedObjectDirectory = UnicodeString;
    BaseSrvpStaticServerData->NamedObjectDirectory.MaximumLength = UnicodeString.Length+(USHORT)sizeof(UNICODE_NULL);
    p = RtlAllocateHeap( BaseSrvSharedHeap,
                         MAKE_SHARED_TAG( INIT_TAG ),
                         UnicodeString.Length + sizeof( UNICODE_NULL )
                       );
    if ( !p ) {
        return STATUS_NO_MEMORY;
    }

    RtlCopyMemory(p,BaseSrvpStaticServerData->NamedObjectDirectory.Buffer,BaseSrvpStaticServerData->NamedObjectDirectory.MaximumLength);
    BaseSrvpStaticServerData->NamedObjectDirectory.Buffer = p;

    //
    // Terminal Server: App installation mode is intially turned off
    //
    BaseSrvpStaticServerData->fTermsrvAppInstallMode = FALSE;

    BaseSrvCSDString.Buffer = &ValueBuffer[ 300 ];
    BaseSrvCSDString.Length = 0;
    BaseSrvCSDString.MaximumLength = 100 * sizeof( WCHAR );

    Status = RtlQueryRegistryValues( RTL_REGISTRY_WINDOWS_NT,
                                     L"",
                                     BaseServerRegistryConfigurationTable1,
                                     NULL,
                                     NULL
                                   );


    if (NT_SUCCESS( Status )) {
        BaseSrvpStaticServerData->CSDNumber = (USHORT)(BaseSrvCSDNumber & 0xFFFF);
        BaseSrvpStaticServerData->RCNumber = (USHORT)(BaseSrvCSDNumber >> 16);
        }
    else {
        BaseSrvpStaticServerData->CSDNumber = 0;
        BaseSrvpStaticServerData->RCNumber = 0;
        }

    Status = RtlQueryRegistryValues( RTL_REGISTRY_WINDOWS_NT,
                                     L"",
                                     BaseServerRegistryConfigurationTable,
                                     NULL,
                                     NULL
                                   );
    if (NT_SUCCESS( Status )) {
        wcsncpy( BaseSrvpStaticServerData->CSDVersion,
                 BaseSrvCSDString.Buffer,
                 BaseSrvCSDString.Length
               );
        BaseSrvpStaticServerData->CSDVersion[ BaseSrvCSDString.Length ] = UNICODE_NULL;
        }
    else {
        BaseSrvpStaticServerData->CSDVersion[ 0 ] = UNICODE_NULL;
        }

#if defined(_WIN64)
    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       (PVOID)&SysInfo,
                                       sizeof(SYSTEM_BASIC_INFORMATION),
                                       NULL
                                     );
#else
    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       (PVOID)&BaseSrvpStaticServerData->SysInfo,
                                       sizeof( BaseSrvpStaticServerData->SysInfo ),
                                       NULL
                                     );
#endif

    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    Status = BaseSrvInitializeIniFileMappings( BaseSrvpStaticServerData );
    if ( !NT_SUCCESS(Status) ){
        return Status;
        }

    BaseSrvpStaticServerData->DefaultSeparateVDM = FALSE;

    RtlInitUnicodeString( &NameString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\WOW" );
    InitializeObjectAttributes( &Obja,
                                &NameString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenKey( &KeyHandle,
                        KEY_READ,
                        &Obja
                      );
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString( &NameString, L"DefaultSeparateVDM" );
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
        Status = NtQueryValueKey( KeyHandle,
                                  &NameString,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof( ValueBuffer ),
                                  &ResultLength
                                );
        if (NT_SUCCESS(Status)) {
            if (KeyValueInformation->Type == REG_DWORD) {
                BaseSrvpStaticServerData->DefaultSeparateVDM = *(PULONG)KeyValueInformation->Data != 0;
                }
            else
            if (KeyValueInformation->Type == REG_SZ) {
                if (!_wcsicmp( (PWSTR)KeyValueInformation->Data, L"yes" ) ||
                    !_wcsicmp( (PWSTR)KeyValueInformation->Data, L"1" )) {
                    BaseSrvpStaticServerData->DefaultSeparateVDM = TRUE;
                    }
                }
            }

        NtClose( KeyHandle );
        }


    BaseSrvpStaticServerData->ForceDos = FALSE;

    RtlInitUnicodeString( &NameString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\WOW" );
    InitializeObjectAttributes( &Obja,
                                &NameString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenKey( &KeyHandle,
                        KEY_READ,
                        &Obja
                      );
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString( &NameString, L"ForceDos" );
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
        Status = NtQueryValueKey( KeyHandle,
                                  &NameString,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof( ValueBuffer ),
                                  &ResultLength
                                );
        if (NT_SUCCESS(Status)) {
            if (KeyValueInformation->Type == REG_DWORD) {
                BaseSrvpStaticServerData->ForceDos = *(PULONG)KeyValueInformation->Data != 0;
                }
            else
            if (KeyValueInformation->Type == REG_SZ) {
                if (!_wcsicmp( (PWSTR)KeyValueInformation->Data, L"yes" ) ||
                    !_wcsicmp( (PWSTR)KeyValueInformation->Data, L"1" )) {
                    BaseSrvpStaticServerData->ForceDos = TRUE;
                    }
                }
            }

        NtClose( KeyHandle );
        }

#if defined(WX86) || defined(_AXP64_)

   SetupWx86KeyMapping();

#endif


    //
    // Following code is direct from Jimk. Why is there a 1k constant
    //

    PrimarySecurityDescriptor = RtlAllocateHeap( BaseSrvHeap, MAKE_TAG( TMP_TAG ), 1024 );
    if ( !PrimarySecurityDescriptor ) {
        return STATUS_NO_MEMORY;
        }

    Status = RtlCreateSecurityDescriptor (
                 PrimarySecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    if ( !NT_SUCCESS(Status) ){
        return Status;
        }

    //
    // Create an ACL that allows full access to System and partial access to world
    //

    Status = CreateBaseAcls( &Dacl, &RestrictedDacl );

    if ( !NT_SUCCESS(Status) ){
        return Status;
        }

    Status = RtlSetDaclSecurityDescriptor (
                 PrimarySecurityDescriptor,
                 TRUE,                  //DaclPresent,
                 Dacl,                  //Dacl
                 FALSE                  //DaclDefaulted OPTIONAL
                 );
    if ( !NT_SUCCESS(Status) ){
        return Status;
        }




    InitializeObjectAttributes( &Obja,
                                  &UnicodeString,
                                  attributes,
                                  NULL,
                                  PrimarySecurityDescriptor
                                );
    Status = NtCreateDirectoryObject( &BaseSrvNamedObjectDirectory,
                                      DIRECTORY_ALL_ACCESS,
                                      &Obja
                                    );


    if ( !NT_SUCCESS(Status) ){
        return Status;
        }

    if (SessionId == 0) {

        Status = NtSetInformationObject( BaseSrvNamedObjectDirectory,
                                         ObjectSessionInformation,
                                         NULL,
                                         0
                                       );

        if ( !NT_SUCCESS(Status) ){
            return Status;
            }
    }

    //
    // Check if LUID device maps are enabled
    //
    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (NT_SUCCESS(Status)) {
        BaseSrvpStaticServerData->LUIDDeviceMapsEnabled = (LUIDDeviceMapsEnabled != 0);
    }
    else {
        BaseSrvpStaticServerData->LUIDDeviceMapsEnabled = FALSE;
    }

    //
    // If LUID device maps are enabled,
    // then initialize the critical section for broadcasting a system message
    // about a drive letter change
    //
    if( BaseSrvpStaticServerData->LUIDDeviceMapsEnabled == TRUE ) {
        Status = RtlInitializeCriticalSectionAndSpinCount( &BaseSrvDDDBSMCritSec,
                                                           PREALLOCATE_EVENT_MASK );
        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    }

    //
    // Create a symbolic link Global pointing to the Global BaseNamedObjects directory
    // This symbolic link will be used by proccesses that want to e.g. access a global
    // event instead of the session specific. This will be done by prepending
    // "Global\" to the object name.
    //

    RtlInitUnicodeString( &UnicodeString, GLOBAL_SYM_LINK );
    RtlInitUnicodeString( &LinkTarget, L"\\BaseNamedObjects" );


    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                attributes,
                                BaseSrvNamedObjectDirectory,
                                PrimarySecurityDescriptor );

    Status = NtCreateSymbolicLinkObject( &SymbolicLinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &Obja,
                                         &LinkTarget );

    if (NT_SUCCESS( Status ) && (SessionId == 0)) {

        NtClose( SymbolicLinkHandle );
    }

    //
    // Create a symbolic link Local pointing to the Current Sessions BaseNamedObjects directory
    // This symbolic link will be used for backward compatibility with Hydra 4
    // naming conventions

    RtlInitUnicodeString( &UnicodeString, LOCAL_SYM_LINK );
    RtlInitUnicodeString( &LinkTarget, szObjectDirectory );


    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                attributes,
                                BaseSrvNamedObjectDirectory,
                                PrimarySecurityDescriptor );

    Status = NtCreateSymbolicLinkObject( &SymbolicLinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &Obja,
                                         &LinkTarget );

    if (NT_SUCCESS( Status ) && (SessionId == 0)) {

        NtClose( SymbolicLinkHandle );
    }


    //
    // Create a symbolic link Session pointing
    // to the \Sessions\BNOLINKS directory
    // This symbolic link will be used by proccesses that want to e.g. access a
    // event in another session. This will be done by using the following
    // naming convention : Session\\<sessionid>\\ObjectName
    //

    RtlInitUnicodeString( &UnicodeString, SESSION_SYM_LINK );
    RtlInitUnicodeString( &LinkTarget, L"\\Sessions\\BNOLINKS" );


    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                attributes,
                                BaseSrvNamedObjectDirectory,
                                PrimarySecurityDescriptor );

    Status = NtCreateSymbolicLinkObject( &SymbolicLinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &Obja,
                                         &LinkTarget );

    if (NT_SUCCESS( Status ) && (SessionId == 0)) {

        NtClose( SymbolicLinkHandle );
    }


    RtlInitUnicodeString( &UnicodeString, L"Restricted" );
    Status = RtlSetDaclSecurityDescriptor (
                 PrimarySecurityDescriptor,
                 TRUE,                  //DaclPresent,
                 RestrictedDacl,        //Dacl
                 FALSE                  //DaclDefaulted OPTIONAL
                 );
    if ( !NT_SUCCESS(Status) ){
        return Status;
        }

    InitializeObjectAttributes( &Obja,
                                  &UnicodeString,
                                  attributes,
                                  BaseSrvNamedObjectDirectory,
                                  PrimarySecurityDescriptor
                                );
    Status = NtCreateDirectoryObject( &BaseSrvRestrictedObjectDirectory,
                                      DIRECTORY_ALL_ACCESS,
                                      &Obja
                                    );


    if ( !NT_SUCCESS(Status) ){
        return Status;
        }

    //
    //  Initialize the Sxs support
    //
    Status = BaseSrvSxsInit();
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    RtlFreeHeap( BaseSrvHeap, 0, Dacl );
    RtlFreeHeap( BaseSrvHeap, 0, RestrictedDacl );
    RtlFreeHeap( BaseSrvHeap, 0,PrimarySecurityDescriptor );

    BaseSrvVDMInit();

    //
    // Initialize the shared heap for the NLS information.
    //
    BaseSrvNLSInit(BaseSrvpStaticServerData);

    Status = STATUS_SUCCESS;
    goto Exit;
OutOfMemory:
    Status = STATUS_NO_MEMORY;
    goto Exit;
Exit:
    return( Status );
}

NTSTATUS
BaseClientConnectRoutine(
    IN PCSR_PROCESS Process,
    IN OUT PVOID ConnectionInfo,
    IN OUT PULONG ConnectionInfoLength
    )
{
    if (*ConnectionInfoLength != sizeof(HANDLE)) {
        return STATUS_INVALID_PARAMETER;
    }
    return ( BaseSrvNlsConnect( Process,
                                ConnectionInfo,
                                ConnectionInfoLength ) );
}

VOID
BaseClientDisconnectRoutine(
    IN PCSR_PROCESS Process
    )
{
    BaseSrvCleanupVDMResources (Process);
}

ULONG
BaseSrvDefineDosDevice(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status;
    PBASE_DEFINEDOSDEVICE_MSG a = (PBASE_DEFINEDOSDEVICE_MSG)&m->u.ApiMessageData;
    UNICODE_STRING LinkName;
    UNICODE_STRING LinkValue;
    HANDLE LinkHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PWSTR Buffer, s, Src, Dst, pchValue;
    ULONG cchBuffer, cch;
    ULONG cchName, cchValue, cchSrc, cchSrcStr, cchDst;
    BOOLEAN QueryNeeded, MatchFound, RevertToSelfNeeded, DeleteRequest;
    ULONG ReturnedLength;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID RestrictedSid;
    PSID WorldSid;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    CHAR Acl[256];               // 256 is more than big enough
    ULONG AclLength=256;
    ACCESS_MASK WorldAccess;
    ULONG lastIndex;
    DWORD iDrive;
    LUID callerLuid;
    BOOLEAN bsmForLuid = FALSE;
    BOOLEAN haveLuid = FALSE;
    BOOLEAN bGlobalSymLink = FALSE;

    UNREFERENCED_PARAMETER(ReplyStatus);

    if (!CsrValidateMessageBuffer(m, &a->DeviceName.Buffer, a->DeviceName.Length, sizeof(BYTE)) ||
        (a->DeviceName.Length&(sizeof (WCHAR) - 1))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (a->TargetPath.Length == 0) {
        cchBuffer = 0;
    } else {
        cchBuffer = sizeof (WCHAR);
    }

    if (!CsrValidateMessageBuffer(m, &a->TargetPath.Buffer, (a->TargetPath.Length + cchBuffer), sizeof(BYTE)) ||
        (a->TargetPath.Length&(sizeof (WCHAR) - 1))) {
        return STATUS_INVALID_PARAMETER;
    }


    cchBuffer = 4096;
    Buffer = RtlAllocateHeap( BaseSrvHeap,
                              MAKE_TAG( TMP_TAG ),
                              cchBuffer * sizeof( WCHAR )
                            );
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    Status = RtlEnterCriticalSection( &BaseSrvDosDeviceCritSec );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( BaseSrvHeap, 0, Buffer );
        return Status;
    }

    if (a->Flags & DDD_REMOVE_DEFINITION) {
        DeleteRequest = TRUE;
    } else {
        DeleteRequest = FALSE;
    }

    LinkHandle = NULL;
    try {
        //
        // Determine if need to broadcast the change to the system, otherwise
        // the client portion of DefineDosDevice will broadcast the change
        // if needed.
        //
        // Broadcast to the system when all the conditions are met:
        //  - LUID device maps are enabled
        //  - Successfully completed operations of this BaseSrvDefineDosDevice
        //  - caller did not specify the DDD_NO_BROADCAST_SYSTEM flag
        //  - symbolic link's name is the "<drive letter>:" format
        //
        // Broadcasting this change from the server because
        // we need to broadcast as Local_System in order to broadcast this
        // message to all desktops that have windows with this LUID.
        // Effectively, we are broadcasting to all the windows with this LUID.
        //
        if ((BaseSrvpStaticServerData->LUIDDeviceMapsEnabled == TRUE) &&
            (!(a->Flags & DDD_NO_BROADCAST_SYSTEM)) &&
            ((a->DeviceName).Buffer != NULL) &&
            ((a->DeviceName).Length == (2 * sizeof( WCHAR ))) &&
            ((a->DeviceName).Buffer[ 1 ] == L':')) {


            WCHAR DriveLetter = a->DeviceName.Buffer[ 0 ];

            if ( ((DriveLetter - L'a') < 26) &&
                 ((DriveLetter - L'a') >= 0) ) {
                DriveLetter = RtlUpcaseUnicodeChar( DriveLetter );
            }

            iDrive = DriveLetter - L'A';

            if (iDrive < 26) {
                bsmForLuid = TRUE;
            }
        }

        if ((a->Flags & DDD_LUID_BROADCAST_DRIVE) &&
            (bsmForLuid == FALSE)) {
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        // Each user LUID has a DeviceMap, so we put the link in that directory,
        // instead of in the global \??.
        //
        // We get the LUID device map by impersonating the user
        // and requesting \??\ in the beginning of the symbolic link name
        // Then, the Object Manager will get the correct device map
        // for this user (based on LUID)
        //

        s = Buffer;
        cch = cchBuffer;
        cchName = _snwprintf( s,
                              cch,
                              L"\\??\\%wZ",
                              &a->DeviceName
                            );

        s += cchName + 1;
        cch -= (cchName + 1);

        RtlInitUnicodeString( &LinkName, Buffer );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &LinkName,
                                    OBJ_CASE_INSENSITIVE,
                                    (HANDLE) NULL,
                                    (PSECURITY_DESCRIPTOR)NULL
                                  );

        QueryNeeded = TRUE;

        RevertToSelfNeeded = CsrImpersonateClient(NULL);
        if (RevertToSelfNeeded == FALSE) {
            Status = STATUS_BAD_IMPERSONATION_LEVEL;
            leave;
        }

        if (bsmForLuid == TRUE) {
            Status = GetCallerLuid( &(callerLuid) );

            if (NT_SUCCESS( Status )) {
                //
                // obtained the caller's LUID
                //
                haveLuid = TRUE;
            }
        }

        Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                           SYMBOLIC_LINK_QUERY | DELETE,
                                           &ObjectAttributes
                                         );
        if (RevertToSelfNeeded) {
            CsrRevertToSelf();
        }

        //
        // With LUID device maps Enabled and DDD_LUID_BROADCAST_DRIVE,
        // we capture all the information need to perform the broadcast:
        //     Drive Letter, action, and the caller's LUID.
        // if the user had specified a delete action,
        // then the drive letter should not exist (status ==
        //    STATUS_OBJECT_NAME_NOT_FOUND)
        // else the drive letter should exist (status == STATUS_SUCCESS)
        //
        // if DDD_LUID_BROADCAST_DRIVE is set, we always leave this 'try'
        // block because the 'finally' block will perform the broadcast
        // when (Status == STATUS_SUCCESS).
        //
        if (a->Flags & DDD_LUID_BROADCAST_DRIVE) {
            if (!NT_SUCCESS( Status )) {
                LinkHandle = NULL;
            }
            if (DeleteRequest && (Status == STATUS_OBJECT_NAME_NOT_FOUND)) {
                    Status = STATUS_SUCCESS;
            }
            leave;
        }

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            LinkHandle = NULL;
            if (DeleteRequest) {
                if (a->TargetPath.Length == 0) {
                    Status = STATUS_SUCCESS;
                }
                leave;
            }

            QueryNeeded = FALSE;
            Status = STATUS_SUCCESS;
        } else {
            if (!NT_SUCCESS( Status )) {
                LinkHandle = NULL;
                leave;
            } else {
                //
                // Symbolic link already exists
                //
                // With device maps per LUID, we must determine that the
                // symlink does not exist in the global device map because
                // DefineDosDevice allow the caller to perform the
                // mapping operations on a symlink (push/pop/delete)
                // mapping for a particular symlink.
                //
                // The mapping capability is supported by writing
                // all mappings (target(s) of a symlink) into the symlink's
                // value, where the mappings names are separate by a NULL
                // char.  The symlink's list of mappings is terminated by
                // two NULL characters.
                //
                // The first mapping, first target name in the symlink's
                // value, is the current (top) mapping for the system because
                // the system only reads the symlink's value up to the
                // first NULL char.
                //
                // The mapping code works by opening the existing symlink,
                // reading the symlink's entire value (name of the target(s)),
                // destroy the old symlink, manipulate the symlink's value
                // for the mapping operation, and finally create a
                // brand-new symlink with the new symlink's value.
                //
                // If we don't check that the symlink exists in the global
                // device map, we might delete a global symlink and
                // and recreate the symlink in a user's LUID device map.
                // Thus, the new symlink will no longer reside in the global
                // map, i.e. other users cannot access the symlink.
                //
                if( BaseSrvpStaticServerData->LUIDDeviceMapsEnabled == TRUE ) {

                    Status = IsGlobalSymbolicLink( LinkHandle,
                                                   &bGlobalSymLink
                                                 );

                    if( !NT_SUCCESS( Status )) {
                        leave;
                    }

                    if( bGlobalSymLink == TRUE ) {
                        s = Buffer;
                        cch = cchBuffer;
                        cchName = _snwprintf( s,
                                              cch,
                                              L"\\GLOBAL??\\%wZ",
                                              &a->DeviceName
                                            );
                        s += cchName + 1;
                        cch -= (cchName + 1);

                        LinkName.Length = (USHORT)(cchName * sizeof( WCHAR ));
                        LinkName.MaximumLength = (USHORT)(LinkName.Length + sizeof(UNICODE_NULL));

                    }
                }
            }
        }

        if (a->TargetPath.Length != 0) {
            Src = a->TargetPath.Buffer;
            Src[a->TargetPath.Length/sizeof (Src[0])] = L'\0';
            cchValue = wcslen( Src );
            if ((cchValue + 1) >= cch) {
                Status = STATUS_TOO_MANY_NAMES;
                leave;
            }

            RtlMoveMemory( s, Src, (cchValue + 1) * sizeof( WCHAR ) );
            pchValue = s;
            s += cchValue + 1;
            cch -= (cchValue + 1);
        } else {
            pchValue = NULL;
            cchValue = 0;
        }

        if (QueryNeeded) {
            LinkValue.Length = 0;
            LinkValue.MaximumLength = (USHORT)(cch * sizeof( WCHAR ));
            LinkValue.Buffer = s;
            ReturnedLength = 0;
            Status = NtQuerySymbolicLinkObject( LinkHandle,
                                                &LinkValue,
                                                &ReturnedLength
                                              );
            if (ReturnedLength == (ULONG)LinkValue.MaximumLength) {
                Status = STATUS_BUFFER_OVERFLOW;
            }

            if (!NT_SUCCESS( Status )) {
                leave;
            }

            lastIndex = ReturnedLength / sizeof( WCHAR );

            //
            // check if the returned string already has the extra NULL at the end
            //
            if( (lastIndex >= 2) &&
                (s[ lastIndex - 2 ] == UNICODE_NULL) &&
                (s[ lastIndex - 1 ] == UNICODE_NULL) ) {

                LinkValue.MaximumLength = (USHORT)ReturnedLength;
            }
            else {
                //
                // add the extra NULL for the DeleteRequest search later
                //
                s[ lastIndex ] = UNICODE_NULL;
                LinkValue.MaximumLength = (USHORT)(ReturnedLength + sizeof( UNICODE_NULL ));
            }
        } else {
            if (DeleteRequest) {
                RtlInitUnicodeString( &LinkValue, NULL );
            } else {
                RtlInitUnicodeString( &LinkValue, s - (cchValue + 1) );
            }
        }

        if (LinkHandle != NULL) {
            Status = NtMakeTemporaryObject( LinkHandle );
            NtClose( LinkHandle );
            LinkHandle = NULL;
        }

        if (!NT_SUCCESS( Status )) {
            leave;
        }


        if (DeleteRequest) {
            Src = Dst = LinkValue.Buffer;
            cchSrc = LinkValue.MaximumLength / sizeof( WCHAR );
            cchDst = 0;
            MatchFound = FALSE;
            while (*Src) {
                cchSrcStr = 0;
                s = Src;
                while (*Src++) {
                    cchSrcStr++;
                }

                if ( (!MatchFound) &&
                     ( (a->Flags & DDD_EXACT_MATCH_ON_REMOVE &&
                        cchValue == cchSrcStr &&
                        !_wcsicmp( s, pchValue )
                       ) ||
                       ( !(a->Flags & DDD_EXACT_MATCH_ON_REMOVE) &&
                         (cchValue == 0 || !_wcsnicmp( s, pchValue, cchValue ))
                       )
                     )
                   ) {
                    MatchFound = TRUE;
                } else {
                    if (s != Dst) {
                        RtlMoveMemory( Dst, s, (cchSrcStr + 1) * sizeof( WCHAR ) );
                        }
                    Dst += cchSrcStr + 1;
                    }
                }
            *Dst++ = UNICODE_NULL;
            LinkValue.Length = wcslen( LinkValue.Buffer ) * sizeof( UNICODE_NULL );
            if (LinkValue.Length != 0) {
                LinkValue.MaximumLength = (USHORT)((PCHAR)Dst - (PCHAR)LinkValue.Buffer);
            }
        } else if (QueryNeeded) {
            LinkValue.Buffer -= (cchValue + 1);
            LinkValue.Length = (USHORT)(cchValue * sizeof( WCHAR ));
            LinkValue.MaximumLength += LinkValue.Length + sizeof( UNICODE_NULL );
        }

        //
        // Create a new value for the link.
        //

        if (LinkValue.Length != 0) {
            //
            // Create the new symbolic link object with a security descriptor
            // that grants world SYMBOLIC_LINK_QUERY access.
            //

            Status = RtlAllocateAndInitializeSid( &WorldSidAuthority,
                                                  1,
                                                  SECURITY_WORLD_RID,
                                                  0, 0, 0, 0, 0, 0, 0,
                                                  &WorldSid
                                                );

            if (!NT_SUCCESS( Status )) {
                leave;
            }

            Status = RtlAllocateAndInitializeSid( &NtAuthority,
                                                  1,
                                                  SECURITY_RESTRICTED_CODE_RID,
                                                  0, 0, 0, 0, 0, 0, 0,
                                                  &RestrictedSid
                                                );

            if (!NT_SUCCESS( Status )) {
                RtlFreeSid( WorldSid );
                leave;
            }

            Status = RtlCreateSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );

            ASSERT(NT_SUCCESS(Status));

            Status = RtlCreateAcl( (PACL)Acl,
                                    AclLength,
                                    ACL_REVISION2
                                  );
            ASSERT(NT_SUCCESS(Status));

            if( (SessionId != 0) && (ProtectionMode & 0x00000003) ) {
                // Do not allow world cross session delete in WTS
                WorldAccess = SYMBOLIC_LINK_QUERY;
            }
            else {
                WorldAccess = SYMBOLIC_LINK_QUERY | DELETE;
            }

            Status = RtlAddAccessAllowedAce( (PACL)Acl,
                                             ACL_REVISION2,
                                             WorldAccess,
                                             WorldSid
                                           );

            ASSERT(NT_SUCCESS(Status));

            Status = RtlAddAccessAllowedAce( (PACL)Acl,
                                             ACL_REVISION2,
                                             WorldAccess,
                                             RestrictedSid
                                           );

            ASSERT(NT_SUCCESS(Status));

            //
            // Sids have been copied into the ACL
            //

            RtlFreeSid( WorldSid );
            RtlFreeSid( RestrictedSid );

            Status = RtlSetDaclSecurityDescriptor ( &SecurityDescriptor,
                                                    TRUE,
                                                    (PACL)Acl,
                                                    TRUE                // Don't over-ride inherited protection
                                                  );
            ASSERT(NT_SUCCESS(Status));

            ObjectAttributes.SecurityDescriptor = &SecurityDescriptor;

            //
            // Since we impersonate the user to create in the
            // correct directory, we cannot request the creation
            // of a permanent object.  By default, only Local_System
            // can request creation of a permanant object.
            //
            // However, we use a new API, NtMakePermanentObject that
            // only Local_System can call to make the object
            // permanant after creation
            //
            if ( BaseSrvpStaticServerData->LUIDDeviceMapsEnabled == TRUE ) {
                if ( bGlobalSymLink == FALSE ) {

                    //
                    // Do not impersonate if global symbolic link is being
                    // created, because administrators do not have permission
                    // to create in the global device map if we impersonate
                    //
                    // Administrators have inherited permissions on the
                    // existing global symbolic links, so we may recreate
                    // the existing global link that we opened and destroyed.
                    //
                    // We had impersonated the caller when opening the symbolic
                    // link, so we know that the caller has permissions for the
                    // link that we are creating.
                    //

                    //
                    // Impersonate Client when creating the Symbolic Link
                    // This impersonation is needed to ensure that the symlink
                    // is created in the correct directory
                    //
                    RevertToSelfNeeded = CsrImpersonateClient( NULL );  // This stacks client contexts

                    if( RevertToSelfNeeded == FALSE ) {
                        Status = STATUS_BAD_IMPERSONATION_LEVEL;
                        leave;
                    }
                }
                //
                // if a global symlink is being create, don't impersonate &
                // don't use the old style of using the OBJ_PERMANENT flag
                // directly
                //
            }
            else {

                //
                // Old style, disabled when separate dev maps are enabled
                //
                ObjectAttributes.Attributes |= OBJ_PERMANENT;
            }

            Status = NtCreateSymbolicLinkObject( &LinkHandle,
                                                 SYMBOLIC_LINK_ALL_ACCESS,
                                                 &ObjectAttributes,
                                                 &LinkValue
                                               );

            if ((BaseSrvpStaticServerData->LUIDDeviceMapsEnabled == TRUE) &&
                (bGlobalSymLink == FALSE)) {

                if (RevertToSelfNeeded) {
                    CsrRevertToSelf();
                }
            }

            if (NT_SUCCESS( Status )) {

                if ( BaseSrvpStaticServerData->LUIDDeviceMapsEnabled == TRUE ) {
                    //
                    // add the OBJ_PERMANENT attribute to the object
                    // so that the object remains in the namespace
                    // of the system
                    //
                    Status = NtMakePermanentObject( LinkHandle );
                }

                NtClose( LinkHandle );
                if (DeleteRequest && !MatchFound) {
                    Status = STATUS_OBJECT_NAME_NOT_FOUND;
                }
            }

            LinkHandle = NULL;
        }
    } finally {
        if (LinkHandle != NULL) {
            NtClose( LinkHandle );
        }
        RtlFreeHeap( BaseSrvHeap, 0, Buffer );

        //
        // Determine if need to broadcast change to the system, otherwise
        // the client portion of DefineDosDevice will broadcast the change
        // if needed.
        //
        // Broadcast to the system when all the conditions are met:
        //  - LUID device maps are enabled
        //  - Successfully completed operations of this BaseSrvDefineDosDevice
        //  - caller did not specify the DDD_NO_BROADCAST_SYSTEM flag
        //  - symbolic link's name is the "<drive letter>:" format
        //
        // Can also broadcast when DDD_LUID_BROADCAST_DRIVE is set,
        // and drive exists (when not a DeleteRequest) or
        //     drive does not exist (when a DeleteRequest)
        //
        // Broadcasting this change from the server because
        // we need to broadcast as Local_System in order to broadcast this
        // message to all desktops that have windows with this LUID.
        // Effectively, we are broadcasting to all the windows with this LUID.
        //
        if (bsmForLuid == TRUE && Status == STATUS_SUCCESS && haveLuid == TRUE) {
            LUID SystemLuid = SYSTEM_LUID;

            if (bGlobalSymLink == TRUE) {
                RtlCopyLuid( &callerLuid, &SystemLuid);
            }

            AddBSMRequest( iDrive,
                           DeleteRequest,
                           &callerLuid );

            //
            // If the user has removed a drive letter from his LUID DosDevices
            // and now sees a global drive letter, then generate a broadcast
            // about the arrival of the drive letter to the user's view.
            //
            if ((DeleteRequest == TRUE) &&
                (!RtlEqualLuid( &callerLuid, &SystemLuid )) &&
                CheckForGlobalDriveLetter( iDrive )) {
                AddBSMRequest( iDrive,
                               FALSE,
                               &callerLuid );
            }
        }

        RtlLeaveCriticalSection( &BaseSrvDosDeviceCritSec );
    }

    return Status;
}


NTSTATUS
CreateBaseAcls(
    PACL *Dacl,
    PACL *RestrictedDacl
    )

/*++

Routine Description:

    Creates the ACL for the BaseNamedObjects directory.

Arguments:

    Dacl - Supplies a pointer to a PDACL that will be filled in with
        the resultant ACL (allocated out of the process heap).  The caller
        is responsible for freeing this memory.

Return Value:

    STATUS_NO_MEMORY or Success

--*/
{
    PSID LocalSystemSid;
    PSID WorldSid;
    PSID RestrictedSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    NTSTATUS Status;
    ACCESS_MASK WorldAccess;
    ACCESS_MASK SystemAccess;
    ACCESS_MASK RestrictedAccess;
    ULONG AclLength;

    // Get the Protection mode from Session Manager\ProtectionMode
    HANDLE KeyHandle;
    ULONG ResultLength;
    WCHAR ValueBuffer[ 32 ];
    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ObjectSecurityInformation;

    RtlInitUnicodeString( &NameString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &NameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(
                 &KeyHandle,
                 KEY_READ,
                 &ObjectAttributes
                 );

    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString( &NameString, L"ProtectionMode" );
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
        Status = NtQueryValueKey(
                     KeyHandle,
                     &NameString,
                     KeyValuePartialInformation,
                     KeyValueInformation,
                     sizeof( ValueBuffer ),
                     &ResultLength
                     );

        if (NT_SUCCESS(Status)) {
            if (KeyValueInformation->Type == REG_DWORD &&
                *(PULONG)KeyValueInformation->Data) {
                ProtectionMode = *(PULONG)KeyValueInformation->Data;
            }
        }

        NtClose( KeyHandle );
    }

    if (NtCurrentPeb()->SessionId) {

        Status = NtQuerySystemInformation( SystemObjectSecurityMode,
                                           &ObjectSecurityInformation,
                                           sizeof(ObjectSecurityInformation),
                                           NULL
                                         );
        if (!NT_SUCCESS( Status )) {

            ObjectSecurityInformation = 0;
        }

    } else {
        
        ObjectSecurityInformation = 0;
    }

    Status = RtlAllocateAndInitializeSid(
                 &NtAuthority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &LocalSystemSid
                 );

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    Status = RtlAllocateAndInitializeSid(
                 &WorldAuthority,
                 1,
                 SECURITY_WORLD_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &WorldSid
                 );

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    Status = RtlAllocateAndInitializeSid(
                 &NtAuthority,
                 1,
                 SECURITY_RESTRICTED_CODE_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &RestrictedSid
                 );

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    if (ObjectSecurityInformation == 0) {
        
        WorldAccess = DIRECTORY_ALL_ACCESS & ~(WRITE_OWNER | WRITE_DAC | DELETE );
    } else {

        WorldAccess = DIRECTORY_TRAVERSE | DIRECTORY_QUERY;
    }

    RestrictedAccess = DIRECTORY_TRAVERSE;
    SystemAccess = DIRECTORY_ALL_ACCESS;

    AclLength = sizeof( ACL )                    +
                3 * sizeof( ACCESS_ALLOWED_ACE ) +
                RtlLengthSid( LocalSystemSid )   +
                RtlLengthSid( RestrictedSid )   +
                RtlLengthSid( WorldSid );

    *Dacl = RtlAllocateHeap( BaseSrvHeap, MAKE_TAG( TMP_TAG ), AclLength );

    if (*Dacl == NULL) {
        return( STATUS_NO_MEMORY );
    }

    Status = RtlCreateAcl (*Dacl, AclLength, ACL_REVISION2 );

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    Status = RtlAddAccessAllowedAce ( *Dacl, ACL_REVISION2, WorldAccess, WorldSid );

    if (NT_SUCCESS( Status )) {
        Status = RtlAddAccessAllowedAce ( *Dacl, ACL_REVISION2, SystemAccess, LocalSystemSid );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlAddAccessAllowedAce ( *Dacl, ACL_REVISION2, RestrictedAccess, RestrictedSid );
    }


    // now create the DACL for restricted use

    if( (SessionId != 0) && (ProtectionMode & 0x00000003) ) {
        // Terminal server does not allow world create in other sessions
        RestrictedAccess = DIRECTORY_ALL_ACCESS & ~(WRITE_OWNER | WRITE_DAC | DELETE | DIRECTORY_CREATE_OBJECT | DIRECTORY_CREATE_SUBDIRECTORY);
    }
    else {
        RestrictedAccess = DIRECTORY_ALL_ACCESS & ~(WRITE_OWNER | WRITE_DAC | DELETE );
    }
    AclLength = sizeof( ACL )                    +
                3 * sizeof( ACCESS_ALLOWED_ACE ) +
                RtlLengthSid( LocalSystemSid )   +
                RtlLengthSid( RestrictedSid )   +
                RtlLengthSid( WorldSid );

    *RestrictedDacl = RtlAllocateHeap( BaseSrvHeap, MAKE_TAG( TMP_TAG ), AclLength );

    if (*RestrictedDacl == NULL) {
        return( STATUS_NO_MEMORY );
    }

    Status = RtlCreateAcl (*RestrictedDacl, AclLength, ACL_REVISION2 );

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    Status = RtlAddAccessAllowedAce ( *RestrictedDacl, ACL_REVISION2, WorldAccess, WorldSid );

    if (NT_SUCCESS( Status )) {
        Status = RtlAddAccessAllowedAce ( *RestrictedDacl, ACL_REVISION2, SystemAccess, LocalSystemSid );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlAddAccessAllowedAce ( *RestrictedDacl, ACL_REVISION2, RestrictedAccess, RestrictedSid );
    }

    //
    // These have been copied in, free them.
    //

    RtlFreeHeap( BaseSrvHeap, 0, LocalSystemSid );
    RtlFreeHeap( BaseSrvHeap, 0, RestrictedSid );
    RtlFreeHeap( BaseSrvHeap, 0, WorldSid );

    return( Status );
}

ULONG
BaseSrvSetTermsrvClientTimeZone(
    IN PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
/*++

Routine Description:

    Sets BaseSrvpStaticServerData->tziTermsrvClientTimeZone
    according to received information

Arguments:

    IN PCSR_API_MSG m - part of timezone information.
                    we have to cut it ito two pieces because of
                    message size restrictions (100 bytes).

    IN OUT PCSR_REPLY_STATUS ReplyStatus - not used.

Return Value:

    always STATUS_SUCCESS

--*/
{

    PBASE_SET_TERMSRVCLIENTTIMEZONE b = (PBASE_SET_TERMSRVCLIENTTIMEZONE)&m->u.ApiMessageData;
    if(b->fFirstChunk) {
        BaseSrvpStaticServerData->tziTermsrvClientTimeZone.Bias=b->Bias;
        RtlMoveMemory(&(BaseSrvpStaticServerData->tziTermsrvClientTimeZone.StandardName),
            &(b->Name),sizeof(b->Name));
        BaseSrvpStaticServerData->tziTermsrvClientTimeZone.StandardDate=b->Date;
        BaseSrvpStaticServerData->tziTermsrvClientTimeZone.StandardBias=b->Bias1;
        //only half of data received
        //see comment below
        BaseSrvpStaticServerData->TermsrvClientTimeZoneId=TIME_ZONE_ID_INVALID;

    } else {
        RtlMoveMemory(&(BaseSrvpStaticServerData->tziTermsrvClientTimeZone.DaylightName),
            &b->Name,sizeof(b->Name));
        BaseSrvpStaticServerData->tziTermsrvClientTimeZone.DaylightDate=b->Date;
        BaseSrvpStaticServerData->tziTermsrvClientTimeZone.DaylightBias=b->Bias1;
        BaseSrvpStaticServerData->ktTermsrvClientBias=b->RealBias;
        //Set TimeZoneId only if last chunk of data received
        //it indicates whether we have correct information in
        //global data or not.
        BaseSrvpStaticServerData->TermsrvClientTimeZoneId=b->TimeZoneId;

        //
        // Refresh the system's concept of time
        //
        NtSetSystemTime(NULL,NULL);
    }

    return( STATUS_SUCCESS );
}

NTSTATUS
IsGlobalSymbolicLink(
    IN HANDLE hSymLink,
    OUT PBOOLEAN pbGlobalSymLink)
/*++

Routine Description:

    Check if the Symbolic Link exists in the global device map

Arguments:

    hSymLink [IN] - handle to the symbolic link for verification
    pbGlobalSymLink [OUT] - result of "Is symbolic link global?"
                           TRUE  - symbolic link is global
                           FALSE - symbolic link is not global

Return Value:

    NTSTATUS code

    STATUS_SUCCESS - operations successful, did not encounter any errors,
                     the result in pbGlobalSymlink is only valid for this
                     status code

    STATUS_INVALID_PARAMETER - pbGlobalSymLink or hSymLink is NULL

    STATUS_NO_MEMORY - could not allocate memory to read the symbolic link's
                       name

    STATUS_INFO_LENGTH_MISMATCH - did not allocate enough memory for the
                                  symbolic link's name

    STATUS_UNSUCCESSFUL - an unexpected error encountered

--*/
{
    UNICODE_STRING ObjectName;
    UNICODE_STRING GlobalDeviceMapPrefix;
    PWSTR NameBuffer = NULL;
    ULONG ReturnedLength;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    if( ( pbGlobalSymLink == NULL ) || ( hSymLink == NULL ) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    try {
        ObjectName.Length = 0;
        ObjectName.MaximumLength = 0;
        ObjectName.Buffer = NULL;
        ReturnedLength = 0;

        //
        // Determine the length of the symbolic link's name
        //
        Status = NtQueryObject( hSymLink,
                                ObjectNameInformation,
                                (PVOID) &ObjectName,
                                0,
                                &ReturnedLength
                              );

        if( !NT_SUCCESS( Status ) && (Status != STATUS_INFO_LENGTH_MISMATCH) ) {
            leave;
        }

        //
        // allocate memory for the symbolic link's name
        //
        NameBuffer = RtlAllocateHeap( BaseSrvHeap,
                                      MAKE_TAG( TMP_TAG ),
                                      ReturnedLength
                                    );

        if( NameBuffer == NULL ) {
            Status = STATUS_NO_MEMORY;
            leave;
        }

        //
        // get the full name of the symbolic link
        //
        Status = NtQueryObject( hSymLink,
                                ObjectNameInformation,
                                NameBuffer,
                                ReturnedLength,
                                &ReturnedLength
                              );

        if( !NT_SUCCESS( Status )) {
            leave;
        }

        RtlInitUnicodeString ( &GlobalDeviceMapPrefix, L"\\GLOBAL??\\" );

        //
        // Check if the symlink exists in the global device map
        //
        *pbGlobalSymLink = RtlPrefixUnicodeString( &GlobalDeviceMapPrefix,
                                                   (PUNICODE_STRING)NameBuffer,
                                                   FALSE);

        Status = STATUS_SUCCESS;
    }
    finally {
        if( NameBuffer != NULL ) {
            RtlFreeHeap( BaseSrvHeap, 0, NameBuffer );
            NameBuffer = NULL;
        }
    }
    return ( Status );
}

NTSTATUS
GetCallerLuid (
    PLUID pLuid
    )
/*++

Routine Description:

    Retrieves the caller's LUID from the effective access_token
    The effective access_token will be the thread's token if
    impersonating, else the process' token

Arguments:

    pLuid [IN] - pointer to a buffer to hold the LUID

Return Value:

    STATUS_SUCCESS - operations successful, did not encounter any errors

    STATUS_INVALID_PARAMETER - pLuid is NULL

    STATUS_NO_TOKEN - could not find a token for the user

    appropriate NTSTATUS code - an unexpected error encountered

--*/

{
    TOKEN_STATISTICS TokenStats;
    HANDLE   hToken    = NULL;
    DWORD    dwLength  = 0;
    NTSTATUS Status;

    if( (pLuid == NULL) || (sizeof(*pLuid) != sizeof(LUID)) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // Get the access token
    // Try to get the impersonation token, else the primary token
    //
    Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_READ, FALSE, &hToken );

    if( Status == STATUS_NO_TOKEN ) {

        Status = NtOpenProcessToken( NtCurrentProcess(), TOKEN_READ, &hToken );

    }

    if( NT_SUCCESS(Status) ) {

        //
        // Query the LUID for the user.
        //

        Status = NtQueryInformationToken( hToken,
                                          TokenStatistics,
                                          &TokenStats,
                                          sizeof(TokenStats),
                                          &dwLength );

        if( NT_SUCCESS(Status) ) {
            RtlCopyLuid( pLuid, &(TokenStats.AuthenticationId) );
        }
    }

    if( hToken != NULL ) {
        NtClose( hToken );
    }

    return( Status );
}


NTSTATUS
BroadcastDriveLetterChange(
    IN DWORD iDrive,
    IN BOOLEAN DeleteRequest,
    IN PLUID pLuid
    )
/*++

Routine Description:

    broadcasting the drive letter change to all the windows with this LUID
    Use BroadcastSystemMessageExW and the flags BSF_LUID & BSM_ALLDESKTOPS
    to send the message

    To broadcast with the BSM_ALLDESKTOPS flag, we need to call
    BroadcastSystemMessageExW as Local_System.  So this function should be
    called as Local_System.

Arguments:

    iDrive [IN] - drive letter that is changing, in the form of a number
                  relative to 'A', used to create a bit mask

    DeleteRequest [IN] - denotes whether this change is a delete
                           TRUE  - drive letter was deleted
                           FALSE - drive letter was added

    pLuid [IN] - caller's LUID

Return Value:

    STATUS_SUCCESS - operations successful, did not encounter any errors,

    appropriate NTSTATUS code

--*/

{
    BSMINFO bsmInfo;
    DEV_BROADCAST_VOLUME dbv;
    DWORD bsmFlags;
    DWORD dwRec;
    UNICODE_STRING DllName_U;
    STRING bsmName;
    HANDLE hUser32DllModule;
    LUID SystemLuid = SYSTEM_LUID;
    NTSTATUS Status = STATUS_SUCCESS;

    if( pLuid == NULL ) {
        return( STATUS_INVALID_PARAMETER );
    }

    bsmInfo.cbSize = sizeof(bsmInfo);
    bsmInfo.hdesk = NULL;
    bsmInfo.hwnd = NULL;
    RtlCopyLuid(&(bsmInfo.luid), pLuid);

    dbv.dbcv_size       = sizeof( dbv );
    dbv.dbcv_devicetype = DBT_DEVTYP_VOLUME;
    dbv.dbcv_reserved   = 0;
    dbv.dbcv_unitmask   = (1 << iDrive);
    dbv.dbcv_flags      = DBTF_NET;

    bsmFlags = BSF_FORCEIFHUNG |
               BSF_NOHANG |
               BSF_NOTIMEOUTIFNOTHUNG;

    //
    // If the LUID is not Local_System, then broadcast only for the LUID
    //
    if (!RtlEqualLuid( &(bsmInfo.luid), &SystemLuid )) {
        bsmFlags |= BSF_LUID;
    }

    dwRec = BSM_APPLICATIONS | BSM_ALLDESKTOPS;

    hUser32DllModule = NULL;
    if( PBROADCASTSYSTEMMESSAGEEXW == NULL ) {
        RtlInitUnicodeString( &DllName_U, L"user32" );

        Status = LdrGetDllHandle(
                    UNICODE_NULL,
                    NULL,
                    &DllName_U,
                    (PVOID *)&hUser32DllModule
                    );

        if( hUser32DllModule != NULL && NT_SUCCESS( Status ) ) {

            //
            // get the address of the BroadcastSystemMessageExW function
            //
            RtlInitString( &bsmName, "CsrBroadcastSystemMessageExW" );
            Status = LdrGetProcedureAddress(
                            hUser32DllModule,
                            &bsmName,
                            0L,
                            (PVOID *)&PBROADCASTSYSTEMMESSAGEEXW
                            );

            if( !NT_SUCCESS( Status ) ) {
                PBROADCASTSYSTEMMESSAGEEXW = NULL;
            }
        }
    }


    if( PBROADCASTSYSTEMMESSAGEEXW != NULL ) {

        //
        // Since this thread is a csrss thread, the thread is not a
        // GUI thread and does not have a desktop associated with it.
        // Must set the thread's desktop to the active desktop in
        // order to call BroadcastSystemMessageExW
        //
        Status = (PBROADCASTSYSTEMMESSAGEEXW)(
                            bsmFlags,
                            &dwRec,
                            WM_DEVICECHANGE,
                            (WPARAM)((DeleteRequest == TRUE) ?
                                                 DBT_DEVICEREMOVECOMPLETE :
                                                 DBT_DEVICEARRIVAL
                                    ),
                            (LPARAM)(DEV_BROADCAST_HDR *)&dbv,
                            (PBSMINFO)&(bsmInfo)
                                             );
    }

    //
    // Send to all the TS CSRSS servers
    //
    if( !(bsmFlags & BSF_LUID) ) {
        Status = SendWinStationBSM(
                        bsmFlags,
                        &dwRec,
                        WM_DEVICECHANGE,
                        (WPARAM)((DeleteRequest == TRUE) ?
                                             DBT_DEVICEREMOVECOMPLETE :
                                             DBT_DEVICEARRIVAL
                                 ),
                        (LPARAM)(DEV_BROADCAST_HDR *)&dbv);
    }

    return( Status );
}

NTSTATUS
AddBSMRequest(
    IN DWORD iDrive,
    IN BOOLEAN DeleteRequest,
    IN PLUID pLuid)
/*++

Routine Description:

    Add a request for Broadcasting a System Message about a change with
    a drive letter.

    Must be running as Local_System and LUID device maps must be enabled.

    Places the request item in the BSM_Request_Queue.

    This mechanism allows the broadcast to occur asynchronously, otherwise
    we encounter waiting issues with explorer.exe, in which the user sees
    the shell hang for 20 seconds.

Arguments:

    iDrive [IN] - drive letter that is changing, in the form of a number
                  relative to 'A', used to create a bit mask

    DeleteRequest [IN] - denotes whether this change is a delete
                           TRUE  - drive letter was deleted
                           FALSE - drive letter was added

    pLuid [IN] - caller's LUID

Return Value:

    STATUS_SUCCESS - operations successful, did not encounter any errors,

    STATUS_INVALID_PARAMETER - pLuid is a null pointer

    STATUS_ACCESS_DENIED - LUID device maps are disabled or the caller
                           is not running as Local_System

    STATUS_NO_MEMORY - could not allocate memory for the DDD_BSM_REQUEST
                       data structure

    appropriate NTSTATUS code

--*/
{
    PDDD_BSM_REQUEST pRequest;
    LUID CallerLuid;
    LUID SystemLuid = SYSTEM_LUID;
    NTSTATUS Status;


    if( pLuid == NULL ) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // LUID device maps must be enabled
    //
    if( BaseSrvpStaticServerData->LUIDDeviceMapsEnabled == FALSE ) {
        return( STATUS_ACCESS_DENIED );
    }

    Status = GetCallerLuid(&CallerLuid);

    if( !NT_SUCCESS(Status) ) {
        return Status;
    }

    //
    // The caller must be Local_System
    //
    if( !RtlEqualLuid(&SystemLuid, &CallerLuid) ) {
        return( STATUS_ACCESS_DENIED );
    }

    pRequest = RtlAllocateHeap( BaseSrvHeap,
                                MAKE_TAG( TMP_TAG ),
                                sizeof( DDD_BSM_REQUEST ));

    if( pRequest == NULL ) {
        return( STATUS_NO_MEMORY );
    }

    pRequest->iDrive = iDrive;
    pRequest->DeleteRequest = DeleteRequest;
    RtlCopyLuid( &(pRequest->Luid), pLuid );
    pRequest->pNextRequest = NULL;


    RtlEnterCriticalSection( &BaseSrvDDDBSMCritSec );

    //
    // add the work item to the end of the queue
    //
    if( BSM_Request_Queue_End != NULL ) {
        BSM_Request_Queue_End->pNextRequest = pRequest;
    }
    else {
        BSM_Request_Queue = pRequest;
    }

    BSM_Request_Queue_End = pRequest;


    //
    // if we added a request to an empty queue,
    // then create a new thread to process the request
    //
    // BaseSrvDDDBSMCritSec guards BaseSrvpBSMThreadCount
    //
    if( BaseSrvpBSMThreadCount < BaseSrvpBSMThreadMax ) {

        RtlLeaveCriticalSection( &BaseSrvDDDBSMCritSec );

        Status = CreateBSMThread();
    }
    else {
        RtlLeaveCriticalSection( &BaseSrvDDDBSMCritSec );
    }

    return( Status );
}

NTSTATUS
CreateBSMThread()
/*++

Routine Description:

    Creates a dynamic csr thread

    This thread will be use to asynchronously broadcast a drive letter
    change message to the LUID's applications

    The caller must be Local_System and LUID device maps must be
    enabled.

Arguments:

    None

Return Value:

    STATUS_SUCCESS - operations successful, did not encounter any errors,

    STATUS_ACCESS_DENIED - caller is not running as Local_System or
                           LUID device maps are not enabled

    appropriate NTSTATUS code

--*/
{
    NTSTATUS Status;

    //
    // Luid device maps must be enabled.
    //
    if (BaseSrvpStaticServerData->LUIDDeviceMapsEnabled == FALSE) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Create a thread to asynchronously broadcast a drive letter change.
    //
    Status = RtlCreateUserThread(
                 NtCurrentProcess(),
                 NULL,
                 FALSE,
                 0,
                 0,
                 0,
                 BaseSrvBSMThread,
                 NULL,
                 NULL,
                 NULL
             );

    return Status;
}

NTSTATUS
BaseSrvBSMThread(
    PVOID pJunk
    )
/*++

Routine Description:

    Remove a work item from the BSM_Request_Queue and broadcast a message
    about drive letter change.

    The caller must be Local_System and LUID device maps must be
    enabled.

Arguments:

    pJunk - not used.

Return Value:

    STATUS_SUCCESS - operations successful, did not encounter any errors,

    STATUS_ACCESS_DENIED - caller is not running as Local_System.

    appropriate NTSTATUS code

--*/
{
    PDDD_BSM_REQUEST pRequest;
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD Error;

    UNREFERENCED_PARAMETER(pJunk);

    //
    // LUID device maps must be enabled for us to get here.
    //
    ASSERT(BaseSrvpStaticServerData->LUIDDeviceMapsEnabled);

    //
    // Enter the critical section that protects the BSM_Request_Queue.
    //
    RtlEnterCriticalSection( &BaseSrvDDDBSMCritSec );
    BaseSrvpBSMThreadCount++;

    while ((pRequest = BSM_Request_Queue) != NULL) {
        //
        // Remove the request from the front of BSM_Request_Queue
        //
        BSM_Request_Queue = BSM_Request_Queue->pNextRequest;

        //
        // If the queue is empty, then make sure that the queue's end
        // pointer is NULL.
        //
        if (BSM_Request_Queue == NULL) {
            BSM_Request_Queue_End = NULL;
        }

        RtlLeaveCriticalSection( &BaseSrvDDDBSMCritSec );

        //
        // Broadcasting can take a long time
        // so broadcast outside of the critical section
        //
        Status = BroadcastDriveLetterChange( pRequest->iDrive,
                                             pRequest->DeleteRequest,
                                             &(pRequest->Luid) );

        //
        // free the work item's memory
        //
        pRequest->pNextRequest = NULL;

        RtlFreeHeap( BaseSrvHeap, 0, pRequest );

        //
        // Enter the critical section that protects the BSM_Request_Queue
        //
        RtlEnterCriticalSection( &BaseSrvDDDBSMCritSec );
    }

    BaseSrvpBSMThreadCount--;
    RtlLeaveCriticalSection( &BaseSrvDDDBSMCritSec );


    //
    // Since this thread was created with RtlCreateUserThread,
    // we must clean up the thread manually.
    //
    // Set the variable for User Stack cleanup and terminate the thread.
    //
    // Note: This thread should not be holding a critical section when
    // terminating the thread.
    //
    NtCurrentTeb ()->FreeStackOnTermination = TRUE;
    NtTerminateThread( NtCurrentThread(), Status );
    return( Status );
}

BOOLEAN
CheckForGlobalDriveLetter (
    DWORD iDrive
    )
/*++

Routine Description:

    Checks if the user sees a drive letter symbolic link that exists in the
    global DosDevices

Arguments:

    iDrive - contains the index of the drive letter relative to 'A'

Return Value:

    TRUE - operations successful && the drive letter does exist in the
           global DosDevices

    FALSE - error encountered or drive letter does not exist in the
            global DosDevices

--*/
{
    WCHAR DeviceName[NT_DRIVE_LETTER_PATH_LENGTH];
    UNICODE_STRING LinkName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE LinkHandle;
    BOOLEAN RevertToSelfNeeded, bGlobalSymbolicLink;
    NTSTATUS Status;

    //
    // workaround warning tool's unawareness of previous verification of the
    // function parameter, which was always a string of two chars "X:".  It was
    // always two chars because this function was only called when (bsmForLuid
    // == TRUE).  bsmForLuid is only set to TRUE when a->DeviceName was 2 chars
    // long.  So now we use an index, iDrive, which is set when bsmForLuid ==
    // TRUE.
    //
    wcsncpy( DeviceName, L"\\??\\X:", NT_DRIVE_LETTER_PATH_LENGTH - 1 );
    DeviceName[ NT_DRIVE_LETTER_PATH_LENGTH - 1 ] = UNICODE_NULL;
    DeviceName[4] = (WCHAR)(L'A' + iDrive);

    RtlInitUnicodeString( &LinkName, DeviceName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &LinkName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR)NULL
                              );

    //
    // Impersonating the user to make sure that there is not a LUID DosDevices
    // drive letter masking the global DosDevices drive letter
    //
    RevertToSelfNeeded = CsrImpersonateClient( NULL );  // This stacks client contexts

    if( RevertToSelfNeeded == FALSE ) {
        Status = STATUS_BAD_IMPERSONATION_LEVEL;
        return FALSE;
    }

    Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                       SYMBOLIC_LINK_QUERY,
                                       &ObjectAttributes
                                     );

    if (RevertToSelfNeeded) {
        CsrRevertToSelf();
    }

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = IsGlobalSymbolicLink( LinkHandle,
                                   &bGlobalSymbolicLink
                                 );

    NtClose( LinkHandle );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    return bGlobalSymbolicLink;
}

NTSTATUS
SendWinStationBSM(
    DWORD dwFlags,
    LPDWORD lpdwRecipients,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    FP_WINSTABROADCASTSYSTEMMESSAGE fpWinStationBroadcastSystemMessage;
    UNICODE_STRING DllName_U;
    STRING bsmName;
    HANDLE hWinStaDllModule;
    LONG result = 0;
    NTSTATUS Status;

    //
    // Load the base library that contains the user message dispatch routines
    // for Terminal Services.
    //
    RtlInitUnicodeString( &DllName_U, L"WINSTA.DLL" );
    Status = LdrLoadDll(
                    NULL,
                    NULL,
                    &DllName_U,
                    (PVOID *)&hWinStaDllModule
                    );
    if(!NT_SUCCESS( Status )) {
        return Status;
    }

    //
    // get the address of the WinStationBroadcastSystemMessage function
    //
    RtlInitString( &bsmName, "WinStationBroadcastSystemMessage" );
    Status = LdrGetProcedureAddress(
                            hWinStaDllModule,
                            &bsmName,
                            0L,
                            (PVOID *)&fpWinStationBroadcastSystemMessage
                            );

    if( NT_SUCCESS( Status ) ) {
        fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                           TRUE,
                                           0,
                                           DEFAULT_BROADCAST_TIME_OUT,
                                           dwFlags,
                                           lpdwRecipients,
                                           uiMessage,
                                           wParam,
                                           lParam,
                                           &result);
    }

    LdrUnloadDll(hWinStaDllModule);

    return( Status );
}

ULONG BaseSrvKernel32DelayLoadComplete = FALSE; // keep ULONG for atomicity
HANDLE BaseSrvKernel32DllHandle = NULL;
PGET_NLS_SECTION_NAME pGetNlsSectionName = NULL;
PGET_DEFAULT_SORTKEY_SIZE pGetDefaultSortkeySize = NULL;
PGET_LINGUIST_LANG_SIZE pGetLinguistLangSize = NULL;
PVALIDATE_LOCALE pValidateLocale = NULL;
PVALIDATE_LCTYPE pValidateLCType = NULL;
POPEN_DATA_FILE pOpenDataFile = NULL;
PNLS_CONVERT_INTEGER_TO_STRING pNlsConvertIntegerToString = NULL;
PGET_USER_DEFAULT_LANG_ID pGetUserDefaultLangID = NULL;
PGET_CP_FILE_NAME_FROM_REGISTRY pGetCPFileNameFromRegistry = NULL;
PCREATE_NLS_SECURITY_DESCRIPTOR pCreateNlsSecurityDescriptor = NULL;

const static struct KERNEL32_DELAY_LOAD_FUNCTION {
    ANSI_STRING Name;
    PVOID*      Code;
} BaseSrvKernel32DelayLoadFunctions[]  = {
    { RTL_CONSTANT_STRING("OpenDataFile"),              (PVOID*)(&pOpenDataFile)              },
    { RTL_CONSTANT_STRING("GetDefaultSortkeySize"),     (PVOID*)(&pGetDefaultSortkeySize)     },
    { RTL_CONSTANT_STRING("GetLinguistLangSize"),       (PVOID*)(&pGetLinguistLangSize)       },
    { RTL_CONSTANT_STRING("NlsConvertIntegerToString"), (PVOID*)(&pNlsConvertIntegerToString) },
    { RTL_CONSTANT_STRING("ValidateLCType"),            (PVOID*)(&pValidateLCType)            },
    { RTL_CONSTANT_STRING("ValidateLocale"),            (PVOID*)(&pValidateLocale)            },
    { RTL_CONSTANT_STRING("GetNlsSectionName"),         (PVOID*)(&pGetNlsSectionName)         },
    { RTL_CONSTANT_STRING("GetUserDefaultLangID"),      (PVOID*)(&pGetUserDefaultLangID)      },
    { RTL_CONSTANT_STRING("GetCPFileNameFromRegistry"), (PVOID*)(&pGetCPFileNameFromRegistry) },
    { RTL_CONSTANT_STRING("CreateNlsSecurityDescriptor"),(PVOID*)(&pCreateNlsSecurityDescriptor)}
};

NTSTATUS
BaseSrvDelayLoadKernel32(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE LocalKernel32DllHandle = BaseSrvKernel32DllHandle;
    int i = 0;
    ASSERT(BaseSrvKernel32DllPath.Buffer != NULL && BaseSrvKernel32DllPath.Length != 0);

    if (BaseSrvKernel32DelayLoadComplete)
        return STATUS_SUCCESS;

    //
    // The structure here is somewhat inverted.
    // Usually you load the library, then loop over functions.
    // We loop over functions, only loading the library when we find a NULL one.
    //
    // I (a-JayK) don't remember why we do this, but it was deliberate.
    //
    for (i = 0 ; i != RTL_NUMBER_OF(BaseSrvKernel32DelayLoadFunctions) ; ++i) {
        //
        // Due to races, we cannot skip out of the loop upon finding any non NULLs.
        //
        if (*BaseSrvKernel32DelayLoadFunctions[i].Code == NULL) {
            if (LocalKernel32DllHandle == NULL) {
                //
                // We depend on the loader lock for thread safety.
                // In a race we might refcount kernel32.dll more than once.
                // This is ok, because we do not ever unload kernel32.dll.
                //
                Status = LdrLoadDll(NULL, NULL, &BaseSrvKernel32DllPath, &BaseSrvKernel32DllHandle);
                ASSERTMSG("Rerun with ShowSnaps to debug.", NT_SUCCESS(Status));
                ASSERTMSG("Rerun with ShowSnaps to debug.", BaseSrvKernel32DllHandle != NULL);
                if (!NT_SUCCESS(Status))
                    goto Exit;
                LocalKernel32DllHandle = BaseSrvKernel32DllHandle;
            }
            Status =
                LdrGetProcedureAddress(
                    BaseSrvKernel32DllHandle,
                    &BaseSrvKernel32DelayLoadFunctions[i].Name,
                    0,
                    BaseSrvKernel32DelayLoadFunctions[i].Code
                    );
            ASSERTMSG("Rerun with ShowSnaps to debug.", NT_SUCCESS(Status));
            ASSERTMSG("Rerun with ShowSnaps to debug.", *BaseSrvKernel32DelayLoadFunctions[i].Code != NULL);
            if (!NT_SUCCESS(Status))
                goto Exit;
        }
    }
    BaseSrvKernel32DelayLoadComplete = TRUE;
Exit:
    return Status;
}

ULONG BaseSrvApphelpDelayLoadComplete = FALSE;
PFNCheckRunApp pfnCheckRunApp = NULL;


NTSTATUS
BaseSrvDelayLoadApphelp(
    VOID
    )
{
    static const UNICODE_STRING ApphelpModuleName = RTL_CONSTANT_STRING(L"\\Apphelp.dll");
    static const STRING         CheckRunAppProcedureName = RTL_CONSTANT_STRING("ApphelpCheckRunApp");
    UNICODE_STRING ApphelpFullPath = { 0 };
    NTSTATUS Status;
    HANDLE ModuleHandle = NULL;

    if (BaseSrvApphelpDelayLoadComplete) {
        return STATUS_SUCCESS;
    }

    ApphelpFullPath.MaximumLength = ApphelpModuleName.Length +
                                    BaseSrvWindowsSystemDirectory.Length +
                                    sizeof(UNICODE_NULL);

    ApphelpFullPath.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                             MAKE_TAG(TMP_TAG),
                                             ApphelpFullPath.MaximumLength);
    if (ApphelpFullPath.Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    ApphelpFullPath.Length = 0;

    Status = RtlAppendUnicodeStringToString(&ApphelpFullPath, &BaseSrvWindowsSystemDirectory);
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    Status = RtlAppendUnicodeStringToString(&ApphelpFullPath, &ApphelpModuleName);
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    //
    // load apphelp
    //

    Status = LdrLoadDll(NULL,
                        NULL,
                        &ApphelpFullPath,
                        &ModuleHandle);

    if (NT_SUCCESS(Status)) {
        Status = LdrGetProcedureAddress(ModuleHandle,
                                        &CheckRunAppProcedureName,
                                        0,
                                        (PVOID*)&pfnCheckRunApp);
    }

cleanup:


    if (ApphelpFullPath.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, ApphelpFullPath.Buffer);
    }

    if (!NT_SUCCESS(Status)) {

        if (ModuleHandle) {
            LdrUnloadDll(ModuleHandle);
        }

        pfnCheckRunApp = NULL;
    }

    BaseSrvApphelpDelayLoadComplete = NT_SUCCESS(Status);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvnls.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    srvnls.c

Abstract:

    This file contains the NLS Server-Side routines.

Author:

    Julie Bennett (JulieB) 02-Dec-1992

Revision History:

--*/



//
//  Include Files.
//

#include "basesrv.h"




//
//  Constant Declarations.
//

#define MAX_PATH_LEN        512        // max length of path name
#define MAX_SMALL_BUF_LEN   32         // C_nlsXXXXX.nls\0 is longest file name (15),
                                       // \NLS\NlsSectionSortkey0000XXXX\0 (31) is longest section name

// Security descriptor buffer is size of SD + size of ACL + size of ACE +
//    sizeof SID + sizeof 1 SUB_AUTHORITY.
//
// THIS IS ONLY VALID FOR 1 ACE with 1 SID (SUB_AUTHORITY).  If you have more it won't work for you.
//
// ACE is size of ACE_HEADER + size of ACCESS_MASK
// SID includes the first ULONG (pointer) of the PSID_IDENTIFIER_AUTHORITY array, so this
// declaration should be 4 bytes too much for a 1 ACL 1 SID 1 SubAuthority SD.
// This is 52 bytes at the moment, only needs to be 48.
// (I tested this by using -4, which works and -5 which STOPS during the boot.
#define MAX_SMALL_SECURITY_DESCRIPTOR  \
    (sizeof(SECURITY_DESCRIPTOR) + sizeof(ACL) +    \
      sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +    \
      sizeof(SID) + sizeof(PSID_IDENTIFIER_AUTHORITY ))

#define MAX_KEY_VALUE_PARTINFO                                             \
    (FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + MAX_REG_VAL_SIZE * sizeof(WCHAR))

//
//  Get the data pointer for the KEY_VALUE_FULL_INFORMATION structure.
//
#define GET_VALUE_DATA_PTR(p)     ((LPWSTR)((PBYTE)(p) + (p)->DataOffset))


//
//  Size of stack buffer for PKEY_VALUE_FULL_INFORMATION pointer.
//
#define MAX_KEY_VALUE_FULLINFO                                             \
    ( FIELD_OFFSET( KEY_VALUE_FULL_INFORMATION, Name ) + MAX_PATH_LEN )




//
//  Typedef Declarations.
//

//
//  These MUST remain in the same order as the NLS_USER_INFO structure.
//
LPWSTR pCPanelRegValues[] =
{
    L"sLanguage",
    L"iCountry",
    L"sCountry",
    L"sList",
    L"iMeasure",
    L"iPaperSize",
    L"sDecimal",
    L"sThousand",
    L"sGrouping",
    L"iDigits",
    L"iLZero",
    L"iNegNumber",
    L"sNativeDigits",
    L"NumShape",
    L"sCurrency",
    L"sMonDecimalSep",
    L"sMonThousandSep",
    L"sMonGrouping",
    L"iCurrDigits",
    L"iCurrency",
    L"iNegCurr",
    L"sPositiveSign",
    L"sNegativeSign",
    L"sTimeFormat",
    L"sTime",
    L"iTime",
    L"iTLZero",
    L"iTimePrefix",
    L"s1159",
    L"s2359",
    L"sShortDate",
    L"sDate",
    L"iDate",
    L"sYearMonth",
    L"sLongDate",
    L"iCalendarType",
    L"iFirstDayOfWeek",
    L"iFirstWeekOfYear",
    L"Locale"
};

int NumCPanelRegValues = (sizeof(pCPanelRegValues) / sizeof(LPWSTR));




//
//  Global Variables.
//

// Critical Section to protect the NLS cache, which caches the current user settings from registry.
RTL_CRITICAL_SECTION NlsCacheCriticalSection;
HANDLE hCPanelIntlKeyRead = INVALID_HANDLE_VALUE;
HANDLE hCPanelIntlKeyWrite = INVALID_HANDLE_VALUE;
PNLS_USER_INFO pNlsRegUserInfo;
ULONG NlsChangeBuffer;
IO_STATUS_BLOCK IoStatusBlock;




//
//  Forward Declarations.
//

ULONG
NlsSetRegAndCache(
    LPWSTR pValue,
    LPWSTR pCacheString,
    LPWSTR pData,
    ULONG DataLength);

VOID
NlsUpdateCacheInfo(VOID);

NTSTATUS GetThreadAuthenticationId(
    PLUID Luid);






////////////////////////////////////////////////////////////////////////////
//
//  BaseSrvNLSInit
//
//  This routine creates the shared heap for the nls information.
//  This is called when csrss.exe is initialized.
//
//  08-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS
BaseSrvNLSInit(
    PBASE_STATIC_SERVER_DATA pStaticServerData)
{
    NTSTATUS rc;                     // return code

    //
    //  Create a critical section to protect the cache.
    //

    rc = RtlInitializeCriticalSection (&NlsCacheCriticalSection);
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI (BaseSrv): Could NOT Create Cache critical section - %lx.\n", rc));
        return (rc);
    }
    

    //
    //  Initialize the cache to zero.
    //
    pNlsRegUserInfo = &(pStaticServerData->NlsUserInfo);
    RtlFillMemory(pNlsRegUserInfo, sizeof(NLS_USER_INFO), (CHAR)NLS_INVALID_INFO_CHAR);
    pNlsRegUserInfo->UserLocaleId = 0;

    RtlEnterCriticalSection(&NlsCacheCriticalSection);    
    pNlsRegUserInfo->ulCacheUpdateCount = 0;
    RtlLeaveCriticalSection(&NlsCacheCriticalSection);
    //
    //  Make the system locale the user locale.
    //
    NtQueryDefaultLocale(FALSE, &(pNlsRegUserInfo->UserLocaleId));

    //
    //  Return success.
    //
    return (STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  BaseSrvNLSConnect
//
//  This routine duplicates the mutant handle for the client.
//
//  08-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS
BaseSrvNlsConnect(
    PCSR_PROCESS Process,
    PVOID pConnectionInfo,
    PULONG pConnectionInfoLength)
{
    return (STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  BaseSrvNlsLogon
//
//  This routine initializes the heap for the nls information.  If fLogon
//  is TRUE, then it opens the registry key, initializes the heap
//  information, and registers the key for notification.  If fLogon is
//  FALSE, then it unregisters the key for notification, zeros out the
//  heap information, and closes the registry key.
//
//  08-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS
BaseSrvNlsLogon(
    BOOL fLogon)
{
    HANDLE hKeyRead;                   // temp handle for read access
    HANDLE hKeyWrite;                  // temp handle for write access
    HANDLE hUserHandle;                // HKEY_CURRENT_USER equivalent
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    UNICODE_STRING ObKeyName;          // key name
    NTSTATUS rc = STATUS_SUCCESS;      // return code
    
    RTL_SOFT_VERIFY(NT_SUCCESS(rc = BaseSrvSxsInvalidateSystemDefaultActivationContextCache()));

    if (fLogon)
    {
        //
        //  Retreive the currently logged on interactive user's Luid
        //  authentication id. The currently executing thread is
        //  impersonating the logged on user.
        //
        if (pNlsRegUserInfo != NULL)
        {
            GetThreadAuthenticationId(&pNlsRegUserInfo->InteractiveUserLuid);

            //
            //  Logging ON.
            //     - open keys
            //
            //  NOTE: Registry Notification is done by the RIT in user server.
            //
            rc = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hUserHandle);
            if (!NT_SUCCESS(rc))
            {
                KdPrint(("NLSAPI (BaseSrv): Could NOT Open HKEY_CURRENT_USER - %lx.\n", rc));
                return (rc);
            }

            RtlInitUnicodeString(&ObKeyName, L"Control Panel\\International");
            InitializeObjectAttributes( &ObjA,
                                        &ObKeyName,
                                        OBJ_CASE_INSENSITIVE,
                                        hUserHandle,
                                        NULL );

            //
            //  Open key for READ and NOTIFY access.
            //
            rc = NtOpenKey( &hKeyRead,
                            KEY_READ | KEY_NOTIFY,
                            &ObjA );

            //
            //  Open key for WRITE access.
            //
            if (!NT_SUCCESS(NtOpenKey( &hKeyWrite,
                                       KEY_WRITE,
                                       &ObjA )))
            {
                KdPrint(("NLSAPI (BaseSrv): Could NOT Open Registry Key %wZ for Write - %lx.\n",
                         &ObKeyName, rc));
                hKeyWrite = INVALID_HANDLE_VALUE;
            }

            //
            //  Close the handle to the current user (HKEY_CURRENT_USER).
            //
            NtClose(hUserHandle);

            //
            //  Check for error from first NtOpenKey.
            //
            if (!NT_SUCCESS(rc))
            {
                KdPrint(("NLSAPI (BaseSrv): Could NOT Open Registry Key %wZ for Read - %lx.\n",
                         &ObKeyName, rc));

                if (hKeyWrite != INVALID_HANDLE_VALUE)
                {
                    NtClose(hKeyWrite);
                }
                return (rc);
            }

            //
            //  Enter the critical section so that we don't mess up the public handle.
            //
            rc = RtlEnterCriticalSection(&NlsCacheCriticalSection);
            if (!NT_SUCCESS( rc )) 
            {
                return (rc);
            }


            //
            //  Make sure any old handles are closed.
            //
            if (hCPanelIntlKeyRead != INVALID_HANDLE_VALUE)
            {
                NtClose(hCPanelIntlKeyRead);
            }

            if (hCPanelIntlKeyWrite != INVALID_HANDLE_VALUE)
            {
                NtClose(hCPanelIntlKeyWrite);
            }

            //
            //  Save the new handles.
            //
            hCPanelIntlKeyRead = hKeyRead;
            hCPanelIntlKeyWrite = hKeyWrite;

            //
            // Fill up the cache so that we have the latest intl settings in the registry.
            //
            NlsUpdateCacheInfo();
            RtlLeaveCriticalSection(&NlsCacheCriticalSection);
        }
    }
    else
    {
        //
        //  Logging OFF.
        //     - close keys
        //     - zero out info
        //

        //
        //  This may come as NULL, during stress memory cond for terminal
        //  server (when NLS cache mutant couldn't be created).
        //
        if (pNlsRegUserInfo != NULL)
        {
            rc = RtlEnterCriticalSection(&NlsCacheCriticalSection);
            if (!NT_SUCCESS( rc )) 
            {
                return (rc);
            }

            if (hCPanelIntlKeyRead != INVALID_HANDLE_VALUE)
            {
                NtClose(hCPanelIntlKeyRead);
                hCPanelIntlKeyRead = INVALID_HANDLE_VALUE;
            }

            if (hCPanelIntlKeyWrite != INVALID_HANDLE_VALUE)
            {
                NtClose(hCPanelIntlKeyWrite);
                hCPanelIntlKeyWrite = INVALID_HANDLE_VALUE;
            }

            //
            //  Fill the cache with NLS_INVALID_INFO_CHAR.
            //
            RtlFillMemory(pNlsRegUserInfo, sizeof(NLS_USER_INFO), (CHAR)NLS_INVALID_INFO_CHAR);
            pNlsRegUserInfo->UserLocaleId = 0;
            // Reset the cache update count.  There is no need to use InterlockedExchange() since
            // all updates to ulCacheUpdateCount are protected in the critical section NlsCacheCriticalSection.
            pNlsRegUserInfo->ulCacheUpdateCount = 0;

            //
            // Make the system locale the user locale.
            //
            NtQueryDefaultLocale(FALSE, &(pNlsRegUserInfo->UserLocaleId));

            //
            //  No need to reset the User's Authentication Id, since it's
            //  being zero'ed out above.
            //

            RtlLeaveCriticalSection(&NlsCacheCriticalSection);
        }
    }

    //
    //  Return success.
    //
    return (STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  BaseSrvNlsUpdateRegistryCache
//
//  This routine updates the NLS cache when a registry notification occurs.
//
//  08-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

VOID
BaseSrvNlsUpdateRegistryCache(
    PVOID ApcContext,
    PIO_STATUS_BLOCK pIoStatusBlock)
{
    ULONG rc = 0L;                     // return code

    if (hCPanelIntlKeyRead == INVALID_HANDLE_VALUE)
    {
        return;
    }

    if (!NT_SUCCESS(RtlEnterCriticalSection(&NlsCacheCriticalSection)))
    {
        return;
    }

    if (hCPanelIntlKeyRead == INVALID_HANDLE_VALUE)
    {
        RtlLeaveCriticalSection( &NlsCacheCriticalSection );
        return;
    }

    //
    //  Update the cache information.
    //
    NlsUpdateCacheInfo();

    RtlLeaveCriticalSection( &NlsCacheCriticalSection );

    //
    //  Call NtNotifyChangeKey.
    //
    rc = NtNotifyChangeKey( hCPanelIntlKeyRead,
                            NULL,
                            (PIO_APC_ROUTINE)BaseSrvNlsUpdateRegistryCache,
                            NULL,
                            &IoStatusBlock,
                            REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_NAME,
                            FALSE,
                            &NlsChangeBuffer,
                            sizeof(NlsChangeBuffer),
                            TRUE );

#ifdef DBG
    //
    //  Check for error from NtNotifyChangeKey.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI (BaseSrv): Could NOT Set Notification of Control Panel International Registry Key - %lx.\n",
                 rc));
    }
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsSetRegAndCache
//
//  This routine sets the registry with the appropriate string and then
//  updates the cache.
//
//  NOTE: Must already own the mutant for the cache before calling this
//        routine.
//
//  08-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG
NlsSetRegAndCache(
    LPWSTR pValue,
    LPWSTR pCacheString,
    LPWSTR pData,
    ULONG DataLength)
{
    UNICODE_STRING ObValueName;             // value name
    ULONG rc;                               // return code

    if (hCPanelIntlKeyWrite != INVALID_HANDLE_VALUE)
    {
        //
        // Validate data length to be set in the registry
        //
        if (DataLength >= MAX_REG_VAL_SIZE)
        {
            return ((ULONG)STATUS_INVALID_PARAMETER);
        }


        RTL_SOFT_VERIFY(NT_SUCCESS(rc = BaseSrvSxsInvalidateSystemDefaultActivationContextCache()));

        //
        //  Set the value in the registry.
        //
        RtlInitUnicodeString(&ObValueName, pValue);

        rc = NtSetValueKey( hCPanelIntlKeyWrite,
                            &ObValueName,
                            0,
                            REG_SZ,
                            (PVOID)pData,
                            DataLength );

        //
        //  Copy the new string to the cache.
        //
        if (NT_SUCCESS(rc))
        {
            wcsncpy(pCacheString, pData, DataLength);
            pCacheString[DataLength / sizeof(WCHAR)] = 0;
        }

        //
        //  Return the result.
        //
        return (rc);
    }

    //
    //  Return access denied, since the key is not open for write access.
    //
    return ((ULONG)STATUS_ACCESS_DENIED);
}

////////////////////////////////////////////////////////////////////////////
//
//  BaseSrvNlsGetUserInfo
//
//  This routine gets all of the values (including ulCacheUpdateCount) in the NLS cache, and copy it
//  to the buffer in the capture buffer.
//
//  Parameters:
//      pData in BASE_NLS_GET_USER_INFO_MSG contains the target buffer to write.
//      DataLength in BASE_NLS_GET_USER_INFO_MSG is the size of target buffer.  It should be the value of sizeof(NLS_USER_INFO).
//
//  When this function returns, the capture buffer will contain the data
//  of the specified field.
//  
//
//  06-06-2002    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS
BaseSrvNlsGetUserInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PBASE_NLS_GET_USER_INFO_MSG a =
        (PBASE_NLS_GET_USER_INFO_MSG)&m->u.ApiMessageData;

    NTSTATUS rc;                // return code
    LPWSTR pValue;              // Points to the cached value.

    if (!CsrValidateMessageBuffer(m, &a->pData, a->DataLength, sizeof(BYTE)))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    
    if (a->DataLength != sizeof(NLS_USER_INFO))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    rc = RtlEnterCriticalSection(&NlsCacheCriticalSection);
    if (!NT_SUCCESS( rc )) 
    {
        return (rc);
    }    
    RtlCopyMemory((LPVOID)a->pData, pNlsRegUserInfo, a->DataLength);
    RtlLeaveCriticalSection( &NlsCacheCriticalSection );
    

    //
    //  Return the result of NtSetValueKey.
    //
    return (rc);

    ReplyStatus;    // get rid of unreferenced parameter warning message
}


////////////////////////////////////////////////////////////////////////////
//
//  BaseSrvNlsSetUserInfo
//
//  This routine sets a particular value in the NLS cache and updates the
//  registry entry.
//
//  08-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG
BaseSrvNlsSetUserInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PBASE_NLS_SET_USER_INFO_MSG a =
        (PBASE_NLS_SET_USER_INFO_MSG)&m->u.ApiMessageData;

    ULONG rc;                // return code
    LPWSTR pValue;
    LPWSTR pCache;

    if (!CsrValidateMessageBuffer(m, &a->pData, a->DataLength, sizeof(BYTE)))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    RTL_VERIFY(NT_SUCCESS(rc = BaseSrvDelayLoadKernel32()));
    ASSERT(pValidateLCType != NULL);

    if (0 == (*pValidateLCType)(pNlsRegUserInfo, a->LCType, &pValue, &pCache))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    rc = RtlEnterCriticalSection(&NlsCacheCriticalSection);
    if (!NT_SUCCESS( rc )) 
    {
        return (rc);
    }
    

    //
    //  Set the value in the registry and update the cache.
    //
    rc = NlsSetRegAndCache( pValue,
                            pCache,
                            a->pData,
                            a->DataLength );
    if (NT_SUCCESS(rc))
    {
        // Increment the cache update count.  There is no need to use InterlockedExchange() since
        // all updates to ulCacheUpdateCount are protected in the same critical section.
    
        pNlsRegUserInfo->ulCacheUpdateCount++;
    }

    RtlLeaveCriticalSection( &NlsCacheCriticalSection );

    //
    //  Return the result of NtSetValueKey.
    //
    return (rc);

    ReplyStatus;    // get rid of unreferenced parameter warning message
}


////////////////////////////////////////////////////////////////////////////
//
//  BaseSrvNlsSetMultipleUserInfo
//
//  This routine sets the date/time strings in the NLS cache and updates the
//  registry entries.
//
//  This call is done so that only one client/server transition is needed
//  when setting multiple entries.
//
//  08-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG
BaseSrvNlsSetMultipleUserInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PBASE_NLS_SET_MULTIPLE_USER_INFO_MSG a =
        (PBASE_NLS_SET_MULTIPLE_USER_INFO_MSG)&m->u.ApiMessageData;

    BOOL DoNotUpdateCacheCount = FALSE;
    ULONG rc = 0L;                     // return code

    if (!CsrValidateMessageBuffer(m, &a->pPicture, a->DataLength, sizeof(BYTE)))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    if (!CsrValidateMessageString(m, &a->pSeparator))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    if (!CsrValidateMessageString(m, &a->pOrder))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    if (!CsrValidateMessageString(m, &a->pTLZero))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    if (!CsrValidateMessageString(m, &a->pTimeMarkPosn))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    rc = RtlEnterCriticalSection(&NlsCacheCriticalSection);
    if (!NT_SUCCESS( rc )) 
    {
        return (rc);
    }
    

    switch (a->Flags)
    {
        case ( LOCALE_STIMEFORMAT ) :
        {
            rc = NlsSetRegAndCache( NLS_VALUE_STIMEFORMAT,
                                    pNlsRegUserInfo->sTimeFormat,
                                    a->pPicture,
                                    a->DataLength );
            if (NT_SUCCESS(rc))
            {
                rc = NlsSetRegAndCache( NLS_VALUE_STIME,
                                        pNlsRegUserInfo->sTime,
                                        a->pSeparator,
                                        (wcslen(a->pSeparator) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                rc = NlsSetRegAndCache( NLS_VALUE_ITIME,
                                        pNlsRegUserInfo->iTime,
                                        a->pOrder,
                                        (wcslen(a->pOrder) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                rc = NlsSetRegAndCache( NLS_VALUE_ITLZERO,
                                        pNlsRegUserInfo->iTLZero,
                                        a->pTLZero,
                                        (wcslen(a->pTLZero) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                rc = NlsSetRegAndCache( NLS_VALUE_ITIMEMARKPOSN,
                                        pNlsRegUserInfo->iTimeMarkPosn,
                                        a->pTimeMarkPosn,
                                        (wcslen(a->pTimeMarkPosn) + 1) * sizeof(WCHAR) );
            }

            break;
        }

        case ( LOCALE_STIME ) :
        {
            rc = NlsSetRegAndCache( NLS_VALUE_STIME,
                                    pNlsRegUserInfo->sTime,
                                    a->pSeparator,
                                    a->DataLength );
            if (NT_SUCCESS(rc))
            {
                rc = NlsSetRegAndCache( NLS_VALUE_STIMEFORMAT,
                                        pNlsRegUserInfo->sTimeFormat,
                                        a->pPicture,
                                        (wcslen(a->pPicture) + 1) * sizeof(WCHAR) );
            }

            break;
        }

        case ( LOCALE_ITIME ) :
        {
            rc = NlsSetRegAndCache( NLS_VALUE_ITIME,
                                    pNlsRegUserInfo->iTime,
                                    a->pOrder,
                                    a->DataLength );
            if (NT_SUCCESS(rc))
            {
                rc = NlsSetRegAndCache( NLS_VALUE_STIMEFORMAT,
                                        pNlsRegUserInfo->sTimeFormat,
                                        a->pPicture,
                                        (wcslen(a->pPicture) + 1) * sizeof(WCHAR) );
            }

            break;
        }

        case ( LOCALE_SSHORTDATE ) :
        {
            rc = NlsSetRegAndCache( NLS_VALUE_SSHORTDATE,
                                    pNlsRegUserInfo->sShortDate,
                                    a->pPicture,
                                    a->DataLength );
            if (NT_SUCCESS(rc))
            {
                rc = NlsSetRegAndCache( NLS_VALUE_SDATE,
                                        pNlsRegUserInfo->sDate,
                                        a->pSeparator,
                                        (wcslen(a->pSeparator) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                rc = NlsSetRegAndCache( NLS_VALUE_IDATE,
                                        pNlsRegUserInfo->iDate,
                                        a->pOrder,
                                        (wcslen(a->pOrder) + 1) * sizeof(WCHAR) );
            }

            break;
        }

        case ( LOCALE_SDATE ) :
        {
            rc = NlsSetRegAndCache( NLS_VALUE_SDATE,
                                    pNlsRegUserInfo->sDate,
                                    a->pSeparator,
                                    a->DataLength );
            if (NT_SUCCESS(rc))
            {
                rc = NlsSetRegAndCache( NLS_VALUE_SSHORTDATE,
                                        pNlsRegUserInfo->sShortDate,
                                        a->pPicture,
                                        (wcslen(a->pPicture) + 1) * sizeof(WCHAR) );
            }

            break;
        }

        default:
        {
            DoNotUpdateCacheCount = TRUE;
            break;
        }


    }

    if (NT_SUCCESS(rc) && (DoNotUpdateCacheCount == FALSE))
    {
        // Increment the cache update count.  There is no need to use InterlockedExchange() since
        // all updates to ulCacheUpdateCount are protected in the same critical section.
    
        pNlsRegUserInfo->ulCacheUpdateCount++;
    }

    RtlLeaveCriticalSection(&NlsCacheCriticalSection);
    //
    //  Return the result.
    //
    return (rc);

    ReplyStatus;    // get rid of unreferenced parameter warning message
}


////////////////////////////////////////////////////////////////////////////
//
//  BaseSrvNlsUpdateCacheCount
//
//  This routine forces an increment on pNlsUserInfo->ulNlsCacheUpdateCount
//
//  11-29-99    SamerA    Created.
////////////////////////////////////////////////////////////////////////////

ULONG
BaseSrvNlsUpdateCacheCount(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PBASE_NLS_UPDATE_CACHE_COUNT_MSG a =
        (PBASE_NLS_UPDATE_CACHE_COUNT_MSG)&m->u.ApiMessageData;

    //
    // Increment the cache count.
    // Use Interlocked operation since we do not use a critical section here.
    //
    if (pNlsRegUserInfo)
    {
        RtlEnterCriticalSection(&NlsCacheCriticalSection);    
        pNlsRegUserInfo->ulCacheUpdateCount++;
        RtlLeaveCriticalSection(&NlsCacheCriticalSection);
    }

    return (0L);

    ReplyStatus;    // get rid of unreferenced parameter warning message
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsUpdateCacheInfo
//
//  This routine updates the NLS cache when a registry notification occurs.
/// It will update every field in the NLS cache which stores value in the
//  the registry.
//
//  NOTENOTE: 
//      THE CALLER OF THIS FUNCITON SHOULD BE IN A CRITICAL SECTION
//      PROTECTED BY NlsCacheCriticalSection, SINCE THE ulCacheUpdateCount
//      AND pNlsRegUserInfo ARE UPDATED IN THIS FUNCTION.
//
//  08-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

VOID
NlsUpdateCacheInfo()
{
    LCID Locale;                       // locale id
    UNICODE_STRING ObKeyName;          // key name
    LPWSTR pTmp;                       // tmp string pointer
    int ctr;                           // loop counter
    ULONG ResultLength;                // result length
    ULONG rc = 0L;                     // return code

    BYTE KeyValuePart[MAX_KEY_VALUE_PARTINFO];
    PKEY_VALUE_PARTIAL_INFORMATION pValuePart;

    //
    //  NOTE:  The caller of this function should already have the
    //         cache mutant before calling this routine.
    //
    
    //
    //  Update the cache information.
    //
    pTmp = (LPWSTR)pNlsRegUserInfo;
    pValuePart = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValuePart;
    for (ctr = 0; ctr < NumCPanelRegValues; ctr++)
    {
        RtlInitUnicodeString(&ObKeyName, pCPanelRegValues[ctr]);
        rc = NtQueryValueKey( hCPanelIntlKeyRead,
                              &ObKeyName,
                              KeyValuePartialInformation,
                              pValuePart,
                              MAX_KEY_VALUE_PARTINFO,
                              &ResultLength );
        if (NT_SUCCESS(rc))
        {
            wcsncpy(pTmp, (LPWSTR)(pValuePart->Data), MAX_REG_VAL_SIZE);
            // When the length of the string in the registry is greater than or equal to
            // MAX_REG_VAL_SIZE, wcsncpy won't put NULL terminiator for us.  So we make sure that
            // it is NULL terminated at the end of the buffer in the statement below.
            pTmp[MAX_REG_VAL_SIZE - 1] = UNICODE_NULL;
        }
        else
        {
            *pTmp = NLS_INVALID_INFO_CHAR;
            *(pTmp + 1) = UNICODE_NULL;
        }

        //
        //  Increment pointer to cache structure.
        //
        pTmp += MAX_REG_VAL_SIZE;
    }

    //
    // Once we finished reading the reg-data, let's increment
    // our global update cache count
    //
    pNlsRegUserInfo->ulCacheUpdateCount++;

    //
    //  Convert the user locale id string to a dword value and store
    //  it in the cache.
    //
    pNlsRegUserInfo->UserLocaleId = (LCID)0;
    if ((pNlsRegUserInfo->sLocale)[0] != NLS_INVALID_INFO_CHAR)
    {
        RtlInitUnicodeString(&ObKeyName, pNlsRegUserInfo->sLocale);
        if (NT_SUCCESS(RtlUnicodeStringToInteger(&ObKeyName, 16, &Locale)))
        {
            pNlsRegUserInfo->UserLocaleId = Locale;
        }
    }

    //
    //  Make sure the user locale id was found.  Otherwise, set it to
    //  the system locale.
    //
    if (pNlsRegUserInfo->UserLocaleId == 0)
    {
        NtQueryDefaultLocale(FALSE, &(pNlsRegUserInfo->UserLocaleId));
    }

}


////////////////////////////////////////////////////////////////////////////
//
//  BaseSrvNlsCreateSection
//
////////////////////////////////////////////////////////////////////////////

ULONG
BaseSrvNlsCreateSection(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PBASE_NLS_CREATE_SECTION_MSG a =
        (PBASE_NLS_CREATE_SECTION_MSG)&m->u.ApiMessageData;

    UNICODE_STRING ObSecName;                // section name
    LARGE_INTEGER Size;
    WCHAR wszFileName[MAX_SMALL_BUF_LEN];    // file name (Actually l2 chars is max: c_nlsXXXXX.nls\0
    WCHAR wszSecName[MAX_SMALL_BUF_LEN];     // section name string
    HANDLE hNewSec = (HANDLE)0;              // new section handle
    HANDLE hProcess = (HANDLE)0;             // process handle
    OBJECT_ATTRIBUTES ObjA;                  // object attributes structure
    NTSTATUS rc = 0L;                        // return code   
    LPWSTR pFile = NULL;
    HANDLE hFile = (HANDLE)0;                // file handle
    ANSI_STRING proc;
    PVOID pTemp;                             // temp pointer
    BYTE pSecurityDescriptor[MAX_SMALL_SECURITY_DESCRIPTOR];    // Buffer for our security descriptor
  
    RTL_VERIFY(NT_SUCCESS(rc = BaseSrvDelayLoadKernel32()));

    //
    //  Set the handles to null.
    //
    a->hNewSection = NULL;

    if (a->Locale)
    {
        if (!(*pValidateLocale)(a->Locale))
        {
            return (STATUS_INVALID_PARAMETER);
        }
    }

    switch (a->uiType)
    {
        case (NLS_CREATE_SECTION_UNICODE) :
        {
            RtlInitUnicodeString(&ObSecName, NLS_SECTION_UNICODE);
            pFile = NLS_FILE_UNICODE;
            break;
        }

        case (NLS_CREATE_SECTION_GEO) :
        {
            RtlInitUnicodeString(&ObSecName, NLS_SECTION_GEO);
            pFile = NLS_FILE_GEO;
            break;
        }

        case (NLS_CREATE_SECTION_LOCALE) :
        {
            RtlInitUnicodeString(&ObSecName, NLS_SECTION_LOCALE);
            pFile = NLS_FILE_LOCALE;
            break;
        }

        case (NLS_CREATE_SECTION_CTYPE) :
        {
            RtlInitUnicodeString(&ObSecName, NLS_SECTION_CTYPE);
            pFile = NLS_FILE_CTYPE;
            break;
        }

        case (NLS_CREATE_SECTION_SORTKEY) :
        {
            RtlInitUnicodeString(&ObSecName, NLS_SECTION_SORTKEY);
            pFile = NLS_FILE_SORTKEY;
            break;
        }

        case (NLS_CREATE_SECTION_SORTTBLS) :
        {
            RtlInitUnicodeString(&ObSecName, NLS_SECTION_SORTTBLS);
            pFile = NLS_FILE_SORTTBLS;
            break;
        }

        case (NLS_CREATE_SECTION_DEFAULT_OEMCP) :
        {
            RtlInitUnicodeString(&ObSecName, NLS_DEFAULT_SECTION_OEMCP);
            pFile = NLS_DEFAULT_FILE_OEMCP;
            break;
        }


        case (NLS_CREATE_SECTION_DEFAULT_ACP) :
        {
            RtlInitUnicodeString(&ObSecName, NLS_DEFAULT_SECTION_ACP);
            pFile = NLS_DEFAULT_FILE_ACP;
            break;
        }

        case (NLS_CREATE_SECTION_LANG_EXCEPT) :
        {
            RtlInitUnicodeString(&ObSecName, NLS_SECTION_LANG_EXCEPT);
            pFile = NLS_FILE_LANG_EXCEPT;
            break;
        }

        case (NLS_CREATE_CODEPAGE_SECTION) :
        {
            // Get the Code Page file name from registry
            ASSERT(pGetCPFileNameFromRegistry);
            if ( FALSE == (*pGetCPFileNameFromRegistry)( a->Locale,
                                                         wszFileName,
                                                         MAX_SMALL_BUF_LEN ) )
            {
                return (STATUS_INVALID_PARAMETER);
            }

            // Remember we're using this file name
            pFile = wszFileName;

            // Hmm, we'll need the section name for this section.
            // Note that this had better be in sync with what we see
            // in winnls\tables.c or else the server will be called needlessly.
            ASSERT(pGetNlsSectionName != NULL);
            if (!NT_SUCCESS((*pGetNlsSectionName)( a->Locale,
                                                   10,
                                                   0,
                                                   NLS_SECTION_CPPREFIX,
                                                   wszSecName,
                                                   MAX_SMALL_BUF_LEN)))
            {
                return (rc);
            }

            // Make it a string we can remember/use later
            RtlInitUnicodeString(&ObSecName, wszSecName);
            
            break;
        }
        case ( NLS_CREATE_SORT_SECTION ) :
        {
            if (a->Locale == 0)
            {
                return (STATUS_INVALID_PARAMETER);
            }

            ASSERT(pGetNlsSectionName != NULL);
            if (rc = (*pGetNlsSectionName)( a->Locale,
                                            16,
                                            8,
                                            NLS_SECTION_SORTKEY,
                                            wszSecName,
                                            MAX_SMALL_BUF_LEN))
            {
                return (rc);
            }

            ASSERT(pGetDefaultSortkeySize != NULL);
            (*pGetDefaultSortkeySize)(&Size);
            RtlInitUnicodeString(&ObSecName, wszSecName);

            break;
        }
        case ( NLS_CREATE_LANG_EXCEPTION_SECTION ) :
        {
            if (a->Locale == 0)
            {
                //
                //  Creating the default section.
                //
                RtlInitUnicodeString(&ObSecName, NLS_SECTION_LANG_INTL);
            }
            else
            {
                ASSERT(pGetNlsSectionName != NULL);
                if (rc = (*pGetNlsSectionName)( a->Locale,
                                                16,
                                                8,
                                                NLS_SECTION_LANGPREFIX,
                                                wszSecName,
                                                MAX_SMALL_BUF_LEN))
                {
                return (rc);
                }
                RtlInitUnicodeString(&ObSecName, wszSecName);
            }

            (*pGetLinguistLangSize)(&Size);
            break;
        }
        default:
            return (STATUS_INVALID_PARAMETER);
    }

    if (pFile)
    {
        //
        //  Open the data file.
        //
        ASSERT(pOpenDataFile != NULL);
        if (rc = (*pOpenDataFile)( &hFile,
                       pFile ))
        {
            return (rc);
        }

    }

    //
    //  Create the NEW Section for Read and Write access.
    //  Add a ReadOnly security descriptor so that only the
    //  initial creating process may write to the section.
    //
    ASSERT(pCreateNlsSecurityDescriptor);
    rc = (*pCreateNlsSecurityDescriptor)( (PSECURITY_DESCRIPTOR)pSecurityDescriptor,
                                          MAX_SMALL_SECURITY_DESCRIPTOR,
                                          GENERIC_READ);
    if (!NT_SUCCESS(rc))
    {
        if (hFile)
            NtClose(hFile);
            return (rc);
    }

    InitializeObjectAttributes( &ObjA,
                                &ObSecName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                NULL,
                                pSecurityDescriptor );

    rc = NtCreateSection( &hNewSec,
                          hFile ? SECTION_MAP_READ : SECTION_MAP_READ | SECTION_MAP_WRITE,
                          &ObjA,
                          hFile? NULL:&Size,
                          hFile ? PAGE_READONLY:PAGE_READWRITE,
                          SEC_COMMIT,
                          hFile );

    NtClose(hFile);

    //
    //  Check for error from NtCreateSection.
    //
    if (!NT_SUCCESS(rc))
    {
        // KdPrint(("NLSAPI (BaseSrv): Could NOT Create Section %wZ - %lx.\n", &ObSecName, rc));
        return (rc);
    }

    //
    //  Duplicate the new section handle for the client.
    //  The client will map a view of the section and fill in the data.
    //
    InitializeObjectAttributes( &ObjA,
                                NULL,
                                0,
                                NULL,
                                NULL );

    rc = NtOpenProcess( &hProcess,
                        PROCESS_DUP_HANDLE,
                        &ObjA,
                        &m->h.ClientId );

    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI (BaseSrv): Could NOT Open Process - %lx.\n", rc));
        NtClose(hNewSec);
        return (rc);
    }

    rc = NtDuplicateObject( NtCurrentProcess(),
                            hNewSec,
                            hProcess,
                            &(a->hNewSection),
                            0L,
                            0L,
                            DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE );

    //
    //  Close the process handle we opened.
    //
    NtClose(hProcess);
    return (rc);

    ReplyStatus;    // get rid of unreferenced parameter warning message
}

////////////////////////////////////////////////////////////////////////////
//
//  GetThreadAuthenticationId
//
//  Retreives the authentication id of the security context of the
//  currently executing thread.
//
//  12-22-98    SamerA    Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS GetThreadAuthenticationId(
    PLUID Luid)
{
    HANDLE TokenHandle;
    TOKEN_STATISTICS TokenInformation;
    ULONG BytesRequired;
    NTSTATUS NtStatus;


    NtStatus = NtOpenThreadToken( NtCurrentThread(),
                                  TOKEN_QUERY,
                                  FALSE,
                                  &TokenHandle );

    if (!NT_SUCCESS(NtStatus))
    {
        KdPrint(("NLSAPI (BaseSrv) : No thread token in BaseSrvNlsLogon - %lx\n", NtStatus));
        return (NtStatus);
    }

    //
    //  Get the LUID.
    //
    NtStatus = NtQueryInformationToken(
                   TokenHandle,
                   TokenStatistics,
                   &TokenInformation,
                   sizeof(TokenInformation),
                   &BytesRequired );

    if (NT_SUCCESS( NtStatus ))
    {
        RtlCopyLuid(Luid, &TokenInformation.AuthenticationId);
    }
    else
    {
        KdPrint(("NLSAPI (BaseSrv) : Couldn't Query Information for Token %lx. NtStatus = %lx\n", TokenHandle, NtStatus));
    }

    NtClose(TokenHandle);

    return (NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvvdm.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvvdm.h

Abstract:

    Include file for VDM related functions

Author:

    Sudeep Bharati (sudeepb) 03-Sep-1991

Revision History:

--*/


// Shared wow vdm definition

typedef struct tagSharedWowRecord *PSHAREDWOWRECORD;
typedef struct _WOWRecord *PWOWRECORD;

typedef struct tagSharedWowRecord {

   // all these structures are wired to the console list
   // so that each shared wow is identified in the console list by it's handle
   // the reason for this extra linkage is to speed up certain calls in which we
   // already know it's wow

   PSHAREDWOWRECORD pNextSharedWow;    // points to the next shared vdm

   HANDLE hConsole;                    // hidden console of wow

   HANDLE hwndWowExec;                 // handle to a wow exec window
   DWORD  dwWowExecProcessId;          // process id of a wowexec
   DWORD  dwWowExecThreadId;           // thread id for wowexec

   // why sequence number:
   // Davehart explains that we could get in trouble if basesrv thinks
   // that wowexec could be identified uniquely by it's window handle, process id and thread id.
   // In reality, these values are recycled rather quickly which could lead us to [mistakenly]
   // accept hwndWowExec for a wowexec window when, in reality the relevant wowexec has long been
   // gone. This number reflects a sequential order in which processes are created.
   // And while it could still be recycled (when it overflows) this is a rather rare event.

   // all the sequence number info that we are in need of is located in the console
   // record itself


   // This is a unicode string representing windows station/desktop which is supported by this
   // particular ntvdm
   UNICODE_STRING WowExecDesktopName;


   ULONG VDMState; // the state of this shared wow

   // task queue
   PWOWRECORD pWOWRecord;

   // LUID - auth id for this wow

   LUID WowAuthId;

   // WOWUserToken - auth process token
   HANDLE WOWUserToken;

   // this is what is so interesting about this particular setting
   // special id that uniquely identifies this wow in the context of this machine
   // consists of [Time] + [SequenceNumber]

   // size of this structure is variable and depends on the length of the desktop name as
   // it is fitted together with this structure


   // sequence number
   ULONG SequenceNumber;
   ULONG ParentSequenceNumber;
   LPTHREAD_START_ROUTINE pfnW32HungAppNotifyThread;  // For VDMTerminateTask

}  SHAREDWOWRECORD, *PSHAREDWOWRECORD;


typedef struct _DOSRecord *PDOSRECORD;
typedef struct _DOSRecord {
    PDOSRECORD DOSRecordNext;       // Task record chain
    ULONG   VDMState;               // VDM State (bit flags)
    ULONG   ErrorCode;              // Error Code returned by DOS
    HANDLE  hWaitForParent;         // Handle to wait object for parent to wait on
    HANDLE  hWaitForParentDup;      // Dup of hWaitForParent
    PVDMINFO lpVDMInfo;             // Pointer to VDM Information block
    ULONG      iTask;
    DWORD    dwThreadId;
    WORD     hTask16;
    WORD     hMod16;
    PCHAR    pFilePath;
    CHAR     szModName[9];
} DOSRECORD, *PDOSRECORD;

typedef struct _CONSOLERECORD *PCONSOLERECORD;
typedef struct _CONSOLERECORD {
    PCONSOLERECORD Next;

    HANDLE  hConsole;               // Console Handle of the session
    HANDLE  hVDM;                   // NTVDM process handle running in the console

    // these two members below are used only with dos vdm
    HANDLE  hWaitForVDM;            // Handle on which VDM will wait
    HANDLE  hWaitForVDMDup;         // Handle on which server will wake up the VDM (Its a dup of previous one)

    ULONG   nReEntrancy;            // Re-entrancy count
    ULONG   SequenceNumber;         // Sequencenumber from PCSR_PROCESS
    ULONG   ParentSequenceNumber;   // Sequencenumber of parent
    ULONG   DosSesId;               // Temp Session ID for no-console
    DWORD   dwProcessId;

    // these two members below are used only with dos vdm
    ULONG   cchCurDirs;             // Length of NTVDM current directory in bytes
    PCHAR   lpszzCurDirs;           // NTVDM current directory accross VDMs
    PDOSRECORD DOSRecord;           // Information for Tasks in this console
    // UserToken - auth process token
    HANDLE DosUserToken;
    LPTHREAD_START_ROUTINE pfnW32HungAppNotifyThread;  // For VDMTerminateTask
} CONSOLERECORD, *PCONSOLERECORD;


typedef struct _WOWRecord {
    ULONG      iTask;
    BOOL       fDispatched;            // Is Command Dispatched
    HANDLE     hWaitForParent;         // Parent Will wait on it
    HANDLE     hWaitForParentServer;   // Server will wake up the parent on it
    PVDMINFO   lpVDMInfo;              // Pointer to VDM Information block
    PWOWRECORD WOWRecordNext;          // Task Record chain
    DWORD    dwThreadId;
    WORD     hTask16;
    WORD     hMod16;
    PCHAR    pFilePath;
    CHAR     szModName[9];
} WOWRECORD, *PWOWRECORD;

typedef struct _INFORECORD {
    ULONG       iTag;
    union {
        PWOWRECORD      pWOWRecord;
        PDOSRECORD      pDOSRecord;
    } pRecord;
} INFORECORD, *PINFORECORD;

typedef struct _BATRECORD {
    HANDLE  hConsole;
    ULONG   SequenceNumber;
    struct  _BATRECORD *BatRecordNext;
} BATRECORD, *PBATRECORD;

#define WOWMINID                      1
#define WOWMAXID                      0xfffffffe

// VDMState Defines

#define VDM_TO_TAKE_A_COMMAND       1
#define VDM_BUSY                    2
#define VDM_HAS_RETURNED_ERROR_CODE 4
#define VDM_READY                   8


VOID  BaseSrvVDMInit(VOID);
ULONG BaseSrvCheckVDM(PCSR_API_MSG, PCSR_REPLY_STATUS);
ULONG BaseSrvUpdateVDMEntry(PCSR_API_MSG, PCSR_REPLY_STATUS);
ULONG BaseSrvGetNextVDMCommand(PCSR_API_MSG, PCSR_REPLY_STATUS);
ULONG BaseSrvExitVDM(PCSR_API_MSG, PCSR_REPLY_STATUS);
ULONG BaseSrvIsFirstVDM(PCSR_API_MSG, PCSR_REPLY_STATUS);
ULONG BaseSrvSetReenterCount (PCSR_API_MSG, PCSR_REPLY_STATUS);
ULONG BaseSrvCheckWOW(PBASE_CHECKVDM_MSG, HANDLE);
ULONG BaseSrvCheckDOS(PBASE_CHECKVDM_MSG, HANDLE);
BOOL  BaseSrvCopyCommand(PBASE_CHECKVDM_MSG,PINFORECORD);
ULONG BaseSrvUpdateWOWEntry(PBASE_UPDATE_VDM_ENTRY_MSG,ULONG);
ULONG BaseSrvUpdateDOSEntry(PBASE_UPDATE_VDM_ENTRY_MSG,ULONG);
NTSTATUS BaseSrvExitWOWTask(PBASE_EXIT_VDM_MSG, ULONG);
NTSTATUS BaseSrvExitDOSTask(PBASE_EXIT_VDM_MSG, ULONG);
ULONG BaseSrvGetWOWRecord(ULONG,PWOWRECORD *);
ULONG BaseSrvGetVDMExitCode(PCSR_API_MSG,PCSR_REPLY_STATUS);
ULONG BaseSrvDupStandardHandles(HANDLE, PDOSRECORD);
NTSTATUS BaseSrvGetConsoleRecord (HANDLE,PCONSOLERECORD*);
VOID  BaseSrvFreeWOWRecord (PWOWRECORD);
PCONSOLERECORD BaseSrvAllocateConsoleRecord (VOID);
VOID  BaseSrvFreeConsoleRecord (PCONSOLERECORD);
VOID  BaseSrvRemoveConsoleRecord (PCONSOLERECORD);
PDOSRECORD BaseSrvAllocateDOSRecord(VOID);
VOID  BaseSrvFreeDOSRecord (PDOSRECORD);
VOID  BaseSrvAddDOSRecord (PCONSOLERECORD,PDOSRECORD);
VOID  BaseSrvRemoveDOSRecord (PCONSOLERECORD,PDOSRECORD);
VOID  BaseSrvFreeVDMInfo(PVDMINFO);
ULONG BaseSrvCreatePairWaitHandles (HANDLE *, HANDLE *);
VOID  BaseSrvAddConsoleRecord(PCONSOLERECORD);
VOID  BaseSrvCloseStandardHandles (HANDLE, PDOSRECORD);
VOID  BaseSrvClosePairWaitHandles (PDOSRECORD);
VOID  BaseSrvVDMTerminated (HANDLE, ULONG);

NTSTATUS
BaseSrvUpdateVDMSequenceNumber (
    IN ULONG  VdmBinaryType,    // binary type
    IN HANDLE hVDM,             // console handle
    IN ULONG  DosSesId,         // session id
    IN HANDLE UniqueProcessClientID,
    IN HANDLE UniqueProcessParentID
    );

VOID  BaseSrvCleanupVDMResources (PCSR_PROCESS);
VOID  BaseSrvExitVDMWorker (PCONSOLERECORD);
NTSTATUS BaseSrvFillPifInfo (PVDMINFO,PBASE_GET_NEXT_VDM_COMMAND_MSG);
ULONG BaseSrvGetVDMCurDirs(PCSR_API_MSG, PCSR_REPLY_STATUS);
ULONG BaseSrvSetVDMCurDirs(PCSR_API_MSG, PCSR_REPLY_STATUS);
ULONG BaseSrvBatNotification(PCSR_API_MSG, PCSR_REPLY_STATUS);
ULONG BaseSrvRegisterWowExec(PCSR_API_MSG, PCSR_REPLY_STATUS);
PBATRECORD BaseSrvGetBatRecord(HANDLE);
PBATRECORD BaseSrvAllocateAndAddBatRecord(HANDLE);
VOID  BaseSrvFreeAndRemoveBatRecord(PBATRECORD);
BOOL BaseSrvIsVdmAllowed(VOID);
NTSTATUS BaseSrvIsClientVdm(HANDLE UniqueProcessClientId);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvtask.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvtask.c

Abstract:

    This module implements windows server tasking functions

Author:

    Mark Lucovsky (markl) 13-Nov-1990

Revision History:

--*/

#include "basesrv.h"

#if defined(_WIN64)
#include <wow64t.h>
#endif // defined(_WIN64)

PFNNOTIFYPROCESSCREATE UserNotifyProcessCreate = NULL;

void
BaseSetProcessCreateNotify(
    IN PFNNOTIFYPROCESSCREATE ProcessCreateRoutine
    )
{
    UserNotifyProcessCreate = ProcessCreateRoutine;
}

ULONG
BaseSrvCreateProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status, Status1;
    PBASE_CREATEPROCESS_MSG a = (PBASE_CREATEPROCESS_MSG)&m->u.ApiMessageData;
    HANDLE CsrClientProcess = NULL;
    HANDLE NewProcess = NULL;
    HANDLE Thread = NULL;
    PCSR_THREAD t;
    ULONG DebugFlags;
    DWORD dwFlags;
    PCSR_PROCESS ProcessVDM;
#if defined(_WIN64)
    PPEB32 Peb32 = NULL;
#endif // defined(_WIN64)
    PPEB NewPeb = NULL;
    USHORT ProcessorArchitecture = a->ProcessorArchitecture;
    BOOL setVdmBits = FALSE;
    PROCESS_BASIC_INFORMATION ProcessBasicInfo;

    if (a->VdmBinaryType ) {

        //
        // Remove the bit which indicates Check VDM Allowed access.
        // (See the client side for setting the bit.)
        //

        if (a->VdmBinaryType == BINARY_TYPE_INJWOW) {
            a->VdmBinaryType = 0;
            if (!BaseSrvIsVdmAllowed()) {
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }
        }

        setVdmBits = TRUE;
    }

    t = CSR_SERVER_QUERYCLIENTTHREAD();
    CsrClientProcess = t->Process->ProcessHandle;

#if defined(_WIN64)
    if (ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
        ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA32_ON_WIN64;
#endif // defined(_WIN64)

    //
    // Get handles to the process and thread local to the
    // Windows server.
    //

    if ((dwFlags = (DWORD)((ULONG_PTR)a->ProcessHandle) & 3)) {
        a->ProcessHandle = (HANDLE)((ULONG_PTR)a->ProcessHandle & ~3);
    }

    Status = NtDuplicateObject(
                CsrClientProcess,
                a->ProcessHandle,
                NtCurrentProcess(),
                &NewProcess,
                0L,
                0L,
                DUPLICATE_SAME_ACCESS
                );
    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = NtDuplicateObject(
                CsrClientProcess,
                a->ThreadHandle,
                NtCurrentProcess(),
                &Thread,
                0L,
                0L,
                DUPLICATE_SAME_ACCESS
                );
    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Register vdm allow bit with ntoskrnl to gain access to ntvdmcontrol
    //

    if (setVdmBits) {
        ULONG vdmFlags = 1;

        Status = NtSetInformationProcess(
                     NewProcess,
                     ProcessWx86Information,
                     &vdmFlags,
                     sizeof(vdmFlags)
                     );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
    }

    //
    // If we are a native client then we will have passed out Peb though so save a system call.
    //
    NewPeb = (PPEB) a->RealPeb;

    if (NewPeb == NULL) {

        Status =
            NtQueryInformationProcess(
                NewProcess,
                ProcessBasicInformation,
                &ProcessBasicInfo,
                sizeof(ProcessBasicInfo),
                NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrintEx(
               DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: NtQueryInformationProcess failed.\n", Status);
            goto Cleanup;
        }
        NewPeb = ProcessBasicInfo.PebBaseAddress;
    }

    if ((a->CreationFlags & CREATE_IGNORE_SYSTEM_DEFAULT) == 0) {
        Status = BaseSrvSxsDoSystemDefaultActivationContext(ProcessorArchitecture, NewProcess, NewPeb);
        if ((!NT_SUCCESS(Status)) && (Status != STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY)) {
            goto Cleanup;
        }
    }

    Status = BaseSrvSxsCreateProcess(CsrClientProcess, NewProcess, m, NewPeb);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    DebugFlags = 0;

    if ( a->CreationFlags & CREATE_NEW_PROCESS_GROUP ) {
        DebugFlags |= CSR_CREATE_PROCESS_GROUP;
    }

    if ( !(dwFlags & 2) ) {
        DebugFlags |= CSR_PROCESS_CONSOLEAPP;
    }

    Status = CsrCreateProcess(
                NewProcess,
                Thread,
                &a->ClientId,
                t->Process->NtSession,
                DebugFlags,
                NULL
                );

    switch(Status) {
    case STATUS_THREAD_IS_TERMINATING:
        if (a->VdmBinaryType )
            BaseSrvVDMTerminated (a->hVDM, a->VdmTask);
        *ReplyStatus = CsrClientDied;
        goto Cleanup;

    case STATUS_SUCCESS:
        //
        // notify USER that a process is being created. USER needs to know
        // for various synchronization issues such as startup activation,
        // startup synchronization, and type ahead.
        //
        // Turn on 0x8 bit of dwFlags if this is a WOW process being
        // created so that UserSrv knows to ignore the console's call
        // to UserNotifyConsoleApplication.
        //

        if (IS_WOW_BINARY(a->VdmBinaryType)) {
           dwFlags |= 8;
        }

        if (UserNotifyProcessCreate != NULL) {
            if (!(*UserNotifyProcessCreate)((DWORD)((ULONG_PTR)a->ClientId.UniqueProcess),
                    (DWORD)((ULONG_PTR)t->ClientId.UniqueThread),
                    0, dwFlags)) {
                //
                // NTRAID#589638-2002/03/29-earhart: changed to NTRAID
                // marker. Shouldn't we close the duplicated
                // process and thread handles above?
                //
                }
            }

        //
        // Update the VDM sequence number.
        //


        if (a->VdmBinaryType) {

           Status = BaseSrvUpdateVDMSequenceNumber(a->VdmBinaryType,
                                                   a->hVDM,
                                                   a->VdmTask,
                                                   a->ClientId.UniqueProcess,
                                                   m->h.ClientId.UniqueProcess);
           if (!NT_SUCCESS( Status )) {
                   //
                   // NTRAID#589638-2002/03/29-earhart: changed to
                   // NTRAID marker.  Shouldn't we close the
                   // duplicated process and thread handles above?
                   //
              BaseSrvVDMTerminated (a->hVDM, a->VdmTask);
           }
        }
        break;

        default:
        goto Cleanup;
    }

// We don't use the usual Exit: pattern here in order to more carefully
// preserve the preexisting behavior, which apparently leaks handles in error cases.
    return( (ULONG)Status );
Cleanup:
    if (NewProcess != NULL) {
        Status1 = NtClose(NewProcess);
        RTL_SOFT_ASSERT(NT_SUCCESS(Status1));
    }
    if (Thread != NULL) {
        Status1 = NtClose(Thread);
        RTL_SOFT_ASSERT(NT_SUCCESS(Status1));
    }
    return( (ULONG)Status );
}

ULONG
BaseSrvCreateThread(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_CREATETHREAD_MSG a = (PBASE_CREATETHREAD_MSG)&m->u.ApiMessageData;
    HANDLE Thread;
    NTSTATUS Status;
    PCSR_PROCESS Process;
    PCSR_THREAD t;

    t = CSR_SERVER_QUERYCLIENTTHREAD();

    Process = t->Process;
    if (Process->ClientId.UniqueProcess != a->ClientId.UniqueProcess) {
        if ( a->ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess ) {
            return STATUS_SUCCESS;
            }
        Status = CsrLockProcessByClientId( a->ClientId.UniqueProcess,
                                           &Process
                                         );
        if (!NT_SUCCESS( Status )) {
            return( Status );
            }
        }

    //
    // Get handles to the thread local to the
    // Windows server.
    //

    Status = NtDuplicateObject(
                t->Process->ProcessHandle,
                a->ThreadHandle,
                NtCurrentProcess(),
                &Thread,
                0L,
                0L,
                DUPLICATE_SAME_ACCESS
                );
    if ( NT_SUCCESS(Status) ) {
        Status = CsrCreateThread(
                    Process,
                    Thread,
                    &a->ClientId,
                    TRUE
                    );
        if (!NT_SUCCESS(Status)) {
            NtClose(Thread);
            }
        }

    if (Process != t->Process) {
        CsrUnlockProcess( Process );
        }

    return( (ULONG)Status );
    ReplyStatus;    // get rid of unreferenced parameter warning message
}

ULONG
BaseSrvRegisterThread(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_CREATETHREAD_MSG a = (PBASE_CREATETHREAD_MSG)&m->u.ApiMessageData;
    HANDLE Thread;
    NTSTATUS Status;
    PCSR_PROCESS Process;
    PCSR_THREAD CsrThread, ExistingThread;
    OBJECT_ATTRIBUTES NullAttributes;

    //
    // We assume the following:
    //
    //    We are called via a LPC_DATAGRAM since this is the only way
    //    that CSR will let the call go through. (csr requires
    //    LPC_REQUEST to be sent only by threads in its list). This
    //    means that CSR_SERVER_QUERYCLIENTTHREAD(); does not return a
    //    valid value.


    Status = CsrLockProcessByClientId( a->ClientId.UniqueProcess,
                                       &Process
                                     );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    //
    // Get handle to the thread local to the
    // Windows server. Since this is called as a
    // LPC_DATAGRAM message, the thread handle is
    // not passed in the message, but instead the
    // calling thread is opened
    //

    InitializeObjectAttributes( &NullAttributes, NULL, 0, NULL, NULL );
    Status = NtOpenThread(&Thread,
                          THREAD_ALL_ACCESS,
                          &NullAttributes,
                          &a->ClientId);

    if ( NT_SUCCESS(Status) ) {
        Status = CsrCreateThread(
                    Process,
                    Thread,
                    &a->ClientId,
                    FALSE
                    );
        if (!NT_SUCCESS(Status)) {
            NtClose(Thread);
            }
        }

    CsrUnlockProcess( Process );

    return( (ULONG)Status );
    ReplyStatus;    // get rid of unreferenced parameter warning message
}


EXCEPTION_DISPOSITION
FatalExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    DbgPrint("CSRSRV: Fatal Server Side Exception. Exception Info %lx\n",
        ExceptionInfo
        );
    DbgBreakPoint();
    return EXCEPTION_EXECUTE_HANDLER;
}

ULONG
BaseSrvExitProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_EXITPROCESS_MSG a = (PBASE_EXITPROCESS_MSG)&m->u.ApiMessageData;
    PCSR_THREAD t;
    ULONG rc = (ULONG)STATUS_ACCESS_DENIED;

    t = CSR_SERVER_QUERYCLIENTTHREAD();
    try {
        *ReplyStatus = CsrClientDied;
        rc = (ULONG)CsrDestroyProcess( &t->ClientId, (NTSTATUS)a->uExitCode );
        }
    except(FatalExceptionFilter( GetExceptionInformation() )) {
        DbgBreakPoint();
        }
    return rc;
}

ULONG
BaseSrvGetTempFile(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_GETTEMPFILE_MSG a = (PBASE_GETTEMPFILE_MSG)&m->u.ApiMessageData;

    BaseSrvGetTempFileUnique++;
    a->uUnique = BaseSrvGetTempFileUnique;
    return( (ULONG)a->uUnique & 0xffff );
    ReplyStatus;    // get rid of unreferenced parameter warning message
}

ULONG
BaseSrvDebugProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    return STATUS_UNSUCCESSFUL;
}

ULONG
BaseSrvDebugProcessStop(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    return STATUS_UNSUCCESSFUL;
}

ULONG
BaseSrvSetProcessShutdownParam(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCSR_PROCESS p;
    PBASE_SHUTDOWNPARAM_MSG a = (PBASE_SHUTDOWNPARAM_MSG)&m->u.ApiMessageData;

    p = CSR_SERVER_QUERYCLIENTTHREAD()->Process;

    if (a->ShutdownFlags & (~(SHUTDOWN_NORETRY))) {
        return !STATUS_SUCCESS;
        }

    p->ShutdownLevel = a->ShutdownLevel;
    p->ShutdownFlags = a->ShutdownFlags;

    return STATUS_SUCCESS;
    ReplyStatus;
}

ULONG
BaseSrvGetProcessShutdownParam(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCSR_PROCESS p;
    PBASE_SHUTDOWNPARAM_MSG a = (PBASE_SHUTDOWNPARAM_MSG)&m->u.ApiMessageData;

    p = CSR_SERVER_QUERYCLIENTTHREAD()->Process;

    a->ShutdownLevel = p->ShutdownLevel;
    a->ShutdownFlags = p->ShutdownFlags & SHUTDOWN_NORETRY;

    return STATUS_SUCCESS;
    ReplyStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\verifier\critsect.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Header Name:

    critsect.h

Abstract:

    This module implements verification functions for 
    critical section interfaces.

Author:

    Daniel Mihai (DMihai) 27-Mar-2001

Revision History:

--*/

#ifndef _CRITSECT_H_
#define _CRITSECT_H_

#include "support.h"

NTSTATUS
CritSectInitialize (
    VOID
    );

VOID
CritSectUninitialize (
    VOID
    );

VOID 
AVrfpFreeMemLockChecks (
    VERIFIER_DLL_FREEMEM_TYPE FreeMemType,
    PVOID StartAddress,
    SIZE_T RegionSize,
    PWSTR UnloadedDllName
    );

VOID
AVrfpIncrementOwnedCriticalSections (
    LONG Increment
    );

#endif // _CRITSECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvsxs.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    srvsxs.c

Abstract:

    Support for side-by-side (fusion) in the win32 base server.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    Jay Krell (a-JayK) July 2000 moved file opening from csr/sxs to kernel32
        marshal over large CreateProcess message with manifest, policy, and assembly path
        pass IStreams to sxs

    Jay Krell (a-JayK) September 2000
        moved (assembly directory computation from manifest) from basesrv to kernel32

    Jay Krell (a-JayK) October 2000 System Default Activation Context
        (aka System Compatible Activation Context)
--*/

#include "basesrv.h"
#include "SxsApi.h"
#include "ntldr.h"
#include "nturtl.h"
#include "mmapstm.h"
#include <limits.h>
#if defined(_WIN64)
#include "wow64t.h"
#endif // defined(_WIN64)

#if !defined(BASE_SRV_SXS_HRESULT_FROM_STATUS)
  #if defined(RTLP_HRESULT_FROM_STATUS)
    #define BASE_SRV_SXS_HRESULT_FROM_STATUS(x) RTLP_HRESULT_FROM_STATUS(x)
  #else
    #define BASE_SRV_SXS_HRESULT_FROM_STATUS(x) HRESULT_FROM_WIN32(RtlNtStatusToDosErrorNoTeb(x))
    //#define BASE_SRV_SXS_HRESULT_FROM_STATUS(x) HRESULT_FROM_WIN32(RtlNtStatusToDosError(x))
    //#define BASE_SRV_SXS_HRESULT_FROM_STATUS(x)   HRESULT_FROM_NT(x)
  #endif
#endif

#if DBG
BOOLEAN DebugFilter_SxsTrace;
#endif

#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_NO_SUCH_FILE             \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    || (x) == STATUS_OBJECT_PATH_NOT_FOUND    \
                                    || (x) == STATUS_RESOURCE_DATA_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_LANG_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_NAME_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_TYPE_NOT_FOUND  \
                                    || (x) == STATUS_SXS_CANT_GEN_ACTCTX      \
                                    || (x) == STATUS_SXS_ASSEMBLY_NOT_FOUND   \
                                    || (x) == STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

#define DPFLTR_LEVEL_WIN32(x)  ((x) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

typedef union _BASE_SRV_SXS_STREAM_UNION_WITH_VTABLE {
    BASE_SRV_MEMORY_MAPPED_STREAM_WITH_VTABLE Mmap;
    RTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE  OutOfProcess;
} BASE_SRV_SXS_STREAM_UNION_WITH_VTABLE, *PBASE_SRV_SXS_STREAM_UNION_WITH_VTABLE;

#if BASESRV_UNLOAD_SXS_DLL
PVOID SxsDllHandle;
RTL_CRITICAL_SECTION BaseSrvSxsCritSec;
LONG SxsDllHandleRefCount;
#endif
LONG BaseSrvSxsGetActCtxGenCount;
PSXS_GENERATE_ACTIVATION_CONTEXT_FUNCTION SxsActivationContextGenerationFunction;
ULONG PinnedMsvcrtDll; // ULONG instead of BOOLEAN for atomicity of store?

const UNICODE_STRING EmptyString = RTL_CONSTANT_STRING(L"");

RTL_CRITICAL_SECTION BaseSrvSxsSystemDefaultActivationContextCriticalSection;
BASE_SRV_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT SxsSystemDefaultActivationContexts[] =
{
#ifdef _WIN64
    { NULL, RTL_CONSTANT_STRING(L"x86"),  PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 },
#else
    { NULL, RTL_CONSTANT_STRING(L"x86"),  PROCESSOR_ARCHITECTURE_INTEL },
#endif
    { NULL, RTL_CONSTANT_STRING(L"ia64"), PROCESSOR_ARCHITECTURE_IA64 },
    { NULL, RTL_CONSTANT_STRING(L"amd64"), PROCESSOR_ARCHITECTURE_AMD64 }
};

#define STRING(x) #x
#define IF_NOT_SUCCESS_TRACE_AND_EXIT(subfunction) \
    do { \
        if (!NT_SUCCESS(Status)) { \
            KdPrintEx((DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() " STRING(subfunction) " failed 0x%08lx\n", __FUNCTION__, Status)); \
            goto Exit; \
        } \
    } while(0)

#define ASSERT_UNICODE_STRING_IS_NUL_TERMINATED(ustr)                   \
    ASSERT((ustr)->MaximumLength >= ((ustr)->Length + sizeof(WCHAR)));  \
    ASSERT((ustr)->Buffer[(ustr)->Length / sizeof(WCHAR)] == 0);

#define IMPERSONATE_ENTIRE_SXS_CALL 1

#if !IMPERSONATE_ENTIRE_SXS_CALL

typedef struct _ACTIVATION_CONTEXT_GENERATION_IMPERSONATION_CONTEXT {
    BOOL SuccessfulImpersonation;
} ACTIVATION_CONTEXT_GENERATION_IMPERSONATION_CONTEXT, *PACTIVATION_CONTEXT_GENERATION_IMPERSONATION_CONTEXT;


BOOL
__stdcall
BaseSrvpSxsActivationContextGenerationImpersonationCallback(
    PVOID ContextIn,
    BOOL Impersonate
    )
/*++
Routine Description:
    This function is called back by the sxs.dll API to create an activation
    context when it needs to impersonate or unimpersonate the client of the
    CSR message.
Arguments:
    ContextIn - PACTIVATION_CONTEXT_GENERATION_IMPERSONATION_CONTEXT
        passed in to the create activation context API returned back
        as a PVOID.  We use it to track whether the previous impersonate
        call succeeded.
    Impersonate - nonzero (TRUE) if this function should impersonate the
        client, zero (FALSE) if the function should revert to the normal
        csrss identity.
Return Value:
// the old comment
    TRUE on success; FALSE on failure.  The last error state is as
        CsrImpersonateClient() leaves it.
// a more accurate comment?
    TRUE on successful impersonation, FALSE upon no successful impersonation
        the last error status is defined
--*/
{
    BOOL Success = FALSE;
    PACTIVATION_CONTEXT_GENERATION_IMPERSONATION_CONTEXT Context =
        (PACTIVATION_CONTEXT_GENERATION_IMPERSONATION_CONTEXT) ContextIn;
    if (Impersonate) {
        Context->SuccessfulImpersonation = CsrImpersonateClient(NULL);
if you enable this function, you must revisit its error handling
        if (!Context->SuccessfulImpersonation)
            goto Exit;
    } else {
        if (Context->SuccessfulImpersonation) {
            CsrRevertToSelf();
            Context->SuccessfulImpersonation = FALSE;
        } else
            goto Exit;
    }
    Success = TRUE;
Exit:
    return Success;
}

#endif

//#define TRACE_AND_EXECUTE(x) do { DbgPrint("%s\n", #x); x ; } while(0)
#define TRACE_AND_EXECUTE(x) x

NTSTATUS
BaseSrvSxsInvalidateSystemDefaultActivationContextCache(
    VOID
    )
{
    ULONG i;
    HANDLE LocalSystemDefaultActivationContextSections[RTL_NUMBER_OF(SxsSystemDefaultActivationContexts)];
    HANDLE SectionHandle;
    RtlEnterCriticalSection(&BaseSrvSxsSystemDefaultActivationContextCriticalSection);
    __try {
        //
        // First copy to locals to minimize time in the critical section.
        //
        for (i = 0 ; i != RTL_NUMBER_OF(SxsSystemDefaultActivationContexts) ; ++i) {
            LocalSystemDefaultActivationContextSections[i] = SxsSystemDefaultActivationContexts[i].Section;
            SxsSystemDefaultActivationContexts[i].Section = NULL;
        }
    } __finally {
        RtlLeaveCriticalSection(&BaseSrvSxsSystemDefaultActivationContextCriticalSection);
    }
    //
    // Then iterate over locals, closing.
    //
    for (i = 0 ; i != RTL_NUMBER_OF(LocalSystemDefaultActivationContextSections) ; ++i) {
        SectionHandle = LocalSystemDefaultActivationContextSections[i];
        if (SectionHandle != NULL) {
            NTSTATUS Status1 = STATUS_SUCCESS;
            RTL_SOFT_VERIFY(NT_SUCCESS(Status1 = NtClose(SectionHandle)));
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
BaseSrvSxsInit(
    VOID
    )
/*++

Routine Description:

    Function called during csr/basesrv.dll initialization which
        creates a critical section we use to guard loading and
        unloading sxs.dll.  We use a critical section rather
        then just relying on the peb loader lock to manage the
        reference count because we want to be able to call a
        one-time initialization function on load and a one-time
        uninitialization function on unload.

Arguments:

Return Value:

    NTSTATUS indicating the disposition of the function.

--*/

{
    NTSTATUS Status;
    
    Status = RtlInitializeCriticalSection(&BaseSrvSxsSystemDefaultActivationContextCriticalSection);
    if (!NT_SUCCESS(Status))
        goto Exit;
#if BASESRV_UNLOAD_SXS_DLL
    Status = RtlInitializeCriticalSection(&BaseSrvSxsCritSec);
    if (!NT_SUCCESS(Status))
        goto Exit;
    ASSERT(SxsDllHandle == NULL);
    ASSERT(SxsActivationContextGenerationFunction == NULL);
    ASSERT(SxsDllHandleRefCount == 0);
#endif
    ASSERT(BaseSrvSxsGetActCtxGenCount == 0);
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
BaseSrvSxsMapViewOfSection(
    OUT PVOID*   Address,
    IN HANDLE    Process,
    IN HANDLE    Section,
    IN ULONGLONG Offset,
    IN SIZE_T    Size,
    IN ULONG     Protect,
    IN ULONG     AllocationType
    )
/*++

Routine Description:

    pare down the NtMapViewOfSection parameter list to the parameters
        that actually ever vary in common use
    allow for unaligned mappings, both in the offset and the size
        the memory manager wants both aligned to 64k
    change the parameters that aren't needed to be inout to only in
        the out-ness of the native parameters doesn't seem useful,
        esp. because the mm will not align your parameters and
        return the aligned values
    deprecate LARGE_INTEGER, use LONGLONG instead

Arguments:

    Subset of NtMapViewOfSection, but can be unaligned

Return Value:

    NTSTATUS

Note:
    It is tempting to pare down the parameter list since many of them
        are always the same: ZeroBits, CommitSize, InheritDisposition, AllocationType.
    It is also tempting to move this to Rtl.
--*/
{
    LARGE_INTEGER LargeIntegerOffset;
    NTSTATUS  Status = STATUS_SUCCESS;
    SIZE_T    OffsetRemainder;
    SIZE_T    SizeRemainder;

#define SIXTY_FOUR_K (1UL << 16)
#define VIEW_OFFSET_ALIGNMENT SIXTY_FOUR_K
#define VIEW_SIZE_ALIGNMENT   SIXTY_FOUR_K

#if DBG
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SRVSXS: %s(\n"
            "SRVSXS:   Process %p\n"
            "SRVSXS:   Section %p\n"
            "SRVSXS:   Offset  0x%I64x\n"
            "SRVSXS:   Size    0x%Ix\n"
            "SRVSXS:   ) beginning\n",
            __FUNCTION__,
            Process,
            Section,
            Offset,
            Size
            );
    }
#endif

    ASSERT(Address != NULL);
    *Address = NULL;

    //
    // round down offset, round up size
    // must round offset first, since rounding it alters size
    //

#if 1 // Mm comments allow this, but the code does not.
    OffsetRemainder = (((SIZE_T)Offset) % VIEW_OFFSET_ALIGNMENT);
    if (OffsetRemainder != 0) {
        Offset -= OffsetRemainder;
        if (Size != 0) {
            Size += OffsetRemainder;
        }
    }
#endif

#if 0 // Mm allows this.
    SizeRemainder = Size % VIEW_SIZE_ALIGNMENT;
    if (SizeRemainder != 0) {
        Size = Size + (VIEW_SIZE_ALIGNMENT - SizeRemainder);
    }
#endif

    LargeIntegerOffset.QuadPart = Offset;

    Status =
        NtMapViewOfSection(
            Section,
            Process,
            Address,
            0, // ZeroBits
            0, // CommitSize
            &LargeIntegerOffset,
            &Size,
            ViewShare, // InheritDisposition
            AllocationType, // AllocationType
            Protect);

    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    *Address = ((PUCHAR)*Address) + OffsetRemainder;

Exit:
    //
    // If the Memory Manager returns STATUS_MAPPED_ALIGNMENT,
    // then we have failed at our task.
    //
    ASSERT(Status != STATUS_MAPPED_ALIGNMENT);
#if DBG
    DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
#endif    
    return Status;
}

NTSTATUS
BaseSrvSxsCreateActivationContextFromStruct(
    HANDLE                                  CsrClientProcess,
    HANDLE                                  SxsClientProcess,
    PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Struct,
    OUT HANDLE*                             OutSection
    )
/*++

Routine Description:

    This function handles the CSR message both for CreateActCtx
        and CreateProcess. Pointers in the "Struct" are trusted (vs.
        pointers in a "message").

Arguments:

    CsrClientProcess - the process that called CreateProcess or CreateActCtx
                       or NtCurrentProcess for creating system default activation context (csr)

    SxsClientProcess - CreateProcess: the new process
                       CreateActCtx: the calling process (csr client process)
                       System default: NtCurrentProcess (csr)

    Struct - the parameters marshaled from the csr client process

    OutSection - for creating the system default context that gets mapped repeatedly

Return Value:

    NTSTATUS

--*/
{
    ASSERT(Struct != NULL);
    if (Struct == NULL) {
        return STATUS_INVALID_PARAMETER;
    }
#define BASE_MSG_SXS_MINIMAL_FLAGS \
    ( BASE_MSG_SXS_MANIFEST_PRESENT \
    | BASE_MSG_SXS_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT \
    | BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT \
    )
    ASSERT(Struct->Flags & BASE_MSG_SXS_MINIMAL_FLAGS);
    if ((Struct->Flags & BASE_MSG_SXS_MINIMAL_FLAGS) == 0) { 
        return STATUS_SUCCESS;
    } else {

    NTSTATUS Status = STATUS_SUCCESS;
    PVOID ViewBase = NULL;
    SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS SxsDllParameters = {0};
    BASE_SRV_SXS_STREAM_UNION_WITH_VTABLE ManifestStream;
    BASE_SRV_SXS_STREAM_UNION_WITH_VTABLE PolicyStream;
    DWORD_PTR Cookie = 0;
    BOOLEAN ReleaseCtxFunction = FALSE;
    PSXS_GENERATE_ACTIVATION_CONTEXT_FUNCTION FunctionPointer = NULL;
    LARGE_INTEGER SectionOffset = {0};
    HRESULT Hr = NOERROR;
    BOOL SxsFunctionSuccess = FALSE;
    NTSTATUS Status1 = STATUS_SUCCESS;
   
#if IMPERSONATE_ENTIRE_SXS_CALL
    BOOLEAN SuccessfulImpersonation = FALSE;
#else
    ACTIVATION_CONTEXT_GENERATION_IMPERSONATION_CONTEXT ImpersonationContext = {0};
#endif
    
#if DBG
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() beginning\n", __FUNCTION__);
    }
#endif
    ASSERT(Struct != NULL);
    ASSERT(Struct != NULL && Struct->Manifest.Path.Buffer != NULL);


    if ( Struct->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) 
    {
        // because these are unions, " = {0}" won't necessarily clear them completely
        RtlZeroMemory(&ManifestStream, sizeof(ManifestStream));
        RtlZeroMemory(&PolicyStream, sizeof(PolicyStream));


        Status = BaseSrvSxsCreateMemoryStream(
            CsrClientProcess,
            &Struct->Manifest,
            &ManifestStream,
            &IID_ISequentialStream,
            (PVOID*)&SxsDllParameters.Manifest.Stream
            );
        IF_NOT_SUCCESS_TRACE_AND_EXIT(BaseSrvSxsCreateMemoryStream(manifest));

        SxsDllParameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_NONE;

        if (Struct->Flags & BASE_MSG_SXS_POLICY_PRESENT) {
            Status = BaseSrvSxsCreateMemoryStream(
                CsrClientProcess,
                &Struct->Policy,
                &PolicyStream,
                &IID_ISequentialStream,
                (PVOID*)&SxsDllParameters.Policy.Stream
                );
            IF_NOT_SUCCESS_TRACE_AND_EXIT(BaseSrvSxsCreateMemoryStream(policy));

            if (Struct->Policy.PathType != BASE_MSG_PATHTYPE_NONE
                && Struct->Policy.Path.Length != 0
                && Struct->Policy.Path.Buffer != NULL
                ) {
                ASSERT_UNICODE_STRING_IS_NUL_TERMINATED(&Struct->Policy.Path);
                SxsDllParameters.Policy.Path = Struct->Policy.Path.Buffer;

                switch (Struct->Policy.PathType) {
                case BASE_MSG_PATHTYPE_FILE:
                    SxsDllParameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;
                    break;
                case BASE_MSG_PATHTYPE_URL:
                    SxsDllParameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_URL;
                    break;
                }
            }
        }
    }
    else // Textual AssemblyIdentity
    {
        SxsDllParameters.Flags |= SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY;
        if ( Struct->Flags & BASE_MSG_SXS_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT)
        {
            SxsDllParameters.Flags |= SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY;
        }

        SxsDllParameters.TextualAssemblyIdentity = Struct->TextualAssemblyIdentity.Buffer;
        ASSERT_UNICODE_STRING_IS_NUL_TERMINATED(&Struct->TextualAssemblyIdentity);        
    }
    
    if ( Struct->Flags & BASE_MSG_SXS_APP_RUNNING_IN_SAFEMODE)    
        SxsDllParameters.Flags |= SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_APP_RUNNING_IN_SAFEMODE;

    SxsDllParameters.ProcessorArchitecture = Struct->ProcessorArchitecture;
    SxsDllParameters.LangId = Struct->LangId;

    SxsDllParameters.AssemblyDirectory = Struct->AssemblyDirectory.Buffer;
    ASSERT_UNICODE_STRING_IS_NUL_TERMINATED(&Struct->AssemblyDirectory);

    Status = BaseSrvSxsGetActivationContextGenerationFunction(&FunctionPointer, &Cookie);
    if (Status == STATUS_DLL_NOT_FOUND) {
        // This happens under stress.
        // We will probably propagate STATUS_NO_MEMORY post beta1 here,
        // if RtlAllocateHeap on a small amount fails.
        // In Blackcomb we will maybe fix RtlSearchPath/LdrLoadDll to propagate
        // accurate status.
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: BaseSrvSxsGetActivationContextGenerationFunction() returned STATUS_DLL_NOT_FOUND, propagating.\n"
            );

        //
        // Old bogus code actually returned a STATUS_SUCCESS when it was a genuine failure.
        // Instead, we should return the actual status that is being generated.  The other
        // option is to return STATUS_NO_MEMORY, the generic "oops" error code.  Our clients
        // do the Smart Thing with an NT_SUCCESS() check, so returning STATUS_DLL_NOT_FOUND
        // is just dandy.  This if block just prints that fact, relying on the following
        // IF_NOT_SUCCESS_TRACE_AND_EXIT to quit out.
        //
    }
    IF_NOT_SUCCESS_TRACE_AND_EXIT(BaseSrvSxsGetActivationContextGenerationFunction);

    // If we fail before we explicitly clean up, release the refcount on the sxs dll
    // in the failure path.
    ReleaseCtxFunction = TRUE;

    if (Struct->Manifest.PathType != BASE_MSG_PATHTYPE_NONE
        && Struct->Manifest.Path.Length != 0
        && Struct->Manifest.Path.Buffer != NULL
        ) {
        ASSERT(Struct->Manifest.Path.Buffer[Struct->Manifest.Path.Length / sizeof(WCHAR)] == 0);
        SxsDllParameters.Manifest.Path = Struct->Manifest.Path.Buffer;
        switch (Struct->Manifest.PathType) {
        case BASE_MSG_PATHTYPE_FILE:
            SxsDllParameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;
            break;
        case BASE_MSG_PATHTYPE_URL:
            SxsDllParameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_URL;
            break;
        }
    }

#if IMPERSONATE_ENTIRE_SXS_CALL
    SuccessfulImpersonation = CsrImpersonateClient(NULL);
    if (!SuccessfulImpersonation) {
        //
        // if we could not impersonate then exit
        //
        // DbgPrintEx(...);
        Status = STATUS_BAD_IMPERSONATION_LEVEL;
        goto Exit;
    }
    SxsDllParameters.ImpersonationCallback = NULL; 
    SxsDllParameters.ImpersonationContext = NULL;
#else
    SxsDllParameters.ImpersonationCallback = BaseSrvpSxsActivationContextGenerationImpersonationCallback;
    SxsDllParameters.ImpersonationContext = &ImpersonationContext;
#endif

    SxsFunctionSuccess = (*FunctionPointer)(&SxsDllParameters);

    if (SxsFunctionSuccess) // succeed but if for system default, we need check the status
    {
        if (Struct->Flags & BASE_MSG_SXS_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT) 
        {
            //
            // For System Default, there are two ignorable cases when ActCtx is failed.
            // case 1: that there is no system defult
            // case 2: The dependency of system default has not been installed. 
            // Status is set to be STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY under this situation which would be ignored 
            // by BaseSrvCreateProcess, xiaoyuw@11/30/2000
            //
            if ((SxsDllParameters.SystemDefaultActCxtGenerationResult & BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_NOT_FOUND)  || 
                (SxsDllParameters.SystemDefaultActCxtGenerationResult & BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_DEPENDENCY_ASSEMBLY_NOT_FOUND))
            {
                Status = STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY; // ActCtx of system default is not generated                
                goto Exit;
            }            
        }

    }

    if (!SxsFunctionSuccess) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_INFO_LEVEL,
            "SXS: Activation Context generation function failed.\n");
        
        Status = STATUS_SXS_CANT_GEN_ACTCTX;

        goto Exit;
    }

    if (SxsDllParameters.SectionObjectHandle != NULL) {
        if (Struct->ActivationContextData != NULL) {            
            // Now let's map the section read-only into the target process...
            Status =
                BaseSrvSxsMapViewOfSection(
                    &ViewBase,
                    SxsClientProcess,
                    SxsDllParameters.SectionObjectHandle,
                    0, // offset
                    0, // size
                    PAGE_READONLY,
                    SEC_NO_CHANGE);
            IF_NOT_SUCCESS_TRACE_AND_EXIT(BaseSrvSxsMapViewOfSection);

            //
            // And now push that duplicated handle into the process's PEB
            //
            // On 64bit we are writing into a 64bit PEB that then is copied
            // into a 32bit PEB if the process is 32bit.
            //
            // Or we are writing into a CreateActCtx local, but again 64bit,
            // and copied back to 32bit for 32bit processes.
            //            
            Status =
                NtWriteVirtualMemory(
                    SxsClientProcess,
                    Struct->ActivationContextData,
                    &ViewBase,
                    sizeof(ViewBase),
                    NULL);
            IF_NOT_SUCCESS_TRACE_AND_EXIT(NtWriteVirtualMemory);
        }
        
        if (OutSection != NULL) {        
            *OutSection = SxsDllParameters.SectionObjectHandle;
            SxsDllParameters.SectionObjectHandle = NULL;
        } else {            
            Status = NtClose(SxsDllParameters.SectionObjectHandle);
            SxsDllParameters.SectionObjectHandle = NULL;
            IF_NOT_SUCCESS_TRACE_AND_EXIT(NtClose);
        }
    }

    Status = BaseSrvSxsReleaseActivationContextGenerationFunction(Cookie);
    ReleaseCtxFunction = FALSE;
    IF_NOT_SUCCESS_TRACE_AND_EXIT(BaseSrvSxsReleaseActivationContextGenerationFunction);

    Status = STATUS_SUCCESS;
    ViewBase = NULL;

Exit:   
    RTL_SOFT_VERIFY(NT_SUCCESS(Status1 = RTL_UNMAP_VIEW_OF_SECTION2(SxsClientProcess, ViewBase)));    
    RTL_SOFT_VERIFY(NT_SUCCESS(Status1 = RTL_CLOSE_HANDLE(SxsDllParameters.SectionObjectHandle)));
    if (ReleaseCtxFunction) {
        Status1 = BaseSrvSxsReleaseActivationContextGenerationFunction(Cookie);
        RTL_SOFT_ASSERT(NT_SUCCESS(Status1));
    }

#if IMPERSONATE_ENTIRE_SXS_CALL
    if (SuccessfulImpersonation) {
        CsrRevertToSelf();
    }
#endif

    if ( Struct->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) 
    {
        RTL_RELEASE(SxsDllParameters.Manifest.Stream);
        RTL_RELEASE(SxsDllParameters.Policy.Stream);
#if DBG
        if (ManifestStream.Mmap.MemStream.Data.ReferenceCount != 0) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SRVSXS: ManifestStream.Mmap.MemStream.Data.ReferenceCount: %ld\n",
                ManifestStream.Mmap.MemStream.Data.ReferenceCount);
        }
        if (PolicyStream.Mmap.MemStream.Data.ReferenceCount != 0) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SRVSXS: PolicyStream.Mmap.MemStream.Data.ReferenceCount: %ld\n",
                PolicyStream.Mmap.MemStream.Data.ReferenceCount );
        }
        ASSERT(ManifestStream.Mmap.MemStream.Data.ReferenceCount == 0
            && PolicyStream.Mmap.MemStream.Data.ReferenceCount == 0);
#endif
    }


#if DBG
    DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
#endif

    return Status;
}}

NTSTATUS
BaseSrvSxsValidateMessageStrings(
    IN CONST CSR_API_MSG* Message,
    IN ULONG NumberOfStrings,
    IN CONST PCUNICODE_STRING* Strings
    )
{
    ULONG i = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    for (i = 0 ; i != NumberOfStrings ; ++i) {
        if (Strings[i] != NULL && Strings[i]->Buffer != NULL) {
            if (!CsrValidateMessageBuffer(
                Message,
                &Strings[i]->Buffer,
                Strings[i]->Length + sizeof(WCHAR),
                sizeof(BYTE))) {

                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: Validation of message buffer 0x%lx failed.\n"
                    " Message:%p\n"
                    " String %p{Length:0x%x, MaximumLength:0x%x, Buffer:%p}\n",
                    i,
                    Message,
                    Strings[i],
                    Strings[i]->Length,
                    Strings[i]->MaximumLength,
                    Strings[i]->Buffer
                    );

                Status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }
        }
    }
    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
#endif    
    return Status;
}

ULONG
BaseSrvSxsCreateActivationContextFromMessage(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
/*++

Routine Description:

    This function handles the CSR message requesting that an activation
    context be created.

    It loads sxs.dll if it is not loaded, calls the sxs.dll api to
    create an activation context, maps the activation context into the
    client API and sets the address of the created activation context
    into the client's address space.

Arguments:

    m - the message sent to csr from the win32 client

    ReplyStatus - an indicator of the status of the reply

Return Value:

    ULONG return value to the win32 client; in this case we return
    the NTSTATUS disposition of the function's execution.

--*/
{
    PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Message =
        (PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG) &m->u.ApiMessageData;

    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE CsrClientProcess = NULL;
    PCUNICODE_STRING StringsInMessageToValidate[4];
    ULONG i = 0;
#if DBG
    BOOLEAN StringsOk = FALSE;
#endif

#if DBG
    DebugFilter_SxsTrace = (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL) == TRUE);
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() beginning\n", __FUNCTION__);
    }
#endif

    StringsInMessageToValidate[0] = &Message->Manifest.Path;
    StringsInMessageToValidate[1] = &Message->Policy.Path;
    StringsInMessageToValidate[2] = &Message->AssemblyDirectory;
    StringsInMessageToValidate[3] = &Message->TextualAssemblyIdentity;
    Status = BaseSrvSxsValidateMessageStrings(m, RTL_NUMBER_OF(StringsInMessageToValidate), StringsInMessageToValidate);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

#if DBG
    StringsOk = TRUE;
#endif

#if DBG
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: %s() Manifest=%wZ; Policy=%wZ; TextualAssemblyIdentity=%wZ\n",
            __FUNCTION__,
            &Message->Manifest.Path,
            &Message->Policy.Path,
            &Message->TextualAssemblyIdentity
            );
    }
#endif

    CsrClientProcess = CSR_SERVER_QUERYCLIENTTHREAD()->Process->ProcessHandle;

    Status = BaseSrvSxsCreateActivationContextFromStruct(CsrClientProcess, CsrClientProcess, Message, NULL);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
    if (StringsOk && DPFLTR_LEVEL_STATUS(Status) == DPFLTR_ERROR_LEVEL) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() Manifest=%wZ; Policy=%wZ; TextualAssemblyIdentity=%wZ\n",
            __FUNCTION__,
            &Message->Manifest.Path,
            &Message->Policy.Path,
            &Message->TextualAssemblyIdentity
            );
    }
#endif
    return Status;
}

ULONG
BaseSrvSxsCreateActivationContext(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    return BaseSrvSxsCreateActivationContextFromMessage(m, ReplyStatus);
}

NTSTATUS
BaseSrvSxsGetActivationContextGenerationFunction(
    PSXS_GENERATE_ACTIVATION_CONTEXT_FUNCTION* FunctionPointer,
    PDWORD_PTR Cookie
    )
/*++

Routine Description:

    This function loads sxs.dll if it is not loaded and returns a pointer
    to the function to call to generate an activation context.

Arguments:

    FunctionPointer - pointer to activation context generation function pointer
        returned.

    Cookie - returned DWORD_PTR value which must later be passed in
        to BaseSrvSxsReleaseActivationContextGenerationFunction() to
        lower the refcount on sxs.dll.

Return Value:

    NTSTATUS indicating the disposition of the function's execution.

--*/

{
    static STRING SxsProcedureName = RTL_CONSTANT_STRING( "SxsGenerateActivationContext" );
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN FreeDll = FALSE;
    DWORD_PTR NewCookie = 0;
    NTSTATUS Status1 = STATUS_SUCCESS;
#if BASESRV_UNLOAD_SXS_DLL
    BOOLEAN CritSecLocked = FALSE;
#else
    PVOID SxsDllHandle = NULL;
#endif

#if BASESRV_UNLOAD_SXS_DLL
    __try
#endif
    {
#if DBG
        if (DebugFilter_SxsTrace) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() beginning\n",  __FUNCTION__);
        }
#endif

        if (!(ARGUMENT_PRESENT(FunctionPointer) && ARGUMENT_PRESENT(Cookie))) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

#if BASESRV_UNLOAD_SXS_DLL
        //
        //  It's tempting to want to optimize away locking the critical section
        //  when looking at the pointer, because we know if it's not NULL, we can
        //  just use it, but we're keeping a reference count on the SXS.DLL
        //  so that we can unload it, so to avoid this race, we need to lock the
        //  critical section.
        //

        Status = RtlEnterCriticalSection(&BaseSrvSxsCritSec);
        if (!NT_SUCCESS(Status))
            goto Exit;

        CritSecLocked = TRUE;
#endif
        if (SxsActivationContextGenerationFunction == NULL) {

            Status = LdrLoadDll(
                        NULL,
                        NULL,
                        &BaseSrvSxsDllPath,
                        &SxsDllHandle);
            if (!NT_SUCCESS(Status)) {

                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_LEVEL_STATUS(Status),
                    "SXS: %s: LdrLoadDll(%wZ) failed 0x%08lx\n",
                    __FUNCTION__,
                    &BaseSrvSxsDllPath,
                    Status
                    );

                if (Status == STATUS_DLL_NOT_FOUND) {
                    PVOID p = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(L"c:\\windows\\system32\\sxs.dll"));
                    RtlFreeHeap(RtlProcessHeap(), 0, p);
                    if (p == NULL) {
                        DbgPrintEx(
                            DPFLTR_SXS_ID,
                            DPFLTR_LEVEL_STATUS(Status),
                            "SXS: %s: LdrLoadDll(%wZ) actually probably out of memory in RtlSearchPath (RtlAllocateHeap failure)\n",
                            __FUNCTION__,
                            &BaseSrvSxsDllPath
                            );
                    }
                }

                goto Exit;
            }

            FreeDll = TRUE;

            Status = LdrGetProcedureAddress(SxsDllHandle, &SxsProcedureName, 0, (PVOID *) &SxsActivationContextGenerationFunction);
            if (!NT_SUCCESS(Status)) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_LEVEL_STATUS(Status),
                    "SXS: %s: LdrGetProcedureAddress(%wZ:%Z) failed 0x%08lx\n",
                    __FUNCTION__,
                    &BaseSrvSxsDllPath,
                    &SxsProcedureName,
                    Status
                    );
                goto Exit;
            }

            FreeDll = FALSE;
        }

        NewCookie = BaseSrvSxsGetActCtxGenCount++;
#if BASESRV_UNLOAD_SXS_DLL
        SxsDllHandleRefCount++;
        RtlLeaveCriticalSection(&BaseSrvSxsCritSec);
        CritSecLocked = FALSE;
#endif

        *FunctionPointer = SxsActivationContextGenerationFunction;
        *Cookie = NewCookie;

        Status = STATUS_SUCCESS;
Exit:
        if (FreeDll) {
#if BASESRV_UNLOAD_SXS_DLL
            ASSERT(CritSecLocked);
            ASSERT(SxsDllHandle != NULL);
            ASSERT(SxsActivationContextGenerationFunction == NULL);
#endif
            SxsActivationContextGenerationFunction = NULL;
            Status1 = LdrUnloadDll(SxsDllHandle);
            RTL_SOFT_ASSERT(NT_SUCCESS(Status1));
            SxsDllHandle = NULL;
        }
#if DBG
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
#endif
    }
#if BASESRV_UNLOAD_SXS_DLL
    __finally
    {
        if (CritSecLocked)
            RtlLeaveCriticalSection(&BaseSrvSxsCritSec);
    }
#endif
    return Status;
}

NTSTATUS
BaseSrvSxsReleaseActivationContextGenerationFunction(
    DWORD_PTR Cookie
    )
/*++

Routine Description:

    This function decrements the reference count on sxs.dll and unloads it
    if the reference count is zero.

Arguments:

    Cookie - value returned by BaseSrvSxsGetActivationContextGenerationFunction

Return Value:

    NTSTATUS indicating the disposition of the function's execution.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
#if BASESRV_UNLOAD_SXS_DLL
    BOOLEAN CritSecLocked = FALSE;

    __try {
#if DBG
        if (DebugFilter_SxsTrace) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() beginning\n",  __FUNCTION__);
        }
#endif

        (Cookie);  // maybe someday we'll actively track this in debug builds...

        Status = RtlEnterCriticalSection(&BaseSrvSxsCritSec);
        if (!NT_SUCCESS(Status))
            goto Exit;

        CritSecLocked = TRUE;

        // We shouldn't have gotten here if the DLL wasn't loaded - someone either
        // released more than once or called release without having called
        // get previously.
        ASSERT(SxsDllHandle != NULL);
        ASSERT(SxsDllHandleRefCount != 0);

        --SxsDllHandleRefCount;

        if (SxsDllHandleRefCount == 0) {
#if DBG
            Status = LdrUnloadDll(SxsDllHandle);
            SxsDllHandle = NULL;
            SxsActivationContextGenerationFunction = NULL;
            if (!NT_SUCCESS(Status))
                goto Exit;
#endif // DBG
        }

        RtlLeaveCriticalSection(&BaseSrvSxsCritSec);
        CritSecLocked = FALSE;

        Status = STATUS_SUCCESS;
Exit:
#if DBG
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
#endif
    } __finally {
        if (CritSecLocked)
            RtlLeaveCriticalSection(&BaseSrvSxsCritSec);
    }
#endif // BASESRV_UNLOAD_SXS_DLL
    return Status;
}

NTSTATUS
BaseSrvSxsDuplicateObject(
    HANDLE  FromProcess,
    HANDLE  FromHandle,
    HANDLE* ToHandle
    )
/*++

Routine Description:

    Shrink the parameter list of NtDuplicateObject to a smaller common case.

Arguments:

    FromProcess -
    FromHandle -
    ToHandle -

Return Value:

    NTSTATUS from NtDuplicateObject

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status =
        NtDuplicateObject(
            FromProcess,
            FromHandle,
            NtCurrentProcess(),
            ToHandle,
            0,
            0,
            DUPLICATE_SAME_ACCESS
            );

    return Status;
}

NTSTATUS
BaseSrvSxsCreateMemoryStream(
    HANDLE                                     CsrClientProcess,
    IN PCBASE_MSG_SXS_STREAM                   MsgStream,
    OUT PBASE_SRV_SXS_STREAM_UNION_WITH_VTABLE StreamUnion,
    IN const IID*                              IIDStream,
    OUT PVOID*                                 OutIStream
    )
/*++

Routine Description:

    Based on MsgStream->HandleType, this initializes the correct
        union member of StreamUnion and returns an IStream* to it.

Arguments:

    CsrClientProcess - the process MsgStream->Handle is valid in,
        and the value of the handle if MsgStream->HandleType == BASE_MSG_HANDLETYPE_CLIENT_PROCESS

    MsgStream - a description of an IStream that is easily remoted across to csrss.exe

    StreamUnion - a union of all our IStream implementations

    OutIStream - resulting IStream*

Return Value:

    NTSTATUS indicating the disposition of the function.

Note:
    All the handles in MsgStream are valid in CsrClientProcess.
    Therefore, we don't close them. We duplicate them, and close the duplicates.
--*/
{
    HANDLE    Handle = NULL;
    HANDLE    FileHandle = NULL;
    NTSTATUS  Status = STATUS_SUCCESS;
    HRESULT   Hr = NOERROR;
    PVOID     ViewBase = NULL;
    NTSTATUS  Status1 = STATUS_SUCCESS;
    ULONG     i = 0;

#if DBG
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SRVSXS: %s() beginning\n",  __FUNCTION__);
    }
#endif

    ASSERT(CsrClientProcess != NULL);
    ASSERT(MsgStream != NULL);
    ASSERT(StreamUnion != NULL);
    ASSERT(IIDStream != NULL);
    ASSERT(OutIStream != NULL);

    // If the manifest is actually just a VA region in the client process, dup the client process
    // handle from our own address space to our own address space; otherwise, it's a handle
    // in the client address space so we need to dup it from the client space to ours.
    if (MsgStream->HandleType == BASE_MSG_HANDLETYPE_CLIENT_PROCESS) {
        Status = BaseSrvSxsDuplicateObject(NtCurrentProcess(), CsrClientProcess, &Handle);
    } else {
        Status = BaseSrvSxsDuplicateObject(CsrClientProcess, MsgStream->Handle, &Handle);
    }
    if (!NT_SUCCESS(Status)) {
        Handle = NULL;
#if DBG
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SRVSXS: %s(): NtDuplicateObject failed; Status = %08lx\n", __FUNCTION__, Status);
#if 1 /* temporary */
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SRVSXS: MsgStream->HandleType 0x%lx\n", MsgStream->HandleType);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SRVSXS: BASE_MSG_HANDLETYPE_CLIENT_PROCESS 0x%lx\n", BASE_MSG_HANDLETYPE_CLIENT_PROCESS);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SRVSXS: CsrClientProcess %p\n", CsrClientProcess);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SRVSXS: MsgStream->Handle %p\n", MsgStream->Handle);
#endif
#endif
        goto Exit;
    }
    if (MsgStream->FileHandle != NULL) {
        Status = BaseSrvSxsDuplicateObject(CsrClientProcess, MsgStream->FileHandle, &FileHandle);
        if (!NT_SUCCESS(Status)) {
#if DBG
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SRVSXS: %s(): NtDuplicateObject(FileHandle) failed.\n", __FUNCTION__);
#endif
            goto Exit;
        }
    }
    switch (MsgStream->HandleType) {
        default:
            ASSERTMSG("Bad HandleType", FALSE);
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        case BASE_MSG_HANDLETYPE_CLIENT_PROCESS:
        case BASE_MSG_HANDLETYPE_PROCESS:
            // This is the app-compat case.
            //
            // REVIEW: if Offset happens to be in a section in the process
            // (you can find out with NtQuerySection(SectionBasicInformation)),
            // we should instead map it. That would be more efficient.
            //
            // That logic could just as well be in kernel32 though, and for
            // the sake of minimizing csr code and time, that's where we'd do it.
            //
            RtlInitOutOfProcessMemoryStream(&StreamUnion->OutOfProcess);
            StreamUnion->OutOfProcess.Data.Process = Handle;
            Handle = NULL; // the stream owns it now
            StreamUnion->OutOfProcess.Data.Begin   = (PUCHAR)MsgStream->Offset;
            StreamUnion->OutOfProcess.Data.Current = StreamUnion->OutOfProcess.Data.Begin;
            StreamUnion->OutOfProcess.Data.End     = StreamUnion->OutOfProcess.Data.Begin + MsgStream->Size;
            break;

        case BASE_MSG_HANDLETYPE_SECTION: {
            Status =
                BaseSrvSxsMapViewOfSection(
                    &ViewBase,
                    NtCurrentProcess(),
                    Handle,
                    MsgStream->Offset,
                    MsgStream->Size,
                    PAGE_READONLY,
                    SEC_NO_CHANGE
                    );
            if (!NT_SUCCESS(Status)) {
                goto Exit;
            }
            BaseSrvInitMemoryMappedStream(&StreamUnion->Mmap);
            StreamUnion->Mmap.MemStream.Data.Begin = (PUCHAR)ViewBase;
            ViewBase = NULL; // the stream owns it now
            StreamUnion->Mmap.MemStream.Data.Current = StreamUnion->Mmap.MemStream.Data.Begin;
            StreamUnion->Mmap.MemStream.Data.End = StreamUnion->Mmap.MemStream.Data.Begin + MsgStream->Size;
            StreamUnion->Mmap.FileHandle = FileHandle;
            FileHandle = NULL; // the stream owns it now
            break;
        }
    }
    // it does not matter here which member of the union we use, we are only using
    // members of the members that are at the same offset
    Hr = StreamUnion->Mmap.MemStream.StreamVTable->QueryInterface(
            (IStream*)&StreamUnion->Mmap.MemStream,
            IIDStream,
            OutIStream);
    ASSERT(SUCCEEDED(Hr));

    Status = STATUS_SUCCESS;
Exit:
    RTL_SOFT_VERIFY(NT_SUCCESS(RTL_CLOSE_HANDLE(FileHandle)));
    RTL_SOFT_VERIFY(NT_SUCCESS(RTL_CLOSE_HANDLE(Handle)));
    RTL_SOFT_VERIFY(NT_SUCCESS(RTL_UNMAP_VIEW_OF_SECTION1(ViewBase)));
#if DBG
    DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
#endif
    return Status;
}

NTSTATUS
BaseSrvSxsCreateProcess(
    HANDLE CsrClientProcess,
    HANDLE NewProcess,
    IN OUT PCSR_API_MSG CsrMessage,
    PPEB   NewProcessPeb
    )
/*++

Routine Description:

    Runs during kernel32.dll::CreateProcessW's calls to csrss.exe.
    Munges the csr message into something more Win32-ish (IStreams) and calls into sxs.dll to
    create the processes default activation context.

    Munges the create process message to look like a CreateActCtx message, which isn't much work,
    and then delegates to code common with CreateActCtx.

Arguments:

    Process - the csr client process, the "old" process, the "parent" process that called
        CreateProcess

    Message - a bunch of parameters

Return Value:

    NTSTATUS indicating the disposition of the function.

--*/
{
    PROCESS_BASIC_INFORMATION ProcessBasicInfo;
    BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Struct = {0};
    PCUNICODE_STRING StringsInMessageToValidate[3];
    NTSTATUS Status = STATUS_SUCCESS;
    PBASE_CREATEPROCESS_MSG CreateProcessMessage = (PBASE_CREATEPROCESS_MSG)&CsrMessage->u.ApiMessageData;
    PBASE_SXS_CREATEPROCESS_MSG SxsMessage = &CreateProcessMessage->Sxs;

    ASSERT(CsrMessage != NULL);

    if ((SxsMessage->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) == 0) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

#if DBG
    DebugFilter_SxsTrace = (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL) == TRUE);

    if (DebugFilter_SxsTrace) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() beginning\n", __FUNCTION__);
    }
#endif

    StringsInMessageToValidate[0] = &SxsMessage->Manifest.Path;
    StringsInMessageToValidate[1] = &SxsMessage->Policy.Path;
    StringsInMessageToValidate[2] = &SxsMessage->AssemblyDirectory;
    Status = BaseSrvSxsValidateMessageStrings(CsrMessage, RTL_NUMBER_OF(StringsInMessageToValidate), StringsInMessageToValidate);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

#if DBG
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: %s() Manifest=%wZ; Policy=%wZ, AssemblyDirectory=%wZ\n",
            __FUNCTION__,
            &SxsMessage->Manifest.Path,
            &SxsMessage->Policy.Path,
            &SxsMessage->AssemblyDirectory
            );
    }
#endif

    if (CsrImpersonateClient(NULL)) {
        __try {
            Status = NtQueryDefaultUILanguage(&Struct.LangId);
        } __finally {
            CsrRevertToSelf();
        }
    } else {
        Status = NtQueryInstallUILanguage(&Struct.LangId);
    }

    if (!NT_SUCCESS(Status))
        goto Exit;

    Struct.Flags = SxsMessage->Flags;    
    Struct.Manifest = SxsMessage->Manifest;
    Struct.Policy = SxsMessage->Policy;
    Struct.AssemblyDirectory = SxsMessage->AssemblyDirectory;
    Struct.ActivationContextData = (PVOID)&NewProcessPeb->ActivationContextData;
    Struct.ProcessorArchitecture = CreateProcessMessage->ProcessorArchitecture;

    Status = BaseSrvSxsCreateActivationContextFromStruct(CsrClientProcess, NewProcess, &Struct, NULL);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
#endif
    return Status;
}

NTSTATUS
BaseSrvSxsGetCachedSystemDefaultActivationContext(
    IN USHORT ProcessorArchitecture,
    OUT PBASE_SRV_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT *SystemDefaultActivationContext
    )
/*++
if (SystemDefaultActivationContext != NULL)
then the caller must take the BaseSrvSxsSystemDefaultActivationContextCriticalSection.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;

    for (i = 0 ; i != RTL_NUMBER_OF(SxsSystemDefaultActivationContexts) ; ++i) {
        if (SxsSystemDefaultActivationContexts[i].ProcessorArchitecture == ProcessorArchitecture) {
            *SystemDefaultActivationContext = &SxsSystemDefaultActivationContexts[i];
            break;
        }
    }

    if (*SystemDefaultActivationContext == NULL) {
        ASSERTMSG("Unknown Processor Architecture", FALSE);
        Status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


NTSTATUS
BaseSrvSxsDoSystemDefaultActivationContext(
    USHORT              ProcessorArchitecture,
    HANDLE              NewProcess,
    PPEB                NewPeb    
    )
/*++

Routine Description:

    Runs during kernel32.dll::CreateProcessW's calls to csrss.exe.
    FOR ALL PROCESSES (except the special first few, system, idle, smss, csrss),
    on demand create the default activation context, and write it into
    the new process's peb.

    Within this function, the textual-assembly-identity string for System Default is created 
    and passed to BaseSrvSxsCreateActivationContextFromStruct, which would pass this string to 
    SXS.dll, where manifest file would be located using this textual-string. 
    
Arguments:

    LangID - user's ui language for the new process
    ProcessorArchitecture - the ProcessorArchitecture for the new process
    NewProcess -
    NewPeb -

Return Value:

    NTSTATUS indicating the disposition of the function.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE ActivationContextSection = NULL;
    PBASE_SRV_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT SystemDefaultActivationContext = NULL;

    LANGID LangId = 0;
    BOOLEAN RevertToSelfNeeded = FALSE;
    BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Struct = {0};
    RTL_UNICODE_STRING_BUFFER SystemDefaultAssemblyDirectoryBuffer = {0};
    // The size of the following buffer is only heuristic, we will grow via the heap if necessary.
    UCHAR SystemDefaultAssemblyDirectoryStaticBuffer[sizeof(L"c:\\windows8.123\\winsxs")];
    UNICODE_STRING SystemRoot;
    USHORT AssemblyDirectoryLength = 0;
    const UNICODE_STRING SystemDefaultContextString = RTL_CONSTANT_STRING(L"System Default Context");    
    RTL_UNICODE_STRING_BUFFER SystemDefaultTextualAssemblyIdentityBuffer = {0};
    UCHAR SystemDefaultTextualAssemblyIdentityStaticBuffer[
         sizeof(LSYSTEM_COMPATIBLE_ASSEMBLY_NAME L",version=\"65535.65535.65535.65535\",type=\"win32\",publicKeyToken=\"6595b64144ccf1df\",processorArchitecture=\"alpha\"...padding...")
         ];
    PVOID ViewBase = NULL;
    BOOLEAN Locked = FALSE;

    __try
    {
        Status = BaseSrvSxsGetCachedSystemDefaultActivationContext(ProcessorArchitecture, &SystemDefaultActivationContext);
        if (!NT_SUCCESS(Status) && SystemDefaultActivationContext == NULL) {
            goto Exit;
        }
        //
        // Enter the critical section to read the Section member data.
        //
        RtlEnterCriticalSection(&BaseSrvSxsSystemDefaultActivationContextCriticalSection);
        Locked = TRUE;
        if (SystemDefaultActivationContext->Section != NULL) {
            goto GotActivationContext;
        }

        //
        // Leave the critical section a while, in order to reduce stress failure.
        //
        RtlLeaveCriticalSection(&BaseSrvSxsSystemDefaultActivationContextCriticalSection);
        Locked = FALSE;

        if (CsrImpersonateClient(NULL)) {
            __try {
                Status = NtQueryDefaultUILanguage(&LangId);
            } __finally {
                CsrRevertToSelf();
            }
        } else {
            Status = NtQueryInstallUILanguage(&LangId);
        }

        if (!NT_SUCCESS(Status)) {
#if DBG
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SRVSXS: %s(): NtQueryDefaultUILanguage failed; status = 0x%08lx.\n", __FUNCTION__, Status);
#endif
            goto Exit;
        }

        RtlInitUnicodeStringBuffer(&SystemDefaultAssemblyDirectoryBuffer, SystemDefaultAssemblyDirectoryStaticBuffer, sizeof(SystemDefaultAssemblyDirectoryStaticBuffer));
        SystemRoot = BaseSrvWindowsDirectory;
        RtlRemoveTrailingPathSeperators(0, &SystemRoot);

        {
#define X(x) { (x).Length, (x).MaximumLength, (x).Buffer }
            /*static*/ const UNICODE_STRING Strings1[] =
            {
                    X(SystemRoot),
                    RTL_CONSTANT_STRING(L"\\WinSxs")                    
            };
#undef X
            Status = RtlMultiAppendUnicodeStringBuffer(&SystemDefaultAssemblyDirectoryBuffer, RTL_NUMBER_OF(Strings1), Strings1);
            IF_NOT_SUCCESS_TRACE_AND_EXIT(RtlMultiAppendUnicodeStringBuffer#1);

            AssemblyDirectoryLength = SystemDefaultAssemblyDirectoryBuffer.String.Length; // AssemblyDirectory = "x:\winnt\winsxs\manifests"
        }

        RtlInitUnicodeStringBuffer(&SystemDefaultTextualAssemblyIdentityBuffer, 
            SystemDefaultTextualAssemblyIdentityStaticBuffer, sizeof(SystemDefaultTextualAssemblyIdentityStaticBuffer));
        {
#define X(x) { (x).Length, (x).MaximumLength, (x).Buffer }
                /*static*/ const UNICODE_STRING Strings1[] =
                {
                        RTL_CONSTANT_STRING(
                            LSYSTEM_COMPATIBLE_ASSEMBLY_NAME
                            L",version=\""
                            SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION_STRING_W 
                            L"\",type=\"win32\",publicKeyToken=\"6595b64144ccf1df\",processorArchitecture=\""
                            ),
                        X(SystemDefaultActivationContext->ProcessorArchitectureString),
                        RTL_CONSTANT_STRING(L"\"")
                };
#undef X

            Status = RtlMultiAppendUnicodeStringBuffer(&SystemDefaultTextualAssemblyIdentityBuffer, RTL_NUMBER_OF(Strings1), Strings1);
            IF_NOT_SUCCESS_TRACE_AND_EXIT(RtlMultiAppendUnicodeStringBuffer#3);
            ASSERT_UNICODE_STRING_IS_NUL_TERMINATED(&SystemDefaultTextualAssemblyIdentityBuffer.String);
        }

        Struct.Flags = BASE_MSG_SXS_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT;
        Struct.Flags |= BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT;
        Struct.TextualAssemblyIdentity.Buffer =  SystemDefaultTextualAssemblyIdentityBuffer.String.Buffer;
        Struct.TextualAssemblyIdentity.Length =  SystemDefaultTextualAssemblyIdentityBuffer.String.Length;
        Struct.TextualAssemblyIdentity.MaximumLength =  SystemDefaultTextualAssemblyIdentityBuffer.String.MaximumLength;
        Struct.AssemblyDirectory = SystemDefaultAssemblyDirectoryBuffer.String;
        Struct.AssemblyDirectory.Length = AssemblyDirectoryLength;
        Struct.AssemblyDirectory.Buffer[Struct.AssemblyDirectory.Length / sizeof(WCHAR)] = 0;
        Struct.Manifest.PathType = BASE_MSG_PATHTYPE_FILE;
        Struct.Manifest.Path = SystemDefaultContextString;
        Struct.LangId = LangId;
        Struct.ProcessorArchitecture = ProcessorArchitecture;


        // 
        // BaseSrvSxsCreateActivationContextFromStruct would return STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY 
        // if the failure from ActCtx generation is ignorable.       
        //
        Status =
            BaseSrvSxsCreateActivationContextFromStruct(
                NtCurrentProcess(),
                NtCurrentProcess(),
                &Struct,
                &ActivationContextSection
                );
        IF_NOT_SUCCESS_TRACE_AND_EXIT(BaseSrvSxsCreateActivationContextFromStruct);

        RtlEnterCriticalSection(&BaseSrvSxsSystemDefaultActivationContextCriticalSection);
        Locked = TRUE;
        if (SystemDefaultActivationContext->Section == NULL) {
            SystemDefaultActivationContext->Section = ActivationContextSection;
        } else {
            NtClose(ActivationContextSection);
        }
        ActivationContextSection = NULL;
GotActivationContext:
        //
        // Hold the critical section until we
        // finish with SystemDefaultActivationContext->Section.
        //
        ASSERT(ActivationContextSection == NULL);
        ASSERT(SystemDefaultActivationContext != NULL
            && SystemDefaultActivationContext->Section != NULL);
        ASSERT(Locked);
        Status =
            BaseSrvSxsMapViewOfSection(
                &ViewBase,
                NewProcess,
                SystemDefaultActivationContext->Section,
                0, // offset
                0, // size
                PAGE_READONLY,
                SEC_NO_CHANGE);
        RtlLeaveCriticalSection(&BaseSrvSxsSystemDefaultActivationContextCriticalSection);
        Locked = FALSE;
        IF_NOT_SUCCESS_TRACE_AND_EXIT(BaseSrvSxsMapViewOfSection);

        Status =
            NtWriteVirtualMemory(
                NewProcess,
                (PVOID)&NewPeb->SystemDefaultActivationContextData,
                &ViewBase,
                (ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA32_ON_WIN64) ? sizeof(ULONG) : sizeof(ViewBase),
                NULL);
        IF_NOT_SUCCESS_TRACE_AND_EXIT(NtWriteVirtualMemory);

        Status = STATUS_SUCCESS;
        ViewBase = NULL;
Exit:
        ;
    } __finally {
        //
        // do the critical section first because
        // 1) it doesn't guard any of the others, they are all local
        // 2) to keep the critical section held shorter
        // 3) in case we exception out from any of the others
        //
        if (Locked) {
            RtlLeaveCriticalSection(&BaseSrvSxsSystemDefaultActivationContextCriticalSection);
            Locked = FALSE;
        }
        RtlFreeUnicodeStringBuffer(&SystemDefaultAssemblyDirectoryBuffer);
        RtlFreeUnicodeStringBuffer(&SystemDefaultTextualAssemblyIdentityBuffer);
        if (AbnormalTermination()) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "Abnormal termination in " __FUNCTION__ ".\n");
        }
        RTL_UNMAP_VIEW_OF_SECTION2(NewProcess, ViewBase);
        
        if (RevertToSelfNeeded) {
            CsrRevertToSelf();                              // This unstacks client contexts
        }
    }
#if DBG

    DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
#endif
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\server\srvvdm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvvdm.c

Abstract:

    This module implements windows server functions for VDMs

Author:

    Sudeep Bharati (sudeepb) 03-Sep-1991

Revision History:

    Sudeepb 18-Sep-1992
    Added code to make VDM termination and resource cleanup robust.
    AndyH   23-May-1994
    Added Code to allow the Shared WOW to run if client is Interactive or SYSTEM
    impersonating Interactive.
    VadimB  Sep-Dec 1996
    Added code to allow for multiple default wows. Dispatching to an appropriate wow
    is based upon the desktop name. It is still not possible to have multiple shared
    wows on the same desktop (although technically trivial to implement) -- which would
    be the level of OS/2 functionality

--*/

#include "basesrv.h"
#include "vdm.h"
#include "vdmdbg.h"

/*
 * VadimB: Work to allow for multiple ntvdms
 *    - Add linked list of hwndWowExec's
 *    - The list should contain dwWowExecThreadId
 *    - dwWowExecProcessId
 *    - dwWowExecProcessSequenceNumber
 *
 * List is not completely dynamic - the first entry is static
 * as the case with 1 shared vdm would be the most common one
 *
 */


// record that reflects winstas with corresponding downlinks for desktops
// there could be only one wowexec per desktop (the default one, I mean)
// there could be many desktops per winsta as well as multiple winstas
//
// We have made a decision to simplify handling of wow vdms by introducing
// a single-level list of wowexecs [as opposed to 2-level so searching for the particular
// winsta would have been improved greatly]. The reason is purely practical: we do not
// anticipate having a large number of desktops/winsta


BOOL fIsFirstVDM = TRUE;
PCONSOLERECORD DOSHead = NULL;      // Head Of DOS tasks with a valid Console
PBATRECORD     BatRecordHead = NULL;

RTL_CRITICAL_SECTION BaseSrvDOSCriticalSection;
RTL_CRITICAL_SECTION BaseSrvWOWCriticalSection;

ULONG WOWTaskIdNext = WOWMINID; // This is global for all the wows in the system


typedef struct tagSharedWOWHead {
   PSHAREDWOWRECORD pSharedWowRecord; // points to the list of shared wows

   // other wow-related information is stored here

}  SHAREDWOWRECORDHEAD, *PSHAREDWOWRECORDHEAD;

SHAREDWOWRECORDHEAD gWowHead;


////////////////////////////////////////////////////////////////////////////////////////
//
//  Synch macros and functions
//
//  DOSCriticalSection -- protects CONSOLERECORD list    (DOSHead)
//  WOWCriticalSection -- protects SHAREDWOWRECORD list  (gpSharedWowRecordHead)
//  each shared wow has it's very own critical section


// function to access console queue for modification


/////////////////////////////////////////////////////////////////////////////////////////
//
// Macros
//
//


// use these macros when manipulating shared wow items (adding, removing) or console
// records (adding, removing)

#define ENTER_WOW_CRITICAL() \
RtlEnterCriticalSection(&BaseSrvWOWCriticalSection)


#define LEAVE_WOW_CRITICAL() \
RtlLeaveCriticalSection(&BaseSrvWOWCriticalSection)


/////////////////////////////////////////////////////////////////////////////////////////
//
// Dynamic linking to system and import api stuff
//
//


typedef BOOL (WINAPI *POSTMESSAGEPROC)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
POSTMESSAGEPROC BaseSrvPostMessageA;

typedef BOOL (WINAPI *GETWINDOWTHREADPROCESSIDPROC)(HWND hWnd, LPDWORD lpdwProcessId);
GETWINDOWTHREADPROCESSIDPROC BaseSrvGetWindowThreadProcessId;

typedef NTSTATUS (*USERTESTTOKENFORINTERACTIVE)(HANDLE Token, PLUID pluidCaller);
USERTESTTOKENFORINTERACTIVE UserTestTokenForInteractive = NULL;

typedef NTSTATUS (*USERRESOLVEDESKTOPFORWOW)(PUNICODE_STRING);
USERRESOLVEDESKTOPFORWOW BaseSrvUserResolveDesktopForWow = NULL;



typedef struct tagBaseSrvApiImportRecord {
   PCHAR  pszProcedureName;
   PVOID  *ppProcAddress;
}  BASESRVAPIIMPORTRECORD, *PBASESRVAPIIMPORTRECORD;

typedef struct tagBaseSrvModuleImportRecord {
   PWCHAR pwszModuleName;
   PBASESRVAPIIMPORTRECORD pApiImportRecord;
   UINT nApiImportRecordCount;
   HANDLE ModuleHandle;
}  BASESRVMODULEIMPORTRECORD, *PBASESRVMODULEIMPORTRECORD;


// prototypes

NTSTATUS
BaseSrvFindSharedWowRecordByDesktop(
   PSHAREDWOWRECORDHEAD pSharedWowRecordHead,
   PUNICODE_STRING      pDesktopName,
   PSHAREDWOWRECORD*    ppSharedWowRecord
   );


VOID BaseSrvAddWOWRecord (
    PSHAREDWOWRECORD pSharedWow,
    PWOWRECORD pWOWRecord
    );

VOID BaseSrvRemoveWOWRecord (
    PSHAREDWOWRECORD pSharedWow,
    PWOWRECORD pWOWRecord
    );

VOID
BaseSrvFreeSharedWowRecord(
   PSHAREDWOWRECORD pSharedWowRecord
   );

ULONG
BaseSrvGetWOWTaskId(
   PSHAREDWOWRECORDHEAD pSharedWowHead // (->pSharedWowRecord)
    );

NTSTATUS
BaseSrvRemoveWOWRecordByTaskId (
    IN PSHAREDWOWRECORD pSharedWow,
    IN ULONG iWowTask
    );


PWOWRECORD
BaseSrvCheckAvailableWOWCommand(
   PSHAREDWOWRECORD pSharedWow
    );

PWOWRECORD
BaseSrvAllocateWOWRecord(
   PSHAREDWOWRECORDHEAD pSharedWowRecordHead
   );

NTSTATUS
BaseSrvAddWowTask (
      PCSR_API_MSG m,
      ULONG SequenceNumber
);

NTSTATUS
BaseSrvEnumWowTask (
      PBASE_GET_NEXT_VDM_COMMAND_MSG b
);

NTSTATUS
BaseSrvEnumWowProcess(
       PBASE_GET_NEXT_VDM_COMMAND_MSG b
);

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Api import definitions
//
//


WCHAR wszUser32ModName[] = L"user32";
WCHAR wszWinSrvModName[] = L"winsrv";

BASESRVAPIIMPORTRECORD rgUser32ApiImport[] = {
     { "PostMessageA",                  (PVOID*)&BaseSrvPostMessageA }
   , { "GetWindowThreadProcessId",      (PVOID*)&BaseSrvGetWindowThreadProcessId }
   , { "ResolveDesktopForWOW",          (PVOID*)&BaseSrvUserResolveDesktopForWow }
};

BASESRVAPIIMPORTRECORD rgWinsrvApiImport[] = {
     { "_UserTestTokenForInteractive",  (PVOID*)&UserTestTokenForInteractive }
};


BASESRVMODULEIMPORTRECORD rgBaseSrvModuleImport[] = {
   { wszUser32ModName, rgUser32ApiImport, sizeof(rgUser32ApiImport) / sizeof(rgUser32ApiImport[0]), NULL },
   { wszWinSrvModName, rgWinsrvApiImport, sizeof(rgWinsrvApiImport) / sizeof(rgWinsrvApiImport[0]), NULL }
};


// import all the necessary apis at once
// This procedure should execute just once and then the appropriate components just
// hang around
// call this with
// Status = BaseSrvImportApis(rgBaseSrvModuleImport,
//                            sizeof(rgBaseSrvModuleImport)/sizeof(rgBaseSrvModuleImport[0]))
//

NTSTATUS
BaseSrvImportApis(
   PBASESRVMODULEIMPORTRECORD pModuleImport,
   UINT nModules
   )
{
   NTSTATUS Status;
   UINT uModule, uProcedure;
   PBASESRVAPIIMPORTRECORD pApiImport;
   STRING ProcedureName; // procedure name or module name
   UNICODE_STRING ModuleName;
   HANDLE ModuleHandle;


   for (uModule = 0; uModule < nModules; ++uModule, ++pModuleImport) {

      // see if we can load this particular dll
      RtlInitUnicodeString(&ModuleName, pModuleImport->pwszModuleName);
      Status = LdrLoadDll(NULL,
                          NULL,
                          &ModuleName,         // module name string
                          &ModuleHandle);

      if (!NT_SUCCESS(Status)) {

         // we may have linked to a few dlls at this point - we have to unlink from all of those
         // by unloading the dll which is really a useless exersise.
         // so just abandon and return -- BUGBUG - cleanup later
         KdPrint(("BaseSrvImportApis: Failed to load %ls\n",
                  pModuleImport->pwszModuleName));
         goto ErrorCleanup;
      }

      pModuleImport->ModuleHandle = ModuleHandle;

      pApiImport = pModuleImport->pApiImportRecord;

      for (uProcedure = 0, pApiImport = pModuleImport->pApiImportRecord;
           uProcedure < pModuleImport->nApiImportRecordCount;
           ++uProcedure, ++pApiImport) {

         RtlInitString(&ProcedureName, pApiImport->pszProcedureName);
         Status = LdrGetProcedureAddress(ModuleHandle,
                                         &ProcedureName,      // procedure name string
                                         0,
                                         pApiImport->ppProcAddress);

         if (!NT_SUCCESS(Status)) {
            // we have failed to get this procedure - something is wrong
            // perform a cleanup
            KdPrint(("BaseSrvImportApis: Failed to link %s from %ls\n",
                     pApiImport->pszProcedureName,
                     pModuleImport->pwszModuleName));
            goto ErrorCleanup;
         }
      }
   }



   return (STATUS_SUCCESS);

ErrorCleanup:

      // here we engage into a messy cleanup procedure by returning things back to the way
      // they were before we have started

   for (; uModule > 0; --uModule, --pModuleImport) {

      // reset all the apis
      for (uProcedure = 0, pApiImport = pModuleImport->pApiImportRecord;
           uProcedure < pModuleImport->nApiImportRecordCount;
           ++uProcedure, ++pApiImport) {

         *pApiImport->ppProcAddress = NULL;

      }

      if (NULL != pModuleImport->ModuleHandle) {
         LdrUnloadDll(pModuleImport->ModuleHandle);
         pModuleImport->ModuleHandle = NULL;
      }
   }

   return (Status);

}


//////////////////////////////////////////////////////////////////////////////
//
// Manipulating shared wows
//
//
// assumes pDesktopName != NULL
// without the explicit checking

PSHAREDWOWRECORD BaseSrvAllocateSharedWowRecord (
    PUNICODE_STRING pDesktopName
    )
{
    PSHAREDWOWRECORD pSharedWow;
    DWORD dwSharedWowRecordSize = sizeof(SHAREDWOWRECORD) +
                                  pDesktopName->Length +
                                  sizeof(WCHAR);

    pSharedWow = RtlAllocateHeap(RtlProcessHeap (),
                                 MAKE_TAG( VDM_TAG ),
                                 dwSharedWowRecordSize);
    if (NULL != pSharedWow) {
       RtlZeroMemory ((PVOID)pSharedWow, dwSharedWowRecordSize);
       // initialize desktop name
       pSharedWow->WowExecDesktopName.MaximumLength = pDesktopName->Length + sizeof(WCHAR);
       pSharedWow->WowExecDesktopName.Buffer = (PWCHAR)(pSharedWow + 1);
       RtlCopyUnicodeString(&pSharedWow->WowExecDesktopName, pDesktopName);
       pSharedWow->WowAuthId = RtlConvertLongToLuid(-1);
    }

    return pSharedWow;
}

// this function completely removes the given shared wow vdm
// from our accounting
//
// removes the record from the list of shared wow records
//
// This function also frees the associated memory
//
//

NTSTATUS
BaseSrvDeleteSharedWowRecord (
    PSHAREDWOWRECORDHEAD pSharedWowRecordHead,
    PSHAREDWOWRECORD pSharedWowRecord
    )
{
   PSHAREDWOWRECORD pSharedWowRecordPrev = NULL;
   PSHAREDWOWRECORD pSharedWowRecordCur;

   if (NULL == pSharedWowRecord) { // this is dumb
      return STATUS_NOT_FOUND;
   }

   pSharedWowRecordCur = pSharedWowRecordHead->pSharedWowRecord;
   while (NULL != pSharedWowRecordCur) {
      if (pSharedWowRecordCur == pSharedWowRecord) {
         break;
      }

      pSharedWowRecordPrev = pSharedWowRecordCur;
      pSharedWowRecordCur = pSharedWowRecordCur->pNextSharedWow;
   }

   if (NULL == pSharedWowRecordCur) {
      KdPrint(("BaseSrvDeleteSharedWowRecord: invalid pointer to Shared WOW\n"));
      ASSERT(FALSE);
      return STATUS_NOT_FOUND;
   }


   // unlink here
   if (NULL == pSharedWowRecordPrev) {
      pSharedWowRecordHead->pSharedWowRecord = pSharedWowRecord->pNextSharedWow;
   }
   else {
      pSharedWowRecordPrev->pNextSharedWow = pSharedWowRecord->pNextSharedWow;
   }

   BaseSrvFreeSharedWowRecord(pSharedWowRecord);

   return STATUS_SUCCESS;
}

// assumes no cs is held -- self-contained
// assoc console record should have been removed by now
// nukes all tasks associated with this particular shared wow

VOID
BaseSrvFreeSharedWowRecord(
   PSHAREDWOWRECORD pSharedWowRecord)
{
   PWOWRECORD pWOWRecord,
              pWOWRecordLast;

   if(pSharedWowRecord->WOWUserToken) {
      NtClose(pSharedWowRecord->WOWUserToken);
   }

   pWOWRecord = pSharedWowRecord->pWOWRecord;


   while (NULL != pWOWRecord) {
      pWOWRecordLast = pWOWRecord->WOWRecordNext;
      if(pWOWRecord->hWaitForParent) {
         NtSetEvent (pWOWRecord->hWaitForParent,NULL);
         NtClose (pWOWRecord->hWaitForParent);
         pWOWRecord->hWaitForParent = 0;
      }
      BaseSrvFreeWOWRecord(pWOWRecord);
      pWOWRecord = pWOWRecordLast;
   }

   RtlFreeHeap(RtlProcessHeap (), 0, pSharedWowRecord);
}


// assumes: global wow crit sec is held

NTSTATUS
BaseSrvFindSharedWowRecordByDesktop(
   PSHAREDWOWRECORDHEAD pSharedWowRecordHead,
   PUNICODE_STRING      pDesktopName,
   PSHAREDWOWRECORD*    ppSharedWowRecord)
{
   PSHAREDWOWRECORD pSharedWowRecord = pSharedWowRecordHead->pSharedWowRecord;

   while (NULL != pSharedWowRecord) {
      if (0 == RtlCompareUnicodeString(&pSharedWowRecord->WowExecDesktopName,
                                       pDesktopName,
                                       TRUE)) {
         break;
      }
      pSharedWowRecord = pSharedWowRecord->pNextSharedWow;
   }

   if (NULL != pSharedWowRecord) {
      *ppSharedWowRecord = pSharedWowRecord;
      return STATUS_SUCCESS;
   }

   return STATUS_NOT_FOUND; // bummer, this is not found
}

// Vadimb : modify this to handle sorted list properly
// then find should be moded to work a little faster - BUGBUG
// assumes: pSharedWowRecord->pNextSharedWow is inited to NULL

VOID
BaseSrvAddSharedWowRecord(
   PSHAREDWOWRECORDHEAD pSharedWowRecordHead,
   PSHAREDWOWRECORD pSharedWowRecord)
{
   PSHAREDWOWRECORD pSharedWowRecordCur = pSharedWowRecordHead->pSharedWowRecord;

   if (NULL == pSharedWowRecordCur) {
      pSharedWowRecordHead->pSharedWowRecord = pSharedWowRecord;
   }
   else {

      PSHAREDWOWRECORD pSharedWowRecordPrev = NULL;
      LONG lCompare;

      while (NULL != pSharedWowRecordCur) {
         lCompare = RtlCompareUnicodeString(&pSharedWowRecordCur->WowExecDesktopName,
                                            &pSharedWowRecord->WowExecDesktopName,
                                            TRUE);
         if (lCompare > 0) {
            break;
         }

         pSharedWowRecordPrev = pSharedWowRecordCur;
         pSharedWowRecordCur = pSharedWowRecordCur->pNextSharedWow;
      }

      pSharedWowRecord->pNextSharedWow = pSharedWowRecordCur;

      if (NULL == pSharedWowRecordPrev) { // goes to the head
         pSharedWowRecordHead->pSharedWowRecord = pSharedWowRecord;
      }
      else {
         pSharedWowRecordPrev->pNextSharedWow = pSharedWowRecord;
      }
   }
}


NTSTATUS
BaseSrvFindSharedWowRecordByConsoleHandle(
   PSHAREDWOWRECORDHEAD pSharedWowRecordHead,
   HANDLE               hConsole,
   PSHAREDWOWRECORD     *ppSharedWowRecord)
{
   PSHAREDWOWRECORD pSharedWow = pSharedWowRecordHead->pSharedWowRecord;

   while (NULL != pSharedWow) {
      // see if same hConsole
      if (pSharedWow->hConsole == hConsole) {
         *ppSharedWowRecord = pSharedWow;
         return STATUS_SUCCESS;
      }
      pSharedWow = pSharedWow->pNextSharedWow;
   }

   return STATUS_NOT_FOUND;
}

NTSTATUS
BaseSrvFindSharedWowRecordByTaskId(
   PSHAREDWOWRECORDHEAD pSharedWowRecordHead,
   ULONG                TaskId,             // task id
   PSHAREDWOWRECORD     *ppSharedWowRecord,
   PWOWRECORD           *ppWowRecord) // optional
{
   PSHAREDWOWRECORD pSharedWow = pSharedWowRecordHead->pSharedWowRecord;
   PWOWRECORD       pWowRecord;

   ASSERT(0 != TaskId); // this is a pre-condition

   while (NULL != pSharedWow) {

      pWowRecord = pSharedWow->pWOWRecord;

      while (NULL != pWowRecord) {

         if (pWowRecord->iTask == TaskId) {

            ASSERT(NULL != ppWowRecord);

            // this is wow task
            *ppSharedWowRecord = pSharedWow;
            if (NULL != ppWowRecord) {
               *ppWowRecord = pWowRecord;
            }

            return STATUS_SUCCESS;
         }

         pWowRecord = pWowRecord->WOWRecordNext;
      }

      pSharedWow = pSharedWow->pNextSharedWow;
   }

   return STATUS_NOT_FOUND;
}


NTSTATUS
BaseSrvGetVdmSequence(
   HANDLE hProcess,
   PULONG pSequenceNumber)
{
   NTSTATUS Status;
   PCSR_PROCESS pCsrProcess;

   Status = CsrLockProcessByClientId(hProcess, &pCsrProcess);
   if ( !NT_SUCCESS(Status) ) {
       return Status;
   }

   *pSequenceNumber = pCsrProcess->SequenceNumber;
   CsrUnlockProcess(pCsrProcess);

   Status = STATUS_SUCCESS;

   return Status;
}


////////////////////////////////////////////// End new code


// internal prototypes
ULONG
GetNextDosSesId(VOID);

NTSTATUS
GetConsoleRecordDosSesId (
    IN ULONG  DosSesId,
    IN OUT PCONSOLERECORD *pConsoleRecord
    );

NTSTATUS
OkToRunInSharedWOW(
    IN HANDLE  UniqueProcessClientId,
    OUT PLUID  pAuthenticationId,
    OUT PHANDLE pWOWUserToken
    );

BOOL
IsClientSystem(
    HANDLE hUserToken
    );

VOID
BaseSrvVDMInit(VOID)
{
   NTSTATUS Status;

   Status = RtlInitializeCriticalSection( &BaseSrvDOSCriticalSection );
   ASSERT( NT_SUCCESS( Status ) );
   Status = RtlInitializeCriticalSection( &BaseSrvWOWCriticalSection );
   ASSERT( NT_SUCCESS( Status ) );
   return;
}



ULONG
BaseSrvCheckVDM(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status;
    PBASE_CHECKVDM_MSG b = (PBASE_CHECKVDM_MSG)&m->u.ApiMessageData;

    if (BaseSrvIsVdmAllowed() == FALSE) {
        return STATUS_VDM_DISALLOWED;
    }
    if (!CsrValidateMessageBuffer(m, &b->CmdLine, b->CmdLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->AppName, b->AppLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->Env, b->EnvLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->PifFile, b->PifLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->CurDirectory, b->CurDirectoryLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->Title, b->TitleLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->Reserved, b->ReservedLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->Desktop, b->DesktopLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!CsrValidateMessageBuffer(m, &b->StartupInfo, sizeof(STARTUPINFO), sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (b->UserLuid && !CsrValidateMessageBuffer(m, &b->UserLuid, sizeof(LUID), sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if(b->BinaryType == BINARY_TYPE_WIN16) {
        Status = BaseSrvCheckWOW (b, m->h.ClientId.UniqueProcess);
    }
    else {
        Status = BaseSrvCheckDOS (b,  m->h.ClientId.UniqueProcess);
    }

    return ((ULONG)Status);
}

ULONG
BaseSrvUpdateVDMEntry(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_UPDATE_VDM_ENTRY_MSG b = (PBASE_UPDATE_VDM_ENTRY_MSG)&m->u.ApiMessageData;
    ULONG SequenceNumber;

    if(!NT_SUCCESS(BaseSrvGetVdmSequence(m->h.ClientId.UniqueProcess, &SequenceNumber))) {
       return (ULONG)STATUS_INVALID_PARAMETER;
    }

    if (BINARY_TYPE_WIN16 == b->BinaryType)
       return (BaseSrvUpdateWOWEntry (b, SequenceNumber));
    else
       return (BaseSrvUpdateDOSEntry (b, SequenceNumber));
}


//
// This call makes an explicit assumption that the very first time ntvdm is accessed --
//
//
//
//
//


ULONG
BaseSrvGetNextVDMCommand(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
   NTSTATUS Status;
   PBASE_GET_NEXT_VDM_COMMAND_MSG b = (PBASE_GET_NEXT_VDM_COMMAND_MSG)&m->u.ApiMessageData;
   PDOSRECORD pDOSRecord,pDOSRecordTemp=NULL;
   PWOWRECORD pWOWRecord;
   PCONSOLERECORD pConsoleRecord;
   PVDMINFO lpVDMInfo;
   HANDLE Handle,TargetHandle;
   LONG WaitState;
   PBATRECORD pBatRecord;
   PSHAREDWOWRECORD pSharedWow = NULL;
   BOOL bWowApp = b->VDMState & ASKING_FOR_WOW_BINARY;
   BOOL bSepWow = b->VDMState & ASKING_FOR_SEPWOW_BINARY;
   ULONG SequenceNumber;

    if(!NT_SUCCESS(BaseSrvGetVdmSequence(m->h.ClientId.UniqueProcess, &SequenceNumber))) {
       return (ULONG)STATUS_INVALID_PARAMETER;
    }


    if (!CsrValidateMessageBuffer(m, &b->Env, b->EnvLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if(b->VDMState & ASKING_FOR_WOWPROCLIST) {
       return BaseSrvEnumWowProcess(b);
    }
    else if(b->VDMState & ASKING_FOR_WOWTASKLIST) {
       return BaseSrvEnumWowTask(b);
    }
    else if(b->VDMState & ASKING_TO_ADD_WOWTASK) {
       return BaseSrvAddWowTask (m, SequenceNumber);
    }


    if (!CsrValidateMessageBuffer(m, &b->CmdLine, b->CmdLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->AppName, b->AppLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->PifFile, b->PifLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->CurDirectory, b->CurDirectoryLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->Title, b->TitleLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->Reserved, b->ReservedLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!CsrValidateMessageBuffer(m, &b->Desktop, b->DesktopLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!CsrValidateMessageBuffer(m, &b->StartupInfo, sizeof(STARTUPINFO), sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }


   if (bWowApp) { // wow call please

      BOOL bPif = b->VDMState & ASKING_FOR_PIF;

      // find the shared wow record that we are calling
      // to do that we look at iTask which (in case of shared wow


      // this could have been the very first call that we've made in so far
      // the iTask in this context procides us with

      // look for our beloved shared wow using the [supplied] task id
      Status = ENTER_WOW_CRITICAL();
      ASSERT(NT_SUCCESS(Status));

      // grab crit section for read access
      if (bPif && b->iTask) {
         // this is probably the very first call -- update session handles first
         Status = BaseSrvFindSharedWowRecordByTaskId(&gWowHead,
                                                     b->iTask,
                                                     &pSharedWow,
                                                     &pWOWRecord);
         pSharedWow->hConsole = b->ConsoleHandle;
      }
      else { // this is not a pif -- find by a console handle then

         Status = BaseSrvFindSharedWowRecordByConsoleHandle(&gWowHead,
                                                            b->ConsoleHandle,
                                                            &pSharedWow);
      }

      // now if we have the share wow - party!
      if (!NT_SUCCESS(Status)) {
         KdPrint(("BaseSrvGetNextVDMCommand: Shared Wow has not been found. Console : 0x%x\n", b->ConsoleHandle));
         LEAVE_WOW_CRITICAL();
         return Status;
      }

      if (SequenceNumber != pSharedWow->SequenceNumber) {
          KdPrint(("BaseSrvGetNextVdmCommand: Shared wow sequence number doesn't match\n"));
          LEAVE_WOW_CRITICAL();
          return STATUS_INVALID_PARAMETER;
      }

      ASSERT(NULL != pSharedWow);

      //
      // WowExec is asking for a command.  We never block when
      // asking for a WOW binary, since WOW no longer has a thread
      // blocked in GetNextVDMCommand.  Instead, WowExec gets a
      // message posted to it by BaseSrv when there are command(s)
      // waiting for it, and it loops calling GetNextVDMCommand
      // until it fails -- but it must not block.
      //

      b->WaitObjectForVDM = 0;

      // Vadimb: this call should uniquelly identify the caller as this is
      // the task running on a particular winsta/desktop
      // thus, as such it should be picked up from the appropriate queue


      if (NULL == (pWOWRecord = BaseSrvCheckAvailableWOWCommand(pSharedWow))) {

         //
         // There's no command waiting for WOW, so just return.
         // This is where we used to cause blocking.
         //
         b->TitleLen =
         b->EnvLen =
         b->DesktopLen =
         b->ReservedLen =
         b->CmdLen =
         b->AppLen =
         b->PifLen =
         b->CurDirectoryLen = 0;

         LEAVE_WOW_CRITICAL();

         return ((ULONG)STATUS_SUCCESS);
      }

      lpVDMInfo = pWOWRecord->lpVDMInfo;

      if (bPif) { // this is initial call made by ntvdm

         Status = BaseSrvFillPifInfo (lpVDMInfo,b);

         LEAVE_WOW_CRITICAL();

         return (Status);
      }

   }
   else {
      //
      // DOS VDM or Separate WOW is asking for next command.
      //

      Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
      ASSERT(NT_SUCCESS(Status));
      if (b->VDMState & ASKING_FOR_PIF && b->iTask)
          Status = GetConsoleRecordDosSesId(b->iTask,&pConsoleRecord);
      else
          Status = BaseSrvGetConsoleRecord(b->ConsoleHandle,&pConsoleRecord);

      if (!NT_SUCCESS (Status) || SequenceNumber != pConsoleRecord->SequenceNumber) {
          RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
          KdPrint(("BaseSrvGetNextVdmCommand: Couldn't find dos record or sequence numbers don't match\n"));
          return ((ULONG)STATUS_INVALID_PARAMETER);
          }


      pDOSRecord = pConsoleRecord->DOSRecord;

      if (b->VDMState & ASKING_FOR_PIF) {
          if (pDOSRecord) {
              Status = BaseSrvFillPifInfo (pDOSRecord->lpVDMInfo,b);
              if (b->iTask)  {
                  if (!pConsoleRecord->hConsole)  {
                      pConsoleRecord->hConsole = b->ConsoleHandle;
                      pConsoleRecord->DosSesId = 0;
                      }
                  else {
                      Status = STATUS_INVALID_PARAMETER;
                      }
                  }
              }
          else {
              Status = STATUS_INVALID_PARAMETER;
              }
          RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
          return (Status);
          }

      if (!bSepWow) {
          if (!(b->VDMState & (ASKING_FOR_FIRST_COMMAND |
                               ASKING_FOR_SECOND_TIME |
                               NO_PARENT_TO_WAKE))
              || (b->VDMState & ASKING_FOR_SECOND_TIME && b->ExitCode != 0))
             {

              // Search first VDM_TO_TAKE_A_COMMAND or last VDM_BUSY record as
              // per the case.
              if (b->VDMState & ASKING_FOR_SECOND_TIME){
                  while(pDOSRecord && pDOSRecord->VDMState != VDM_TO_TAKE_A_COMMAND)
                      pDOSRecord = pDOSRecord->DOSRecordNext;
                  }
              else {
                  while(pDOSRecord){
                      if(pDOSRecord->VDMState == VDM_BUSY)
                          pDOSRecordTemp = pDOSRecord;
                      pDOSRecord = pDOSRecord->DOSRecordNext;
                      }
                  pDOSRecord = pDOSRecordTemp;
                  }


              if (pDOSRecord == NULL) {
                  RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
                  return STATUS_SUCCESS;
                  }

              pDOSRecord->ErrorCode = b->ExitCode;
              pDOSRecord->VDMState = VDM_HAS_RETURNED_ERROR_CODE;
              NtSetEvent (pDOSRecord->hWaitForParentDup,NULL);
              NtClose (pDOSRecord->hWaitForParentDup);
              pDOSRecord->hWaitForParentDup = 0;
              pDOSRecord = pDOSRecord->DOSRecordNext;
              }
          }

      while (pDOSRecord && pDOSRecord->VDMState != VDM_TO_TAKE_A_COMMAND)
          pDOSRecord = pDOSRecord->DOSRecordNext;

      if (pDOSRecord == NULL) {

          if (bSepWow ||
              (b->VDMState & RETURN_ON_NO_COMMAND && b->VDMState & ASKING_FOR_SECOND_TIME))
            {
              b->WaitObjectForVDM = 0;
              RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
              return ((ULONG)STATUS_NO_MEMORY);
              }

          if(pConsoleRecord->hWaitForVDMDup == 0 ){
              if(NT_SUCCESS(BaseSrvCreatePairWaitHandles (&Handle,
                                                          &TargetHandle))){
                  pConsoleRecord->hWaitForVDMDup = Handle;
                  pConsoleRecord->hWaitForVDM = TargetHandle;
                  }
              else {
                  b->WaitObjectForVDM = 0;
                  RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
                  return ((ULONG)STATUS_NO_MEMORY);
                  }
              }
          else {
              NtResetEvent(pConsoleRecord->hWaitForVDMDup,&WaitState);
              }
          b->WaitObjectForVDM = pConsoleRecord->hWaitForVDM;
          RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
          return STATUS_SUCCESS;
          }

      b->WaitObjectForVDM = 0;
      lpVDMInfo = pDOSRecord->lpVDMInfo;

   }

   //
   // ASKING_FOR_ENVIRONMENT
   // Return the information but DO NOT delete the lpVDMInfo
   // associated with the DOS record
   // ONLY DOS APPS NEED THIS
   //
   if (b->VDMState & ASKING_FOR_ENVIRONMENT) {
      if (lpVDMInfo->EnviornmentSize <= b->EnvLen) {
         RtlMoveMemory(b->Env,
                       lpVDMInfo->Enviornment,
                       lpVDMInfo->EnviornmentSize);
         Status = STATUS_SUCCESS;
      }
      else {
         Status = STATUS_INVALID_PARAMETER;
      }

      b->EnvLen = lpVDMInfo->EnviornmentSize;

      if (bWowApp) {
         LEAVE_WOW_CRITICAL();
      }
      else {
         RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
      }

      return Status;
   }


   //
   // check buffer sizes, CmdLine is mandatory!
   //

   if (!b->CmdLine || lpVDMInfo->CmdSize > b->CmdLen ||
       (b->AppName && lpVDMInfo->AppLen > b->AppLen) ||
       (b->Env && lpVDMInfo->EnviornmentSize > b->EnvLen) ||
       (b->PifFile && lpVDMInfo->PifLen > b->PifLen) ||
       (b->CurDirectory && lpVDMInfo->CurDirectoryLen > b->CurDirectoryLen) ||
       (b->Title && lpVDMInfo->TitleLen > b->TitleLen) ||
       (b->Reserved && lpVDMInfo->ReservedLen > b->ReservedLen) ||
       (b->Desktop && lpVDMInfo->DesktopLen > b->DesktopLen)) {

      Status = STATUS_INVALID_PARAMETER;
   }
   else {
      Status = STATUS_SUCCESS;
   }

   b->CmdLen = lpVDMInfo->CmdSize;
   b->AppLen = lpVDMInfo->AppLen;
   b->PifLen = lpVDMInfo->PifLen;
   b->EnvLen = lpVDMInfo->EnviornmentSize;
   b->CurDirectoryLen = lpVDMInfo->CurDirectoryLen;
   b->DesktopLen = lpVDMInfo->DesktopLen;
   b->TitleLen = lpVDMInfo->TitleLen;
   b->ReservedLen = lpVDMInfo->ReservedLen;

   if (!NT_SUCCESS(Status)) {
      if (bWowApp) {
         LEAVE_WOW_CRITICAL();
      }
      else {
         RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
      }
      return (Status);
   }


   if (lpVDMInfo->CmdLine && b->CmdLine)
      RtlMoveMemory(b->CmdLine,
                    lpVDMInfo->CmdLine,
                    lpVDMInfo->CmdSize);

   if (lpVDMInfo->AppName && b->AppName)
      RtlMoveMemory(b->AppName,
                    lpVDMInfo->AppName,
                    lpVDMInfo->AppLen);

   if (lpVDMInfo->PifFile && b->PifFile)
      RtlMoveMemory(b->PifFile,
                     lpVDMInfo->PifFile,
                     lpVDMInfo->PifLen);

   if (lpVDMInfo->CurDirectory && b->CurDirectory)
      RtlMoveMemory(b->CurDirectory,
                    lpVDMInfo->CurDirectory,
                    lpVDMInfo->CurDirectoryLen);

   if (lpVDMInfo->Title && b->Title)
      RtlMoveMemory(b->Title,
                    lpVDMInfo->Title,
                    lpVDMInfo->TitleLen);

   if (lpVDMInfo->Reserved && b->Reserved)
      RtlMoveMemory(b->Reserved,
                    lpVDMInfo->Reserved,
                    lpVDMInfo->ReservedLen);

   if (lpVDMInfo->Enviornment && b->Env)
      RtlMoveMemory(b->Env,
                    lpVDMInfo->Enviornment,
                    lpVDMInfo->EnviornmentSize);


   if (lpVDMInfo->VDMState & STARTUP_INFO_RETURNED)
      RtlMoveMemory(b->StartupInfo,
                    &lpVDMInfo->StartupInfo,
                    sizeof (STARTUPINFOA));

   if (lpVDMInfo->Desktop && b->Desktop)
      RtlMoveMemory(b->Desktop,
                    lpVDMInfo->Desktop,
                    lpVDMInfo->DesktopLen);


   if ((pBatRecord = BaseSrvGetBatRecord (b->ConsoleHandle)) != NULL)
      b->fComingFromBat = TRUE;
   else
      b->fComingFromBat = FALSE;

   b->CurrentDrive = lpVDMInfo->CurDrive;
   b->CodePage = lpVDMInfo->CodePage;
   b->dwCreationFlags = lpVDMInfo->dwCreationFlags;
   b->VDMState = lpVDMInfo->VDMState;

   if (bWowApp) {
      b->iTask = pWOWRecord->iTask;
      pWOWRecord->fDispatched = TRUE;
   }
   else {
      pDOSRecord->VDMState = VDM_BUSY;
   }

   b->StdIn  = lpVDMInfo->StdIn;
   b->StdOut = lpVDMInfo->StdOut;
   b->StdErr = lpVDMInfo->StdErr;

   if (bSepWow) {
      // this was a sep wow request -- we have done this only record that is to
      // be dispatched to this particular wow -- now just remove every trace of
      // this wow on the server side...

      NtClose( pConsoleRecord->hVDM );
      BaseSrvFreeConsoleRecord(pConsoleRecord); // unwire as well
      RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
   }
   else {
      // this is shared wow or dos app -- free vdm info and release the
      // appropriate sync object

      BaseSrvFreeVDMInfo (lpVDMInfo);
       // BUGBUG -- fixed

      if (bWowApp) {
         pWOWRecord->lpVDMInfo = NULL;
         LEAVE_WOW_CRITICAL();
      }
      else {
         pDOSRecord->lpVDMInfo = NULL;
         RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
      }
   }

   return Status;
}  // END of GetNextVdmCommand




ULONG
BaseSrvExitVDM(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
   PBASE_EXIT_VDM_MSG b = (PBASE_EXIT_VDM_MSG)&m->u.ApiMessageData;
   NTSTATUS Status;
   ULONG SequenceNumber;

   if(!NT_SUCCESS(BaseSrvGetVdmSequence(m->h.ClientId.UniqueProcess, &SequenceNumber))) {
       return (ULONG)STATUS_INVALID_PARAMETER;
   }


   if (b->iWowTask) {
      Status = BaseSrvExitWOWTask(b, SequenceNumber);
   }
   else {
      Status = BaseSrvExitDOSTask(b, SequenceNumber);
   }

   return Status;
}


ULONG
BaseSrvIsFirstVDM(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_IS_FIRST_VDM_MSG c = (PBASE_IS_FIRST_VDM_MSG)&m->u.ApiMessageData;

    if(!NT_SUCCESS(BaseSrvIsClientVdm(m->h.ClientId.UniqueProcess))) {
       return STATUS_ACCESS_DENIED;
    }

    c->FirstVDM = fIsFirstVDM;
    if(fIsFirstVDM)
        fIsFirstVDM = FALSE;
    return STATUS_SUCCESS;
}


//
// This call should only be used for DOS apps and not for wow apps
// hence we don't remove ConsoleHandle == -1 condition here as it is
// only a validation check
//
//

ULONG
BaseSrvSetVDMCurDirs(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status;
    PBASE_GET_SET_VDM_CUR_DIRS_MSG b = (PBASE_GET_SET_VDM_CUR_DIRS_MSG)&m->u.ApiMessageData;
    PCONSOLERECORD pConsoleRecord;
    ULONG SequenceNumber;

    if (b->ConsoleHandle == (HANDLE) -1) {
        return (ULONG) STATUS_INVALID_PARAMETER;
    }

    if (!CsrValidateMessageBuffer(m, &b->lpszzCurDirs, b->cchCurDirs, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }


    if(!NT_SUCCESS(BaseSrvGetVdmSequence(m->h.ClientId.UniqueProcess, &SequenceNumber))) {
      return (ULONG)STATUS_INVALID_PARAMETER;
    }

    Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
    ASSERT(NT_SUCCESS(Status));
    Status = BaseSrvGetConsoleRecord(b->ConsoleHandle,&pConsoleRecord);

    if (!NT_SUCCESS (Status) || SequenceNumber != pConsoleRecord->SequenceNumber) {
        RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
        return ((ULONG)STATUS_INVALID_PARAMETER);
    }
    if (pConsoleRecord->lpszzCurDirs) {
        RtlFreeHeap(BaseSrvHeap, 0, pConsoleRecord->lpszzCurDirs);
        pConsoleRecord->lpszzCurDirs = NULL;
        pConsoleRecord->cchCurDirs = 0;
    }
    if (b->cchCurDirs && b->lpszzCurDirs) {
            pConsoleRecord->lpszzCurDirs = RtlAllocateHeap(
                                                           BaseSrvHeap,
                                                           MAKE_TAG( VDM_TAG ),
                                                           b->cchCurDirs
                                                           );

            if (pConsoleRecord->lpszzCurDirs == NULL) {
                pConsoleRecord->cchCurDirs = 0;
                RtlLeaveCriticalSection(&BaseSrvDOSCriticalSection);
                return (ULONG)STATUS_NO_MEMORY;
            }
            RtlMoveMemory(pConsoleRecord->lpszzCurDirs,
                          b->lpszzCurDirs,
                          b->cchCurDirs
                          );

            pConsoleRecord->cchCurDirs = b->cchCurDirs;
            RtlLeaveCriticalSection(&BaseSrvDOSCriticalSection);
            return (ULONG) STATUS_SUCCESS;
    }

    RtlLeaveCriticalSection(&BaseSrvDOSCriticalSection);
    return (ULONG) STATUS_INVALID_PARAMETER;
}


ULONG
BaseSrvBatNotification(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status;
    PBATRECORD pBatRecord;
    PBASE_BAT_NOTIFICATION_MSG b = (PBASE_BAT_NOTIFICATION_MSG)&m->u.ApiMessageData;

    Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
    ASSERT(NT_SUCCESS(Status));

    // If BATRECORD does'nt exist for this console, create one only if
    // bat file execution is beginig i.e. fBeginEnd is TRUE.

    if ((pBatRecord = BaseSrvGetBatRecord(b->ConsoleHandle)) == NULL) {
        if (!(b->fBeginEnd == CMD_BAT_OPERATION_STARTING &&
            (pBatRecord = BaseSrvAllocateAndAddBatRecord (b->ConsoleHandle)))) {
            RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
            return ((ULONG)STATUS_SUCCESS);
        }
    }
    else if (b->fBeginEnd == CMD_BAT_OPERATION_TERMINATING)
        BaseSrvFreeAndRemoveBatRecord (pBatRecord);

    RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );

    return ((ULONG)STATUS_SUCCESS);
}





ULONG
BaseSrvRegisterWowExec(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PBASE_REGISTER_WOWEXEC_MSG b = (PBASE_REGISTER_WOWEXEC_MSG)&m->u.ApiMessageData;
    UNICODE_STRING ModuleNameString_U;
    PVOID ModuleHandle;
    STRING ProcedureNameString;
    NTSTATUS Status;
    PCSR_PROCESS Process;
    PSHAREDWOWRECORD pSharedWow;
    ULONG SequenceNumber;

    Status = ENTER_WOW_CRITICAL();
    ASSERT( NT_SUCCESS( Status ) );

    //
    // Do a run-time link to PostMessageA and GetWindowThreadProcessId
    // which we'll use to post messages to WowExec.
    //

    if (NULL == BaseSrvPostMessageA) {
       // this is an impossible event as all the imports are inited at once
       KdPrint(("BaseSrvRegisterWowExec: Api PostMessage is not available to BaseSrv\n"));
       ASSERT(FALSE);
       Status = STATUS_INVALID_PARAMETER;
       goto Cleanup;
    }

    Status = BaseSrvFindSharedWowRecordByConsoleHandle(&gWowHead,
                                                       b->ConsoleHandle,
                                                       &pSharedWow);
    if (!NT_SUCCESS(Status)) {
       KdPrint(("BaseSrvRegisterWowExec: Could not find record for wow console handle 0x%lx\n", b->ConsoleHandle));
       goto Cleanup;
    }

    if(!NT_SUCCESS(BaseSrvGetVdmSequence(m->h.ClientId.UniqueProcess, &SequenceNumber)) ||
       SequenceNumber != pSharedWow->SequenceNumber) {
       Status = STATUS_INVALID_PARAMETER;
       KdPrint(("BaseSrvRegisterWowExec: SequenceNumber didn't match\n"));
       goto Cleanup;
    }

    ASSERT(NULL != pSharedWow);

    // see what the window handle is -- special "die wow, die" case
    if (NULL == b->hwndWowExec) {
       //
       // Shared WOW is calling to de-register itself as part of shutdown.
       // Protocol is we check for pending commands for this shared WOW,
       // if there are any we fail this call, otherwise we set our
       // hwndWowExec to NULL and succeed the call, ensuring no more
       // commands will be added to this queue.
       //
       if (NULL != pSharedWow->pWOWRecord) {
          Status = STATUS_MORE_PROCESSING_REQUIRED;
       }
       else { // no tasks for this wow
              // it goes KABOOOOOOM!!!!!

          Status = BaseSrvDeleteSharedWowRecord(&gWowHead, pSharedWow);
       }

       goto Cleanup;
    }

    if (pSharedWow->hwndWowExec) {
    // Shared WOW windows  was already registered
    // someone else is trying to overwrite it, so don't allow it
       Status = STATUS_INVALID_PARAMETER;

       goto Cleanup;
    }

    // set the window handle
    pSharedWow->hwndWowExec = b->hwndWowExec;

    // rettrieve thread and process id of the calling process
    pSharedWow->dwWowExecThreadId = BaseSrvGetWindowThreadProcessId(
                                          pSharedWow->hwndWowExec,
                                          &pSharedWow->dwWowExecProcessId);

Cleanup:

    LEAVE_WOW_CRITICAL();
    return (ULONG)Status;
}

PBATRECORD
BaseSrvGetBatRecord(
    IN HANDLE hConsole
    )
{
    PBATRECORD pBatRecord = BatRecordHead;
    while (pBatRecord && pBatRecord->hConsole != hConsole)
        pBatRecord = pBatRecord->BatRecordNext;
    return pBatRecord;
}

PBATRECORD
BaseSrvAllocateAndAddBatRecord(
    HANDLE  hConsole
    )
{
    PCSR_THREAD t;
    PBATRECORD pBatRecord;

    if((pBatRecord = RtlAllocateHeap(RtlProcessHeap (),
                                     MAKE_TAG( VDM_TAG ),
                                     sizeof(BATRECORD))) == NULL)
        return NULL;

    t = CSR_SERVER_QUERYCLIENTTHREAD();
    pBatRecord->hConsole = hConsole;
    pBatRecord->SequenceNumber = t->Process->SequenceNumber;
    pBatRecord->BatRecordNext = BatRecordHead;
    BatRecordHead = pBatRecord;
    return pBatRecord;
}

VOID
BaseSrvFreeAndRemoveBatRecord(
    PBATRECORD pBatRecordToFree
    )
{
    PBATRECORD pBatRecord = BatRecordHead;
    PBATRECORD pBatRecordLast = NULL;

    while (pBatRecord && pBatRecord != pBatRecordToFree){
        pBatRecordLast = pBatRecord;
        pBatRecord = pBatRecord->BatRecordNext;
    }

    if (pBatRecord == NULL)
        return;

    if (pBatRecordLast)
        pBatRecordLast->BatRecordNext = pBatRecord->BatRecordNext;
    else
        BatRecordHead = pBatRecord->BatRecordNext;

    RtlFreeHeap ( RtlProcessHeap (), 0, pBatRecord);

    return;
}


ULONG
BaseSrvGetVDMCurDirs(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status;
    PBASE_GET_SET_VDM_CUR_DIRS_MSG b = (PBASE_GET_SET_VDM_CUR_DIRS_MSG)&m->u.ApiMessageData;
    PCONSOLERECORD pConsoleRecord;

    if (!CsrValidateMessageBuffer(m, &b->lpszzCurDirs, b->cchCurDirs, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
    ASSERT(NT_SUCCESS(Status));
    Status = BaseSrvGetConsoleRecord(b->ConsoleHandle,&pConsoleRecord);
    if (!NT_SUCCESS (Status)) {
        RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
        b->cchCurDirs = 0;
        return ((ULONG)STATUS_INVALID_PARAMETER);
    }
    if (pConsoleRecord->lpszzCurDirs != NULL){
        if (b->cchCurDirs < pConsoleRecord->cchCurDirs || b->lpszzCurDirs == NULL)
            {
             b->cchCurDirs = pConsoleRecord->cchCurDirs;
             RtlLeaveCriticalSection(&BaseSrvDOSCriticalSection);
             return ((ULONG)STATUS_INVALID_PARAMETER);
        }
        else {
            RtlMoveMemory(b->lpszzCurDirs,
                          pConsoleRecord->lpszzCurDirs,
                          pConsoleRecord->cchCurDirs
                          );
            // remove it immediately after the copy. This is done because
            // the next command may be a WOW program(got tagged process handle
            // as VDM command)  and in that case we will return incorrect
            //information:
            // c:\>
            // c:\>d:
            // d:\>cd \foo
            // d:\foo>dosapp
            // d:\foo>c:
            // c:\>wowapp
            // d:\foo>  -- this is wrong if we don't do the following stuff.
            RtlFreeHeap(BaseSrvHeap, 0, pConsoleRecord->lpszzCurDirs);
            pConsoleRecord->lpszzCurDirs = NULL;
            b->cchCurDirs = pConsoleRecord->cchCurDirs;
            pConsoleRecord->cchCurDirs = 0;
         }
    }
    else {
        b->cchCurDirs = 0;
    }
    RtlLeaveCriticalSection(&BaseSrvDOSCriticalSection);
    return ((ULONG)STATUS_SUCCESS);
}



//
// temporary static desktop name buffer
// BUGBUG -- change when User gives me better return values
//
WCHAR wszDesktopName[MAX_PATH];

//
// This call produces a desktop name and optionally a shared wow running in the context
// of this particular desktop.
// extra bad: making conversion Uni->Ansi in client/vdm.c and ansi->Uni here
//               this is BUGBUG -- look into it later
//
// this function returns success in all the cases (including when wow is not found)
// and fails only if under-layers return failures

NTSTATUS
BaseSrvFindSharedWow(
   IN PBASE_CHECKVDM_MSG b,
   IN HANDLE UniqueProcessClientId,
   IN OUT PUNICODE_STRING   pDesktopName,
   IN OUT PSHAREDWOWRECORD* ppSharedWowRecord)

{
   ANSI_STRING DesktopNameAnsi;
   BOOLEAN fRevertToSelf;
   NTSTATUS Status;

   // the first time out, we have not dyna-linked NtUserResolveDesktopForWow, so
   // as an optimization, check to see if the list of shared wows is empty
   // see if we need to dyna-link
   if (NULL == BaseSrvUserResolveDesktopForWow) {
      Status = BaseSrvImportApis(rgBaseSrvModuleImport,
                                 sizeof(rgBaseSrvModuleImport)/sizeof(rgBaseSrvModuleImport[0]));
      if (!NT_SUCCESS(Status)) {
         KdPrint(("BaseSrvFindSharedWow: Failed to dyna-link apis\n"));
         return Status;
      }
   }

   if (b->DesktopLen == 0) {
      return STATUS_INVALID_PARAMETER;
   }

   ASSERT(NULL != BaseSrvUserResolveDesktopForWow);

   pDesktopName->Buffer = wszDesktopName;
   pDesktopName->MaximumLength = sizeof(wszDesktopName);

   DesktopNameAnsi.Buffer = b->Desktop;
   DesktopNameAnsi.Length = (USHORT)(b->DesktopLen - 1);
   DesktopNameAnsi.MaximumLength = (USHORT)(b->DesktopLen);

   RtlAnsiStringToUnicodeString(pDesktopName, &DesktopNameAnsi, FALSE);

   // now get the real desktop name there
   // impersonate
   fRevertToSelf = CsrImpersonateClient(NULL);
   if (!fRevertToSelf) {
       return STATUS_BAD_IMPERSONATION_LEVEL;
   }

   Status = BaseSrvUserResolveDesktopForWow(pDesktopName);


   CsrRevertToSelf();

   if (!NT_SUCCESS(Status)) {
      // show that desktop is not valid name here by invalidating the pointer to buffer
      pDesktopName->Buffer = NULL;
      pDesktopName->MaximumLength = 0;
      pDesktopName->Length = 0;
      return Status;
   }


   // now look for this dektop in our task list

  Status = BaseSrvFindSharedWowRecordByDesktop(&gWowHead,
                                                   pDesktopName,
                                                   ppSharedWowRecord);
  if (!NT_SUCCESS(Status)) {
      *ppSharedWowRecord = NULL;
  }



  return STATUS_SUCCESS;
}




ULONG
BaseSrvCheckWOW( //////////////////////////////////// NEW IMP
    IN PBASE_CHECKVDM_MSG b,
    IN HANDLE UniqueProcessClientId
    )
{
   NTSTATUS Status;
   HANDLE Handle,TargetHandle;
   PWOWRECORD pWOWRecord;
   INFORECORD InfoRecord;
   USHORT Len;
   LUID  ClientAuthId;
   DWORD dwThreadId, dwProcessId;
   PCSR_PROCESS Process;
   PSHAREDWOWRECORD pSharedWow = NULL;
   PSHAREDWOWRECORD pSharedWowPrev;
   UNICODE_STRING DesktopName;
   PCSR_PROCESS ParentProcess;
   HANDLE       WOWUserToken = NULL;

   Status = ENTER_WOW_CRITICAL();
   ASSERT( NT_SUCCESS( Status ) );

   // see if what we have in startup info matches any of the existing wow vdms
   DesktopName.Buffer = NULL;

   Status = BaseSrvFindSharedWow(b,
                                 UniqueProcessClientId,
                                 &DesktopName,
                                 &pSharedWow);

   if (!NT_SUCCESS(Status)) {
      ASSERT(FALSE);     // this is some sort of a system error
      b->DesktopLen = 0; // indicate desktop access was denied/not existing
      LEAVE_WOW_CRITICAL();
      return Status;
   }

   //
   // here we could either have succeeded and have a shared wow or not -
   // and hence have a desktop name in a global buffer pointed to by DesktopName.Buffer
   //

   if (NULL != pSharedWow) {
      BOOLEAN      fEqual;

      switch(pSharedWow->VDMState & VDM_READY) {

      case VDM_READY:
         // meaning: vdm ready to take a command
         // verify if the currently logged-on interactive user will be able to take out task
         //
         Status = OkToRunInSharedWOW( UniqueProcessClientId,
                                      &ClientAuthId,
                                      &WOWUserToken
                                      );

         if (NT_SUCCESS(Status)) {
             if (!RtlEqualLuid(&ClientAuthId, &pSharedWow->WowAuthId)) {
                 Status = STATUS_ACCESS_DENIED;
             }
             else if (b->UserLuid && !RtlEqualLuid(&ClientAuthId, b->UserLuid)) {
                 Status = STATUS_ACCESS_DENIED;
             }
             else if(!NT_SUCCESS(NtCompareTokens(WOWUserToken,pSharedWow->WOWUserToken,&fEqual) || !fEqual)) {
                 Status = STATUS_ACCESS_DENIED;
             }
         }

         if(WOWUserToken) {
            NtClose(WOWUserToken);
         }


         if (!NT_SUCCESS(Status))  {
            LEAVE_WOW_CRITICAL();
            return ((ULONG)Status);
         }


         // now we have verified that user 1) has access to this desktop
         //                                2) is a currently logged-on interactive user


         // Allocate a record for this wow task
         if (NULL == (pWOWRecord = BaseSrvAllocateWOWRecord(&gWowHead))) {
            Status = STATUS_NO_MEMORY;
            break; // failed with mem alloc  -- still holding task critical
         }

         // copy the command parameters

         InfoRecord.iTag = BINARY_TYPE_WIN16;
         InfoRecord.pRecord.pWOWRecord = pWOWRecord;

         if (BaseSrvCopyCommand (b,&InfoRecord) == FALSE){
            BaseSrvFreeWOWRecord(pWOWRecord);
            Status = STATUS_NO_MEMORY;
            break;  // holding task critical
         }

         // create pseudo handles

         Status = BaseSrvCreatePairWaitHandles (&Handle,&TargetHandle);

         if (!NT_SUCCESS(Status) ){
            BaseSrvFreeWOWRecord(pWOWRecord);
            break;
         }
         else {
            pWOWRecord->hWaitForParent = Handle;
            pWOWRecord->hWaitForParentServer = TargetHandle;
            b->WaitObjectForParent = TargetHandle; // give the handle back to the client
         }

         // set the state and task id, task id is allocated in BaseSrvAllocateWowRecord

         b->VDMState = VDM_PRESENT_AND_READY;
         b->iTask = pWOWRecord->iTask;

         // add wow record to this shared wow list

         BaseSrvAddWOWRecord (pSharedWow, pWOWRecord);

         // let User know we have been started

         if (NULL != UserNotifyProcessCreate) {
            (*UserNotifyProcessCreate)(pWOWRecord->iTask,
                                       (DWORD)((ULONG_PTR)CSR_SERVER_QUERYCLIENTTHREAD()->ClientId.UniqueThread),
                                       (DWORD)((ULONG_PTR)TargetHandle),
                                       0x04);
         }

         // see if the wowexec window exists and is valid

         if (NULL != pSharedWow->hwndWowExec) {

            //
            // Check to see if hwndWowExec still belongs to
            // the same thread/process ID before posting.
            //

            // BUGBUG -- debug code here -- not really needed

            dwThreadId = BaseSrvGetWindowThreadProcessId(pSharedWow->hwndWowExec,
                                                         &dwProcessId);

            if (dwThreadId) {
               ULONG SequenceNumber;
               Status = BaseSrvGetVdmSequence((HANDLE)LongToPtr(dwProcessId), &SequenceNumber);
               if (!NT_SUCCESS(Status) || SequenceNumber != pSharedWow->SequenceNumber) {
                   Status = STATUS_INVALID_PARAMETER;
               }
            }
            else {
               Status = STATUS_UNSUCCESSFUL;
               KdPrint(("BaseSrvCheckWOW: Not authentic wow by process seq number\n"));
               //
               // Spurious assert was here. The wow process has died while the message was incoming.
               //  The code below will cleanup appropriately
               //
            }

            if (dwThreadId  == pSharedWow->dwWowExecThreadId &&
                dwProcessId == pSharedWow->dwWowExecProcessId &&
                NT_SUCCESS(Status)) {

                HANDLE ThreadId;

                /*
                 * Set the csr thread's desktop temporarily to the client
                 * it is servicing
                 */


                BaseSrvPostMessageA((HWND)pSharedWow->hwndWowExec,
                                    WM_WOWEXECSTARTAPP,
                                    0,
                                    0);


            }
            else {

               //
               // Thread/process IDs don't match, so forget about this shared WOW.
               //

               if ( NT_SUCCESS(Status) ) {

                      KdPrint(("BaseSrvCheckWOW: Thread/Process IDs don't match, shared WOW is gone.\n"
                               "Saved PID 0x%x TID 0x%x hwndWowExec (0x%x) maps to \n"
                               "      PID 0x%x TID 0x%x\n",
                               pSharedWow->dwWowExecProcessId,
                               pSharedWow->dwWowExecThreadId,
                               pSharedWow->hwndWowExec,
                               dwProcessId,
                               dwThreadId));
               }

               // okay, panic! our internal list is in fact corrupted - remove the offending
               // entry


               // to do this we must have access -- relinquish control
               // and then re-aquire it

               BaseSrvDeleteSharedWowRecord(&gWowHead, pSharedWow);

                  // reset these values so that new shared wow is created
               pSharedWow = NULL;

            }

         }

         // ELSE
         // if pSharedWow->hwndWowExec == NULL our shared wow doesn't have a window yet.
         // however, it is ok to attach new wowrecord because we know shared wow's ntvdm is
         // still alive. if it wasn't it would have been cleaned up by the process clean-up
         // routine BaseSrvCleanupVDMResources.



         break; // case VDM_READY


       default:
          KdPrint(("BaseSrvCheckWOW: bad vdm state: 0x%lx\n", pSharedWow->VDMState));
          ASSERT(FALSE);  // how did I get into this mess ?
          break;
       }  // end switch
    }


    // if we are here then either :
    //   -- the first take on a shared wow failed
    //   -- the app was successfully handed off to wowexec for execution
    // if pSharedWow is NULL, then we have to start shared wow in this environment
    // as it was either not present or nuked due to seq number/id conflics
    //

    if (NULL == pSharedWow) {

       //
       // this check verifies command line for not being too long
       //
       if (b->CmdLen > MAXIMUM_VDM_COMMAND_LENGTH) {
          LEAVE_WOW_CRITICAL();
          return ((ULONG)STATUS_INVALID_PARAMETER);
       }

       //
       // Only the currently logged on interactive user can start the
       // shared wow. Verify if the caller is such, and if it is
       // store the Authentication Id of the client which identifies who
       // is allowed to run wow apps in the default ntvdm-wow process.
       //

       //
       // if needed, do a run-time link to UserTestTokenForInteractive,
       // which is used to verify the client luid.
       //

       // this dynalink is performed automatically using our all-out api
       // see above for dynalink source

       ASSERT (NULL != UserTestTokenForInteractive);


       ASSERT (NULL != DesktopName.Buffer); // yes, it should be valid

       //
       // see if we had desktop there. if not (the first time around!) - get it now
       // by calling FindSharedWow (which retrieves desktop as well)
       //

       //
       // If the caller isn't the currently logged on interactive user,
       // OkToRunInSharedWOW will fail with access denied.

       Status = OkToRunInSharedWOW(UniqueProcessClientId,
                                   &ClientAuthId,
                                   &WOWUserToken);

       if (NT_SUCCESS(Status)) {
          if (b->UserLuid && !RtlEqualLuid(&ClientAuthId, b->UserLuid)) {
              Status = STATUS_ACCESS_DENIED;
          }
       }

       if (!NT_SUCCESS(Status)) {
          if(WOWUserToken) {
             NtClose(WOWUserToken);
          }
          LEAVE_WOW_CRITICAL();
          return ((ULONG)Status);
       }

       //
       // Store the Autherntication Id since this now is the currently
       // logged on interactive user.
       //

       // produce a viable shared wow record
       // this process consists of 2 parts : producing a wow record and producing a
       // console record. the reason for this is to be able to identify this record
       // when the wow process had been created and is calling to update a record with it's
       // own handle (this is twise confusing, but just bear with me for a while).
       //
       // just as a dos program, we might need a temporary session id or a console id for the
       // creating process.


       pSharedWow = BaseSrvAllocateSharedWowRecord(&DesktopName);
       if (NULL == pSharedWow) {
          Status = STATUS_NO_MEMORY;
       }

       //
       // Store the WOWUserToken since this gives better granularity then just user id
       //
       pSharedWow->WOWUserToken = WOWUserToken;

       //
       // Store parent process sequence number until ntvdm
       // comes and gives its sequence number
       //

       Status = CsrLockProcessByClientId(UniqueProcessClientId,
                                  &ParentProcess);
       if (NT_SUCCESS(Status)) {
          pSharedWow->ParentSequenceNumber = ParentProcess->SequenceNumber;
          CsrUnlockProcess(ParentProcess);
       }



       if (NT_SUCCESS(Status)) {
          pSharedWow->pWOWRecord = BaseSrvAllocateWOWRecord(&gWowHead); // this is a new shared wow
          if (NULL == pSharedWow->pWOWRecord) {
             Status = STATUS_NO_MEMORY;
          }
       }


       if (NT_SUCCESS(Status)) {
          // here we have [successfully] allocated shared struct and a console record
          // and a wow record for the task

          // copy the command parameters

          InfoRecord.iTag = BINARY_TYPE_WIN16;
          InfoRecord.pRecord.pWOWRecord = pSharedWow->pWOWRecord;

          if(!BaseSrvCopyCommand (b, &InfoRecord)) {
             Status = STATUS_NO_MEMORY;
          }
       }

       if (NT_SUCCESS(Status)) {

#if 0
          pSharedWow->WowSessionId = BaseSrvGetWOWTaskId(&gWowHead);  // wow task id
#endif
          // store the retrieved auth id
          pSharedWow->WowAuthId = ClientAuthId;

          // link shared wow to the console...
          // set wow state to be ready
          pSharedWow->VDMState = VDM_READY;

          b->VDMState = VDM_NOT_PRESENT;
          b->iTask = pSharedWow->pWOWRecord->iTask;

          // now add this shared wow in --
          BaseSrvAddSharedWowRecord(&gWowHead, pSharedWow);

       }
       else {

          // this has not succeeded. cleanup
          if (NULL != pSharedWow) {
             BaseSrvFreeSharedWowRecord(pSharedWow);
          }
       }

   }


   LEAVE_WOW_CRITICAL();
   return (ULONG)Status;

}


NTSTATUS
OkToRunInSharedWOW(
    IN  HANDLE UniqueProcessClientId,
    OUT PLUID  pAuthenticationId,
    OUT PHANDLE pWOWUserToken
    )
/*
 * Verifies that the client thread is in the currently logged on interactive
 * user session or is SYSTEM impersonating a thread in the currently logged
 * on interactive session.
 *
 * Also retrieves the the authentication ID (logon session Id) for the
 * caller.
 *
 * if the clients TokenGroups is not part of the currently logged on
 * interactive user session STATUS_ACCESS_DENIED is returned.
 *
 */
{
    NTSTATUS Status;
    PCSR_PROCESS    Process;
    PCSR_THREAD     t;
    BOOL fRevertToSelf;

    Status = CsrLockProcessByClientId(UniqueProcessClientId,&Process);
    if (!NT_SUCCESS(Status))
        return Status;

    //
    // Open a token for the client
    //
    Status = NtOpenProcessToken(Process->ProcessHandle,
                                TOKEN_QUERY,
                                pWOWUserToken
                               );

    if (!NT_SUCCESS(Status)) {
        CsrUnlockProcess(Process);
        return Status;
        }

    //
    // Verify the token Group, and see if client's token is the currently
    // logged on interactive user. If this fails and it is System
    // impersonating, then check if the client being impersonated is the
    // currently logged on interactive user.
    //

    Status = (*UserTestTokenForInteractive)(*pWOWUserToken, pAuthenticationId);

    if (!NT_SUCCESS(Status)) {
        if (IsClientSystem(*pWOWUserToken)) {
            NtClose(*pWOWUserToken);
            *pWOWUserToken = NULL;

            //  get impersonation token

            fRevertToSelf = CsrImpersonateClient(NULL);
            if(!fRevertToSelf) {
               Status = STATUS_BAD_IMPERSONATION_LEVEL;
               }
            else {
               t = CSR_SERVER_QUERYCLIENTTHREAD();
               Status = NtOpenThreadToken(t->ThreadHandle,
                                          TOKEN_QUERY,
                                          TRUE,
                                          pWOWUserToken);

               CsrRevertToSelf();

               if (NT_SUCCESS(Status)) {
                   Status = (*UserTestTokenForInteractive)(*pWOWUserToken,
                                                        pAuthenticationId);
                   }
               else {
                   Status = STATUS_ACCESS_DENIED;
                   }
               }
            }
        }

    CsrUnlockProcess(Process);
    return(Status);
}

NTSTATUS
BaseSrvGetUserToken(
    IN  HANDLE UniqueProcessClientId,
    OUT PHANDLE pUserToken
    )
/*
 *
 * retrieves the the authentication ID (logon session Id) for the
 * caller.
 *
 */
{
    NTSTATUS Status;
    PCSR_PROCESS    Process;
    PCSR_THREAD     tCsr;
    BOOL fRevertToSelf;

    Status = CsrLockProcessByClientId(UniqueProcessClientId,&Process);
    if (!NT_SUCCESS(Status))
        return Status;

    fRevertToSelf = CsrImpersonateClient(NULL);

    if (!fRevertToSelf) {
        Status = STATUS_BAD_IMPERSONATION_LEVEL;
       }
    else {
        tCsr = CSR_SERVER_QUERYCLIENTTHREAD();
        Status = NtOpenThreadToken(tCsr->ThreadHandle,
                                   TOKEN_QUERY,
                                   TRUE,
                                   pUserToken);
         CsrRevertToSelf();
    }

    if(Status ==  STATUS_NO_TOKEN) {
       //
       // Open a token for the client
       //
       Status = NtOpenProcessToken(Process->ProcessHandle,
                                   TOKEN_QUERY,
                                   pUserToken
                                   );
       }

    CsrUnlockProcess(Process);
    return(Status);
}

ULONG
BaseSrvCheckDOS(
    IN PBASE_CHECKVDM_MSG b,
    IN HANDLE UniqueProcessClientId
    )
{
    NTSTATUS Status;
    PCONSOLERECORD pConsoleRecord = NULL;
    HANDLE Handle,TargetHandle;
    PDOSRECORD pDOSRecord;
    INFORECORD InfoRecord;
    PCSR_PROCESS ParentProcess;
    HANDLE       UserToken;
    BOOLEAN      fEqual;

    if (!NT_SUCCESS(BaseSrvGetUserToken(UniqueProcessClientId,&UserToken))) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );

    Status = BaseSrvGetConsoleRecord(b->ConsoleHandle,&pConsoleRecord);

    if ( NT_SUCCESS(Status) ) {
        Status = NtCompareTokens(UserToken,pConsoleRecord->DosUserToken,&fEqual);
        NtClose(UserToken);

        if(!NT_SUCCESS(Status) || !fEqual) {
            RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
            return STATUS_INVALID_PARAMETER;
        }

        pDOSRecord = pConsoleRecord->DOSRecord;

        ASSERT (pDOSRecord != NULL);

        switch( pDOSRecord->VDMState){

            case VDM_READY:
            case VDM_HAS_RETURNED_ERROR_CODE:

                InfoRecord.iTag = BINARY_TYPE_DOS;
                InfoRecord.pRecord.pDOSRecord = pDOSRecord;

                if(!BaseSrvCopyCommand (b,&InfoRecord)) {
                    Status = STATUS_NO_MEMORY;
                    break;
                    }

                if (!NT_SUCCESS ( Status = BaseSrvDupStandardHandles (
                                                pConsoleRecord->hVDM,
                                                pDOSRecord)))

                    break;

                Status = BaseSrvCreatePairWaitHandles (&Handle,&TargetHandle);

                if (!NT_SUCCESS(Status) ){
                    BaseSrvCloseStandardHandles (pConsoleRecord->hVDM, pDOSRecord);
                    break;
                    }
                else {
                    b->WaitObjectForParent = TargetHandle;
                    pDOSRecord->hWaitForParent = TargetHandle;
                    pDOSRecord->hWaitForParentDup = Handle;
                }

                pDOSRecord->VDMState = VDM_TO_TAKE_A_COMMAND;

                b->VDMState = VDM_PRESENT_AND_READY;

                if(pConsoleRecord->hWaitForVDMDup)
                    NtSetEvent (pConsoleRecord->hWaitForVDMDup,NULL);

                break;

            case VDM_BUSY:
            case VDM_TO_TAKE_A_COMMAND:

                if((pDOSRecord = BaseSrvAllocateDOSRecord()) == NULL){
                    Status = STATUS_NO_MEMORY ;
                    break;
                    }

                InfoRecord.iTag = BINARY_TYPE_DOS;
                InfoRecord.pRecord.pDOSRecord = pDOSRecord;

                if(!BaseSrvCopyCommand(b, &InfoRecord)){
                    Status = STATUS_NO_MEMORY ;
                    BaseSrvFreeDOSRecord(pDOSRecord);
                    break;
                    }

                Status = BaseSrvCreatePairWaitHandles(&Handle,&TargetHandle);
                if (!NT_SUCCESS(Status) ){
                    BaseSrvFreeDOSRecord(pDOSRecord);
                    break;
                    }
                else {
                    b->WaitObjectForParent = TargetHandle;
                    pDOSRecord->hWaitForParentDup = Handle;
                    pDOSRecord->hWaitForParent = TargetHandle;
                    }


                Status = BaseSrvDupStandardHandles(pConsoleRecord->hVDM, pDOSRecord);
                if (!NT_SUCCESS(Status)) {
                    BaseSrvClosePairWaitHandles (pDOSRecord);
                    BaseSrvFreeDOSRecord(pDOSRecord);
                    break;
                    }

                BaseSrvAddDOSRecord(pConsoleRecord,pDOSRecord);
                b->VDMState = VDM_PRESENT_AND_READY;
                if (pConsoleRecord->nReEntrancy) {
                    if(pConsoleRecord->hWaitForVDMDup)
                        NtSetEvent (pConsoleRecord->hWaitForVDMDup,NULL);
                }
                pDOSRecord->VDMState = VDM_TO_TAKE_A_COMMAND;

                break;

            default:
                ASSERT(FALSE);
            }
        }


    if (pConsoleRecord == NULL) {

        pConsoleRecord = BaseSrvAllocateConsoleRecord ();

        if (pConsoleRecord == NULL)
            Status = STATUS_NO_MEMORY ;

        else {

            pConsoleRecord->DOSRecord = BaseSrvAllocateDOSRecord();
            if(!pConsoleRecord->DOSRecord) {
                BaseSrvFreeConsoleRecord(pConsoleRecord);
                RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
                return (ULONG)STATUS_NO_MEMORY;
                }

            Status = CsrLockProcessByClientId(UniqueProcessClientId,
                               &ParentProcess);

            if (!NT_SUCCESS(Status)) {
               BaseSrvFreeConsoleRecord(pConsoleRecord);
               RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
               return Status;
            }

            pConsoleRecord->ParentSequenceNumber = ParentProcess->SequenceNumber;
            CsrUnlockProcess(ParentProcess);
            pConsoleRecord->DosUserToken = UserToken;

            InfoRecord.iTag = b->BinaryType;
            InfoRecord.pRecord.pDOSRecord = pConsoleRecord->DOSRecord;


            if(!BaseSrvCopyCommand(b, &InfoRecord)) {
                BaseSrvFreeConsoleRecord(pConsoleRecord);
                RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
                return (ULONG)STATUS_NO_MEMORY;
                }


            pConsoleRecord->hConsole = b->ConsoleHandle;


                // if no console for this ntvdm
                // get a temporary session ID and pass it to the client
            if (!pConsoleRecord->hConsole) {
                b->iTask = pConsoleRecord->DosSesId = GetNextDosSesId();
                }
             else {
                b->iTask = pConsoleRecord->DosSesId = 0;
                }

            pConsoleRecord->DOSRecord->VDMState = VDM_TO_TAKE_A_COMMAND;

            BaseSrvAddConsoleRecord(pConsoleRecord);
            b->VDMState = VDM_NOT_PRESENT;
            Status = STATUS_SUCCESS;
            }
        }

    RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );

    return Status;
}


BOOL
BaseSrvCopyCommand(
    PBASE_CHECKVDM_MSG b,
    PINFORECORD pInfoRecord
    )
{
    PVDMINFO VDMInfo;

    if((VDMInfo = RtlAllocateHeap(RtlProcessHeap (), MAKE_TAG( VDM_TAG ),sizeof(VDMINFO))) == NULL){
        return FALSE;
        }

    VDMInfo->CmdLine = RtlAllocateHeap(RtlProcessHeap (), MAKE_TAG( VDM_TAG ),b->CmdLen);

    if (b->AppLen) {
        VDMInfo->AppName = RtlAllocateHeap(RtlProcessHeap (), MAKE_TAG( VDM_TAG ),b->AppLen);
        }
    else
        VDMInfo->AppName = NULL;

    if (b->PifLen)
        VDMInfo->PifFile = RtlAllocateHeap(RtlProcessHeap (), MAKE_TAG( VDM_TAG ),b->PifLen);
    else
        VDMInfo->PifFile = NULL;

    if (b->CurDirectoryLen)
        VDMInfo->CurDirectory = RtlAllocateHeap(RtlProcessHeap (), MAKE_TAG( VDM_TAG ),b->CurDirectoryLen);
    else
        VDMInfo->CurDirectory = NULL;

    if (b->EnvLen)
        VDMInfo->Enviornment = RtlAllocateHeap(RtlProcessHeap (), MAKE_TAG( VDM_TAG ),b->EnvLen);
    else
        VDMInfo->Enviornment = NULL;

    if (b->DesktopLen)
        VDMInfo->Desktop = RtlAllocateHeap(RtlProcessHeap (), MAKE_TAG( VDM_TAG ),b->DesktopLen);
    else
        VDMInfo->Desktop = NULL;

    if (b->TitleLen)
        VDMInfo->Title = RtlAllocateHeap(RtlProcessHeap (), MAKE_TAG( VDM_TAG ),b->TitleLen);
    else
        VDMInfo->Title = NULL;

    if (b->ReservedLen)
        VDMInfo->Reserved = RtlAllocateHeap(RtlProcessHeap (), MAKE_TAG( VDM_TAG ),b->ReservedLen);
    else
        VDMInfo->Reserved = NULL;

    // check that all the allocations were successful
    if (VDMInfo->CmdLine == NULL ||
        (b->AppLen && VDMInfo->AppName == NULL) ||
        (b->PifLen && VDMInfo->PifFile == NULL) ||
        (b->CurDirectoryLen && VDMInfo->CurDirectory == NULL) ||
        (b->EnvLen &&  VDMInfo->Enviornment == NULL) ||
        (b->DesktopLen && VDMInfo->Desktop == NULL )||
        (b->ReservedLen && VDMInfo->Reserved == NULL )||
        (b->TitleLen && VDMInfo->Title == NULL)) {

        BaseSrvFreeVDMInfo(VDMInfo);

        return FALSE;
    }


    RtlMoveMemory(VDMInfo->CmdLine,
                  b->CmdLine,
                  b->CmdLen);

    VDMInfo->CmdSize = b->CmdLen;


    if (b->AppLen) {
        RtlMoveMemory(VDMInfo->AppName,
                      b->AppName,
                      b->AppLen);
    }

    VDMInfo->AppLen = b->AppLen;

    if (b->PifLen) {
        RtlMoveMemory(VDMInfo->PifFile,
                      b->PifFile,
                      b->PifLen);
    }

    VDMInfo->PifLen = b->PifLen;

    if (b->CurDirectoryLen) {
        RtlMoveMemory(VDMInfo->CurDirectory,
                      b->CurDirectory,
                      b->CurDirectoryLen);
    }
    VDMInfo->CurDirectoryLen = b->CurDirectoryLen;

    if (b->EnvLen) {
        RtlMoveMemory(VDMInfo->Enviornment,
                      b->Env,
                      b->EnvLen);
    }
    VDMInfo->EnviornmentSize = b->EnvLen;

    if (b->DesktopLen) {
        RtlMoveMemory(VDMInfo->Desktop,
                      b->Desktop,
                      b->DesktopLen);
    }
    VDMInfo->DesktopLen = b->DesktopLen;

    if (b->TitleLen) {
        RtlMoveMemory(VDMInfo->Title,
                      b->Title,
                      b->TitleLen);
    }
    VDMInfo->TitleLen = b->TitleLen;

    if (b->ReservedLen) {
        RtlMoveMemory(VDMInfo->Reserved,
                      b->Reserved,
                      b->ReservedLen);
    }

    VDMInfo->ReservedLen = b->ReservedLen;

    if (b->StartupInfo) {
        RtlMoveMemory(&VDMInfo->StartupInfo,
                      b->StartupInfo,
                      sizeof (STARTUPINFOA));
        VDMInfo->VDMState = STARTUP_INFO_RETURNED;
    }
    else
        VDMInfo->VDMState = 0;

    VDMInfo->dwCreationFlags = b->dwCreationFlags;
    VDMInfo->CurDrive = b->CurDrive;
    VDMInfo->CodePage = b->CodePage;

    // ATTENTION THIS CODE ASSUMES THAT WOWRECORD AND DOSRECORD HAVE THE SAME LAYOUT
    // THIS IS BAD BAD BAD  -- fix later BUGBUG
    //

    if (pInfoRecord->iTag == BINARY_TYPE_WIN16) {
       pInfoRecord->pRecord.pWOWRecord->lpVDMInfo = VDMInfo;
    }
    else {
       pInfoRecord->pRecord.pDOSRecord->lpVDMInfo = VDMInfo;
    }

    VDMInfo->StdIn = VDMInfo->StdOut = VDMInfo->StdErr = 0;
    if(pInfoRecord->iTag == BINARY_TYPE_DOS) {
        VDMInfo->StdIn  = b->StdIn;
        VDMInfo->StdOut = b->StdOut;
        VDMInfo->StdErr = b->StdErr;
        }
    else if (pInfoRecord->iTag == BINARY_TYPE_WIN16) {
        pInfoRecord->pRecord.pWOWRecord->fDispatched = FALSE;
        }


    // else if (pInfoRecord->iTag == BINARY_TYPE_SEPWOW)


    return TRUE;
}

ULONG
BaseSrvUpdateWOWEntry(
    PBASE_UPDATE_VDM_ENTRY_MSG b,
    ULONG ParentSequenceNumber
    )
{
    NTSTATUS Status;
    PSHAREDWOWRECORD pSharedWow;
    PWOWRECORD pWOWRecord;
    HANDLE Handle,TargetHandle;

    Status = ENTER_WOW_CRITICAL();
    ASSERT( NT_SUCCESS( Status ) );

    // this is fun -- we get the the record using the task id
    // reason: the call is made from the context of a creator process
    // hence console handle means nothing

    Status = BaseSrvFindSharedWowRecordByTaskId(&gWowHead,
                                                b->iTask,
                                                &pSharedWow,
                                                &pWOWRecord);
    // this returns us the shared wow record and wow record

    if ( NT_SUCCESS(Status) ) {

        if (ParentSequenceNumber != pSharedWow->ParentSequenceNumber) {
            Status = STATUS_INVALID_PARAMETER;
            goto UpdateWowEntryExit;
        }

        switch ( b->EntryIndex ){

            case UPDATE_VDM_PROCESS_HANDLE:
                Status = STATUS_SUCCESS;
                break;

            case UPDATE_VDM_UNDO_CREATION:
                if( b->VDMCreationState & VDM_BEING_REUSED ||
                        b->VDMCreationState & VDM_FULLY_CREATED){
                    NtClose(pWOWRecord->hWaitForParent);
                    pWOWRecord->hWaitForParent = 0;
                }

                if( b->VDMCreationState & VDM_PARTIALLY_CREATED ||
                        b->VDMCreationState & VDM_FULLY_CREATED){

                    BaseSrvRemoveWOWRecord (pSharedWow, pWOWRecord);
                    BaseSrvFreeWOWRecord (pWOWRecord);

                    if (NULL == pSharedWow->pWOWRecord) {
                       Status = BaseSrvDeleteSharedWowRecord(&gWowHead, pSharedWow);
                    }
                }
                break;

            default:
                ASSERT(FALSE);
            }
        }


    if (!NT_SUCCESS(Status) )
        goto UpdateWowEntryExit;

    switch ( b->EntryIndex ){
        case UPDATE_VDM_PROCESS_HANDLE:
            Status = BaseSrvCreatePairWaitHandles (&Handle,&TargetHandle);

            if (NT_SUCCESS(Status) ){
                pWOWRecord->hWaitForParent = Handle;
                pWOWRecord->hWaitForParentServer = TargetHandle;
                b->WaitObjectForParent = TargetHandle;
                if (UserNotifyProcessCreate != NULL) {
                    (*UserNotifyProcessCreate)(pWOWRecord->iTask,
                                (DWORD)((ULONG_PTR)CSR_SERVER_QUERYCLIENTTHREAD()->ClientId.UniqueThread),
                                (DWORD)((ULONG_PTR)TargetHandle),
                                 0x04);
                    }
                }
            break;

        case UPDATE_VDM_UNDO_CREATION:
        case UPDATE_VDM_HOOKED_CTRLC:
            break;

        default:
            ASSERT(FALSE);
            break;

        }


UpdateWowEntryExit:
    LEAVE_WOW_CRITICAL();
    return Status;
}

ULONG
BaseSrvUpdateDOSEntry(
    PBASE_UPDATE_VDM_ENTRY_MSG b,
    ULONG ParentSequenceNumber
    )
{
    NTSTATUS Status;
    PDOSRECORD pDOSRecord;
    PCONSOLERECORD pConsoleRecord = NULL;
    HANDLE Handle,TargetHandle;
    PCSR_THREAD t;

    Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
    ASSERT( NT_SUCCESS( Status ) );

    if (b->iTask)
        Status = GetConsoleRecordDosSesId(b->iTask,&pConsoleRecord);
    else
        Status = BaseSrvGetConsoleRecord(b->ConsoleHandle,&pConsoleRecord);

    if ( NT_SUCCESS(Status) ) {

        if (ParentSequenceNumber != pConsoleRecord->ParentSequenceNumber) {
            Status = STATUS_INVALID_PARAMETER;
            goto UpdateDosEntryExit;
        }

        pDOSRecord = pConsoleRecord->DOSRecord;

        switch ( b->EntryIndex ){

            case UPDATE_VDM_PROCESS_HANDLE:

                t = CSR_SERVER_QUERYCLIENTTHREAD();
                Status = NtDuplicateObject (
                            t->Process->ProcessHandle,
                            b->VDMProcessHandle,
                            NtCurrentProcess(),
                            &pConsoleRecord->hVDM,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS
                            );

                break;

            case UPDATE_VDM_UNDO_CREATION:
                if( b->VDMCreationState & VDM_BEING_REUSED ||
                        b->VDMCreationState & VDM_FULLY_CREATED){
                    NtClose(pDOSRecord->hWaitForParentDup);
                    pDOSRecord->hWaitForParentDup = 0;
                    }
                if( b->VDMCreationState & VDM_PARTIALLY_CREATED ||
                        b->VDMCreationState & VDM_FULLY_CREATED){

                    BaseSrvRemoveDOSRecord (pConsoleRecord,pDOSRecord);
                    BaseSrvFreeDOSRecord (pDOSRecord);
                    if (pConsoleRecord->DOSRecord == NULL) {
                        if (b->VDMCreationState & VDM_FULLY_CREATED) {
                            if (pConsoleRecord->hVDM)
                                NtClose(pConsoleRecord->hVDM);
                            }
                        BaseSrvFreeConsoleRecord(pConsoleRecord);
                        }
                    }
                break;

            case UPDATE_VDM_HOOKED_CTRLC:
                break;
            default:
                ASSERT(FALSE);
            }
        }


    if (!NT_SUCCESS(Status) )
        goto UpdateDosEntryExit;

    switch ( b->EntryIndex ){
        case UPDATE_VDM_PROCESS_HANDLE:
            // williamh, Oct 24, 1996.
            // if the ntvdm is runnig on a new console, do NOT subsititue
            // the given process handle with event. The caller(CreateProcess)
            // will get the real process handle and so does the application
            // who calls CreateProcess. When it is time for the application
            // to call GetExitCodeProcess, the client side will return the
            // right thing(on the server side, we have nothing because
            // console and dos record are gone).
            //
            // VadimB: this code fixes the problem with GetExitCodeProcess
            //         in a way that is not too consistent. We should review
            //         TerminateProcess code along with the code that deletes
            //         pseudo-handles for processes (in this file) to account for
            //         outstanding handle references. For now this code also
            //         makes terminateprocess work on the handle we return
            //
            if ((!pConsoleRecord->DosSesId && b->BinaryType == BINARY_TYPE_DOS)) {
                Status = BaseSrvCreatePairWaitHandles (&Handle,&TargetHandle);

                if (NT_SUCCESS(Status) ){
                    if (NT_SUCCESS ( Status = BaseSrvDupStandardHandles (
                                                    pConsoleRecord->hVDM,
                                                    pDOSRecord))){
                        pDOSRecord->hWaitForParent = TargetHandle;
                        pDOSRecord->hWaitForParentDup = Handle;
                        b->WaitObjectForParent = TargetHandle;
                        }
                    else{
                        BaseSrvClosePairWaitHandles (pDOSRecord);
                        }
                    }
                }
            else {
                pDOSRecord->hWaitForParent = NULL;
                pDOSRecord->hWaitForParentDup = NULL;
                b->WaitObjectForParent = NULL;
                }

            break;

        case UPDATE_VDM_UNDO_CREATION:
        case UPDATE_VDM_HOOKED_CTRLC:
            break;

        default:
            ASSERT(FALSE);
            break;
        }

UpdateDosEntryExit:
    RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
    return Status;
}


PWOWRECORD
BaseSrvCheckAvailableWOWCommand(
   PSHAREDWOWRECORD pSharedWow
    )
{

   PWOWRECORD pWOWRecord;

   if (NULL == pSharedWow)
      return NULL;

   pWOWRecord = pSharedWow->pWOWRecord;

   while(NULL != pWOWRecord) {
      if (pWOWRecord->fDispatched == FALSE) {
         break;
      }
      pWOWRecord = pWOWRecord->WOWRecordNext;

   }
   return pWOWRecord;
}

// this function exits given wow task running in a given shared wow
//

NTSTATUS
BaseSrvExitWOWTask(
    PBASE_EXIT_VDM_MSG b,
    ULONG SequenceNumber
    )
{
   NTSTATUS Status;
   PSHAREDWOWRECORD pSharedWow;

   // now we might get burned here -- although unlikely

   // find shared wow first

   Status = ENTER_WOW_CRITICAL();
   ASSERT(NT_SUCCESS(Status));

   Status = BaseSrvFindSharedWowRecordByConsoleHandle(&gWowHead,
                                                      b->ConsoleHandle,
                                                      &pSharedWow);

   if (NT_SUCCESS(Status)) {

      if(SequenceNumber != pSharedWow->SequenceNumber) {
         Status = STATUS_INVALID_PARAMETER;
      }
      else if (-1 == b->iWowTask) { // the entire vdm goes

         // remove from the chain first
         Status = BaseSrvDeleteSharedWowRecord(&gWowHead,
                                            pSharedWow);
      }
      else {
         Status = BaseSrvRemoveWOWRecordByTaskId(pSharedWow,
                                                 b->iWowTask);

      }
   }

   LEAVE_WOW_CRITICAL();
   return Status;
}


NTSTATUS
BaseSrvExitDOSTask(
    PBASE_EXIT_VDM_MSG b,
    ULONG SequenceNumber
    )
{
   NTSTATUS Status;
   PDOSRECORD pDOSRecord;
   PCONSOLERECORD pConsoleRecord = NULL;

   Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
   ASSERT( NT_SUCCESS( Status ) );

   Status = BaseSrvGetConsoleRecord(b->ConsoleHandle,&pConsoleRecord);

   if (!NT_SUCCESS (Status) || SequenceNumber != pConsoleRecord->SequenceNumber) {
       RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
       return ((ULONG)STATUS_INVALID_PARAMETER);
       }

   if (pConsoleRecord->hWaitForVDMDup){
       NtClose(pConsoleRecord->hWaitForVDMDup);
       pConsoleRecord->hWaitForVDMDup =0;
       b->WaitObjectForVDM = pConsoleRecord->hWaitForVDM;
   }

   pDOSRecord = pConsoleRecord->DOSRecord;
   while (pDOSRecord) {
       if (pDOSRecord->hWaitForParentDup) {
           NtSetEvent (pDOSRecord->hWaitForParentDup,NULL);
           NtClose (pDOSRecord->hWaitForParentDup);
           pDOSRecord->hWaitForParentDup = 0;
       }
       pDOSRecord = pDOSRecord->DOSRecordNext;
   }
   NtClose(pConsoleRecord->hVDM);

   BaseSrvFreeConsoleRecord (pConsoleRecord);

   RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );

   return Status;
}

// assumes: shared wow cs is being held
//          iWowTask is valid

NTSTATUS
BaseSrvRemoveWOWRecordByTaskId (
    IN PSHAREDWOWRECORD pSharedWow,
    IN ULONG iWowTask
    )
{
   PWOWRECORD pWOWRecordLast = NULL, pWOWRecord;

   if (pSharedWow == NULL) {
      return STATUS_INVALID_PARAMETER;
   }

   pWOWRecord = pSharedWow->pWOWRecord;

      // Find the right WOW record and free it.
   while (NULL != pWOWRecord) {

      if (pWOWRecord->iTask == iWowTask) {

         if (NULL == pWOWRecordLast) {
            pSharedWow->pWOWRecord = pWOWRecord->WOWRecordNext;
         }
         else {
            pWOWRecordLast->WOWRecordNext = pWOWRecord->WOWRecordNext;
         }

         if(pWOWRecord->hWaitForParent) {
            NtSetEvent (pWOWRecord->hWaitForParent,NULL);
            NtClose (pWOWRecord->hWaitForParent);            
            pWOWRecord->hWaitForParent = 0;
         }
         BaseSrvFreeWOWRecord(pWOWRecord);

         return STATUS_SUCCESS;
      }

      pWOWRecordLast = pWOWRecord;
      pWOWRecord = pWOWRecord->WOWRecordNext;
   }

   return STATUS_NOT_FOUND;
}


ULONG
BaseSrvGetVDMExitCode( ///////// BUGBUG -- fixme
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status;
    PCONSOLERECORD pConsoleRecord = NULL;
    PDOSRECORD pDOSRecord;
    PBASE_GET_VDM_EXIT_CODE_MSG b = (PBASE_GET_VDM_EXIT_CODE_MSG)&m->u.ApiMessageData;

    if (b->ConsoleHandle == (HANDLE)-1){
        b->ExitCode =    0;
        }
    else{


        Status = RtlEnterCriticalSection( &BaseSrvDOSCriticalSection );
        ASSERT( NT_SUCCESS( Status ) );
        Status = BaseSrvGetConsoleRecord (b->ConsoleHandle,&pConsoleRecord);
        if (!NT_SUCCESS(Status)){
            b->ExitCode =   0;
            RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
            return STATUS_SUCCESS;
            }

        pDOSRecord = pConsoleRecord->DOSRecord;
        while (pDOSRecord) {
            // sudeepb 05-Oct-1992
            // fix for the change markl has made for tagging VDM handles

            if (pDOSRecord->hWaitForParent == (HANDLE)((ULONG_PTR)b->hParent & ~0x1)) {
                if (pDOSRecord->VDMState == VDM_HAS_RETURNED_ERROR_CODE){
                    b->ExitCode = pDOSRecord->ErrorCode;
                    if (pDOSRecord == pConsoleRecord->DOSRecord &&
                        pDOSRecord->DOSRecordNext == NULL)
                       {
                        pDOSRecord->VDMState = VDM_READY;
                        pDOSRecord->hWaitForParent = 0;
                        }
                    else {
                        BaseSrvRemoveDOSRecord (pConsoleRecord,pDOSRecord);
                        BaseSrvFreeDOSRecord(pDOSRecord);
                        }
                    }
                else {
                    if (pDOSRecord->VDMState == VDM_READY)
                        b->ExitCode = pDOSRecord->ErrorCode;
                    else
                        b->ExitCode = STILL_ACTIVE;
                    }
                break;
            }
            else
                pDOSRecord = pDOSRecord->DOSRecordNext;
        }

        if (pDOSRecord == NULL)
            b->ExitCode = 0;

        RtlLeaveCriticalSection( &BaseSrvDOSCriticalSection );
        }

    return STATUS_SUCCESS;
}


ULONG BaseSrvDupStandardHandles(
    IN HANDLE     pVDMProc,
    IN PDOSRECORD pDOSRecord
    )
{
    NTSTATUS Status;
    HANDLE pSrcProc;
    HANDLE StdOutTemp = NULL;
    PCSR_THREAD t;
    PVDMINFO pVDMInfo = pDOSRecord->lpVDMInfo;

    t = CSR_SERVER_QUERYCLIENTTHREAD();
    pSrcProc = t->Process->ProcessHandle;

    if (pVDMInfo->StdIn){
        Status = NtDuplicateObject (
                            pSrcProc,
                            pVDMInfo->StdIn,
                            pVDMProc,
                            &pVDMInfo->StdIn,
                            0,
                            OBJ_INHERIT,
                            DUPLICATE_SAME_ACCESS
                         );
        if (!NT_SUCCESS (Status))
            return Status;
        }

    if (pVDMInfo->StdOut){
        StdOutTemp = pVDMInfo->StdOut;
        Status = NtDuplicateObject (
                            pSrcProc,
                            pVDMInfo->StdOut,
                            pVDMProc,
                            &pVDMInfo->StdOut,
                            0,
                            OBJ_INHERIT,
                            DUPLICATE_SAME_ACCESS
                         );
        if (!NT_SUCCESS (Status))
            return Status;
        }

    if (pVDMInfo->StdErr){
        if(pVDMInfo->StdErr != StdOutTemp){
            Status = NtDuplicateObject (
                            pSrcProc,
                            pVDMInfo->StdErr,
                            pVDMProc,
                            &pVDMInfo->StdErr,
                            0,
                            OBJ_INHERIT,
                            DUPLICATE_SAME_ACCESS
                         );
            if (!NT_SUCCESS (Status))
                return Status;
            }
        else
            pVDMInfo->StdErr = pVDMInfo->StdOut;
        }

    return STATUS_SUCCESS;
}


// Generates a DosSesId which is unique and nonzero
ULONG GetNextDosSesId(VOID)
{
  static BOOLEAN bWrap = FALSE;
  static ULONG NextSesId=1;
  ULONG ul;
  PCONSOLERECORD pConsoleHead;

  pConsoleHead = DOSHead;
  ul = NextSesId;

  if (bWrap)  {
      while (pConsoleHead) {
          if (!pConsoleHead->hConsole && pConsoleHead->DosSesId == ul)
             {
              pConsoleHead = DOSHead;
              ul++;
              if (!ul) {  // never use zero
                  bWrap = TRUE;
                  ul++;
                  }
              }
          else {
              pConsoleHead = pConsoleHead->Next;
              }
          }
      }

  NextSesId = ul + 1;
  if (!NextSesId) {   // never use zero
      bWrap = TRUE;
      NextSesId++;
      }
  return ul;
}




NTSTATUS BaseSrvGetConsoleRecord (
    IN HANDLE hConsole,
    IN OUT PCONSOLERECORD *pConsoleRecord
    )
{
    PCONSOLERECORD pConsoleHead;

    pConsoleHead = DOSHead;

    if (hConsole) {
        while (pConsoleHead) {
            if (pConsoleHead->hConsole == hConsole){
                    *pConsoleRecord = pConsoleHead;
                    return STATUS_SUCCESS;
                }
            else
                pConsoleHead = pConsoleHead->Next;
        }
    }

    return STATUS_INVALID_PARAMETER;
}



NTSTATUS
GetConsoleRecordDosSesId (
    IN ULONG  DosSesId,
    IN OUT PCONSOLERECORD *pConsoleRecord
    )
{
    PCONSOLERECORD pConsoleHead;

    if (!DosSesId)
        return STATUS_INVALID_PARAMETER;

    pConsoleHead = DOSHead;

    while (pConsoleHead) {
        if (!pConsoleHead->hConsole &&
            pConsoleHead->DosSesId == DosSesId)
           {
            *pConsoleRecord = pConsoleHead;
            return STATUS_SUCCESS;
            }
        else
            pConsoleHead = pConsoleHead->Next;
    }

    return STATUS_INVALID_PARAMETER;
}



PWOWRECORD
BaseSrvAllocateWOWRecord(
   PSHAREDWOWRECORDHEAD pSharedWowRecordHead
   )
{
    register PWOWRECORD WOWRecord;

    WOWRecord = RtlAllocateHeap ( RtlProcessHeap (), MAKE_TAG( VDM_TAG ), sizeof (WOWRECORD));

    if (WOWRecord == NULL)
        return NULL;

    RtlZeroMemory ((PVOID)WOWRecord,sizeof(WOWRECORD));

    // if too many tasks, error out.
    if ((WOWRecord->iTask = BaseSrvGetWOWTaskId(pSharedWowRecordHead)) == WOWMAXID) {
        RtlFreeHeap(RtlProcessHeap(), 0, WOWRecord);
        return NULL;
        }
    return WOWRecord;
}

VOID BaseSrvFreeWOWRecord (
    PWOWRECORD pWOWRecord
    )
{
    if (pWOWRecord == NULL)
        return;
    if (pWOWRecord->pFilePath) {
        RtlFreeHeap(RtlProcessHeap (), 0, pWOWRecord->pFilePath);
    }
    BaseSrvFreeVDMInfo (pWOWRecord->lpVDMInfo);

    RtlFreeHeap(RtlProcessHeap (), 0, pWOWRecord);
}

VOID BaseSrvAddWOWRecord (
    PSHAREDWOWRECORD pSharedWow,
    PWOWRECORD pWOWRecord
    )
{
    PWOWRECORD WOWRecordCurrent,WOWRecordLast;

    // First WOW app runs first, so add the new ones at the end
    if (NULL == pSharedWow->pWOWRecord) {
       pSharedWow->pWOWRecord = pWOWRecord;
       return;
    }

    WOWRecordCurrent = pSharedWow->pWOWRecord;

    while (NULL != WOWRecordCurrent){
        WOWRecordLast = WOWRecordCurrent;
        WOWRecordCurrent = WOWRecordCurrent->WOWRecordNext;
    }

    WOWRecordLast->WOWRecordNext = pWOWRecord;

    return;
}

VOID BaseSrvRemoveWOWRecord (
    PSHAREDWOWRECORD pSharedWow,
    PWOWRECORD pWOWRecord
    )
{
    PWOWRECORD WOWRecordCurrent,WOWRecordLast = NULL;

    if (NULL == pSharedWow) {
       return;
    }

    if (NULL == pSharedWow->pWOWRecord) {
       return;
    }

    if (pSharedWow->pWOWRecord == pWOWRecord) {
       pSharedWow->pWOWRecord = pWOWRecord->WOWRecordNext;
       return;
    }

    WOWRecordLast = pSharedWow->pWOWRecord;
    WOWRecordCurrent = WOWRecordLast->WOWRecordNext;

    while (WOWRecordCurrent && WOWRecordCurrent != pWOWRecord){
        WOWRecordLast = WOWRecordCurrent;
        WOWRecordCurrent = WOWRecordCurrent->WOWRecordNext;
    }

    if (WOWRecordCurrent != NULL)
        WOWRecordLast->WOWRecordNext = pWOWRecord->WOWRecordNext;

    return;
}

PCONSOLERECORD BaseSrvAllocateConsoleRecord (
    VOID
    )
{
    PCONSOLERECORD pConsoleRecord;

    if (NULL == (pConsoleRecord = RtlAllocateHeap (RtlProcessHeap (),
                                                  MAKE_TAG(VDM_TAG),
                                                  sizeof (CONSOLERECORD)))) {
       return NULL;
    }


    RtlZeroMemory(pConsoleRecord, sizeof(CONSOLERECORD));

    return pConsoleRecord;
}


VOID BaseSrvFreeConsoleRecord (
    PCONSOLERECORD pConsoleRecord
 