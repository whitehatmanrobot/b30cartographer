		; add leading digit
SCISMALL:			
	XCHG	AL,AH		; get remainder here
	AAM			;Convert binary to unpacked BCD
	XCHG	AL,AH
	OR	AX,"00" 	;Add ASCII bias
	STOSW
	JMP	PUTEND

;
; Rewritten and moved here from CONASC.ASM
;
;***
;B$FloatCONASC - Convert number to ASCII
;
;Purpose:
;	Convert number to a string of ASCII digits with no leading or
;	trailing zeros. Return base 10 exponent and count of digits.
;	No integer values will be passed to this routine.
;
;Entry:
;	B$AC has SP number OR B$DAC has DP or CY number
;
;Exit:
;	CX = number of significant figures (decimal point to right)
;	DL = base 10 exponent
;	SI = Address of first digit (non-zero unless number is zero)
;	[b$SIGN] has sign - blank if positive, "-" if negative
;
;Uses:
;	Uses all.
;****

cProc	B$FloatCONASC,<NEAR,PUBLIC>
cBegin
	MOV	SI,OFFSET DGROUP:B$DAC ;address of location to put final R8
	CMP	b$VTYP,VT_R8	;Is it an R8
	JE	CONASC2 	;brif so, we are ready to convert

GOT_R4: 			
DbAssertRelB  b$VTYP,E,VT_R4,RT_TEXT,<Unknown value for b$VTYP in CONASC>

	MOV	BX,OFFSET DGROUP:B$AC ;point to AC for R4s
	fld	dword ptr [bx]	;Load the R4
	fstp	qword ptr [si]	;And store it as an R8
	FWAIT			;ensure stored


CONASC2:
	Call   FAR PTR B$I8_OUTPUTHack ;math coversion from R8 to ascii string

;	At this point $i8_output returns the following conditions
;		DS:SI	- pointer to converted string (first byte is length)
;		AX	- 1 if number was ok, 0 if indefinite
;		BL	- sign character: either ' ' or '-'
;		DX	- base 10 exponent (left of digits)
;		CX,BH	- smashed

CONASC3:
	MOV	b$SIGN,BL	;save sign char
	LODSB			;AL = length of strings
	CBW
	CMP	AX,1		;See if single digit
	JNZ	ModExp		;If not, go modify exponent
	CMP	BYTE PTR [SI],"0" ;Else see if number is zero
	JZ	NoModExp	;If so, leave exponent alone
ModExp:
	SUB	DX,AX		;DX = base 10 exponent (right of digits)
NoModExp:
	XCHG	AX,CX		;return num digits in CX
cEnd


sEnd	RT_TEXT

assumes CS,_TEXT
sBegin	_TEXT

	externNP $i8_output	;math pack string conversion

;***
;B$I8_OUTPUTHack  - Hack to call B$I8_OUTPUT near from _TEXT.
;
;Purpose:
;	Hack to call B$I8_OUTPUT near from _TEXT.
;	Convert number to a string of ASCII digits.
;
;Entry:
;	DS:SI	- ptr to 8 byte double precision number.
;
;Exit:
;	DS:SI	- pointer to converted string (first byte is length)
;	AX	- 1 if number was ok, 0 if indefinite
;	BL	- sign character: either ' ' or '-'
;	DX	- base 10 exponent
;	CX,BH - smashed
;
;Uses:
;	Uses all but BP,DI.
;****

cProc	B$I8_OUTPUTHack,<FAR>,<BP,DI>
cBegin
	cCall	$i8_output	;math coversion from R8 to ascii string

;	At this point $i8_output returns the following conditions
;		DS:SI	- pointer to converted string (first byte is length)
;		AX	- 1 if number was ok, 0 if indefinite
;		BL	- sign character: either ' ' or '-'
;		DX	- base 10 exponent
;		DI,CX,BH - smashed

cEnd

sEnd	_TEXT


	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\fin.asm ===
TITLE	FIN - String and numeric input
;***
; FIN - String and numeric input
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; BASIC Syntax mapping to included runtime entry points:
;
; - VAL Function:
;
;      v = VAL(x$)
;	    |
;	B$FVAL
;
;******************************************************************************
	INCLUDE rmacros.inc	; Runtime Macro Defintions
	INCLUDE switch.inc

	useSeg	_DATA		
	useSeg	_TEXT		
	useSeg	MT_TEXT 	
	useSeg	NH_TEXT 	
	useSeg	_BSS		

	INCLUDE seg.inc 	
	INCLUDE baslibma.inc	; SKIP macro
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE const.inc	; Values of Flags for KANJI support
	INCLUDE idmac.inc	
	INCLUDE string.inc	

;
; The following constants are from the mathpack interface to $i8_input
; (Note: s16inv is a flag we synthesize.)
;
l_s16inv=	80h		; 16 bit signed value is invalid
l_ind=		80h		; indefinite
l_inv=		40h		; invalid (no digits or syntax error)
l_s32inv=	20h		; 32 bit signed value is invalid
l_u32inv=	10h		; 32 bit unsigned value is invalid
l_long= 	08h		; l_Dexp or more than 7 digits
l_Dexp= 	04h		; explicit 'D' or 'd' seen
l_Rexp= 	02h		; explicit 'E' or 'e' seen
l_inf=		01h		; DP overflow
h_curr= 	  2		;currency value was valid

sBegin	_DATA			

	externD B$AC		
	externQ B$DAC		
	externB $i8_input_ws   ; white space skipping flag

sEnd	_DATA			

sBegin	_BSS			

	externB b$VTYP		


sEnd	_BSS			

externFP B$LDFS 		; Load fixed length string




sBegin	MT_TEXT

externNP B$STPUTZ		
externNP B$STDALCTMP		
externNP B$ERR_OV		
externNP B$ERR_TM		
externNP B$ftolrnd		; Convert TOS to long integer in DX:AX
externNP B$UPCASE		; Convert AL to an uppercase character



assumes CS,MT_TEXT

	SUBTTL	B$FVAL - VAL function
	PAGE
;***
; B$FVAL - VAL function
;
;Function:
;	Compute numeric equivalent of the string
;
;Inputs:
;	sdNum = Address of string descriptor
;
;Outputs:
;	Double precision result in DAC
;
;******************************************************************************
cProc	B$FVAL,<FAR,PUBLIC>,<SI> 
parmSD	sdNum			
cBegin				
	MOV	BX,sdNum	
	CALL	B$STPUTZ	
	MOV	SI,[BX+2]	;Get address of string data
	PUSH	BX		;Save string descriptor address
	MOV	[B$VTYP],VT_R8	; Force to double precision
	CALL	B$FIN		
	POP	BX
	CALL	B$STDALCTMP	; Delete if temp string
	MOV	AX,OFFSET DGROUP: B$DAC	
cEnd				

	SUBTTL	B$FIN - Floating point and string input

;***
; B$FIN - Floating point and string input
; Largely rewritten
;
;Purpose:
;	Perform floating point and string input.  The string that
;	is passed must be zero terminated.
;
;
;	If FK_FULLMAP then the calling routine must allocate B$Buf1
;	and B$Buf2 before calling B$FIN and must deallocate them
;	after the call.  The way that these buffers are used in this
;	routine will NOT affect their use in B$INPP to hold data. Right
;	before calling FAR_I8_INPUT, we convert the rest of this data
;	item (up to a termination comma or zero terminator) from double
;	byte to single byte and store it in the buffers.  This will only
;	overwrite data that is no longer needed for INPUT.
;
;Entry:
;	[b$VTYP] = Type of value required
;	[SI]  = Address of character stream to analyze for the value.
;	[ES]  = segment of character stream IF REQUESTED TYPE IS STRING
;		Otherwise the requested segment is DS.
;Exit:
;	AC    = Address of string descriptor ([B$VTYP] = VT_SD)
;	AC    = integer value ([B$VTYP] = VT_I2)
;	AC    = long integer value ([B$VTYP] = VT_I4)
;	AC    = S.P. value ([B$VTYP] = VT_R4)
;	DAC   = D.P. value ([B$VTYP] = VT_R8)
;	DAC   = currency value ([B$VTYP] = VT_CY)
;	[AX]  = Delimiter Character
;	[SI]  = Address to start scanning for next item (if any) in list
;
;Uses:
;	SI is updated [3]
;
;Preserves:
;	None
;
;Exceptions:
;	If a runtime error occurs, this routine doesn't return to caller
;******************************************************************************
cProc	B$FIN,<PUBLIC,NEAR>,<DI,ES,BP>	; Warning!	Alternate entry
cBegin					;		through B$SimpleFin.
;
; If we are evaluating TO a string, call B$STRSCAN to do that, and then just
; assign the result to a string temp.
;
	CMP	[B$VTYP],VT_SD	; Getting a string?
	JNZ	FIN_5		;Jump if not
	CALL	B$STRSCAN	;[ES:DX] = start, [CX]=length [AX]=delimiter
	PUSH	AX		;Save delimiter Character
	cCall	B$LDFS,<ES,DX,CX>	;[AX] = address of string temp
	MOV	[WORD PTR B$AC],AX	; Put address in AC for safekeeping
	POP	AX		;Restore Delimiter Character
	JMP	FIN_Str_Exit	;go exit

FIN_5:
;
; Determine the target base. This is a function of the leading characters:
;	<none>	Decimal
;	&	Octal integer
;	&O	Octal Integer
;	&H	Hex Integer
;
; where integers may be short or long.
;
	PUSH	DS		;If not string,
	POP	ES		;assumed below that ES = DS

	XOR	BX,BX		;[BL] = radix. 0 is default
	MOV	[$i8_input_ws],1       ; skip white space is default
	CALL	B$GETCH 	;[AL] = next char (skipping white space)
	CMP	AL,'&'		;check for special radix constant
	jne	FIN_10		;jump if normal number
;
;	read special radix numbers
;
	MOV	[$i8_input_ws],BL ; reset skip white space for non-decimal
	CALL	B$GETCH_NS	;[AL] = next char (not skipping white space)
	MOV	BX,10H		;assume hex
	CMP	AL,'H'
	JE	FIN_15
	MOV	BL,8H		;assume octal
	CMP	AL,'O'
	JE	FIN_15

FIN_10:
	DEC	SI		; must be octal - move back pointer
;
; At this point, BX contains the desired conversion base, if one was specified,
; or zero for a default.
;
FIN_15:
;
; This odd piece of code ensure that the max length (passed in cx) when added
; to the start address of the string does not overflow the datasegment. The
; length is just a maximum, and we should stop conversion prior to exceding
; that in all cases by virtue of a zero terminator.
;
; We determine if the string start address is in the range FF00 to FFFF. If
; not, the max length is set to 255. If it is in that range, we set the max
; length to 1000H - start address - 1, i.e. the amount of room left in dgroup.
;

	MOV	CX,SI		;[CX] = string start address
	INC	CH		;Zero set if in 0FFxxH range
	JNZ	FIN_16		;Jump if not in that range
	XOR	CX,CX		;[CX] = 0
FIN_16:
	SUB	CX,SI		;[CX] = either 100H, or space left in DGROUP
	DEC	CX		;[CX] = either 0FFH, or space -1


;
; Set up for, and call the math-pack's conversion routine.
;
InvokeMathPack:

	MOV	DI,OFFSET DGROUP:B$DAC	;[DI] = location to place R8 result
	XOR	AX,AX			;[AX] = 0 (FORTRAN garbage)
	CWD				;[DX] = 0 (FORTRAN garbage)
	PUSH	BX			; Save radix
	PUSH	SI			; Save starting point
	PUSH	BP			;$i8_input trashes BP
	CALL	FAR PTR FAR_I8_INPUT	;Call math pack via aother seg
	POP	BP
	MOV	[$i8_input_ws],0  ;reset skip white space for C

	POP	DX			; DX = pointer to start location
	CMP	SI,DX			; did we use any characters
	JNE	ParsedNumber		; brif so, compute value

; If the mathpack did not like the first character it saw, it will return
; with l_inv false but l_s32inv and l_u32inv true.  We want to accept the
; number as valid, but 0. So munge the flags and the return value here.
; Note that it will have walked on the 8 byte value (B$DAC) also.

	AND	CL,NOT (l_s32inv OR l_u32inv) ;[42] make the number look valid
	XOR	AX,AX		; Set the number to zero
	XOR	BX,BX
	STOSW			; Store it as an R8 (will be 0 for all
	STOSW			;  possible lengths). DI is return
	STOSW			;  as part of B$FAR_I8_INPUT, and ES=DS.
	STOSW

ParsedNumber:

; After calling the math pack, we have two results. The R8 result is in B$DAC,
; unless a radix was specified. If the result is a valid U2, it is in AX, if
; it is a valid U4, it is in BX:AX. Flags are returned in CX.
; Possible 8-byte CY value is in $i8_input_cy.				    [33]
;
; Create the "16 bit value invalid" flag
;
	CWD			;Sign extend I2 in AX into DX
	CMP	BX,DX		;Same as 32 bite high word?
	JZ	FIN_18		;Jump if 16 bit signed value okay
	OR	CL,l_s16inv	;else 16 bit signed value is in error
FIN_18:
	TEST	CL,l_s32inv	;check if valid 32-bit integer
	JZ	FIN_19		;Jump if it is...
	OR	CL,l_s16inv	;else it's also a bad 16 bit'er
FIN_19:
	XCHG	BX,DX		; [DX:AX] = possible long result
	POP	BX		; [BX] = Originally requested base
	MOV	BH,BL		; [BH] = Originally requested base


;
; Check for a type character following the number. Modify the returned flags
; such that when we try to store the result, overflows will be detected.
;
	XCHG	AX,BX		;[DX:BX] = possible long result, [AH] = base
	CALL	B$GETCH_NS	;see if there's a suffix character
;
; If a non-long constant was specified, and the value falls in the range 32768
; to 65535, convert to a negative short integer.
;
	CMP	AL,'&'		; Z if long const
	JZ	FIN_43		; Long constant, do nothing
	OR	AH,AH		
	JZ	FIN_43		; Not any constant, do nothing
	
	;We also have to test for l_inv, as there is an altmath bug where
	;$I8_INPUT may set l_inv but forget to set l_s32inv or l_u32inv.
	
	TEST	CL,l_s32inv OR l_inv 
	JNZ	FIN_43		; Not a valid int, do nothing
	OR	DX,DX		; In range 0-65535?
	JNZ	FIN_43		; If not, nothing to do
	XCHG	AX,BX		; [DX:AX] = possible long return
FIN_GOT_CONST:
	CWD			; New high order work is value sign extend
	AND	CL,NOT l_s16inv ; result is a valid 16-bit integer
	MOV	[WORD PTR B$DAC],AX ; save low word
	XCHG	AX,BX		; [DX:BX] = possible long return

	FILD	WORD PTR B$DAC	; [ST0] = R8
	FSTP	B$DAC		; Save as R4

FIN_43: 			

	CMP	AL,'#'		;double precision?
	JNE	FIN_20
	OR	CL,l_long+l_s32inv+l_s16inv	;force it double
	JMP	SHORT FIN_40
FIN_20:

	CMP	AL,'!'		;single precision?
	JNE	FIN_25
	AND	CL,NOT l_long	;force it single
	OR	CL,l_s32inv+l_s16inv
	JMP	SHORT FIN_40
FIN_25:

	CMP	AL,'%'		;integer?
	JNE	FIN_30
	TEST	CL,l_s16inv	;check if valid 16-bit integer
	JNZ	FIN_TM		; no - type character error
	JMP	SHORT FIN_40

FIN_30:
	CMP	AL,'&'		;long?
	JNE	FIN_35
	TEST	CL,l_s32inv	;check if valid 32-bit integer
	JNZ	FIN_TM		;  no - type character error
	OR	CL,l_s16inv	;force it long
	JMP	SHORT FIN_40

FIN_TM: JMP	B$ERR_TM	;invalid type character

FIN_35:

	DEC	SI		;back up

FIN_40:
;
; Since we couldn not parse any number at all, we have to explicitly
; return a zero ($I8_INPUT will return garbage).  We can also just
; return without further tests, which will avoid an altmath bug where
; certain invalid flags are not being set if l_inv is set.
;
; This check could not be done earlier, as we need to do the same type
; character parsing as before this bug fix.
;
	TEST	CL,l_inv	; was the number invalid?
	JNZ	InValidNumber	; yes, zero out our number and return
;
; Now we attempt to store the result, based on the user-requested data type.
;
	XCHG	AX,BX		; [DX:AX] = possible long result
	MOV	BL,[B$VTYP]    
;
; If the result is a valid 16 bit int, and the user wants an int, just store
; the result (in AX) into the fac.
;
	TEST	CL,l_s16inv	;result a valid 16-bit integer?
	JNZ	FIN_45		;Jump if not
	CMP	BL,VT_I2	; User wants an I2?
	JZ	FIN_50		;brif so - same logic as when have I4
;
; If the result is a valid 32 bit int (or a fall through valid 16 bit int), and
; the user want's an I4, then just store the result (in BX:AX) into B$AC.
;
FIN_45:
	TEST	CL,l_s32inv	;result a valid 32 bit int?
	JNZ	FIN_55		;Jump if not
	CMP	BL,VT_I4	; caller wants an I4?
	JNZ	FIN_55		;brif not
	MOV	[WORD PTR B$AC+2],DX	 ; save high word
FIN_50:
	MOV	[WORD PTR B$AC],AX	 ; save low word
	jmp	SHORT FIN_EXIT		 ;done - exit
;
;If the result is a valid currency, and the user wants currency, just
;store the result (at $i8_input_cy) into B$DAC.
;
FIN_55: 			
;
; The number is not a valid int, thus only the R8 in B$DAC is valid. Determine
; what type the user wants, and coerce to that by loading up on the numeric
; stack, and storing as the desired type.
;
	TEST	CL,l_inf	; Waaaayyyyyy too big?
	JNZ	FIN_OV		; then go complain.
	XCHG	BX,DX		; [DL] = valtype
	CMP	DL,VT_R8	;Does the user perhaps want R8?
	JZ	FIN_EXIT	;In that case, we're done!

	FLD	B$DAC		; [ST0] = R8

	CMP	DL,VT_R4	;Does the user want an R4?
	JNZ	FIN_60		;Jump if not, probably wants an int

	FSTP	B$AC		; Save as R4

	JMP	SHORT FIN_EXIT
;
; Here we have an Integer result type, with only an R8 in B$AC. Convert to the
; appropriate type, with rounding, and make sure the result fits.
;
FIN_60:
	CMP	DL,VT_I2
	JZ	FIN_65		;Must be either I2 or I4 or CY at this point
	CMP	DL,VT_I4
	JNZ	FIN_OV		;Jump if error
FIN_65:
	PUSH	DX		;Save the user resuested type
	cCALL	B$ftolrnd	;Round nearest or even & Store it in DX:AX
	MOV	[WORD PTR B$AC],AX	; Store low word
	MOV	[WORD PTR B$AC+2],DX	; Store Hi-word
	MOV	BX,DX		;Get a copy of Hi-word
	CWD			;Needed to check for overflow in SINT
	CMP	DX,BX		;If they are equal, then all is well
	POP	DX		;[DL] = valtype
	JE	FIN_EXIT	;No complaint
	CMP	DL,VT_I4	;User wanted a long integer?
	JE	FIN_EXIT	;Brif so - no error

FIN_OV: JMP	B$ERR_OV	;Overflow error

InValidNumber:
	MOV	DI,OFFSET DGROUP:B$DAC	 
	XOR	AX,AX		; Get a Zero to store
	STOSW			; Store it as an R8 (will be 0 for all
	STOSW			;  possible lengths)
	STOSW			
	STOSW			

FIN_EXIT:
	CALL	B$GETCH 	; provide return value

FIN_Str_Exit:			 
	FWAIT			; Always wait for 87 to complete.
cEnd				



	SUBTTL	B$STRSCAN
	PAGE
;***
;B$STRSCAN
;
;Purpose:
;	This routine will scan a zero terminated string for the
;	presence of a string input by the user.  If the first
;	character of the string is a double quote ("), then the
;	string is composed of all characters from the double quote
;	to the next double quote not including the quotes.  Otherwise
;	the string is composed of all the characters from the first
;	character until the first comma.
;
;	If the double quote or comma does not appear before the terminating
;	zero, then the zero byte is used as a legal terminator. On return,
;	[ES:SI] will point to the byte following the string seperator.	The
;	seperator, which is returned in AL, is determined as follows:
;
;	1.) If the string was terminated by a zero byte, then the
;	    seperator is the zero byte
;	2.) If the string was not quoted, then the seperator is
;	    the comma that ended the string
;	3.) If the string was quoted, then the seperator is the
;	    first non-blank character following the second double quote.
;
;
;Parameters:
;	[ES:SI]       = Pointer to text string to analyze
;
;Returns:
;	[ES:DX]       = updated pointer to start of string
;	[ES:SI]       = updated pointer to char after string seperator.
;	[CX]	      = Length of string (number of bytes in string)
;	[AL]	      = Seperator byte
;****

cProc	B$STRSCAN,<NEAR,PUBLIC>
cBegin

assumes DS,NOTHING		
assumes ES,NOTHING		
	PUSH	DS		
	PUSH	ES		; CAUTION: We switch DS to point to string
	POP	DS		; CAUTION: data references won't work.

	CALL	B$GETCH
	MOV	AH,AL		;In case first char is "
	CMP	AL,'"'		;Is it?
	JZ	COUNTSTR
	MOV	AH,","		;Terminate with comma if not quoted
	DEC	SI		;Scan first char again
COUNTSTR:
	MOV	DX,SI		;Save starting address of string data
	XOR	CX,CX		;Character count
RDSTR:
	LODSB			;get byte from DS:SI and increment SI
	CMP	AL,AH		;End of string?
	JZ	NEGCNT
	OR	AL,AL		;End of line?
	LOOPNZ	RDSTR		;Count char and loop if not EOL
	INC	CX		;Don't count the EOL character
	CMP	AH,','		;Quoted string?
	JE	NEGCNT		;  No
	DEC	SI		;  Yes - point back to 00 terminator
NEGCNT:
	NEG	CX		;Make character count positive
	CMP	AH,','		;Unquoted string?
	JNZ	GETRTN
;Not a quoted string. Trim off trailing blanks.
	DEC	SI		;Point back at termination character
	MOV	DI,SI
	DEC	DI		;Point to last char of string
	MOV	AL," "
	CMP	AL,AL		;Set zero flag in case CX=0
	STD			;Set direction DOWN
	REPE	SCASB		;Scan of blanks backward
	CLD			;Restore direction
	JZ	GETRTN		;If null string, leave zero in CX
	INC	CX		;Last char scanned not blank - count it
GETRTN:
	CALL	B$GETCH 	;Get Delimiter for return
	POP	DS		;Restore Data Segment
cEnd


page

;***
; B$GETCH, B$GETCH_NS - get next byte from buffer
;
;Purpose:
;	These routines will get the next byte from a zero terminated
;	string of characters.  B$GETCH will skip blank spaces, tabs, and
;	linefeeds, B$GETCH_NS will not.  If the character is a letter, it
;	will be converted to upper case.  If FV_DBCS and FK_FULLMAP
;	then any two byte characters will first be converted to their
;	one byte format if at all possible otherwise any double double
;	byte character will be returned one character at a time.
;
;	If FV_DBCS, then b$SISAVE will be set to the offset (from DS)
;	of the character that is being returned.  This is used by other
;	code to back up a single character.  It is possible for this routine
;	to return only the first half of a Double Byte Character.  This
;	will cause no problems, as it will always be invalid for the purpose
;	that it is used (this will desynchronize the character order
;	but everyone who gets a double byte character from here will die
;	with an error at one point or another).
;
;	NOTE: DS may not point to DGROUP!
;
;Entry:
;	DS:SI - points to a zero terminated string
;
;Exit:
;	AL - next legal character in the string
;	DS:SI - points to next character
;
;Uses:
;	SI is used as the index into a string.
;
;Preserves:
;	AH, BX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$GETCH_NS,<PUBLIC,NEAR>
cBegin
	LODSB			;get byte from DATA statement segment
	JMP	SHORT UPPER	;continue on with processing in B$GETCH
cEnd	<nogen>

cProc	B$GETCH,<PUBLIC,NEAR>
cBegin

GET_ANOTHER:			
	LODSB			;get byte from DATA statement segment

	CMP	AL," "		;Ignore spaces
	JZ	GET_ANOTHER	
	CMP	AL,9		;Ignore tabs
	JZ	GET_ANOTHER	
	CMP	AL,10		;Ignore linefeeds
	JZ	GET_ANOTHER	
UPPER:
	CALL	B$UPCASE	;Convert to upper case
cEnd



assumes DS,DGROUP		
assumes ES,DGROUP		


sEnd	MT_TEXT

	SUBTTL	FAR_I8_INPUT - Far Interface to $i8_input
	PAGE
;***
;FAR_I8_INPUT - far interface to $i8_input
;
;Purpose:
; This interface routine is required because we can't be sure that the B$FIN
; portion of MT_TEXT will be within 64k of $i8_input in _TEXT, and $i8_input
; must be called NEAR
;
;Entry:
; [AX] = FORTRAN scale factor
; [BX] = Radix desired (1..36), integer only to be returned.
; [CX] = Maximum character count for scanning input stream.
; [DX] = FORTRAN decimal point format factor
; [DI] = DS offset of space for 8 byte result
; [SI] = points to first digit in number to input
; [BX] = radix desired, integer only to be returned (0 is default)
; [ES] = DS
;
;Exit:
; [SI] = DS offset of first byte after decoded string value
; [DI] = DS offset of 8-byte result
; [AX] = low order part of integer value (32-bit integer)
; [BX] = high order part of integer value (32-bit integer)
; [CX] = Return flags - - - defined elsewhere
;
; Outputs:
;
;****
sBegin	_TEXT			; $i8_input must be called NEAR from here
	ASSUMES CS,_TEXT

externNP $i8_input	       


FAR_I8_INPUT PROC    FAR
	CALL	$i8_input      ;mathpack call
	RET
FAR_I8_INPUT	ENDP

sEnd	_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\field.asm ===
TITLE	FIELD  - FIELD Statement Processors
;***
; FIELD  - FIELD Statement Processors
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; - FIELD Statement:
;
;	FIELD [#]n, Width AS StringVar [, Width AS StringVar] ...
;
;	FIELD now makes two calls :
;
;	void B$FLDP(I2 channel)
;
;	This call is a preamble to the actual FIELD statement call and sets
;	up the channel and pointers to the field buffer. (FLDP stands for
;	FieLD Preamble)
;
;	void B$FIEL(I2 Width, *psdStringvar)
;
;	This call be made for each pair of width and stringvar in the FIELD
;	statement.
;
;	NOTE: There is NO NEED to set up PTRFIL.  The only thing required
;	is a pointer to the field buffer and this can be obtained once the
;	channel number is known. Hence there is no call to B$PEOS.
;
;******************************************************************************
	page	,132

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;Code segments
	useSeg	DK_TEXT
	useSeg	NH_TEXT
	useSeg	ER_TEXT
;Data segments
	useSeg	_BSS
	useSeg	_DATA

	INCLUDE seg.inc
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE idmac.inc	
	INCLUDE string.inc	


sBegin	_BSS

	staticW FIELD_LEFT,,1	;bytes left in field buffer
	staticW FIELD_POS,,1	;current field position
	staticW FIELD_FDB,,1	;location of backptr descr

sEnd	;_BSS

sBegin	NH_TEXT

	externNP	B$LHFDBLOC	
	externNP	B$LHFLDDESCADD	
	externNP	B$STDALC	

sEnd	;NH_TEXT

sBegin	ER_TEXT

	externNP	B$ERR_BFM	
	externNP	B$ERR_FOV	
	externNP	B$ERR_FC	

sEnd	;ER_TEXT

	assumes CS,DK_TEXT
sBegin	DK_TEXT

	SUBTTL	FIELD interfaces -- B$FLDP & B$FIEL
	page
;***
;B$FLDP -- preamble of FIELD statement
;void B$FLDP(I2 Channel)
;
;Purpose:
;	Sets up the channel and pointers to the field buffer.
;
;	NOTE: no need to set up b$PTRFIL.
;Entry:
;	Parameter in stack.
;	int	Channel
;Exit:
;	[FIELD_FDB]	= *FDB
;	[FIELD_LEFT]	= record length
;	[FIELD_POS]	= *field buffer
;Uses:
;	none
;Exceptions:
;	bad file mode -- B$ERR_BFM
;*******************************************************************************

cProc	B$FLDP,<PUBLIC,FAR>,<SI>
	ParmW	Channel 		;I2 file number
cBegin
	MOV	BX,Channel		;BX has the file number
	CALL	B$LHFDBLOC		;if NZ then SI=*FDB
	JZ	ERCBFM			;Brif not, give "bad file mode"
	CMP	[SI].FD_MODE,MD_RND
	JNE	ERCBFM			;Brif not, give "bad file mode"
	OR	[SI].FD_FLAGS,FL_FIELD	; Indicate FIELD encountered
	MOV	[FIELD_FDB],SI		;get address of FDB data pointer
	MOV	AX,[SI].FD_VRECL	; get record length
	MOV	[FIELD_LEFT],AX 	;Save record length
	ADD	SI,FD_BUFFER		; [SI] = field buffer address
	MOV	[FIELD_POS],SI		;Save address
cEnd					;pop si, and exit to caller

ERCBFM: JMP	B$ERR_BFM		
ERCFC:	JMP	B$ERR_FC		
ERCFOV: JMP	B$ERR_FOV		


	page
;***
;B$FIEL -- set up each field of a record
;void B$FIEL(I2 wid, SD psdStringVar)
;
;Purpose:
;	Sets up each field for a record.  (pointer to the actual buffer
;	position and the length)
;Entry:
;	Parameters in stack.
;	int	Wid
;	sd	*psdStringVar
;Exit:
;	sd of StringVar is set up
;Uses:
;	per conv.
;Exceptions:
;	field overflow -- B$ERR_FOV
;	illegal function call -- B$ERR_FC
;*******************************************************************************

cProc	B$FIEL,<PUBLIC,FAR>,<SI>
	ParmW	Wid		;I2 field width
	ParmW	psdStringVar	;*SD pointer of the sd of StringVar
cBegin
	MOV	DX,Wid		;DX has the field width
	OR	DX,DX		;can't be negative
	JS	ERCFC		;Brif yes, give "illegal function call"
	SUB	[FIELD_LEFT],DX ;count how many left in the field buffer
	JB	ERCFOV		;if field past buffer size, then error
	MOV	BX,psdStringVar ;BX is the pointer of sd of StringVar
	CALL	B$STDALC	;free string space
	MOV	SI,[FIELD_POS]	;get current field position
	MOV	[BX],DX 	;set new string length
	MOV	[BX+2],SI	;set new string address
	OR	DX,DX		; zero length string?
	JZ	FieldExit	; brif so -- skip call to B$LHFLDDESCADD
				; to avoid String Space Corrupt.
	ADD	[FIELD_POS],DX	;bump to next field postion
	MOV	SI,[FIELD_FDB]	;set up pointer to FDB for heap entry

;	Add fielded descriptor value to end of string of descriptor
;	addresses associated with the FDB.

	CALL	B$LHFLDDESCADD	;add the descriptor pointed by BX
FieldExit:			
cEnd				;pop si and exit to caller


sEnd	;DV_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\filename.asm ===
TITLE	FILENAME - filename scanning routines
;***
; FILENAME - filename scanning routines
;
;	Copyright <C> 1987, Microsoft Corporation
;
; Contains functions:
;	B$IValidatePath
;	B$GET_PATHNAME
;	B$ADD_EXT
;	B$GET_CUR_DRIVE
;	B$GET_CUR_DIR
;	B$GET_DEV_NUM
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	USESEG	CONST
	USESEG	_DATA
	USESEG	_BSS
	USESEG	DK_TEXT

	INCLUDE seg.inc
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE idmac.inc
	INCLUDE rtps.inc	; constants shared with QBI

;	Device Name Generator

DEVMAC	MACRO	ARG
	DB	'&ARG'
	DB	DN_&ARG
	ENDM


	externFP OpenCheckDrive	

sBegin	CONST
	staticB BAD_CHAR_TBL,<34,"+,:;<=>[]|">	; illegal filename chars
	BAD_CHAR_CNT	EQU ($ - BAD_CHAR_TBL)	; table length (w/o space)
	staticB	,<" ">,1	; reject spaces for B$IValidatePath
sEnd	CONST

sBegin	_DATA
	globalB	szWildDefault,<"*"> ; "*.bas" (MUST be before b$BAS_EXT!!!)
	globalB	b$BAS_EXT,<".BAS",0>	
	globalB	b$EXE_EXT,<".EXE",0>	
	EVEN			; sd's must be word-aligned
	staticW	fakeSD,0,2	; phoney SD for B$IValidatePath QB5 code.
sEnd	_DATA

sBegin	_BSS
	globalW b$PN_NAME,,1	; addr of first char in filename.ext
	staticW	FIRST_SLASH,?,1	; address of first "\" in pathname, for
				; underflow checking
	staticW	b$BadCharCnt,,1	; # of bytes of BAD_CHAR_TBL to use
sEnd	_BSS

	; special flag values
SLASH_SEEN		= FILNAML + 1	; last char was a "\"
SLASHDOT_SEEN		= FILNAML + 2	; last chars were "\."
SLASHDOTDOT_SEEN	= FILNAML + 3	; last chars were "\.."


assumes CS,DK_TEXT
sBegin	DK_TEXT

	externNP B$UPCASE
	externNP B$ERR_BFN
	externNP B$ERR_DNA


DEVICE_NAME_TABLE LABEL BYTE
	DEVNAM
	DB	0


;*** 
;B$IValidatePath -- interpreter filename parser (FAR)
;
;Purpose:
;	Interpreter reachable routine to call B$GET_PATHNAME and B$ADD_EXT.
;	Added with revision [9].
;Entry:
;	pSource  = DGROUP offset of filename to be parsed
;	cbSource = length of filename to be parsed
;	pDestBuf = DGROUP offset of destination buffer for parsed filename
;	pExt	 = DGROUP offset of extension to add (if none present)
;Exit:
;	AX = length of parsed filename (NOT including null terminator)
;Uses:
;	per conv.
;Preserves:
;	per conv.
;Exceptions:
;	Invalid file name, Device unavailable 
;******************************************************************************
cProc	B$IValidatePath,<FAR,PUBLIC>,<ES,SI,DI>
ParmW	pSource 			;offset of filename to be parsed
ParmW	cbSource			;length of filename to be parsed
ParmW	pDestBuf			;offset of dest buffer
ParmW	pExt				;offset of extension to add
cBegin

	PUSH	DS			;ES=DS
	POP	ES
	MOV	AX,[pSource]		; AX = ptr to filename string
	MOV	CX,[cbSource]		; CX = length of filename
	MOV	BX,OFFSET DGROUP:fakeSD	; BX = ptr to filename SD
	MOV	[BX],CX			; set up phony SD
	MOV	[BX+2],AX		
	MOV	DI,[pDestBuf]		;[DI] = ptr to destination buffer
	MOV	b$BadCharCnt,BAD_CHAR_CNT+1 ; reject spaces in filenames
	CALL	B$GET_PATHNAME_CORE	; returns CX=length (includes null)
					; and AL = flags
	MOV	SI,[pExt]		;[SI] = ptr to extension
	CALL	B$ADD_EXT		;add extension if one not already there
	XCHG	AX,CX			;[AX] = length of parsed filename
	DEC	AX			; don't include null byte in count
cEnd
ERBFN3:					
	JMP	ERBFN2			


	SUBTTL	General File Name Parser

;*** 
; B$GET_PATHNAME
;
;Purpose:
;
;	Generates the fully-qualified pathname from a filename.
;	Converts name to upper case, and removes "\..\" and "\.\" from the
;	pathname.  Resulting pathname is null-terminated.  Appends the drive
;	letter and a ":" to the front if it doesn't have one already.
;
;	Names within pathname do not have '*'s expanded to '?'s.  No checks
;	are done for too many slashes or length.  These checks are not
;	necessary, since the DOS calls that take as input this processed
;	pathname should perform those checks.  Both forward and backward
;	slashes are accepted as path characters.
;
;	An error is given if a filename has more than one dot.
;	Filenames without extensions that are longer than 8 characters have
;	a "." inserted after the 8th position. 
;	The extension portion is truncated to 3 chars.
;
;Algorithm:
;
;
;Entry:
;	BX    = pointer to filename string descriptor
;	DI    = address to place processed pathname (DGROUP offset)
;
;Exit:
;	AL = FLAGS -- bits FN_HAS_EXT and FN_WILD set appropriately.
;	CX = length of pathname (including the null byte)
;	Upper case, fully-specified pathname filled in.
;
;Uses:
;	none
;
;Preserves:
;	BX,DX
;
;Exceptions:
;	Invalid file name.
;
;******************************************************************************
labelNP	<PUBLIC,B$GET_PATHNAME>			
	mov	b$BadCharCnt,BAD_CHAR_CNT	; use default # of bad chars

cProc	B$GET_PATHNAME_CORE,<NEAR>,<ES,SI,BX,DX>	

cBegin

	PUSH	DS		; ES=DS
	POP	ES		
	MOV	SI,[BX+2]	; DS:SI = pointer to filename
	MOV	CX,[BX]		; CX = length of filename
				; ES:DI = pointer to destination buffer
	PUSH	DI		; save start of processed pathname
	LEA	BX,[DI+FILNAML] ; BX = address for overflow check

; place the drive letter into pathname

	DEC	CX		; filename length < 2?
	JLE	NO_DRIVE_SPEC	; brif so -- no drive specified
	CMP	BYTE PTR [SI+1],':' ; is next filename char a ":"?
	JNE	NO_DRIVE_SPEC	; brif not -- no drive specified
	LODSW			; get first two chars of filename into AX
	DEC	CX		; adjust count
	CALL	B$UPCASE	; convert drive letter to upper case
	JMP	SHORT GOT_DRIVE	; store specified drive in pathname

NO_DRIVE_SPEC:			; no drive specified at start of filename
	INC	CX		; restore filename length
	CALL	B$GET_CUR_DRIVE ; put current DRIVE_LETTER: into AX

GOT_DRIVE:			; AX contains "DRIVE_LETTER:"
	STOSW			; store "DRIVE_LETTER:" into pathname
	MOV	FIRST_SLASH,DI	; save address for underflow check
	cCall	OpenCheckDrive,<ax>	; put up a message box if we are
					; switching logical drives
					; PRESERVES ALL REGISTERS
	SUB	AX,':' SHL 8 + 'A'-1 ; convert AX to drive number (A=1,B=2,etc)
	XCHG	DX,AX		; DX = drive number (DH = 0)
	JCXZ	USE_CURDIR	; brif end of filename -- use current directory
	MOV	AL,[SI]		; get next char into AL
	CALL	CHK_FOR_SLASH	; slash char?
	JE	PROCESS_NAME	; brif so -- don't use current directory

USE_CURDIR:
	CALL	B$GET_CUR_DIR	; get current directory for the proper drive,
				; and store it into the pathname buffer

	XOR	AL,AL		; search for null byte
	PUSH	CX		; save count
	MOV	CX,-1		; search for up to 64K chars
	REPNE	SCASB		; set DI to position past null byte
	DEC	DI		; [DI] = null byte at end of pathname
	CMP	BYTE PTR [DI-1],'\' ; root directory?
	JE	Not_Root_Dir	; brif so -- don't add a "\"
	MOV	AL,'\'		; place a "\" between the current directory
	STOSB			; and the filename
Not_Root_Dir:			
	POP	CX		; restore count

PROCESS_NAME:
	CALL	SLASH_END	; indicate slash char seen, and set b$PN_NAME.
	JCXZ	CheckDir	; brif end of filename -- just return the
				; current directory for the proper drive

	; Register usage:
	;    DS:SI = pointer to next char in filename
	;    ES:DI = pointer to next char in processed pathname
	;	AL = next char in filename
	;	AH = KANJI Flags
	;		0  => not Double Byte Character
	;		1  => Double Byte Character
	;	BX = pathname buffer end address (for overflow check)
	;	CX = number of remaining chars in filename
	;	DH = flags:
	;		FN_WILD -- name portion of pathname contains a wildcard
	;		FN_HAS_EXT -- name portion of pathname has extension
	;	DL = last char(s) flag:
	;		SLASH_SEEN	-- last char in path is "\"
	;		SLASHDOT_SEEN	-- last chars in path are "\."
	;		SLASHDOTDOT_SEEN - last chars in path are "\.."
	;		otherwise	-- number of chars since last "\"
	; On stack:
	;	pathname buffer address


; Now add specified filename to current drive:path, processing "." and ".."

NAME_LOOP:
			; get next filename char
	LODSB			; AL = next filename character

	CALL	B$UPCASE	; convert to upper case
	STOSB			; store char from filename into pathname
	CMP	DI,BX		; are we now past the end of the buffer?
	JA	ERBFN2		;brif so -- illegal pathname

			; process the char

	CMP	AL,'.'		; is char a DOT?
	JNE	CHK_SLASH	; brif not -- check for slash

	CMP	DL,SLASHDOTDOT_SEEN ; seen "\..."?
	JAE	ERBFN2		;brif so -- invalid pathname
	CMP	DL,SLASH_SEEN	; seen "\." or "\.."?
	JAE	INC_COUNT	; brif so -- advance state
	TEST	DH,FN_HAS_EXT	; seen two dots since last "\"? ("x.y.z")
	JNZ	ERBFN2		; brif so -- invalid pathname.
; This handles name of the form "xxxxxxxxy.z" too, since "xxxxxxxxy"
; gets changed to "xxxxxxxx.y" before the ".z" is added.
DOT_EXIT:			
	OR	DH,FN_HAS_EXT	; set extension present flag
	JMP	SHORT ResetCount ; reset count to 1 (just the ".")

CHK_SLASH:
	CALL	CHK_FOR_SLASH	; is it a slash?
DJMP	JNE	CHK_BAD_CHAR	; brif not -- check for invalid char

	CALL	PROCESS_SLASH
	JMP	SHORT END_LOOP	; go to the end of the loop

ERBFN2:				; centrally located
DJMP	JMP	SHORT ERBFN	

VALID_CHAR:			
	CMP	AL,'*'		; is it an asterix?
	JE	IS_WILD_CHAR	; brif so
	CMP	AL,'?'		; is it a question mark?
	JNZ	CHK_DEFAULT	; brif not -- perform default char processing
IS_WILD_CHAR:
	OR	DH,FN_WILD	; flag wild card present

CHK_DEFAULT:
	CMP	DL,SLASHDOT_SEEN ; seen "\.x" (ext w/o name) or "\..x"?
	JAE	ERBFN		; brif so -- illegal pathname
	CMP	DL,SLASH_SEEN	; have we seen "\x"?
	JNE	INC_COUNT	; brif not -- just increment count
ResetCount:			
	XOR	DL,DL		; reset char count/last char flag to 0

INC_COUNT:
	INC	DX		; have seen another char

	CMP	DL,SLASH_SEEN	; processing name portion?
	JAE	END_LOOP	; brif not -- process next char
	CMP	DL,4		; valid length for either extension or name?
	JBE	END_LOOP	; brif so
	TEST	DH,FN_HAS_EXT	; seen a dot already?
	JNZ	BackUpChar	; brif so -- truncate extension to 3 chars

	CMP	DL,9		; 9 characters in name now?
	JB	END_LOOP	; brif < -- process next char
	MOV	AL,'.'		; pretend we now have a '.'
	XCHG	AL,[DI-1]	; turn "xxxxxxxxy" into "xxxxxxxx.y"
	STOSB			
INSERTED_DOT:
	OR	DH, FN_HAS_EXT	; Indicate the presence of the DOT
	MOV	DL, 1		; extenstion has 1 character (the DOT)
	JMP	SHORT INC_COUNT ; Include the new character in the count

				; here if truncating extension
BackUpChar:			; back up 1 char in output fname
	dec	di		; back up over char
	dec	dx		; one less char

END_LOOP:
	LOOP	NAME_LOOP	; process next char, if any

; filename has now been almost completely processed
	CMP	DL,SLASH_SEEN	; does current pathname end with "\." or "\.."?
	JBE	CheckDir	; brif not -- add the null byte
		;Special code to handle directory names
	INC	DI		; pretend there's another "\" on the end
	CALL	PROCESS_SLASH	; and process as if there is a slash char,
				; removing the dots.
CheckDir:			
	CMP	DL,SLASH_SEEN	; does it end with a '\'?
	JNE	ADD_NULL	; brif not -- just add the null byte
	OR	DH,FN_IS_DIR	; set directory flag so B$ADD_EXT won't
				; try to add an extension to directory name
ADD_NULL:
	XCHG	AX,CX		; set AX = 0, since CX will always = 0 here
	STOSB			; store terminating null byte

; complete null-terminated pathname without "\." or "\.." is now in buffer.

	MOV	CX,DI		; one past the last position (past null byte)
	POP	DI		; restore DI to point to the processed pathname
	SUB	CX,DI		; and set CX to the count of chars in pathname
				; (including the null)
	MOV	AL,DH		; return flags in AL
cEnd

ERBFN:				; centrally located
	jmp	B$ERR_BFN	; give bad filename error

CHK_BAD_CHAR:		; Check if char is a valid filename character.
	CMP	AL,' '		; control character?
	JB	ERBFN		; brif so -- bad filename

			; search table of invalid chars for current char
	PUSH	DI		; save registers
	PUSH	CX		
	MOV	DI,OFFSET DGROUP:BAD_CHAR_TBL ; table to search
	MOV	CX,b$BadCharCnt ; number of chars to search (changes)
	REPNE	SCASB		; search for char in table
	JZ	ERBFN		; brif char found -- bad filename
	POP	CX		; restore registers
	POP	DI		
	JMP	VALID_CHAR	; valid char -- continue processing





;*** 
;PROCESS_SLASH -- perform processing for a "\" in the pathname
;
;Purpose:
;	Eliminates "\.\" and "\dir\..\" from pathname string, and checks
;	for underflow (".." at the root directory level).
;
;Entry: (same conditions as within pathname processing loop)
;	ES:DI = pointer to next char in processed pathname
;	DH    = flags:
;		    FN_WILD -- name portion of pathname contains a wildcard
;		    FN_HAS_EXT -- name portion of pathname has extension
;	DL    = last char(s) flag:
;		    SLASH_SEEN	    -- last char in path is "\"
;		    SLASHDOT_SEEN   -- last chars in path are "\."
;		    SLASHDOTDOT_SEEN - last chars in path are "\.."
;Exit:
;	DI updated
;	DH = NOT FN_WILD and NOT FN_HAS_EXT
;	DL = SLASH_SEEN
;	b$PN_NAME = address of last "\" in pathname.
;
;Uses:
;	AL
;
;Preserves:
;
;Exceptions:
;	Bad File Name
;
;******************************************************************************
PROCESS_SLASH:			;Transform "\.\" or "\dir_name\..\" to "\"
	CMP	DL,SLASHDOT_SEEN ; seen "\.\"?
	JNE	CHK_SLASHDOTDOT	; brif not -- check for "\..\"
	DEC	DI		; remove the last "\"
	DEC	DI		; remove the "."
	JMP	SHORT SLASH_END	; indicate slash char seen

CHK_SLASHDOTDOT:
	CMP	DL,SLASHDOTDOT_SEEN ; seen "\..\"?
	JNE	SLASH_END	; brif not -- indicate slash char seen
	SUB	DI,4		; get rid of the "\..\"
				; [DI] = addr of the first "\"

REMOVE_SLASHES:
	DEC	DI		; remove another char
	MOV	AL,[DI]		; get deleted char
	CALL	CHK_FOR_SLASH	; just removed a previous "\"?
	JE	REMOVE_SLASHES	; remove another char

	CMP	DI,FIRST_SLASH	; have we deleted the first "\"?
	JB	ERBFN		; brif so -- underflow -- too many "\..\"'s
REMOVE_NAME:
	DEC	DI		; remove another char of the name
	MOV	AL,[DI]		; get deleted char
	CALL	CHK_FOR_SLASH	; just removed a previous "\"?
	JNE	REMOVE_NAME	; brif not -- delete another character
	INC	DI		; put back the last "\"

SLASH_END:
	MOV	DX,SLASH_SEEN	; indicate slash character seen, no wildcards,
				; and no extension
	MOV	b$PN_NAME,DI	; set address of name.ext in pathname
	RET			; return to caller


;*** 
; CHK_FOR_SLASH -- check if char is "\" or "/"
;
;Purpose:
;	Since we're to allow both forward and backwards slashes in the
;	pathname, check if char is "\" or "/".  Extracted to save code.
;
;Entry:
;	AL = char to check.
;Exit:
;	ZF if AL = "\" or "/", NZ otherwise.
;Uses:
;	None
;Preserves:
;	All
;Exceptions:
;	None
;
;******************************************************************************
CHK_FOR_SLASH:			; check for forward slash and back slash
	CMP	AL,'\'		; is it a back slash?
	JE	CHK_SLASH_EXIT	; brif so -- return to caller
	CMP	AL,'/'		; is it a forward slash?
CHK_SLASH_EXIT:
	RET			; return to caller


;*** 
; B$ADD_EXT -- add extension to pathname
;
;Purpose:
;	Adds a 4-byte extension to a name, updating the count and checking
;	for overflow.  It first checks to see that there is not already an
;	extension on the last name of the file.
;
;Entry:
;	ES:DI = address of null-terminated pathname to append extension to
;	CX = index into the pathname of the char past the char to overwrite
;		(usually the pathname length returned from B$GET_PATHNAME)
;	DS:SI = address of 4-bytes to be appended to name
;	AL = flags returned from B$GET_PATHNAME
;
;Exit:
;	if not already an extension
;	    extension appended to name at ES:DI
;	    CX = new length of name (INCLUDING the NULL)
;
;Uses:
;	SI,AX
;
;Preserves:
;	BX,DX
;
;Exceptions:
;	Bad file name
;
;******************************************************************************
cProc	B$ADD_EXT,<NEAR,PUBLIC>,<DI>
cBegin

	TEST	AL,FN_HAS_EXT or FN_IS_DIR ; does the filename already have
				; an extension (or end with a '\')?
	JNZ	NO_EXTENSION	; brif so -- don't add an extension

	DEC	CX		; CX = # chars w/o the null
	ADD	DI,CX		; set destination pointer to point to null byte

NextChar:			
	INC	cx		; advance count
	CMP	CX,FILNAML	; will we overflow with this char?
	JA	ERBFN		; brif so -- Bad file name error
	LODSB			; get char
	STOSB			; store it
	OR	AL,AL		; got the null yet?
	JNZ	NextChar	

NO_EXTENSION:
cEnd



;*** 
; B$GET_CUR_DRIVE -- get current drive letter and number
;
;Purpose:
;
;	get current drive number (1-26) and letter (A-Z) from DOS
;
;Entry:
;	none
;
;Exit:
;	AL    = current drive letter (A-Z)
;	AH    = ':'
;
;Uses:
;	DX
;
;Preserves:
;	BX,CX
;
;Exceptions:
;	None
;
;******************************************************************************
cProc	B$GET_CUR_DRIVE,<NEAR,PUBLIC>
cBegin

	CALLOS	GDRV		; AL = default drive  (A=0, B=1, etc)
	CBW			; clear high byte
	ADD	AX,':' SHL 8 + 'A' ; return drive letter in AL and ':' in AH

cEnd


;*** 
; B$GET_CUR_DIR -- return current directory for a given drive number.
;
;Purpose:
;
;Algorithm:
;	Add "\" to string
;	Get current directory from DOS into string
;
;Entry:
;	ES:DI = address of area to place current directory
;	DX = drive number (1-26)
;	ES=DS
;
;	Note: IF FV_FARSTR, DS is not necessarily DGROUP on entry.
;
;Exit:
;	current directory (null-terminated) loaded into buffer
;
;Uses:
;	AX,DX
;
;Preserves:
;	BX,CX
;
;Exceptions:
;	Device not available
;
;******************************************************************************
cProc	B$GET_CUR_DIR,<NEAR,PUBLIC>,<CX>
cBegin

	MOV	AL,'\'		; add a beginning "\"
	STOSB

	PUSH	SI		; save register
	MOV	SI,DI		; set SI to current location in buffer
	CALLOS	CURDIR,ERDNA	; load current directory into DS:SI
	POP	SI		; restore register
cEnd


ERDNA:
	jmp	B$ERR_DNA	; give Device unavailable error


;*** 
; B$GET_DEV_NUM
;
;Purpose:
;	Checks if the first 5 chars of a string are equal to some BASIC
;	device, and if so, returns the device number for that device.
;	Accepts names of the form "XXXX:yyyyyy" as a valid devices, and
;	copies the options string for valid devices into the specified buffer.
;
;Entry:
;	BX    = pointer to filename string descriptor
;
;Exit:
;	AL = device number if device, or 0 if not a valid BASIC device
;	FLAGS = result of "OR AL,AL"
;
;Uses:
;	None
;
;Preserves:
;	BX,CX,DX
;
;Exceptions:
;	none
;
;******************************************************************************

cProc	B$GET_DEV_NUM,<NEAR,PUBLIC>,<ES,SI,DI,CX>	
cBegin
	MOV	SI,[BX+2]	; [DS:SI] = pointer to string data
	CMP	WORD PTR [BX],5	; length < 5?
	JB	NOT_DEV		; brif so -- not a valid BASIC device
	CMP	BYTE PTR [SI+4],':' ; name of the form "xxxx:" ?
	JNZ	NOT_DEV		; brif not -- not a BASIC device

; No checks will need to be done for KANJI characters, because there are
; none in our tables.  The call to B$UPCASE will not matter, as it can not
; do anything to make a match succeed. (The first byte of a KANJI character
; will not be converted, nor will it be in the table.)

	MOV	DI,OFFSET DEVICE_NAME_TABLE
	PUSH	CS		; set ES = CS for table reference
	POP	ES

DEV_LOOP:			; for each device in table
	CMP	BYTE PTR ES:[DI],0 ; end of table?
	JZ	NOT_DEV		; brif so -- not a valid BASIC device
	PUSH	SI		; save start of name
	MOV	CX,4		; compare 4 chars
CMP_LOOP:
	LODSB			; get character from the name into AL
	CALL	B$UPCASE	; convert to upper case
	SCASB			; does it match char in the device table?
	JE	NEXT_CHAR	; brif so -- try next char
	ADD	DI,CX		; skip over remaining chars and dev # in table
	POP	SI		; retrieve start of name
	JMP	SHORT DEV_LOOP	; and try to match the next entry
NEXT_CHAR:
	LOOP	CMP_LOOP	; falls through if device matched

	POP	SI		; clean off stack
	MOV	AL,ES:[DI]	; return device number in AL
	OR	AL,AL		; set flags for calling routine
	JMP	SHORT DEV_EXIT
NOT_DEV:
	XOR	AL,AL		; not a device -- clear AL and flags
DEV_EXIT:
cEnd

sEnd	DK_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\getput.asm ===
PAGE	56,132
	TITLE	GETPUT - iAPX 88/86 SUPPORT FOR GRAPHICS PUT/GET STATEMENTS
;***
; GETPUT - iAPX 88/86 SUPPORT FOR GRAPHICS PUT/GET STATEMENTS
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - GET Statement:
;
;      GET (x1,y1)-(x2,y2),arrayname [(indecies)]
;	|     |       |
;	|   Coord Routines	      B$GGET
;	|				 |
;	+--------------------------------+
;
; - PUT Statement:
;
;      PUT (x,y),array[(indecies)][,action]
;	|    |
;	|  Coord Routines	B$GPUT
;	|			   |
;	+--------------------------+
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions


	useSeg	_BSS		
	useSeg	GR_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE array.inc	


sBegin	_BSS			
;
;****************************************************************************
; External low-level function vectors
;****************************************************************************
;
externW b$MapXYC		
externW b$UpC			
externW b$DownC			
externW b$SetPixLastC		

externW B$GXPOS			; defined in GWDATA.ASM
externW B$GYPOS			; defined in GWDATA.ASM
externW B$MINDEL 		; defined in GWDATA.ASM
externW B$MAXDEL 		; defined in GWDATA.ASM

externB B$WNDWSW 		; defined in GWDATA.ASM
externB B$WNDWSC 		; defined in GWDATA.ASM

sEnd	_BSS			

sBegin	GR_TEXT 		
assumes CS,GR_TEXT		

externNP B$IDIVBX		
externNP B$ComputeSpace		


externNP B$COORD1		
externNP B$COORD2		

externNP B$INVIEW		

externNP B$SCINIT		; Performs screen initialization

externNP B$ERR_FC		
externNP B$ERR_BS		

;
;low-levels:
;
externNP B$ImageSize		
externNP B$PixSize		
externNP B$PutGetInit		
externNP B$NReadC		
externNP B$NWriteC		
externNP B$XDELT 		
externNP B$YDELT 		



	SUBTTL	B$GGET - read rectangle screen area into the specified array
	PAGE
;***
; B$GGET - read the rectangle screen area into the specified array
; void pascal B$GGET(far *fpData, ad *pAd)
;
;Purpose:
; Read all the pixels in the specified rectangle on the screen into the array.
; The first two bytes of the array will be set to the number of bits along the
; X axis, the second two bytes, the Y axis.
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Entry:
; fpData = Far pointer to location at which to place the data.
; pAd	 = Pointer to the array descriptor to be used...
;
;Exit:
; Array set
;
;Uses:
; Per convention
;
;Exceptions:
; Control could be transfered to an error routine, such as B$ERR_FC
;
; [3/4] Routine largely rewritten for array indecies and new array descriptor
;******************************************************************************
cProc	B$GGET,<FAR,PUBLIC>,<ES,SI>
parmD	fpData			;far ptr to start of array data
parmW	pAd			;pointer to array descripptor of interest
cBegin				

	CALL	B$SCINIT	; initialize screen if not already done.
	cCall	B$COORD1	;Process first coord pair
	PUSH	CX		;save X1
	PUSH	DX		;save Y1

	cCall	B$COORD2	;Process second coord pair
;
; First step is to calculate the upper right hand corner and the delta-x and
; delta-y of the area that the caller has selected through previous calls to
; set the first and second pairs of coordinates.
;
	POP	DX		; [DX] = Y1
	POP	CX		; [CX] = X1
	CALL	B$YDELT		;CALC DELTA Y
	JNB	GPUTG2
	XCHG	DX,[B$GYPOS]	;ensure DX = MIN(Y1,Y2)
GPUTG2:

	CMP	B$WNDWSW,0
	JZ	GPUTGW		;Brif no WINDOW
	CMP	B$WNDWSC,0
	JNZ	GPUTGW		;Use MinY if WINDOW SCREEN
	XCHG	DX,[B$GYPOS]	;ensure DX = MIN(Y1,Y2)
GPUTGW:

	INC	BX		;MAKE DELTA A COUNT
	MOV	B$MINDEL,BX	;SAVE DELTA Y IN MIDEL
	CALL	B$XDELT
	JNB	GPUTG3
	XCHG	CX,[B$GXPOS]	;ensure CX = MIN(X1,X2)
GPUTG3:

	INC	BX		;MAKE DELTA A COUNT
	MOV	B$MAXDEL,BX	;SAVE DX IN B$MAXDEL
	CALL	[b$MapXYC]	;OEM ROUTINE CALL TO UPDATE GRAPHICS ACCUM
;
; Next step is to calculate the starting location in the array, and the amount
; of room available for the data to GET.
;
	cCall	B$ComputeSpace,<fpData,pAd>	
	PUSH	DX		;place on stack for subsequent pops
	PUSH	AX		;[ES:SI] = address, [TOS] = room left

;
; From the delta-x and delta-y, calculate the amount of room required for the
; graphics area to GET, and then make sure that the amount of available space
; calculated above is sufficient.
;
	MOV	BX,B$MINDEL	;Get delta Y
	MOV	DX,B$MAXDEL	;Get delta X
	XOR	CX,CX		;Clear CX before call to ImageSize
	CALL	B$ImageSize	;[CX:BX]=number bytes req'd, [DX]=bits per row
	JC	OVERFL		;Jump if overflow occurred
	ADD	BX,4		;Add 4 bytes to space needed for deltax,deltay
	adc	cx,0		;carry to high-order word
;	JC	GP0_ERR 	;Issue error if space needed > 64K
;	INC	CX
;	LOOP	GP0_ERR 	;If CX <> 0 issue error
	POP	AX		; [AX] = low bytes available
	SUB	AX,BX		; [AX] = low available - low required
	POP	AX		; [AX] = high available
	SBB	AX,CX		; [AX] = high available - high required
	JNB	GET0		;Continue if there's enough room
GP0_ERR: JMP	 B$ERR_FC	   ;ERROR IF TOO BIG

GET0:
;
; Begin the GET. Store the delta-x and delta-y as the first two (word) elements
; in the array, and then perform a line read delta-y times.
;
	PUSH	BP		;low level GET trashes BP
	MOV	BX,SI		;[ES:BX] = address
	MOV	ES:[BX],DX	;Store x dimension at ES:BX
	MOV	CX,B$MINDEL	;get y line count
	MOV	ES:[BX+2],CX	;Store y dimension at ES:BX + 2
	ADD	BX,4		;Increment array ptr past raster
	XCHG	CX,DX		;CX:=bits per row for INIT ;DX:=delta y of raster
	CLC			;Clear carry for INIT
	PUSH	DX		;RESAVE DY
	CALL	B$PutGetInit	; [CX]=BIT COUNT,[BX]=ARRAY ADDR
	POP	CX		;get y count


	MOV	AX,WORD PTR [B$WNDWSW] ;get window switches


;
;      if wndwsw and ~wndwsc then use upc else use downc
;
	NOT	AH		;negate B$WNDWSC (low bit 1 for no SCREEN)
	AND	AL,AH
	RCR	AL,1		;only make assumption about 0/1
	JC	GLOOPU

GLOOPD:
	PUSH	CX		;preserve count register
	CALL	B$NReadC	;read a raster line from the screen
	CALL	[b$DownC]	;move the cursor down a line
	POP	CX		;restore count register
	LOOP	GLOOPD		;repeat cx times


	JMP	SHORT GGET_90
GLOOPU:
	PUSH	CX		;preserve count register
	CALL	B$NReadC	;read a raster line from the screen
	CALL	[b$UpC]	;move the cursor up a line
	POP	CX		;restore count register
	LOOP	GLOOPU		;repeat cx times

GGET_90:

	POP	BP		;recover real BP
	call	[b$SetPixLastC] 



cEnd

OVERFL: JMP	B$ERR_BS
	PAGE

	SUBTTL	B$GPUT - write specified array contents to screen with action
	PAGE
;***
; B$GPUT - write specified array contents to screen with action
; void pascal B$GPUT(far *fpData, ad *pAd, I2 action)
;
;Purpose:
; Write the specified array data to the screen in a rectangle whose upper left
; vertex is the specified coordinate. The action is performed on the pixel
; value in the array before it is written to the screen. The rectangle width
; and height are kept in the first word of the array.
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Entry:
; fpData = Far pointer to location from which to obtain the data.
; pAd	 = Pointer to the array descriptor to be used.
; action = PUT action to be performed
;		1 for PSET
;		2 for PRESET
;		3 for XOR
;		4 for OR
;		5 for AND
;
;Exit:
; None.
;
;Uses:
; Per convention.
;
;Exceptions:
; Control could be transfered to an error routine, such as B$ERR_FC
;
; [3/4] Routine largely rewritten for array indecies and new array descriptor
;******************************************************************************
cProc	B$GPUT,<FAR,PUBLIC>,<DI,SI,ES>
parmD	fpData			;far ptr to start of array data
parmW	pAd			;pointer to array descriptor of interest
parmW	action			;PUT action to be taken
cBegin

	CALL	B$SCINIT	; initialize screen if not already done.
	cCall	B$COORD1	;Process Coord pair
	cCall	[b$MapXYC]	;update graphics cursor
;
; Start by determining the base address within the array at which to place
; data, taking into account if any indecies have been passed.
;
	LES	BX,fpData	;[ES:BX] = address to obtain data
	MOV	CX,ES
	INC	CX		;Is there a specified place?
	LOOP	GPUT_10 	;brif so
	MOV	BX,pAd		;[AX] = ptr to array descriptor
	LES	BX,DWORD PTR [BX].AD_fhd.FHD_oData ;[ES:BX] = base array address

GPUT_10:			;[ES:BX] = address
;
; Compute the opposite corner of the rectangle to be PUT, and ensure that it
; lies within the available area.
;
	MOV	SI,ES:[BX]	;[SI] = x bit count
	PUSH	SI
	MOV	DI,ES:[BX+2]	;[DI] = y dimension
	PUSH	DI
	ADD	BX,4		;[BX] = Pointer to array data
	PUSH	BX
	CALL	B$PixSize	;[AL] = BITS/PIXEL
	XCHG	AX,BX		;[BL] = bits/pixel
	XCHG	AX,SI		;[AX] = bit count for IDIV instruction
	CWD			;[DX:AX] = bit count for B$IDIVBX
	XOR	BH,BH		;[BX] = bits/pixel
	CALL	B$IDIVBX 	;[AX] = No. of pixels in x
	DEC	AX		;DECREMENT SINCE IT'S A COUNTER
	MOV	DX,B$GXPOS	;[DX] = starting X
	ADD	AX,DX		;[AX] = ending X
	JB	PRNGER		;ERROR IF CARRY
	MOV	CX,AX		;[CX] = ending X

	MOV	BX,B$GYPOS	;[BX] = starting Y
	CMP	B$WNDWSW,0
	JZ	PRNGNW		;Brif no WINDOW
	CMP	B$WNDWSC,0
	JNZ	PRNGNW		;Use MinY if WINDOW SCREEN
	SUB	BX,DI		;Since y is reversed if window
	JMP	SHORT PRNGER
PRNGNW:
	DEC	DI		;DECREMENT DY SINCE IT'S A COUNTER
	ADD	BX,DI		;[BX] = Ending Y (start Y + DELTA Y)
PRNGER:
	JNB	PRNGOK

PUTERR: JMP	B$ERR_FC	  ;ERROR IF CARRY

PRNGOK:
	MOV	DX,BX		;[DX]=Y + DELTA Y
	CALL	B$INVIEW 	;If coords inside viewport boundary
	JNC	PUTERR		;ABORT IF CX,DX OFF SCREEN
	POP	BX		;[ES:BX] = ARRAY POINTER
	POP	DX		;POP DY
	POP	CX		;POP DX*BITS/PIX
	PUSH	BP		;low levels trash BP
	PUSH	DX		;RESAVE DY
;
;For a PUT statement, on entry to INIT AL=put action mode (0..4):
;
;	0		OR
;	1		AND
;	2		PRESET
;	3		PSET
;	4		XOR
;


	STC			;SET CARRY TO FLAG PUT INIT
	MOV	AX,action	;get the action
	CALL	B$PutGetInit	;[CX]=BIT COUNT,[BX]=ARRAY ADDR
	POP	CX		;get y count

	MOV	AX,WORD PTR [B$WNDWSW] ;get window switches


;
;      if wndwsw and ~wndwsc then use upc else use downc
;
	NOT	AH		;negate B$WNDWSC (low bit 1 for no SCREEN)
	AND	AL,AH
	RCR	AL,1		;only make assumption about 0/1
	JC	PLOOPU

PLOOPD: 			;do put loop with downc
	PUSH	CX		;preserve count register
	CALL	B$NWriteC	;write a raster line to the screen
	CALL	[b$DownC]	;move the cursor down a line
	POP	CX		;restore count register
	LOOP	PLOOPD		;repeat cx times


	JMP	SHORT GPUT_90

PLOOPU: 			;put with upc
	PUSH	CX		;preserve count register
	CALL	B$NWriteC	;write a raster line to the screen
	CALL	[b$UpC]	;move the cursor up a line
	POP	CX		;restore count register
	LOOP	PLOOPU		;repeat cx times

GPUT_90:


	call	[b$SetPixLastC] 


	POP	BP		;recover trashed BP

cEnd

sEnd	GR_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\grline.asm ===
TITLE	GRLINE - LINE STATEMENT SUPPORT
	PAGE	56,132
;***
;GRLINE - LINE STATEMENT SUPPORT
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - LINE Statement:
;
;      LINE [(x1,y1)] -(x2,y2) [,[color] [,B[F]] [,style]]
;	|	|	  |
;	|    Coordinate Routines			   B$LINE
;	|						       |
;	+------------------------------------------------------+
;
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	_BSS
	useSeg	GR_TEXT

	INCLUDE seg.inc


sBegin	_BSS
;
;****************************************************************************
; External low-level function vectors
;****************************************************************************
;
externW b$NSetC		
externW b$MapXYC		

externW B$VXMIN
externW B$VXMAX
externW B$VYMIN
externW B$VYMAX
externW B$GRPACX
externW B$GRPACY
externW B$GXPOS
externW B$GYPOS
externW B$GX_OLD
externW B$GY_OLD
externW B$MAXDEL
externW B$MINDEL
externW B$MINUPD
externW B$MAXUPD

externW B$LINSTL


externW	b$PenC			
externW	b$OffC			
externW b$Incr1			; major axis update value for Line
externW b$Incr2			; minor axis update value for Line
externW b$IncrY			; change for Y movement for Line
externW b$LineX			
externW b$LineY			
externW b$LineV			
externW	b$SetPixLastC		
externW	b$SetPixFirstC		
externW	b$BytesPerRow		

sEnd	_BSS



sBegin	GR_TEXT
assumes CS,GR_TEXT

externNP B$XDELT
externNP B$YDELT
externNP B$DOBOXF
externNP B$CLRATR
externNP B$COORD1		; process first coordinate pair
externNP B$COORD2		; process second coordinate pair
externNP B$ERR_FC
externNP B$ERR_DV0
externNP B$ERR_OV


externNP B$CLIPCK



;low-level routines:
externNP B$SCINIT		; Performs screen initialization

	SUBTTL	B$LINE - Line statement entry point
	PAGE
;***
;B$LINE - Line statement entry point
;void pascal B$LINE(I2 color, I2 style, I2 fBF)
;
;Purpose:
; Draw line, box or filled box, with or without line styling, according to
; the requested form of line statement.
;
;Input:
; color = color spec (-1 if default)
; style = line style (-1 if default to solid line)
; fBF	= box spec:	0 if normal line (no box)
;			1 if box with no fill
;			2 if filled box
;
;Output:
; none
;
;Modifies:
; Per convention
;
;Exceptions:
; Control may be transfered to an error routine such as B$ERR_FC
;
;******************************************************************************
cProc	B$LINE,<FAR,PUBLIC>
parmW	color
parmW	style
parmW	fBf
cBegin

	CALL	B$SCINIT	; inititalize screen if not already done

	cCall	B$COORD1	; process first coord pair
	MOV	AX,B$GRPACX	;move first x coordinate into B$GX_OLD
	MOV	B$GX_OLD,AX	;B$GX_OLD:=B$GXPOS
	MOV	AX,B$GRPACY	;move first y coordinate into B$GY_OLD
	MOV	B$GY_OLD,AX	;B$GY_OLD:=B$GYPOS
	cCall	B$COORD2	; process second coord pair

	MOV	AX,style
	MOV	B$LINSTL,AX	; Set LINE STYLE
	MOV	AX,color	; [AX] = COLOR ATTRIBUTE
	CALL	B$CLRATR 	;SET COLOR
	MOV	AX,B$GX_OLD	; [AX] = B$GX_OLD
	MOV	DX,B$GY_OLD	; [DX] = B$GY_OLD
	MOV	CX,fBF		; [CX] = box fill flag
	JCXZ	REGLIN		; 0 = NORMAL LINE
	LOOP	BOXFIL		; 2 = DO BOX WITH FILL
	JMP	SHORT BOXNF1	; 1 = DO BOX, NO FILL

REGLIN: 			;DO NORMAL LINE
	XCHG	AX,CX		; [CX] = B$GX_OLD
	CALL	B$LINDRW 	;DRAW LINE FR.(CX,DX) TO (B$GXPOS,B$GYPOS)
	JMP	SHORT LINE_90	; and exit

BOXNF1:
	XCHG	AX,CX		; [CX] = B$GX_OLD
	CALL	B$BOXNOF 	; draw box
	JMP	SHORT LINE_90	;EXIT LINE STATEMENT

BOXFIL:
	LOOP	ERRFC		; else FUNCTION CALL ERROR
	XCHG	AX,CX		; [CX] = B$GX_OLD
	CALL	B$DOBOXF 	; do the box fill

LINE_90:

	MOV	B$LINSTL,-1	; RESTORE LINE STYLE TO SOLID

cEnd

ERRFC:	JMP	B$ERR_FC	;ILLEGAL FUNCTION CALL


	PAGE
	SUBTTL	Line Statement Support Routines
;***
;B$BOXNOF
;
;Purpose:
; Draw a BOX.
;
;Entry:
;
;Exit:
;
;Uses:
;
;******************************************************************************
cProc	B$BOXNOF,<NEAR,PUBLIC>
cBegin
	MOV	BX,B$GYPOS
	PUSH	BX		;SAVE Y2
	PUSH	DX		;SAVE Y1
	XCHG	DX,BX		;MOVE Y2 TO Y1
	CALL	B$LINDRW 	;DO TOP LINE
	POP	BX		;MOVE Y1 TO Y2
	MOV	B$GYPOS,BX
	XCHG	DX,BX		;RESTORE Y1 TO [DX]
	CALL	B$LINDRW
	POP	BX		;GET BACK Y2
	MOV	B$GYPOS,BX	;AND RESTORE
	MOV	BX,B$GXPOS	;GET X2
	PUSH	CX		;SAVE X1
	MOV	CX,BX		;SET X1=X2
	CALL	B$LINDRW
	POP	BX
	MOV	B$GXPOS,BX	;SET X2=X1
	MOV	CX,BX		;RESTORE X1 TO [CX]
cEnd	nogen			;fall into B$LINDRW

;***
;B$LINDRW
;
;Purpose:
; Draw a line.
;
;Entry:
;
;Exit:
;
;Uses:
;
;******************************************************************************
cProc	B$LINDRW,<NEAR,PUBLIC>,<SI,DI> 
cBegin
	PUSH	CX		;SAVE COORDINATES
	PUSH	DX
	CALL	DOGRPH
	MOV	AX,B$GRPACX	;RESTORE ORIGINAL SECOND COORDINATE
	MOV	B$GXPOS,AX
	MOV	AX,B$GRPACY	;FOR B$BOXNOF CODE
	MOV	B$GYPOS,AX
	POP	DX
	POP	CX
cEnd


;***
;HorizLine		Draw a horizontal line
;
;Purpose:
; Draw a horizontal line using.
;
;Entry:
; [DX]	= B$GYPOS = y1 = y2
; [cx]	= x1
; B$GXPOS = x2
;
;Exit:
; Graphics accumulators updated.
;
;Modifies:
; bx,si,ax,cx,dx
;
;******************************************************************************
HorizLine:
	call	B$XDELT		; bx = abs(x2-x1)
	pushf			; remember flag setting
	push	cx		; save x
	jnc	noxchg		; x1 < x2
	xchg	cx,[B$GXPOS]	;ensure CX = MIN(X1,X2)
noxchg:
	inc	bx		; bx = # of pixels to draw
	push	bx		; preserve bx across mapxyc
	call	[b$MapXYC]	;set graphics cursor to (x1,y1)
	pop	bx		; restore pixel count
	call	[b$NSetC]	;draw the line
	pop	cx		; restore x
	popf			; recall if exchange took place
	jnc	nosort		; x1 and x2 were not exchanged
	xchg	cx,[B$GXPOS]	;ensure CX = MIN(X1,X2)
nosort:
	ret

;***
;DOGRPH
;
;Purpose:
; DRAWS A LINE FROM ([CX],[DX]) TO (B$GXPOS,B$GYPOS)
;
;Entry:
;
;Exit:
;
;Uses:
;
;******************************************************************************
DOGRPH:
	CALL	CLIPP		; Clip the line before plotting
	JZ	DOGRP0		; Brif line is visible, plot it
	RET
DOGRP0:
	XCHG	CX,[B$GXPOS]	;ensure CX = MIN(X1,X2)
	XCHG	DX,[B$GYPOS]	;ensure DX = MIN(Y1,Y2)

	cmp	B$LINSTL,-1	; line style active ?
	jnz	nohorizontal	; brif so (do not special case
				; horizontal line if line style
				; active)
	cmp	dx,B$GYPOS	; y1 = y2?
	je	HorizLine	; special case horizontal line
nohorizontal:
	MOV	AX,B$GXPOS	
	MOV	BX,B$GYPOS	
	MOV	DI,B$LINSTL	
	;	draw a line between (AX,BX) and (CX,DX) with linestyle (DI),
	;	color in b$AttrC
	CALL	B$LineXYV	;call low-level

DOGRPHX:			
	mov	[B$LINSTL],di	;[speed]
	RET

	PAGE
	SUBTTL	LINE CLIPPING ROUTINES

;***
;CLIPP
;
;Purpose:
; Line clipping routine
;
;Entry:
; [CX]	= x1
; [DX]	= y1
; B$GXPOS= x2
; B$GYPOS= y2
;
;Exit:
; ZF set if the line is visible.
; NZ if the line is not visible.
;
;Uses:
;
;
;******************************************************************************
CLIPP:
	CALL	CLIPC		;status of visibility, [AL]=p1, [AH]=p2
CLIPP0:
	OR	AX,AX
	JZ	CLIPPX		;Brif points visible
	TEST	AL,AH		;Any octant common?
	JNZ	CLIPPX		;Brif line outside, not visible
	OR	AL,AL		;Line may be visible, try to clip
	JNZ	CLIPP1		;Brif point 1 not visible
	XCHG	CX,[B$GXPOS]	;ensure CX = MIN(X1,X2)
	XCHG	DX,[B$GYPOS]	;ensure DX = MIN(Y1,Y2)
	XCHG	AL,AH		; exchange point 1,2 status
CLIPP1:
	MOV	BX,B$VXMIN
	SAR	AL,1
	JB	CLIPX1		;If x1 .lt. vx1, modify x1,y1
	MOV	BX,B$VXMAX
	SAR	AL,1
	JB	CLIPX1		;If x1 .lt. vx2, modify x1,y1
	MOV	BX,B$VYMIN
	SAR	AL,1
	JB	CLIPY1		;If y1 .lt. vy1, modify x1,y1
	SAR	AL,1
	JNB	CLIPP2
	MOV	BX,B$VYMAX	;If y1 .gt. vy2, modify x1,y1
CLIPY1:
	CALL	MODXY2
	JMP	SHORT CLIPP2
CLIPX1:
	CALL	MODXY1
CLIPP2:
	CALL	B$CLIPCK 	;[AL]= new status for current point
	JMP	SHORT CLIPP0	;Try for further clipping

CLIPC:
	PUSH	CX		;Save x1
	PUSH	DX		;Save y1
	CALL	B$CLIPCK 	;Get status of p(x1,y1)
	XCHG	AH,AL		;[AH]= p1 status
	MOV	CX,B$GXPOS	;x2
	MOV	DX,B$GYPOS	;y2
	CALL	B$CLIPCK 	;Get status of p(x2,y2)
	XCHG	AH,AL		;[AH]= p2 status, [AL]= p1 status
	POP	DX		;y1
	POP	CX		;x1
CLIPPX:
	RET

;***
;MODXY1
;
;Purpose:
; Modify (clip) x,y into VIEW range
; Given: x1,y1 and x2,y2 - clip x1,y1
;
; x is set to VIEW boundary: vx1 or vx2
; y= y1+(y2-y1)/(x2-x1)*(vx1 or vx2-x1)
;
;Entry:
; [BX]= View boundary vx1, vx2, vy1, or vy2
; [CX]= x, [DX]= y
;
;Exit:
;
;Uses:
;
;******************************************************************************
MODXY1:
	PUSH	AX		;Save VIEW status
	PUSH	BX		;Save boundary
	SUB	BX,CX		;[BX]= boundary-x1
	MOV	SI,BX		;[SI]= Dxb
	MOV	BX,B$GXPOS
	SUB	BX,CX		;[BX]= (Dx)=x2-x1
	MOV	CX,SI		;[CX]= Dxb
	MOV	SI,DX		;[SI]= y1
	MOV	AX,B$GYPOS
	SUB	AX,DX		;[AX]= (Dy)=y2-y1
	CWD			;Extend sign into [DX]
	CALL	B$IDIVBX 	;[AX]= (D)=Dy\Dx
	PUSH	DX		;[DX]= (R)=Dy remainder Dx
	IMUL	CX		;[AX]= D*Dxb
	ADD	SI,AX		;[SI]= y1+D*Dxb
	POP	AX
	IMUL	CX		;[DXAX]= R*Dxb
	SAL	AX,1
	RCL	DX,1		;[DXAX]= R*Dxb*2
	CALL	B$IDIVBX 	;[AX]= (R*Dxb*2)\Dx
	OR	AX,AX		; Simulate CINT(R*Dxb/Dx)
	JS	modxyc		;don't inc if neg
	INC	AX		;[AX]= (R*2*Dxb)\Dx+1
modxyc:
	SAR	AX,1		;[AX]= ((R*2*Dxb)\Dx+1)\2
	ADD	AX,SI		;[AX]= y1+D*Dxb+((R*2*Dxb)\Dx+1)\2
	MOV	DX,AX		;[DX]= New Y
	POP	CX		;[CX]= New X
	POP	AX		;View Status
	RET


;***
;B$IDIVBX - Simulate IDIV instruction
;
;Purpose:
; Perform an "IDIV BX" after making sure neither a /0 or overflow error will
; occur. The test for overflow is that the next power of two larger than each
; of the two numbers is found and if the difference is more than 2^14, an
; overflow is flagged.
;
;Entry:
; [BX]	  = denominator
; [DX:AX] = numerator
;
;Exit:
; [AX]	  = quotient
; [DX]	  = remainder
;
;****

cProc	B$IDIVBX,<NEAR,PUBLIC>
cBegin
	OR	BX,BX		;Is denominator 0?
	JZ	ERR0		;Error if so.

	PUSH	AX
	OR	AX,DX		;Is numerator 0?
	POP	AX
	JZ	RET0		;If so, return 0 for quotient & remainder.

;	Both numerator and denominator are non-zero.  Now take the absolute
;	values of each and figure the difference in the magnitudes of the
;	two numbers by finding the next power of two larger than each.
;	If the difference in magnitudes is more than 2^14, give B$ERR_OV.


	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX

	XOR	CX,CX		;CH=magnitude of numerator
				;CL=magnitude of denominator
	OR	BX,BX		;Is BX negative?
	JNS	BXPOS		;If so, negate it
	NEG	BX
BXPOS:
	OR	DX,DX		;Is DX:AX negative?
	JNS	DXAXPOS 	;If so, negate it
	NOT	AX
	NOT	DX
	ADD	AX,1
	ADC	DX,0
DXAXPOS:

BXLOP:
	INC	CL		;Figure BX's magnitude
	SHR	BX,1
	JNZ	BXLOP
				;Figure DX:AX's magnitude
	OR	DX,DX
	JZ	AXLOP
	MOV	CH,16d
	MOV	AX,DX
AXLOP:
	INC	CH
	SHR	AX,1
	JNZ	AXLOP

	SUB	CH,CL		;Figure difference in magnitudes
	CMP	CH,14d		;More than 2^14?
	JG	GOVERR		;Error if so

	POP	DX
	POP	CX
	POP	BX
	POP	AX

	IDIV	BX		;Now that /0 errors and overflows
				;have been ruled out, it's OK to
				;do an IDIV.
RET0:
cEnd


ERR0:
	JMP	B$ERR_DV0
GOVERR:
	JMP	B$ERR_OV


MODXY2:
	CALL	INTXY2		;xchg x1,y1 B$GXPOS,B$GYPOS
	CALL	MODXY1		;Clip x1,y1
INTXY2:
	XCHG	CX,DX		;xchg x1,y1 B$GXPOS,B$GYPOS
	PUSH	B$GXPOS
	PUSH	B$GYPOS
	POP	B$GXPOS
	POP	B$GYPOS
	RET


	PAGE
	SUBTTL	LINE UTILITIES
;***
;B$CLINE2
;
;Purpose:
;
;Entry:
;
;Exit:
;
;Modifies:
;
;******************************************************************************
cProc	B$CLINE2,<NEAR,PUBLIC>
cBegin
	MOV	AX,B$GRPACX	;DRAW LINE FROM [CX],[DX]
	MOV	B$GXPOS,AX	;TO B$GRPACX,Y
	MOV	AX,B$GRPACY
	MOV	B$GYPOS,AX
	JMP	B$LINDRW 	;GO DRAW THE LINE
cEnd	nogen


;***
;B$GTABSC - GET ABSOLUTE COORDS
;
;Purpose:
; ([CX],[DX])=(B$GRPACX+[CX],B$GRPACY+[DX])
;
;Entry:
; B$GRPACX = x center
; B$GRPACY = y center
;
;Exit:
; [cx]	 =  x center
; [dx]	 =  y center
;
;Modifies:
;	cx,dx
;
;******************************************************************************
cProc	B$GTABSC,<NEAR,PUBLIC>
cBegin
	ADD	CX,[B$GRPACX]	;[CX]=X CENTER + [CX]
	ADD	DX,[B$GRPACY]	;[DX]=Y CENTER + [DX]
cEnd


;***
; B$LineXYV - Draw a line
;
;Purpose:
;	Moved here from LLCGRP with revision [16].
;	Draw a line in a given style between two points.  The line will
;	be drawn according to the pattern given in the Line style mask
;	(DI).  For each pixel that is going to be set for the line,
;	the corresponding bit in DI is tested.	If it is 1, the pixel
;	is set, otherwise that pixel is skipped.  If the line is longer
;	than 16 pixels, the line style mask is repeated.
;
;Entry:
;	DI = Line style mask
;	AX,BX = one end point X,Y
;	CX,DX = other end point X,Y
;
;Exit:
;	DI = Line style mask
;
;Uses:
;	DI is used as an input parameter and may be modified as it is
;	rotated to get successive bits to test.
;
;Exceptions:
;	none
;******************************************************************************
cProc	B$LineXYV,<NEAR>,<BP,SI,ES>
cBegin
	CMP	AX,CX		;make sure X <= X2
	JLE	Line1		;go if (AX,BX) left of (CX,DX)
	XCHG	AX,CX		;ensure leftmost point in (AX,BX)
	XCHG	BX,DX		;line will always move left to right
Line1:				
	SUB	CX,AX		;CX <- X distance (will be >= 0)
	SUB	DX,BX		;DX <- Y distance
	MOV	SI,DX		;SI <- abs(Y distance)
	JGE	Line2		
	NEG	SI		
Line2:				
	PUSH	CX		;save axes directed distances
	PUSH	DX		
	MOV	CX,AX		;set up raster offset and pixel bit mask
	MOV	DX,BX		;  (point in CX,DX for MAPXYC)
	CALL	[b$MapXYC]	
	CALL	[b$SetPixFirstC] ;set up ES and EGA, if applicable
	POP	DX		;restore axes distances
	POP	CX		
				
	OR	DX,DX		;Y distance negative?
	MOV	DX,b$BytesPerRow   ;bytes per pixel line (assume positive)
	JNS	Line3		;go if positive
	NEG	DX		;negate direction
Line3:
	MOV	b$IncrY,DX	;save for Y update of BP
	MOV	BP,b$OffC	;BP <- raster offset
	CMP	SI,CX		;is X or Y the major axis?
	JGE	LineY		;go if Y is major
				;fall thru if X is major
LineX:				;X-major lines, CX <- major (X) axis length
	MOV	AX,SI		;Incr1 <- minor * 4
	SHL	AX,1		
	SHL	AX,1		
	MOV	b$Incr1,AX	
	SUB	AX,CX		;SI <- Incr1 - major
	XCHG	AX,SI		
	SUB	AX,CX		;Incr2 <- (minor - major) * 4
	SHL	AX,1		
	SHL	AX,1		
	MOV	b$Incr2,AX	
	INC	CX		;#points <- distance + 1
	MOV	AX,b$PenC	;AL <- bit accumulator
				;AH <- color info
	MOV	BH,AL		;BH <- current bit mask
	XOR	AL,AL		;clear pixel accumulator
	call	[b$LineX]	;draw X-major line
	jmp	short LineExit	
LineY:				;Y-major lines
	OR	CX,CX		;vertical line?
	JZ	LineV		;go if so
	MOV	AX,CX		
	SHL	CX,1		;Incr1 <- minor * 4
	SHL	CX,1		
	MOV	b$Incr1,CX	
	XCHG	CX,SI		;CX <- major (Y) axis length
	SUB	SI,CX		;SI <- Incr1 - major
	SUB	AX,CX		;Incr2 <- (minor - major) * 4
	SHL	AX,1		
	SHL	AX,1		
	MOV	b$Incr2,AX	
	INC	CX		;#points <- distance + 1
	MOV	AX,b$PenC	;AL <- bit accumulator
				;AH <- color info
	call	[b$LineY]	;draw Y-major line
	jmp	short LineExit	
LineV:				;vertical lines
	MOV	CX,SI		;#points <- distance + 1
	INC	CX		
	MOV	AX,b$PenC	;AL <- bit accumulator
				;AH <- color info
	call	[b$LineV]	;draw vertical line
LineExit:			
	CALL	[b$SetPixLastC] ;reset EGA for BIOS
cEnd
sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\grinit.asm ===
TITLE	GRINIT - GRAPHICS COMPONENT INITIALIZATION
;***
; GRINIT - GRAPHICS COMPONENT INITIALIZATION
;
;	Copyright <C> 1986 - 1988, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

;-------------------------------------------------------------------------------
;
;-----	Guide to Graphics Package Organization			7/16/86
;
;
;      The graphics package has been reorganized into several small modules
;      in order to reduce the size of compiled programs which use little or
;      no graphics.  This guide shows which modules contain which graphics
;      statements or routines.
;
;
;      LOCATION (MODULE)	   STATEMENT(s)
;      -------- --------	   ------------
;
;      circle.asm . . . . . . . . .circle
;
;      draw.asm . . . . . . . . . .draw
;
;      getput.asm . . . . . . . . .get
;				   put
;
;      grinit.asm . . . . . . . . .code used at initialization:
;				   viewport init: (B$VWINI,B$VEWINI)
;				   graphics init: (B$GRPINI)
;				   move utility:
;				       (B$MOV$MR)
;				   transformation routines (part of pmap):
;				       (B$MAPBXL,B$MAPBYL)
;
;      grputil.asm . . . . . . . . graphics utilities:
;				   coordinate processing routines:
;				       ($gsv,B$XYSAVE,$save1)
;				   attribute parser: B$CLRATR
;				   pixel clipping routine: B$INVIEW
;
;      grpmap.asm . . . . . . . . .point (arg) function
;				   rest of pmap function
;				   transformation routines (part of pmap):
;				       ($maplpx,$maplpy,$maplx1,$maply1)
;
;      gw2grp . . . . . . . . . . .gw2.0 graphics features:
;				   VIEW
;				   window
;
;      linept.asm . . . . . . . . .line
;				   point (x,y) function
;				   pset
;				   preset
;
;      paint.asm . . . . . . . . . paint
;
;      vwclr.asm . . . . . . . . . clear screen support:
;				   viewport clear: (B$VWCLR,B$VWFILL)
;				   box fill (part of line):
;				       (B$DOBOXF,boxtst,boxclp,clipck,B$SCALXY)
;				   line utilities:
;				       ($xchgx,$xchgy,$xchgac,B$XDELT,B$YDELT,
;					clipck,B$SCALXY)
;
;------------------------------------------------------------------------------
	INCLUDE switch.inc
	INCLUDE rmacros.inc	

	useSeg	_DATA		
	useSeg	_BSS		
	useSeg	GR_TEXT 	
	useSeg	DV_TEXT 	
	useSeg	<XIB>		; XIB and XIE must bracket XI!
	useSeg	<XI>		; initializer segment
	useSeg	<XIE>		

	INCLUDE seg.inc 	
	INCLUDE idmac.inc	; Internal debugging macros
	INCLUDE compvect.inc	; Initialization vectors

	INITIALIZER B$xGRINI	;Put B$xGRINI in initializer list

sBegin	_DATA			

	globalW	b$pFPGRINI,B$NearRet,1 ; vector to indirectly call B$FPGRINI

	externW	b$VWCLR_PTR
	externW	b$VWINI_PTR

	externW b$run_disp	; RUN time initialization dispatch table
	externW b$clr_disp	; CLEAR statement support dispatch table
	externW b$err_disp	; error dispatch table


sEnd	_DATA			

sBegin	_BSS			
;
;#***************************************************************************
; External low-level function vectors
;#***************************************************************************
;
externW b$MapXYC		
externW b$SetAttr		
externW b$PalReset		
;#***************************************************************************

	externB B$COPTFL 	; Circle options flag

staticB ScreenLocked,,1 	; Screen is locked flag

	EXTRN	B$GRPACX:WORD	;defined in GWDATA.ASM
	EXTRN	B$GRPACY:WORD	;defined in GWDATA.ASM

	externB	B$WNDWSC	; defined in GWDATA.ASM
	externB	B$WNDWSW	; defined in GWDATA.ASM

	globalW B$VXSIZ,,1	;Viewport horiz size
	globalW B$VYSIZ,,1	;Viewport vert size
	globalW B$VXMIN,,1	;Viewport minimum X coord
	globalW B$VXMAX,,1	;Viewport maximum Y coord
	globalW B$VYMIN,,1	;Viewport minimum X coord
	globalW B$VYMAX,,1	;Viewport maximum Y coord
	globalW B$VXOFF,,1	;Viewport offset X
	globalW B$VYOFF,,1	;Viewport offset Y

	globalW B$VXDIF,,1	; View x displacement
	globalW B$VYDIF,,1	; View y displacement

	externB	B$VIEWSW	; defined in GWDATA.ASM
	externB	B$VIEWSC	; defined in GWDATA.ASM

	EXTRN	B$DFRACX:WORD	;defined in GWDATA.ASM

	EXTRN	B$LINSTL:WORD	;defined in GWDATA.ASM

	EXTRN	B$LENDRW:ABS	;defined in GWDATA.ASM
	EXTRN	B$DRWSCL:WORD	;defined in GWDATA.ASM
	EXTRN	B$DRWANG:WORD	;defined in GWDATA.ASM

sEnd	_BSS			


sBegin	DV_TEXT 			
	externNP	B$NearRet	;for disp vectors in compvect.inc
sEnd	DV_TEXT 			

sBegin	GR_TEXT 		
assumes CS,GR_TEXT		

externNP B$RESETSCN		
;OEM routines:
	externNP B$GRMODE	
	externNP B$GrScreenSize 
externNP B$MapVWC		
	EXTRN	B$VWCLR:NEAR


	PUBLIC	B$VWINI
	PUBLIC	B$GRPINI
	PUBLIC	B$VEWINI
	PUBLIC	B$VWMAPC

	PAGE
	SUBTTL	Graphics initialization routines
;***
;B$xGRINI - Initializer for the graphics component
;PLM B$xGRINI()
;
;Purpose:
;
;Entry:
; None.
;
;Exit:
;	Appropriate dispatch vectors filled.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xGRINI,<FAR> 	
cBegin				
;
;	update "RUN" time initialization dispatch address to B$VWINI
;
	MOV	WORD PTR [b$run_disp].GR_RVEC,GR_TEXTOFFSET B$GRINI	
;
;	update CLEAR statement dispatch address to B$GRPRST
;
	MOV	WORD PTR [b$clr_disp].GR_CVEC,GR_TEXTOFFSET B$GRPRST	
;
;	update ERROR dispatch address to B$GRREST
;
	MOV	WORD PTR [b$err_disp].GR_ERVEC,GR_TEXTOFFSET B$GRREST 

	MOV	[b$VWINI_PTR],OFFSET B$VWINI
	MOV	[b$VWCLR_PTR],OFFSET B$VWCLR
cEnd				

cProc	B$GRINI,<NEAR>		
cBegin				
	call	B$RESETSCN	;restore the screen to the startup state
	call	[b$PalReset]	;reset the palette
cEnd				


;***
;B$GRPINI	Calculate center of viewport
;
;Purpose:
;		Calculate center of viewport (center of screen if no viewports)
;		saving in B$GRPACX, B$GRPACY. Find B$VXDIF and B$VYDIF if viewports
;		and windows.
;
;Entry:
;		none
;
;Exit:
;		variables updated as specified above
;
;Modifies:
;		none
;
;****

B$GRPINI:
	PUSH	AX
	PUSH	CX
	XOR	CX,CX		;Use Vx1= 0
	MOV	AX,WORD PTR B$VXSIZ ;and Vx2= max
	CMP	[B$VIEWSC],0	; if VIEW SCREEN
	JNZ	VWMAP2		;Brif so, else
	MOV	CX,WORD PTR B$VXMIN ;calculate x center
	MOV	AX,WORD PTR B$VXMAX ;using View port Vx1,Vx2
VWMAP2:
	SUB	AX,CX		;[AX]= Vx2-Vx1
	MOV	WORD PTR B$VXDIF,AX 
	INC	AX		;+1 since inclusive
	SHR	AX,1
	ADD	CX,AX		;[CX]= xmin+(xmax-xmin)/2
	MOV	B$GRPACX,CX

;	--------------
	XOR	CX,CX		;Use Vy1= 0
	MOV	AX,WORD PTR B$VYSIZ ;and Vy2= max
	CMP	[B$VIEWSC],0 ; if VIEW SCREEN
	JNZ	VWMAP3		;Brif so, else
	MOV	CX,WORD PTR B$VYMIN ;calculate y center
	MOV	AX,WORD PTR B$VYMAX ;using View port Vy1,Vy2
VWMAP3:
	SUB	AX,CX		;[AX]= Vy2-Vy1
	MOV	WORD PTR B$VYDIF,AX 
	INC	AX		;+1 since inclusive
	SHR	AX,1
	ADD	CX,AX		;[CX]= ymin+(ymax-ymin)/2
	MOV	B$GRPACY,CX
	POP	CX
	POP	AX
	RET


;***
;B$VWINI 	Initialize graphics viewport
;
;Purpose:
;		Initialize graphics viewport by setting viewport state
;		variables.  Center graphics cursor.  Calculate floating
;		point screen aspect ratio.
;
;Entry:
;		none
;
;Exit:
;		none
;
;Modifies:
;		none
;
;****
B$VWINI:
	PUSH	BX
	PUSH	AX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	PUSH	DI
	MOV	WORD PTR B$LINSTL,0FFFFh ;Set line style to solid
	CALL	B$VEWINI 	;Init viewport, center graphics cursor
	POP	DI
	POP	SI
	POP	DX
	POP	CX
	POP	AX
	POP	BX
	RET

;***
;B$VEWINI	 initialize viewport coordinates
;
;Purpose:
;		Initialize screen and viewport variables.  Calculate
;		window variables to make window transformations proceed
;		faster.
;
;Entry:
;		none
;
;Exit:
;		VIEW and window variables updated
;
;Uses:
;		Per convention.
;
;****

B$VEWINI:
	MOV	WORD PTR B$VIEWSW,0 ;Initially no VIEW (Clears B$VIEWSC also)
	CALL	B$GRMODE	;Legal graphics mode?
	JNZ	VEWIN0		;Yes: go init viewport
	RET			; else quit
VEWIN0:
	CALL	B$GrScreenSize   ;[CX]= B$VXSIZ, [DX]= B$VYSIZ
	MOV	WORD PTR B$VXSIZ,CX
	MOV	WORD PTR B$VYSIZ,DX
	XOR	AX,AX
VEWIN1:
	MOV	WORD PTR B$VXMIN,AX ;vx1= 0
	MOV	WORD PTR B$VYMIN,AX ;vy1= 0
	MOV	WORD PTR B$VXOFF,AX ;vx offset= 0
	MOV	WORD PTR B$VYOFF,AX ;vy offset= 0
	MOV	WORD PTR B$VXMAX,CX ;vx2= B$VXMAX
	MOV	WORD PTR B$VYMAX,DX ;vx2= B$VYMAX

;B$VWMAPC Caculates center of Viewport and stores in:
;	B$GRFACX,B$GRFACY (world coords), and B$GRPACX,B$GRPACY (physical coords).
;	Also calls B$MapVWC to set View bounds at 'CLOC' level so PAINT
;	works rapidly. Clears DRAW vars, recalculates WINDOW vars...

B$VWMAPC:
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	PUSH	DI		
	MOV	DI,OFFSET DGROUP:B$DRWSCL ;Init Draw dependent
	MOV	CX,B$LENDRW	;get external constant of vars
	XOR	AX,AX
	CLD
	REP	STOSB		
	POP	DI		
	POP	ES		
	MOV	WORD PTR B$DFRACX,100200O ;x,y fraction is 1/2
;	PUSH	BX			;Save possible text pointer
	MOV	AX,WORD PTR B$VXMIN
	MOV	BX,WORD PTR B$VXMAX
	MOV	CX,WORD PTR B$VYMIN
	MOV	DX,WORD PTR B$VYMAX
	push	bp		;save bp ($mapxyc will trash it)
	CALL	B$MapVWC	;Let OEM know viewport boundaries for PAINT.
;	--------------		now move "C" to center
	CALL	B$GRPINI 	;Center graphics cursor
	MOV	CX,B$GRPACX
	MOV	DX,B$GRPACY
;	--------------
	CALL	[b$MapXYC]	;Set CLOC/CMASK
	pop	bp		;restore bp after mapxyc calls

	JMP	[b$pFPGRINI]	; Initialize window variables

	PAGE
	SUBTTL	Graphics Initialization

	PUBLIC	B$GRPRST 	;Graphics Initialization routine
	EXTRN	B$GETFBC:NEAR

;***
;B$GRPRST	Reset graphics variables
;Purpose:
;	 B$GRPRST resets graphics.  It is called at initialization and whenever
;	 a CLEAR statement is executed.
;
;Entry:
;	none
;Exit:
;	graphics variables reset
;Modifies:
;	none
;****

B$GRPRST:
	PUSHF
	PUSH	AX
	PUSH	BX
	XOR	AX,AX
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	PUSH	DI
	PUSH	CX
	MOV	DI,OFFSET DGROUP:B$DRWSCL ;Init Draw dependent
	MOV	CX,B$LENDRW	;get external constant no. of vars
	CLD
	REP	STOSB		
	POP	CX
	POP	DI		
	POP	ES		
	MOV	WORD PTR B$DFRACX,100200O ;x,y fraction is 1/2
	MOV	BYTE PTR B$DRWSCL,AL ;Draw scale init
	MOV	BYTE PTR B$DRWANG,AL ;Draw angle init
	MOV	WORD PTR B$WNDWSW,0 ;Turn off windows
	CALL	B$VWINI		;Reset viewport, turn off window
				; and center the graphics cursor
	STC
	CALL	B$GETFBC 	;Get foreground/background colors
	CALL	[b$SetAttr]	;Set the default DRAW color
	POP	BX
	POP	AX
	POPF
	RET

;***
; B$GRREST - Reset graphics state variables.
;
;Purpose:
; Use at the end of a graphics statement, or when an error ocurrs which
; abnormally terminates a graphics statement, to reset state variables.
; Added with revision [6].
;
;Entry:
; None.
;
;Exit:
; Variables reset.
;
;Uses:
; Per convention.
;
;******************************************************************************
cProc	B$GRREST,<NEAR> 	
cBegin

	XOR	AX,AX
	MOV	B$COPTFL,AL	;Reset circle options.

cEnd





sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\grfpinit.asm ===
TITLE	GRFPINIT - FP & WINDOW GRAPHICS COMPONENT INITIALIZATION
;***
; GRFPINIT - FP & WINDOW GRAPHICS COMPONENT INITIALIZATION
;
;	Copyright <C> 1988, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - POINT Function - R4 entry point for 2-argument POINT function.
;
;      v = POINT(R4,R4)
;	     |
;	   B$PNR4
;
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

	useSeg	_DATA
	useSeg	_BSS
	useSeg	CONST
	useSeg	GR_TEXT
	useSeg	<XIB>		; XIB and XIE must bracket XI!
	useSeg	<XI>		; initializer segment
	useSeg	<XIE>

	INCLUDE seg.inc
	INCLUDE idmac.inc	; Internal debugging macros
	INCLUDE baslibma.inc	; useful macros


;******************************************************************************
;
; point data structure
;
;******************************************************************************
POINT	STRUC
fPoint	DB	(?)		;content flags
xI2	DW	(?)		;x coordinate as an I2
xR4	DW	2 DUP (?)	;x coordinate as an I4
yI2	DW	(?)		;y coordinate as an I2
yR4	DW	2 DUP (?)	;y coordinate as an I4
POINT	ENDS

fxI2	EQU	00000001B	;xI2 is valid
fxR4	EQU	00000010B	;xR4 is valid
fxStep	EQU	00001000B	;x represents a STEP value
fyI2	EQU	00010000B	;yI2 is valid
fyR4	EQU	00100000B	;yR4 is valid
fyStep	EQU	10000000B	;y represents a STEP value

	INITIALIZER	B$xFPGRINI ; Put B$xFPGRINI in initializer list

sBegin	_DATA
	externW b$pFPGRINI	; pointer to B$FPGRINI
	externW b$pFPCOORD	; pointer to B$FPCOORD
sEnd	_DATA

sBegin	_BSS

	externB b$point1	;first coordinate pair
	externB b$point2	;second coordinate pair
	externB b$ScreenMode	; defined in LLCGRP.ASM

	externW B$VXSIZ 	;defined in GRINIT.ASM
	externW B$VYSIZ 	;defined in GRINIT.ASM
	externW B$VXMIN 	;defined in GRINIT.ASM
	externW B$VYMIN 	;defined in GRINIT.ASM
	externW B$VXMAX 	;defined in GRINIT.ASM
	externW B$VYMAX 	;defined in GRINIT.ASM
	externW B$VXOFF 	;defined in GRINIT.ASM
	externW B$VYOFF 	;defined in GRINIT.ASM
	externW B$GRPACX	;defined in GWDATA.ASM
	externW B$GRPACY	;defined in GWDATA.ASM

	externB B$VIEWSC	; defined in GWDATA.ASM

	globalQ B$PXDIF,,1	;Used to Map Physical
	globalQ B$PYDIF,,1	;to Logical coordinates
	globalQ B$LXDIF,,1	; Used to Map Logical
	globalQ B$LYDIF,,1	; to Physical coordinates
	globalQ B$WXDIF,,1	;Window x displacement
	globalQ B$WYDIF,,1	;Window y displacement
	externD B$GRFACX	;defined in GWDATA.ASM
	externD B$GRFACY	; defined in GWDATA.ASM

	globalQ B$WXMIN,,1	; Window x min (*) MUST BE IN THIS ORDER
	globalQ B$WYMIN,,1	; Window y min (*)
	globalQ B$WXMAX,,1	; Window x max (*)
	globalQ B$WYMAX,,1	; Window y max (*)
	externW B$VXDIF 	;defined in GRINIT.ASM
	externW B$VYDIF 	;defined in GRINIT.ASM
	externB B$WNDWSW 	; defined in GRINIT.ASM
	externB B$WNDWSC 	; defined in GRINIT.ASM

	globalD B$ASPRF,,1	;Aspect ratio in s.p. floating format

sEnd	_BSS

sBegin	CONST

	externD b$FP_1		; s.p. constant   1.0
	externD b$FP_256	; s.p. constant 256.0

sEnd	CONST


sBegin	GR_TEXT
assumes CS,GR_TEXT

	externNP B$ftolrnd	
	externNP B$STOREFLAGS
	externNP B$DO_POINT

;OEM routines:
	externNP B$GetAspect

	externNP B$GRMODE	

	externNP B$fmldw
	externNP B$SCINIT	; Performs screen initialization
	externNP B$ERR_FC	; illegal function call

	PAGE
	SUBTTL	Graphics initialization routines
;***
;B$xFPGRINI - Initializer for the fp and WINDOW graphics component
;PLM B$xFPGRINI()
;
;Purpose:
;
;Entry:
;	None.
;
;Exit:
;	Appropriate dispatch vectors filled.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xFPGRINI,<FAR>
cBegin

	MOV	[b$pFPGRINI],GR_TEXTOFFSET B$FPGRINI
	MOV	[b$pFPCOORD],GR_TEXTOFFSET B$FPCOORD
cEnd

;***
; B$FPGRINI - combine FP stuff from B$GRPINI and VWINI with B$CLCWXY
; B$CLCWXY makes window transformation calculations go fast by
; eliminating the following common sub-expressions when Window is active:
;
; Given that VIEW set:
;
; B$VXDIF = Vx2-Vx1
; B$VYDIF = Vy2-Vy1
;
; then calculate:
;
; B$WXDIF = (Wx2-Wx1)
; B$WYDIF = (Wy2-Wy1)
;
; B$LXDIF = (Vx2-Vx1)/(Wx2-Wx1)
; B$LYDIF = (Vy2-Vy1)/(Wy2-Wy1)
;
; B$PXDIF = (Wx2-Wx1)/(Vx2-Vx1)
; B$PYDIF = (Wy2-Wy1)/(Vy2-Vy1)
;****

cProc	B$FPGRINI,<PUBLIC,NEAR>	; replaces all FP code from grinit.asm
cBegin
; following taken from B$VWINI
	CALL	B$GRMODE	;Legal graphics mode?
	JZ	GRPIN0		;If not Graphics mode, don't bother to calc
				; floating aspect ratio.
	CALL	B$GetAspect	;[BX] = OEM's aspect ratio*256 for this screen mode
	CALL	B$fmldw		; ST0 = aspect ratio*256
	FDIV	b$FP_256	; ST0 = aspect ratio
	FSTP	B$ASPRF		; Save floating aspect ratio, pop from ST0
	FWAIT
GRPIN0:

; following taken from B$VEWINI
labelNP	<PUBLIC,B$CLCWXY>	
	CMP	B$WNDWSW,0	; Don't reset Window to View
	JNZ	B$WNDINX 	;bounds if Window is active
	XOR	CX,CX		;make CXDX = s.p. zero
	XOR	DX,DX
	MOV	BX,OFFSET DGROUP:B$WXMIN
	CALL	B$MOV$MR 	;B$WXMIN= 0
	ADD	BX,4		
	CALL	B$MOV$MR 	; R8 zero!
	MOV	BX,OFFSET DGROUP:B$WYMIN
	CALL	B$MOV$MR 	;B$WYMIN= 0
	ADD	BX,4		
	CALL	B$MOV$MR 	; R8 zero!
	MOV	BX,B$VXSIZ	;BX:=screen size x direction
	CMP	[B$VIEWSC],0	; Is a VIEW screen stmt active?
	JNZ	CLCWXS		;Yes: window applies to entire screen
	MOV	BX,B$VXMAX	;Otherwise window applies to viewport
	SUB	BX,B$VXMIN	;therefore BX:=(B$VXMAX-B$VXMIN)
CLCWXS:
	CALL	B$fmldw		; push integer in BX onto numeric stack (ST0)

	FSTP	B$WXMAX		; B$WXMAX= FLOAT(BX)
	MOV	BX,B$VYSIZ	; BX:=screen size y direction
	CMP	[B$VIEWSC],0	; Is a VIEW screen stmt active?
	JNZ	CLCWYS		; Yes: window applies to entire screen
	MOV	BX,B$VYMAX	; Otherwise window applies to viewport
	SUB	BX,B$VYMIN	; therefore BX:=(B$VXMAX-B$VXMIN)
CLCWYS:
	CALL	B$fmldw		; push integer in BX onto numeric stack (ST0)
	FSTP	B$WYMAX		; B$WYMAX= FLOAT(BX)

labelNP	<PUBLIC,B$WNDINX>	
	FLD	B$WXMIN
	FSUBR	B$WXMAX		; ST0 = B$WXMAX - B$WXMIN
	FST	B$WXDIF		; B$WXDIF= (Wx2-Wx1), ST0 unchanged

	FIDIVR	B$VXDIF		; ST0 = B$VXDIF/B$WXDIF
	FST	B$LXDIF		; B$LXDIF= (Vx2-Vx1)/(Wx2-Wx1), ST0 unchanged
	FDIVR	b$FP_1 		; ST0 = 1.0/B$LXDIF = (Wx2-Wx1)/(Vx2-Vx1)
	FSTP	B$PXDIF		; B$PXDIF= (Wx2-Wx1)/(Vx2-Vx1)

	FLD	B$WYMIN
	FSUBR	B$WYMAX		; ST0 = B$WYMAX - B$WYMIN
	FST	B$WYDIF		; B$WYDIF= (Wy2-Wy1), ST0 unchanged

	FIDIVR	B$VYDIF		; ST0 = B$VYDIF/B$WYDIF
	FST	B$LYDIF		; B$LYDIF= (Vy2-Vy1)/(Wy2-Wy1), ST0 unchanged
	FDIVR	b$FP_1 		; ST0 = 1.0/B$LYDIF = (Wy2-Wy1)/(Vy2-Vy1)
	FSTP	B$PYDIF		; B$PYDIF= (Wy2-Wy1)/(Vy2-Vy1)

	MOV	BX,B$GRPACX	; [BX]= Physical x coordinate
	CALL	B$MAPBXL 	; ST0=  World	x coordinate
	FSTP	B$GRFACX 	; Store floating x coordinate
	MOV	BX,B$GRPACY	; [BX]= Physical y coordinate
	CALL	B$MAPBYL 	; ST0 =  World   y coordinate
	FSTP	B$GRFACY 	; Store floating y coordinate
	FWAIT

cEnd	

PAGE
SUBTTL	Transformation routines used at initialization

;The following transformation routines comprise part of the PMAP function.
;They have been separated out into this module to reduce the size of compiled
;programs which do not use graphics since they are always called at initializa-
;tion.


labelNP	<PUBLIC, B$MAPBXL
	SUB	BX,B$VXOFF

labelNP	<PUBLIC, B$MAPPX2>
	MOV	CX,OFFSET DGROUP:B$WXMIN ;CX points at B$WXMIN
	MOV	DX,OFFSET DGROUP:B$PXDIF ;DX points at B$PXDIF
	PUSH	CX		;Save ptr to B$WXMIN
	CALL	MAPSUB		; Do mapping
	JMP	SHORT MAPYLX	;ST0= ST0+ Wc1 (or Wc2 if WINDOW)

labelNP	<PUBLIC, B$MAPBYL>
	SUB	BX,B$VYOFF

labelNP	<PUBLIC, B$MAPPY2>
	MOV	CX,OFFSET DGROUP:B$WYMIN ;CX points to B$WYMIN
	CALL	B$ISWNDW 	;Check window status flags
	JB	MAPYL1		;No need to invert y coord
	MOV	CX,OFFSET DGROUP:B$WYMAX ;Must invert y coord since current

MAPYL1:
	PUSH	CX
	MOV	DX,OFFSET DGROUP:B$PYDIF ;DX points to sub expr B$PYDIF
	CALL	MAPSUB		; Do mapping
	CALL	B$ISWNDW 	; Check window status flags
	JB	MAPYLX		; No need to invert y coord

	FCHS			; Negate expression for window( )-( ) form
MAPYLX:
	POP	BX		; Wy1 or Wy2
	FADD	QWORD PTR [BX]	; ST0 = ST0 + Wc1 (or Wc2 if WINDOW)
	RET

;***
;MAPSUB 	Mapper multiply subroutine
;
;Purpose:	Convert operand to single precision then multiply by single
;	precision number in [CXDX] returning single precision result on top
;	of numeric stack (ST0)
;
;Entry:
;	DX = ptr to s.p. operand 1
;	BX = integer operand 2
;
;Exit:
;	ST0 = (operand 1 * float(operand 2))
;
;Modifies:
;****
cProc	MAPSUB,<NEAR>
cBegin
	PUSH	DX		;Save ptr to B$PYDIF or B$PXDIF
	CALL	B$fmldw		;push integer in BX on numeric stack
	POP	BX		;B$PXDIF OR B$PYDIF
	FMUL	QWORD PTR [BX]	; ST0 = ST0 * d.p. number pointed to by BX
cEnd

;***
;B$MOV$MR	Move registers to memory
;Purpose:
;		Move contents of [CXDX] to memory location referenced by BX.
;Entry:
;		[CXDX] = bytes to be stored
;		BX = ptr to memory
;Exit:
;		referenced memory location <= [CXDX]
;Modifies:
;		none.
;****

cProc	B$MOV$MR,<PUBLIC,NEAR>	; entire routine
cBegin
	MOV	[BX],DX
	MOV	[BX+2],CX
cEnd

; B$ISWNDW -  Returns NC if WINDOW active
;	    Returns CY if no window or WINDOW SCREEN
cProc	B$ISWNDW,<PUBLIC,NEAR>	; entire routine
cBegin
	CMP	[B$WNDWSW],0	;WINDOW active?
	JZ	ISWNDC		;Brif not
	CMP	[B$WNDWSC],0	;WINDOW SCREEN active?
	JZ	ISWNDX		;brif not
ISWNDC:
	STC			;set carry flag
ISWNDX:
cEnd

	SUBTTL	Real point specification entrypoints
	PAGE
;***
; B$N1R4, B$S1R4, B$N2R4, B$S2R4 - Integer point specification
; void pascal B$N1R4(R4 x, R4 y)
;
;Purpose:
; Specify real coordinate pairs.
;	B$N1R4 	- "normal" first coordinate pair
;	B$S1R4 	- STEP first coordinate pair
;	B$N2R4 	- "normal" second coordinate pair
;	B$S2R4 	- STEP second coordinate pair
;
;Entry:
; x,y	= real x and y values.
;
;Exit:
; None.
;
;Uses:
; per convention
;
;******************************************************************************
cProc	B$S1R4,<FAR,PUBLIC>	;First STEP pair
cBegin	nogen

	MOV	CL,fxR4+fxStep+fyR4+fyStep	;indicate type of values
	SKIP	2				;fall into next routine

cEnd	nogen


cProc	B$N1R4,<FAR,PUBLIC>	;First pair
cBegin	nogen

	MOV	CL,fxR4+fyR4			;indicate type of values
	MOV	BX,OFFSET DGROUP: b$point1	;point at first pair table

cEnd	nogen


cProc	B$R4POINT,<FAR,PUBLIC> ;Common routine
parmD	x
parmD	y
cBegin	nogen

	POP	AX
	POP	DX		;[DX:AX] = return address
	POP	[BX].yR4	;store y coordinate
	POP	[BX].yR4+2	;store y coordinate
	POP	[BX].xR4	;store x coordinate
	POP	[BX].xR4+2	;store x coordinate
	JMP	B$STOREFLAGS	;go store flags and return

cEnd	nogen


cProc	B$S2R4,<FAR,PUBLIC>	;Second STEP pair
parmD	x
parmD	y
cBegin	nogen
	MOV	CL,fxR4+fxStep+fyR4+fyStep	;indicate type of values
	SKIP	2				;fall into next routine

cEnd	nogen


cProc	B$N2R4,<FAR,PUBLIC>	;Second pair
parmD	x
parmD	y
cBegin	nogen

	MOV	CL,fxR4+fyR4			;indicate type of values
	MOV	BX,OFFSET DGROUP: b$point2	;point at second pair table
	JMP	B$R4POINT

cEnd	nogen


	SUBTTL	B$PNR4 - POINT(X,Y) FUNCTION WHERE BOTH PARAMETERS ARE R4
	PAGE
;***
;B$PNR4 - POINT(X,Y) FUNCTION WHERE BOTH PARAMETERS ARE R4
;
;Purpose:
; This routine returns the color attribute of the point specified by the given
; (x,y) coordinate pair.  The graphics accumulators are preserved across calls
; to this function so that cases like line (x1,y1)-(x2,y2), point(x,y) will
; work.
;
;Input:
; x	= x coord
; y	= y coord
;
;Output:
; AX=attribute
;
;Modifies:
; per convention
;
;******************************************************************************
cbPoint	EQU 	13		;local copy of b$cbPoint
cProc	B$PNR4,<FAR,PUBLIC>
parmD	x			;x coordinate
parmD	y			;y coordinate
localV	point1,cbPoint		;place to put coordinate pair, if needed
cBegin

DbAssertRel  b$cbPoint,Z,cbPoint,GR_TEXT,<b$cbPoint not equal cbPoint in B$PNR4>
	CALL	B$SCINIT	;initialize screen if not already done

	LEA	BX,point1	;[BX] = pointer to local storage
	MOV	CL,22H		;[CL] = flag saying both are real
	cCall	B$GRMODE	; deturmine if we are in a text mode
	JE	ERRFC		; Brif so, function call error
	cCall	B$R4POINT,<seg_x,off_x,seg_y,off_y> ;format data at [point]
	cCall	B$DO_POINT	; go perform point function calling coord
cEnd

ERRFC:	JMP	B$ERR_FC	; ILLEGAL FUNCTION CALL

;***
;B$FPCOORD - Convert coords into integers if necessary.
;
;Purpose:
;
;Entry:
;	[SI]  = pointer to coordinate pair struct
;	[AL]  = structure flags
;
;Exit:
;	[AL]  = updated structure flags
;	structure updated
;
;Uses:
;
;Exceptions:
;	None.
;****
cProc	B$FPCOORD,<NEAR>
cBegin
	TEST	AL,fxI2		; does x need conversion?
	JNZ	COR2FP		; brif not

	FLD	DWORD PTR [SI].xR4
	CALL	B$ftolrnd	;[AX] = INT(ST0)
	MOV	[SI].xI2,AX	;Update I2 representation
	OR	[SI].fPoint,fxI2 ;Update flags
	MOV	AL,[SI].fPoint	; [AL] = updated flags
	TEST	AL,fyI2		; does y need conversion?
	JNZ	C2FP_EXIT	; brif not
;
;COR2FP - Convert 2nd coord into integer.
;
COR2FP:
	FLD	DWORD PTR [SI].yR4
	CALL	B$ftolrnd	;[AX] = INT(ST0)
	MOV	[SI].yI2,AX	;Update I2 representation
	OR	[SI].fPoint,fyI2 ;Update flags
	MOV	AL,[SI].fPoint	; [AL] = updated flags
C2FP_EXIT:
cEnd


sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\grcoord.asm ===
TITLE	GRCOORD - graphics point specification
	PAGE	56,132
;***
;GRCOORD - graphics point specification
;
;	Copyright <C> 1986 - 1988, Microsoft Corporation
;
;Purpose:
; This module contains point specification routines, and routines which will
; transform and convert those points as required.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	useSeg	_BSS		;Uninitialized data
	useSeg	_DATA		; Initialized data
	useSeg	GR_TEXT		;Graphics segments
	useSeg	RT_TEXT

	INCLUDE seg.inc 	;segment definitions & cmacros
	INCLUDE baslibma.inc	;useful macros

;******************************************************************************
;
; point data structure
;
;******************************************************************************
POINT	STRUC
fPoint	DB	(?)		;content flags
xI2	DW	(?)		;x coordinate as an I2
xR4	DW	2 DUP (?)	;x coordinate as an I4
yI2	DW	(?)		;y coordinate as an I2
yR4	DW	2 DUP (?)	;y coordinate as an I4
POINT	ENDS

fxI2	EQU	00000001B	;xI2 is valid
fxR4	EQU	00000010B	;xR4 is valid
fxStep	EQU	00001000B	;x represents a STEP value
fyI2	EQU	00010000B	;yI2 is valid
fyR4	EQU	00100000B	;yR4 is valid
fyStep	EQU	10000000B	;y represents a STEP value

b$cbPoint EQU	SIZE POINT
	PUBLIC	b$cbPoint	;Size of the point structure

;******************************************************************************
;
; point data storage
;
;******************************************************************************
sBegin	_BSS

globalB b$point1,,<b$cbPoint> ;first coordinate pair
globalB b$point2,,<b$cbPoint> ;second coordinate pair

globalB b$fpoint,,1		; point statement being processed flag

externB b$ScreenMode		
externB B$COPTFL			; CIRCLE option flag
externW B$GRPACX 		;graphics accumulator X
externW B$GRPACY 		;graphics accumulator Y
externW B$GXPOS
externW B$GYPOS
externW B$VXOFF			;Viewport offset X
externW B$VYOFF			;Viewport offset Y

externB	B$WNDWSW		; flag indicates WINDOW active

externB B$DFRACX 		;8 bit fraction x after

sEnd	_BSS

sBegin	_DATA			
globalW	b$pFPCOORD,B$ERR_FC,1	; vector to B$FPCOORD
globalW	b$pFPCOORDW,B$ERR_FC,1	; vector to B$FPCOORDW
sEnd	_DATA			

sBegin	RT_TEXT
externNP B$ERR_FC
sEnd

sBegin	GR_TEXT
assumes CS,GR_TEXT

externNP B$INVIEW		;determine if points within viewport


	SUBTTL	Integer point specification entrypoints
	PAGE
;***
; B$N1I2, B$S1I2, B$N2I2, B$S2I2 - Integer point specification
; void pascal B$N1I2(I2 x, I2 y)
;
;Purpose:
; Specify integer coordinate pairs.
;	B$N1I2 	- "normal" first coordinate pair
;	B$S1I2 	- STEP first coordinate pair
;	B$N2I2 	- "normal" second coordinate pair
;	B$S2I2 	- STEP second coordinate pair
;
;Entry:
; x,y	= integer x and y values.
;
;Exit:
; None.
;
;Uses:
; per convention
;
;******************************************************************************
cProc	B$S1I2,<FAR,PUBLIC>	;First STEP pair
cBegin	nogen

	MOV	CL,fxI2+fxStep+fyI2+fyStep	;indicate type of values
	SKIP	2				;fall into next routine

cEnd	nogen


cProc	B$N1I2,<FAR,PUBLIC>	;First pair
cBegin	nogen

	MOV	CL,fxI2+fyI2			;indicate type of values
	MOV	BX,OFFSET DGROUP: b$point1	;point at first pair table

cEnd	nogen


cProc	B$I2POINT,<FAR,PUBLIC> ;Common routine to set point struct
parmW	x
parmW	y
cBegin	nogen

	POP	AX
	POP	DX		;[DX:AX] = return address
	POP	[BX].yI2	;store y coordinate
	POP	[BX].xI2	;store x coordinate
labelNP	<PUBLIC,B$STOREFLAGS>	; entry point from R4 code
	MOV	[BX].fPoint,CL	;store flags
	MOV	B$COPTFL,0	; Reset it - CIRCLE may have left it set.
	PUSH	DX
	PUSH	AX		;put return address back on stack
	RET			;and we are done

cEnd	nogen


cProc	B$S2I2,<FAR,PUBLIC>	;Second STEP pair
parmW	x
parmW	y
cBegin	nogen
	MOV	CL,fxI2+fxStep+fyI2+fyStep	;indicate type of values
	SKIP	2				;fall into next routine

cEnd	nogen


cProc	B$N2I2,<FAR,PUBLIC>	;Second pair
parmW	x
parmW	y
cBegin	nogen

	MOV	CL,fxI2+fyI2			;indicate type of values
	MOV	BX,OFFSET DGROUP: b$point2	;point at second pair table
	JMP	B$I2POINT

cEnd	nogen

	SUBTTL	B$COORD - process & return integer coordinates
	PAGE
;***
;B$COORD, B$COORD1, B$COORD2 - get a coordinate pair
;
;Purpose:
; Calculate the physical screen coordinates of the given point. Relative
; coordinates, viewports and windowing are all considered in determining the
; final coordinates. Clipping is not done in this routine.
;
;Entry:
; [BX]	= pointer to point to be processed (B$COORD only)
;
;Exit:
; [CX]	= x value
; [DX]	= y value
; Graphics accumulators updated
;
;Modifies:
; per convention
;
;Notes:
; This routine used to be $COORDS, and contained switches for FG_SCRNROT
;
;******************************************************************************
cProc	B$COORD2,<NEAR,PUBLIC> ;Get second point in coord pair
cBegin	<nogen> 		
	MOV	BX,OFFSET DGROUP:b$point2 
	JMP	SHORT B$COORD	
cEnd	<nogen> 		

cProc	B$COORD1,<NEAR,PUBLIC> ;Get first point
cBegin	<nogen> 		
	MOV	BX,OFFSET DGROUP:b$point1 
cEnd	<nogen> 		

cProc	B$COORD,<NEAR,PUBLIC>
cBegin
	MOV	AL,[BX].fPoint	;[AL] = flags relating to coordinate pair
	OR	AL,AL		;See if there is a point to process
	JNZ	COORD_5 	;Jump if there is
	MOV	CX,B$GRPACX	;Return Graphics Accumulator x
	MOV	DX,B$GRPACY	;Return Graphics Accumulator y
	RET

COORD_5:
	PUSH	SI		;Save me
	MOV	SI,BX		;[SI] = pointer to point struct

	CMP	[B$WNDWSW],0	; Is window active?
	JZ	CORINT		;Jump if not, we should have INT's
	JMP	[b$pFPCOORDW]	; resumes at B$COORD_NOSTEP
;
; No window is active, so we expect to do integer calculations. Make sure that
; we have I2 representations for both our points.
;
CORINT:
	TEST	AL,fxR4+fyR4	;Is either coord an R4?
	JZ	CORINT1		;brif not - no conversion needed
	CALL	[b$pFPCOORD]	; make coords I2
CORINT1:
	MOV	CX,[SI].xI2	;[CX] = I2 representation of X
	MOV	DX,[SI].yI2	;[DX] = I2 representation of Y

	CMP	b$fpoint,1	;processing point function ?
	JZ	B$COORD_NOSTEP	; if so do not add the bases
	TEST	AL,fxStep	;only need to test one, they come in pairs
	JZ	B$COORD_NOSTEP	; If not step, then don't add base
	ADD	CX,B$GRPACX	;Add current graphics accum to create step.
	ADD	DX,B$GRPACY

	JMP	SHORT COORD_STEP
labelNP	<PUBLIC,B$COORD_NOSTEP>	; B$FPCOORDW returns here
	ADD	CX,B$VXOFF	;ABSx = Vx1 +x
	ADD	DX,B$VYOFF	;ABSy = Vy1 +y
COORD_STEP:

	MOV	B$GRPACX,CX	;Update Graphics Accumulator x
	MOV	B$GXPOS,CX	;Copy
	MOV	B$GRPACY,DX	;Update Graphics Accumulator y
	MOV	B$GYPOS,DX	;Copy

	MOV	WORD PTR B$DFRACX,8080H ;Set Fractional x,y to 1/2
	XOR	AX,AX		
	MOV	[SI].fPoint,AL	;clear point flag for next time...

	CMP	b$ScreenMode,0	; graphics mode?
	JZ	FC_ERRR 	;Illegal function call
	POP	SI
	JMP	B$INVIEW 	;See if point in viewport

cEnd	nogen

FC_ERRR:
	JMP	B$ERR_FC	;ILLEGAL FUNCTION CALL

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\grputil.asm ===
TITLE	GRPUTIL - iAPX 88/86 GRAPHICS UTILITY ROUTINES
;***
; GRPUTIL - iAPX 88/86 GRAPHICS UTILITY ROUTINES
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Graphics utility routines.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	_BSS		
	USESEG	GR_TEXT 	

	INCLUDE seg.inc 	;segment definitions

sBegin	_BSS			
;
;****************************************************************************
; External low-level function vectors
;****************************************************************************
;
externW b$SetAttr		

	externW B$VXMIN		;defined in GWDATA.ASM
	externW B$VXMAX		;defined in GWDATA.ASM
	externW B$VYMIN		;defined in GWDATA.ASM
	externW B$VYMAX		;defined in GWDATA.ASM

sEnd	_BSS			

assumes CS,GR_TEXT		
sBegin	GR_TEXT 		

;low-level routines:

	externNP B$GETFBC

	externNP B$ERR_FC

	PAGE

	SUBTTL	GRAPHICS SUPPORT ROUTINES

;***
;
;B$CLRATR		PROCESS COLOR ATTRIBUTE FOR GRAPHICS STATEMENTS
;
;Purpose:
;	   This routine processes a color attribute for several graphics
;	   statements.	If the color attribute is defaulted, the default color
;	   is put into AL by a call to the OEM dependent routine B$GETFBC.  Next
;	   OEM routine SetAttr is called to set the current graphics attribute
;	   to the specified color.  If the color was invalid, SetAttr returns
;	   carry set and this routine issues a function call error.
;
;Entry:
;	AL=color attribute or AX=-1 if default color
;
;Exit:
;	AL=valid color attribute
;
;Modifies:
;	AX,BX
;
;****
cProc	B$CLRATR,<PUBLIC,NEAR>
cBegin
				;PROCESS COLOR ATTRIBUTE
	CMP	AX,-1		;IS DEFAULT COLOR NEEDED?
	JNE	SET_COLOR	;NO: USE SPECIFIED VALUE
	STC			;SET CARRY
	CALL	B$GETFBC 	;GET FG/BG COLORS
SET_COLOR:
	CALL	[b$SetAttr]	;SET ATTRIBUTE
	JC	FC_ERROR	;ABORT IF INVALID COLOR
cEnd

FC_ERROR:
	JMP	B$ERR_FC	;ILLEGAL FUNCTION CALL

	SUBTTL	COMPILER INTERFACE ROUTINES
	PAGE

;***
;
;B$INVIEW     Determine whether (x,y) coordinates within viewport boundaries
;
;Purpose:
;	  Test the (x,y) coordinates in (CX,DX) against the current viewport
;	  boundaries. The carry flag is cleared if either
;	  coordinate was outside the viewport boundary.
;
;Entry:
;	  CX=x coordinate DX=y coordinate
;
;Exit:
;	carry set if no coords changed, clear if either coord changed
;
;Modifies: none
;
;****
cProc	B$INVIEW,<PUBLIC,NEAR>
cBegin
				;See if x is in VIEW
	CMP	CX,B$VXMIN	;Is it off the left of the viewport
	JL	OUTVIEW 	;Yes, out of VIEW
	CMP	CX,B$VXMAX	;Is it off the right of the viewport
	JG	OUTVIEW 	;Yes, out of VIEW
	CMP	DX,B$VYMIN	;Is it off the top of the viewport
	JL	OUTVIEW 	;Yes, out of VIEW
	CMP	DX,B$VYMAX	;Is it off the bottom of the viewport
	JG	OUTVIEW 	;Yes, out of VIEW
	STC			;no, is in VIEW
	RET
OUTVIEW:
	CLC
	RET
cEnd	nogen

sEnd	GR_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\grpmap.asm ===
TITLE	GRPMAP - Graphics Window-to-Viewport transormation code
;***
; GRPMAP - Graphics PMAP and POINT functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; This module contains Window-to-Viewport transformation code. This code lives
; in a module of its own to allow us the opportunity to make low-level mathpack
; dependancies for these speed-critical transformations.
;
; BASIC Syntax mapping to included runtime entry points:
;
; - PMAP Function:
;
;      v = PMAP(x,n)
;	     |
;	   B$PMAP
;
; - POINT Function - There are two forms of this, one which takes 2 arguments
;		     (x and y coordinates), and one which takes only 1.
;		     The second form is given here:
;
;      v = POINT(n)
;	     |
;	   B$PNT1
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	_DATA
	useSeg	_BSS
	useSeg	GR_TEXT

	INCLUDE seg.inc

sBegin	_DATA
externW B$AC
sEnd	_DATA

sBegin	_BSS

externW B$VXMIN
externW B$VYMIN
externW B$VXOFF
externW B$VYOFF
externW B$GRPACX
externW B$GRPACY

externB B$VIEWSW		
externB B$VIEWSC		
externW B$VXOFF
externW B$VYOFF

externB B$WNDWSW		
externW B$GRFACX
externW B$GRFACY
externW B$GRFACX
externW B$GRFACY


sEnd	_BSS


sBegin	GR_TEXT
assumes CS,GR_TEXT


externNP B$ERR_FC
externNP B$fmldw		
externNP B$ftolrnd		
externNP B$MAPLX1		; AX = view x coord
externNP B$MAPLY1		; AX = view y coord
externNP B$GRMODE

externNP B$MAPPX2
externNP B$MAPPY2


	SUBTTL	B$PMAP - Map expression to Logical or Physical Coordinates
	PAGE

;***
; B$PMAP - Map expression to Logical or Physical Coordinates
; R4 pascal B$PMAP(R4 expr, I2 funct)
;
;Purpose:
; x = PMAP(expr,funct) - Function to map expression to logical or physical
; coordinates as follows:
;
;	funct = 0	Maps Logical  expr to Physical x.
;		1	Maps Logical  expr to Physical y.
;		2	Maps Physical expr to Logical  x.
;		3	Maps Physical expr to Logical  y.
;
;Input:
; expr	= S.P. expr value
; funct = function code 0-3
;
;Output:
; [AX]	= pointer to result
;
;Modifies:
; per convention
;
;Exceptions:
; Control may be transfered to B$ERR_FC
;
;******************************************************************************
cProc	B$PMAP,<FAR,PUBLIC>,<SI,ES>
parmD	expr			;R4 expression result
parmW	funct			;function to perform
cBegin


	PUSH	DS		
	POP	ES		;Set ES = DS
	CALL	B$GRMODE 	;Legal graphics mode?
	JZ	ERRFC		;Brif Illegal Graphics

	LEA	BX,expr 	;[BX] = pointer to R4
	MOV	SI,funct	;[SI] = function code
	CMP	SI,4		;Check funct range
	JB	MAPID2		;Must be in range 0-3
ERRFC:
	JMP	B$ERR_FC	  ;function call error
MAPID2:

	SHL	SI,1		;funct*2 for dispatch

	CALL	WORD PTR CS:MAPTBL[SI] ;Do the map

	MOV	BX,OFFSET DGROUP:B$AC ; semi-colons work well for comments!
	FSTP	DWORD PTR [BX]	; return result in FAC
	XCHG	AX,BX		; pointer in ax
	FWAIT			

cEnd

MAPTBL:
	DW	OFFSET MAPLXP	;Log X to Phy X
	DW	OFFSET MAPLYP	;Log Y to Phy Y
	DW	OFFSET MAPPXL	;Phy X to Log X
	DW	OFFSET MAPPYL	;Phy Y to Log Y
;
; Logical to physical transformation.
;
; These routines call transormation routines in grwindow.asm, which return
; an integer result in AX.
;
MAPLYP: 			;Map window y coord to VIEW y coord
	CALL	B$MAPLY1	; AX = integer value
	JMP	SHORT MAPLXP1	;go put it in ST0.
MAPLXP: 			;Map window x coord to VIEW x coord
	CALL	B$MAPLX1	; AX = integer value
MAPLXP1:
	XCHG	BX,AX		; BX = view coord
	JMP	B$fmldw	;push value on numeric stack

;
; Physical to Logical transformation.
;
; These routines all jump to code in grinit to complete there functions. The
; code resides there to reduce size of programs which do not use graphics.
; (At least that's what the comment over there says).
;
MAPPXL:
	FLD	DWORD PTR [BX]	
	CALL	B$ftolrnd	
	XCHG	AX,BX		;[BX]= INT(expr)
	JMP	B$MAPPX2 	;continue calculation of transformation
MAPPYL:
	FLD	DWORD PTR [BX]	
	CALL	B$ftolrnd	
	XCHG	AX,BX		;[BX]= INT(expr)
	JMP	B$MAPPY2 	;continue transformation


	SUBTTL	B$PNT1 - Single argument POINT function
	PAGE
;***
;B$PNT1 - Single argument POINT function
;R4 pascal B$PNT1(I2 funct)
;
;Purpose:
; x = POINT(funct) - Function to map expression to logical or physical
; coordinates as follows:
;
;	funct = 0	Returns the current Physical x coordinate
;		1	Returns the current Physical y coordinate
;		2	if WINDOW active
;			  Returns the current Logical  x coordinate
;			else
;			  Returns the current Physical x coordinate
;		3	if WINDOW active
;			  Returns the current Logical  y coordinate
;			else
;			  Returns the current Physical y coordinate
;
;Input:
; funct = function code 0-3
;
;Output:
; [AX]	= pointer to result.
;
;Modifies:
; Per convention
;
;Exceptions:
; Control may be transfered to B$ERR_FC
;
;******************************************************************************
cProc	B$PNT1,<FAR,PUBLIC>
parmW	funct			;function code
cBegin

	CALL	B$GRMODE 	;Legal graphics mode?
	JZ	ERRFC		;Brif Illegal Graphics

	MOV	CX,funct	;[CX] = function code
	CMP	CX,4		;Allow 0-3 if WINDOW Statement
	JNB	ERRFC		;Brif out of range


POINT0:
	MOV	BX,B$GRPACX
	MOV	DX,B$VXMIN
	JCXZ	POINTP		;if funct==0 then return Physical x

	LOOP	POINT_NOT1	;Jump if not function 1
	MOV	BX,B$GRPACY
	MOV	DX,B$VYMIN
POINTP:
	CMP	B$VIEWSW,0	;VIEW in effect?
	JZ	POINT4		;Brif not
	CMP	B$VIEWSC,0	;VIEW SCREEN option?
	JNZ	POINT4		;Brif so
	SUB	BX,DX		;else map into Viewport
POINT4:
	CALL	B$fmldw	; ST0 = integer in BX
POINT_EXIT:
	MOV	BX,OFFSET DGROUP:B$AC ; semi-colons work well for comments!
	FSTP	DWORD PTR [BX]	; return result in FAC
	XCHG	AX,BX		
	FWAIT			
cEnd

POINT_NOT1:

	DEC	CX		;In case we jump
	CMP	B$WNDWSW,0	;WINDOW active?
	JZ	POINT0		;Jump if not, CX = changed FCN (2->0, 3->1)

	MOV	BX,OFFSET DGROUP:B$GRFACX
	JCXZ	POINTF		;Jump if it was function 2
	MOV	BX,OFFSET DGROUP:B$GRFACY ;Function 3: return Logical y
POINTF:
	FLD	DWORD PTR [BX]	
	JMP	POINT_EXIT	

POINT_NOT3:

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\grpoint.asm ===
TITLE	GRPOINT - POINT statements & functions
	PAGE	56,132
;***
;GRPOINT - POINT statements & functions
;
;	Copyright <C> 1986 - 1988, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - POINT Function - There are two forms of this, one which takes 2 arguments
;		     (x and y coordinates), and one which takes only 1.
;		     The first form generates 1 of 3 possible calls depending
;		     on the types of the x and y arguments ('I2' and 'R4'
;		     represent 2-byte integer and 4-byte real arguments,
;		     respectively.  The R4 entry point is in grfpinit.asm )
;		     The second form is given in gw2grp.asm.
;
;      v = POINT(I2, I2)
;	     |
;	   B$PNI2
;
; - PSET Statement - the PSET statement calls different runtime routines
;		   depending on whether a color has been specified:
;
;    Examples:
;
;      PSET (x, y)[,color]	     PSET (x, y)
;	 |				 |
;      B$PSTC			       B$PSET
;
;
; - PRESET Statement
;
;      PRESET (x, y)[,color]
;	 |
;      B$PRST
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	_DATA
	useSeg	_BSS
	useSeg	GR_TEXT

	INCLUDE seg.inc
	INCLUDE idmac.inc

sBegin	_BSS
;
;****************************************************************************
; External low-level function vectors
;****************************************************************************
;
externW b$ReadC		
externW b$MapXYC		
externW b$SetC 		
externW b$SetAttr		


	EXTRN	B$GRAFACC:WORD	;defined in GWDATA.ASM
	externB b$ScreenMode	; defined in LLCGRP.ASM
	EXTRN	B$SIZEACC:ABS	;defined in GWDATA.ASM

	EXTRN	B$WNDWSW:WORD	;defined in GWDATA.ASM

	EXTRN	B$VXOFF:WORD	;defined in GWDATA.ASM
	EXTRN	B$VYOFF:WORD	;defined in GWDATA.ASM

externB	b$fpoint		; defined in grcoord.asm to indicate whether
				; we are processing point function or not.
sEnd	_BSS

sBegin	GR_TEXT
assumes CS,GR_TEXT

externNP B$INVIEW		;coordinate within current viewport?
externNP B$COORD		; process coordinate pair
externNP B$COORD1		; process coordinate pair
externFP B$I2POINT		;specify an I2 point

	EXTRN	B$ERR_FC:near

externNP B$SCINIT		; Performs screen initialization

;low-level routines:
	EXTRN	B$GETFBC:NEAR
externNP B$FetchC		
externNP B$StoreC		


externNP B$GRMODE			



	SUBTTL	B$PSTC - Set point with color
	PAGE
;***
;B$PSTC - PSET statement with attribute
;void pascal B$PSET(I2 color)
;
;Purpose:
; Process the PSET statement. Set the specified point to the specified color.
; PSTC_ENTRY is a local routine that takes the arg in BX.
;
;Input:
; color = color to be set
;
;Output:
; Graphics accumulators updated
;
;Modifies:
; Per convention
;
;******************************************************************************
cProc	B$PSTC,<FAR,PUBLIC>
parmW	color
cBegin

	CALL	B$SCINIT	; initialize screen if not already done
	MOV	AX,color	; get color to set
	cCall	DO_PSET 	; and process

cEnd

;***
;DO_PSET - PSET statement with attribute
;
;Purpose:
; Common code to process the PSET and PRESET statements. Set the specified
; point to the specified color.
;
;Input:
; [AX]	= color to be set
;
;Output:
; Graphics accumulators updated
;
;Modifies:
; Per convention
;
;******************************************************************************
cProc	DO_PSET,NEAR		
cBegin				

	CMP	b$ScreenMode,0	; text mode?
	JE	ERRIFC		; Brif so, function call error
	CALL	[b$SetAttr]	;SET COLOR ATTRIBUTE
	JC	ERRIFC		;ABORT IF INVALID COLOR
	CALL	B$COORD1	; PROCESS COORDINATES

	JNC	PSE_RET 	;EXIT IF POINT OUT OF BOUNDS
	CALL	[b$MapXYC]	;MAP X,Y COORDS TO SCREEN POSITION
	CALL	[b$SetC]	;DRAW THE POINT
PSE_RET:

cEnd

ERRIFC: JMP	B$ERR_FC	;ILLEGAL FUNCTION CALL

	SUBTTL	B$PSET - Set point with default color
	PAGE
;***
;B$PSET - PSET statement with no attribute
;void pascal B$PSET()
;
;Purpose:
; Process the PSET statement. Set the specified point to the default color.
;
;Input:
; None
;
;Output:
; Graphics accumulators updated
;
;Modifies:
; Per convention
;
;******************************************************************************
cProc	B$PSET,<FAR,PUBLIC,FORCEFRAME> 
cBegin
	CALL	B$SCINIT	; initialize screen if not already done
	STC			; SET CARRY
	CALL	B$GETFBC 	; GET FOREGRD/BACKGRD COLORS
PSET_5: 			
	CALL	DO_PSET 	; and do it
cEnd

	PAGE
	SUBTTL	B$PNI2 - POINT(X,Y) FUNCTION WHERE BOTH PARAMETERS ARE INTEGER
;***
;B$PNI2 - POINT(X,Y) FUNCTION WHERE BOTH PARAMETERS ARE INTEGER
;
;Purpose:
; This routine returns the color attribute of the point specified by the given
; (x,y) coordinate pair.  The graphics accumulators are preserved across calls
; to this function so that cases like line (x1,y1)-(x2,y2), point(x,y) will
; work.
;
;Input:
; x	= x coord
; y	= y coord
;
;Output:
; AX	= attribute
;
;Modifies:
; Per convention
;
;******************************************************************************
cbPoint EQU	13		;local copy of b$cbPoint

cProc	B$PNI2,<FAR,PUBLIC>
parmW	x			;x coordinate
parmW	y			;y coordinate
localV	point,cbpoint		;place to put coordinate pair, if needed
cBegin

DbAssertRel  b$cbPoint,Z,cbPoint,GR_TEXT,<b$cbPoint not equal cbPoint in B$PNI2>
	CALL	B$SCINIT	; initialize screen if not already done

	MOV	CX,x		;[CX] = X
	MOV	DX,y		;[DX] = Y
	cCall	B$GRMODE	; are we in a text mode?
	JE	ERRFC		; Brif so, function call error
	CMP	BYTE PTR B$WNDWSW,0 ; Is window active?
	JZ	PNI2_5		;No, go do stuff directly

	PUSH	CX		;parameters to B$I2POINT
	PUSH	DX
	LEA	BX,point	;[BX] = pointer to local storage
	MOV	CL,11H		;[CL] = flag saying both are integers
	cCall	B$I2POINT	;format data at [point]
	cCall	B$DO_POINT	; go perform point function calling coord
	JMP	SHORT PNI2_90	;and exit

PNI2_5:
	ADD	CX,WORD PTR B$VXOFF ;;ABSx= Vx1 +x
	ADD	DX,WORD PTR B$VYOFF ;;ABSy= Vy1 +y
	cCall	DO_POINT2	;perform point function on (cx,dx)
PNI2_90:

cEnd

ERRFC:	JMP	B$ERR_FC	; ILLEGAL FUNCTION CALL (centrally located)

	SUBTTL	PRESET statement with no attribute
	PAGE
;***
;B$PRST - PRESET statement with no attribute
;void pascal B$PRST()
;
;Purpose:
; Process the PRESET statement. Set the specified point to the backround color.
;
;Input:
; None
;
;Output:
; Graphics accumulators updated
;
;Modifies:
; Per convention
;
;******************************************************************************
cProc	B$PRST,<FAR,PUBLIC,FORCEFRAME> 
cBegin
	CALL	B$SCINIT	; initialize screen if not already done
	STC			; SET CARRY
	CALL	B$GETFBC 	; GET FOREGRD/BACKGRD COLORS
	XCHG	AX,BX		; [AX] = backround color
	JMP	SHORT PSET_5	; and set point
cEnd	nogen			


	SUBTTL	POINT helper routines
	PAGE
;***
;B$DO_POINT
;
;Purpose:
; Perform point function, saving the "B$GRAFACC", and calling B$COORD.
;
;Input:
; [BX]	= pointer to coordinate structure.
;
;Output:
; AX=attribute
;
;Modifies:
; per convention
;
;******************************************************************************
SIZEACC EQU	11		;local copy of B$SIZEACC

cProc	B$DO_POINT,<PUBLIC,NEAR>,<SI,DI,DS,ES> 
localV	savedacc,SIZEACC*2
cBegin


DbAssertRel  B$SIZEACC,Z,SIZEACC,GR_TEXT,<B$SIZEACC not equal SIZEACC in DO_POINT>

	MOV	CX,B$SIZEACC	;external constant
	MOV	SI,OFFSET DGROUP:B$GRAFACC ;point at graphics accum data
	PUSH	SS
	POP	ES		; ES = SS
	LEA	DI,savedacc
	PUSH	ES
	PUSH	DI		;Save interesting values
	PUSH	DS
	PUSH	SI
	PUSH	CX
	REP	MOVSW		;Save all graphics accums

	mov	b$fpoint,1	;indicate to B$COORD we are processing POINT
	.erre	ID_SSEQDS
	cCall	B$COORD	;[CX], [DX] = point
	mov	b$fpoint,0

	cCall	DO_POINT2

	POP	CX		;[CX] = restoration move count
	POP	DI
	POP	ES		;[ES:DI] = far ptr to B$GRAFACC
	POP	SI
	POP	DS		;[DS:SI] = far ptr to local storage
	REP	MOVSW		;Restore all graphics accums

cEnd


;***
;DO_POINT2
;
;Purpose:
; Perform point function, saving the graphics cursor
;
;Input:
; [CX]	= x
; [DX]	= y
;
;Output:
; AX=attribute
;
;Modifies:
; per convention
;
;******************************************************************************
cProc	DO_POINT2,<NEAR>,<SI>	
cBegin
	MOV	SI,CX		;Preserve CX around call to B$FetchC
	CALL	B$FetchC	;Get Graphics Cursor
	PUSH	CX		
	PUSH	BX		;Preserve the graphics cursor so cases like
	PUSH	AX		;LINE (x1,y1)-(x2,y2),POINT(x3,y3) will work
	MOV	CX,SI		;Restore X coordinate

	CALL	B$INVIEW 	;See if within viewport


	MOV	AX,-1		;ASSUME ILLEGAL POINT
	JNB	PNTNOT		;NOT LEGAL : RETURN -1
	CALL	[b$MapXYC]	;C:=(X,Y)
	CALL	[b$ReadC]	;READ OUT THE ATTRIBUTE
	xor	ah,ah		;AH:=AL7
PNTNOT:
	XCHG	DX,AX		;SAVE ATTRIBUTE
	POP	AX
	POP	BX
	POP	CX		
	CALL	B$StoreC	
	XCHG	DX,AX		;restore attribute

cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\grspace.asm ===
PAGE	56,132
	TITLE	GRSPACE - Compute space left in an array
;***
; GRSPACE - Compute space left in an array
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;
;	Graphics support routines for computing space left in an array.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	_BSS
	useSeg	GR_TEXT
	useSeg	FH_TEXT 

	INCLUDE seg.inc
	INCLUDE array.inc

sBegin	_BSS

externB b$HugeShift		;OS dependent selector increment

sEnd	_BSS

sBegin	FH_TEXT
externNP B$ADArraySize
sEnd	FH_TEXT

sBegin	GR_TEXT
assumes CS,GR_TEXT

externNP B$ERR_BS


	SUBTTL	B$ComputeSpace - Compute space left in an array.
	PAGE
;*** 
; B$ComputeSpace - compute space remaining in array
;
;Purpose:
;	Given an array descriptor and an address into the array,
;	compute the space, in bytes, from the address to the
;	end of the array.
;
;Entry:
;	fpData	= array address (possibly after the array starting address)
;	pAd	= array descriptor
;Exit:
;	[DX:AX] = array space remaining in bytes
;	[ES:SI] = start address to use
;Uses:
;
;Exceptions:
;	to B$ERR_BS
;******************************************************************************

cProc	B$ComputeSpace,<PUBLIC,NEAR>
parmD	fpData			;far ptr to start of array data
parmW	pAd			;pointer to array descriptor of interest
cBegin
	MOV	BX,pAd		;[BX] = pointer to array descriptor
	MOV	AX,[BX].AD_fhd.FHD_hData ;get seg from array desc
	CWD			
	OR	AX,DX		;was seg 0 (array unallocated)?
	JZ	CompSpaceExit	;yes, exit with DX:AX = 0
	cCall	B$ADArraySize	;[DX:AX] = size of the array in bytes
	PUSH	DX		
	PUSH	AX		;save that
	LES	SI,DWORD PTR [BX].AD_fhd.FHD_oData ;[ES:SI] = base array address

	MOV	DX,Seg_fpData
	MOV	AX,Off_fpData	;[DX:AX] = place to put data in array

	OR	DX,DX		;Is there a specified place?
	JNZ	ComputeSpace	;brif so
	MOV	DX,ES		;else use array base address
	MOV	AX,SI

ComputeSpace:
	PUSH	DX		
	PUSH	AX		;save array address


;	Convert seg:offset pairs into 20 bit addresses and subtract
;	them to compute 20 bit offset from base of array.

	cCall	ConvToAddr	;convert seg:off in [DX:AX] to 20 bit addr
	PUSH	BX		;in [BX:AX]
	PUSH	AX		;save address of get data
	XCHG	AX,SI
	MOV	DX,ES		;[DX:AX] = array base seg:offset
	cCall	ConvToAddr	;[BX:AX] = converted 20 bit address
	XCHG	AX,CX		;[BX:CX] = array base address
	POP	AX
	POP	DX		;[DX:AX] = array get address
	SUB	AX,CX		;low offset
	SBB	DX,BX		;[DX:AX] = 20 bit offset from array base
	JC	OVERFL		;error if get addr < array base addr
	POP	SI		
	POP	ES		;[ES:SI] = address for get data
	POP	BX		
	POP	CX		;[CX:BX] = size of array
	SUB	BX,AX		;[BX] = low difference
	SBB	CX,DX		;[CX:BX] = room left for get data
	XCHG	CX,DX		;swap so that
	XCHG	BX,AX		;    [DX:AX] = space remaining
	JC	OVERFL		;Jump if indexed off of array end
CompSpaceExit:			
cEnd


OVERFL: JMP	B$ERR_BS

;***
; ConvToAddr - converts a segment offset pair to 20 bit address
;
;Purpose:
; Converts the segment offset pair in DX:AX to a 20 bit address in BX:AX.
; Added for DOS 3 indexed GETs.
;
;Entry:
; DX:AX  = segment offset pair to be converted.
;
;Exit:
; BX:AX  = 20 bit address
;
;Uses:
; Per convention
;
;Exceptions:
; None.
;
;******************************************************************************
cProc	ConvToAddr,<NEAR>
cBegin
	XOR	BX,BX
	MOV	CX,4
SegLoop:
	SHL	DX,1
	RCL	BX,1
	LOOP	SegLoop 	;[BX] = high 4 bits of seg
	ADD	AX,DX		;add low 4 bits of seg to high 4 bits of offset
	ADC	BX,CX		;[BX:AX] = 20 bit address (CX=0 from LOOP)
cEnd

sEnd	GR_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\grwindow.asm ===
TITLE	GRWINDOW - FP & WINDOW GRAPHICS COMPONENT INITIALIZATION
;***
; GRWINDOW - FP & WINDOW GRAPHICS COMPONENT INITIALIZATION
;
;	Copyright <C> 1988, Microsoft Corporation
;
;
; - WINDOW Statement - Generates 1 call if no parameters, or 2 calls:
;
;      WINDOW [[SCREEN] (x1,y1)-(x2,y2)]
;
;    Possibilities:
;
;      WINDOW [SCREEN] (x1,y1)-(x2,y2)
;	  |
;      B$WIND
;
;
;      WINDOW
;	  |
;      B$WIN0
;
;Purpose:
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

	useSeg	_DATA
	useSeg	_BSS
	useSeg	CONST
	useSeg	GR_TEXT		
	useSeg	<XIB>		; XIB and XIE must bracket XI!
	useSeg	<XI>		; initializer segment
	useSeg	<XIE>

	INCLUDE seg.inc
	INCLUDE idmac.inc	; Internal debugging macros

;******************************************************************************
;
; point data structure
;
;******************************************************************************
POINT	STRUC
fPoint	DB	(?)		;content flags
xI2	DW	(?)		;x coordinate as an I2
xR4	DW	2 DUP (?)	;x coordinate as an I4
yI2	DW	(?)		;y coordinate as an I2
yR4	DW	2 DUP (?)	;y coordinate as an I4
POINT	ENDS

fxI2	EQU	00000001B	;xI2 is valid
fxR4	EQU	00000010B	;xR4 is valid
fxStep	EQU	00001000B	;x represents a STEP value
fyI2	EQU	00010000B	;yI2 is valid
fyR4	EQU	00100000B	;yR4 is valid
fyStep	EQU	10000000B	;y represents a STEP value


	INITIALIZER	B$xWINDINI ; Put B$xWINDINI in initializer list

sBegin	_DATA
externW	b$pFPCOORDW		; pointer to B$FPCOORDW
sEnd	_DATA


sBegin	_BSS

	externQ B$LXDIF		; Used to Map Logical
	externQ B$LYDIF		; to Physical coordinates
	EXTRN	B$GRFACX:DWORD	;defined in GWDATA.ASM
	EXTRN	B$GRFACY:DWORD	; defined in GWDATA.ASM

	externQ B$WXMIN		; Window x min (*) MUST BE IN THIS ORDER
	externQ B$WYMIN		; Window y min (*)
	externQ B$WXMAX		; Window x max (*)
	externQ B$WYMAX		; Window y max (*)
	externW B$WNDWSW 	;defined in GRINIT.ASM
	externW B$WNDWSC 	;defined in GRINIT.ASM


sEnd	_BSS

	externP B$FCMP
	externP	B$FIST		; round to integer in DX:AX
	externFP B$SWP8		; swaps 2 DP reals

sBegin	GR_TEXT
assumes CS,GR_TEXT

; Generic Feature selection list

	externNP B$ERR_FC
	externNP B$SCINIT	; initialize screen
	externNP B$ISWNDW


;OEM routines:
	externNP B$GRMODE

	EXTRN	B$fmldw:near
	externNP B$WNDINX	; defined in grfpinit.asm
	externNP B$COORD_NOSTEP
	externNP B$CLCWXY 	; defined in grfpinit.asm

	PAGE
	SUBTTL	Graphics initialization routines
;***
;B$xWINDINI - Initializer for the fp and WINDOW graphics component
;PLM B$xWINDINI()
;
;Purpose:
;
;Entry:
; None.
;
;Exit:
;	Appropriate dispatch vectors filled.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xWINDINI,<FAR>
cBegin

	MOV	[b$pFPCOORDW],GR_TEXTOFFSET B$FPCOORDW
cEnd

	SUBTTL	WINDOW - Define Window transformation

; SYNTAX: WINDOW [ [SCREEN] (Wx1,Wy1)-(Wx2,Wy2) ]

;	WINDOW defines the "Window" transformation from
;	Wx1,Wy1 (upper left x,y coordinates) to Wx2,Wy2
;	(lower right x,y coordinates).	The x and y coordinates
;	may be any Single Precision floating point number and
;	define the rectangle within the screen that graphics
;	will map into.
;	Initially, RUN (or WINDOW with no arguments) define the
;	entire screen as the Window.

;***
;B$WIND - process coordinate pairs, SCREEN flag, and execute WINDOW Statement
;
;Purpose:
;	Process coordinate pairs for WINDOW by storing in B$WXMAX
;	and B$WYMAX.  Make sure B$WXMIN<B$WXMAX and B$WYMIN<B$WYMAX. If
;	B$WXMIN=B$WXMAX or B$WYMIN=B$WYMAX issue a function call error.  If
;	B$WXMIN>B$WXMAX then exchange them. If B$WYMIN>B$WYMAX then exchange
;	them. If Screen flag<>0 then set B$WNDWSC=1. Set B$WNDWSW=1.
;Entry:
;	x1,y1,x2,y2 - R4 coordinate pairs defining new viewport.
;	fScreen     - SCREEN flag    NZ if SCREEN option
;Exit:
;	B$WXMAX,B$WYMAX,B$WNDWSW,B$WNDWSC updated
;Uses:
;	Per convention.
;Exceptions:
;	Control may be transfered to B$ERR_FC
;****

cProc	B$WIND,<PUBLIC,FAR>,<ES,DI>
parmD	X1
parmD	Y1
parmD	X2
parmD	Y2
parmW	fScreen
cBegin
	CALL	B$SCINIT	; init screen if not already done
	MOV	B$WNDWSW,0	;Initially no WINDOW
	CALL	B$GRMODE 	;Legal graphics mode?
	JZ	WINDFC		;Error if not Graphics mode

;	Process first coord pair

	LEA	BX,X1		;point to first coord pair
	LEA	DX,Y1
	CALL	XYLOAD		
	MOV	BX,OFFSET DGROUP:B$WXMIN ; BX = address of B$WXMIN
	CALL	B$XYSAVE 	; SAVE x and y in B$WXMIN and B$WYMIN
	PUSH	BX		; save ptr to B$WXMIN

;	Process second coord pair

	LEA	BX,X2		;point to second coord pair
	LEA	DX,Y2
	CALL	XYLOAD		
	MOV	BX,OFFSET DGROUP:B$WXMAX ; BX = address of B$WXMAX
	CALL	B$XYSAVE	; SAVE x and y in B$WXMAX and B$WYMAX

	FLD	QWORD PTR [BX]	; ST0 = B$WXMAX
	POP	BX		; recover ptr to B$WXMIN
	FLD	QWORD PTR [BX]
	cCall	B$FCMP		; COMPARE B$WXMIN to B$WXMAX
	JZ	WINDFC		; Error if Wx1 = Wx2
	JC	WX1LESS 	; Brif Wx1 .lt. Wx2
	CALL	B$XCHGF		; exchange Wx1,Wx2
WX1LESS:
	FLD	B$WYMAX		; ST0 = B$WYMAX
	MOV	BX,OFFSET DGROUP:B$WYMIN
	PUSH	BX		; save ptr to B$WYMIN
	FLD	QWORD PTR [BX]
	cCall	B$FCMP		; COMPARE B$WYMIN to B$WYMAX

	POP	BX		; get back ptr to B$WYMIN
	JZ	WINDFC		; Error if Wy1 = Wy2
	JC	WY1LESS 	; Brif Wy1 .lt. Wy2
	CALL	B$XCHGF		; exchange Wy1,Wy2
WY1LESS:
	MOV	AL,1		; WARNING:  DON'T change this!  It has to
				; WARNING:  be a 1, not just non-zero!
	CMP	fScreen,0	; SCREEN option specified?
	JZ	NOTSCR		; Branch if not SCREEN option
	MOV	BYTE PTR B$WNDWSC,AL ; Flag Window SCREEN active
NOTSCR:
	MOV	BYTE PTR B$WNDWSW,AL ; Flag WINDOW as active
	CALL	B$WNDINX 	; recalculate window vars, update
				;logical accumulators B$GRFACX,B$GRFACY
cEnd				;and return

WINDFC:
	JMP	B$ERR_FC

;*** 
;XYLOAD - load s.p. X and Y on numeric stack
;
;Purpose:
;	Load X and Y on numeric stack
;
;Entry:
;	[BX] = pointer to X
;	[DX] = pointer to Y
;
;Exit:
;	[ST1] = X
;	[ST0] = Y
;
;Uses:
;	Per convention.
;
;******************************************************************************
cProc	XYLOAD,<NEAR>
cBegin				; entire routine
	FLD	DWORD PTR [BX]	; x coord
	XCHG	BX,DX
	FLD	DWORD PTR [BX]	; y coord
cEnd

;***
;B$WIN0 - process WINDOW statement with no parms
;
;Purpose:
;	Set WINDOW boundary variables (B$WXMIN,B$WXMAX,B$WYMIN,B$WYMAX) equal to
;	the floating point equivalent of current viewport boundaries
;	(B$VXMIN,B$VXMAX, B$VYMIN,B$VYMAX).
;Entry:
;	None.
;Exit:
;	B$WXMIN,B$WXMAX,B$WYMIN,B$WYMAX updated
;Uses:
;	Per convention
;Exceptions:
;	Control may be transfered to B$ERR_FC
;****
cProc	B$WIN0,<PUBLIC,FAR>,<BP>
cBegin
	MOV	BP,SP		;set up frame
	MOV	B$WNDWSW,0	;Initially no WINDOW
	CALL	B$GRMODE 	;Legal graphics mode?
	JZ	WINDFC		;Error if not Graphics mode
	CALL	B$CLCWXY 	;init window vars
cEnd


	SUBTTL	B$FPCOORDW - process & return integer coordinates
	PAGE
;***
;B$FPCOORDW
;
;Purpose:
; Calculate the physical screen coordinates of the given point. Relative
; coordinates, viewports and windowing are all considered in determining the
; final coordinates. Clipping is not done in this routine.
;
;Entry:
;	SI = pointer to point to be processed
;
;Exit:
; 	CX = physical X
; 	DX = physical Y
; 	JMPs to B$COORD_NOSTEP in grcoord.asm
;
;Modifies:
; 	AX,BX
;
;******************************************************************************

cProc	B$FPCOORDW,<NEAR>
cBegin

;
; If windows are active, we will be doing f.p. calcs. Make sure we have R4
; representations of our coordinate
;
	TEST	AL,fxR4 	;Is the first coord an R4?
	JZ	COR1INT 	;No, go convert it
COR3:
	TEST	AL,fyR4 	;Is the 2nd coord an R4?
	JZ	COR2INT 	;No, go convert it
COR4:
	LEA	CX,[SI].xR4	;[CX] = pointer to r4 value of X
	LEA	DX,[SI].yR4	;[DX] = pointer to r4 value of Y

	PUSH	DX		;SAVE PTR TO Y
	MOV	BX,CX		;[BX] = pointer to R4 value of x

	FLD	DWORD PTR [BX]	; [ST0] = X COORDINATE VALUE REF'D BY BX
	MOV	BX,OFFSET DGROUP:B$GRFACX
	TEST	[SI].fPoint,fxStep ; Now, were we stepping?
	JZ	COORINT_5	; jump if not
	FADD	DWORD PTR [BX]	; ST0 = ST0 + B$GRFACX
COORINT_5:
	FSTP	DWORD PTR [BX]	; B$GRFACX = ST0

	POP	BX		; [BX] = PTR TO Y
	FLD	DWORD PTR [BX]	; [ST0] = Y COORDINATE VALUE REF'D BY DX
	MOV	BX,OFFSET DGROUP:B$GRFACY
	TEST	[SI].fPoint,fyStep ; Now, were we stepping?
	JZ	COORINT_10	; jump if not
	FADD	DWORD PTR [BX]	; ST0 := ST0 + B$FY_BASE
COORINT_10:
	FSTP	DWORD PTR [BX]	; B$GRFACY := ST0

	CALL	MAPLPX		;MAP LOGICAL TO PHYSICAL X, RESULT IN AX
	PUSH	AX		;SAVE PHYSICAL X ON STACK
	CALL	MAPLPY		;MAP LOGICAL TO PHYSICAL Y, RESULT IN AX
	XCHG	DX,AX		; DX := PHYSICAL Y
	POP	CX		;CX := PHYSICAL X
	JMP	B$COORD_NOSTEP	;and continue

;
;COR1INT - Convert first coord into s.p.
;
;Parameters:
; [SI] = pointer to point structure
;
;Returns:
; [AL] = updated structure flags
; structure contents updated
;
COR1INT:
	MOV	BX,[SI].xI2	;[BX] = X in I2 format
	CALL	B$fmldw		;[ST0] = X
	FSTP	DWORD PTR [SI].xR4 ;save x coord
	OR	[SI].fPoint,fxR4 ;indicate R4 present
	MOV	AL,[SI].fPoint
	JMP	SHORT COR3
;
; COR2INT - Convert 2nd coord into s.p.
;
;Parameters:
; [SI] = pointer to point structure
;
;Returns:
; [AL] = updated structure flags
; structure contents updated
;
COR2INT:
	MOV	BX,[SI].yI2	;[BX] = Y in I2 format
	CALL	B$fmldw		;[ST0] = Y
	FSTP	DWORD PTR [SI].yR4 ; save x coord
	OR	[SI].fPoint,fyR4 ;indicate R4 present
	MOV	AL,[SI].fPoint
	JMP	SHORT COR4
cEnd	<nogen>			; B$FPCOORDW


;*** 
;B$XYSAVE - save X and Y as doubles pointed to by DI
;
;Purpose:
;	Save X and Y as doubles pointed to by DI
;
;Entry:
;	[ST1] = X
;	[ST0] = Y
;	[BX] points to first of two consecutive doubles.
;
;Exit:
;	[BX]   = X  (d.p. if MI_EMULATOR, else s.p.)
;	[BX+8] = Y  (d.p. if MI_EMULATOR, else s.p.)
;
;Uses:
;	Per convention.
;
;Preserves:
;	BX.
;
;******************************************************************************

cProc	B$XYSAVE,<PUBLIC,NEAR>
cBegin				; entire routine
	PUSH	BX		; save X pointer
	ADD	BX,8
	FSTP	QWORD PTR [BX]	; [BX].Y = d.p. ST0
	FWAIT			; don't change BX until FSTP finished
	POP	BX
	FSTP	QWORD PTR [BX]	; [BX].X = d.p. ST0
cEnd

;***
;B$XCHGF - xchg 2 DP numbers
;
;Purpose:
;	Given a pointer (ptr) to the start of a 8-byte d.p. number, exchange
;	it's contents with that of the  8-byte d.p. number at ptr+16
;
;Entry:
;	[BX] - points to dp buffer
;Exit:
;	entries swapped
;Uses:
;	Per Convention
;Exceptions:
;	None.
;****
cProc	B$XCHGF,<PUBLIC,NEAR>
cBegin
	PUSH	DS
	PUSH	BX		;far ptr to first number
	ADD	BX,16		; advance to second number
	PUSH	DS
	PUSH	BX		;far ptr to second number
	cCall	B$SWP8		;swap the numbers
cEnd

;***
;MAPLPY & B$MAPLY1
;
;Purpose:
;
;     [AX] = ( Y - B$WYMAX) * ((Vy2-Vy1)/(Wy2-Wy1))
;
; If WINDOW ( )-( ):
;
;     [AX] = -( Y - B$WYMIN) * ((Vy2-Vy1)/(Wy2-Wy1))
;
; where "Y" is either B$GRFACY (MAPLPY), or passed by reference (B$MAPLY1).
;
; The following sub-expressions are calculated and saved every time the VIEW
; or window changes so that these mapping routines will go faster:
;
;	Variable name	      Formula
;	B$LXDIF		      (Vx2-Vx1)/(Wx2-Wx1)
;	B$LYDIF		      (Vy2-Vy1)/(Wy2-Wy1)
;
;Entry:
; [BX]	= pointer to R4 Y coordinate (B$MAPLY1 only).
;
;Exit:
;	AX = result.
;
;Uses:
;	Per convention.
;
;******************************************************************************
cProc	MAPLPY,NEAR
cBegin
	MOV	BX,OFFSET DGROUP:B$GRFACY ;BX points to logical y accum
cEnd	<nogen>			; Fall into B$MAPLY1

cProc	B$MAPLY1,<NEAR,PUBLIC>
cBegin
	FLD	DWORD PTR [BX]	; ST0 = R4 window Y
	MOV	BX,OFFSET DGROUP:B$WYMIN ;BX points to window minimum y
	CALL	B$ISWNDW 	;Check window status flags
	PUSHF
	JB	MAPLY2		;Current window is not WINDOW ( )-( ) form
	MOV	BX,OFFSET DGROUP:B$WYMAX ;BX points to window maximum y
MAPLY2:
	MOV	CX,OFFSET DGROUP:B$LYDIF ;BX points to B$LYDIF ratio (see above)
	CALL	MAPMUL		;[AX]:=physical y (also BX for BASIC)
	POPF			;Check window status flags
	JB	MAPLY3		;Current window is not WINDOW ( )-( ) form 
	NEG	AX		; AX:=-AX (implements minus sign in $MAPLPY
				;expression - see above)
MAPLY3: 			;Return viewport relative integer coord
cEnd

;***
;MAPLPX
;
;Purpose:
;
;Entry:
;
;Exit:
; 	AX = INT( (B$GRFACX - B$WXMIN) * B$LXDIF )
;
;Uses:
;	Per convention.
;
;******************************************************************************
cProc	MAPLPX,NEAR
cBegin
	MOV	BX,OFFSET DGROUP:B$GRFACX ;BX points to logical x accum
cEnd	<nogen>			; Fall into B$MAPLX1

cProc	B$MAPLX1,<NEAR,PUBLIC>
cBegin
	FLD	DWORD PTR [BX]
	MOV	BX,OFFSET DGROUP:B$WXMIN 
	MOV	CX,OFFSET DGROUP:B$LXDIF ;BX points to B$LXDIF ratio (see above)
cEnd	<nogen>			; Fall into MAPMUL

;***
;MAPMUL - Mapper multiply subroutine
;
;Purpose:
;Exit:
;	AX = INT(([ST0] - [BX]) * [CX])
;
;******************************************************************************
cProc	MAPMUL,NEAR
cBegin
	FSUB	QWORD PTR [BX]	; ST0 = B$GRFACX-B$WXMIN
	XCHG	BX,CX
	FMUL	QWORD PTR [BX]	; ST0:=s.p. @ [BX] * ST0
	cCall	B$FIST		;Round to integer in DX:AX
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwaevt.asm ===
PAGE	56,132
	TITLE	GWAEVT Advanced Event Trapping Handler
;***
; GWAEVT Advanced Event Trapping Handler
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - ON COM(n) Statement:
;
;      ON COM(n) GOSUB line
;      --------------------
;		|
;	      B$ONCA
;
; - ON SIGNAL(n) Statement:
;
;      ON SIGNAL(n) GOSUB line
;      -----------------------
;		|
;	      B$ONSG
;
; - ON KEY(n) Statement:
;
;      ON KEY(n) GOSUB line
;      --------------------
;		|
;	      B$ONKA
;
; - ON MOUSE(n) Statement:
;
;      ON MOUSE(n) GOSUB line
;      --------------------
;		|
;	      B$ONMO
;
; - ON UEVENT Statement:
;
;      ON UEVENT GOSUB line
;      --------------------
;		|
;	      B$ONUE
;
; - ON PEN Statement:
;
;      ON PEN GOSUB line
;      -----------------
;	       |
;	     B$ONPA
;
; - ON PLAY(n) Statement:
;
;      ON PLAY(n) GOSUB line
;      ---------------------
;		|
;	      B$ONLA
;
; - ON STRIG(n) Statement:
;
;      ON STRIG(n) GOSUB line
;      ----------------------
;		|
;	      B$ONSA
;
; - ON TIMER(n) Statement:
;
;      ON TIMER(n) GOSUB line
;      ----------------------
;		|
;	      B$ONTA
;
;******************************************************************************
	include switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	_BSS		; Uninitailzed data
	useSeg	_DATA		; Initialized data
	useSeg	EV_TEXT 	; Event handler code
	useSeg	RT_TEXT 	; Runtime Core
	useSeg	ER_TEXT 	; Errors
	UseSeg	INIT_CODE	
	UseSeg	<XIB>		; XIB and XIE must bracket XI!
	UseSeg	<XI>		; initializer segment
	UseSeg	<XIE>		

	INCLUDE seg.inc 	
	INCLUDE baslibma.inc
	INCLUDE intmac.inc
	include event.inc	; oem interface
	include queues.inc	;get queue stuff
	include stack.inc	
	INCLUDE compvect.inc	
	include idmac.inc	

INITIALIZER	B$x?EVTDSPINI	

sBegin	_DATA			
	staticB b$EVTFLG,0	; event occurred flag
	globalW B$PollDispTable,0,NUM_TRAPDEV ;Dispatch table for polling.
					      ;One word per trappable dev.
					      ;Address of B$POL* routine
					      ;for that device if used,
					      ;else zero.
	externB	b$EventFlags	; misc event flags. bits def in CONST.INC

	externD b$run_disp	
	externD b$clr_disp	

	externW	b$pInitKeys1	
	externW	b$pInitKeys2	
	externW	b$pTrapEvent	

sEnd	_DATA			

sBegin	_BSS			

	externW b$cNonQBIFrames ; non qbi frame count

	externW b$cCSubs	; compiler nested sub level
	externD b$EVTRETV	;defined in RTINIT.ASM
	externB	b$inonerr	; defined in RTINIT.ASM
	externW b$TRPTBL	;defined in GWCEVT.ASM
	externW b$TRAP_QUE	;defined in GWCEVT.ASM
	externB b$TRAP_SEM	;defined in GWCEVT.ASM

staticW TRPCUR,,1		; Current trap table address

sEnd	_BSS			

;#*****************************************************************************

	externFP B$IEvSet	;interp routine to set BOS EV flag
	externFP B$IEvReset	;interp routine to reset BOS EV flag
	externFP B$IEvHandler	;interp routine to do event GOSUB
	externFP B$EnsShowOutputScr ;displays output screen
sBegin	RT_TEXT 		
	externFP B$FRAMESETUP	; Set up runtime frame
	externNP B$NearRet	
sEnd	RT_TEXT 		

sBegin	ER_TEXT 		
	externNP B$FrameAFE	; advanced feature error + frame setup
	externNP B$ERR_DNA	; device not available error
	externNP B$ERR_FC	
sEnd	ER_TEXT 		

sBegin	EV_TEXT			; EV_TEXT externals go here

	externNP B$FreeTrap	
	externNP B$StopTrap	
	externNP B$ResetTrap	
	externNP B$OffTrap	
	externNP B$OnTrap	
	externNP B$SetChk	
	externNP B$TrapAddr	
	externNP B$SetContext	;Set context bit in event flags

sEnd	EV_TEXT			

sBegin	INIT_CODE		
assumes	CS,INIT_CODE		

;*** 
;B$x?EVTDSPINI - Make sure event vectors get initialized when necessary.
;
;Purpose:
;	Make sure that event vectors are initialized if events are linked in.
;	Initializes RUN and CLEAR time event dispatch vectors to B$?EVT.
;	Also initializes [b$EVTRETV] vector to B$EVTRET.
;
;Entry:
;	None.
;
;Exit:
;	Appropriate dispatch vectors filled.
;	Sets [b$EVTRETV] to B$EVTRET.
;	Sets [b$pTrapEvent] to B$TrapEvent.
;
;Uses:
;	Per convention.
;
;Exceptions:
;	None.
;
;******************************************************************************
cProc	B$x?EVTDSPINI,<FAR>	
cBegin				; set run and clear init vectors to B$?EVT
	MOV	AX,SEG EV_TEXTBASE ; load EV_TEXT segment into AX
	MOV	WORD PTR [b$run_disp].EV_RVEC,EV_TEXTOFFSET B$?EVTN ; offset
	MOV	WORD PTR [b$clr_disp].EV_CVEC,EV_TEXTOFFSET B$?EVTN ; offset
	MOV	WORD PTR [b$EVTRETV],EV_TEXTOFFSET B$EVTRET ; offset
	MOV	WORD PTR [b$EVTRETV+2],AX ; segment
	MOV	b$pTrapEvent,EV_TEXTOFFSET B$TrapEvent ; for LLSND, LLCOMx.
cEnd				
sEnd	INIT_CODE		

sBegin	EV_TEXT 		
assumes CS,EV_TEXT		

	SUBTTL	TRAP ROUTINES - INIT
;***
; B$?EVT
;
; Purpose:
;  Runtime Entry Point for /O if /V or /W in effect in any module.
;  Always a Runtime Entry Point for non-/O and for EI_QB.
;  Clears Event Trap Table, clears GOSUB dispatch buffer, and initializes
;  keyboard trapping.
;
; Input:
;  NONE
;
; Output:
;  NONE
;
;******************************************************************************
cProc	B$?EVT,<FAR,PUBLIC>,<ES,SI,DI> 
cBegin				
	PUSH	DS		
	POP	ES		;Set ES = DS
	MOV	DI,OFFSET DGROUP:b$TRPTBL

;	Each entry in b$TRPTBL is 5 bytes.  The first byte is a flag byte
;	that must be inited to zero.  The next 4 bytes are the GOSUB address
;	and must be inited to -1 (to indicate no trap handler).

	MOV	CX,NUM_TRAPS	; count of 5-byte entries in b$TRPTBL
IniTrpTblLoop:			
	XOR	AX,AX		; start with zero each time through loop
	STOSB			; Set flag byte to 0
	DEC	AX		; Get a -1
	STOSW			; 2nd and 3rd bytes = -1
	STOSW			; 4th and 5th bytes = -1
	LOOP	IniTrpTblLoop	; keep going until entire table inited


	MOV	[b$TRAP_SEM],CL ;Set no Events in process
	MOV	SI,OFFSET DGROUP:b$TRAP_QUE ;init event gosub dispatch tbl
	mov	ax,(NUM_TRAPS+1)*2  ; room for event dispatches
	MOV	BX,OFFSET DGROUP:b$TRAP_QUE+QUE_HEADER_SIZE
	CALL	B$INITQ		;Init queue descriptor

	STI
	MOV	AL,DISABLE_TRAP ; to disable ctrl-break trapping
	CALL	[b$pInitKeys1]	; Init some keytrapping stuff
	CALL	[b$pInitKeys2]	; Init some more keytrapping stuff
cEnd				

;***
; B$?EVTN
;
; Purpose:
;  Near entry to B$?EVT.
;  Added with [52]
;
; Input:
;  NONE
;
; Output:
;  NONE
;
;******************************************************************************
cProc	B$?EVTN,<NEAR>
cBegin
	call	B$?EVT
cEnd

	SUBTTL Stack for event traps
	PAGE
;Stack for event dispatches in different environments. The notation X->Y means
;that the executing context was X (I for interp, C for comp), and
;->Y means that control was transfered to context Y. SC, DC and RC are
;abbreviations for Source Context, Destination Context, and Runtime Context.
;
;Pushed
;  By  C->C	       I->C			C->I		 I->I
;----  +-----------------------------+	 High	+-----------------------------+
;      |	      |Interp context|	  ^	|	       |Interp context|
; SC   |Far ret addr  |Far ret addr  |	  |	|Far ret addr  |Far ret addr  |
;----  |--------------|--------------|	  |	|--------------|--------------|
;      |Context flag  |Context flag  |	STACKS	|Context flag  |Context flag  |
; RC   |Trap tabl addr|Trap tabl addr|	  |	|Trap tabl addr|Trap tabl addr|
;----  |--------------|--------------|	  |	|--------------|--------------|
;      |Compiler frame|Compiler frame|	  |	|Interp frame  |Interp frame  |
; DC   |Zero	      |Zero	     |	  v	|Zero(?)       |Zero(?)       |
;----  +-----------------------------+	 Low	+-----------------------------+

;Note that the context flag is pushed on the stack even in the COMPILER ONLY
;environment to keep the event frame size the same for all environments.

	SUBTTL Event dispatch execution path
	PAGE
;The flow of control is as follows:
;
;Compiled Code (CC)	 Common runtime (RT)	   Interpreted Code (IC)
;==================	 ===================	   =====================
;
;+------------------------+		       +------------------------------+
;|CC ACTIVE AT EV DISPATCH|		       | IC ACTIVE AT EV DISPATCH     |
;|Comp calls B$EVCK	  |------>+<-----------+ interp detects BOS event flag|
;+------------------------+	  |	       | interp saves context on stack|
;				  |	       | interp calls B$EVCK	      |
;				  v	       +------------------------------+
;		     +--------------------------------+
;		     |	 B$EVCK detects trap request |
;		     |	 if last event in Q,	      | 	+------------+
;		     |	    RT calls interp to	      +<= = = =>+Reset BOS EV|
;		     |	    reset BOS flag	      | 	|FLAG	     |
;		     |	 pushes context flag	      | 	+------------+
;		     |	 pushes trap table address    |
;		     |----------------+---------------|
;		     |if CC handler   |if IC handler  |
;		     | inc contxt flag| 0 context flag|
;*Done for compiler* | builds CC frame| jmps to interp|
;*by the runtime   * | pushes 0 for   |   with ptr to |
;		     |	 B$RETA      |   handler     |
;		     | jmps to CC addr|   context     |
;		     |	 in trap table| 	      |
;		     +--------+--------------+--------+
;+-----------------------+    | 	     |	     +------------------------+
;|   CC EVENT HANDLER	 |    | 	     |	     |	  IC EVENT HANDLER    |
;|handler executes	 |<---+ 	     |	     |interp builds frame     |
;|CC calls B$RETA	 |--------+	     +------>|handler executes	      |
;+-----------------------+	  v		     |interp tears down frame |
;			+--------------------------+ |interp JMPS to B$EVTRET|
;* Done for compiler *	|B$RETA determines EV ret | +----------+-------------+
;*		     *	|tosses return address	   |		|
;*		     *	|cleans off frame	   |		|
;* by the runtime    *	|Runtime JMPS to B$EVTRET |		|
;			+---------+----------------+		|
;				  +<----------------------------+
;				  v
;			+--------------------------+
;			|B$EVTRET		   |
;			|recovers trap table addr  |
;			|recovers context flag	   |
;			|restarts event 	   |
;			|return untrapped brk flag |
;			|returns to caller	   |
;			+---------+----------------+
;+-------------------+		  |		     +------------------------+
;|Comp code continues|<-----------+----------------->|interp BOS proc recovers|
;|execution	     |				     |context and continues   |
;+-------------------+				     +------------------------+
;
	SUBTTL	B$POLLEV/Description of event trapping
	PAGE
;***
;B$POLLEV - Check if a trapable event has occured.
;	 Defunct routine, but the comments are nice.
;Purpose:
;
;      Poll to determine if a trapable event has taken place.
;	 Trapable events are:
;	   data placed in keyboard queue
;	   data placed in any RS232 queue
;	   RS232 error - timeout etc.
;	   light pen
;	   joy stick trigger
;	   music events
;	   timer events
;
;Event and Trapping Mechanisms:
;
;	All events, no matter what generates them, are handled in
;	the same way.  When the event occurs, it will either cause
;	a routine to be called or will be tested by a routine.	This
;	routine will set two different flags.  The first flag that
;	is set is b$EVTFLG.  This flag indicates that at least one
;	event has taken place.	It does not keep track if multiple
;	events have occured since events were last tested or not.
;	At the appropriate time (either after every statement or
;	after every line) the flag will be tested.  If it indicates
;	that an event has taken place, the flag will be cleared and
;	all trappable items will be polled to see if they have an
;	outstanding event.
;
;	The second flag that is set at the time of the event is
;	one that is local to the item that has the event.  This
;	is needed so that each item can properly give its status
;	when it is polled.  Note that polling an individual item
;	will not change the global event flag.
;
;	If for some reason your machine can not suport the global
;	event trapping, always set the flag to indicate that an
;	event has taken place.	Thus, at the end of each statement,
;	the OEM-independent code will poll each of the individual
;	items for its status.  This will produce a degradation in
;	execution time, however.
;
;******************************************************************************

	SUBTTL	B$EVCK - New Stmt Event Trap Dispatch Handler
	PAGE
;***
; B$EVCK - New Stmt Event Trap Dispatch Handler
;
;Purpose:
; Event trap dispatcher. Pass thru here on each new statement. Process Event
; trap if event Enabled and Requested.
;
;Entry:
; None
;
;Exit:
; GOSUBs to event handler, if so indicated.
; [AL] = non-zero if untrapped ctl-Break has been hit (QB only)
; [AH] = non-zero if event was handled (QB only)
;
;******************************************************************************
cProc	B$EVCK,<PUBLIC,FAR>	
cBegin
	XOR	AX,AX		; a Zero to switch with
	XCHG	[b$EVTFLG],AL	; get and reset trapable event flag
	OR	AL,AL		; trapable event occured?
	JZ	NoPolling	; brif not -- don't bother to check traps

	MOV	SI,OFFSET DGROUP:B$PollDispTable ;point to dispatch table
	MOV	CX,NUM_TRAPDEV	;number of entries in table
PollLoop:			
	LODSW			;get next address from table
	OR	AX,AX		;is entry zero?
	JZ	SkipCall	;yes, don't try to call it
	PUSH	CX		;preserve counter across call
	CALL	AX		;call the poll routine
	POP	CX		;restore counter
SkipCall:			
	LOOP	PollLoop	;keep going until done

NoPolling:			
	TEST	[b$TRAP_SEM],0FFh ;(faster than CMP)
	JNZ	TRAP_OEIP	;Brif events

IgnoreIt:			
	CALL	QBEvReset	;Reset interp event flag if neccessary
	XOR	AH,AH		;event not handled
	RET			

TRAP_OEIP:
	TEST	[b$inonerr],0FFh ; Are we in ON ERROR routine?
	JNZ	IgnoreIt	; brif so -- ignore event

	MOV	SI,OFFSET DGROUP:b$TRAP_QUE ;get next enabled request
	CALL	B$GETQ
	mov	ah,al
	CALL	B$GETQ
	JZ	IgnoreIt	; don't process if queue underflow
	MOV	[TRPCUR],AX	; Save current trap address
	mov	bx,ax		;[bx]= trap table event addr
	XOR	SI,SI		
	CALL	B$FreeTrap	;Free Trap Request
	CALL	B$StopTrap	;Put STOP on Trap
	CALL	QBEvReset	;Reset interp event flag if neccessary
	CALL	B$EnsShowOutputScr ;Make sure output screen is active
	PUSH	b$cCSubs	
	PUSH	BX		;save trap table index
	TEST	BYTE PTR[BX],TRP_CN ;Is compiler handler active?
	JZ	CompHandler	;brif so
	MOV	b$cCSubs,0	;set interpreted code active
	INC	BX		; [BX] = ptr to interp handler context
	JMP	B$IEvHandler	;let interp handle gosub (DOESN'T RETURN)
CompHandler:			
	MOV	DX,[BX+3]	
	MOV	AX,[BX+1]	; [DX:AX] = Trap routine address
	cCall	B$FRAMESETUP	; Set up the frame
	INC	WORD PTR [BP].FR_GOSUB	 ; set gosub count to 1
	MOV	BX,[TRPCUR]	; Get current trap table address again

	INC	b$cNonQBIFrames ;bump count of NonQBIframes
	XOR	AX,AX
	PUSH	AX		;Push a 00 so RETURN works right
	jmp	dword ptr[BX+1] ;GOSUB the Trap routine...

cEnd	nogen

;***
; QBEvReset - Checks for more trappable events
;
;Purpose:
; Added as part of [19].
; Checks for more queued events.  If none, resets QB Event flag.
; It also returns value of b$EventFlags & CNTLC, indicating if untrapped
; Ctl-Break has occurred.
;
;Entry:
; None.
;Exit:
; AX - non-zero if untrapped Ctl-Break has occurred.
;Uses:
; None.
;Exceptions:
; None.
;****
cProc	QBEvReset,<NEAR>
cBegin
	CLI
	XOR	AX,AX
	CMP	[b$TRAP_SEM],AL ;any more events queued?
	JNZ	MoreEvents	;brif so
	CMP	[b$EVTFLG],AL	;any events happen since last check?
	JNZ	MoreEvents	;brif so
	CALL	B$IEvReset	;reset interpreter BOS flag for events
MoreEvents:
	STI
	MOV	AL,b$EventFlags	; get untrapped break flag
	AND	AX,CNTLC	; mask out all bits but CNTLC, & clear AH
cEnd

;***
;B$IFindEvHandler - Finds requested event handler context.
;
;Purpose:
;	Added as part of revision [24].
;	Entry point for QBI Scanner to find QBI context information
;	for an event handler.  This routine searches for the event
;	table for the closest "handler offset" for the requested
;	"segment". Note: the seg:off for the interpreter really map
;	to an oRs:oTx pair which defines the event handler.
;	When a handler matching the specified "segment" is found,
;	the entry will be marked as processed by placing FFFF in the
;	offset part of the handler context.
;Entry:
;	Seg - requested "Segment" to search for in event table.
;Exit:
;	AX - smallest "offset" found for requested "segment".
;	     0FFFFH if not found.
;	DX - DGROUP address of Event table entry.
;	Marks processed entries with 0FFFFH.
;Uses:
;	Per convention.
;Exceptions:
;	None.
;******************************************************************************
cProc	B$IFindEvHandler,<PUBLIC,FAR>,<SI,DI>
parmW	EvSeg
cBegin
	MOV	SI,OFFSET DGROUP:b$TRPTBL ;SI = points to event trap table
	MOV	CX,NUM_TRAPS*5		;CX = size of trap table
	XOR	DI,DI			;DI = points to smallest so far
	MOV	DX,0FFFFH		;DX = smallest

;	Walk the event table, looking for QB entries with matching segments
;	Return the offset of the smallest such entry, or FFFF if none.

EvFindLoop:
	LODSB				;get context byte
	XCHG	AX,BX			;BL = context byte
	LODSW				;AX = Handler offset
	TEST	BL,TRP_CN		;see if QBI handler
	JZ	EvFindSkip		;brif not

	MOV	BX,[SI] 		;BX = Handler Seg
	CMP	BX,EvSeg		;Segment of handler match search seg?
	JNZ	EvFindSkip		;skip entry if not

	CMP	AX,DX			;is Handler offset smallest?
	JAE	EvFindSkip		;brif not

;	Table entry is smallest so far encountered.  Remember value and address

	MOV	DI,SI			;point to it.
	XCHG	DX,AX			;remember lowest so far

EvFindSkip:
	LODSW				;skip seg
	SUB	CX,4
	LOOP	EvFindLoop		;process next table entry

	OR	DI,DI			;did we find one?
	JZ	NoMatch 		;brif not

	MOV	AX,DI			;AX = address of table entry
	DEC	AX			;back up to point at "offset"
	DEC	AX			

NoMatch:
	XCHG	AX,DX			;return lowest match in AX addr in DX
cEnd

;***
; B$EVTRET - Return from event trap routine
;
;Purpose:
; Reset STOPped bit, if trap ON, and restore frame pointer to previous frame.
;
;Entry:
; [BX]	= Trap table address
; top of stack contains long return address
;
;Exit:
; [AH] = non-zero if event was handled.
; [AL] = non-zero if an untrapped ctrl-break has occurred.
;
;Uses:
;
;Preserves: (optional)
;
;Exceptions:
;
;******************************************************************************
cProc	B$EVTRET,<FAR,PUBLIC>	
cBegin				
	CMP	[b$cCSubs],0	;are we returning from a compiled event?
	JZ	QBIEvRet	;brif not
	DEC	b$cNonQBIFrames ;adjust count of NonQBIframes
QBIEvRet:			
	POP	BX		;recover trap table address
	POP	[b$cCSubs]	;Recover context flag
	TEST	BYTE PTR [BX],TRP_ON ; Is Trap ON?
	JZ	TRAPRETX	; Brif not.
	CALL	B$ResetTrap	; else Reset Stopped bit.
TRAPRETX:			
	MOV	AX,0FFh SHL 8 + CNTLC ; return event handled (AH = -1)
	AND	AL,b$EventFlags	; return whether or not Break has occurred
				; (bit CNTLC of b$EventFlags)
cEnd				

	SUBTTL	ON Event GOSUB Statement handler
	PAGE
;***
; B$ONCA, B$ONKA, B$ONPA, B$ONLA, B$ONSA, B$ONTA, B$ONSG, B$ONMO, B$ONUE
;
; Syntax:	ON [Event] GOSUB line no.
;
;	WHERE:
;		Event:	     Arg:		traps:
;		    COM(x)    x in [1..NUM_RS232] COM [1..NUM_RS232]
;		       PEN			  Light pen.
;		  STRIG(x)    x =  <0|2>	  Trigger <A|B>
;		    KEY(x)    x in [1..NUM_TKEYS] Soft/Cursor/User defined keys
;		   PLAY(x)    x in [1..32]	  size(music-q) drops below x
;		  TIMER(n)    n in [1..86400]	  every n seconds
;		 SIGNAL(n)    n in [1..7]	  DOS signal n
;		  MOUSE(n)    n in [1..5]	  MOUSE function n
;		    UEVENT			  User defined event
;
; Entry:
;  parm1 =	TIMER:		A 4-byte integer.			[23]
;		PEN:		Far ptr to event handler subroutine	[23]
;		UEVENT: 	Far ptr to event handler subroutine	[40]
;		All Others:	A 2-byte integer.			[23]
;  parm2 = Far ptr to event handler subroutine (except for PEN)		[23]
;
; Exit:
;	The event trap address is saved.
;
;******************************************************************************


;#*****************************************************************************
;
; for those with a single word parameter:
;
cProc	B$ONFUN,<FAR,PUBLIC>	
parmW	placeHolder		; ensure generated exit code matches entries
parmD	fpHandler		
cBegin	<nogen> 		

	DEC	BX		; Want base 0.
	js	on_error	; if original arg is 0 then Ill fun error
	CMP	BL,CH		;Value [BL] .gt. MAX [CH]?
	JNB	ON_ERROR	;If so, then Ill fun error.
	MOV	CH,BL		; Save Event index in [CH]
	XCHG	AX,CX		; into AX (don't care about CX)
	ADD	AL,AH		; Final offset in al
	LEA	BX,[fpHandler]	; parm to settbl
	call	B$settbl	  
cEnd				

ON_ERROR:
	JMP	B$ERR_FC

;***
;B$settbl - save ON <event> GOSUB handler address in trap table
;
;Purpose:
;
;
;entry:
;	AL contains offset for appropriate event
;	BX contains a pointer to fpHandler, on the stack
;
;exit:
;
;
;Uses:
;
;
;Exceptions:
;      None.
;****
cProc	B$settbl,<NEAR,PUBLIC>,<SI>	 
cBegin

.erre	ID_SSEQDS
	MOV	SI,BX		
	CALL	B$TrapAddr	; modifies ax & bx only - address in bx
	LODSW			
	MOV	[BX+1],AX	; Put (far) handler address in Trap Table
	LODSW			
	MOV	[BX+3],AX	
	CALL	B$SetContext	;Set context bit in event flags
	CALL	B$SetChk	;Set Trap if On+Req and GOSUB <> 0.
cEnd				



	SUBTTL	B$EVNT_SET - Set Event ON, OFF or STOP
	PAGE
;***
; B$EVNT_SET -	  Sets Event ON, OFF or STOP
;
; Entry:	[DL] = ON, OFF or STOP Token.
;		[CH] = key # if KEY on
;		[CL] = Trap table index to Event.
;		[BL] = Event subscript.
;
; Exit: 	Event set in Trap Table, or Error.
; Preserves:
;		DI
;****

cProc	B$EVNT_SET,<NEAR,PUBLIC> 
cBegin				

	XCHG	AL,BL		; [AL] = Event subscript  ([BX] = garbage)
	ADD	AL,CL		; [AL] = Event Trap base + index.
	CALL	B$TrapAddr	;Get Event addr in Trap Table
	DEC	DL		; cheap test of ON/OFF/STOP token
.errnz	$ON - 0
	JS	EVON		; brif DL == $ON
.errnz	$OFF - 1
	JZ	EVOFF		; brif DL = $OFF
	;default - fall through to EVSTP
	DbAssertRelB	DL,z,$STOP-1,EV_TEXT,<gwaevt: B$EVNT_SET, invalid input>

;EVENT(n) ON, OFF and STOP (Enable EVENT Trapping)

EVSTP:
	JMP	B$StopTrap	;STOP TRAP
EVON:
	JMP	B$OnTrap	;TURN TRAP ON
EVOFF:
	JMP	B$OffTrap	;TURN TRAP OFF
cEnd	<nogen>			

	SUBTTL unsupported device code
	page

; this code consolidated with revision [35].

labelFP	<PUBLIC,B$ESG0>		; SIGNAL(n) ON
labelFP	<PUBLIC,B$ESG1>		; SIGNAL(n) OFF
labelFP	<PUBLIC,B$ESG2>		; SIGNAL(n) STOP
labelFP	<PUBLIC,B$ONSG>		; ON SIGNAL(n) GOSUB


labelFP	<PUBLIC,B$EMO0>		; MOUSE(n) ON
labelFP	<PUBLIC,B$EMO1>		; MOUSE(n) OFF
labelFP	<PUBLIC,B$EMO2>		; MOUSE(n) STOP
labelFP	<PUBLIC,B$ONMO>		; ON MOUSE(n) GOSUB

labelFP <PUBLIC,B$EUE0> 	; UEVENT ON
labelFP <PUBLIC,B$EUE1> 	; UEVENT OFF
labelFP <PUBLIC,B$EUE2> 	; UEVENT STOP
labelFP <PUBLIC,B$ONUE> 	; ON UEVENT GOSUB


cProc	AFE_PROC,<FAR>		
cBegin
	JMP	B$FrameAFE	; "advanced feature error" + frame setup
cEnd	<nogen>






;***
;B$TrapEvent - An event has been detected.  Set event flag
;
;Purpose:
;	Moved here with revision [39]
;	This routine is called when an event has been detected to
;	set the global event flag and notify the interpreter
;	that an event has occurred.
;Entry:
;IF	(b$EventFlags & InSLEEP)
;	AL = trap number
;ELSE
;	None.
;ENDIF
;Exit:
;	B$EVTFLG = 1
;Uses:
;IF	(b$EventFlags & InSLEEP)
;	AX
;ELSE
;	None.
;ENDIF
;Exceptions:
;	None.
;****
cProc	B$TrapEvent,<NEAR,PUBLIC>
cBegin
	MOV	b$EVTFLG,1	;set global event flag

	cCall	B$IEvSet	; call interp to set event BOS flag

	TEST	b$EventFlags,InSLEEP ; in SLEEP statement?
	JZ	NotSleep	; brif not -- don't do slow stuff

	PUSH	BX		; save register
	CALL	B$TrapAddr	; BX = *trap table entry for this event
	MOV	AL,[BX]		; get trap status
	AND	AL,TRP_ON or TRP_ST ; mask out all bits but ON and STOP
	CMP	AL,TRP_ON	; trap on and NOT stopped?
	POP	BX		; restore register
	JNE	NotSleep	; brif not enabled -- don't wake up SLEEP
	
labelNP	<PUBLIC,B$Wakeup>	; entry point for keyboard interrupt handler
				; forces wakeup of SLEEP
	AND	b$EventFlags,NOT (InSLEEP OR SLEEPtmr) ; clear flags to exit
				; SLEEP statement wait loop

NotSleep:


cEnd

sEnd	EV_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwdata.asm ===
TITLE	GWDATA - Global Data Declarations for GW BASCOM
;***
; GWDATA - Global Data Declarations for GW BASCOM
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	

	useSeg	DV_TEXT 	
	useSeg	_DATA		
	useSeg	_BSS		
	useSeg	CONST		
	useSeg	BR_SKYS 	

	INCLUDE seg.inc 	
	INCLUDE	comdcb.inc	

sBegin	_DATA			

;***
;b$CURSOR - screen cursor position (1,1-relative)
;OEM-callback routine (variable)
;
;Purpose:
;	b$CURSOR keeps track of the current cursor position.
;	The low byte is the X coordinate (1-relative) and
;	the high byte is the Y coordinate (1-relative).
;
;	This value has to be set by the OEM at startup time.
;
;Allocation:
;	b$CURSOR is a WORD value declared in the _DATA segment
;	by the OEM-independent code.
;
;Values:
;	1	  <= b$CURSOR low byte <= b$CRTWIDTH (+1)
;	b$WDOTOP <= b$CURSOR hi byte	<= b$WDOBOT
;
;	There is a case where the value of b$CURSOR will not reflect
;	the actual cursor position.  This occurs when we have printed
;	a character to the last column of the screen and have incremented
;	the cursor.  In this case b$CURSOR will indicate column
;	b$CRTWIDTH + 1, and the cursor will be positioned at column
;	b$CRTWIDTH.  This is to keep from scrolling the screen when
;	writing to the bottom right most corner.
;
;Initially Set:
;	This value should be set by the OEM during initialization of
;	the screen I/O variables (currently done in B$GWINI).
;
;Modified by:
;	The value of b$CURSOR is updated anytime a routine moves the
;	cursor on the screen.  It is not done when the cursor is actually
;	moved, as several of the routines need b$CURSOR to stay fixed (as
;	an initial location) while they move the cursor around.  The OEM
;	routines should therefore NOT modify this value except upon
;	initialization.
;
;Used by:
;	Any routine that wants to know the position of the cursor
;	according to the OEM independent code.	If the position of
;	cursor must be known exactly, then it is suggested to obtain
;	this value from the hardware.
;*****************************************************************************

;	b$CSRY and b$CSRX must remain in this order and of this size.

	labelW	<PUBLIC,b$CURSOR> ; screen cursor (1,1)-relative.
	globalB b$CSRY,1	; cursor row
	globalB b$CSRX,1	; cursor column

	globalB b$LINCNT,24	;max lines on screen (logical is WDOBOT)
				; Set by calls to B$SCNSWI.
	globalB b$SCRNWIDTH,80 ; logical width of last screen
				; width change. (physical is B$CRTWIDTH)

;***
;b$WDOTOP, b$WDOBOT - Logical top and bottom lines of the screen.
;OEM-callback routine (variables)
;
;Purpose:
;	These variables define the logical top and bottom of the text
;	window (1-relative).
;
;Allocation:
;	b$WDOTOP, b$WDOBOT are BYTE values declared in the _DATA segment
;	by the OEM-independent code.
;
;Values:
;	Initially, b$WDOTOP = 1 and b$WDOBOT = 24.  Updated as needed.
;
;Initially Set:
;	b$WDOTOP and b$WDOBOT are statically initialized.
;
;Modified by:
;	These variables are modified by various OEM-independent routines
;	associated with VIEW PRINT, SCREEN, and other functions that modify
;	the size of the screen.  They should not be modified or changed
;	by the OEM.
;
;Used by:
;	The only OEM routines that should need access to these variables
;	is the clear screen routine (B$CLRSCN).
;*************************************************************************

	globalB b$WDOTOP,1
	globalB b$WDOBOT,24	  ;Logical screen last line
				;(LINCNT is physical)
	labelW <PUBLIC,b$ERDEVP>		; sd for errors
	staticW ,,1				;string desc for errors
	staticW ,<OFFSET DGROUP:ERDEVP_STR>

;    graphics routine pointers only set when a graphics
;    statment is executed so non-graphics program are smaller.

	globalW b$VWINI_PTR, <DV_TEXTOFFSET B$NearRet>
	globalW B$GRPINI_PTR,<DV_TEXTOFFSET B$NearRet>
	globalW B$GRPRST_PTR,<DV_TEXTOFFSET B$NearRet>

	globalW b$VWCLR_PTR,<DV_TEXTOFFSET B$NearRet>

	globalW b$pTrapEvent,<DV_TEXTOFFSET B$NearRet>	

;***
; b$CRTWIDTH - Current Physical Screen Width
;OEM-callback routine (variable)
;
;Purpose:
;	This variable specifies the current physical width of the screen.
;	It will also give the rightmost column of the screen (1-relative).
;
;	This variable should only be changed by the OEM by calling B$SCNSWI.
;
;Allocation:
;	b$CRTWIDTH is a BYTE value declared in the _DATA segment by the
;	OEM-independent code.
;
;Values:
;	Either 40 or 80, depending on screen mode.
;
;Initially Set:
;	b$CRTWIDTH is statically initialized to 80.
;
;
;Modified By:
;	The value of b$CRTWIDTH should only be modified by calling B$SCNSWI.
;	Note that the WIDTH function will also modify this value directly.
;
;Used By:
;	Any routine (OEM-dependent or OEM-independent) that needs to know
;	the current size of the screen.
;*****************************************************************************

	globalB b$CRTWIDTH,80	; Characters per line (40 or 80 allowed)

	globalD b$RndVar,050000H,1 ; Random number generator seed.

	externB	b$Buf1		; 256+2 bytes of temporary storage

	EVEN			; SD's must be word-aligned
labelW <PUBLIC,b$SDBuf1>	; sd to b$Buf1
	staticW	,0			; size
	staticW	,<OFFSET DGROUP:b$Buf1> ; address of data


	globalB b$PRFG,0	; print control flag.  See PRNVAL.ASM
				; for the legal bit values.

sEnd	_DATA			

sBegin	_BSS			


;	MACLNG variables for DRAW

	globalB B$DRWSCL,,1	;DRAW: SCALE
	globalB B$DRWFLG,,1	;DRAW flag
	globalB B$DRWANG,,1	;DRAW "ANGLE" (0..3)

	globalD B$COSA,,1	;Cosine(Rad(ang))
	globalD B$MSINA,,1	;-Sin(Rad(ang))*Aspect
	globalD B$DSINA,,1	;Sin(Rad(ang))/Aspect


;
	globalW B$MCLPTR,,1	;MAC LANG PTR
	globalW B$MCLLEN,,1	;STRING LENGTH
	globalW B$MCLTAB,,1	;PTR TO COMMAND TABLE
	globalW B$MCLPSD,,1	; PTR TO STRING DESCRIPTOR

B$LENDRW EQU	B$MCLPTR-B$DRWSCL 
	PUBLIC	B$LENDRW 	



;	From GWUND.ASM in interpreter:

	EVEN

	globalW B$X_BASE,,1	;Integer x base value for rel coords
	globalW B$Y_BASE,,1	;Integer y base value for rel coords

; To help speed up the point function, the following variables must be
; contiguous (can be in any order) so a block copy onto the stack can
; be done instead of a zillion pushes.

	labelW	<PUBLIC,B$GRAFACC> ; Graphics accumulator block
	globalW B$GRPACX,,1	;previous X Coordinate
	globalW B$GRPACY,,1	;previous Y Coordinate

;	B$GX_OLD, B$GY_OLD must be contiguous in memory for circle code

	globalW B$GX_OLD,,1	;X Position of First Coordinate
	globalW B$GY_OLD,,1	;Y Position of First Coordinate
	globalW B$GXPOS,,1	;X Position of Second Coordinate
	globalW B$GYPOS,,1	;Y Position of Second Coordinate

	globalB B$DFRACX,,1	;8 bit fraction x after
				;angle transform (*)Order!
	globalB B$DFRACY,,1	;8 bit fraction y after
				;angle transform (*)


;	The following two variables must be consecutive in memory.

	globalD B$GRFACX,,1	;Logical Graphic acc x
	globalD B$GRFACY,,1	;Logical Graphic acc y



	labelW	<PUBLIC,B$LASTACC>
	PUBLIC	B$SIZEACC
B$SIZEACC EQU	(B$LASTACC-B$GRAFACC)/2 ;external constant

	globalW B$MAXUPD,,1	;Address of Major Axis Move Update
	globalW B$MINUPD,,1	;Address of Minor Axis Move Update
	globalW B$MAXDEL,,1	;Largest Delta for Line
	globalW B$MINDEL,,1	;Smaller of 2 Deltas for Line

	globalW B$LINSTL,,1	;Line style

				; speed optimization for circle
	globalB B$CLIPF,,1	; Clipping flag
	globalB B$CLINEF,,1	;LINE-TO-CENTER FLAG
	globalW b$ASPECTR,,1	;ASPECT RATIO
	globalW B$CENCNT,,1	;END CIRCLE POINT COUNT
	globalW B$CNPNTS,,1	;1/8 NO. OF PTS IN CIRCLE
	globalW B$CPCNT,,1	;1/8 NO. OF PTS IN CIRCLE
	globalW B$CPCNT8,,1	;NO. OF PTS IN CIRCLE
	globalW B$CRCSUM,,1	;CIRCLE SUM
	globalW B$CSTCNT,,1	;START COUNT
	globalB B$CPLOTF,,1	;PLOT FLAG
	globalB B$COPTFL,,1	;FLAG WHETHER ASPECT WAS .GT. 1
	globalD B$A_START,,1	;FLTING PT. START ANGLE FOR CIRCLE STMT
	globalD B$A_END,,1	;FLTING PT. END ANGLE FOR CIRCLE STMT


	globalW B$C1SAVE,,1	;ADVGRP C save area
	globalW B$C2SAVE,,1	;ADVGRP C save area
	globalW B$C3SAVE,,1	;ADVGRP C save area
	globalW B$CXOFF,,1	;X OFFSET FROM CENTER SAVE LOC
	globalW B$CYOFF,,1	;Y OFFSET SAVE LOCATION


	globalB B$LFPROG,,1	;PAINT: SCAN LINE ALREADY PAINTED FLAGS
	globalB B$RTPROG,,1
	globalW B$SKPCNT,,1	;SKIP COUNT
	globalW B$MOVCNT,,1	;MOVE COUNT
	globalB B$PDIREC,,1	;PAINT DIRECTION

	EVEN
	globalB B$TILFLG,,1	;Tiling on/off flag
	globalB B$TIPROG,,1	;Tile progress flag
	globalB B$TILNDX,,1	;TILE TABLE INDEX (Y COORD MOD 64)
	globalB B$TILLEN,,1	;TILE LENGTH
	globalW B$TILLOC,,1	;TILE STRING'S ADDRESS
	globalW B$BGTLOC,,1	;Background tile STRING'S ADDRESS
	globalB B$TILHGT,,1	;Pixel height of tile string
	globalB B$TILPTR,,1	;ptr to fground tile string
	globalB B$GRPLAN,,1	;# of planes,for tile interpretation


	EVEN

	globalW B$PQGET,,1	;Queue head
	globalW B$PQPUT,,1	;Queue tail
	globalW B$PQNUM,,1	;Present length
	globalW B$PQLEN,,1	;Maximum queue length

;	(*)the next two variables must be in this order:

	globalB B$WNDWSW,,1	;1 if WINDOW in effect, else zero
	globalB B$WNDWSC,,1	;1 if WINDOW SCREEN in effect, else zero (*)

;	(*)the next two variables must be in this order:

	globalB B$VIEWSW,,1	;Viewport active=1
	globalB B$VIEWSC,,1	;VIEW SCREEN active=1 (*)

	globalW B$GXHPOS,,1	;bx1	Temps for clipping box
	globalW B$GXLPOS,,1	;bx2	and box fill...
	globalW B$GYHPOS,,1	;by1
	globalW B$GYLPOS,,1	;by2

;	End of new graphics data


;***
;b$COM_DCB - COM Device Control Block (DCB)
;
;Purpose:
;	This variable points to the beginning of the first COM
;	Device Control Block (DCB).  There are NUM_RS232 contiguous
;	control blocks at this location, each one controlling a
;	separate COM port.  NUM_RS232 is a constant defined at the
;	time the OEM-independent code is compiled.
;
;Allocation:
;	b$COM_DCB is a BYTE value declared in the _BSS segment by the
;	OEM-independent code.  The COM DCBs exist in memory even if
;	the COM support code is not linked in.
;
;Values:
;	The definition and size of a DCB can be found in COMDCB.INC.
;	The runtime will make sure that all bytes in this block are
;	0 at initialization time.  Even if COM support code is not linked
;	into the program, all items that access the b$COM_DCB will
;	currently work as they check if the port has been opened, and
;	0 is a flag to indicate that it is closed.
;
;Initially Set:
;	The value of b$COM_DCB is statically initialized to be all 0.
;	The DCBs are reset to a closed state at RUN time.
;
;Modified By:
;	The fields in b$COM_DCB may be modified by any routine as long
;	as the Device Control Block still repesents the current status
;	of the COM port(s).
;
;Used By:
;	Any routine needing information about the COM port(s).
;
;****************************************************************************

;	CDCBSZ=24D

	labelB <PUBLIC,B$CM1DCB> 
	globalB b$COM_DCB,0,<(SIZE COMDCB)*NUM_RS232> ;space for COM DCB's



	globalB b$LOCKTYPE,,1	; LOCK type for OPEN statment
	globalB b$ACCESS,,1	; ACCESS type for OPEN statement
	globalB b$FILMOD,,1	; file MODE for OPEN statment

;***
;b$KEY_SW - Status of Function Key Display
;OEM-Callback routine (variable)
;
;Purpose:
;	This variable serves two different purposes.  First of all, it
;	indicates the current status of the function key display.  Once
;	it is initially set, it should always reflect the display status
;	properly.  Secondly, this variable is used to turn on or off the
;	function key display.  To do this, set b$KEY_SW to the desired
;	status and do an indirect call to [b$vKEYDSP].
;
;Allocation:
;	b$KEY_SW is a byte value declared in the _BSS segment by the
;	OEM-Independent code.
;
;Values:
;	0  - Function Key Display is turned off (not displayed)
;	FF - Function Key Display is turned on (displayed)
;
;Initially Set:
;	b$KEY_SW is statically initialized to 0 (off).
;
;Modified By:
;	This variable should only be modified by code that updates the
;	function keys.	Any change to b$KEY_SW must be followed by a
;	call to [b$vKEYDSP].
;
;Used By:
;	Any routine that needs to know if the function keys are displayed.
;****
	globalB b$KEY_SW,,1	;initial func key off=0 / on=-1 switch
	globalB B$FKCNUM,,1	;number of chars of softkey to display

	staticB ERDEVP_STR,,8
	globalW b$ERDEV,,1	; device error word

	globalW B$LNASEG,,1	;LNA segment value
	globalW B$LNAOFF,,1	;LNA offset value


	globalW B$SOFT_KEY_LEN,,1    ;Nonzero if eating Soft Key chars
	globalW B$SOFT_KEY_INDEX,,1  ;Base pointer to Soft Key String



sEnd	_BSS			


sBegin	BR_SKYS 		

	labelD	<PUBLIC,b$STRTAB>       ;SOFTKEY table (word aligned)
	globalD b$SOFT_KEYS,0,NUM_FKEYS ;Initial SOFTKEY values
					;4 bytes/soft key
	labelD	<PUBLIC,b$STRTAB_END>   ;offset to end of table
sEnd	BR_SKYS 		


sBegin	CONST			

.8087				;so floating point constants will be IEEE format

	globalD b$FP_1,<1.0>	  ;s.p. 1.0 constant
	globalD b$FP_256,<256.0> ;s.p. 256.0 constant

sEnd	CONST			

sBegin	DV_TEXT

	externNP B$NearRet

sEnd	DV_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwini.asm ===
TITLE	GWINI - GW BASIC 2.0 Initialization/Utility Routines
;***
; GWINI - GW BASIC 2.0 Initialization/Utility Routines
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;	The routines in this module are always called; regardless of
;	whether the statements they are initializing are found in the
;	program or not. This module should not cause any statement
;	processing module to be linked in (i.e. only low-level routines
;	should be called).
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; general runtime macros

	UseSeg	_BSS		
	UseSeg	_DATA		
	UseSeg	ER_TEXT 	
	UseSeg	RT_TEXT 	

	INCLUDE seg.inc 	; Segment definitions
	INCLUDE baslibma.inc
	INCLUDE files.inc
	INCLUDE nhutil.inc	
	INCLUDE idmac.inc	; Internal debugging macros
	INCLUDE const.inc	; bit flag constants
	INCLUDE rtps.inc	; constants shared with QBI

	.radix	10

sBegin	_DATA			

globalW b$pCommSave,Near_Ret,1	; conditional vector to B$CommSave
globalW b$pCommRestore,Near_Ret,1 ; conditional vector to B$CommRestore

; b$TempSD is a general purpose string descriptor for temporary use
globalW b$TempSD,?,2		; handle (ppData) & SB

externB	b$CRTWIDTH		; Physical width
externB	b$SCRNWIDTH		; Logical width
externB b$WDOBOT		
externB b$WDOTOP		

externW	b$CURSOR		; (1,1)-relative screen cursor
externB b$LINCNT		
externW b$VWINI_PTR		;Calls B$GRPINI once initialized
externW __aenvseg



;			  Added with revision [28]
;***
;b$IOFLAG - General Purpose IO Bits
;OEM-callback routine (variable)
;
;Purpose:
;	This variable keeps track of the global state of the I/O module.
;	Most of the bits in the flag variable are used to handle all the
;	different cases for I/O redirection.
;
;Allocation:
;	b$IOFLAG is a BYTE value declared in the _DATA segment by
;	the OEM-Independent code.
;
;Values:
;	Field definitions of b$IOFLAG are in CONST.INC.  Initially, all
;	fields are set to 0.
;
;	RED_INP is a bit that is set when input from stdin is being redirected
;	    from a file.  This field is set during console initialization
;	    by the runtime and is not changed.	(01H)
;
;	RED_OUT is a bit that is set when output stdout is being redirected
;	    to a file.	This field is set during console initialization
;	    by the runtime and is not changed.	(02H)
;
;	LPR_ECHO is a bit that is set when output to the screen is being
;	    echoed to the line printer.  Its value does not affect redirected
;	    IO, but the printer will not echo redirected output.  (04H)
;	    This field is set/cleared when the Print Scrn key is recognized.
;
;	F_KDSP is a bit that is set when currently updating a function key
;	    display, and output should not be sent to the printer or a
;	    redirected file.  A special routine to map the function keys
;	    is called when this is true.  (08H)
;
;	IN_INPUT is a bit that is set when redirected output to stdout is
;	    to be inhibited.  This is when an INPUT statement is being
;	    processed, and the user is editing his input.  Not until the
;	    user hits <return> is the data entered sent to the redirected
;	    file, so that the editing corrections are not present.
;	    However, while IN_INPUT is set , output will go to the screen,
;	    using screen cursor values. (10H)
;
;	F_EDIT is a bit that is set when in the INPUT statement, and B$PRTMAP
;	    should be disabled as B$EDTMAP does the mapping.  (20H)
;
;	SCN_INIT is a bit that is set to indicate that the screen has been
;	    physically initialized. This field is set by the OEM at the
;	    time the screen is actually initialized (B$SCINIT).  (40H)
;
;	SCN_SCROLL is a bit indicating that we need to scroll the screen
;	    upon the first screen operation because we entered on the last
;	    line of the screen.  This flag is only used by the OEM before
;	    the screen has been physically initialized.  (80H)
;
;Initially Set:
;	RED_INP is set by the OEM-Independent code before B$GWINI or
;		B$RTLLINIT are called.
;	RED_OUT is set by the OEM-Independent code before B$GWINI or
;		B$RTLLINIT are called.
;	LPR_ECHO is statically initialized to be 0.
;	F_KDSP	is statically initialized to be 0.
;	IN_INPUT is statically initialized to be 0.
;	F_EDIT	is statically initialized to be 0.
;	SCN_INIT is statically initialized to be 0.
;	SCN_SCROLL is statically initialized to be 0.
;
;Modified By:
;	RED_INP and RED_OUT should not be modified once initialized.
;	LPR_ECHO is modified by the OEM-Independent code upon detection
;		of the Print Screen Key and upon a RUN command.
;	F_KDSP is set at the beginning of the function key update routines
;		and cleared at the end of them.
;	IN_INPUT and F_EDIT are set and cleared by the Screen Editor
;	SCN_INIT and SCN_SCROLL are only modified by the OEM-Dependent code.
;
;Used By:
;	All the fields of b$IOFLAG except for SCN_INIT and SCN_SCROLL are
;	only used by the OEM-Independent Code. SCN_INIT is used by both
;	the OEM-Dependent code and the termination code.  If SCN_INIT
;	is 1 at termination time, then B$RESETSCN will be called.  Otherwise
;	B$RESETSCN will not be called by the termination code.	SCN_SCROLL
;	is not used by the OEM-Independent Code in any way.  This flag
;	may be used for any purpose.
;****

globalB	b$IOFLAG,0		; general-purpose IO bits defined above.

;*** 
;b$vKEYDSP - Vector for indirect call to B$KEYDSP, display/clear function keys
;OEM-callback routine (variable)
;
;Purpose:
;	Update the function key display.  If b$KEY_SW is set to 0 then
;	the function key display is disabled and is removed from the
;	screen if it existed.  If b$KEY_SW is set to -1, then the
;	function key display is enabled and is displayed on the screen
;	if needed.
;
;	This routine is called indirectly through the vector
;	b$vKEYDSP
;
;Entry:
;	B$KEY_SW set appropriately:  0 = turn off function key display
;				    -1 = display function keys.
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	Just returns unless B$KEYDSP is linked in by B$INPP or B$KFUN.
;
;Vector Information:
;	b$vKeyDSP is a WORD value defined in the _DATA segment by the
;	OEM-Independent code.  It is set up by an initializer before
;	the BASIC runtime is first called.  It should not be modified.
;******************************************************************************

globalW	b$vKEYDSP,Near_Ret,1	


sEnd	_DATA			


sBegin	_BSS			

externB   b$KEY_SW	  ;GWDATA -
externW   B$WNDWSW	  ;GWDATA -

;***
; b$HugeShift, b$HugeDelta - OS selector shift count for HUGE access
;OEM-callback routine (variable)
;
;Purpose:
;	This value is used to access successive pieces of a
;	HUGE array.  To get to the next segment of memory in
;	which the array exists, use the following formula:
;	(assuming that the array is accessed through DS:)
;
;		DS:  =	DS: + (1 << b$HugeShift)
;
;	The value (1 << b$HugeShift) is precomputed and stored
;	in the variable b$HugeDelta.
;
;	NOTE: For DOS, these variables are guarenteed to be identical
;	      each time the program is run and could be replaced by
;	      constants.
;
;Allocation:
;	b$HugeShift is a BYTE value defined in the _BSS segment by
;	the runtime code.
;
;	b$HugeDelta is a WORD value defined in the _BSS segment by
;	the runtime code.
;
;Values:
;	The values for b$HugeShift and b$HugeDelta are dependent upon
;	the operating system.  Both variables are initialized by the
;	runtime during runtime initialization and should not be changed.
;
;Initially Set:
;	The values of these variables are undefined until they are set
;	at initialization time.  They are initialized after B$GWINI and
;	and B$RTLLINIT are called but before any user code is executed
;	or interpreted.
;
;Modified By:
;	These variables should not be modified once they are initialized.
;
;Used By:
;	These variables are used by anyone who wants to access a dynamic
;	array bigger than 64K.
;****************************************************************************

	globalB b$HugeShift,?	;OS selector shift count for HUGE access
				;NOTE: this uses an extra byte from
				;b$HugeDelta when we pass b$HugeShift to
				;DOSGETHUGESHIFT (which returns a WORD)
	globalW b$HugeDelta,?	;OS selector seg increment for HUGE access

;***
;b$Buf1, b$Buf2 - temporary buffer space
;OEM-callback routine (variable)
;
;Purpose:
;	Both b$Buf1 and b$Buf2 are large buffers of temporary storage
;	for general use.  These buffers are used in many places
;	throughout the runtime.  While it is theoretically possible for
;	the OEM code to use either or both of these buffers any time they
;	are not in use, there is no way to determine whether they are being
;	used.  The mechanism in the rest of the runtime for determining
;	availability is visual inspection and use of the routines
;	B$HoldBuf(n) and B$FreeBuf(n) which do not exist in a release
;	version.
;
;	These buffers are mainly described here for the understanding
;	of the sample code supplied by MicroSoft.  However, there are a
;	couple of specific times the buffers are guaranteed to be free,
;	which are described below.
;
;	Note that b$Buf2 immediately follows b$Buf1, so if both are
;	available you have a block of 258 contiguous bytes of DGROUP.
;
;Allocated:
;	b$Buf1 is a block of 129 BYTES allocated in _BSS by the runtime.
;	b$Buf2 is a block of 129 BYTES allocated in _BSS by the runtime.
;
;Values:
;	Undefined
;
;Initially Set:
;	Undefined
;
;Modified By:
;	Undefined
;
;Used By:
;	b$BUF1 is guaranteed to be available during the calls to
;		B$GWINI and B$RTLLINI.	Furthermore, it is guaranteed
;		that the value of b$BUF1 will not change between these
;		two calls.
;	b$BUF2 is guaranteed to be available with the same conditions as
;		b$BUF1.  Also, b$BUF2 will be available for use during
;		the execution of any of the routines in LLCOM5.ASM.
;		However, the contents of the buffer may change between
;		calls to these routines.
;******************************************************************************
;
; NOTE -- Any (or all) of these LARGE buffers can be used by anyone
; that wants to, provided they are not used in a calling routine.  
; IN DEBUG CODE, call B$HoldBuf(1,2,12,3) to allocate the the buffers to
; your routine, and B$FreeBuf(1,2,12,3) to release the buffers.
;
;#########

labelB	<PUBLIC,b$PATHNAM>	; pathname buffer
globalB b$Buf1,,FILNAML	; 1st large (pathname-sized) scratch buffer
globalB b$Buf2,,FILNAML	; 2nd large (pathname-sized) scratch buffer
globalB b$Buf3,,16		; 3rd scratch buffer
				; these buffers MUST remain contiguous

sEnd	_BSS			


sBegin	RT_TEXT

assumes cs,RT_TEXT

	PAGE

	SUBTTL	Screen initialization

;***
; B$WHOME - Home the text cursor
; Moved here from iotty.asm with revision [60].  See note below!
;
; Input:
;	b$WDOTOP set
; Output:
;	[DL] == home row of cursor
;	[DH] == home column of cursor
; Modifies:
;	NONE
; Note:  
;  IMPORTANT: Must be kept in sync with the local WHOME routine in iotty.asm
;****

cProc	B$WHOME,<PUBLIC,NEAR>
cBegin
	MOV	DL,b$WDOTOP
	MOV	DH,1
cEnd


;***
; B$CRLF - Adust cursor row/column while doing a CR/LF. [61]
; Added with [60].
;
; Purpose:
;	This routine is called every time a CR/LF is to be output
;	to the screen.  It checks whether the screen will need to be
;	scrolled and if not, increments DL.  Flags are set indicating
;	whether or not the screen must be scrolled. DH is set to 1.
;
; Entry:
;	DL = current line
;
; Exit:
;	DH = 1
;	DL = new line
;	ZF ==> didn't change DL, since on last line
;	NZ ==> changed DL, since not on last line
;
; Modifies:
;	None
;****
cProc	B$CRLF,<PUBLIC,NEAR>	
cBegin
	MOV	DH,1		; reset cursor column to 1  
	CMP	DL,b$LINCNT 	; on status line?
	JNE	NOT_STATUS	; brif not -- don't adjust line
	MOV	DL,b$WDOBOT 	; move cursor to bottom
				; line of text window
NOT_STATUS:
	CMP	b$WDOBOT,DL	; Are we at bottom of window?
	JE	NO_INC		; brif so -- ZF ==> last line
	INC	DX		; increment row (NZ)
NO_INC:				; return with flags set
cEnd

;***
;B$SCNCLR - Home Text & Graphics Cursor, Refresh Function Key Display
;OEM-callback routine
;
;	Re-written with revision [54].
;
;Purpose:
;	This routine is used to initialize the screen editor, reset
;	the graphics viewport and window to the screen dimensions,
;	center the graphics cursor, home the text cursor and display
;	the function keys if needed.
;
;	This routine must be called at initialization and whenever
;	screen characters are no longer accessible to the user because
;	the screen dimensions have changed.  This routine should only
;	be called from B$SCRSTT, B$SWIDTH, B$RESETSCN, and during
;	initialization.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$SCNCLR,<NEAR,PUBLIC>
cBegin

	CALL	B$WHOME			; DX=text cursor home
	MOV	b$CURSOR,DX		; update b$CURSOR
	CALL	[b$vKEYDSP] 		; Conditionally display softkeys
			 		; (displays user cursor at position
					; b$CURSOR when done)

cEnd	<nogen>				; fall into B$VIEWINIT


;		Added as part of revision [30]
;***
;B$VIEWINIT - Initialize viewport, center graphics cursor
;OEM-callback routine
;
;Purpose:
;	Initialize the graphics viewport and centers the graphics cursor.
;	Sets the logical coordinate system to be identical to the
;	physical coordinate system (disable WINDOW command).
;
;Entry:
;	None
;
;Exit:
;	None
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$VIEWINIT,<NEAR,PUBLIC> 
cBegin				
	CALL	[b$VWINI_PTR]	;Initialize viewport, center graphics cursor
	MOV	B$WNDWSW,0	;Turn B$WNDWSW and B$WNDWSC off
Near_Ret:			;near ret for vectors
cEnd				

;***
;B$SCNSWI - Set screen width(logical/physical) and height
;OEM-callback routine
;
;Purpose:
;	B$SCNSWI will set the screen width (both logical and physical)
;	and screen height.  Since this routine is used to communicate
;	the screen dimensions to the Screen Editor, it must be called at
;	initialization and whenever the character dimensions of the
;	screen are modified.
;
;Input:
;	AL=width, CL=height
;
;Output:
;	None.
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$SCNSWI,<PUBLIC,NEAR>		
cBegin					

	MOV	b$CRTWIDTH,AL	; Set physical width of screen
	MOV	b$SCRNWIDTH,AL	; Set SCRN: logical width
	MOV	B$LINCNT,CL	;Save physical height
	MOV	b$WDOTOP,1	;Init window top
	PUSH	CX
	DEC	CL		; Reserve status line
	MOV	b$WDOBOT,CL	;Set window bottom
	POP	CX
cEnd				; End of B$SCNSWI


;***
;B$UPCASE - Convert Character to Upper Case
;DBCS-callback
;
;Purpose:
;	Convert the character in AL to uppercase if possible.  If it is
;	not a character or it is already uppercase, it is not modified.
;	This is done by a comparison against the range 'a'-> 'z'.  It does
;	not use the Operating System call to case convert characters
;	outside of this range.
;
;	NOTE:  It is the caller's responsibility to make sure that it is
;	       not sending 1/2 of a KANJI character to this routine.
;
;	WARNING: Because this routine is called by B$GETCH
;
;			  DS != DGROUP
;
;		 If you go to change the code, keep this in mind!!!
;Entry:
;	AL = Character to convert
;
;Exit:
;	AL = UpperCase version of character
;
;Uses:
;	Per Convention
;
;Preserves:
;	AH, BX, CX, DX
;
;Exceptions:
;	None.
;****
cProc	B$UPCASE,<PUBLIC,NEAR>	
cBegin
	CMP	AL,'a'		;Is AL < 'a'
	JB	upret		;Skip it
	CMP	AL,'z'		;Is AL > 'z'
	JA	upret		;Skit it
upit:				
	AND	AL,255-' '	;Convert to Upper Case
upret:
cEnd


;*** 
;B$Mul32x16 -- 32 by 16 bit multiply
;
;Purpose:
;	Added with revision [68].
;
;Entry:
;	[DX|AX] = multiplicand
;	[CX]	= multiplier
;
;Exit:
;	[DX|AX] = [DX|AX] * [CX]
;	CF ==> overflow
;
;Uses:
;	BX
;
;Preserves
;	CX
;
;Exceptions:
;	None
;
;******************************************************************************
cProc	B$Mul32x16,<PUBLIC,NEAR>
cBegin
	xchg	bx,dx		; [BX|AX] = multiplicand
	mul	cx		; multiply low word by 1000 ([DX|AX] = result)
	push	ax		; save low word result
	push	dx		; save first overflow
	xchg	ax,bx		; AX = high word
	mul	cx		; [DX|AX] = result of high word multiply
	pop	dx		; DX = original high word
	jc	Overflow	; brif overflow (need to clean stack)
	add	ax,dx		; AX = high word of result (PSW.C if overflow)
	xchg	ax,dx		; DX = high word of result
OverFlow:
	pop	ax		; AX = low word of result
cEnd

	page


sEnd	RT_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\grview.asm ===
TITLE	GRVIEW - Graphics VIEW Support
;***
; GRVIEW -  Graphics VIEW Support
;
;	Copyright <C> 1986 - 1988, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - VIEW Statement - Generates 1 call if no parameters, or 3 calls:
;
;      VIEW [[SCREEN][(x1,y1)-(x2,y2) [,[color] [,[boundary]]]] ]
;
;    Possibilities:
;
;      VIEW [SCREEN] (x1,y1)-(x2,y2) [,[color] [,[boundary]]]
;	 |
;     B$VIEW
;
;
;      VIEW
;	 |
;     B$VEW0
;
;
; - VIEW PRINT Statement
;
;
;      VIEW PRINT [top screen line TO bottom screen line]
;	      |
;	   B$VWPT
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	_DATA		
	USESEG	_BSS		
	USESEG	GR_TEXT 	

	INCLUDE seg.inc 	; segment definitions
	INCLUDE const.inc	; b$IOFLAG field definitions


sBegin	_DATA			

	externB b$LINCNT 	; support VIEW PRINT statement
	externB b$WDOTOP 	
	externB b$WDOBOT 	
	externB	b$IOFLAG	; Misc. IO flags.  Defined in GWINI.ASM

sEnd	_DATA			

sBegin	_BSS			
;
;****************************************************************************
; External low-level function vectors
;****************************************************************************
;
externW b$SetAttr		

	externB b$KEY_SW 	;defined in GWDATA.ASM
	externW B$VXSIZ		;defined in GRINIT.ASM
	externW B$VYSIZ		;defined in GRINIT.ASM
	externW B$VXMIN		;defined in GRINIT.ASM
	externW B$VYMIN		;defined in GRINIT.ASM
	externW B$VXMAX		;defined in GRINIT.ASM
	externW B$VYMAX		;defined in GRINIT.ASM
	externW B$VXOFF		;defined in GRINIT.ASM
	externW B$VYOFF		;defined in GRINIT.ASM
	externW B$GXPOS		;defined in GRINIT.ASM
	externW B$GYPOS		;defined in GRINIT.ASM
	externW B$GRPACX 	;defined in GWDATA.ASM
	externW B$GRPACY 	;defined in GWDATA.ASM

	externB B$VIEWSW 	;defined in GWDATA.ASM
	externB B$VIEWSC 	;defined in GWDATA.ASM

sEnd	_BSS			

assumes CS,GR_TEXT		
sBegin	GR_TEXT 		


	externNP B$ERR_FC	
	externNP B$ERR_AFE	
	externNP B$SCINIT	; initialize screen






	SUBTTL	VIEW - Define Viewport transformation

; SYNTAX: VIEW [SCREEN] [(vx1,vy1)-(vx2,vy2) [,[fill] [,[border]]]]

;	VIEW defines the "viewport" transformation from
;	vx1,vy1 (upper left x,y coordinates) to vx2,vy2
;	(lower right x,y coordinates).	The x and y coordinates
;	must be within the physical bounds of the screen  and
;	define the rectangle within the screen that graphics
;	will map into.
;	Initially, RUN (or VIEW with no arguments) define the
;	entire screen as the viewport.	The 'fill' attribute
;	allows the user to fill the VIEW area with a color.
;	If fill is omitted, the VIEW area is not filled.
;	The 'border' attribute allows the user to draw a line
;	surrounding the viewport if space for a border is
;	available.  If border is omitted, no border is drawn.

	externNP B$VWMAPC	
	externNP B$VEWINI	
	externNP B$VWFILL	
	externNP B$GRMODE	
	externNP B$BOXNOF	
	externNP B$SCNLOC	; update and display user cursor

;***
;ViewCoord1 - Process first coordinate pair for VIEW statement
;
;Purpose:
;	Process first coordinate pair for VIEW statement by saving in
;	B$VXMIN and B$VYMIN.  CALL B$VEWINI to initialize VIEW statement variables.
;Entry:
;	BX=first x coordinate = Vx1
;	DX=first y coordinate = Vy1
;Exit:
;	View variables updated
;Uses:
;	Per convention
;Exceptions:
;	Control may be transfered to B$ERR_FC
;****
cProc	ViewCoord1,<NEAR>	
cBegin				
	PUSH	BX		;Save x coord
	PUSH	DX		;Save y coord
	CALL	B$VEWINI 	;initialize VIEW variables
	POP	DX		;Restore x coord
	POP	BX		;Restore y coord
	MOV	B$VXMIN,BX	;B$VXMIN:=BX=vx1
	MOV	B$VYMIN,DX	;B$VYMIN:=DX=vy1
cEnd				;Return

;***
;ViewCoord2 - process second coordinate pair for VIEW statement
;
;Purpose:
;	Process second coordinate pair for VIEW statement.  Compare
;	Vx1 and Vx2, storing the largest of the two in B$VXMAX and the smallest
;	in B$VXMIN.  Compare vy1 and vy2, storing the largest of the two in
;	B$VYMAX and the smallest in B$VYMIN.  Issue a function call error if
;	VX1=VX2 or if VY1=VY2.
;Entry:
;	BX=second x coordinate = VX2
;	DX=second y coordinate = VY2
;Exit:
;	B$VXMIN,B$VYMIN,B$VXMAX,B$VYMAX updated
;Uses:
;	Per convention.
;Exceptions:
;	Control may be transfered to B$ERR_FC
;****
cProc	ViewCoord2,<NEAR>	
cBegin				
				;Make Vx1 .lt. Vx2 and Vy1 .lt. Vy2
				;If Vx1=Vx2 or Vy1=Vy2, then error.
	MOV	AX,B$VYMIN	;AX:=B$VYMIN
	CMP	AX,DX		;Compare B$VYMIN to VY2
	JZ	VEWFCE		;Error if Vy1=Vy2
	JB	VY1LT2		;Brif Vy1 .lt. Vy2
	XCHG	AX,DX		; else exchange
VY1LT2:
	MOV	B$VYMIN,AX	;Store Vy1
	MOV	B$VYMAX,DX	; and  Vy2
	CMP	B$VYSIZ,DX	;Screen y max cannot be
	JB	VEWFCE		;less than Vy2
	MOV	AX,B$VXMIN
	CMP	AX,BX		;Compare B$VXMIN(=VX1) to Vx2
	JZ	VEWFCE		;Error if Vx1=Vx2
	JB	VX1LT2		;Brif Vx1 .lt. Vx2
	XCHG	AX,BX		; else exchange
VX1LT2:
	MOV	B$VXMIN,AX	;Store Vx1
	MOV	B$VXMAX,BX	; and  Vx2
	CMP	B$VXSIZ,BX	;Screen x max cannot be
	JB	VEWFCE		;less than Vx2
cEnd				

VEWFCE:
	JMP	B$ERR_FC	;Error

;***
;B$VIEW - Process VIEW statement with parameters
;
;Purpose:
;	Set viewport as specified by current values of (B$VXMIN,B$VYMIN) and
;	(B$VXMAX,B$VYMAX) which get initialized in ViewCoord1 and ViewCoord2.
;	Update B$VXOFF and B$VYOFF if the SCREEN option was not specified.
;	If fill was requested, fill the viewport with the desired color
;	by calling B$VWFILL.  If a border was requested, draw the border
;	by calling B$BOXNOF in the LINE statement code in GENG86.
;	Update B$VIEWSC and B$VIEWSW to reflect the current active VIEW option.
;	B$VIEWSC = 0 means the most recent VIEW statement was not a VIEW SCREEN
;		= 1 means the most recent VIEW statement was a VIEW SCREEN
;	B$VIEWSW = 0 means the most recent VIEW statement was a VIEW w/ no parms
;		= 1 means the most recent VIEW statement was a VIEW with parms
;Entry:
;	x1,y1,x2,y2 - I2 coordinate pairs defining new viewport.
;	Color	    - fill color or -1 if default
;	Border	    - border color or -1 if default
;	fScreen     - screen flag: NZ if VIEW SCREEN option
;Exit:
;	Variables updated as noted above
;Uses:
;	Per convention.
;Exceptions:
;	Control may be transfered to B$ERR_FC
;****
cProc	B$VIEW,<PUBLIC,FAR>	
parmW	X1			
parmW	Y1			
parmW	X2			
parmW	Y2			
parmW	Color			
parmW	Border			
parmW	fScreen 		
cBegin				
	CALL	B$SCINIT	; init screen if not already done
	MOV	BX,X1		
	MOV	DX,Y1		
	cCall	ViewCoord1	;process first coord pair
	MOV	BX,X2		
	MOV	DX,Y2		
	cCall	ViewCoord2	;process second coord pair

	CALL	B$GRMODE 	;Legal graphics mode?
	JZ	VEWFCE		;Function call error if not in graphics mode
	MOV	BL,1		;default is VIEW SCREEN active
	CMP	fScreen,0	;VIEW SCREEN option specified?
	JNZ	VEWSCR		;Brif so, don't set offsets
	DEC	BL		;no VIEW SCREEN
	MOV	AX,B$VXMIN	;AX:=B$VXMIN
	MOV	B$VXOFF,AX	;B$VXOFF:=B$VXMIN for VIEW no SCREEN
	MOV	AX,B$VYMIN	;AX:=B$VYMIN
	MOV	B$VYOFF,AX	;B$VYOFF:=B$VYMIN for VIEW no SCREEN
VEWSCR:
	MOV	B$VIEWSC,BL	;Set VIEW SCREEN active
	MOV	AX,Color	;get color attribute
	INC	AX		;default fill attribute?
	JZ	VBRDR		;Yes: don't fill but check border
	DEC	AX		;recover correct attribute
	CALL	B$VWFILL 	;No: fill viewport with color
VBRDR:				;Check border parameter
	MOV	AX,Border	;get border color
	INC	AX		;default border color?
	JZ	VEWRET		;Yes: don't draw border
	DEC	AX		;recover real border color
	CALL	[b$SetAttr]	;set border attr
	JB	VEWFCE		;ERROR IF ILLEGAL ATTRIBUTE
	CALL	DrawBorder	;draw border to view region
VEWRET:
	MOV	B$VIEWSW,1	;Set Viewport active
	CALL	B$VWMAPC 	;Set up View "C" bounds for PAINT.
				; and Graphics cursor to VIEW center
cEnd				

;***
;DrawBorder - Draw border for viewport
;
;Purpose:
;	 Draw viewport border by calling B$BOXNOF in GENG86.  B$BOXNOF
;	 is a routine in the code for the LINE statement which FG_DRAW
;	 an unfilled box.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	Per convention
;Exceptions:
;	None.
;****
cProc	DrawBorder,<NEAR>	
cBegin				
	MOV	AX,B$VXMAX
	PUSH	AX
	INC	AX		;Line outside viewport
	MOV	B$GRPACX,AX
	MOV	B$GXPOS,AX	;vx2
	MOV	AX,B$VYMAX
	PUSH	AX
	INC	AX		;Line outside viewport
	MOV	B$GRPACY,AX
	MOV	B$GYPOS,AX	;vy2
	MOV	CX,B$VXMIN
	PUSH	CX
	DEC	CX		;Line outside viewport
	MOV	DX,B$VYMIN
	PUSH	DX
	DEC	DX		;Line outside viewport
	XOR	AX,AX
	MOV	B$VXMIN,AX	;Vx1= 0
	MOV	B$VYMIN,AX	;Vy1= 0
	MOV	AX,B$VXSIZ
	MOV	B$VXMAX,AX	;Vx2= x max
	MOV	AX,B$VYSIZ
	MOV	B$VYMAX,AX	;Vy2= Y max
	CALL	B$BOXNOF 	;Draw Viewport Border
	POP	B$VYMIN		;vy1
	POP	B$VXMIN		;vx1
	POP	B$VYMAX		;vy2
	POP	B$VXMAX		;vx2
cEnd				

;***
;B$VEW0 - process VIEW statement with no parameters
;
;Purpose:
;	Process a VIEW statement that has no parameters.
;	Call B$VEWINI to initialize viewport to the entire screen.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	Per Convention.
;Exceptions:
;	Control may be transfered to B$ERR_FC
;****
cProc	B$VEW0,<PUBLIC,FAR,FORCEFRAME> 
cBegin				
	CALL	B$SCINIT	; init screen if not already done
	CALL	B$GRMODE 	;Legal graphics mode?
	JZ	VWFERR		;Function call error if not in graphics mode
	CALL	B$VEWINI 	;viewport := screen
cEnd				

VWFERR:
	JMP	B$ERR_FC	;Function call error


;***
;B$VWPT - VIEW PRINT statement
;
;Purpose:
;	VIEW PRINT statement for setting the boundaries of the text
;	window.
;
;	SYNTAX:
;	   VIEW PRINT [<top line> TO <bot line>][,<left col> TO <right col>]
;
;	Note that each TO clause which is present must have both numbers
;	present.
;	   "VIEW PRINT" alone will reset the text window to whole screen.
;	   "VIEW PRINT x TO y" will set top and bottom only.
;	   "VIEW PRINT ,x TO y" will set left and right only.
;	An illegal function call will result
;	   -if <top line> is .GT. <bot line>,
;	   -if <left col> is .GT. <right col>,
;	   -if any parameter is larger than current screen dimensions,
;
;	------------------------ NOTE -----------------------------
;	Since the screen editor does not yet support the arbitrary
;	setting of the right and left margins of the screen window,
;	the second TO clause of the VIEW PRINT statement is not yet
;	allowed and will make for a syntax error if present.
;	-----------------------------------------------------------
;
;Entry:
;	TopLine = Top line (default -1)
;	BotLine = Bottom line (default -1)
;Exit:
;	WDOTOP and WDOBOT
;Uses:
;	Per convention.
;Exceptions:
;	Control may be transfered to B$ERR_FC
;****
cProc	B$VWPT,<PUBLIC,FAR>	
parmW	TopLine 		
parmW	BotLine 		
cBegin

	TEST	b$IOFLAG,RED_OUT ;	Is output redirected?
	JNZ	VWPT_XIT	; brif so -- do nothing.

	MOV	AH,b$KEY_SW	
	MOV	AL,b$LINCNT	
	MOV	BX,TopLine	
	MOV	DX,BotLine	
	INC	BX		;default?
	JZ	DEFAULT 	;brif so
	DEC	BX		;top line = 0?
	JZ	VPFCE		;brif so
	JS	VPFCE		;or if < 0
	CMP	BX,DX		;top line > bottom line
	JA	VPFCE		;brif so .... error
	PUSH	DX		;save [dx]
	ADD	DL,AH		;make sure bottom line is not off screen and
	CMP	DL,AL		;does'nt include function key display line (if ON)
	POP	DX		;restore [dx]
	JA	VPFCE		;brif above .... error
	JMP	SHORT NOTDEF
DEFAULT:
	INC	BX		; [bx] = 1
	XOR	DX,DX
	MOV	DL,AL		;[dl] = line count
	SUB	DL,AH		;[dl] = line count or line count - 1
NOTDEF:
	MOV	b$WDOTOP,BL	;set text window top
	MOV	b$WDOBOT,DL	;set text window bottom
	MOV	DL,BL		;[dl] = window top , cursor top
	MOV	DH,1		;[dh] = window left , cursor left
	CALL	B$SCNLOC 	; update b$CURSOR and display user cursor

VWPT_XIT:			
cEnd				

VPFCE:
	JMP	B$ERR_FC	;function call error

	externNP B$PCOPYS	

;***
;B$PCPY - PCOPY STATEMENT
;
;Entry:
;	FromPage - 'FROM' PAGE
;	ToPage	 - 'TO' PAGE
;Exit:
;	None.
;Uses:
;	Per convention.
;Exceptions:
;	B$ERR_AFE,B$ERR_FC
;	Illegal Function Call Error in case of any error if PCOPY is supported
;	Else Advanced Function Error is issued
;
;****
cProc	B$PCPY,<PUBLIC,FAR>	
parmW	FromPage		
parmW	ToPage			
cBegin				

;No range checks are necessary - $PCOPY does it
	MOV	AX,FromPage	; AX = source page number
	MOV	CX,ToPage	; AX = destination page number
	CALL	B$PCOPYS 	;Do the move
	JNC	OKRET		; everything ok so return
				; carry is set so something is wrong
	JMP	B$ERR_FC	; Illegal function call
				;(never returns)
OKRET:
cEnd				

sEnd	GR_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwcevt.asm ===
PAGE	56,132
	TITLE	GWCEVT - Core of GW BASIC 2.0 Event Handler
;***
; GWCEVT - Core of GW BASIC 2.0 Event Handler
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains event trapping support which is needed
;	whether or not the user program does event trapping.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	

	UseSeg	EV_TEXT 	
	UseSeg	_BSS		
	UseSeg	_DATA		

	INCLUDE seg.inc 	
	INCLUDE baslibma.inc
	INCLUDE event.inc	; misc equates
	INCLUDE devdef.inc
	INCLUDE const.inc	; b$IOFLAG field definitions

sBegin	EV_TEXT 		
	INCLUDE queues.inc	;get structure and access routines
	externNP B$NearRet	
sEnd	EV_TEXT 		

sBegin	_DATA			
	globalW b$pInitKeys1,B$NearRet,1 
	globalW b$pInitKeys2,B$NearRet,1 
sEnd	_DATA			

sBegin	_BSS			
	externW b$cCSubs	;Compiled sub nesting level

;	Trap table and flag for ON <event> GOSUB trap.

	globalB b$TRAP_SEM,,1	;nonzero if event dispatch queued
	EVEN

	labelB	<PUBLIC,b$TRPTBL>	    

	staticB b$TRP_RS232,,<5*NUM_RS232> ;NUM_RS232 COM traps.

	globalB b$TRP_LITEPEN,,<5*NUM_LITEPEN> ;NUM_LITEPEN PEN traps.

	staticB b$TRP_TKEYS,,<5*NUM_TKEYS> ;NUM_TKEYS KEY traps.

	staticB b$TRP_JOYST,,<5*NUM_JOYST> ;NUM_JOYST TRIG traps.

	staticB b$TRP_SOUND,,<5*NUM_SOUND> ;NUM_SOUND PLAY traps.

	staticB b$TRP_TIMER,,<5*NUM_TIMER> ;NUM_TIMER TIMER traps.




	labelB	<PUBLIC,b$TRPTBLEND> 

	EVEN			; Trap table must be an even number
				; of bytes
	PUBLIC	b$TRAP_QUE	
b$TRAP_QUE QUEUE<>		;Active Trap Queue Control Block

	DW	(NUM_TRAPS+1) DUP(?) ; event gosub addrs go here

sEnd	_BSS			

externFP B$IEvSet		;QB interp routine to set EVENT BOS flag

assumes CS,EV_TEXT		
sBegin	EV_TEXT 		



	SUBTTL	TRAP ROUTINES - ON/OFF/STOP/REQUEST/FREE/RESET

;***
;B$OnTrap , B$OffTrap , B$StopTrap
;
;entry: BX - index to b$TRPTBL
;	CH - KEY# if present (1 based)
;	CL - <evt>OFF
;	SI - low level routine, if present
;****

;TURN TRAP ON

cProc	B$OnTrap,<PUBLIC,NEAR> 
cBegin				
	test	byte ptr[bx],TRP_OS ; don't enable if already active
	jnz	on_already
	mov	al,enable_trap	; tell low-level
	call	set_oem_trap	; to start trapping [key #ch]
on_already:
;	CLI
	MOV	AL,[BX]
	AND	AL,TRP_RQ+TRP_CN ;LEAVE REQUEST BIT and Context bit
	OR	AL,TRP_ON	;Set Event Trapping ON.
	CMP	AL,[BX]
	MOV	[BX],AL
	JZ	ONTRP0		;NO CHANGE IN STATUS
	AND	AL,TRP_RQ
	JNZ	SETTRP		;Activate Delayed Trap Request
ONTRP0:
;	    STI
cEnd				

;TURN TRAP OFF

cProc	B$OffTrap,<PUBLIC,NEAR> 
cBegin				
	mov	al,disable_trap ; tell low-level
	call	set_oem_trap	; to stop trapping [key #ch]
;	    CLI
	MOV	AL,[BX] 	;get current status
	AND	AL,TRP_CN	;reset all but context bit
	XCHG	AL,[BX] 	;store new status
	JMP	SHORT FRECHK	;FREE OUTSTANDING REQUEST
cEnd	<nogen> 		

;STOP TRAP

cProc	B$StopTrap,<PUBLIC,NEAR> 
cBegin				  
	test	byte ptr[bx],TRP_OS ; don't enable if already active
	jnz	stopped_already
	mov	al,enable_trap	; tell low-level (if present)
	call	set_oem_trap	; to start trapping [key # in ch]
stopped_already:
;	    CLI 		    ;	 but don't mark as stopped
	MOV	AL,[BX]
	PUSH	AX
	OR	AL,TRP_ST	;Set Event Trap Stopped.
	MOV	[BX],AL
	POP	AX
FRECHK: 			;entry point for B$OffTrap
	AND	AL,TRP_MSK	;mask out context bit
	XOR	AL,TRP_ON+TRP_RQ ;if on and requested,
	JZ	FRETP2		;FREE THIS TRAP
;	    STI
cEnd				

;***
;set_oem_trap
;
;Purpose:
;
;Entry: al = enable/disable function
;	si = oem routine ($RD<evt>)
;	cl = trap table offset
;	ch = key number
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;****

cProc	set_oem_trap,<NEAR>	
cBegin				
	or	si,si
	jz	on_no_oem	; no oem routine if 0
	push	dx
	mov	dl,ch
	xor	dh,dh		; dx = key# (if calling B$RDKYBD)
	PUSH	BX		; Preserve trap table address
	call	si
	POP	BX		
	pop	dx
on_no_oem:
cEnd				

;***
;B$ResetTrap  - RESET STOP ON TRAP
;
;Purpose:
;
;
;Entry:
;
;
;Exit:
;
;
;Uses:
;
;
;Exceptions:
;
;****

cProc	B$ResetTrap,<PUBLIC,NEAR> 
cBegin				   
;	    CLI
	MOV	AL,[BX]
	AND	AL,TRP_ON+TRP_RQ+TRP_CN ;preserve ON,REQUESTED, and CONTEXT
	CMP	AL,[BX]
	MOV	[BX],AL
	JNZ	SETCHK_AL	;If new Status, may want to Request Trap
;	    STI
cEnd				

;***
;B$ReqTrap  - REQUEST TRAP
;
;Purpose:
;
;
;Entry:
;
;
;Exit:
;
;
;Uses:
;
;
;Exceptions:
;
;
;****

cProc	B$ReqTrap,<PUBLIC,NEAR> 
cBegin				 
;	    CLI
	MOV	AL,[BX]
	TEST	AL,TRP_OS
	JZ	REQTPX		;TRAP NOT ON OR STOPPED
	OR	AL,TRP_RQ
	CMP	AL,[BX]
	JZ	REQTPX		;NO CHANGE
	MOV	[BX],AL 	;Remember Request
	TEST	AL,TRP_ST	;Stopped?
	JNZ	REQTPX		;Yes don't P-sem
cEnd	<nogen> 		; fall into B$SetChk

;***
;B$SetChk
;
;Purpose:
;
;
;Entry:
;
;
;Exit:
;
;
;Uses:
;
;
;Exceptions:
;
;****

cProc	B$SetChk,<PUBLIC,NEAR> 
cBegin				
;	    CLI
	MOV	AL,[BX] 	;Get Flags
SETCHK_AL:			;Entry point for B$ResetTrap
	AND	AL,TRP_MSK	;mask out context bit
	XOR	AL,TRP_ON+TRP_RQ ; If Trap On and Requested..
	JZ	SETTRP		; then check addr and Queue the Trap.
REQTPX: 			;Exit point for B$ReqTrap
;	    STI
cEnd				

;SET THE TRAP

cProc	SETTRP,<NEAR>
cBegin
	CMP	WORD PTR [BX+1],-1 
	JZ	settrp_exit	   ;can't ON xxx GOSUB 0
	PUSH	AX
	PUSH	SI
	MOV	SI,OFFSET DGROUP:b$TRAP_QUE 
	mov	al,bh
	CALL	B$PUTQ		;queue MSB of trap entry
	mov	al,bl
	CALL	B$PUTQ		;queue LSB of trap entry
	jz	qovflo		;don't record event if q overflow
	INC	[b$TRAP_SEM]	
	CALL	B$IEvSet	;notify interp of delayed activation
qovflo: POP	SI
	POP	AX
;	    STI

settrp_exit:			

cEnd

;***
;B$FreeTrap - FREE TRAP
;
;
;Purpose:
;
;
;Entry:
;
;
;Exit:
;
;
;Uses:
;
;
;Exceptions:
;
;
;****

cProc	B$FreeTrap,<PUBLIC,NEAR> 
cBegin				  
;	    CLI
	MOV	AL,[BX]
	AND	AL,TRP_OS+TRP_CN ;preserve ON,STOP,and CONTEXT
	CMP	AL,[BX] 	;was a trap requested?
	MOV	[BX],AL
	JZ	FRETPX
FRETP2:
	MOV	AL,[b$TRAP_SEM] ;V-sem if was active request
	SUB	AL,1
	JB	FRETPX
	MOV	[b$TRAP_SEM],AL 
FRETPX:
;	    STI
cEnd
				
;***
;B$SetContext - Set context bit in event flags entry
;
;Purpose:
;	Added as part of revision [3].
;	This routine is called when an ON <event> GOSUB is executed.
;	For the interpreter, the GOSUB routine may be in either
;	interpreted code, or compiled code.  A bit in the event flags
;	is used to determine the context of the handler.  When the bit
;	is set, the handler is an interpreter handler, otherwise, it
;	is a compiled code handler.
;Entry:
;	[BX] - points to event table entry.
;	b$cCSubs - 0 means interpreted code is executing
;Exit:
;	Flags byte in Event dispatch table is updated to reflect
;	handler context.
;Uses:
;	AL,CX
;Exceptions:
;	None.
;****
cProc	B$SetContext,<PUBLIC,NEAR> 
cBegin
	OR	BYTE PTR[BX],TRP_CN ;default to interp handler
	MOV	CX,b$cCSubs	;get current execution context
	JCXZ	InterpActive	;brif interp active
	AND	BYTE PTR[BX],TRP_MSK ;reset interp handler bit
InterpActive:
cEnd

;*** 
;B$TestTrap -- check if trapping on for a given trap #
;
;Purpose:
;
;Entry:
;	AL = Trap number
;Exit:
;	BX = pointer to trap table entry for this trap
;	NZ if Trapping ON or STOPPed for a trap in AL
;Uses:
;	AX
;Preserves:
;	CX,DX
;Exceptions:
;	None
;
;******************************************************************************
cProc	B$TestTrap,<PUBLIC,NEAR>	
cBegin					
	CALL	B$TrapAddr		; BX = *trap table entry
	TEST	BYTE PTR [BX],TRP_OS	;Non-zero if Trapping ON.
cEnd					

;*** 
;B$TrapAddr -- get trap table entry for a trap #
;
;Purpose:
;
;Entry:
;	AL = Trap number
;Exit:
;	BX = pointer to trap table entry for this trap
;Uses:
;	AX
;Preserves:
;	CX,DX
;Exceptions:
;	None
;
;******************************************************************************
cProc	B$TrapAddr,<PUBLIC,NEAR> 	
cBegin					
	MOV	BX,OFFSET DGROUP:b$TRPTBL 
	CBW
	ADD	BX,AX			; [BX] = [BX]+AL
	SAL	AX,1
	SAL	AX,1			; [AX] = [AL]*4
	ADD	BX,AX			; [BX] = [BX]+[AL]*5
cEnd					


sEnd	EV_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwio.asm ===
TITLE	GWIO - Basic I/O and initialization
	PAGE	56,132
;***
; GWIO - Basic I/O and initialization
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; This module contains code for doing initialization and termination
; and code for calling the lowest level OEM dependent screen I/O routines.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	_DATA		
	USESEG	_BSS		

	USESEG	DV_TEXT 	
	useSeg	RT_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE baslibma.inc
	INCLUDE files.inc
	INCLUDE intmac.inc
	INCLUDE devdef.inc
	INCLUDE addr.inc
	INCLUDE event.inc	; functions for $RDevt routines
	INCLUDE dc.inc
	INCLUDE messages.inc	
	INCLUDE stack.inc	
	INCLUDE idmac.inc	

	.LIST

sBegin	_DATA			

globalW  b$pTEST_CLOSE,B$NearRet 

	externW	b$ERDEVP
	externB	__osmajor	

; initial indirect jumps for no /v, no /d

globalW b$IPOLKEY,B$NearRet

globalW b$fInt24Err,-1		;On entry, non-zero means IGNORE int24
				;on exit from int24, low 15 bits contain
				;INT 24 error code.
externB	fInt24Error		; flag to COW than an INT 24 occurred.

	globalB b$EventFlags,,1	


sEnd	_DATA			

sBegin	_BSS			

	externW	b$SOFT_KEYS	;defined in GWDATA.ASM
	externW	B$SOFT_KEY_LEN	;defined in GWDATA.ASM
	externW	B$SOFT_KEY_INDEX	;defined in GWDATA.ASM

	externW	b$ERDEV	;defined in GWDATA.ASM

	staticW	DIV0_SAVE,,2
	staticW	OVRF_SAVE,,2
	staticW	DEVR_SAVE,,2	;Disk error interrupt save

	staticW	DERRCD,,1	; Disk error error code save area
	staticW	CHAR_SAVE,,1
	staticW	DCHAR_SAVE,,1

	staticB	DEVICE,,1
	staticB	WPRFLG,,1	;Write Protect Flag for INT 24 hndlr
	staticB	EXTFLG,,1	;set if sharing violation

sEnd	_BSS			


sBegin	RT_TEXT 		
	externNP B$GETDS 	
sEnd	RT_TEXT 		

sBegin	DV_TEXT 		
	assumes CS,DV_TEXT	

	externNP B$BREAK	
	externNP B$DIV0		
	externNP B$OVFR		
	externNP B$ERR_DME	
	externNP B$ERR_DNR	
	externNP B$ERR_FWP	
	externNP B$ERR_IOE	
	externNP B$ERR_DVF	
	externNP B$ERR_OTP	
	externNP B$ERR_DNA	
	externNP B$ERR_DTO	

	externNP B$KEYINP	; oem routine


;B$NearRet -- near return
;Called by something that thinks there is event trapping when there isn't any

labelNP	<PUBLIC,B$NearRet>	
	RET			;near RETURN

	SUBTTL	B$IOINI - MS-DOS special I/O initialization

;***
; B$IOINI - Run-time initialization
;
;Purpose: To install handlers for Divide by zero, Oveflow and I/O interrupts.
;
;Entry:
;	None
;Exit:
;	None
;Modifies:
;	Per Convention
;Exceptions:
;	None
;****

cProc	B$IOINI,<PUBLIC,NEAR>	
cBegin				


	PUSHF			;save interrupt status
	XOR	AX,AX		;Clear segment
	PUSH	DS		;Save DS
	PUSH	ES		; new savint trashes [es]
	CLI			; Turn off interrupts
	SAVINT	DGROUP:DIV0_SAVE,0
	SAVINT	DGROUP:OVRF_SAVE,4*4
	SAVINT	DGROUP:DEVR_SAVE,36D*4
	POP	ES
	MOV	AX,CS
	MOV	DS,AX		; All interrupt vectors point to code segment
ASSUME	DS:NOTHING
	SETVEC	0,B$DIV0	; Divide by zero
	SETVEC	4,B$OVFR	; Overflow
	SETVEC	24h,DEVR_INT	; Fatal Error Abort Address
	POP	DS		;Restore DS
ASSUME	DS:DGROUP
	POPF			;restore interrupts

cEnd				; End of B$IOINI

	PAGE
	SUBTTL	DOSIO utility subroutines

;B$KYBINI puts the keyboard device server in an initial state.
; It is called at initialization time and after CTL-C.
; On exit, all registers are preserved.


	PUBLIC	B$KYBINI
B$KYBINI:
	push	ax
	xor	ax,ax
	mov	[B$SOFT_KEY_LEN],ax ;soft key expansion terminated.
	mov	[char_save],ax
	mov	[dchar_save],ax
	inc	ax		; psw.z reset so keyinp wont wait
kywait: cCall	B$KEYINP 	; any chars present?
	jnz	kywait		; read them until none left
	pop	ax
	ret

;***
;B$BREAK_CHK - check for keyboard interrupts (CNTL-BREAK)
;OEM-callback routine
;
;Purpose:
;	This routine checks if the user has tried to interrupt
;	the program with a CNTL-C.  If this has occured, then
;	branch to the break handler, else return.
;	NOTE: A /D switch to the compiler is required for this
;	routine to have any effect.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per convention.
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	May not return.
;
;****************************************************************************

labelNP <PUBLIC,B$CHKKYB>	

cProc	B$BREAK_CHK,<PUBLIC,NEAR> 
cBegin				
	CALL	[B$IPOLKEY]
	TEST	b$EventFlags,CNTLC ; bit CNTLC = 0 if no ^Break
	JNZ	BREAK		; brif ^Break
cEnd				

BREAK:
	AND	b$EventFlags,NOT CNTLC ; Clear it to avoid recursion
				; (for COMM close if output still busy).
	JMP	B$BREAK		; print Break message and die..



;***
; B$TTYST - TTY status
;
; Inputs:
;	None.
; Function:
;	Check console for pending character.
; Outputs:
;	PSW.Z set if if no char waiting.
;	AL =  character
;	AH =  0 if single byte, NZ if double byte
;	char_save and dchar_save have the byte(s) receive by keyinp
; Registers:
;	Only AX and F affected.
;****

cProc	B$TTYST,<NEAR,PUBLIC>,<DX>	
cBegin				

	cmp	[B$SOFT_KEY_LEN],0 ; Processing soft key?
	jnz	tty_ret 	; If so, then have char...
	mov	ax,[char_save]	
	or	al,al		; Was the pending char already input ?
	jnz	tty_ret 	; Yes, note presence
	or	sp,sp		; Psw.z reset so keyinp wont wait
	cCall	B$KEYINP 	
	jz	tty_ret 	; No char available
	mov	[char_save],ax	; Save high byte(s)
	mov	[dchar_save],dx ; Save low bytes (if present)

tty_ret:

cEnd				

;	Added with revision [47]
;	OS/2 support totally rewritten with [49]
;
;***
;B$TTYGetChar - Wait for character from keyboard, using polling
;
;Purpose:
;	This routine will Poll the keyboard until a character is
;	ready. The character is returned as in B$TTYIN.  B$BREAK_CHK
;	can be called between the polls by setting DX non-zero.
;
;	If OM_DOS5, we can't poll waiting for a keystroke as it
;	hogs the CPU.  Giving up our time slice between polls does
;	not work as the forground process of the current screen
;	group has extra priority, so we frequently get the time slice
;	back before anyone else can run.
;
;	If we do not have a keyboard monitor installed, or we are not
;	suspose to do polling, then we go directly to B$TTYIN and ask
;	it to wait for a charcter.  This is safe, as no keyboard events
;	could happen without the keyboard monitor.
;
;	If we do have a keyboard monitor, then it will clear the sleep
;	semaphore whenever a keystroke is recognized.  Thus, we block
;	on the sleep semaphore and only check for events/keys when it
;	is clear.
;
;Entry:
;	DL = 0	: don't call B$BREAK_CHK between checks for a character
;	DL != 0 : call B$BREAK_CHK
;
;Exit:
;	[AL]	Has character if not Scan Code. Zero Flag not set.
;	[AH]	Has 128D, [AL] has Scan Code; or AX has Kanji char
;	[DX]	May have OEM's special code, AL=254d if so, exit with NZ,NC
;	Z flag set if Scan Code, C flag set if two byte code
;
;Uses:
;	AX,DX,Flags
;
;Exceptions:
;	None.
;****

cProc	B$TTYGetChar,<PUBLIC,NEAR>
cBegin
TryAgain:
	CALL	B$TTYST 	;Is a character available?
	JNZ	CharReady	;yes, get char and return (Use code in B$TTYIN)
	OR	DL,DL		;Should we call B$BREAK_CHK
	JZ	TryAgain	;no, just loop
	CALL	B$BREAK_CHK	;Check if ^BREAK has been hit
	JMP	SHORT TryAgain	;try to get the character again
cEnd	<nogen>


;***
; B$TTYIN - TTY input
;
; Inputs:
;	None.
; Function:
;	Get character from console keyboard
; Outputs:
;	[AL]	Has character if not Scan Code. Zero Flag not set.
;	[AH]	Has 128D, [AL] has Scan Code; or AX has Kanji char
;	[DX]	May have OEM's special code, AL=254d if so, exit with NZ,NC
;	Z flag set if Scan Code, C flag set if two byte code
;
; Registers:
;	Only AX and F affected.
;	DX affected too.
;
;Note:	this code assumes that the first byte of a
;	two byte code will be in the range [80h..0FFh].
;****

cProc	B$TTYIN,<NEAR,PUBLIC>	
cBegin				
	CALL	B$TTYST	; check for presence of char
	jz	ttwait		; none present so wait for one
CharReady:			; Common entry point: B$TTYIN/B$TTYGetChar
	cmp	[B$SOFT_KEY_LEN],0 ; processing soft key?
	jnz	skey_rd 	; if so, return its next char
	mov	ax,[char_save]	; fetch char read by B$TTYST
	mov	dx,[dchar_save]
	jmp	short ttyin2
				;Second Entry point for B$TTYGetChar
ttwait: xor	ax,ax		; tell keyinp to wait for char
	cCall	B$KEYINP 	
	jnc	ttyx		; PSW.C set if exactly 2 bytes

ttyin2: CMP	AH,LOW 128D	;start checking for function key
	JNE	TTYINX0 	;branch if not function key
	CMP	AL,LOW 32D	;[AL]=' ' for 1st function key
	JB	TTYINX
	CMP	AL,NUM_FKEYS+32D ;see if its a	function key
	JB	SKEY_SET	; go setup and return 1st char
TTYINX:
	CMP	AH,128D 	;Zero flag set if returning Scan Code..
TTYINX0:
	CMC			;Carry set if 2 byte.
ttyx:
	mov	[char_save],0	; char no longer waiting
cEnd				

	PAGE

;SKEY_SET -	Soft Key detected.  Store index into B$SOFT_KEYS
;		and return 1st char of Soft Key.  SKEY_RD will
;		return the rest...
;Entry:
;	[AX]	Has Scan Code.
;Exit:
;	[AL]	Has Soft Key char if assigned, else...
;	[AH]	Has Scan Code if not.

SKEY_SET:
	PUSH	SI
	PUSH	AX
	SUB	AL,32D		;make into index into soft key table
	MOV	SI,OFFSET DGROUP:B$SOFT_KEYS
	XOR	AH,AH
	SHL	AL,1		;Soft Key Table entry size is 4
	SHL	AL,1		;[AX] = Key no. * 4
	ADD	SI,AX		;Index into Soft Key Descriptor Table
	MOV	AX,[SI] 	;[AX] = Soft Key string Length
	MOV	B$SOFT_KEY_LEN,AX ;Store Length of Soft Key
	OR	AX,AX		;Null?
	POP	AX		;clean up stack
	JZ	SKEY_RET	;If null then return Scan Code
	MOV	SI,[SI+2]	;[SI] = Addr of Soft Key String
	MOV	B$SOFT_KEY_INDEX,SI ;Store index for SKEY_RD
	JMP	SHORT SKEY_RD_2 ; and return 1st character...

;SKEY_RD -	If Soft Key in Progress, return next character
;		from Soft Key String.

SKEY_RD:
	PUSH	SI
SKEY_RD_2:
	MOV	SI,[B$SOFT_KEY_INDEX]
	MOV	AL,[SI] 	;Get char from Soft Key string
	xor	ah,ah
	cmp	al,0feh 	; soft key assigned to chr$(254) ?
	jne	not_254 	; brif not
	mov	dx,0feh 	; else set [dx] to 00feh bcos $inkmap
				; assumes a three byte code if [al]=254
	mov	[dchar_save],dx ; store the same in [dchar_save] also
not_254:
	INC	[B$SOFT_KEY_INDEX]
	DEC	[B$SOFT_KEY_LEN]
SKEY_RET:
	POP	SI
	JMP	TTYINX

;***
;B$CNTRL - check for control characters during printing
;
;****

cProc	B$CNTRL,<NEAR,PUBLIC>	
cBegin				
	JMP	[B$IPOLKEY]	; wait on pause_key
cEnd	<nogen>			

	PAGE
;***
;B$DOS3CHECK - Check DOS version, return carry set if < DOS 3.00
;OEM-callback routine
;
;Purpose:
;	Common routine to check for DOS 3.  This check is made
;	several places in the runtime.	A near call and a relative
;	jump is smaller than a cmp imm,mem and relative jump.
;
;Entry:
;	__osmajor - byte containing DOS major version number - must be set.
;		     This is done before any OEM routines can be called.
;
;Exit:
;	PSW.C - Set if __osmajor < DOS 3.00
;	PSW.Z - Set if = DOS 3.00
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;*****************************************************************************
cProc	B$DOS3CHECK,<PUBLIC,NEAR> 
cBegin				
	CMP	__osmajor,3	; check for dos 3
cEnd				

	PAGE
	SUBTTL	DEVR_INT - fatal device error interrupt handler
;***
;DEVR_INT - fatal device error interrupt handler
;
;Purpose:
;
;Entry:
; [BP:SI] = points to the device header
; [AL]	  = has drive number if block device (a=0,b=1,...)
; [DI]	  = Error code as follows:
;		00 - Write Protected.
;		01 - Unknown Unit
;		02 - Not Ready
;		03 - Unknown command
;		04 - Data Error
;		05 - Bad Drive structure length
;		06 - Seek Error
;		07 - Unknown Media
;		08 - Sector not found
;		09 - Printer out of paper
;		10 - Write Fault (hard disks only)
;		11 - Read Fault
;		12 - Other error.
;
; Special handling must be done for "Disk Write Protect"  error  due  to  some
; MS-DOS booboo.   Control  must pass to the standard INT 24h handler in order
; to clean up some (state?)  variables.  But then BASIC cannot trap the error.
; The solution	is  to	modify BASIC's parent pointer to point to itself, then
; if a write protect error occurs, DEVR_INT can  abort	to  MS-DOS  which  will
; return via the parent pointer to BASIC's error handling routine DSKERC.
;
; Note: On entry DS, ES are not pointing to BASIC.
;
;Exit:
;
;Uses:
;
;Preserves: (optional)
; SS, SP, DS, ES, BX, CX, and DX must be preserved if an IRET is executed
;
;Exceptions:
;
;******************************************************************************
DbPub	DEVR_INT		
cProc	DEVR_INT,FAR		
cBegin				
	ASSUME	DS:NOTHING, ES:NOTHING, SS:NOTHING
	STI
	PUSH	DS
	PUSH	BX
	CALL	B$GETDS
	MOV	DS,BX
	ASSUME	DS:DGROUP
	MOV	fInt24Error,-1	; set flag for QB5/COW

	CMP	b$fInt24Err,0	;Should we IGNORE this error?
	JZ	TestWriteProtect ;brif not, test for a write protect sequence

	MOV	b$fInt24Err,DI ; save error in b$fInt24Err
	OR	b$fInt24Err,0FF00h; insure b$fInt24Err does not go to 0.
	JMP	SHORT IgnoreInt24 ;ignore this error

TestWriteProtect:		

	CMP	BYTE PTR [WPRFLG],0 ;Are we in a write protect INT 24 Seqenc
	JZ	DSKER1		;Brif not

IgnoreInt24:			
	XOR	AX,AX		;Tell DOS to ignore the error
	pop	bx
	pop	ds
	IRET			;Back to DOS - ignore dirty buffers

DSKER1: 			;Here if Write protect flag not set
	CLI			; Critical section below.  A second
				; interrupt would blow away the first one
	PUSH	BX		; save basic DGROUP
	MOV	BX,SP		; get psuedo frame pointer
	MOV	CX,[BX+24]	; [CX] = [BP] at INT 21H time (documented)
	POP	BX		; restore basic DGROUP
	mov	es,bx		; ES = DGROUP
	mov	ss,bx		; restore BASIC's stack 
	mov	sp,cx		; new stack pointer = previous BP

	; Stack now back to where it was just after the:
	;	PUSH	BP
	;	MOV	BP,SP
	; of the runtime entry point that caused the error.

	assume	ds:dgroup, es:dgroup, ss:dgroup
	STI			;Turn interrupts back on
	.erre	ID_SSEQDS	; assumes ss equals ds.
	push	cx		; save old BP for later

	mov	cx,di		;get device error into cl
	mov	DEVICE,AL	; device
	AND	AH,80H		;test for char dev or bad FAT
	JZ	CHRDEV		;not either, so not char dev
	PUSH	DS		
	MOV	DS,BP		; get device header segment
	TEST	BYTE PTR DS:[SI+4],80H ; test for character device
	POP	DS		
	JZ	CHRDEV		;jump if char dev, not block dev

	XOR	AH,AH		;clear flag for no char device
CHRDEV:
	mov	al,cl		;error code into al
	mov	DERRCD,AX	; Save error code and device type bit
	assume	es:nothing
	test	al,255		; Is this a write protect error?
	jnz	noprtct 	; Yes: return to MS-DOS with abort request
;	---------------------------	;Mark begining of Wr-Pro Sequence
	mov	byte ptr [wprflg],1 ;"Zibo" method of handling INT 24
	callos	REST		;from write protects.  Forces DOS
	mov	byte ptr [wprflg],0 ;to REALLY ignore error and discard
;	---------------------------	;pending dirty buffers.
noprtct:
	MOV	EXTFLG,0	;no violation yet
	CALL	B$GETEXTERR	; psw.c set if <dos 3
;	JB	NO_VIOLATION	;if DOS2, then branch
	JNZ	NO_VIOLATION	; ZF=1 if violation
	INC	EXTFLG		;set violation flag
NO_VIOLATION:
	callos	VERSN		;Do this for good luck. clears unstable dos
				;state

;Control is passed here after a hard disk error (INT 24H).
;	  Now we decide what the error is and JMP to its error handler.
; Entry DS, ES undefined

	mov	ax,DERRCD	; Restore error code
	MOV	BX,OFFSET DGROUP:b$ERDEVP ;[BX]= ptr to ERDEV$ sd
	TEST	AH,80H		;Character device ?
	jnz	devr_2		;Yes: go copy name
				;No: block oriented device (disk)
	mov	WORD PTR[BX],2	;device name length to 2
	MOV	BX,[BX+2]	;get ptr to erdev$ string
	mov	word ptr [BX],":A" ;damn hi/low
	mov	ch,DEVICE
	add	byte ptr [BX],ch ;set name
	jmp	short devr_3
devr_2:
	PUSH	DS		;save basic data segment
	MOV	DS,BP		;point to device header segment
	add	si,10		;get to character device name
	mov	cx,8
	mov	es:[BX],cx	;store name length
	mov	di,ES:[BX+2]	;target
	cld
	rep	movsb
	pop	ds		;get back ds
devr_3:
	POP	BP		; get frame at error time
	mov	b$ERDEV,ax	;save in error variable
	CALL	[b$pTEST_CLOSE] ; If closing, close it w/o error checks
	CMP	EXTFLG,0	;violation?
	JNZ	FWP		;if so, then PERMISSION DENIED
	cmp	al,0		;Write protected ?
	jz	dwp
	cmp	al,1		;Device available ?
	je	dna		; no
	cmp	al,9		;no paper ?
	je	nopaper
	cmp	al,10		;device fault ?
	je	dvf
	TEST	AH,80H		;Character device ?
	jnz	devr_4		; yes
	cmp	al,2		;disk not ready
	je	dnr
	cmp	al,7		;disk media error
	je	dme
	jmp	short ioe	;device i/o error
devr_4:
	cmp	al,2		;timeout ?
	je	dto
IOE:
	JMP	B$ERR_IOE	; device i/o error

cEnd	<nogen>			

;***
;B$GETEXTERR -- get extended error info.
;
;Purpose:
; Return extended error info, if available.
; Redone, edit [24]
;
;Entry:
; None
;
;Exit:
; CF (and NZ):	No extended info available (running under < DOS 3.x)
; NC:	[AX] = extended error code
;	ZF	if error was either sharing violation or locking violation
;	NZ	Some other error
;
;Uses:
; If C1: nothing, else only AX.
;
;Preserves: (optional)
; BX, CX, DX
;
;******************************************************************************
cProc	B$GETEXTERR,<NEAR,PUBLIC>,<BX,CX,DX,SI,DI,BP,DS,ES> ; extended
				; error call destroys all these
cBegin
	cCall	B$DOS3CHECK	;See if we're DOS 3 or not
	JC	GETEXTERR_90	;just exit if not
	XOR	BX,BX		;clear for call...
	MOV	AH,59H		;extended error code
	INT	21H		;do the call
	CMP	AX,20H		;test if sharing violation
	JE	GACERR_10	;if so, then return it
	CMP	AX,21H		;test if lock violation
GACERR_10:
	CLC			;C0 means okay
GETEXTERR_90:

cEnd


DTO:
	JMP	B$ERR_DTO	
DVF:
	JMP	B$ERR_DVF	
NOPAPER:
	JMP	B$ERR_OTP	
DNA:
	JMP	B$ERR_DNA	

DME:
	JMP	B$ERR_DME	; give disk media error

DWP:				;permission denied due to write protection
FWP:				;permission denied due to open violation
	JMP	B$ERR_FWP	; give permission denied error

DNR:
	JMP	B$ERR_DNR	; give disk not ready error

	PAGE

;***
; B$IOCLOS - Run-time initialization
;
;Purpose: To deinstall handlers for Divide by zero, Oveflow and I/O interrupts.
;
;Entry:
;	None
;Exit:
;	None
;Modifies:
;	Per convention
;Exceptions:
;	None
;
;****

cProc	B$IOCLOS,<PUBLIC,NEAR>	
cBegin				

ASSUME	ES:DGROUP		
ASSUME	DS:NOTHING

	XOR	AX,AX		;Clear segment
	PUSH	DS		;Save DS
	PUSH	DS		; Restore ES
	POP	ES
	MOV	DS,AX		;Set DS to 0:xxxx
	PUSHF			;Save interrupt status
	CLI			;Turn off interrupts
	RSTVEC	0,ES:DIV0_SAVE
	RSTVEC	4,ES:OVRF_SAVE
	RSTVEC	24h,ES:DEVR_SAVE
	POPF			;Restore interrupts
	POP	DS		;Restore DS

ASSUME	DS:DGROUP


cEnd				; End of B$IOCLOS

sEnd	DV_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwcom.asm ===
TITLE	GWCOM - OEM-indepedent Communications Routines

	PAGE	56,132

;***
; GWCOM.ASM - OEM-indepedent Communications Routines
;
;	Copyright <C> 1986 - 1988, Microsoft Corporation
;
; Purpose:
;	To provide the GW I/O dispatch routines for the serial
;	communications ports through calls to the OEM routines.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc	

	useSeg	_BSS		
	useSeg	_DATA		
	useSeg	CONST		
	useSeg	DV_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE baslibma.inc
	INCLUDE files.inc
	INCLUDE devdef.inc
	INCLUDE ascii.inc	;must follow devdef.inc
	INCLUDE addr.inc	;usercode header structure
	INCLUDE comdcb.inc	;DCB structure for comm device
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE idmac.inc	

;	The following macros generate the dispatch target labels used
;	by the the I/O system one-time initialization(I) and dispatch
;	dispatch table entry(D).

ComDspLabels	MACRO	Ctype
	Cindex	= 0		;;value to pass to item generation macro

	REPT	NUM_RS232	;;one item for each comm device defined
	Cindex	= Cindex + 1	;;update the counter
	ComItem	Ctype,%Cindex	;;define item with type (I,C,D) and counter
	ENDM

	ENDM	;;ComDspLabels

ComItem	MACRO	Ctype,Cindex
	PUBLIC	B$&Ctype&_COM&Cindex ;;define PUBLIC (e.g., PUBLIC B$I_COM2)
B$&Ctype&_COM&Cindex:		 ;;define label (e.g., B$I_COM2:)
	ENDM	;;ComItem

sBegin	CONST			

CMERRT	DW	OFFSET B$ERR_IOE ;Other IO Error
	DW	OFFSET B$ERR_CBO ;buffer overflow error
	DW	OFFSET B$ERR_IOE ;parity error
	DW	OFFSET B$ERR_DTO ;device timeout
	DW	OFFSET B$ERR_DTO ;device timeout
	DW	OFFSET B$ERR_DTO ;device timeout

sEnd	CONST			

sBegin	_BSS			

	externB	B$CM1DCB		; defined in GWDATA.ASM
	externB	b$FILMOD	; defined in GWINI.ASM
	externB	b$PATHNAM	; defined in GWINI.ASM
	externW b$ComPort	;LLPARAM - save area for COMx I/O ports
	externB b$COM_DCB	;DCB for COM1 device

externD b$RECPTR		; pointer to random record
externW b$cbComBuffer		;combuffer size specified on QB command line
	staticW COMSAV,,2	;save area for b$ComPort across SHELL
	globalB b$COFlag,0,1	; Flag to indicate COM OPEN in progress

sEnd	_BSS			


sBegin	DV_TEXT 		
assumes CS,DV_TEXT		

	externNP B$FHHighAlloc
	externNP B$FHHighDealloc



;   Device Independent Interface

DSPMAC	MACRO	func
	DW	COM_&func	;;Define Dispatch Table for Specific Device
	ENDM

;	Communications Dispatch Table - must not be at offset 0.

ComDspLabels	D		;define dispatch table labels

	DSPNAM			;define dispatch table

	SUBTTL	Communications Generalized I/O Routines

	externNP B$DEVOPN
	externNP B$LHDALC_CPCT	
	externNP B$INICOM	
	externNP B$RECCOM	
	externNP B$SNDCOM	
	externNP B$STACOM	
	externNP B$TRMCOM	
	externNP B$BREAK_CHK
	externNP B$ERR_BFN	;Error routines - Bad File Name
	externNP B$ERR_DNA	;device unavailable error
	externNP B$ERR_FAO	;   File Already Open
	externNP B$ERR_CBO	;   Com Buffer Overflow
	externNP B$ERR_DTO	;   Device Time Out
	externNP B$ERR_IOE	;   Device Input Output Error
	externNP B$ERR_FC	;   Bad Function Call
	externNP B$ERR_OM_FH	; out of memory error

;	$I_COMx - called during BASIC initialization

;	Entry - DI = -2*device id

ComDspLabels	I		;define initialization labels

	PUSH	AX		;save registers...
	PUSH	DI
	CALL	GetComDCB	;DI points to device control block
	MOV	[DI].CD_CMWID,0FFH ;initial width is infinite
	MOV	[DI].CD_CMPOS,0	;initial position is zero
	MOV	[DI].CD_CMFDB,0 ;mark this device as available for open
	POP	DI		;restore registers...
	POP	AX
	RET			;return to caller

;***
; COM_OPEN - open an asynchronous communications device
;
; Entry:
;	AL = device id (negative number from DN_COM1 to DN_COMn)
;	BX = file number (0..n)
;	CX = random record size if [b$FILMOD] = random
;		 (if [CX] = 0, use default record size)
;	DI = device offset (2=COMD, 4=SCRN, etc.)
;	b$FILMOD = file mode
;		MD_SQI = 1 - sequential input
;		MD_SQO = 2 - sequential output
;		MD_RND = 4 - random
;		MD_APP = 8 - append
;	b$PATHNAM = null-terminated com options string (including "COMn:")
; Exit:
;	SI = pointer to FDB allocated
;*****************************************************************************


; Syntax:	OPEN "COMn:[SPEED][,[PARITY][,[DATA][,[STOP][,nonpos]]]]"

; Positional parameters:
;
;	SPEED	baud rate in bits per second
;	PARITY  N(none), E(even), O(odd), M(mark), S(space)
;	DATA    5, 6, 7, or 8 bits per character
;	STOP	1, 1.5, or 2 stop bits
;		Default for slower than 110 baud and 6, 7, or 8 data bits is 2.
;		Default for slower than 110 baud 5 data bits is 1.5.
;		Default for 110 baud or faster is 1.
;
; Nonpositional parameters:
;
;	RS	Suppress RTS (Request To Send).
;	OP[n]	Open timeout in milliseconds.
;	CS[n]   Clear-to-send (CTS) timeout in milliseconds.
;	DS[n]   Data-set-ready (DSR) timeout in milliseconds.
;	CD[n]	Carrier-detect (CD) timeout in milliseconds.
;	RB[n]	Size of receive buffer in bytes.
;	TB[n]	Size of transmit buffer in bytes.
;	LF	Transmit a line-feed following a carriage-return.
;	ASC	Open COM file in ASCII mode  | none => open in
;	BIN	Open COM file in binary mode | IBM mode

DbPub	<COM_OPEN>		
COM_OPEN:
	MOV	AH,BL		;[AH]=file number
	PUSH	AX		;save file number, device id
	PUSH	CX		;save variable record len (if random)
	CALL	GetComDCB	;AX = 0, 1, ... for COM1, COM2, ...
				;DI points to Device Control Block
	CMP	[DI].CD_CMFDB,0 ;see if device is opened to another file
	JE	NERFNO		;No ERror, File Not Open
	JMP	B$ERR_FAO	;File Already Opened
NERFNO:
	MOV	[DI].CD_DEVID,AL ;set unit field of Device Control Block

	MOV	SI,OFFSET DGROUP:b$PATHNAM+5 ; point to options
	CALL	ParseOpt	;parse options (fill in DCB fields)

	CALL	B$ComAlloc	;[2]allocate the comm buffer and fill in DCB

	MOV	[DI].CD_CMPOS,0 ;reset column to 0
	MOV	BX,DI		;BX points to DCB
DbAssertRelB	<[b$COFlag]>,E,0,DV_TEXT,<b$COFlag non-zero in COM_OPEN> ;
	INC	[b$COFlag]	; non-zero indicates COM OPEN in progress
	CALL	B$INICOM 	;call machine dependent OPEN routine
				;destroys FLAGS, AX..DX
DbAssertRelB	<[b$COFlag]>,B,2,DV_TEXT,<bad b$COFlag value in COM_OPEN> ;
	MOV	[b$COFlag],0	; be sure this is CLEARed on exit
	OR	AH,AH		;check for error during OPEN
	JZ	COMOPEN_NOERR	;if no error, then jump

	CALL	B$ComDealloc	;[2]deallocate the comm buffers

	INC	AH		;see if B$INICOM didn't like options
	JZ	ERCIFN		;bad file name error if illegal mode
	INC	AH		;test if device unavailable
	JZ	ERCDNA		;if so, then process error
	SUB	AH,2		;get back error code other than -1 or -2
	CALL	CKCMER		;check for device error code (will not return)

COMOPEN_NOERR:			
	POP	CX		;[CX]=record length
	CMP	b$FILMOD,MD_RND ; random open?
	JNE	NOTRND		; brif not
	INC	CX		; LEN parameter specified?
	LOOP	OPENIT		; brif so -- use that value for length
	MOV	CX,REC_LENGTH	; use default record length
	SKIP	2		; JMP OPENIT
NOTRND:				
	XOR	CX,CX		; don't need any buffer space for seq files
OPENIT:				
	POP	AX		; [AL]=device id, AH = file number
	MOV	DL,[DI].CD_CMWID ; [DL]=width from Device Control Block
	MOV	BL,AH
	XOR	BH,BH		; [BX]=file number
	MOV	AH,MD_RNDCH+MD_RND+MD_APP+MD_SQO+MD_SQI ; allow all file
				; modes except BINARY
	CALL	B$DEVOPN 	;Initialize FDB, SI has addr of FDB
	JCXZ	NO_BUFFER	; brif no buffer allocated
	MOV	[SI].FD_VRECL,CX ; save buffer size in FDB
NO_BUFFER:			
	OR	[SI].FD_FLAGS,FL_NEOF ;not at eof
	MOV	[DI].CD_CMFDB,SI ;save FDB pointer in DCB
	MOV	[DI].CD_CMEVT,0 ;init event signal counter
	TEST	[DI].CD_CMFLG,CF_CMBIN
	JZ	CMOPNX		;branch if user wants ASCII mode
	OR	[SI].FD_FLAGS,FL_BIN ; indicate BINARY mode
CMOPNX:
	RET

ERCIFN:
	JMP	B$ERR_BFN	;Bad File Name
ERCDNA:
	JMP	B$ERR_DNA	;device unavailable

;***
; ParseOpt - parse communications option string
;
; Purpose:
;	[Rewritten as part of revision 6].
;	To parse the communication option string and set the
;	appropriate values in the device control block (DCB) for
;	the specified device.
; Inputs:
;	SI = pointer to start of option string.
;	DI = pointer to device control block (DCB).
; Outputs:
;	None.
; Modifies:
;	AX, BX, CX, DX.
; Exceptions:
;	B$ERR_BFN - bad file name error if option string syntax error.
;******************************************************************************

ParseOpt:

;	Parse the first field as a numeric field for the baud rate.

	MOV	[DI].CD_BAUDR,300 ;set the default baud rate
	CALL	GetOptVal	;get the numeric value in DX
	JC	ParseBaudDone	;if null field, then use default
	MOV	[DI].CD_BAUDR,DX ;set the baud rate to the value read
ParseBaudDone:

;	Parse the second field as one letter for the parity type.
;	None(N)=0, Odd(O)=1, Even(E)=2, Mark(M)=3, and Space(S)=4.

	MOV	[DI].CD_PARIT,2	;set the default parity as even
	CALL	GetOptChar	;read the next character in AL
	JC	ParseParDone	;if null field, then use default

	MOV	CX,5		;five parity type to test
	XOR	BX,BX		;initialize the table index
ParseParLoop:
	CMP	AL,CS:ParityTable[BX] ;test field against parity types
	JE	ParseParFound	;if found, then jump to set it
	INC	BX		;increment index to next table entry
	LOOP	ParseParLoop	;loop until last type is tested
ParseError:
	JMP	B$ERR_BFN	;jump to report error in option string

ParityTable	DB	"NOEMS"	;available parity types in order

ParseParFound:
	MOV	[DI].CD_PARIT,BL ;put index as the parity type

	CALL	GetOptChar	;read next character looking for terminator
	JNC	ParseError	;if not terminator, then error
ParseParDone:

;	Parse the third field as a numeric value for the data
;	length (valid range is 5 to 8).

	MOV	[DI].CD_BYTSZ,7 ;default data length is 7 bits
	CALL	GetOptVal	;get the numeric value in DX
	JC	ParseSizeDone	;if null, then jump to use default

	CMP	DX,5		;test lower bound of legal range
	JB	ParseError	;if less, then error
	CMP	DX,8		;test upper bound of legal range
	JA	ParseError	;if more, then error
	MOV	[DI].CD_BYTSZ,DL ;set the size field with the value read
ParseSizeDone:

;	Parse the fourth field as the number of stop bits.  Legal
;	values are 1, 1.5, and 2.  Values are read as characters,
;	not as a numeric value (no leading zeroes).  If no value
;	is given, the default value is:
;		1 stop bit    - 0 - if over 110 baud
;		1.5 stop bits - 1 - if 110 or less baud and 5 bit data length
;		2 stop bits   - 2 - if 110 or less baud and 6-8 bit data length

	XOR	DX,DX		;assume 1 stop bit
	CMP	[DI].CD_BAUDR,110 ;test computed baud rate
	JA	ParseStopDef	;if over 110 baud, jump to set default
	INC	DX		;now assume 1.5 stop bits
	CMP	[DI].CD_BYTSZ,5	;test if 5 bit data length
	JE	ParseStopDef	;if 5 bit data, set default to 1.5 stop bits
	INC	DX		;6-8 bit data, set default to 2 stop bits
ParseStopDef:

	CALL	GetOptChar	;get the first character in field
	JC	ParseStopSet	;if null, jump to use default value in DL
	MOV	DL,AL		;move the character read
	SUB	DL,"1"		;map "1" to 0 and "2" to 1
	CMP	DL,1		;test for valid range (0 to 1)
	JA	ParseError	;if not in range, then error
	SHL	DL,1		;shift so values are 0(1 bit) and 2(2 bits)
	JNZ	ParseStopTerm	;if 2 bits, then jump to test for termination
	CALL	GetOptChar	;get the next char - either "." or terminator
	JC	ParseStopSet	;if terminator, then done - jump
	MOV	AH,AL		;move character for double test
	CALL	GetOptChar	;get next character - should be "5"

	CMP	AX,"5." 	;*WRONG* test if last two characters of "1.5"
	JNE	ParseError	;if not, then syntax error
	INC	DL		;make value 1 for 1.5 stop bits
ParseStopTerm:
	CALL	GetOptChar	;get the terminator character
	JNC	ParseError	;if not, then syntax error
ParseStopSet:
	MOV	[DI].CD_STOPB,DL ;set the stop bit value

;	The fifth and successive fields contain the order-independent
;	parameters, which are identified by their leading characters.
;	These parameters are:
;		RS  - turn off request-to-send
;		OPn - set open timeout to n milliseconds
;		DSn - set data-set-ready timeout to n milliseconds
;		CSn - set clear-to-send timeout to n milliseconds
;		CDn - set carrier-detect timeout to n milliseconds
;		RBn - set size of receive buffer in bytes
;		TBn - set size of transmit buffer in bytes
;		LF  - send line-feed after carriage-return at line end
;		BIN - send data without conversion
;		ASC - send data with conversion
;		PE  - enable reporting of parity errors on received data

	XOR	AX,AX		;clear register for setting values
	MOV	[DI].CD_CMFLG,CF_CMBIN ;clear all flags except for BIN
	MOV	[DI].CD_RLSTO,AX ;set carrier-detect timeout to zero
	MOV	[DI].CD_CTSTO,1000 ;set clear-to-send timeout to 1 second
	MOV	[DI].CD_DSRTO,1000 ;set data-set-ready timeout to 1 second
	MOV	[DI].CD_RXSIZ,AX ;clear receive buffer size for default
	MOV	[DI].CD_TXSIZ,AX ;clear transmit buffer size for default

;	The first character of each parameter is read.  If a null field,
;	it is ignored.  If at the option string end, then return.

ParseLoop:
	CALL	GetOptChar	;read the first character in AL
	JNC	ParseNext	;if not a separator, then start processing
	JNZ	ParseLoop	;if comma, then just ignore it
	JMP	ParseEnd	;else process end of statement

;	Test for valid prefix on parameter.  To reduce code size, read the
;	second character and use both for testing.

ParseNext:
	MOV	AH,AL		;move first character
	CALL	GetOptChar	;first character in AH, second in AL

;	First, test for "RS".  If so, then set RS flag and set default
;	CSn value to zero.

	CMP	AX,"RS"		;test if RS
	JNE	ParseOP		;if not, try OP next
	OR	[DI].CD_CMFLG,CF_CMRTS ;set the RS flag in the DCB
	TEST	[DI].CD_CMFLG,CF_CMCTS ;test if CS value is still default
	JNZ	ParseTerm	;test for termination after parameter
	MOV	[DI].CD_CTSTO,0	;set the CS timeout value to 0 (disable)

;	For parameters that do not have a numeric argument that is
;	processed with GetOptVal, the character after the parameter
;	must be a terminator (comma or end-of-string).

ParseTerm:
	CALL	GetOptChar	;get what should be terminator
	JC	ParseLoop	;if so, then loop for the next parameter
ParseTermErr:
	JMP	B$ERR_BFN	;jump to report error in option string

;	Second, test for "OP".  If so, then read the following numeric
;	value and put it in the DCB and set the flag.

ParseOP:
	CMP	AX,"OP"		;test for OP
	JNE	ParseDS		;if not, then test for DS
	CALL	GetOptVal	;get numeric value in DX
	JNC	ParseOPNoDef	;if numeric value specified, then jump
	MOV	DX,10000D	;otherwise set to 10 seconds
ParseOPNoDef:
	MOV	[DI].CD_OPNTO,DX ;put value in DCB
	OR	[DI].CD_CMFLG,CF_CMOPN ;set flag for OP parameter given
	JMP	SHORT ParseLoop	;jump to process next parameter

;	Third, test for "DS".  If so, then read the following numeric
;	value and put it in the DCB.

ParseDS:
	CMP	AX,"DS"		;test for DS
	JNE	ParseCD		;if not, then test for CD
	CALL	GetOptVal	;get numeric value in DX
	MOV	[DI].CD_DSRTO,DX ;put value in DCB
	JMP	SHORT ParseLoop	;jump to process next parameter

;	Fourth, test for "CD".  If so, then read the following numeric
;	value and put it in the DCB.

ParseCD:
	CMP	AX,"CD"		;test for CD
	JNE	ParseCS		;if not, then test for CS
	CALL	GetOptVal	;get numeric value in DX
	MOV	[DI].CD_RLSTO,DX ;put value in DCB
	JMP	SHORT ParseLoop	;jump to process next parameter

;	Fifth, test for "CS".  If so, then read the following numeric
;	value and put it in the DCB.
	
ParseCS:
	CMP	AX,"CS"		;test for CS
	JNE	ParseRB		;if not, then test for RB
	CALL	GetOptVal	;get numeric value in DX
	MOV	[DI].CD_CTSTO,DX ;put value in DCB
	OR	[DI].CD_CMFLG,CF_CMCTS ;set flag for nondefault CS timeout
	JMP	SHORT ParseLoop	;jump to process next parameter

;	Sixth, test for "RB".  If so, then read the following numeric
;	value and put it in the DCB.

ParseRB:
	CMP	AX,"RB"		;test for RB
	JNE	ParseTB		;if not, then test for TB
	CALL	GetOptVal	;get numeric value in DX
	MOV	[DI].CD_RXSIZ,DX ;put value in DCB
	JMP	SHORT ParseLoop	;jump to process next parameter

;	Seventh, test for "TB".  If so, then read the following numeric
;	value and put it in the DCB.

ParseTB:
	CMP	AX,"TB"		;test for TB
	JNE	ParseLF		;if not, then test for LF
	CALL	GetOptVal	;get numeric value in DX
	MOV	[DI].CD_TXSIZ,DX ;put value in DCB
	JMP	ParseLoop	;jump to process next parameter

;	Eighth, test for "LF".  If so, then set the flag in the DCB.

ParseLF:
	CMP	AX,"LF"		;test for LF
	JNE	ParseBIN	;if not, then test for BIN
	OR	[DI].CD_CMFLG,CF_CMCLF ;set the LF flag
	JMP	SHORT ParseTerm	;jump to check for terminator

;	Ninth, test for "BIN".  If so, then set the flag in the DCB.

ParseBIN:
	CMP	AX,"BI"		;test for BI
	JNE	ParseASC	;if not, then test for ASC
	CALL	GetOptChar	;get the third character
	CMP	AL,"N"		;test if parameter was BIN
	JNE	ParseTermErr	;if not, then error
ParseCOD:
	TEST	[DI].CD_CMFLG,CF_CMCOD ;test if ASC or BIN specified before
	JNZ	ParseTermErr	;if so, then error
	OR	[DI].CD_CMFLG,CF_CMCOD ;set the flag for ASC or BIN specified
	JMP	ParseTerm	;jump to test for terminator

;	Tenth, test for "ASC".  If so, then clear the flag in the DCB.

ParseASC:
	CMP	AX,"AS"		;test for AS
	JNE	ParsePE		;if not, then test for PE
	CALL	GetOptChar	;get the third character
	CMP	AL,"C"		;test if parameter was ASC
	JNE	ParseTermErrJmp	;if not, then error
	AND	[DI].CD_CMFLG,NOT CF_CMBIN ;clear the binary mode flag
	JMP	SHORT ParseCOD	;jump to check CF_CMCOD in DCB

ParseTermErrJmp:
	JMP	ParseTermErr	;short jump to process error

;	Finally, test for "PE".  If so, then set the flag in the DCB.

ParsePE:
	CMP	AX,"PE"		;test for PE
	JNE	ParseTermErrJmp	;if not, then unknown parameter - error
	OR	[DI].CD_CMFLG,CF_CMPEN ;set the flag PE specified
	JMP	ParseTerm	;jump to test for terminator

;	The end of the statement has been reached.  If not specified,
;	compute the open timeout value to be ten times the maximum of the
;	other timeouts, with a maximum value of 64K-1 milliseconds.

ParseEnd:			
	TEST	[DI].CD_CMFLG,CF_CMOPN ;test if nondefault OP timeout
	JNZ	ParseRet	;if so, then use the one specified
	MOV	AX,[DI].CD_RLSTO ;get the CD timeout value
	CMP	AX,[DI].CD_DSRTO ;test against the DS timeout value
	JA	ParseKeep1	;jump to keep greater value in AX
	MOV	AX,[DI].CD_DSRTO ;else update the maximum value
ParseKeep1:			
	MOV	CX,0FFFFH	;assume maximum value
	MOV	DX,10		;factor to multiply maximum time
	MUL	DX		;compute OP timeout in DX:AX
	JC	ParseSetOP	;if over 64K-1, then jump to set max
	MOV	CX,AX		;set the product
ParseSetOP:			
	MOV	[DI].CD_OPNTO,CX ;set the OP timeout value
ParseRet:			
	RET			;if statement end, then finished, so return


;***
; GetOptChar - get a character in the option string
;
; Purpose:
;	[Rewritten as part of revision 6].
;	The next character in the option string is read into AL.
;	If lower case, it is mapped to upper case and the carry and
;	zero flags are set accordingly.  Blank and tab characters
;	are ignored.
; Input:
;	SI = pointer to next character in the option string.
; Outputs:
;	SI = pointer to the following character (except for string end).
;	AL = character (mapped if lower case).
;	CF set and ZF set = end of string
;	CF set and ZF clear = comma character
;	CF clear and ZF clear = not comma or end of string
; Modifies:
;	None.
; Exceptions:
;	None.
;*****************************************************************************

GetOptChar:
	LODSB			;get the next character from the string
	CMP	AL," "		;test if blank character
	JE	GetOptChar	;if so, then ignore it
	CMP	AL,ASCHT	;test if tab character
	JE	GetOptChar	;if so, then also ignore it
	CMP	AL,","		;test if comma
	JE	GetOptStc	;if so, then return with CF set and ZF clear
	CMP	AL,"a"		;test if character is lower case
	JB	GetOptNoMap	;if not, then skip the mapping
	ADD	AL,"A"-"a"	;map lower case letter to upper
GetOptNoMap:
	OR	AL,AL		;test if at the end of the string
	JNZ	GetOptRet	;if not end, then return with CF and ZF clear
	DEC	SI		;backup pointer to the statement end
	OR	AL,AL		;clear ZF again for exit condition
GetOptStc:
	STC			;set carry for end-of-statement or comma
GetOptRet:
	RET			;near return to caller

;***
; GetOptVal - get value from option string
;
; Purpose:
;	[Rewritten as part of revision 6].
;	To read the option string for characters to be interpreted
;	as decimal digits.  A value from these digits is computed
;	and returned.  This routine then checks for a proper terminating
;	character (either a comma or end-of-string) after the value.
;	If no terminator, then an error is reported.
; Inputs:
;	SI = pointer to option string at value.
; Outputs:
;	SI = pointer to option string after the terminator.
;	DX = computed value.
;	CY set = null value (first character terminator).
;	   clear = nonnull value.
; Modifies:
;	AX.
; Exceptions:
;	B$ERR_BFN - bad file name if improper terminator.
;*****************************************************************************

GetOptVal:
	PUSH	BX		;save register
	XOR	DX,DX		;initialize result
	CALL	GetOptChar	;get the first character of the value
	JC	GetOptValRet	;return with CY set for null value
	DEC	SI		;back up over first character read
GetOptValLoop:
	CALL	GetOptChar	;get option string character in AL
	CMC			;complement so CY clear for terminator
	JNC	GetOptValRet	;return with CY clear for nonull value
	SUB	AL,"0"		;subtract bias for decimal digit
	CMP	AL,9		;test if digit or not
	JA	GetOptValErr	;if not digit or terminator, then error
	CBW			;zero AH for word value
	SHL	DX,1		;present result * 2
	JC	GetOptValErr	;jump if overflow error
	MOV	BX,DX		;save result * 2
	SHL	DX,1		;present result * 4
	JC	GetOptValErr	;jump if overflow error
	SHL	DX,1		;present result * 8
	JC	GetOptValErr	;jump if overflow error
	ADD	DX,BX		;present result * 10
	JC	GetOptValErr	;jump if overflow error
	ADD	DX,AX		;add in new digit - new value
	JNC	GetOptValLoop	;if no overflow, then loop for next
GetOptValErr:
	JMP	B$ERR_BFN	;if error, then bad file name
GetOptValRet:
	POP	BX		;restore register
	RET			;near return to caller

;
;Written as part of revision [6]
;
;***
;B$ComAlloc - Allocate memory for a communications device
;
;Purpose:
;	From high memory, allocate two blocks for use as communications
;	queues, one for the receive queue and the other for the transmit
;	queue.	The size of the two queues is passed into this procedure
;	as an arguement.
;
;	If the size specified for the receive queue is 0, then the size
;	given on the command line with the /C:xxx option is used.  If this
;	value is -1 (not specified), then the queue will be cbComBuf bytes
;	long.  If the size specified for the transmit queue is 0, then
;	it will be cbComBuf bytes long.
;
;	On exit, the DCB of the communications device that was passed
;	in as a parameter will have the segment which contains the
;	receive queue and the transmit queue.  The queues will be the
;	first (and only) things in the segments.  The fields of the
;	DCB are defined in comdcb.inc.
;
;	For OS/2, this routine will also allocate a 2K-byte block for the
;	stack of the thread.
;
;Entry:
;	DI = communications device control block (DCB)
;	[DI].CD_RXSIZ = size of the receive queue in bytes
;	[DI].CD_TXSIZ = size of the transmit queue in bytes
;
;Exit:
;	[DI].CD_RXSEG = segment of memory allocated for the receive queue
;	[DI].CD_TXSEG = segment of memory allocated for the transmit queue
;	[DI].CD_SPSIZ = size of the thread stack in bytes (2048+slop)
;	[DI].CD_SPSEG = segment of memory allocated for the thread stack
;
;Uses:
;	Per convention.
;
;Exceptions:
;	B$ERR_DNA - device not available if /C:0 for compatibility
;		     This error will be given if the option's value is
;		     needed or not.
;	B$ERR_OM  - out of memory if allocation failed for any reason.
;****************************************************************************

	PUBLIC	B$ComAlloc	

B$ComAlloc PROC NEAR		

;	Get the C parameter value for comm buffer size.

	MOV	AX,b$cbComBuffer ;get /C:nnnn value saved from command line

;	If buffer size is zero, then error.

	OR	AX,AX		;test if zero buffer size
	JZ	ComAllocDNAErr	;if so, then give "device not available" error

;	Compute the size of the receive queue.  If [DI].CD_RXSIZ is
;	nonzero, use the size specified in the RB[n] parameter.

	MOV	DX,[DI].CD_RXSIZ ;get the receive buffer size
	OR	DX,DX		;test if specified
	JNZ	ComAllocRB	;if so, then use it

;	Use size in AX from command line, except for -1 where the
;	default is cbComBuf bytes.

	MOV	DX,cbComBuf	;default size for receive buffer
	CMP	AX,-1		;test if -1 for default
	JE	ComAllocRBSet	;if default, use cbComBuf bytes
	MOV	DX,AX		;move size from command line for use
ComAllocRBSet:
	MOV	[DI].CD_RXSIZ,DX ;set the block size

;	Allocate the receive queue and set buffer segment in DCB.

ComAllocRB:
	MOV	AX,DX		;move the size into AX
	XOR	DX,DX		;size in bytes now in DX:AX
	CALL	B$FHHighAlloc	;allocate the comm buffer with segment in CX
	JCXZ	ComAllocOMErrR	;out of memory if couldn't allocate buffer
	MOV	[DI].CD_RXSEG,CX ;[8]set the DCB segment

;	Compute the size of the transmit queue.  If [DI].CD_TXSIZ is
;	nonzero, use the size specified in the TB[n] parameter.

	MOV	AX,[DI].CD_TXSIZ ;get the transmit buffer size
	OR	AX,AX		;test if specified
	JNZ	ComAllocTB	;if so, then use it

;	If not specified, use the size of cbComBuf bytes.

	MOV	AX,cbComBuf	 ;default size for transmit buffer
	MOV	[DI].CD_TXSIZ,AX ;set the default size of the buffer

;	Allocate the transmit queue and set buffer segment in DCB.

ComAllocTB:
	XOR	DX,DX		;size in bytes now in DX:AX
	CALL	B$FHHighAlloc	;allocate the comm buffer with segment in CX
	JCXZ	ComAllocOMErrT	;out of memory allocation failed
	MOV	[DI].CD_TXSEG,CX ;[8]set the DCB segment

;	Allocate the stack for the thread and set segment in DCB.


	RET			;near return to caller

ComAllocDNAErr:
	JMP	B$ERR_DNA	;give DNA error for /C:0 for interpreter compat


ComAllocOMErrT:
	MOV	AX,[DI].CD_RXSEG ;get segement allocated for the receive queue
	CALL	B$FHHighDealloc ;and deallocate it before giving error
ComAllocOMErrR:			
	JMP	B$ERR_OM_FH	;give OM error if couldn't allocate buffer

B$ComAlloc ENDP		

;***
;B$ComDealloc - Deallocate memory for a communications queue
;
;Purpose:
;	Deallocate the blocks of memory used as a communications queue.
;	The queues to be deallocated are specified by passing the DBC of
;	the communications device.  This device must have queues
;	allocated to it (with B$ComAlloc) otherwise there is a possibility
;	of corrupting memory.
;
;	For OS/2, this routine will also deallocate the stack segment for
;	the thread.
;
;Entry:
;	DI = communications device control block (DCB)
;
;Exit:
;	None.
;
;Uses:
;	Per Convention.
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	May generate B$ERR_MEM or B$ERR_FHC if memory has been
;	corrupted or the segment descriptors in the FDB have been
;	modified.
;******************************************************************************

	PUBLIC	B$ComDealloc	

B$ComDealloc PROC NEAR		

;	Deallocate the block defined in the comm DCB.

	PUSH	AX		;save the register


	MOV	AX,[DI].CD_RXSEG ;get the segment of the block
	CALL	B$FHHighDealloc ;deallocate the segment
	MOV	AX,[DI].CD_TXSEG ;get the segment of the block
	CALL	B$FHHighDealloc ;deallocate the segment


	POP	AX		;restore the register
	RET			;near return to caller

B$ComDealloc ENDP		

;***
; B$ComPreChain - prepare for DOS 5 chaining
; Purpose:
;	Added as part of revision [16].
;	Since DOS 5 CHAIN (with RTM) starts a new process, the current
;	emptier/filler threads must be terminated to be restarted later
;	in the new process itself.  Also, since the receive and transmit
;	buffers are in far memory, new selectors must be mapped using
;	DOSGIVESEG and provided to the new process.
;
; Inputs:
;	CX = pid of the new process
; Outputs:
;	Com buffer selectors are mapped.
; Modifies:
;	None.
; Exceptions:
;	B$ERR_OM - if mapping if selectors fail.
;******************************************************************************


;***
; B$ComPostChain - finish up after DOS 5 chaining
;
; Purpose:
;	Added as part of revision [16].
;	After the chaining is complete, reenable the thread for each
;	active device.
; Inputs:
;	None.
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	None.
;******************************************************************************


	SUBTTL	-  EOF, LOC, LOF etc (std file functions)

;COM_EOF - test for End-Of-File on device.
; Entry - SI points to File-Data-Block.
;	  [DI] = device offset (2=COMD, 4=SCRN, etc.)
; Exit	- [AX] = -1 if EOF, 0 if not EOF [1]

; This EOF function will hang waiting for input, but
; presumably, user wants device to look like sequential file, not
; a dynamic COM-I/O device if he is using EOF function.
; EOF(binary_file) is always false.

COM_EOF:
	TEST	[SI].FD_FLAGS,FL_BIN ; binary file?
	JNZ	bineof		;branch if not ascii file
	XOR	BX,BX		;assume no EOF
	CALL	INCHSI		;[AL]=next byte from COM device
	JB	YCMEOF		;branch if next char = EOF
	CALL	COM_BAKC	;put this back in queue
	INC	BX		;BX=0,	end-of-file is false
YCMEOF: DEC	BX		;BX=-1, end-of-file is true
	MOV	AX,BX		; result in AX
	RET

;   In BINARY mode, GW-BASIC EOF is compatible with IBM-PC Basic
;   That is, EOF is true when no data is in input queue.

BINEOF:
	push	dx		;5.40
	push	ax
	call	GetComUnitID	;AX = CD_DEVID in DCB
	mov	ah,al		;AH = CD_DEVID in DCB
	CALL	B$STACOM 	;[DX]=number of bytes in input queue
	call	ckcmer		; check for com error
	mov	bx,dx
	pop	ax
	pop	dx		;5.40
	OR	BX,BX
	JZ	YCMEOF		;branch if input queue is empty
	XOR	AX,AX		; return with [AX]=0 (false)
	RET			; AX=-1 if end-of-file is true

;INCHSI - get next byte from file SI (CTL Z = end-of-file)
; Exit	- Carry set if EOF, else [AL]=byte.
;	  All other regs preserved

INCHSI:
	TEST	[SI].FD_FLAGS,FL_NEOF
	JZ	INCEOF		;branch if EOF already reached
	TEST	[SI].FD_FLAGS,FL_BKC
	JNZ	GETBKC		;branch if char backed up
	CALL	COM_SINP	;[AL]=next input from file
	JB	INCEOF		;branch if device detected EOF
	RET

GETBKC: AND	[SI].FD_FLAGS,NOT FL_BKC ;Flag char as no longer backed up
	MOV	AL,[SI].FD_BAKC	;Get backup char
	CLC			;Make sure EOF isnt set
	RET

INCEOF: AND	[SI].FD_FLAGS,NOT FL_BKC ;Tell the world no char backed up
	STC			;Set carry to indicate EOF
	RET

;COM_BAKC - backup sequential input file
;	    original name: BCHRSI
;   Entry - [AL] = char to be backed up
;	    [SI] points to FDB of file to be backed up

COM_BAKC:
	MOV	[SI].FD_BAKC,AL
	OR	[SI].FD_FLAGS,FL_BKC ;set flag indicating char backed up
	RET

;B$COMLOC -- entry point to B$STACOM for $polcom in gwaevt
;entry: same as B$STACOM
;exit:	same as B$STACOM

	PUBLIC	B$COMLOC
B$COMLOC:
	JMP	B$STACOM	

;COM_LOC - Number of Bytes in input buffer for device.
; Entry - SI points to File-Data-Block.
;	  DI = device offset
; Exit	- [DX|AX] has I4 result
;	  uses DI

COM_LOC:
	CALL	GetComUnitID	;AL=Unit ID
	MOV	AH,AL
	CALL	B$STACOM 	;[DX]=number of bytes in input buffer
	CALL	CKCMER		;Check for Com Error
	TEST	[SI].FD_FLAGS,FL_BKC
	JZ	CMLOCX		;branch if char not backed up
	INC	DX
CMLOCX:
	MOV	AX,DX		; result in [DX|AX]
	JMP	SHORT DBLEX

;COM_LOF - number of bytes free in OUTPUT buffer.
; Entry - SI points to File-Data-Block.
;	  [DI] = device offset (2=COMD, 4=SCRN, etc.)
; Exit	- [DX|AX] has I4 result
;	  uses DI
COM_LOF:
	CALL	GetComUnitID	;AL=Unit ID
	MOV	AH,AL
	CALL	B$STACOM 	;Result in CX
	CALL	CKCMER		;Check for Com error
	MOV	AX,CX		; Put result in DX, now Zero the Regs:
DBLEX:
	XOR	DX,DX		; DX=0
	RET			;return result in FAC

;COM_CLOSE - perform any device dependent close functions.
; Entry - SI points to File-Data-Block.
;	  [DI] = device offset (2=COMD, 4=SCRN, etc.)
; Exit	- All registers preserved.
;	  This routine releases the fdata-block associated with this file.

DbPub	<COM_CLOSE>		
COM_CLOSE:
DbAssertRelB	<[b$COFlag]>,E,0,DV_TEXT,<b$COFlag non-zero in COM_CLOSE> ;
	CALL	GetComDCB	;DI points to device control block
	TEST	[SI].FD_FLAGS,FL_BIN ; binary file?
	JNZ	COMCLX		; Branch if BINARY file mode
	CMP	[SI].FD_MODE,MD_SQI
	JE	COMCLX		;don't send EOF if input mode
	MOV	AL,EOFCHR	;else send CTL-Z indicating EOF
	CALL	CMROUT
COMCLX:
	MOV	AH,[DI].CD_DEVID ;get device id
	PUSH	CX		; must preserve CX for dispatch count
	XOR	CX,CX		; CX = 0 to RESET DTR and RTS (DOS 3 only)
	CALL	B$TRMCOM 	;close device
	POP	CX		; Restore CX = dispatch count
	CALL	B$ComDealloc	;[2]deallocate the comm buffer
	MOV	[DI].CD_CMFDB,0 ;mark device as not-in-use
	CALL	B$LHDALC_CPCT	; Deallocate FDB and compact local heap
	JMP	CKCMER		; check for B$TRMCOM error and return


;COM_WIDTH - set file width
; Entry - SI points to File-Data-Block.
;	  [DX] = new device width
;	  [DI] = device offset (2=COMD, 4=SCRN, etc.)
; Exit	- All registers preserved

COM_WIDTH:
	MOV	[SI].FD_WIDTH,DL ;set DCB value to be effective now
	RET


;*** 
;COM_DWID - Set device width.  Added with [20].
;
;Purpose:
;
;Entry:
;	[DL] = new device width
;	[DI] = device offset
;Exit:
;	None
;Uses:
;	Per convention
;Exceptions:
;	None
;
;******************************************************************************
cProc	COM_DWID,<NEAR>,<DI>
cBegin
	CALL	GetComDCB	; get DCB in DI
	MOV	[DI].CD_CMWID,DL ; update DCB value
cEnd


;***
;COM_RANDIO -- low level routine to access comm for GET/PUT
;
;Purpose:
; This routine reads from/writes to a comm port a record.
;
;Entry:
;	[AL]		= flags
;			  Bit 0: 1 if PUT, else GET
;			  BIT 1: 1 if explicit record number specified
;			  BIT 2: 1 if record variable specified
;	[BX]		= record length to be written
;	[CX|DX] 	= user specified record number if GET/PUT (This number
;			  is used to override the length to be read/written)
;	[DI]		= Device Offset
;	[SI]		= *FDB
;	[b$RECPTR]	= Pointer to the data to be written
;
;Exit:
;	[AX]		= number of bytes actual read/write
;	one buffer is filled/flushed
;Uses:
;	Per convention
;
;Exceptions:
;	B$ERR_FC  -- illegal function call
;
;*******************************************************************************
cProc	COM_RANDIO,NEAR,ES	
cBegin				
	TEST	AL,RelFlg	; See if record specified
	JNZ	CRAND_5 	; Jump if record specified
	MOV	DX,BX		; [DX] = length to be read/written
	JMP	SHORT CRAND_20	; Go perform operation

CRAND_5:			; Record specified
	JCXZ	CRAND_15	; Jump if rec num < 64k (valid)
ERRFC:				
	JMP	B$ERR_FC	; Record number too big
CRAND_15:			
	CMP	BX,DX		; Record number must be less than buffer
	JC	ERRFC		; Jump if record number exceeds buff size

; [BX] = size of the buffer (size to clear for GET)
; [DX] = number of characters to actually deal with

CRAND_20:			
	MOV	CX,BX		; [CX] = size of buffer
	LES	BX,[b$RECPTR]	; [ES:BX] = pointer to buffer
	TEST	AL,PutFlg	; See if put or get
	JNZ	CRAND_30	; Jump if PUT

	PUSH	DI		; Save dispatch offset
	MOV	DI,BX		; [ES:DI] = pointer to buffer
	MOV	AL," "		; [AL] = a space to place
	REP	STOSB		; Fill buffer
	POP	DI		; [DI] = dispatch offset

	MOV	CX,DX		; [CX] = number of characters to get
CRAND_25:			
	PUSH	DI		; Save dispatch offset
	CALL	COM_SINP	; [AL] = next byte from comm port
	POP	DI		; [DI] = dispatch offset
	MOV	ES:[BX],AL	; Place into buffer
	INC	BX		; Move on
	LOOP	CRAND_25	; For all characters desired
	JMP	SHORT CRAND_90	; exit

CRAND_30:			; Put
	MOV	CX,DX		;get number of characters to output
	CALL	GetComDCB	; [DI] = DCB pointer
CRAND_35:			
	MOV	AL,ES:[BX]	; [AL]=next byte from buffer
	CALL	CMROUT		; output to com port
	INC	BX		; bump buffer pointer
	LOOP	CRAND_35	; For all characters desired

CRAND_90:			
	XCHG	AX,DX		; return count in AX

cEnd


;COM_SINP - Sequential Input.
; Entry - SI points to File-Data-Block.
;	  [DI] = device offset (2=COMD, 4=SCRN, etc.)
; Exit	- [AL] = next byte from file,
;	  carry set if EOF.
;	  All other registers preserved

COM_SINP:
	TEST	[SI].FD_FLAGS,FL_BKC ;Is a char backed up?
	JZ	CSWAIT		;No - go get one
	MOV	AL,[SI].FD_BAKC	;Yes get ch from backup
	AND	[SI].FD_FLAGS,NOT FL_BKC ;char is no longer backed up
	JMP	SHORT CMNEOF	;indicate no eof and return

CSWAIT:
	CALL	GetComUnitID	;[AL]=Com Unit ID(DI)
	MOV	AH,AL		;[AH]=Com Unit ID(DI)
	CALL	B$RECCOM 	;[AL]=input byte (if data is ready)
	PUSHF
	CALL	CKCMER		;check for Com Error
	POPF
	JNZ	CSGOT1		;wait if none ready to be read
	CALL	B$BREAK_CHK	;allow ^Break to break in
	JMP	SHORT CSWAIT
CSGOT1:
	PUSH	AX		;save registers...
	PUSH	DI
	CALL	GetComDCB	;get DCB in DI
	DEC	[DI].CD_CMEVT	;one less char in input queue
	POP	DI		;restore registers
	POP	AX
	CMP	AL,EOFCHR 	;check for CTL-Z
	JNE	CMNEOF		;branch if not
	TEST	[SI].FD_FLAGS,FL_BIN ; binary file?
	JNZ	CMNEOF		;CTL-Z is not EOF for Binary files
	STC			;CTL-z is EOF for ASCII files
	AND	[SI].FD_FLAGS,NOT FL_NEOF ;flag as eof
	JMP	SHORT CMSINX	;restore registers and exit
CMNEOF:
	CLC			;clear carry (no eof)
CMSINX:
	RET

;COM_SOUT - Sequential Output.
; Entry - SI points to File-Data-Block.
;	  [DI] = device offset (2=COMD, 4=SCRN, etc.)
;	  [AL] = byte to be output.
; Exit	- SI, DI can be changed.
;	  All other registers preserved
;	  This routine keeps track of column position,
;	  expands tabs, and forces a carriage return when line width
;	  is exceeded.


COM_SOUT:
	PUSH	AX
	CALL	GetComDCB	;DI points to COMx DCB
	POP	AX
	TEST	[DI].CD_CMFLG,CF_CMCOD ;did user explicity specifiy BIN/ASC?
	JZ	NOTBIN		;No
	TEST	[SI].FD_FLAGS,FL_BIN
	JNZ	CMROUT		;if binary, branch to Raw-Output routine
NOTBIN:
	PUSH	DX		;NOT binary
	MOV	DL,[SI].FD_WIDTH ;[DL]=device width (from FDB)
	MOV	DH,[DI].CD_CMPOS ;[DH]=current column (from DCB)
	CALL	XTABCR		;Expand tabs, force CR, do output, etc.
	MOV	[DI].CD_CMPOS,DH ;save new column position
	POP	DX
RET11:
	RET


;CLRCRF - Clear <CR> flag and output character
;CMROUT - Raw output routine
; Exit	- All registers preserved

CLRCRF:
	AND	[DI].CD_CMFLG,NOT CF_CMCRF ;clear CR flag

CMROUT: 			;output character/raw output routine
	MOV	AH,[DI].CD_DEVID ;[AH]=device ID
	CALL	B$SNDCOM 	;output [AL] to COM
	JMP	CKCMER		;check for successful transmit and rtn

;XTABCR     expand tabs,force <CR> if EOL
;entry->    [AL] = Char to be output
;	    [DX] = [current column,file width]
;	    [DI] = device offset
;exit ->    [DH] = new column
;	    all other regesters preserved


XTABCR:
	INC	DH		; send character and then check
				;if beyond width specified
	CMP	AL,ASCSP 	;Is it printable
	JB	OTHERS		;No  - start checking alternatives
	CALL	CLRCRF		;Yes - print it
	CMP	DH,DL		;Are we in range?
	JB	INRANG		;YES
	CMP	DL,0FFh 	;NO, but do we care?
	JE	INRANG		;We dont care so pretend were in range
	MOV	AL,ASCCR 	;	  and print a
	CALL	TRYCR		;     carriage return
	AND	[DI].CD_CMFLG,NOT CF_CMCRF ;clear CR flag
INRANG:
	RET
OTHERS:
	DEC	DH
TRYTAB:
	CMP	AL,ASCHT 	;is it a tab
	JNE	TRYCR		;no so try <CR>
	TEST	[DI].CD_CMFLG,CF_CMCOD ;test if IBM mode
	JZ	CMROUT		;if so, just output tab
	MOV	AL,ASCSP 	;expand to spaces
MORSPC:
	CALL	XTABCR
	TEST	DH,7		;Are we on a multiple of 8?
	JNZ	MORSPC		;Nope, try again
	MOV	AL,ASCHT 	;Restore AL
	RET			;and return
TRYCR:
	CMP	AL,ASCCR 	;is it a <CR>?
	JNE	TRYLF		;No  - see if its a line feed
	CALL	CMROUT		;Yes - put it out
	XOR	DH,DH		;      and update pos.
	TEST	[DI].CD_CMFLG,CF_CMCLF ;  add an <LF>?
	JZ	SETCRF		;      no
	MOV	AL,ASCLF	;	   yes, so put one out
	CALL	CMROUT
	MOV	AL,ASCCR	;	   restore AL
SETCRF:
	OR	[DI].CD_CMFLG,CF_CMCRF ;set CR flag
	RET

TRYLF:
	CMP	AL, ASCLF	;Is it an <LF>
	JNE	TRYBS		;No - try a <BS>
	TEST	[DI].CD_CMFLG,CF_CMCRF ;look to see this follows CR
	JZ	CMROUT		;not preceded by a <CR>
	AND	[DI].CD_CMFLG,NOT CF_CMCRF ;pred by CR - ignore LF, clear flag
	TEST	[DI].CD_CMFLG,CF_CMCOD ;test if IBM mode
	JZ	CMROUT		;if so, no LF suppression
	RET			;   and return

TRYBS:
	CMP	AL,ASCBS 	;is it a <BS>
	JNE	CLRCRF		;no - write it out
	DEC	DH		;back up pos
	JNC	CLRCRF		;send it out unless pos backed up past 0
	INC	DH
	JMP	CLRCRF


;COM_GPOS - return current file position.
; Entry - SI points to File-Data-Block.
;	  [DI] = device offset (2=COMD, 4=SCRN, etc.)
; Exit	- [AH] = current file column. (0-relative)
;	  All other registers preserved

COM_GPOS:
	PUSH	AX		;save contents of AL
	CALL	GetComDCB	;DI points to Device Control Block
	POP	AX		;restore contents of AL
	MOV	AH,[DI].CD_CMPOS
	RET

;COM_GWID - get device width
; Entry - SI points to File-Data-Block.
;	  [DI] = device offset (2=COMD, 4=SCRN, etc.)
; Exit	- [AH] = device width as set by xxxSWD

COM_GWID:
	MOV	AH,[SI].FD_WIDTH ;get current width
	RET

;COM_SCW - set device comma width	****Apparently not used by Bascom****
; Entry - [BX] = new device comma width
;	  SI points to File-Data-Block.
;	  [DI] = device offset (2=COMD, 4=SCRN, etc.)
; Exit	- SI, DI can be changed.
;	  All other registers preserved
;
;COM_SCW:
;	 RET

;COM_GCW - get device comma width	****Apparantly not used by Bascom****
; Entry - SI points to File-Data-Block.
;	  [DI] = device offset (2=COMD, 4=SCRN, etc.)
; Exit	- [BX] = device comma width as set by xxxSCW
;	  All other registers preserved
;
;COM_GCW:
;	RET

;**	com_blkin - block input
;**	com_blkout  - block output			--DMA support for BLOAD
;	NOT IMPLEMENTED

;	Entry	[bx] =	offset of destination
;		[cx] =	maximum number of bytes to read
;		[dx] =	DS of destination
;		[di] =	device number
;		[si] -> FDB of file to be loaded
;	exit	?      (This routine is provided to allow the user
;			to trash himself beyond all recognition!
;	Exit	[bx] =	1 past last byte read
;		CF	set if EOF encountered
;	Uses	AX
com_blkin equ	B$ERR_FC
com_blkout equ	B$ERR_FC

;***
; GetComDCB - get pointer to COM Device Control Block
;
; Purpose:
;	To compute the offset the device control block (DCB) of
;	the communications device ID given.  The number of the
;	device is also given (0-relative).
; Entry:
;	DI = -2 * device ID (positive value)
; Exit:
;	DI = offset to the device control block
;	AX = 0 for COM1, 1 for COM2, ...
; Modifies:
;	None.
; Exceptions:
;	None.
;*****************************************************************************

GetComDCB:
	CALL	GetComUnitId	;[AX]=unit id (0..n)

	MOV	DI,OFFSET DGROUP:B$CM1DCB ;assume COM1: first
	OR	AX,AX		;test if really first device
	JZ	GetComDCBDone	;if so, then jump
	ADD	DI,SIZE COMDCB	;add to get start of DCB for COM2:
GetComDCBDone:
	RET

;***
; GetComUnitID - get communications unit ID
;
; Purpose:
;	To get the zero-relative unit identification number from
;	the device ID.
; Entry:
;	DI = -2 * device ID (positive number)
; Exit:
;	AX = 0 for COM1:, 1 for COM2:,...
; Modifies:
;	None.
; Exceptions:
;	None.
;***************************************************************************

GetComUnitID:
	MOV	AX,DI
	ADD	AX,2*DN_COM1
	SHR	AX,1		;[AX]=0, 1. for COM1, COM2, ...
ERRRET:
	RET

; Check for COM I/O error and output COM Error Message if error occured.
; Entry - [AH] = non-zero if error occured

CKCMER:
	OR	AH,AH
	JZ	ERRRET		;branch if no COM I/O error detected
	MOV	BL,AH
	XOR	BH,BH		;[BX]=error code 1..n
	MOV	DI,OFFSET DGROUP:CMERRT ;DI has dipatch table for error routines
	CMP	BL,5
	JBE	ERROK
	XOR	BX,BX		;use default error
ERROK:
	SHL	BX,1		;convert error to word offset
	JMP	[DI+BX] 	;Handle error

;***
;B$CommSave - Save communications state
;
;Purpose:
;	This routine will be called whenever a process is going to
;	be shelled.   The communications ports, if opened, are
;	disabled, but their DCB's and opened status are kept for
;	subsequent reopening in B$CommRestore.  Note that
;	interrupt handlers will not have to be terminated.
;
;	This is a DOS only routine.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;********************************************************************

cProc	B$CommSave,<PUBLIC,NEAR>,<AX,BX,CX,DX,SI,DI> 
cBegin				

DbAssertRelB	<[b$COFlag]>,E,0,DV_TEXT,<b$COFlag non-zero in B$CommSave> ;
	MOV	CX,b$ComPort	;get value of I/O port for COM1
	MOV	COMSAV,CX	;put into save area
	JCXZ	NoActCOM1	;if no active COM1, then jump

	MOV	DI,OFFSET DGROUP:b$COM_DCB ;get offset to COM1 DCB
; CX must be non-zero so DTR and RTS are unaffected (DOS 3 only)
	MOV	AH,0		; AH = 0 indicates COM1
	CALL	B$TRMCOM	;[3]terminate COM1 device
	CALL	B$ComDealloc	;and dellocate the COM1 buffer
NoActCOM1:			

	MOV	CX,b$ComPort+2	;get value of I/O port for COM2
	MOV	COMSAV+2,CX	;put into save area
	JCXZ	NoActCOM2	;if no active COM2, then jump

	MOV	DI,OFFSET DGROUP:b$COM_DCB+SIZE COMDCB ;offset to COM2 DCB
; CX must be non-zero so DTR and RTS are unaffected (DOS 3 only)
	MOV	AH,1		; AH = 1 indicates COM2
	CALL	B$TRMCOM	;[3]terminate COM2 device
	CALL	B$ComDealloc	;and dellocate the COM2 buffer
NoActCOM2:			
cEnd				

;***
;B$CommRestore - Restore communications state
;
;Purpose:
;	This routine will be called when a shelled process returns.
;	The communications ports disabled in B$CommSave are
;	reopened with their preSHELL values.  Note that interrupt
;	handlers will not have to be restarted.
;
;	This is a DOS only routine.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;********************************************************************

cProc	B$CommRestore,<PUBLIC,NEAR>,<AX,BX,CX,DX,SI,DI> 
cBegin				

DbAssertRelB	<[b$COFlag]>,E,0,DV_TEXT,<b$COFlag non-zero in B$CommRestore> ;
	MOV	CX,COMSAV	;get saved I/O port for COM1
	JCXZ	NoRestCOM1	;if none, the skip over restore

	MOV	DI,OFFSET DGROUP:b$COM_DCB ;get offset to COM1 DCB
	CALL	B$ComAlloc	;allocate the COM1 buffer
	MOV	BX,DI		;move DCB address to BX
	CALL	B$INICOM	;[3]initialize COM1 device
NoRestCOM1:			

	MOV	CX,COMSAV+2	;get saved I/O port for COM2
	JCXZ	NoRestCOM2	;if none, then skip over restore

	MOV	DI,OFFSET DGROUP:b$COM_DCB+SIZE COMDCB ;offset to COM2 DCB
	CALL	B$ComAlloc	;allocate the COM2 buffer
	MOV	BX,DI		;move DCB address to BX
	CALL	B$INICOM	;[3]initialize COM2 device
NoRestCOM2:			

cEnd				

sEnd	DV_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwkey.asm ===
PAGE	56,132
	TITLE	GWKEY - SUPPORT FOR SOFT KEY ASSIGNMENT
;***
; GWKEY - SUPPORT FOR SOFT KEY ASSIGNMENT
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;      KEY n,x$
;      --------
;	   |
;	 $KY1
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	EV_TEXT 	
	useSeg	_DATA		
	useSeg	_BSS		

	INCLUDE seg.inc 	; segment definitions
	INCLUDE baslibma.inc
	INCLUDE event.inc	; oem evt routines parameters
	INCLUDE string.inc	

	SUBTTL	local constant definitions	
	page

;Number of keys 		
	OrgFky		= 10	; normally, there is 10 function keys
	CsrMovKy	= 4	; four cursor movement keys

	NumF10		= 10	; # of F10
	NumF11		= 30	; # of F11
	NumF12		= 31	; # of F12

sBegin	_DATA			
	externW	b$vKEYDSP	; vector for indirect call of B$KEYDSP
sEnd	_DATA			

sBegin	_BSS			
	externW b$STRTAB	;defined in GWDATA.ASM
	externB b$KEY_SW
sEnd	_BSS			

sBegin	EV_TEXT 		

assumes CS,EV_TEXT		

	externNP B$ERR_FC	
	externFP B$FMID 	; MID$ function
	externFP B$SASS 	
	externNP B$STDALCTMP	; deallocate temp string
	externNP B$RDKYBD


;***
; B$KMAP - Soft Key Assignment
;
;Purpose:
;
;	Runtime Entry Point
;	Syntax:
;	      KEY<n>,<string>
;
;	Where:
;
;	<n>	is an integer expression returning a result in
;		the range 1 to 10 (or 30,31).  Other values will result
;		in an "Illegal Function Call" Error.
;
;	<string>is any string expression.  Only the 1st 15 characters
;		are assigned as the Soft Key value.  If a null string
;		is assigned, the Soft Key is effectively disabled.
;		In this case, INKEY$ returns a 2 byte string.
;		B$TTYIN returns 0, and the Line Editor complains.
;		if FK_KANJI then if 15th byte is the beginning of a Kanji char
;				then substitute a blank and ignore second half
;
;
;Entry:
;
;	keynum	= Key number (1 to 10)
;	string	= SD of assignment string
;
;Exceptions:
;	B$ERR_FC if bad key number.
;
;******************************************************************************
cProc	B$KMAP,<PUBLIC,FAR>	
parmW	keynum			; key number
parmSD	string			;string to assign
cBegin				
	MOV	AX,keynum	; get key number
	GetpSD	BX,string	;and string descriptor address
	CMP	AL,OrgFky	; if not one of F1-F10 then
	JA	check_user	;[7]  check for user-defined key or F11, F12
SoftKeys:			; if F11 & F12 continue from here
	DEC	AX		
	JS	ERRFC		; Jump if invalid
	ADD	AX,AX		
	ADD	AX,AX		; [AX] = (4 * Key number).
	ADD	AX,OFFSET DGROUP:b$STRTAB ;Index into Soft Key table
	PUSH	AX		;Save Soft Key Table addr
	MOV	DX,1
	MOV	CX,15		;String may be 0 to 15 chars.


	cCall	B$FMID,<BX,DX,CX>	; Get a String 0 to 15 chars long
	POP	DX		; [DX] = softkey table address
	cCall	B$SASS,<AX,DX>	; in the Soft Key Table
	TEST	b$KEY_SW,1	;test if key display is on
	JZ	KMAP_90 	;if not, just jump
	CALL	[b$vKEYDSP] 	; Display new Keys
	JMP	SHORT KMAP_90	
;
; BASICA32 doesn't check whether the ronco is present when assigning the key
; definition, so is here.
;
F11F12:
	SUB	AX,NumF11-NumF10-1 ; F11, F12 are next to F10 in b$STRTAB
	JMP	SHORT SoftKeys	; process as one of function keys
;
ERRFC:	JMP	B$ERR_FC	; complain..
;
; Check for user defined key definition
;
check_user:
	CMP	AL,NUM_TKEYS+1	; beyond the range ?
	JNB	ERRFC		; Brif yes
	cmp	AL,OrgFky+CsrMovKy+1 ; is it a soft key? (10 < key# < 14)
	jb	ERRFC		; yes - (can't define crsr movement keys)
	CMP	AL,NumF11	; is F11 ? (BX is 0-relative)
	JZ	F11F12		; Brif yes
	CMP	AL,NumF12	; is F12 ? (current last soft key is F12)
	JZ	F11F12		; Brif yes
	CMP	AL,NumF11-NUM_GAP+1 ; gap between the last user key and F11
	jnb	ERRFC		; no -	complain
	XCHG	DX,AX		; [DX] = 1-offset key num
	push	bx		; save psd
	mov	cx,[bx] 	; CX has length of string
	mov	bx,[bx+2]	; BX -> text
	mov	al,define_key
	call	B$RDKYBD 	; set the trap
	pop	bx		; retrieve psd
	jc	ERRFC		; oem didn't like that
	CALL	B$STDALCTMP	; Delete if temporary string

KMAP_90:

cEnd				

sEnd	EV_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwlin.asm ===
TITLE	GWLIN - read and edit line from keyboard
;***
; GWLIN - read and edit line from keyboard
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
;
;	* entry point: B$RDLIN
;
;	* returns string in b$Buf1
;	  * byte vector up to length of 255
;	  * zero-byte terminated
;
;	* both ASCII and KANJI versions on switch FK_KANJI
;
;-------------------------------------------------------------------
;
;	Data structures used:
;
;	* b$INBUF - byte vector of length 256
;	  * contains ASCII/KANJI values of present state
;	    of string entered
;	  * end-of-line (EOL) indication is 0 value
;
;	* XBLTAB - word vector of length 8 (KANJI only)
;	  * entries, if any, defined up to index XBLNXT
;	  * entry contains b$INBUF location of KANJI character
;	    where an extra blank had to be inserted on the
;	    display screen to prevent splitting the KANJI
;	    character across rows.
;
;------------------------------------------------------------------
;
;	Editting functions supported:
;
;	* ^B  - move cursor back one word
;	* ^C  - exit program
;	* ^E  - truncate line at cursor
;	* ^F -	move cursor forward one word
;	* ^H  - delete character left of cursor
;	* ^I  - insert/overwrite to next tab field of length 8
;	* ^K  - move cursor to beginning of line
;	* ^M  - (carriage return) return string to program
;	* ^N  - move cursor to end of line
;	* ^R  - toggle between insertion and overwriting
;	* ^T  - toggle function key label display
;	* ^U  - erase line
;	* ^\  - (left cursor) move cursor left once
;	* ^]  - (right cursor) move cursor right once
;	* DEL - delete character over cursor
;==================================================================
				;      ASCII character definitions

	CTL_B=002D		;^B - control B
	CTL_C=003D		;^C - control C
	CTL_E=005D		;^E - control E
	CTL_F=006D		;^F - control F
	CTL_G=007D		;^G - control G (BELL)
	CTL_H=008D		;^H - control H (backspace)
	CTL_I=009D		;^I - control I (TAB)
	CTL_J=010D		;^J - control J (line feed)
	CTL_K=011D		;^K - control K
	CTL_M=013D		;^M - control M (carriage return)
	CTL_N=014D		;^N - control N
	CTL_R=018D		;^R - control R (insert map)
	CTL_T=020D		;^T - control T
	CTL_U=021D		;^U - control U (ESC map)
	CTL_BS=028D		;^\ - control \ (right arrow map)
	CTL_RB=029D		;^] - control ] (left arrow map)

	ASC_SP=032D		;ASCII space
	ASC_DL=127D		;ASCII DEL (delete map)

; Standard MS Keyboard codes (have FF as high byte)

	CNTL=0FFh		; Must be sent in front of control chars

;	other definitions

	.XLIST
	INCLUDE switch.inc	
	INCLUDE rmacros.inc	

	USESEG	_DATA		
	USESEG	CONST		
	USESEG	_BSS		
	USESEG	CN_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE dc.inc
	INCLUDE messages.inc	; MS message
	INCLUDE const.inc	
	.LIST

	BUFLEN=255D		;length of b$INBUF

	.SALL			;suppress macro expansion

sBegin	_DATA			

	externW	b$CRTWIDTH	; width of display screen
	externW	b$CURSOR	; (1,1)-relative screen cursor
	externB	b$IOFLAG	; Misc. IO flags.  Defined in GWINI.ASM

sEnd	_DATA			

sBegin	CONST			

	globalB	b$EightSpaces,' ',8 ; string of eight spaces (for TAB)

sEnd	CONST			

sBegin	_BSS			

	externB b$Buf1		; defined in GWINI.ASM
	b$INBUF EQU b$Buf1	; (use b$Buf1 and b$Buf2)

	staticW CSRPTR,,1	;b$INBUF index to input cursor
	staticW EOLPTR,,1	;b$INBUF index to input end-of-line
	staticW UPDPTR,,1	;b$INBUF index to start of update
	staticW CSRLOC,,1	;display column of cursor
	staticW EOLLOC,,1	;display column of end-of-line
	staticB INSFLG,,1	;0=overwrite mode, 0FFH=insert mode
	staticB ENDFLG,,1	;0=process another char, 0FFH=done
	INPLEN=16D		;length of input string for insert
	externB b$Buf3		; defined in GWINI.ASM
INPSTR	EQU	b$Buf3		; string of bytes for character insert


sEnd	_BSS			

sBegin	CN_TEXT 		
	assumes CS,CN_TEXT	

	externNP B$TTYGetChar	; Wait for keyboard character, checking for
				; ^BREAK
	externNP B$TTYST	;determines if character input pending
	externNP B$BREAK	
	externNP B$TTY_SOUT	;output character in AL to screen
	externNP B$STDGET	; input char from keyboard or redir input
	externNP B$ERR_RPE	; INPUT PAST END error
	externNP B$BREAK_CHK	;check for break character entered
	externNP B$SCRN_GPOS	; get screen cursor position
	externNP B$SCNLOC	; update cursor position and variables
	externNP B$EDTMAP	;OEM mapping for keyboard characters
	externNP B$LABELK	;toggle function label display
	externNP B$OFFCSR	; off cursor
	externNP B$INSCSR	; insert mode cursor
	externNP B$OVWCSR	; overwrite mode cursor
	externNP B$USRCSR	; user cursor
	externNP B$BLEEP	; sound bell on display

;	TABLE macro to define entries in CTLTAB

TABLE	MACRO	FCODE,FADDR
	DB	FCODE
	DW	FADDR
	ENDM	TABLE

;	CTLTAB definition for control character processing

CTLTAB:
	TABLE	CTL_B,BAKWRD	;move cursor backward one word
	TABLE	CTL_C,BREAK	;exit from BASCOM program
	TABLE	CTL_E,TRUNC	;truncate input line at cursor
	TABLE	CTL_F,FORWRD	;move cursor forward one word
	TABLE	CTL_J,IGNORE	; process LF (follows CR in redirected input)
	TABLE	CTL_K,BEGIN	;move cursor to line beginning
	TABLE	CTL_M,ENDLIN	;process CR to end line input
	TABLE	CTL_N,APPEND	;move cursor to end of input line
	TABLE	CTL_U,ERASE	;erase entire input line
	TABLE	CTL_BS,CSRRGT	;move cursor once to the right
	TABLE	CTL_RB,CSRLFT	;move cursor once to the left

;	the above functions set INSFLG=0

CTLINS:
	TABLE	CTL_H,DELLFT	;delete character left of cursor
	TABLE	CTL_I,TABCHR	;process TAB printing character
	TABLE	CTL_R,TOGINS	;toggle insert/overwrite mode
	TABLE	CTL_T,B$LABELK	;toggle key label display
	TABLE	ASC_DL,DELCSR	;delete character on cursor
CTLEND: 			;end of CTLTAB


	page
;*** 
; B$RDLIN -- Read a line of input.
;
;Purpose:
;
;Entry:
;	Caller should hold (and subsequently release) b$Buf1 & b$Buf2
;Exit:
;	b$Buf1 (+ b$Buf2) contains the data input.
;Uses:
;	None
;Preserves:
;	All
;Exceptions:
;
;******************************************************************************

cProc	B$RDLIN,<NEAR,PUBLIC>,<AX,BX,CX,DX,ES>	
cBegin				


;	initialization

	PUSH	DS		; set ES=DS
	POP	ES		

	XOR	BX,BX		;clear BX for use as zero

	MOV	CSRPTR,BX	;cursor at start of input line
	MOV	EOLPTR,BX	;input line starts out null

	MOV	INSFLG,BL	;start with overwrite mode
	MOV	ENDFLG,BL	;input line is starting, not ending

	MOV	b$INBUF,BL	;clear EOL position of b$INBUF

	OR	b$IOFLAG,(F_EDIT OR IN_INPUT) ; Disable $PRTMAP
				; and tell B$TTY_SOUT not to echo to stdout
				; until final dump of edited buffer.

	CALL	FRCLIN		;force new line if cursor stuck
	CALL	OFFCSR		;turn off cursor

;********************************************************************
;	start of main program loop
;********************************************************************

;	get next keyboard character
;	  if PSW.Z=1, then ignore the character
;	  if PSW.C=0, then character is ASCII in AL

NXTCHR:

	; Update the state of the BIOS Insert bit to correspond to
	; the current state of our Insert flag.  This allows programs
	; that depend on this bit (i.e. screen readers for the blind)
	; to work properly.

	push	es
	push	ax
	push	bx

	xor	bx, bx
	mov	es, bx		;prepare ES for accessing BIOS
	cli			;No interrupts while munging Keyboard flags
	mov	al, es:[417h]	;get current shift states
	and	al, 7fh 	;assume insert mode off
	cmp	INSFLG, bl	;is insert mode off
	je	@F		;brif so, assumption correct
	or	al, 80h 	;otherwise, set insert mode on
@@:
	mov	es:[417h], al	;tell the BIOS of the change
	sti			;allow interrupts again.

	pop	bx		;Restore previous registers
	pop	ax
	pop	es


	CALL	FRCSTR		;force output if no char pending
	CALL	GETCHR		;get the next character
	JNZ	NXTCH1		;jump if input is legal
	CALL	BADCHR		;process illegal character
	JMP	SHORT NXTCHR	;and try for the next character

;	if one-byte character, process as ASCII printing code

NXTCH1:
	JC	NXTCH2		;jump if two-byte character
NXTCH1A:
	CALL	ASCCHR		;process as ASCII if carry clear
	JMP	SHORT NXTCHR	;and process the next character

;	two-byte character - test for function key code

NXTCH2:
	CMP	AH,080H 	;test if function key code
	JNE	NXTCH3		;if not, then jump
	CMP	AL,080H 	;test for 8080H -> 80H byte
	JE	NXTCH1A 	;if so, then just print it
	CALL	FKYCHR		;process function key
	JMP	SHORT NXTCHR	;and process the next character

;	test for control character code

NXTCH3:
	CMP	AH,0FFH 	;test if control character
	JNE	NXTCHR		; brif not -- process next char
	CMP	AL,010H 	;test for FF10H -> FEH
	JNE	NXTCH3A 	;if not, then jump
	MOV	AL,0FEH 	;force in mapped character
	JMP	SHORT NXTCH1A	;jump to print character
NXTCH3A:
	CMP	AL,0FFH 	;test for FFFFH -> FFH
	JE	NXTCH1A 	;if so, then print character
	CALL	CTLCHR		;process control character in AL

;	test if input line is finished - if so, leave module

	TEST	ENDFLG,0FFH	;test if input line has ended
	JNZ	RDEXIT		;if so, jump to exit the module
	JMP	SHORT NXTCHR	;jump to process the next char


RDEXIT:
	CALL	USRCSR		;turn on user cursor


cEnd				; restore registers and return to caller

	page


;********************************************************************
;	GETCHR - get keyboard character - remove 3-byte codes
;********************************************************************
; Note that the interpreter does character mapping on ouput only.
; Either B$EDTMAP and $PRTMAP is called when a character is printed
; on the screen, depending on whether in edit mode or not.
; The compiler, not having a full screen editor, only needs B$EDTMAP
; during the INPUT statement. So edit character mapping is done on the
; keyboard input, and print mapping is done on screen output. Since
; characters echoed from here have already been mapped, they must not
; be mapped in B$TTY_SOUT also, so F_EDIT [13] is set to nonzero on entry
; to B$RDLIN and cleared on the only three exits through ENDLIN, BREAK,
; and end of redirected IO.


GETCHR:
;   PUSH    DX		    ;save register on the stack

	CALL	ONCSR		;turn on cursor for input
	test	b$IOFLAG,RED_INP ; input redirected?
	jz	noredir
	call	B$STDGET 	; read char from standard input
	jnz	redir

; End of redirected input seen, flush input buffer and exit
	AND	b$IOFLAG,NOT (F_EDIT OR IN_INPUT) ; Re-enable $PRTMAP
				; Exiting INPUT statement
	CALL	APPEND		; move cursor to end of line
	JMP	B$ERR_RPE	; jump to "INPUT PAST END" error

noredir:

	MOV	DL,1		;Check for events while waiting
	CALL	B$TTYGetChar	;get character from keyboard

redir:
	cCALL	B$EDTMAP 	;map to OEM specifications
	PUSHF			;save flags on stack
	CALL	OFFCSR		;turn off cursor

;	if 3-byte code (AL=254D), clear AX to ignore character

	CMP	AL,254D 	;is this a 3-byte code?
	JNE	GETCH1		;if not, then branch
	POPF			;restore flags (and stack)
	XOR	AX,AX		;clear AX to be ignored

;   POP     DX		    ;restore register from stack
	RET			;and return to caller

;	not 3-byte code, just return AX to caller

GETCH1:
	POPF			;restore flags
;   POP     DX		    ;restore register from stack
	RET			;and return to caller

;********************************************************************
;	EDTSTR - edit string in INPSTR into input buffer
;********************************************************************

EDTSTR:
	PUSH	CX		;save registers on stack
	PUSH	SI

	MOV	CX,BX		;get length of INPSTR in bytes
	JCXZ	EDTST1		;if null, then just exit
	MOV	SI,OFFSET DGROUP:INPSTR ;get offset of string
	CALL	PRTCHR		;insert/overwrite string in b$INBUF
	XOR	BX,BX		;done - reset INPSTR pointer
EDTST1:
	POP	SI		;restore registers from stack
	POP	CX
	RET			;return to caller

;********************************************************************
;	ONCSR - turn on appropriate cursor
;********************************************************************

ONCSR:
	TEST	INSFLG,0FFH	;is insert mode active?
	JNZ	INSCSR		; brif so (returns to caller)
	JMP	SHORT OVRCSR	; otherwise, turn on overwrite cursor
				; and return to caller

;********************************************************************
;	OFFCSR - turn off cursor
;	INSCSR - turn on insert cursor (half-height)
;	OVRCSR - turn on overwrite cursor
;	USRCSR - turn on user cursor
;********************************************************************

OFFCSR:
	PUSH	AX		;save register on stack
	MOV	AX,OFFSET CS:B$OFFCSR	; turns off cursor
	JMP	SHORT CHGCSR	;jump to common code
INSCSR:
	PUSH	AX		;save register on stack
	MOV	AX,OFFSET CS:B$INSCSR	; displays insert cursor
	JMP	SHORT CHGCSR	;jump to common code
OVRCSR:
	PUSH	AX		;save register on stack
	MOV	AX,OFFSET CS:B$OVWCSR	; displays overwrite cursor
	JMP	SHORT CHGCSR	;jump to common code
USRCSR:
	PUSH	AX		;save register on stack
	MOV	AX,OFFSET CS:B$USRCSR	; displays user cursor
CHGCSR:
	PUSH	DX		;save register on stack

	MOV	DL,b$IOFLAG	
	AND	DL,RED_INP OR RED_OUT ; redirected input and output?
	CMP	DL,RED_INP OR RED_OUT 
	JZ	NO_CURSOR	; brif so -- don't touch cursor

	MOV	DX,b$CURSOR	; get cursor position
	CALL	AX 		; call appropriate cursor display routine
NO_CURSOR:			
	POP	DX		;restore register from stack
	POP	AX
	RET			;and return to caller

;********************************************************************
;	BADCHR - process an illegal character
;********************************************************************

BADCHR:
	CALL	EDTSTR		;dump out INPSTR to b$INBUF
	CALL	OUTBEL		;sound bell for signal
	RET			;return to caller

;********************************************************************
;	FKYCHR - process nonexpanded function key
;********************************************************************

FKYCHR:
	PUSH	AX		;save register on stack

	CALL	EDTSTR		;dump out INPSTR to b$INBUF
	SUB	AL,20H		;subtract offset to keys
	CMP	AL,NUM_FKEYS	;test if legal key number
	JL	FKYCH1		;if legal, then jump
	CALL	OUTBEL		;sound bell for signal
FKYCH1:
	POP	AX		;restore register from stack
	RET			;and return to caller

;********************************************************************
;	ASCCHR - process ASCII character
;********************************************************************

ASCCHR:
	CMP	BX,INPLEN	;test if INPSTR is full
	JL	ASCCH1		;if not, then jump
	CALL	EDTSTR		;dump out INPSTR to b$INBUF
ASCCH1:
	MOV	INPSTR[BX],AL	;put ASCII byte in INPSTR
	INC	BX		;advance INPSTR pointer
	RET			;and return to caller

;********************************************************************
;	KANCHR - process KANJI character
;		 rewrite to support interim characters
;********************************************************************


;********************************************************************
;	FRCSTR - force INPSTR out if no input character pending
;********************************************************************

FRCSTR:
	PUSH	AX		;save register on stack

	test	b$IOFLAG,RED_INP ; input redirected?
	jnz	frcst1		; Yes, always a char ready.
	CALL	B$TTYST	;test for character pending
	JNZ	FRCST1		;if one pending, then jump
	CALL	EDTSTR		;output INPSTR to b$INBUF
FRCST1:
	POP	AX		;restore register from stack
	RET			;return to caller

;********************************************************************
;	CTLCHR - process control character
;********************************************************************

;	search in CTLTAB for entry (1-byte code, 2-byte address)
;	if found, do processing, else signal bell for error

CTLCHR:
	PUSH	SI		; save register on stack

	CALL	EDTSTR		;dump out any INPSTR bytes
	MOV	SI,OFFSET CTLTAB ; initialize pointer to table
CTLCH1:
	CMP	SI,OFFSET CTLEND ; test if pointer at table end
	JE	CTLCH4		;if at end, sound bell for undefined
	CMP	CS:[SI],AL	; test if entry matches
	JE	CTLCH2		;if so, then jump
	ADD	SI,3		; point to next table entry
	JMP	SHORT CTLCH1	;and try to process it

;	set to overwrite mode according to function index

CTLCH2:
	CMP	SI,OFFSET CTLINS ; check if function clears INSFLG
	JAE	CTLCH3		;if not, then jump
	MOV	INSFLG,0	;put into overwrite mode
CTLCH3:
	CALL	CS:[SI+1]	; call routine address in table
	JMP	SHORT CTLCH5	;jump to return

;	sound bell for undefined key input

CTLCH4:
	CALL	OUTBEL		;output control-G (BELL) to screen
CTLCH5:
	POP	SI		; restore register from stack
	RET			;and return to caller

;********************************************************************
;	TABCHR - print TAB character
;********************************************************************

TABCHR:
	PUSH	BX		;save registers on stack
	PUSH	CX
	PUSH	SI

	MOV	BX,CSRPTR	;get cursor pointer in b$INBUF
	AND	BX,7		;get position within TAB field
	MOV	CX,8		;size of TAB field
	SUB	CX,BX		;get spaces to process
	MOV	SI,OFFSET DGROUP:b$EightSpaces ; set to string of blanks
	CALL	PRTCHR		;process the character

	POP	SI		;restore registers from stack
	POP	CX
	POP	BX
	RET			;and return to caller

;********************************************************************
;	TOGINS - toggle between insert and overwrite mode
;********************************************************************

TOGINS:
	XOR	INSFLG,0FFH	;complement flag between 00 and FF
	RET			;and return to caller

;********************************************************************
;	IGNORE - Throw away this control char without beeping.
;********************************************************************

IGNORE: RET

;********************************************************************
;	ENDLIN - signal end of line input
;	    Redisplays input line if:				[13]
;		LPR_ECHO OR RED_OUT  				[13]
;********************************************************************

ENDLIN:
	AND	b$IOFLAG,NOT IN_INPUT	; Tell B$TTY_SOUT to process edited
					; buffer
	PUSH	b$CURSOR		; save previous screen cursor values

	TEST	b$IOFLAG,LPR_ECHO OR RED_OUT ; printer echo or ouput redir?
	JZ	ENDLI2			; brif not -- don't re-display line.
	CALL	BEGIN		; Move cursor back to beginning of line
ENDLI2:
	CALL	APPEND		;move cursor to end-of-line, printing as we go
	DEC	ENDFLG		;set flag from 00 to FF
	POP	b$CURSOR		; restore previous cursor values
	AND	b$IOFLAG,NOT F_EDIT	; Re-enable $PRTMAP
	RET			;and return

;********************************************************************
;	BREAK - exit immediately from program
;********************************************************************

BREAK:
	AND	b$IOFLAG,NOT (F_EDIT OR IN_INPUT) ; Re-enable $PRTMAP
				; and exiting INPUT statement.
	CALL	APPEND		;move cursor to end of line
	JMP	B$BREAK	; print Break message and terminate

;********************************************************************
;	PRTCHR - process printing character on input line
;********************************************************************

;	entry - CX - number of bytes to process
;		SI - offset of string to be processed
;		CSRPTR - b$INBUF pointer to cursor
;		EOLPTR - b$INBUF pointer to end-of-line
;		INSFLG - insert mode, 0=overwrite, 1=insert

PRTCHR:
	PUSH	BX		;save registers used to stack
	PUSH	DX

	CALL	SETLOC		;set display columns / UPDPTR

;	set default values of insertion pointer BX and byte
;	  number DX

	MOV	DX,CX		;set number of bytes to insert
	MOV	BX,CSRPTR	;and the b$INBUF point to start

;	test if insertion or overwrite

	TEST	INSFLG,0FFH	;test for insertion
	JZ	PRTCH2		;if not, overwrite, jump

;	try to allocate DX bytes at b$INBUF[BX] for insertion

	CALL	ALCBYT		;allocate new space in b$INBUF
	JC	PRTCH4		;if not enough room, then jump
	JMP	SHORT PRTCH3	;jump to common code

;      overwrite - allocate any bytes that are appended to b$INBUF

PRTCH2:
	SUB	DX,EOLPTR	;DX=CX-EOLPTR
	ADD	DX,BX		;DX=CX-(EOLPTR-CSRPTR)
	OR	DX,DX		;test if any characters to append
	JLE	PRTCH3		;if not, just jump to finish up
	MOV	BX,EOLPTR	;insertion pointer is at b$INBUF EOL
	CALL	ALCBYT		;allocate new space in b$INBUF
	JC	PRTCH4		;if not enough room, then jump
	MOV	BX,CSRPTR	;restore pointer to cursor location

;	BLKKAN converts any KANJI bytes whose partners are modified
;	  into ASCII spaces. (KANJI only)
;	PUTCHR puts the character bytes entered into b$INBUF.
;	UPDATE updates the display screen to reflect the new contents
;	  of b$INBUF.

PRTCH3:
	CALL	PUTCHR		;put new characters in b$INBUF
	CALL	UPDATE		;update screen display
	JMP	SHORT PRTCH5	;processing successful - jump

;	if error occurred on allocation, output a control-G (BELL)

PRTCH4:
	CALL	OUTBEL		;output BELL character for error

;	done - restore registers and return

PRTCH5:
	POP	DX		;restore registers
	POP	BX
	RET			;and return to caller

;********************************************************************
;	ALCBYT - insert DX new ASCII spaces into b$INBUF indexed
;		 by BX.  The substring from BX to the end-of-line
;		 is moved to the right DX places.
;********************************************************************

;		 entry - BX - b$INBUF pointer of insertion
;			 DX - number of spaces to insert

;		 exit -  PSW.C=0 - insertion successful
;			 PSW.C=1 - no room - buffer unchanged

ALCBYT:
	PUSH	AX		;save registers on stack
	PUSH	CX
	PUSH	SI
	PUSH	DI

;	test for room in b$INBUF

	MOV	CX,EOLPTR	;get present EOL index
	ADD	CX,DX		;add insertion count
	CMP	CX,BUFLEN	;test if room in buffer
	JBE	ALCBY1		;if room, then jump

;	no room - set PSW.C=1 and return

	STC			;set carry bit in PSW
	JMP	SHORT ALCBY3	;and jump to return

;	move substring in b$INBUF located from index BX to EOLPTR
;	  over DX bytes to the right

ALCBY1:
	PUSH	BX		;save insertion pointer
	MOV	CX,EOLPTR	;get end-of-line value
	SUB	CX,BX		;now EOLPTR-BX
	INC	CX		;EOLPTR-BX+1 = length of substring
	MOV	BX,EOLPTR	;get end-of-line value
	STD			;set flag for decrementing SI/DI
	LEA	SI,b$INBUF[BX] ;get source offset
	MOV	DI,SI		;move offset to destination
	ADD	DI,DX		;add bytes to move to right
	REP	MOVSB		;move b$INBUF substring
	CLD			;clear flag
	POP	BX		;restore insertion pointer

;      put in ASCII spaces in new locations

	MOV	AL,ASC_SP	;set AL to ASCII space
	LEA	DI,b$INBUF[BX] ;get address of allocation
	MOV	CX,DX		;get count of bytes allocated
	REP	STOSB		;put ASCII spaces in them

;	update end-of-line pointer

	ADD	EOLPTR,DX	;add number of new bytes

;	signal successful insertion

ALCBY2:
	CLC			;carry cleared for success

;	done - restore registers and return

ALCBY3:
	POP	DI		;restore registers
	POP	SI
	POP	CX
	POP	AX
	RET			;and return to caller

;********************************************************************
;	BLKKAN - change KANJI bytes to ASCII spaces if their
;		 partners are being modified. (KANJI only)
;********************************************************************

;	entry - BX - b$INBUF index of start of modification
;		CX - size of string modification


;********************************************************************
;	PUTCHR - put new character(s) into b$INBUF
;********************************************************************

;	entry - BX - b$INBUF pointer to start of insertion
;		CX - number of bytes to insert
;		SI - pointer to string being inserted
;		CSRPTR - b$INBUF pointer to cursor
;		EOLPTR - b$INBUF pointer to end-of-line
;	exit  - CSRPTR - updated b$INBUF pointer to cursor

PUTCHR:
	PUSH	SI		;save registers on stack
	PUSH	DI

;	move CX bytes from string SI to b$INBUF indexed at BX

	PUSH	CX		;save insertion length
	LEA	DI,b$INBUF[BX] ;get insertion address
	REP	MOVSB		;put in characters from string at SI
	POP	CX		;restore insertion length

;	adjust CSRPTR for new character(s) inserted

	ADD	CSRPTR,CX	;move CX bytes to the right

	POP	DI		;restore registers from stack
	POP	SI
	RET			;and return from stack

;********************************************************************
;	DELCSR - delete character positioned at the cursor
;********************************************************************

DELCSR:
	PUSH	BX		;save register on the stack

	CALL	SETLOC		;set display columns / UPDPTR

	MOV	BX,CSRPTR	;get cursor pointer into b$INBUF
	CMP	BX,EOLPTR	;test if cursor at EOL
	JE	DELCS1		;at EOL, do nothing - just return
	CALL	DELETE		;delete character on cursor
	CALL	UPDATE		;and update the display
DELCS1:
	POP	BX		;restore register from stack
	RET			;and return to caller

;********************************************************************
;	DELLFT - delete character positioned left of the cursor
;		 if at start of line, delete character at cursor
;********************************************************************

DELLFT:
	PUSH	BX		;save register on the stack

	CALL	SETLOC		;set display columns / UPDPTR

	MOV	BX,CSRPTR	;get cursor pointer into b$INBUF
	OR	BX,BX		;test if cursor at start of line
	JZ	DELLF2		;at start, try to delete at cursor

	DEC	BX		;move pointer to char before cursor
	DEC	CSRPTR		;also move cursor back
	JMP	SHORT DELLF3	;jump to finish processing

;	at line start - delete character at cursor

DELLF2:
	CMP	BX,EOLPTR	;test if empty line
	JE	DELLF4		;if so, then just return

;	delete the character and update

DELLF3:
	CALL	DELETE		;delete character before cursor
	CALL	UPDATE		;update the display screen
DELLF4:
	POP	BX		;restore register from stack
	RET			;and return to caller

;********************************************************************
;	DELETE - delete character at BX and move remaining
;		 substring to the left to fill in
;********************************************************************

DELETE:
	PUSH	CX		;save registers on the stack
	PUSH	DX
	PUSH	SI
	PUSH	DI

;	If interim character is pending, just output bell and return.
;	Cursor is on KANJI2 byte only from DELLFT.


	MOV	UPDPTR,BX	;update at start of substring
	MOV	DX,1		;assume one byte to delete
	MOV	CX,EOLPTR	;CX will be length - get EOL pointer
	SUB	CX,BX		;CX=EOL-CSR
	INC	CX		;CX=EOL-CSR+1 - length of substring
	SUB	CX,DX		;subtract length of char deleted
	LEA	DI,b$INBUF[BX] ;get destination pointer
	MOV	SI,DI		;source is destination...
	ADD	SI,DX		;plus length of the deleted char
	REP	MOVSB		;move the substring in b$INBUF
	SUB	EOLPTR,DX	;move EOL pointer back
	POP	DI		;restore the registers from stack...
	POP	SI
	POP	DX
	POP	CX
	RET			;and return to caller

;********************************************************************
;	TRUNC - truncate input line at cursor
;********************************************************************

TRUNC:
	PUSH	BX		;save register on stack

	CALL	SETLOC		;set display columns / UPDPTR
	MOV	BX,CSRPTR	;get cursor b$INBUF index

;	cursor cannot be on KANJI2 byte - code removed.

	MOV	EOLPTR,BX	;truncate the line at the cursor
	MOV	b$INBUF[BX],0	;set end-of-line byte
	CALL	UPDATE		;update the screen display

	POP	BX		;restore register from stack
	RET			;return to caller

;********************************************************************
;	BEGIN - move cursor to start of input line
;********************************************************************

BEGIN:
	PUSH	BX		;save register on stack

	CALL	SETLOC		;set display columns / UPDPTR
	XOR	BX,BX		;clear BX
	MOV	CSRPTR,BX	;move cursor to start of input line
	CALL	UPDATE		;update the screen display

	POP	BX		;restore register from stack
	RET			;return to caller

;********************************************************************
;	APPEND - move cursor to end of input line
;********************************************************************

APPEND:
	PUSH	BX		;save register on stack

	CALL	SETLOC		;set display columns / UPDPTR
	MOV	BX,EOLPTR	;set to EOL pointer
	MOV	CSRPTR,BX	;move cursor to end of input line
	CALL	UPDATE		;update the screen display

	POP	BX		;restore register from stack
	RET			;return to caller

;********************************************************************
;	ERASE - delete entire input line
;********************************************************************

ERASE:
	PUSH	BX		;save register on stack

	CALL	SETLOC		;set display columns / UPDPTR
	XOR	BX,BX		;clear BX
	MOV	CSRPTR,BX	;set cursor to start of input line
	MOV	UPDPTR,BX	;set update to start of input line
	MOV	EOLPTR,BX	;set EOL to start of input line
	CALL	UPDATE		;update the screen display
	MOV	b$INBUF,BL	;put end-of-line byte at start

	POP	BX		;restore register from stack
	RET			;return to caller

;********************************************************************
;	CSRLFT - move cursor once to the left
;********************************************************************

CSRLFT:
	PUSH	AX		;save registers on stack
	PUSH	BX

	MOV	BX,CSRPTR	;get b$INBUF cursor index
	OR	BX,BX		;test if cursor at line beginning
	JZ	CSRLF2		;if so, then just jump to exit

;	backspace over byte at cursor
;	if extra display blank is now on cursor, backspace over it

	DEC	BX		;get byte before it
	CALL	OUTBS		;backspace over byte at cursor
	DEC	CSRPTR		;set pointer to previous byte
CSRLF2:
	POP	BX		;restore registers from stack
	POP	AX
	RET			;return to caller

;********************************************************************
;	CSRRGT - move cursor once to the right
;		 move over both bytes of KANJI character
;********************************************************************
;Entry	BX = pointer in INPSTR

CSRRGT:
	PUSH	AX		;save registers on stack
	PUSH	BX

	MOV	BX,CSRPTR	;get b$INBUF cursor index

	CMP	BX,EOLPTR	;test if cursor is at EOL
	JNE	CSRRG0
	POP	BX
	POP	AX
	MOV	AL,ASC_SP	; if at EOL then put out a space
	JMP	ASCCHR
CSRRG0:
;    CMP     BX,EOLPTR	     ;test if cursor is at EOL
;    JE      CSRRG4	     ;if so, then just jump to exit

;	if byte at cursor is KANJI1, then output it and its
;	  partner and then backspace once
;	do not backspace, but just output both characters


	MOV	AL,b$INBUF[BX] ;get KANJI2 (or ASCII) byte
	CALL	B$TTY_SOUT	;and output it also
;      if cursor over extra blank, then pass over it


;	update CSRPTR and call FRCLIN

	INC	CSRPTR		;update cursor pointer
	CALL	FRCLIN		;force cursor on new line if needed
CSRRG4:
	POP	BX		;restore registers from stack
	POP	AX
	RET			;and return to caller

;*********************************************************************
;    FORWRD - move cursor forward one word - first alphanumeric
;	      character after the first non-alphanumeric one
;*********************************************************************

FORWRD:
	PUSH	BX		;push register on stack
	MOV	BX,CSRPTR	;get cursor pointer
	DEC	BX		;BX is at cursor after INC next
FORWR1:
	INC	BX		;move pointer forward one byte
	CMP	BX,EOLPTR	;test if at line end
	JZ	FORWR3		;if so, then jump
	CALL	TSTALN		;test if byte is alphanumeric
	JC	FORWR1		;if so, then loop back
FORWR2:
	CMP	BX,EOLPTR	;test if at line end
	JZ	FORWR3		;if so, then jump
	INC	BX		;move pointer forward one byte
	CALL	TSTALN		;test if byte is alphanumeric
	JNC	FORWR2		;if not, then loop back
FORWR3:
	CMP	BX,CSRPTR	;is cursor at new value?
	JE	FORWR4		;if so, then jump to finish up
	CALL	CSRRGT		;move cursor right, CSRPTR updated
	JMP	SHORT FORWR3	;try for next one
FORWR4:
	POP	BX		;restore register from stack
	RET			;return to caller

;*********************************************************************
;    BAKWRD - move cursor backward one word - before first
;	      non-alphanumeric character after first alphanumeric
;*********************************************************************

BAKWRD:
	PUSH	BX		;push register on stack
	MOV	BX,CSRPTR	;get cursor pointer
BAKWR1:
	OR	BX,BX		;test if at line start
	JZ	BAKWR3		;if so, then jump
	DEC	BX		;move pointer back one byte
	CALL	TSTALN		;test if byte is alphanumeric
	JNC	BAKWR1		;if not, then loop back
BAKWR2:
	OR	BX,BX		;test if at line start
	JZ	BAKWR3		;if so, then jump
	DEC	BX		;move pointer back one byte
	CALL	TSTALN		;test if byte is alphanumeric
	JC	BAKWR2		;if so, then loop back
	INC	BX		;overshot, move to first alphanum
BAKWR3:
	CMP	BX,CSRPTR	;is cursor at new value?
	JE	BAKWR4		;if so, then jump to finish up
	CALL	CSRLFT		;move cursor left, CSRPTR updated
	JMP	SHORT BAKWR3	;try for next one
BAKWR4:
	POP	BX		;restore register from stack
	RET			;return to caller

;*********************************************************************
;    TSTALN - set carry if b$INBUF[BX] points to an alphanumeric
;	      character (KANJI, 0-9, A-Z, a-z).
;*********************************************************************

TSTALN:
	PUSH	AX		;save register on stack
	MOV	AL,b$INBUF[BX] ;get character to test
	CMP	AL,"0"		;test against lowest numeric
	JB	TSTAL1		;if less, then non-alphanumeric
	CMP	AL,"9"		;test against highest numeric
	JBE	TSTAL2		;if not greater, then alphanumeric
	CMP	AL,"A"		;test against lowest uppercase
	JB	TSTAL1		;if less, then non-alphanumeric
	CMP	AL,"Z"		;test against highest uppercase
	JBE	TSTAL2		;if not greater, then alphanumeric
	CMP	AL,"a"		;test against lowest lowercase
	JB	TSTAL1		;if less, then non-alphanumeric
	CMP	AL,"z"		;test against highest lowercase
	JBE	TSTAL2		;if not greater, then alphanumeric
TSTAL1:
	CLC			;clear carry for non-alphanumeric
	JMP	SHORT TSTAL3	;jump to return
TSTAL2:
	STC			;set carry for alphanumeric
TSTAL3:
	POP	AX		;restore register from stack
	RET			;return to caller

;********************************************************************
;	SETLOC - set display column amounts for the cursor and
;		   end-of-line positions
;		 set default value of UPDPTR to CSRPTR
;********************************************************************

SETLOC:
	PUSH	BX		;save register on stack

	MOV	BX,CSRPTR	;get cursor pointer value
	MOV	UPDPTR,BX	;set default value for update
	MOV	CSRLOC,BX	;store for later use in UPDATE
	MOV	BX,EOLPTR	;get eol pointer value
	MOV	EOLLOC,BX	;store for later use in UPDATE

	POP	BX		;restore register on stack
	RET			;and return to caller


;********************************************************************
;	GETLOC - take b$INBUF pointer in BX and add the number of
;		 extra blanks to return the display column in BX.
;********************************************************************


;********************************************************************
;	UPDATE - update screen display with the contents of b$INBUF

;	entry - CSRLOC - display column of old b$INBUF cursor
;		EOLLOC - display column of old b$INBUF EOL
;		CSRPTR - b$INBUF index of new cursor position
;		EOLPTR - b$INBUF index of new EOL position
;		UPDPTR - b$INBUF index to start update
;********************************************************************

UPDATE:
	PUSH	AX		;save registers on the stack...
	PUSH	BX
	PUSH	CX
	PUSH	DX

;	put update pointer in DX - decrement if on KANJI2 byte
;	cursor cannot be on KANJI2 byte - remove code.

	MOV	DX,UPDPTR	;get update pointer

;	backspace display to update pointer

	MOV	CX,CSRLOC	;get old cursor display column
	SUB	CX,DX		;result is number of backspaces
	JCXZ	UPDA06		;if no backspaces, then jump
UPDA05:
	CALL	OUTBS		;backspace the display
	LOOP	UPDA05		;repeat until at start of update

;      output string in b$INBUF from update start to EOL

UPDA06:
;   MOV     BX,DX	    ;start output at update pointer
	MOV	BX,UPDPTR	;start output at update pointer
UPDA07:
	CMP	BX,EOLPTR	;test if string has been output
	JE	UPDA09		;if so, then jump


;	output the character at b$INBUF[BX]

	MOV	AL,b$INBUF[BX] ;get buffer character
	CALL	B$TTY_SOUT	; output character to screen
	CMP	AL,0FFH		; Test if char was 0ffH
	JNE	UPDA08_NOT_FF	; Brif not
	CALL	B$TTY_SOUT	; Send it again
UPDA08_NOT_FF:			
	INC	BX		;advance update pointer for next
	JMP	SHORT UPDA07	;and try to process it

;	blank out trailing characters if new string was shorter
;	  backspace cursor back to EOL

UPDA09:
	MOV	CX,EOLLOC	;CX has display column of old EOL
	SUB	CX,BX		;CX now has old-new difference
	OR	CX,CX		;test if new string was shorter
	JLE	UPDA12		;if not, then jump
	PUSH	CX		;save shrinkage count
	MOV	AL,ASC_SP	;put in ASCII space for output
UPDA10:
	CALL	B$TTY_SOUT	; output the space to cover old string
	LOOP	UPDA10		;loop until old string covered

	POP	CX		;get shrinkage count again
UPDA11:
	CALL	OUTBS		;output backspace to screen
	LOOP	UPDA11		;loop until back to new EOL

;	backspace to location of the new cursor to complete update

UPDA12:
	MOV	CX,BX		;put new EOL display column in CX
	MOV	BX,CSRPTR	;BX has new cursor index
	SUB	CX,BX		;get backspaces from EOL to cursor

	JCXZ	UPDA14		;if no backspaces, then jump
UPDA13:
	CALL	OUTBS		;output backspace
	LOOP	UPDA13		;loop until back to new cursor
	JMP	SHORT UPDA15	;jump to exit

;	cursor is at end of input line - if also at end of display
;	  line, output space and backspace for new display line

UPDA14:
	CALL	FRCLIN		;force new line if present is full

;	done - restore register and return

UPDA15:
	POP	DX		;restore registers from stack
	POP	CX
	POP	BX
	POP	AX
	RET			;and return to caller

;********************************************************************
;	OUTBS - output backspace to screen
;********************************************************************

OUTBS:
	PUSH	AX		;save register on stack

	MOV	AL,b$IOFLAG	
	AND	AL,RED_INP OR RED_OUT ; redirected input and output?
	CMP	AL,RED_INP OR RED_OUT 
	JZ	OUTBX		; brif so -- don't touch screen

	PUSH	DX		; save register
	MOV	DX,b$CURSOR	; get cursor location (1,1) relative
	DEC	DH		; decrement column and set flags
	JNZ	OUTBS1		; jump if not now at column 0
	MOV	DH,BYTE PTR b$CRTWIDTH ; column 0 - put in one past end
	DEC	DX		; and decrement row counter
OUTBS1:
	CALL	B$SCNLOC 	;display cursor at new location

	POP	DX		; restore register
OUTBX:				
	POP	AX		;restore register from stack
	RET			;and return to caller

;********************************************************************
;	OUTBEL - output BELL character to screen
;********************************************************************

OUTBEL:
;   PUSH    AX		    ;save register on stack

;   MOV     AL,CNTL	    ; put control char flag in
;   CALL    B$TTY_SOUT	    ;and output it to the speaker
;   MOV     AL,CTL_G	    ;put control-G (BELL) in for output
;   CALL    B$TTY_SOUT	    ;and output it to the speaker

;   POP     AX		    ;restore register from stack
	cCALL	B$BLEEP	; sound bell on terminal
	RET			;and return to caller

;********************************************************************
;	FRCLIN - forces the cursor to the next display line if the
;		   present display line is full
;********************************************************************

FRCLIN:
	PUSH	AX		;save registers on stack
	PUSH	BX

	CALL	B$SCRN_GPOS 	; get column position of cursor
	CMP	AH,BYTE PTR b$CRTWIDTH ; test if at end of display line
	JNE	FRCLI3		;if not, then jump

;	display line full - if at b$INBUF EOL, then output space
;	  and backspace

	MOV	BX,CSRPTR	;get cursor index
	CMP	BX,EOLPTR	;test if at b$INBUF EOL
	JNE	FRCLI1		;if not, then jump
	MOV	AL,ASC_SP	;get ASCII space
	CALL	B$TTY_SOUT	;and output it
	CALL	OUTBS		;then output the backspace
	JMP	SHORT FRCLI3	;jump to exit

;	not EOL - byte must be KANJI1 or ASCII

FRCLI1:

;	ASCII byte - output it and then backspace over it

	MOV	AL,b$INBUF[BX] ;get ASCII byte
	CALL	B$TTY_SOUT	;and output it
	CALL	OUTBS		;backspace over it
FRCLI3:
	POP	BX		;restore registers from stack
	POP	AX
	RET			;return to caller

;********************************************************************
;	TSTKJ1 - test for first byte of KANJI in b$INBUF[BX]
;********************************************************************

;	entry - BX - b$INBUF index to byte tested

;	exit - PSW.C=0 - byte tested is not KANJI1
;	       PSW.C=1 - byte tested is KANJI1



;********************************************************************
;	TSTKJ2 - test for second byte of KANJI in b$INBUF[BX]
;********************************************************************

;	entry - BX - b$INBUF index to byte tested

;	exit - PSW.C=0 - byte tested is not KANJI2
;	       PSW.C=1 - byte tested is KANJI2


sEnd	CN_TEXT 		

	END			;textual end of module B$RDLIN
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwpal.asm ===
TITLE	PALETTE - BASCOM palette support
;***
; PALETTE - BASCOM palette support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - PALETTE Statement:
;
;      PALETTE
;	  |
;	B$PAL0
;
;
; - PALETTE Statement:
;
;      PALETTE color number, display color
;	  |
;	B$PAL2
;
;
; - PALETTE USING Statement:
;
;      PALETTE USING array(array index)
;	  |
;	B$PALU
;
;******************************************************************************
	INCLUDE rmacros.inc	; Runtime Macro Defintions
	INCLUDE switch.inc

	useSeg	_BSS
	useSeg	GR_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE array.inc

sBegin	_BSS
externW b$PalPut
externW b$PalSet
externW b$PalReset
sEnd	_BSS

sBegin	GR_TEXT 		
assumes CS,GR_TEXT		

	SUBTTL	PALETTE, PALETTE USING support


	externNP B$ERR_FC	
	externNP B$SCINIT	; Performs screen initialization
	externNP B$ComputeSpace

;***
; B$PAL0 - PALETTE (no arguments)
;
; Purpose:
;	This routine supports the PALETTE statement with no arguments which
;	resets the palette to the modes initial values.
; Input:
;	NONE
; Output:
;	NONE
; Modifies:
;	NONE
; Exceptions:
;	Can jump to B$ERR_FC
;****
cProc	B$PAL0,<FAR,PUBLIC,FORCEFRAME> ; set up frame for error recovery
cBegin

	CALL	B$SCINIT	; initialize screen if not already done
	CALL	[b$PalReset]	;no args - initialize palette
	JB	PALERR		;branch if error occurred
cEnd

;***
; B$PAL2 - PALETTE #logical color,#actual color
;
; Purpose:
;	This routine supports the PALETTE statement with arguments to define
;	the Color mapping for a specific Attribute (palette index).
; Input:
;	Attribute = logical color
;	Color	  = actual  color
; Output:
;	NONE
; Modifies:
;	NONE
; Exceptions:
;	Can jump to B$ERR_FC
;****
cProc	B$PAL2,<FAR,PUBLIC>
parmW	Attribute
parmD	Color
cBegin

	CALL	B$SCINIT	; initialize screen if not already done
	MOV	BX,Attribute
	MOV	AX,OFF_Color	;lo order word of color
	MOV	DX,SEG_Color	;hi order word of color
	CALL	[b$PalPut]
	JB	PALERR

PALRET: 			
cEnd

PALERR: JMP	B$ERR_FC

;***
; B$PALU - PALETTE USING array name(array index)
;
;Purpose:
; This routine supports the PALETTE USING statement which defines the actual
; colors to use for Basic's logical colors, from an integer array starting at a
; particular index. The compiler insures the array is I2 or I4. The array
; descriptor is used by the low-levels to insure there are sufficient entries
; remaining to the end of the array for palette loading and to determine if the
; elements are I2 or I4.
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Input:
; fpData = far ptr to start of array data
; pAd	 = pointer to array descriptor of interest
;
;Output:
; NONE
;
;Modifies:
; NONE
;
;Exceptions:
;	Can jump to B$ERR_FC
;****

cProc	B$PALU,<FAR,PUBLIC>,<ES,SI>
parmD	fpData			;far ptr to start of array data
parmW	pAd			;pointer to array descriptor of interest
cBegin
	CALL	B$SCINIT	; initialize screen if not already done
	cCall	B$ComputeSpace,<fpData,pAd>
				;[DX:AX] = space from address to end of array
				;[ES:SI] = starting address
	mov	bx,pAd
	mov	cx,[bx].AD_cbElement ;get the element size
	shr	dx,1		;divide size by 2 for count of I2 elements
	rcr	ax,1
	cmp	cx,4
	jne	PalI2		;skip next divide if I2 elements
	shr	dx,1		;divide size by 4 for count of I4 elements
	rcr	ax,1
PalI2:				;[DX:AX] = element count
	or	dx,dx		;hi order word of element count 0?
	jz	SmallCnt	;go if not, otherwise max out the count
	mov	ax,65535	;[AX]	 = element count	[7]
SmallCnt:			;[ES:SI] = starting address	[7]
				;[CX]	 = element size
	CALL	[b$PalSet]	;set the palette
	JB	PALERR
cEnd


sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwplays.asm ===
TITLE	GWPLAYS - GW BASIC 2.0 Multi Voice Play
;***
; GWPLAYS - GW BASIC 2.0 Multi Voice Play
;
;	Copyright <C> 1986 - 1988, Microsoft Corporation
;
;Purpose:
;	Multi Voice Play statement processor
;
; BASIC Syntax mapping to included runtime entry points:
;
; - PLAY Statement:
;
;      PLAY string
;	 |
;      B$SPLY
;
;    NOTE: the more advanced syntax of 'PLAY string, string, ...' (i.e.
;    multi-voiced PLAY) will be accepted by the compiler. For all but the
;    last parameter (which is passed to B$SPLY), defaulted parameters will
;    generate a call to B$PL1, and specified parameters get passed to B$PL0
;    both of these, in turn, just generate an Advanced Feature error.
;    NOTE 2: the above comment doesn't apply to bascom 30.  The compiler
;	will not generate calls to B$PL0 and B$PL1.  They will be flagged as
;	syntax errors.	B$PL0 and B$PL1 will not be present for BASCOM 30.
;	The code to support multivoice play will be left for future reference,
;	but it will need to be changed to the new style interface (stack based)
;	if a multi voice version is ever produced.
;
;******************************************************************************

	INCLUDE switch.inc	; switch file [new]
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	_DATA		
	USESEG	_BSS		
	USESEG	SN_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE	ibmunv.inc	
	INCLUDE	rtps.inc	
	INCLUDE idmac.inc	
	INCLUDE string.inc	

	.RADIX	10

;	Two new macros Alloc & DeclareB/DeclareW are defined here.
;	The main purpose of Declare macro is to allocate given number of
;	bytes (static variable) and initialize it to the specified value.
;	Additionally, it declares an EQUate for the specified variable
;	for automatic indexing if FS_MVOICE is TRUE. The index register
;	assumed is SI. Actually, the variable defined has a trailing underscore
;	and the indexed EQUate is identical to the name supplied to this macro.
;	Alloc is just a helper macro.

Alloc	MACRO	v,nm,init,siz	
static&v	<nm&_>,<init>,<siz>

nm	EQU	nm&_		
	ENDM

DeclareB	MACRO	nm,init,siz	
Alloc	B,<nm>,<init>,<siz>
	ENDM			

DeclareW	MACRO	nm,init,siz	
Alloc	W,<nm>,<init>,<siz>
	ENDM			


sBegin	_DATA			

externW	B$AC			

sEnd				

sBegin	_BSS			

	externW B$MCLTAB 	;defined in GWDATA.ASM
	externW B$MCLLEN 	;defined in GWDATA.ASM
	externW B$MCLPTR 	;defined in GWDATA.ASM

	externB B$MMODE		;defined in GWINI.ASM
	externB B$BEATS		;defined in GWINI.ASM
	externB B$NOTE1L 	;defined in GWINI.ASM
	externB B$NOTELN 	;defined in GWINI.ASM
	externB B$NOTFLG 	;defined in GWINI.ASM
	externB B$MSCALE 	;defined in GWINI.ASM
	externB B$OCTAVE 	;defined in GWINI.ASM
	externB b$VTYP		
	externW b$curlevel	;current program level



DeclareB MQUEFL,?,1		
DeclareB PLYPRS,?,1		
DeclareW STRDSC,?,NUM_VOICES	
DeclareW VSTACK,?,<NUM_VOICES*NUM_VSTACK> 
DeclareW VSTBAS,?,NUM_VOICES	
DeclareW VSTOFF,?,NUM_VOICES	

sEnd	_BSS			

assumes CS,SN_TEXT		
sBegin	SN_TEXT 		

;	externNP B$MCLXEQ	;execute substring routine

	externNP B$DONOTE	;oem routine
	externNP B$STRTSD	
	externNP B$SNDWAT	

	externNP B$ERR_FC	
	externNP B$ERR_OM	
	externNP B$ERR_TM	; Type mismatch error

	externNP B$SETMCL	
	externNP B$MACCMD	
	externNP B$FETCHR	
	externNP B$DECFET	
	externNP B$FETCHZ	
	externNP B$VALSC2	
	externNP B$BREAK_CHK	
	externNP B$GETSTKC	; Check stack
	externNP B$SCNVAR	; get descriptor from VARPTR$

	externNP B$STDALCALLTMP ; **** liberate temporaries ****

;PLAY Statement
;Syntax:
;   PLAY ON
;   PLAY OFF
;   PLAY STOP
;   PLAY [A$] [, [B$] [, [C$]]]   - multi-voice play

;PLAY is made up of a forground task and a background task.  A queue exists
;for each voice through which the forground task passes the background task
;Commands and Syncronization information.  One SYNC byte is placed in each
;voice queue at the start of each PLAY statement.  All commands which are
;produced by the PLAY statement follow the SYNC byte in the queue.
;When the background task encounters the SYNC byte, it disables that voice
;until it has received a SYNC byte for each voice and PLYBGC .GT. 0.  This
;mechanism insures that all voices for a play statement will begin at
;the same time, even if one of the voices in the previous play statement
;was shorter than the rest.

;A String-Pointer stack is associated with each voice to allow each voice
;string to include (nest) other voice strings via the X macro-language
;command.

;PLAY Algorithm:
;    Initialize a str-ptr stack for every voice.
;    Parse n strings (saving ptrs to string temps in STRDSC(i)).
;    For each voice,
;      Put SYNC byte at start of each voice queue
;      Release Temp string desc and push str ptr&len to voice's str-ptr stack.
;    For each voice,
;1)    Fill each queue as far as possible (till end-of-string or end-of-queue)
;      if 1st pass
;	 B$STRTSD (start clock int routine, all voices)
;      if no voices active and all strings are not empty, B$STRTSD(all voices)
;	 (This is a safety valve to insure BASIC will never hang during PLAY)
;    If all strings have not been completely consumed,
;      goto step 1
;  If Music Forground, wait till all voice activity halts



PLAYS:
; Entry point for the PLAY statement.  Test to see which of the
; allowed forms has been specified.

;***
; B$PL0, B$PL1, B$SPLY - Play   <sexp>... statement
;
; Purpose:
;	Runtime Entry Points.
;	B$PL0 and B$PL1 are alternate PLAY Statement preamble entry points
;		B$SPLY is called with the last parm, and it actually executes
;		the statement.
;	B$PL0   called if a parm is specified
;	B$PL1   called if a parm is defaulted
;	B$SPLY   called for last parm (may be the only parm as well)
;
;	 Parse the strings from the program statement, and set up the pointers
;	 in the string stacks.
;
; Input:
;	sdPlay == string descriptor of a single argument (B$PL0 & B$SPLY only -
;		no input is given for B$PL1)
; Output:
;	NONE
; Modifies:
;	NONE
;****


cProc	B$SPLY,<PUBLIC,FAR>,<SI> 
parmSD	sdPlay			
cBegin				
	cCALL	B$CHKINI
	GetpSD	BX,sdPlay	;BX = psd for play string
	MOV	STRDSC,BX	; save str desc for B$PARSER.
	cCALL	B$PARSE0	; Go process everything
	MOV	AX,b$curlevel	;deallocate all temps >= current level
	cCALL	B$STDALCALLTMP	
cEnd				

;***
;B$CHKINI
;
;PURPOSE:
;	Initialize runtime variables related to music if starting play statement
;
;ENTRY:
;
;EXIT:
;
;MODIFIES:
;	AX,CX,SI
;
;****

cProc	B$CHKINI,<NEAR>		
cBegin				

				;exit -- bx is preserved

	XOR	AX,AX		

	MOV	[B$MCLTAB],OFFSET PLYTAB ;B$MCLTAB points to play command table
				; for B$MACCMD
	MOV	[MQUEFL],AL	; indicates no music cmds have been queued

; Initialize the string stacks for use while parsing the play strings.
; These stacks are used to support the X music command which functions
; like a subroutine call.

	MOV	CX,OFFSET DGROUP:VSTACK ; *cx = string stack for voice 1
inistl:
	MOV	VSTOFF,AX	; reset offset for voice si
	MOV	VSTBAS,CX	; set stack base ptr for voice si
	MOV	STRDSC,AX	; reset string desr ptr for voice si
chkret:

cEnd				; End of B$CHKINI

;
;***
;B$PARSE0
;
;PURPOSE:
;	Pre-PARSER for play string
;
;ENTRY:
;
;EXIT:
;
;USES:
;	per convention
;
;****

cProc	B$PARSE0,<NEAR>	
cBegin				; **** HERE AFTER LAST PARM ****

; Release string temps in reverse order (because its a stack)

	MOV	[PLYPRS],NUM_VOICES ;NUM_VOICES strings have been parsed


SETSTL:

	MOV	BX,STRDSC	; *bx = temp str desc for voice(si)
	OR	BX,BX
	JE	EMPTYS		;branch if no string was parsed
	CALL	B$SETMCL 	;set B$MCLPTR, B$MCLLEN to str @bx
	cCALL	B$PUTSTR	;save B$MCLPTR, B$MCLLEN on voicen's stack
	DEC	[PLYPRS]	;one less string has been parsed
emptys:
	JMP	SHORT B$PARSER	

cEnd	<nogen>			; End of B$PARSE0

;***
;B$PARSER fills the background-music queues as follows:
; Repeat
;   For Each voice
;     while (input string is not empty) and
;	    (room exists in voice's queue for 1 command)
;	Call B$MACCMD to process next command in string.
;	(This causes some routine in PLYTAB to be called which may try to
;	 queue information for the background task into that voice's queue.
;   If 1st pass, DI, bump PLYBGC, cCALL	B$STRTSD(7) to initiate background task
; Until all voice strings are empty
; If music-forground, wait until PLYMSK=0
;****

cProc	B$PARSER,<NEAR>	
cBegin				

PARSER_BEGIN:			


; Get music macro commands from the string for this voice until the
; queue for this voice fills or we hit the end of the string.

PRSL10:
	cCALL	B$GETSTR		;Get B$MCLPTR, B$MCLLEN for [voicen]


	CMP	[B$MCLLEN],0	; Check if end of string
	JNE	PRSCONT		; Brif more in string, process it
	CMP	VSTOFF,0	; Test if string was nested by X command
	JNE	PRSL10		; Brif so, jump to return to next string up
	JMP	SHORT PRSLPX	; Else, the top level string s done 
PRSCONT:			; Continue with parsing
	PUSH	[B$MCLPTR]	;SAve the current string pointers
	PUSH	[B$MCLLEN]	;  in case the queue overflows

	CALL	B$MACCMD 	;Parse one command from this string
	JB	PRSL20		;Quit this loop if the queue overflowed
	POP	AX		;Clear old pointers from stack
	POP	AX
	cCALL	B$PUTSTR		;save new B$MCLPTR, B$MCLLEN for [voicen]
	JMP	SHORT PRSL10	;continue trying to fill this queue

; Had a queue overflow on the last call to B$MACCMD.  Restore the original
; string pointers so that the command which caused the overflow can be
; reprocessed the next time.
PRSL20:
	POP	[B$MCLLEN]	;RESTORE the old pointers
	POP	[B$MCLPTR]
	cCALL	B$PUTSTR		;And  put them back on the local stack

PRSLPX:


; Test if the user wants to break
	CALL	B$BREAK_CHK	;CTRL-BREAK?

; Have made a pass through the strings.  If this is pass 1 and there
; is data in any of the queues, then start the music playing.

	TEST	PLYPRS,LOW 128D
	JNZ	NOTPS1		;Brif not Pass 1
	OR	PLYPRS,LOW 128D ;Set parsed once flag
	CMP	MQUEFL,LOW 0
	JE	NOTPS1		;branch if no cmds have been queued for
				; this PLAY statement (no need to start
				; background task
	cCALL	B$STRTSD	;Start sounds

NOTPS1:

; Test if we are all done.  This occurs when the count of voice strings
; completely parsed (contained in PLYPRS) equals the number of voices.

	CMP	[PLYPRS],LOW 200O+NUM_VOICES
	JE	PRSDON		;Brif all NUM_VOICES strings parsed
	MOV	AL,LOW TSTVOC	;Ask the OEM if any voices are active
	cCALL	B$DONOTE	
	OR	AL,AL		;See what they had to say about it
	JNE	PARSER_BEGIN	; If there are active voices, then the
				;queue's are emptying, so go try to
				;parse the rest of the strings.

; If we get here, then it means that we are not done parsing the PLAY
; strings, the queues are full, but none of the voices are active.
; This should never occur, but IF it did, BASIC would be hung indefinitely.
; This simple safeguard ensures this will never happen.

	MOV	AL,LOW STRSND	;Function code to start music
	cCALL	B$DONOTE 	; Tell OEM to start playing the music
	JMP	PARSER_BEGIN	; and go parse the rest of the strings

; We are all done parsing the input strings.  If the music mode is
; Background, then we are done.  If mode is Foreground, we need to
; wait around until the sound stops.

PRSDON:
	cCALL	B$SNDWAT	;wait if Music Foreground

cEnd				; End of B$PARSER


;***
;B$PUTSTR
;Purpose:
;	Save B$MCLPTR, B$MCLLEN on Voice Stack for voice [VOICEN]
;Input:
;	[VOICEN] = voice id (0..2)
;	[B$MCLLEN]=number of bytes left in current string for this voice
;	[B$MCLPTR]=pointer to next byte in current string for this voice
;Output:
;	If stack overflows, an Out of Memory error is issued
;Modifies:
;	AX
;****

cProc	B$PUTSTR,<NEAR>,<BX,SI,DI>	
cBegin				

; Get the stack pointer for this string and check for stack overflow


	MOV	DI,VSTBAS	; di points to stack base for voice si
	MOV	BX,VSTOFF	; bx = offset for current top of stack
	CMP	BX,NUM_VSTACK	;Check if the stack is full
	JB	STKOK		;branch if still room on stack
	JMP	B$ERR_OM	;NO room, so signal out of memory error

				; Save the current data on the stack
STKOK:
	MOV	AX,[B$MCLPTR]
	MOV	[BX+DI],AX	;save string pointer on stack
	MOV	AX,[B$MCLLEN]
	MOV	[BX+DI]+2,AX	;save string length on stack
; Update the stack pointer to account for new stack size
	ADD	BX,4
	MOV	VSTOFF,BX	; save offset to top of stack

cEnd				; End of B$PUTSTR

;***
;B$GETSTR
;Purpose:
;	Set B$MCLPTR, B$MCLLEN for Voice [VOICEN]
;Input:
;	[VOICEN] = voice id (0..2)
;Output:
;	[B$MCLLEN]=number of bytes left in current string for this voice
;	[B$MCLPTR]=pointer to next byte in current string for this voice
;	If this voice's string has been completely consumed then
;	  PLYPRS is incremented and B$MCLLEN=0
;Modifies:
;	AX
;****

cProc	B$GETSTR,<NEAR>,<BX,SI,DI>	
cBegin				

; Get the stack pointer for this voice, and test if stack is empty

	MOV	BX,VSTOFF	; bx = offset for current top of stack
	MOV	[B$MCLLEN],BX	;length=0 if no more strings stacked
	OR	BX,BX
	JE	GETSTX		;brif no entries exist on voice's stack
	MOV	DI,VSTBAS	; DI points to stack base for voice SI

; Get the next set of entries from the stack.
GETSTL:
	SUB	BX,4		;Adjust stack pointer to next entry
	MOV	AX,[BX+DI]	;get string pointer from stack
	MOV	[B$MCLPTR],AX
	MOV	AX,[BX+DI]+2	;get string length from stack
	MOV	[B$MCLLEN],AX
	OR	AX,AX
	JNE	GETSTX		;exit if this string is not empty
	OR	BX,BX
	JNE	GETSTL		;brif more entries on voice's stack
	INC	[PLYPRS]	;Bump number of strings consumed

; Update the stack pointer, restore the registers, and get out
GETSTX:
	MOV	VSTOFF,BX	; save offset to top of stack

cEnd				; End of B$GETSTR

;--------------------------------------------------------------------------
; Music Macro Language command table
; This table contains all of the command characters allowed in the music
; language strings, and the entry points of the routines to process them

PLYTAB	LABEL	BYTE		

	DB	"A"		;The notes A-G
	DW	OFFSET PLYNOT
	DB	"B"
	DW	OFFSET PLYNOT
	DB	"C"
	DW	OFFSET PLYNOT
	DB	"D"
	DW	OFFSET PLYNOT
	DB	"E"
	DW	OFFSET PLYNOT
	DB	"F"
	DW	OFFSET PLYNOT
	DB	"G"
	DW	OFFSET PLYNOT

	DB	"M"		;Music Meta Command
	DW	OFFSET B$PLYMET

;	DB	"Q"		;Envelope Subcommand Lead In
;	DW	OFFSET QCMNDS

	DB	"N"+128 	;PLAY NUMERIC NOTE
	DW	OFFSET PLYNUM
	DB	"O"+128 	;OCTAVE
	DW	OFFSET POCTAV
	DB	"P"+128 	;PAUSE
	DW	OFFSET PPAUSE
	DB	"T"+128 	;TEMPO
	DW	OFFSET PTEMPO
	DB	"L"+128 	;LENGTH
	DW	OFFSET PLYLEN

;	DB	"V"+128 	;Volume
;	DW	OFFSET PVOLUM

	DB	"X"		;EXECUTE STRING
;	DW	OFFSET B$MCLXEQ	; substring handler in MCLPRC
	DW	OFFSET B$PLYXEQ	; Substring handler is local

	DB	"<"		;Decrement Octave
	DW	OFFSET POCTAD
	DB	">"		;Increment Octave
	DW	OFFSET POCTAI
	DB	00		;END OF TABLE


; This table contains the allowed subcommands for the Q command
; in the Music Macro Language.

;	This table has been removed as part of PC Jr code removal

;B$PLYXEQ
;Purpose:
;	Reimplemented as part of revision [5]
;	This routine is dispatched to by the X command in the PLAY statement.
;	It is equivalent to a macro-language subroutine call, in that it
;	specifies a variable which is to be inserted in the Macro String.  It:
;
;	 1)  Calls B$GETSTKC to check for enought stack space.
;	 2)  Calls B$SCNVAR to get string descriptor in the FAC
;	 3)  Calls B$PUTSTR to stack the current string pointer & length,
;	 4)  Sets B$MCLPTR & B$MCLLEN to point to new nested string,
;	 5)  Returns to its caller (presumably PLAY (via B$MACCMD)

cProc	B$PLYXEQ,<NEAR>	
cBegin				

	MOV	CL,100		; Get size for stack check
	CALL	B$GETSTKC	; Check the stack for enough room
	CALL	B$SCNVAR	; Get the VARPTR$ descriptor offset in FAC
	CMP	[b$VTYP],VT_SD	; Test if type was a string
	JNE	PLYERR		; Brif not, signal an error
	cCALL	B$PUTSTR	; Put B$MCLPTR & B$MCLLEN on local stack
	MOV	BX,OFFSET DGROUP:B$AC	; Get FAC for descriptor
	CALL	B$SETMCL		; Set new values of B$MCLPTR & B$MCLLEN
	CLC			; To indicate to use new values

cEnd				; End of B$PLYXEQ

PLYERR:				; Indicate type mismatch error

	JMP	B$ERR_TM	

; Decrement the current octave number
POCTAD: CMP	B$OCTAVE,LOW 0	
	JZ	PLYRET
	DEC	B$OCTAVE		; octave -1
	RET

; Increment the current octave number
POCTAI: cmp	B$OCTAVE,low 6	
	JNB	PLYRET
	CLC
	INC	B$OCTAVE		; octave +1
	RET

; Set the volume level

; Volume support code has been deleted from here

; Set the note length
PLYLEN:
	JNB	PLGOFC		;ERROR IF NO ARG
	CMP	DL,LOW 65	;ALLOW ONLY UP TO 64
	JNB	PLGOFC		;FC ERROR IF TOO BIG
	OR	DL,DL		;DON'T ALLOW ZERO
	JZ	PLGOFC		;FC ERROR IF ZERO
	MOV	B$NOTELN,DL	; store note length
	RET

; Set the play tempo
PTEMPO:
	CMP	DL,LOW 32	;ALLOW ONLY 32 - 255
	JB	PLGOFC		;FC ERROR IF TOO SMALL
	mov	B$BEATS,dl	; store beats per minute
	CLC
	RET

; Play a rest (Pause command)
PPAUSE:
	JNB	PLGOFC		;ERROR IF NO ARG
	XOR	CX,CX		;PASS FREQ OF 0
	CMP	DL,LOW 65	;ALLOW ONLY 1-64
	JNB	PLGOFC		;FC ERROR IF TOO BIG
	OR	DL,DL		;SEE IF ZERO
	JZ	PLYRET		;RETURN IF SO - NO PAUSE
	JMP	PPAUS2		;[DX]=PAUSE LENGTH

; Set the current octave number
POCTAV:
	JNB	PLGOFC		;ERROR IF NO ARG
	CMP	DL,LOW 7	;ALLOW ONLY OCTAVES 0..6
	JNB	PLGOFC		;FC ERROR IF TO BIG
	mov	B$OCTAVE,dl	
	CLC
PLYRET: RET

; Play a particular note by note number
PLYNUM:
	JNB	PLGOFC		;ERROR IF NO ARG
	MOV	AL,DL		;GET NOTE NUMBER INTO [AL]
	OR	AL,AL		;SEE IF ZERO (PAUSE)
	JZ	PLYNO3		;DO THE PAUSE
	CMP	AL,LOW 85	;ALLOW ONLY 0..84
	JNB	PLGOFC		;FC ERROR IF TOO BIG
	CBW			;CLEAR HI BYTE FOR DIVIDE
	DEC	AX		;MAP TO 0..83
	MOV	DL,LOW 12	;DIVIDE BY 12
	DIV	DL
	MOV	DH,AL		;OCTAVE TO [DH]
	MOV	AL,AH		;NOTE NUMBER IS REMAINDER
	INC	AL		;ADD ONE
	ADD	AL,AL		;DOUBLE TO MAKE INDEX
	JMP	SHORT PLYNU3	;PLAY NOTE [AL], OCTAVE [DH]

PLGOFC: JMP	B$ERR_FC	; GIVE FUNCTION CALL ERROR

; Play a note by name
PLYNOT: SUB	CL,LOW "A"-1	;MAP TO 1..7
	ADD	CL,CL		;MAP TO 2..14 (THIS ASSUMES SHARP)
	CALL	B$FETCHR 	;GET NEXT CHARACTER
	JZ	PLYNO2		;END OF STRING - NO SHARP OR FLAT
	CMP	AL,LOW "#"	;CHECK FOR POSSIBLE SHARP
	JZ	PLYSHP		;SHARP IT THEN
	CMP	AL,LOW "+"	;"+" ALSO MEANS SHARP
	JZ	PLYSHP
	CMP	AL,LOW "-"	;"-" MEANS FLAT
	JZ	PLYFLT
	CALL	B$DECFET 	;PUT CHAR BACK IN STRING.
	JMP	SHORT PLYNO2	;TREAT AS UNMODIFIED NOTE.
PLYFLT: DEC	CL		;DECREMENT TWICE TO FLAT IT
PLYNO2: DEC	CL		;MAP BACK TO UNSHARPED
PLYSHP: MOV	AL,CL		;INTO [AL] FOR XLAT
	MOV	BX,OFFSET NOTXLT ;POINT TO TRANSLATE TABLE
	XLAT	BYTE PTR CS:[BX] ; TRANSLATE INTO NOTE TABLE INDEX
	OR	AL,AL		;SEE IF LEGAL NOTE
	JS	PLGOFC		;NOTE'S OK IF NOT .GT. 127

; ENTER HERE WITH NOTE TO PLAY IN [AL]
; NOTE 0 IS PAUSE, 2,4,6,8..10,12 ARE A-G AND FRIENDS.

PLYNO3:
	mov	dh,B$OCTAVE	; get B$OCTAVE into [dh] for later math
PLYNU3:
	PUSH	AX		;Save Note
	PUSH	DX		; Save Octave
	MOV	AL,B$NOTELN
	MOV	B$NOTE1L,AL	; one note duration = note length
	CALL	B$FETCHR
	JZ	PLYNU4		;Brif end of string
	CALL	B$VALSC2 	;See if possible number
	CMP	DL,LOW 65	;If was .gt. 64
	JNB	PLGOFC		; then error
	OR	DL,DL		;Any Length?
	JZ	PLYNU4		;Brif not, just do note
	MOV	B$NOTE1L,DL	; store duration for this note
PLYNU4:
	POP	DX		;Get Octave
	POP	AX		;Restore Note
	CBW			;FILL [AH] WITH ZEROS
	MOV	BX,AX		;TRANSFER TO BX FOR INDEXING
	OR	BX,BX		;SEE IF PAUSE (NOTE # 0)
	JZ	PLYNO4		;IF PAUSE, PASS [BX]=0
	MOV	BX,WORD PTR CS:NOTTAB-2[BX] ;FETCH FREQUENCY
	MOV	CL,LOW 6	;CALCULATE 6-OCTAVE
	SUB	CL,DH		;FOR # OF TIMES TO SHIFT FREQ.
	SHR	BX,CL		;DIVIDE BY 2^(6-OCTAVE)
	ADC	BX,0		;ADD IN CARRY TO ROUND UP
PLYNO4:
	MOV	CX,BX		;FREQUENCY INTO [CX] FOR DONOTE
	MOV	DL,B$NOTE1L	; get this note's length
PPAUS2:
	MOV	AL,B$BEATS	; GET BEATS PER UNIT TIME
	MUL	DL		;CALC NOTE LENGTH * B$BEATS
	PUSH	CX		;SAVE [CX] WHILE WE DIVIDE
	MOV	CX,AX		;CALC TIME CONST/(B$BEATS * NOTE LENGTH)
	MOV	DX,1		;96000 (4*60*400) is
	MOV	AX,73400O	;SPECIAL TIME CONSTANT
	DIV	CX
	POP	CX		;RESTORE FREQUENCY
	OR	AX,AX		;IF DURATION IS ZERO, GET OUT.
	JZ	PLYNO8
	PUSH	CX		;Save Freq

PLYDOT:
	MOV	CX,AX		; Copy of duration for doted notes
PLYDOT1:
	PUSH	AX		; Save duration
	PUSH	CX		; Save the current dot duration
	CALL	B$FETCHR
	JZ	PLYDOX		; Brif EOS
	CMP	AL,LOW "."	; Note duration extender?
	JNZ	PLYDO2		; Brif not
	POP	CX		; Get last dot duration
	POP	AX		; Get current duration
	SHR	CX,1		; This dot = previous dot / 2
	ADD	AX,CX		; Update the new duration
	JNB	PLYDOT1 	; Loop if not overflow
	JMP	B$ERR_FC	; else complain.... (wont return)

PLYDO2:
	CALL	B$DECFET 	; Put char back
PLYDOX:
	POP	AX		; Trash the dot duration
	POP	AX		; Duration
	POP	CX		; Get freq
	PUSH	AX		;Save Duration
	PUSH	CX		;Save Frequency
	JCXZ	PLYNO7		;Brif Pause
	CMP	B$MSCALE,LOW 1	
	JZ	PLYNO7		;Brif Legatto
	MOV	CL,B$MSCALE	; using scale for shift count
	MOV	BX,3		;Stacatto multiplier
	CMP	CL,LOW 2
	JZ	PLYNO6		;Brif Stacatto
	MOV	BX,7		; else Normal
PLYNO6:
	MUL	BX		;Duration * 7/8 or 3/4
	SHR	AX,CL
	OR	AX,AX
	JNZ	PLYNO7		;If zero
	INC	AX		; then make 1

; Have all of the parameters for this note.  Send the info to the OEM
; to queue the note.
; Because a note is sent via two separate commands (one for the first,
; sound generating, part of the note, and a second one for the inter-
; note pause) it is possible for the queue to overflow in the middle of
; the note.  It isn't possible to simply wait for space to become available
; in the queue, because there is no guarantee that the queue is being
; emptied.  So to handle this case the following things happen:
;	If the queue overflows on either half of the note, the carry
;	flag is returned set as a signal to the music string B$PARSER that
;	the present command needs to be rescanned the next time around
;	If the first half of the note is sent successfully, a flag is
;	set (B$NOTFLG[SI]) indicating that it has been sent.  When the
;	second half of the note is sent successfully, then this flag is
;	cleared indicating that the entire note has been sent.	Before
;	sending the first half, it is necessary to check the flag to see
;	if this part has already been passed to the OEM on a previous
;	pass through the B$PARSER.
PLYNO7:
	POP	CX		;Get Freq
	CMP	B$NOTFLG,LOW 0 	; has the first part of this note already
				;been queued
	JNZ	PLYN7B		;If so, don't send it again
	cCALL	B$SNDNOT		;Send note
	JNB	PLYN7A		;If no queue overflowed, continue
	POP	AX		;If queue overflowed, get out, not even
	JMP	SHORT PLYNO9	; the first part of note was queued.

PLYN7A:
	mov	B$NOTFLG,low 1 	; set flag to say that note has been sent
PLYN7B:

; Now send an inter-note pause for this note (if required)
	POP	AX		;Get back original duration
	JCXZ	PLYNO8		;Brif Pause
	CMP	B$MSCALE,LOW 1	
	JZ	PLYNO8		;Brif Legatto
	MOV	CL,B$MSCALE	; scale factor for current mode (1/8|1/4)
	SHR	AX,CL		;divide note duration by scale factor
	OR	AX,AX		;Pause = 0?
	JZ	PLYNO8		;Don't send anything if so.
	cCALL	B$SNDPSN		;Send the rest
	JB	PLYNO9		;If queue overflowed, don't reset
				; flag for this note
PLYNO8:
	MOV	B$NOTFLG,LOW 0 	; clear the flag to indicate that the
				;complete note has been queued
PLYNO9:
	RET			; else do nothing

;***
; B$SNDNOT,B$SNDPSN
; Purpose:
; Send the specified note information to the OEM routine to be queued.
; B$SNDNOT will queue the first part of a note.
; B$SNDPSN will queue the second (inter-note pause) part of a note.
; Entry:
;	AX	- Duration
;	CX	- Frequency
; Exit:
;	none
; Modifies:
;	SI, DI, CX preserved.

; The registers must be set up as follows for the call to B$DONOTE
; [AL] = B$DONOTE function code number (1 for note, 0 for inter-note pause)
; [AH] = Voice
; [BX] = Volume
; [CX] = FREQUENCY IN HERTZ
; [DX] = DURATION IN CLOCK TICKS (1/18.2 SECONDS)

;****

cProc	B$SNDNOT,<NEAR>	
cBegin				

	XCHG	DX,AX		; B$DONOTE wants duration in DX

;	MOV	BX,B$VCEVOL	; Volume into bx

	MOV	AL,LOW QUENOT	;B$DONOTE function code in AL

; Test if this is the first time a note has been parsed in this play
; statement, and if so, queue sync marks in all voice queues.
	CMP	MQUEFL,LOW 0
	JNE	SDNT20		;branch if cmds have already been queued
				; for this PLAY statement
	MOV	MQUEFL,LOW 1


	JMP	SHORT SDNT20

cEnd	<nogen>			; End of B$SNDNOT


; Queue an internote pause (rest) for the current note

cProc	B$SNDPSN,<NEAR>	
cBegin				

	XCHG	DX,AX		; B$DONOTE wants duration in DX

	MOV	AL,LOW QUERST	;B$DONOTE function code in AL

; Send the instruction to the OEM, and test for any error codes coming
; back
SDNT20:
	cCALL	B$DONOTE 	; PLAY THE NOTE
	JNB	MQD90		;If no error occured, then go on
	CMP	AL,LOW 1	;Test for overflow on this voice
	JNE	PLYMER		;If not queue full, then report error
MQD80:
	STC			;Set error return state
MQD90:

cEnd				; End of B$SNDPSN


; Function call error occured while processing Music Meta command.
PLYMER:
	JMP	B$ERR_FC	; wont return

; B$PLYMET -	Process Music Meta Commands.

cProc	B$PLYMET,<NEAR>	
cBegin				

	CALL	B$FETCHZ 	;Get Meta action or error
	MOV	CL,LOW 1	;Factor for Legatto (1/1)
	CMP	AL,LOW "L"
	JZ	PLYDUR		;Brif Legatto (Full note)
	INC	CL		;Factor for Stecatto (3/4)
	CMP	AL,LOW "S"
	JZ	PLYDUR		;Brif Stecatto (3/4)
	INC	CL		;Factor for Normal (7/8)
	CMP	AL,LOW "N"
	JZ	PLYDUR		;Brif Normal (7/8)
	XOR	CL,CL
	CMP	AL,LOW "F"
	JZ	PLYMOD		;Brif Foreground Music
	DEC	CL
	CMP	AL,LOW "B"
	JNZ	PLYMER		;Brif not Background Music
PLYMOD:
	MOV	[B$MMODE],CL	;Store Music Mode (0=FG, 255=BG)
	JMP	SHORT PLYMET_RET	

PLYDUR:
	MOV	B$MSCALE,CL	; store duration scaling factor

PLYMET_RET:			; Common exit point

cEnd				; End of B$PLYMET


; This is the executive for dispatching the Q command.	It sets
; up the Macro command processor table to point to the Q subcommand
; table, and then uses the macro command processor to dispatch to
; the appropriate routine to process the subcommand.

; Envelope support code has been deleted from here


; TABLE OF INDEXES INTO NOTTAB FOR EACH NOTE
; VALUE OF 255 MEANS NOTE NOT ALLOWED.

NOTXLT	LABEL	BYTE		
	DB	9*2		;A- (G#)
	DB	10*2		;A
	DB	11*2		;A#
	DB	12*2		;B
	DB	255		;NO C- OR B#
	DB	1*2		;C
	DB	2*2		;C#
	DB	3*2		;D
	DB	4*2		;D#
	DB	5*2		;E
	DB	255		;NO E# OR F-
	DB	6*2		;F
	DB	7*2		;F#
	DB	8*2		;G
	DB	9*2		;G#

; TABLE OF NOTE FREQUENCIES
; THESE ARE THE FREQUENCIES IN HERTZ OF THE TOP OCTAVE (6)
; DIVIDED DOWN BY POWERS OF TWO TO GET ALL OTHER OCTAVES

NOTTAB	LABEL	WORD		
	DW	4186		;C
	DW	4435		;C#
	DW	4699		;D
	DW	4978		;D#
	DW	5274		;E
	DW	5588		;F
	DW	5920		;F#
	DW	6272		;G
	DW	6645		;G#
	DW	7040		;A
	DW	7459		;A#
	DW	7902		;B

;***
;B$QSYNC
;Purpose:
;	Output a Syncronization Byte to all voices
;Input:
;	none
;Output:
;	A SYNC byte is put in voice [VOICEN]'s queue
;Modifies:
;	none
;****

;	SYNC byte is output only if multi-voice support is present.
;	For single-voice music it is not necessary and hence not output.


sEnd	SN_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwscreen.asm ===
TITLE   GWSCREEN - Support for stmt
;***
;GWSCREEN - Support for stmt
;
; Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - SCREEN Statement:
;
;     SCREEN [mode][,[burst][,[apage][,vpage]]]
;	|
;     B$CSCN
;
;******************************************************************************
	INCLUDE switch.inc	;Product switches
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	USESEG	CN_TEXT 	;Place in CN segment, when defined

	INCLUDE seg.inc 	;Segment definitions


assumes CS,CN_TEXT
sBegin	CN_TEXT

externNP B$ERR_FC		;Illegal functionc call
externFP B$ScCleanUpParms	;Clean up parameters
externNP B$SCRSTT		;Low level screen statement support
externNP B$ScSetup		;Setup parameters


	SUBTTL	B$CSCN - execute SCREEN Statement
	PAGE
;***
;B$CSCN - execute SCREEN Statement
;void pascal B$CSCN([I2 flag,<I2 parm>]...,cwParams)
;
;Purpose:
; Pass parameters on to low level SCREEN statement routine (B$SCRSTT). There is
; one flag per parameter. If flag is zero, then the parameter was defaulted. If
; flag is non-zero, the next word in parameter block contains user specifed
; value. No dummy values are specified.
;
;Entry:
; parameter block is on stack. First word is count of params, excluding the
; count parameter.
;
;Exit:
; None.
;
;Uses:
; Per convention
;
;Exceptions:
; Could result in a jump to B$ERR_FC if parameter is too large or if some error
; occurs in B$SCRSTT
;
;******************************************************************************
cProc	B$CSCN,<PUBLIC,FAR>
cBegin	<nogen>
	cCall	B$ScSetup	;set up frame, parms
	cCALL	B$SCRSTT	;call low level SCREEN statement support
	JB	FUNC_ERROR	;brif error occurred
	JMP	B$ScCleanUpParms;clean up stack and exit...
cEnd	<nogen> 		;fall into routine to clean up and return

FUNC_ERROR:
	JMP	B$ERR_FC	;Bad Parm, complain.

sEnd	CN_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwque.asm ===
TITLE	GWQUE -- General Queue support routines
;***
; GWQUE -- General Queue support routines
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   B$INITQ   -   Initialize queue header
;   B$PUTQ    -   Enqueue a byte
;   B$GETQ    -   dequeues a byte
;   B$NUMQ    -   returns # bytes queued
;   B$LFTQ    -   returns space available in queue
;               ( B$NUMQ + B$LFTQ + 1 = # bytes allocated in buffer )
;
;   These routines are all called with SI pointing to a 12-byte queue
;   descriptor, defined as Que_ctrl_block, below.
;
;******************************************************************************

	include switch.inc	
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	useSeg	RT_TEXT 	;Runtime Core

	INCLUDE seg.inc 	

Que_ctrl_block struc
Queput	dw	?		; queue put pntr
Queget	dw	?		; queue get pntr
Quebot	dw	?		; bot of queue location
Quetop	dw	?		; top of queue location
Quelen	dw	?		; length of queue = maximum queable bytes + 1
Quenum	dw	?		; number of bytes in que
Que_ctrl_block ends

Que_header_size = size que_ctrl_block

sBegin	RT_TEXT 		
assumes CS,RT_TEXT		

	PUBLIC	B$INITQ
	PUBLIC	B$PUTQ
	PUBLIC	B$GETQ
	PUBLIC	B$NUMQ
	PUBLIC	B$LFTQ		;[$]

;B$GETQ   - General Dequeue routine
;entry  - SI -> queue descriptor
;exit   - ZR flag   1 if queue underflow
;         AL        byte queued (if ~underflow)
;         Others    Preserved
B$GETQ:				;[$]
	push	bx
	mov	bx,[si].queget
	cmp	bx,[si].queput	;is queue empty?
	jz	nochar		;it is
	mov	al,[bx]		;Get char
	inc	bx		;Bump get
	cmp	bx,[si].quetop	;wrap-around?
	jnz	nwrdqu		;No
	mov	bx,[si].quebot	;Get Que Bot
nwrdqu:
	mov	[si].queget,bx	;Store new get ptr
	dec	[si].quenum	;One less in Queue
	inc	bx		;make certain that Z-flag is not zero
nochar:	pop	bx
	ret

;B$PUTQ   - General queue routine
;entry  - SI     -> queue descriptor
;         AL        byte to be queued
;exit   - ZR flag   1 if queue overflow
;         AH        can be used
;         Others    Preserved
B$PUTQ:				;[$]
	push	bx
	mov	bx,[si].queput	;bottom of queue
	mov	[bx],al		;Put char in queue
	inc	bx		;Advance put
	cmp	bx,[si].quetop
	jnz	nwrque		;No
	mov	bx,[si].quebot	;Get Que Bot
nwrque:
	cmp	bx,[si].queget	;overflow?
	jz	povrflo		;yes - ignore this put
	mov	[si].queput,bx	;no  - store new put ptr
	inc	[si].quenum	;One more in Queue
povrflo:
	pop	bx
	ret

;B$INITQ  - Initialize queue descriptor for empty queue
; entry - [SI]  uninitialized queue descriptor
;         [BX]  first byte of queue buffer
;         AX    number of bytes in buffer
; exit  - AX    used
;         Rest  Preserved
B$INITQ:				;[$]
	mov	[si].queget,bx	;reset pointers to
	mov	[si].queput,bx	;beginning of queue buffer
	mov	[si].quebot,bx	;ditto
	mov	[si].quelen,ax	;length of queue
	add	ax,bx		;now points to top of queue
	mov	[si].quetop,ax	;length of queue
	mov	[si].quenum,0	;[RDK]clear queue counter.
	ret

;B$LFTQ   - How many times can B$PUTQ be successfully called for queue SI
; entry - [SI]  queue descriptor
; exit  - AX    number of free bytes in buffer

B$LFTQ:	MOV	AX,[SI].QUELEN	;[$]
	sub	ax,[si].quenum
	dec	ax
	ret

;B$NUMQ - How many times can B$GETQ be successfully called for queue SI
; Entry - SI points to 8 byte queue descriptor
; Exit  - [AX] = number of bytes of data in queue (0..QueueSize - 1)

B$NUMQ:	MOV	AX,[SI].QUENUM	;[$]
	ret

sEnd	RT_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwplayf.asm ===
PAGE	,132
	TITLE	GWPLAYF - GW BASIC 2.0 Multi-Voice Play Function
;***
; GWPLAYF - GW BASIC 2.0 Multi-Voice Play Function
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;	Multi Voice Play Function Processor
;
; BASIC Syntax mapping to included runtime entry points:
;
; - PLAY Function:
;
;      v = PLAY(n)
;	     |
;	   B$FPLY
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	SN_TEXT 	
	USESEG	_DATA 		

	INCLUDE seg.inc 	


	INCLUDE	ibmunv.inc	

sBegin	_DATA			
	externW	b$SNDQCB	
sEnd	_DATA			

assumes CS,SN_TEXT		
sBegin	SN_TEXT 		


;***
;B$FPLY - play function
;
;Purpose:
;	Runtime Entry Point.
;	Syntax: X = PLAY (n)
;Entry:
;	numVoice = number of voice to get info for
;Exit:
;	[AX] = $donote(1,n), number of notes left in Q for this voice
;Uses:
;	Per convention
;Exceptions:
;	None
;****
cProc	B$FPLY,<PUBLIC,FAR>	
parmW	numVoice		
cBegin				


; this code extraced from B$RDPLAY to improve granularity and save code.
	MOV	AX,[b$SNDQCB].QUNOTE ; AX = the remaining notes in queue
				; (from sound-block)
cEnd				

sEnd	SN_TEXT			
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\helpfp87.asm ===
TITLE	HELPFP87 - IEEE floating point compiler helpers (8087 version)
;***
; HELPFP87 - IEEE floating point compiler helpers (8087 version)
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;	This file contains several compiler helpers for floating point
;	support not contained in the standard C math packages.
;
;	The routines load and store 4 byte integers with the 8087 stack.
;	A fast compare is also provided.
;
;******************************************************************************
	.8087
	INCLUDE switch.inc
	INCLUDE rmacros.inc


	useSeg	MT_TEXT

	INCLUDE seg.inc

sBegin	MT_TEXT
assumes cs,MT_TEXT

;***
; B$fcompz - Compare 8087 top stack entry with zero
;
;Purpose:
; This routine is used to compare the top 8087 stack entry with zero. Note!
; Carry is reversed from an equivalent CMP x,0!
;
;Entry:
; ST(0)
;
;Exit:
;	Z   C	Indicates
;	0   0	ST(1) < 0
;	0   1	ST(1) > 0
;	1   0	ST(1) = 0
;	1   1	Error
;
;Preserves: (optional)
; All
;
;Exceptions:
;
;******************************************************************************
cProc	B$fcompz,<FAR,PUBLIC>
cBegin
	FLDZ			;Throw on a zero, and fall in
cEnd	nogen

;***
; B$fcomp - Compare and pop 1 8087 stack entry
;
;Purpose:
; This routine is used to compare the top two 8087 stack entries and pop 1.
;
;Entry:
; ST(0) and ST(1)
;
;Exit:
;	Z C Indicates
;	0 0 ST(0) > ST(1)
;	0 1 ST(0) < ST(1)
;	1 0 ST(0) = ST(1)
;	1 1 Error
;
; ST(0) <= ST(1)
;
;Preserves: (optional)
; All
;
;*****************************************************************************
cProc	B$fcomp,<PUBLIC,FAR>,AX
localW	result
cBegin
	FCOMP			; compare and ST(0)
	FSTSW	result		; get compare status
	FWAIT			; synchronize
	MOV	AH,BYTE PTR (result + 1) ; get compare status
	SAHF			; set flags like unsigned compare
cEnd

;***
; B$fcompp - Compare and pop 2 8087 stack entries
;
;Purpose:
; This routine is used to compare the top two 8087 stack entries and pop both.
;
;Entry:
; ST(0) and ST(1)
;
;Exit:
;	Z C Indicates
;	0 0 ST(0) > ST(1)
;	0 1 ST(0) < ST(1)
;	1 0 ST(0) = ST(1)
;	1 1 Error
;
; ST(0) <= ST(1)
;
;Preserves: (optional)
; All
;
;*****************************************************************************
cProc	B$fcompp,<PUBLIC,FAR>,AX
localW	result
cBegin
	FCOMPP			; compare and pop ST(0) and ST(1)
	FSTSW	result		; get compare status
	FWAIT			; synchronize
	MOV	AH,BYTE PTR (result + 1) ; get compare status
	SAHF			; set flags like unsigned compare
cEnd

sEnd	MT_TEXT


end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwsound.asm ===
TITLE	GWSOUND - GW BASIC 2.0 NOISE, SOUND, & BEEP support
;***
; GWSOUND - GW BASIC 2.0 NOISE, SOUND, & BEEP support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - SOUND Statement:
;
;      SOUND freq, duration
;	 |
;	 |	    
;    B$SOND
;
;******************************************************************************
	include switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	.xall
	.radix	10

	useSeg	SN_TEXT		
	useSeg	_BSS		
	useSeg	_DATA		

	include	seg.inc		
	INCLUDE	ibmunv.inc	; EQUates for B$DONOTE


sBegin	_BSS			

DURATION DW	1 DUP(?)
FREQUENCY DW	1 DUP(?)
DURASHN DW	2 DUP(?)	; need two words to store s.p. duration

sEnd	_BSS			



sBegin	SN_TEXT
	assumes CS,SN_TEXT

	externNP B$FrameAFE	; advanced function error + frame setup


	externNP B$ftolrnd	
	externNP B$fmldw     	

	externNP B$STRTSD     	
	externNP B$SNDWAT     	

	externNP B$DONOTE     

	externNP B$ERR_AFE	; advanced function error
	externNP B$ERR_FC	; function error



cProc	B$NOI,<FAR,PUBLIC>	
cBegin				
	JMP	B$FrameAFE	; sets up frame for error recovery
cEnd	<nogen>			


	SUBTTL	BEEP and SOUND Statements
	PAGE

	PUBLIC	B$BP0
	PUBLIC	B$BP1		; BEEP ON/OFF
	PUBLIC	B$SO0
	PUBLIC	B$SO1		;   SOUND ON/OFF


B$BP0:
B$BP1:
B$SO0:
	PUBLIC B$SND
B$SND:
cProc	B$SO1,<FAR>		
cBegin				
	JMP	B$FrameAFE	; sets up frame for error recovery
cEnd	<nogen>			



;***
;B$STOPSD
;Purpose:
;	Signal background task to flush voice queues and stop playing
;	music.
;Input:
;	none
;Output:
;	Preserves all registers
;****
cProc	B$STOPSD,<NEAR>,<AX>	
cBegin				
	MOV	AL,STPSND	;Function code to stop sound
	cCALL	B$DONOTE 	;Pass command to the OEM
	JC	FC_ERR		; function call error if B$DONOTE complains
cEnd				; End of B$STOPSD

;***
;B$SOND - accept parms 1&2 to sound statement
;
; Purpose:
;	Runtime Entry Point.
;	accept parms 1&2 to sound statement
;	Syntax: SOUND x,y[,[volume][,voice]]
;
;	Where:	x is the Frequency in Hertz.
;		y is the Duration in Clock ticks. (currently 18.2/sec).
;
;		Frequency must be at least 37 Hz.
;		If Duration is 0, then just turn off current sound...
;
; Input:
;	parm1 = frequency			[6]
;	parm2 = duration (s.p.)			[6]
; Output:
;****
cProc	B$SOND,<FAR,PUBLIC>,<ES,SI,DI> ;[7]
parmW	freq			
parmD	dur			
cBegin				
;
; When converting the duration into a real time quantity, the sound duration on
; the statement is specified in 55ms increments, but the B$DONOTE interface
; specifies it in 2.5ms increments. So we need to multiply the duration by 22,
; and then check for overflow. (error only if duration .gt. 64k)
;
	MOV	BX,[freq]	
	MOV	[FREQUENCY],BX	; save frequency
	LEA	SI,[dur]	; [si] points to SP duration
	MOV	DI,OFFSET DGROUP:DURASHN ; [di] points to save area
	PUSH	DS		
	POP	ES		; set ES=DS

	PUSH	DI		; save ptr to DURASHN
	MOVSW			; move first word of duration
	LODSW			; get second word of duration
	STOSW			; now we've moved s.p. duration, plus we've
				;	got second word in AX for testing below
	POP	BX		; restore ptr to s.p. DURASHN
	XCHG	AX,CX		; [CX] = second word of s.p. duration
	SHL	CX,1		; test duration - -
	JC	FC_ERR		; illegal function call if duration negative
	JZ	HLTSND		; stop sound & return if zero duration given

	FLD	DWORD PTR [BX]	; ST0 = duration (load from DS:BX to ST0)
	FLD	ST(0)		; copy for destructive compare

	CALL	B$ftolrnd	; pop copy from ST0, put in DX:AX as integer
	OR	DX,DX		; max. legal value of duration is 65535
	JZ	DUR_OK		; brif duration is legal

FC_ERR:				
	JMP	B$ERR_FC	; function call error - doesn't return
DUR_OK:
	MOV	BX,22D
	CALL	B$fmldw	; ST1 = duration, ST0 = 22D
	FMULP	ST(1),ST	; ST0 = 22 * duration
	CALL	B$ftolrnd	; DX:AX = 22 * duration
	MOV	CX,0FFFFH	; cache in register to save a couple bytes
	OR	DX,DX		
	JZ	LODDUR		; brif 22 * duration <= 64K

	MOV	AX,CX		;[3] put max value in AX (0FFFFH)
LODDUR:
	MOV	[DURATION],AX	; [duration] = [ax]
	MOV	DX,CX		;[2]default voice (0FFFFH)
	MOV	BX,DX		;default volume

SETVOI:
	; at this point, BX = volume
	; 		    DX = voice
	
	MOV	AH,DL		; assume user specified voice
	INC	DL
	JNZ	SNDES1		; go make noise if he did
	MOV	AH,DL		; he didnt so use 0

; Get the sound parameters from the first call and send them to the OEM
; routines.

SNDES1: 			; [bx] = volume
	MOV	DX,[DURATION]	; [dx]=duration
	MOV	CX,[FREQUENCY]	; [cx]=frequency
	OR	DX,DX		; if duration=0 then sound already
	JZ	SNDRET		; turned off -- exit
	CALL	B$SNDWAT	; wait until other sounds are done
DNT:
	MOV	AL,QUENOT	; function code to queue a note
	cCALL	B$DONOTE 	;start new sound.
	JNC	START		; brif no carry
	DEC	AL
	JZ	DNT		; try queuing again
	JMP	SHORT FC_ERR	; else function call error
START:
	CALL	B$STRTSD	;start sound
SNDRET: 			

cEnd				

HLTSND:				
				; range for B$SOND, below
	MOV	[DURATION],CX	; subsequent calls to B$SND use
				; zero duration!
	cCALL	B$STOPSD	; stop sound & exit
	JMP	SNDRET		; Exit gracefully



sEnd	SN_TEXT			

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\helpi4.asm ===
TITLE	HELPI4 - I4 compiler helpers
;***
; HELPI4 - I4 compiler helpers
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;	This file contains several compiler helpers for 4 byte integer
;	support not contained in the standard C math packages.
;
;	The routines are for mul, div, mod, and cmp.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	useSeg	RT_TEXT

	INCLUDE seg.inc


;	for now use C library routines which do modular arithmetic

externFP	__aFlmul
externFP	__aFldiv
externFP	__aFlrem


sBegin	RT_TEXT
assumes cs,RT_TEXT

;***
; B$MUI4(I4 op1,I4 op2)
;
;Purpose:
;	Long integer multiply
;
;Entry:
;	op1 and op2 on stack
;
;Exit:
;	dx:ax = op1*op2
;
;Uses:
;	ax,cx,dx,bx
;
;Exceptions:
;	none
;
;******************************************************************************


cProc	B$MUI4,<FAR,PUBLIC>,<> 	

cBegin	nogen

	jmp	__aFlmul

cEnd	nogen



;***
; B$DVI4(I4 op1,I4 op2)
;
;Purpose:
;	Long integer divide
;
;Entry:
;	op1 and op2 on stack
;
;Exit:
;	dx:ax = op1/op2
;
;Uses:
;	ax,cx,dx,bx
;
;Exceptions:
;	hardware divide overflow
;
;******************************************************************************


cProc	B$DVI4,<FAR,PUBLIC>,<> 	

cBegin	nogen

	jmp	__aFldiv

cEnd	nogen



;***
; B$RMI4(I4 op1,I4 op2)
;
;Purpose:
;	Long integer remainder
;
;Entry:
;	op1 and op2 on stack
;
;Exit:
;	dx:ax = op1 mod op2
;
;Uses:
;	ax,cx,dx,bx
;
;Exceptions:
;	hardware divide overflow
;
;******************************************************************************


cProc	B$RMI4,<FAR,PUBLIC>,<> 	

cBegin	nogen

	jmp	__aFlrem

cEnd	nogen


;***
; B$CPI4(I4 op1,I4 op2) - long integer compare
;
;Purpose:
;	Long integer compare
;	This routine returns a signed compare result.
;
;Entry:
;	op1 and op2 on stack
;
;Exit:
;	flags = signed compare of op1 ? op2 (in AH for Windows)
;
;Uses:
;	ax,cx,dx,bx
;
;Exceptions:
;	hardware divide overflow
;
;******************************************************************************

cProc	B$CPI4,<FAR,PUBLIC>,<AX>

	parmD	op1
	parmD	op2

cBegin
	mov	ax,word ptr (op1+2)	; signed compare high words
	cmp	ax,word ptr (op2+2)
	jne	LCMPretx		;not equal - return flags

	mov	ax,word ptr (op1)	; unsigned compare low words
	cmp	ax,word ptr (op2)

	lahf				; (ah) = "unsigned" flags
	and	ax,4100h		; (ah,al) = interesting flags,0
	shr	ax,1			; move C0(cf) to high bit of al(sf)
	shl	ah,1			; restore C3(zf) to original position
	or	ah,al			; (ah) = signed flags
	sahf				; set flags

LCMPretx:				

cEnd


;***
; B$CMI4(I4 op1,I4 op2) - long integer compare
;
;Purpose:
;	Added with [4].
;	Long integer compare
;	This routine performs a signed comparison, but returns the flags
;	for the use of unsigned jumps.
;	This allows LAHF to save all required flags for Windows and other
;	QB uses.
;
;Entry:
;	op1 and op2 on stack
;
;Exit:
;	flags = signed compare of op1 ? op2 (in AH for Windows)
;
;Uses:
;	cx,dx,bx
;
;******************************************************************************

cProc	B$CMI4,<FAR,PUBLIC>

	parmD	op1
	parmD	op2

cBegin
	push	ax			;preserve AX for Compiler

	mov	ax,word ptr (op1+2)	; signed compare high words
	cmp	ax,word ptr (op2+2)
	stc				;BELOW == CF set
	jl	LCMPret 		;exit if LESS (BELOW)
	clc				;ABOVE == CF clr
	jg	LCMPret 		;exit if GREATER (ABOVE)
	mov	ax,word ptr (op1)	;unsigned compare low words
	cmp	ax,word ptr (op2)
LCMPret:
	pop	ax			; restore AX for compiler

cEnd


sEnd	RT_TEXT

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\gwscr.asm ===
TITLE   GWSCR - GENERAL support for LOCATE, SCREEN stmt & fct,COLOR, CLS
;***
; GWSCR - GENERAL support for LOCATE, SCREEN stmt & fct,COLOR, CLS
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - CLS Statement:
;
;      CLS [0,1,2]
;	|
;     B$SCLS
;
;
; - COLOR Statement:
;
;    Text:
;      COLOR [foreground] [,[background] [,border]]
;
;    Graphics:
;      COLOR [background] [,[palette]]
;
;      COLOR 1,2,3
;	|
;     B$COLR
;
;
; - CSRLIN Function:
;
;      v = CSRLIN
;	      |
;	    B$CSRL
;
;
; - KEY Statement - calls B$KFUN or B$KMAP depending on syntax:
;
;      KEY (ON | OFF | LIST | (n,x$))
;
;    The first 3 possibilities cause $KY0 to be called, $KY1 for the 4rth:
;
;      KEY (ON | OFF | LIST)		 KEY n,x$
;      ---------------------		 --------
;		 |			     |
;	       B$KFUN			   B$KMAP
;
;
; - LOCATE Statement:
;
;      LOCATE [row][,[col][,[cursor][,[start][,stop]]]]
;
;      LOCATE 1,1
;	|
;     B$LOCT
;
;
; - POS Function:
;
;      POS(I)
;	|
;   B$FPOS
;
;
; - SCREEN Function:
;
;      v = SCREEN(row, col [,z])
;	      |
;	    B$FSCN
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	USESEG	_DATA		
	USESEG	_BSS		
	USESEG	CN_TEXT 	
	USESEG	RT_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE ascii.inc	;must follow switch.inc
	INCLUDE idmac.inc	

sBegin	_DATA			

	externW	b$CURSOR	; (1,1)-relative screen cursor
	externB	b$CSRY		; 1-relative y-coordinate cursor
	externB	b$CSRX		; 1-relative x-coordinate cursor
	externB b$LINCNT 	
	externB b$WDOBOT 	
	externB b$WDOTOP 	
	externB b$CRTWIDTH 	

	externW b$VWCLR_PTR	

sEnd	_DATA			

sBegin	_BSS			

	externB b$RcoFlg	;NZ if Ronco keyboard present

	externB b$KEY_SW 	;defined in GWDATA.ASM
	externW b$STRTAB 	;defined in GWDATA.ASM

	externB B$VIEWSW 	; defined in GWDATA.ASM

sEnd	_BSS			


assumes CS,CN_TEXT		
sBegin	CN_TEXT 		

	externNP B$SETCLR	
	externNP B$GetParm	
	externNP B$KEYDSP	
	externNP B$WHOME 	
	externNP B$SCNLOC	
	externNP B$ERR_FC	
	externNP B$CSRATR	
	externNP B$CLRSCN	
	externNP B$GRMODE	
	externNP B$$WCHT 	
	externNP B$SCREEN	; new name for $SCRATR & $SCRINP
	externNP B$SCINIT	; init screen if not already done
	externNP B$CRLF		; perform CR/LF processing


	SUBTTL	COLOR statement
	PAGE
;***
;B$COLR - execute COLOR  Statement
;void pascal B$COLR([I2 flag,<I2 parm>]...,cwParams)
;
;Purpose:
;	Pass parameters on to low level COLOR statement routine (SetColor).
;	There is one flag per parameter.  If flag is zero, then the parameter
;	was defaulted.	If flag is non-zero, the next word in parameter
;	block contains user specifed value.  No dummy values are specified.
;Entry:
;	parameter block is on stack.  First word is count of params, excluding
;	the count parameter.
;Exit:
;	None.
;Uses:
;	Per convention
;Exceptions:
;	Could result in a jump to B$ERR_FC if parameter is too large
;	or if some error occurs in SetColor
;****
cProc	B$COLR,<PUBLIC,FAR>	
cBegin	<nogen> 		
	cCall	B$ScSetup	;set up frame, parms
	CALL	B$SETCLR	;call low level COLOR statement support
	JB	FUNC_ERROR	;brif error occurred
cEnd	<nogen> 		;fall into routine to clean up and return

	SUBTTL	COLOR/SCREEN/LOCATE statement support
	PAGE

;***
;CleanUpParms - clean a variable number of parameters off of the stack and ret
;
;Purpose:
;	This routine cleans a variable length parameter block off of the
;	stack and does a far ret back to the caller.
;Entry:
;	Stack contains -
;
;		|  first parm	|
;		+---------------+
;		|		|
;		\ 		/
;		|		|
;		+---------------+
;		|  last  parm	|
;		+---------------+
;		|  cw parms	|
;		+---------------+
;		|  return seg	|
;		+---------------+
;		|  return off	|
;		+---------------+
;		|  old BP	|
;		+---------------+
;	 SP ->	|  saved SI	|
;		+---------------+
;Exit:
;	Stack cleaned
;Uses:
;	Per convention
;Exceptions:
;	None.
;NOTE:
;	This routine should be jumped into...
;****
cProc	B$ScCleanUpParms,<FAR,PUBLIC>  
cBegin				
	POP	SI		
	POP	ES		
	POP	BP		;recover BP
	POP	AX		;get return offset
	POP	DX		;get return segment
	POP	CX		;get count of parms
	SHL	CX,1		;convert word count to byte count
	ADD	SP,CX		;clean up parms
	PUSH	DX		;replace segment
	PUSH	AX		;replace offset
cEnd				
	PAGE

;***
;B$ScSetup - Preamble for LOCATE, COLOR, and SCREEN statements
;
;Purpose:
;	Does initial setup of parameters for LOCATE, COLOR,
;	and SCREEN statements.
;Entry:
;	BX - CS relative address to exit to.
;	parameter block is on stack.  First word is count of params, excluding
;	the count parameter.
;	Stack contains -
;
;		|  first parm	|
;		+---------------+
;		|		|
;		\ 		/
;		|		|
;		+---------------+
;		|  last  parm	|
;		+---------------+
;		|  cw parms	|
;		+---------------+
;		|  return seg	|
;		+---------------+
;		|  return off	|
;		+---------------+
;		|  near ret	|
;		+---------------+
;Exit:
;	initial SI is pushed on stack
;	CX - count of words in parameter block
;	SI - ptr to start of parameter block (grows down in memory).
;Uses:
;	Per convention
;Exceptions:
;	None.
;****
cProc	B$ScSetup,<NEAR,PUBLIC> 
parmW	parmBlock		;beginning of parameter block
parmW	cwParms 		;word count of parameter block
parmW	retAddr 		;return address of compiled/interp code
cBegin	<nogen> 		
	POP	BX		;get near return addr
	PUSH	BP		;set up ...
	MOV	BP,SP		;... stack frame
	PUSH	ES		;save ES
	PUSH	SI		;preserve SI
	MOV	CX,cwParms	;get param count
	MOV	AX,CX		;convert cwParms to cbParms
	SHL	AX,1		
	LEA	SI,cwParms	;get pointer to end of block
	ADD	SI,AX		;point to start of block
	JMP	BX		;return to caller
cEnd	<nogen> 		

FUNC_ERROR:
	JMP	B$ERR_FC	;Bad Parm, complain.

	SUBTTL	LOCATE statement
	PAGE

;***
;B$LOCT - execute the LOCATE Statement
;
;Purpose:
;   LOCATE -	Moves the Cursor to the Specified position
;		on the Active Screen.  Optionally:
;		1).  Turns the Cursor on/off.
;		2).  Allows setting of the Cursor Start/Stop
;		     Raster Lines.
;
;   Syntax: LOCATE [row] [, [col] [,[cursor] [, [start] [, [stop] ]]
;
;	WHERE:	row is Screen line number 1 to B$LINCNT-1 if KEY ON.
;		row is Screen line number 1 to B$LINCNT	 if KEY OFF.
;		col is Screen column number.  1 to 40 or 1 to 80
;		depending on WIDTH.
;
;		If Row and/or Column are missing, the current
;		value(s) are used.
;
;		cursor is a boolean value indicating whether
;		the cursor is visible or not.
;		0 for off,  non-zero for on.
;
;		start is the Cursor Start Raster Line (0-31).
;		stop  is the Cursor End   Raster Line (0-31).
;		If omitted, stop assumes start value.
;
;		The Cursor Raster Start/Stop parms are optional.
;		Cursor Blink is not selectable and always set
;		at 1/16 Rate...
;
;Entry:
;	parameter block is on stack.  First word is count of params, excluding
;	the count parameter.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	Control may be transfered to B$ERR_FC
;****
cProc	B$LOCT,<PUBLIC,FAR>	
cBegin	<nogen> 		
	cCall	B$ScSetup	;set up frame, parms
	cCall	GetCsrParm	;not psw.z if got parm in [AL],flg in [AH]
	JNZ	LOCT20		;brif got parm
	MOV	AL,b$CSRY	;get current y coord
LOCT20: 			
	PUSH	AX		;save flag/row
	cCall	GetCsrParm	;get column if specified
	JNZ	LOCT30		;brif got column
	MOV	AL,b$CSRX	;get current column
LOCT30: 			
	PUSH	AX		;save flag/column
	cCall	GetCsrParm	;get cursor parm if specified
	XCHG	AX,DX		;[DX]=cursor flag/type
	cCall	GetCsrParm	;get start raster if specified
	XCHG	AX,BX		;[BX]=cursor flag/start raster
	cCall	GetCsrParm	;get stop raster if specified
	XCHG	AX,CX		;[CX]=cursor flag/stop raster
	XCHG	AX,DX		;[AX]=cursor type for ll call
	cCall	B$CSRATR 	;let low level do it's thing with cursor
	JB	FUNC_ERROR	;brif ll error
	POP	CX		;[CX]=flag/column
	POP	DX		;[DX]=flag/row
	OR	DH,DH		;was row specified?
	JZ	ChkCol		;brif not - go check column

;  here if the row parameter was specified

	OR	DL,DL		;check if new row zero
	JZ	FUNC_ERROR	;if so, then error
	MOV	AL,DL
	CMP	AL,b$WDOBOT	;don't allow locate to outside text window
	JBE	StoreRow	; if row < wdobot check against top
	CMP	b$KEY_SW,0	; function keys on ?
	JNE	FUNC_ERROR	; Brif so
	CMP	AL,B$LINCNT	; is row same as B$LINCNT ?
	JNE	FUNC_ERROR	; Brif not (This is the only time
				; a locate outside textt window
				; is allowed

StoreRow:
	CMP	AL,b$WDOTOP	; don't allow locate above text window
	JB	FUNC_ERROR	; brif above text window

ChkCol:
	DEC	CH		;was new column specified?
	JNZ	SetPos		;brif not - go set cursor position

;  Here if new column was specified...

	JCXZ	FUNC_ERROR	;Must be 1 to Width (40 or 80).
	CMP	CL,b$CRTWIDTH	; Test against physical screen width
	JA	FUNC_ERROR	;Error if Col is GT than Width.

SetPos:
	CALL	B$SCINIT	; Init screen if not already done.  Makes
				; sure that if this is the first screen
				; operation, that the next locate operation
				; can go to any line it wants to.
	MOV	DH,CL		;DH=col,DL=row
	CALL	B$SCNLOC		; Store DX into b$CURSOR, and display
				; user cursor at new position
	JMP	B$ScCleanUpParms;clean up stack and exit...
cEnd	<nogen> 		


	PAGE
;***
;GetCsrParm - Get a locate statement parameter if specified by user
;
;Purpose:
;	Gets a parameter for locate statement if one was specified
;	by the user.
;Entry:
;	SI - points to next parameter flag in parameter block
;	CX - count of words left in parameter block
;Exit:
;	SI,CX - advanced over parmeter flag and parameter
;	AH - 0 if no parameter specified, else 1
;	AL - parameter specified by user iff AH <> 0
;	psw.z - set if no parameter was specified
;Uses:
;	None.
;Exceptions:
;	None.
;****
cProc	GetCsrParm,<NEAR>,<DX>	
cBegin				
	MOV	DH,1		;default is parm specified
	cCall	B$GetParm	;call low level routine to get parm
	JNZ	GCP10		;brif got parm in [AL]
	DEC	DH		;no parm was specified (sets psw.z)
GCP10:				
	MOV	AH,DH		;[AH]=flag, [AL]=parm iff AH<>0
cEnd

	SUBTTL	CLS statement
	PAGE
;***
; B$SCLS - clear text/graphics/both screens.  Re-written as revision [15].
;
; Purpose:
;	This statement may have an optional byte parameter.  The value
;	of this parameter indicates what area of the screen is to be cleared.
;
;       CLS (no param)
;		if text mode:
;			clear text window (VIEW PRINT)
;			refresh function keys (if on, else blank the line)
;			home the cursor in text window
;		if graphics and viewport (VIEW):
;			clear defined graphics viewport
;			initialize graphics viewport variables
;		if graphics, but no viewport (no VIEW):
;			clear all text and graphics
;			initialize graphics viewport variables
;			refresh function keys (if on, else blank the line)
;			home the cursor in text window
;	CLS 0
;		clear all text and graphics
;		initialize graphics viewport variables
;		refresh function keys (if on, else blank the line)
;		home the cursor in text window
;	CLS 1
;		if text mode:
;			no-operation (return immediately)
;		if graphics and viewport (VIEW):
;			clear defined graphics viewport
;			initialize graphics viewport variables
;		if graphics, but no viewport (no VIEW):
;			clear all text and graphics
;			initialize graphics viewport variables
;			refresh function keys (if on, else blank the line)
;			home the cursor in text window
;	CLS 2
;		clear text window (VIEW PRINT)
;		home the cursor in text window
;			
; Entry:
;	ScnNum - screen to clear
; Exit:
;	None.
; Uses:
;	Per convention.
; Exceptions:
;	B$ERR_FC
;****
cProc	B$SCLS,<PUBLIC,FAR>
	parmW	ScnNum		;screen number to clear
cBegin

	MOV	BX,ScnNum	;keep screen number in BX
	INC	BX		;test if parameter was given
	JNZ	ClsParamGiven	;if given, then jump

	MOV	AX,0602H	;assume CLS 2 with key and text refresh
	CALL	B$GRMODE		;test if graphics mode
	JZ	ClsStart	;if not, use assumed value
	MOV	AX,0101H	;assume CLS 1 with only graphic vp init
	CMP	B$VIEWSW,0	;test if viewport active
	JNZ	ClsStart	;if so, use assumed value
	MOV	AX,0700H	;else CLS 0 with full initialization
	JMP	SHORT ClsStart	;process the initialization

ClsParamGiven:
	DEC	BX		;restore parameter
	CMP	BX,2		;test upper limit of parameter
	JA	ClsError	;if over, then report error

	MOV	AL,BL		;get lower byte of parameter
	MOV	AH,7		;assume full initialization
	CMP	AL,1		;test the parameter value
	JB	ClsStart	;if CLS 0, then full initialization
	MOV	AH,4		;assume just redisplay keys after clear
	JA	ClsStart	;if CLS 2, then text initialization
	CALL	B$GRMODE		;else CLS 1, test for graphics mode
	JZ	ClsReturn	;if no graphics mode, then just return
	MOV	AH,1		;just erase the viewport
	CMP	B$VIEWSW,0	;test if viewport active
	JNZ	ClsStart	;if so, then just redisplay keys
	MOV	AH,7		;else erase screen and redisplay keys

;	AL contains the mode for the call to B$CLRSCN.
;	AH contains a bit mask to execute the proper combination
;	    of routines after B$CLRSCN.
;		1 - clear the graphics viewport
;		2 - refresh the function key display
;		4 - home the cursor to the current text window

ClsStart:
	CALL	B$CLRSCN	; clear the screen with value in AL
	JB	ClsError	;if error, then jump to report it

	TEST	AH,1		;test if graphics viewport is initialized
	JZ	ClsNoViewInit	;if not, then jump
	PUSH	AX		;save bit mode and bit mask over call
	CALL	[b$VWCLR_PTR]	;initialize viewport variables
	POP	AX		;and restore it
ClsNoViewInit:

	TEST	AH,2		; test if keys are to be redisplayed
	JZ	ClsNoKeys	; brif not
	CALL	B$KEYDSP	; redisplay key line or blank last line
ClsNoKeys:			

	TEST	AH,4		; test if text cursor to be homed
	JZ	ClsReturn	; brif not
	CALL	B$WHOME		; DX has home position
	CALL	B$SCNLOC	; display user cursor.  TRASHES AX, so
				; don't get any ideas about moving this
				; up before the call to B$KEYDSP.
ClsReturn:
cEnd

ClsError:
	JMP	B$ERR_FC	;Bad Parm, complain.

	SUBTTL	CSRLIN and POS functions
	PAGE
;***
;B$CSRL - return current line (row) of the cursor
;
;Purpose:
;	Runtime enty point.
;	Return current 1-relative line (row) of the cursor on the screen.
;Entry:
;	None.
;Exit:
;	AX = screen row
;Uses:
;	Per convention
;Exceptions:
;	None.
;****
cProc	B$CSRL,<PUBLIC,FAR>	
cBegin				

	MOV	DX,b$CURSOR	; place screen row in DL, column in DH
	CMP	DH,b$CRTWIDTH	; past last physical column?
	JBE	VALUE_OK	; brif not -- row is ok
	CALL	B$CRLF		; adjust DL, DH trashed by CBW anyway
VALUE_OK:			
	XCHG	AX,DX		; return line in AL
	CBW			; clear high byte
cEnd				


;***
; B$FPOS - POS(n) function
;
; Purpose:
;	Runtime Entry Point.
;	Return the 1-relative horizontal screen position of the cursor.
; Input:
;	NONE
; Output:
;	AX= position (1-relative)
; Modifies:
;	F
; Exceptions:
;	NONE
;****
cProc	B$FPOS,<PUBLIC,FAR>	
parmW	Dummy			
cBegin				
	MOV	AL,b$CSRX	; get 1-relative column position
	CMP	AL,b$CRTWIDTH	; past last physical column?
	JBE	POS_OK		; brif not -- value OK
	MOV	AL,1		; assume first column
POS_OK:				
	CBW			; clear high byte
cEnd				

	SUBTTL	KEY statement
	PAGE
;***
;B$KFUN - KEY ON, KEY OFF, KEY LIST
;
;Purpose:
;	Runtime Entry Point.
;	Executes KEY ON, KEY OFF, or KEY LIST depending on input
;Entry:
;	fAction = 0 - KEY OFF
;		  1 - KEY ON
;		  2 - KEY LIST
;Exit:
;	None.
;Uses:
;	Per convention.
;Exceptions:
;	None.
;****
cProc	B$KFUN,<PUBLIC,FAR>	
parmW	fAction 		
cBegin				
	MOV	AX,100H 	;AH=scroll delta, AL=scroll flag (off)
	MOV	CX,fAction	;get action flag
	JCXZ	KEYOFF		;key off
	LOOP	KEYLST		;brif Key list

;	KEY ON...
	MOV	AX,-1		;AH=scroll delta, AL=scroll flag (ON)
KEYOFF:
	CMP	AL,b$KEY_SW	;state change?
	MOV	b$KEY_SW,AL	
	JZ	KEYXX		;Brif same, do nothing
	CALL	B$KEYDSP 	;On, Display on 25th line.
	JMP	SHORT KEYXX	;exit
KEYLST: 			
DbAssertRel	CX,E,1,CN_TEXT,<Illegal flag as input for B$KFUN>
	CALL	KEYLIST 	
KEYXX:
cEnd				

	PAGE
;***
;KEYLIST - List function key definitions
;
;Purpose:
;	Prints all currently defined function keys.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	Per convention.
;Exceptions:
;	None.
;****
cProc	KEYLIST,<NEAR>,<SI,DI>
cBegin
	MOV	DI,OFFSET DGROUP:b$STRTAB ;function key str descriptors
	MOV	CX,NUM_FKEYS	; Keys to the Screen, default 12 for Ronco
	XOR	DL,DL		;DL = FN key counter
	TEST	b$RcoFlg,0FFH	; is Ronco keyboard presented ?
	JNZ	KEY_LIST_0	; Brif yes
	DEC	CX		
	DEC	CX		; AT keyboard has 10 function keys
KEY_LIST_0:
	INC	DL		
	MOV	AL,"F"
	CALL	B$$WCHT
	CALL	KEY_DSP_NUM	;Display the Key number.
	MOV	AL," "
	CALL	B$$WCHT
	PUSH	CX
	MOV	CX,[DI] 	;get char count of string
	JCXZ	KEY_LIST_3
	MOV	SI,[DI+2]	;get ptr to string
KEY_LIST_1:
	LODSB
	OR	AL,AL
	JZ	KEY_LIST_3
	CMP	AL,ASCCR
	JNZ	KEY_LIST_2
	MOV	AL," "
KEY_LIST_2:
	CALL	B$$WCHT
	LOOP	KEY_LIST_1
KEY_LIST_3:
	MOV	AL,ASCCR
	CALL	B$$WCHT
	POP	CX
	ADD	DI,4		;point to next FN key SD
	LOOP	KEY_LIST_0	
cEnd				

	PAGE
;***
;KEY_DSP_NUM - convert function key number to 2 chars and display them
;
;Purpose:
;	Converts function key number in DL to ascii chars and
;	displays 2 chars (leading space if num < 10
;Entry:
;	DL - function key number
;Exit:
;	None.
;Uses:
;	Per convention.
;Preserves:
;	BX,CX,DX
;Exceptions:
;	None.
;****
cProc	KEY_DSP_NUM,<NEAR>	
cBegin				
	MOV	AL,DL		;get fn key number
	AAM
	OR	AX,"00"
	CMP	AH,"0"
	JNZ	KEY_DSP_NUM2
	XCHG	AH,AL
	MOV	AL," "
KEY_DSP_NUM2:
	PUSH	AX
	MOV	AL,AH
	CALL	B$$WCHT		;Output MSD
	POP	AX
	JMP	B$$WCHT		;Output LSD
cEnd	nogen			;returns through B$$WCHT

	SUBTTL	Screen function
	PAGE
;***
;B$FSCN - SCREEN Function
;
;Purpose:
;	Syntax: x = SCREEN(row,col [,z])
;
;		Returns the Ordinal of the char on the screen
;		at row,col.
;
;	If z is given, and non-zero, then:
;		Returns the Color Attribute of the character
;		on the screen at row,col.
;Entry:
;	Row
;	Column
;	fAttr -     If non-zero then return Attribute.
;		    If zero then return character Ordinal.
;Exit:
;	[AX] -	Contains character ordinal or attribute value.
;Uses:
;	Per Convention
;Exceptions:
;	B$ERR_FC
;****
cProc	B$FSCN,<PUBLIC,FAR>	
parmW	Row			
parmW	Column			
parmW	fAttr			
cBegin				
	MOV	DX,Row		
	MOV	AX,Column	

	OR	AH,DH		
	JNZ	SCF_ERROR	;Out of range if either GT 255

;	It is assumed that both b$CRTWIDTH & B$LINCNT will be less than 255

	DEC	DX		; For comparison purposes make AX & DX
	DEC	AX		; 0-relative

	CMP	AL,b$CRTWIDTH	; Is Y greater than the number of rows?
	JAE	SCF_ERROR	;Error if so.
	CMP	DL,B$LINCNT	;Check for parameter range
	JAE	SCF_ERROR	;1..B$LINCNT-1 if keys on, 1..B$LINCNT if off

	INC	DX		; Bring AX & DX back
	INC	AX		; to 1-relative values

	MOV	DH,AL		;DH=col, DL=row
	cCALL	B$SCREEN 	; [AX] = Char read at position
				; [BX] = Attribute at position

	XCHG	AX,BX		; Get Attribute in AX
	CMP	fAttr,0		; Was attribute wanted?
	JNE	FSCN_RET	; Brif so - AX contains attribute
	XCHG	AX,BX		; AX = Character
				; else return character in AX

FSCN_RET:			; Common exit point

cEnd				

SCF_ERROR:
	JMP	B$ERR_FC	;Generic Complaint

sEnd	CN_TEXT 		
END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\id_util.asm ===
TITLE	id_util.asm - internal debug utilities
;***
;id_util.asm - internal debug utilities
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Utilities used for non-RELEASE versions of the common runtime.
;
;****************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc


	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\hexoct.asm ===
TITLE	HEXOCT - OCT, HEX functions
;***
; HEXOCT - OCT, HEX functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - HEX$ Function - calls B$FHEX with 4-byte integer parm.
;
;      v$ = HEX$(n)
;	     |
;	 B$FHEX
;
;
; - OCT$ Function - calls B$FOCT with 4-byte integer parm.
;
;      v$ = OCT$(n)
;	     |
;	 B$FOCT
;
; - BIN$ Function - calls B$FBIN with 4-byte integer parm.
;
;      v$ = BIN$(n)
;	     |
;	 B$FBIN
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	ST_TEXT
	USESEG	NH_TEXT
	USESEG	_DATA

	INCLUDE seg.inc

sBegin	NH_TEXT
	externNP B$STALCTMPCPY
sEnd	NH_TEXT

assumes CS,ST_TEXT
sBegin	ST_TEXT

	externNP B$FrameAFE	; advanced feature error + frame setup

;***
;B$FBIN,B$FHEX,B$FOCT - Convert I4 number to binary, hex, or octal string
;
;Purpose:
;	Runtime Entry points.
;	Create a string of minimum length (no leading zeros) that represents
;	the value of the number in binary, octal or hex.
;Entry:
;	parmD = I4 Integer value to be converted to a string
;Exit:
;	AX = Address of string descriptor
;Uses:
;	Per convention.
;Exceptions:
;	B$ERR_OM
;****
cProc	B$FBIN,<PUBLIC,FAR>	;BIN$ function
cBegin	<nogen> 		
	JMP	B$FrameAFE	; advanced feature error + frame setup
cEnd	<nogen> 		;and convert to string

cProc	B$FHEX,<PUBLIC,FAR>	;HEX$ function
cBegin	<nogen> 		
	MOV	CX,0F04H	;CH=mask, CL=shift count
	JMP	SHORT CONVERT	;use common conversion routine to pick param
cEnd	<nogen> 		;and convert to string

cProc	B$FOCT,<PUBLIC,FAR>	;OCT$ function
cBegin	<nogen> 		
	MOV	CX,0703H	;CH=mask, CL=shift count
cEnd	<nogen> 		;fall into conversion routine

.erre	ID_SSEQDS		;assumes SS=DS

cProc	CONVERT,<FAR>,<ES,DI>
parmD	Val			;I4 parameter for above routines
localW	BufTop			;Top of string buffer
localV	Buf,30			;32 byte buffer for string
cBegin
	PUSH	DS		;set ES=DS
	POP	ES
	MOV	BX,WORD PTR[Val];DX:BX = I4 to be converted
	MOV	DX,WORD PTR[Val+2]
	XOR	AH,AH		;init char count
	LEA	DI,BufTop	;set up to build string on stack
	STD			;move from high to low

; At this point the following conditions exist:
;	AH = Character count
;	CH = Mask
;	CL = Shift count
;	DX:BX = I4 to convert
;	DI = pointer to digit buffer
; Perform the conversion by shifting DX:BX by CL bits and masm out
; unused bits with CH.	Take this number and convert to ascii char
; representing digit. Stuff the char in the buffer, bump the char
; count and continue until no non-zero digits remain.

CONVERT_LOOP:
	MOV	AL,BL		;Bring number to accumulator
	AND	AL,CH		;Mask down to the bits that count
;Trick 6-byte hex conversion
	ADD	AL,90H
	DAA
	ADC	AL,40H
	DAA			;Number in hex now
	STOSB			;Save in string
	INC	AH		;Count the digits
	PUSH	CX		;Save mask/shift count
	XOR	CH,CH		;zero out mask, leaving shift count

SHIFT_LOOP:
	SHR	DX,1		;shift low bit into carry, zero high bit
	RCR	BX,1		;rotate carry into low word
	LOOP	SHIFT_LOOP	;repeat shift count times

	POP	CX		;recover mask/shift count
	PUSH	BX
	OR	BX,DX		;is rest of I4 = 0?
	POP	BX
	JNZ	CONVERT_LOOP	;brif not, convert next digit

	CLD			;Restore direction UP
	INC	DI		;Point to most significant digit
	MOV	BL,AH		;Digit count in BX (BH already zero)
	MOV	DX,DI		;Put string pointer in DX
	CALL	B$STALCTMPCPY	;Allocate string and copy data in
	XCHG	AX,BX		;return string descriptor in AX
cEnd
sEnd	ST_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\ifout.asm ===
TITLE	IFOUT - Integer Free-format numeric output
;***
; IFOUT - Integer Free-format numeric output
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Integer only versions of the routines in FOUT.ASM.  These routines
;	will call the floating point versions only if the floating point
;	versions have been linked in.  This prevents a print statement from
;	automatically pulling in the math pack.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	USESEG _DATA
	USESEG _BSS
	USESEG MT_TEXT

	INCLUDE seg.inc
	INCLUDE rtps.inc


sBegin	_DATA


	externB B$AC		;Floating accumulator
sEnd	_DATA

sBegin	_BSS
	externB b$VTYP

	;NOTE: The buffer consists of b$SIGN, b$FOBUF, and BUFFER_END
	;NOTE: I.E. the buffer is 36 bytes long

	globalB b$SIGN,,1	;Sign of Value returned from B$CONASC
	globalB b$FOBUF,,34	;Numeric output buffer (integer + floating)
	staticB BUFFER_END,,1	;Last byte of buffer
sEnd	_BSS


sBegin	MT_TEXT
	assumes CS,MT_TEXT

	externNP B$ERR_FC


	externNP B$FloatFOUTBX	

;***
;B$IFOUT - Free-format numeric output (FAR interface)
;
;Purpose:
;	Format number for printing, using BASIC's formatting rules.
;Entry:
;	BX = ptr to Number to be formatted
;	AL = Val type - VT_I2, VT_I4, VT_R4, VT_R8 or VT_CY
;Exit:
;	BX = Address of ASCII string, terminated by 00
;	AX = Length of string (not including terminating 00)
;Uses:
;	Per convention. (DS, ES, SI, DI, BP preserved. PSW.D clear)
;Exceptions:
;	None
;****
cProc	B$IFOUT,<PUBLIC,FAR>,<BP>
cBegin
	MOV	[b$VTYP],AL
	cCall	B$FOUTBX	;call common fouter
cEnd


;***
;B$FOUTBX - Free-format numeric output
;
;Purpose:
;	Format number for printing, using BASIC's formatting rules.
;
;Entry:
;	BX = ptr to Number to be formatted
;	[b$VTYP] = VT_I2, or  VT_I4
;
;Exit:
;	BX = Address of ASCII string, terminated by 00
;	AX = Length of string (not including terminating 00)
;
;Uses:
;	Per convention.
;
;Exceptions:
;	B$ERR_FC if invalid b$VTYP.
;****

cProc	B$FOUTBX,<PUBLIC,NEAR>	;NOTE: Prolog doesn't put anything on stack
cBegin

	MOV	AX,[BX] 	;AX = low word of I4 or I2
	CWD			;Assume I2 (and convert to I4)
	CMP	b$VTYP,VT_I2	; Is it an I2
	JE	Got_Num 	;Yes, check if negative
	CMP	b$VTYP,VT_I4	; Is it an I4
	JNE	FloatingFoutBX	;No, pass it on to the floating point fout.
	MOV	DX,[BX+2]	;DX = High word of I4
Got_Num:
	XOR	BX,BX	;Get a Zero
	XCHG	AX,DX	;AX:DX = I4
	MOV	CL,' '	;Assume that number is positive
	AND	AX,AX	;Check for positive
	JGE	Positive	;It is!
	MOV	CL,'-'	;Flag it as a negative number
	NEG	DX	;And convert it to positive
	ADC	AX,BX	;Add in carry (BX = 0)
	NEG	AX
Positive:
	PUSH	SI	;Preserve original SI
	PUSH	CX	;Save Sign for later
	MOV	SI,OFFSET DGROUP:BUFFER_END
	MOV	BYTE PTR [SI],BL ;Zero Terminate the buffer.
	PUSH	SI	;Save this value for later
	MOV	CX,10	;Dividing by 10

Div_Loop:
	PUSH	DX	;Save Low part of I4
	XOR	DX,DX	;DX:AX = High Word of I4 (extended to 4 bytes)
	DIV	CX	;DX = Remainder, AX = Quotent
	POP	BX	;Restore Low part of I4
	XCHG	AX,BX	;DX:AX = Low Word of I4,  BX = High Quotent
	DIV	CX
	XCHG	AX,DX	;AX = Remainder of I4/10, BX:DX = Quotent of I4/10
	ADD	AL,"0"	;adjust for ASCII
	DEC	SI
	MOV	BYTE PTR [SI],AL
	MOV	AX,BX	;AX:DX = I4 again
	OR	BX,DX	;Are we done yet?
	JNZ	Div_Loop	;Nope, get next digit.
;
;Finish up
;

	POP	AX	;Restore starting point
	SUB	AX,SI	;AX = # digits
	POP	CX	;Restore Sign
	DEC	SI
	MOV	BYTE PTR [SI],CL;Put sign on number
	MOV	BX,SI	;BX = Start of string
	INC	AX	;Include sign in count
	POP	SI	;Restore original SI
cEnd

FloatingFoutBX:
	JMP	B$FloatFOUTBX	; Call the routine directly

;***
; B$ASCRND - Round ASCII digits
;
;Purpose:
;	Round number to the specified number of digits. Eliminate trailing
;	zeros from digit count.
;
;Inputs:
;	AL = Number of digits wanted
;	CX = Number of digits presently in number
;	DX = Base 10 exponent (D.P. to right of digits)
;	SI = Address of first digit
;
;Outputs:
;	CX = Number of digits now in number (always <= request)
;	DX = Base 10 exponent of rounded number
;	SI = Address of first digit of rounded number
;	DI = Address of formatting buffer, b$FOBUF
;
;Registers:
;	Only ES, BX, BP preserved.
;****
cProc	B$ASCRND,<NEAR,PUBLIC>,<ES>
cBegin

	PUSH	DS		;ES=DS
	POP	ES
	MOV	DI,SI
	CBW			;Zero AH (AL <= 18)
	ADD	DI,CX		;Point past last digit
	CMP	AX,CX		;Any extra digits?
	JAE	ZSCAN		;If not, no rounding
	XCHG	AX,CX		;Say we'll return number requested
	SUB	AX,CX		;See how many digits we're trimming
	ADD	DX,AX		;Increase exponent accordingly
	SUB	DI,AX		;Point to first extra digit
	MOV	AL,"0"
	XCHG	AL,[DI] 	;Get rounding digit and replace it with zero
	CMP	AL,"5"		;Do we need to round?
	JB	ZSCAN
	JCXZ	RNDALL
RND:
	DEC	DI		;Point to digit to round
	MOV	AL,[DI] 	;Get a digit that needs incrementing
	INC	AL
	CMP	AL,"9"+1	;Did we overflow this digit position?
	JB	STORND		;If not, store it and we're done
	INC	DX		;Otherwise exponent must be adjusted
	LOOP	RND		;We'll need to round next digit
RNDALL:
	INC	CX		;Must have at least one digit
	MOV	AL,"1"		;If we rounded all digits, must be to 1
STORND:
	STOSB			;Save rounded digit
ZSCAN:
;DI points just past the digits we want. Check for trailing zeros.
	DEC	DI		;Point to last digit
	MOV	AH,CL		;Remember how many digits we started with
	MOV	AL,"0"
	STD			;Scan DOWN
	REPE	SCASB		;Scan for "0"s
	CLD			;Restore direction UP
	INC	CX		;Number of digits left
	SUB	AH,CL		;Number of digits skipped
	ADD	DL,AH		;Increase base 10 exponent accordingly
	ADC	DH,0
	MOV	DI,OFFSET DGROUP:b$FOBUF
cEnd

sEnd	MT_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\iocons.asm ===
TITLE	IOCONS - Machine Independent CONS: Device Support
;***
; IOCONS - Machine Independent CONS: Device Support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; Contains the code to drive the machine independant "CONS:" device. Under DOS
; 2/3, we use direct console I/O to output data, and under DOS 5, VIO calls.
; This is a redirectable output only device which DOES get run through device
; drivers for escape sequence detection.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	

	USESEG	CN_TEXT 	
	USESEG	_DATA		

	INCLUDE seg.inc 	
	INCLUDE idmac.inc	
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE rtps.inc	; constants shared with QBI


sBegin	CN_TEXT 		
	assumes CS,CN_TEXT	

	externNP	B$ERR_BFM	
	externNP	B$LHDALC_CPCT	
	externNP	B$OPEN_DEV 	
	externNP	B$CON_SOUT	

	PAGE
	SUBTTL	CONS (Raw-CRT output Dispatch Table and Routines)

;   equates to make dspnam generate tables that dispatch directly to
;   the error routines.

CON_EOF 	EQU	B$ERR_BFM
CON_LOC 	EQU	B$ERR_BFM
CON_LOF 	EQU	B$ERR_BFM
CON_RANDIO	EQU	B$ERR_BFM
CON_BAKC	EQU	B$ERR_BFM
CON_SINP	EQU	B$ERR_BFM
CON_BLKIN	EQU	B$ERR_BFM
CON_BLKOUT	EQU	B$ERR_BFM


;   Device Independent Interface

DSPMAC	MACRO	func
	DW	CON_&func	;;Define Dispatch Table for Specific Device
	ENDM

;Console Dispatch Table 	;must not be at CS:0
;

labelNP <PUBLIC,B$D_CONS>	
	DSPNAM			;make dispatch table (from devdef)


;*** 
;CON_OPEN - perform any device dependent open functions.
;
;Purpose:
;	Open the CONS: device for output.
;
;
;Entry:
;	[AL]=  device id
;		0 if default device,
;		1..n for Disk A:, B:, ...
;		-1..-n for non-disk devices
;	[BX] = file number (0..n)
;	[CX] = random record size if [FILMOD] = random (ignored)
;	[DI] = device offset (2=SCND, 4=SCRN, etc.)
;	[FILMOD] = file mode
;		 MD.SQI = 1 ;sequential input
;		 MD.SQO = 2 ;sequential output
;		 MD.RND = 3 ;random
;		 MD.APP = 4 ;append
;Exit:
;	[SI] points to new FDB
;	FDB is linked into FDB chain with all standard fields initialized.
;Uses:
;	AX,DX
;
;Exceptions:
;	None, though exits through B$OPEN_DEV which can generate errors
;******************************************************************************

cProc	CON_OPEN,<NEAR>		
cBegin
	MOV	AH,MD_SQO	; allow open for output only
	MOV	DL,255D 	; initial file width=255
	JMP	B$OPEN_DEV	; allocate FDB with no buffer
				; and return
cEnd	<nogen>

;***
;CON_CLOSE - Console file close      ;[6-30-83 5.40 pbs]
;
;Purpose:
;	Close the CONS: device and deallocate its file block.
;
;Entry/Exit/Uses/Exceptions:
;	Same as B$LHDALC_CPCT
;****
CON_CLOSE EQU	B$LHDALC_CPCT	; jump directly to deallocate file block
				; compacts heap after deallocation

;***
;CON_GPOS - return current file position.
;
;Purpose:
;	Returns the current column position of CONS:.  Since CONS: is a
;	stream device without a width, 0 is returned instead.
;
;Entry:
;	SI points to File-Data-Block.
;
;Exit:
;	[AH] = current file column. (0-relative)
;
;Uses:
;	SI is an entry value
;
;Preserves:
;	AL, BX, CX, DX
;
;Exceptions:
;	None.
;****
cProc	CON_GPOS,<NEAR>
cBegin
	MOV   AH,0		
cEnd	<nogen> 		;fall through to return

;***
;CON_DWID, CON_WIDTH - Set CONS: width
;
;Purpose:
;	This function fullfills the requirement that all devices
;	have a routine to set their width (so that the dispatch
;	table does not have holes.  Since CONS: has no concept
;	as width, these routines just return.
;****
labelNP	<CON_DWID>		; no action necessary for CONS:
cProc	CON_WIDTH,<NEAR>	;so just return
cBegin
cEnd

;***
;CON_GWID - get device width for CONS:
;
;Purpose:
;	Return the width of the CONS: device.  Since CONS: does not
;	have a width, this routine will return 255 (= infinite width).
;
;Entry:
;	SI - Pointer to File Data Block
;
;Exit:
;	[AH] = device width = 255
;
;Uses:
;	SI is an entry condition.
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****
cProc	CON_GWID,<NEAR>
cBegin
	MOV	AH,255		; infinite width
cEnd

;***
;CON_SOUT - Write one byte to the console.
;
;Purpose:
;	This routine will send a single byte to the CON: device.  This
;	is a redirectable output device.
;
;Entry:
;	AL = Byte to output
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX,BX,CX,DX
;
;Exceptions:
;	None.
;****
CON_SOUT	EQU	B$CON_SOUT	

sEnd	CN_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\iolpt.asm ===
TITLE	IOLPT  - Line printer Device Drivers
;***
; IOLPT  - Line printer Device Drivers
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains the device independent printer routines for
;	the BASIC Compiler.  While this module is intended for use with
;	the IBM Personal Computer, there is only a small amount which
;	actually depends on this fact.
;
; BASIC Syntax mapping to included runtime entry points:
;
; - LPOS Function:
;
;      LPOS(x)
;	 |
;     B$LPOS
;
; - WIDTH Statement:
;
;    Four different Syntax possibilities map to four runtime entry points:
;
;      WIDTH size			 WIDTH LPRINT size
;	 |				   |
;      B$WIDT				 B$LWID
;
;
;      WIDTH filenumber, size		 WIDTH device, size
;	 |				   |
;      B$DWID				 B$DWID
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	CONST		
	USESEG	_DATA		
	USESEG	_BSS		
	USESEG	OI_TEXT 	
	USESEG	DV_TEXT 	
	USESEG	DK_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE ascii.inc
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE const.inc	

	TTY	EQU	0	;default for b$PTRFIL is TTY

	PRSTM	EQU	0	;print statement
	CHANL	EQU	1	;#
	USING	EQU	2	;using
	WRSTM	EQU	4	;write statement
	LPSTM	EQU	8	;lprint statement

iniwid= 80			;Initial printer width

sBegin	_DATA			

	externB b$PRFG		;flag for PRINT/LPRINT/WRITE [#][USING]

	EXTRN	b$ERDEVP:word

;error codes from int 24 handler
;		00 - Write Protected.
;	       *01 - Unknown Unit
;	       *02 - Not Ready
;		03 - Unknown command
;		04 - Data Error
;		05 - Bad Drive structure length
;		06 - Seek Error
;		07 - Unknown Media
;		08 - Sector not found
;	       *09 - Printer out of paper
;		10 - Write Fault (hard disks only)
;		11 - Read Fault
;		12 - Other error.


iniwid= 80			; Initial printer width

B$LPTWID DB	NUM_LPT DUP(INIWID,0) ;Width/initial position
B$LPTCRF DB	NUM_LPT DUP(0,0) ;CR flag/unused field
				;Must follow B$LPTWID
				;width/pos field
	LPDCBSZ = NUM_LPT * 2



;LPT Device Control Block field definitions:

_LPWID= 0			;device width (columns per line)
_LPPOS= 1			;current column device is in

;LPT Device Flag Block field definitions:
_LPFLG= lpdcbsz 		;Boolean attributes mask for this device
				;Attribute definitions
	_LPCRF= 1		;non-zero=last char sent was Carriage Return
_LPunused=lpdcbsz+1		;Unused field.

LPTPOS	EQU	B$LPTWID+_LPPOS

LPTWIDTH EQU	B$LPTWID[DI+2*DN_LPT1+_LPWID] ;Base for indexed by
POSITION EQU	B$LPTWID[DI+2*DN_LPT1+_LPPOS] ;	device number

sEnd	_DATA			

sBegin	CONST			

	externW b$FILVEC	
LPNAMES DB	"LPT1LPT2LPT3LPT4"
LPERRS	DW	1,2,9

sEnd	CONST			

sBegin	_BSS			
	externW b$PTRFIL	
	externW b$ERDEV 	;defined in GWDATA.ASM
	externW b$LPTFDB	; defined in GLOBALS.INC
	externB	b$PATHNAM	; defined in GWINI.ASM
	externB b$EOL,,1	; set when in B$$WCLF


sEnd	_BSS			


sBegin	DK_TEXT
	externNP B$WCHSET	; in prnval.asm, set dispatch vector
sEnd	DK_TEXT

sBegin	DV_TEXT 		
	externNP b$devused	; drag in dvinit for lprint support
	externNP B$CLSLPT	
sEnd	DV_TEXT 		

assumes CS,OI_TEXT		
sBegin	OI_TEXT 		

;	Run-time Entries

	PUBLIC	B$D_LPT1
	PUBLIC	B$D_LPT2
	PUBLIC	B$D_LPT3
	PUBLIC	B$D_LPT4

;	Run-time Externals

	externNP B$OPNLPT	
	externNP B$SNDLPT	
	externNP B$UPCASE
	externNP B$LHDALC_CPCT	; deallocate FDB and compact local heap
	externNP B$OPEN_DEV	
	externNP B$ERR_FC	
	externNP B$ERR_BFN	
	externNP B$ERR_IOE	
	externNP B$ERR_DNA	
	externNP B$ERR_DTO	
	externNP B$ERR_OTP	


;	Illegal Device Functions

LPT_EOF EQU	B$ERR_FC
LPT_LOC EQU	B$ERR_FC
LPT_LOF EQU	B$ERR_FC
LPT_RANDIO EQU	B$ERR_FC
LPT_BAKC EQU	B$ERR_FC
LPT_SINP EQU	B$ERR_FC
LPT_BLKIN EQU	B$ERR_FC	  ;5.41 PBS 28/jun/83
LPT_BLKOUT EQU	B$ERR_FC

;	Device Independent Printer Interface

DSPMAC	MACRO	func
	DW	LPT_&func
	ENDM





;-----	File Action Routines  -----------------------------------------------


;	These routines are all called from the file dispatcher.

;	The registers are set up as follows:

;	   (ES:)[SI] = file data block address (points to file mode field)
;		(DI) = device offset  (0 = disk , 2 = next , 4 = next , ...)
;		(AH) = function code of routine
;		(AL,CX,DX,BX) = parameters for each routine

;	These routines are free to use SI and DI as temporaries


fileio	PROC

;*** 
; LPT_OPEN - OPEN statement for LPTn:
;
;Purpose:
;	Allocates FDB for LPTn:, and opens it for output.
;
;Entry:
;	(BX) = file number
;	(AL) = device number for OPEN
;	(CX) = variable record length
;	b$PATHNAM = null-terminated options string (including the "LPTn:")
;Exit:
;	(ES:)[SI] = *FDB
;
;Uses:
;
;Preserves:
;	BX, CX
;
;Exceptions:
;
;******************************************************************************
LPT_OPEN:
	PUSH	BX
	PUSH	CX
	PUSH	AX		;save device number

	MOV	AH,MD_SQO+MD_RND ; valid file modes

	MOV	DL,LPTWIDTH	; DL = width
	CALL	B$OPEN_DEV	; allocate FDB with no buffer
	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB

;Parse option string.
	PUSH	SI		; save FDB pointer
	MOV	SI,OFFSET DGROUP:b$PATHNAM+5 ; get the options string

	CALL	GETPR0		;Get 1st char in Filename, skipping blanks
	JZ	Default 	;If no "BIN" option, default to ASC
LPRBIN: CMP	AL,"B"		;BIN?
	JNZ	BadLptOpt	;no, bad LPT option.
	CALL	GETPRM
	CMP	AL,"I"		; I?
	JNZ	BadLptOpt	;no, error
	CALL	GETPRM
	CMP	AL,"N"		; N?
	JNZ	BadLptOpt	;no, error
	CALL	GETPR0		;Get next non-blank char
	JNZ	BadLptOpt	;If not EOS then bad LPT option
	POP	SI		
	OR	FileDB.FD_FLAGS,FL_BIN ;indicate binary mode
	JMP	SHORT LPRBIX
Default:
	POP	SI		
	AND	FileDB.FD_FLAGS,NOT FL_BIN ;indicate ascii mode
LPRBIX:
	POP	AX		;restore device number
	PUSH	AX		;and save it again
	NEG	AL		; convert to positive number
	CBW			; AH = 0
	SHL	AX,1		;get -2*device number
	MOV	DI,AX		;move to DI
	CALL	B$GLPUID 	;get printer number in AH
	CALL	B$OPNLPT	; open the device
	FDB_PTR ES		;restore FDB SEG in ES after movement
	OR	AH,AH		;test for error
	JZ	NLPERR		;if none, then jump around
	CALL	B$LHDALC_CPCT	; Deallocate the FDB and compact local heap
	JMP	SHORT LPERR	;if so, then branch
NLPERR:
	MOV	FileDB.FD_HANDLE,BX ;store handle away in FDB
	POP	AX		;restore register

	pop	cx
	pop	bx
	RET

BadLptOpt:
	POP	SI		; SI = *FDB
	CALL	B$LHDALC_CPCT	; Deallocate the FDB and compact local heap
	JMP	B$ERR_BFN	;bad file name
;Get Next Option Char forcing upper case
; Exit - Z = end-of-statement, else [AL]=byte
;	SI not advanced if End Of String

GETPRM:
	CMP	BYTE PTR [SI],0
	JNZ	GetNxt		;Brif EOS
	RET
GetNxt: LODSB
	JMP	SHORT GETPR1

;Get Next Option Char skipping blanks and forcing upper case
; Exit -Z = end-of-statement, else [AL]=byte
;	SI not advanced if End Of String

GETPR0:
	LODSB			;Get next char
	CMP	AL," "
	JZ	GETPR0		;Ignore Blanks
	CMP	AL,0		;Is it End Of String?
	JZ	GETPRX
;++Not needed unless a second option added.
;	 CMP	 AL,","
;	 JNZ	 GETPR1 	 ;Brif not ","
;	 OR	 AL,AL		 ;set NZ (not end-of-statement)
;	 STC			 ;set carry
;	 RET			 ;Comma returns: NZ and TC
GETPR1:
	call	B$UPCASE
	OR	AL,AL		;Chars return NZ and NC
GETPRX:
	RET			;EOS returns TZ and NC
;++

B$D_LPT1:			;moved here out of module offset 0
B$D_LPT2:
B$D_LPT3:
B$D_LPT4:
	DSPNAM

	page

;*** 
;LPT_DWID -- WIDTH device statement.  Added with [16]
;
;Purpose:
;
;Entry:
;	(AL) = device number
;	(DL) = device width
;	(DI) = device offset
;Exit:
;	None
;Uses:
;	None
;Exceptions:
;	None
;
;******************************************************************************
cProc	LPT_DWID,<NEAR>
cBegin
	MOV	LPTWIDTH,DL	; Set new printer width (indexes by DI)
	CMP	AL,DN_LPT1	; LPT1:?
	JNE	WidthRet	; brif not -- don't set LPRINT width
	MOV	b$LPTFDB.FD_WIDTH,DL ; set width for LPRINT
WidthRet:			
cEnd

;*** 
;LPT_WIDTH -- WIDTH file statement.
;
;Purpose:
;
;Entry:
;	(DL) = device width
;	(DI) = device offset
;Exit:
;	None
;Uses:
;	None
;Exceptions:
;	None
;
;******************************************************************************
LPT_WIDTH:
	MOV	FileDB.FD_WIDTH,DL  
	RET

	page


LPERRT: DW	OFFSET B$ERR_DNA ; 1 = device not available
	DW	OFFSET B$ERR_DTO ; 2 = time out
	DW	OFFSET B$ERR_OTP ; 3 = out of paper

LPERR:
	CMP	AH,3
	JBE	ERROR1		;branch if legal error code
	JMP	B$ERR_IOE	  ;map all other error codes to I/O error
Error1: MOV	AL,AH
	cbw			; [AX]=error code 1..n
	DEC	AX		;[AX]=error code 0..n
	shl	ax,1		;[AX]=offset into error dispatch table
	xchg	ax,bx
	mov	si,offset dgroup:lpnames
	pop	ax
	mov	al,ah
	cbw
	shl	ax,1
	shl	ax,1
	add	si,ax
	mov	di,[b$ERDEVP+2]	;get ptr to erdev$ string
	PUSH	ES		
	PUSH	DS		
	POP	ES		
	movsw
	movsw
	POP	ES		
	mov	[b$ERDEVP],4
	mov	ax,lperrs[bx]
	mov	[b$ERDEV],ax
	JMP	word ptr lperrt[BX] ; asmter this way



;Raw Line Printer Output routine
; Entry - [AL]=byte to be sent to current line printer
;	  [AH]=device id (0..n)
; Exit	- Flags used, All other registers preserved.

LPROUT:
	PUSH	AX
	PUSH	BX
	MOV	BX,FileDB.FD_HANDLE ; get handle for routine
	CALL	B$SNDLPT	; Call OEM routine to output to printer
	OR	AH,AH
	JNE	LPERR		;branch if OEM routine detected error
	POP	BX
	POP	AX
	RET



;*** 
; LPT_SOUT -- Sequential output.
;
;Purpose:
;	This routine keeps track of column position, expands tabs, and forces
;	a carriage return when line width is exceeded.
;
;Entry:
;	(ES:)[SI] = *FDB
;	DI = -2*device id
;	[AL] = byte to be output.
;
;Exit:
;	None
;
;Uses:
;	SI, DI can be changed.
;
;Preserves:
;	All other registers.
;
;Exceptions:
;
;******************************************************************************
cProc	LPT_SOUT,<NEAR>,<DX>	
cBegin				

;	First check if LPRINT is being performed.  If so, then check
;	if it is the first character since it was last closed and do
;	an open operation on LPT1.

	CMP	SI,OFFSET DGROUP:b$LPTFDB ; test if LPRINT
	JNE	NO_LPRINT_OPEN	;if not, then jump
	TEST	b$LPTFDB.FD_FLAGS,FL_LPT_OPN ; test if device is open
	JNE	NO_LPRINT_OPEN	;if so, then jump
	PUSH	AX		;save registers...
	PUSH	BX
	XOR	AH,AH		;will select LPT1
	CALL	B$OPNLPT	; open the device
	OR	AH,AH		;test for any errors
	JNZ	LPERR		;if so, then jump
	MOV	WORD PTR b$LPTFDB.FD_HANDLE,BX ; get handle in FDB
	OR	b$LPTFDB.FD_FLAGS,FL_LPT_OPN ; set the open flag
	POP	BX		;restore registers...
	POP	AX
NO_LPRINT_OPEN:

	PUSH	BX		;save caller's BX
	PUSH	AX		;save char to be output
	CALL	GLPDCB		;DI points to line printer DCB, unit in AH
				; Note interpreter returns unit in AX!
	MOV	BL,AH		;[BL] = device id
	POP	AX		;[AL] = byte to be output
	MOV	AH,BL		;[AH] = device id
	POP	BX		;restore caller's BX

	MOV	DX,WORD PTR _LPWID[DI] ;[DL]=device width, [DH]=current column
	CMP	SI,OFFSET DGROUP:b$LPTFDB	; Test if LPRINT FDB
	JZ	NOTBIN		;branch if so -- not binary mode
	MOV	DL,FileDB.FD_WIDTH	;Get width from FDB

	TEST	FileDB.FD_FLAGS,FL_BIN	; binary mode?
	JZ	NOTBIN		; brif not
	CALL	LPROUT		; Raw output of character
	CALL	$UPDPOS		; DH = new position
	JMP	SHORT SAVPOS	; save new position
	
NOTBIN:
	CALL	$CRIFEL 	;force CR if End-Of-Line
SAVPOS:
	MOV	BYTE PTR _LPPOS[DI],DH ;save new column position
cEnd				


;*** 
; LPOUT1 -- low-level line printer output
;
;Purpose:
;	For IBM Compatibility, the filter performs the following translations
; 		x x x CR x x x    === x x x CR LF x x x
;		x x x CR LF x x x === x x x CR LF x x x
;	If LPT was opened for RANDOM mode, and WIDTH=255, then suppress LF which
;	follow carriage returns for IBM compatibility.
;
;	Eat all LineFeeds which follow CarriageReturns with following algorithm:
;	if (Char <> LF) or (LastWasCR = 0) then output (Char)
;	if (Char = CR) then
;	    LastWasCR = 1
;	    if FDB.MODE<>RANDOM or FDB.WIDTH<>255 then
;		output(LF)
;	else
;	    LastWasCR = 0
;
;	The only case where this is not compatible with IBM is when the user
;	executes:
;		PRINT CHR$(13);CHR$(10);...
;
;	The best way this could have been done was by setting CRONLY=1 in the
;	switch files and letting the device drivers append Line-Feeds if
;	necessary.  It was considered too late to make a change this drastic.
;
;Entry:
;	AL = char to output
;	(ES:)[SI] = *FDB
;
;Exit:
;	DH = new column position
;
;Uses:
;	None
;
;Exceptions:
;
;******************************************************************************
cProc	LPOUT1,<NEAR>		
cBegin				

	CALL	$UPDPOS 	;[DH]=new column position(AL, DH)
	CMP	AL,ASCLF
	JNE	LPOUT2		;branch if not attempting to output LF
	CMP	b$EOL,1	; end-of-line processing ?
	JNE	LPOUT2		; brif not end-of-line processing, the
				; user might be doing something like
				; print chr$(13)+chr$(10)
	TEST	BYTE PTR _LPFLG[DI],_LPCRF
	JNE	LPOUT3		;brif last byte out was CR (eat LF)
LPOUT2:
	CALL	LPROUT		;output the character
LPOUT3:
	AND	BYTE PTR _LPFLG[DI],255-_LPCRF ;reset last byte out was CR flag
	CMP	AL,ASCCR
	JNE	LPOUTX		;return if wasn't carriage return
	OR	BYTE PTR _LPFLG[DI],_LPCRF ;set last byte out CR flag

	CMP	SI,OFFSET DGROUP:b$LPTFDB	; Test if LPRINT FDB
	JZ	OUTLF		;branch if Pseudo FDB (LPRINT)

	CMP	FileDB.FD_MODE,MD_RND	;MODE = RANDOM?
	JNE	OUTLF		; brif not -- print LF after a CR
	CMP	FileDB.FD_WIDTH,255	;WIDTH = 255?
	JE	LPOUTX		; brif so -- suppress LF following CRs
OUTLF:
	PUSH	AX
	MOV	AL,ASCLF
	CALL	LPROUT
	POP	AX
LPOUTX:
cEnd				


$CRIFEL:
	CALL	LPOUT1		; output character
	CMP	DH,DL		; compare column with width
	JB	NOCR		; Brif still room on current line
	CMP	AL,32		; printable character ?
	JB	NOCR		; brif non-printable
	CMP	DL,255		; infinite width ?
	JZ	NOCR		; Brif so (width = 255)
				; else output <CR><LF>

WRICR:				; output <CR>
	PUSH	AX		; save char
	MOV	AL,ASCCR
	CALL	LPOUT1		
	POP	AX		; restore char
NOCR:				
	RET

;$UPDPOS - update column position (called by device out routines)
; Entry - [DH] = current 0-relative column position
;	  [AL] = byte to be output
; Exit	- [DH] = new column position.  All other registers preserved

$UPDPOS: CMP	AL,32
	JB	NPRINT		;branch if not printable (CTL CHR)
	INC	DH		;bump column position
	RET
NPRINT: CMP	AL,ASCCR
	JNE	NOTCR		;branch if not carriage return
ZERPOS: MOV	DH,0		;reset to left margin
	RET
NOTCR:	CMP	AL,ASCBS
	JNE	UPPOSX		;branch if not backspace
	OR	DH,DH
	JE	UPPOSX		;don't decrement below 0
	DEC	DH		;decrement position
UPPOSX: RET



;	GPOS - Get position

;	EXIT	(AH) = device position

LPT_GPOS:
	MOV	AH,POSITION	;Get position (device)
	RET


;	GWID - Get width

;	EXIT	(AH) = file width

LPT_GWID:
	MOV	AH,FileDB.FD_WIDTH  ;Get printer (file) width
	RET


fileio	ENDP

;***
; B$LPOS - Line printer position
;
; Purpose:
;	Get line printer position
; Input:
;	lptID = printer # (map 1 into 0, etc.)
; Output:
;	(AX) = printer position
; Modifies:
;	per convention
; Exceptions:
;	Control may be transfered to B$ERR_FC
;****
cProc	B$LPOS,<PUBLIC,FAR>	
parmW	lptID			
cBegin				
	MOV	BX,lptID	
	CMP	BX,NUM_LPT	;Check for too high
	JA	ercfc
	OR	BX,BX		;Test for 0 - same as 1
	JZ	lpos1
	DEC	BX		;Map 1 to 0
lpos1:	SHL	BX,1		;BX=0,2,4... offset into B$LPTWID
	MOV	AL,LPTPOS[BX]	;Get position for printer #n
	XOR	AH,AH		
	INC	AX		
cEnd				

ercfc:	JMP	B$ERR_FC

;***
; B$LWID - WIDTH LPRINT Statement
;
; Purpose:
;	Sets the LPRINT file width and device width
; Input:
;	newWidth = desired LPRINT file width
; Output:
;	NONE
; Modifies:
;	Per convention
; Exceptions:
;	NONE
;****
cProc	B$LWID,<PUBLIC,FAR>	
parmW	newWidth		
cBegin				
	MOV	DX,newWidth		;  Get New Width for Printer
	or	dh,dh			;  If new widht is >255 Error
	jnz	ercfc			;  and
	or	dl,dl			;  If new width is zero Error
	jz	ercfc			

	MOV	B$LPTWID,DL		;Set printer 1 width
	MOV	b$LPTFDB.FD_WIDTH,DL	;Set LPRINT file width
cEnd				

;GLPDCB - get pointer to LPT Device Control Block
; Entry - [DI] = -2*device id (2,4,..n)
; Exit	- DI points to the device control block for device DI.
;	  [AH] = 0..n for LPT1, LPT2, ...
;		 Note: interpreter returns unit number in AX!

GLPDCB: CALL	B$GLPUID 	; [AH]=unit id (0..n)
	PUSH	AX		;save unit id
	xchg	ah,al
	xor	ah,ah
	SHL	AX,1		;2 fields in DCB
	ADD	AX,OFFSET DGROUP:B$LPTWID
	MOV	DI,AX		;DI points to LPTx device ctl block
	POP	AX		;[AX]=unit id
	RET

;***
;B$LPTECHO
;Purpose:
;	Echo to the line printer.		[13]
;Entry:
;	[AX] = character code
;Exit:
;	none
;Modifies:
;	none ([AX] is preserved)
;****
cProc	B$LPTECHO,<PUBLIC,NEAR>,<DI,SI,AX>
cBegin
	MOV	SI,OFFSET DGROUP:b$LPTFDB	
	MOV	DI,DN_LPT1*-2	; lpt1:
	OR	AH,AH		;  Test for two byte character
	JZ	ONEBYT
	PUSH	AX
	XCHG	AH,AL
	CALL	LPT_SOUT	; Write the high byte first
	POP	AX
ONEBYT:
	CALL	LPT_SOUT	; Then the low byte
cEnd

; Entry - [DI] = -2*device id (2,4,..n)
; Exit	- [AH] = 0..n for LPT1, LPT2, ...
; Uses AH

cProc	B$GLPUID,<NEAR>,<BX>	
cBegin

	MOV	BX,DI
	ADD	BX,2*DN_LPT1
	SHR	BX,1		;[BX]=0, 1. for LPT1, LPT2, ...
	MOV	AH,BL		; return (printer # - 1) * 2 in AH

cEnd


;	File close routines
;	Deallocate file block

cProc	LPT_CLOSE,<NEAR>	
cBegin

	PUSH	BX		;save register
	MOV	BX,FileDB.FD_HANDLE ; get handle of printer
	CALL	B$CLSLPT	; close the device
	POP	BX		;restore the register
	CMP	SI,OFFSET DGROUP:b$LPTFDB ; is this LPRINT?
	JE	LPRINT_CLOSE	;if so, then branch
	CALL	B$LHDALC_CPCT	; deallocate FDB and compact local heap
LPRINT_CLOSE:

cEnd				; return to caller

	SUBTTL	interface for LPRINT preamble
	page
;***
;B$LPRT -- LPRINT preamble
;void B$LPRT(void)
;
;Purpose:
;	This is the only interface for LPRINT preamble.  BASCOM 2.0 uses two
;	preambles, $PR0E for LPRINT and $PR0F for LPRINT USING.  This routine
;	sets up flag, b$PRFG, to 8 (LPSTM) to indicate LPRINT is on going.
;	If there is LPRINT USING, B$USNG will OR the flag, b$PRFG, with
;	USING (=2) to indicate USING is on going.
;Entry:
;	none
;Exit:
;	b$PTRFIL = LPRINT FDB pointer/handle
;	b$PRFG is set to LPSTM (=8)
;Uses:
;	none
;Exceptions:
;	none
;*******************************************************************************

cProc	B$LPRT,<PUBLIC,FAR>,<SI> ; don't set up frame (can't get an error)
cBegin

	OR	[b$PRFG],LPSTM ;set the flag to indicate a LPRINT is on going

	MOV	[b$PTRFIL],OFFSET DGROUP:b$LPTFDB ;set up b$PTRFIL

	MOV	SI,OFFSET DGROUP:b$FILVEC
	cCall	B$WCHSET	;set the dispatch vector for print items

cEnd				; exit to caller



sEnd	OI_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\inputf.asm ===
TITLE	INPUTF - INPUT$ function
	page	,132
;***
; INPUTF - INPUT$ function
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - INPUT$ Function:
;
;      INPUT$(x [,[#]y])
;	  |
;	B$FINP
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

;Code segments			
	useSeg	RT_TEXT 	
	useSeg	DK_TEXT 	
	useSeg	NH_TEXT 	
	useSeg	ER_TEXT 	
;Data segments			
	useSeg	_BSS		
	UseSeg	_DATA		

	INCLUDE seg.inc 	
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE idmac.inc	
	INCLUDE string.inc	

	SUBTTL	local contant definitions	
	page

	TTY	EQU	0	; [b$PTRFIL] is default to TTY

	SUBTTL	data definitions
	page			


sBegin	_BSS			
	externW b$PTRFIL	; defined in GOSTOP.ASM
	externW b$RECPTR	; pointer to random record
sEnd	;_BSS			

	SUBTTL	code externals	
	page			

sBegin	DK_TEXT 		
	externNP B$$RCH		
	externNP B$PtrDispatch	
sEnd	;DK_TEXT

sBegin	NH_TEXT 		
	externNP B$LHFDBLOC	
	externNP B$STALCTMPSUB	
	externNP B$STALCTMP	

sEnd	;NH_TEXT

sBegin	RT_TEXT 		
	externNP B$END		
sEnd	;RT_TEXT		

sBegin	ER_TEXT 		
	externNP B$ERR_IFN	
	externNP B$ERR_RPE	
	externNP B$ERR_FC	
sEnd	;ER_TEXT		

sBegin	_DATA			
	globalW  B$ENTRY_BUFCNT,0 
sEnd	;_DATA			

sBegin	DK_TEXT 		
	assumes CS,DK_TEXT	
	SUBTTL	INPUT$ interface -- B$FINP	
	page			

ERCIFC:	JMP	B$ERR_FC	; illegal function call
BADNUM: JMP	B$ERR_IFN	

;***[4]
;B$FINP -- INPUT$ interface
;sd *B$FINP(I2 cbInp,I2 channel)
;DBCS-callback
;
;Purpose:
;	Return a string of n bytes read from the keyboard or from a file.
;	The input device is specified by the file descriptor called
;	channel.  This routine does not handle double byte characters.
;	See the function B$INPY (INPUT<yen>) for a version that will
;	read n characters (handling double byte characters correctly).
;
;Entry:
;	Parameters are in stack.
;	int	cbInp
;	int	channel; (0 or 7FFFH for TTY, otherwise a file)
;
;Exit:
;	[AX]	= *sd (pointer to a string descriptor)
;
;Uses:
;	none
;
;Exceptions:
;	B$ERR_IFN -- illegal file number
;	B$ERR_RPE -- read pass end
;*******************************************************************************

cProc	B$FINP,<PUBLIC,FAR>,<SI,DI,ES> 
	ParmW	cbInp		; I2 number of characters
	ParmW	Channel 	; I2 channel number
cBegin				
	PUSH	DS		
	POP	ES		; Set ES = DS
	MOV	CX,cbInp	; number in CX
	MOV	BX,Channel	; file number in BX

	XOR	SI,SI		; assume TTY input
	OR	BX,BX		; is zero (TTY) ?
	JZ	GetTmpStr	; Brif yes

	CMP	BL,255		; Is it TTY ?
	JZ	GetTmpStr	; Brif yes

	cCall	B$LHFDBLOC	; on return, NZ & SI=*FDB
	JZ	BADNUM		;illegal file number?
	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB
	MOV	AX,FileDB.FD_BUFCNT ; Save fdb position.
	MOV	B$ENTRY_BUFCNT,AX   ; Used to reset on error
	TEST	FileDB.FD_MODE,MD_SQO+MD_APP ; output or append?
   DJMP JNZ	ERCRPE		; Brif yes

GetTmpStr:			
	MOV	[b$PTRFIL],SI	; [b$PTRFIL] has 0 or *FDB
	or	cx,cx		; > 32K length requested?
	js	ERCIFC		; brif so -- illegal function call	
	MOV	BX,CX		; length in BX
	cCall	B$STALCTMP	; allocate temp string, on return
				;  BX=*sd, DX=*temp string
	JCXZ	InpExit 	; exit (return a *sd to a null string)
	PUSH	BX		; save BX
	OR	SI,SI		; TTY input?
	JZ	NotBinary	; brif so -- not binary mode
	FDB_PTR ES		;refresh ES after possible global movement
	TEST	FileDB.FD_MODE,MD_BIN ; binary mode?
	JZ	NotBinary	; brif not -- don't load directly
				; load directly into the string
	MOV	[b$RECPTR],DX	; b$RECPTR = buffer pointer (seg and off)
	MOV	[b$RECPTR+2],DS 
	MOV	BX,CX		; BX = requested count
	MOV	AX,DV_RANDIO SHL 8 + 100B ;  AH = dispatch function (RANDIO)
				; AL = flag [record var, no rec #, GET]
	PUSH	CX		; save count
	CALL	B$PtrDispatch	; do the load -- AX = actual count read
				; BX, CX, DX unknown
	POP	CX		; restore count
	POP	BX		; get back SD
	CMP	CX,AX		; did we get the full count we requested?
	JE	InpExit		; brif so -- exit
				; string we have is too long
	XCHG	DX,AX		; DX = actual count
	XOR	CX,CX		; CX = copy from start of string
	CALL	B$STALCTMPSUB	; allocate temporary substring, deleting old
	JMP	SHORT InpExit	; leave the loop

NotBinary:			
	MOV	DI,DX		; put data pointer in DI

FillStr:
	cCall	B$$RCH		; read one character

	JZ	EndRedir	; end of redirected input seen, exit program.
	JC	ERCRPE		; Brif end of file
	STOSB			; put in string, DI incremented
	LOOP	FillStr 	; repeat until CX=0

	POP	BX		; result (*sd) in BX
InpExit:			
	XCHG	AX,BX		; return new SD in AX
	MOV	[b$PTRFIL],TTY	; reset [b$PTRFIL] to default
cEnd				; exit

ERCRPE: JMP	B$ERR_RPE

EndRedir:
	JMP	B$END		;jump to exit abruptly


sEnd	;DK_TEXT		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\inptty.asm ===
TITLE	INPTTY - console input
	page	,132
;***
;inptty - console input
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;BASIC Syntax mapping to included runtime entry points
;
;i)	INPUT[;]["prompt";|,]variable[,variable]...
;
;	BASCOM 2.0 generates calls to IN0A, IPUA, and a call to IPUB for
;	each variable.	Now it will generate the following calls :
;
;	1.	void B$INPP (sd *psdPrompt, I2 FAR *pBlock)
;
;			Where pBlock is a far pointer to a block
;			with the following information :
;
;			word 1 .... word count of the length of this block
;			byte 3 .... an encoded flag having information about
;					CRLF and the ?. It is described below.
;			bytes 4 to n+3 .... have the n types.
;
;			the block would look like :
;
;			1  2  3 	  4
;			----------------------------------------------
;			| n+3 | fCRLFqMark|<---------n types-------->|
;			______________________________________________
;			^
;			|
;			|
;			|
;			pBlock
;
;		The CRLFqMark flag can take the following values :
;
;		0 ....	no ';' before prompt and ';' after prompt.
;		1 ....	no ';' before prompt and ',' after prompt.
;		2 ....	   ';' before prompt and ';' after prompt.
;		3 ....	   ';' before prompt and ',' after prompt.
;
;		Note: the above has the same meaning as:
;			bit 0 set if NO question mark will be displayed
;			bit 1 set if NO no carriage return will be forced.
;
;		The types are as follows :
;
;		I2 .... 2H     \
;		I4 .... 14H	\    This is what the runtime is
;		R4 .... 4H	     using.
;		R8 .... 8H	/
;		SD .... 3H     /
;
;		(INPP stands for INPut Preamble)
;
;		The value of b$FInput will be:
;
;		default 0FFH
;		inptty	0H
;		inpdsk	1H
;
;	2. void B$RD<type> (<type> *pDest)
;
;		Where,
;			<type>	=	I2:	Two byte integer
;					I4:	Four byte integer
;					R4:	Single precision real
;					R8:	Double precision real
;					SD:	String descriptor
;
;		This will be called once for each variable.
;
;		The B$RD<type> routines are going to be shared between
;		the READ and INPUT statements and they need to know whether
;		they are called from an INPUT statement or a READ
;		statement. This is done by setting a flag (say b$FInput)
;		in B$DSKI.
;		(The default value of b$FInput would be used for READ)
;
;		(Note:
;		In the case of interpreted code, the B$RD<type>
;		routines will call the interpreter to get a pointer to
;		the next DATA item and return the # of bytes consumed.)
;
;	3. void B$PEOS(void)
;
;		The flag b$FInput gets cleared in B$PEOS.
;
;ii)	INPUT #filenum, variable [,variable]...
;
;	BASCOM 2.0 generates calls to IN0B, IPUA and IPUB. Now it will
;	generate the following calls :
;
;
;	1. void B$DSKI (I2 channel)
;
;	2. void B$RD<type> (<type> *pDest)
;
;		Refer to the description above.
;
;	3. void B$PEOS(void)
;
;		Refer to the description above.
;
;iii)	LINE INPUT [;]["prompt";|,] stringvar
;
;	BASCOM 2.0 generates calls to IN0A and LIPA. Now it will generate
;	a call to B$LNIN. (see routine documentation).
;
;iv)	LINE INPUT #filenum, stringvar
;
;	BASCOM 2.0 generates calls to IN0B and LIPA. Now it will generate
;	calls to B$DSKI followed by B$LNIN.
;
;	Since B$LNIN is shared between LINE INPUT and LINE INPUT #, B$DSKI
;	sets b$FInput telling B$LNIN that this is disk input. b$FInput gets
;	cleared before exiting B$LNIN.
;
;	B$INPP is in inptty.asm
;	B$DSKI is in inpdsk.asm
;	B$LNIN is in lininp.asm
;	B$RD<type> is in read.asm
;
; - RANDOMIZE Statement - calls B$RNZ0 if no parm
;
;      RANDOMIZE
;      ---------
;	   |
;	B$RNZ0
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;Code segments
	useSeg	DK_TEXT
	useSeg	CN_TEXT
	useSeg	MT_TEXT
	useSeg	ST_TEXT
	useSeg	ER_TEXT
	useSeg	RT_TEXT
;data segments
	useSeg	_DATA
	useSeg	_BSS

	INCLUDE seg.inc
	INCLUDE messages.inc
	INCLUDE const.inc	; b$IOFLAG field definitions
	INCLUDE rtps.inc	
	INCLUDE string.inc	
	INCLUDE idmac.inc	

	SUBTTL	local constants
	page

	InpTTY		EQU	0H	;console input

	SUBTTL	data definitions
	page

sBegin	_DATA

	externW b$GetOneVal
	externB b$FInput
	externW B$AC
	externB	b$IOFLAG	; Misc. IO flags.  Defined in GWINI.ASM
	externW b$nuldes	; Null string descriptor
	externW b$RndVar	; random number seed.

labelW	RandpBlock		; information block needed by B$INPP
	staticW ,2		; total 4 bytes
	staticB ,0		; need '?' and CR
	staticB ,2		; var type is I2

sEnd	;_DATA

sBegin	_BSS

	globalW b$DATAPT,,1
	externW b$StkBottom	; for clean stack

	externB b$Buf1		; 256+1 bytes of temp storage

	labelD	BlockPt
	staticW BlockOff,,1	;points to the block of type list
	staticW BlockSeg,,1

	staticW SaveDI,,1	;save registers
	staticW SaveSI,,1
	staticW SaveES,,1

	staticW SaveBP,,1	; save old BP, NOTE: SaveBP, RetOff & RetSeg
				;  should be in this order
	labelD	RetAddr
	staticW RetOff,,1	;return address
	staticW RetSeg,,1

	staticW TYPCNT,,1
	staticW VALCNT,,1

	staticW PROMPT,,1
	staticB INFLG,,1

	externW b$errvec	; error vector (0=none, else address)
	externW b$PTRFIL

	externW b$curlevel	
	externB b$VTYP 	

sEnd	;_BSS

	SUBTTL	code externals
	page

sBegin	CN_TEXT
	externNP	B$TYPSTR
	externNP	B$$WCHT
	externNP	B$$TCR
	externNP	B$KEYDSP	; Trick to pull in B$KEYDSP code 
	externNP	B$INPCRLF	; moved to out.asm
	externNP	B$RDLIN

sEnd	;CN_TEXT

sBegin	MT_TEXT
	externNP	B$FIN
sEnd

sBegin	ER_TEXT
	externNP	B$PUTNUM
sEnd

sBegin	ST_TEXT 			
	externNP	B$STDALCTMP	; deallocate if temp string
	externNP	B$STDALCALLTMP	; deallocate all string temps
sEnd					

sBegin	RT_TEXT
sEnd

	assumes CS,DK_TEXT
sBegin	DK_TEXT
	externFP	B$PEOS		; input/output generate reset routine
	externFP	B$RDI2		; read one item

	SUBTTL	console input interfaces -- B$INPP & B$INPA
	page
;***
;B$INPP -- console input preamble
;void B$INPP(sd sdPrompt, I2 far *pBlock)
;
;Purpose:
;	This is the preamble for console input.  This routine sets up some
;	flags, and checks types of inputs.  If anything goes wrong, print
;	"?Redo from start" and start over. Values will be saved in stack,
;	and will be assigned to variables by the succeeding calls to
;	B$RD<type>.
;
;	We need special care to handle the stack, since all input values
;	are stored in stack and are used across the interfaces.  In order
;	to have a clean stack for storage, registers and stack frame, which
;	are usually saved in stack, are stored in memory.  Note that the
;	stack frame has to be in stack whenever there is the possiblity
;	that an uncontrolled error would happen.  In this routine, the read
;	line routine, B$RDLIN, is the possible troulbe spot.
;
;	The following is the illustration of the stack frame and the
;	stack situation when the routine exits.
;
;		|		|		|		|
;	High	|---------------|	High	|---------------|
;		|		|		|		|
;		|---------------|[b$StkBottom]>|---------------|
;		|		|	     /	|     value	|
;		|---------------| [b$DATAPT]	|---------------|
;		|		|		|		|
;		\ 		\ 		\ 		\
;		\ 		\ 		\ 		\
;		|---------------|		|---------------|
;		|		|		|     value	|
;		|---------------|		|---------------|
;		| Return Segment|		|     value	|
;		|---------------|		|---------------|
;		| Return Offset |		|     (R4 high) |
;		|---------------|		|---------------|
;		|	BP	|		|     (R4 low)	|
;	   BP ->|---------------|		|---------------|
;		\ 		\ 		\ 	.	\
;		\ 		\ 		\ 	.	\
;		|		|		|     value	|
;	Low	|---------------|	Low	|---------------|
;
;	Note: the way to store the value here (in stack) is the same as
;		to store in any memory location.  Look the example for R4.
;
;	The algorithm is split into three parts:
;	(I) Set up
;		save registers (e.g. ES,SI,DI) in memory location
;		save stack frame (BP RetOff RetSeg) in memory location
;		save the pointer of the stack bottom in [b$StkBottom] &
;						     in [b$DATAPT]
;		turn user cursor off (in order to print prompt)
;		save # of values in VALCNT
;		save input flag ("?" and/or CR)
;
;	(II) Parse each value
;		print prompt with/out "? " <CR>
;	     ** read line
;		clean the stack by using [b$StkBottom]
;
;		loop each input value and check the type (B$FIN)
;			Note that around the call to B$FIN (for as short a
;			period as possible) the error vector is set such that
;			all errors encounted will vector back here.
;		if no error then
;			push value into the stack
;		else /* error happened */
;			give error message
;			reconstruct stack frame on the TOP OF THE STACK
;			goto (II)
;	(III) epilog
;		give error if the number of values is not correct (goto
;			error handling routine and start over)
;		restore registers from memory location
;		far jump to the caller
;
;	Note: ** means stack frame has to be in stack.
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement. (The interpeter
; places the parameter block in a far heap entry).
;
;Entry:
;	Parameters in stack.
;	sd	sdPrompt
;	int	far*pBlock
;
;	Refer the source head comments for the structure of Block.
;Exit:
;	values are in stack.
;
;	[b$DATAPT] = [b$StkBottom] points to the bottom of var list & stack
;	NOTE: the direction of the list is auto-decrement.
;
;	[BlockPt] contains the far pointer to the types list
;	NOTE: the type list is the subset of the Block described above.
;
;	[VALCNT] is the count of how many variables
;Uses:
;	none
;Exceptions:
;
;*******************************************************************************

cProc	B$INPP,<PUBLIC,FAR>
	ParmSD	sdPrompt	;sd of prompt string
	ParmD	pBlock		;far point to Block
				;NOTE: we may use the symbols of off_pBlock
				;	and seg_pBlock
cBegin				;generate stack frame
	MOV	[SaveES],ES	;save ES
	MOV	[SaveSI],SI	;save SI
	MOV	[SaveDI],DI	;save DI

	LEA	BX,[BP+12]	;bottom of the stack and var list
	MOV	[b$DATAPT],BX	; [b$DATAPT] = [b$StkBottom]
	MOV	[b$StkBottom],BX 

.erre	ID_SSEQDS		; give error if SS <> DS
	PUSH	DS		
	POP	ES		; let ES=DS
	MOV	SI,BP		; source addr
	MOV	DI,OFFSET DGROUP:SaveBP ; destination addr
	MOV	CX,3		; 3 words
	REP	MOVSW		; save in data area, stack frame still in
				;  stack
	MOV	[b$PTRFIL],CX	; Set output to TTY (CX=0)

	GetpSD	BX,sdPrompt	;BX = psdPrompt
	MOV	[PROMPT],BX	;Save prompt string descriptor address
	LES	DI,pBlock	;ES:DI points to the block
	MOV	AX,ES:[DI]	;get block length
	DEC	AX		; block length is n+1
	MOV	[VALCNT],AX	;Remember number of values
	INC	DI
	INC	DI		;increment the pointer
	MOV	AL,ES:[DI]	;get the flag byte
	MOV	[INFLG],AL	;save flag byte
	INC	DI		;so DI points to the list of types now
	MOV	[BlockOff],DI	
	MOV	[BlockSeg],ES	;save segment:offset to the Block

	
PrtPrompt:			;Enter here if error to re-prompt and
				; re-read data
	MOV	BX,[PROMPT]	;BX=*sd of Prompt
	CALL	B$TYPSTR 	;Print the prompt
	TEST	[INFLG],FINP_QSupress ;Need a "?" after prompt?
	JNZ	GetLin		;Brif not
	MOV	AL,"?"		;output "?"
	CALL	B$$WCHT
	MOV	AL," "		; and one blank
	CALL	B$$WCHT
GetLin:
	CALL	B$RDLIN	;get input line
	TEST	[INFLG],FINP_CrLf ;is it INPUT "semi-colon" ?
	JNZ	CleanStk	;Brif yes, don't send <CR><LF>
	CALL	B$INPCRLF	; force CR to all places where input was
				; written (screen and/or redirected file)

CleanStk:
	MOV	SP,[b$StkBottom]	; clean the stack
				; at this point, stack frame is destroyed.
				;  Since B$FIN return error code and error
				;  handler will restore the stack frame, it
				;  should be fine.
	MOV	AX,[VALCNT]	;get # of types
	MOV	[TYPCNT],AX	;Initialize count of values
	MOV	SI,OFFSET DGROUP:b$Buf1
				;DS:SI points to the value list
	LES	DI,[BlockPt]	;ES:DI points to the type list

; At this point, [TYPCNT] has the number of values
;		 ES:DI points to the next type in the type list
;		 DS:SI points to the next input in the input stream
;		 stack is ready to put values.

EachVal:
	MOV	AL,ES:[DI]	;get next type
	INC	DI		;increment the pointer
	MOV	[b$VTYP],AL	;save the type (used by B$FIN)

	MOV	[b$errvec],DK_TEXTOFFSET InpErr	; set err vec
	PUSH	ES		
	PUSH	DS		; set ES = segment of source
	POP	ES		
	INC	[b$curlevel]	; Increment level for possible dealloc
	CALL	B$FIN		;get number or string (AL=Next Char)
	DEC	[b$curlevel]	; restore b$curlevel
	POP	ES		
	MOV	[b$errvec],0	; reset error vector

	MOV	CL,[b$VTYP]	;get the type
	AND	CL,0FH		;get rid of upper half
	CMP	CL,VT_R4	;is 2 byte value ?
	MOV	BX,OFFSET DGROUP:B$AC
				;BX has the result
	JB	PushAC		;Don't do high word if integer or string
	PUSH	[BX+2]		;Push highest word
PushAC:
	PUSH	[BX]
	JBE	NextVal 	;Only push low words if D.P.
	PUSH	[BX-2]
	PUSH	[BX-4]
NextVal:
	DEC	[TYPCNT]	;any values left?
	JZ	ChkEnd		;Brif no more
	CMP	AL,","		;values must be separated by ","
	JZ	EachVal 	;process next value

;Come here to restart if any error occurred

RedoFromStart:			
	CALL	B$$TCR		;force CR/LF
	MOV	AX,MS_REDO	;message number
	cCall	B$PUTNUM	; output message
	CALL	B$$TCR		;force CR/LF

	MOV	AX,[b$curlevel]	; setup for string temp deallocation...
	INC	AX		; ...only above current level!
	CALL	B$STDALCALLTMP	; deallocate all string temps.

	MOV	SP,[b$DATAPT]	;roughly clean the stack, this is only to
				; avoid stack overflow when we restore the
				; stack frame.	the thorough clean will be
				; done after read line.
	PUSH	[RetSeg]	;restore stack fram on stack
	PUSH	[RetOff]
	PUSH	[SaveBP]
	MOV	BP,SP
	JMP	PrtPrompt	;redo from start

;Come here from error trap if overflow in $FIN

InpErr: 			; give error message
	DEC 	[b$curlevel]	; restore [b$curlevel] after B$FIN error
	MOV	[b$errvec],0	; don't allow infinite loop
	PUSH	BX		; save error number
	CALL	B$$TCR		;force CR/LF
	POP	AX		; get back error number
	cCall	B$PUTNUM	; output message
	JMP	SHORT RedoFromStart	; redo from start

ChkEnd:
	OR	AL,AL		;Did we reach end of line?
	JNZ	RedoFromStart	; Brif not, redo from the start

	MOV	BX,[PROMPT]	; BX = pointer to prompt string
	cCall	B$STDALCTMP	; deallocate it if it was temp


	MOV	[b$GetOneVal],OFFSET TTYInpVal
				;set up for get one input item
	MOV	[b$FInput],InpTTY
				;set input flag
	MOV	DI,[SaveDI]	;restore registers
	MOV	SI,[SaveSI]
	MOV	ES,[SaveES]
	MOV	BP,[SaveBP]
	JMP	[RetAddr]	;return to caller
cEnd	nogen			;no code generated

	SUBTTL	TTY input supporting routine -- TTYInpVal
	page
;***
;TTYInpVal -- get one input value
;
;Purpose:
;	This routine gets one value from the buffer (in stack).
;
;	After the input preamble, the succeeding calls will assign values
;	into variables.  The functionality of those assignment routines,
;	B$RD<type>, may be roughly split into two parts -- namely, getting
;	one value and then assigning it to the variable.  In BASCOM 3.0,
;	those assignment routines are shared by READ stmt, input from TTY
;	and input from a disk file (or a device).  Generally speaking,
;	the second part of the assignment routines DOESN'T discriminate
;	among the statements which share its use.  However, the first part
;	of the assignment routines MUST discriminate among the statements
;	which share its use.  In order to achieve this, the first part of
;	the assignment routines uses an indirect call, CALL [b$GetOneVal],
;	to get one value.  [b$GetOneVal] is default to the address of
;	ReadVal, which gets one value for READ stmt, or contains either
;	the address of TTYInpVal for TTY input or the address of DskInpVal
;	for disk (device) input.
;
;Entry:
;	[b$VTYP]	= types
;	[b$DATAPT]	points to the var list
;Exit:
;	[SI]		= pointer to the value
;	[b$DATAPT]	is updated
;Uses:
;	none
;Exceptions:
;	none
;*******************************************************************************

cProc	TTYInpVal,<NEAR>	;assume DS=SS, ES=DS when enter

cBegin
.erre	ID_SSEQDS		;assume SS=DS (used in B$RD<type>)
	MOV	SI,[b$DATAPT]	;get pointer to next value
	MOV	AL,[b$VTYP]	; AL has the type
	CBW			;AX has the type
	AND	AL,0EH		;AX has the length
	SUB	SI,AX		;SI points to the begining of the source
	MOV	[b$DATAPT],SI	;save for next call
cEnd				;return to caller


	SUBTTL	RANDOMIZE interface -- B$RNZ0
	page
;***
;B$RNZ0 -- randomize without parameter specified.
;void B$RNZ0(void)
;
;Purpose:
; Reseeds the random number generator.
; Moved here from RANDOM.ASM [21]
;
;Entry:
; This routine prompts for the user to enter the new random number seed'
;
;Exit:
; User specified seed is stored in b$RndVar+1 (the middle word of the random
; number (DWORD)).
;
;Uses:
; Per convention
;
;Exceptions:
; B$ERR_OV -- overflow (in B$INPP)
;
;*******************************************************************************
cProc	B$RNZ0,<PUBLIC,FAR,FORCEFRAME>
cBegin
	MOV	AX,MS_SEED
	cCall	B$PUTNUM	;Output seed message
	MOV	AX,OFFSET DGROUP:b$nuldes
	PUSH	AX		;push *sd of prompt
	PUSH	DS		;far pointer
	MOV	AX,OFFSET DGROUP:RandpBlock
	PUSH	AX		;push *pBlock
	cCall	B$INPP		;on return, input value is in stack
	PUSH	DS
	MOV	AX,OFFSET DGROUP:b$RndVar+1 ;destination
	PUSH	AX
	cCall	B$RDI2		;read user's seed into destination
	cCall	B$PEOS		;reset flags & variables
cEnd				;exit to caller

sEnd	;DK_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\inpdsk.asm ===
TITLE	INPDSK - disk input
	page	,132
;***
; INPDSK - disk input
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;BASIC Syntax mapping to included runtime entry points:
;
;i)	INPUT[;]["prompt";|,]variable[,variable]...
;
;	BASCOM 2.0 generates calls to IN0A, IPUA, and a call to IPUB for
;	each variable.	Now it will generate the following calls :
;
;	1.	void B$INPP (sd *psdPrompt, I2 FAR *pBlock)
;
;			Where pBlock is a far pointer to a block
;			with the following information :
;
;			word 1 .... word count of the length of this block
;			byte 3 .... an encoded flag having information about
;					CRLF and the ?. It is described below.
;			bytes 4 to n+3 .... have the n types.
;
;			the block would look like :
;
;			1  2  3 	  4
;			----------------------------------------------
;			| n+3 | fCRLFqMark|<---------n types-------->|
;			______________________________________________
;			^
;			|
;			|
;			|
;			pBlock
;
;		The CRLFqMark flag can take the following values :
;
;		0 ....	no ';' before prompt and ';' after prompt.
;		1 ....	no ';' before prompt and ',' after prompt.
;		2 ....	   ';' before prompt and ';' after prompt.
;		3 ....	   ';' before prompt and ',' after prompt.
;
;		Note: the above has the same meaning as:
;			bit 0 set if NO question mark will be displayed
;			bit 1 set if NO no carriage return will be forced.
;
;		The types are as follows :
;
;		I2 .... 2H     \
;		I4 .... 14H	\    This is what the runtime is
;		R4 .... 4H	     using.
;		R8 .... 8H	/
;		SD .... 3H     /
;
;		(INPP stands for INPut Preamble)
;
;		The value of b$FInput will be:
;
;		default 0FFH
;		inptty	0H
;		inpdsk	1H
;
;	2. void B$RD<type> (<type> *pDest)
;
;		Where,
;			<type>	=	I2:	Two byte integer
;					I4:	Four byte integer
;					R4:	Single precision real
;					R8:	Double precision real
;					SD:	String descriptor
;
;		This will be called once for each variable.
;
;		The B$RD<type> routines are going to be shared between
;		the READ and INPUT statements and they need to know whether
;		they are called from an INPUT statement or a READ
;		statement. This is done by setting a flag (say b$FInput)
;		in B$DSKI.
;		(The default value of b$FInput would be used for READ)
;
;		(Note:
;		In the case of interpreted code, the B$RD<type>
;		routines will call the interpreter to get a pointer to
;		the next DATA item and return the # of bytes consumed.)
;
;	3. void B$PEOS(void)
;
;		The flag b$FInput gets cleared in B$PEOS.
;
;ii)	INPUT #filenum, variable [,variable]...
;
;	BASCOM 2.0 generates calls to IN0B, IPUA and IPUB. Now it will
;	generate the following calls :
;
;
;	1. void B$DSKI (I2 channel)
;
;	2. void B$RD<type> (<type> *pDest)
;
;		Refer to the description above.
;
;	3. void B$PEOS(void)
;
;		Refer to the description above.
;
;iii)	LINE INPUT [;]["prompt";|,] stringvar
;
;	BASCOM 2.0 generates calls to IN0A and LIPA. Now it will generate
;	a call to B$LNIN. (see routine documentation).
;
;iv)	LINE INPUT #filenum, stringvar
;
;	BASCOM 2.0 generates calls to IN0B and LIPA. Now it will generate
;	calls to B$DSKI followed by B$LNIN.
;
;	Since B$LNIN is shared between LINE INPUT and LINE INPUT #, B$DSKI
;	sets b$FInput telling B$LNIN that this is disk input. b$FInput gets
;	cleared before exiting B$LNIN.
;
;	B$INPP is in inptty.asm
;	B$DSKI is in inpdsk.asm
;	B$LNIN is in lininp.asm
;	B$RD<type> is in read.asm
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;Code segment
	useSeg	DK_TEXT
	useSeg	NH_TEXT
	useSeg	ST_TEXT
	useSeg	MT_TEXT
	useSeg	ER_TEXT
;Data segment
	useSeg	_DATA
	useSeg	_BSS

	INCLUDE seg.inc
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE ascii.inc
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE idmac.inc	

	SUBTTL	local constant definitions
	page


	NEWLINE= ASCCR

	InpDefault	EQU	0FFH	;default READ statement
	InpTTY		EQU	0H	;console input
	InpDsk		EQU	1H	;device input

	SUBTTL	data definitions
	page

sBegin	_DATA

	externW B$ENTRY_BUFCNT	;buffer position in fdb before current stmt.
	externB b$FInput	;default InpDefault
	externW b$GetOneVal	;default OFFSET ReadVal
	externW b$SDBuf1	; sd of b$Buf1
	externW B$AC

sEnd	;_DATA

sBegin	_BSS

	externW b$PTRFIL	;defined in GOSTOP.ASM
	externB b$Buf1		; defined in GWINI.ASM
	externB b$VTYP 	;defined in GLOBAL.INC

sEnd	;_BSS

	SUBTTL	code externals
	page


sBegin	NH_TEXT
	externNP	B$STDALCTMP
	externNP	B$STALCTMP
	externNP	B$STGETSTRLEN
	externNP	B$STALCTMPCPY
	externNP	B$LHFDBLOC	
sEnd	;NH_TEXT

sBegin	DK_TEXT
	externNP	B$$RCH
	externNP	B$PtrDispatch	
	externNP	B$ChkFNUM	
sEnd	;DK_TEXT

sBegin	ER_TEXT
	externNP	B$ERR_IFN
	externNP	B$ERR_RPE
	externNP	B$ERR_BFM	
sEnd	;ER_TEXT

sBegin	ST_TEXT
	externFP	B$SCAT 	
sEnd	;ST_TEXT

sBegin	MT_TEXT
	externNP	B$FIN
	externNP	B$STRSCAN	
sEnd	;MT_TEXT

	assumes CS,DK_TEXT
sBegin	DK_TEXT
	SUBTTL	disk input interface -- B$DSKI & B$RD<type>
	page
;***
;B$DSKI -- preamble for disk input
;void B$DSKI(I2 channel)
;
;Purpose:
;	This is the preamble of disk input.  It sets up flags and variables
;	for subsequent calls to B$RD<type>.
;Entry:
;	Parameter is in stack.
;	int	channel
;Exit:
;	[b$PTRFIL]	= *FDB
;	[b$FInput]	= InpDsk
;	[b$GetOneVal]	= OFFSET DskInpVal
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;	read pass end -- B$ERR_RPE
;*******************************************************************************

cProc	B$DSKI,<PUBLIC,FAR>,<SI>
	ParmW	Channel 	;I2 filenum
cBegin
	MOV	BX,Channel	;BX has the file number
	CALL	B$ChkFNUM	; make sure in range 1-255

	CALL	B$LHFDBLOC	;NZ & SI= *FDB if file exists
	JZ	ERCIFN		;Brif not exist, give "illegal file number"
	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB
	MOV	AX,FileDB.FD_BUFCNT ; Save current buffer postion
	MOV	B$ENTRY_BUFCNT,AX   ; Used to reset on error
	TEST	FileDB.FD_MODE,MD_SQO+MD_APP	
	JNZ	ERCRPE		;if output mode, give "read pass end"
	TEST	FileDB.FD_MODE,MD_BIN ; binary mode?
	JNZ	ERCBFM		; brif so --  give "bad file mode"

	MOV	[b$PTRFIL],SI	;set up PTRFIL
	MOV	[b$GetOneVal],OFFSET DskInpVal
				;set routine to input one item
	MOV	[b$FInput],InpDsk
				;indicate disk input
cEnd				;pop si and exit to caller

ERCIFN: JMP	B$ERR_IFN	;illegal file number
ERCRPE: JMP	B$ERR_RPE	;read pass end
ERCBFM: JMP	B$ERR_BFM	;bad file mode

	SUBTTL	READ/disk [LINE] INPUT supporting routines
	page
;***
;DskInpVal -- input one item from a disk file or from a device
;
;Purpose:
;	This routine is to get one value for disk (device) input.
;
;	After the input preamble, the succeeding calls will assign values
;	into variables.  The functionality of those assignment routines,
;	B$RD<type>, may be roughly split into two parts -- namely, getting
;	one value and then assigning it to the variable.  In BASCOM 3.0,
;	those assignment routines are shared by READ stmt, input from TTY
;	and input from a disk file (or a device).  Generally speaking,
;	the second part of the assignment routines DOESN'T discriminate
;	among the statements which share its use.  However, the first part
;	of the assignment routines MUST discriminate among the statements
;	which share its use.  In order to achieve this, the first part of
;	the assignment routines uses an indirect call, CALL [b$GetOneVal],
;	to get one value.  [b$GetOneVal] is default to the address of
;	ReadVal, which gets one value for READ stmt, or contains either
;	the address of TTYInpVal for TTY input or the address of DskInpVal
;	for disk (device) input.
;Entry:
;	[b$VTYP]	= types
;Exit:
;	[SI]		= pointer to source
;Uses:
;	none
;Exceptions:
;	B$ERR_RPE -- read pass end (B$FillBuf generates)
;	B$RUNERR handles it
;*******************************************************************************

cProc	DskInpVal,<NEAR>

cBegin
	MOV	DX,"," SHL 8 + " "	;default delimiters for number
	CMP	[b$VTYP],VT_SD	; is string ?
	JNZ	GetVal		;Brif not
	MOV	DL,DH		;both delimiters be "," for string
GetVal:
	cCall	B$FillBuf	;get one value (in the form of character
				; stream in buffer), on return, SI=*sd
	cCall	DeviceFin	;convert it into number if it is
				; B$AC or B$DAC has the result
	MOV	SI,OFFSET DGROUP:B$AC
	TEST	[b$VTYP],8	;R8 or currency (8-byte values)?
	JZ	DskInpExit	;go if not
	SUB	SI,4		;points to B$DAC
DskInpExit:
cEnd				;exit to caller

	page
;***
;B$FillBuf -- fill one input item into the buffer
;
;Purpose:
;	According to the delimiters, fill in the buffer with one input item,
;	which is still in the form of character stream, from a disk file or
;	from a device.
;
;	A data file for input could be created by any editor or by a BASIC
;	program.  If it is created by BASIC, we should keep our eyes on the
;	continuation mark, LF, and the end-of-line mark, "CR LF."
;
;	This routine abides by two rules.  The first rule is for inputing
;	a quoted string and the second is for unquoted string and numbers
;	as well.  The first rule says to pick up all characters between
;	two '"'s inclusively.  The second rule says that, when a combination
;	of continuation marks and end-of-line marks has been encountered,
;	within the input character stream, if a LF precedes a CR, the CR is
;	ignored.  These rules are for INPUT # stmt.  LINE INPUT # statement
;	follows the second rule, except that, if a LF precedes a CR, the CR
;	is still stored as part of the character stream.
;
;	This routine checks for the situation mentioned above.
;
;	Note: The continuation mark, LF, is treated as a regular character
;		and is stored in the buffer as part of the item if the input
;		is for a number; whereas the LF is NOT stored if the input
;		is for a unquoted string.  One reason for this is that the
;		next call, B$FIN, will take care of the LF when converting
;		the digital stream into a number.
;
;Entry:
;	[DX]		= 0		if LINE INPUT #
;			= ","+" "	if INPUT #, numberVar
;			= ","+","	if INPUT #, stringVar
;	[b$FInput]	= DskInp
;	[b$PTRFIL]	= *FDB
;Exit:
;	[SI]		= *sd of the character stream of the input item
;Uses:
;	none
;Exceptions:
;	read pass end -- _BERR_RPE
;*******************************************************************************

cProc	B$FillBuf,<PUBLIC,NEAR>,<DI,ES> ;save DI,ES

cBegin
	PUSH	DS		
	POP	ES		; make sure ES=DS

SkipLeading:
	CALL	B$$RCH		;get next char in AL
	JC	ERCRPE		;Brif no char got, give "read pass end"
	OR	DL,DL		;line input?
	JZ	Get1stChar	;Brif yes
	CMP	AL," "		;is blank ?
	JZ	SkipLeading	;skip it

Get1stChar:
	MOV	SI,OFFSET DGROUP:b$SDBuf1 ; initialze string to b$Buf1
	MOV	DI,OFFSET DGROUP:b$Buf1 
	MOV	CL,255		;allow max of 255 characters per buffer

	CMP	AL,'"'		;quoted string?
	JNZ	CharLoop	;Brif not
	CMP	DL,","		;looking for a string?
	JNZ	CharLoop	;Brif not
	cCall	StoreChar	;save '"' at start of string so FIN can match it
	MOV	DX,'""' 	;Set delimiters to '"'
	CALL	B$$RCH		;get next char
	JC	Quit		;Brif null string

CharLoop:
	CMP	DH,'"'		;getting a quoted string?
	JZ	NotCRLF 	;Brif yes, don't check LF CR

	CMP	AL,NEWLINE	;end of a line? (unquoted string or number)
	JZ	EndCR		;Brif yes

	CMP	AL,ASCLF	;check LF CR, the CR will be ignored
	JNZ	NotCRLF 	;Brif not
GotLF:				;have a continuation mark and not a quoted str
	CMP	DL,","		;getting an unquoted string?
	JZ	ChkLFCR 	;don't store linefeeds if unquoted strings
	cCall	StoreChar	;store LF for numbers
ChkLFCR:
	CALL	B$$RCH		;get next char
	JC	QUIT		; quit if eof.
	CMP	AL,ASCLF	;check for LF after LF
	JZ	GotLF		;Brif yes
	CMP	AL,NEWLINE	;ignore CR after LF if NOT LINE INPUT
	JNZ	NotCRLF 	;Brif not
	OR	DL,DL		;is LINE INPUT ?
	JNZ	NextChar	;Brif not (ignore CR)
NotCRLF:
	OR	AL,AL
	JZ	NextChar	;ignore nulls
	CMP	AL,DH		;check for first terminator
	JZ	Quit		;Brif yes
	CMP	AL,DL		;check for second terminator
	JZ	Quit		;Brif yes
	cCall	StoreChar	;store the character
NextChar:
	CALL	B$$RCH		;read next char
	JNC	CharLoop	;loop again
Quit:				;AL="," or '"' or " "
	CMP	AL,","		;must has more item
	JZ	PutZero
SkipEnding:			;skip ending blanks
	CALL	B$$RCH
	JC	PutZero
	CMP	AL," "
	JZ	SkipEnding
	CMP	AL,","		;has more item to go
	JZ	PutZero
	CMP	AL,NEWLINE	;ends ?
	JNZ	BackOneChar	;back up one char for next time
EndCR:
	MOV	BX,[b$PTRFIL]	;get file pointer (never 0000)
	MOV	AL,[BX].FD_DEVICE	; Get device type
	CMP	AL,DN_PIPE		; are we piping?
	JZ	ENDCR_PIPE		; Then just process like a file
	OR	AL,AL			; See if other special device
	JS	PutZero 	;do not look for LF if special device
ENDCR_PIPE:			
	CALL	B$$RCH
	JC	PutZero
	CMP	AL,ASCLF
	JZ	PutZero
BackOneChar:
	PUSH	SI		; Save SI
	MOV	SI,[b$PTRFIL]	; Get File pointer (not 0)
	MOV	AH,DV_BAKC	; Back up one char
	CALL	B$PtrDispatch	
	POP	SI		; Restore SI
PutZero:

	XOR	AL,AL
	STOSB			;terminated by 00H
	MOV	BX,OFFSET DGROUP:b$Buf1 
	CALL	B$STGETSTRLEN	;find length of string in input buffer
	INC	AX		;ensure room for terminating zero
	MOV	b$SDBuf1,AX	; make sd
	cCall	Concat		;concatenate buffer to string, if necessary
				;on return SI=*sd of concatenated string
cEnd				;exit to caller

	page
;***
;StoreChar -- store char in buffer
;
;Purpose:
;	Store character in AL into location ES:DI.  If the buffer is full,
;	then concatenate the buffer into a string, and reset the buffer for
;	next input.
;Entry:
;	[SI]		= *sd of result string
;	[AL]		= char
;	ES:DI		= buffer location
;	[CL]		= buffer count
;Exit:
;	if buffer is not full then
;		SI	= *sd of result string
;		character is stored in buffer pointed by ES:DI
;		DI is incremented by one (buffer pointer)
;		CL is decremented by one (buffer count)
;	else
;		SI	= *sd of concatenated string
;		DI	= *b$Buf1
;		CL	= 255
;	endif
;Uses:
;	none
;Preserves: (optional)
;	DX
;Exceptions:
;	none
;*******************************************************************************

cProc	StoreChar,<NEAR>

cBegin
	OR	AL,AL
	JZ	StoreExit	;no char, exit
	STOSB			;store in ES:DI, DI incremented
	DEC	CL		;Buffer full?
	JNZ	StoreExit	;no, continue
	MOV	b$SDBuf1,255	; yes, note buffer length
	PUSH	DX		; Save DX Flags (trashed in Concat + below)
	cCall	Concat		;concatenate buffer to string, if necessary
	JNZ	BufferReset	;already had a string, return concatenated one
				;first buffer overflow, need initial string
	MOV	BX,255		;string length
	MOV	DX,[SI+2]	;point to the string
	CALL	B$STALCTMPCPY	;copy contents of b$Buf1 into temp string
	MOV	SI,BX		;note string as start of input data
BufferReset:
	POP	DX		; Restore Flags
	MOV	DI,OFFSET DGROUP:b$Buf1 
	MOV	CL,255		;reset input to start of buffer
StoreExit:
cEnd				;exit to caller

	page
;***
;Concat -- concatenate the buffer into a string
;
;Purpose:
;	Concatenate the buffer b$Buf1, whose sd is b$SDBuf1, into the
;	current string pointed by SI, if the current one is not b$Buf1.
;Entry:
;	SI	= *sd of current string
;Exit:
;	ZR	if no concatenation happened (SI = addr of b$SDBuf1)
;	NZ & SI=*sd of concatenated string
;Uses:
;	none
;Exceptions:
;	none
;*******************************************************************************
DbPub	Concat				  
cProc	Concat,<NEAR>

cBegin
	MOV	BX,OFFSET DGROUP:b$SDBuf1	
	CMP	BX,SI		;is the current string the input buffer
	JZ	ConcatExit	;yes, just return it with ZR
	cCall	B$SCAT,<SI,BX> ; concatenate buffer to current string
	MOV	SI,AX		;SI has the concatenated string
ConcatExit:
cEnd				;exit to caller

	page
;***
;DeviceFin
;
;Purpose:
;	Device (disk) float or string input.
;
;	Allocating the string could make all temp string offsets changed.
;	Only string descriptor is still valid in that case.
;
;	For device (disk) input, if an input string is longer than 255
;	bytes, we use a temp string instead of the static buffer.  (Refer
;	to the above routine, B$FillBuf)  This caused problem when we use
;	B$FIN for disk input.
;
;	B$FIN takes the pointer of the given string (NOT *SD) and does
;	the string move using that string pointer after allocating a temp.
;	This will be fine if the pointer passed to B$FIN is a static one.
;	However, device (disk) input isn't the case if the length of input
;	string is longer than 255.
;
;	In this routine, it takes *SD instead of *string for a string input.
;
;Entry:
;	[b$VTYP]	= type of var
;	[SI]		= *sd of variable character string
;Exit:
;		AC has integer value ([b$VTYP] = VT_I2) (calls B$FIN)
;		AC has integer value ([b$VTYP] = VT_I4) (calls B$FIN)
;		AC has the address of string descriptor ([b$VTYP] = VT_SD)
;		AC has S.P. value ([b$VTYP] = VT_R4) (calls B$FIN)
;		DAC has D.P. value ([b$VTYP] = VT_R8) (calls B$FIN)
;		DAC has CY value ([b$VTYP] = VT_CY) (calls B$FIN)
;	endif
;Uses:
;	none
;Exceptions:
;	if error, runtime error handler is invoked, and this never returns
;*******************************************************************************

DbPub	DeviceFin		
cProc	DeviceFin,<NEAR>,<SI,DI,ES>
cBegin
	PUSH	SI		;save *sd one more copy for later use
	MOV	SI,[SI+2]	;B$FIN likes string offset...
	CMP	[b$VTYP],VT_SD	; test if string
	JZ	GetString	;jump to special case
	CALL	B$FIN		;process non-string value
	JMP	SHORT FinExit	;jump to finish up

GetString:
	PUSH	DS		
	POP	ES		; make ES=DS
	CALL	B$STRSCAN	; get string from buffer pointed by ES:SI
				; do all of $GETSTR except for temp string
				; creation, on return DX=*string, CX=length
	POP	DI		;get input string description (pushed as SI)
	PUSH	DI		;and put it back on stack
	MOV	AX,DX		;get offset of the string
	SUB	AX,[DI+2]	;skip count for leading white spaces
	MOV	BX,CX		;get length of new string
	CALL	B$STALCTMP	;allocate a temporary string

	MOV	DI,[BX+2]	;get new string pointer
	POP	SI		;get old descriptor again
	PUSH	SI		;still want it on stack
	MOV	SI,[SI+2]	;get pointer of the old string
	ADD	SI,AX		;get pointer of the old string without white
				; white spaces
	INC	CX		;roundup byte count
	SHR	CX,1		;make a word count for transfer
	REP	MOVSW		;move from old to new string
	MOV	[B$AC],BX	;put output string desc in BX
FinExit:
	POP	BX		;done - restore descriptor
				;this was pushed as SI
	CALL	B$STDALCTMP	;delete if temporary
cEnd				;pop registers and return to caller


sEnd	;DK_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\iotty.asm ===
TITLE	IOTTY  - Console driver for BASCOM-86
;***
; IOTTY  - Console driver for BASCOM-86
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - BEEP Statement:
;
;      BEEP
;	 |
;   B$BEEP
;
; - WIDTH Statement:
;
;      WIDTH size
;	 |
;      B$WIDT
;
;******************************************************************************
	include switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	_DATA		
	USESEG	_BSS		
	USESEG	DV_TEXT 	
	USESEG	OI_TEXT 	

	INCLUDE seg.inc 	
	include baslibma.inc
	include devdef.inc
	include files.inc
	include ascii.inc
	INCLUDE const.inc	
	INCLUDE rtps.inc	; constants shared with QBI

sBegin	_DATA			

	globalW b$pLHDALC_CPCT,Near_Ret,1 
	globalW b$pKYBD_OPEN,Near_Ret,1 
	globalW b$pSCRN_OPEN,Near_Ret,1 
	globalW b$pLPTECHO,LPTECHO,1 ; conditional vector to B$LPTECHO
	externW	b$CURSOR	; (1,1)-relative screen cursor
	externB	b$CSRX		; 1-relative x-coordinate cursor
	externB b$LINCNT	
	externB b$WDOTOP	
	externB b$WDOBOT	
	externB b$KEY_SW	
	externW	b$vKEYDSP	; vector for indirect call to B$KEYDSP
	externB b$CRTWIDTH	; physical width of screen (40 or 80)
	externB	b$SCRNWIDTH	; logical width of SCRN:
	externB	b$IOFLAG	; Misc. IO flags.  Defined in GWINI.ASM
	staticB b$REDCSRX,01h	; 1-relative X-coordinate cursor for
				; redirected output.
sEnd	_DATA			

sBegin	_BSS			

	externW b$PTRFIL	;defined in GOSTOP.ASM
	externB	b$LPTFDB	; defined in GLOBAL.INC
	externB	b$FILMOD	; defined in GLOBAL.INC

	globalB b$TTY_BAKCHR,?,1  ; <>0 <=> contains pushed char for TTY

	staticB TWOBYT,?,1	; <>0 means it contains the first half of a
				; two-byte (not necessarily KANJI) character
	staticB TEMPFLAG,?,1	; temporary flag to store results of
				; CHKCHAR

	; equates for use with the results of CHKCHAR
SCN_CHR    =	01h		; char should be printed on the screen
RED_CHR    =	02h		; char should be printed to redirected file
LPR_CHR    =	04h		; char should be echoed to line printer

sEnd	_BSS			

sBegin	OI_TEXT 		
	externNP B$ERR_IOE	
sEnd	OI_TEXT 		



assumes CS,DV_TEXT
sBegin	DV_TEXT

;	Run-time entries

	PUBLIC	B$D_KYBD
	PUBLIC	B$D_SCRN
	PUBLIC	B$TTY_BAKC
	PUBLIC	B$TTY_SINP
	PUBLIC	B$TTY_SOUT
	PUBLIC	B$TTY_GWID
	PUBLIC	B$TTY_BLKIN
	PUBLIC	B$TTY_BLKOUT

;	Run-time externals


	externNP B$ERR_FC
	externNP   B$SWIDTH	
	externNP B$SCROUT	
	externNP B$INFMAP	; OEM's mapping routine
	externNP B$PRTMAP	
	externNP B$BLEEP	
	externNP B$USRCSR	; display user cursor
	externNP B$SCNLOC	; update b$CURSOR and display user cursor
	externNP B$TTYGetChar	
	externNP B$CLRSCN	; clear screen
	externNP B$CRLF		; update cursor for scrolling

	externNP B$FKYMAP	

	externNP B$SCROLL	; OEM scroll routine

	externNP B$STDPUT	
;	Illegal Device Functions

KYBD_EOF EQU	B$ERR_FC
KYBD_LOC EQU	B$ERR_FC
KYBD_LOF EQU	B$ERR_FC
KYBD_WIDTH EQU	B$ERR_FC
KYBD_RANDIO EQU B$ERR_FC
KYBD_SOUT EQU	B$ERR_FC
KYBD_GPOS EQU	B$ERR_FC
KYBD_GWID EQU	B$ERR_FC
KYBD_BLKIN EQU	B$ERR_FC
KYBD_BLKOUT EQU B$ERR_FC
KYBD_DWID EQU	B$ERR_FC

SCRN_EOF EQU	B$ERR_FC
SCRN_LOC EQU	B$ERR_FC
SCRN_LOF EQU	B$ERR_FC
SCRN_RANDIO EQU B$ERR_FC
SCRN_BAKC EQU	B$ERR_FC
SCRN_SINP EQU	B$ERR_FC
SCRN_BLKIN EQU	B$ERR_FC
SCRN_BLKOUT EQU B$ERR_FC

;	Device Close Routines

SCRN_WIDTH EQU	B$SCNSWD	
SCRN_DWID  EQU  B$SCNSWD	
;
; SCRN_DWID:		; set width for next open
;	MOV	b$SCRNWIDTH,DL	; set logical screen width
;	RET
;

;	Device Independent Console Interface

DSPMAC	MACRO	func
	DW	SCRN_&func
	ENDM

B$D_SCRN:
	DSPNAM


DSPMAC	MACRO	func
	DW	KYBD_&func
	ENDM

B$D_KYBD:
	DSPNAM

	PAGE

devio	PROC	NEAR

KYBD_CLOSE:			 
SCRN_CLOSE:			 
	JMP	[b$pLHDALC_CPCT] 
KYBD_OPEN:
	JMP	[b$pKYBD_OPEN]
SCRN_OPEN:
	JMP	[b$pSCRN_OPEN]
;***
;B$TTY_SINP,KYBD_SINP - Get a byte from the keyboard (non-redirectable)
;
;Purpose:
;	Retreive a byte from the keyboard and return it to the user.
;	This routine also alows a one character push back though
;	the routine B$TTY_BAKC.  If a character is not immediately
;	ready, this routine will wait until one becomes available.
;	There is no echoing of characters.
;
;	Note that when supporting double byte characters, the low
;	level routines will return two bytes of data.  Since this routine
;	will only return one byte, the second byte has to be saved.  It
;	is saved in the backup mechanism, which is extended to hold
;	two bytes.
;
;Entry:
;	None.
;
;Exit:
;	AL = character
;	PSW.C = clear (indicates character available)
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****

B$TTY_SINP:
KYBD_SINP:
	XOR	AL,AL		;Get a zero value
	XCHG	AL,[b$TTY_BAKCHR] ;Get the value of/zero out BACKUP flag/char
	OR	AL,AL		;Was there a character pushed back?
	JNE	NoDblCh 	;Yes, return it.

keyin:
	PUSH	DX		; DX gets 2nd and 3rd of 3 byte codes
	XOR	DL,DL		;No ^BREAK checking
	cCALL	B$TTYGetChar	;And get the character
	cCALL	B$INFMAP 	; OEM's mapping routine
	POP	DX
	JZ	keyin		; OEM filtered out the key - get the next
	jnc	NoDblCh 	; BRIF not 2 byte char (kanji or scan)
	call	B$TTY_BAKC	; save second half of 2-byte code
	mov	al,ah		; Return first half
KYBD_Clr_Ret:
	xor	ah,ah		; Clear High order byte

NoDblCh:
	CLC			;Clear carry
Near_Ret:			;Near return for vectors
	RET

;***
;B$TTY_BAKC, KYBD_BAKC - Back up a byte for the keyboard
;
;Purpose:
;	Push a single character "back into the keyboard" so that the
;	next call to B$TTY_SINP will re-read it.  There is room for
;	only one byte of data.
;
;	The value is stored in the variable [b$TTY_BAKCHR].  If this
;	variable has a zero value, there is no character pushed back.
;	If it is non-zero, the value is the byte that was pushed back.
;
;	If Double Byte Characters are supported, then this routine is
;	enhanced to be able to store two bytes of information.	This is
;	not to store a full character, but to store 1/2 of a character
;	gotten from B$TTYIN and 1/2 of a charcter that was pushed back.
;	In this case, b$TTY_BAKCHR is a word and has the following possible
;	values:
;		HIGH BYTE	LOW BYTE	MEANING
;		 undef		   0		No bytes pushed back
;		   0		 non 0		One Byte (Low) pushed back
;		 non 0		 non 0		Two Bytes pushed back
;						(HI, then LOW)
;
;Entry:
;	AL = byte to be saved
;
;Exit:
;	None (state variables updated)
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;****


B$TTY_BAKC:
KYBD_BAKC:
	MOV	[b$TTY_BAKCHR],AL ;Save Char (non-zero value indicates char)
	RET

	SUBTTL	B$TTY_SOUT and B$KanjiFlush
	PAGE


; Support code for B$TTY_SOUT/SCRN_SOUT - - - code that has been pulled
; out of the "mainstream" code, so typical use of B$TTY_SOUT falls through
; all conditional jumps

SCND_BYTE:			;here if just got second of 2 bytes
				;AX = two byte character
	MOV	TWOBYT,0	;Clear TWOBYT flag
	CMP	AL,0FFH 	;test if FFFF needs to be mapped
	JNE	SCNSO3		;if not, just output both bytes
				;   AL = FF only if it is FFFF.
	XOR	AH,AH		;change FFFF to FF for output
	JMP	SHORT SCNSO3	;jump to output the one byte

FIRST_BYTE:
				;here if have the first byte of a two-byte char
	MOV	TWOBYT,AL	;save char for next time
	POP	AX
	RET

CR_OUT:
				;here if char received is a CR
	MOV	AH,0FFh 	;  carriage return is NEVER
	JMP	SHORT SCNOUT	; graphics character! (Prevents
				;  infinite recursion in CHWRAP)
SCNSO6:
				;here if F_EDIT was non-zero, i.e., in INPUT mode
	MOV	AH,TWOBYT	;if 2nd of two bytes, first byte was
				;0FFh, and was put in TWOBYT
	OR	AH,AH		;is this the second of two bytes?
	JNZ	SCND_BYTE	;brif so
	CMP	AL,255	 	;first of two bytes?
	JZ	FIRST_BYTE	;brif so
	JMP	SHORT SCNSO3	;back to mainstream

;***
; B$TTY_SOUT, SCRN_SOUT - send a character to the screen
;
;Purpose:
;	Send a char to the screen. Handle 2-byte chars at this level.
;	A two byte character is managed by calling this routine twice,
;	once with the first byte and once with the second byte.  After
;	the second call, the two byte character will be processed.
;
;	If we do not have FK_KANJI, then the only legal two byte
;	characters are FFxx (Screen Editor Function Code) and then only
;	if F_EDIT is true.  Everything else must be a single byte.  Note
;	that 0x80 and 0xFE are codes to be printed, not part of multiple
;	character sequences.
;
;	If we do have FK_KANJI on, then we can also print any two byte
;	character that has a first byte that is valid according to
;	B$CKDBLC.
;
;	Note that any control characters or double byte characters are
;	sent through B$PRTMAP before printing.	This may introduce
;	a Screen Editor Function which will be resolved internally or
;	it might indicate that there is no character to be printed.
;
;Input:
;	[AL] == character to send to screen
;
;Output:
;	NONE
;
;Modifies:
;	F
;****
B$TTY_SOUT:
SCRN_SOUT:
	PUSH	AX
;
;If last char B$TTY_SOUT was called with was the 1st byte of a 2-byte char,
; B$TTY_SOUT saved it in TWOBYT so they will be both output as one 16-bit
; character.  If we are not running with FK_KANJI, then the only possible
; 2-byte characters are FFxx (for function codes and special characters).

	XOR	AH,AH
				;if not KANJI, can only be a non-zero value in
				;TWOBYT if F_EDIT is TRUE  - - - use this to
				;reduce code executed in typical case.
	TEST	b$IOFLAG,F_EDIT ; in INPUT statement?
	JNZ	SCNSO6		;brif in INPUT
SCNSO3: 			;AH guaranteed 0 if single byte char
	CMP	AL,ASCCR	; Is this a carriage return?
	JZ	CR_OUT		; BRIF so

; Fall through into SCNOUT

;***
; SCNOUT - Output character
;
;Purpose:
;	Output a character to one or more of three places:  the screen,	[13]
;	redirected stdout, and the line printer.			[13]
;	For each char processed, checks to see which of the possible	[13]
;	destinations are to be written to.  Handles chars requiring	[13]
;	mapping (???), and escape sequences.  Only updates the screen	[13]
;	if there is a char to go to the screen.  SCNOUT is recursively	[13]
;	called in order to output a destructive tab to the screen.	[13]
;
;Input:
;	[AL] == character
;	[AH] == 0 if standard character, 0xFF if [AL] == <CR>
;	IF FO_REDIRECT , RED_OUT is set if we're going to redirect stdout [13]
;	b$PTRFIL == 0 if stdout is tty
;	LPR_ECHO is set if we're going to echo to line printer [13]
;	NOTE: Expects AX to be on stack, pops it back to AX at end
;
;Output:
;	NONE
;
;Modifies:
;	F
;****
SCNOUT:
	PUSH	DX
	MOV	DL,SCN_CHR	; assume only SCN_CHAR (speed)
	TEST	b$IOFLAG,RED_OUT OR LPR_ECHO ; Printer echo or redir out?
	JZ	SAV_FLGS	; brif not -- don't do slow checks
	CALL	CHKCHAR		; set RED_CHR, SCN_CHR and LPR_CHR flags
SAV_FLGS:			
	MOV	TEMPFLAG,DL	; save flags in TEMPFLAG

	MOV	DX,b$CURSOR	; put b$CSRY in DL, b$CSRX in DH

	TEST	TEMPFLAG,RED_CHR ; Is output redirected?
	JNZ	REDOUT	       ; BRIF redirection of output
REDOUT_RETURN:		       

;	Do control char logic
; Input:
;	[AX] == control character
;	[DH] == Current screen column position
;	[DL] == Current screen row position

;  Jumps to CTLDSX if AX=valid character to output, else
;  Jumps to SCNOTC_XIT if AX is undefined, and not to be printed to screen


; Map the given character to a new character.  This is where we take
; our internal representation of a character and turn it into something
; useful.  If after mapping the character it contains a screen editor
; function implement the function at this point.
;
; Note that if we are in the screen editor (GWLIN.ASM), we have already
; done the mapping (using EDTMAP instead of PRTMAP).  We know to avoid
; the mapping because F_EDIT was set in __bIOFLAG.

	OR	AH,AH		;test if two-byte character
	JNZ	CALL_PRTMAP1	;[12] jump to map the character
	CMP	AL,31		; is this a CTL character?
	JBE	CALL_PRTMAP2	;[12] branch if so

CTLDSX: 			; end of CTLDSP

; PUTSCR - Now print the char to the screen
;	[AX] == character to put to screen
;	[DX] == prospective destination char. (cursor) position

	TEST	TEMPFLAG,SCN_CHR ; print char on screen?
	JZ	SCNOTC_XIT	; brif not

;Force CR if char in AX won't fit

	PUSH	AX		; save char
	CALL	B$CHKLASTCOL	; DH past last column of screen?
	JBE	NO_WRAP		; brif not -- no wrap required
	CALL	B$SCNCRLF	; output a CR/LF (updates DX)
NO_WRAP:			
	CALL	B$SCROUT 	; Send char in AX to BIOS at DX posn
	INC	DH		; increment cursor location
	CALL	B$UPDATE_CSR	; update cursor variables, and display
	POP	AX		; restore char

SCNOTC_XIT:

	TEST	TEMPFLAG,LPR_CHR ; Is printer echo wanted?
	JNE	SCNOTLE		; Brif want to echo
SCNOTLE_RETURN:			

	POP	DX		; end of SCNOUT
	POP	AX		;NOTE: caller must push AX ...
	RET			; end of B$TTY_SOUT



REDOUT:

;	Here if char to go to redirected file.  Map and output char to stdout.

	PUSH	BX		;save across next two calls
	CALL	REDMAP		; do redirection mapping
	CALL	PUTSTD		; Put char to stdout (if char exists)
	POP	BX
	JMP	SHORT REDOUT_RETURN    ; Jump back to main code sequence


SCNOTLE:
				;here if want to echo to line printer
	CMP	AX,0FF0DH	;test if code for CR
	JNE	SCNOTLE_NO_CR	;if not, then jump
	XOR	AH,AH		;make one-byte char for printer
SCNOTLE_NO_CR:
	CALL	[b$pLPTECHO]	;Echo to line printer if necessary
	JMP	SHORT SCNOTLE_RETURN	


CTLDP1_1:
				;here if function key display mode
	CMP	AH,1		; Set PSW.C if two byte character
	CMC
	cCALL	B$FKYMAP	; Map function key display character
	JMP	SHORT CTLEDT

CALL_PRTMAP2:
				;here if character in AL is <= 31d

	TEST	b$IOFLAG,F_KDSP ; Test for function key display mode
	JNZ	CTLDP1_1	; BRIF function key display mode

CALL_PRTMAP1:
		;here if we don't have a normal char, i.e., it must be mapped
	TEST	b$IOFLAG,F_EDIT ; Test for Screen Edit mode
	JNZ	CTLPRN		; BRIF edit mode
	CMP	AH,1		; Set PSW.C if one byte character
	CMC			; Set PSW.C if two byte character
	cCALL	B$PRTMAP 	; Map print function/output character codes
CTLEDT: JZ	SCNOTC_XIT	; Ignore this character
				; Print or perform the editor function
CTLPRN:
	CMP	AH,255		; Is it an editor function (&HFF)?
	JE	NOT_CTLDSX	;if so, then jump around
	JMP	CTLDSX		;if not, near jump
NOT_CTLDSX:			
	XOR	AH,AH		; Clear (no longer needed) editor function flag
	CMP	AL,177O		; Delete function?
	JNZ	CTLNDL		; BRIF not DEL
	MOV	AL," "		; DEL code
CTLNDL: CMP	AL,255		;++Compiler ignores 0FFh
	JZ	SCNOTC_XIT	; BRIF "mark line for deletion" - don't print
	CMP	AL," "+1 	; Test for legal function code
	JNB	CTLEND		
	TEST	TEMPFLAG,SCN_CHR; screen char?
	JZ	CTLEND		; brif not -- don't process control char

	PUSH	AX

	; get proper index into FUNTAB -- asumes AL in range [0..31]
	SUB	AL,7		; adjust so ascii [7..13] = [0..6]
	CMP	AL,6		; ascii chars [7..13]?
	JBE	TBL_ADJ		;	brif so -- table entry = [0..6]

	SUB	AL,14		; adjust so ascii [28..31] = [7..10]
	CMP	AL,7		; < ascii char 28?
	JL	CTLIGN		;	brif so -- don't process char
	CMP	AL,10		; ascii chars [28..31]?
	JG	CTLIGN		;	brif not -- don't process char

TBL_ADJ:			

	PUSH	BX
	PUSH	CX

	ADD	AX,AX		; Two bytes per entry
	XCHG	BX,AX		
	MOV	AX,OFFSET CS:CTLDPX
	PUSH	AX		; Put CTLPDX: as return address on stack
	CLC
	JMP	WORD PTR CS:FUNTAB[BX] ; Go do control routine

;All control chars come here after processing
; Update b$CURSOR, display new cursor, restore registers, return

CTLDPX:
	CALL	B$SCNLOC	; update B$CURSOR and display user cursor
	POP	CX
	POP	BX
CTLIGN:				
	POP	AX
CTLEND:	JMP	SCNOTC_XIT	; do not to print this char to screen

;--------------------------------------------------------------------------
;  Control character processing routines.
;  All routines will return to CTLDPX.


;-- END SUBROUTINE SCNOUT

	PAGE

	SUBTTL	Control Character processing
;CONTROL CHARACTER DISPATCH TABLE
;--
;Interpreter supports more control characters than compiler.
;		Dispatch address	Action (compiler ignores some)	[13]
FUNTAB:				
	DW	OFFSET B$BLEEP	; ^G  -  Beep
	DW	0		; unused position
	DW	OFFSET LTAB	; ^I  -  Destructive tab
	DW	OFFSET B$SCNCRLF ; ^J - Linefeed outputs CR/LF.
	DW	OFFSET WHOME	; ^K  -  Home within window
	DW	OFFSET CCLRSN	; ^L  -  Clear window, home cursor
	DW	OFFSET B$SCNCRLF ; ^M - carriage return


	DW	OFFSET WCSADV	; ^\  -  Cursor advance within window
	DW	OFFSET WCSREG	; ^]  -  Cursor regress within window
	DW	OFFSET WCSUP	; ^^  -  Cursor up within window
	DW	OFFSET WCSDWN	; ^_  -  Cursor down within window

;***
;LPTECHO
;Purpose:
;	Echo to the line printer.
;	Added with revision [32].
;Entry:
;	[AX] = character code
;Exit:
;	none
;Modifies:
;	None ([AX-DX] is preserved)
;****
cProc	LPTECHO,<NEAR>,<AX,BX,CX,DX>	; preserve the world
cBegin
EchoAnother:			
	PUSH	AX		;store byte in stack
	MOV	DX,SP		;[DS:DX] points to data to be output
	.ERRE	ID_SSEQDS	;assumes DS=SS
	MOV	BX,0004H	;file handle for stdprn
        MOV     CX,1            ;[CX] = # of bytes to be written
	MOV	AH,40H		;write operation
	INT	21H		;do the write
	POP	AX		;even stack and restore AX
	JNC	LPTECHOExit	;jump if no error on write
	JMP	B$ERR_IOE	;give generic Device I/O Error
LPTECHOExit:
	CMP	AL,ASCCR	; just printed a CR?
	MOV	AL,ASCLF	; Assume so -- then we want a LF, too
	JE	EchoAnother	; brif CR -- add a Line feed
cEnd

;***
; PUTSTD - Put character to redirected standard output.
;
; Purpose:
;	Writes a char to redirected stdout.  If given character is a <cr>, [13]
;	put out an <lf> also, as stdout needs one.  Adjust the redirected  [13]
;	file cursor position (used to do line wrapping) appropriately.	   [13]
;
; Entry:	[BX] = character (or zero)
; Exit:  none
; Modifies:
;	F, AX
;****
PUTSTD:
	OR	BX,BX		; Test to see if character exists
	JZ	PUTSTDX 	; BRIF not

	MOV	AX,BX		; place char in AX as well

	CMP	AX,0AH		; about to output an <lf>?
	je	PUT_CR_FIRST	; brif <lf> to put a <cr> first
PUTSTD2:
	CLC			;PWS.C reset indicates a 1 byte character
	CALL	B$STDPUT 	; Write the character
	MOV	AX,BX		; restore character into AX
	CMP	AL,9		; ASCII code < 9 (HT)?
	JB	INC_CSR 	; brif if so -- increment cursor.
	JE	TAB_CHAR	; brif HT
	CMP	AL,0DH		; <lf>,<vt>,<ff>,<cr> ?
	JE	PUT_LF_TOO	; brif <cr> to put an <lf> too
	JBE	RESET_CSR 	; brif <LF>,<VT>, or <FF>
INC_CSR:
	INC	b$REDCSRX	; increment redirected file cursor
PUTSTDX:			
	RET

PUT_CR_FIRST:			;here if we're about to put out an lf
	MOV	AX,0DH		; output a <cr> first
	CLC			;Writing a single byte
	CALL	B$STDPUT	; write it out
	MOV	AX,0AH		; restore <lf>
	JMP	SHORT PUTSTD2

PUT_LF_TOO:			;here if we've just sent a <cr> to stdout and
				;need to put in an <lf> now
	MOV	AX,0Ah		;put <lf> in AX
	CLC			;Writing a single byte
	CALL	B$STDPUT 	; write it out, and reset cursor position

RESET_CSR:			
	XOR	AX,AX		; reset redirected file cursor to 1 for
	JMP	SHORT TAB_DONE	; <LF>,<VT>,<FF>,<CR>

TAB_CHAR:			; adjust cursor when TAB printed
	MOV	AL,b$REDCSRX	; load redirected file cursor (1-relative)
	ADD	AL,8		; move to next modulo-8 position.
	AND	AL,0F8H		
TAB_DONE:			
	INC	AX		; make it 1-relative
	MOV	b$REDCSRX,AL	; store redirected file cursor
	RET			; and return from PUTSTD



;*** 
; B$CHKLASTCOL -- check for last column on screen.  Added with revision [19]
;
;Purpose:
;	Sets flags according to whether DH is [<,=,>] the last printable
;	screen location.
;
;Entry:
;	DH = 1-relative screen column
;Exit:
;	Flags set as if CMP DH,LAST_POS was done.
;Uses:
;	None
;Preserves:
;	All
;Exceptions:
;	None
;
;******************************************************************************
cProc	B$CHKLASTCOL,<PUBLIC,NEAR>
cBegin
	CMP	b$PTRFIL,0	; Test if TTY (=0) or SCRN: (>0)
	JE	CHK_PHYS	; If TTY then check physical width
	CMP	DH,b$SCRNWIDTH	; Test if over logical (SCRN:) width
	JAE	CHK_EXIT	; Brif if greater than or equal
CHK_PHYS:
	CMP	DH,b$CRTWIDTH	; Check for last physical column
CHK_EXIT:
cEnd


;*** 
; B$UPDATE_CSR -- Update cursor after a screen write.
;			 Added with revision [19]
;
;Purpose:
;	Updates the high-level cursor position, and displays the user
;	cursor at the appropriate place.  If we have just printed into
;	the last column of the screen, the cursor is NOT displayed at
;	the first position of the next line.  Instead, it is backed up
;	on top of the character just written.
;
;Entry:
;	DX = new cursor position
;Exit:
;	b$CURSOR updated
;
;	DX = position at which cursor was displayed
;Uses:
;	None
;Preserves:
;	All
;Exceptions:
;	None
;
;******************************************************************************
cProc	B$UPDATE_CSR,<PUBLIC,NEAR>
cBegin
	MOV	b$CURSOR,DX	; update logical cursor b$CURSOR
	CALL	B$CHKLASTCOL	; past last column?
	JBE	NO_DEC		; brif not
	DEC	DH		; back up one position to display cursor
NO_DEC:
	JMP	B$USRCSR	; Redisplay user cursor and return
cEnd	<nogen>


;***
; CHKCHAR -- Sets fields of DL to facilitate complicated checks.  Added with
;		revision [13].
;
; Purpose:
;    Decide whether a character should be printed on the screen, to the
;    redirected file, and/or to the printer, according to the following chart:
;
;------------------------------------------------------------------------
;		|	|	|	|        INPUT statement	|
; Redirection	| FKEY	| SCRN:	| CONS:	|   with edits	| without edits	|
;---------------|-------|-------|-------|---------------|---------------|
; No redirection|   S	|  S,P	|  S,P	|	S	|      S,P	|
; Red OUT	|  ---	|  S,P	|  F	|	S	|      F,P	|
; Red INP	|   S	|  S,P	|  S,P	|	S	|      S,P	|
; Red INP & OUT	|  ---	|  S,P	|  F	|      ---	|      F	|
;------------------------------------------------------------------------
;
;	S = print char to screen
;	P = print char to printer
;	F = print char to redirected output
;
; Function key display when F_KDSP.
; Printing to SCRN: when b$PTRFIL <> 0.
; INPUT statement with user edits when IN_INPUT.
; INPUT statement without user edits when
;	(F_EDIT and NOT IN_INPUT).
; Printing to CONS: at all other times.
;
;
; Algorithm summary:
;
;   Char should be printed to redirected file (RED_CHR) if:
;	RED_OUT and NOT (SCRN: or IN_INPUT or F_KDSP)
;
;   Character should be printed to the screen (SCN_CHR) if:
;	SCRN: or NOT RED_OUT or (NOT RED_INP and IN_INPUT)
;
;   Character should be echoed to the printer (LPR_CHR) if:
;	LPR_ECHO and NOT F_KDSP and NOT IN_INPUT and
;	(SCRN: or NOT RED_OUT or
;	(RED_OUT and NOT IN_INPUT and F_EDIT))
; Input:
;	b$PTRFIL set correctly.
; Exit:	
;	SCN_CHR, RED_CHR, and LPR_CHR fields of DL set correctly.
; Modifies:
;	DX, F
;****
cProc	CHKCHAR,<NEAR>,<AX>
cBegin

	XOR	DX,DX			; initially all flags are false 
	MOV	AL,b$IOFLAG		; keep b$IOFLAG in AL

	TEST	AL,RED_OUT		; is output redirected?
	JZ	SCN_CHAR		;   brif not -- screen char
	CMP	b$PTRFIL,DX		; Test if TTY (=0) or SCRN: (>0)
	JNZ	SCN_CHAR		;   brif SCRN: -- screen char
	TEST	AL,F_KDSP OR IN_INPUT	; function key display or
					; INPUT statement?
	JNZ	CHK_SCN			;	brif so -- not a redir char
	OR	DL,RED_CHR		; set bit to indicate redir char
	JMP	SHORT CHK_LPR		; skip check for screen char

CHK_SCN:				; RED_OUT = TRUE here
	TEST	AL,RED_INP		; redirected input?
	JNZ	CHK_LPR			; 	brif so -- not screen char
	TEST	AL,IN_INPUT		; INPUT statement?
	JZ	CHK_LPR			; 	brif not -- not screen char
SCN_CHAR:
	OR	DL,SCN_CHR		; set bit to indicate screen char

CHK_LPR:
	TEST	AL,LPR_ECHO		; printer echo wanted?
	JZ	CHKCHAR_EXIT		;	brif not -- not a printer char
	TEST	AL,F_KDSP OR IN_INPUT	; function key display or IN_INPUT?
	JNZ	CHKCHAR_EXIT		;	brif so -- not a printer char
	CMP	b$PTRFIL,0		; Test if TTY (=0) or SCRN: (>0)
	JNZ	LPR_CHAR		;	brif SCRN: -- printer char
	TEST	AL,RED_OUT		; redirected output?
	JZ	LPR_CHAR		;	brif not -- printer char

	AND	AL,RED_INP OR F_EDIT	; redisplaying line and not
	CMP	AL,F_EDIT		; redirected input ?
	JNZ	CHKCHAR_EXIT		; 	brif not -- not a printer char
LPR_CHAR:
	OR	DL,LPR_CHR		; set bit to indicate printer char

CHKCHAR_EXIT:
cEnd


;***
; REDMAP - Map character for redirected std. output file
;
; Purpose:
;	Given a character to be printed to redirected stdout, return
;	the mapped character in BX or 0 character should be ignored.
; Input:
;	[AX] = unmapped control character for screen
; Output:
;	[BX] = mapped char for std output (0 if it should be ignored)
;		may be a 1- or a 2-byte character
; Modifies:
;	F
;****

REDMAP: PUSH	AX
	XOR	BX,BX		;Assume no character for standard output
	CMP	AH,1		;Set PSW.C for two byte character
	CMC
	cCALL	B$PRTMAP 	; Map as if a print statement
	JZ	REDMAX		;No character to print
	MOV	BX,AX		;Assume character will be used as mapped
	JNB	REDMAX		;Print character as mapped
	CMP	AH,255D		;Test for control character
	JNZ	REDMAX		;Must be KANJI or other FK_KANJI
	XOR	BH,BH		;Map to single byte char
REDMAX:
	POP	AX
	RET

	PAGE
	SUBTTL	CONTROL CHARACTER ROUTINES - Beep, form feed, home, backspace, tab.

;***
; B$BEEP - BEEP stmt
;
; Purpose:
;	Runtime Entry Point.
;	beep the speaker
; Input:
;	NONE
; Output:
;	NONE
; Modifies:
;	NONE
;****

cProc	B$BEEP,<PUBLIC,FAR>	
cBegin				
	cCALL	B$BLEEP	
cEnd				

;Clear the screen
CCLRSN:
	MOV	AL,2		; specify text only
	CALL	B$CLRSCN 	; OEM supplied Clear-Screen Routine
	CALL	[b$vKEYDSP]	; clear or output status line
				; fall into WHOME

;***
; WHOME - Home the text cursor [36]
; Public equivalent B$WHOME moved into gwini.asm with revision [36].
; Note:  These 2 routines (WHONE & B$WHOME) must be kept in sync!
;
; Input:
;	b$WDOTOP set
; Output:
;	[DL] == home row of cursor
;	[DH] == home column of cursor
; Modifies:
;	NONE
;****
WHOME:				; moved public version to gwini.asm
	MOV	DL,b$WDOTOP	
	MOV	DH,1		
SHORT_RET:			; label to jump to for a RET
	RET



;	LTAB - Destructive TAB to modulo 8 column
LTAB:
	MOV	AX,OFFSET CODE:LTAB_RET ;push the return address first
	PUSH	AX		;and then the letter value...
	MOV	AX,0020h	;Blank out chars
	PUSH	AX		;NOTE: SCNOUT pops AX, but doesn't push it -
				;	this is for B$TTY_SOUT speed
	JMP	SCNOUT		;jump with stack set up
LTAB_RET:
	MOV	DX,b$CURSOR	; put b$CSRY in DL, b$CSRX in DH
	DEC	DH		;TAB stops at 8th column, 16th, ...
	TEST	DH,7
	JNZ	LTAB		;More spacing to next column

	INC	DH
	RET			;New position set on exit.

	PAGE
	SUBTTL	CONTROL CHARACTER ROUTINES

;*** 
; B$SCNCRLF -- Output a CR/LF to the screen.  Re-written with [19].
;
;Purpose:
;	This code is used for either <CR> or <LF>.
;	This routine may find that erasing function key line,scrolling
;	whole screen and redisplaying function key line, is faster than
;	scrolling 1-24.
;
;Entry:
;	DX = present cursor position
;
;Exit:
;	DX = new cursor position
;	Screen possibly scrolled
;Uses:
;	None
;Preserves:
;	AX,BX,CX
;Exceptions:
;	None
;
;******************************************************************************

cProc	B$SCNCRLF,<NEAR>
cBegin
	CALL	B$CRLF		; adjust DX if necessary
	JNZ	SHORT_RET	; if no need to scroll, just return
	JMP	B$SCROLL	; scroll screen and return
cEnd	<nogen>

	PAGE
	SUBTTL	CONTROL CHARACTER ROUTINES - Function key display and advance

;B$LABELK - If function key display is off then turn on and exit.
;	  If function key display is on then advance display line and
;	  redisplay.
;ENTRY  - DX = cursor position
;EXIT	- None [13]
;USES	- None [13]



	PUBLIC	B$LABELK 	;Can be called by $RDLIN directly.
B$LABELK:			

	NOT	b$KEY_SW	; toggle function key display switch
	JMP	[b$vKEYDSP]	; Display function keys

	PAGE
	SUBTTL	CONTROL CHARACTER ROUTINES - Cursor movement by character and line
;	The control character routines are entered with DH=current column and
;	DL=current line. They return updated posn in the same registers. They
;	can modify AX, BX, CX but must save any other registers used.


;***
; WCSADV, WCSREG, WCSUP, WCSDWN - cursor control
;
; Purpose:
;	CURSOR CONTROL
;	The cursor control routines allow moving the cursor right (and left)
;	with wraparound to following (or previous) line unless it is at the
;	very bottom (or top) of the screen. Attempts to move the cursor up
;	from the top line of the screen or to move the cursor down from the
;	bottom line on the screen are ignored.
;
; Inputs:
;	[DL] == current line
;	[DH] == current column
; Outputs:
;	updated line position in DL
;	updated column position in DH
;
;	These routines return CF=1 when they do not change the posn.
; Modify:
;	AL
;****

;Cursor right within window
WCSADV:
	INC	DH		; Next column
	CALL	B$CHKLASTCOL	; past last valid column?
	JBE	CSRRET		; BRIF Good value
CSRADV_DOWN:			
	DEC	DH
	CALL	WCSDWN
	JB	CSRRET		; BRIF can't change physical lines
	MOV	DH,1		;First column
CSRRET:
	RET			; update position and redisplay cursor

;Cursor left within window(or within physical line if outside window)
WCSREG:
	DEC	DH		; Previous column
	JNZ	CSRRET		; BRIF good value (1 or greater)
	INC	DH		; Restore column
	CALL	WCSUP		
	JB	CSRRET		; BRIF can't change physical lines
				; fall into B$GETLASTCOL

B$GETLASTCOL:			; DH = last column (anybody need this FN?)
	MOV	DH,BYTE PTR b$CRTWIDTH ; Last column of physical screen
	CMP	b$PTRFIL,0	; Test if TTY (=0) or SCRN: (>0)
	JE	CSRRET		; If TTY, then jump to redisplay cursor
	CMP	b$SCRNWIDTH,255 ; Check for infinite width
	JE	CSRRET		; If so, then use b$CRTWIDTH, redisplay
	MOV	DH,b$SCRNWIDTH	; Else use logical width
	RET			; return and redisplay cursor

;Cursor up within window(or NOP if outside window)
WCSUP:
	CMP	b$WDOBOT,DL	
	JB	CSRRET		; BRIF outside of window
	CMP	DL,b$WDOTOP	
	JB	CSRRET
	STC
	JZ	CSRRET		; BRIF at top or outside of window
	CLC
	DEC	DX		
	RET			; return and redisplay cursor

;Cursor down within window(or NOP if outside window)
WCSDWN:
	CMP	DL,b$WDOTOP	
	JB	CSRRET		; BRIF outside window
	CMP	b$WDOBOT,DL	
	JB	CSRRET		; BRIF at bottom or outside of window
	STC
	JZ	CSRRET
	CLC
INC_DX:				
	INC	DX		; Next line
	RET			; return and redisplay cursor


;***
; B$TTY_GPOS, B$SCRN_GPOS - return screen position
;
; Input:
;	b$CSRX contains current cursor position on screen
;	or b$REDCSRX contains the current redirected file position [13]
; Output:
;	[AH] == screen position
; Modifies:
;	F
;****
labelNP	<PUBLIC,B$TTY_GPOS>	
	TEST	b$IOFLAG,RED_OUT ; redirected output?
	MOV	AH,b$REDCSRX	; return redirected file position
	JNZ	GPOS_RET	; brif so -- return redir file cursor

labelNP	<PUBLIC,B$SCRN_GPOS>	
SCRN_GPOS:
	MOV	AH,b$CSRX	; return screen cursor position
GPOS_RET:
	DEC	AH		; return 0-relative value
	RET


;***
; B$TTY_GWID, SCRN_GWID - return screen width
;
; Input:
;	b$CRTWIDTH contains current tty width
;	b$SCRNWIDTH contains current SCRN: width
; Output:
;	[AH] == screen width
; Modifies:
;	NONE
;****

B$TTY_GWID:
	MOV	AH,b$CRTWIDTH	; (AH) = physical screen width
	RET

SCRN_GWID:
	MOV	AH,b$SCRNWIDTH	; (AH) = logical screen width
	RET

	PAGE

;***
; B$TTY_BLKIN	- block input
;	NOT IMPLENTED					--DMA support for BLOAD
;	Entry	[bx] =	offset of destination
;		[cx] =	maximum number of bytes to read
;		[dx] =	DS of destination
;		[di] -> device number
;		[si] -> FDB of file to be loaded
;	exit	?      (This routine is provided to allow the user
;			to trash himself beyond all recognition!
;	Exit	[bx] =	1 past last byte read
;		CF	set if EOF encountered
;****

B$TTY_BLKIN:			;fall into B$ERR_FC jump


;***
; B$TTY_BLKOUT	-  block output
;	NOT IMPLEMENTED 				--DMA support for BSAVE
;	Entry	[bx] =	offset of source
;		[cx] =	maximum number of bytes to write
;		[dx] =	DS of source
;		[di] =	device number
;		[si] -> FDB of file to be loaded
;	Exit	[bx] =	1 past last byte written
;		CF	set if insufficient space
;****

B$TTY_BLKOUT:
width_error:  jmp B$ERR_FC	

devio	ENDP

;
; Moved here from GWINI with [41]
;
;***
;B$SCNSWD - set screen width (called by WIDTH"scrn:",n)
;
;Purpose:
;	Sets the width of the SCRN: device to the specified amount.
;
;Entry:
;	DL = new width
;
;Exit
;	b$SCRNWIDTH (logical width) set
;	physical screen width possibly changed (if 80 or 40 columns specified)
;
;Uses:
;	Per convention
;****

cProc	B$SCNSWD,<NEAR>
cBegin
	XCHG	AX,DX		;keep width in AL
	DEC	AX		;map [1-255] to [0-254]
	CMP	AX,254		;in range [0-254]?
	JA	WIDTH_ERROR	;brif not -- illegal function call error
	INC	AX		;restore width from entry

	CMP	AL,255		;infinite width?
	JZ	SCNWD2		;Brif so
SCNWD1:
	CMP	AL,b$CRTWIDTH	;new width different from physical?
	JE	SCNWD2		;brif not
	PUSH	AX		;save logical width
	MOV	CL,B$LINCNT	;pass Height in CL
	cCALL	B$SWIDTH	;Let OEM call B$SCNSWI if legal
				;if OEM didn't like it, b$CRTWIDTH unchanged
	POP	AX		;restore logical width
	CMP	AL,b$CRTWIDTH	;Test if logical < physical width
	JB	SCNWD2		;If so, then use given width
	MOV	AL,b$CRTWIDTH	;Get physical width
SCNWD2:
	MOV	b$SCRNWIDTH,AL	;set the SCRN: logical screen width

cEnd

;
;Merged in B$SCNWID from GWINI.ASM
;
;***
;B$WIDT - WIDTH wid,hgt statement
;
;Purpose:
;	Runtime Entry Point.
;	Set the WIDTH for the screen
;
;Input:
;	wid - requested width (-1 if default)
;	height - requested height (-1 if default)
;
;Output:
;	None
;
;Uses:
;	Per Convention
;
;Exceptions:
;	NONE
;****
cProc	B$WIDT,<PUBLIC,FAR>	
parmW	wid			
parmW	height			
cBegin				
	MOV	BX,wid		;get width
	MOV	DX,height	;get height
	CMP	DX,-1		;Is height specified?
	JNE	H_Specified	; Yes:
	MOV	DL,B$LINCNT	; No: set to full screen
	XOR	DH,DH
H_Specified:

	OR	DH,DH		;Height < 256?
	JNZ	width_error
	CMP	BX,-1		; Is Width specified?
	JNE	W_Specified	; Yes:
	MOV	BL,b$CRTWIDTH	; No: set to full screen
	XOR	BH,BH		; Make Hi-Byte zero
W_specified:			
	OR	BH,BH		;Width < 256?
	JNZ	width_error

	CMP	BL,b$CRTWIDTH	; Test if physical width changed
	JNE	SCNWID0 	;Yes:
	CMP	DL,B$LINCNT	; Has height changed?
	JE	SCNRET		; wrong jump sense
				;Yes: call B$SWIDTH to set $CRTWID if legal.
SCNWID0:			;if either changed, go set hardware.

	PUSH	CX		;If width has changed, set hardware
	PUSH	AX
	XCHG	AX,BX		; pass Width in AL
	XCHG	CX,DX		; pass Height in CL
	CALL	B$SWIDTH	;Let OEM call B$SCNSWI if legal
	JB	WIDTH_ERROR	;OEM didn't like it.
	POP	AX
	POP	CX

SCNRET:
cEnd				


;***
; B$IfScrnDev - Check if current device printing to screen.
;
; Purpose:
;	Used by QB4 to determine if they have to do debug screen swapping.
;	Added with [20].
;
;	Returns true if the current I/O device is TTY, SCRN:, CONS:,
;	or a console I/O DOS file.
;
;	Note:  This routine MUST preserve ES and CANNOT cause heap movement.
; Entry:
;	b$PTRFIL set correctly.
; Exit:
;	AX	=  0 if no screen output possible
;	AX	= -1 if screen output possible
; Modifies:
;	BX,CX
; Preserves:
;	DX,ES
; Exceptions:
;	None
;****

cProc	B$IfScrnDev,<PUBLIC,FAR>
cBegin

	XOR	AX,AX		; assume no screen output
	MOV	BX,b$PTRFIL	; pointer to current file/device
	OR	BX,BX		; TTY?
	JZ	ScrnDevice	; brif so -- screen device
	MOV	CL,[BX].FD_DEVICE ; AX = device number
	XOR	CH,CH		; clear high byte
	JCXZ	DiskFile	; brif disk file
	CMP	CL,DN_SCRN	; SCRN:?
	JE	ScrnDevice	; brif so -- screen device
	CMP	CL,DN_CONS	; CONS:?
	JE	ScrnDevice	; brif so -- screen device
	JMP	SHORT NoScrnDevice ; otherwise, not a screen device
DiskFile:
	TEST	[BX].FD_FLAGS,FL_CONOUT+FL_CONINP ; console I/O?
	JZ	NoScrnDevice	; brif not -- not a screen device

ScrnDevice:
	DEC	AX		; AX = -1 ==> screen output
NoScrnDevice:
cEnd




sEnd	DV_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\keydsp.asm ===
TITLE	KEYDSP - Display function keys/ Clear last line
;***
; KEYDSP - display function keys / Clear last line / utility routines
;
;	Copyright <C> 1987 Microsoft Corporation
;
;Purpose:
;
;  This module is used to display the values of the function keys on the
;  last line of the screen.  It is also used to clear the last line.
;  This module is not generally linked in unless an INPUT or KEY statement
;  occurs in the BASIC program.  Called in by B$INPP and B$KFUN.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc	; general runtime macros

	UseSeg	_BSS
	UseSeg	_DATA
	UseSeg	RT_TEXT
	UseSeg	INIT_CODE
	UseSeg	<XIB>		; XIB and XIE must bracket XI!
	UseSeg	<XI>		; initializer segment
	UseSeg	<XIE>		

	INCLUDE seg.inc		; segment definitions
	INCLUDE baslibma.inc
	INCLUDE files.inc
	INCLUDE nhutil.inc
	INCLUDE ascii.inc
	INCLUDE idmac.inc	; Internal debugging macros
	INCLUDE const.inc	; bit flag constants
	INCLUDE rtps.inc	; constants shared with QBI

	.radix	10

INITIALIZER	B$xFNKYDSPINI	

sBegin	INIT_CODE
assumes	CS,INIT_CODE

cProc	B$xFNKYDSPINI,<FAR>
cBegin
	mov	[b$vKEYDSP],RT_TEXTOFFSET B$KEYDSP ;;initialize B$KEYDSP vector
cEnd
sEnd	INIT_CODE

;#***********************************************************************
;
sBegin	_DATA

externW	b$vKEYDSP		;vector for B$KEYDSP indirect calls
externW	b$CURSOR		; (1,1)-relative screen cursor
externB b$LINCNT
externB	b$IOFLAG		; general-purpose IO bits 

sEnd	_DATA
;
;#***********************************************************************

;#***********************************************************************
;
sBegin	_BSS

externW   b$PTRFIL	  ;GOSTOP -
externW   B$FKCNUM	  ;GWDATA -
externW   b$STRTAB	  ;GWDATA -
externB   b$KEY_SW	  ;GWDATA -


sEnd	_BSS
;
;#***********************************************************************

sBegin	RT_TEXT

assumes cs,RT_TEXT

;#*************************************
;	Equates

	FKEYCR=27D		;IBM CR FKey display line graphic

;#*************************************
;	Externals

externNP   B$SCNLOC
externNP   B$CLREOL
externNP   B$OFFCSR		; turn off cursor (B$CSRDSP with AL=0)
externNP   B$FKYFMT
externNP   B$GETFBC		; Get and set
externNP   B$SETFBC		; foreground/background attributes
	externNP   B$TTY_SOUT

;#*************************************
;	Publics

;***
; B$LastLine -- return values of last line.
;
;Purpose:
;	Return cursor position of first column of last line.
;Entry:
;	None.
;Exit:
;	DX = b$CURSOR = cursor position of first column of last line.
;Modifies:
;	none.
;Exceptions:
;	none.
;****

cProc	B$LastLine,<NEAR,PUBLIC>
cBegin
	MOV	DH,1		; column 1
	MOV	DL,B$LINCNT 	; last line
	MOV	b$CURSOR,DX	; update cursor variable
cEnd


	SUBTTL	KEYON,	KEYOFF, and KEYDSP

;***
;B$KEYDSP -	Display Softkeys on last line of Screen.
; Entry:
;	None
; Exit:
;	None.
; Modifies:
;	none.
;****

cProc	B$KEYDSP,<NEAR,PUBLIC>,<AX,BX,CX,DX,SI>
cBegin
				
	OR	b$IOFLAG,F_KDSP ; Tell B$TTY_SOUT we want $FKYMAP

	PUSH	b$CURSOR	; Save current cursor position (row and col)
	CALL	B$LastLine	; DX = b$CURSOR = first column of last line

	MOV	AL,b$KEY_SW
	OR	AL,AL		;Key on or off?
	JNZ	KEYDS0		;Softkey display switch on
	CALL	B$CLREOL	;Clear from (DH,DL) to EOL,return cursor
keyret:
	POP	DX		;get back original cursor position.
	CALL	B$SCNLOC 	; Reset cursor position and display user
				; cursor
	AND	b$IOFLAG,NOT F_KDSP ; Turn off function key display mode

cEnd


KEYDS0:
	CALL	B$OFFCSR 	;Turn the cursor off, and position

	CALL	GETFMT		;Get function key display format
KNXTST: PUSH	AX		;Save Key disp no.
	CMP	AH,"0"		;Single digit case?
	JZ	SINDIG		;Print only one digit
	XCHG	AH,AL
	CALL	KEYDCH		;Display first digit
	XCHG	AH,AL
SINDIG: CALL	KEYDCH		;Display last digit
	PUSH	SI
	LODSW
	XCHG	BX,AX		;Get length of this function key string
	LODSW
	XCHG	SI,AX		;SI := address of string.
	MOV	CL,BYTE PTR B$FKCNUM ;Count of chars per fun. key (set by GET
	OR	BL,BL		;test if softkey string is null
	JZ	FKCNL1		;if so, do not invert the video
	CALL	$XFGBG		;Swap Forground & background colors
FKCNL1:
;BX=length of string, CL=number of chars to display
KNXTCH: 			; Write the next key character
	OR	BX,BX		; if length<=0 then print a blank
	jg	PrintChar	; else print char from string
	xor	al,al
	jmp	SHORT NOCR	
PrintChar:
	LODSB

	CMP	AL,ASCCR	;     If char is CR then print graphic char
	JNZ	NOCR
	MOV	AL,FKEYCR
NOCR:
	CALL	KEYDCH		;Display char, adv cursor in DX
	dec	bx
	DEC	CL		;Repeat until FCKNUM chars/fkey displayed
	JNZ	KNXTCH		;Loop for next character

	ADD	BL,BYTE PTR B$FKCNUM ;BL is 0 if softkey string null
	JZ	FKCNL2		;if null, then do not invert video
	CALL	$XFGBG		;Swap Forground & background colors
FKCNL2:
	XOR	AL,AL
	CALL	KEYDCH
	POP	SI
	POP	AX
	CALL	KEYADV		;Advance to next key
	DEC	CH
	JNZ	KNXTST		;Loop for next key string
	jmp	keyret		;Return cursor to original position and exit


KEYDCH:
	PUSH	AX
	PUSH	BX
	OR	AL,AL		;Separating keys?
	JNZ	KEYDC1		;Brif not.
	MOV	AL," "		;else write space
KEYDC1:
	CMP	AL,ASCLF	;Line feed?
	JNZ	KEYNLF		;Not line feed
	MOV	AL,74O		;Substitute Greater-Than-Sign
KEYNLF:

	PUSH	CX
	CALL	B$TTY_SOUT	; Write the character, skipping redirection.

	POP	CX
	POP	BX
	POP	AX		;Restore key number
	RET

	PAGE
;Get function key display format

GETFMT: PUSH	BX
	cCALL	B$FKYFMT 	; OEM routine
	MOV	CX,WORD PTR 0[BX] ;CH=key count, CL=Chrs/key
	MOV	BYTE PTR B$FKCNUM,CL
	PUSH	CX
	MOV	SI,OFFSET DGROUP:b$STRTAB ;SI=address of first fkey in table
	MOV	AL,BYTE PTR 2[BX]
	CBW
	PUSH	AX		; Save number of first function key
	DEC	AX		; Set to zero relative
	SHL	AX,1		; Multiply by  4 (bytes/key descriptor)
	SHL	AX,1		; AX = index of first display key
	ADD	SI,AX
	POP	AX
	CALL	INTOCH		;Get key number to character code
	CMP	AH,"0"
	JZ	ONEDIG		;Only one digit
	DEC	BYTE PTR B$FKCNUM ;Adjust function key format for two digits
ONEDIG: CALL	KADNRM		;Normalize key address
	POP	CX
	POP	BX
	RET

;INTOCH: Translate integer AL to characters in AX.
;	 Integers must be in the range (100,0].
;	 Radix is 10.
;USES -  none


INTOCH: PUSH	CX
	XOR	AH,AH
	MOV	CL,10D		;Load radix
	DIV	CL
	ADD	AX,"00"		; 3030H forms character codes
	XCHG	AH,AL		;AH represents significant digit
	POP	CX
	RET

;KEYADV - Advance to next key

KEYADV: ADD	SI, 4D		;Move to next key table entry
	INC	AL
	CMP	AL,"9"
	JLE	KADNRM
	MOV	AL,"0"
	INC	AH
	CMP	AH,"1"		;Test for first two digit key number
	JNZ	KADNRM
	DEC	BYTE PTR B$FKCNUM ;And adjust format for it
KADNRM: CMP	SI,OFFSET (DGROUP:b$STRTAB)+NUM_FKEYS*4
	JBE	KADNMX		; brif less than end address
				; (UNSIGNED compare required!!!)
	MOV	SI,OFFSET DGROUP:b$STRTAB ;Wrap around to the first function key
	MOV	AH,"0"
	MOV	AL,"1"
	INC	BYTE PTR B$FKCNUM ;Re-adjust format
KADNMX: RET

	PAGE
	SUBTTL	Swap Forground & Background Colors

;Swap Forground & Background Colors (Toggle Reverse Video Mode)

$XFGBG:
	push	ax
	push	bx
	CLC			;Signal text attributes
	CALL	B$GETFBC	;Get foreground/background attributes
	XCHG	AX,BX
	CALL	B$SETFBC	;Set foreground/background attributes
	pop	bx
	pop	ax
	RET

sEnd	RT_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llaevt.asm ===
PAGE	56,132
	TITLE	LLAEVT - GW-BASIC Event Trapping Interface
;***
; LLAEVT - GW-BASIC Event Trapping Interface
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;   ***********************************************************************
;
;	This module has advanced EVENT support routines:
;
;	B$RTIMR
;	B$RDPEN
;	B$RDPLAY	
;	B$RDSIG
;	B$RDMOUSE	
;	B$RDUEVENT	
;	CLOCKTIC  .....clock interrupt routine branches here after
;			updating time of day. This routine is used to
;			check for TIMER events, PEN status and TRIG
;			status.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	

	useSeg	_BSS		
	useSeg	_DATA		
	useSeg	EV		; Event handling segment(s)

	INCLUDE seg.inc 	
	INCLUDE ibmunv.inc
	INCLUDE idmac.inc	; debugging macros
	INCLUDE intmac.inc
	INCLUDE event.inc	; bit flag constants

sBegin	_DATA			

	externB	b$EventFlags	; misc event flags
globalW b$pJoystInt,NearRet,1	; Joystick interrupt handler

staticW	TIMRN1,-1		; stores n of ON TIMER(n) (4 bytes)
staticW	TIMRN2,-1		; start with -1 (no timeout) for OS/2

staticW	SleepCnt1,0		; number of clock ticks to wait before
staticW	SleepCnt2,0		; SLEEP statement times out


sEnd	_DATA			


sBegin	_BSS			

	externB b$PLAFLG	;LLSND - playing flag
	externB b$PLENBL	;LLSND - play enable flag
	externW b$PLYCNT	;LLSND - play note count
	externW b$SNDQCB	; Sound queue block



LPEN_MAX_ARG	EQU	9	; Maximum allowable arg value

LPEN_COORDS	STRUC		; Structure for LPEN land/touch values

LPEN_STATUS	DB	0	; Used as filler as PEN(0) does not require
LPEN_DUMMY	DB	0	; any data variable

X_LAND		DW	0	; Graphics X-coord when pen last landed
Y_LAND		DB	0	; Graphics Y-coord when pen last landed
Y_LAND_HI	DB	0	; Dummy entry for high byte

LPEN_ENABLE	DB	FALSE	; LPEN enable/disable flag - initial disable
LAND_FLAG	DB	FALSE	; These used since PEN(3) does not require
				; any data variable
X_TOUCH		DW	0	; Graphics X-coord when pen last touched
Y_TOUCH		DB	0	; Graphics Y-coord when pen last touched
Y_TOUCH_HI	DB	0	; Dummy entry for high byte
ROW_LAND	DB	1	; Character row when pen last landed
ROW_LAND_HI	DB	0	; Dummy entry 
COL_LAND	DB	1	; Character column when pen last landed
COL_LAND_HI	DB	0	; Dummy entry
ROW_TOUCH	DB	1	; Character row when pen last touched
ROW_TOUCH_HI	DB	0	; Dummy entry
COL_TOUCH	DB	1	; Character column when pen last touched
COL_TOUCH_HI	DB	0	; Dummy entry

LPEN_COORDS	ENDS

LPEN	LPEN_COORDS	<>	; Allocate space and initialize


TMRFLG	DB	1 DUP(?)	;timer evnt flag
TMENBL	DB	1 DUP(?)	;timer event enable flag
;
;	The timer used $TIMRSW as an one-second downcounter, which counted
;	down from 18.  Although the period of 18 clock interrupts were closed
;	to one second, there was about 0.0109 second difference, which was
;	based on 18.2 interrupts being one second.
;	Instead of using an one-second counter, current method uses the
;	interrupt counter directly.  When the high level code gets n from
;	the statement ON TIMER (n) ... and passes it to the low level code,
;	the n, in seconds, is multiplied by 18.2.  The result, which is
;	how many interrupts needed, is then stored in $TMCNT1 & $TMCNT2.
;
TMCNT1	DW	1 DUP(?)	;down counter
TMCNT2	DW	1 DUP(?)	;down counter is now 4 bytes





sEnd	_BSS			


sBegin	EV_TEXT 		
assumes CS,EV_TEXT		

externNP B$TrapEvent		;routine to set global event flag



externNP	B$SCNIO		;LLINI - perform screen BIOS call
externW 	b$BASDSG	;LLINI - BASCOM data segment
externD 	b$OldClkTic	;LLINI - saved INT 1CH vector

	SUBTTL	B$RDPEN - Read Light-Pen Coordinates and Trigger Flag.
	PAGE
;***
;B$RDPEN - Read Light-Pen Coordinates and Trigger Flag.
;OEM-interface routine
;
;Purpose:
;	This routine supports the light-pen.  It allows reading of
;	the coordinates of the pen, deturmining its status (touching
;	the screen or not touching the screen), and event support
;	for ON TRIGGER(n) GOTO.
;
;	See the documentation for B$POLLEV for a description of the
;	event and trapping mechanisms.
;
;Definitions:
;	The light pen is always in one of 2 states:
;
;	   "touching the screen" or "not touching the screen".
;
;	In the following text, the point at which a light pen last landed  on
;	the  screen  is defined as the point where the pen last changed state
;	from "not-touching the screen" to "touching the screen".   The	point
;	at which the pen last touched the screen is defined as the last point
;	at which the state of the pen was "touching the screen".
;
;Entry:
;	[AL] = which value to return in [BX]
;	    0:	 If PEN has touched screen since
;		 last call to B$RDPEN with [AL]=0 then return -1
;		 else return 0.
;	    1:	 Return graphic X-Coordinate where pen last landed
;		 on the screen.
;	    2:	 Return graphic Y-Coordinate where pen last landed
;		 on the screen.
;	    3:	 If PEN is currently touching screen
;		 then return -1, else return 0.
;	    4:	 Return graphics X-Coordinate where pen last
;		 touched the screen.
;	    5:	 Return graphics Y-Coordinate where pen last
;		 touched the screen.
;	    6:	 Return character line where pen last landed
;		 on the screen.
;	    7:	 Return character column where pen last landed
;		 on the screen.
;	    8:	 Return character line where pen last
;		 touched the screen.
;	    9:	 Return character column where pen last
;		 touched the screen.
;	    254: Enable light pen interrupt processing until B$RDPEN
;		 is called with [AL]=255.  This is to increase
;		 system performance.  It can be ignored by OEM.
;	    255: Disable light pen interrupt processing until B$RDPEN
;		 is called with [AL]=254.  This is to increase
;		 system performance.  It can be ignored by OEM.
;		 When the system is initialized, light pen interrupt
;		 processing can be disabled.
;
;Exit:
;	[BX]=return value as a signed 16-bit integer.
;
; Note	- The range of Graphics Coordinates is determined by the
;	  current graphics mode.  Character line and column coordinates
;	  are 1 relative.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;****

cProc	B$RDPEN,<PUBLIC,NEAR>	
cBegin				

	cCall	B$SetClockInt	; check if CLOCK_INT has been installed
				;if not install it
	CBW			; AH = 0/-1
	CMP	AL,LPEN_MAX_ARG	; Check for input value
	JBE	PROC_LPEN	; Brif if PEN function

LPEN_ON_OFF:			; Check if request is to turn it on/off
	INC	AX		; AX = -1/0 (254/255)
	MOV	LPEN.LPEN_ENABLE,AL ; Set the enable variable appropriately

;	Now, read the LPEN_STATUS once again and discard it. This is required
;	to avoid spurious results next time the light pen status is read
;	because the BIOS internal flag is cleared only when it is read

	XCHG	BX,AX		; Save it in BX
	cCALL	B$PENINT	; Still LPEN_STATUS is modified
	AND	LPEN.LPEN_STATUS,BL ; And change the status correctly
				; If enabled & active then remain active
				; else set to inactive
	JMP	SHORT LPEN_RET	; & Exit...

LPEN_3:				; Process PEN(3) function
	SCNIOS	vReadLightPen	; Read light pen status again (current val)
	SAHF			; If AH = 1 , then CF = 1 (pen active)
	XCHG	AX,BX		; Save BX (returned value) in AX
	SBB	BX,BX		; Set BX to 0/-1 as return value
	JZ	LPEN_RET	; If pen not active, simply return
	MOV	LPEN.X_TOUCH,AX	; Current X coordinate
	MOV	LPEN.Y_TOUCH,CH	; Current Y coordinate
	MOV	LPEN.ROW_TOUCH,DH	; Current row
	MOV	LPEN.COL_TOUCH,DL	; Current col
	JMP	SHORT LPEN_RET		; Exit ...

PROC_LPEN:			
				; AH = 0 here
;	If light pen is not enabled, then issue an error

;	CMP	LPEN.LPEN_ENABLE,AH	; Is it zero? (disabled)
;	MOV	BX,-1		; Prepare for error
;	JE	LPEN_RET	; Brif disable - CF = 1 for error

;	The function value requested is other than 0.
;	If it is 3, then handle it as a special case

	CMP	AL,03		; Is it special case?
	XCHG	AX,BX		; Get input arg in BX
	JE	LPEN_3		; If 3, then read the current lpen status
	SHL	BX,1		; Make it a word index into LPEN structure
	MOV	BX,[OFFSET DGROUP:LPEN+BX] ; Get the value requested
	JNZ	LPEN_RET	; If arg not zero then return the value
	MOV	LPEN.LPEN_STATUS,BH ; If arg = 0, then reset status to zero
	MOV	BH,BL		; Copy low byte for reporting

LPEN_RET:			; Time for returning

cEnd				; End of B$RDPEN



	SUBTTL	B$RDMOUSE - Read Mouse information
	PAGE


	SUBTTL	Timer Event Routines
	PAGE
;***
;B$RTIMR - Timer Event Trapping
;OEM-interface routine
;
;Purpose:
;	This routine supports timer event trapping and the
;	ON TIMER(n) function. This routine allows enabling and
;	and disabling the timer, setting the timer interval, and
;	polling if a timer event has occured.
;
;	A timer event will not be generated until the timer is enabled
;	and the timer interval has passed.
;
;	See the documentation for B$POLLEV for a description of the
;	event and trapping mechanisms.
;
;Entry:
;	[AL] = Function code
;		0: Return [BX] = -1 if event occured since last
;					call to B$RTIMR with [AL] = 0
;				  0 if event did not occur since last
;					call to B$RTIMR with [AL] = 0
;		1: Set timer interval to three byte integer [CL]:[DX]
;		254: Enable timer trapping
;		255: Disable timer trapping
;	[CL]:[DX] = three byte integer timer interval (in seconds)
;
;Exit:
;	[BX] = value if specified by function [AL]
;	PSW.C set indicates an error in the input parameters and will
;	      cause an Illegal Function Call.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;****
cProc	B$RTIMR,<NEAR,PUBLIC>
cBegin
	CALL	B$SetClockInt	; check if CLOCK_INT has been installed
				;if not install it
	CMP	AL,0		;is [AL] = 0?
	JE	CHKTMR		;check for timer event
	CMP	AL,1
	JE	SETIMR		;set timer interval
	INC	AL		; was it 255?
	JZ	STPTMR		; disable timer trapping
	INC	AL		; was it 254?
	JZ	STATMR		; enable timer trapping
	STC			;set carry to indicate function
	JMP	SHORT RDTRET	;call error and return
;
; See if timer event occurred. Returns BX as described above.
;
CHKTMR:
	XOR	BX,BX		; default is to report no timer event
	CMP	TMENBL,1	;is timer enabled?
	JNZ	RDTRET		; Brif not
	CMP	TMRFLG,1	;did timer event occur?
	JNZ	RDTRET		; Brif not
	DEC	BX		; else report it
	MOV	TMRFLG,0	;clear the timer event flag
	JMP	SHORT RDTRET
;
; Set the timer event to occur in CL:DX seconds.
;
SETIMR:
	CALL	SCTOIC		;[CX:DX] = n * factor (OS dependant)
	MOV	TMCNT1,DX	;[TMCNT1:TMCNT2] = time, in os dependant terms
	MOV	TMCNT2,CX	;	 CNT is count decremented by timer int
	MOV	TIMRN1,DX	;[TIMRN2:TIMRN1] = same
	MOV	TIMRN2,CX
	JMP	SHORT RDTRET
;
; Start the timer
;
STATMR:
	PUSH	BX
	MOV	BX,TIMRN1	;move n of ON TIMER(n)
	MOV	TMCNT1,BX	;to the down counter
	MOV	BX,TIMRN2	; changed to four bytes
	MOV	TMCNT2,BX
	POP	BX
	MOV	TMENBL,1	;enable trapping
	JMP	SHORT RDTRET
;
; Stop the timer
;
STPTMR:
	MOV	TMENBL,AL	; disable trapping
	MOV	TMRFLG,AL	; clear the timer event flag

RDTRET:

cEnd				

;***
;B$SetClockInt - Install CLOCKTIC interrupt if not already installed
;OEM-interface routine
;
;Purpose:
;	This routine checks to see if the CLOCKTIC has been
;	installed or not. If not installed it installs it.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;****
cProc	B$SetClockInt,<NEAR,PUBLIC>	
cBegin				
	TEST	b$EventFlags,TimerInst ; timer interrupt installed yet ?
	JZ	SET_IT		;Brif not -- install it now
NearRet:			; label to a near return
	RET
SET_IT:


	PUSH	AX
	PUSH	DX
	PUSH	DS
	IN	AL,MSKREG	;get IMR into AL
	OR	AL,01H		;mask out timer interrupt
	PAUSE
	OUT	MSKREG,AL	;write mask to IMR
	CLI			;Interrupts off during mod.
	push	bx
	push	es
	savint	cs:b$OldClkTic,timadr
	pop	es
	pop	bx
	PUSH	CS		;set [DS] = [CS]
	POP	DS
	SETVEC	TMRCTL,CLOCKTIC ;set clock interrupt
	POP	DS		;restore [DS]
	POP	DX
	OR	b$EventFlags,TimerInst ; set timer installed flag
	IN	AL,MSKREG	;get IMR into AL
	AND	AL,0FEH 	;unmask timer interrupt
	PAUSE
	OUT	MSKREG,AL	;write mask to IMR
	POP	AX		;restore [AX]
	STI			;restore interrupts

cEnd				



;***
;CLOCKTIC - The Timer Interupt vectors here AFTER updating the time-of-day.
;
;		CLOCKTIC polls the PEN Status (if ON) and stores
;		new values.  Then Joystick TRIGGERS (if ON) and
;		stores their values if fired since last time
;		read with the STRIG(0) or STRIG(2) Statement.
;
;	NOTE:	Rom clock interrupt routine saved [AX],[DX],[DS]
;
;	read the comment at the top of the file for detail.
;******************************************************************************
cProc	CLOCKTIC,<FAR>		
cBegin				
	PUSH	BP
	PUSH	DI
	PUSH	SI
	PUSH	DS
	PUSH	AX
	MOV	DS,CS:b$BASDSG ;Get DS addr for our vars.
	TEST	b$EventFlags,SLEEPtmr ; SLEEP timer on?
	JZ	NoWakeup	; brif not
	DEC	SleepCnt1	; decrement low word of SLEEP timer
	JNZ	NoWakeup	; brif not timeout/wrap
	DEC	SleepCnt2	; decrement high word of SLEEP timer
	JNS	NoWakeup	; brif not timeout
	AND	b$EventFlags,NOT (InSLEEP OR SLEEPtmr) ; break out of
				; SLEEP wait loop
NoWakeup:
	CMP	TMENBL,1	;is timer enabled?
	JNZ	TRYPEN		;Brif not
	DEC	TMCNT1		;decrement timer count
	JNZ	TRYPEN		;Brif not zero
	DEC	TMCNT2		;decrement the remaining byte
	JNS	TRYPEN		; Brif not negative
RESET:
	MOV	AX,TIMRN1	;reset the timer
	MOV	TMCNT1,AX	;count after counting
	MOV	AX,TIMRN2	; down the timer
	MOV	TMCNT2,AX	; it is word now
	MOV	TMRFLG,1	;set timer event flag
	MOV	AL,TIMOFF	; AL = trap number for B$TrapEvent
	CALL	B$TrapEvent	;set global event flag
TRYPEN:

	CMP	LPEN.LPEN_ENABLE,0 ; PEN ON?
	JE	TICTRG		; No, Try Trigger
	cCall	B$PENINT 	; Yes, Update Pen status.
TICTRG:

	CALL	b$pJoystInt	; process joystick interrupt (if present)
	POP	AX
	POP	DS
	POP	SI
	POP	DI
	POP	BP
	JMP	CS:b$OldClkTic ;go service the old interrupt 1C

cEnd	nogen			


;***
;SCTOIC -- translate number of seconds to number of interrupts
;
;Purpose:
; Converts the number of seconds to a factor as required by the operating
; system. Under DOS 2/3, we multiply [CL:DX] by 18.2 and return this number
; of clock ticks in [CX:DX]. Under DOS 5 we multiply [CL:DX] by 1000, and
; return this number of millesecodns in [CX:DX].
;
;  DOS3 NOTE: .2(n)=n/5, IDIV is used here.  Since max(n)=86400, the
;	      result will be a two-byte integer, and won't cause overflow.
;Entry:
;	[CL:DX] = number of seconds
;
;Exit:
;	[CX:DX] = number of interrupts needed
;
;Uses:
;	AX.
;****
cProc	SCTOIC,<NEAR>,<SI,DI>	
cBegin
	XOR	CH,CH
	MOV	AX,DX
	MOV	DX,CX		; store n in [DX:AX] (for IDIV)
	MOV	DI,AX
	MOV	SI,DX		; save n in [SI:DI]
	MOV	CX,5		; .2 is 1/5
	IDIV	CX		; get 0.2n in AX=[DX:AX]/[CX],
				; and remainder is in DX
	CMP	DX,2		; do we need to round ?
	JNA	NOADD1		; Brif don't
	INC	AX		; increment one
NOADD1:
	MOV	DX,DI
	MOV	CX,SI		; one more n in [CX:DX]
	CLC			; NC
	RCL	DX,1
	RCL	CX,1		; [CX:DX]=2*n
	PUSH	CX		; save CX
	MOV	CX,4		; loop count
MLOOP:				; multiple loop
	CLC			; no carry
	RCL	DI,1		; rotate left through carry
	RCL	SI,1
	LOOP	MLOOP		; when done, [SI:DI]=16*n
	POP	CX		; get back CX, so [CX|DX]=2*n
	ADD	DX,DI
	ADC	CX,SI		; [CX:DX]=18*n
	ADD	DX,AX
	ADC	CX,0		; [CX:DX]=18.2 * n (nearly)

cEnd				


;***
;B$SleepInit - set up timeout for SLEEP statement
;OEM-interface routine
;
;Purpose:
;
;Entry:
;	[DX|AX] = number of seconds to wait
;Exit:
;	[SleepCnt2|SleepCnt1] = number of clock ticks to wait
;Uses:
;	Per convention
;Preserves:
;
;Exceptions:
;	None.
;****

cProc	B$SleepInit,<NEAR,PUBLIC>
cBegin
	xchg	AX,DX			; [CL|DX] = # of seconds
	xchg	AX,CX
	call	SCTOIC			; [CX|DX] = # of clock ticks
	mov	SleepCnt1,DX		; update counter variables
	mov	SleepCnt2,CX
cEnd


	SUBTTL	PLAY
	PAGE
;***
;B$RDPLAY - play trapping and the PLAY function
;OEM-interface routine
;
;Purpose:
;	This routine supports play trapping and the play function.
;	A play event occurs when the background music queue shrinks
;	from n to n-1 notes (where n is specified in the ON PLAY(n)
;	statement). The event does not occur until PLAY trapping is
;	enabled and the background music queue has length greater
;	than n-1.
;
;	When PLAY trapping is enabled and the music queue shrinks
;	from n to n-1, the event flag and the play event flag are
;	both set.
;
;	See the documentation for B$POLLEV for a description of the
;	event and trapping mechanisms.
;
;Entry:
;	[AL] = Function code
;		0:Return [BX] = -1 if event occured since last
;				   call to B$RDPLAY with [AL] = 0
;				 0 if event did not occur since
;				   last call to B$RDPLAY with [AL] = 0
;		1:Return [BX] = number of notes in the queue
;			 [AH] = Voice Id (multivoice only)
;		2:Set event threshold to [BX], the number of notes
;			specified in the ON PLAY(n) statement
;		254: Enable PLAY trapping
;		255: Disable PLAY trapping
;
;Exit:
;	[BX] = value if specified by function [AL]
;	PSW.C set will cause a function call error
;	      to be declared
;
;Uses:
;	Per convention
;
;Preserves:
;	AX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$RDPLAY,<NEAR,PUBLIC>,<SI,AX>	
cBegin				

	CMP	AL,0
	JE	CHKPLY		;check for play event
	CMP	AL,1
	JE	RTNOTE		;return # of notes in queue
	CMP	AL,2
	JE	STNOTE		;save # of notes in ON PLAY(n)
	CMP	AL,254
	JE	STPLAY		;enable play trapping
	CMP	AL,255
	JE	SPPLAY		;disable play trapping
STNOTE_ERROR:			
	STC			;set carry to indicate function
PlayExit:			
cEnd				; restore registers & return

CHKPLY:
	XOR	BX,BX		; assume no event occured (BX = 0)
	CMP	b$PLENBL,0	;is play trapping enabled?
	JE	RDPRET		; Brif not enabled
	CMP	b$PLAFLG,1	;did play event occur?
	JNE	RDPRET		; Brif not
	DEC	BX		; return -1 in BX to report it
	MOV	b$PLAFLG,0	;clear the play event flag
	JMP	SHORT RDPRET

RTNOTE:
	MOV	BX,OFFSET DGROUP:b$SNDQCB	; get the addr of sound-block
	MOV	BX,[BX].QUNOTE	; Get the remaining notes in queue
	JMP	SHORT RDPRET
STNOTE:
	OR	BX,BX		;test if zero
	JZ	STNOTE_ERROR	;if so, then error
	CMP	BX,32D		;test if greater than 32
	JA	STNOTE_ERROR	;if so, then error
	MOV	b$PLYCNT,BX	;store # of notes specified in
	JMP	SHORT RDPRET	;ON PLAY(n) statement in PLYCNT
STPLAY:
	MOV	b$PLENBL,1	;enable trapping
	JMP	SHORT RDPRET
SPPLAY:
	MOV	b$PLENBL,0	;disable trapping
RDPRET:
	CLC			;clear carry to indicate no error
	JMP	SHORT PlayExit	; and return

;***
;B$PENINT -- PEN Update
;
;		Called by Timer Interupt AFTER updating the
;		time-of-day only if PEN or STRIG are ON.
;
;		CLOCKTIC polls the PEN Status (if ON) and stores
;		new values.  Then Joystick TRIGGERS (if ON) and
;		stores their values if fired since last time
;		read with the STRIG(0), STRIG(2), STRIG(4) or
;		STRIG(6) Statement.
;
;	NOTE:	Rom clock interrupt routine saved [AX],[DX],[DS]
;****

cProc	B$PENINT,<NEAR>,<BX,CX,DX,SI>	
cBegin					

	SCNIOS	vReadLightPen		; Read Lpen
	MOV	SI,OFFSET DGROUP:LPEN	; Point to LPEN structure
					; AH 01/00 if pen down/up
	SAHF				; CF = 1/0 if pen down/up
	SBB	AX,AX			; AX = -1/0 if pen down/up
	XCHG	AH,[SI].LAND_FLAG	; Get old LAND_FLAG in AH and
					; set it to new value
	JZ	PENINT_EXIT		; If pen not down nothing else to do

;	Now, set the lpen-coords to new values as return by BIOS

	ADD	DX,0101H		; Make row/col 1-relative
	MOV	[SI].X_TOUCH,BX		; Update the TOUCH variables
	MOV	[SI].COL_TOUCH,DL	; Hi-Byte will always ramin zero
	MOV	[SI].ROW_TOUCH,DH	;  --ditto--
	MOV	[SI].Y_TOUCH,CH		;  --ditto--
	CMP	AH,AL			; Any change in the pen down status?
	JE	PENINT_EXIT		; Brif not
					; Else, update the new LAND variables
	MOV	[SI].LPEN_STATUS,AL	; Set the current status as active
	MOV	[SI].Y_LAND,CH		; Hi-Byte will remain zero always
	MOV	[SI].COL_LAND,DL	;  --ditto--
	MOV	[SI].ROW_LAND,DH	;  --ditto--
	MOV	[SI].X_LAND,BX		
	MOV	AL,PENOFF		; AL = trap number for B$TrapEvent
	cCALL	B$TrapEvent

PENINT_EXIT:			; Time to exit

cEnd				; End of B$PENINT



	SUBTTL	SIGNAL processing code
	PAGE



sEnd	EV_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llagrp.asm ===
TITLE	LLAGRP - GW-BASIC Support for advanced graphics
;***
; LLAGRP - GW-BASIC Support for advanced graphics
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains support for graphics functions required only
;	by programs using graphics drawing statements.	Routines called
;	directly or indirectly by statements not specifically graphic in
;	nature (such as CLS) belong in LLCGRP for runtime granularity.
;
;	Routines in this module are mode-independent in one or more of the
;	following ways:
;	    1) no device-dependent interaction,
;	    2) table driven through mode-dependent data hooks, or
;	    3) calls mode-dependent routines through function hooks.
;
;	Mode-dependent graphics functions and initializers for hooks
;	are segregated in separate modules for better granularity.
;
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_BSS
	USESEG	GR_TEXT

	INCLUDE seg.inc
	INCLUDE ibmunv.inc

sBegin	_BSS
;
;#****************************************************************************
; External variables
;#****************************************************************************
;
externW b$PenC
externB b$MaskC
externB b$AttrC
externD b$AddrC
externW b$OffC
externW b$SegC
externB b$BytesPerRow
externB b$BitsPerPixel
externB b$Planes
externB b$PaintBorder
externB b$Tiling
externW b$Incr1
externW b$Incr2
externW b$IncrY
;
;#****************************************************************************
; External function vectors
;#****************************************************************************
;
externW b$SetAttr
externW b$MapXYC
externW b$PutAction
externW b$NReadL
externW b$NWriteL
externW b$SetPixFirstC
externW b$SetPixLastC
;
;#****************************************************************************
; Local variables
;#****************************************************************************
;
staticW BitCount,,1		;count of pixel bits per line for Get/Put
staticW Shift,,1		;lo byte = left shift count to align video
				;	   byte with array byte for Get/Put
staticW Masks,,1		;lo byte = mask to apply to last partial
				;	   byte for Put
				;hi byte = mask to apply to first partial
				;	   byte for Put
labelD	ArrayAddr,,1		;address of Get/Put array
staticW ArrayOff,,1		;  offset of Get/Put array
staticW ArraySeg,,1		;  segment of Get/Put array

sEnd	_BSS

assumes CS,GR_TEXT

sBegin	GR_TEXT

;***
;B$PixSize - Get number of bits per pixel
;OEM-interface routine
;
;Purpose:
;	Get the number of bits per pixel for the current graphics mode.
;	This routine will never be called if the screen is not in a
;	graphics mode.
;
;	This routine is only called when determining whether a graphics
;	PUT will fit on the screen.  Note that on multiple plane
;	systems, this routine should return the number of bits per pixel
;	on a single plane, not the total number of bits on all the planes.
;
;Entry:
;	none
;
;Exit:
;	[AL] = bits / pixel
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	none
;****
cProc	B$PixSize,<PUBLIC,NEAR>
cBegin
	mov	al,b$BitsPerPixel
cEnd

;***
;B$PutGetInit - Initialize variables for B$NReadC and B$NWriteC
;OEM-interface routine
;
;Purpose:
;	Called once for every PUT or GET statement to initialize
;	variables used by B$NReadC and B$NWriteC.
;
;	Following B$PutGetInit, PUT and GT enter a loop which
;	calls B$NReadC or B$NWriteC once for each line of the
;	rectangle being processed.  If B$PutGetInit is being
;	called by PUT, then it must retain which function ([AL])
;	is being requested.  Usually this entails setting up a
;	PUT function dispatch vector.  B$PutGetInit is also
;	responsible for saving the array address and the line
;	length for B$NReadC or B$NWriteC.  Depending on how
;	these routines are implemented, it may be desirable to
;	calculate certain other values in B$PutGetInit for speed
;	considerations.
;
;	Upon entry into B$PutGetInit, the graphics cursor has
;	been set to the upper left hand corner of the rectangle
;	that is to be used.
;
;Entry:
;	[AL] = PUT action [0..4] represent (OR,AND,PRESET,PSET,XOR)
;	[ES:BX] = address of source/destination array
;	[CX] = bits/pixel * pixels/horizontal line
;	PSW.C = set indicates caller is PUT
;	PSW.C = reset indicates caller is GET
;
;Exit:
;	none
;
;Uses:
;	Per Convention
;
;Exceptions:
;	none
;****
cProc	B$PutGetInit,<PUBLIC,NEAR>
cBegin
	pushf
	mov	ArrayOff,bx	;set up array address
	mov	ArraySeg,es
	mov	BitCount,cx	;save bit count
	mov	bl,b$MaskC	;align mask to array byte to get shift count
	xor	dx,dx		;zero shift count
	xor	bh,bh		;mask for PUT
	mov	ch,cl		;get bit count
				;  (only concerned about mod 8 for bit index)
	mov	cl,b$BitsPerPixel  ;shift count
PGILoop:
	shl	bl,cl		;test mask byte alignment
	jc	PGI2		;go if it was
	or	bh,bl		;or pixel to first partial byte PUT mask
	add	ch,cl		;byte-align count for last partial byte PUT mask
	add	dl,cl		;bump shift count of bits
	jmp	short PGILoop
PGI2:
	mov	bl,0FFH 	;set up mask for last partial byte
	popf			
	jc	PGIPut		;go for PUT init
	mov	cx,BitCount	;use bit cnt to determine final mask for GET
	and	cx,7		;bit count in last byte
	jz	PGI4		;go if full byte
	shr	bl,cl		;shift 0's in for mask
	not	bl		;invert for 1's
PGI4:				
	mov	dh,bl		;last byte mask
	mov	Shift,dx	;save align shift count and last byte mask
	jmp	short PGExit	;exit if not PUT init
PGIPut: 			
	not	bh		;mask for 1st partial byte
	mov	cl,ch
	and	cx,7		;bit count in last byte
	jz	PGI3		;go if full byte
	shr	bl,cl		;shift 0's in for mask
	not	bl		;invert for 1's
PGI3:
	mov	Shift,dx	;save alignment shift count
	mov	Masks,bx	;save masks
	call	[b$PutAction]	;set up PUT action
PGExit:
cEnd

;***
;B$NReadC - Read multiple pixels from screen
;OEM-interface routine
;
;Purpose:
;	Transfer bits from the screen to the array specified by
;	the last B$PutGetInit.  This routine is responsible for
;	maintaining a pointer to the appropriate location in the
;	destination array.  The starting point on the screen for
;	the transfer is the graphics cursor.
;
;Entry:
;	B$PutGetInit must have been called.
;
;Exit:
;	Array updated.
;
;Uses:
;	per convention
;
;Exceptions:
;	none
;****
cProc	B$NReadC,<PUBLIC,NEAR>,<DI,SI,BP>
cBegin
	cld
	mov	bl,b$Planes	;number of planes to read for each row
	les	di,ArrayAddr	;array offset and segment
	push	ds
	lds	si,b$AddrC	;screen address

	ASSUME	DS:NOTHING

	xor	bh,bh		;starting plane
NRdLoop:
.erre	ID_SSEQDS		;assumes ss = ds
	mov	cx,ss:Shift	;cl=array align shift, ch=last byte mask
	mov	bp,ss:BitCount	;total bits to read
	push	bx		;save: plane info
	push	si		;   screen address
.erre	ID_SSEQDS		;assumes ss = ds
	call	ss:[b$NReadL]	;read a line from plane [bh]
	pop	si		
	pop	bx
	inc	bh		;next plane
	dec	bl		;one more plane done
	jnz	NRdLoop 	;go for next plane
	pop	ds

	ASSUME	DS:DGROUP

	mov	ArraySeg,es	;save updated array segment
	mov	ArrayOff,di	;  and offset
cEnd

;***
;B$NWriteC - Write multiple pixels to the screen
;OEM-interface routine
;
;Purpose:
;	Retrieve information from the array indicated by the last call
;	to B$PutGetInit, perform the requested function on it, and store
;	the resulting data on the screen.  This routine is responsible
;	for maintaining a pointer to the appropriate location in the
;	source array, so that multiple calls to B$NWriteC will step
;	though the entire array.  The pixels will be written starting
;	at the graphics cursor.
;
;Entry:
;	B$PutGetInit must have been called
;
;Exit:
;	Screen updated.
;
;Uses:
;	per convention
;
;Exceptions:
;	none
;****

cProc	B$NWriteC,<PUBLIC,NEAR>,<DI,SI,BP>
cBegin
	cld
	mov	bl,b$Planes	;number of planes to write for each row
	les	di,b$AddrC	;screen address
	push	ds
	lds	si,ArrayAddr	;array offset and segment

	ASSUME	DS:NOTHING

	xor	bh,bh		;starting plane
NWrLoop:
.erre	ID_SSEQDS		;assumes ss = ds
	mov	cx,ss:Shift	;cx=array align shift
	mov	bp,ss:BitCount	;total bits to read
	mov	dx,ss:Masks	;dl=last byte mask, dh=first byte mask
	push	bx		;save: plane info
	push	di		;      screen address
.erre	ID_SSEQDS		;assumes ss = ds
	call	ss:[b$NWriteL] ;write a line to plane [bh]
	pop	di
	pop	bx
	inc	bh		;next plane
	dec	bl		;one more plane done
	jnz	NWrLoop 	;go for next plane
.erre	ID_SSEQDS		;assumes ss = ds
	mov	ss:ArraySeg,ds	;save updated array segment
	pop	ds

	ASSUME	DS:DGROUP

	mov	ArrayOff,si	;  and offset
cEnd

;***
;B$PaintInit - Initialize for [b$ScanL] and [b$ScanR]
;OEM-interface routine
;
;Purpose:
;	This routine is called once for each user paint request.
;	It must determine if the boarder attribute is legal for
;	the current screen mode, and if it is legal it should be
;	stored for later use.  It should also provide any
;	initialization needed for the PAINT support routines
;	[b$ScanL] and [b$ScanR].
;
;	In general, painting is accomplished by starting from
;	the entry point and painting right to the border then
;	returning to the entry point and painting left to the
;	border.  Then go up one line and repeat the paint right
;	paint left procedure.  Next go down two lines and repeat.
;	Since [b$ScanR] and [b$ScanL] are called so many times
;	for this one function, it is important that they be
;	optimized for speed.  Any precomputations that can be done
;	outside of these routines will have a measurable effect on
;	the running time of a PAINT command.
;
;	Note:  The following OEM routines are only called during
;	a PAINT command, thus will always be proceeded by B$PaintInit.
;
;		[b$ChkDown]
;		[b$ChkUp]
;		[b$LeftC]
;		[b$PaintBound]
;		[b$ScanL]
;		[b$ScanR]
;		[b$SetTile]
;
;Entry:
;	[AL] = prospective border attribute
;
;Exit:
;	PSW.C = set implies legal border attribute
;	PSW.C = reset implies illegal border attribute.
;
;Uses:
;	Per convention.
;
;Exceptions:
;	none
;****
cProc	B$PaintInit,<PUBLIC,NEAR>
cBegin
	; If b$Tiling=0 OR b$Tiling=2 then B$TileMod has not been called for
	;	this PAINT (PAINT without tiling). Set b$Tiling=0.
	; If b$Tiling = 1 then B$TileMod has been called and a PAINT with
	;	tiling. Set b$Tiling=0FFh.
	CMP	b$Tiling,1	;has tilmod been called?
	MOV	b$Tiling,0	;default no tiling
	JNE	NO_TILE_PAINT
	DEC	b$Tiling	;if tiling, then b$Tiling=0FFh
NO_TILE_PAINT:
	MOV	CH,b$AttrC	;GET FILL COLOR
	CALL	[b$SetAttr]	;go calc color mask
	MOV	AL,b$AttrC	;GET ENCODED BORDER ATTRIBUTE
	MOV	b$PaintBorder,AL ;SAVE BORDER ATTRIBUTE
	MOV	b$AttrC,CH	;RESTORE OLD ATTRIB
cEnd

;***
;B$ImageSize - Calculate space needed for a GET command
;OEM-interface routine
;
;Purpose:
;	This routine returns the number of bytes needed to
;	store a rectangle of pixels in an array when a GET is
;	performed.
;
;	Formula used:
;	    Space required := ((xdim*bits/pixel+7)/8)*planes*ydim
;
;	    where:
;
;		xdim = width, in pixels, of the rectangle
;		ydim = height, in pixels, of the rectangle
;		planes = number of planes for current graphics mode
;		bits/pixel = number of bits required to represent
;			     a single pixel
;
;	    The division in the formula is an integer division, with
;	    the remainder ignored.
;
;
;Entry:
;	[BX] = Y-pixel dimension of rectangle
;	[DX] = X-pixel dimension of rectangle
;
;Exit:
;	[CX:BX] = # of bytes necessary to store the rectangle
;	[DX] = number of BITS needed for one row of the rectangle
;	       for a single plane.  (xdim * bits/pixel)
;	PSW.C set if overflow occurred and [BX], [DX] undefined.
;
;Uses:
;	per convention
;
;Exceptions:
;	none
;****
cProc	B$ImageSize,<PUBLIC,NEAR>
cBegin
	mov	al,b$BitsPerPixel
	cbw
	mul	dx		;xdim*bits/pixel
	mov	cx,ax		;save X bit dimension
	add	ax,7		;() + 7
	shr	ax,1		;() / 8
	shr	ax,1
	shr	ax,1
	mov	dl,b$Planes	;() * planes
	xor	dh,dh
	mul	dx
	mul	bx		;() * ydim
	xchg	bx,ax		;result to CX:BX
	xchg	cx,dx		;  w/ X BIT dimension to DX
	clc
cEnd

;***
;B$TileMod - Get modulus of tile string
;OEM-interface routine
;
;Purpose:
;	This routine reports the modulus of the tile string
;	interpretation for this screen mode.  Since the tile
;	string in PAINT is a bit map representation of the tile
;	pattern, its interpretation depends on the number of
;	planes of graphics memory.  In single plane systems
;	(including interlaced, single bit per pixel, or multiple
;	bits per pixel), the tile string is interpreted as an
;	eight bit wide tile, with a vertical dimension equal
;	to the length of the string.  On a multi-plane system,
;	the tile string is interpreted as an eight bit wide
;	tile, with a vertical dimension equal to the length
;	of the string MOD number of planes.  The first byte
;	in the string represents the bits to be set in the first
;	plane, the second byte represents the second plane,
;	and so on.
;
;	For example, given a six byte tile string:
;
;	    A single plane system interprets the string as a
;	    6 pixel high tile.
;
;	    A 3 plane system interprets the string as a 2 pixel
;	    high tile.
;
;	In order to maintain the alignment of the tile string
;	along the Y axis and to pass the right number of tile
;	bytes to the OEM dependent routine [B$SetTile], the runtime
;	needs to know how many bytes are needed to represent a 1
;	pixel high portion of the tile.  This is usually the number
;	of graphics planes available.
;
;	The way that tiling will proceed is thus:
;
;	    For each line in the region to be tiled, pass to the OEM
;	    routines one byte for each plane.  This byte will be
;	    replicated across the entire line by [b$ScanR] and
;	    [b$ScanL].  The bytes should be aligned such that
;	    two lines with the same tiling pattern will be aligned
;	    visually.
;
;Entry:
;	None
;
;Exit:
;	[AL] = modulus of tile string representation
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None
;****
cProc	B$TileMod,<PUBLIC,NEAR>
cBegin
	MOV	AL,b$Planes	;returns the # of bytes needed to represent
				;a 1 pixel high portion of the tile
	MOV	b$Tiling,1	;set tiling flag
cEnd

;***
;B$StoreC - Store values for graphics cursor
;OEM-interface routine
;
;Purpose:
;	Set the graphics cursor to a previous value.
;
;	The cursor specification passed to this routine will always be
;	a copy obtained from B$FetchC or [b$ScanR].  The OEM independent
;	code never modifies or interprets the values comprising cursor.
;
;	If the graphics cursor does not need three words, this routine
;	can just ignore the values that are not needed.  The routines
;	that return a cursor do not have to set the unneeded values.
;
;Entry:
;	AX = first byte of cursor
;	BX = second byte of cursor
;	CX = third byte of cursor
;
;Exit:
;	None.
;
;Uses:
;	Per convention
;
;Preserves:
;	DX
;
;Exceptions:
;	none
;****
;
; In our implementation, we only use 3 bytes for the cursor.  The
; values that are required are:
;
;	AL = mask portion of cursor
;	BX = offset portion of cursor
;
;#***

cProc	B$StoreC,<PUBLIC,NEAR>
cBegin
	MOV	b$OffC,BX
	MOV	b$MaskC,AL
cEnd

;***
;B$FetchC - Get values for the graphics cursor
;OEM-interface routine
;
;Purpose:
;	On return, AX, BX, and CX are loaded with the location of the
;	graphics cursor.  The values returned are not interpreted and
;	are only used to set the cursor at a later point with a call
;	to B$StoreC.
;
;	The OEM has 6 bytes (3 words) in which to implement a graphics
;	cursor. This should accommodate machines with very high resolution
;	screens.  The representation of the cursor is totally up to the
;	OEM, however it is important to put effort into finding a representation
;	that will allow accessing pixels on the screen as fast as
;	possible.
;
;	A couple of possible implementations are:
;
;	   a)	first word:  segment of cursor address in screen memory
;		second word: offset into the segment
;		third word:  mask for position of cursor within byte/word
;
;	   b)	first word:  offset into segment (segment is constant)
;		second word: mask for position of cursor within byte/word
;		third word:  column and row of cursor
;
;	Note that the runtime code will preserve the order of the word
;	for the cursor based on their names and not their registers.
;	Thus for [b$ScanR], SI and DI are used to return parts of the
;	cursor.
;
;Entry:
;	none
;
;Exit:
;	AX = first word of cursor
;	BX = second word of cursor
;	CX = third word of cursor
;
;Uses:
;	Per Convention
;
;Preserves:
;	DX
;
;Exceptions:
;	none
;****
;
; In our implementation, we only use 3 bytes for the cursor.  The
; values that are returned are:
;
;	AL = mask portion of cursor
;	BX = offset portion of cursor
;
; However, the code should still conform to the OEM specifications so
; that we do not have to change things when this is sent to the OEM.
;#****

cProc	B$FetchC,<PUBLIC,NEAR>
cBegin
	MOV	AL,b$MaskC
	MOV	BX,b$OffC
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\lininp.asm ===
TITLE	LININP - LINE INPUT statement
	page	56,132
;***
; LININP - LINE INPUT statement
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - LINE INPUT # Statement:
;
;      LINE INPUT # filenumber, string-var
;      -----------------------	   |
;		 |		   |
;	       B$DSKI		  B$LNIN
;
;
; - LINE INPUT Statement:
;
;      LINE INPUT [;] ["prompt string";] string-var
;      --------------------------------------------
;			  |
;			  |
;			B$LNIN
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE string.inc	

;Code segments
	useSeg	DK_TEXT
	useSeg	NH_TEXT
	useSeg	ST_TEXT
	useSeg	CN_TEXT
	useSeg	RT_TEXT
;Data segments
	useSeg	_DATA
	useSeg	_BSS

	INCLUDE seg.inc
	INCLUDE idmac.inc	

	SUBTTL	location constant definitions
	page

	InpDsk		EQU	1H	;device (disk) I/O

	SUBTTL	data definitions
	page

sBegin	_DATA
	externB b$FInput	;input flag
	externW	b$PTRFIL	
	externW	b$SDBuf1	

sEnd	;_DATA

	SUBTTL	code externals
	page

sBegin	NH_TEXT
	externNP	B$STGETSTRLEN
	externNP	B$STALCTMPSUB	
sEnd	;NH_TEXT

sBegin	ST_TEXT
	externFP	B$ASSN		
	externNP	B$STDALCTMP	; deallocate if temp string
sEnd	;ST_TEXT

sBegin	CN_TEXT
	externNP	B$TYPSTR
	externNP	B$RDLIN
	externNP	B$INPCRLF	
sEnd	;CN_TEXT

sBegin	RT_TEXT
sEnd	;RT_TEXT

sBegin	DK_TEXT
	externNP	B$FillBuf	;get one input item from a disk file
	externNP	B$InpReset	;reset flag & variables
sEnd

	assumes CS,DK_TEXT
sBegin	DK_TEXT

	SUBTTL	LINE INPUT interface -- B$LNIN
	page
;***
;B$LNIN -- LINE INPUT [#] interface
;void B$LNIN (sd *psdPrompt, far *pDest, I2 cbDest, I2 fCRLF)
;
;Purpose:
; This is the interface for LINE INPUT stmt to assign the input value into the
; destination (a stringVar). This interface is shared by either console LINE
; INPUT or device (disk) LINE INPUT. Since the device (disk) LINE INPUT doesn't
; give the prompt, parameters, psdPrompt and fCRLF, are invalid for device
; (disk) input.
;
; The algorithm is as follows:
;
; if not device (disk) I/O
;	print prompt, if there is any
;	read one line into buffer (b$Buf1)
;	force CR if fCRLF says so
; else
;	 read one line into buffer (SI points to, could be temp)
; endif
; assign to the destination
; reset b$FInput to InpDefault (for READ stmt)
; reset b$GetOneVal to B$ReadVal (for READ stmt)
; reset b$PTRFIL to TTY
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Entry:
; sdPrompt	= prompt sd
; pDest 	= far pointer to either the destination sd, (cbDest == 0) or
;		  the actual address of the destination (cbDest <> 0)
;			Note: if EI_EB, then the real SD is on the stack
;			      instead of a far pointer to the SD
; cbDest	= Byte count of the fixed length string to receive the data. 0
;		  if a variable length string.
; fCRLF 	= CRLF flag. Set to indicate a ";" was specified prior to the
;		  prompt string.
;
; Also, if [b$FInput]=InpDsk [b$PTRFIL] is set
;
;Exit:
;	if device (disk) I/O then
;		b$FInput, b$GetOneItem and b$PTRFIL are reset to default
;
;Uses:
; per convention
;
;*******************************************************************************
cProc	B$LNIN,<PUBLIC,FAR>,<SI>
parmSD	sdPrompt	; sd of the prompt
parmD	pDest		; far *sd to the destination (or sd if EI_EB)
parmW	cbDest		; length of destination
parmW	fCRLF		; I2 of input flag
cBegin

	CMP	[b$FInput],InpDsk	;disk I/O ?
	JZ	DiskIO		;Brif yes

	GetpSD	BX,sdPrompt	;BX=*sd to the prompt
	PUSH	BX		; save that
	CALL	B$TYPSTR 	;print prompt if any
	POP	BX		
	cCall	B$STDALCTMP	; deallocate prompt if it was temp

	CALL	B$RDLIN 	;read one line into b$Buf1

	TEST	fCRLF,FINP_CrLf ;need a CR ?
	JNZ	LNIN_5		; brif not
	CALL	B$INPCRLF	; force a CR to all sources where keyboard
				; was written (screen and/or redir. file).
LNIN_5: 			
	MOV	SI,OFFSET DGROUP:b$SDBuf1 ; [SI] = pointer to source
	JMP	SHORT Assign	;go assign
DiskIO:
	XOR	DX,DX		;tell B$FillBuf this is for LINE INPUT
	cCall	B$FillBuf	;get one line into buffer pointed by SI
	cCall	B$InpReset	;reset flag and variables

Assign:
	MOV	BX,[SI+2]	; [BX] = pointer to string data
	CALL	B$STGETSTRLEN	; [AX] = string length
	MOV	BX,SI		
	CMP	AX,[SI] 	; already correct length?
	JZ	Assign_5	; then go assign
	XOR	CX,CX		; [CX] = start offset of string
	XCHG	AX,DX		; [DX] = correct length
	cCall	B$STALCTMPSUB	; [BX] = sd of shorter substring
Assign_5:			
	XOR	AX,AX		
	cCall	B$ASSN,<DS,BX,AX,Seg_pDest,Off_pDest,cbDest> ; Assign
	MOV	[b$PTRFIL],0	; Reset it to default

cEnd				;pop si, exit to caller

sEnd	;DK_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llcevt.asm ===
TITLE	LLCEVT - Core GW-BASIC Event Interface
	PAGE	56,132
;***
; LLCEVT - Core GW-BASIC Event Interface
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;	This module has the CORE EVENT support routines:
;
;	1. B$RDKYBD
;	2. B$KBDTRP....This is the keyboard interrupt handler. All keys
;			are filtered through this interrupt routine.
;			In case the key hit is not a trappable key
;			it is allowed to pass through the ROM keyboard
;			interrupt handler.
;
;	The following is the relationship of several tables used in this
;	module.  TRTBL2, USRTBL2 & TRTBL4 are the table of flags, and
;	TRTBL1 & USRTBL1 are the tables of definitions of keys (either
;	the scan code or user's definitions).  In order to support the
;	IBM advanced 101-key keyboard (ronco keyboard), there are four
;	entries paded after USRTBL2.  This is for the convenience of
;	table search for key number.
;
;	The definition of the flag, please refer the comments for
;	PPBEBL below.
;
;	TRTBL2 -->|--|	TRTBL1 -->|--| <-- Scan code of F1-F10
;		  |--|		  |--|		(10 keys)
;	(flags) ->|--|		  |--|
;		  \  \  	  \  \
;		  \  \  	  \  \
;		  |--|		  |--|
;		  |--|		  |--| <-- Scan code of cursor move key
;		  \  \  	  \  \  	(4 keys)
;		  \  \  	  \  \
;	USRTBL2 ->|--|	USRTBL1 ->|--|--| <-- user key definition
;		  |--|		  |--|--|	(11 keys)
;		  \  \  	  \  \  \
;		  \  \  	  \  \  \
;		  |--|		  |__|__|
;	(dummy) ->|--|
;	(0,4 keys)\  \  		(no corresponding table)
;		  \  \
;	TRTBL4 -->|--|			(no corresponding table)
;		  |--|
;		  |__|
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	

	useSeg	_BSS		
	useSeg	CONST		
	useSeg	_DATA		
	useSeg	EV_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE ibmunv.inc
	INCLUDE idmac.inc	
	INCLUDE intmac.inc
	INCLUDE oscalls.inc	
	INCLUDE baslibma.inc	
	INCLUDE event.inc	
	INCLUDE const.inc	

	SUBTTL	local constant definitions	
	page

;Number of keys 		
	OrgFky		= 10	; normally, there is 10 function keys
	CsrMovKy	= 4	; four cursor movement keys
	ExtFky		= 2	; extended function keys (F11/F12)

;Scan codes			
	ScanPrtsc	= 37H	; scan code for Prtsc
	ScanPause	= 45H	; scan code for Pause
	ScanBreak	= 46H	; scan code for Break
	ScanF11 	= 57H	; scan code for F11
	ScanF12 	= 58H	; scan code for F12
	ScanExt1	= 0E0H	; scan code for extended keys
	ScanExt2	= 0E1H	; scan code for extended keys

	CTRLDown	= 04H	; bit for CTRL been pressed
	ALTDown 	= 08H	; bit for ALT been pressed


	SUBTTL	data definitions
	page

sBegin	_DATA			

externB b$IOFLAG		
externW b$IPOLKEY		
externB b$CtrlFlags		
staticB PPBEBL,07H		;This byte is used in the following way:
				;Bit 0 used for CTRL BRK enable/disable
				;Bit 1 used for CTRL PAUSE enb/disb
				;Bit 2 used for CTRL PRTSC enb/disb
				;ENABLE=1 and DISABLE=0

staticB TRTBL2,4,OrgFky+CsrMovKy; validate the first 14 keys (*)
staticB USRTBL2,0,NUM_UKEYS	; invalidate NUM_UKEYS user defined keys (*)

; Constants used in TRTBL2 and USRTBL2
TRP_OCCURED	EQU	1	; Bit 0 indicates occurence of a trap
TRP_ENABLED	EQU	2	; Bit 1 indicates trapping enb/disb
TRP_VALID	EQU	4	; Bit 2 indicates def valid/invalid

staticB ,0,NUM_GAP		; there is a gap between the last user
				;  defined key and F11
staticB TRTBL4,4,ExtFky 	; flags for F11/F12, NOTE: TRTBL2, USRTBL2
				;  and TRTBL4 has to be contiguous and in
				;  this order
sEnd	;_DATA			

sBegin	CONST			

staticB TRTBL1,<59,60,61,62,63>
staticB ,<64,65,66,67,68>	; 10 function keys
staticB ,<72,75,77,80>		; 4 cursor control keys
				; currently, there is no need to use a
				;  table for F11/F12, since there are only
				;  two of them.  Within the code, it checks
				;  the scan code of F11/F12 directly.  But
				;  the trap flag table, TRTBL4, is needed.
staticB SHFTBL,<52H,3AH,45H,46H>; used to check for shift keys in SHKEYS
staticB ,<38H,1DH,2AH,36H>	; The last 3 entries must remain last!


sEnd	;CONST			

sBegin	_BSS			

staticB WasE0E1,0		; the value will be either 00H or 80H, to
				;  indicate the extended keys

	externB b$NetCard	; defined in LLINI.ASM
				; b$NetCard=1 --> network installed and
				; running on 3.xx
				; b$NetCard=0 --> network not installed

staticW USRTBL1,,NUM_UKEYS	; NUM_UKEYS user defined keys
staticW KEYHIT,,1		
staticB LPTFLG,,1		; line printer echo key flag
staticB POSFLG,,1		; pause key flag
staticB BRKFLG,,1		; break key flag
staticB KEYFLG,,1		; trapped key flag
staticB KEYTRP,,1		; key trapping enable/disable flag
staticB WASPOS,,1		; helps in handling the CTRL PAUSE key.
				; A value of 0 indicates that the CTRL
				; PAUSE is not active, whereas a value
				; of 0FFH indicates that the CTRL PAUSE
				; is active. (used in B$KBDTRP & B$RDKYBD)

externB	b$EventFlags		; misc event flags

sEnd	;_BSS			


	SUBTTL	code externals	
	page

externFP B$IBreak		;interp call back to notify of CTRL-BREAK


sBegin	EV_TEXT 		
assumes CS,EV_TEXT		

	externNP B$TrapEvent	
	externNP B$TestTrap	
	externNP B$ReqTrap	
	externNP B$Wakeup	
	externNP B$GETDS	

	SUBTTL	B$RDKYBD - Keyboard control routine
	PAGE
;***
;B$RDKYBD - Support for Keyboard Events
;OEM-interface routine
;
;Purpose:
;	This routine allows the caller to do one of the following:
;	(1) Check whether the key trap happened.
;	(2) Define the user definable trap keys. The key definition syntax
;		specifies a string.This string is passed directly to B$RDKYBD.
;	(3) Start trapping keys.
;	(4) Stop trapping keys.
;	(5) Enable trapping for a specific key#
;	(6) Disable trapping for specific key#
;
;	See the documentation for B$POLLEV for a description of the
;	event and trapping mechanisms.
;
;	The string that is passed in as a parameter in function number
;	1 is directly from the user.  It has to be checked for proper
;	length and contents before it can be used.  In this implementation,
;	the length of this string must be 2.  If the string is incorrect,
;	return with PSW.C set and an ILLEGAL FUNCTION CALL will be
;	generated.
;
;Entry:
;	[AL] = 0: Return in [BX]
;			0 if no keyboard trap occurred
;			key number if a trap key was detected
;			-1 if ctrl-break was encountered
;			-2 if pause was encountered
;			-3 if LPTECHO was encountered
;	       1: define a user definable key for trapping
;			[BX] = address of the key definition string
;			[CX] = length of the key definition string
;			[DX] = key number
;	       252: start trapping keys
;	       253: stop trapping keys
;	       254: enable trapping for key # [DX]
;			Key number range is [-3,(max key index)]
;			Key numbers are one relative, Key 0 not used.
;	       255: disable trapping for key # [DX]
;			Key number range is [-3,(max key index)]
;			Key numbers are one relative, Key 0 not used.
;	[BX] = value as specified by function [AL]
;	[CX] = value as specified by function [AL]
;	[DX] = value as specified by function [AL]
;
;Exit:
;	[BX] = value, if specified by function [AL]
;	[DX] = value, if specified by function [AL]
;	PSW.C set will cause a function call error
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None.
;******************************************************************************
;
;ALGORITHM:
;
;	case [AL] of
;		0: begin
;			if LPTFLG then
;			    begin
;			       set [BX] to -3
;			       clear LPTFLG
;			    end
;			if (any trap key flag set ) then
;			      begin
;				set [BX] to trap key #
;				clear corr. trap key flag
;			      end
;			else
;			    if POSFLG then
;				begin
;				  set [BX] to -2
;				  clear POSFLG
;				end
;			    else
;				if BRKFLG then
;				  begin
;				    set [BX] to -1
;				    clear BRKFLG
;				  end
;				else
;				   set [BX] to 0
;		   end
;		1: begin
;		     if (( [CX] < 1 ) or ( [CX] > 2 )) then
;			set carry  to indicate function
;			call error
;		     else
;			redefine key # [DX] using
;			the address in [BX]
;		   end
;		252: enable
;		253: clear enable flag for all trappable keys
;		254: set enable flag for
;		      key # [DX]
;		255: clear enable flag for
;		      key # [DX]
;		otherwise : set carry to indicate error
;			    in function call
;	endcase
;
;DATA STRUCTURE:
;	The trap table has NUM_TKEYS rows, each row made up of
;	2 bytes. The two bytes are required for the definition
;	of a key string. There is another table having 20 rows
;	each row having a byte. This byte is used to store
;	three flags, namely
;	   1. Definition valid or not
;	   2. Key enabled or not
;	   3. Trap occurred or not
;	The mask is defined as follows:
;	   Bit 0 corresponds to the occurence of a key trap.
;	   Bit 1 corresponds to key Enable/Disable.
;	   Bit 2 corresponds to key definition validation.
;
;#****

cProc	B$RDKYBD,<NEAR,PUBLIC>,ES 
cBegin				


	PUSH	DS		
	POP	ES		
	CALL	B$SetKybdInt	; install keyboard handler if not already
				; installed
	OR	AL,AL		;test if key trapping status
	JNZ	RDK1A		;if not, then process normally
	XOR	BX,BX		;preset BX to zero
	XCHG	BL,KEYFLG	;swap zero and key trapping flag
	OR	BX,BX		;test if flag was set
RDK1A:
	PUSH	SI
	push	ax		; save [ax]
	JZ	RDKRET		; if flag was not set, then don't process it
	ADD	AL,4		;[7] check if [AL] is within limits
	JS	RDKERR
	CMP	AL,6		; no LOC/LOF support (one less entry)
	JNB	RDKERR
RDK2:
	CBW			; since all positive, save one byte
	SHL	AX,1
	MOV	SI,AX		;[SI] = word index into table
	PUSH	ES
	PUSH	CX
	PUSH	DI
	PUSH	DS		
	POP	ES		; make ES=DS
	CALL	CS:RDKOFST[SI]
	POP	DI
	POP	CX
	POP	ES
	JMP	SHORT	RDKRET
RDKERR:
	STC
RDKRET:
	pop	ax		; restore [ax]
	POP	SI

cEnd				


RDKOFST DW	TRPEBL
	DW	TRPDIS
	DW	ENABL
	DW	DISABL
	DW	KEYRTN
	DW	KEYDEF

	SUBTTL	B$SetKybdInt - Install keyboard handler
	PAGE
;***
;B$SetKybdInt, B$InstKybdInt - install keyboard interrupt handler
;OEM-Interface Routine
;
;PURPOSE:
;	These routines install the keyboard interrupt service
;	routine. B$SetKybdInt checks to see if the routine has already
;	been installed and returns without doing anything if it has
;	been.  B$InstKybdInt does not check if there is already a keyboard
;	servrice routine.
;
;Preserves:
;	AX
;
;********************************************************************
cProc	B$SetKybdInt,<NEAR,PUBLIC>
cBegin

	TEST	b$EventFlags,KybdInst ; keyboard service routine installed ?
	JZ	B$InstKybdInt 	; brif not -- install it
	RET			; otherwise, just return

labelNP	<B$InstKybdInt>		


	CLI			;clear interrupts
	PUSH	DS
	PUSH	DX
	PUSH	AX
	PUSH	CS
	POP	DS		;[DS] := [CS]
	SETVEC	KYBINT,B$KBDTRP ;install new keyboard service routine
	POP	AX
	POP	DX
	POP	DS
	OR	b$EventFlags,KybdInst		; set init flag
	STI			;restore interrupts


cEnd				

;**
;This routine returns the key that was most
;recently struck. Actually it returns a value
;in [BX] corresponding to the key struck.

KEYRTN:
	CMP	LPTFLG,1	;was it the line printer echo?
	JNE	TRPKYS		;no, check for the trap keys
	MOV	LPTFLG,0	;clear the printer echo flag
	MOV	BX,-3		;return a -3 in BX
	JMP	SHORT KEYRET
TRPKYS:
	MOV	DI,OFFSET DGROUP:TRTBL2 ;[DI] = offset of trap table 2
	MOV	CX,NUM_TKEYS	; [CX] = count of total function keys
				;  including the gap (which is always 0)
				; this number including the 4 padding
				; entries
	MOV	AL,07H		;[AL] = 00000111B
	CLD			;just to be safe
	REPNZ	SCASB		;search for a trapped key
	JNZ	POSBRK		; Brif none found, the original code used
				;  count=(total number of keys)+1 and JCXZ
				;  here, it was OK.	I use JNZ and count=
				;  (total number of keys) instead.  The
				;  effect is waste one byte, but save one
				;  comparison.
	SUB	CX,NUM_TKEYS	; getting the 1-relative key
	NEG	CX		;number in [CX]
	DEC	DI		;adjust [DI] to point to found key
	AND	BYTE PTR[DI],0FEH ;clear the trap flag for this key
	MOV	BX,CX		;return the key number in [BX]
	JMP	SHORT KEYRET
POSBRK:
	CMP	POSFLG,1	;was it the pause key?
	JNE	CHKBRK		;no, check for BRK
	MOV	POSFLG,0	;yes, clear the pause key flag
	MOV	BX,-2		;return -2 in BX
	NOT	WASPOS		;WASPOS indicates whether
				;CTRL PAUSE is active or not
	JMP	SHORT	KEYRET
CHKBRK:
	CMP	BRKFLG,1	;was it the break key
	JNE	NOKEYS		;no, jump to no keys trapped
	MOV	BRKFLG,0	;clear the break flag
	MOV	BX,-1		;return -1 in BX
	JMP	SHORT	KEYRET
NOKEYS:
	XOR	BX,BX		; return 0 to indicate no keys
				;  and XOR clear the carry flag
	RET			; return with NC & BX=0
KEYRET:
	MOV	KEYFLG,1	;set flag to process again
	CLC			;indicate no error
	RET

;**
;This routine is used to define a user defined
;trap key.
; DI is used. (caller, B$RDKYBD preserves AX,CX,SI,DI)
; BX is preserved.

KEYDEF:
	CMP	CX,2		;is CX = 2 as it should be
	STC			; assume error
	JNE	DEFRET		; Brif CX <> 2, return with CY (error)
	PUSH	BX		; save BX
	MOV	CX,[BX] 	;get the key definition in [CX]
	XCHG	CH,CL		;swap before storing
	TEST	CH,3		; left/right shift been pressed ?
	JZ	NO_SHIFT	; Brif not
	OR	CH,3		; make both the same
NO_SHIFT:
	MOV	DI,DX			; # in DI
	SUB	DI,OrgFky+CsrMovKy+1	; map 15,16,... to 0,1,...
	MOV	BX,OFFSET DGROUP:USRTBL2; [BX] = offset of trap table 2
	OR	BYTE PTR [BX+DI],TRP_VALID  ; validate the new definition
	MOV	BX,OFFSET DGROUP:USRTBL1; [BX] = offset of trap table 1
	SHL	DI,1			; get the word offset
	MOV	WORD PTR[BX+DI],CX	; store the new key definition
	POP	BX		; get back BX
	CLC
DEFRET:
	RET

;**
;enables key trapping

TRPEBL:
	MOV	KEYTRP,1
	CLC			; original code exit via TRPDIS, slower
	RET

;**
;disables key trapping

TRPDIS:
	MOV	KEYTRP,0
	CLC
	RET

;**
;enables trapping for key # [DX]

ENABL:
	PUSH	DX		;save [DX]
	OR	DX,DX		; is [DX]>0 ? NOTE: [DX]=0 isn't taken care
	JG	ENABL1		;Brif so
	NEG	DX		;else complement [DX]
	CMP	DL,3		;if [DL]=3 then [DL]:=4
	JB	ENABL0		;Brif not
	INC	DL		;else make [DL]=4
ENABL0:
	OR	PPBEBL,DL	;enable the corresponding key
				; carry is cleared
	JMP	SHORT ENABL2
ENABL1:
	MOV	DI,OFFSET DGROUP:TRTBL2-1 ; [DI] = (offset of trap table2)-1
	ADD	DI,DX		;get byte offset in table
	OR	BYTE PTR[DI],02H ;enable the key
				; carry is cleared
ENABL2:
	POP	DX		;restore [DX]
	RET			; with NC

;**
;disables trapping for key # [DX]

DISABL:
	PUSH	DX		;save [DX]
	OR	DX,DX		; is [DX]>0 ? NOTE: [DX]=0 isn't taken care
	JG	DISBL1		;Brif so
	DEC	DX		;disable the corresponding key
;Bug fixed April 12,1984
	CMP	DL,0FCH 	;is low nibble of [DL]=1100 ?
	JA	DISBL0		;Brif not
	DEC	DL		;else make it 1011
DISBL0:
	AND	PPBEBL,DL	;leaving the others intact
				; carry is cleared
	JMP	SHORT DISBL2
DISBL1:
	MOV	DI,OFFSET DGROUP:TRTBL2-1 ; [DI] = (offset of trap table2)-1
	ADD	DI,DX		;get byte offset in table
	AND	BYTE PTR[DI],0FDH ;disable the corr. key
				; carry is cleared
DISBL2:
	POP	DX		;restore [DX]
	RET			; with NC

	SUBTTL	B$KBDTRP - Keyboard interrupt / monitor loop
	PAGE
;***
;B$KBDTRP
;
;PURPOSE:
;	The keyboard interrupt handler first branches to
;	this routine to see if any of the following keys
;	were typed in that order:
;	1. The NUM_TKEYS trappable keys including the NUM_UKEYS user
;	   defined trap keys.
;	2. PRTSC key, LPT echo toggle key, Pause key
;	   or the Break key.
;	If any of the above keys were hit, B$KBDTRP sets
;	Event flag and the corresponding key flag and
;	returns.
;	If none of the above keys were hit then the
;	routine branches to the ROM keyboard interrupt
;	handler.
;
;ALGORITHM:
;	if (key typed is the LPTECHO key) then
;	   begin
;		set LPTFLG
;		set EVTFLG and KEYFLG
;	   end
;	If (key typed is a valid trap key for which
;	    trapping is enabled) then
;	   begin
;	      set the corr. TRAP key flag in the TRAPTABLE
;	      set the EVTFLG and KEYFLG
;	   end
;	else
;	     if (key typed is PAUSE key and CTRL PAUSE
;			trapping enabled) then
;		begin
;		  set PAUSE key flag
;		  set EVTFLG and KEYFLG
;		end
;	     else
;		if (key typed is BREAK key and CTRL BREAK
;			trapping enabled) then
;		      begin
;			set BREAK key flag
;			set EVTFLG and KEYFLG
;		      end
;	     else
;		continue with ROM keyboard interrupt
;		handler
;
;DATA STRUCTURE:
;	This routine also uses the TRAP TABLE data
;	structure described above in B$RDKYBD.
;
;ENTRY:
;	None
;
;EXIT:
;	Set the EVTFLG, KEYFLG and the corresponding key
;	flag if any of the enabled trap keys were typed.
;
;MODIFIED:
;	None
;
;***********************************************************************

dbpub	B$KBDTRP			
B$KBDTRP:					

	ENABLE			;enable further interrupts
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DS
	PUSH	DI
	PUSH	ES
	XOR	CX,CX
	MOV	DS,CX		;zero DS
	MOV	BX,KBDFLG	;set BX to special status flag's addr
	MOV	AH,BYTE PTR[BX] ;get the mask in AH
	CALL	B$GETDS
	MOV	DS,BX		;get the addr of basic data seg
	MOV	ES,BX		;make [ES] = [DS]
	IN	AL,KBDATA	;else get keyboard data in acc.
				; when enter here,
				;  [AX]=[shift status|scan code]
	MOV	KEYHIT,AX	; store the key hit
	CMP	AL,ScanExt1	; is extended scan code (E0H) ?
	JZ	SetExtFlg	; Brif yes
	CMP	AL,ScanExt2	; is extended scan code (E1H) ?
	JNZ	SetToggle	; Brif not
SetExtFlg:			
	MOV	WasE0E1,80H	; set extended scan code flag
	JMP	NONE		; let ROM handles it
SetToggle:			
	AND	AH,6FH		;throw away INS & SCROLL (80H & 10H)
				;and continue with the INT handler.
	OR	AH,WasE0E1	; or the flag for extended key
	MOV	WasE0E1,0	; reset extended scan code flag
	TEST	AH,3		; was either right or left shift ?
	JZ	NO_SHFT 	; Brif not
	OR	AH,3		; make them the same
NO_SHFT:

	TEST	b$EventFlags,InSLEEP ; in sleep statement?
	JZ	NoWakeup	; brif not -- nothing to wake up
	OR	AL,AL		; BREAK scan code?
	JS	NoWakeup	; brif so -- don't wake up SLEEP
	CALL	B$Wakeup	; key hit -- force SLEEP statement wakeup
NoWakeup:			

	CALL	CHKLPT		;check for CTRL PRTSC
	CMP	WASPOS,0	;Pause active ?
	JE	NOPAUS		;Brif not
	AND	AL,07FH 	;else strip bit 7
NOPAUS:
	CALL	B$CHKTRP	; check for trap keys
	JC	KBDRET		;Brif found
	CALL	OTHERS		;check for CTRL PAUSE and CTRL BRK
	JC	KBDRET		;Brif found
	JMP	NONE

KBDRET: 			

	MOV	KEYFLG,1	;set flag for key event
	CALL	B$TrapEvent	;set global event flag

	IN	AL,KBDATA+1	;get keyboard control port
	MOV	AH,AL		;save it in AH
	OR	AL,80H		;keyboard reset bit
	PAUSE			;make sure instruction fetch has occurred
	OUT	KBDATA+1,AL	;Ack so keyboard can Int again
	MOV	AL,AH		;get control bits back
	PAUSE			;make sure instruction fetch has occurred
	OUT	KBDATA+1,AL	;restore keyboard mode
	MOV	AL,EOI		;send End of Interrupt
	PAUSE			;make sure instruction fetch has occurred
	OUT	INTA0,AL	;to 8259
	STC			;carry since we processed char
ROMINT:
				;CF indicates whether we processed
				;character or not
	POP	ES
	POP	DI
	POP	DS
	POP	CX
	POP	BX
	POP	AX
	JC	REALRT
	INT	ROMKBD
REALRT:
	IRET

	SUBTTL
	PAGE
;**
;This routine checks for CTRL PRTSC
;and if CTRL PRTSC is down it sets LPTFLG
;and the event flags

CHKLPT:
	TEST	AH,CTRLDown	; CTRL down ?
	JZ	LPTRET		;Brif not
	CMP	AL,ScanPrtsc	; was it the PRTSC key ?
	JNE	LPTRET		;Brif not
	TEST	PPBEBL,04H	;PRTSC key trapping enabled ?
	JZ	LPTRET		;Brif not
	MOV	LPTFLG,1	;else set printer echo flag
	MOV	KEYFLG,1	;set flag for key event
	CALL	B$TrapEvent	;set the global event flag
LPTRET:
	RET


;**
;This routine checks for any of the
;NUM_TKEYS trappable keys and if found sets
;the trap flag for the corresponding key

dbpub	B$CHKTRP		
B$CHKTRP:			
	CMP	KEYTRP,1	;key trapping enabled ?
	JNE	NoTrap		;Brif not
				; check F11/F12, or F1-F10 & cursor movement
				;  keys, and then user defined keys
	XOR	CX,CX		; CX=0, in case it is F11
	CMP	AL,ScanF11	; is F11/F12
	JB	SetTbl1 	; Brif not
	MOV	BX,OFFSET DGROUP:TRTBL4 ; [BX]=offset of trap table 4
	JZ	IsTrapable	; Brif F11, TRAPPED need BX & CX
	DEC	CX		; CX=-1, TRAPPED need negative 0-relatived #
	CMP	AL,ScanF12	; is F12 ?
	JZ	IsTrapable	; Brif yes, TRAPPED need BX & CX
	JMP	SHORT UsrKeys	; search user defined keys
SetTbl1:			
	TEST	AH,80H		; is new set of cursor moving keys ?
	JNZ	UsrKeys 	; Brif yes
	MOV	DI,OFFSET DGROUP:TRTBL1 ; [DI]=offset of trap table 1
	MOV	CX,OrgFky+CsrMovKy	; [CX]=count of keys
	MOV	BX,OFFSET DGROUP:TRTBL2 ; [BX]=offset of trap table 2
	CLD			;just to be safe
	REPNZ	SCASB		;search for a trappable key
	JNZ	UsrKeys 	; Brif none found
	SUB	CX,OrgFky+CsrMovKy-1	; get negative 0-relative key
IsTrapable:			
	CALL	TRAPPED 	; trappable ?
	JC	SHORT TrpExit	; is a trapped key, return with CY
UsrKeys:			
	MOV	DI,OFFSET DGROUP:USRTBL1;[DI]=offset of user trap_table 1
	MOV	CX,NUM_UKEYS	; [CX]=count of keys
	MOV	BX,OFFSET DGROUP:USRTBL2;[BX]=offset of user trap_table 2
	CLD			; just to be safe
Loop2:
	REPNZ	SCASW		;search for a trappable key
	JNZ	NoTrap		; Brif none found
	SUB	CX,NUM_UKEYS-1	; get the negative 0-relative key #
	PUSH	BX		; save BX for next run, BX is needed by
				;  TRAPPED and is ruined in it
	CALL	TRAPPED 	; trappable ? on return CX=positive
				;  0-relative key #, CY indicate the key is
				;  trapable, ZR or NC indicate not trapable
	POP	BX		; get BX back
	JC	TrpExit 	; exit with carry set if found
	SUB	CX,NUM_UKEYS-1	; get back count in [CX]
	JCXZ	NoTrap		; if zero, then done, no trap key found
	NEG	CX
	JMP	SHORT Loop2	; look for other trappable keys
NoTrap:
	CLC			;CLC to indicate none found
TrpExit:			; exit
	RET

TRAPPED:			; this routine returns with
				; CF set if the key is trappable
				; else returns with Z flag set & NC
	NEG	CX		;number
	ADD	BX,CX		;get byte offset into table
	TEST	BYTE PTR[BX],TRP_VALID ; key valid?
	JZ	NOTFOUND	; Brif not -- return with carry clear
	TEST	BYTE PTR[BX],TRP_ENABLED ; key trapping enabled?
	JZ	NOTFOUND	; Brif not -- return with carry clear
	OR	BYTE PTR[BX],TRP_OCCURED ; else set the trap key flag
GotKeyBreak:			
	STC			;STC to indicate that a trappable
NOTFOUND:
	RET			;key was found
;**
;This routine checks for CTRL PAUSE and CTRL BRK
;in that order and if found returns with carry set
;else returns with carry clear.

OTHERS:
	TEST	AH,CTRLDown	; CTRL down ? (carry reset NC)
	JZ	NOTFND		;Brif not
	CMP	AL,ScanPause	; was it CTRL PAUSE ?
	JNE	BRKCHK		;Brif not
	TEST	AH,ALTDown	; was ALT also down ?
	JNZ	OTHRET		;EAT CTRL ALT PAUSE
	TEST	PPBEBL,02H	;PAUSE key trapping enabled ?
	JZ	BRKCHK		;Brif not
	CMP	WASPOS,0	;CTRL PAUSE active ?
	JZ	SETPOS		;Brif not (^S not active, so treat
				;this as ^S)
	JMP	SHORT OTHRET	;else just eat the character
SETPOS:
	MOV	POSFLG,1	;else set the PAUSE key flag
	JMP	SHORT OTHRET	;and return
BRKCHK:
	CMP	AL,ScanBreak	;was it CTRL BRK ?
	JNE	NOTFND		;Brif not
	CMP	b$NetCard,1	; network installed ?
	JNZ	NetNotFound	; brif not,
	TEST	AH,ALTDown	; alt key down ?
	JNZ	NOTFND		; brif so, without eating ctrl-alt-brk
NetNotFound:			
	TEST	AH,ALTDown	; was ALT also down ?
	JNZ	OTHRET		;EAT CTRL ALT BRK
	TEST	PPBEBL,01H	;BREAK key trapping enabled ?
	JZ	NOTFND		;Brif not
	CMP	WASPOS,0	;CTRL PAUSE active ?
	JZ	BRKCH1		;Brif not
	JMP	SHORT SETPOS	;else report this as ^S
BRKCH1:
	MOV	BRKFLG,1	;else set BREAK key flag
	CALL	B$IBreak	;notify interpreter of BREAK

OTHRET:
	STC			;indicates key found
	RET
NOTFND:
	CLC			;indicates key not found
	RET

;**
;Control branches here if no trappable key was
;hit. This routine lets all other keys to go
;through the ROM keyboard interrupt handler
;IF AND ONLY IF CTRL PAUSE is NOT active. If
;CTRL PAUSE is active then it reports that key as
;another CTRL PAUSE if it is NOT any of the SHIFT
;keys.

NONE:

	CMP	WASPOS,0	;CTRL PAUSE active ?
	JZ	NONE2		;Brif not
	CALL	SHKEYS		;else check for shift keys
	JC	NONE1		;Brif it is a shift key
	MOV	POSFLG,1	;else report it as CTRL PAUSE
	JMP	KBDRET		;set EVTFLG and return
NONE1:
	CMP	CX,3		; was it CTRL, LEFT-SHIFT or RIGHT-SHIFT?
	JBE	NONE2		; brif so -- let it go through
	JMP	KBDRET		;EAT ALL OTHER SHIFT KEYS
NONE2:				;comes here if CTRL PAUSE not
				;active and no trapping occured
	CLC			;clear carry
	MOV	AX,KEYHIT	; restore key hit
	JMP	ROMINT		;pass control to ROM INTERRUPT
				;i.e. pass the key to the input stream


;******************************************************
;SHKEYS is used to find out if the key hit
;is one of the following:
;	INS, CAPSLOCK, NUMLOCK, SCROLLLOCK, ALT,
;	CTRL, LEFTSHIFT, RIGHTSHIFT.
;	If the key hit is one of the above it returns
;	with carry set else returns with carry clear.
;	Also if it is the CTRL key it returns the
;	value 3 in [CX]. If PAUSE is active then typing
;	any of these keys will not release pause, and
;	except for CTRL all other shift keys are EATEN
;	by B$KBDTRP.
;******************************************************
SHKEYS:				; AL = scan code
	MOV	DI,OFFSET DGROUP:SHFTBL
	MOV	CX,9		;count of 8 keys
	CLD			;to be safe
	REPNZ	SCASB		;search for a shift key
	CLC			; clear carry
	JCXZ	SHKRET		; Brif none found
	STC
SHKRET:
	RET
	PAGE
;***
;B$HookKbd - Hook keyboard interrupt
;
;Purpose:
;	Added with revision [13].
;	The QB4 user interface needs to have control of the
;	keyboard interrupt when it is active to avoid conflicts
;	with TSR programs like SIDEKICK.  When the user interface
;	is exitting, it will deinstall it's handler and call
;	this routine so that the runtime can reinstall our keyboard
;	handler.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	Per Convention.
;Exceptions:
;	None.
;******************************************************************************
cProc	B$HookKbd,<PUBLIC,FAR>
cBegin
	AND 	b$EventFlags,NOT KybdInst	; force re-installation of
						; keyboard interrupt handler
	XOR	AL,AL				; get current key status,
						; flush keystrokes, and
	CALL	B$RDKYBD			; hook int 9
cEnd
	PAGE
;***
;B$UnHookKbd - UnHook runtime keyboard interrupt
;
;Purpose:
;	The QB4 user interface needs to have control of the
;	keyboard interrupt when it is active to avoid conflicts
;	with TSR programs like SIDEKICK.  When the user interface
;	is entering, it will call this routine and the runtime will
;	unhook itself from the keyboard interrupt chain.  The user
;	interface will then install its keyboard handler.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	Per Convention.
;Exceptions:
;	None.
;******************************************************************************
cProc	B$UnHookKbd,<PUBLIC,FAR>
cBegin
	XFRINT	KYBINT,KBDVEC/4 	;restore original INT 9 (saved in EF)
cEnd

;***
;B$InitKeys1 - Init some event stuff
;OEM-interface routine
;
;Purpose:
;	Init some event stuff.
;
;Entry:
;	AL = value to pass to B$RDKYBD when DX = Ctl_Creak
;
;Exit:
;	None.
;
;Uses:
;	Per Convention.
;
;Exceptions:
;	None.
;
;******************************************************************************
cProc	B$InitKeys1,<PUBLIC,NEAR>
cBegin
	MOV	[B$IPOLKEY],EV_TEXTOFFSET B$POLKEY 
	TEST	b$CtrlFlags,DSwitch ;has B$DBINI done this already?
	jnz	inidon		;brif so
	PUSH	AX		;save this value for later

	MOV	SI,EV_TEXTOFFSET B$RDKYBD ;stick in reg to make

	mov	al,enable_trap		  ;  code smaller & faster
	mov	dx,printer_echo ;enable the printer echo
	call	si

	mov	dx,pause_key	;enable pause key
	call	si

	POP	AX		;retrieve input value
	mov	dx,Ctl_Break	;en/disable ^Break trapping (depending on AL)
	call	si

	mov	al,start_key	;start key trapping
	call	si

inidon:
cEnd				

	SUBTTL	Keyboard Interrupt/Trap Checking in an Operating System Environment
	PAGE

;***
;B$POLKEY -
;OEM-interface Routine
;
;Purpose:
;	Process keys trapped by the OEM/machine dependent keytrapping
;	support.
;	Algorithm:
;
;	Set b$CntlC to 0
;	Call OEM routine B$RDKYBD to detect if a key event has occurred.
;	If trapped key then
;		report to KEYTRP
;	If ^C then
;		Set b$CntlC to 1
;	If ^S then
;		toggle the ^S flag
;	If <printer-echo>
;		toggle the printer echo flag
;	Loop to call B$RDKYBD until no more key events are reported.
;	If ^S flag is set then
;		loop to call B$RDKYBD until another ^S event is detected.
;Entry:
;	none
;
;Exit:
;	none
;
;Uses:
;	none
;
;Exceptions:
;	none
;
;****

cProc	B$POLKEY,<PUBLIC,NEAR>,<AX,BX>
cBegin				; - this routine was completely
				; rewritten - mostly taken from
				; the interpreter
Pollop:
	xor	ax,ax		;Read trapped keys function code
	call	B$RDKYBD	;OEM dependent key trap routine
	dec	bx
	jns	Waskey		;Function, arrow, or user def. key trapped
	inc	bx
	jz	Polkyx		;No key was trapped
	inc	bx
	jz	Wasctc		;^C / <break> function
	inc	bx
	jz	Wascts		;^S / <pause> function
	inc	bx
	jnz	Pollop		;Not <print-screen> func. - ignore, poll next

Wasctp: 			;<printer echo> function
	XOR	b$IOFLAG,LPR_ECHO ; Toggle the printer echo flag
	jmp	short Pollop	;Key found, so there may be more

Waskey:
	; Trap zero relative key if event is ON
	xchg	ax,bx		
	ADD	AL,KEYOFF	; [AL] = 0-relative event id
	CALL	B$TestTrap	
	JZ	Pollop		
	CALL	B$ReqTrap	    ; Trap enabled, Issue Request
	jmp	short Pollop	; Key found, so there may be more

Wascts: 			;^S / <pause> function
	XOR	b$EventFLags,PAUSEF ; Toggle the pause flag
	jmp	short Pollop	;Key found, so there may be more

Wasctc: 			;flag ^Break found
	OR	b$EventFlags,CNTLC ; ^Break is reported last so
	AND	b$EventFlags,NOT PAUSEF ; turn off pause and exit

Polkyx:
	TEST	b$EventFlags,PAUSEF ; Test for pause processing
	jnz	Pollop		;Pause in process, wait for "unpause"
cEnd
sEnd	EV_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llascn.asm ===
TITLE	LLASCN - GW-BASIC Advanced Screen Interface
;***
; LLASCN - GW-BASIC Advanced Screen Interface
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This is one of the sample OEM dependent source code modules
;	required to build the GW-BASIC Interpreter or the GW-BASIC
;	Compiler for the IBM PC family of computers.
;
;	This module contains OEM dependent support for the following:
;
;		SHELL Statement 	(B$SHLSAV and B$SHLRST)
;		PCOPY Statement 	(B$PCOPYS)
;
;******************************************************************************
	INCLUDE switch.inc	; feature switches [new]
	INCLUDE	rmacros.inc	

	UseSeg	_DATA		
	UseSeg	_BSS		
	UseSeg	RT_TEXT		

	INCLUDE	seg.inc		
	INCLUDE ibmunv.inc

sBegin	_DATA			

        externW b$CurrPSize    ;Current page size in paragraphs
        externW b$VideoBase    ;Current video base
sEnd	_DATA			

sBegin	_BSS			
	externB b$MaxPage	
	externB b$BiosMode	

	externW b$KBDVEC_SAVE	;LLINI - save area for keyboard vector
	externW b$CLKVEC_SAVE	;LLINI - save area for clock vector

	staticW OLDCS,,1	;used to save CS when SHELL is executed
	staticW ISAV,,6 	;save area for interrupt vectors

sEnd	_BSS			

sBegin	RT_TEXT			

	ASSUMES	CS,RT_TEXT	

	externD  b$OldClkTic	;LLINI - old vector of INT 1CH

	externNP B$SCINIT	; initialize screen

	externNP B$OutWord	;LLAGRP - write out port of EGA

;***
;B$SHLSAV - Save machine state for a SHELL
;OEM-interface routine
;
;Purpose:
;	This routine will be called whenever a process is
;	shelled. It saves all the machine dependent configuration
;	parameters which may be changed by the shelled process.
;	As of now it saves all the screen mode parameters and the
;	interrupt vectors.
;
;	This is a DOS only routine.
;
;Entry:
;	None
;
;Exit:
;	PSW.C set will cause a function call error to be declared.
;	No attempt will be made to execute the user process.
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None
;********************************************************************

cProc	B$SHLSAV,<PUBLIC,NEAR>,<AX,BX,DX,ES,DS> 
cBegin				;NOTE: exits through
				;SAVXT in B$SHLRST

	SAVINT	ISAV,CLKINT	; save timer interrupt
	SAVINT	ISAV+4,TIMADR	; save timer control interrupt
	SAVINT	ISAV+8,KBDINT	; save keyboard interrupt
	XOR	DX,DX
	MOV	ES,DX		;[ES] := 0
	MOV	OLDCS,CS	;save old CS
	CLI			;disable interrupts
	RSTVEC	TMRCTL,ES:TICSAV ;restore 'get ctl on timer INT'
	POP	DS		;restore DS
	PUSH	DS		;save DS
	XFRINT	KYBINT,KBDVEC/4 ;move INT EFH to INT 09H
	XFRINT	TIMINT,CLKVEC/4 ;move INT F0H to INT 08H
	RSTVEC	KBDVEC/4,b$KBDVEC_SAVE ;restore INT EF vector
	POP	DS		;restore seg register
	PUSH	DS		;save seg register...
	RSTVEC	CLKVEC/4,b$CLKVEC_SAVE ;restore INT F0 vector
	POP	DS		;restore seg register
	PUSH	DS		;save seg register...
	JMP	SAVXT		;common return for
				;B$SHLSAV and B$SHLRST
cEnd	<nogen> 		

PAGE				
;***
;B$SHLRST - Restore machine state after a SHELL
;OEM-interface routine
;
;Purpose:
;	This routine is called after a shelled process terminates.
;	It restores the machine dependent configuration parameters
;	saved by B$SHLSAV. If this restoration can not be done,
;	the carry flag is set on exit and the runtime will abort
;	with the error "Can't continue after SHELL".
;
;	This is a DOS only routine.
;
;Entry:
;	None
;
;Exit:
;	PSW.C set will cause the runtime to abort with a SHELL error
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None
;********************************************************************

cProc	B$SHLRST,<PUBLIC,NEAR>,<AX,BX,DX,ES,DS> 
cBegin
	CLI			;disable interrupts
	SAVINT	CS:b$OldClkTic,TIMADR ; saving int vector 1ch in b$OldClkTic
	MOV	AX,OLDCS	;[AX] = old CS
	CMP	AX,[ISAV+2]	;is ISAV+1 same as old CS   ?
	JNE	SHLRS1		;Brif not
	MOV	[ISAV+2],CS	;else set it to new CS
SHLRS1:
	CMP	AX,[ISAV+6]	;is [ISAV+3] same as old CS ?
	JNE	SHLRS2		;Brif not
	MOV	[ISAV+6],CS	;else set it to new CS
SHLRS2:
	CMP	AX,[ISAV+10]	;is [ISAV+5] same as old CS ?
	JNE	SHLRS3		;Brif not
	MOV	[ISAV+10],CS	;else set it to new CS
SHLRS3:
	PUSH	DS
	POP	ES		;[ES] := [DS]
assumes	ES,DGROUP		
assumes	DS,NOTHING		
	XFRINT	KBDVEC/4,KBDINT/4 ;move INT 09H to INT EFH
	XFRINT	CLKVEC/4,CLKINT/4 ;move INT 04H to INT F0H
	RSTVEC	TIMINT,ES:ISAV	;restore timer interrupt
	RSTVEC	TMRCTL,ES:[ISAV+4] ;restore 'get timer ctl interrupt'
	RSTVEC	KYBINT,ES:[ISAV+8] ;restore keyboard interrupt
	PUSH	ES
	POP	DS		; [ds] := [es] i.e., old [ds]
assumes	DS,DGROUP		
assumes	ES,NOTHING		

SAVXT:				;exit point for B$SHLSAV
	STI
	CLC			;indicate no error
cEnd				

PAGE				
;***
;B$PCOPYS - Support for PCOPY statement
;OEM-interface routine
;
;Purpose:
;	This routine provides the support for the PCOPY statement.
;	It copies the contents of one screen page (either graphics
;	or text) to another.
;
;	If the source or destination page numbers are not in the range of
;	allowable pages for the current mode as determined by the formula:
;
;
;	       max_page_allowed = video_memory/page_size - 1
;
;
;	then the routine returns with carry set so that an Illegal Function
;	Call will be issued.
;
;	If the source and destination pages are the same, this routine
;	can just return without trying to copy anything.
;
;	NOTE: if you are supporting delayed screen initialization,
;	      B$SCNINT must be called before any changes to the
;	      screen pages are made.
;
;	This is a DOS only routine.
;
;Entry:
;	[AX] = source page #
;	[CX] = destination page #
;
;Exit:
;	PSW.C set indicates a function call error.
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None
;********************************************************************



cProc	B$PCOPYS,<PUBLIC,NEAR>,<SI,DI,DS,ES>	
cBegin				

	CALL	B$SCINIT	; initialize screen if not already done
	OR	CH,AH		; Check if High-bytes zero
	STC			; Prepare for error condition
	JNZ	PCOPY_EXIT	; Brif either arg > 255
	MOV	CH,AL		; CH = Source page : CX = page values
        MOV     AL,b$MaxPage   ;permitted max-pages for this mode
	CMP	AL,CH		; Is source-page > maximum allowed?
	JB	PCOPY_EXIT	; Yes, exit with error : CF = 1
	CMP	AL,CL		; Is destination-page > max value?
	JB	PCOPY_EXIT	; Yes - issue error : CF = 1
	CMP	CL,CH		; Src = Dst?
	JE	PCOPY_EXIT	; Br - nothing to do

;	Get the base address of source & destination pages

        MOV     BX,b$VideoBase 

COPY_PAGES:

;	Now, get the page size for this mode

        MOV     DI,b$CurrPSize ;DI = 128-byte page units
	CLD			; Get ready for auto-increment

;	Now, compute the offset of src/dst page from the base
;	The following multiplications always result in DX = 0 because only
;	the paragraph size of each page is used.

	MOV	AL,CL		; AX = Destination page
	MUL	DI		; AX = dst-page * page-size
	ADD	AX,BX		; Add the base address also to get the final
	MOV	ES,AX		; Address in ES (destination base)
	MOV	AL,CH		; Get source page number
	MOV	AH,BL		; AH = BL = 0
	MUL	DI		; AX = src-page * page-size
	ADD	AX,BX		; Add the base address also to get the final
	MOV	BL,b$BiosMode	;get BIOS mode while we still have DS
	MOV	DS,AX		; Address in DS (source base)

;	DI still has the page size (in paras) & convert it to word-size

	MOV	CL,3		; Multiply by 8
	SHL	DI,CL		; DI = page size in words
	MOV	CX,DX		; CX = DX = 0
	XCHG	DI,CX		; CX = page size
				; DI = 0 (destination offset from page)

;	If current mode is a CGA mode then all is set for page copying

	CMP	BL,0DH		;Is it a CGA mode?
	MOV	SI,DI		; SI = 0 (Source offset from page)
	JB	CGA_COPY	; Brif to normal word copy

EGA_COPY:

;	We can use the EGA write mode 1 to do 4-plane memory copying via
;	the MOVSB instruction. This mode is documented to work so that the
;	planes are written from the latches, which are loaded by a previous
;	read. What in fact happens is that the MOVSB instruction handles the
;	reads in such a way that the latches are correctly loaded for the
;	4-planes from DS:SI and the write to ES:DI reproduces the contents of
;	the source area at the destination.

	MOV	DX,GRPADD	; EGA port address
	MOV	AX,1 SHL 8 + RWMReg ; Use write-mode 1
	OutWord 		;[17]Set up EGA
	SHL	CX,1		; Make it a byte count
REP	MOVSB			; ... and go
	MOV	AX,RWMReg	; Reset EGA to mode 0
	OutWord 		;[17]and DX is still intact
	JMP	SHORT PCOPY_RET	; & Exit...

CGA_COPY:			; Simple word move would do

REP	MOVSW			; Copy source to destination

PCOPY_RET:			; Clear CF to indicate no error
	CLC			

PCOPY_EXIT:			; Time to exit - do not change flags

cEnd				; End of B$PCOPYS



sEnd	RT_TEXT			

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llcgasup.asm ===
TITLE	LLCGASUP - LowLevel CGA support (shared routines)
;***
; LLCGASUP - LowLevel CGA support
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	This module contains support routines extracted from LLCGA.ASM
;	which are shared by CGA and VGA functions.
;
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_DATA
	USESEG	_BSS
	USESEG	GR_TEXT

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE llgrp.inc
	INCLUDE idmac.inc

sBegin	_BSS
;
;
; ***************************************************************************
; External variables
; ***************************************************************************
;
externW B$LEOFST
externW B$REOFST
externB B$VLMASK
externB B$VRMASK
externD b$AddrC
externB b$AttrC
externB b$BitsPerPixel
externB b$DivShift
externB b$MaskC
externB b$MaskLeft
externB b$MaskRight
externW b$ModMask
externW b$OffC
externB b$PaintBorder
externW b$PenC
externW b$PixelsPerByte
externW b$SegC
;
; ***************************************************************************
; Global variables
; ***************************************************************************
;
globalW b$UpSub,,1		;subtract to try to move up
globalW b$DnSub,,1		;subtract to try to move down
globalW b$UpDnAdd,,1		;add if wrong quadrant/half for subtractor
;
; ***************************************************************************
; External function vectors
; ***************************************************************************
;
externW b$PutVector
externW b$Incr1
externW b$Incr2
;
; ***************************************************************************
; Local variables
; ***************************************************************************
;
staticW SaveCa,,1
staticB SaveCm,,1
staticW PutVectorM,,1		

sEnd	_BSS

assumes CS,GR_TEXT

sBegin	GR_TEXT

externNP B$BumpDS
externNP B$BumpES		
externNP B$DecDS		

;***
; B$CgaSetAttr
;
;Purpose:
;	Replicate the 1 bit attribute for 1-bit-per-pixel modes throughout
;	the attribute byte used by the graphics functions.  If the supplied
;	attribute is greater than 1, use 1.
;Entry:
;	AL = attribute
;Exit:
;	_bAttrC = 00 if AL was 0, else FF
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaSetAttr,<PUBLIC,NEAR>,<AX>
cBegin
	NEG	AL		;set carry iff non-0
	SBB	AL,AL		;AL = (AL==0) ? 0 : -1
	MOV	b$AttrC,al
	CLC			;exit no error
cEnd

;***
; B$CgaReadC
;
;Purpose:
;	Return the attribute of the current pixel as specified by
;	b$MaskC and b$OffC for CGA screen modes.
;Entry:
;	b$MaskC, b$OffC specify pixel to read
;Exit:
;	AL = attribute of specified pixel
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaReadC,<PUBLIC,NEAR>,<ES>
cBegin
	mov	al,b$MaskC	;get cursor mask
	les	bx,b$AddrC	;get memory address of cursor
	mov	cl,b$BitsPerPixel
	mov	ah,es:[bx]	;current cell value
	and	ah,al		;mask out other pixels (using b$MaskC)
RdLoop: shr	ax,cl		;shift right 1 pixel
	jnc	RdLoop		;loop till mask is right justified
	shl	ax,cl		;went once too far
	mov	al,ah		;return with attribute in [al]
cEnd


;***
; B$CgaSetC
;
;Purpose:
;	Set the pixel defined by the current graphics cursor to
;	the current attribute for CGA modes.
;Entry:
;	b$PenC  = cursor mask and attribute
;	b$AddrC = address of pixel
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaSetC,<PUBLIC,NEAR>,<DS>
cBegin
	mov	cx,b$PenC	;[cl] = cursor mask, [ch] = attribute
	lds	bx,b$AddrC	;[BX] = cursor offset, [ES] = segment
	xor	ch,[bx] 	;change masked bits of video byte
	and	ch,cl		;  to color in attribute byte
	xor	[bx],ch
cEnd

;***
; B$CgaSetPixC
;
;Purpose:
;	Set the pixel defined by the current graphics cursor to
;	the current attribute for CGA modes.  This is identical to
;	B$CgaSetC except that this routine assumes ES is set to
;	video segment.
;Entry:
;	ES	= video segment (set up by B$CgaSetPixFirstC)
;	b$PenC = cursor mask and attribute
;	b$OffC = address of pixel
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaSetPixC,<PUBLIC,NEAR>
cBegin
	mov	cx,b$PenC	;[cl] = cursor mask, [ch] = attribute
	mov	bx,b$OffC	;[BX] = cursor offset
				;[ES] = setup by SetPixFirstC
	xor	ch,es:[bx]	;change masked bits of video byte
	and	ch,cl		;  to color in attribute byte
	xor	es:[bx],ch	
cEnd

;***
; B$CgaSetPixFirstC/B$CgaSetPixLastC
;
;Purpose:
;	Set up ES to the video segment for CGA modes (FirstC).
;	LastC just returns as nothing needs to be done here for CGA modes.
;Entry:
;	b$SegC = video segment
;Exit:
;	ES set to video segment
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaSetPixFirstC,<PUBLIC,NEAR>
cBegin
	mov	es,b$SegC	;ES = video segment for b$SetPixC
labelNP <PUBLIC,B$CgaSetPixLastC>
cEnd

labelW	PutTable		;Put Vectors according to put action value
	DW	PutOr, PutAnd, PutPreset, PutPset, PutXor

labelW	PutTableM		;Put Vectors for "Middle" (full mask) PUTs
	DW	PutOrM, PutAndM, PutPresetM, PutPsetM, PutXorM	

;***
; B$CgaPutAction
;
;Purpose:
;	Set b$PutVector to appropriate PUT action routine for CGA modes.
;	Requested action is used to index into a table of entry points.
;Entry:
;	AL = PUT action [0..4] representing (OR, AND, PRESET, PSET, XOR)
;Exit:
;	b$PutVector set to entry point of appropriate PUT action routine
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaPutAction,<PUBLIC,NEAR>
cBegin
	xor	ah,ah		;make word index
	shl	ax,1
	mov	bx,ax
	mov	ax,cs:PutTable[BX]  ;get our vector
	mov	b$PutVector,ax ;save it
	mov	ax,cs:PutTableM[BX] ;get our Middle vector
	mov	PutVectorM,ax	;save it
cEnd

;***
; PutAnd
;
;Purpose:
;	Support routine for CGA PUT.  Write to the specified screen byte
;	the result of ANDing the given attribute with what was already
;	in the screen byte.
;Entry:
;	ES:DI = address of screen byte
;	AH    = attribute to AND, then write
;	DH    = pixel mask
;Exit:
;	ES:DI = address of next screen byte
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	PutAnd,<NEAR>
cBegin
	not	dh		;NEGATE [DH] AND USE NEGATIVE LOGIC
	or	ah,dh		;MAKE NON-SIG BITS ONES
	not	dh		;RESTORE [DH]
	and	es:[di],ah	;AND WITH SCREEN
	inc	di
cEnd

;***
; PutOr
;
;Purpose:
;	Support routine for CGA PUT.  Write to the specified screen byte
;	the result of ORing the given attribute with what was already
;	in the screen byte.
;Entry:
;	ES:DI = address of screen byte
;	AH    = attribute to OR, then write
;	DH    = pixel mask
;Exit:
;	ES:DI = address of next screen byte
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	PutOr,<NEAR>
cBegin
	and	ah,dh		;ISOLATE SIG BITS
	or	es:[di],ah	;OR WITH SCREEN
	inc	di
cEnd

;***
; PutPreset/PutPset/PutXor
;
;Purpose:
;	Support routine for CGA PUT.  Write to the specified screen byte
;	either the specified attribute unchanged (Pset), the one's complement
;	of the specified attribute (Preset), or the result of XORing the
;	specified attribute with what was already in the screen byte,
;	depending on the entry point.
;Entry:
;	ES:DI = address of screen byte
;	AH    = attribute to apply
;	DH    = pixel mask
;Exit:
;	ES:DI = address of next screen byte
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	PutPreset,<NEAR>
cBegin
	not	ah		;NEGATE DATA FOR PRESET
labelNP PutPset
	xor	ah,es:[di]	;XOR DATA WITH EXISTING SCREEN BYTE
labelNP PutXor
	and	ah,dh		;ISOLATE SIG BITS
	xor	es:[di],ah	;XOR WITH SCREEN
	inc	di
cEnd

	ASSUME	DS:NOTHING

;***
; B$CgaNReadL
;
;Purpose:
;	Read a line of pixels from the screen to an array for CGA modes.
;Entry:
;	DS:SI	= screen address
;	ES:DI	= array address
;	CL	= array align shift count
;	CH    = mask for last partial byte
;	BP	= count of bits (not pixels) to read
;Exit:
;	ES:DI	= updated to array byte past point filled
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaNReadL,<PUBLIC,NEAR>
cBegin
	mov	ah,[si] 	;preload hi byte
	inc	si		
NRdLoop:
	lodsb			;fill ax word with video bytes
	mov	bh,al		;this lo byte will become next hi byte
	rol	ax,cl		;align to array
	sub	bp,8		;8 bits done
	jbe	NRdLast 	;go if bit count exhausted
	mov	es:[di],ah	;save full byte
	inc	di		
	mov	ah,bh		;move lo byte (BH) to hi byte (AH)
	jnz	NRdLoop 	;loop if no offset overflow
	call	B$BumpES	;move array pointer over segment boundary
	jmp	short NRdLoop	;go do another
NRdLast:
	and	ah,ch		;strip unused bits from last byte
	mov	es:[di],ah	;save last byte
	inc	di		
	jnz	NRdDone 	
	call	B$BumpES	;move array pointer over segment boundary
NRdDone:
cEnd

;***
; B$CgaNWriteL
;
;Purpose:
;	Write a line of pixels from an array to the screen for CGA modes.
;Entry:
;	ES:DI	= screen address
;	DS:SI	= array address
;	CL	= array align shift count
;	BP	= count of bits (not pixels) to write
;	DL	= last partial byte mask
;	DH	= first partial byte mask
;Exit:
;	DS:SI	= updated to array byte past point used
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaNWriteL,<PUBLIC,NEAR>
cBegin
	mov	ah,[si] 	;preload byte from array
	inc	si
	jnz	NWrOvfl1	
	call	B$BumpDS	;move array pointer over segment boundary
NWrOvfl1:
	ror	ax,cl		;align to video
	add	bp,cx
	sub	bp,8		;account for first partial byte
	jbe	NWrLast 	;go if last byte
.erre	ID_SSEQDS		;assumes ss = ds
	call	ss:[b$PutVector]   ;put the byte
	mov	dh,0FFH 	;mask for whole bytes in the middle
.erre	ID_SSEQDS		;assumes ss = ds
	mov	bx,ss:[PutVectorM]  ;preload the "full mask" put routine
	jmp	short NWrLoop2	;go for more bytes
NWrLoop:
	jmp	bx		;vector to put the byte
;
;The following Put routines are identical to those documented above but
;are optimized for the middle loop where the mask is always 0FFH
;
;
; PutAndM:
;
PutAndM:
	and	es:[di],ah	;AND WITH SCREEN
	jmp	short PutEnd
;
; PutOrM:
;
PutOrM:
	or	es:[di],ah	;OR WITH SCREEN
	jmp	short PutEnd
;
; PutPresetM/PutPsetM
;
PutPresetM:
	not	ah		;NEGATE DATA FOR PRESET
PutPsetM:
	mov	es:[di],ah	;store data for PSET
	jmp	short PutEnd
;
; PutXorM
;
PutXorM:
	xor	es:[di],ah	;OR WITH SCREEN
PutEnd:
	inc	di		;bump to next screen byte
;
NWrLoop2:
	rol	ax,cl		;re-align to array
	lodsb			;fill ax word with array bytes
	or	si,si		;did pointer overflow segment?
	jz	NWrOvfl3	;go if so
NWrOvfl2:
	xchg	ah,al		
	ror	ax,cl		;align to video
	sub	bp,8		;8 bits done
	ja	NWrLoop 	;go if bit count not exhausted
	add	bp,8		;restore BP to #bits in last byte
	cmp	cx,bp		;did we use any of the second byte?
	jb	NWrLast 	;go if so
	or	si,si		;at start of segment?
	jnz	NWrUnfl 	;go if not
	call	B$DecDS	;backup to previous segment
NWrUnfl:			
	dec	si		;move ptr back
NWrLast:
	and	dh,dl		;combine first|middle mask with end mask
.erre	ID_SSEQDS		;assumes ss = ds
	call	ss:[b$PutVector]   ;put the byte
cEnd

NWrOvfl3:			
	call	B$BumpDS	;move array pointer over segment boundary
	jmp	short NWrOvfl2	;back to loop

	ASSUME	DS:DGROUP

;***
; B$CgaNSetC
;
;Purpose:
;	Set a horizontal line of pixels to the current attribute for CGA
;	modes.	The line starts at the current cursor position and moves right.
;
;	Discussion of QCG tiling:
;	Mode 6 tiling is relatively simple; to preserve the background
;	pixels just AND the cursor mask with the byte at BKG_MASK[B$TILNDX].
;	Mode 4/5 tiling is hairy because the fill mask is 8 pixels wide.
;	This covers two bytes per row, which is wider than the current
;	paint tiling code can do.  Because QCG only lets the user supply
;	the pixel on/off mask, as opposed to the actual pixel values, the
;	tile_mask and b$AttrC values are the same for both bytes (actually,
;	for all bytes, in CGA modes).  Only the bkg_mask has to be 16-bits
;	wide -- each row takes two consecutive bytes of bkg_mask.
;
;Entry:
;	b$AddrC specifies start pixel
;	b$PenC = cursor mask and attribute
;	BX	= number of pixels to set
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaNSetC,<PUBLIC,NEAR>,<ES,DI>
cBegin
	les	di,b$AddrC	;graphics cursor address
	mov	dx,b$PenC	;dl = cursor mask, dh = attribute
	or	dl,dl		;left aligned in byte?
	js	NSet2a		;go if so, skip single-bit start
NSet1:
	xor	ah,ah		;zero out new mask accumulator
	mov	cl,b$BitsPerPixel
NSet2:
	or	ah,dl		;include this pixel in mask
	dec	bx		;decrement pixel count
	jz	NSet4		;treat as last byte if bit count exhausted
	ror	dl,cl		;move 1 pixel right
	jnb	NSet2		;continue if not right-most bit
	mov	al,dh		;copy of attribute
	xor	al,es:[di]	;get bits that need to be changed
	and	al,ah		;mask in bits that need to be changed
	xor	es:[di],al	;update pixels
	inc	di		;bump cursor byte pointer
NSet2a:
	mov	ax,bx		;remaining bit count
	mov	cl,b$DivShift	;pixels/byte divisor shift
	shr	ax,cl		;compute full byte count
	jz	NSet3		;go do remaining bits if no full bytes
	xchg	ax,cx		;byte count to cx
	mov	al,dh		;attribute byte
	rep	stosb		;block write full bytes
NSet3:
	and	bx,b$ModMask	;mask in remaining bit count
	jz	NSet5		;no bits remaining - exit
	jmp	NSet1		;go do remaining bits
NSet4:				;update last byte
	xor	dh,es:[di]	;get bits that need to be changed
	and	dh,ah		;mask in bits that need to be changed
	xor	es:[di],dh	;update pixels
NSet5:
cEnd


;***
; B$CgaSetTile
;
;Purpose:
;	This routine stores the internal form of the current tile attribute.
;	This routine is called each time a row is to be painted in CGA modes.
;Entry:
;	BL = tile attribute
;Exit:
;	_bAttrC set to tile attribute
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaSetTile,<PUBLIC,NEAR>
cBegin
	MOV	b$AttrC,BL	 ;set attribute to the tile attribute
cEnd

;***
; ScanInit
;
;Purpose:
;	This routine does some initialization for both ScanL and ScanR
;	for CGA modes.
;Entry:
;	None
;Exit:
;	ES:DI = Video segment address (b$AddrC)
;	CH = cursor mask	      (b$MaskC)
;	DL = border attribute	      (b$PaintBorder)
;	DH = paint attribute	      (b$AttrC)
;	SI = already painted flag     (0)
;	BL = screen byte	      (read from ES:DI)
;	CL = b$BitsPerPixel
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	ScanInit,<NEAR>
cBegin
	les	di,b$AddrC	    ;di=cursor offset, es=video seg
	mov	ch,b$MaskC	    ;ch=cursor mask
	mov	dl,b$PaintBorder   ;dl=border attribute
	mov	dh,b$AttrC	    ;dh=paint attribute
	mov	cl,b$BitsPerPixel  ;shift count
	mov	bl,es:[di]	    ;load the screen byte or word
	xor	si,si		    ;clear already-painted-flag
cEnd

;***
; Helper
;
;Purpose:
;	This routine is used by the beginning and ending parts of
;	SCANL and SCANR. It returns with ZF set if a border pixel was
;	found, else it sets the already-painted-flag appropriately.
;Entry:
;	BL = screen byte
;	DL = border attribute
;	CH = pixel mask
;Exit:
;	If border found
;	    PSW.C set
;	else
;	    AL = screen byte with non-masked pixels set to attribute
;	    SI = non-zero value
;	    BP (paint count) incremented
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	Helper,<NEAR>
cBegin
	mov	al,bl		;get screen byte
	xor	al,dl		;xor with border
	and	al,ch		;mask out unwanted bits
	jz	helpxt1 	;quit if border
	mov	al,bl		;get screen byte in [al]
	xor	al,dh		;xor it with paint attribute
	and	al,ch		;mask out other bits
	or	si,ax		;set already painted flag
	inc	bp		;increment paint count
helpxt1:
cEnd

;***
; B$CgaScanL
;
;Purpose:
;	Scan left beginning with the pixel to the left of cursor,
;	and paint pixels until:
;		(1) the viewport edge is encounteered (edge painted)
;		(2) a border pixel is encountered (border not painted)
;
;Entry:
;	b$AddrC, b$MaskC = pixel to right of starting pixel
;	b$PaintBorder	   = attribute of paint region border
;	b$AttrC	   = attribute to paint
;	B$LEOFST, B$VLMASK   = left viewport edge
;Exit:
;	BX		   = number of pixels scanned
;	CL		   = 0 iff no pixels changed color
;	b$OffC, b$MaskC  = the last non-border pixel examined/painted
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaScanL,<PUBLIC,NEAR>,<SI,DX,DI,BP,ES>
cBegin
	call	ScanInit	;init regs for scanning
	mov	bp,si		;clear paint count

;	Prolog

	cmp	di,B$LEOFST	;cursor offset same as left edge offset ?
	jz	exit4		;Brif so and do the ending
	rol	ch,cl		;move left one pixel
begin1:
	JC	MIDDLE		;go if byte aligned
	call	Helper		;check if this pixel is a border pixel
				;else set the already painted flag
	jz	exit1		;brif if border pixel found
	rol	ch,cl		;move left by one pixel
	JMP	SHORT begin1	;else test the other pixels in this byte
middle:

;	Middle paint loop
;	Middle is used by all screen modes
middle0:

	sub	di,1		;move left one byte
	jb	exit2		;brif underflow
	mov	bl,es:[di]	;get the screen byte
	cmp	di,B$LEOFST	;are we at left edge ?
	je	exit3		;brif so
	mov	al,bl		;screen byte in [al]
	xor	al,dl		;xor it with border
tstbdr1:
	test	al,ch		;border encountered ?
	jz	exit3		;brif border
	rol	ch,cl		;prepare mask to test next pixel
	jnb	tstbdr1 	;test the next pixel
	mov	al,bl		;[al] = screen byte ****
	xor	al,dh		;xor screen byte with paint attribute
	or	si,ax		;set the already-painted-flag
	add	bp,b$PixelsPerByte ;increment paint count by # of
				;pixels in a byte
	JMP	SHORT middle0	;go do the rest

;	Epilog
;	branches here from the beginning part

exit1:
	ror	ch,cl		;back up so not on border
	jnb	final_exit	;brif no carry
	JMP	SHORT exit21

;	branches here if [di] goes < 0

exit2:
	mov	ch,b$MaskLeft	;set mask with the leftmost
				;bit/bits equal to 1
exit21:
	inc	di		;back up
	JMP	SHORT final_exit

;	branches here if [di] is same as B$LEOFST or
;	if a border pixel was found in the middle loop

exit3:
	mov	cl,b$BitsPerPixel
	mov	ch,b$MaskRight ;make the rightmost bit/bits equal to 1
exit31:
	call	Helper
	jz	exit1		;brif border found
	rol	ch,cl		;move left by one pixel
	jb	exit41		;this is a special case
	cmp	ch,B$VLMASK	;compare bit addresses
	ja	exit1		;brif done
	JMP	SHORT exit31	;else continue

;	branches here if we start with cursor offset equal
;	to B$LEOFST (right at the beginning)

exit4:
	rol	ch,cl		;move left by one pixel
;	jnb	exit31		;continue if not the left most pixel
	JB	EXIT41		;if leftmost pixel, then jump
	CMP	CH,B$VLMASK	;test if past the viewport on left
	JNA	EXIT31		;if not, then jump
exit41:
	ror	ch,cl

;	this is where NSetC gets called to do the actual painting

final_exit:
	mov	bx,bp		;paint count in [bx]
	or	bx,bx		;is paint count 0 ?
	jz	fexit1		;branch around NSetC if so
	mov	b$OffC,di	;return cursor offset
	mov	b$MaskC,ch	;return cursor mask
	call	B$CgaNSetC	;paint them
fexit1:
	mov	bx,bp		;return paint count
	mov	cx,si		;return already-painted-flag
cEnd

;***
; B$CgaScanR
;
;Purpose:
;	Starting with the current pixel, search right until:
;		(1) a non-border pixel is found
;		(2) [DX] pixels have been tested
;		(3) the viewport edge is encountered
;
;	If (2) or (3) terminated the scan, exit with:
;		DX = remaining border bount = 0
;
;	If (1) terminated the scan, scan and paint non-border pixels until:
;		(1) the viewport edge is encountered (edge painted)
;		(2) a border pixel is encountered (border not painted)
;
;Entry:
;	DX		   = count of border pixels which may be skipped
;	b$AddrC, b$MaskC = starting pixel
;	b$PaintBorder	   = attribute of paint region border
;	b$AttrC	   = attribute to paint
;	B$REOFST, B$VRMASK   = right viewport edge
;Exit:
;	BX		   = number of pixels painted
;				(whether or not they changed color)
;	CL		   = 0 iff no pixels changed color
;	DX		   = remaining border pixel count
;	b$OffC, b$MaskC  = the last non-border pixel examined/painted
;	SI, AL		   = the first non-border pixel encountered
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaScanR,<PUBLIC,NEAR>,<DI,BP,ES>
cBegin
	mov	bp,dx		;save skip count in [bp]
	call	ScanInit	;init regs for scanning
scnr0:
	mov	al,bl		;screen byte in [al]
	xor	al,dl		;xor it with border
scnr1:
	test	al,ch		;border pixel or not ?
	jnz	begin_paint
	dec	bp		;decrement border count
	jz	scnrxt01	;brif border count zero
	ror	ch,cl		;move right by one pixel
	jnb	scnr1
	inc	di		;move right by one byte
	mov	bl,es:[di]	;screen byte in [bl]
	cmp	di,B$REOFST	;cursor offset same as right edge offset
	jnz	scnr0		;brif so....one more byte to go
	cmp	ch,B$VRMASK	;compare bit addresses
	jae	scnr0		;brif within screen limits
	xor	bp,bp		;pretend to run out of skip count
scnrxt01:
	jmp	scnrxt0

;	We begin painting here. Again the paint loop is in three
;	parts: prolog, main body, and epilog.

begin_paint:
	mov	SaveCa,di	;saving SaveCa and
	mov	SaveCm,ch	;  SaveCm
	mov	b$OffC,di	;set the cursor offset
	mov	b$MaskC,ch	;set the cursor mask
	push	bp		;save border count
	xor	bp,bp		;clear paint count
	test	ch,80h		;cursor byte aligned ?
	JNZ	SRMIDDLE0	;go if so

; PROLOG

begpaint1:
	call	Helper		;calls helper1 increments
				;paint count and sets painted flag
	jz	scnxtn1 	;brif border found
	cmp	di,B$REOFST	; cursor offset = right edge offset?
	jne	begpaint2	; brif not
	cmp	ch,B$VRMASK	; compare bit addresses
	je	scnxtn1		; brif edge of viewport
	ja	begpaint2	; loop if not edge yet
	xor	bp,bp		; special case:  nothing to paint
	jmp	short scnxtn1	
begpaint2:			
	ror	ch,cl		;move right by one pixel
	JNC	BEGPAINT1	;go if not byte aligned

; MAIN BODY

	INC	DI		;to next byte
SRMIDDLE0:
	cmp	b$BitsPerPixel,2
	je	SRMIDDLE2

srmiddle:
	mov	bl,es:[di]	;[bl] = screen byte
	cmp	B$REOFST,di	;are we at the right edge ?
	JBE	SCNRXTCHK	;brif so or beyond
	MOV	AL,BL		;copy screen byte
	NOT	AL		;bitwise equivalence with border color
	XOR	AL,DL		;  a bit in a pixel will be 1 if pixel
				;  is border color
	JNZ	BEGPAINT1	;go if border color found in the byte
	XOR	BL,DH		;detect any differences from paint color
	OR	SI,BX		;combine with the already painted flag
				;only LOByte is significant
	ADD	BP,8		;increment paint count
	INC	DI		;move right by one byte
	JMP	SHORT srmiddle	;go do the rest

SRMIDDLE2:
	MOV	AH,55H
SRMIDDLE3:
	MOV	BL,ES:[DI]	;get screen byte
	CMP	B$REOFST,di	;at the right edge or beyond?
	JBE	SCNRXTCHK	;go if so
	MOV	AL,BL		;copy screen byte
	NOT	AL		;bitwise equivalence with border color
	XOR	AL,DL		;  both bits in a pixel will be 1 if pixel
	MOV	BH,AL		;  is border color
	SHR	BH,1		;shift left bit in copy on to right bit
	AND	BH,AH		;mask off the trash
	AND	BH,AL		;see if both bits set in any pixel
	JNZ	BEGPAINT1	;go if border color found in the byte
	XOR	BL,DH		;detect any differences from paint color
	OR	SI,BX		;combine with the already painted flag
				;only LOByte is significant
	ADD	BP,4		;increment paint count
	INC	DI		;to next byte
	JMP	SHORT SRMIDDLE3 ;loop until border color or edge found

; EPILOG

SCNRXTCHK:
	jz	scnrxt3
	mov	cl,b$BitsPerPixel  ;[cl] = screen bits/pixel
	rol	ch,cl		;back up
	inc	di		;move right a byte
scnxtn1:
	JMP	SHORT scnrxt2	;start painting

scnrxt3:
	mov	ch,b$MaskLeft	;set the leftmost bit/bits
scnrxt31:
	call	Helper		;calls helper1 increments
				;paint count and sets painted flag
	jz	scnrxt2 	;brif border
	ror	ch,cl		;move right by one pixel
	jb	scnrxt1 	;special case ??????
	CMP	DI,B$REOFST	;test if on right viewport byte
	JNE	SCNRXT31	;if not, then continue on
	cmp	ch,B$VRMASK	;compare bit addresses
	jb	scnrxt1 	;brif edge encountered
	JMP	SHORT scnrxt31

scnrxt1:
	rol	ch,cl		;back up

scnrxt2:
	push	cx
	mov	bx,bp		;paint count
	or	bx,bx		;paint count = 0 ?
	jz	no_nset 	;branch around NSetC
	call	B$CgaNSetC
no_nset:
	mov	bx,bp		;return paint count
	pop	cx
	mov	b$OffC,di	;return cursor offset
	mov	b$MaskC,ch	;return cursor mask
	pop	dx		;return skip count
	mov	cx,si		;return already-painted -flag
	JMP	SHORT scnrxt

scnrxt0:
	mov	bx,bp		;paint count = 0
	mov	dx,bp		;skip count  = 0
	mov	cl,bl		;already-painted-flag = 0
	mov	b$OffC,di	;return cursor offset
	mov	b$MaskC,ch	;return cursor mask
scnrxt:
	mov	si,SaveCa	;returning SaveCm and
	mov	al,SaveCm	;  SaveCm
cEnd

;***
; LineSetup
;
;Purpose:
;	This routine is called at the beginning of LineX, LineY, and LineV.
;	It handles the buffer half splitting of the CGA and quadrant row
;	splitting of the HGC.
;	(See discussion of the architecture in the LLCGA and LLHGC headers).
;Entry:
;	DX	 = negative for up, otherwise down
;Exit:
;	DX	 = up/down move assumption
;Uses:
;	none.
;Exceptions:
;******************************************************************************
cProc	LineSetup,<NEAR>
cBegin
	OR	DX,DX		;Y difference negative? (up)
	MOV	DX,b$UpSub	;assume so, use UP subtractor
	JS	LineSetupExit	;go if correct assumption
	MOV	DX,b$DnSub	;no, use DOWN subtractor
LineSetupExit:			
cEnd

;***
; B$CgaLineX
;
;Purpose:
;	Draw an X-major line for CGA modes.
;Entry:
;	AH    = color (b$AttrC)
;	AL    = bit accumulator
;	BX    = point count
;	CH    = bit mask
;	CL    = trash for twiddle and pixel shift count
;	DX    = BP change for Y movement (UpSub or DnSub)
;	SI    = delta decision value
;	DI    = line style
;	BP    = video offset
;	ES    = video segment
;	Incr1 = major axis delta update value
;	Incr2 = minor axis delta update value
;	UpDnAdd = corrector for DX subtraction
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaLineX,<PUBLIC,NEAR>
cBegin
	CALL	LineSetup	

	XCHG	BX,CX		;point count to BX
	MOV	CL,b$BitsPerPixel

LineCXloop:

	ROL	DI,1		;next line style bit
	JNC	LineCX2 	;go if bit is 0 not to plot

	OR	AL,CH		;OR this bit into byte mask
LineCX2:
	OR	SI,SI		;time to move in Y (+ or 0 delta)?
	JNS	LineCX4 	;go if so
	ADD	SI,b$Incr1	;update delta for X movement
	ROR	CH,CL		;move to next X
	JC	LineCX3 	;go if not still in same byte
	DEC	BX
	JNZ	LineCXloop	;go for more
	JMP	SHORT LineCX7	;  or exit
LineCX3:
	MOV	CL,AH		;get color, dump accumulated pixels
	XOR	CL,ES:[BP]	;change masked bits of video byte
	AND	CL,AL		;  to color in attribute byte
	XOR	ES:[BP],CL	;(twiddle)
	XOR	AL,AL		;clear pixel accumulator
	MOV	CL,b$BitsPerPixel  ;reload bits per pixel
	INC	BP		;go to next byte
	DEC	BX
	JNZ	LineCXloop	;go for more
	JMP	SHORT LineCX7	;  or exit
LineCX4:
	ADD	SI,b$Incr2	;update delta for Y movement
	MOV	CL,AH		;get color, dump accumulated pixels
	XOR	CL,ES:[BP]	;change masked bits of video byte
	AND	CL,AL		;  to color in attribute byte
	XOR	ES:[BP],CL	;(twiddle)
	XOR	AL,AL		;clear pixel accumulator
	MOV	CL,b$BitsPerPixel  ;reload bits per pixel
	ROR	CH,CL		;move to next X
	ADC	BP,0		;(+1 if next X byte)
	sub	BP,DX		;make the assumed Y movement
	jnb	LineCX5 	;go if no problem
	add	BP,b$UpDnAdd	;undo SUB + perform correct movement
LineCX5:
	DEC	BX
	JNZ	LineCXloop	;go for more
LineCX7:			;flush accumulated pixels
	XOR	AH,ES:[BP]	;change masked bits of video byte
	AND	AH,AL		;  to color in attribute byte
	XOR	ES:[BP],AH	;(twiddle)
cEnd

;***
; B$CgaLineY
;
;Purpose:
;	Draw a Y-major line for CGA modes.
;Entry:
;	AH    = color (b$AttrC)
;	AL    = bit mask
;	BX    = point count
;	CH    = trash for twiddle
;	CL    = pixel shift count
;	DX    = BP change for Y movement (UpSub or DnSub)
;	SI    = delta decision value
;	DI    = line style
;	BP    = video offset
;	ES    = video segment
;	Incr1 = major axis delta update value
;	Incr2 = minor axis delta update value
;	UpDnAdd = corrector for DX subtraction
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaLineY,<PUBLIC,NEAR>
cBegin
	call	LineSetup	

	XCHG	BX,CX		;point count to BX
	MOV	CL,b$BitsPerPixel

LineCYloop:

	ROL	DI,1		;next line style bit
	JNC	LineCY2 	;go if bit is 0 not to plot

	MOV	CH,AH		;get color, dump accumulated pixels
	XOR	CH,ES:[BP]	;change masked bits of video byte
	AND	CH,AL		;  to color in attribute byte
	XOR	ES:[BP],CH	;(twiddle)
LineCY2:
	OR	SI,SI		;time to move in X (+ or 0 delta)?
	JNS	LineCY3 	;go if so
	ADD	SI,b$Incr1	;update delta for Y movement
	sub	BP,DX		;make the assumed Y movement
	jnb	LineCY2A	;go if no problem
	add	BP,b$UpDnAdd	;undo SUB + perform correct movement
LineCY2A:
	DEC	BX
	JNZ	LineCYloop
	ret
LineCY3:
	ADD	SI,b$Incr2	;update delta for X movement
	ROR	AL,CL		;move to next X
	ADC	BP,0		;(+1 if next X byte)
	sub	BP,DX		;make the assumed Y movement
	jnb	LineCY5 	;go if no problem
	add	BP,b$UpDnAdd	;undo SUB + perform correct movement
LineCY5:
	DEC	BX
	JNZ	LineCYloop	;go for more
cEnd

;***
; B$CgaLineV
;
;Purpose:
;	Draw a vertical line for CGA modes.
;Entry:
;	AH = color (b$AttrC)
;	AL = bit mask
;	BH = trash for twiddle
;	BL = unused
;	CX = point count
;	DX = BP change for Y movement (UpSub or DnSub)
;	SI = UpDnAdd = corrector for DX subtraction
;	DI = line style
;	BP = video offset
;	ES = video segment
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaLineV,<PUBLIC,NEAR>
cBegin
	call	LineSetup	

	MOV	SI,b$UpDnAdd	;to register here

LineCVloop:

	ROL	DI,1		;next line style bit
	JNC	LineCV2 	;go if bit is 0 not to plot

	MOV	BH,AH		;get color, dump accumulated pixels
	XOR	BH,ES:[BP]	;change masked bits of video byte
	AND	BH,AL		;  to color in attribute byte
	XOR	ES:[BP],BH	;(twiddle)
LineCV2:
	sub	BP,DX		;make the assumed Y movement
	jnb	LineCV5 	;go if no problem
	add	BP,SI		;undo SUB + perform correct movement
LineCV5:			
	LOOP	LineCVloop	;go for more
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llcga.asm ===
TITLE		LLCGA - CGA screen mode support
;***
;LLCGA - CGA screen mode support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Support for CGA graphics screen modes (BIOS 4,5,6).
;	Note that this module module contains support
;	code for all adapters capable of handling these
;	screen modes and also attempts to compensate for
;	the subtle differences in their treatment.
;
;	This module sets hooks in the mode-independent
;	modules to routines here for mode-dependent
;	graphics support.  See the mode-independent
;	modules for more precise descriptions of the
;	purposes and interfaces of these routines.
;
;	The following table summarizes the information for
;	the modes and configurations covered:
;
;    C		  |	A			     B
;    O		  |  B	T			     I
;    L		  |  I	T		 P	     T
;    O	     A	M |  O	R		 A    C      S
;  S R	     D	O |  S	I    C		 G    H      / P
;  C B	     A	N |	B    O		 E    A   P  P L
;  R U	C  R P	I |  M	U    L	 X   Y	 S    R   A  I A
;  E R	O  O T	T |  O	T    O	 R   R	 I    B   G  X N
;  E S	L  W E	O |  D	E    R	 E   E	 Z    O   E  E E
;  N T	S  S R	R |  E	S    S	 S   S	 E    X   S  L S
; -- - -- -- - -- | -- --- ---- --- --- --- ---- --- - -
;  1 0 40 25 C	x |  4	 4  N/A 320 200  16 8x8   1  2 1
;  1 0 40 25 E	x |  "   "  16	 "   "	  "  "	  "  " "
;  1 1 40 25 C	x |  5	 "  N/A  "   "    "  "    "  " "
;  1 x 40 25 I	x |  "   "   "   "   "    "  "    "  " "
;  1 1 40 25 E	x |  "   "  16	 "   "	  "  "	  "  " "
;  1 x 40 25 S	x |  "   "   "   "   "    "  "    "  " "
;
;  2 x 80 25 C	x |  6	 2  N/A 640 200  16 8x8   1  1 1
;  2 x 80 25 I	x |  "   "   "   "   "    "  "    "  " "
;  2 x 80 25 E	x |  "   "  16	 "   "	  "  "	  "  " "
;  2 x 80 25 S	x |  "   "   "   "   "    "  "    "  " "
;
; Discussion of CGA odd/even line archtecture:
;	CGA video memory is organized into two banks.  The first bank,
;	starting at B800, contains all the even scan lines.  The second
;	bank, starting at B800+8K, contains all the odd scan lines:
;
;	Scan	Offset
;	Line	from B800
;	----	---------
;	0	0
;	1	8K
;	2	80
;	3	8K+80
;	.	.
;	.	.
;	.	.
;
;	To move UP   from odd  scan line to even, add -8K    to current address
;	To move UP   from even scan line to odd,  add +8K-80 to current address
;	To move DOWN from odd  scan line to even, add -8K+80 to current address
;	To move DOWN from even scan line to odd,  add +8K    to current address
;
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_DATA
	USESEG	_BSS
	USESEG	GR_TEXT
	USESEG	CN_TEXT
	USESEG	XIB		
	USESEG	XI		
	USESEG	XIE		

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE llgrp.inc	; Constant definitions
	INCLUDE idmac.inc
	INCLUDE grmac.inc	;ModeData macros

	INITIALIZER B$xINITCGA	;Put B$xINITCGA in initializer list


sBegin	_BSS
;
; ***************************************************************************
; Local variables
; ***************************************************************************
;
staticB BackColor,,1		;save background color for COLOR stmt
				;__bBackColor is actually an attribute,
				;and should stay 0 in graphics modes
;
; ***************************************************************************
; External function vectors
; ***************************************************************************
;
externW b$PalPut
;
; ***************************************************************************
; External variables
; ***************************************************************************
;
externW b$CurPages		; current active and visual page
externB b$BiosMode
externB b$Adapter
externB b$Monitor
externW b$ModeBurst
externB b$ScreenMode
externW b$VideoBase
externB b$MaskC
externB b$AttrC
externW b$OffC
externW b$SegC
externB b$MaxAttr
externB b$EgaPalSup		
externW B$VTOFST
externW B$VBOFST
externW B$VLOFST
externW B$VROFST
externW B$LEOFST
externW B$REOFST
externB b$NullColor
externB b$BitsPerPixel
externW b$BytesPerRow

externW b$UpSub 		
externW b$DnSub 		
externW b$UpDnAdd		
externW b$ScreenTab		
sEnd	_BSS

assumes CS,GR_TEXT
sBegin	GR_TEXT

externNP B$SCNIO 		;used in SCNIO macro

externNP B$InitModeData
externNP B$GetParm
externNP B$EgaPalReset
externNP B$EgaPalPut
externNP B$EgaPalTrans
externNP B$EgaPalSet
externNP B$ErrorReturn
externNP B$CgaSetAttr
externNP B$CgaLeftC1		
externNP B$CgaLeftC2		
externNP B$CgaChkUpC		
externNP B$CgaUpC		
externNP B$CgaChkDownC		
externNP B$CgaDownC		
externNP B$CgaPaintBound	
externNP B$CgaReadC
externNP B$CgaSetC
externNP B$CgaSetPixC
externNP B$CgaSetPixFirstC
externNP B$CgaSetPixLastC
externNP B$CgaPutAction
externNP B$CgaNReadL
externNP B$CgaNWriteL
externNP B$CgaNSetC
externNP B$CgaSetTile
externNP B$CgaScanL
externNP B$CgaScanR
externNP B$CgaLineX
externNP B$CgaLineY
externNP B$CgaLineV


;===========================================================================
mModeData	Mode1Data
;
; SCREEN 1, BIOS modes 4 & 5
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	1
mBiosMode	4		;BIOS mode and burst may be adjusted later
mBurst		0
mScrWidth	40
mScrHeight	25
mHorzRes	320
mVertRes	200
mVideoBase	0B800H
mMaxAttr	3
mMaxColor	15
mPageSize	16		    ;page size in K
mCurrPSize	<(16*1024) shr 4>   ;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	3
mBackColor	0
mEgaWrMd	0
mInitPalette	Mode1Palette
mInitVgaPal	Mode1VgaPal
mAlphaDim	AlphaDim1
mSetMode	SetMode
mSetPages	B$CgaSetPages		
mPalReset	B$EgaPalReset
mPalPut 	PalPut1
mPalTrans	B$EgaPalTrans
mPalSet 	B$EgaPalSet
mSetColor	SetColor1
mForeMapped	3
mBitsPerPixel	2
mPlanes 	1
mMapXYC 	MapXYC1
mLeftC		B$CgaLeftC2	
mChkUpC 	B$CgaChkUpC	
mUpC		B$CgaUpC	
mChkDownC	B$CgaChkDownC	
mDownC		B$CgaDownC	
mSetAttr	SetAttr1
mReadC		B$CgaReadC
mSetC		B$CgaSetC
mSetPixC	B$CgaSetPixC
mSetPixFirstC	B$CgaSetPixFirstC
mSetPixLastC	B$CgaSetPixLastC
mLineX		B$CgaLineX
mLineY		B$CgaLineY
mLineV		B$CgaLineV
mPutAction	B$CgaPutAction
mNReadL 	B$CgaNReadL
mNWriteL	B$CgaNWriteL
mNSetC		B$CgaNSetC
mPaintBound	B$CgaPaintBound 
mSetTile	B$CgaSetTile
mScanL		B$CgaScanL
mScanR		B$CgaScanR
mEnd		GraphDataLen
;===========================================================================

;===========================================================================
mModeData	Mode2Data
;
; SCREEN 2, BIOS mode 6
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	2
mBiosMode	6
mBurst		0
mScrWidth	80
mScrHeight	25
mHorzRes	640
mVertRes	200
mVideoBase	0B800H
mMaxAttr	1
mMaxColor	15
mPageSize	16		    ;page size in K
mCurrPSize	<(16*1024) shr 4>   ;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	1
mBackColor	0
mEgaWrMd	0
mInitPalette	b$Mode2Palette		
mInitVgaPal	b$Mode2VgaPal		
mAlphaDim	AlphaDim2
mSetMode	SetMode
mSetPages	B$CgaSetPages		
mPalReset	B$EgaPalReset
mPalPut 	B$EgaPalPut
mPalTrans	B$EgaPalTrans
mPalSet 	B$EgaPalSet
mSetColor	B$ErrorReturn
mForeMapped	1
mBitsPerPixel	1
mPlanes 	1
mMapXYC 	MapXYC2
mLeftC		B$CgaLeftC1	
mChkUpC 	B$CgaChkUpC	
mUpC		B$CgaUpC	
mChkDownC	B$CgaChkDownC	
mDownC		B$CgaDownC	
mSetAttr	B$CgaSetAttr
mReadC		B$CgaReadC
mSetC		B$CgaSetC
mSetPixC	B$CgaSetPixC
mSetPixFirstC	B$CgaSetPixFirstC
mSetPixLastC	B$CgaSetPixLastC
mLineX		B$CgaLineX
mLineY		B$CgaLineY
mLineV		B$CgaLineV
mPutAction	B$CgaPutAction
mNReadL 	B$CgaNReadL
mNWriteL	B$CgaNWriteL
mNSetC		B$CgaNSetC
mPaintBound	B$CgaPaintBound 
mSetTile	B$CgaSetTile
mScanL		B$CgaScanL
mScanR		B$CgaScanR
mEnd		GraphDataLen
;===========================================================================

;
; Mode1Palette - used to initialize the EGA palette for SCREEN 1
;		 (BIOS mode 4 or 5).
;
labelB	Mode1Palette
	;	RGBrgb
	DB	000000B 	;black
	DB	111011B 	;bright cyan
	DB	111101B 	;bright magenta
	DB	111111B 	;bright white
	;DB	    12 DUP (0)
;
; Mode2Palette - used to initialize the EGA palette for SCREEN 2
;		 (BIOS mode 6).
;
PUBLIC	b$Mode2Palette		
labelB	b$Mode2Palette		
	;	RGBrgb
	DB	000000B 	;black
	DB	111111B 	;bright white
	;DB	    14 DUP (0)



labelNP <PUBLIC, B$CGAUSED>	


;*** 
; B$Screen1
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 1.
;Entry:
;	AL = screen mode (1)
;	AH = burst (0 or 1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen1,<PUBLIC,NEAR>
cBegin
	test	b$Adapter,VGA + MCGA + EGA + CGA ;check for adapter support
	je	ScrErr		;exit w/error if not supported
	test	b$Monitor,AnalogColor + EnhColor + StdColor
				;check for monitor support
	je	ScrErr		;exit w/error if not supported
	mov	al,ah		;new BIOS mode = 4 if no burst
	add	al,4		;		 5 if burst
	mov	bx,GR_TEXTOFFSET Mode1Data  ;mode-specific data
	mov	cx,GraphDataLen 
	push	ax
	call	B$InitModeData ;initialize table data
	pop	ax
	mov	b$ModeBurst,ax ;save new mode and burst
	jmp	short ScrCommon ;common exit
ScrErr:
	stc
ScrExit:
JustReturn:
cEnd

;*** 
; B$Screen2
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 2.
;Entry:
;	AL = screen mode (2)
;	AH = burst (0 or 1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;	can exit through B$Screen1's error exit.
;******************************************************************************
cProc	B$Screen2,<PUBLIC,NEAR>
cBegin
	test	b$Adapter,VGA + MCGA + EGA + CGA ;check for adapter support
	je	ScrErr		;exit w/error if not supported
	test	b$Monitor,AnalogColor + EnhColor + StdColor
				;check for monitor support
	je	ScrErr		;exit w/error if not supported
	mov	bx,GR_TEXTOFFSET Mode2Data  ;mode-specific data
	mov	cx,GraphDataLen 
	call	B$InitModeData ;initialize table data
ScrCommon:				
	mov	b$UpSub,8192		
	mov	b$DnSub,8192-80 	
	mov	b$UpDnAdd,8192-80+8192	
	clc			;indicate no error
cEnd

;***
; AlphaDim1
;
;Purpose:
;	Validate the proposed text dimensions for Screen 1.
;	  If 40x25 is requested, this mode satisfies the request
;	  elseif 80x25 is requested, suggest screen mode 2
;	  else suggest screen mode 0.
;Entry:
;	BH = number of lines
;	BL = number of columns
;Exit:
;	AL = -1 if this mode satisfies the request, otherwise
;		AL is suggested screen mode to invoke for desired dimensions
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	AlphaDim1
cProc	AlphaDim1,<NEAR>
cBegin
	mov	al,-1		;flag request satisfied (maybe)
	cmp	bx,40+25*256	;40x25?
	je	ADim1Exit	;exit if so, standard stuff
	xor	al,al		;flag request for screen 0
	cmp	bx,80+25*256	;80x25?
	jne	ADim1Exit	;if not, let text mode try
	mov	al,2		;otherwise use screen 2
ADim1Exit:
	clc			;no error
cEnd

;***
; AlphaDim2
;
;Purpose:
;	Validate the proposed text dimensions for Screen 2.
;	  If 80x25 is requested, this mode satisfies the request
;	  elseif 40x25 is requested, suggest screen mode 1
;	  else suggest screen mode 0.
;Entry:
;	BH = number of lines
;	BL = number of columns
;Exit:
;	AL = -1 if this mode satisfies the request, otherwise
;		AL is suggested screen mode to invoke for desired dimensions
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	AlphaDim2
cProc	AlphaDim2,<NEAR>
cBegin
	mov	al,-1		;flag request satisfied (maybe)
	cmp	bx,80+25*256	;80x25?
	je	ADim1Exit	;exit if so, standard stuff
	xor	al,al		;flag request for screen 0
	cmp	bx,40+25*256	;40x25?
	jne	ADim2Exit	;if not, let text mode try
	inc	al		;otherwise use screen 1
ADim2Exit:
	clc			;no error
cEnd

;***
; SetMode
;
;Purpose:
;	Set the screen mode according to the characteristics established
;	by previous call to B$Screenx and b$AlphaDim.
;Entry:
;
;Exit:
;
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	SetMode
cProc	SetMode,<NEAR>
cBegin
	mov	al,b$BiosMode	;set BIOS mode
	SCNIOS	vSetMode	
	cmp	b$ScreenMode,1 ;remainder for SCREEN 1 only
	jne	SetModeExit	;exit if not
	test	b$Adapter,EGA+VGA  ;EGA or VGA?
	jz	SetModeExit	;go if not
;
;	The following is provided only to overcome a bug in the EGA BIOS
;	routines which support the graphics "compatibility mode" (BIOS 4)
;	so that the two calls related to PALETTE (INT10 AH = 0BH and
;	INT10H AH = 10H) work correctly.  If we use the first call once
;	when user invokes SCREEN 1 to set the background color, then the
;	BIOS will subsequently reference the correct (low-intensity)
;	color values for the 4 palette attributes whenever the call using
;	INT10H, AH = 0BH is used to toggle the palette, and whenever the
;	call INT10H, AH = 10H is used to set an individual palette regis-
;	ter.  In the absence of this initialization, the high-intensity
;	color values for both palettes are referenced.
;
	xor	bx,bx		;set background to 0
	SCNIOS	vSetPalette	;INT10H, AH=0BH "set color palette"
SetModeExit:
cEnd

;***
; B$CgaSetPages
;
;Purpose:
;	Set the current active and visual pages and calculate page size
;	and video segment offset.
;Entry:
;	AL = active page (will always be 0 for these modes)
;	AH = visual page (will always be 0 for these modes)
;Exit:
;	b$CurPages set to new active and visual pages
;	b$SegC set to video segment
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
PUBLIC	B$CgaSetPages		
cProc	B$CgaSetPages,<NEAR>	
cBegin
DbAssertRel	AX,E,0,GR_TEXT,<Non-zero page requested in B$CgaSetPages (LLCGA)>
	mov	[b$CurPages],ax	; save page numbers
	mov	ax,[b$VideoBase] ;set video segment
	mov	[b$SegC],ax
cEnd

;***
; PalPut1
;
;Purpose:
;	Change palette entry for Screen 1 with translation/verification.
;	A color value of -1 indicates that the associated palette
;	entry is not to be modified.
;Entry:
;	[DX:AX] = color
;	BL	= attribute
;Exit:
;	PSW.C reset indicates successful operation
;		set indicates PALETTE function call error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	PalPut1
cProc	PalPut1,<NEAR>
cBegin
	cmp	ax,-1		;lo word of color == -1?
	jne	PutPalA 	;go if not, can't ignore
	cmp	dx,ax		;hi word too?
	je	PutPalX 	;exit if color == -1
PutPalA:			
	push	ax
	push	dx		
	push	bx
	call	B$EgaPalPut	;put palette value
	pop	bx
	pop	dx		
	pop	ax
	jc	PutPalX 	;go if error
	or	bl,bl		;is for background?
	jnz	PutPalX 	;exit if not
	call	B$EgaPalTrans	;translate color value again!!
	cmp	b$EgaPalSup,0	;have we an EGA palette?
	je	PutPalX 	;exit if not
	mov	bh,al		;overscan color
	mov	al,1		;subfunction "Set Overscan (Border) Register"
	SCNIO	vSetEgaPalette	;set the border color identically
PutPalX:
cEnd


;***
; MapXYC1
;
;Purpose:
;	May given X and Y coordinates to the graphics cursor for Screen 1.
;Entry:
;	CX = X coordinate
;	DX = Y coordinate
;Exit:
;	b$OffC, b$MaskC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	MapXYC1
cProc	MapXYC1,<NEAR>
cBegin
	xor	ax,ax
	shr	dx,1		;dx=row within odd or even half, carry=1 if odd
	rcr	ax,1		;ax=8K if dx was odd, 0 if was even
	shr	ax,1		;  computing offset to proper buffer half
	shr	ax,1
	mov	bx,dx		;multiply y by 80 to compute row displacement
	shl	dx,1		;dx=2*Y
	shl	dx,1		;dx=4*Y
	add	dx,bx		;dx=5*Y
	shl	dx,1		;dx=10*Y
	shl	dx,1		;dx=20*Y
	shl	dx,1		;dx=40*Y
	shl	dx,1		;dx=80*Y
	add	dx,ax		;odd rasters are displaced 8k
	mov	ax,cx		;save x
	shr	ax,1		;div by PixelsPerByte (4)
	shr	ax,1		;  to get byte index
	add	dx,ax		;add x byte offset to y row address
	mov	b$OffC,dx	;save byte offset
	and	cl,3		;mask in x bit addr
	shl	cl,1		;  *2 for pixel addr in byte
	mov	ch,11000000B	;leftmost pixel on in shift mask
	shr	ch,cl		;move over to get mask
	mov	b$MaskC,ch	;store cursor mask
cEnd

;***
; MapXYC2
;
;Purpose:
;	May given X and Y coordinates to the graphics cursor for Screen 2.
;Entry:
;	CX = X coordinate
;	DX = Y coordinate
;Exit:
;	b$OffC, b$MaskC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	MapXYC2
cProc	MapXYC2,<NEAR>
cBegin
	xor	ax,ax
	shr	dx,1		;dx=row within odd or even half, carry=1 if odd
	rcr	ax,1		;ax=8K if dx was odd, 0 if was even
	shr	ax,1		;  computing offset to proper buffer half
	shr	ax,1
	mov	bx,dx		;multiply y by 80 to compute row displacement
	shl	dx,1		;dx=2*Y
	shl	dx,1		;dx=4*Y
	add	dx,bx		;dx=5*Y
	shl	dx,1		;dx=10*Y
	shl	dx,1		;dx=20*Y
labelNP	<PUBLIC,B$MapXYC2_4>	; common to MAPXYC4 routine (lloga.asm)
	shl	dx,1		;dx=40*Y
	shl	dx,1		;dx=80*Y
	add	dx,ax		;odd rasters are displaced 8k
	mov	ax,cx		;save x
	shr	ax,1		;div by PixelsPerByte (8)
	shr	ax,1		;  to get byte index
	shr	ax,1
	add	dx,ax		;add x byte offset to y row address
	mov	b$OffC,dx	;save byte offset
	and	cl,7		;mask in x bit addr
	mov	ch,10000000B	;leftmost pixel on in shift mask
	shr	ch,cl		;move over to get mask
	mov	b$MaskC,ch	;store cursor mask
cEnd

;***
; SetAttr1
;
;Purpose:
;	Replicate supplied attribute throughout the attribute byte for
;	use by Screen 1 functions.  If supplied attribute is beyond
;	legal range the maximum legal attribute is used.
;Entry:
;	AL = attribute
;Exit:
;	b$Attr updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	SetAttr1
cProc	SetAttr1,<NEAR>,<AX>
cBegin
	cmp	al,b$MaxAttr	;test against maximum attribute
	jbe	SetAttr1Ok	;Brif legal
	mov	al,b$MaxAttr	;limit to max
SetAttr1Ok:
	MOV	CL,2		;2 bits per pixel
	MOV	AH,AL		;attr mask in ??????xx
	SHL	AH,CL
	OR	AL,AH		;attr mask in ????xxxx
	SHL	AH,CL
	OR	AL,AH		;attr mask in ??xxxxxx
	SHL	AH,CL
	OR	AL,AH		;attr mask in xxxxxxxx
	MOV	b$AttrC,al	;exit no error
cEnd

;***
; SetColor1
;
;Purpose:
;	Process the color statement for Screen 1.  Syntax for Screen 1
;	color statement is as follows:
;
;		COLOR [background],[fg palette],[fg override]
;
;	where "background"  is a color number 0-255 which gets mapped to 0-15,
;	      "fg palette"  is a number which selects CGA palette 0 if even,
;						   or CGA palette 1 if odd,
;	  and "fg override" (if present) replaces and functions identically
;			    to "fg palette".
;
;	Any omitted parameter(s) indicate no change for that parameter.
;Entry:
;	parameter list
;		WORD 1 = flag 0 if param not present
;		WORD 2 = parameter if WORD 1 <> 0, else second param flag
;		etc.
;Exit:
;	PSW.C set if too many parameters, reset if Ok
;	b$NullColor set to background attribute value (always 0 for screen 1)
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	SetColor1
cProc	SetColor1,<NEAR>
cBegin
	cCall	B$GetParm	;AL=background parameter
	push	ax		;save background and flag
	cCall	B$GetParm	;AL=1st palette parameter
	xchg	ax,bx		;save 1st palette and flag
	cCall	B$GetParm	;AL=2nd palette parameter
	jnz	SetCol1 	;jump if param found
				;  which overrides the 1st one
	xchg	ax,bx		;restore 1st palette param
	or	ah,ah		;is it defaulted too?
	jnz	SetCol2 	;go if so
SetCol1:
;	If palette parameter, then user gets bogus palette reset to
;	0 or 1.
	push	ax		;save palette select value
	test	b$Adapter,EGA + VGA ;EGA or VGA?
	jnz	IsEga		;go if so
	xor	bx,bx		;set background subfunction (0)
	mov	bl,BackColor	;get chosen background color
	SCNIOS	vSetPalette	;set background
IsEga:				
	pop	bx		;restore palette select value
	mov	bh,1		;subfunction - set bogus palette
	and	bl,bh		;force palette number to 0 or 1
	SCNIOS	vSetPalette	
SetCol2:
	pop	bx		;the background parameter is on the stack
	or	bh,bh		;was there background parameter?
	jnz	SetColExit	;no, only palette
	and	bl,0FH		;Allow 0-255, mask to 0-15.
	test	bl,8		;If Bgnd to be intensified
	jz	SetCol3 	;Brif not
	or	bl,10H		;Set Intensity Bit
SetCol3:
	mov	BackColor,bl	;save it
	test	b$Adapter,EGA + VGA ; EGA card present? [10] or VGA?
	jz	NoEga		; No, use CGA BIOS call to set background
	mov	al,bl		;AL=color
	and	al,0FH		;strip intensity (PalPut will translate)
	cbw			;AX=color
	cwd			;DX:AX=color
	mov	bl,bh		;BL=attribute(0)
	call	[b$PalPut]	;make the EGA do what WE want
	jmp	short SetColExit 
NoEga:				
	SCNIOS	vSetPalette	;set background color
SetColExit:
	mov	b$NullColor,0	;use background for null color
	clc			;indicate no error
	jcxz	SetColDun	;if we got all params, thats true
	stc			;otherwise set error
SetColDun:
cEnd

;***
; B$xINITCGA - initialize CGA modes
;
;Purpose:
;	Added with revision [14].
;	Put the addresses of CGA screen mode support routines into the
;	dispatch table used by the screen statement.
;
;Entry:
;	None
;Exit:
;	ScreenTab updated
;Uses:
;	None
;Exceptions:
;******************************************************************************
cProc	B$xINITCGA,<FAR,PUBLIC> 
cBegin
	MOV	WORD PTR [b$ScreenTab + (1*2) + 1],OFFSET B$Screen1
	MOV	WORD PTR [b$ScreenTab + (2*2) + 1],OFFSET B$Screen2
cEnd


sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llcgrp.asm ===
TITLE	LLCGRP - Core GW-BASIC Graphics Interface
;***
; LLCGRP - Core GW-BASIC Graphics Interface
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains support for graphics functions required
;	by programs that may not use graphics drawing statements.
;	Some non-graphic statements (such as CLS) require some graphic
;	support.  Routines directly supporting only graphics drawing
;	statements are placed in LLAGRP to improve runtime granularity
;	and reduce the size of programs not directly using graphics.
;
;	Routines in this module are mode-independent in one or more of the
;	following ways:
;	    1) no device-dependent interaction,
;	    2) table driven through mode-dependent data vectors, or
;	    3) calls mode-dependent routines through function vectors.
;
;	Mode-dependent graphics functions and initializers for vectors
;	are segregated in separate modules for better granularity.
;
;******************************************************************************

	INCLUDE switch.inc	;switch file
	INCLUDE rmacros.inc

	USESEG	_BSS
	USESEG	_DATA
	USESEG	GR_TEXT 	

	INCLUDE seg.inc
	INCLUDE idmac.inc	
	INCLUDE grmac.inc	
	INCLUDE ibmunv.inc

sBegin	_BSS
;
;#***************************************************************************
; External variables
;#***************************************************************************
;
externW b$HugeDelta		;OS dependent selector increment
;
;#***************************************************************************
; Global variables
;#***************************************************************************
;
labelW	<PUBLIC,b$PenC>	;cursor "pen" is mask + attribute
globalB b$MaskC,,1		;  cursor mask byte
globalB b$AttrC,,1		;  each pixel in byte set to color attribute

labelD	<PUBLIC,b$AddrC>	;address of cursor in video memory
globalW b$OffC,,1		;  cursor address offset
globalW b$SegC,,1		;  cursor address segment

globalB b$PaintBorder,,1	;color attribute of PAINT border
globalB b$Tiling,,1		;tiling flag
globalW b$SaveCa,,1		;cursor values for first
globalB b$SaveCm,,1		;  non-border pixel during PAINT
globalB b$PlaneMask,,1 	;bit mask for Map Mask Reg for PUT

globalW b$Incr1,,1		;major axis update value for Line
globalW b$Incr2,,1		;minor axis update value for Line
globalW b$IncrY,,1		;change for Y movement for Line

globalW B$VTOFST,,1		;second row down from top of viewport
globalW B$VBOFST,,1		;bottom edge of viewport
globalW B$VLOFST,,1		;left edge of viewport and row 0
globalW B$VROFST,,1		;right edge of viewport and row 0
globalB B$VLMASK,,1		;corresponding mask for left edge
globalB B$VRMASK,,1		;corresponding mask for right edge
globalW B$LEOFST,,1		;left edge offset of viewport at current row
globalW B$REOFST,,1		;right edge offset of viewport at current row
globalB b$BorderColor,,1	;border color (overscan)
sEnd	_BSS			

sBegin	_DATA			
;
;#***************************************************************************
; Mode-dependent data and function vectors
;
; This data is filled by B$InitModeData from matching tables in the mode-
; dependent modules.  All are created using the same macro set to insure
; consistency in their structure and to provide a central point (the macros)
; for modifying that structure.  The "mEnd" macro actually builds the table.
; Specifying TRUE for its "def" (third) parameter causes it to also create
; PUBLIC names (prefixed with "b$") for each data item.  This also
; creates the GraphVectStart LABEL and GraphVectCnt ABSOLUTE used by
; B$InitModeData to reset the graphics function vectors for text modes.
;
; Refer to GRMAC.INC for more details on the actual structure and the
; variables provided.  To aid in the textual search for these names,
; omit the "b$" in the search.  This will locate all of the macro-generated
; sources for the data item in all the modules.  (e.g.: searching for
; "ScreenMode" instead of "b$ScreenMode" will find all of the "mScreenMode"
; macro invocations.)
;
;This data table is pre-initialized to resemble a 40-column (worst case)
;    text mode to account for its possible usage even before any screen mode
;    initialization takes place.  Function vectors are initialized to
;    B$ErrorReturn, which just sets the carry (as an error indication) and
;    returns.
;#***************************************************************************
;
mModeData	b$ModeData
mScreenMode	0
mBiosMode	0
mBurst		0
mScrWidth	40
mScrHeight	25
mHorzRes	320
mVertRes	200
mVideoBase	0B800H
mMaxAttr	15
mMaxColor	0
mPageSize	2		    ;page size in K
mCurrPSize	<(2*1024) shr 4>    ;page size in paragraphs
mMaxPage	0
mNullColor	7
mForeColor	7
mBackColor	0
mEgaWrMd	0
mInitPalette	0
mInitVgaPal	0
mAlphaDim	B$ErrorReturn
mSetMode	B$ErrorReturn
mSetPages	B$ErrorReturn
mPalReset	B$ErrorReturn
mPalPut 	B$ErrorReturn
mPalTrans	B$ErrorReturn
mPalSet 	B$ErrorReturn
mSetColor	B$ErrorReturn
mForeMapped	7
mBitsPerPixel	1
mPlanes 	1
mMapXYC 	B$ErrorReturn
mLeftC		B$ErrorReturn
mChkUpC 	B$ErrorReturn
mUpC		B$ErrorReturn
mChkDownC	B$ErrorReturn
mDownC		B$ErrorReturn
mSetAttr	B$ErrorReturn
mReadC		B$ErrorReturn
mSetC		B$ErrorReturn
mSetPixC	B$ErrorReturn
mSetPixFirstC	B$ErrorReturn
mSetPixLastC	B$ErrorReturn
mLineX		B$ErrorReturn
mLineY		B$ErrorReturn
mLineV		B$ErrorReturn
mPutAction	B$ErrorReturn
mNReadL 	B$ErrorReturn
mNWriteL	B$ErrorReturn
mNSetC		B$ErrorReturn
mPaintBound	B$ErrorReturn
mSetTile	B$ErrorReturn
mScanL		B$ErrorReturn
mScanR		B$ErrorReturn
mEnd		GraphDataLen,TextDataLen,TRUE
;
; End of table-initialized mode-dependent data
;
;#***************************************************************************
; Mode-dependent functions set-up and used by other mode-dependent functions
;	(see detailed descriptions below)
;#***************************************************************************
;
globalW b$PutVector,B$ErrorReturn,1	
;
;#***************************************************************************
; Mode-dependent variables are described in detail here
;#***************************************************************************
;

;***
;b$ScreenMode - Current Basic Screen Mode
;OEM-interface routine (variable)
;
;Purpose:
;	This variable contains the BASIC mode number of the current
;	screen mode.  This is the number as given in the SCREEN
;	statement, not the BIOS mode number.
;
;Allocated:
;	b$ScreenMode is a BYTE value allocated in _DATA by the OEM.
;
;Values:
;	This variable is initially set to 0 for a worst case scenario
;	when an error message has to be printed before the screen is
;	initialized.  After initialization, it may take on the value
;	of any legal screen mode (0-2, 7-13 if all possible modes are
;	supported).
;
;Initially Set:
;	b$ScreenMode is statically initialized to 0.
;
;Modified By:
;	This variable is only modified by the OEM-Dependent routines.
;	It should be updated when the screen is initialized, and when
;	a SCREEN statement is given.
;
;Used By:
;	This routine is used by the OEM-Dependent code to keep track
;	of which screen mode is current.  It is used by the OEM-Independent
;	Code to determine if a graphics mode is in effect.
;	(b$ScreenMode = 0 <=> non graphics mode)
;******************************************************************************

;
;#***************************************************************************
; Mode-dependent functions called indirectly are described in detail here
;#***************************************************************************
;

;*** 
; b$AlphaDim
;
;Purpose:
;	Validate the proposed text dimensions and establish mode-dependent
;	variables accordingly.	This routine may indicate that the
;	dimensions are invalid or unsupportable, or may request a change
;	in screen mode where the dimensions are supported.
;	NOTE:  No actual change in screen mode occurs until SetMode is called!
;
;Entry:
;	[BH] = number of lines
;	[BL] = number of columns
;
;Exit:
;	PSW.C = set if error
;	[AL] = -1 if dimensions set in current mode or error,
;	       otherwise AL is SCREEN mode to invoke for desired dimensions
;
;Uses:
;Exceptions:
;******************************************************************************

;
;*** 
; b$SetMode
;
;Purpose:
;	Set the screen mode according to the characteristics established
;	by previous calls to B$Screenx and b$AlphaDim
;
;Entry:
;Exit:
;Uses:
;Exceptions:
;******************************************************************************

;*** 
; b$SetPages
;
;Purpose:
;	Set the current active and visual pages and calculate page size
;	and video segment offsets.
;
;Entry:
;	[AL] = active page
;	[AH] = visual page
;
;Exit:
;Uses:
;Exceptions:
;******************************************************************************

;***
; b$PalReset - Reset PALETTE to default state.
;OEM-interface routine
;
;Purpose:
;	Reset the PALETTE to the initial, default colors.  This routine
;	is only called for the PALETTE command and when the screen modes
;	change (note: screen initialization is a mode change).
;
;	NOTE: b$PalReset is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	None
;
;Exit:
;	PSW.C is set to indicate an error.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;******************************************************************************

;***
; b$PalPut - Change palette entry
;OEM-interface routine
;
;Purpose:
;	Change palette entry with translation/verification.
;	A color value of negative one indicates that the associated
;	palette entry is not to be modified.
;
;	Before setting the palette, the color and attribute values
;	are verified as legal and translated, if necessary, to the
;	internal/hardware values.  Attribute values are seen by the
;	BASIC user as being contiguous, when in fact they may not
;	be.  Color values are similarly manipulated.
;
;	NOTE: b$PalPut is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	[DX:AX] = color
;	[BL]	= attribute
;
;Exit:
;	PSW.C reset indicates successful operation
;		set indicates PALETTE function call error
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;******************************************************************************

;***
; b$PalTrans
;
;Purpose:
;	User supplied color and attribute values are verified as legal
;	and translated, if necessary, to internal/hardware values.
;	Attribute values are seen by the BASIC user as being contiguous
;	from 0 to b$MaxAttr, when in fact they may not be.  This
;	routine vector provides the opportunity for modes to map from the
;	user supplied attribute to that which is actually used as a pixel
;	value in video memory or as a palette index.
;	Color values are similarly disguised and may also be manipulated
;	in support of different monitors.
;
;	NOTE: b$PalTrans is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	[DX:AX] = internal color
;	[BL]	= internal attribute
;
;Exit:
;	PSW.C reset if entry OK
;	[DX:AX] = actual color
;	[BL]	= actual attribute
;
;Uses:
;Exceptions:
;******************************************************************************

;***
; b$PalSet - Set entire palette from an array
;OEM-interface routine
;
;Purpose:
;	Set the entire palette from an array specified by the user.  Each
;	element of the array is a color value for the attribute which is
;	the current index of the array.   A color value of
;	of -1 indicates the entry should be left alone.  All entries are
;	verified before any are set and are also translated, as needed.
;	Verification and Translation are discussed in b$PalTrans (a non
;	OEM interface routine) and b$PalPut.
;
;	Special consideration must be made for the number of bytes per
;	element in the array.  Also, if there are not enough elements in
;	the array to fill the palette, the return with PSW.C set for
;	an Illegal Function Call.
;
;	NOTE: b$PalSet is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	[AX]	= size of the array in elements
;	[ES:SI] = address of the array
;	[CX]	= size of each array element in bytes (2 or 4)
;
;Exit:
;	PSW.C set indicates function call error
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;******************************************************************************

;***
; b$MapXYC - Map coordinates to graphics cursor
;OEM-interface routine
;
;Purpose:
;	Move the graphics cursor to the pixel specified by the given
;	coordinates.  Both coordinates will always be within the screen
;	boundaries and will already have been clipped to ensure that
;	they are within the viewport.
;
;	NOTE: b$MapXYC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	[CX] = X coordinate
;	[DX] = Y coordinate
;
;Exit:
;	Graphics Cursor location updated.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;******************************************************************************
;Our Exit Condition:
;	   b$OffC, b$MaskC updated


;***
; b$LeftC - Move graphics cursor left a pixel
;OEM-interface routine
;
;Purpose:
;	Move graphics cursor left 1 pixel.  No test is made for
;	screen boundaries.
;
;	NOTE: b$LeftC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	none
;
;Exit:
;	Graphics Cursor location updated.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;******************************************************************************
;Our Exit Condition:
;	   b$OffC, b$MaskC updated

;***
; b$ChkUpC - Move graphics cursor up a pixel, checking for upper boundary
;OEM-interface routine
;
;Purpose:
;	This routine will move the graphics cursor up one pixel if it
;	would stay within the viewport boundaries.  If this move would
;	make it leave the viewport, then PSW.C is set upon the return
;	and no move is made.  The viewport boundaries are specified by
;	a previous call to B$MapVWC.  Note that there does not have
;	to be a separate check for screen boundaries, as the viewport
;	defaults to the screen boundary.
;
;	NOTE: b$ChkUpc is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	None.
;
;Exit:
;	PSW.C = set if original graphics cursor was on screen top edge.
;	PSW.C = reset if cursor could move.  Graphics Cursor location updated.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;******************************************************************************
;Our Exit Condition:
;	   b$OffC, b$MaskC updated if cursor not on boundary.

;***
; b$UpC - Move graphics cursor up 1 pixel.
;OEM-interface routine
;
;Purpose:
;	Move graphics cursor up 1 pixel.  No test is made for
;	screen or viewport boundaries.
;
;	NOTE: b$UpC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	None
;
;Exit:
;	Graphics Cursor location updated.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;******************************************************************************
;Our Exit Condition:
;	   b$OffC, b$MaskC updated

;***
; b$ChkDownC - Move Graphics Cursor down a pixel, checking for bottom edge
;OEM-interface routine
;
;Purpose:
;	This routine will move the graphics cursor down one pixel if
;	it would stay within the viewport boundaries.  If this move
;	would make it leave the viewport, then PWS.C is set upon return
;	and no move is made.  The viewport boundaries are specified by
;	a previous call to B$MapVWC.  Note that there does not have
;	to be a separate check for screen boundaries, as the viewport
;	defaults to the screen boundary.
;
;	NOTE: b$ChkDownC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	None.
;
;Exit:
;	PSW.C = set    if original cursor was on screen edge.
;	PSW.C = reset  otherwise, Graphics Cursor moved
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;******************************************************************************
;Our Exit Condition:
;	   b$OffC, b$MaskC updated if not originally on boundary.

;***
; b$DownC - Move graphics cursor down a pixel
;OEM-interface routine
;
;Purpose:
;	Move graphics cursor down 1 pixel.  No test is made for
;	screen boundaries.
;
;	NOTE: b$DownC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	None.
;
;Exit:
;	Graphics Cursor location updated.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;******************************************************************************
;Our Exit Condition:
;	   b$OffC, b$MaskC updated

;***
; b$SetAttr - Set attribute value
;OEM-interface routine
;
;Purpose:
;	Map the supplied attribute value to that required for use by
;	the mode-dependent module.  If the value is legal, then update
;	the OEM state to indicate the new attribute to use.  Otherwise,
;	return with PSW.C set to indicate an error.
;
;	NOTE: b$SetAttr is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	[AL] = attribute
;
;Exit:
;	PSW.C = set indicates an error with the attribute value.
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX
;
;Exceptions:
;	None
;******************************************************************************

;***
; b$SetColor
;
;Purpose:
;	Process the COLOR statement.  Because different modes have different
;	reactions to the color statement parameters, they use the parameters
;	directly according to their mode-specific functions.
;
;	NOTE: b$SetColor is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	[SI] = address of the parameter list
;	[CX] = count of words in parameter list
;	(get parameters using B$GetParm)
;
;Exit:
;	PSW.C = set indicates that an error was encountered
;
;Uses:
;Exceptions:
;******************************************************************************

;***
; b$ReadC - Return attribute of current pixel
;OEM-interface routine
;
;Purpose:
;	Return the attribute of the current pixel as specified by
;	by the location of the graphics cursor.  This routine is
;	used by the BASIC function POINT().  The attribute that is
;	is returned should be in the form as it would be passed to
;	[b$SetAttr], not in an internal form.
;
;	NOTE: b$ReadC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	None
;
;Exit:
;	[AL] = attribute of pixel
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None
;******************************************************************************

;***
;b$SetC - Set pixel under graphics cursor to current attribute
;OEM-interface routine
;
;Purpose:
;	Set the pixel defined by the current graphics cursor to
;	the current attribute.
;
;	NOTE: b$SetC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	None
;
;Exit:
;	None
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None
;******************************************************************************

;***
; b$SetPixC - Set pixel under graphics cursor to current attribute (fast)
;OEM-interface routine
;
;Purpose:
;	Set the pixel defined by the current graphics cursor to
;	the current attribute.	This is identical to b$SetC with the
;	initialization and termination code extracted to make it
;	faster when multiple pixels are being set in a graphics
;	function (i.e. CIRCLE).  A call to b$SetPixFirstC should proceed
;	the first call to b$SetPixC.  A call to b$SetPixLastC should follow
;	the last.  b$SetPixFirstC sets up ES which should be preserved for
;	all b$SetPixC calls.
;
;	NOTE: b$SetPixC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	[ES] = the current video segment (set up by b$SetPixFirstC)
;
;Exit:
;	None
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;******************************************************************************

;***
; b$SetPixFirstC - Initialize for b$SetPixC
;OEM-interface routine
;
;Purpose:
;	Set up ES to the video segment and perform any other mode-dependent
;	functions required to optimize setting a number of pixels. A call
;	to b$SetPixFirstC should proceed the first call to b$SetPixC.
;
;	NOTE: b$SetPixFirstC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	None.
;
;Exit:
;	[ES] = video segment
;
;Uses:
;	ES is modified to point to the video segment
;
;Exceptions:
;	None.
;******************************************************************************

;***
; b$SetPixLastC - Termination for b$SetPixC
;OEM-interface routine
;
;Purpose:
;	Perform any mode-dependent functions required after setting a number
;	of pixels.  A call to b$SetPixLastC should follow the last call
;	to b$SetPixC.
;
;	NOTE: b$SetPixLastC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None.
;******************************************************************************

;***
; b$LineX
;
;Purpose:
;	Draw an X-major line.
;
;	NOTE: b$LineX is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	AH    = color (__AttrC)
;	AL    = bit accumulator (0)
;	CX    = point count
;	BH    = bit mask
;	DX    = BP change for Y movement (b$IncrY)
;	SI    = delta decision value
;	DI    = line style
;	BP    = video offset
;	ES    = video segment
;	Incr1 = major axis delta update value
;	Incr2 = minor axis delta update value
;	IncrY = BP change for Y movement
;
;Exit:
;Uses:
;Exceptions:
;******************************************************************************

;***
; b$LineY
;
;Purpose:
;	Draw a Y-major line.
;
;	NOTE: b$LineY is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	AH    = color (__AttrC)
;	CX    = point count
;	AL    = bit mask
;	DX    = BP change for Y movement (b$IncrY)
;	SI    = delta decision value
;	DI    = line style
;	BP    = video offset
;	ES    = video segment
;	Incr1 = major axis delta update value
;	Incr2 = minor axis delta update value
;	IncrY = BP change for Y movement
;
;Exit:
;Uses:
;Exceptions:
;******************************************************************************

;***
; b$LineV
;
;Purpose:
;	Draw a vertical line.
;
;	NOTE: b$LineV is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	AH    = color (__AttrC)
;	CX    = point count
;	AL    = bit mask
;	DX    = BP change for Y movement (b$IncrY)
;	DI    = line style
;	BP    = video offset
;	ES    = video segment
;	IncrY = BP change for Y movement
;
;Exit:
;Uses:
;	any
;Exceptions:
;******************************************************************************

;***
; b$PutAction
;
;Purpose:
;	Allow the mode-dependent module to established which PUT action
;	to apply for the next call to b$NWriteL.
;
;	NOTE: b$PutAction is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	AL = PUT action [0..4] represent (OR,AND,PRESET,PSET,XOR)
;
;Exit:
;Uses:
;	per convention
;
;Exceptions:
;******************************************************************************

;***
; b$NReadL
;
;Purpose:
;	Read a line of pixels from a specified plane to an array.
;
;	NOTE: b$NReadL is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	ES:DI	= screen address
;	DS:SI	= array address
;	CX	= array align shift count
;	BP	= count of bits (not pixels) to read
;	BH	= plane to read from
;
;Exit:
;	DS:SI	= updated to array byte past point filled
;
;Uses:
;Exceptions:
;******************************************************************************

;***
; b$NWriteL
;
;Purpose:
;	Write a line of pixels from an array to a specified plane.
;
;	NOTE: b$WriteL is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	ES:DI	= screen address
;	DS:SI	= array address
;	CX	= array align shift count
;	BP	= count of bits (not pixels) to write
;	BH	= plane to write to
;	DL	= last partial byte mask
;	DH	= first partial byte mask
;
;Exit:
;	DS:SI	= updated to array byte past point used
;
;Uses:
;Exceptions:
;******************************************************************************

;***
; b$NSetC - Set horizontal line of pixels
;OEM-interface routine
;
;Purpose:
;	Set a horizontal line of pixels to the current attribute.
;	The line starts at the current cursor position and moves right.
;	This routine need not check for the end of the screen.
;
;
;	NOTE: b$NSetC is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	[BX] = number of pixels to set
;
;Exit:
;	None
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;******************************************************************************

;***
; b$PaintBound - Setup for a scan line of PAINT
;OEM-interface routine
;
;Purpose:
;	Called by PAINT before painting each scan line, to
;	facilitate fast viewport edge detection.  This routine will
;	normally set VIEW left and right cursor addresses and masks.
;
;	The VIEW statement is handled primarily in the OEM independent
;	code but in the interest of speed, it is up to the OEM dependent
;	code to check for the edges of the viewport during painting.
;	The OEM is passed the pixel coordinates of the viewport in
;	a call to B$MapVWC, however converting from this form to
;	the internal representation may be too slow to do repeatedly.
;	Thus, for each row of a region that is going to be painted
;	[b$PaintBound] is called.  This routine should set up conditions
;	so that [b$ChkDownC], [b$ChkUpc], [b$ScanR], and [b$ScanL]
;	can do fast tests for detecting the edges of the viewport.
;
;	The calculations done by b$PaintBound are entirely up to the
;	OEM.  Note however, that the part of the screen that can be
;	changed by graphics statements after a VIEW statement includes
;	the "edges" that the user specified.  Thus VIEW(10,10)-(11,11)
;	has for pixels that can be changed by graphics statements.
;
;	NOTE: b$PaintBound is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	Graphics Cursor is positioned on line to be painted
;
;Exit:
;	Viewport left edge address of current row computed.
;	Viewport right edge address of current row computed.
;	Possible OEM state variables updated.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;******************************************************************************
;Our Entry Condition:
;	b$OffC = address of current pixel
;
;Our Exit Condition:
;	B$LEOFST = left edge offset
;	B$REOFST = right edge offset
;

;***
;  b$SetTile - Set tile attribute
;OEM-interface routine
;
;Purpose:
;	This routine stores the internal form of the current tile
;	attribute for a specific plane.  This routine is called
;	N times for each line to be tiled, where N is the number
;	of planes (actually the value returned by B$TILEMOD).	If
;	not all the bytes for multiple plane systems are specified
;	by the BASIC programmer [b$SetTile] will be called with
;	a value of 0 for the remaining planes.
;
;	The tile attribute should be aligned to the current graphics
;	cursor before actually setting pixels in [b$ScanR] or [b$ScanL].
;
;	NOTE: b$SetTile is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	[BL] = internal form of the tile attribute
;	[BH] = which plane the attribute is for
;
;Exit:
;	b$AttrC set to tile attribute
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None
;******************************************************************************

;***
;  b$ScanL - Paint pixels from cursor to the left
;OEM-interface routine
;
;Purpose:
;	Scan left beginning with the pixel to the left of cursor,
;	and paint pixels with the current attribute until:
;		(1) the viewport edge is encountered (edge painted)
;	     or (2) a border pixel is encountered (border not painted)
;
;	The border value is set in the call to B$PaintInit.  The viewport
;	edges are set when B$MapVWC is called.  Since this routine
;	is called multiple times for a single PAINT statement, it is
;	important that this routine be optimized for speed.  Any values
;	that can be precomputed should be done so in the routines
;	B$PaintInit and [b$PaintBound].
;
;	NOTE: b$ScanL is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	Graphics Cursor    = pixel to right of starting pixel
;Exit:
;	BX		   = number of pixels scanned
;	CL		   = 0 iff no pixels changed color
;	Graphics Cursor    = the last non-border pixel examined/painted
;
;Uses:
;	per convention
;
;Exceptions:
;	None
;******************************************************************************
;Our Entry Conditions:
;	b$PaintBorder	   = attribute of paint region border
;	b$AttrC	   = attribute to paint
;	B$LEOFST, B$VLMASK   = left viewport edge
;

;***
;  b$ScanR - Paint pixels from cursor to the right
;OEM-interface routine
;
;Purpose:
;	Starting with the current pixel, search right until:
;		(1) a non-border pixel is found
;		(2) [DX] pixels have been tested
;		(3) the viewport edge is encountered
;
;	If (2) or (3) terminated the scan, exit with:
;		DX = remaining border count   = 0
;		CL = pixels modified flag     = 0
;		BX = number of pixels painted = 0
;		Graphics Cursor returned to starting point.
;		Returned Cursor = Last cursor returned by [b$ScanR]
;
;	If (1) terminated the scan, start a new scan and paint non-border
;	pixels until:
;		(1) the viewport edge is encountered (edge painted)
;		(2) a border pixel is encountered (border not painted)
;
;	Return with:
;		DX = entry DX - # pixels searched before non-border found
;		CL = pixels modified flag
;		BX = number of pixels painted (even if no color change)
;		Graphics Cursor is at the last pixel examined
;			(either border or viewport edge)
;		Returned Cursor = Cursor Position at which the original
;				  scan was terminated.
;
;	NOTE: b$ScanR is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	DX		   = count of border pixels which may be skipped
;	Graphics Cursor    = starting pixel
;
;Exit:
;	BX		   = number of pixels painted
;				(whether or not they changed color)
;	CL		   = 0 iff no pixels changed color
;	DX		   = remaining border pixel count
;	Graphics Cursor    = the last non-border pixel examined/painted
;	AX, SI, DI	   = the first non-border pixel encountered
;			      AX = first byte of cursor
;			      SI = second byte of cursor
;			      DI = third byte of cursor
;Uses:
;	SI and DI are used for return values.
;
;Exceptions:
;	None
;******************************************************************************
;Our Entry Conditions:
;	b$PaintBorder	   = attribute of paint region border
;	b$AttrC	   = attribute to paint
;	B$REOFST, B$VRMASK   = right viewport edge
;

;***
; b$PutVector
;
;Purpose:
;	PUT action vectors. The PUT code vectors through this routine
;	to write bytes to the screen with the specified PUT action.
;	This vector is generally set up by the b$PutAction routine.
;
;	NOTE: b$PutVector is a variable through which the routine is
;	      indirectly called.
;
;Entry:
;	AH =	byte to write to screen.
;	DH =	mask
;	ES:DI = pointer to video memory
;
;Exit:
;	DI =	updated to point to next video byte
;
;Uses:
;Exceptions:
;******************************************************************************

sEnd	_DATA			

sBegin	GR_TEXT 		
	ASSUMES CS,GR_TEXT	

externNP B$GETDS		
externNP B$ErrorReturn 	

;*** 
; B$InitModeData
;
;Purpose:
;	Initialize mode-dependent data from a table.
;
;Entry:
;	CS:BX = pointer to table to match b$ModeData.
;	CX    = table length
;
;Exit:
;Uses:
;Exceptions:
;******************************************************************************

cProc	B$InitModeData,<PUBLIC,NEAR>,<SI,DI,DS,ES>
cBegin
	push	ds		;to DS:ModeData
	pop	es
	cmp	cx,TextDataLen	;a text entry?
	jne	InitTable	;go if not
	
	;when only the text data is initialized, set all of the graphics
	;function vectors to B$ErrorReturn which will just set carry
	;and return
	
	push	cx		
	mov	di,OFFSET DGROUP:GraphVectStart 
	mov	cx,GraphVectCnt 		
	mov	ax,GR_TEXTOFFSET B$ErrorReturn 
    rep stosw			
	pop	cx		
InitTable:
	mov	di,OFFSET DGROUP:b$ModeData
	push	cs		;from CS:BX
	pop	ds
	mov	si,bx
	cld
    rep movsb			;move it
; initialize foreground attribute to default
	push	es		
	pop	ds		;set DS=DGROUP for SetAttr
	mov	al,b$ForeColor ;get default foreground attribute
	call	[b$SetAttr]	;set attribute
	mov	b$BorderColor,0 ;clear border
cEnd


;***
; B$MapVWC - Change OEM viewport
;OEM-interface routine
;
;Purpose:
;	This routine is called each time the viewport is changed
;	to notify OEM dependent code of the current viewport
;	boundaries. Whenever B$MapVWC is called constants are
;	calculated and these constants will be used in other
;	OEM dependent routines to help speed up the PAINT routine.
;
;Entry:
;	[AX] = Minimum horizontal co-ordinate of viewport. (left edge)
;	[BX] = Maximum horizontal co-ordinate of viewport. (right edge)
;	[CX] = Minimum vertical co-ordinate of viewport. (top edge)
;	[DX] = Maximum vertical co-ordinate of viewport. (bottom edge)
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None.
;****
cProc	B$MapVWC,<PUBLIC,NEAR>,<DI>
cBegin
	PUSH	b$OffC 	;SAVE CURSOR OFFSET
	push	bx		;save viewport_right
	PUSH	AX
	XOR	AH,AH
	MOV	AL,b$MaskC	;SAVE CURSOR MASK
	MOV	DI,AX		;IN [DI]
	PUSH	DX		;SAVE DX, BCOS MAPXYC USES DX
	MOV	DX,CX		;get offset of (o,viewport-topedge)
	XOR	CX,CX
	CALL	[b$MapXYC]
	MOV	CX,b$OffC	;add b$BytesPerRow to this offset
	ADD	CX,b$BytesPerRow 
	MOV	B$VTOFST,CX	;and save in VTOFST (used in b$ChkUpC)
	POP	DX		;RESTORE DX
	XOR	CX,CX
	CALL	[b$MapXYC]	;get offset of (0,viewport-bottomedge)
	MOV	CX,b$OffC	;and svae it in VBOFST
	MOV	B$VBOFST,CX	;used in $TDOWNC
	POP	AX		;restore viewport_left
	MOV	CX,AX		;GET OFFSET AND MASK FOR THE
	XOR	DX,DX		;POINT (VIEWPORT_LEFT,0)
	CALL	[b$MapXYC]
	MOV	CX,b$OffC	;TRANSFER OFFSET AND MASK TO
	MOV	B$VLOFST,CX	;VLOFST AND VLMASK
	MOV	CL,b$MaskC
	MOV	B$VLMASK,CL
	pop	bx		;restore viewport_right
	MOV	CX,BX		;GET OFFSET AND MASK FOR THE
	XOR	DX,DX		;POINT (VIEWPORT_RIGHT,0)
	CALL	[b$MapXYC]
	MOV	CX,b$OffC	;TRANSFER OFFSET AND MASK TO
	MOV	B$VROFST,CX	;VROFST AND VRMASK
	MOV	CL,b$MaskC
	MOV	B$VRMASK,CL
	MOV	AX,DI		;RESTOR OLD CURSOR MASK
	MOV	b$MaskC,AL	;AND STORE IT BACK IN b$MaskC
	POP	b$OffC 	;RESTORE OLD OFFSET
cEnd

;***
; B$GetAspect - Get screen aspect ratio
;OEM-interface routine
;
;Purpose:
;	Return the screen aspect ratio.  Aspect ratio is used by CIRCLE
;	and DRAW to compensate for the possibility that pixels are of
;	unequal dimensions.  The ratio is returned as a fraction of 256.
;
;Entry:
;	None.
;
;Exit:
;	BX = 256 * aspect ratio
;	DX = 256 / aspect ratio
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, CX
;
;Exceptions:
;	None.
;****
cProc	B$GetAspect,<PUBLIC,NEAR>
cBegin
	MOV	BX,b$Aspect	;get aspect ratio
	MOV	DX,b$AspectInv ;get inverse aspect ratio
cEnd

;***
;B$BumpDS - Advances array segment in DS to next valid segment
;
;Purpose:
;	This routine is called by the low level PUT code when it is
;	detected that an indexed PUT has crossed a segment boundary
;	This routine knows that the Low Levels access the array through
;	DS.  It will advance the selector to the next legal 64K chunk.
;
;Entry:
;	DS = Array segment
;
;Exit:
;	DS = Next 64K Array segment
;
;Uses:
;	None!
;
;Exceptions:
;	None.
;****
cProc	B$BumpDS,<PUBLIC,NEAR>,<AX>	
cBegin
	MOV	AX,DS		;save array selector
.erre	ID_SSEQDS		;assumes ss = ds
	add	ax,ss:b$HugeDelta ;add in HUGE segment delta
	MOV	DS,AX		;update DS
cEnd

;***
;B$BumpES - Advances array segment in ES to next valid segment
;
;Purpose:
;	This routine is called by the low level GET code when it is
;	detected that an indexed GET has crossed a segment boundary
;	This routine knows that the Low Levels access the array through
;	ES.  It will advance the selector to the next legal 64K chunk.
;	Added with [10].
;
;Entry:
;	ES = Array segment
;
;Exit:
;	ES = Next 64K Array segment
;
;Uses:
;	None!
;
;Exceptions:
;	None.
;****
cProc	B$BumpES,<PUBLIC,NEAR>,<AX>
cBegin
	MOV	AX,ES		;save array selector
.erre	ID_SSEQDS		;assumes ss = ds
	add	ax,ss:b$HugeDelta ;add in HUGE segment delta
	MOV	ES,AX		;update ES
cEnd

;***
;B$DecDS - Decrements array segment in DS to prev valid segment
;
;Purpose:
;	This routine has the opposite effect of B$BumpDS.
;	Added with [10].
;
;Entry:
;	DS = Array segment
;
;Exit:
;	DS = Prev 64K Array segment
;
;Uses:
;	None!
;
;Exceptions:
;	None.
;****
cProc	B$DecDS,<PUBLIC,NEAR>,<AX>
cBegin
	MOV	AX,DS		;save array selector
.erre	ID_SSEQDS		;assumes ss = ds
	sub	ax,ss:b$HugeDelta ;sub HUGE segment delta
	MOV	DS,AX		;update DS
cEnd

;***
; B$OutWord
;
;Purpose:
;	Output the word in AX to the port at DX.  This is equivalent
;	to "OUT DX,AX" except that AH and AL are swapped when done.
;	This routine exists to support machines (specifically the
;	ATT 6300+) whose word output capability malfunctions.
;
;Entry:
;	[DX] = address of output port
;	[AX] = output data
;
;Exit:
;Uses:
;Exceptions:
;****
cProc	B$OutWord,<PUBLIC,NEAR>
cBegin
	OUT	DX,AL		;set index register
	XCHG	AL,AH		;set up data in AL
	INC	DX		;data port is one byte above index register
	OUT	DX,AL		;set up data in relevant register
	DEC	DX		;restore address of index register
cEnd

;***
; B$ResetEGA
;
;Purpose:
;	To reset EGA Registers to values expected by the BIOS.
;
;Entry:
;Exit:
;
;Uses:
;	none
;
;Exceptions:
;****
cProc	B$ResetEGA,<PUBLIC,NEAR>,<AX,DX>
cBegin
	MOV	DX,SEQADD
	
	;converted OutWord macros to in-line byte outs here for speed
	
	MOV	AL,MMREG	;enables all planes for 32-bit write
	OUT	DX,AL
	INC	DX
	MOV	AL,0FH
	OUT	DX,AL
	MOV	DX,GRPADD	;address of graphics index register
	MOV	AL,ENBREG	;make sure Set/Reset is NOT enabled
	OUT	DX,AL
	INC	DX
	XOR	AL,AL
	OUT	DX,AL
	DEC	DX
	MOV	AL,CLCREG	;select color compare register, and set color 0
	OUT	DX,AL
	INC	DX
	XOR	AL,AL
	OUT	DX,AL
	DEC	DX
	MOV	AX,DTRREG	;reset logical operations
	OUT	DX,AL
	INC	DX
	XOR	AL,AL
	OUT	DX,AL
	DEC	DX
	MOV	AL,BMKREG	;activate all bits in the mask
	OUT	DX,AL
	INC	DX
	MOV	AL,0FFH
	OUT	DX,AL
	DEC	DX
	MOV	AL,CDCREG	;Color Don't Care Register
	OUT	DX,AL
	INC	DX
	MOV	AL,0FH
	OUT	DX,AL
	DEC	DX
	MOV	AL,RWMREG	;index to Mode Register
	OUT	DX,AL
	INC	DX
	MOV	AL,b$EgaWrMd	;then set bit 4 for odd/even addressing
	AND	AL,10H		;use only odd/even bit
	OUT	DX,AL
cEnd

sEnd	GR_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llega.asm ===
TITLE		LLEGA - EGA screen mode support
;***
;LLEGA - EGA screen mode support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Support for EGA graphics screen modes (BIOS D,E,F,10).
;	Note that this module module contains support
;	code for all adapters capable of handling these
;	screen modes and also attempts to compensate for
;	the subtle differences in their treatment.
;
;	This module sets hooks in the mode-independent
;	modules to routines here for mode-dependent
;	graphics support.  See the mode-independent
;	modules for more precise descriptions of the
;	purposes and interfaces of these routines.
;
;	The following table summarizes the information for
;	the modes and configurations covered:
;
;    C		  |	A			     B
;    O		  |  B	T			     I
;    L		  |  I	T		 P	     T
;    O	     A	M |  O	R		 A    C      S
;  S R	     D	O |  S	I    C		 G    H      / P
;  C B	     A	N |	B    O		 E    A   P  P L
;  R U	C  R P	I |  M	U    L	 X   Y	 S    R   A  I A
;  E R	O  O T	T |  O	T    O	 R   R	 I    B   G  X N
;  E S	L  W E	O |  D	E    R	 E   E	 Z    O   E  E E
;  N T	S  S R	R |  E	S    S	 S   S	 E    X   S  L S
; -- - -- -- - -- | -- --- ---- --- --- --- ---- --- - -
;  7 x 40 25 E	C |  D	16  16	320 200  32 8x8  (2) 1 4
;  7 x 40 25 E	E |  "   "   "   "   "    "  "    "  " "
;  7 x 40 25 S	x |  "   "   "   "   "    "  "    "  " "
;
;  8 x 80 25 E	C |  E	16  16	640 200  64 8x8  (2) 1 4
;  8 x 80 25 E	E |  "   "   "   "   "    "  "    "  " "
;  8 x 80 25 S	x |  "   "   "   "   "    "  "    "  " "
;
;  9 x 80 25 E	E | 10	 4  64	640 350  64 8x14  1  1 2  (64K video memory)
;  9 x 80 43 E	E |  "   "   "   "   "    " 8x8   "  " "
;
;  9 x 80 25 E	E | 10	16  64	640 350 128 8x14 (2) 1 4  (>64K video memory)
;  9 x 80 25 S	x |  "   "   "   "   "    "  "    "  " "
;  9 x 80 43 E	E |  "   "   "   "   "    " 8x8   "  " "
;  9 x 80 43 S	x |  "   "   "   "   "    "  "    "  " "
;
; 10 x 80 25 E	M |  F	 4   9	640 350  64 8x14 (1) 1 2  (>64K video memory)
; 10 x 80 25 S	x |  "   "   "   "   "    "  "    "  " "
; 10 x 80 43 E	M |  "   "   "   "   "    " 8x8   "  " "
; 10 x 80 43 S	x |  "   "   "   "   "    "  "    "  " "
;
;-----------------------------------------------------------------------
;NOTES:  (1) PAGES = <video memory> / 2 / PAGESIZE (max 8 pages)
;	 (2) PAGES = <video memory> / PAGESIZE	   (max 8 pages)
;-----------------------------------------------------------------------
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_DATA
	USESEG	_BSS
	USESEG	GR_TEXT
	USESEG	CN_TEXT
	USESEG	XIB		
	USESEG	XI		
	USESEG	XIE		

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE baslibma.inc
	INCLUDE llgrp.inc	; Constant definitions
	INCLUDE idmac.inc
	INCLUDE grmac.inc	;ModeData macros

	INITIALIZER B$xINITEGA	;Put B$xINITEGA in initializer list


sBegin	_BSS
;
; ***************************************************************************
; External function vectors
; ***************************************************************************
;
externW b$PutVector
externW b$PalPut
externW b$SetAttr		
;
; ***************************************************************************
; External variables
; ***************************************************************************
;
externB b$BiosMode
externB b$Adapter
externB b$Monitor
externW b$VideoMem
externW b$CurPages
externW b$VideoBase
externB b$MaskC
externB b$AttrC
externW b$PenC 		
externW b$OffC
externW b$SegC
externB b$MaxAttr
externB b$MaxColor
externW B$LEOFST
externW B$REOFST
externB B$VLMASK
externB B$VRMASK
externB b$ForeColor
externB b$PageSize
externW b$CurrPSize
externB b$ScrHeight
externB b$MaxPage
externB b$Tiling
externB b$ForeMapped		
externW b$CURSOR		
externW b$CSRTYP		
externW b$SaveCa
externB b$SaveCm
externB b$PlaneMask
externW b$ScreenTab		

;
; ***************************************************************************
; Local variables
; ***************************************************************************
;
staticB MapMask,,1		;bit mask for Map Mask Register odd/even map
staticB BasePlane,,1		;base plane for odd/even modes
sEnd	_BSS

sBegin	CN_TEXT
externNP B$USRCSR		
sEnd	CN_TEXT

assumes CS,GR_TEXT
sBegin	GR_TEXT

externNP B$OutWord
externNP B$BumpDS
externNP B$BumpES		
externNP B$InitModeData
externNP B$GetParm
externNP b$ColorPalette	
externNP b$EnhPalette		
externNP B$EgaPalReset
externNP B$EgaPalResetB	
externNP B$EgaPalPut
externNP B$EgaPalTrans
externNP B$EgaPalSet
externNP B$EgaMapXYC
externNP B$EgaMapXYC_D
externNP B$EgaLeftC
externNP B$EgaChkUpC
externNP B$EgaUpC
externNP B$EgaChkDownC
externNP B$EgaDownC
externNP B$EgaSetAttr
externNP B$EgaReadC
externNP B$EgaReadC_F
externNP B$EgaReadC_64K
externNP B$EgaSetC
externNP B$EgaSetPixC
externNP B$EgaSetPixFirstC
externNP B$ResetEGA
externNP B$EgaLineX
externNP B$EgaLineY
externNP B$EgaLineV
externNP B$EgaPutAction
externNP B$EgaPutAction_F
externNP B$EgaPutAction_64K
externNP B$EgaNReadL
externNP B$EgaNReadL_F
externNP B$EgaNWriteL
externNP B$EgaNWriteL_F
externNP B$EgaNSetC
externNP B$EgaPaintBound
externNP B$EgaPaintBound_D
externNP B$EgaSetTile
externNP B$EgaScanL
externNP B$EgaScanR
externNP B$EgaCHKBTL
externNP B$EgaCHKBTR
externNP B$EgaPAINPX
externNP B$EgaPIXCNT
externNP B$EgaScanInit
externNP B$EgaSETCMP
externNP B$EgaTILLFT
externNP B$EgaTILRGT

;===========================================================================
mModeData	ModeDData
;
; SCREEN 7, BIOS mode D
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	7
mBiosMode	0DH
mBurst		0
mScrWidth	40
mScrHeight	25
mHorzRes	320
mVertRes	200
mVideoBase	0A000H
mMaxAttr	15
mMaxColor	15
mPageSize	32		    ;page size in K
mCurrPSize	<(32/4*1024) shr 4> ;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	15
mBackColor	0
mEgaWrMd	2
mInitPalette	b$ColorPalette 	;moved to LLXGASUP for sharing
mInitVgaPal	b$VgaPalette		
mAlphaDim	AlphaDim_D
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$EgaPalReset
mPalPut 	B$EgaPalPut
mPalTrans	B$EgaPalTrans	
mPalSet 	B$EgaPalSet
mSetColor	SetColor
mForeMapped	15
mBitsPerPixel	1
mPlanes 	4
mMapXYC 	B$EgaMapXYC_D
mLeftC		B$EgaLeftC
mChkUpC 	B$EgaChkUpC
mUpC		B$EgaUpC
mChkDownC	B$EgaChkDownC
mDownC		B$EgaDownC
mSetAttr	B$EgaSetAttr
mReadC		B$EgaReadC
mSetC		B$EgaSetC
mSetPixC	B$EgaSetPixC
mSetPixFirstC	B$EgaSetPixFirstC
mSetPixLastC	B$ResetEGA
mLineX		B$EgaLineX
mLineY		B$EgaLineY
mLineV		B$EgaLineV
mPutAction	B$EgaPutAction
mNReadL 	B$EgaNReadL
mNWriteL	B$EgaNWriteL
mNSetC		B$EgaNSetC
mPaintBound	B$EgaPaintBound_D
mSetTile	B$EgaSetTile
mScanL		B$EgaScanL
mScanR		B$EgaScanR
mEnd		GraphDataLen
;===========================================================================

;===========================================================================
mModeData	ModeEData
;
; SCREEN 8, BIOS mode E
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	8
mBiosMode	0EH
mBurst		0
mScrWidth	80
mScrHeight	25
mHorzRes	640
mVertRes	200
mVideoBase	0A000H
mMaxAttr	15
mMaxColor	15
mPageSize	64		    ;page size in K
mCurrPSize	<(64/4*1024) shr 4> ;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	15
mBackColor	0
mEgaWrMd	2
mInitPalette	b$ColorPalette 	;moved to LLXGASUP for sharing
mInitVgaPal	b$VgaPalette
mAlphaDim	AlphaDim_E
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$EgaPalReset
mPalPut 	B$EgaPalPut
mPalTrans	B$EgaPalTrans	
mPalSet 	B$EgaPalSet
mSetColor	SetColor
mForeMapped	15
mBitsPerPixel	1
mPlanes 	4
mMapXYC 	B$EgaMapXYC
mLeftC		B$EgaLeftC
mChkUpC 	B$EgaChkUpC
mUpC		B$EgaUpC
mChkDownC	B$EgaChkDownC
mDownC		B$EgaDownC
mSetAttr	B$EgaSetAttr
mReadC		B$EgaReadC
mSetC		B$EgaSetC
mSetPixC	B$EgaSetPixC
mSetPixFirstC	B$EgaSetPixFirstC
mSetPixLastC	B$ResetEGA
mLineX		B$EgaLineX
mLineY		B$EgaLineY
mLineV		B$EgaLineV
mPutAction	B$EgaPutAction
mNReadL 	B$EgaNReadL
mNWriteL	B$EgaNWriteL
mNSetC		B$EgaNSetC
mPaintBound	B$EgaPaintBound
mSetTile	B$EgaSetTile
mScanL		B$EgaScanL
mScanR		B$EgaScanR
mEnd		GraphDataLen
;===========================================================================

;===========================================================================
mModeData	ModeFData
;
; SCREEN 10, BIOS mode F (with > 64K video memory>
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	10
mBiosMode	0FH
mBurst		0
mScrWidth	80
mScrHeight	25
mHorzRes	640
mVertRes	350
mVideoBase	0A000H
mMaxAttr	3
mMaxColor	8
mPageSize	64		    ;page size in K
mCurrPSize	<(64/2*1024) shr 4> ;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	3
mBackColor	0
mEgaWrMd	2		    ;no even/odd with > 64K
mInitPalette	ModeFPalette
mInitVgaPal	0			;not applicable
mAlphaDim	AlphaDim_F
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$EgaPalResetB
mPalPut 	PalPut_F
mPalTrans	PalTrans_F
mPalSet 	B$EgaPalSet
mSetColor	SetColor
mForeMapped	5		    ;attr 3 maps to hardware attr 5
mBitsPerPixel	1
mPlanes 	2
mMapXYC 	B$EgaMapXYC
mLeftC		B$EgaLeftC
mChkUpC 	B$EgaChkUpC
mUpC		B$EgaUpC
mChkDownC	B$EgaChkDownC
mDownC		B$EgaDownC
mSetAttr	SetAttr_F_10_64K
mReadC		B$EgaReadC_F
mSetC		B$EgaSetC
mSetPixC	B$EgaSetPixC
mSetPixFirstC	B$EgaSetPixFirstC
mSetPixLastC	B$ResetEGA
mLineX		B$EgaLineX
mLineY		B$EgaLineY
mLineV		B$EgaLineV
mPutAction	B$EgaPutAction_F
mNReadL 	B$EgaNReadL_F
mNWriteL	B$EgaNWriteL_F
mNSetC		B$EgaNSetC
mPaintBound	B$EgaPaintBound
mSetTile	B$EgaSetTile
mScanL		ScanLX
mScanR		ScanRX
mEnd		GraphDataLen
;===========================================================================

;===========================================================================
mModeData	ModeFData_64K
;
; SCREEN 10, BIOS mode F with 64K video memory
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	10
mBiosMode	0FH
mBurst		0
mScrWidth	80
mScrHeight	25
mHorzRes	640
mVertRes	350
mVideoBase	0A000H
mMaxAttr	3
mMaxColor	8
mPageSize	64		    ;page size in K
mCurrPSize	<(64/2*1024) shr 4> ;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	3
mBackColor	0
mEgaWrMd	12H
mInitPalette	ModeFPalette
mInitVgaPal	0			;not applicable
mAlphaDim	AlphaDim_F
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$EgaPalResetB
mPalPut 	PalPut_F
mPalTrans	PalTrans_F
mPalSet 	B$EgaPalSet
mSetColor	SetColor
mForeMapped	5		    ;attr 3 maps to hardware attr 5
mBitsPerPixel	1
mPlanes 	2
mMapXYC 	B$EgaMapXYC
mLeftC		B$EgaLeftC
mChkUpC 	B$EgaChkUpC
mUpC		B$EgaUpC
mChkDownC	B$EgaChkDownC
mDownC		B$EgaDownC
mSetAttr	SetAttr_F_10_64K
mReadC		B$EgaReadC_64K
mSetC		B$EgaSetC
mSetPixC	B$EgaSetPixC
mSetPixFirstC	B$EgaSetPixFirstC
mSetPixLastC	B$ResetEGA
mLineX		B$EgaLineX
mLineY		B$EgaLineY
mLineV		B$EgaLineV
mPutAction	B$EgaPutAction_64K
mNReadL 	NReadL_64K
mNWriteL	NWriteL_64K
mNSetC		B$EgaNSetC
mPaintBound	B$EgaPaintBound
mSetTile	B$EgaSetTile
mScanL		ScanLX
mScanR		ScanRX
mEnd		GraphDataLen
;===========================================================================

;===========================================================================
mModeData	Mode10Data
;
; SCREEN 9, BIOS mode 10 (with > 64K video memory)
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	9
mBiosMode	10H
mBurst		0
mScrWidth	80
mScrHeight	25
mHorzRes	640
mVertRes	350
mVideoBase	0A000H
mMaxAttr	15
mMaxColor	63
mPageSize	128		    ;page size in K
mCurrPSize	<(128/4*1024) shr 4>;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	15
mBackColor	0
mEgaWrMd	2
mInitPalette	b$EnhPalette		;moved to LLXGASUP for sharing
mInitVgaPal	b$VgaPalette		
mAlphaDim	AlphaDim_10
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$EgaPalReset
mPalPut 	B$EgaPalPut
mPalTrans	B$EgaPalTrans
mPalSet 	B$EgaPalSet
mSetColor	SetColor
mForeMapped	15
mBitsPerPixel	1
mPlanes 	4
mMapXYC 	B$EgaMapXYC
mLeftC		B$EgaLeftC
mChkUpC 	B$EgaChkUpC
mUpC		B$EgaUpC
mChkDownC	B$EgaChkDownC
mDownC		B$EgaDownC
mSetAttr	B$EgaSetAttr
mReadC		B$EgaReadC
mSetC		B$EgaSetC
mSetPixC	B$EgaSetPixC
mSetPixFirstC	B$EgaSetPixFirstC
mSetPixLastC	B$ResetEGA
mLineX		B$EgaLineX
mLineY		B$EgaLineY
mLineV		B$EgaLineV
mPutAction	B$EgaPutAction
mNReadL 	B$EgaNReadL
mNWriteL	B$EgaNWriteL
mNSetC		B$EgaNSetC
mPaintBound	B$EgaPaintBound
mSetTile	B$EgaSetTile
mScanL		B$EgaScanL
mScanR		B$EgaScanR
mEnd		GraphDataLen
;===========================================================================

;===========================================================================
mModeData	Mode10Data_64K
;
; SCREEN 9, BIOS mode 10 (with 64K video memory)
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	9
mBiosMode	10H
mBurst		0
mScrWidth	80
mScrHeight	25
mHorzRes	640
mVertRes	350
mVideoBase	0A000H
mMaxAttr	3
mMaxColor	63
mPageSize	64		    ;page size in K
mCurrPSize	<(64/2*1024) shr 4> ;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	3
mBackColor	0
mEgaWrMd	12H
mInitPalette	Mode10Palette_64K
mInitVgaPal	Mode10VgaPal_64K	
mAlphaDim	AlphaDim_10
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$EgaPalReset
mPalPut 	B$EgaPalPut
mPalTrans	PalTrans_10_64K
mPalSet 	B$EgaPalSet
mSetColor	SetColor
mForeMapped	15			
mBitsPerPixel	1
mPlanes 	2
mMapXYC 	B$EgaMapXYC
mLeftC		B$EgaLeftC
mChkUpC 	B$EgaChkUpC
mUpC		B$EgaUpC
mChkDownC	B$EgaChkDownC
mDownC		B$EgaDownC
mSetAttr	SetAttr_F_10_64K
mReadC		B$EgaReadC_64K
mSetC		B$EgaSetC
mSetPixC	B$EgaSetPixC
mSetPixFirstC	B$EgaSetPixFirstC
mSetPixLastC	B$ResetEGA
mLineX		B$EgaLineX
mLineY		B$EgaLineY
mLineV		B$EgaLineV
mPutAction	B$EgaPutAction_64K
mNReadL 	NReadL_64K
mNWriteL	NWriteL_64K
mNSetC		B$EgaNSetC
mPaintBound	B$EgaPaintBound
mSetTile	B$EgaSetTile
mScanL		ScanLX
mScanR		ScanRX
mEnd		GraphDataLen
;===========================================================================

;
; ModeFPalette - used to initialize the EGA palette for SCREEN 10
;		 (BIOS mode F).
;
labelB	ModeFPalette		;EGA palette for BIOS mode 0FH
	;	RGBrgb
	DB	000000B 	;black
	DB	001000B 	;video
	DB	000000B 	;black
	DB	000000B 	;black
	DB	011000B 	;intensified
	DB	011000B 	;intensified
	DB	000000B 	;black
	DB	000000B 	;black
	DB	000000B 	;black
	DB	001000B 	;video
	DB	000000B 	;black
	DB	000000B 	;black
	DB	000000B 	;black
	DB	011000B 	;intensified
	DB	000000B 	;black
	DB	000000B 	;black
;
; Mode10Palette_64K - used to initialize the EGA palette for SCREEN 9
;		  (BIOS mode 10) with 64K of video memory.
;
labelB	Mode10Palette_64K	;EGA palette for BIOS mode 10H with only 64K
	;	RGBrgb
	DB	000000B 	;black
	DB	111011B 	;light cyan
	DB	000000B 	;black (not used)
	DB	000000B 	;black (not used)
	DB	111101B 	;light magenta
	DB	111111B 	;bright white
	;DB      10 DUP (0)      ;brown


labelNP <PUBLIC,B$EGAUSED>	

;*** 
; B$Screen7
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 7.
;Entry:
;	AL = screen mode (7)
;	AH = burst (0 or 1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen7,<PUBLIC,NEAR>
cBegin
	mov	bx,GR_TEXTOFFSET ModeDData  ;mode-specific data
	jmp	short ScrCommon2	    ;common routine
cEnd	<nogen>

;*** 
; B$Screen8
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 8.
;Entry:
;	AL = screen mode (8)
;	AH = burst (0 or 1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen8,<PUBLIC,NEAR>
cBegin
	mov	bx,GR_TEXTOFFSET ModeEData  ;mode-specific data
ScrCommon2:
	test	b$Monitor,AnalogColor + EnhColor + StdColor
				;check for monitor support
	je	ScrErr		;exit w/error if not supported
	jmp	short ScrCommon ;common routine
cEnd	<nogen>

;*** 
; B$Screen9
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 9.
;Entry:
;	AL = screen mode (9)
;	AH = burst (0 or 1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen9,<PUBLIC,NEAR>
cBegin
	test	b$Monitor,AnalogColor + EnhColor ;check for monitor support
	je	ScrErr		;exit w/error if not supported
	mov	bx,GR_TEXTOFFSET Mode10Data ;mode-specific data
	cmp	b$VideoMem,64	;check for mode 10 w/only 64K
	ja	ScrCommon	;go if greater, otherwise use diff table
	mov	bx,GR_TEXTOFFSET Mode10Data_64K ;mode-specific data
ScrCommon:
	test	b$Adapter,VGA + EGA ;check for adapter support
	je	ScrErr		;exit w/error if not supported
	mov	cx,GraphDataLen 
	call	B$InitModeData ;initialize table data
	mov	ax,b$VideoMem	;MaxPage = VideoMem / PageSize - 1
	div	b$PageSize	
	dec	al		;MaxPage = #pages-1
	mov	b$MaxPage,al
	clc			;indicate no error
cEnd

;*** 
; B$Screen10
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 10.
;Entry:
;	AL = screen mode (10)
;	AH = burst (0 or 1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen10,<PUBLIC,NEAR>
cBegin
	test	b$Monitor,AnalogMono + Monochrome ;check monitor support
	je	ScrErr		;exit w/error if not supported
	mov	bx,GR_TEXTOFFSET ModeFData  ;mode-specific data
	cmp	b$VideoMem,64	;check for mode F w/only 64K
	ja	Scr10Common	;go if greater, otherwise use diff table
	mov	bx,GR_TEXTOFFSET ModeFData_64K ;mode-specific data
Scr10Common:
	test	b$Adapter,VGA + EGA ;check for adapter support
	je	ScrErr		;exit w/error if not supported
	mov	cx,GraphDataLen 
	call	B$InitModeData ;initialize table data
	mov	ax,b$VideoMem	; MaxPage = VideoMem / 2 / PageSize - 1
	shr	ax,1		; divide VideoMem by 2
	div	b$PageSize	
	sub	al,1		;MaxPage = #pages-1
	adc	al,0		;if MaxPage < 0 (64K EGA), force back to 0
	mov	b$MaxPage,al
	clc			;indicate no error
	jmp	short ScrExit	
ScrErr:
	stc
ScrExit:			
cEnd

;***
; AlphaDim_D
;
;Purpose:
;	Validate the proposed text dimensions for Screen 7.
;	  If 40x25 is requested, this mode satisfies the request
;	  elseif 80x25 is requested, suggest screen mode 8
;	  else suggest screen mode 0.
;Entry:
;	BH = number of lines
;	BL = number of columns
;Exit:
;	AL = -1 if this mode satisfies the request, otherwise
;		AL is suggested screen mode to invoke for desired dimensions
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	AlphaDim_D
cProc	AlphaDim_D,<NEAR>
cBegin
	mov	al,-1		;flag request satisfied (maybe)
	cmp	bx,40+25*256	;40x25?
	je	ADimSet 	;exit if so, standard stuff
	mov	al,8		;prepare request for screen 8, JIC
	cmp	bx,80+25*256	;80x25?
	je	ADimDOk 	;exit if so, try screen 8
	xor	al,al		;flag request for screen 0
ADimDOk:
cEnd

;***
; AlphaDim_F
;
;Purpose:
;	Validate the proposed text dimensions for Screen 10.
;	  If 40 columns are requested, treat as if 80 were requested.
;	  Fall through to AlphaDim_10 for validation.
;Entry:
;	BL = number of lines
;	BH = number of columns
;Exit:
;	falls through to AlphaDim_10
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	AlphaDim_F
cProc	AlphaDim_F,<NEAR>
cBegin
	cmp	bl,40		;40 columns?
	jne	AlphaDim_10	;go if not, as if mode 10H
	mov	bl,80		;treat 40 as if request for 80
cEnd	<nogen> 		;fall thru to AlphaDim_10

;***
; AlphaDim_10/AlphaDim_E
;
;Purpose:
;	Validate the proposed text dimensions for Screen 9 or Screen 8,
;	depending on entry point.
;	  If 80x25 or 80x43 is requested, this mode satisfies the request
;	  elseif 40x25 is requested, suggest screen mode 7
;	  else suggest screen mode 0.
;Entry:
;	BL = number of lines
;	BH = number of columns
;Exit:
;	If this mode satisfies request
;	  AL = -1
;	  b$ScrHeight is set to value in BL
;	else
;	  AL = suggested screen mode to invoke for desired dimensions
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	AlphaDim_10
cProc	AlphaDim_10,<NEAR>
cBegin
	mov	al,-1		;flag request satisfied (maybe)
	cmp	bx,80+43*256	;80x43?
	je	ADimSet 	;exit if so, standard stuff

labelNP AlphaDim_E

	mov	al,-1		;flag request satisfied (maybe)
	cmp	bx,80+25*256	;80x25?
	je	ADimSet 	;exit if so, standard stuff
	mov	al,7		;prepare request for screen 7, JIC
	cmp	bx,40+25*256	;40x25?
	je	ADimOk		;exit if so, try screen 7
	xor	al,al		;flag request for screen 0
	jmp	short ADimOk	;  and exit
ADimSet:
	mov	b$ScrHeight,bh ;set alpha rows
ADimOk:
	clc			;no error
cEnd

;***
; SetMode
;
;Purpose:
;	Set EGA screen mode according to the characteristics established
;	by previous call to B$Screenx and b$AlphaDim.  Set 8x8 character
;	font if new mode is to be 43 lines.
;Entry:
;	b$BiosMode is mode to set
;	b$ScrHeight is number of lines
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	SetMode,<NEAR>
cBegin
	mov	al,b$BiosMode	;set BIOS mode
	SCNIO	vSetMode
	cmp	b$ScrHeight,43 ;43 lines?
	jne	SetMode25	;go if not
	mov	dl,43		; char gen call wants # of lines in DL
	mov	ax,1123H	;character generator request
	xor	bl,bl		;  to load 8x8 font
	SCNIO			;  which gets 43 lines
SetMode25:
	call	B$ResetEGA
	MOV	DX,b$CURSOR	; Get current cursor position
	MOV	BYTE PTR b$CSRTYP,-1 ; invalidate present cursor type so it
				; will get changed
	CALL	B$USRCSR	; display user cursor
cEnd

;***
; SetPages
;
;Purpose:
;	Set the current active and visual pages and calculate page size
;	and video segment offset for EGA modes.
;Entry:
;	AL = active page
;	AH = visual page
;Exit:
;	b$CurPages set to new active and visual pages.
;	b$SegC set to start of new active page.
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	SetPages,<NEAR>
cBegin
	mov	b$CurPages,ax	;save page numbers
	push	ax
	mov	al,ah
	SCNIO	vSelActivePage	;set visual page
	pop	ax
	cbw			;extend active page to word
	mul	b$CurrPSize	;times page size in paras
	add	ax,b$VideoBase ;set video segment
	mov	b$SegC,ax
cEnd

;***
; PalPut_F
;
;Purpose:
;	Change palette entry for Screen 10 with translation/verification.
;	A color value of -1 indicates that the associated palette
;	entry is not to be modified.
;Entry:
;	DX:AX = color
;	BL = attribute
;Exit:
;	PSW.C reset indicates successful operation
;		set indicates PALETTE function call error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	PalPut_F
cProc	PalPut_F,<NEAR>
cBegin
	cmp	ax,-1		;lo word of color == -1?
	jne	PalPut1 	;go if not, can't ignore
	cmp	dx,ax		;hi word too?
	je	PalPutExit	;exit if color == -1
PalPut1:			
	call	PalTrans_F	;translate to external form
	jc	PalPutExit	;exit if invalid w/error
	mov	bh,al		;BH:BL = color:attribute
	mov	al,bl		;ah:al = 2nd pair
	add	al,8
	push	ax		;save 2nd values in pair
	xor	al,al		;subfunction "Set Individual Palette Register"
	SCNIO	vSetEgaPalette
	pop	ax
	xchg	bx,ax		;2nd pair
	xor	al,al		;subfunction "Set Individual Palette Register"
	SCNIO	vSetEgaPalette
	clc			;no error
PalPutExit:
cEnd

labelW	TransF
	DB	0,0,0,8,0,24	;9 possible value pairs of mode 0FH
	DB	8,0,8,8,8,24	;0 - black, 8 - video, 18H - intensified
	DB	24,0,24,8,24,24

;***
; PalTrans_F
;
;Purpose:
;	Translate a user supplied attribute/color pair for Screen 10 to
;	the corresponding hardware values after verifying that they are
;	in the legal range.
;	    Attribute mapping:	0 --> 0
;				1 --> 1
;				2 --> 4
;				3 --> 5
;	    Color pair mapping per TransF table.
;Entry:
;	DX:AX = user supplied color value
;	BL    = user supplied attribute value
;Exit:
;	PSW.C set if illegal value, reset if Ok
;	AX = actual color pair value
;	BL = actual attribute value
;Uses:
;	per conv.
;Exceptions:
;	can exit through PalTrans_10_64K error exit.
;******************************************************************************
DbPub	PalTrans_F
cProc	PalTrans_F,<NEAR>
cBegin
	cmp	bl,b$MaxAttr	;is legal attribute ?
	ja	PalTrErr	;error return
	or	dh,dl		;hi 3 bytes of color must be 0
	or	dh,ah		
	jnz	PalTrErr	;error if not
	cmp	al,b$MaxColor	;is legal color ?
	ja	PalTrErr	;error return
	cmp	bl,2		;attributes 0 and 1 map directly
	jb	PalTrNxt	;go if so
	add	bl,2		;attribute 2 maps to 4, 3 to 5
PalTrNxt:
	push	di
	MOV	DI,GR_TEXTOFFSET TransF ;translate to color pair
	XOR	AH,AH
	SHL	AL,1		;word index
	ADD	DI,AX
	MOV	AX,CS:[DI]	;translate color AX to color pair AX
	pop	di
	clc			;no error
cEnd

;***
; PalTrans_10_64K
;
;Purpose:
;	Translate a user supplied attribute for Screen 9/64K to the
;	corresponding hardware value after verifying that the attribute
;	value and the color value are in the legal ranges.
;	    Attribute mapping:	0 --> 0
;				1 --> 1
;				2 --> 4
;				3 --> 5
;Entry:
;	DX:AX = user supplied color value
;	BL    = user supplied attribute value
;Exit:
;	PSW.C set if illegal value, reset if Ok
;	DX:AX = unchanged (user supplied color value)
;	BL    = actual attribute value
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	PalTrans_10_64K
cProc	PalTrans_10_64K,<NEAR>
cBegin
	call	B$EgaPalTrans	;check attribute and translate color
	jc	PalTrErr	;error return
	cmp	bl,2		;attributes 0 and 1 map directly
	jb	PalTrExit	;go if so
	add	bl,2		;attribute 2 maps to 4, 3 to 5
PalTrExit:
	clc			;no error
	ret
PalTrErr:
	STC			;indicate error
cEnd

labelB	AttrX
	DB	0,3,0CH,0FH	;map to 0,3,C,F for odd/even

;***
; SetAttr_F_10_64K
;
;Purpose:
;	Map attribute value to the value needed by odd/even mode functions.
;		0 --> 00
;		1 --> 03
;		2 --> 0C
;		3 --> 0F
;	If supplied attribute is outside legal range, use maximum legal value.
;Entry:
;	AL = attribute
;Exit:
;	b$Attr updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	SetAttr_F_10_64K
cProc	SetAttr_F_10_64K,<NEAR>,<AX,BX>
cBegin
	cmp	al,b$MaxAttr	;test against maximum attribute
	jbe	SetAttrXOk	;Brif legal
	mov	al,b$MaxAttr	;limit to max
SetAttrXOk:
	mov	bx,GR_TEXTOFFSET AttrX	;translate for odd/even mode
	xlat	cs:[bx]
	mov	b$AttrC,al
	clc			;exit no error
cEnd

;***
; SetColor
;
;Purpose:
;	Process the color statement for Bios modes 0Dh - 010h (BASIC Screen
;	modes 7-10).  Syntax for Screen 7-10 color statement is as follows:
;
;		COLOR	[foreground],[background]
;
;	where "foreground" is the attribute to be used for the foreground
;	  and "background" is the color to be used for the background
;
;	Any omitted parameter(s) indicate no change for that parameter.
;Entry:
;	parameter list
;		WORD 1 = flag 0 if param not present
;		WORD 2 = parameter if WORD 1 <> 0, else second param flag
;		etc.
;Exit:
;	PSW.C set if error, reset if Ok.
;	b$ForeColor is set to foreground attribute
;	b$ForeMapped is set to foreground attribute mapped to internal value
;
;Uses
;	per conv.
;Exceptions:
;*****************************************************************************
cProc	SetColor,<NEAR>
cBegin
	cCall	B$GetParm	;AL=foreground parameter
	mov	bh,b$ForeColor ;use old values as default
	mov	bl,b$ForeMapped
	jz	GotFore 	;go if none supplied
	cmp	b$MaxAttr,al	;check for valid range
	jc	SetColDun	;go if error
	push	ax		;save: unmapped attr [14]
	push	cx		;      param count
	push	b$PenC 	;  b$AttrC
	call	[b$SetAttr]	;translate the attribute
	mov	bl,b$AttrC	;translated attr in BL
	pop	b$PenC 	
	pop	cx
	pop	ax		;restore unmapped attr
	mov	bh,al		;unmapped attr to BH
GotFore:
	cCall	B$GetParm	;AL=background parameter
	jz	NoBack		;go if none supplied
	push	bx		;preserve foreground info
	xor	bx,bx		;attribute 0 is background
	cbw			;AX=color
	cwd			;DX:AX=color
	call	[b$PalPut]	;set background
	pop	bx
	jc	SetColDun	;go if error
NoBack:
	mov	b$ForeColor,bh ;save foreground values
	mov	b$ForeMapped,bl
	clc			;indicate no error
	jcxz	SetColDun	;if we got all params, thats true
	stc			;otherwise set error
SetColDun:
cEnd

;***
; PIXLF3
;Purpose:
;	Check for non-paint pixels left, odd/even EGA modes.
;	Look through entire range of non-border pixels right to left
;	to determine whether any will actually change color.
;	Use AL as Color Don't Care mask.
;
;	If using EGAINT10 interface, this routine must access the CDCReg
;	and perform the associated color compare read with ints disabled,
;	then reenable them to allow other processes to access the card
;	before the next byte is checked.  Since another process may have
;	modified the graphics chip index reg as well as the data reg, we
;	must send both index and data for each odd/even toggle.
;Entry:
;	SI = byte address of rightmost byte in range
;	BH = bit mask for leftmost byte
;	BL = bit mask for rightmost byte
;	DI = total number of whole bytes between first and last
;	ES = video segment
;Exit:
;	CL = 0 if no pixels found to change, non-zero if pixels to change
;Uses:
;	per conv.
;Exceptions:
;****
DbPub	PIXLF3
cProc	PIXLF3,<NEAR>,<DX>
cBegin
	MOV	DX,GRPADD	;index port for graphics register
	MOV	AL,LOW CDCREG	;specify Color Don't Care
	EGAINT10CLI		;disable ints if using EGAINT10
	OUT	DX,AL
	INC	DX
	MOV	AL,10101010B	;initially assume odd byte address
	TEST	SI,1
	JNZ	STMSKL		;if correct, set this mask
	ROR	AL,1		;else rotate for other pair of planes
STMSKL:
	OUT	DX,AL		;set up for initial color compare

;	read first byte

	MOV	CL,ES:[SI]	;bit pattern of first byte with 0's where
				;color not paint attribute
	AND	CL,BL		;AND now produces difference if non-paint
				;bit in significant position
	XOR	CL,BL		;for significant bits in our first byte (bit
				;set in BH), then non-paint will be one
	JNZ	SETBTL		;found a bit to change
	OR	BH,BH		;see if only one byte
	JZ	NOSETL		;nothing to paint
	OR	DI,DI		;see if only a "last byte"
	JZ	LSBYT3

;	Look at whole bytes within viewport range until non-paint color found.

LKPTL3:
	DEC	SI
	ROR	AL,1
	OUT	DX,AL		;set up opposite Don't Care planes each time
	MOV	CL,ES:[SI]
	EGAINT10STI		;read is done, reenable ints if EGAINT10
	NOT	CL		;check if all bits set (all paint color)
	OR	CL,CL		;NOT does not affect flags
	JNZ	SETBTL
	DEC	DI
	EGAINT10CLI		;disable ints for next OUTs (loop
				;	or fall through)
	JNZ	LKPTL3		;keep looking until search of complete
				;bytes is exhausted

;	On last byte now, mask in BH.

LSBYT3:
	DEC	SI
	ROR	AL,1
	OUT	DX,AL		;last Don't Care
	MOV	CL,ES:[SI]	;do last compare
	AND	CL,BH		;significant bit = 0 if not paint color
	XOR	CL,BH		;if different, non-paint pixel(s) present
	JNZ	SETBTL
NOSETL:
	XOR	CL,CL		;no bits to set, so zero pixels-changed flag
SETBTL:
	EGAINT10STI		;reenable ints at common exit
cEnd

;***
; PIXRT3
;Purpose:
;	Check for non-paint pixels right with odd/even EGA modes.
;	Look through entire range of non-border pixels left to right
;	to determine whether any will actually change color.
;	AL is used for Color Don't Care mask
;
;	If using EGAINT10 interface, this routine must access the CDCReg
;	and perform the associated color compare read with ints disabled,
;	then reenable them to allow other processes to access the card
;	before the next byte is checked.  Since another process may have
;	modified the graphics chip index reg as well as the data reg, we
;	must send both index and data for each odd/even toggle.
;Entry:
;	SI = byte address of leftmost byte in range
;	BH = bit mask for rightmost byte
;	BL = bit mask for leftmost byte
;	DI = total number of whole bytes -1
;	ES = video segment
;Exit:
;	CL = 0 if no pixels found to change, non-zero if pixels to change
;Uses:
;	per conv.
;Exceptions:
;****
DbPub	PIXRT3
cProc	PIXRT3,<NEAR>,<DX>
cBegin
	MOV	DX,GRPADD	;index port for graphics
	MOV	AL,LOW CDCREG	;set up for Color Don't Care register
	EGAINT10CLI		;disable ints if using EGAINT10
	OUT	DX,AL
	INC	DX
	MOV	AL,10101010B	;initially assume odd byte mask
	TEST	SI,1		;check whether first byte odd or even
	JNZ	SETMSK		;if odd, branch to set mask
	ROR	AL,1		;else rotate mask 1 right
SETMSK:
	OUT	DX,AL

;	read first byte

	MOV	CL,ES:[SI]	;bit pattern of first byte with 0's where
				;color not paint attribute
	AND	CL,BL		;AND now produces difference if non-paint
				;bit in significant position
	XOR	CL,BL		;for significant bits in our first byte (bit
				;set in BH), then non-paint will be one
	JNZ	PNTBIT		;found a bit to change
	OR	DI,DI		;any more bytes?
	JZ	PIXLAST 	;no full bytes, go try last


;	Look at whole bytes within viewport range until non-paint color found.

LKPTR3:
	INC	SI
	ROR	AL,1		;shift Don't Care mask
	OUT	DX,AL
	MOV	CL,ES:[SI]
	EGAINT10STI		;read is done, reenable ints if EGAINT10
	NOT	CL		;check if all bits set (all paint color)
	OR	CL,CL		;NOT does not affect flags
	JNZ	PNTBIT
	DEC	DI
	EGAINT10CLI		;disable ints for next OUTs (loop
				;	or fall through)
	JNZ	LKPTR3		;keep looking until search of complete
				;bytes is exhausted

;	On last byte now, mask in BH.
PIXLAST:			
	INC	SI
	ROR	AL,1
	OUT	DX,AL
	MOV	CL,ES:[SI]	;do last compare
	AND	CL,BH		;significant bit = 0 if not paint color
	XOR	CL,BH		;if different, non-paint color pixels
	JNZ	PNTBIT		;leave CL non-zero as flag
NOBTR3:
	XOR	CL,CL		;else zero the flag
PNTBIT:
	EGAINT10STI		;reenable ints at common exit
cEnd

;***
; ScanLX
;Purpose:
;	Scan left beginning with the pixel to the left of cursor,
;	and paint pixels until:
;		(1) the viewport edge is encounteered (edge painted)
;		(2) a border pixel is encountered (border not painted)
;
;	This version supports PAINT for the odd/even EGA modes (bios mode
;	10H with 64K of memory, and monochrome bios mode F).  It differs
;	from SCANL2 in its use of the Color Don't Care register in
;	conjunction with screen reads.	This is necessary because if the
;	planes representing the even bytes and those representing the odd
;	bytes are not disabled during color compares for odd and even bytes,
;	respectively, the color compare is made as the sum of the bits set
;	for each even byte and its odd successor, all four planes at one
;	address.
;Entry:
;	b$AddrC, b$MaskC = pixel to right of starting pixel
;	b$PaintBorder	   = attribute of paint region border
;	b$AttrC	   = attribute to paint
;	B$LEOFST, B$VLMASK   = left viewport edge
;Exit:
;	BX		   = number of pixels scanned
;	CL		   = 0 iff no pixels changed color
;	b$OffC, b$MaskC  = the last non-border pixel examined/painted
;Uses:
;	per conv.
;Exceptions:
;*****************************************************************************
DbPub	ScanLX
cProc	ScanLX,<NEAR>,<ES>
cBegin
	CALL	B$EgaScanInit
	ROL	CH,1		;see if cursor is left edge of byte
	JNB	VWBYT1		;if not, proceed to viewport checks
	DEC	SI		;if so, start next byte left
	JS	SCNOUT		;if negative, hit corner of screen
VWBYT1:				;start on-screen viewport checks
	CMP	SI,B$LEOFST	;see if off edge of viewport to left
	JNB	VWBYT2
SCNOUT:
	JMP	BRDEX3		;else do nothing, exit
VWBYT2:
	JNZ	NOTBYT		;if not edge byte, skip bit checks
	CMP	CH,B$VLMASK	;else check for pixel left too far and
	JNA	NOTBYT
	JMP	BRDEX3		;thus off viewport edge -- exit if so
NOTBYT:
	MOV	DI,SI		;extra copy of first byte address
	MOV	BL,CH		;extra copy of initial bit mask
	MOV	BP,-1		;this will be count of whole bytes
	XOR	AH,AH		;initialize this byte's viewport mask to 0

;	First task is to set up initial Color Don't Care mask depending
;	on whether first byte is odd or even.

	MOV	CL,10101010B	;initially assume odd byte -- 10101010
	TEST	SI,1
	JNZ	STCDC3
	ROR	CL,1		;if even, set up 01010101
STCDC3:
	MOV	DX,GRPADD
	MOV	AL,LOW CDCREG	;index to Color Don't Care register

	OUT	DX,AL
	INC	DX
	MOV	AL,CL
	OUT	DX,AL

;	read first byte off the screen

	MOV	AL,ES:[DI]
	EGAINT10STI		;read is done, reenable ints if EGAINT10
	TEST	AL,CH		;see whether initial pixel is border
	JZ	SRCLF3		;if not, start search left
	XOR	CL,CL		;else set pixels-changed flag back to 0
	MOV	BL,CL		;zero out 8-bit register used
	JMP	BRDEX3		;and exit gracefully
SRCLF3:

;	look for border or viewport in first byte

	CMP	DI,B$LEOFST	;is this in fact viewport edge byte?
	JNZ	NTVWL3
	MOV	AH,B$VLMASK	;if so, set up viewport mask in AH
NTVWL3:

;	while not border

	TEST	AL,CH
	JNZ	HAVPX3

;	and not viewport edge

	TEST	AH,CH
	JNZ	HAVPX3

;	and not off the edge of the byte

	ROL	CH,1
	JNB	NTVWL3

;	keep moving left - edge of first byte

	DEC	DI		;next byte address left
	INC	BP		;count of intermediate bytes
	ROR	CL,1		;rotate Color Don't Care mask
	MOV	AL,CL
	OUT	DX,AL
	MOV	AL,ES:[DI]	;read next byte left
	EGAINT10STI		;reenable ints between bytes if EGAINT10
	JMP	SHORT SRCLF3	;check next byte

;	Here when border or viewport edge found.
;	Set up bit mask for first (possibly only) byte
;	SI = rightmost byte
;	DI = leftmost byte (possibly same byte)
;	BL = mask for rightmost bit in rightmost byte

;	If viewport edge was found, AH will contain the viewport bit
;	mask, and DI is the viewport edge byte.  If SI=DI=viewport edge
;	byte, we need to retain the viewport mask in AH.  Otherwise
;	clear AH and fetch the mask again later if needed for DI.

HAVPX3:
	CMP	SI,B$LEOFST	;see if rightmost byte is LEFT viewport
	JZ	SINTV2		;if so, don't clear viewport mask
				; register
	XOR	AH,AH		;else clear AH for CHKBTL on
SINTV2:				; rightmost byte
	MOV	CH,BL		;initial bit position in CH
	MOV	CL,10101010B	;need to reset Color Don't Care mask
	TEST	SI,1		;see if odd byte
	JNZ	SISET
	ROR	CL,1
SISET:
	MOV	AL,CL
	OUT	DX,AL		;set up Color Don't Care
	MOV	AL,ES:[SI]	;get border bits if any
	XOR	DX,DX		;this will be #pixels painted
	CALL	B$EgaCHKBTL	;set up bit mask for first byte
	MOV	BL,BH		;store in BL
	XOR	BH,BH		;there may be only one byte

;	see if more than 1 byte to paint

	PUSH	SI		;save a copy of rightmost address
	INC	BP		;see if still -1
	JZ	ONEALN		;"one alone"
	DEC	BP		;if not, recover real value
	PUSH	DX		;store pixel count
	MOV	DX,GRPADD+1	;data port for Color Don't Care
	MOV	CL,10101010B	;assume mask 10101010
	TEST	DI,1		;check DI for odd or even address
	JNZ	DISET
	ROR	CL,1		;if even, set up 01010101
DISET:
	MOV	AL,CL
	OUT	DX,AL
	POP	DX		;restore pixel count
	MOV	AL,ES:[DI]	;get border bits if any
	MOV	CH,1		;set up mask for final byte
	CMP	DI,B$LEOFST	;was this viewport byte?
	JNZ	DINTV2		;no -- don't need viewport mask
	MOV	AH,B$VLMASK	;yes -- get viewport mask for CHKTBL
DINTV2:
	CALL	B$EgaCHKBTL	;set up leftmost byte bit mask in BH
ONEALN:
	MOV	b$OffC,DI
	MOV	b$MaskC,CH	;update cursor
	PUSH	DI		;save a copy of leftmost address
	MOV	DI,BP		;store whole byte count for PIXLFT
	CMP	b$Tiling,0	;see if tiling is on
	JZ	COLCM7
	CALL	B$EgaTILLFT
	JMP	SHORT COLCM8
COLCM7:
	CALL	B$EgaSETCMP	;set color compare register to paint attribute
	CALL	PIXLF3		;see whether any pixels in range will change
COLCM8:
	POP	SI		;restore leftmost address to SI
	POP	DI		;restore rightmost address to DI
	OR	CL,CL		;returns CL non-zero if changes needed
	JZ	BRDEX2

;	we found at least 1 pixel to change, so set entire range
;	set pixels-changed flag, set up write mode 2

	XOR	CH,CH
	NOT	CH		;set to FF as decrement flag
	STD			;for SCANL, decrement from DI
	CALL	B$EgaPAINPX
	CLD
BRDEX2:
	CALL	B$EgaPIXCNT	;returns # pixels "painted" in BX
BRDEX3:
	CALL	B$ResetEGA
cEnd

;***
; ScanRX
;Purpose:
;	Starting with the current pixel, search right until:
;		(1) a non-border pixel is found
;		(2) [DX] pixels have been tested
;		(3) the viewport edge is encountered
;
;	If (2) or (3) terminated the scan, exit with:
;		DX = remaining border bount = 0
;
;	If (1) terminated the scan, scan and paint non-border pixels until:
;		(1) the viewport edge is encountered (edge painted)
;		(2) a border pixel is encountered (border not painted)
;
;	This version supports PAINT for the odd/even EGA modes (bios mode
;	10H with 64K of memory, and monochrome bios mode F).  It differs
;	from SCANR2 in its use of the Color Don't Care register in
;	conjunction with screen reads.	This is necessary because if the
;	planes representing the even bytes and those representing the odd
;	bytes are not disabled during color compares for odd and even bytes,
;	respectively, the color compare is made as the sum of the bits set
;	for each even byte and its odd successor, all four planes at one
;	address.
;Entry:
;	DX		   = count of border pixels which may be skipped
;	b$AddrC, b$MaskC = starting pixel
;	b$PaintBorder	   = attribute of paint region border
;	b$AttrC	   = attribute to paint
;	B$REOFST, B$VRMASK   = right viewport edge
;Exit:
;	BX		   = number of pixels painted
;				(whether or not they changed color)
;	CL		   = 0 iff no pixels changed color
;	DX		   = remaining border pixel count
;	b$OffC, b$MaskC  = the last non-border pixel examined/painted
;	SI, AL		   = the first non-border pixel encountered
;Uses:
;	per conv.
;Exceptions:
;
;****************************************************************************
DbPub	ScanRX
cProc	ScanRX,<NEAR>,<ES>
cBegin
;	set up EGA registers for color compare read
;	point ES:[SI] to screen memory, b$MaskC in CH
;	CL = 0 (pixels changed flag)

	CALL	B$EgaScanInit	;setup

;	Initial task is to set up a mask for specifying which planes
;	we want to read when doing color compare reads.	For even bytes,
;	we need to specify 0's in bits 1 and 3 (color don't care planes
;	1 and 3), vice versa for odd bytes.  For convenience in coding,
;	we set up an 8-bit mask in CL and rotate right as we move across
;	the screen.

	MOV	BX,DX		;decrement BX instead of DX (needed for OUTs)
	MOV	CL,10101010B	;assume start mask 10101010
	TEST	SI,1		;check whether odd or even byte
	JNZ	COLCOM		;if odd, we're in business
	ROR	CL,1		;else 010101
COLCOM:
	MOV	DX,GRPADD	;address of index port
	MOV	AL,LOW CDCREG	;Color Don't Care register

	OUT	DX,AL
	INC	DX		;data port address
	MOV	AL,CL		;mask indicating planes to ignore (=0)
	OUT	DX,AL		;set up initial Color Don't Care planes

;	perform color compare on first byte

	MOV	AL,ES:[SI]	;bits set where border found
	EGAINT10STI		;read is done, reenable ints if EGAINT10

;	Starting at entry cursor, search right looking for non-border,
;	viewport edge, or end-of-byte as long as DX does not decrement to 0.

	XOR	AH,AH		;initialize viewport mask to 0
SRCRT3:
	CMP	SI,B$REOFST	;check whether we are in viewport edge byte
	JNZ	NOTVP3
	MOV	AH,B$VRMASK	;if so, get viewport edge mask
NOTVP3:

;	While border...

	TEST	AL,CH		;compare color compare mask with b$MaskC
	JZ	ENDRT3		;if pixel not border, exit loop

;	and not viewport edge...

	TEST	AH,CH		;compare viewport edge mask with b$MaskC
	JNZ	ENDRT3		;if edge found, exit

;	and BX is greater than 0...

	DEC	BX		;contains # pixels which can be skipped
	JZ	ENDRT3		;in search for non-border pixel

;	and not off the edge of the byte...

	ROR	CH,1		;shift bit mask right

;	repeat the search

	JNB	NOTVP3

;	end of first byte.

	INC	SI		;next byte address
	ROR	CL,1		;rotate mask for next Color Don't Care
	MOV	AL,CL
	OUT	DX,AL		;next compare with alternate planes disabled
	MOV	AL,ES:[SI]
	EGAINT10STI		;reenable ints between bytes if EGAINT10
	MOV	CH,80H		;mask now 1000/0000 for next search
	JMP	SHORT SRCRT3

;	either (not border) OR (viewport edge) OR (DX = 0)

ENDRT3:
	MOV	DX,BX		;return decremented value to proper register
	TEST	AL,CH		;border?
	JZ	NTBRD3		;if so, we are either at viewport edge
	XOR	DX,DX		;or have skipped DX pixels and therefore
	MOV	BX,DX		;should exit with info as initialized
	XOR	CL,CL		;restore old value to flag
	JMP	SHORT SCNEX3	

;	Look for viewport edge to determine how many bytes to look
;	through for border pixel.

NTBRD3:
	PUSH	DX		;store skipcount for later
	XOR	DX,DX		;use to count pixels painted
	MOV	b$SaveCa,SI	;we have a new CSAVE
	PUSH	SI		;store copy of first byte address
	MOV	b$SaveCm,CH
	CALL	B$EgaCHKBTR	;set up byte for write, and count some pixels
				;(AH = viewport edge mask if any)
	MOV	BL,BH		;store first bit mask in BL
	XOR	BH,BH		;zero BH until last byte bit mask if any
	XOR	BP,BP		;start whole byte count at 0
	MOV	DI,B$REOFST
	SUB	DI,SI		;viewport edge address - first byte address
	TEST	BL,1		;if last bit not set, we found border for sure
	JZ	WRTPX3		;if just one byte, we're done
	OR	DI,DI		;check also if we hit viewport edge
	JZ	WRTPX3		;if so, also done

;	else look through DI bytes for border (this includes viewport
;	edge byte)

	DEC	BP		;start increment at -1
	MOV	CH,80H		;start each byte at left edge
	PUSH	DX		;save accumulating bit count
	MOV	DX,GRPADD+1	;prepare to send Color Don't Care data
SCANM3:
	INC	BP		;whole byte count
	INC	SI		;point to byte
	ROR	CL,1		;rotate plane mask
	MOV	AL,CL
	OUT	DX,AL
	MOV	AL,ES:[SI]	;read each byte for color compare
	EGAINT10STI		;read is done, reenable ints if EGAINT10
	OR	AL,AL		;check for occurrence of border pixel(s)
	JNZ	BRDPX3		;set up last byte
	DEC	DI		;decrement to 0 to include last byte
	JNZ	SCANM3		;go check out this byte
;	MOV	AH,B$VRMASK	;if edge of viewport, get viewport mask
				;and proceed to set up byte for write
BRDPX3:
				;may have found border, viewport
				; edge, or have both in same byte
	CMP	SI,B$REOFST	;heck if this is edge byte
	JNZ	BRDFD3
	MOV	AH,B$VRMASK	;if found, install viewport edge mask
BRDFD3:
	POP	DX		;restore pixel count
	CALL	B$EgaCHKBTR	;set up byte for write

;	most recent call to CHKBTR has generated new cursor location and mask

WRTPX3:
	MOV	b$OffC,SI
	MOV	b$MaskC,CH
	POP	DI		;restore leftmost byte address
	PUSH	DI		;save a copy for leftmost add. for painting
	PUSH	SI		;save copy of rightmost address also
	MOV	SI,DI		;leftmost byte address in SI for PIXRGT
	MOV	DI,BP		;PIXRGT will use DI to count whole bytes
	CMP	b$Tiling,0	;see whether tiling is on
	JZ	COLCM3
	CALL	B$EgaTILRGT
	JMP	SHORT COLCM4
COLCM3:
	CALL	B$EgaSETCMP	;set color compare register to paint attribute
	CALL	PIXRT3		;routine to determine whether any pixels change
COLCM4:
	POP	SI		;restore rightmost
	POP	DI		;and leftmost byte addresses
	OR	CL,CL		;non-zero indicates at least one must change
	JZ	NPNTR3
	XOR	CH,CH		;zero as increment flag
	CLD			;for SCANR, paint routine should increment REP
	CALL	B$EgaPAINPX	;set line
NPNTR3:
	CALL	B$EgaPIXCNT	;return # pixels "painted" in BX
	POP	DX		;skipcount in DX
SCNEX3:
	CALL	B$ResetEGA	;reset EGA registers for BIOS write mode 0
	MOV	SI,b$SaveCa	;return CSAVE
	MOV	AL,b$SaveCm
cEnd

	ASSUME	DS:NOTHING

;***
; Read_64K
;
;Purpose:
;	Support routine for NReadL_64K, reads one byte from screen
;	memory into AL.  Read from even plane even address, from
;	odd plane if odd address.
;Entry:
;	DS:SI = screen address
;Exit:
;	AL    = screen contents from address at ES:DI
;	DI    = incremented to next screen byte
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	Read_64K
cProc	Read_64K,<NEAR>
cBegin
	EGAINT10CLI		;disable ints if using EGAINT10
	mov	al,RMPREG	;select read map select register
	out	dx,al
	inc	dx
	xor	al,al		;for plane computation
	ror	di,1		;carry = 1 if odd address
	adc	al,BasePlane	;base plane +1 iff odd address
	rol	di,1		;restore address
	out	dx,al		;set plane to read
	dec	dx
	lodsb			;read it (finally!!)
	EGAINT10STI		;reenable ints if using EGAINT10
cEnd

;***
; NReadL_64K
;
;Purpose:
;	Read a line of pixels from a specified plane to an array for
;	64K Screen mode 9 (odd/even color mode).
;Entry:
;	DS:SI = screen address
;	ES:DI = array address
;	CL    = array align shift count
;	CH    = mask for last partial byte
;	BP    = count of bits to read
;	BH    = plane to read from
;Exit:
;	ES:DI = updated to array byte past point used
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	NReadL_64K
cProc	NReadL_64K,<NEAR>
cBegin
	MOV	DX,GRPADD	;address graphics controller
;the next 2 statements appear to be unnecessary, but I'm not totally sure.
;	MOV	AX,RWMREG	;r/w mode, [ah] = 0
;	OutWord 		;non color compare read
	shl	bh,1		;plane 0 = maps 0/1, plane 1 = maps 2/3
	mov	BasePlane,bh
	call	Read_64K	;preload hi byte
	mov	ah,al		;  to ah
NRdLoopX:
	call	Read_64K	;fill ax word with video bytes
	mov	bh,al		;this lo byte will become next hi byte
	rol	ax,cl		;align to array
	sub	bp,8		;8 bits done
	jbe	NRdLastX	;go if bit count exhausted
	mov	es:[di],ah	;save full byte
	inc	di		
	mov	ah,bh		;move lo byte (BH) to hi byte (AH)
	jnz	NRdLoopX	;loop if no offset overflow
	call	B$BumpES	;move array pointer over segment boundary
	jmp	short NRdLoopX	;go do another
NRdLastX:
	and	ah,ch		;strip unused bits from last byte
	mov	es:[di],ah	;save last byte
	inc	di		
	jnz	NRdDoneX	
	call	B$BumpES	;move array pointer over segment boundary
NRdDoneX:
cEnd

;***
; Write_64K
;
;Purpose:
;	Support routine for NWriteL_64K, writes one byte to screen
;	memory from AL.  Initializes EGA regs to appropriate plane and
;	vectors through [b$PutVector] which writes the byte after
;	applying any bitwise logic necessary.
;Entry:
;	ES:DI = screen address
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	Write_64K
cProc	Write_64K,<NEAR>,<AX,DX>
cBegin
	push	ax
	MOV	DX,GRPADD	;address graphics controller
	mov	al,RMPREG	;select read map select register
	out	dx,al
	inc	dx
	xor	al,al		;for plane computation
	ror	di,1		;carry = 1 if odd address
	adc	al,BasePlane	;base plane +1 iff odd address
	rol	di,1		;restore address
	out	dx,al		;set plane to read
	MOV	DX,SEQADD	;address the sequencer
	MOV	AL,MMREG	;  map mask register
	out	dx,al
	inc	dx
	mov	al,b$PlaneMask ;get base plane mask
	and	al,MapMask	;with even/odd map mask
	and	al,0FH		;strip to nibble
	out	dx,al		;set plane to write
	rol	MapMask,1	;rotate even/odd mask for next byte
	pop	ax
.erre	ID_SSEQDS		;assumes ss = ds
	call	ss:[b$PutVector]   ;put the byte (finally!!)
cEnd

;***
; NWriteL_64K
;
;Purpose:
;	Write a line of pixels from an array to a specified plane for
;	64K Screen mode 9 (odd/even color mode).
;Entry:
;	ES:DI = screen address
;	DS:SI = array address
;	CX    = array align shift count
;	BP    = count of bits to write
;	BH    = plane to write to
;	DL    = last partial byte mask
;	DH    = first partial byte mask
;Exit:
;	DS:SI = updated to array byte past point used
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	NWriteL_64K
cProc	NWriteL_64K,<NEAR>
cBegin
	rol	b$PlaneMask,1	;shift to next plane
	rol	b$PlaneMask,1
	mov	MapMask,01010101B	;setup map mask for even access
	test	di,1		;is it even?
	jz	IsEvenX 	;go if so
	rol	MapMask,1
IsEvenX:
	shl	bh,1		;plane 0 = maps 0/1, plane 1 = maps 2/3
	mov	BasePlane,bh
	push	dx
	mov	ah,dh		;first byte bit mask
	MOV	DX,GRPADD	;address graphics controller
	mov	al,BMKREG	;  bit mask register
	EGAINT10CLI		;disable ints if using EGAINT10 interface
	OutWord 		;set first partial byte mask
	pop	dx

	mov	ah,[si] 	;preload byte from array
	inc	si
	jnz	NWrOvfl1X	
	call	B$BumpDS	;move array pointer over segment boundary
NWrOvfl1X:
	ror	ax,cl		;align to video
	add	bp,cx
	sub	bp,8		;account for first partial byte
	jbe	NWrLastX	;go if last byte
	call	Write_64K
	mov	dh,0FFH 	;mask for whole bytes in the middle
	push	ax
	push	dx
	mov	ah,dh		;middle byte bit mask
	MOV	DX,GRPADD	;address graphics controller
	mov	al,BMKREG	;  bit mask register
	OutWord 		;set full byte mask for middle bytes
	EGAINT10STI		;reenable ints if using EGAINT10 interface
	pop	dx
	pop	ax
	jmp	short NWrLoopX2
NWrLoopX:
.erre	ID_SSEQDS		;assumes ss = ds
	EGAINT10CLI		;disable ints if using EGAINT10 interface
	call	Write_64K	;put the byte
	EGAINT10STI		;reenable ints if using EGAINT10 interface
NWrLoopX2:
	rol	ax,cl		;re-align to array
	xchg	ah,al
	cmp	cx,bp		;enough bits in this byte to finish
	jae	NWrOvfl2X	;go if so, don't load another
	mov	ah,[si] 	;fill ax word with array bytes
	inc	si
	jnz	NWrOvfl2X	
	call	B$BumpDS	;move array pointer over segment boundary
NWrOvfl2X:
	ror	ax,cl		;align to video
	sub	bp,8		;8 bits done
	ja	NWrLoopX	;go if bit count not exhausted
NWrLastX:
	push	ax
	and	dh,dl		;combine first|middle mask with end mask
	mov	ah,dh		;last byte bit mask
	MOV	DX,GRPADD	;address graphics controller
	mov	al,BMKREG	;  bit mask register
	EGAINT10CLI		;disable ints if using EGAINT10 interface
	OutWord 		;set first partial byte mask
	pop	ax
.erre	ID_SSEQDS		;assumes ss = ds
	call	Write_64K	;put the last byte
	EGAINT10STI		;reenable ints if using EGAINT10 interface
cEnd

	ASSUME	DS:DGROUP

;***
; B$xINITEGA - initialize EGA modes
;
;Purpose:
;	Added with revision [26].
;	Put the addresses of EGA screen mode support routines into the
;	dispatch table used by the screen statement.
;
;Entry:
;	None
;Exit:
;	ScreenTab updated
;Uses:
;	None
;Exceptions:
;******************************************************************************
cProc	B$xINITEGA,<FAR,PUBLIC> 
cBegin
	MOV	WORD PTR [b$ScreenTab + (7*2) + 1],OFFSET B$Screen7
	MOV	WORD PTR [b$ScreenTab + (8*2) + 1],OFFSET B$Screen8
	MOV	WORD PTR [b$ScreenTab + (9*2) + 1],OFFSET B$Screen9
	MOV	WORD PTR [b$ScreenTab + (10*2)+ 1],OFFSET B$Screen10
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llcom3.asm ===
TITLE	LLCOM3 - Communications Interface for DOS 3

	PAGE	56,132

;***
; LLCOM3.ASM - GW-BASIC Communications Interface for DOS 3
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module supports the initialization/open, read, write, line
;	status check, termination and interrupt/monitor service for
;	communication lines.  In DOS3, BASIC handles the actual low level
;	functions itself, whereas in DOS5, BASIC takes advantage of the dos
;	function calls.
;
;******************************************************************************

INCLUDE switch.inc		;feature switches [new file]
INCLUDE rmacros.inc		

;	Code Segments

	useSeg	DV_TEXT 	
	useSeg	RT_TEXT 	
	useSeg	EV_TEXT 	

;	Data segments

	useSeg	_DATA		
	useSeg	_BSS		

INCLUDE seg.inc 		
INCLUDE ibmunv.inc
INCLUDE	baslibma.inc		; skip macro
INCLUDE comdcb.inc		;comm data control block (DCB) structure
INCLUDE event.inc 		
INCLUDE idmac.inc		

	SUBTTL	local constant/structure definitions

QUE_CTRL_LEN =	QUSIZE		;Length of Queue Control  Block

RS232B	=	400H		; X'400' RS232 Card(s) I/O addr Save area.

COMDEB	STRUC
	DEVID	DB	?	;device id number
	COMBSY	DB	0	; nonzero if Tx Interrupts active
	COMRTS	DB	2	; Request to Send Mask bit if RTS wanted
	COMCTS	DW	?	; CTS timeout count
	COMDSR	DW	?	; DSR timeout count
	COMRLS	DW	?	; CD (RLSD) timeout count
	COMOVF	DB	0	; Nonzero on overflow
	COMERR	DB	0	; Nonzero if I/O error
	MSRERR	DB	0	; Nonzero if lost DSR
	MSREG	DB	?	; Contents of Modem Status Register
	PARTYP	DB	?	; Parity type (internal form see B$INICOM)
	BYTSIZ	DB	?	; Size of byte(internal form - see B$INICOM)
	CTRLZ	DB	0	; ASCII mode EOF flag
	BINMOD	DB	0	; BIN/ASCII (Z/NZ) flag
	COMPE	DB	?	;nonzero if PE option selected
	RCVSEG	DW	?	;segment of receive queue buffer
	XMTSEG	DW	?	;segment of transmit queue buffer
COMDEB	ENDS

PAUSE	MACRO			;macro to insure that an instruction
	JMP	$+2		;fetch occurs between IN and/or OUT
	ENDM			;instructions on the Salmon machine

	SUBTTL	data definitions
	page
sBegin	_DATA			

	COMM1	COMDEB	<>	;COM1 device equipment block
	COMM2	COMDEB	<>	;COM2 device equipment block

sEnd	_DATA			

sBegin	_BSS			

	externB	b$COFlag	; non-zero indicates called from COM_OPEN
	externB	b$EventFlags	; misc. event flags
	externW	b$IPOLKEY	; vector for B$POLKEY routine
	externB b$DOS_INT_MASK ;defined in LLINI.ASM
	externW	b$ComPort	;I/O port address table

	staticB COM1_VECTOR,?,2	; old COM1 vector is saved here
	staticB COM2_VECTOR,?,2	; old COM2 vector is saved here
	externW	b$pTrapEvent	; pointer to B$TrapEvent if events linked in

Q_IN	QUE_CTRL_BLOCK <>	;Input Que Ctrl Data Blk Ptr
Q_IN2	QUE_CTRL_BLOCK <>

Q_OUT	QUE_CTRL_BLOCK <>	;Output Que Ctrl Data Blk Ptr
Q_OUT2	QUE_CTRL_BLOCK <>
sEnd	_BSS			

	SUBTTL	code externals	
	page

sBegin	RT_TEXT 		
	externW b$BASDSG	; in code segment to record basic data seg
sEnd	Rt_TEXT 		

sBegin	EV_TEXT 		
	externNP B$BREAK_CHK	;check ctrl-break
sEnd	EV_TEXT 		

sBegin	DV_TEXT 		
	externNP	B$INIQUE	
	externNP	B$QUE	
	externNP	B$DQUE	
sEnd	DV_TEXT 		

	SUBTTL	Comm initialization
	page
	assumes CS,DV_TEXT	
sBegin	DV_TEXT 		


;***
;B$INICOM - initialize the COM device
;[OEM documentation is in file LLCOM5]
;
;Purpose:
;	Initialize the requested RS232 port, if present, and set
;	up the port with the given attributes, when they are valid.
;	The memory for the input and output queues has already been
;	allocated, but will need to be initialized.  This routine is
;	passed the address of a device control block (DCB) as defined
;	in the file comdcb.inc.
;
;	The signals RLSD, CTS, and DSR should bbe ignored by all
;	COM routines if the curresponding Support of Timeout Flags
;	by BIOS is optional.
;
;IBM Communications Error Reporting
;	The following scheme is used in reporting errors:
;
;	1.) OPEN returns any OPEN specific erros and resets the input buffer.
;	2.) CLOSE, EOF, LOC, LOF, and device polling for trapping returns
;	    no error.
;	3.) INPUT returns only input errors.
;	4.) WRITE and PRINT return only output errors.
;	5.) Errors are reported at the earliest possible BASIC I/O
;	    statement (with respect to the rules above).
;	6.) I/O errors are cleared when they are reported to the runtime
;	    code and the byte being read or written is not removed from
;	    or added to the buffer.
;	7.) If an error occurs when reading a byte and the port is opened
;	    with less than eight data bits, then set the high bit of that
;	    byte.
;
;Entry:
;	BX = points to initialized DCB.
;
;Exit:
;	AH = 0	if no errors occured
;	   = 4	if timeout while waiting for DSR signal
;		(will cause a DEVICE TIMEOUT error)
;	   = 5	if timeout while waiting for RLSD signal
;		(will cause a DEVICE TIMEOUT error)
;	   = FE if device unavailable via BIOS data location
;		(will cause a DEVICE NOT AVAILABLE error)
;	   = FF if requested mode is not supported
;		(will cause a BAD FILE NAME error)
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None.
;*************************************************************************
;
;Algorithm:
;	If DOS 3,
;		check for valid device (0 or 1)
;		if card is present enable it else ERROR
;		initialize buffer control blocks
;		get parity and bytesize
;		if parity=NONE and bytesize=4 then ERROR
;		if parity<>NONE and bytesize=8 then ERROR
;		map parity to easier value
;			(0->0, 1->1, 2->3, 3->5, 4->7)
;		save new parity value
;		get baud rate
;		determine and save divisor for setting baud rate
;		set up card with appropriate characteristics

cProc	B$INICOM,<PUBLIC,NEAR>,<DI,SI> ; save DI, SI

cBegin				
	MOV	AH,0FFH 	;assume requested mode unsupported
	MOV	DL,[BX].CD_DEVID ;get device i.d.
	CMP	DL,1		;is i.d. > 1
	JBE	DeviceOK	;jump if device is 0 or 1
	JMP	INIRET		;near jump to error
DeviceOK:			
	MOV	SI,OFFSET DGROUP:COMM2 ;get com2 deb (dcb in dos5)
	JZ	IdOK		; br. if com2
	MOV	SI,OFFSET DGROUP:COMM1 ;get com1 deb (dcb in dos5)
IdOK:				

	MOV	[SI].DEVID,DL	;save device i.d.
	XOR	DH,DH
	MOV	DI,DX		;copy offset
	SHL	DI,1		;make word index (COM1=0 / COM2=2)
	CALL	InitComPort	;initialize the port, int vector, etc.
	OR	AX,AX		;test if error reported
	JZ	InitComAvail	;if zero, then initialization successful
	JMP	INIRET		;else exit with CH set with 0FEH for DNA
InitComAvail:			

	MOV	DX,[BX].CD_RXSIZ ;get size of the receive buffer
	MOV	CX,[BX].CD_TXSIZ ;get size of the transmit buffer
	CALL	BUFFINI 	;initialize buffer stuff

	MOV	CL,[BX].CD_CMFLG ;get com flags

	MOV	[SI].COMBSY,0	;not initially transmitting
	MOV	[SI].COMRTS,2	;set RTS mask
	AND	[SI].COMRTS,CL	;should RTS be enabled?
	MOV	[SI].COMPE,4D	;set PE mask
	MOV	CL,[BX].CD_CMFLG ;get com flags
	AND	[SI].COMPE,CL	;should PE be enabled?
	MOV	CX,[BX].CD_RXSEG ;get segment of receive comm buffer
	MOV	[SI].RCVSEG,CX	;set segment of receive comm buffer
	MOV	CX,[BX].CD_TXSEG ;get segment of transmit comm buffer
	MOV	[SI].XMTSEG,CX	;set segment of transmit comm buffer

	XOR	CX,CX		;assume no timeout value
	CMP	[BX].CD_RLSTO,CX ;test if RLSD timeout to be tested
	JZ	InicomNoCD	;if not, then leave timeout as zero
	MOV	CX,[BX].CD_OPNTO ;get OPEN timeout value
InicomNoCD:			
	MOV	[SI].COMRLS,CX	;set RLSD timeout count

	XOR	CX,CX		;assume no timeout value
	CMP	[BX].CD_DSRTO,CX ;test if DSR timeout to be tested
	JZ	InicomNoDS	;if not, then leave timeout as zero
	MOV	CX,[BX].CD_OPNTO ;get OPEN timeout value
InicomNoDS:			
	MOV	[SI].COMDSR,CX	;set DSR timeout count

	MOV	[SI].COMCTS,0	;don't check CTS during initialization
	MOV	[SI].COMOVF,0	;clear overflow flag
	MOV	[SI].COMERR,0	;clear I/O error flag
	MOV	[SI].MSRERR,0	;clear modem status flag
	MOV	[SI].MSREG,0	;clear modem error value
	MOV	DH,[BX].CD_BYTSZ ;get number of data bits in byte in [DH]
	MOV	DL,[BX].CD_PARIT ;get requested parity in [DL]
	OR	DL,DL		;is parity "NONE"?
	JZ	ChkParity	; br. if so
	CMP	DH,8		;is byte size 8?
	JNZ	ByteSizeOK	; Brif not
ErrorJmp:			; for jump out of range
	MOV	AH,0FFH 	; require mode not support
	JMP	SHORT TRMRET	; else error (reset interrupt vectors)

ChkParity:			
	CMP	DH,4		;was it no parity and byte size 4?
	JZ	ErrorJmp	; Brif yes, error
ByteSizeOK:			; the following is set line status and baud
				;  rate
	SUB	DH,5		;shift byte size to bits 0&1
	MOV	[SI].BYTSIZ,DH	;save byte size
	MOV	DH,DL		;copy parity
	CMP	DL,2		;does parity need adjustment?
	JB	ParityOK	; br. if not
	MOV	DH,1		;[DH]=new parity value
	DEC	DL		;[DL] = Loop count
AdjParLoop:			; keep adjust
	INC	DH		;parity 0 -> 0, parity 1 -> 1
	INC	DH		;parity 2 -> 3
	DEC	DL		;parity 3 -> 5
	JNZ	AdjParLoop	; parity 4 -> 7
ParityOK:			
	MOV	[SI].PARTYP,DH	;store adjusted parity value
	MOV	AL,[BX].CD_STOPB ;get number of stop bits 0=1,1/2= .GT. 1
	DEC	AL		;Find out if 0 stop bits?
	JS	StopBitOK	; Brif sign, must have been zero stop bits
				;Request > 1 stop bit if by ORing with BIT 2 on
	OR	BYTE PTR [SI].BYTSIZ,00000100B
				;[BYTSIZ] is number of data bits and stop bits
StopBitOK:			
	MOV	CX,[BX].CD_BAUDR ;get requested baud rate
	CALL	GETDIV		;get necessary divisor to support baud rate
	MOV	AH,0FFH		;set error code if baud not supported
	JCXZ	TRMRET		;reset vector if not and give error
	CALL	SETEM		;set up RS232 card
	OR	AH,AH		;test if error occurred
	JNZ	TRMRET		;if so, then reset vector and jump

	MOV	CX,[BX].CD_RLSTO ;get RLSD time out count
	MOV	[SI].COMRLS,CX	;set RLSD timeout count
	MOV	CX,[BX].CD_DSRTO ;get DSR time out count
	MOV	[SI].COMDSR,CX	;set DSR timeout count
	MOV	CX,[BX].CD_CTSTO ;get CTS timeout count
	MOV	[SI].COMCTS,CX	;store real CTS timeout count

	JMP	SHORT INIRET

TRMRET:
	PUSH	AX		;save registers...
	PUSH	BX
	PUSH	CX
	PUSH	DX
	XOR	CX,CX		; reset DTR
	MOV	[b$COFlag],CL	; Clear flag for next call to MSRWAT!
	CALL	CLSMSR		;full termination - bring lines down
	POP	DX		;restore registers...
	POP	CX
	POP	BX
	POP	AX
	CMP	AH,0FCh		; was CTRL-BREAK detected in MSRWAT?
	JNE	INIRET		; brif not
	CALL	B$BREAK_CHK	; process CTRL-BREAK -- should not return
DbHalt	DV_TEXT,<CTRL-BREAK lost during COM OPEN in B$INICOM>	;

INIRET:
cEnd	;B$INICOM		; pop register and exit
	page			
;***
; InitComPort - Initialize a communications port
;
; Purpose:
;	First tests if device is available through the BIOS data location
;	(0:400H for COM1 - 0:402H for COM2) which contains the I/O data port.
;	If the device is available, then set up the ISR vector and initialize
;	the hardware.
; Entry:
;	DI = device index (COM1=0 / COM2=2)
; Exit:
;	AH = 0FEH if device is not available.
;	AX = 0 if device is available.
; Modifies:
;	AX, DX.
; Exceptions:
;	None.
;*************************************************************************

;	First, determine if the device is available by examining the
;	BIOS location of the I/O port number.  If zero, it is unavailable.
;	If nonzero, clear the value for exclusive use and store the port
;	address in the DCB.

InitComPort:
	PUSH	DS		;save DGROUP on stack
	XOR	DX,DX		;clear DX for use as BIOS segment
	MOV	DS,DX		;set segment to access BIOS data area
	XCHG	DX,DS:RS232B[DI] ;get I/O address in DX, clear BIOS data
	POP	DS		;restore DGROUP from stack

	MOV	b$ComPort[DI],DX ;store I/O port address in DCB
	OR	DX,DX		;test if device is available
	JNZ	ComPortAvail	;if so, then jump
	MOV	AH,0FEH		;set CH for "device not ready" error
	RET			;do a near return to caller with CH=0FEH

;	With the device index in DI and the I/O port address in DX,
;	initialize the hardware and interrupt vectors.

ComPortAvail:
	PUSH	BX		;save registers...
	PUSH	SI

	MOV	SI,OFFSET CODE:COM_INT1 ;COM1: Service addr
	MOV	BX,OFFSET DGROUP:COM1_VECTOR ;get offset for saved vector

	OR	DI,DI		;test if COM1 is being initialized
	JZ	ComPortStart	;if so, then start the initialization

	MOV	SI,OFFSET CODE:COM_INT2 ;COM2: Service addr
	MOV	BX,OFFSET DGROUP:COM2_VECTOR ;get offset for saved vector
ComPortStart:

	MOV	CX,0EF00H+IRQ4/4 ;8259 enable mask/int number (primary)

	CMP	b$ComPort[DI],03F8H ;test if primary asynch card
	JE	ComPortPrimary	;if so, then jump

	MOV	CX,0F700H+IRQ3/4 ;8259 enable mask/int number (secondary)
ComPortPrimary:			

	CLI			;disable interrupts during initialization
	ADD	DX,4		;Modem Control Register
	MOV	AL,1		; AL = 1 = DTR active; RTS off
	OUT	DX,AL		; Turn of RTS; leave DTR active
	PAUSE			;Delay
	SUB	DX,3		;Interrupt Enable Register
	DEC	AX		; AL = 0 = disable interrupts
	OUT	DX,AL		;Turn off interrupts
	MOV	DX,SI		;Set IRQ-4 Vector
	MOV	SI,BX		;get pointer to save vector addr
	MOV	AL,CL		;get interrupt number
	MOV	AH,35H		;get vector function call
	INT	21H		;get vector in ES:BX
	MOV	[SI],BX 	;store away current vector offset
	MOV	[SI+2],ES	;and likewise the current segment
	PUSH	DS		;get BASIC data segment
	POP	ES		;and restore ES with it
	PUSH	CS		;DS = CS
	POP	DS
	MOV	AH,25H		;DOS Set Vector Function
	INT	21H
	PUSH	ES		;save BASIC data segment
	POP	DS		;Original DS
	MOV	AH,CH		;get mask to AND with current one
	IN	AL,INTA1	;get interrupt mask for 8259
	AND	AL,AH		;include IRQ-3 or IRQ-4
	PAUSE			;to give settle time for I/O bus signals
	OUT	INTA1,AL	;output the new interrupt mask
	XOR	AX,AX		;clear AX for no error
	STI			;re-enable interrupts

	POP	SI		;restore registers...
	POP	BX
	RET			;near return to caller

;***
; BUFFINI - initialize COM buffers
;
; Purpose:
;	This routine is responsible for initializing the queue control
;	block field elements for the input and output buffers.
; Entry:
;	DX = size of receive buffer.	
;	SI = pointer to deb.
; Exit:
;	None.
; Modifies:
;	None.
; Exceptions:
;	None.
;***************************************************************************

BUFFINI:
	PUSH	SI
	PUSH	BX
	PUSH	AX
	MOV	BX,OFFSET DGROUP:Q_OUT ;get output QCB for COM1
	CMP	[SI].DEVID,0	;is this com1?
	JZ	BUFF2		;jump if so
	MOV	BX,OFFSET DGROUP:Q_OUT2 ;[BX]= Out QCB
BUFF2:
	XOR	AX,AX		;each buffer starts at zero
	MOV	[BX].QUEBOT,AX	;Store Out buffer Bottom addr
	cCALL	B$INIQUE 	; initialize queue
	MOV	[BX].QUETOP,CX	;Store Out buffer Top addr
	MOV	[BX].QUELEN,CX	;Store Out Queue length

	MOV	BX,OFFSET DGROUP:Q_IN ;BX points to COM1 input QCB
	CMP	[SI].DEVID,0	;test if COM1
	JZ	BUFF4		;branch if so
	MOV	BX,OFFSET DGROUP:Q_IN2 ;[BX] points to in_QCB
BUFF4:				
	XOR	AX,AX		;each buffer starts at zero
	MOV	[BX].QUEBOT,AX	;Store In buffer Bottom addr
	cCALL	B$INIQUE 	; initialize queue
	MOV	[BX].QUETOP,DX	;store in_buf1 top addr
	MOV	[BX].QUELEN,DX	;store in_queue length
	POP	AX
	POP	BX
	POP	SI
	RET

;***
; GETDIV
;
; Purpose:
;	gets baud rate divisor from table.
; Entry:
;	[CX] = requested baud rate
; Exit:
;	[CX] = baud rate divisor
;	       0 means invalid baud request
; Modifies:
;	None.
;***************************************************************************

GETDIV:
	PUSH	BX
	PUSH	DX
	MOV	BX,OFFSET CODE:BAUD_TBL-2 ;get address of baud table - 2
	MOV	DX,CX		;copy baud rate for compare
GETRA1:
	INC	BX
	INC	BX
	MOV	CX,CS:[BX]	; Get rate from Table
	INC	BX
	INC	BX		; (Baud value)
	JCXZ	GETEXT		;EOT, Bad Value given
	CMP	DX,CX
	JNZ	GETRA1		; No match, look next
GETEXT:
	MOV	CX,CS:[BX]	; [CX] = Baud Divisor
	POP	DX
	POP	BX
	RET

BAUD	MACRO	RATE,RATDIV
	DW	RATE
	DW	RATDIV
	ENDM

BAUD_TBL:
	BAUD	75,1536 	; 75
	BAUD	110,1047	; 110
	BAUD	150,768 	; 150
	BAUD	300,384 	; 300
	BAUD	600,192 	; 600
	BAUD	1200,96 	; 1200
	BAUD	1800,64 	; 1800
	BAUD	2400,48 	; 2400
	BAUD	4800,24 	; 4800
	BAUD	9600,12 	; 9600
	BAUD	19200,6 	; 19200
	BAUD	0,0		; End

;***
;SETEM
;
; Purpose:
;	Place the RS232 card in a deterministic initial state.	This
;	routine initializes the baud rate, parity, word size, and
;	INS 8250 interrupt enable register for the card.
; Entry:
;	CX = baud rate divisor
;	SI = pointer to deb for this device
;	DI = word index to COM device
; Exit:
;	AH = 0 means no errors occurred
;	     4 means time out occurred while waiting for DSR
;	     5 means time out occurred while waiting for RLSD
; Modifies:
;	AX,CX,DX
;**************************************************************************

SETEM:
	MOV	DX,b$ComPort[DI] ;Get I/O Base Addr.
DbAssertRel	DX,NE,0,DV_TEXT,<LLCOM3.ASM: Com I/O address = 0 in SETEM>
	ADD	DX,3		;Line Ctrl Reg.
	MOV	AL,80H		;Set DLAB=1
	OUT	DX,AL		;Enable Baud Latch
	SUB	DX,2		;MSB of Baud Latch
	MOV	AL,CH
	PAUSE			;make sure instruction fetch has occurred
	OUT	DX,AL		;Set MSB of Div
	DEC	DX
	MOV	AL,CL
	PAUSE			;make sure instruction fetch has occurred
	OUT	DX,AL		;Set LSB of Div
	MOV	CH,[SI].PARTYP	;Get Parity
	MOV	CL,3
	SHL	CH,CL		;Shift Parity to D4-D3.
	MOV	AL,[SI].BYTSIZ	;Get Byte size (5,6,7,8)
	OR	AL,CH		;[AL] = Parity+Word size.
	ADD	DX,3		;Line Ctrl Reg.
	PAUSE			;make sure instruction fetch has occurred
	OUT	DX,AL		;Set Line Control Reg.
	SUB	DX,3		;Data reg.
	XOR	CX,CX		;Lots of time
DATDLY:
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,DX		;Trash data
	LOOP	DATDLY		;  waiting for 8250 to settle

	ADD	DX,5		;line status register (port xFDH)
	PAUSE			;wait for bus settle
	IN	AL,DX		;read to clear DR,OE,PE,FE,BI,THRE,TEMT

	INC	DX		;modem status register (port xFEH)
;	ADD	DX,6		;Modem Status reg
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,DX		;Throw away 1st status read
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,DX		;Save 2nd
	MOV	[SI].MSREG,AL	; so MSRWAT works right
	DEC	DX		;Subtract 2 to get
	DEC	DX		;Modem Contrl Register
	MOV	AL,[SI].COMRTS	;Get RTS mask
	XOR	AL,2		;toggle rts bit
	OR	AL,9		;  or in DTR/INT enable
	PAUSE			;make sure instruction fetch has occurred
	OUT	DX,AL		;Enable the Card..
	SUB	DX,3		;Interrupt Enable Reg.
	MOV	AL,MSRIE+RDAIE+TBEIE ;MSR/RDA/THRE Enable
	PAUSE			;make sure instruction fetch has occurred
	OUT	DX,AL		;Enable Tx/Rx Interrupts.
	INC	DX		;Interrupt I.D. reg.
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,DX		;  so interrupt line goes low
;	----------------
	CALL	MSRWAT		;Check MSR (On ret, [DH] = ERROR CODE).
;	----------------
	MOV	AH,DH		;copy error code
	RET

;***
;MSRWAT:
;
;PURPOSE:
;	Checks the modem status register for CTS,DSR, and/or RLSD
;	signals.  If a timeout occurred while checking then this
;	routine will return the appropriate error code in DH.
;	This routine will not check for any signal with a corresponding
;	time out value of 0.
;ENTRY:
;	[SI] = Pointer to deb for this device
;	time out values in COMCTS,COMDSR, and COMRLS
;EXIT:
;	[DH] = 0 indicates no time out errors occurred.
;	       3 CTS timeout occurred
;	       4 DSR timeout occurred
;	       5 RLSD timeout occurred
;	      FC CTRL-BREAK found but not handled (COM OPEN ONLY)
;MODIFIED:
;	AX,CX
;****

	PUBLIC	MSRWAT
MSRWAT:
	PUSH	BX		;save registers
	PUSH	CX		
	PUSH	DI

	XOR	BX,BX		;initialize CX:BX to zero...
	MOV	CX,BX		;...for first time in
MSRWA0:				
	XOR	DI,DI		;initialize millisecond timeout value
MSRWA1:
	CMP	[b$COFlag],0	; Is this a COM OPEN?
	JNZ	MSRComOpen	; brif so -- special case
	CALL	B$BREAK_CHK	
MSRWA2:				
	XOR	AH,AH		;[AH] will be 0 if status is Ok.
	MOV	AL,[SI].MSREG	;Read Modem Status
	TEST	AL,CTS
	JNZ	MSRWA3		;Brif got CTS
	CMP	[SI].COMCTS,0	;Checking CTS?
	JZ	MSRWA3		;Brif not
	MOV	DH,3		;assume CTS timeout
	CMP	DI,[SI].COMCTS	;CTS timeout yet?
	JAE	MSRWAX		;jump if so
	INC	AH		;Status retry
MSRWA3:
	TEST	AL,DSR
	JNZ	MSRWA4		;Brif got DSR
	CMP	[SI].COMDSR,0	;Checking DSR?
	JZ	MSRWA4		;Brif not
	MOV	DH,4		;assume DSR timeout
	CMP	DI,[SI].COMDSR	;DSR timeout yet?
	JAE	MSRWAX		;jump if so
	INC	AH		;Status retry
MSRWA4:
	TEST	AL,RLSD
	JNZ	MSRWA5		;Brif got RLSD
	CMP	[SI].COMRLS,0	;Checking RLSD?
	JZ	MSRWA5		;Brif not
	MOV	DH,5		;assume MSR timeout
	CMP	DI,[SI].COMRLS	;RLDS timeout yet?
	JAE	MSRWAX		;jump if so
	INC	AH		;Status retry
MSRWA5:
	OR	AH,AH		;Check final status
	JZ	MSRWA8		;Brif Status is Ok!

;	CX:BX has entry tick value if nonzero.
;	If zero, the entry tick value is set.

	MOV	DI,CX		;DI:BX has entry tick value
	XOR	AH,AH		;clear AH to get time-of-day...
	INT	1AH		;...tick value in CX:DX
	XCHG	DI,CX		;CX:BX has entry - DI:DX has t-o-d value
	MOV	AX,CX		;get low-order t-o-d value...
	OR	AX,BX		;...and OR with high-order to test if zero
	JNZ	MSRNotFirst	;if nonzero, then not first time in
	MOV	CX,DI		;CX:BX zero, set to value...
	MOV	BX,DX		;...in DI:DX
	JMP	SHORT MSRWA0	;jump to init DI to 0

MSRNotFirst:			
	SUB	DX,BX		;subtract CX:BX from DI:DX...
	SBB	DI,CX		;...to get elapsed tick value
	JNC	MSRNoWrap	;if no wraparound, then jump
	ADD	DX,00B0H	;add 0018:00B0H to DI:DX...
	ADC	DI,0018H	;...to wrap for the next day
MSRNoWrap:			
	OR	DI,DI		;test if over 64K ticks
	MOV	DI,0FFFFH	;assume maximum millisecond value
	JNZ	MSRWA1		;if over 64K ticks, use maximum value
	MOV	AX,55D		;convert ticks to milliseconds...
	MUL	DX		;...where 1 tick is 55 milliseconds
	JC	MSRWA1		;if over 64K milliseconds, use maximum value
	MOV	DI,AX		;move computed millisecond value
	JMP	SHORT MSRWA1	;jump to retry the test

MSRComOpen:			; special handling for COM OPEN
	CALL	[b$IPOLKEY]	; check keyboard buffer (if /D or QB)
	TEST	[b$EventFlags],CNTLC ; test for CTRL-BREAK
	JZ	MSRWA2		; brif no CTRL-BREAK
	MOV	DH,0FCh		; set error flag to indicate CTRL_BREAK
	SKIP	2		; and exit via MSRWAX
MSRWA8:
	XOR	DH,DH		;indicate no errors occurred
MSRWAX:
	POP	DI
	POP	CX		
	POP	BX		
	RET

	SUBTTL	Comm read/write/status
	page
;***
;B$RECCOM
;[OEM documentation in LLCOM5]
;
;PURPOSE:
;	Read Byte From RS232 Input Queue If Data Is Ready
;
;ALGORITHM:
;	If COM interrupt handler detected error for this device,
;	  set PSW.C and return error code in [AH]
;	Else if interrupt handler has queued data for this device,
;	  move 1 byte from queue into [AL] and
;	  return with [AH]=0 and PSW.Z reset
;	Else if cntrl z (eof) then
;	  return with [AH]=26 and PSW.Z reset
;	Else
;	  return with [AH]=0 and PSW.Z set.
;ENTRY:
;	[AH] = RS232 device ID (0..255)
;
;EXIT:
;	[AH] = 0 if no I/O errors have occured
;	     = 1 if receive data queue overflow
;	     = 2 if receive parity error
;	     = 3 if CTS timeout
;	     = 4 if DSR timeout
;	     = 5 if RLSD timeout
;	     = 6 if receive Overrun error
;	     = 7 if receive Framing error
;	     = FF for all other I/O errors
;	If data is available, PSW.Z is reset & [AL] = input byte
;	else PSW.Z is set.
;
;MODIFIED:
;	none
;****

cProc	B$RECCOM,<PUBLIC,NEAR> 

cBegin				
	PUSH	SI
	PUSH	BX
	MOV	SI,OFFSET DGROUP:COMM1 ;get comm1 deb
	OR	AH,AH		;is it com1?
	JZ	RECC2		;br. if so
	MOV	SI,OFFSET DGROUP:COMM2 ;get com2 deb
RECC2:
	CALL	CHKERR		;get any errors in [AH]
	CMP	AH,0		;have any errors occurred?
	JNZ	RECERR		;br. if so
	MOV	BX,OFFSET DGROUP:Q_IN ;get address of queue control block
	CMP	[SI].DEVID,0	; is this COM1?
	JZ	RECC3		;br. if so
	MOV	BX,OFFSET DGROUP:Q_IN2 ; must be COM2 - get its queue
RECC3:
	CMP	[BX].QUENUM,0	;are there elements in the queue
	JNZ	NOZYET		;br. if so
	CMP	[SI].CTRLZ,0	;has control z been struck?
	JZ	RECERR		;br. if not
	MOV	AL,26D		;else return control z
	JMP	SHORT RETOK	;avoid deque
NOZYET:
	PUSH	ES
	MOV	ES,[SI].RCVSEG	;get buffer segment from DCB
	cCALL	B$DQUE		; get char from queue in [AL]
	POP	ES
RETOK:
	OR	SP,SP		;reset PSW.Z
	JMP	SHORT RECEXIT	

RECERR:
	XOR	AL,AL		;set PSW.Z
RECEXIT:			; get back registers and exit
	POP	BX
	POP	SI
cEnd				; return to caller

;***
;CHKERR
;
;PURPOSE:
;	checks to see if framing, overrun, parity, or data queue overflow
;	errors have taken place.
;
;ENTRY:
;	[SI] = Pointer to deb for this device
;
;EXIT:
;	[AH] = 0 if no errors have occurred
;	       1 if receive data queue overflow
;	       2 if receive parity error
;	       6 if ovrrun error
;	       7 if framing error
;	       FF if other errors occurred
;
;MODIFIED:
;	AH
;****

CHKERR:
	CMP	[SI].COMERR,0	;did line status register return errors?
	JZ	NOCMER		;br. if not
	MOV	AL,[SI].COMERR	;get error
	MOV	AH,6		;assume overrun error
	TEST	AL,2		;was this overrun error?
	JNZ	CHKRET		;br. if so
	MOV	AH,2		;assume parity error
	TEST	AL,4		;was it parity error?
	JNZ	CHKRET		;br. if so
	MOV	AH,7		;assume framing error
	TEST	AL,8		;was it a framing error?
	JNZ	CHKRET		;br. if so
	MOV	AH,0FFH 	;assume break error
	TEST	AL,10H		;was it a break error
	JNZ	CHKRET		;br. if so
NOCMER:
	MOV	AH,1		;assume overflow
	CMP	[SI].COMOVF,0	;was there overflow
	JNZ	CHKRET		;br. if so
	XOR	AH,AH		;must have been no errors
CHKRET:
	MOV	[SI].COMOVF,0	;reset for next time
	MOV	[SI].COMERR,0	;reset for next time
	RET

;***
; B$SNDCOM
;[OEM documentation in LLCOM5]
;
; Purpose:
;	Transmit one character over the specified serial port.
; Algorithm:
;	if COM interrupt handler detected error for this device,
;	  reset error-flag and return error code in [AH]
;	else if [DCB].CD_CTSTO > 0 then begin
;	  wait [DCB].CD_CTSTO milliseconds for CTS signal to become true.
;	  If TIMEOUT, return CTS timeout indication.
;	if [DCB].CD_DSRTO > 0 then begin
;	  wait [DCB].CD_DSRTO milliseconds for DSR signal to become true.
;	  If TIMEOUT, return DSR timeout indication.
;	if [DCB].CD_RSLTO > 0 then begin
;	  wait [DCB].CD_RSLTO milliseconds for RSLD signal to become true.
;	  If TIMEOUT, return RSLD timeout indication.
;	if queue is full wait until there is room in queue
;	queue Data and return with [AH] = 0.
; Entry:
;	 [AH] = RS232 device ID (0..255)
;	 [AL] = byte to be output
;
; Exit:
;	 [AH] = 0 if no I/O errors have occured
;	      = 1 if receive data queue overflow
;	      = 2 if receive parity error
;	      = 3 if CTS timeout
;	      = 4 if DSR timeout
;	      = 5 if RLSD timeout
;	      = 6 if receive Overrun error
;	      = 7 if receive Framing error
;	      = FF for all other I/O errors
; Modifies:
;	None.
;******************************************************************************

cProc	B$SNDCOM,<PUBLIC,NEAR> 

cBegin				
	PUSH	DI
	PUSH	SI
	PUSH	DX
	PUSH	CX
	PUSH	BX
	MOV	SI,OFFSET DGROUP:COMM1 ;get com1 deb
	MOV	BX,OFFSET DGROUP:Q_OUT ; get com1 queue
	OR	AH,AH		;is it comm1?
	JZ	SND2		;br. if so
	MOV	SI,OFFSET DGROUP:COMM2 ;get com2 deb
	MOV	BX,OFFSET DGROUP:Q_OUT2 ; get com2 queue
SND2:
	PUSH	AX		
	CALL	MSRWAT		;Check MSR, return or "timeout"
	POP	AX		;restore char
	MOV	AH,DH		;Copy error code
	CMP	AH,0		;time out?
	JNZ	PUTRET		;br. if so
	MOV	CX,[BX].QUELEN	;Length of queue
;PUTCLP:
	CALL	B$BREAK_CHK	
	CMP	CX,[BX].QUENUM	;Queue full?
;	JZ	PUTCLP		;Wait for space in queue
	JZ	SND2		; always check modem lines
;	PUSH	AX		;save char
;	PUSH	BX		;Save queout
;	CALL	MSRWAT		;Check MSR, (on ret, [BX] = Q_DEB).
;	POP	BX		;[SI] = queout
;	POP	AX		;Restore char to output
;	MOV	AH,DH		;copy error code
;	CMP	AH,0		;time out?
;	JNZ	PUTRET		;br. if so
	CLI			;Critical section
	CMP	[SI].COMBSY,0	;Tx already running?
	JNZ	PUTINQ		;If so, just queue and exit.
	MOV	[SI].COMBSY,255D ;Pre-set Tx busy flag.
	XOR	DX,DX
	MOV	DL,[SI].DEVID	;get device offset
	MOV	DI,DX
	SHL	DI,1		;make word index
	MOV	DX,b$ComPort[DI] ;get the I/O address port
DbAssertRel	DX,NE,0,DV_TEXT,<LLCOM3.ASM: Com I/O address = 0 in B$SNDCOM>
	OUT	DX,AL		; restarting Tx interrupts.
	JMP	SHORT POPBAR	
PUTINQ:
	PUSH	ES		; make [ES] equal to [DS]
	MOV	ES,[SI].XMTSEG	;get buffer segment from DEB
	cCALL	B$QUE		; Put char [AL] in output queue
	POP	ES
POPBAR:
	STI			;End Critical
PUTRET:
	POP	BX
	POP	CX
	POP	DX
	POP	SI
	POP	DI
cEnd				; return to caller

;***
; B$STACOM
;[OEM documentation in file LLCOM5]
;
; Purpose:
;	Returns the number of bytes of free space in the input queue
;	and the number of bytes of information queued for input.
;	In order to support the IBM Communications Error Reporting
;	philosophy, this routine will not report communications errors.
;
; Entry:
;	AH = RS232 device ID (0..255)
;
; Exit:
;	AH = 0 for no I/O error
;	CX = number of bytes of free space in the output queue
;	DX = number of bytes queued for input
;
; Modified:
;	None.
;****

cProc	B$STACOM,<PUBLIC,NEAR>,<BX,SI>	;[1]preserve registers

cBegin				
	MOV	BX,OFFSET DGROUP:Q_IN ;Addr of Input Queue
	MOV	SI,OFFSET DGROUP:Q_OUT ;address of COM1 output queue
	OR	AH,AH		;is this COM1?
	JZ	STA2		;br. if so
	MOV	BX,OFFSET DGROUP:Q_IN2 ;else get com2 input queue
	MOV	SI,OFFSET DGROUP:Q_OUT2 ;address of COM2 output queue
STA2:
	MOV	DX,[BX].QUENUM	;get number of bytes in queue
	MOV	CX,[SI].QUELEN	;get length of queue
	SUB	CX,[SI].QUENUM	;determine amount of free space in queue
	XOR	AH,AH		;indicate no errors
cEnd				; pop BX and exit

;***
;B$TRMCOM - Terminate the communications device
;[OEM documentation given in LLCOM5]
;
;Purpose:
;	Terminate an RS232 channel.  This routine is called when a file
;	associated with a COM channel is closed, or when a SYSTEM statement
;	is executed.  It waits for any outbound data to be transmitted, drops
;	the DTR line,  disables interrupts from this device, and disables the
;	queues if needed.  Any interupt handlers or threads should be removed.
;
;	While waiting for any data to be written, make sure to check the
;	keyboard for a ^Break and to check the Modem Status Registers for
;	any timeout conditions so as not to hang. This routine will not
;	report communications errors unless operating under OS/2.
;
;Entry:
;	[AH] = RS232 device ID (0 <= AH < NUM_RS232 <= 2)
;	[CX] = FLAG: 0 = reset DTR
;
;Exit:
;	[AH] = 0 to indicate that there are no errors.
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$TRMCOM,<PUBLIC,NEAR> 

cBegin				
	PUSH	SI
	PUSH	BX
	PUSH	CX
	PUSH	DX
	MOV	SI,OFFSET DGROUP:COMM1 ;Com1 deb
	MOV	BX,OFFSET DGROUP:Q_OUT ; Get Output Queue base
	OR	AH,AH		;is this com1?
	JZ	TRM2		;br.if so
	MOV	SI,OFFSET DGROUP:COMM2 ;get com2 deb
	MOV	BX,OFFSET DGROUP:Q_OUT2 ; Get Output Queue base
TRM2:
	CMP	[BX].QUENUM,0	;Output busy?
	JZ	CLSWAX		;Brif done
CLSWAT:
	CALL	MSRWAT		;Allow "Time out" during CLOSE
	OR	DH,DH		;did a timeout occur?
	JNE	CLSWAX		;if so, just call quits and close it
	CMP	[BX].QUENUM,0	;Output busy?
	JNZ	CLSWAT		;Yes, wait until done
CLSWAX:
	PUSH	CX		; save flag
	XOR	CX,CX		;Lots of time
CLSDLY:
	LOOP	CLSDLY		;for Shift Reg to empty...
	POP	CX		; CX = flag; 0 = reset DTR
	CALL	CLSMSR		;Force the file closed
	POP	DX
	POP	CX
	POP	BX
	POP	SI
	RET			;COM file is closed and deallocated

CLSMSR:
	PUSH	DI
	XOR	DX,DX
	MOV	DL,[SI].DEVID
	MOV	DI,DX		;get device offset
	SHL	DI,1		;make a word index
	MOV	DX,b$ComPort[DI] ;get the device I/O port address
DbAssertRel	DX,NE,0,DV_TEXT,<LLCOM3.ASM: Com I/O address = 0 at start of B$TRMCOM>
	MOV	AL,0		; 0 to reset lines
	JCXZ	Reset_RTS	; if CX  = 0, reset DTR
	INC	AX		; else, leave DTR active
Reset_RTS:			; always reset RTS
	ADD	DX,4		;Modem Ctrl reg.
	OUT	DX,AL		;Clear MSR, disable card.
	MOV	[BX].QUENUM,0	;Clear # to output
	SUB	DX,3		;Interrupt Enable Reg.
	PAUSE			;make sure instruction fetch has occurred
	MOV	AX,1000h + 0	; 0 to disable interrupts; AH=10H for below
	OUT	DX,AL		; Disable COMM Interrupts
	DEC	DX		;get back base I/O address
;	MOV	AH,10H		;IRQ-4 Disable Mask
	CMP	DH,3		; RS232 Port addr 3xx?
	JZ	$C_COM_3xx	;Yes, Disable IRQ-4
	MOV	AH,8		;IRQ-3 Disable Mask, assume 2xx.
$C_COM_3xx:
	CLI
	TEST	b$DOS_INT_MASK,AH ;test if bit was initially enabled
	JZ	NO_INT_DISABLE	;if so (bit was 0), then no disable
	IN	AL,INTA1	;Get INT masks from 8259 IMR Reg.
	OR	AL,AH		;Disable IRQ-3 or IRQ-4
	PAUSE			;make sure instruction fetch has occurred
	OUT	INTA1,AL	;For RS232 Cards.
NO_INT_DISABLE:

	MOV	BX,OFFSET DGROUP:COM1_VECTOR ;get start of old COM1 vector
	OR	DI,DI		;test if COM1
	JZ	REST_VECTOR	;if COM1, then jump
	MOV	BX,OFFSET DGROUP:COM2_VECTOR ;get start of old COM2 vector
REST_VECTOR:			

	MOV	AL,IRQ4/4	;vector number for primary card
	CMP	DH,3		;test if primary asynch card
	JE	REST_MASK	;if so, then jump
	MOV	AL,IRQ3/4	;vector number for secondary card
REST_MASK:			

	PUSH	DS		; Save BASIC data segment
	LDS	DX,DWORD PTR [BX] ;load vector into DS:DX
	MOV	AH,25H		;get DOS function code
	INT	21H		;and restore it
	STI
	POP	DS		;and restore DS to it
	XOR	AX,AX		;clear AX
	MOV	[BX],AX 	;clear offset of saved vector
	MOV	[BX+2],AX	;and same for the segment...

;	Set the BIOS data location for the COM I/O port address.

	XOR	BX,BX		; get a zero
	XCHG	BX,b$ComPort[DI] ;get the COM I/O port address [25]& reset
DbAssertRel	BX,NE,0,DV_TEXT,<LLCOM3.ASM: Com I/O address = 0 at end of B$TRMCOM>
	PUSH	DS		;save DGROUP on the stack
	XOR	DX,DX		;set to zero to access...
	MOV	DS,DX		;...the BIOS data segment
	MOV	DS:RS232B[DI],BX ;restore the BIOS data location
	POP	DS		;restore DGROUP from the stack

	POP	DI
cEnd				; return to caller

	SUBTTL	Comm interrupt service routine
	page
;***
;COM_INT1 / COM_INT2
;
;PURPOSE:
;	Interrupt handlers for COM1: and COM2:.  This is the communications
;	interrupt service routine for RS232 communications.  When an RS232
;	event occurs the interrupt vectors here.  This routine determines
;	who the caller was and services the appropriate interrupt.  The
;	interrupts are prioritized in the following order:
;		1.  line status interrupt
;		2.  read data available interrupt
;		3.  transmit buffer empty interrupt
;		4.  modem service interrupt
;	This routine continues to service until all interrupts have been
;	satisfied.
;
;ENTRY:
;	none
;EXIT:
;	none
;MODIFIED:
;	none
;******************************************************************************

COM_INT2:
	PUSH	DS
	PUSH	DI
	PUSH	DX
	MOV	DS,CS:b$BASDSG    ;get BASIC's data seg
	MOV	DX,DS:b$ComPort+2 ;DX = COM2 I/O addr.
DbAssertRel	DX,NE,0,DV_TEXT,<LLCOM3.ASM: Com I/O address = 0 in COM_INT2>
	MOV	DI,OFFSET DGROUP:COMM2 ;get com2 deb
	JMP	SHORT COMM_INT

COM_INT1:
	PUSH	DS
	PUSH	DI
	PUSH	DX
	MOV	DS,CS:b$BASDSG  ;get BASIC's data seg
	MOV	DX,DS:b$ComPort ;DX = COM1 I/O addr.
DbAssertRel	DX,NE,0,DV_TEXT,<LLCOM3.ASM: Com I/O address = 0 in COM_INT1>
	MOV	DI,OFFSET DGROUP:COMM1 ;get com1 deb

COMM_INT:
	PUSH	AX
	PUSH	BX
	PUSH	SI
	INC	DX
	INC	DX		;Interrupt Id Reg.
COMM_ILP:
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,DX		;Get Interrupt Id.
	TEST	AL,1		;Interrupt need servicing?
	JNZ	COMSRX		;Brif not, all done..
	XOR	AH,AH		;Using [AX] for Interrupt dispatch.
	MOV	SI,AX
	PUSH	DX		;Save Id reg.
	CALL	CS:SRVTAB[SI]	;Service the Interrupt..
	CLI			; disable interrupts for next iter. of loop
	POP	DX		;Interrupt Id reg.
	JMP	COMM_ILP	; Until all Interrupts Serviced

COMSRX:
	POP	SI
	POP	BX
	MOV	DX,INTA0
	MOV	AL,EOI		;Send End-of-Interrupt
	PAUSE			;make sure instruction fetch has occurred
	OUT	DX,AL		; to 8259
	POP	AX
	POP	DX
	POP	DI
	POP	DS
	IRET

SRVTAB	LABEL	WORD
	DW	MSISRV		;Service Modem Status Interrupt
	DW	THRSRV		;Service Tx Holding Reg. Interrupt
	DW	RDASRV		;Service Rx Data Available Interrupt
	DW	RLSSRV		;Service Line Status Interrupt

; Rx Data Available Interrupt Service (Second)

;		Line Status Interrupt Service (Highest)
;		Not currently enabled.	Line status is read
;		on RDA Interrupt and sets COMERR error flag
;		if any errors exist.

RLSSRV:
	STI			; we're not reading, reenable interrupts
	RET

RDASRV:
	XOR	AH,AH		;Don't set hi bit if no errors
	ADD	DX,3		;Line Status Reg.
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,DX
	AND	AL,1EH		;Mask for errors
	JZ	RDASR2		;Brif no errors
	CMP	[DI].COMPE,0	;is PE option selected?
	JE	RDASR4		;if not, do not parity error
	CMP	[DI].PARTYP,0	;Checking Parity errors
	JNZ	RDASR1		;Brif so, report all errors
RDASR4:
	CMP	AL,4		;Parity error?
	JZ	RDASR2		;Ignore if so, else report others
RDASR1:
	MOV	[DI].COMERR,AL	;Nonzero for "Device I/O Error"
	MOV	AH,80H		;Will set hi bit of byte in error
RDASR2:
	SUB	DX,5		;Data I/O Reg.
	MOV	BX,OFFSET DGROUP:Q_IN ;Addr of Input Queue
	CMP	[DI].DEVID,0	;is this COM1?
	JZ	RDASR3		;br. if so
	MOV	BX,OFFSET DGROUP:Q_IN2 ;else get com2 input queue
RDASR3:
	MOV	SI,[BX].QUENUM
	CMP	SI,[BX].QUELEN	;Is queue full?
	JZ	COMOVR		;Yes, comm overrun
	CMP	[DI].CTRLZ,0	;has control z been struck?
	JNZ	COMOVR		;br. if so - treat as overflow
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,DX		;Read Char from 8250
	STI			; reenable interrupts now that char is read
	CMP	[DI].BINMOD,0	;is this binary stuff?
	JZ	QUEIT		;br. if so
	CMP	AL,26D		;is this a control z?
	JNZ	QUEIT		;br. if not - que data
	MOV	[DI].CTRLZ,255D ;set control z flag
	JMP	SHORT NOQUE	;skip the queing process
QUEIT:
	OR	AL,AH		;Sets hi bit if error
;#***
	PUSH	ES
	MOV	ES,[DI].RCVSEG	;get buffer segment from DCB
	cCALL	B$QUE		; Put char [AL] in output queue
	POP	ES
	JMP	SHORT NOQUE	
;#***

COMOVR:
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,DX		;Dismiss and lose char
	STI			; reenable interrupts now that char is read
	MOV	[DI].COMOVF,1	;Set we have overflowed
NOQUE:				
	MOV	AX,DI		; AL = 0 for COM 1, 2 for COM2
	SHR	AL,1		; AL = trap number for B$TrapEvent
;	ADD	AL,COMOFF	; COMOFF = 0
	JMP	[b$pTrapEvent]	; and indicate an event if events linked
				; in, and return

; Tx Holding Reg Empty Interrupt Service (Third)

THRSRV:
	STI			; we're not reading, reenable interrupts
	CMP	[DI].MSRERR,0	;If Modem status fault then turn
	JNZ	TXSTOP		; off Tx interrupts until cleared
THRSR2:
	MOV	SI,BX		;[SI] = Queue base for speed
	MOV	BX,OFFSET DGROUP:Q_OUT ;Get Output Queue
	CMP	[DI].DEVID,0	;is this com1?
	JZ	THRSR3		;br. if so
	MOV	BX,OFFSET DGROUP:Q_OUT2 ;else get com2 output queue
THRSR3:
	CMP	[BX].QUENUM,0	;Zero if queue empty
	JZ	XMITOF		;Brif No chars, Set COMBSY = 0.

	DEC	DX
	DEC	DX		;Data I/O Reg.
	PUSH	ES		;save register
	MOV	ES,[DI].XMTSEG	;get buffer segment from DEB
	cCALL	B$DQUE		; get char from queue in [AL]
	POP	ES		;restore register
	OUT	DX,AL		;Send char
TXSTOP:
	RET
XMITOF:
	MOV	[DI].COMBSY,0	;Set Tx Interrupt status.
	RET

;Modem Status Interrupt Service (Lowest)

MSISRV:
	STI			; we're not reading, reenable interrupts
	ADD	DX,4		;Modem Status Reg.
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,DX
	MOV	[DI].MSREG,AL	;Save MSR data for others
	CMP	[DI].COMRLS,0	;Did user want to check?
	JZ	MSISRD		;Brif not, Try DSR.
	TEST	AL,RLSD 	;Did we lose RLSD?
	JZ	MSISRE		;"Device Timeout" if so.
MSISRD:
	CMP	[DI].COMDSR,0	;Did user want to check?
	JZ	MSISRC		;Brif not, Try CTS.
	TEST	AL,DSR		;Did we lose DSR?
	JZ	MSISRE		;"Device Timeout" if so.
MSISRC:
	CMP	[DI].COMCTS,0	;Did user want to check?
	JZ	MSISRX		;Brif not.
	TEST	AL,CTS		;id we lose CTS?
	JNZ	MSISRX		;Ignore if not.
MSISRE:
	MOV	[DI].MSRERR,DL	;will give "Device Timeout".
MSIRET:
	RET
MSISRX:
	CMP	[DI].MSRERR,0	;If was running
	JZ	MSIRET		; leave alone
	MOV	[DI].MSRERR,0	;Clear the Modem status fault
	DEC	DX		;Line Status reg.
MSISRH:
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,DX
	AND	AL,20H		;Tx Holding reg empty?
	JZ	MSISRH		;Brif not, wait for it
	SUB	DX,3		;Restore to Int Id reg.
	JMP	THRSRV		; and turn Tx Interrupts on if chars

sEnd	DV_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llcscn.asm ===
TITLE	LLCSCN - GW-BASIC Core Screen Interface
;***
; LLCSCN - GW-BASIC Core Screen Interface
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This file contains code for screen manipulations that is needed
;	for all programs.
;
;*****************************************************************************
	INCLUDE switch.inc	;switches
	INCLUDE rmacros.inc	

	USESEG	_DATA		
	USESEG	_BSS		
	USESEG	CN_TEXT 	
	USESEG	CONST		
	USESEG	GR_TEXT
	USESEG	RT_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE oscalls.inc	
	INCLUDE idmac.inc	
	INCLUDE intmac.inc
	INCLUDE llgrp.inc
	INCLUDE ibmunv.inc

sBegin	_BSS

	externB b$Adapter	
	externB b$ScrHeight


	externB b$OrgEquip	
	externB b$BiosMode	
	externB b$ScreenMode
	externB b$Burst
	externB b$ScrWidth
	externB b$MaxPage
	externW b$OrgScrBst	
	externW b$OrgScrDim	
	externW b$OrgCsrTyp	
	externW b$OrgPages	
	externB b$KEY_SW	
	externW b$SetMode
	externW b$AlphaDim
	externW b$PalReset
	externW b$SetPages

;***
;b$ScreenRestored - Flag to indicate that the screen mode has been changed
;OEM-interface routine (variable)
;
;Purpose:
;	This flag is used to signal the interpreter that we have changed
;	the screen mode in B$RESETSCN.	The interpreter UI uses it during
;	RUN time initialization to decide if it needs to throw away its
;	saved image of the user output screen.
;
;	This variable is only needed in a version of the runtime that
;	supports the QB Interpreter.
;
;Allocation:
;	b$ScreenRestored is a BYTE value declared in the _BSS segment
;	by the OEM.
;
;Values:
;	0 - Screen Mode did not change
;	1 - Screen Mode changed
;
;
;Initially Set:
;	This variable is initialized to 0 with the rest of the _BSS segment.
;
;Modified By:
;	The variable should only be modified by the runtime during execution
;	of the routine B$RESETSCN.  It may be modified by the Interpreter
;	at any point.
;
;Used by:
;	b$ScreenRestored is used by the interpreter for screen management.
;****
globalB b$ScreenRestored,,1	;non-0 if screen changed in B$RESETSCN


sEnd	_BSS


sBegin	_DATA

	globalW b$CSRTYP,-1,1	; CURRENT cursor type (start and stop lines)
				; Low byte = -1 if actual cursor type is
				; unknown.

;***
;b$CurPages, b$ActPage - Display pages
;OEM-interface routine (variable)
;
;Purpose:
;	b$CurPages contains the current active and visual display
;	page.  The visual display page is also accessible by the
;	variable b$ActPage.  The high byte of b$CurPages is the
;	number of the current visual page and its low byte is the
;	number of the current active page.
;
;	This value is only used by OEM independent code during termination
;	when trying to display the message "Hit any key to return to system".
;	When this is done, we have to make sure that the message gets
;	displayed on the visual page.  To do this, we copy the high order
;	byte of b$CurPages (the visual page) to b$ActPage.  A call to
;	B$GETCSRDATA is then done to get the cursor position of the
;	(possibly new) active page. After displaying the message, the visual
;	page is restored by another change to b$ActPage.
;
;	One major effect of this use of b$ActPage is that the OEM-dependent
;	code has to be written such that it can handle an asynchronious
;	change to this variable.
;
;Allocation:
;	b$CurPages is a WORD value declared in the _DATA segment
;	by the OEM. b$ActPage is a BYTE value.	It is the low order
;	byte of b$CurPages.
;
;Values:
;	The values of the two halves of b$CurPages are dependent on
;	the current screen mode and the hardware installed in the
;	computer.
;
;Initially Set:
;	The OEM-Dependent code is responsible for initially setting
;	this variable. It must be initialized such that, at termination,
;	if the active display page is not the visual display page (as
;	indicated by b$CurPages (HI) != b$CurPages (LOW)), changing
;	the value of b$ActPage will be sufficient to indicate that the
;	pages must be changed.
;
;Modified By:
;	By OEM only, except during termination as noted above.
;
;Used By:
;	OEM and termination code.
;****

labelW	<PUBLIC,b$CharPage>	;b$CharColor and b$ActPage in one word
	globalB b$CharColor,7,1 ;encoded color attributes for character
labelW	<PUBLIC,b$CurPages>	;b$ActPage and b$VisPage in one word
	globalB b$ActPage,0,1	;active display page
	globalB b$VisPage,0,1	;visual display page

	externW b$CurrPSize	;Current page size in paras
	externW b$UsrCsrTyp	; user-defined cursor


globalW b$ScreenX,<OFFSET DGROUP:ScreenTb>,1 ; Indirect pointer to screen mode table
				; in DGROUP

labelW	ScreenTb		; mode-dependent SCREEN set-up
	DB	0		; Maximum screen mode (default=0)
	DW	B$Screen0

	externW b$CURSOR
	externW b$vKEYDSP	; vector for indirect call to B$KEYDSP
	externB b$UsrCsrStart	; user-defined cursor start line
	externB b$UsrCsrStop	; user-defined cursor stop line
	externW b$InsCsrTyp	; insert mode cursor (init to 1/2 block)
	externB b$InsCsrStop	; insert cursor stop line
	externW b$MapXYC	
	externD b$AddrC 	
	externB b$ForeMapped	
	externB b$WDOTOP	; top line of text window (1-relative)
	externB b$WDOBOT	; bottom line of text window (1-relative)
	externB b$CRTWIDTH	; rightmost column (1-relative)
	externB b$NullColor	;encoded color attributes for blank/_BSCROLL
	globalB b$UsrCsrOn,0,1	; user cursor status (1=on, 0=off)
	globalW b$pOgaCsr,B$NearRet ; pointer to Olivetti version of GRPCSR

sEnd	_DATA

OffCsrTyp EQU 2707H		; valid cursor start and stop lines, with
				; bit 5 set to indicate cursor off



sBegin	GR_TEXT
externNP B$Screen0
externNP B$FixTextPage				
sEnd	GR_TEXT

sBegin	CONST			

	staticB BLTLOT,0,4	;Half Box Character
	staticB ,255,12 	;Whole Box Character

sEnd	CONST			



sBegin	RT_TEXT 		
	externNP B$GRMODE	
	externNP B$VIEWINIT	
	externNP B$ChkMonitor	; set VGA mono/color monitor

sEnd	RT_TEXT 		


sBegin	CN_TEXT 		
	assumes CS,CN_TEXT	



;=============== Code from here to next marker moved from LLSCNIO.ASM

	externNP B$OutWord

	externNP B$SCINIT	; Delayed screen initializer
	externNP B$SCNSWI
	externNP B$ERR_FC
	externNP B$SCNCLR
	externNP B$NearRet	; a public NEAR RET
	externNP B$SetAdapter





;***
;B$SCNIO
;
;Purpose:
;
;Entry:
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;****
cProc	B$SCNIO,<PUBLIC,NEAR>
cBegin
	SCNIO			;Screen I/O saving: BP,DI,SI
cEnd


;***
;B$SELAPG - select active page
;B$SELVPG - select visual page
;
;Purpose:
;	Set the current BIOS active page to be either the page number in
;	ActPage (for B$SELAPG) or VisPage (for B$SELVPG).
;
;Entry:
;	b$ActPage
;	b$VisPage
; WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
; WARNING!                                                       WARNING!
; WARNING!		 DS may not always = DGROUP		 WARNING!
; WARNING!                                                       WARNING!
; WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
;Exit:
;	[AL] = active page
;Uses:
;
;Preserves:
;	BX,CX,DX
;
;Exceptions:
;	none
;
;******************************************************************************

cProc	B$SELVPG,<PUBLIC,NEAR>
cBegin
	MOV	AL,SS:[b$VisPage]
	JMP	SHORT SELPAG
cEnd	<nogen> 		;End of B$SELVPG

cProc	B$SELAPG,<PUBLIC,NEAR>
cBegin
	MOV	AL,SS:[b$ActPage] ; [al] = active page #
SELPAG:


	PUSH	DX
	MOV	DX,SS:[b$CurrPSize] ;Get page size (set by B$SCRSTT) in paras
	SHL	DX,1		; Make it byte count
	SHL	DX,1		; * 4
	SHL	DX,1		; * 8
	SHL	DX,1		; * 16
	XOR	AH,AH
	PUSH	DS		; save current data segment
	PUSH	AX		; save new active page number
	MUL	DX		; [ax] = page No. * page size
	MOV	DS,DX		; [ES] = 0, since [DX] = 0 after multiply
	MOV	DS:CRT_START,AX ; store active page offset
	POP	AX		; restore page number
	MOV	DS:ACTIVE_PAGE,AL ; and store it in BIOS data area
	POP	DS		; restore data segment
	POP	DX
SELPAX:

cEnd				;End of B$SELAPG/B$SELVPG


;***
;B$GETCSRDATA -- Get current cursor position and type.
;OEM-interface routine
;
;Purpose:
;	Returns in DX the current screen cursor position and cursor type
;	for the current active page as reported by BIOS/VIO.  The cursor
;	type is returned with the low order byte containing the stop line
;	and the high order byte containing the line of cursor block in
;	which to start the cursor.
;
;	When in a graphics mode under OS/2, the cursor position returned
;	is the last cursor position (b$CURSOR), and the type returned in
;	CX is invalid.	Note that under DOS, the cursor type must always
;	be a legal even when bogus values are returned from DOS (i.e.
;	for a graphics screen).
;
;Entry:
;	None.
;
;Exit:
;	DX = Current screen cursor position.
;	CX = Current screen cursor start and stop lines.
;
;Uses:
;	Per Convention.
;
;Preserves:
;	AX, BX
;
;Exceptions:
;	None.
;**********************************************************************
cProc	B$GETCSRDATA,<PUBLIC,NEAR>,<AX,BX>
cBegin
	MOV	BH,b$ActPage	;return cursor for current active page
	SCNIOS	vReadCursorPos	; get cursor position and type from BIOS
	INC	DX		; make row 1-relative
	XCHG	DH,DL		; want row in DL, column in DH
	INC	DX		; make column 1-relative

	CMP	CH,CL		; is cursor type read valid? (CH <= CL)
	JBE	CURSOR_OK	; brif so
	MOV	CX,b$UsrCsrTyp	; return a known cursor
CURSOR_OK:
	MOV	BYTE PTR b$CSRTYP,-1 ; invalidate low-level current cursor
				; type so it will get reset.
cEnd


;***
;B$SCNLOC - Locate cursor on physical screen, saving new coordinates
;OEM-interface routine
;
;Purpose:
;	Moves the cursor on the screen and save the final location
;	in b$CURSOR.  The coordinates are 1,1-relative to the physical
;	screen.  The cursor is displayed only if it is currently visible.
;
;Entry:
;	DH=column, DL=line (1,1 is home)
;
;Exit:
;	Updates b$CURSOR.
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****
;***
;B$OFFCSR, B$OVWCSR, B$INSCSR, B$USRCSR - Set Cursor Type and Location
;OEM-interface routine
;
;Purpose:
;	These routines display the appropriate cursor at a specified
;	location as given by the input parameters.  A request can also
;	be made to not display a cursor.  There are currently three
;	different types of cursors that are used, User Cursor, Insert
;	Cursor, and Overwrite Cursor.  The user cursor, which can be
;	modified by the LOCATE statement, is the one that is displayed
;	for all but editing.  When editing a line of input, either the
;	Overwrite or Insert cursor will be used depending on whether
;	we are overwriting or inserting characters.  The Overwrite
;	cursor is identical to the User Cursor, except that it can
;	not be turned off with the LOCATE statement.
;
;
;	Initially, the User Cursor and Overwrite cursors are a full
;	block, and the insert cursor is a 1/2 block.  Under DOS, the
;	cursor has to be handled separately if we are in a graphics
;	mode since the IBM BIOS does not support a cursor font in
;	graphics mode.	Note that none of this has anything to do with
;	the graphics cursor, which is a one pixel location on the
;	current graphics screen and is never displayed.
;
;	NOTE: If you are supporting delayed screen initialization,
;	      B$SCNINIT has to be called before any changes are
;	      made.
;
;Algorithm:
;
;    B$INSCSR - Turn insert cursor on and move to specified location
;
;    B$OFFCSR - Turn cursor off and move invisible cursor to specified
;		 location
;
;    B$USRCSR - Turn on user cursor if specified as being visible in
;		 the last call to B$CSRATR, otherwise do not display
;		 a cursor.  Move (possibly invisible) cursor to specified
;		 location if the cursor is on.  If the cursor is off,
;		 DO NOT move the cursor (for speed).
;
;    B$OVWCSR - Turn overwrite cursor on and move to specified location.
;		 The overwrite cursor has the same specifications as the
;		 user cursor, but does not obey the visibility parameter
;		 specified in B$CSRATR.
;
;Entry:
;	[DL] = new 1-relative line number
;	[DH] = new 1-relative column number
;	It is assumed that the values in DX are in range.
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX,CX,DX
;
;Exceptions:
;	None.
;****
;***
;B$CSRDSP - Change Cursor Type and Location
;
;Purpose:
;	This routines display the specified cursor at a particular
;	location as given by the input parameters.  It may also
;	request to not display a cursor.  The text mode graphics cursor
;	will be implemented as a full block for user cursor requests,
;	and as a 1/2 block for insert modes.  The graphics cursor will
;	be handled separately (for DOS3) since the IBM BIOS does not
;	support a cursor font in graphics mode.
;
;	Entry points B$OFFCSR, B$OVWCSR, B$INSCSR, and B$USRCSR	[16]
;	exist to set AX to the appropriate value before falling through	[16]
;	into B$CSRDSP, in order to save code space. (Documented above)
;
;Algorithm:
;
;    B$CSRDSP:
;	if not OS/2
;	  if graphics request then
;	    if previous cursor valid
;	      if previous cursor is not an off cursor
;	        erase previous cursor using xor function on previous cursor
;	        and the screen.
;
;	convert 1-relative row and col to 0-relative row and column
;	swap row and col registers for bios call
;	get active screen page number
;	move cursor to desired location
;	swap start and stop lines
;	if text mode or OS/2
;	  if cursor type request != current cursor type
;	    change cursor to new type
;	else (DOS3 graphics modes)
;	  if requested cursor is not for an off cursor
;	    display requested cursor using an xor function on requested cursor
;		and the screen.
;	store new cursor position and type
;
;Entry:
;	b$CSRTYP = current cursor position
;	[AX] = new cursor type
;	[DL] = new 1-relative line number
;	[DH] = new 1-relative column number
;	It is assumed that the values in DX are in range.
;
;Exit:
;	b$CSRTYP = current cursor type (start and stop lines)
;
;Modifies:
;	None
;
;Preserves:
;	BX,CX,DX
;
;Exceptions:
;	None.
;****
CSRGRPH:
				;here if screen mode graphics
	PUSH	AX		;save csr request for call
	MOV	AX,b$CSRTYP	; get previous cursor type
	CMP	AL,-1		; unknown previous cursor type?
	JZ	NO_CURSOR	; brif so -- no cursor to erase
	CALL	GRPCSR		;erase previous cursor
NO_CURSOR:
	POP	AX		;restore csr request
	JMP	SHORT TXTCSR

labelNP <PUBLIC,B$SCNLOC>	; update cursor position variable
	MOV	b$CURSOR,DX	; and fall into SLOWUSRCSR.

labelNP <PUBLIC,B$SlowUsrCsr>
	CMP	[B$UsrCsrOn],0	; should users cursor be displayed?
	JZ	B$OFFCSR	; brif not -- turn off cursor

USRCSR:
	CMP	b$ScreenMode,0	; is screen mode graphics?
	JNZ	B$OFFCSR	; brif so -- use off cursor

labelNP <PUBLIC,B$OVWCSR>	; display overwrite cursor
	MOV	AX,b$UsrCsrTyp	; get user defined cursor
	JMP	SHORT B$CSRDSP	; and display it

labelNP <PUBLIC,B$INSCSR>	; display insert mode cursor
	MOV	AX,b$InsCsrTyp	; get insert mode cursor
	JMP	SHORT B$CSRDSP	; and display it

labelNP <PUBLIC,B$USRCSR>	; conditionally display user cursor
	CMP	[B$UsrCsrOn],0	; should users cursor be displayed?
	JNZ	USRCSR		; brif so -- check for graphics mode
	CMP	b$CSRTYP,OffCsrTyp ; cursor already off?
	JNE	B$OFFCSR	; brif not -- turn it off now
	RET			; otherwise, don't position or check type.
				; check type.

; This REALLY speeds up print statements, but will usually NOT update the
; hardware cursor!  To FORCE the cursor to get reset, invalidate the cursor
; type by moving -1 into b$CSRTYP.

labelNP <PUBLIC,B$OFFCSR>	; turn cursor off
	MOV	AX,OffCsrTyp	;  get off cursor


cProc	B$CSRDSP,<NEAR,PUBLIC>,<BX,CX>
cBegin

	PUSH	AX		; save registers
	PUSH	DX
	CALL	B$SCINIT	; make sure screen is initialized.
	cmp	b$ScreenMode,0	;is screen mode graphics?
	JNZ	CSRGRPH 	;br. if so
TXTCSR:

	DEC	DX		; DL = 0-relative row
	XCHG	DH,DL		;swap for BIOS call
	DEC	DX		; DL,DH = 0-relative column,row
	MOV	BH,b$ActPage	;get active page
	PUSH	AX		;save cursor type
	SCNIOS vSetCursorPos	; issue BIOS call to move cursor
	POP	AX		;recover cursor type
	cmp	b$ScreenMode,0	;Text mode ?
	JNZ	NOT_TEXT_MODE	; Brif not -- generate graphics cursor
	CMP	AX,b$CSRTYP	; (speed) need to change the cursor type?
	JE	DSPRET		; (speed) brif not -- just return
	XCHG	AX,CX		; CX = cursor type
				; CH = start line, CL = stop line


	SCNIOS	vSetCursorType	; display requested cursor
; The bios does not set the cursor type right for IBM EGA cards
; when trying to get an underline cursor when not in 25-line mode.  So
; we have to set it ourselves.  We do the BIOS call beforehand to update
; the internal BIOS cursor type variable.
	TEST	CH,20H		; cursor off request?
	JNZ	NoChangeType	; brif so -- don't reset type
	TEST	b$Adapter,EGA	; EGA adapter?
	JZ	NoChangeType	; brif not -- don't reset type
	CMP	b$ScrHeight,25	; 25-line mode?
	JZ	NoChangeType	; brif not -- don't reset type
	MOV	DX,03D4h	; EGA port
	XCHG	AX,CX		; AH = start line
	MOV	AL,0Ah		; select start line register
	OutWord 		; write correct value - macro for AT&T 6300
NoChangeType:

DSPRET:
	POP	DX		; restore new position and type
	POP	AX
	MOV	b$CSRTYP,AX	; store current cursor type
cEnd


NOT_TEXT_MODE:
	CALL	GRPCSR		; generate graphics cursor
	JMP	DSPRET		; exit

;*** 
; GRPCSR -- Toggle a generated graphics mode text cursor (DOS 3 only)
;
;Purpose:
;
;Entry:
;	AX = cursor type
;
;Exit:
;	None
;Uses:
;	AX,BX,CX
;
;Preserves:
;	DX
;
;Exceptions:
;	None
;
;******************************************************************************

cProc	GRPCSR,<NEAR>
cBegin
	CMP	AX,OffCsrTyp	; cursor off request?
	JE	GRPRET		; brif so -- return without doing anything
	PUSH	ES		; save ES
	mov	bl,[b$BiosMode] ; check BIOS mode
	cmp	bl,13h		; VGA mode 13h?
	je	Cursor13	; go if so
	XOR	CX,CX		; CX = 0
	MOV	ES,CX		; ES = 0
	CMP	BL,40h		; Is it Olivetti 640x400 mode?
	JNE	NotCsr40h	; brif not

; The Olivetti VGA handles character fonts normally in mode 40h, but we
; special-case their CGA and EGA which use a MASTER TABLE POINTER at 40:84.

	TEST	[b$Adapter],CGA+EGA; Is it CGA or EGA Olivetti?
	JZ	NotCsr40h	; brif not (ie. Olivetti VGA)

;Note: B$OgaCsr requires ES = CX = 0 on entry

	CALL	[b$pOgaCsr]	; use Olivetti version of routine
	JMP	SHORT GrpRet2
NotCsr40h:
	PUSH	ES:CHREXT	;Save Old Char Extention Ptr
	PUSH	ES:CHREXT+2
	MOV	ES:WORD PTR CHREXT,OFFSET DGROUP:BLTLOT
	MOV	ES:CHREXT+2,DS	;Segment Addr of Box Char

	CMP	AX,b$InsCsrTyp	; is it an insert cursor?

	PUSHF			; save check for insert mode
	cmp	b$BiosMode,8	;Hercules graphics mode?
	je	UseEga		;use EGA code if so
	CMP	b$BiosMode,0Dh	;current screen mode EGA?
	JB	NotEga		;brif not Ega mode
UseEga:
	MOV	BL,b$ForeMapped ;use current color
	OR	BL,080H 	;set XOR bit
	MOV	AL,0DCh 	;half height block character for EGA
	POPF			;insert mode?
	JZ	GRPCS2		;brif insert cursor
	DEC	AL		;make overwrite cursor
	JMP	SHORT GRPCS2
NotEga:
	POPF			;insert mode?


	MOV	AL,128		;Char code for Box
	JZ	GRPCS1		;brif it is insert cursor
	INC	AL		;Map to 128 or 129..
GRPCS1: 			;Half Box (128) If INS_MODE
				;Whole Box (129) for normal (NOT INS_MODE)
	MOV	BL,87H		;Select Invert (xor) Mode
				;bit 7 of [BL] = 1 for XOR mode and
				;low nibble =7, bcos we need low intensity white

GRPCS2:
	MOV	BH,b$ActPage	; Active Page
	INC	CX		; CX = 1 -- One Character
	SCNIOS	vWriteChar
	POP	ES:CHREXT+2
	POP	ES:CHREXT	;Restore Char Extention ptr
GrpRet2:
	POP	ES		;restore register
GRPRET:
cEnd

;
;BIOS mode 13H (SCREEN 13) does not perform XOR drawing of characters.
;We must therefore draw the cursor the hard way, XORing the 8x8 character
;cell with the desired cursor color.
;
Cursor13:
	push	dx		;preserve DX
	push	ax		;save cursor type
	SCNIOS	vReadCursorPos	;DH=cursor row, DL=column
	xor	ax,ax
	xchg	al,dh		;AX=row, DX=col
	mov	cl,3		;*8
	shl	ax,cl		;AX=Y coordinate of character
	shl	dx,cl		;DX=X coordinate of character
	mov	cx,dx		;CX=X
	mov	dx,ax		;DX=Y
	call	[b$MapXYC]	;convert X,Y to buffer offset
	mov	al,b$ForeMapped ;get cursor color
	mov	ah,al		;replicate for 2 pixels
	les	bx,b$AddrC	;buffer address for character start
DbAssertRel    ES,E,0A000H,RT_TEXT,<Buffer segment invalid in B$CSRDSP> 
	mov	cx,8		;8 raster lines down per character
	pop	dx		;restore cursor type
	cmp	dx,b$InsCsrTyp	;is it an insert cursor?
	jne	NextRaster	;go if not for full-block cursor
	shr	cx,1		;half-block cursor
	add	bx,320*4	;start 4 rasters down, do half as many
NextRaster:
	push	cx
	mov	cx,4		;8 pixels (4 words) across per character
NextWord:
	xor	word ptr es:[bx],ax ;xor 2 pixels with color
	inc	bx		;to next word
	inc	bx
	loop	NextWord	;do all 8 pixels
	pop	cx
	add	bx,320-8	;down to next raster and back to left
	loop	NextRaster
	pop	dx		;restore DX
	jmp	short GrpRet2


;***
;B$SCROLL - Scroll the screen by one line
;OEM-interface routine
;
;Purpose
;	Scrolls up one line an area of the screen with a left,top corner of
;	(1,b$WDOTOP), and a right,bottom corner of (b$CRTWIDTH,b$WDOBOT)
;
;Entry:
;	b$WDOTOP, b$WDOBOT, b$CRTWIDTH set.
;
;Exit:
;	None
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$SCROLL,<PUBLIC,NEAR>,<AX,BX,CX,DX>
cBegin

	XOR	CX,CX		; CL = left column (0-relative)
	MOV	CH,b$WDOTOP	; CH = top row
	DEC	CH		; make it 0-relative
	MOV	BL,b$CRTWIDTH	; BL = right column
	MOV	BH,b$WDOBOT	; BH = bottom row
	DEC	BX		; make column 0-relative
	DEC	BH		; make row 0-relative

OLD_SCROLL:			; former entry point
;	[BH] = Window bottom row (0-relative)
;	[BL] = Right column of scroll window (0-relative)
;	[CH] = Window top row (0-relative)
;	[CL] = Left column of scroll window (0-relative)

	cCALL	B$SELAPG	; Active Visual Page

;	Determine if scrolling is Horizontal or Vertical by comparing
;	source line and destination line
;	Source line will can be equal to destination line if VIEW PRINT n TO n
;	is used.

;	Use BIOS/DOS support to scroll a window of any size

	MOV	DX,BX		;copy bottom right coordinates
	MOV	BH,b$NullColor	;get scroll attribute
	XOR	AX,AX		; zero lines default	

	CMP	CH,DH		; only one line to scroll?
	JE	ScrollSet	; brif so -- just clear screen
	INC	AX		; Set number of lines to scroll as 1
ScrollSet:			
	SCNIOS	vScrollPageUp	;SCROLL page up

SCROLL_RET:			; All done .. Exit after setting current
	cCALL	B$SELVPG	; Active Visual Page

cEnd				; End of B$SCROLL

;===================================


;*** 
; B$ErrorReturn
;
;Purpose:
;	Return carry set, indicating error.
;
;Entry:
;	None.
;
;Exit:
;	PSW.C = set
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;******************************************************************************

cProc	B$ErrorReturn,<PUBLIC,NEAR>
cBegin
	stc
cEnd

;*** 
; B$ScreenN
;
;Purpose:
;	Invoke b$ScreenX[AL] to initialize mode data for the screen mode
;	specified in AL.
;
;Entry:
;	AL = Screen Mode
;	AH = Burst (0/1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates an error (mode not supported)
;Uses:
;	per convention
;Preserves:
;	AX, BX, CX, DX.
;Exceptions:
;******************************************************************************

cProc	B$ScreenN,<PUBLIC,NEAR>,<AX,BX,CX,DX> 
cBegin
	MOV	BX,[b$ScreenX]  ; BX = DGROUP offset of screen mode table
	CMP	[BX],AL 	; invalid mode?
	JB	ScrNExit	; brif so -- exit with carry set
	MOV	DL,AL		; Form screen mode in DX
	XOR	DH,DH		; [DX] = screen mode
	ADD	BX,DX
	ADD	BX,DX		; [DS:BX] = pointer-1 to pointer to routine
	CALL	word ptr [BX+1]	; set mode-dependent data
ScrNExit:
cEnd

;***
;B$GetParm - get a parameter from the list passed from high levels
;OEM-interface routine
;
;Purpose:
;	This routine gets a parameter from the list pointed to by SI.
;	The first word of the list is a flag specifying if a parameter
;	was specified.	If the flag is non-zero the next word in the
;	list is the parameter.	Otherwise the next word in the list
;	is the flag for the next parameter.  The list grows from high
;	memory down.  This routine will not modify the list.
;
;	For example, if CX = 11,
;
;	---------------------------------------------------------
;	| 51 |	~0|  4 | ~0 | 255|  ~0 |  0 |  0 | 23 | ~0 | 0	|
;	---------------------------------------------------------
;							      ^
;							     SI
;	will return the following on successive calls:
;
;		   CX	   AL	   AH	   PSW.Z
;
;		   10	    -	    1	     reset
;		    8	   23	    0	     reset
;		    7	    -	    1	     reset
;		    6	    -	    1	     reset
;		    4	  255	    0	     reset
;		    2	    4	    0	     reset
;		    0	   51	    0	     reset
;		    0	    -	    1	     set
;
;	NOTE: Although both the flags and values are WORDs, any value
;	      that is greater than 255 will cause an Illegal Function
;	      Call. It is assumed that the list will be in a proper
;	      format.
;
;Entry:
;	[SI] - points to high end of parameter list
;	       (parameters run from high to low memory)
;	[CX] - count of words left in list
;
;Exit:
;	[SI] - points to next parameter in list
;	[CX] - modified count of words left in parameter list
;	[AL] - parameter, if one was specified
;	[AH] - 1 if parameter was missing or defaulted, 0 otherwise
;	PSW.Z - set means no parameter was found
;
;Uses:
;	SI is used as a return value
;
;Preserves:
;	BX, DX
;
;Exceptions:
;	B$ERR_FC if the value of the parameter > 255.
;******************************************************************************
cProc	B$GetParm,<PUBLIC,NEAR>
cBegin
	mov	ah,1		;ah=1 means (missing or) defaulted
	STD			;from high to low....
	OR	CX,CX		;unfortunately, JCXZ doesn't set 0 flag
	JZ	GetParmExit	;brif list empty
	LODSW			;get parameter flag

	DEC	CX		;one less word in list....
	OR	AX,AX		;was param defaulted?
	mov	ah,1		;ah=1 means (missing or) defaulted
	JZ	GetParmExit	;brif so...
DbAssertRel    CX,NZ,0,CN_TEXT,<Parameters out of sync in B$GetParm>

	LODSW			;get parameter
	OR	AH,AH		
	JNZ	BadParm 	;Don't allow parms > 255
	DEC	CX		;one less word in list...
	OR	SP,SP		;got a parameter...
GetParmExit:
	CLD
cEnd

BadParm:			
	CLD			
	JMP	B$ERR_FC	;illegal function call


;***
;B$SETSCNDATA -- Set mode-dependent data for initialization.
;
;PURPOSE:
;	This sets up all the mode-dependent data, both high and low-level.
;	The startup screen mode or special mode characteristics (such as
;	43-line mode) may not be supported due to runtime version features
;	or mode-dependent module stubbing.  Default mode characteristics
;	are used if the screen mode is available.  Screen 0 is used if the
;	startup mode itself is not supported.
;	Major rewrite with [22].
;
;ENTRY:
;	AL = Screen Mode ... all gleened from the initialization state
;	AH = Burst
;	CL = Screen Width
;	CH = Screen Height
;	DL = Active Page
;	DH = Visual Page
;
;EXIT:
;	Most internal screen variables set.
;
;USES:
;****

cProc	B$SETSCNDATA,<NEAR,PUBLIC>
cBegin
	call	B$ScreenN	;set mode-dependent data
	jnc	ScrOk		;go if mode supported
	cmp	al,1		;trying for screen 1?
	jne	BurstOk 	;go if not
	xor	ah,al		;invert burst if going from screen 1 to 0
BurstOk:
	xor	al,al		;default to screen 0
	call	B$ScreenN	;set up screen 0
ScrOk:
	xchg	bx,cx		;width/height to BX
	push	dx		;save pages
	call	[b$AlphaDim]	;set text dimensions
	call	B$FixTextPage	
	mov	al,b$ScrWidth	
	mov	cl,b$ScrHeight 
	cCALL	B$SCNSWI	;Inform Hi-Level about dimensions change
	pop	ax		;AX=act/vis pages for b$SetPages
	cmp	al,b$MaxPage	;Active Page OK?
	ja	ResetPage	;go if not
	cmp	ah,b$MaxPage	;Visual Page OK?
	jbe	PageOk		;go if not
ResetPage:
	xor	ax,ax		;clear both pages if either invalid
PageOk:
	call	[b$SetPages]	;set page values
cEnd



;***
;B$RESETSCN -- Reset the screen startup mode for termination.
;OEM-interface routine
;
;Purpose:
;	This routine sets up the mode dependent data and the screen
;	to the startup mode for termination.  The startup mode was
;	saved by B$GWINI in a form that our standard routines would
;	be able to use it for termination.  If delayed screen initialization
;	is being implemented and the physical screen has not yet
;	been changed, then this routine should just change internal
;	variables.  However if the screen has been changed, this
;	routine must change the physical screen parameters to their
;	entry value.
;
;Entry:
;	None.
;
;Exit:
;	Most internal screen variables set.
;	b$ScreenRestored set properly
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;****
;
;NOTE:
;	The startup mode and characteristics were filtered by B$SETSCNDATA
;	to values that we can support here.
;
;Our Entry Conditions:
;
;	b$OrgScrBst = original startup screen mode and burst
;	b$OrgScrDim = original startup screen dimensions
;	b$OrgEquip  = original startup equipment flags
;	b$OrgCsrTyp = original startup cursor type
;	b$OrgPages  = original startup active/visual pages
;

cProc	B$RESETSCN,<NEAR,PUBLIC>
cBegin
	mov	b$ScreenRestored,0  ;first assume no screen change
; With a VGA, the BIOS actually changes the BiosEquip flags to reflect
; the current mode.  If we change it back (or the user POKEs it)
; the BIOS can get awfully confused!  So DON'T mess with it!
	test	b$Adapter,VGA	;using VGA?
	jnz	ChkMode 	;avoid Equipment flag check if so
				;carry clear means must check mode
	xor	ax,ax		;use seg = 0
	mov	es,ax		
	mov	al,b$OrgEquip	;check the original equipment flags
	cmp	al,es:[BiosEquip] ;were they changed?
	mov	es:[BiosEquip],al ;restore original equipment flags
	push	ds		
	pop	es		
	je	ChkMode 	;no change, go check for mode change
				;carry clear means must check mode
	call	B$SetAdapter	;make sure the adapter info is current
	stc			;carry set means force SetMode
ChkMode:			
	mov	ax,b$OrgScrBst	;original screen mode and burst
	mov	cx,b$OrgScrDim	;	       width and height
	jc	SetMode 	;go if decision already made to SetMode
	cmp	al,b$ScreenMode;mode changed?
	jne	ChgMode 	;go if so
	cmp	ah,b$Burst	;burst changed?
	jne	ChgMode 	;go if so
	cmp	ch,b$ScrHeight ;height changed?
	jne	ChgMode 	;go if so
	cmp	cl,b$ScrWidth	;width changed?
	je	SetMode 	;go if not
ChgMode:			
	stc			;carry set means force SetMode
SetMode:			
	pushf			;save SetMode decision
; Always set screen mode data with B$ScreenN and b$AlphaDim which do
; not change the physical screen.
; B$SCNSWI must be called to reset the text (VIEW PRINT) window.
	call	B$ScreenN	;set mode-dependent data
	xchg	bx,cx		;width/height to BX
	call	[b$AlphaDim]	;set text dimensions
	mov	al,b$ScrWidth	
	mov	cl,b$ScrHeight 
	cCALL	B$SCNSWI	;Inform Hi-Level about dimensions change
	popf			;should we SetMode
	jnc	NoChgMode	;go if not
	mov	b$ScreenRestored,1  ;Set flag for QB because screen changed
	call	B$ChkMonitor	; Set VGA monitor type before setting mode
	call	[b$SetMode]	;actually set the mode
	call	B$SCNCLR 	
	jmp	short Cleanup	
NoChgMode:			
	call	B$VIEWINIT	;reset viewports
Cleanup:			
	call	B$FixTextPage	
	call	[b$PalReset]	; reset the palette to default
	mov	dx,b$CURSOR	; force positioning of cursor
	call	B$OFFCSR	
	mov	ax,b$OrgPages	;restore startup page selections
	call	[b$SetPages]	
	call	B$GETCSRDATA	; DX = cursor positon for this page
	mov	b$CURSOR,dx	; update cursor position in case pages
				; changed (QB can re-start after this
	xor	cx,cx		; reset b$KEY_SW to 0
	xchg	[b$KEY_SW],cl	; KEY OFF (equivalent to call B$TKEYOF)
	jcxz	no_keys		; brif already off
	call	[b$vKEYDSP]	; turn function key display off if on
no_keys:			; (clears status line).  This should be
				; done in the final ACTIVE=VISUAL page
	cCall	B$GRMODE	
	jz	TextMode	; brif so
	call	B$OFFCSR	; turn off cursor for graphics modes
	jmp	short ResetExit	
TextMode:
	mov	ax,b$OrgCsrTyp	; get startup cursor type
	call	B$CSRDSP	; display startup cursor type
ResetExit:			
cEnd


;*** 
;B$SetDOS5Mode - Set screen mode for OS/2
;OEM-interface routine
;
;Purpose:
;	Set the screen mode for OS/2.
;
;	In order to perform a CHAIN command under OS/2 and pass COMMON
;	variables, the normal initialization has to be avoided.  What
;	happens is that the parent process does not terminate immediately,
;	but waits for a signal from the child process.	When this occurs,
;	the parent process will set some shared variables and signal the
;	child, which will start a signal handler.  This handler copies all
;	the data from the parents data space into its own data space, using
;	the shared variables set up by the parent to delimit how much
;	data has to be moved.  At this point, all the data is set up for
;	executing the program, but the machine state has to be updated.
;	Everything but the screen is set by the standard calls.   This
;	routine will update the screen state so that it matches the state
;	of the parent, who has now terminated.	To do this, it must have
;	kept a record of the old state.
;
;	In our implementation, we save all the information that needs to
;	be passed to GIOSETMODE which is called in this routine and we
;	also calculate the Segment descriptor for the video memory.
;
;	This is a OS/2 only routine.
;
;Entry:
;	b$Dos5Packet set as OS/2 VIO/GIO set mode data packet
;
;Exit:
;	None.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;******************************************************************************



sEnd	CN_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llegasup.asm ===
TITLE	LLEGASUP - LowLevel EGA support (shared routines)
;***
; LLEGASUP - LowLevel EGA support
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This module contains support routines extracted from LLEGA.ASM
;	which are shared by EGA and VGA functions.
;
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_BSS
	USESEG	GR_TEXT

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE baslibma.inc
	INCLUDE llgrp.inc

sBegin	_BSS
;
;
; ***************************************************************************
; External variables
; ***************************************************************************
;
externB b$EgaPalSup
externD b$InitPalette
externB b$MaxColor
externB b$Monitor
externW B$LEOFST
externW B$REOFST
externW B$VTOFST
externW B$VBOFST
externW B$VLOFST
externW B$VROFST
externB B$VLMASK
externB B$VRMASK
externD b$AddrC
externB b$AttrC
externW b$BytesPerRow
externB b$DivShift
externB b$EgaWrMd
externW b$Incr1
externW b$Incr2
externW b$IncrY
externB b$MaskC
externB b$MaxAttr
externW b$ModMask
externW b$OffC
externB b$PaintBorder
externW b$PenC
externB b$Planes
externW b$SegC
externB b$Tiling
externW b$SaveCa
externB b$SaveCm
externB b$PlaneMask
;
; ***************************************************************************
; External function vectors
; ***************************************************************************
;
externW b$PutVector
externW b$ReadC
externW b$PalTrans
externW b$PalPut
;
; ***************************************************************************
; Local variables
; ***************************************************************************
staticB AttrTile,,4		;tile attribute pattern table
staticB ColorBits,,8		;table of rotated tiling patterns
staticW ByteCount,,1
staticB EgaPalette,,17
;

sEnd	_BSS

assumes CS,GR_TEXT

sBegin	GR_TEXT

externNP B$BumpDS
externNP B$BumpES		
externNP B$DecDS		
externNP B$OutWord
externNP B$ResetEGA

;***
; B$EgaMapXYC_D
;
;Purpose:
;	Map given X and Y coordinates to the graphics cursor for Screen 7.
;Entry:
;	CX = X coordinate
;	DX = Y coordinate
;Exit:
;	b$OffC, b$MaskC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaMapXYC_D,<PUBLIC,NEAR>
cBegin
	mov	bx,dx		;multiply y by 40 to compute row displacement
	shl	dx,1		;dx=2*Y
	shl	dx,1		;dx=4*Y
	add	dx,bx		;dx=5*Y
	jmp	short MapCommon
cEnd	<nogen>

;***
; B$EgaMapXYC
;
;Purpose:
;	Map given X and Y coordinates to the graphics cursor for EGA modes
;Entry:
;	CX = X coordinate
;	DX = Y coordinate
;Exit:
;	b$OffC, b$MaskC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaMapXYC,<PUBLIC,NEAR>
cBegin
	mov	bx,dx		;multiply y by 80 to compute row displacement
	shl	dx,1		;dx=2*Y
	shl	dx,1		;dx=4*Y
	add	dx,bx		;dx=5*Y
	shl	dx,1		;dx=10*Y
MapCommon:
	shl	dx,1		;dx=20*Y
	shl	dx,1		;dx=40*Y
	shl	dx,1		;dx=80*Y   (40*Y for mode 0DH)
	mov	ax,cx		;save x
	shr	ax,1		;div by PixelsPerByte (8)
	shr	ax,1		;  to get byte index
	shr	ax,1
	add	dx,ax		;add x byte offset to y row address
	mov	b$OffC,dx	;save byte offset
	and	cl,7		;mask in x bit addr
	mov	ch,10000000B	;leftmost pixel on in shift mask
	shr	ch,cl		;move over to get mask
	mov	b$MaskC,ch	;store cursor mask
cEnd

;***
; B$EgaLeftC/B$EgaLeftC_13
;
;Purpose:
;	Move graphics cursor left 1 pixel for EGA modes or Screen 13,
;	depending on entry point.  No test is made for screen boundaries.
;Entry:
;	None
;Exit:
;	b$MaskC, b$OffC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaLeftC,<PUBLIC,NEAR>
cBegin
	rol	b$MaskC,1
	jc	LeftCnext	;go if not in same byte
	ret
labelNP <PUBLIC,B$EgaLeftC_13>
LeftCnext:
	dec	b$OffC 	;move byte pointer
cEnd

;***
; B$EgaChkUpC
;
;Purpose:
;	Move graphics cursor up 1 pixel for EGA modes.	A test is made for
;	boundaries.  If it is a boundary then PSW.C is set upon return and
;	no move is made.
;
;Entry:
;	None
;Exit:
;	b$MaskC, b$OffC updated
;	PSW.C = set if original graphics cursor was on screen top edge.
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaChkUpC,<PUBLIC,NEAR>
cBegin
	MOV	AX,b$OffC	;[AX] = cursor offset
	CMP	AX,B$VTOFST	;already on top of viewport ?
	JAE	B$EgaUpC	;less than VTOFST means on top of
				;viewport
	STC			;STC to indicate that cursor already
cEnd				;on top of viewport

;***
; B$EgaUpC
;
;Purpose:
;	Move graphics cursor up 1 pixel for EGA modes.	No test is made for
;	screen boundaries.
;Entry:
;	None
;Exit:
;	b$MaskC, b$OffC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaUpC,<PUBLIC,NEAR>
cBegin
	mov	ax,b$BytesPerRow 
	sub	b$OffC,ax	;up one row
	clc			;(no error for ChkUpC)
cEnd

;***
; B$EgaChkDownC
;
;Purpose:
;	Move graphics cursor down 1 pixel for EGA modes.  If beyond the
;	bottom edge, PSW.C is set upon return and no move is made.
;Entry:
;	None
;Exit:
;	PSW.C = set if original cursor was on screen edge.
;	b$MaskC, b$OffC Updated otherwise
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaChkDownC,<PUBLIC,NEAR>
cBegin
	MOV	AX,b$OffC	;[AX] = cursor offset
	CMP	AX,B$VBOFST	;already at the bottom of viewport?
	JB	B$EgaDownC	;Brif not
	STC			;STC to indicate that cursor is
cEnd				;on bottom of viewport

;***
; B$EgaDownC
;
;Purpose:
;	Move graphics cursor down 1 pixel for EGA modes.  No test is made for
;	screen boundaries.
;Entry:
;	None
;Exit:
;	b$MaskC, b$OffC Updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaDownC,<PUBLIC,NEAR>
cBegin
	mov	ax,b$BytesPerRow 
	add	b$OffC,ax	;down one row
	clc			;(no error for ChkDownC)
cEnd

;***
; B$EgaSetAttr
;
;Purpose:
;	Set b$AttrC to user-supplied attribute for EGA modes.	If
;	user-supplied attribute is outside legal range, use maximum legal
;	attribute.
;Entry:
;	AL = attribute
;Exit:
;	b$AttrC set to new attribute
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaSetAttr,<PUBLIC,NEAR>,<AX>
cBegin
	cmp	al,b$MaxAttr	;test against maximum attribute
	jbe	SetAttrOk	;Brif legal
	mov	al,b$MaxAttr	;limit to max
SetAttrOk:
	mov	b$AttrC,al
	clc			;exit no error
cEnd

;***
; B$EgaReadC
;
;Purpose:
;	For EGA modes, return the attribute of the current pixel as
;	specified by b$MaskC and b$OffC.
;
;Entry:
;	b$MaskC and b$OffC specify pixel to read
;Exit:
;	AL = attribute of pixel
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaReadC,<PUBLIC,NEAR>,<SI,ES>
cBegin
	les	si,b$AddrC
	mov	bx,0103H	;start at plane 3 and dec by 1 for 4 planes
ReadCX1:
	EGAINT10CLI		; disable interrupts if using EGAINT10
	MOV	DX,GRPADD	;address of graphics index register
	MOV	AX,RWMREG	;r/w mode index in AL, 0 in AH
	OutWord 		;set read mode to 0 so that we read byte
				;specified as 0/1 for one plane at a time
	MOV	AL,RMPREG	;AL=index to read map reg
	OUT	DX,AL		;indicate next data for read map register
	INC	DX		;data port address
	MOV	al,bl		;al = plane number
	xor	ah,ah		;ah = color accumulator
	MOV	cl,b$MaskC	;bit position
ReadC1:
	OUT	DX,AL		;indicate plane to read
	MOV	ch,ES:[si]	;get 8 bits for plane
	AND	ch,cl		;isolate bit to read
	neg	ch		;carry = (ch==0)?0:1
	rcl	ah,1		;shift bit into color accumulator
	sub	al,bh		;reference next color plane to read
	jae	ReadC1		;do next plane
	XCHG	AH,AL		;color attribute returned in AL
	CALL	B$ResetEGA	;set up EGA for next BIOS write
cEnd

;***
; B$EgaReadC_F
;
;Purpose:
;	For Screen 10, return the attribute of the current pixel as
;	specified by b$MaskC and b$OffC.
;
;Entry:
;	b$MaskC and b$OffC specify pixel to read
;Exit:
;	AL = attribute of pixel
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaReadC_F,<PUBLIC,NEAR>,<SI,ES>
cBegin
	les	si,b$AddrC
	mov	bx,0202H	;start at plane 2 and dec by 2 for 2 planes
				;  (0&2)
	jmp	short ReadCX1	;continue in common code
cEnd	<nogen>

;***
; B$EgaReadC_64K
;
;Purpose:
;	For Screen 9/64K, return the attribute of the current pixel as
;	specified by b$MaskC and b$OffC.
;
;Entry:
;	b$MaskC and b$OffC specify pixel to read
;Exit:
;	AL = attribute of pixel
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaReadC_64K,<PUBLIC,NEAR>,<SI,ES>
cBegin
	les	si,b$AddrC
	mov	bx,si		;copy video address
	mov	bh,2		;bh = dec by 2 between planes
	and	bl,1		;1 if odd, 0 if even
	add	bl,bh		;bl = plane (use maps 3 and 1 if odd address)
				;	    ( or maps 2 and 0 if even address)
	jmp	short ReadCX1	;continue in common code
cEnd	<nogen>

;***
; B$EgaSetC
;
;Purpose:
;	Set the pixel defined by the current graphics cursor to
;	the current attribute for EGA modes.
;Entry:
;	b$PenC  = cursor mask and attribute
;	b$AddrC = address of pixel byte
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaSetC,<PUBLIC,NEAR>,<ES>	
cBegin
	EGAINT10CLI		; disable interrupts if using EGAINT10
	MOV	DX,GRPADD	;address of graphics index port
	MOV	AL,RWMREG	;index to the graphics controller mode reg
	OUT	DX,AL
	MOV	AL,b$EgaWrMd	;write mode 2; odd/even or sequential addr.
	INC	DX		;address data port
	OUT	DX,AL
	MOV	AL,BMKREG	;index to the bit mask register
	DEC	DX
	OUT	DX,AL
	mov	ax,b$PenC	;[al] = cursor mask, [ah] = attribute
	INC	DX
	OUT	DX,AL		;set bit mask
	les	bx,b$AddrC	;[BX] = cursor offset, [DS] = segment
	XCHG	ah,es:[BX]	;latch screen contents and do a color write
	;reset EGA regs to those expected by the BIOS
	MOV	AL,0FFH 	;set all mask bits
	OUT	DX,AL
	MOV	AL,RWMREG	;index to the graphics controller mode reg
	DEC	DX
	OUT	DX,AL
	MOV	AL,b$EgaWrMd	;odd/even or sequential addr.
	and	al,10H		;set write mode 0 for bios
	INC	DX
	OUT	DX,AL
	EGAINT10STI		; reenable interrupts if using EGAINT10
cEnd

;***
; B$EgaSetPixC
;
;Purpose:
;	Set the pixel defined by the current graphics cursor to
;	the current attribute for EGA modes.  This is identical
;	to B$EgaSetC with the initialization and termination code
;	extracted to make it faster when multiple pixels are being
;	set in a graphics functin (ie: CIRCLE).  A call to
;	B$EgaSetPixFirstC should preceed the first call to
;	B$EgaSetPixC.	A call to B$ResetEGA should follow
;	the last.  B$EgaSetPixFirstC sets up ES which should be
;	preserved for all B$SetPixC calls.
;Entry:
;	ES	= video segment (set up by B$EgaSetPix)
;	b$PenC = cursor mask and attribute
;	b$OffC = address of pixel
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaSetPixC,<PUBLIC,NEAR>
cBegin
	MOV	DX,GRPADD+1	;address graphics data port
	mov	ax,b$PenC	;[al] = cursor mask, [ah] = attribute
	OUT	DX,AL
	mov	bx,b$OffC	;[BX] = cursor offset
				;[ES] = setup by SetPixFirstC
	XCHG	ah,ES:[BX]	;latch screen contents and do a color write
cEnd

;***
; B$EgaSetPixFirstC
;
;Purpose:
;	Set up ES to the video segment and set up EGA write mode so
;	repeated calls can be made to B$EgaSetPixC without having
;	to reinitialize.
;Entry:
;	b$SegC    = video segment
;	b$EgaWrMd = EGA write mode to set up
;Exit:
;	ES = video segment
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaSetPixFirstC,<PUBLIC,NEAR>
cBegin
	mov	es,b$SegC	;ES = video segment for B$SetPix
	MOV	DX,GRPADD	;address of graphics index port
	MOV	AL,RWMREG	;index the graphics controller mode reg
	OUT	DX,AL
	MOV	AL,b$EgaWrMd	;write mode 2; odd/even or sequential addr.
	INC	DX		;address data port
	OUT	DX,AL
	MOV	AL,BMKREG	;index to the bit mask register
	DEC	DX		;leave bit mask register addressed so all
	OUT	DX,AL		;  we have to do is output the mask
cEnd

;***
; B$EgaLineX
;
;Purpose:
;	Draw an X-major line for EGA modes.
;Entry:
;	AH    = color (b$AttrC)
;	AL    = bit accumulator
;	BH    = bit mask
;	BL	unused
;	CX    = point count
;	DX    = EGA graphics controller data port
;	SI    = delta decision value
;	DI    = line style
;	BP    = video offset
;	ES    = video segment
;	Incr1 = major axis delta update value
;	Incr2 = minor axis delta update value
;	IncrY = BP change for Y movement
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaLineX,<PUBLIC,NEAR>
cBegin
	MOV	DX,GRPADD+1	;graphics controller data port for bit mask

LineEXloop:

	ROL	DI,1		;next line style bit
	JNC	LineEX2 	;go if bit is 0 not to plot

	OR	AL,BH		;OR this bit into byte mask
LineEX2:
	OR	SI,SI		;time to move in Y (+ or 0 delta)?
	JNS	LineEX4 	;go if so
	ADD	SI,b$Incr1	;update delta for X movement
	ROR	BH,1		;move to next X
	JC	LineEX3 	;go if not still in same byte
	LOOP	LineEXloop
	JMP	SHORT LineEX7
LineEX3:
	OUT	DX,AL		;output mask from accumulated pixels
	MOV	AL,AH		;color for write
	XCHG	AL,ES:[BP]	;read loads latches, write color thru mask
	XOR	AL,AL		;clear pixel accumulator
	INC	BP		;go to next byte
	LOOP	LineEXloop
	JMP	SHORT LineEX7
LineEX4:
	ADD	SI,b$Incr2	;update delta for Y movement
	OUT	DX,AL		;output mask from accumulated pixels
	MOV	AL,AH		;color for write
	XCHG	AL,ES:[BP]	;read loads latches, write color thru mask
	XOR	AL,AL		;clear pixel accumulator
	ROR	BH,1		;move to next X
	ADC	BP,b$IncrY	;move to next Y (+1 if next X byte)
	LOOP	LineEXloop
LineEX7:			;flush accumulated pixels
	OUT	DX,AL		;output mask from accumulated pixels
	XCHG	AH,ES:[BP]	;read loads latches, write color thru mask
cEnd

;***
; B$EgaLineY
;
;Purpose:
;	Draw a Y-major line for EGA modes.
;Entry:
;	AH    = color (b$AttrC)
;	AL    = bit mask
;	BH    = trash for XCHG
;	BL	unused
;	CX    = point count
;	DX    = EGA graphics controller data port
;	SI    = delta decision value
;	DI    = line style
;	BP    = video offset
;	ES    = video segment
;	Incr1 = major axis delta update value
;	Incr2 = minor axis delta update value
;	IncrY = BP change for Y movement
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaLineY,<PUBLIC,NEAR>
cBegin
	MOV	DX,GRPADD+1	;graphics controller data port for bit mask

LineEYloop:

	ROL	DI,1		;next line style bit
	JNC	LineEY2 	;go if bit is 0 not to plot

	OUT	DX,AL		;output bit mask
	MOV	BH,AH		;color for write
	XCHG	BH,ES:[BP]	;read loads latches, write color thru mask
LineEY2:
	OR	SI,SI		;time to move in X (+ or 0 delta)?
	JNS	LineEY3 	;go if so
	ADD	SI,b$Incr1	;update delta for Y movement
	ADD	BP,b$IncrY	;move to next Y
	LOOP	LineEYloop
	ret
LineEY3:
	ADD	SI,b$Incr2	;update delta for X movement
	ROR	AL,1		;move to next X
	ADC	BP,b$IncrY	;move to next Y (+1 if next X byte)
	LOOP	LineEYloop
cEnd

;***
; B$EgaLineV
;
;Purpose:
;	Draw a vertical line for EGA modes.
;Entry:
;	AH = color (b$AttrC)
;	AL = bit mask
;	BX = IncrY = BP change for Y movement
;	CX = point count
;	DI = line style
;	BP = video offset
;	ES = video segment
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaLineV,<PUBLIC,NEAR>
cBegin
	MOV	DX,GRPADD+1	;graphics controller data port for bit mask
	OUT	DX,AL		;output mask
	MOV	BX,b$IncrY	;to register here
LineEVloop:

	ROL	DI,1		;next line style bit
	JNC	LineEV2 	;go if bit is 0 not to plot

	MOV	AL,AH		;color for write
	XCHG	AL,ES:[BP]	;read loads latches, write color thru mask
LineEV2:
	ADD	BP,BX		;to next Y
	LOOP	LineEVloop
cEnd

;***
; PutPreset/PutOther
;
;Purpose:
;	Support routine for EGA PUT.  Write to the specified screen byte
;	the specified attribute (after NOTing it if entry point is Preset).
;	Write will apply bit-wise logic as defined by the contents of
;	DTRREG, which is set up in PUT action routines which then branch
;	to PutOther.
;Entry:
;	AH    = attribute
;	ES:DI = screen address
;Exit:
;	DI incremented to next screen address
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	PutPreset,<NEAR>
cBegin
	not	ah		;NEGATE DATA FOR PRESET
labelNP PutOther
	xchg	ah,es:[di]	;read loads latches, write sets data according
	inc	di		;  to EGA function set in DTRREG
cEnd

labelW	PutTable		;EGA write function according to put action
	DB	10000B		;Or
	DB	01000B		;And
	DB	00000B		;Preset (data unmodified, but NOT before)
	DB	00000B		;Pset	(data unmodified)
	DB	11000B		;Xor

;***
; B$EgaPutAction_64K
;
;Purpose:
;	Set b$PutVector to appropriate PUT action routine for Screen 9/64K.
;	Set up DTRREG according to PUT action table values so that next
;	screen write will apply the requested PUT action to the data.
;Entry:
;	AL = PUT action [0..4] representing (OR, AND, PRESET, PSET, XOR)
;Exit:
;	b$PutVector set to entry point of appropriate PUT action routine
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaPutAction_64K,<PUBLIC,NEAR>
cBegin
	mov	bl,11001100B	;setup for first plane pair (after two shifts)
	SKIP	2		;fall thru to normal PutAction
cEnd	<nogen>

;***
; B$EgaPutAction_F
;
;Purpose:
;	Set b$PutVector to appropriate PUT action routine for Screen 10.
;	Set up DTRREG according to PUT action table values so that next
;	screen write will apply the requested PUT action to the data.
;Entry:
;	AL = PUT action [0..4] representing (OR, AND, PRESET, PSET, XOR)
;Exit:
;	b$PutVector set to entry point of appropriate PUT action routine
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaPutAction_F,<PUBLIC,NEAR>
cBegin				;(NOTE: SKIP above!!)
	mov	bl,01000100B	;setup for first plane (after two shifts)
	SKIP	2		;fall thru to normal PutAction
cEnd	<nogen>

;***
; B$EgaPutAction
;
;Purpose:
;	Set b$PutVector to appropriate PUT action routine for EGA modes.
;	Set up DTRREG according to PUT action table values so that next
;	screen write will apply the requested PUT action to the data.
;Entry:
;	AL = PUT action [0..4] representing (OR, AND, PRESET, PSET, XOR)
;Exit:
;	b$PutVector set to entry point of appropriate PUT action routine
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaPutAction,<PUBLIC,NEAR>
cBegin
				;(NOTE: SKIPs above!!)
	mov	bl,10001000B	;setup for first plane (after 1 shift)
	mov	b$PlaneMask,bl
	;NOTE:	the plane mask is replicated in both nibbles for wrap-around
	;	shift, but will be masked to the low nibble for map-enabling
	mov	bx,GR_TEXTOFFSET PutPreset  ;assume preset
	cmp	al,2			    ;is it?
	je	IsPreset		    ;go if so
	mov	bx,GR_TEXTOFFSET PutOther   ;all others use same code and
IsPreset:				    ;  rely on EGA for operation
	mov	b$PutVector,bx 	    ;save vector
	mov	bx,GR_TEXTOFFSET PutTable   ;EGA function table
	xlat	cs:[bx] 		    ;convert put action to EGA func
	mov	ah,al
	MOV	DX,GRPADD	;address graphics controller
	mov	al,DTRREG	;data rotate/function register
	OutWord 		;select EGA logical operation
cEnd

	ASSUME	DS:NOTHING

;***
; B$EgaNReadL_F
;
;Purpose:
;	Read a line of pixels from the screen to an array for Screen 10.
;Entry:
;	ES:DI	= screen address
;	DS:SI	= array address
;	CL	= array align shift count
;	BP	= count of bits (not pixels) to read
;	BH	= plane to read from
;Exit:
;	DS:SI	= updated to array byte past point filled
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaNReadL_F,<PUBLIC,NEAR>
cBegin
	shl	bh,1		;logical plane 0 = physical plane 0
				;logical plane 1 = physical plane 2
cEnd	<nogen> 		;fall thru to regular NReadL

;***
; B$EgaNReadL
;
;Purpose:
;	Read a line of pixels from the screen to an array for EGA modes.
;Entry:
;	DS:SI	= screen address
;	ES:DI	= array address
;	CL	= array align shift count
;	CH	= mask for last partial byte
;	BP	= count of bits (not pixels) to read
;	BH	= plane to read from
;Exit:
;	ES:DI	= updated to array byte past point filled
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaNReadL,<PUBLIC,NEAR>
cBegin
	MOV	DX,GRPADD	;address graphics controller
	MOV	al,RMPREG	;read map select register
	out	dx,al		
	mov	al,bh		
	inc	dx		
	out	dx,al		
	mov	ah,[si] 	;preload hi byte
	inc	si		
NRdLoop:
	lodsb			;fill ax word with video bytes
	mov	bh,al		;this lo byte will become next hi byte
	rol	ax,cl		;align to array
	sub	bp,8		;8 bits done
	jbe	NRdLast 	;go if bit count exhausted
	mov	es:[di],ah	;save full byte
	inc	di		
	mov	ah,bh		;move lo byte (BH) to hi byte (AH)
	jnz	NRdLoop 	;loop if no offset overflow
	call	B$BumpES	;move array pointer over segment boundary
	jmp	short NRdLoop	;go do another
NRdLast:
	and	ah,ch		;strip unused bits from last byte
	mov	es:[di],ah	;save last byte
	inc	di		
	jnz	NRdDone 	
	call	B$BumpES	;move array pointer over segment boundary
NRdDone:
cEnd

;***
; B$EgaNWriteL_F
;
;Purpose:
;	Write a line of pixels from an array to the screen for Screen 10.
;Entry:
;	ES:DI	= screen address
;	DS:SI	= array address
;	CL	= array align shift count
;	BP	= count of bits (not pixels) to write
;	DL	= last partial byte mask
;	DH	= first partial byte mask
;Exit:
;	DS:SI	= updated to array byte past point used
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaNWriteL_F,<PUBLIC,NEAR>
cBegin
	rol	b$PlaneMask,1	;logical plane 0 = physical plane 0
				;logical plane 1 = physical plane 2
				;must shift plane mask twice (1 more below)
cEnd	<nogen> 		;fall thru to regular NWriteL

;***
; B$EgaNWriteL
;
;Purpose:
;	Write a line of pixels from an array to the screen for EGA modes.
;Entry:
;	ES:DI	= screen address
;	DS:SI	= array address
;	CL	= array align shift count
;	BP	= count of bits (not pixels) to write
;	DL	= last partial byte mask
;	DH	= first partial byte mask
;	BH	= plane
;Exit:
;	DS:SI	= updated to array byte past point used
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaNWriteL,<PUBLIC,NEAR>
cBegin
	rol	b$PlaneMask,1	;shift plane mask by one plane
	push	dx
	MOV	BL,DH		;first byte bit mask
	MOV	DX,GRPADD	;address graphics controller
	mov	al,BMKREG	;  bit mask register
	OUT	DX,AL		;set index register
	XCHG	AX,BX		;set up data in AL, plane moves to AH
	INC	DX		
	OUT	DX,AL		
	DEC	DX		
	MOV	AL,RWMREG	;set r/w mode 0
	OUT	DX,AL		
	XOR	AL,AL		
	INC	DX		
	OUT	DX,AL		
	DEC	DX		
	MOV	al,RMPREG	;read map select register
	OUT	DX,AL		
	MOV	AL,AH		;[al] = plane number
	INC	DX		
	OUT	DX,AL		
	MOV	DX,SEQADD	;address the sequencer
	MOV	AL,MMREG	;  map mask register
	OUT	DX,AL		
	mov	al,b$PlaneMask ;get plane mask bit
	and	al,0FH		;strip to nibble
	INC	DX		
	OUT	DX,AL		
	pop	dx

	mov	ah,[si] 	;preload byte from array
	inc	si
	jnz	NWrOvfl1	
	call	B$BumpDS	;move array pointer over segment boundary
NWrOvfl1:
.erre	ID_SSEQDS		;assumes ss = ds
	mov	bx,ss:[b$PutVector]	;preload PUT action vector
	ror	ax,cl		;align to video
	add	bp,cx
	sub	bp,8		;account for first partial byte
	jbe	NWrLast 	;go if last byte
	call	bx		;put the byte
	mov	dh,0FFH 	;mask for whole bytes in the middle
	push	ax
	push	dx
	mov	ah,dh		;middle byte bit mask
	MOV	DX,GRPADD	;address graphics controller
	mov	al,BMKREG	;  bit mask register
	OUT	DX,AL		
	XCHG	AL,AH		;bit mask to AL and output
	INC	DX		
	OUT	DX,AL		
	EGAINT10STI		;reenable ints if using EGAINT10
	pop	dx
	pop	ax
	jmp	short NWrLoop2
NWrLoop:
	call	bx		;put the byte via PUT action vector
NWrLoop2:
	rol	ax,cl		;re-align to array
	lodsb			;fill ax word with array bytes
	or	si,si		
	jz	NWrOvfl3	;go if address overflow
NWrOvfl2:
	xchg	ah,al		
	ror	ax,cl		;align to video
	sub	bp,8		;8 bits done
	ja	NWrLoop 	;go if bit count not exhausted
	add	bp,8		;restore BP to #bits in last byte
	cmp	cx,bp		;did we use any of the second byte?
	jb	NWrLast 	;go if so
	or	si,si		;at start of segment?
	jnz	NWrUnfl 	;go if not
	call	B$DecDS	;backup to previous segment
NWrUnfl:			
	dec	si		;move ptr back
NWrLast:
	push	ax
	and	dh,dl		;combine first|middle mask with end mask
	mov	ah,dh		;last byte bit mask
	MOV	DX,GRPADD	;address graphics controller
	mov	al,BMKREG	;  bit mask register
	EGAINT10CLI		;disable ints for direct EGA manipulation
	OUT	DX,AL		
	XCHG	AL,AH		
	INC	DX		
	OUT	DX,AL		;output bit mask
	DEC	DX		
	pop	ax
.erre	ID_SSEQDS		;assumes ss = ds
	call	bx		;put the last byte
	EGAINT10STI		;reenable ints if using EGAINT10
cEnd

NWrOvfl3:			
	call	B$BumpDS	;move array pointer over segment boundary
	jmp	short NWrOvfl2	;back to loop

	ASSUME	DS:DGROUP

;***
; B$EgaNSetC
;
;Purpose:
;	Set a horizontal line of pixels to the current attribute for EGA
;	modes.	The line starts at the current cursor position and moves right.
;
;	This becomes a bit of a mess with EGAINT10 and QCG support.  Here's
;	the current approach:
;	    No EGAINT10 (QCG or not, doesn't matter) --
;		No problem, just execute straight code, modifying the EGA
;		hardware directly where needed.
;	    EGAINT10 and no QCG --
;		Disable ints at the beginning and reenable them at the end.
;		This will work because in the worst case the entire routine
;		takes approx. 1500 clock cycles, and we are using a ceiling
;		of 1800 clock cycles between CLI/STI.
;	    EGAINT10 and QCG --
;		Now things get ugly.  We can't just disable ints over the
;		whole routine because it would exceed the 1800 clock max.
;		Instead, we use a combination of writing regs through the
;		EGAINT10 interface (like setting RWMReg, because it's needed
;		for the entire routine), and modifying regs directly within
;		small CLI/STI brackets (like setting BMKReg for a byte and
;		then restoring it before reenabling ints).
;Entry:
;	b$AddrC specifies start pixel
;	b$PenC = cursor mask and attribute
;	BX	= number of pixels to set
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaNSetC,<PUBLIC,NEAR>,<ES,DI>
cBegin
	EGAINT10CLI		;disable ints for entire routine if EGAINT10
	MOV	DX,GRPADD	;address of graphics index register
	MOV	AL,RWMREG	;r/w mode register
	OUT	DX,AL		;index the mode register
	MOV	AL,b$EgaWrMd	;write mode 2; odd/even or sequential addr.
	INC	DX		;to data port
	OUT	DX,AL		
	DEC	DX		;back to index port
	MOV	AL,BMKREG	
	OUT	DX,AL		;index the mask register
	INC	DX		;to data port
	les	di,b$AddrC	;graphics cursor address
	mov	cx,b$PenC	;ch = desired attribute
				;cl = cursor mask
	or	cl,cl		;left aligned in byte?
	js	NSet2a		;go if so, skip single-bit start
NSet1:
	xor	ah,ah		;zero out new mask accumulator
NSet2:
	or	ah,cl		;include this pixel in mask
	dec	bx		;decrement pixel count
	jz	NSet4		;treat as last byte if bit count exhausted
	ror	cl,1		;move 1 pixel right
	jnb	NSet2		;continue if not right-most bit
	mov	al,ah		;mask to AL for OUT
	out	dx,al		;set bit mask
	mov	al,ch		;copy desired attribute
	xchg	al,es:[di]	;set the byte
	inc	di		;bump cursor byte pointer
NSet2a:
	push	cx
	mov	al,0FFH 	;set bit mask for full bytes
	out	dx,al
	mov	ax,bx		;remaining bit count
	mov	cl,b$DivShift	;pixels/byte divisor shift
	shr	ax,cl		;compute full byte count
	jz	NSet3		;go do remaining bits if no full bytes
	xchg	ax,cx		;byte count to cx
	mov	al,ah		;attribute byte
	rep	stosb		;block write full bytes
NSet3:
	pop	cx
	and	bx,b$ModMask	;mask in remaining bit count
	jnz	NSet1		;go do remaining bits
	jmp	short NSet5	;no bits remaining - exit
NSet4:				;update last byte
	mov	al,ah		;mask to AL for OUT
	out	dx,al		;set bit mask
	xchg	ch,es:[di]	;set the byte
NSet5:
	EGAINT10STI		;reenable ints if using EGAINT10
	CALL	B$ResetEGA	;call routine to reset write mode for BIOS
cEnd


;***
; B$EgaPaintBound_11
;
;Purpose:
;	Called by PAINT before painting each scan line for
;	Screen 11 to facilitate fast viewport edge detection.
;	Set VIEW left and right cursor addresses and masks.
;Entry:
;	b$OffC = address of current pixel
;Exit:
;	B$LEOFST = left edge offset
;	B$REOFST = right edge offset
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaPaintBound_11,<PUBLIC,NEAR>
cBegin
	mov	AX,b$OffC	;video offset
	MOV	CX,80		;divisor = 80
	XOR	DX,DX
	DIV	CX		;quotient in AX = row # (INT(b$OffC/80))
	SHL	AX,1		;row * 2
	JMP	SHORT PntBndCommon ;finish the math and store the results
cEnd	<nogen>

;***
; B$EgaPaintBound_D
;
;Purpose:
;	Called by PAINT before painting each scan line for
;	Screen 7 to facilitate fast viewport edge detection.
;	Set VIEW left and right cursor addresses and masks.
;Entry:
;	b$OffC = address of current pixel
;Exit:
;	B$LEOFST = left edge offset
;	B$REOFST = right edge offset
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaPaintBound_D,<PUBLIC,NEAR>
cBegin
	mov	ax,b$OffC	;video offset
	MOV	CX,40		;divisor = 40
	XOR	DX,DX
	DIV	CX		;quotient in AX = INT(CLOC/40) -- this is row
	CALL	PntBndCommon	;finish the math and store the results
	JMP	SHORT SetColorBits ;set up ColorBits array and exit
cEnd	<nogen>

;***
; B$EgaPaintBound
;
;Purpose:
;	Called by PAINT before painting each scan line for
;	EGA modes to facilitate fast viewport edge detection.
;	Set VIEW left and right cursor addresses and masks.
;Entry:
;	b$OffC = address of current pixel
;Exit:
;	B$LEOFST = left edge offset
;	B$REOFST = right edge offset
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaPaintBound,<PUBLIC,NEAR>
cBegin
	mov	ax,b$OffC	;video offset
	MOV	CX,80		;divisor = 80
	XOR	DX,DX
	DIV	CX		;quotient in AX = INT(CLOC/80) -- this is row
	SHL	AX,1		;row * 2
	CALL	PntBndCommon	;finish the math and store the results

;	In order for SCANL and SCANR to be able to check whether any tiles
;	will actually change, we need bit-specific information about the
;	tile pattern for the current byte.  This is collected as binary
;	representations of the colors of each bit, and stored in the array
;	ColorBits.
;
;	At this point, the SetTile routine has set up the AttrTile array
;	with the tile pattern for this row. Now calculate the ColorBits
;	array.

SetColorBits:
	PUSH	DI
	PUSH	SI
	PUSH	BX
	MOV	SI,7		;offset to color array
	MOV	DI,3		;offset into AttrTile
SHFTBT:
	XOR	BH,BH		;clear byte for isolating one color
GETCOL:
	ROR	AttrTile[DI],1	;plane 3 bit
	RCL	BH,1		;rotate carry into color accumulator
	DEC	DI		;next plane
	TEST	b$Planes,2	;if 2-plane graphics --
	JZ	GETCL1		;we need to pass up next plane down --
	DEC	DI		;to find color bit for odd/even mode
	ROR	AttrTile[DI],1	;get bit for low plane
	RCL	BH,1		;rotate carry
	JMP	SHORT STTIL3
GETCL1:
	ROR	AttrTile[DI],1	;plane 2 bit
	RCL	BH,1		;rotate carry
	DEC	DI		;for 4-plane, repeat down through 0
	ROR	AttrTile[DI],1	;plane 1 bit
	RCL	BH,1
	DEC	DI
	ROR	AttrTile[DI],1	;plane 0 bit
	RCL	BH,1
STTIL3:
	MOV	ColorBits[SI],BH ;store color in array element
	MOV	DI,3		;go back to plane 3 pattern
	DEC	SI		;next lower offset in color array
	JNS	SHFTBT		;and shift out next color
	POP	BX
	POP	SI
	POP	DI
cEnd

cProc	PntBndCommon,<NEAR>
cBegin
	SHL	AX,1		;row * 2 (or row * 4)
	SHL	AX,1		;    * 4 (or row * 8)
	SHL	AX,1		;    * 8 (or row * 16)
	MOV	DX,AX		;save (row * 8) or (row * 16)
	SHL	AX,1		;row * 16 (or row * 32)
	SHL	AX,1		;row * 32 (or row * 64)
	ADD	AX,DX		;(row*32) + (row*8) = row*40 = byte address
				;(or (row*64)+(row*16)=row*80 = byte address)
				;left margin of screen at this row
	MOV	DX,AX		;two copies of this value
	ADD	AX,B$VLOFST	;byte address at (x=0) + offset to viewport
	MOV	B$LEOFST,AX	;left margin = byte address of left margin
	ADD	DX,B$VROFST	;byte address at (x=0) + offset to viewport
	MOV	B$REOFST,DX	;right margin = byte address of right margin
cEnd

;***
; B$EgaSetTile
;
;Purpose:
;	This routine stores the internal form of the current tile attribute.
;	This routine is called each time a row is to be painted.
;Entry:
;	BL = internal form of the tile attribute
;	BH = which plane the attribute is for
;Exit:
;	AttrTile[plane] = attribute
;	b$AttrC	= attribute
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaSetTile,<PUBLIC,NEAR>,<AX,DI>
cBegin
	MOV	AL,BH
	XOR	AH,AH
	MOV	DI,AX		;DI = 1 based plane number
	CMP	b$Planes,2	;2 plane system?
	JA	FOUR_PLANE
	SHL	DI,1		;plane now 2 or 4
	DEC	DI
	MOV	AttrTile[DI],BL
FOUR_PLANE:
	DEC	DI		;0 based
	MOV	AttrTile[DI],BL
	MOV	b$AttrC,BL	;set attribute to the tile attribute
cEnd

;***
; B$EgaScanInit
;
;Purpose:
;	This routine does some initialization for both ScanL and ScanR
;	for EGA modes.	Set up EGA Read/Write Mode register for color
;	compare read and EGA Color Compare register with b$PaintBorder.
;Entry:
;	None
;Exit:
;	ES:SI = Video segment address (b$AddrC)
;	CH = cursor mask	      (b$MaskC)
;	CL = flag for pixels changed  (0)
;	BX = count of pixels changed  (0)
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaScanInit,<PUBLIC,NEAR>,<DX>
cBegin
	les	si,b$AddrC	;di=cursor offset, es=video seg
	mov	ch,b$MaskC	;ch=cursor mask
	MOV	DX,GRPADD	;address of graphics index register
	MOV	AL,RWMREG
	OUT	DX,AL		;index the mode register
	MOV	AL,8H		;set read mode 1 for color compare
	INC	DX		;to data port
	OUT	DX,AL		
	DEC	DX		;back to index port
	MOV	AL,LOW CLCREG
	OUT	DX,AL		;index the color compare register
	MOV	AL,b$PaintBorder ;set up color compare with border attribute
	INC	DX		;to data port
	OUT	DX,AL
	XOR	CL,CL		;flag for pixels changed
	XOR	BX,BX		;count of pixels changed initialized to 0
cEnd

;***
; B$EgaPAINPX
;Purpose:
;	Paint first byte (and) last byte (and) whole bytes in between
;	Fast write is left to right or v.v. depending on whether SCANR, SCANL.
;	Call has reset or set direction flag.
;
;	This becomes a bit of a mess with EGAINT10 and QCG support.  Here's
;	the current approach:
;	    No EGAINT10 (QCG or not, doesn't matter) --
;		No problem, just execute straight code, modifying the EGA
;		hardware directly where needed.
;	    EGAINT10 and no QCG --
;		Disable ints at the beginning and reenable them at the end.
;		This will work because in the worst case the entire routine
;		takes approx. 1500 clock cycles, and we are using a ceiling
;		of 1800 clock cycles between CLI/STI.  TILING is an exception:
;		If tiling is used then the routine takes too long, but there
;		is an opportune point in the middle to reenable ints and then
;		disable them again without too much of a speed hit.
;	    EGAINT10 and QCG --
;		Now things get ugly.  We can't just disable ints over the
;		whole routine because it would exceed the 1800 clock max.
;		Instead, we use a combination of writing regs through the
;		EGAINT10 interface (like setting RWMReg, because it's needed
;		for the entire routine), and modifying regs directly within
;		small CLI/STI brackets (like setting BMKReg for a byte and
;		then restoring it before reenabling ints).
;Entry:
;	DI = first byte
;	SI = last byte,
;	BL = bit mask for first byte
;	BH = bit mask for last byte
;	BP = count of whole bytes to paint in between first and last
;	CH = 00 if SCANR (for INC DI before REP) or
;	   = FF if SCANL (for DEC DI before REP)
;Exit:
;	CL = non-zero to flag pixels changed
;Uses:
;Exceptions:
;******************************************************************************

;	Now to write the whole line from [DI], first pixel, to [SI],
;	final pixel first set up for write mode 2, if solid color PAINT,
;	or 0, if tile PAINT.

cProc	B$EgaPAINPX,<PUBLIC,NEAR>,<DX>
cBegin
	MOV	DX,GRPADD
	MOV	AH,b$EgaWrMd
	CMP	b$Tiling,0
	JZ	PAINT1
	AND	AH,10H		;if TILE write, use write mode 0
PAINT1:
	MOV	AL,LOW RWMREG
	EGAINT10CLI		;disable interrupts if using EGAINT10
	OUT	DX,AL		;index the mode register
	XCHG	AL,AH		;set write mode
	INC	DX		;to data port
	OUT	DX,AL		
	DEC	DX		;back to index port

;	Set up bit mask.

	MOV	AL,LOW BMKREG
	OUT	DX,AL		;index the bit mask register
	MOV	AL,BL		
	INC	DX		;to data port
	OUT	DX,AL		
	DEC	DX		;back to index port

;	Latch

	MOV	AL,ES:[DI]
	CMP	b$Tiling,0
	JZ	NOTIL1		;tiling not on, write solid color b$AttrC
	CALL	WRTTIL		;else call routine for writing partial tile
	JMP	SHORT CHKLST	;proceed to check for a last byte
NOTIL1:

;	Write first byte.

	MOV	BL,b$AttrC
	MOV	ES:[DI],BL
CHKLST:
	OR	BH,BH		;see if a last byte to write
	JNZ	MORWRT
	CALL	CLRMSK		;all done -- clear bit mask
	JMP	SHORT WHLBYT
MORWRT:

;	Set up bit mask for last byte.

	MOV	AL,LOW BMKREG
	OUT	DX,AL		;index the bit mask register
	MOV	AL,BH		;set mask
	INC	DX		;to data port
	OUT	DX,AL		
	DEC	DX		;back to index port

;	Latch

	MOV	AL,ES:[SI]
	CMP	b$Tiling,0
	JZ	NOTIL2
	XCHG	DI,SI		;WRTTIL addresses screen with DI
	CALL	WRTTIL		;if tiling is on, set [partial] last byte
	XCHG	DI,SI		;restore DI for whole-byte write
	JMP	SHORT CLRBT1
NOTIL2:
	MOV	ES:[SI],BL	;write last byte
CLRBT1:
	CALL	CLRMSK
WHLBYT:
	OR	BP,BP		;check if intermediate whole bytes
	JZ	CLRBT2

;	Set up to write all whole bytes.

	INC	DI		;if SCANR, go right
	OR	CH,CH
	JZ	BYTE2
	DEC	DI
	DEC	DI		;else start to left of first byte
BYTE2:
	MOV	BH,CH		;may need INC/DEC flag for 2-plane write
	MOV	CX,BP		;whole-byte counter in CX
	MOV	AL,BL		;attribute in AL for no-tile speed routine
	CMP	b$Tiling,0	;see whether tiling is on
	JZ	WRITE4
	CALL	TILSET		;set up for copy of off-screen tile

;	NOTE: This call has the effect of immunizing all bits from
;	      processor writes therefore, we must clear the bit mask
;	      following the write if tiling is on.

;	QCG tiling always does slow loop, so 2-plane hack isn't needed?

	TEST	b$Planes,4	;check for four-plane graphics mode
	JNZ	WRITE4		;if 2 planes, need byte-by-byte write routine
; QCG: would need to fix bkg mask here if using this code
	OR	BH,BH		;see whether SCANR or SCANL
	JNZ	CALLFT		;non-zero flag indicates move left
	CALL	WRTRGT		;zero indicates move right
	JMP	SHORT CLRBT2
CALLFT:
	CALL	WRTLFT
	JMP	SHORT CLRBT2

WRITE4:
	REP	STOSB
CLRBT2:
	EGAINT10STI		; reenable interrupts at common exit
	MOV	CL,1		;single pixels counted in B$EgaCHKBTR calls
				;non-zero as pixels changed flag
cEnd

;***
; WRTTIL
;Purpose:
;	Used for writing first and last bytes, possibly partial bytes,
;	to the screen when tiling is on for EGA modes.
;	At entry, the bit mask has been set up for the byte to write, and the
;	contents have been latched.
;	This routine writes the relevant bits to each plane one at a time,
;	using the map mask register to enable the planes from 3 to 0 and
;	writing from AttrTile from offset 3 down to 0.
;
;Entry:
;	ES:DI	 = screen address
;	AttrTile = tile value to write
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;*******************************************************************************
WRTTIL:
	PUSH	DX
	PUSH	BX
	MOV	DX,SEQADD	;index port for sequencer
	MOV	AL,LOW MMREG	;index to Map Mask Register
	OUT	DX,AL
	INC	DX
	MOV	AL,8H		;start with plane 3
	MOV	BX,3
WRTPLN:
	OUT	DX,AL		;set up for one plane
	MOV	AH,AttrTile[BX] ;get tile pattern for that plane
	MOV	ES:[DI],AH	;write to one plane
	MOV	AH,ES:[DI]	;latch that write
	DEC	BX
	SHR	AL,1		;next plane down the list
	JNB	WRTPLN		;repeat 3,2,1,0
	DEC	DX		;back to SEQADD
	MOV	AL,MMREG	
	OUT	DX,AL		;index the register
	XCHG	AL,AH		
	MOV	AL,0FH		;reeanable all planes
	INC	DX		;to data port
	OUT	DX,AL		
	POP	BX
	POP	DX
	RET

;***
; TILSET
;Purpose:
;	Prepares for write of whole tile bytes to the screen in the following
;	fashion :
;
;	i.  uses the routine WRTTIL to write the tile pattern, plane by
;	    plane, at the first offscreen address (6D60H); and, if we are
;	    in odd/even mode, writes it at the second offscreen address also
;	ii. sends 0 to Bit Mask Register to indicate all bits immune
;	iii.reenables write to all planes
;
;	This sets up the card so that it will always write not from processor
;	data but from the latches. If more than 64K, mode 10H, we can perform
;	one latch read at the off-screen address and then write on-screen bytes
;	in the tile pattern simply by changing the address back on-screen and
;	asking for writes to the screen.
;	If we are in odd/even mode, we must perform a latch for each byte
;	written, at the even address for even bytes, at the odd address for odd
;	bytes.	These reads occur within the routines WRTRGT and WRTLFT, which
;	then write to the screen from the latches, byte by byte.
;Entry:
;	ES:DI = screen address
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************

TILSET: 			;this routine altered for Modes D,E support
	TEST	b$Planes,4	;see if 4-plane tile
	JNZ	TILST4		;if so, just write first whole byte,latch,exit
	PUSH	DI		;for odd/even mode, save on-screen byte address
	MOV	DI,OFFSCN	;and substitute offscreen address (fancy
	CALL	WRTTIL		;monitor only)
	INC	DI		;if 2-plane, move to odd offscreen address
	CALL	WRTTIL		;and write to the 2 odd planes
	POP	DI		;restore on-screen address
	JMP	SHORT TILSEX	;no need to latch for 2-plane tile
TILST4:
	CALL	WRTTIL
	MOV	AL,ES:[DI]	;latch
TILSEX:
	MOV	AL,BMKREG	;send 0 to Bit Mask Register
	OUT	DX,AL		;index the bit mask register
	XOR	AL,AL		;disable all bits
	INC	DX		;to data port
	OUT	DX,AL		
	DEC	DX		;back to index port
	RET

;***
; B$EgaPIXCNT
;Purpose:
;	Whether or not we actually change any pixels, we have to send
;	the number "painted".
;
;Entry:
;	BP = number of whole bytes painted
;	DX = number of single pixels painted
;Exit:
;	BX = total number of pixels painted
;Uses:
;	BP, DX
;Exceptions:
;***************************************************************************
cProc	B$EgaPIXCNT,<PUBLIC,NEAR>
cBegin
	SHL	BP,1		;no. whole bytes * 2
	SHL	BP,1		;		 * 4
	SHL	BP,1		;		 * 8
SCNEX1:
	ADD	DX,BP		;pixel count
	MOV	BX,DX
cEnd

;***
; B$EgaSETCMP
;Purpose:
;	Set color compare register to current paint attribute.
;
;	This routine os called to set up the color compare register for
;	PIXLF2/PIXLF3/PIXRT2/PIXRT3.  Since these routines can take more
;	time than is allowed between CLI/STI, this routine must use an
;	EGAINT10 call to set the reg.
;Entry:
;	b$AttrC = attribute
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;*****************************************************************************
cProc	B$EgaSETCMP,<PUBLIC,NEAR>,<DX>
cBegin
	MOV	DX,GRPADD
	MOV	AL,LOW CLCREG
	OUT	DX,AL		;index the color compare register
	MOV	AL,b$AttrC	
	INC	DX		;to data port
	OUT	DX,AL
cEnd

;***
; CLRMSK
;Purpose:
;	Clear bit mask so full bytes will be written.
;Entry:
;	None
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;****************************************************************************

CLRMSK:
	MOV	AX,0FFH SHL 8 + BMKREG ;AH=FF,AL=8
	OUT	DX,AL		;index the bit mask register
	XCHG	AL,AH		
	INC	DX		;to data port
	OUT	DX,AL		
	DEC	DX		;back to index port
	RET

;***
; B$EgaCHKBTR
;Purpose:
;	Check byte right.
;	Look through byte setting up bit mask.
;	BX is used for bit masks, left and right bytes
;
;Entry:
;	AL = border bits set
;	AH = viewport edge mask if in this byte
;	CH = bit mask
;	DX = count of pixels painted so far
;Exit:
;	BH = final bit mask
;	CH = updated b$MaskC
;	DX = updated to reflect pixels painted
;Uses:
;	per conv.
;Exceptions:
;****************************************************************************
cProc	B$EgaCHKBTR,<PUBLIC,NEAR>
cBegin
	MOV	BH,CH		;initial bit mask

;if viewport edge coincides with a border pixel, don't count as painted
;	TEST	BH,AH		;is this viewport edge pixel?
;	JNZ	BYTEX1		;yes, set pixels (BH) and exit with
				; current b$MaskC
BYTLP:
	TEST	CH,AL		;check for border pixel
	JNZ	BYTEXT
	OR	BH,CH		;add pixel to set
	TEST	BH,AH		;have we just OR'd in viewport edge?
	JNZ	BYTEX1		;if so, exit with CH current and
				; BH=bit mask
	INC	DX		;count pixels painted
	ROR	CH,1		;move over one
	JNB	BYTLP		;repeat if not end of byte
	ROL	CH,1		;if off edge, rotate bit in at right
BYTEXT:

;	Final bit mask returned in BH.

	NOT	AL		;0 if border pixel(s) in AL
	AND	BH,AL		;cross out border pixel in bit mask
	RET

;	This exit only if viewport edge was encountered.

BYTEX1:
	INC	DX		;indicate one (more) pixel set
cEnd

;***
; B$EgaCHKBTL
;Purpose:
;	Check byte left.
;	Look through byte setting up bit mask.
;	BX is used for bit masks, left and right bytes
;
;Entry:
;	AL = border bits set
;	AH = viewport edge mask if in this byte
;	CH = bit mask
;	DX = count of pixels painted so far
;Exit:
;	BH = final bit mask
;	CH = value for updating b$MaskC
;	DX = updated to reflect pixels painted
;Uses:
;	per conv.
;Exceptions:
;**************************************************************************
cProc	B$EgaCHKBTL,<PUBLIC,NEAR>
cBegin
;	First check whether least significant bit is border (thinking
;	right to left).  If so, we have moved one byte too far to the
;	left for b$OffC, and want to set nothing in this byte.

	TEST	AL,CH
	JZ	BYTLF0
	INC	DI		;increment for b$OffC
	JMP	SHORT BYTLFX
BYTLF0:
	MOV	BH,CH		;initial bit mask
	TEST	BH,AH		;is this viewport edge pixel?
	JNZ	BYTLF1		;yes, set pixels (BH) and exit with
				; preexisting b$MaskC
BYTLFT:
	TEST	CH,AL		;check for border pixel
	JNZ	BYTLFX
	OR	BH,CH		;add pixel to set
	TEST	BH,AH		;test for viewport edge bit encountered
	JNZ	BYTLF1		;if found, exit with CH at that bit
	INC	DX		;count pixels painted
	ROL	CH,1		;move over one
	JNB	BYTLFT		;repeat if not end of byte
BYTLFX:
	ROR	CH,1		;else set up as rightmost pixel
	NOT	AL
	AND	BH,AL		; final bit mask returned in BH
	RET
BYTLF1: 			;this exit only if viewport edge bit encountered
	INC	DX		;count one (more) pixel painted
cEnd

;***
; PIXRT2
;Purpose:
;	Check for non-paint pixels right for 4 plane EGA modes.
;	Look through entire range of non-border pixels left to right
;	to determine whether any will actually change color.
;	AL is used for Color Don't Care mask
;
;Entry:
;	SI = byte address of leftmost byte in range
;	BL = bit mask for leftmost byte
;	BH = bit mask for rightmost byte
;	DI = total number of whole bytes -1
;	ES = video segment
;Exit:
;	CL = 0 if no pixels found to change, non-zero if pixels to change
;Uses:
;	per conv.
;Exceptions:
;****
cProc	PIXRT2,<NEAR>
cBegin
	XOR	CL,CL		;maybe no bits change

;	read first byte

	MOV	AL,ES:[SI]	;bit pattern of first byte with 0's where
				;color not paint attribute
	AND	AL,BL		;AND now produces difference if non-paint
				;bit in significant position
	XOR	AL,BL		;for significant bits in our first byte (bit
				;set in BH), then non-paint will be one
	JNZ	BITFDR		;found a bit to change
	OR	DI,DI		;any more bytes?
	JZ	PIXLAST 	;Brif not, test the last byte

;	Look at whole bytes within viewport range until non-paint color found.

LKPNTR:
	INC	SI
	MOV	AL,ES:[SI]
	NOT	AL		;check if all bits set (all paint color)
	OR	AL,AL		;NOT does not affect flags
	JNZ	BITFDR
	DEC	DI
	JNZ	LKPNTR		;keep looking until search of complete
				;bytes is exhausted
;	On last byte now, mask in BH.

PIXLAST:			
	INC	SI
	MOV	AL,ES:[SI]	;do last compare
	AND	AL,BH		;significant bit = 0 if not paint color
	XOR	AL,BH		;if different, not paint
	JZ	NOBITR
BITFDR:
	MOV	CL,AL		;set change bits flag to non-zero
NOBITR:
cEnd

;***
; B$EgaTILRGT
;Purpose:
;	Check for non-paint pixels right if tiling is on.
;	Use READC to do bit-wise color compares with tile colors stored in
;	color array ColorBits (colors of bits 0 to 7 configured left to right
;	are represented in the array as elements offset 0 to 7 from base
;	address).
;
;Entry:
;	BL    = bit mask for leftmost partial byte
;	BH    = bit mask for rightmost partial byte
;	DI    = count of whole bytes
;	ES:SI = screen address
;Exit:
;	CL = 0 iff no pixels to change
;Uses:
;	per conv.
;Exceptions:
;****
cProc	B$EgaTILRGT,<PUBLIC,NEAR>,<DX,BP>
cBegin
	PUSH	b$OffC
	PUSH	b$PenC
	PUSH	BX		;copy for BH check
	MOV	ByteCount,DI	;whole byte counter
	MOV	AL,BL		;copy bit mask from BL
	OR	AL,AL		;make sure at least 1 bit is set
	JZ	TILRT5
	CALL	LOWCHK		;check first partial byte (uses mask in AL)
	JNZ	TILRT1		;if no carry, non-match was found
TILRT5:
	CMP	ByteCount,0	;see whether whole bytes to check
	JZ	TILRT4
TILRT2:
	INC	SI
	MOV	b$OffC,SI
	MOV	b$MaskC,80H
	XOR	BP,BP		;offset to color array
TILRT3:
	CALL	[b$ReadC]
	CMP	AL,ColorBits[BP] ;check for non-match
	JNZ	TILRT1
	INC	BP
	SHR	b$MaskC,1	;move to next bit
	JNB	TILRT3
	DEC	ByteCount
	JNZ	TILRT2		;keep looking until all whole bytes done
TILRT4:
	POP	BX		;get bit mask in BH
	OR	BH,BH
	PUSH	BX
	JZ	TILRT6		;BH=0 indicates no "last byte"
	MOV	AL,BH		;get last partial byte
	INC	SI
	CALL	HICHK
	JNZ	TILRT1		;exit if non-match found
TILRT6:
	MOV	CL,-1
TILRT1:
	INC	CL		;non-zero if pixels changed
	POP	BX
	POP	b$PenC
	POP	b$OffC
cEnd

;***
; PIXLF2
;Purpose:
;	Check for non-paint pixels left for 4 plane EGA modes.
;	Look through entire range of non-border pixels right to left
;	to determine whether any will actually change color.
;	BH/BL = bit masks for leftmost and rightmost bytes, respectively
;	DI = total whole bytes between first and last
;
;Entry:
;	SI = byte address of rightmost byte in range
;	BL = bit mask for rightmost byte
;	BH = bit mask for leftmost byte
;	DI = total number of whole bytes
;	ES = video segment
;Exit:
;	CL = 0 if no pixels found to change, non-zero if pixels to change
;Uses:
;	per conv.
;Exceptions:
;****
cProc	PIXLF2,<NEAR>
cBegin
	XOR	CL,CL		;maybe no bits change

;	read first byte

	MOV	AL,ES:[SI]	;bit pattern of first byte with 0's where
				;color not paint attribute
	AND	AL,BL		;AND now produces difference if non-paint
				;bit in significant position
	XOR	AL,BL		;for significant bits in our first byte (bit
				;set in BH), then non-paint will be one
	JNZ	BITFDL		;found a bit to change
	OR	BH,BH		;see if only one byte
	JZ	NOBITL		;nothing to paint
	OR	DI,DI		;see if only a "last byte"
	JZ	LSTBYT

;	Look at whole bytes within viewport range until non-paint color found.

LKPNTL:
	DEC	SI
	MOV	AL,ES:[SI]
	NOT	AL		;check if all bits set (all paint color)
	OR	AL,AL		;NOT does not affect flags
	JNZ	BITFDL
	DEC	DI
	JNZ	LKPNTL		;keep looking until search of complete
				;bytes is exhausted

;	On last byte now, mask in BH.

LSTBYT:
	DEC	SI
	MOV	AL,ES:[SI]	;do last compare
	AND	AL,BH		;significant bit = 0 if not paint color
	XOR	AL,BH		;if different, not paint
	JZ	NOBITL
BITFDL:
	MOV	CL,AL		;set change bits flag to non-zero
NOBITL:
cEnd

;***
; B$EgaTILLFT
;Purpose:
;	Check for non-paint pixels left if tiling is on.
;	Use READC to do bit-wise color compares with tile colors stored in
;	color array ColorBits (colors of bits 0 to 7 configured left to right
;	are represented in the array as elements offset 0 to 7 from base
;	address).
;
;Entry:
;	BL    = bit mask for rightmost partial byte
;	BH    = bit mask for leftmost partial byte
;	DI    = count of whole bytes
;	ES:SI = screen address
;Exit:
;	CL = 0 iff no pixels to change
;Uses:
;	per conv.
;Exceptions:
;****
cProc	B$EgaTILLFT,<PUBLIC,NEAR>,<DX,BP>
cBegin
	PUSH	b$OffC
	PUSH	b$PenC
	PUSH	BX
	MOV	AL,BL		;copy of bit mask for rightmost byte
	MOV	ByteCount,DI	;store whole byte counter
	OR	AL,AL		;make sure at least 1 bit set
	JZ	TILLF5
	CALL	HICHK		;check first [partial] byte using mask in [AL]
	JNZ	TILLF1		;exit if non-match found
TILLF5:
	CMP	ByteCount,0	;check for intermediate whole bytes
	JZ	TILLF4		;if not, proceed to check for last byte
TILLF2:
	DEC	SI		;move left on line
	MOV	b$OffC,SI	; store in b$OffC for READC
	MOV	b$MaskC,1	;start at rightmost bit
	MOV	BP,7		;rightmost element of color array
TILLF3:
	CALL	[b$ReadC]	;determine color of pixel (returned in AL)
	CMP	AL,ColorBits[BP] ;look for non-match
	JNZ	TILLF1		;when we find one, we can exit
	DEC	BP
	SHL	b$MaskC,1	;move to next bit left
	JNB	TILLF3		;continue 'til we shift out of byte left
	DEC	ByteCount	;prepare to check next byte left
	JNZ	TILLF2
TILLF4:
	POP	BX
	OR	BH,BH		;see whether a "last byte"
	PUSH	BX
	JZ	TILLF6		;if not, there was only 1 byte
	MOV	AL,BH		;get last byte's bit mask
	DEC	SI
	CALL	LOWCHK		;look through last [partial] byte for match
	JNZ	TILLF1
TILLF6:
	MOV	CL,-1
TILLF1:
	INC	CL		;non-zero if pixels changed
	POP	BX
	POP	b$PenC
	POP	b$OffC
cEnd

;***
; HICHK
;Purpose:
;	Check partial byte for tile pattern match, where byte may be
;	partial in that some low bits may be immunized from PAINT and
;	therefore must be skipped during the tile pattern check.
;
;Entry:
;	AL = screen byte to check
;	ColorBits array contains tile pattern to check against
;Exit:
;	PSW.C set iff no match found
;Uses:
;	per conv.
;Exceptions:
;****
cProc	HICHK,<NEAR>
cBegin
	MOV	CH,10000000B	;rotate will start mask at 0000/0001
	MOV	BP,8		;start counter at 8
HICHK1:
	ROL	CH,1
	DEC	BP		;offset to first bit to check for color
	ROR	AL,1		;shift immune bits out right
	JNB	HICHK1		;if we got a 1, we found a relevant bit
	MOV	b$MaskC,CH
HICHK2:
	PUSH	AX		;store state of shift mask
	MOV	b$OffC,SI
	CALL	b$ReadC	;get color for this pixel
	CMP	ColorBits[BP],AL ;see if match
	POP	AX		;restore shift mask
	JNZ	HICHK3		;our goal is just one non-matching pixel
	DEC	BP
	ROR	AL,1		;look for additional 0's to left of first 1
	JNB	HICHK4
	SHL	b$MaskC,1
	JNB	HICHK2
HICHK4:
	XOR	BP,BP		;return ZF set if no match found
HICHK3:
cEnd

;***
; LOWCHK
;Purpose:
;	Check partial byte for tile pattern match, where byte may be
;	partial in that some high bits may be immunized from PAINT and
;	therefore must be skipped during the tile pattern check.
;
;Entry:
;	AL = screen byte to check
;	ColorBits array contains tile pattern to check against
;Exit:
;	PSW.C set iff no match found
;Uses:
;	per conv.
;Exceptions:
;****
cProc	LOWCHK,<NEAR>
cBegin
	MOV	CH,00000001B	;rotate will start mask at 1000/0000
	XOR	BP,BP
	NOT	BP		;counter at -1
LWCHK1:
	ROR	CH,1
	INC	BP		;offset to first bit to check for color
	ROL	AL,1		;shift immune bits out left
	JNB	LWCHK1		;if we got a 1, we found a relevant bit
	MOV	b$OffC,SI
	MOV	b$MaskC,CH
LWCHK2:
	PUSH	AX		;store state of shift mask
	CALL	b$ReadC	;get color for this pixel
	CMP	ColorBits[BP],AL ;see if match
	POP	AX		;restore state of shift mask
	JNZ	LWCHK3		;our goal is just one non-matching pixel
	ROL	AL,1		;look for any trailing 0's indicating immune
	JNB	LWCHK4
	INC	BP
	SHR	b$MaskC,1
	JNB	LWCHK2
LWCHK4:
	XOR	BP,BP		;set ZF
LWCHK3: 			;non-zero indicates non-match
cEnd

;***
; WRTLFT
;Purpose:
;	Used for tiling if in odd/even mode, during SCANL.
;	Latches off-screen tile pattern at even address when DI even, and
;	at odd address when DI odd, then "writes" this pattern at DI.
;
;Entry:
;	ES:DI = screen address of start byte
;	CX    = count of bytes to write
;Exit:
;	ES:DI = screen address of stop byte
;Uses:
;	SI
;Exceptions:
;****
cProc	WRTLFT,<NEAR>
cBegin
	MOV	SI,OFFSCN	;get address of off-screen location
	TEST	DI,1		;see whether first byte odd
	JNZ	INCBYL
	INC	SI		;even byte, so set up for DEC loop
DECBYL:
	DEC	SI		;SI gets even offscreen byte address
	MOV	AL,ES:[SI]	;latch even byte pattern
	MOV	ES:[DI],AL	;dummy write puts latched byte out
	DEC	DI		;move left on write line
	DEC	CX		;decrement byte counter
	JCXZ	LFTEX
INCBYL:
	INC	SI		;point to odd offscreen byte
	MOV	AL,ES:[SI]	;latch odd byte pattern
	MOV	ES:[DI],AL	;dummy write of latched pattern
	DEC	DI		;move left
	LOOP	DECBYL
LFTEX:
cEnd

;***
; WRTRGT
;Purpose:
;	Used for tiling if in odd/even mode, during SCANR.
;	Latches off-screen tile pattern at even address when DI even, and
;	at odd address when DI odd, then "writes" this pattern at DI.
;
;Entry:
;	ES:DI = screen address of start byte
;	CX    = count of bytes to write
;Exit:
;	ES:DI = screen address of stop byte
;Uses:
;	SI
;Exceptions:
;****
cProc	WRTRGT,<NEAR>
cBegin
	MOV	SI,OFFSCN	;get address of off-screen location
	TEST	DI,1		;see whether first byte odd
	JNZ	INCBYR
	INC	SI		;even byte, so set up for DEC loop
DECBYR:
	DEC	SI		;SI gets even offscreen byte address
	MOV	AL,ES:[SI]	;latch even byte pattern
	MOV	ES:[DI],AL	;dummy write puts latched byte out
	INC	DI		;move right on write line
	DEC	CX		;decrement byte counter
	JCXZ	RGTEX
INCBYR:
	INC	SI		;point to odd offscreen byte
	MOV	AL,ES:[SI]	;latch odd byte pattern
	MOV	ES:[DI],AL	;dummy write of latched pattern
	INC	DI		;move right
	LOOP	DECBYR
RGTEX:
cEnd

;***
; ScanL
;Purpose:
;	To scan left beginning one pixel to the left of the current
;	graphics cursor setting pixels to the paint attribute until
;	either edge of viewport or border is found; to return
;	certain information to the calling routine.
;
;	Algorithm for SCANL2 is as follows: starting next left to b$OffC
;	  b$MaskC:
;
;	  i.  While (not border) AND (not viewport edge) AND (not left
;	      edge of byte) move left in byte.
;	  ii. If (left edge of byte) then
;		 decrement b$OffC, set up b$MaskC, go to i.
;	      Else
;		 test if on border pixel
;		    x.	if true, exit unchanged
;		    xx. else
;			   xx1. set up bit mask for first byte
;			   xx2. calculate # whole bytes if any
;			   xx3. set up bit mask for last byte if any
;			   xx4. see whether any pixels in range will
;				change color
;				xx41. if not, exit to pixel count routine
;				xx42. if so, paint all pixels
;			   xx5. calculate number of pixels "painted"
;			   xx6. exit with appropriate information
;Entry:
;	b$AttrC       = attribute to paint
;	b$PaintBorder = border attribute which ends paint
;	b$OffC, b$MaskC specify pixel one to right of first to examine
;Exit:
;	BX = number of nonborder pixels tested
;	CL = 0 ifF no pixels changed color
;	b$OffC, b$MaskC specify location of last pixel painted, or
;	       unchanged if only border pixels found
;Uses:
;	per conv.
;Exceptions:
;****************************************************************************
cProc	B$EgaScanL,<PUBLIC,NEAR>,<ES>
cBegin
	CALL	B$EgaScanInit
	ROL	CH,1		;see if cursor is left edge of byte
	JNB	VWPCK1
	SUB	SI,1		;if so, start next byte left
	JNC	VWPCK1		;(SUB used since DEC doesn't set carry)
	JMP	BRDEX1		;if negative, hit corner of screen
VWPCK1: 			;to check first for viewport edge byte
	CMP	SI,B$LEOFST	;see if on edge of viewport, or off to left
	JNB	VWPCK2		;if viewport byte or to right,
	JMP	BRDEX1		; continue, else off to left; do nothing, exit
VWPCK2: 			;to check for edge bit if in edge byte
	JNZ	NOTEDG		;if not viewport edge byte, skip
	CMP	CH,B$VLMASK	;bit check else compare first pixel left with
				;viewport edge bit -- if farther left, we are
;	JA	BRDEX1		;are left of viewport edge and must
	JNA	NOTEDG		;exit
	JMP	BRDEX1
NOTEDG: 			;exit
	MOV	DI,SI		;extra copy of first byte address
	MOV	CL,CH		;extra copy of initial bit mask
	MOV	BP,-1		;this will be count of whole bytes
	XOR	DX,DX		;this will be #pixels painted
	XOR	AH,AH		;initialize this byte's viewport mask to 0

;	read first byte off the screen

	MOV	AL,ES:[DI]
	TEST	AL,CH		;see whether initial pixel is border
	JZ	SRCHLF		;if not, start search left
	XOR	CL,CL		;else set pixels-changed flag back to 0
	JMP	SHORT BRDEX1	;and exit gracefully
SRCHLF:

;	look for border or viewport in first byte

	CMP	DI,B$LEOFST	;is this in fact viewport edge byte?
	JNZ	NOTVWL
	MOV	AH,B$VLMASK	;if so, set up viewport mask in AH
NOTVWL:

;	while not border

	TEST	AL,CH
	JNZ	HAVPIX

;	and not viewport edge

	TEST	AH,CH
	JNZ	HAVPIX

;	and not off the edge of the byte

	ROL	CH,1
	JNB	NOTVWL

;	keep moving left - edge of first byte

	DEC	DI		;next byte address left
	INC	BP		;count of intermediate bytes
	MOV	AL,ES:[DI]	;read next byte left
	JMP	SHORT SRCHLF	;check next byte

HAVPIX:

;	Here when border or viewport edge found.
;	Set up bit mask for first (possibly only) byte.
;	SI = rightmost byte
;	DI = leftmost byte (possibly same byte)
;	CL = mask for rightmost bit in rightmost byte

;	If viewport edge was found, AH will contain the viewport bit
;	mask, and DI is the viewport edge byte. If SI=DI=viewport edge
;	byte, we need to retain the viewport mask in AH.  Otherwise
;	clear AH and fetch the mask again later if needed for DI.

	CMP	SI,B$LEOFST	;see if rightmost byte is LEFT viewport
	JZ	SINOTV		;if so, don't clear viewport mask
				; register
	XOR	AH,AH		;else clear AH for B$EgaCHKBTL on
SINOTV: 			;  rightmost byte
	MOV	CH,CL		;initial bit position in CH
	MOV	AL,ES:[SI]	;get border bits if any
	CALL	B$EgaCHKBTL	;set up bit mask for first byte
	MOV	BL,BH		;store in BL
	XOR	BH,BH		;there may be only one byte

;	see if more than 1 byte to paint

	PUSH	SI		;save a copy of rightmost address
	INC	BP		;see if still -1
	JZ	ONEBYT
	DEC	BP		;if not, recover real value
	MOV	CH,1		;set up mask for final byte
	MOV	AL,ES:[DI]	;get border bits if any
	CMP	DI,B$LEOFST	;was this viewport byte?
	JNZ	DINOTV		;no -- don't need viewport mask
	MOV	AH,B$VLMASK	;yes -- get viewport mask for CHKTBL
DINOTV:
	CALL	B$EgaCHKBTL	;set up leftmost byte bit mask in BH
ONEBYT:
	MOV	b$OffC,DI
	MOV	b$MaskC,CH	;update cursor
	PUSH	DI		;save a copy of leftmost address
	MOV	DI,BP		;store whole byte count for PIXLF2
	CMP	b$Tiling,0
	JZ	COLCM5
	CALL	B$EgaTILLFT
	JMP	SHORT COLCM6
COLCM5:
	CALL	B$EgaSETCMP	;set color compare register to paint attribute
	CALL	PIXLF2		;see whether any pixels in range will change
COLCM6:
	POP	SI		;restore leftmost address to SI
	POP	DI		;restore rightmost address to DI
	OR	CL,CL		;returns CL non-zero if changes needed
	JZ	BRDEXT

;	We found at least 1 pixel to change, so set entire range
;	set pixels-changed flag, set up write mode 2

	XOR	CH,CH
	NOT	CH		;set to FF as decrement flag
	STD			;for SCANL, decrement from DI
	CALL	B$EgaPAINPX
	CLD
BRDEXT:
	CALL	B$EgaPIXCNT	;returns # pixels "painted" in BX
BRDEX1:
	CALL	B$ResetEGA
cEnd

;***
; ScanR
;Purpose:
;	To scan right beginning with the graphics cursor at entry
;	setting certain pixels to the current graphics attribute
;	(color or tile pattern); to return certain information to
;	the calling routine .
;
;	ScanR algorithm is as follows :
;	 i.  Search right until
;	     a.  DX pixels have been tested without encountering non-
;		 border,
;		 OR
;	     b.  viewport edge is encountered without encountering non-
;		 border,
;		 OR
;	     c. a non-border pixel is found.
;	 ii. If a. or b., then exit with
;		[BX] = number of pixels painted = 0
;		[CL] = pixels modified flag = 0
;		[DX] = border pixels skipped during successful search for
;		       non-border pixel = 0
;		graphics cursor preserved
;		CSAVE (cursor values returned by previous SCANs) preserved
;
;	 iii.If c., then continue searching right painting non-border
;	     pixels until
;	     a. a border pixel is found
;		OR
;	     b. the edge of the viewport is encountered
;	     then exit with
;		[BX] = count of pixels painted (even if no color change
;		[CL] = pixels modified flag (0 if no pixels changed color)
;		[DX] = entry [DX] - count of border pixels searched before
;		       encountering non-border
;		b$OffC, b$MaskC = last pixel examined (border or viewport
;		      edge, painted if viewport edge
;		b$SaveCa,b$SaveCm = cursor values for first non-border pixel
;
;	This routine, which is specific to the EGA graphics modes, takes
;	advantage of the following special properties of the EGA card :
;	      a.  The ability to return 8-bit color compare to a specified
;		  color with respect to all 4 planes via a single MOV
;	      b.  The ability to write to all four planes via a single MOV
;
;	The algorithm is as follows : starting with b$OffC, b$MaskC
;
;	i.  While (border) and (not viewport edge) and (not DX=0) and
;	    (not right edge of byte) do
;		move right in byte
;		decrement DX
;	ii. If (right edge of byte) then
;		increment b$OffC, set up b$MaskC
;		go to i.
;	    Else
;		test if on border pixel
;		x.  if true, exit with appropriate information
;		xx. else
;		   xx1. save pertinent information including bit mask for
;		       first byte
;		   xx2. calculate number of bytes between b$OffC and
;		       viewport edge
;		   xx3. read all bytes until edge or border pixel
;		   xx4. analyze last byte
;		   xx5. set CL = 0
;			starting at CSAVE, while (pixel = paint
;			attribute) and (not end of range) read right
;			if (pixel = non-attribute) then
;			   CL = non-zero
;			   write first byte, whole bytes, last byte
;		   xx6. exit with appropriate information.
;
;Entry:
;	DX		   = count of border pixels which may be skipped
;	b$AddrC, b$MaskC = starting pixel
;	b$PaintBorder	   = attribute of paint region border
;	b$AttrC	   = attribute to paint
;	B$REOFST, B$VRMASK   = right viewport edge
;Exit:
;	BX		   = number of pixels painted
;				(whether or not they changed color)
;	CL		   = 0 iff no pixels changed color
;	DX		   = remaining border pixel count
;	b$OffC, b$MaskC  = the last non-border pixel examined/painted
;	SI, AL		   = the first non-border pixel encountered
;Uses:
;	per conv.
;Exceptions:
;*****************************************************************************
cProc	B$EgaScanR,<PUBLIC,NEAR>,<ES>
cBegin
;	set up EGA registers for color compare read
;	point ES:[SI] to screen memory, b$MaskC in CH
;	CL = 0 (pixels changed flag)

	CALL	B$EgaScanInit	;setup

;	perform color compare on first byte

	MOV	AL,ES:[SI]	;bits set where border found

;	starting at entry cursor, search right looking for non-border,
;	viewport edge, or end-of-byte as long as DX does not decrement to 0

	XOR	AH,AH		;initialize viewport mask to 0
SRCHRT:
	CMP	SI,B$REOFST	;check whether we are in viewport edge byte
	JNZ	NOTVPR
	MOV	AH,B$VRMASK	;if so, get viewport edge mask
NOTVPR:

;	While border...

	TEST	AL,CH		;compare color compare mask with b$MaskC
	JZ	ENDRT		;if pixel not border, exit loop

;	and not viewport edge...

	TEST	AH,CH		;compare viewport edge mask with b$MaskC
	JNZ	ENDRT		;if edge found, exit

;	and DX is greater than 0...

	DEC	DX		;contains # pixels which can be skipped
	JZ	ENDRT		;in search for non-border pixel

;	and not off the edge of the byte...

	ROR	CH,1		;shift bit mask right

;	repeat the search

	JNB	NOTVPR

;	end of first byte.

	INC	SI		;next byte address
	MOV	AL,ES:[SI]
	MOV	CH,80H		;mask now 1000/0000 for next search
	JMP	SHORT SRCHRT

;	either (not border) OR (viewport edge) OR (DX = 0)

ENDRT:
	TEST	AL,CH		;border?
	JZ	NOTBRD		;if so, we are either at viewport edge
	XOR	DX,DX		;or have skipped DX pixels and therefore
	JMP	SHORT SCNEX2	;should exit with info as initialized

;	look for viewport edge to determine how many bytes to
;	look through for border pixel

NOTBRD:
	PUSH	DX		;store skipcount for later
	XOR	DX,DX		;use to count pixels painted
	MOV	b$SaveCa,SI	;we have a new CSAVE
	PUSH	SI		;store copy of first byte address
	MOV	b$SaveCm,CH
	CALL	B$EgaCHKBTR	;set up byte for write, and count some pixels
				;(AH = viewport edge mask if any)
	MOV	BL,BH		;store first bit mask in BL
	XOR	BH,BH		;zero BH until last byte bit mask if any
	XOR	BP,BP		;start whole byte count at 0
	MOV	DI,B$REOFST
	SUB	DI,SI		;viewport edge address - first byte address
	TEST	BL,1		;if last bit not set, we found border for sure
	JZ	WRTPIX		;if just one byte, we're done
	OR	DI,DI		;check also if we hit viewport edge
	JZ	WRTPIX		;if so, also done

;	else look through DI bytes for border (this includes
;	viewport edge byte)

	DEC	BP		;start increment at -1
	MOV	CH,80H		;start each byte at left edge
SCANEM:
	INC	BP		;whole byte count
	INC	SI		;point to byte
	MOV	AL,ES:[SI]	;read each byte for color compare
	OR	AL,AL		;check for occurrence of border pixel(s)
	JNZ	BRDPIX		;set up last byte
	DEC	DI		;decrement to 0 to include last byte
	JNZ	SCANEM		;go check out this byte
;[alice]MOV	AH,B$VRMASK	;if edge of viewport, get viewport mask
				;and proceed to set up byte for write
BRDPIX:
	CMP	SI,B$REOFST	;if viewport edge not reached, skip
	JNZ	BRDRFD		; since it was border with no
				; viewport edge
				;this instruction reached if
				; viewport edge byte
				;this byte may contain border also
	MOV	AH,B$VRMASK	;if edge of viewport, get viewport mask
BRDRFD:
	CALL	B$EgaCHKBTR	;set up byte for write

;	most recent call to B$EgaCHKBTR has generated new cursor
;	location and mask

WRTPIX:
	MOV	b$OffC,SI
	MOV	b$MaskC,CH
	POP	DI		;restore leftmost byte address
	PUSH	DI		;save a copy for leftmost add. for painting
	PUSH	SI		;save copy of rightmost address also
	MOV	SI,DI		;leftmost byte address in SI for PIXRT2
	MOV	DI,BP		;PIXRGT will use DI to count whole bytes
	CMP	b$Tiling,0	;see if tiling is on
	JZ	COLCM1
	CALL	B$EgaTILRGT	;need routine for reading individual pixels
	JMP	SHORT COLCM2	;for position-sensitive compare
COLCM1:
	CALL	B$EgaSETCMP	;set color compare register to paint attribute
	CALL	PIXRT2		;routine to determine whether any pixels change
COLCM2:
	POP	SI		;restore rightmost
	POP	DI		;and leftmost byte addresses
	OR	CL,CL		;non-zero indicates at least one must change
	JZ	NOPNTR
	XOR	CH,CH		;zero as increment flag
	CLD			;for SCANR, paint routine should increment REP
	CALL	B$EgaPAINPX	;set line
NOPNTR:
	CALL	B$EgaPIXCNT	;return # pixels "painted" in BX
	POP	DX		;skipcount in DX
SCNEX2:
	CALL	B$ResetEGA	;reset EGA registers for BIOS write mode 0
	MOV	SI,b$SaveCa	;return CSAVE
	MOV	AL,b$SaveCm
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llgrtabl.asm ===
TITLE	llgrtabl - graphics mode dispatch table
;***
;llgrtabl - graphics mode dispatch table
;
; Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
; Provides the dispatch table that includes all graphics screen modes, if
; graphics statements are used in a users program.
;
;******************************************************************************
	INCLUDE switch.inc	;Product switches
	INCLUDE rmacros.inc	;runtime macros

	useSeg	_DATA		
	useSeg	GR_TEXT
	useSeg	XIB		
	useSeg	XI		
	useSeg	XIE		

	INCLUDE seg.inc 	;segment definitions

	INITIALIZER B$xGRINITTAB    ;Put B$xGRINITTAB in initializer list

sBegin	GR_TEXT			
externNP B$ErrorReturn		
externNP B$Screen0		
sEnd	; GR_TEXT		

sBegin	_DATA			; needs to be in data seg

externW b$ScreenX		; NEAR pointer to screen mode table

labelW	<PUBLIC,b$ScreenTab>	;mode-dependent SCREEN set-up
	DB	MaxScrMode	;Maximum screen mode
	DW	B$Screen0
	DW	B$ErrorReturn	; for screen 1
	DW	B$ErrorReturn	; for screen 2
	DW	B$ErrorReturn	; for screen 3
	DW	B$ErrorReturn
	DW	B$ErrorReturn
	DW	B$ErrorReturn
	DW	B$ErrorReturn	; for screen 7
	DW	B$ErrorReturn	; for screen 8
	DW	B$ErrorReturn	; for screen 9
	DW	B$ErrorReturn	; for screen 10
	DW	B$ErrorReturn	; for screen 11
	DW	B$ErrorReturn	; for screen 12
	DW	B$ErrorReturn	; for screen 13
MaxScrMode  =	($-b$ScreenTab)/2-1   ;max BASIC screen mode

sEnd				; end _DATA

sBegin	GR_TEXT 		
assumes CS,GR_TEXT

cProc	B$xGRINITTAB,<FAR>	
cBegin
	MOV	[b$ScreenX],OFFSET DGROUP:b$ScreenTab	
cEnd

sEnd

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llgrstub.asm ===
TITLE	LLGRSTUB - Link helper for graphics modules
;***
; LLGRSTUB - Link helper for graphics modules
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	When the compiler sees a SCREEN statement with a constant for the
;	screen mode, it will emit a reference to a public label defined
;	in the low level module corresponding to that screen mode. (ie: if
;	SCREEN 1 is seen, a reference to B$CGAUSED will be emitted.)
;	But if the SCREEN statement contains a variable, the compiler will
;	emit a reference to B$GRPUSED which should cause all the screen
;	modules to be linked in.  B$GRPUSED is defined here and this
;	module will reference the mode-specific labels to force linkage.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	useSeg	GR_TEXT
	useSeg	_DATA

	INCLUDE seg.inc
	INCLUDE idmac.inc

sBegin	GR_TEXT
assumes CS,GR_TEXT

labelNP <PUBLIC,B$GRPUSED>


externNP B$CGAUSED

externNP B$EGAUSED

externNP B$VGAUSED

externNP B$HRCUSED

externNP B$OLIUSED	

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llevtstg.asm ===
PAGE	56,132
	TITLE	LLEVTSTG - Low-level joystick support
;***
; LLEVTSTG - Low-level joystick support
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	useSeg	_BSS
	useSeg	_DATA
	useSeg	EV_TEXT

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE idmac.inc	; debugging macros
	INCLUDE intmac.inc
	INCLUDE event.inc	; bit flag constants

sBegin	_DATA

TRIGSA	DB	0,TRIG_A1	;TRIGGER 'A1 Save Status & Mask
	DB	0,TRIG_B1	;TRIGGER 'B1 Save Status & Mask
	DB	0,TRIG_A2	;TRIGGER 'A2 Save Status & Mask
	DB	0,TRIG_B2	;TRIGGER 'B2 Save Status & Mask

sEnd	_DATA


sBegin	_BSS

	externB	b$MACHID	; machine identification

STIKAX	DB	4 DUP(?)	;STICK 'A' x,y - 'B' x,y Positions

sEnd	_BSS


sBegin	EV_TEXT
assumes CS,EV_TEXT


externNP B$TrapEvent		;routine to set global event flag
externNP B$SetClockInt		;routine to install clock interrupt


	SUBTTL	B$RDTRIG - Read Joystick Trigger Flag.
	PAGE

;***
;B$RDTRIG - Read Joystick Trigger Flag.
;OEM-interface routine
;
;Purpose:
;	Determines the status of a Joystick Trigger.  This routine
;	can return either the current status of the trigger (AH=0)
;	or a latched status (AH=1).  The latched status will indicate
;	if the joystick trigger has been pressed since the last time
;	this routine was called.
;
;	See the documentation for B$POLLEV for a description of the
;	event and trapping mechanisms.
;
;Entry:
;	[AL]=joy-stick trigger id (0..n)
;
;	[AH]=current/latched flag
;	     [AH]=0  request current status
;	     [AH]=1  request latched status
;
;Exit:
;	[AL]=0 if trigger is not pressed (current) or has not been pressed
;	       since last call to B$RDTRIG (latched).
;	[AL]=-1 if trigger is pressed (current) or has been pressed since last
;	       call to B$RDTRIG (latched).
;
;	PSW.C set indicates that there was an error, else PSW.C is clear.
;
;Uses:
;	per convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$RDTRIG,<NEAR,PUBLIC>
cBegin

	CALL	B$SetClockInt	; check if CLOCK_INT has been installed
				;if not install it
	PUSH	BX
	PUSH	CX
	PUSH	AX
	XOR	BX,BX
	MOV	BL,AL		;place i.d. in bx
	SHL	BX,1
	TEST	AH,1		;Read Status or Trigger?
	JNZ	$STF_S		;Brif Status (0, 2, 4 or 6).
	MOV	CH,TRIGSA[BX+1] ;Get Trigger Mask for read
	CALL	RTRGST		;Read Trigger A1,B1,A2 or B2 in [CL]
	MOV	AL,CL
	JMP	SHORT $STF_RET	;Return: -1 if fired, 0 if not.

$STF_S:
	MOV	AL,BYTE PTR TRIGSA[BX] ;Get Trigger A or B value.
	MOV	BYTE PTR TRIGSA[BX],0 ;Tell INT routine we read it.
				;Return: -1 if fired, 0 if not.
$STF_RET:
	POP	BX		;restore original ah
	MOV	AH,BH
	POP	CX
	POP	BX
	CLC			;carry clear since no error
cEnd				

;***
;B$RDSTIK - Read Joystick Coordinates
;OEM-interface routine
;
;Purpose:
;	Return either the X or Y coordinate of a joystick.  The coordinate
;	is a system dependent signed value, which may simply be -1, 0 or 1.
;
;Entry:
;	[AL]=Function to be performed as follows:
;	       0 = Return the x coordinate for joystick A.
;	       1 = Return the y coordinate for joystick A.
;	       2 = Return the x coordinate for joystick B.
;	       3 = Return the y coordinate for joystick B.
;	       n = If n is even then n is x coordinate for joystick (n+2)/2
;		     else n is y coordinate for joystick (n+1)/2.
;
;Exit:
;	PSW.C is set indicates an error ([AL] represents a joystick number
;		     that is too large)
;	PSW.C is reset otherwise
;
;	[BX] = Signed integer result.
;
;Uses:
;	Per convention.
;
;Preserves:
;	AX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$RDSTIK,<NEAR,PUBLIC>,<AX,CX,DX>
cBegin

	CALL	B$SetClockInt	; check if CLOCK_INT has been installed
				;if not install it
	MOV	BL,AL		;place offset in bx
	XOR	BH,BH		;clear high byte
	CMP	BX,4		;Out of Range?
	JNB	STICK_ERROR	;Yes, complain..
	CALL	RSTICK		;read stick
	MOV	BL,STIKAX[BX]	;get it
	XOR	BH,BH		;(clears carry)
	JMP	SHORT StickExit	; return with carry clear
STICK_ERROR:
	STC			; indicate error
StickExit:
cEnd				; restore registers & return

;***
;RSTICK -	Reads the 4 Potentiometers.  Typically, each
;		value will range from 0 to 200 depending upon
;		the R values of the Pots.
;
;Entry: 	None
;
;Exit:		STIKAX,AY = x,y Coordinates of Channel A.
;		STIKBX,BY = x,y Coordinates of Channel B.
;****

cProc	RSTICK,<NEAR>,<AX,BX,DX>
cBegin

	CMP	b$MACHID,0FCH	;is this a PC-AT?
	JE	AT_STICK 	; brif so
	MOV	DX,GAMECD	;Game Card
	MOV	CX,257		;Counter, adjusted by -2.
	MOV	BX,0FH		;Pot Mask.
	CLI			;No Interrups During Sample
	PAUSE
	OUT	DX,AL		;Strobe to start
SAMPL:
	PAUSE
	IN	AL,DX		;Get the Pot Values
	AND	AL,0FH		;Isolate Pot Value
	CMP	AL,BL		;Set ZF if no change.
	LOOPZ	SAMPL		;Loop till change or count exhausted.
	JCXZ	SAMPL1		;Brif count done, else got change.
	XOR	AL,BL		;[AL] = one(s) that changed state
	MOV	AH,CL		;[AH] = compl of count.
	PUSH	AX		;Save count/mask
	INC	BH		;Push count +1.
	XOR	BL,AL		;[BL] = New Mask.
	JMP	SHORT SAMPL
SAMPL1:
	ENABLE			;Interrupts back on
	OR	BH,BH
	JZ	SAMPLX		;Brif no Game Card.
	MOV	DL,BH		;[DL] = No. to POP.
SAMPL2:
	MOV	BX,OFFSET DGROUP:STIKAX ;Pot value save area.
	MOV	CX,4		;Shift count (4 pots).
	POP	AX		;Get count/mask.
	NOT	AH		;Compl for true count.
	ADD	AH,DL		;Adjust for time in sample loop.
SAMPL3:
	SHR	AL,1		;Has this Paddle changed State?
	JNB	SAMPL4		;Brif Not..
	MOV	[BX],AH 	;Yes, store current count
SAMPL4:
	INC	BX		;Point to next Location
	LOOP	SAMPL3		;Until all 4 done...
	DEC	DL		;No. to POP -1
	JNZ	SAMPL2		;Brif more Values.
SAMPLX:

cEnd

;	read joystick coordinates for PC-AT

AT_STICK:
	MOV	AH,84H		;Joystick support
	MOV	DX,1		;read joystick pots
	INT	21D
	MOV	STIKAX,AL	;A(x)
	MOV	STIKAX+1,BL	;A(y)
	MOV	STIKAX+2,CL	;B(x)
	MOV	STIKAX+3,DL	;B(y)
	JMP	SHORT SAMPLX

;***
;B$JoystInt  STRIG Update
;
;		Called by Timer Interupt AFTER updating the
;		time-of-day only if joystick code present.
;
;		CLOCKTIC polls the PEN Status (if ON) and stores
;		new values.  Then Joystick TRIGGERS (if ON) and
;		stores their values if fired since last time
;		read with the STRIG(0), STRIG(2), STRIG(4) or
;		STRIG(6) Statement.
;
;	NOTE:	Rom clock interrupt routine saved [AX],[DX],[DS]
;****

cProc	B$JoystInt,<NEAR,PUBLIC>,<BX,CX>
cBegin

	MOV	BX,OFFSET DGROUP:TRIGSA ;Look at Trigger 'A' status.
	MOV	CX,4		;no. of triggers to read
TRGIN2:
	CMP	BYTE PTR [BX],0 ;Trigger x been read?
	JNZ	TRGIN3		;No, try next Trigger
	PUSH	CX
	MOV	CH,[BX+1]	;Get Mask for this Trigger
	CALL	RTRGST		; Read Trigger 'A' or 'B'
	MOV	[BX],CL 	; Store value
	CMP	CL,-1		; has trigger been pressed?
	JNZ	NoTrig		; brif not
	MOV	AX,BX		; AL = trap number for B$TrapEvent
	ADD	AX,STGOFF*2 + OFFSET DGROUP:TRIGSA
	SHR	AL,1		
	CALL	B$TrapEvent	; set global event flag
NoTrig:				
	POP	CX
TRGIN3:
	INC	BX
	INC	BX		;Next trigger status loc.
	LOOP	TRGIN2		;Until all triggers tested

cEnd				; restore regs & return



cProc	RTRGST,<NEAR>,<DX>	
cBegin				
	CMP	b$MACHID,0FCH	;is this a PC-AT?
	JNE	PCTRIG		;br. if not
	MOV	AH,84H		;Joystick support
	XOR	DX,DX		;read joystick triggers
	INT	15h		; [AL] = trigger values
	JMP	SHORT ALLTRIG	;skip PC trigger read
PCTRIG:
	MOV	DX,GAMECD
	PAUSE
	IN	AL,DX		;Read Joysticks/Triggers
ALLTRIG:
	AND	AL,CH		;Mask to Trigger 'A' or 'B'
	DEC	AL		;-1 if down.
	CBW			; 0 if up.
	MOV	CL,AH		;Return in [CL]
cEnd				; restore regs & return


sEnd	EV_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llhgcsup.asm ===
TITLE	LLHGCSUP - LowLevel HGC/CGA support (shared routines)
;***
; LLHGCSUP - LowLevel HGC/CGA support
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This module contains support routines extracted from LLCGA.ASM
;	(and modified) which are shared by CGA and HGC functions.
;
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_DATA
	USESEG	_BSS
	USESEG	GR_TEXT

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE llgrp.inc
	INCLUDE idmac.inc

sBegin	_BSS
;
; ***************************************************************************
; External variables
; ***************************************************************************
;
externB b$MaskC
externW b$OffC
externW B$VTOFST
externW B$VBOFST
externW B$VLOFST
externW B$VROFST
externW B$LEOFST
externW B$REOFST
externW b$BytesPerRow
externW b$UpSub
externW b$DnSub
externW b$UpDnAdd

sEnd	_BSS

assumes CS,GR_TEXT
sBegin	GR_TEXT

;***
; B$CgaLeftC2/B$CgaLeftC1
;
;Purpose:
;	Move graphics cursor left 1 pixel (2 bits for Screen 1, 1 bit for
;	Screen 2 or 3).  No test is made for screen boundaries.
;Entry:
;	None
;Exit:
;	b$MaskC, b$OffC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaLeftC2,<PUBLIC,NEAR>
cBegin
	;2 bits per pixel in screen 1
	rol	b$MaskC,1	;rotate mask one pixel left
	;1 bit per pixel in screen 2
labelNP <PUBLIC,B$CgaLeftC1>
	rol	b$MaskC,1
	jc	LeftCnext	;go if not in same byte
	ret
LeftCnext:
	dec	b$OffC 	;move byte pointer
	ret
cEnd

;***
; B$CgaChkUpC
;
;Purpose:
;	Move graphics cursor up 1 pixel.  A test is made for boundaries.
;	If it is a boundary then PSW.C is set upon return and no move is
;	made.
;Entry:
;	None
;Exit:
;	PSW.C set if original cursor was on top screen edge.
;	b$MaskC, b$OffC updated otherwise.
;Uses:
;	per conv.
;Exceptions:
;	exits through UpC if not on edge
;******************************************************************************
cProc	B$CgaChkUpC,<PUBLIC,NEAR>
cBegin
	MOV	AX,b$OffC	;[AX] = cursor offset
	XOR	AX,B$VTOFST	;cursor and VTOFST SHOULD BE same
				;half or quadrant of the screen
	AND	AH,60H		;will be non zero if not in same
				;half or quadrant of the screen
	JNZ	B$CgaUpC	;move cursor up by one
	MOV	AX,b$OffC	;[AX] = cursor offset
	CMP	AX,B$VTOFST	;already on top of viewport ?
	JAE	B$CgaUpC	;less than VTOFST means on top of
				;viewport
	STC			;STC to indicate that cursor already
cEnd				;on top of viewport

;***
; B$CgaUpC
;
;Purpose:
;	Move graphics cursor up 1 pixel.  No test is made for screen
;	boundaries.
;Entry:
;	None
;Exit:
;	b$MaskC, b$OffC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaUpC,<PUBLIC,NEAR>
cBegin
	mov	AX,b$OffC
	sub	AX,b$UpSub	;assume not going up MOD 0 to MOD 3
	jnb	UpExit		;go if so
	add	AX,b$UpDnAdd	;undo SUB + move up from MOD 0 to MOD 3
	clc			;(no error for ChkUpC)
UpExit:
	mov	b$OffC,AX
cEnd

;***
; B$CgaChkDownC
;
;Purpose:
;	Move graphics cursor down 1 pixel for Screen 1 or Screen 2.
;	If beyond the bottom edge, PSW.C is set upon return and no
;	move is made.
;Entry:
;	None
;Exit:
;	PSW.C set if original cursor was on bottom screen edge.
;	b$MaskC, b$OffC updated otherwise.
;Uses:
;	per conv.
;Exceptions:
;	exits through DownC if not on edge
;******************************************************************************
cProc	B$CgaChkDownC,<PUBLIC,NEAR>
cBegin
	MOV	AX,b$OffC	;[AX] = cursor offset
	XOR	AX,B$VBOFST	;cursor and VBOFST SHOULD BE in same
				;half or quadrant of screen
	AND	AH,60H		;will be non zero if not in same half
				;or quadrant of the screen
	JNZ	B$CgaDownC	;move cursor down by one
	MOV	AX,b$OffC	;[AX] = cursor offset
	CMP	AX,B$VBOFST	;already at the bottom of viewport?
	JB	B$CgaDownC	;Brif not
	STC			;STC to indicate that cursor is
cEnd				;on bottom of viewport

;***
; B$CgaDownC
;
;Purpose:
;	Move graphics cursor down 1 pixel for Screen 1 or Screen 2.
;	No test is made for screen boundaries.
;Entry:
;	None
;Exit:
;	b$MaskC, b$OffC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaDownC,<PUBLIC,NEAR>
cBegin
	mov	AX,b$OffC
	sub	AX,b$DnSub	;assume not going down from MOD 0 to MOD 3
	jnb	DownExit	;go if so
	add	AX,b$UpDnAdd	;undo SUB + move down from MOD 0 to MOD 3
	clc			;(no error for ChkDownC)
DownExit:
	mov	b$OffC,AX
cEnd

;***
; B$CgaPaintBound
;
;Purpose:
;	Called by PAINT before painting each scan line to facilitate
;	fast viewport edge detection for Screen 1 or Screen 2.	Set
;	VIEW left and right cursor addresses and masks.
;Entry:
;	None
;Exit:
;	B$LEOFST = left edge offset
;	B$REOFST = right edge offset
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$CgaPaintBound,<PUBLIC,NEAR>
cBegin

;  Map all rows to the first quadrant/half so that the first pixel in each
;  row will be a multiple of b$BytesPerRow.  Since each half/quadrants starts
;  at a power of two, and b$BytesPerRow has a 5 factor in it, rows in the upper
;  half/quadrants are not evenly divisible by b$BytesPerRow.

	MOV	AX,b$OffC	;get cursor position
	MOV	CH,AH		;b$OffC offset will be needed to remap
	AND	CH,01100000B	;mask in quadrant/half offset bits
	AND	AH,00011111B	;map to lower quadrant/half to make addr a
				;multiple of b$BytesPerRow

;  Compute the addr of the 1st pixel by doing an
;  INT(b$OffC/b$BytesPerRow)*b$BytesPerRow

	XOR	DX,DX		
	DIV	b$BytesPerRow	;[AL]= INT(b$OffC/b$BytesPerRow)
	MUL	b$BytesPerRow	;[AL]= INT(b$OffC/b$BytesPerRow)*b$BytesPerRow
	OR	AH,CH		;map back to proper quadrant/half
	XCHG	AX,DX

;  b$OffC addr of 1st pixel in current row is now in DX - compute boundries

	MOV	AX,B$VLOFST
	ADD	AX,DX
	MOV	B$LEOFST,AX	;Left margin= (x1,0)+b$OffC
	MOV	AX,B$VROFST
	ADD	AX,DX
	MOV	B$REOFST,AX	;Right margin= (x2,0)+b$OffC
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llhgc.asm ===
TITLE		LLHGC - HGC screen mode support
;***
;LLHGC - HGC screen mode support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Support for Hercules Graphics Card (HGC) graphics
;	screen mode (BIOS 8).
;
;	This module sets hooks in the mode-independent
;	modules to routines here for mode-dependent
;	graphics support.  See the mode-independent
;	modules for more precise descriptions of the
;	purposes and interfaces of these routines.
;
;	The following table summarizes the information for
;	the modes and configurations covered:
;
;    C		  |	A			     B
;    O		  |  B	T			     I
;    L		  |  I	T		 P	     T
;    O	     A	M |  O	R		 A    C      S
;  S R	     D	O |  S	I    C		 G    H      / P
;  C B	     A	N |	B    O		 E    A   P  P L
;  R U	C  R P	I |  M	U    L	 X   Y	 S    R   A  I A
;  E R	O  O T	T |  O	T    O	 R   R	 I    B   G  X N
;  E S	L  W E	O |  D	E    R	 E   E	 Z    O   E  E E
;  N T	S  S R	R |  E	S    S	 S   S	 E    X   S  L S
; -- - -- -- - -- | -- --- ---- --- --- --- ---- --- - -
;  3 x 80 25 H	M |  8	 2  N/A 720 348  32 9x14  2*  1 1
;
;  * only 1 page allowed if color card installed
;
; Discussion of HGC memory interleave line archtecture:
;	HGC video memory is organized into four interleaved banks of 8K
;	each.
;
;	Scan	Offset
;	Line	from B800
;	----	---------
;	0	0
;	1	8K
;	2	16K
;	3	24K
;	4	90
;	5	8K+90
;	6	16K+90
;	7	24K+90
;	.	.
;	.	.
;	.	.
;
;	To move  from scan line  to scan line  add to current address
;	-------  --------------  ------------  ----------------------
;	 UP	     MOD 0	     MOD 3	     24K-90
;	 UP	     MOD 1	     MOD 0	     -8K
;	 UP	     MOD 2	     MOD 1	     -8K
;	 UP	     MOD 3	     MOD 2	     -8K
;	 DOWN	     MOD 0	     MOD 1	      8K
;	 DOWN	     MOD 1	     MOD 2	      8K
;	 DOWN	     MOD 2	     MOD 3	      8K
;	 DOWN	     MOD 3	     MOD 0	    -24K+90
;
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_DATA
	USESEG	_BSS
	USESEG	GR_TEXT
	USESEG	CN_TEXT
	USESEG	XIB		
	USESEG	XI		
	USESEG	XIE		

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE llgrp.inc	;Constant definitions
	INCLUDE idmac.inc
	INCLUDE grmac.inc	;ModeData macros

	INITIALIZER B$xINITHERC ;Put B$xINITHERC in initializer list

sBegin	_BSS
;
; ***************************************************************************
; External variables
; ***************************************************************************
;
externB b$BiosMode
externB b$Adapter
externW b$VideoBase
externB b$MaskC
externW b$OffC
externW b$SegC
externW b$CurrPSize
externW b$CurPages
externW b$UpSub
externW b$DnSub
externW b$UpDnAdd
externB	b$MaxPage		; maximum number of pages allowed - 1
externW	b$VideoMem		; used to calculate b$MaxPage
externW b$ScreenTab		
sEnd	_BSS

assumes CS,GR_TEXT
sBegin	GR_TEXT

externNP B$SCNIO		;used in SCNIO macro

externNP B$InitModeData
externNP B$ErrorReturn
externNP B$CgaSetAttr
externNP B$CgaLeftC1
externNP B$CgaChkUpC
externNP B$CgaUpC
externNP B$CgaChkDownC
externNP B$CgaDownC
externNP B$CgaReadC
externNP B$CgaSetC
externNP B$CgaSetPixC
externNP B$CgaSetPixFirstC
externNP B$CgaSetPixLastC
externNP B$CgaPutAction
externNP B$CgaNReadL
externNP B$CgaNWriteL
externNP B$CgaNSetC
externNP B$CgaSetTile
externNP B$CgaPaintBound
externNP B$CgaScanL
externNP B$CgaScanR
externNP B$CgaLineX
externNP B$CgaLineY
externNP B$CgaLineV

;===========================================================================
mModeData	Mode3Data
;
; SCREEN 3, BIOS mode 8
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	3
mBiosMode	8
mBurst		0
mScrWidth	80
mScrHeight	25
mHorzRes	720
mVertRes	348
mVideoBase	0B000H
mMaxAttr	1
mMaxColor	-1		    ;no palette
mPageSize	32		    ;page size in K
mCurrPSize	<(32*1024) shr 4>   ;page size in paragraphs (1 plane)
mMaxPage	1
mNullColor	0
mForeColor	1
mBackColor	0
mEgaWrMd	0
mInitPalette	0
mInitVgaPal	0
mAlphaDim	AlphaDim3
mSetMode	SetMode3
mSetPages	SetPages
mPalReset	B$ErrorReturn
mPalPut 	B$ErrorReturn
mPalTrans	B$ErrorReturn
mPalSet 	B$ErrorReturn
mSetColor	B$ErrorReturn
mForeMapped	1
mBitsPerPixel	1
mPlanes 	1
mMapXYC 	MapXYC3
mLeftC		B$CgaLeftC1
mChkUpC 	B$CgaChkUpC
mUpC		B$CgaUpC
mChkDownC	B$CgaChkDownC
mDownC		B$CgaDownC
mSetAttr	B$CgaSetAttr
mReadC		B$CgaReadC
mSetC		B$CgaSetC
mSetPixC	B$CgaSetPixC
mSetPixFirstC	B$CgaSetPixFirstC
mSetPixLastC	B$CgaSetPixLastC
mLineX		B$CgaLineX
mLineY		B$CgaLineY
mLineV		B$CgaLineV
mPutAction	B$CgaPutAction
mNReadL 	B$CgaNReadL
mNWriteL	B$CgaNWriteL
mNSetC		B$CgaNSetC
mPaintBound	B$CgaPaintBound
mSetTile	B$CgaSetTile
mScanL		B$CgaScanL
mScanR		B$CgaScanR
mEnd		GraphDataLen
;===========================================================================

labelNP <PUBLIC, B$HRCUSED>	

;*** 
; B$Screen3
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 3.
;Entry:
;	AL = screen mode (3)
;	AH = burst (N/A)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen3,<PUBLIC,NEAR>
cBegin
	test	b$Adapter,HGC	;check for adapter support
	stc
	jz	ScrExit 	;exit w/error if not supported
	mov	bx,GR_TEXTOFFSET Mode3Data  ;mode-specific data
	mov	cx,GraphDataLen
	call	B$InitModeData	;initialize table data
	mov	b$UpSub,8192
	mov	b$DnSub,24576-90
	mov	b$UpDnAdd,8192+24576-90
	mov	ax,[b$VideoMem]
	rol	al,1		; divide by 32K
	rol	al,1		
	and	[b$MaxPage],al	; Max pages = b$Videomem / 32K
; NOTE:  Clear carry here -- currently done by the AND instruction
;	clc			;indicate no error
ScrExit:
cEnd

;***
; AlphaDim3
;
;Purpose:
;	Validate the proposed text dimensions for Screen 3.
;	  If 80x25 is requested, this mode satisfies the request
;	  else suggest screen mode 0.
;Entry:
;	BH = number of lines
;	BL = number of columns
;Exit:
;	AL = -1 if this mode satisfies the request, otherwise
;		AL is suggested screen mode to invoke for desired dimensions
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	AlphaDim3
cProc	AlphaDim3,<NEAR>
cBegin
	mov	al,-1		;flag request satisfied (maybe)
	cmp	bx,80+25*256	;80x25?
	je	ADim3Exit	;exit if so, standard stuff
	xor	al,al		;flag request for screen 0, let text mode try
ADim3Exit:
	clc			;no error
cEnd

;***
; SetMode3
;
;Purpose:
;	Set the screen mode according to the characteristics established
;	by previous call to B$Screenx and b$AlphaDim.
;Entry:
;
;Exit:
;
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	SetMode3
cProc	SetMode3,<NEAR>
cBegin
	mov	al,b$BiosMode	;set BIOS mode 8
	SCNIOS	vSetMode
cEnd

;***
; SetPages
;
;Purpose:
;	Set the current active and visual pages and calculate page size
;	and video segment offset for EGA modes.
;Entry:
;	AL = active page
;	AH = visual page
;Exit:
;	b$CurPages set to new active and visual pages.
;	b$SegC set to start of new active page.
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	SetPages,<NEAR>
cBegin
	mov	b$CurPages,ax	;save page numbers
	push	ax
	mov	al,ah
	SCNIO	vSelActivePage	;set visual page
	pop	ax
	cbw			;extend active page to word
	mul	b$CurrPSize	;times page size in paras
	add	ax,b$VideoBase ;set video segment
	mov	b$SegC,ax
cEnd

;***
; MapXYC3
;
;Purpose:
;	May given X and Y coordinates to the graphics cursor for Screen 3.
;Entry:
;	CX = X coordinate
;	DX = Y coordinate
;Exit:
;	b$OffC, b$MaskC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	MapXYC3
cProc	MapXYC3,<NEAR>
cBegin
	xor	ax,ax
	shr	dx,1		;dx=row within quadrant
	rcr	ax,1		;ax=8K multiple for quadrant displacement
	shr	dx,1
	rcr	ax,1
	shr	ax,1
	mov	bx,dx		;multiply y by 90 to compute row displacement
	shl	dx,1		;dx=2*Y
	shl	dx,1		;dx=4*Y
	add	dx,bx		;dx=5*Y
	shl	dx,1		;dx=10*Y
	mov	bx,dx
	shl	dx,1		;dx=20*Y
	shl	dx,1		;dx=40*Y
	shl	dx,1		;dx=80*Y
	add	dx,bx		;dx=90*Y
	add	dx,ax		;add in quadrant displacement
	mov	ax,cx		;save x
	shr	ax,1		;div by PixelsPerByte (8)
	shr	ax,1		;  to get byte index
	shr	ax,1
	add	dx,ax		;add x byte offset to y row address
	mov	b$OffC,dx	;save byte offset
	and	cl,7		;mask in x bit addr
	mov	ch,10000000B	;leftmost pixel on in shift mask
	shr	ch,cl		;move over to get mask
	mov	b$MaskC,ch	;store cursor mask
cEnd

;***
; B$xINITHERC - initialize HERC modes
;
;Purpose:
;	Added with revision [2].
;	Put the address of Hercules screen mode support routine into the
;	dispatch table used by the screen statement.
;
;Entry:
;	None
;Exit:
;	ScreenTab updated
;Uses:
;	None
;Exceptions:
;******************************************************************************
cProc	B$xINITHERC,<FAR,PUBLIC> 
cBegin
	MOV	WORD PTR [b$ScreenTab + (3*2) + 1],OFFSET B$Screen3
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llinit.asm ===
TITLE	LLINIT - GW-BASIC Interface Initialization
;***
; LLINIT.ASM - GW-BASIC Interface Initialization
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

	INCLUDE switch.inc	;switch file [new]
	INCLUDE rmacros.inc	;useseg macro

	USESEG	RT_TEXT 	;core runtime segment
	USESEG	_DATA		
	USESEG	CONST		
	USESEG	_BSS		

	INCLUDE seg.inc 	;segment definitions
	INCLUDE idmac.inc	;internal debug macros
	INCLUDE oscalls.inc	;Dos 5 structures
	INCLUDE ibmunv.inc
	INCLUDE intmac.inc
	INCLUDE const.inc	; b$IOFLAG field definitions.
	INCLUDE llgrp.inc	; Constant definitions
	INCLUDE baslibma.inc	; SKIP macro



sBegin	_DATA			

globalW b$pChkOlivetti,B$NearRet ; pointer to routine in lloga.asm

labelW	<PUBLIC,b$DSP> 	;b$BLDSP and b$WHDSP in one word
globalB b$BLDSP,70H,1		;encoded attr for fct. key reverse video
globalB b$WHDSP,7,1		;encoded attr for fct. key reverse video

labelW	<PUBLIC,b$InsCsrTyp>	; insert mode cursor (init to 1/2 block)
globalB	b$InsCsrStop,7,1	; cursor stop line (*)
staticB	InsCsrStart,4,1		; cursor start line (*)

labelW	<PUBLIC,b$UsrCsrTyp>	; user defined cursor
globalB	b$UsrCsrStop,7,1	; cursor stop line (*)
globalB	b$UsrCsrStart,7,1	; cursor start line (*)

globalW b$OrgCsrTyp,,1 	;startup cursor type

globalW b$OrgScrBst,,1 	;screen BASIC mode and burst at startup
globalB b$OrgBiosMode,,1	;entry BIOS mode save [23] made public
globalW b$OrgPages,,1		;active and visual pages at startup

labelW	<PUBLIC,b$OrgScrDim>	;screen dimensions at startup in one word
staticB	,,1			;width
labelB	<PUBLIC,b_orglen>	;Interpreter reachable label
globalB b$orglen,25,1		;height

externB	b$IOFLAG		; Misc. IO flags.  Defined in GWINI.ASM
externW	b$CURSOR		; Screen cursor.  Defined in GWDATA.ASM
externW b$CurPages		

staticB b$SCNFLAG,0,1		;screen initialization flags
	SCN_RESET = 1		;screen startup mode change
	SCN_GIOINI= 1		;force SetMode for GIO initialization

sEnd	_DATA			

sBegin	CONST

	 ;translation table to translate from BIOS mode to BASIC screen mode
HSMTBL	DB	0,0,0,0,1,1,2,0,3,0,0,0,0,7,8,10,9  
	DB	11,12,13	

sEnd	CONST

sBegin	_BSS			
externB b$ScrWidth		
externB b$ScrHeight		
externB b$ScreenMode		
externB b$BiosMode		
globalW b$VGAmodesL,,1		; flag for VGA BIOS modes 0-F
globalB	b$VGAmodesH,,1		; flag for VGA BIOS modes 10h-13h
staticB	VgaMiscInfo,,1		; miscellaneous VGA-MCGA-PS/2 info
externB b$Burst			

externW  b$SetMode		
externW  b$SetPages		
externW b$PalReset		
globalB b$EgaPalSup,,1 	;EGA palette hardware support flag

externB b$Buf1			

labelW	Equip			;b$OrgEquip and b$CurEquip in one word
globalB b$OrgEquip,,1		;startup BiosEquip flags
globalB b$CurEquip,,1		;current BiosEquip flags

globalW b$KBDVEC_SAVE,,2	;ROM keyboard vector saved here
globalW b$CLKVEC_SAVE,,2	;ROM clock vector saved here

globalB b$NetCard,,1		;boolean indicating if netcard installed
				; under DOS 3.xx
				; b$NetCard=1 --> netcard installed
				; b$NetCard=0 --> not installed
globalB b$DOS_INT_MASK,,1	;8259 interrupt mask is saved here
				;on BASIC entry (IRQ2 set if AT)

globalB b$MACHID,,1		;machine ID. This byte is set by the
				;routine B$GWINI as follows:
				;  0FFH if PC
				;  0FEH if PC XT
				;  0FDH if PC Jr
				;  0FCH if PC AT
				;	or PS/2 model 50 (Centurion)
				;	or PS/2 model 60 (Skylane)
				;  0FAH if PS/2 model 30 (Icarus)
				;  0F8H if PS/2 model 80 (Cardinal)


; b$Adapter and b$Monitor must be contiguous
labelB	<PUBLIC,b_Adapter> ; Interpreter reachable label
globalB b$Adapter,0,1	;current graphics adapter; !0 indicates GWINI called
			;  00000001 = Monochrome Display Adapter (MDPA)
			;  00000010 = Color Graphics Adapter     (CGA)
			;  00000100 = Enhanced Graphics Adapter  (EGA)
			;  00001000 = Video Graphics Array	     (VGA)
			;  00010000 = MultiColor Graphics Array  (MCGA)
			;  00100000 = Hercules Graphics Card     (HGC)
			;  0100xxx0 = Olivetti Graphics Adapter  (OGA)

; The VGA is limited to color modes if an MDPA is found in the machine,
; and limited to monochrome modes if a CGA is found in the machine.  If
; the VGA is the only adapter in the machine it can use all modes.

; b$Adapter and b$Monitor must be contiguous
globalB b$Monitor,,1	;current display monitor
			;  00000001 = Monochrome
			;  00000010 = Color (or Enhanced emulating color)
			;  00000100 = Enhanced Color
			;  00001000 = Analog (supporting mono modes)
			;  00010000 = Analog (supporting color modes)
globalW b$VideoMem,,1		;graphics adapter video memory in K


sEnd	_BSS			

sBegin	RT_TEXT 		
	assumes CS,RT_TEXT	

	externNP B$NearRet	
	externNP B$VIEWINIT	
	externNP B$SETSCNDATA	; init the low-level screen variables
	externNP B$GRMODE	
	externNP B$SCROLL	



	externNP B$GETCSRDATA	


	externNP B$SCNIO	; used in SCNIOS macro!!!!!

	externNP B$FixTextPage	

globalD b$OldClkTic,,1 	;label storing the vectors of
				;of old interrupt 1CH
globalW b$BASDSG,,1		;address of BASIC data segment



;***
;B$GWINI - OEM initialization
;OEM-interface routine
;
;Purpose:
;	This routine is called once during initialization.  It contains
;	machine specific code to put the system into a deterministic
;	initial state.
;
;Responsibilities:
;	After executing this routine, the following items must have
;	occurred:
;	   1) B$VIEWINIT must have been called.
;	   2) B$SCNSWI must have been called.
;	   3) The initial screen state must have been saved so that
;	      screen termination (B$RESETSCN) can restore it.
;	   4) if this runtime is for a QB interpreter, B$SCINIT must
;	      have been called.
;	   5) The variables listed in the Exit: section must be set.
;
;	B$GWINI should not reset the physical screen.	This is done by
;	B$SCINIT which is called before any screen activity.
;
;	This routine is called FAR.
;
;	NOTE:  This is one of a pair of OEM-Dependent initialization
;	routines.  This one deals mainly with Screen and Interrupt
;	initialization.  See B$RTLLINI for more details.
;
;Entry:
;	None.
;
;Exit:
;	b$IOFLAG   - Set fields SCN_INIT and SCN_SCROLL properly
;	b$CurPages - contains initial active and visual pages
;	b$CURSOR   - contains current cursor position.
;	b$ScreenMode - contains current BASIC screen mode
;	b$CurPages - contains current visual and active pages
;
;	PSW.C is set to indicate an error.  The runtime will abort
;	      with a fatal error condition.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;****
;
;Algorithm:
;	get initial screen mode
;	store mode for exit
;	compute screen length and width
;	get current cursor position and type
;	save cursor type for exit
;	set up the initial cursor rasters
;	compute BASIC screen mode and color burst toggle
;	call section of SCREEN statement code that initializes
;		the screen variables
;	clear carry before exiting
;#****

cProc	B$GWINI,<PUBLIC,FAR>	
cBegin				

	CMP	[b$Adapter],0	; make sure first time called (mixed lang.)
	JZ	FirstTime	; brif not
	JMP	INIRET		; otherwise abort
FirstTime:			
	and	b$IOFLAG,NOT SCN_INIT	;clear screen init flag

	PUSH	ES
	XOR	BX,BX
	MOV	ES,BX
	mov	al,es:[BiosEquip]   ;get the equipment flags
	mov	ah,al		;copy to AH
	mov	Equip,ax	;save b$OrgEquip and b$CurEquip values
	dec	bx		;segment 0FFFFH
	MOV	ES,BX		;address using the ES register
	MOV	AL,ES:[000EH]	;get the machine ID in [AL]
	MOV	b$MACHID,AL	;store it in b$MACHID
	POP	ES

;   If machine is an AT, enable IRQ2.  In any case, save the
;   current interrupt mask register contents in b$DOS_INT_MASK.

	MOV	DX,INTA1	;get interrupt mask register address
	CLI			;disable interrupts
	IN	AL,DX		;get interrupt mask (IRQ7->IRQ0)
	CMP	b$MACHID,0FCH	;test if machine is AT
	JNZ	NOT_AT		;jump if not an AT machine
	AND	AL,NOT 4	;clear bit 3 (IRQ2) for AT
	OUT	DX,AL		;and write it out to enable it
NOT_AT:
	STI			;re-enable interrupts
	MOV	b$DOS_INT_MASK,AL ;save as the DOS interrupt mask


	CLI			;disable interrupts
				;The 3 SAVINTs are required since
				;B$SNDOFF and B$GWTERM restore them.
				;Interrupts turned on in SNDOFF.

	PUSH	ES
	SAVINT	b$KBDVEC_SAVE,KBDVEC ;save INT EF vector
	SAVINT	b$CLKVEC_SAVE,CLKVEC ;save INT F0 vector
	POP	ES		;restore segments...

	XFRINT	KBDVEC/4,KBDINT/4 ;move INT 09H to INT EFH
	XFRINT	CLKVEC/4,CLKINT/4 ;move INT 04H to INT F0H

	PUSH	DS		;save DS...
	xor	ax,ax
	mov	ds,ax
	push	es
	SAVINT	DS:TICSAV,TIMADR ; save get control on timer INT VEC
	pop	es
	pop	ds

	SCNIOS	vGetVideoState	;get current screen mode
	mov	dl,bh		;let the current active page AND visual
	mov	dh,bh		;  page be the visual page from entry
	MOV	b$OrgBiosMode,AL ;save inital screen mode
	MOV	CL,AH		;CL = screen width
	CMP	AL,40h		; check for Olivetti 640x400 mode
	JNE	Not40h		; brif not
	MOV	AL,4		; BASIC Screen mode 4
	JMP	SHORT NoBurst	; no burst for Screen 4
Not40h:				
	MOV	AH,AL		;AH = bios mode
	MOV	BX,OFFSET DGROUP:HSMTBL ;get init scrn mode table offset
	XLAT			;AL = screen mode
	and	ah,1		;strip bios mode to get color burst
	cmp	al,1		;screen 0 or 1?
	jbe	UseBurst	;go if so, burst is valid
NoBurst:			
	xor	ah,ah		;no burst for other modes
UseBurst:			
	push	ax		;save: screen mode and burst
	push	dx		;	   pages
	push	cx		;	   width

	CALL	B$SetAdapter	; Determine display hardware configuration


	MOV	AL,30h		
	XOR	BX,BX		
	XOR	CX,CX		
	MOV	DX,24		; default to 25 lines (incremented below)
	PUSH	ES		; Preserve (it's a return value)
	SCNIOS	vCharGen	
	POP	ES		
	INC	DX		
	pop	cx		
	mov	ch,dl		;CH = height
	pop	dx		
	pop	ax		
	push	ax		;save:  screen mode and burst
	push	cx		;	    width and height
	call	B$SETSCNDATA	;set up screen data for entry mode
	pop	cx		
	pop	ax		
	;The entry mode may not be one supported by our software
	;configuration. If something is different than what was
	;requested, set a flag so screen initialization will set
	;the new mode when the time comes.
	cmp	al,b$ScreenMode;mode changed?
	jne	ModeChgd	;go if so
	cmp	cl,b$ScrWidth	;width?
	jne	ModeChgd	;go if so
	cmp	ch,b$ScrHeight ;height?
	je	NoChange	;go if not
ModeChgd:			
	OR	b$SCNFLAG,SCN_RESET	;set screen reset flag for B$SCINIT
NoChange:			
	mov	al,b$ScreenMode;save entry screen mode
	mov	ah,b$Burst	;		burst
	mov	b$OrgScrBst,ax 

	mov	ax,b$CurPages	;		pages
	mov	b$OrgPages,ax	

	mov	ax,word ptr [b$ScrWidth] ; width and height in 1 word
	mov	b$OrgScrDim,ax	;(sets b$orglen)

;	If we're in 25 line mode, the cursor start/stop lines vary depending
;	on how many scan lines are on the screen.  If we're in a mode with
;	other than 25 lines, the cursor is from 7 to 7 regardless of scan line
;	count.

	CMP	AH,25		; 25 line mode?
	JNZ	Use7_7		; no, use 7,7 cursor.

	CMP	b$BiosMode,7	; is it b/w mode? (indicates 350 scan lines)
	JNZ	Use7_7		; no, use default
	MOV	AX,0C0CH	; b/w cursor raster is 12,12
	MOV	b$UsrCsrTyp,AX	; save new user cursor
	MOV	b$InsCsrStop,AL ; save new insert cursor stop line

Use7_7:
	CALL	B$GETCSRDATA	; load cursor position into DX
				; and cursor type into CX
				; (updates B$CSRPOS, B$CSRTYP)
	mov	b$OrgCsrTyp,cx ; save entry cursor type
	test	b$SCNFLAG,SCN_RESET	;will we reset screen?
	jnz	HomeCsr 		;go if so to home cursor
	CALL	B$GRMODE 	; graphics mode?
	JZ	NOT_GRAPH	; brif not -- use current cursor location
HomeCsr:			
	MOV	DX,0101h	; use (1,1) as initial high-level cursor
NOT_GRAPH:			

	CMP	DL,b$ScrHeight ; is cursor presently on last line?
	JNZ	NOT_LST		; brif not
				; note: graphics modes will always branch
	DEC	DX		; we want it on previous line
	OR	b$IOFLAG,SCN_SCROLL ; signal B$SCINIT to scroll the
				; screen before first screen operation.
NOT_LST:			

	MOV	b$CURSOR,DX	; update high-level cursor position

	CALL	B$VIEWINIT	; initialize viewports and graphics cursor

	call	B$SCINIT	;initialization.  Do it all now to

	sti
	mov	ah,30h		; if dos 3 then if network installed
	int	21h		; then do not eat CTRL-ALT-BRK.
	cmp	al,3		; version 3 and above
	jb	not3		; brif less than 3.xx
	xor	ah,ah		; netcard installation check
	int	2ah
	or	ah,ah		; [ah] = 0 --> network not installed
	jz	not3		; brif network not installed
	mov	b$NetCard,1	; else set b$NetCard for use in -cevt
not3:
	CLC			;clear carry to indicate no error
INIRET:

cEnd				



;
;	Added as part of revision [17].
;***
;B$SCINIT -- Initialize the screen.
;OEM-interface routine
;
;Purpose:
;
;	This routine exists to delay initialization operations that
;	actually effect the screen until such time as it is determined
;	that an actual screen operation (text output, graphics, etc.)
;	is to take place.  Thus a program which does not use the screen
;	(such as those doing only file I/O or redirection) will never
;	change the screen mode or appearance.
;
;	Performs the remaining screen initialization required before a
;	screen operation can be done. If bit SCN_INIT of b$IOFLAG is not
;	set, it initializes the cursor raster and initializes the palette.
;	Scrolls the screen if bit SCN_SCROLL of b$IOFLAG is set.  Sets
;	bit SCN_INIT of b$IOFLAG to indicate that screen initialization
;	has been done.
;
;	If running under OS/2, the screen should to be cleared by a
;	call to B$CLRSCN with a parameter of 0.
;
;	In the OEM code, the following routines must either call B$SCINIT
;	or make sure that B$SCINIT has been called.
;
;	    LLASCN.ASM
;
;		B$PCOPYS
;
;	    LLCSCN.ASM
;
;		B$SCREEN, B$SCRSTT, B$SWIDTH, B$SETCLR
;
;	    LLSCNIO.ASM
;
;		B$OFFCSR, B$OVWCSR, B$INSCSR, B$USRCSR
;		B$CLRSCN
;
;Entry:
;	Bits SCN_INIT and SCN_SCROLL of b$IOFLAG properly set.
;
;Exit:
;	Bit SCN_INIT of b$IOFLAG set.
;
;Uses:
;	Per convention.
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;**********************************************************************
;
;	Bit SCN_RESET of b$SCNFLAG may also be set indicating that the
;	startup (current) screen mode is unsupported.  If so, a new mode
;	has already been determined and setup by B$SETSCNDATA (called
;	from B$GWINI) and all that remains here is to actually change the
;	screen to that mode and set valid page data.
;
;	There must be a call to B$SCINIT before each screen operation.
;	The following is a list of where each of the calls are, and what
;	screen statements they handle:
;
;	    CIRCLE.ASM:
;		B$CIRC:		Handles CIRCLE.
;
;	    DRAW.ASM:
;		B$DRAW:		Handles DRAW.
;
;	    GETPUT.ASM:
;		B$GGET:		Handles GET.
;		B$GPUT:		Handles PUT.
;
;	    GRLINE.ASM:
;		B$LINE:		Handles LINE.
;
;	    GRPOINT.ASM:
;		B$PNI2, B$PNR4:	Handles POINT.
;		DO_PSET:		Handles PSET, PRESET.
;
;	    GW2GRP.ASM:
;		B$VIEW, B$VEW0:	Handles VIEW.
;
;	    GWPAL.ASM:
;		B$PAL0, B$PAL2,	Handles PALETTE.
;		B$PALU
;
;	    GWSCR.ASM:
;		B$CSRL:		Handles CSRLIN.  No changes.
;
;	    IOTTY.ASM:
;		B$FPOS:		Handles POS.  No changes.
;
;	    LLASCN:
;		B$PCOPYS:		Handles PCOPY.
;
;	    LLCSCN:
;		B$SCREEN:		Handles SCREEN().
;		B$SCRSTT:		Handles SCREEN.
;		B$SWIDTH:		Handles WIDTH.
;		B$SETCLR:		Handles COLOR.
;
;	    LLSCNIO:
;		B$CSRDSP:		Handles INPUT, LINE INPUT, PRINT,
;						WRITE, LOCATE, KEY, SHELL,
;						VIEW PRINT, TAB, SPC, WINDOW.
;		B$CLRSCN:		Handles CLS.
;		B$SCROUT, B$STRSOUT:	Handles PRINT, WRITE.
;
;	    PAINT.ASM:
;		B$PAIN, B$PNTC:	Handles PAINT.
;
;

cProc	B$SCINIT,<PUBLIC,NEAR>
cBegin
	TEST	b$IOFLAG,SCN_INIT ; init done already?
	JZ	DO_INIT		; brif not -- do it now
INIT_DONE:			; took initialization code out of here
				; so that most calls will fall through
cEnd


cProc	DO_INIT,<NEAR>,<AX,BX,CX,DX>	
cBegin				
	OR	b$IOFLAG,SCN_INIT ; signal screen init done

	test	b$SCNFLAG,SCN_RESET	;startup screen mode change?
	jz	NoReset 	;go if not
	call	B$ChkMonitor	; Set VGA monitor type before setting mode
	call	[b$SetMode]	;set the new screen mode
	call	B$FixTextPage	; fix b$CurrPSize, b$PageTable

NoReset:			
	mov	ax,b$CurPages	
	call	[b$SetPages]	; Set current page data

	; move up one line if on the last one
	TEST	b$IOFLAG,SCN_SCROLL ; are we to scroll the screen?
	JZ	NOT_LAST	; brif not

	CALL	B$SCROLL	; scroll up 1 line
NOT_LAST:

	CALL	[b$PalReset]	;initialize the palette

cEnd				; restore registers & return


;***
; B$SetAdapter
;
;Purpose:
;	Determine configuration of video adapter, monitor and memory.
;	Major rewrite (from $SETCL4) with [21].
;Entry:
;Exit:
;	b$Adapter, b$Monitor, and b$VideoMem updated
;	b$EgaPalSup set as appropriate
;Uses:
;Exceptions:
;****

cProc	B$SetAdapter,<PUBLIC,NEAR>,<AX,BX,CX>
cBegin
	PUSH	ES		
	PUSH	DI		

	
	mov	ax,StdColor	;AH gets 0, AL gets CGA mask
	mov	b$Adapter,al	;Assume CGA, no EGA or VGA card present
	mov	b$VideoMem,16	;  w/16K video memory
	mov	b$Monitor,al	;Assume std color monitor
	mov	b$EgaPalSup,ah ;  no EGA palette support

	PUSH	DS		;set ES=DS
	POP	ES		;  for vGetVgaInfo call
	MOV	DI,OFFSET DGROUP:b$Buf1 ; dest. buffer for VGA info
	XOR	BX,BX		;Bios sub-function to return VGA info
	SCNIOS	vGetVgaInfo	;Returns: [AL] = 1B (vGetVgaInfo) if VGA
				;	      if VGA, 64 bytes of info at ES:DI

	CMP	AL,vGetVgaInfo	;is VGA present?
	JNE	NOTVGA		;no, go check for EGA
	MOV	BL,[DI+31H]	; available video memory
	MOV	AL,[DI+2Dh]	; VGA-MCGA-PS/2 Miscellaneous state info
	MOV	[VgaMiscInfo],AL ; save state info for B$ChkMonitor
	LES	DI,[DI] 	;long pointer to static functionality table
	MOV	AX,ES:[DI]	; find out which VGA modes hardware supports
	MOV	[b$VGAmodesL],AX ; save for Screen mode validation
	MOV	AL,ES:[DI+2]	; same for modes 10h-13h
	MOV	[b$VGAmodesH],AL ; save for Screen mode validation

;	The first three bytes of the static functionality table define (by bit
;	flags) which bios modes are supported by the current graphics adapter.
;	Bios mode 12H is supported by the VGA but not by the MCGA.  We can tell
;	which of these two we are working with by testing the bit which
;	corresponds to that bios mode.

	MOV	b$Adapter,MCGA	;assume MCGA
	MOV	b$Monitor,AnalogColor ; analog color monitor (in case MCGA)
	TEST	AL,VGAmode12h	; is bios mode 12H supported?
	JZ	MonOK		;no, we must have an MCGA
; At this point we know we have a VGA, but we must check if there is
; a second adapter (MDPA, HGC, CGA) installed and, if so, which one is
; currently active.  ADJUST_VGA returns with PSW.C set if VGA not active.
; Also, b$Monitor, b$VGAmodeL, and b$VGAmodeH are adjusted accordingly.
	MOV	b$Monitor,AnalogColor + AnalogMono ; analog monitor
	CALL	ADJUST_VGA	; check/adjust for 2nd adapter
	JC	TRANS		; brif VGA not active adapter
	MOV	b$Adapter,VGA	;using VGA
	MOV	b$EgaPalSup,1	;have EGA palette support
	JMP	SHORT MonOK	;translate video memory size and then exit
NOTVGA: 			

	MOV	BL,10h		;% Bios sub-function to return EGA information
	SCNIOS	vAltSelect	;% Returns: [BH] = 0=color/1=mono mode
				;%	    [BL] = memory on ega card
				;	    [CH] = feature bits
				;	    [CL] = switch settings (monitor)

	TEST	BL,11111100B	;if EGA support, only bit 0,1 have values
	JNZ	TRANS		;exit if no EGA

;	At this point we know we have an EGA card, and whether it has
;	monochrome monitor attached.
;	Use the 30H bits in b$CurEquip to determine
;	the active display. 10H for COLOR40, 20H for COLOR80 or 30h for
;	Monochrome.

	mov	al,b$CurEquip	; Read the current equipment setting
	AND	AX,30H		; Knock off unwanted bits : AH = 0
	CMP	AL,30H		; Is it monochrome?
	JNE	COLOR_ACTIVE	; Brif not - color monitor
	INC	AH		; AH = 1 for Monochrome
COLOR_ACTIVE:			
	CMP	AH,BH		; init mode same as EGA mode?
	JNE	TRANS		; Brif not
	mov	b$Adapter,EGA	;using EGA
	mov	b$EgaPalSup,1	;have EGA palette support
	and	cl,0FH		;monitor 7=color,8=enh as color,9=enh,B=mono
	sub	cl,9		;<0=color,0=enh,2=mono
	jc	MonOk		;go if color (the above assumption)
	MOV	CH,EnhColor	; assume enh (cl=0)
	JZ	IsEnh		; it is enh, CH has bit mask we want
	MOV	CH,Monochrome	; must be mono, set up bit mask accordingly
IsEnh:				
	MOV	b$Monitor,CH	; save it
MonOk:
	;BL=amount of EGA memory: 0 -- 64K, 1 -- 128K, 2 -- 192K,3 -- 256K
	inc	bl		;now increments of 64K
	xor	bh,bh
	mov	cl,6
	shl	bx,cl		;times 64 to put in increments of 1K
	mov	b$VideoMem,bx	;save it
	JMP	SHORT SETEXT	;exit

; this label reached only if EGA card is not installed or is not the
; current active card.

TRANS:

	mov	al,b$CurEquip	;check if equipment set for MDPA
	AND	AL,00110000B	;by isolating bits 4 and 5
	CMP	AL,00110000B	;and checking for both set
	JNZ	SETEXT		;BRIF color correct (not MDPA)
	dec	b$Monitor	;else MDPA
	dec	b$Adapter	;  and mono monitor
	mov	b$VideoMem,4	;w/4K video memory

SETEXT:				
; check for OGA here if CGA, EGA, or VGA
	test	[b$Adapter],CGA+EGA+VGA ; only these could be Olivetti
	jz	ChkHerc		; brif cannot be Olivetti
	xor	ax,ax		; ensure AX = 0 if lloga.ob3 not linked in
	call	[b$pChkOlivetti] ; check if Olivetti 640x400 mode supported
	jz	ChkHerc		; returns AL=0, PSW.Z = 1 if not supported
	or	[b$Adapter],al	; Assumes b$Adapter never CMPed in runtime!
	cmp	[b$VideoMem],32	; will have at least 32K
	ja	ChkHerc		; brif already set
	mov	[b$VideoMem],32 ; set 32K video memory
ChkHerc:			
	mov	dx,-1		; DX will not change if no driver
	SCNIOS	0EFH		;test for Hercules INT10 driver
	cmp	dl,-1		;DL returns -1 if no driver or no HGC
; code to handle CGA plus HGC 
	je	setext2		; brif so, already set to CGA or MDPA above
	test	[b$Adapter],MDPA ; do we have a monochrome display?
	jz	half_mode	; brif not, make CGA work with HGC
	mov	b$Adapter,HGC	;set adapter to HGC
	mov	b$VideoMem,64	;w/64K video memory
	or	dh,dh		; see if driver indicated HALF mode
	jnz	setext2		; brif not, assume only card
	shr	[b$VideoMem],1	; only 32K with second card
half_mode:			; make HGC work with CGA
	mov	dx,03BFh	; Hercules configuration port
	mov	al,HALF		; make sure only in HALF mode
	out	dx,al		; write to HGC config. port

setext2:			

	POP	DI		
	POP	ES		
cEnd

;*** 
;ADJUST_VGA - Check if VGA is active and which modes it supports
;
;Purpose:
;	Checks for multiple adapters when one is a VGA.
;
;Entry:
;	b$Monitor = AnalogColor + AnalogMono
;
;Exit:
;	b$CurEquip possibly updated.
;	PSW.C set if VGA not active adapter.
;	b$VGAmodeL and b$VGAModeH adjusted as necessary.
;	b$Monitor adjusted for active display (if PSW.C, = StdColor)
;
;Uses:
;	AX.
;
;Preserves:
;	ES.
;
;Exceptions:
;	None.
;
;******************************************************************************
cProc	ADJUST_VGA,<NEAR>,<ES>
cBegin				; entire routine
	XOR	AX,AX
	mov	ES,AX
	MOV	AX,ES:[488h]
	TEST	AH,1		; see if VGA handles all modes
	JNZ	vga_exit	; brif so
	TEST	AL,8		; see if display attached
	JNZ	got_display
	XOR	AL,2		; reverse BIT 1
got_display:
	MOV	AH,ES:[BiosEquip] ; read current BiosEquip
	mov	b$CurEquip,ah	; update the current equipment setting
	AND	AH,30H		; Knock off unwanted bits
	CMP	AH,30H		; Is it monochrome?
	JE	flag_Set	; Brif so
	XOR	AL,2		; invert for color monitor
flag_set:
	TEST	AL,2
	JZ	no_vga		; VGA not active
	CMP	AH,30h		; MONO?
	je	setvgamono	; brif so
	and	b$VGAmodesL, NOT (VGAMode7h+VGAModeFh)
	MOV	b$Monitor,AnalogColor
	jmp	short vga_exit
setvgamono:
	mov	b$VGAmodesH,0
	and	b$VGAmodesL, VGAMode7h+VGAModeFh
	MOV	b$Monitor,AnalogMono
	jmp	short vga_exit
no_vga:
	XOR	AX,AX
	MOV	b$VGAmodesH,AL
	MOV	b$VGAmodesL,AX
	MOV	AL,StdColor	; reset back to defaults:
	MOV	b$Adapter,AL	; CGA
	MOV	b$Monitor,AL	; StdColor monitor
	STC			; PSW.C indicates VGA not active
vga_exit:
cEnd







;*** 
;B$ChkMonitor - Make sure VGA set for mono or color appropriately
;
;Purpose:
;	This routine ensures that a VGA card is properly set up for whatever
;	Bios mode we are about to go into, monochrome or color.
;	Added with revision [49].
;	Rewritten with revision [64].
;	Note: this is unnecessary for PS/2 VGA and Olivetti VGA
;
;Entry:
;	[b$BiosMode] set to desired BIOS mode
;	B$Adapter & VgaMiscInfo initialized.
;
;Exit:
;	[b$CurEquip] updated.
;	VGA card set up for desired mode.
;
;Uses:
;	Per convention.
;
;Preserves:
;	ES.
;
;Exceptions:
;	None.
;
;******************************************************************************

cProc	B$ChkMonitor,<PUBLIC,NEAR>
cBegin
	CMP	[b$Adapter],VGA ; VGA? (not MCGA or Olivetti VGA)
	JNE 	EndOfChk	; no - nothing to do
	PUSH	ES		; preserve ES
	XOR	AX,AX		; ES = 0
	MOV	ES,AX
	MOV	AH,ES:[BiosEquip] ; read current BiosEquip
DbAssertTst	AX,NZ,2000h,RT_TEXT,<Unexpected BiosEquip flag in B$ChkMonitor>
	OR	AH,30h		; set equipment flag for MONO (default)
	MOV	AL,[b$BiosMode] ; check desired BIOS mode for 7 of F.
DbAssertRelB	AL,B,17h,RT_TEXT,<Advanced BIOS mode in B$ChkMonitor>
	AND	AL,7		
	SUB	AL,7		; Is it a monochrome mode?
	JZ     NeedMono		; brif & set Adapter to monochrome
	AND	AH,0EFh		; set equipment flag for Color80
	MOV	AL,1		; turn off summing if color monitor
NeedMono:
	MOV	[B$CurEquip],AH ; update [b$CurEquip]
	MOV	ES:[BiosEquip],AH ; update current BiosEquip
	POP	ES
	TEST	[VgaMiscInfo],4	; monochrome analog monitor?
	JNZ	EndOfChk	; brif so -- okay as is
	MOV	BL,33h		; turn gray-scale summing on/off
	SCNIOS	vAltSelect	
EndOfChk:

cEnd


;***
;B$GWTERM - OEM termination
;OEM-interface routine
;
;Purpose:
;	This routine is called once immediately before BASIC terminates.
;	It contains machine specific code to put the system into
;	a deterministic final state.  The final state should be as close
;	to the initial startup state as possible.
;
;	NOTE: All of the screen termination is done by a call to
;	      B$RESETSCN from a different part of the runtime.  This
;	      routine should not try to reset the screen in any way.
;
;Entry:
;	None
;
;Exit:
;	None
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;****

cProc	B$GWTERM,<PUBLIC,NEAR> 
cBegin

; All of the screen restoration code has been moved from here
; into B$CNTERM.


	IN	AL,MSKREG	; get IMR into [AL]
	OR	AL,01H		; mask out timer interrupt
	PAUSE			; make sure instruction fetch has occurred
	OUT	MSKREG,AL	; write mask to IMR

	CLI
	PUSH	DS
	XOR	AX,AX
	MOV	DS,AX
	ASSUME	DS:NOTHING
	RSTVEC	TMRCTL,DS:TICSAV ;restore clock interrupt
	POP	DS

	ASSUME	DS:DGROUP

	XFRINT	KYBINT,KBDVEC/4 ;move INT EFH to INT 09H

	PUSH	DS		;save seg register...
	RSTVEC	KBDVEC/4,b$KBDVEC_SAVE ;restore INT EF vector
	POP	DS		;restore seg register
	PUSH	DS		;save seg register...
	RSTVEC	CLKVEC/4,b$CLKVEC_SAVE ;restore INT F0 vector
	POP	DS		;restore seg register

	IN	AL,MSKREG	; get IMR into [AL]
	AND	AL,0FEH 	; unmask timer interrupt
	PAUSE			; make sure instruction fetch has occurred
	OUT	MSKREG,AL	; write mask to IMR
	STI

cEnd				


;***
;B$SEGINI - Initialize Variable for B$GETDS
;OEM-interface routine
;
;Purpose:
;	This routine stores the address of the runtime data segment.
;	The value is stored in the code segment so that it can be
;	retrieved later by a call to B$GETDS. These two routines
;	are used to save the data segment across a run, chain, or
;	shell command.	The runtime will call B$SEGINI before it
;	needs to call B$GETDS.
;
;	Note that it is possible that B$SEGINI is called multiple
;	times throughout the execution of a program.
;
;	This is a DOS 3 only routine.
;
;Entry:
;	DS = Final runtime data segment address
;
;Exit:
;	DS stored.
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX, FLAGS
;
;Exceptions:
;	none
;****

cProc	B$SEGINI,<PUBLIC,NEAR>	
cBegin
	MOV	[b$BASDSG],DS	  ;store addr of BASIC data segment
cEnd


;***
;B$GETDS - Get Data Segment for Runtime
;OEM-interface routine
;
;Purpose:
;	This routine is used to obtain the location of
;	the  BASIC data segment. The value is kept in the
;	basic code segment, where it is put by B$SEGINI.
;
;	See also B$SEGINI.
;
;Entry:
;	None.
;
;Exit:
;	[BX] = BASIC data segment
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, CX, DX, FLAGS
;
;Exceptions:
;	None
;****

cProc	B$GETDS,<PUBLIC,NEAR>	
cBegin				
	MOV	BX,[b$BASDSG]
cEnd				



sEnd	RT_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\lloga.asm ===
TITLE		LLOGA Olivetti CGA graphics mode support
;***
;LLOGA - Olivetti CGA graphics mode support
;
;	Copyright <C> 1988, Microsoft Corporation
;
;Purpose:
;	Support for Olivetti Color Graphics Adapter (OGA) graphics
;	screen mode (BIOS 40h).
;
;	This module sets hooks in the mode-independent
;	modules to routines here for mode-dependent
;	graphics support.  See the mode-independent
;	modules for more precise descriptions of the
;	purposes and interfaces of these routines.
;
;	The following table summarizes the information for
;	the modes and configurations covered:
;
;    C		  |	A			     B
;    O		  |  B	T			     I
;    L		  |  I	T		 P	     T
;    O	     A	M |  O	R		 A    C      S
;  S R	     D	O |  S	I    C		 G    H      / P
;  C B	     A	N |	B    O		 E    A   P  P L
;  R U	C  R P	I |  M	U    L	 X   Y	 S    R   A  I A
;  E R	O  O T	T |  O	T    O	 R   R	 I    B   G  X N
;  E S	L  W E	O |  D	E    R	 E   E	 Z    O   E  E E
;  N T	S  S R	R |  E	S    S	 S   S	 E    X   S  L S
; -- - -- -- - -- | -- --- ---- --- --- --- ---- --- - -
;  4 0 80 25 O	C | 40	2   16  640 400  32 8x16  1  1 1
;
;   This mode uses 32K starting at B8000h and is organized in four 8K banks.
;   It is identical to CGA 640x200 mode except that the bank is determined
;   by looking at the least-significant 2 bits of Y:
;   0  -   bank 0  at B8000    (same as CGA)
;   1  -   bank 1  at BA000    (same as CGA)
;   2  -   bank 2  at BC000
;   3  -   bank 3  at BE000
;   The formula to map Y to the correct line in each bank is:
;   BASE = B8000h + (Y AND 3) * 2000h
;   Y = Y AND NOT 3
;   ADDR = BASE + Y * 20
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_DATA
	USESEG	_BSS
	USESEG	GR_TEXT
	USESEG	XIB
	USESEG	XI
	USESEG	XIE

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE llgrp.inc	;Constant definitions
	INCLUDE idmac.inc
	INCLUDE grmac.inc	;ModeData macros

	INITIALIZER B$xINITOGA ;Put B$xINITOGA in initializer list

sBegin	_BSS
;
; ***************************************************************************
; External variables
; ***************************************************************************
;
externB b$Adapter
externB	b$MaxColor
externW b$UpSub
externW b$DnSub
externW b$UpDnAdd
externW b$ScreenTab
externW	b$InsCsrTyp	
externB b$ActPage
externW	b$pChkOlivetti
externW	b$pOgaCsr
sEnd	_BSS

assumes CS,GR_TEXT
sBegin	GR_TEXT

	staticW OGAALTTAB,22,1	;alternate master table
	staticD	,?,3
OGAALTCSR DD OGACSRTAB		; ptr to OGA cursor table
	staticB OGACSRTAB,0,8	;8x16 half cursor plus
	staticB ,255,24		; 8x16 solid cursor

externNP B$SCNIO		;used in SCNIOS macro

externNP B$GetParm
externNP B$MapXYC2_4		; shared with CGA code
externNP B$CgaSetPages		; shared with CGA code
externNP B$InitModeData
externNP B$ErrorReturn
externNP B$CgaSetAttr
externNP B$CgaLeftC1
externNP B$CgaChkUpC
externNP B$CgaUpC
externNP B$CgaChkDownC
externNP B$CgaDownC
externNP B$CgaReadC
externNP B$CgaSetC
externNP B$CgaSetPixC
externNP B$CgaSetPixFirstC
externNP B$CgaSetPixLastC
externNP B$CgaPutAction
externNP B$CgaNReadL
externNP B$CgaNWriteL
externNP B$CgaNSetC
externNP B$CgaSetTile
externNP B$CgaPaintBound
externNP B$CgaScanL
externNP B$CgaScanR
externNP B$CgaLineX
externNP B$CgaLineY
externNP B$CgaLineV
externNP b$Mode2Palette

;===========================================================================
mModeData	Mode4Data
;
; SCREEN 4, BIOS mode 40h
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	4
mBiosMode	40h
mBurst		0
mScrWidth	80
mScrHeight	25
mHorzRes	640
mVertRes	400
mVideoBase	0B800H
mMaxAttr	1
mMaxColor	15		
mPageSize	32			;page size in K
mCurrPSize	<(32*1024) shr 4>	;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	1
mBackColor	0
mEgaWrMd	0
mInitPalette	b$Mode2Palette
mInitVgaPal	b$Mode2VgaPal
mAlphaDim	AlphaDim4
mSetMode	SetMode4
mSetPages	B$CgaSetPages
mPalReset	B$ErrorReturn
mPalPut 	B$ErrorReturn
mPalTrans	B$ErrorReturn
mPalSet 	B$ErrorReturn
mSetColor	SetColor4
mForeMapped	1
mBitsPerPixel	1
mPlanes 	1
mMapXYC 	MapXYC4
mLeftC		B$CgaLeftC1
mChkUpC 	B$CgaChkUpC
mUpC		B$CgaUpC
mChkDownC	B$CgaChkDownC
mDownC		B$CgaDownC
mSetAttr	B$CgaSetAttr
mReadC		B$CgaReadC
mSetC		B$CgaSetC
mSetPixC	B$CgaSetPixC
mSetPixFirstC	B$CgaSetPixFirstC
mSetPixLastC	B$CgaSetPixLastC
mLineX		B$CgaLineX
mLineY		B$CgaLineY
mLineV		B$CgaLineV
mPutAction	B$CgaPutAction
mNReadL 	B$CgaNReadL
mNWriteL	B$CgaNWriteL
mNSetC		B$CgaNSetC
mPaintBound	B$CgaPaintBound
mSetTile	B$CgaSetTile
mScanL		B$CgaScanL
mScanR		B$CgaScanR
mEnd		GraphDataLen
;===========================================================================

labelNP <PUBLIC, B$OLIUSED>

;*** 
; B$Screen4
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 4.
;Entry:
;	AL = screen mode (4)
;	AH = burst (N/A)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen4,<PUBLIC,NEAR>
cBegin
	test	[b$Adapter],OGA	;check for adapter support
	stc
	jz	ScrExit 	;exit w/error if not supported
	mov	bx,GR_TEXTOFFSET Mode4Data  ;mode-specific data
	mov	cx,GraphDataLen
	call	B$InitModeData	;initialize table data
	mov	b$UpSub,8192	; Add 8K to move up one line
	mov	b$DnSub,24576-80 ; Add 24K and subtract line length to go down
	mov	b$UpDnAdd,8192+24576-80 ; Sum of the two offsets
	clc			;indicate no error
ScrExit:
cEnd

;***
; AlphaDim4
;
;Purpose:
;	Validate the proposed text dimensions for Screen 4.
;	  If 80x25 is requested, this mode satisfies the request
;	  else suggest screen mode 0.
;Entry:
;	BH = number of lines
;	BL = number of columns
;Exit:
;	AL = -1 if this mode satisfies the request, otherwise
;		AL is suggested screen mode to invoke for desired dimensions
;	PSW.C clear
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	AlphaDim4
cProc	AlphaDim4,<NEAR>
cBegin
	xor	al,al		;try Screen 0 if not 80x25
	cmp	bx,80+25*256	;80x25?
	jne	ADim4Exit	;brif not, try text mode
	dec	al		;al = -1 indicates dimensions are supported
ADim4Exit:
	clc			;no error
cEnd

;***
; SetMode4
;
;Purpose:
;	Set the screen mode according to the characteristics established
;	by previous call to B$Screenx and b$AlphaDim.
;Entry:
;
;Exit:
;
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	SetMode4
cProc	SetMode4,<NEAR>
cBegin
	mov	al,40h	;set BIOS mode 40h
	SCNIOS	vSetMode
cEnd

;*** 
;SetColor4 - Set the foreground color for Screen 4
;
;Purpose:
;	Process the COLOR statement for BIOS mode 40h.  Syntax is:
;
;	COLOR <foreground color>
;
;	where <foreground color> is from 0-15.
;
;Entry:
;	parameter list.
;
;Exit:
;	PSW.C set if error.
;
;Uses:
;	Per convention.
;
;******************************************************************************
cProc	SetColor4,<NEAR>
cBegin
	cCall	B$GetParm	; get the foreground color
	jz	SetColDone	; done if no parameters
	xor	bx,bx		; bh = 0 (used below)
	cmp	bx,cx		; make sure no more parameters
	jc	SetColDone	; brif illegal syntax
	cmp	[b$MaxColor],al ; make sure 0-15
	jc	SetColDone	; error if al > b$MaxColor
	mov	bl,al		; bh=0; bl = foreground color
	SCNIOS	vSetPalette
	clc			; indicate no error
SetColDone:
cEnd

;***
; MapXYC4
;
;Purpose:
;	May given X and Y coordinates to the graphics cursor for Screen 4.
;Entry:
;	CX = X coordinate
;	DX = Y coordinate
;Exit:
;	b$OffC, b$MaskC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	MapXYC4
cProc	MapXYC4,<NEAR>
cBegin

	mov	ax,3
	and	ax,dx
	xor	dx,ax		; AND DX, NOT 3
	ror	ax,1		;ax=8K multiple for quadrant displacement
	ror	ax,1
	shr	ax,1
	mov	bx,dx		;multiply y by 20 to compute row displacement
	shl	dx,1		;dx=2*Y
	shl	dx,1		;dx=4*Y
	add	dx,bx		;dx=5*Y
	jmp	B$MapXYC2_4	;use common code from Screen mode 2
cEnd	<nogen>

;*** 
;B$ChkOlivetti - Check if Olivetti 640x400 graphics mode is supported
;
;Purpose:
;	See if this is an Olivetti version of CGA, EGA, or VGA which supports
;	their 640x400 color graphics mode. 
;
;Entry:
;	Adapter = CGA or EGA or VGA
;
;Exit:
;	If mode is supported, PSW.Z = 0, AL = OGA.
;	If mode is not supported, PSW.Z = 1, AL = 0.
;
;Uses:
;	AX.
;
;Preserves:
;	DS.
;
;******************************************************************************
cProc	B$ChkOlivetti,<PUBLIC,NEAR>,<DS>
cBegin
	mov	ax,0FC00h	; BIOS ROM
	mov	ds,ax		; look for "OLIVETTI"
	cmp	word ptr DS:[50h],"LO" ; DS:50h  = "OL"?  (MASM reverses chars!)
	jne	NotOGA
	cmp	word ptr DS:[52h],"VI" ; DS:52h  = "IV"?
	jne	NotOGA

	mov	ah,0F0h		; This is an Olivetti machine
	mov	ds,ax		; DS = F000h -- SYSTEM ROM
	mov	ax,DS:[0FFFDh]	; DS:FFFDh -- Exclude M15 and M19 models:
	cmp	ax,0FF46h	; Is it M15?
	je	NotOGA		; brif - done
	cmp	ax,0FE00h	; Is it M19?
	je	NotOGA		; brif - done
	mov	ax,0C000h	; look for 2nd graphics card installed
	mov	ds,ax
	cmp	word ptr DS:[0],0AA55h ; DS:0 -- check for option ROM
	jne	GotOGA		; brif no option ROM -- just OGA

; See if option card supports the Olivetti mode
	cmp	word ptr DS:[3Ch],"AP" ; = "PA" ? -- check for PARADISE card
	je	GotOGA		; brif found - use OGA
	cmp	word ptr DS:[10h],"LO" ; DS:10h = "OL" -- Olivetti EGA/VGA card?
	jne	NotOGA		; brif a non-Olivetti card is installed
	mov	ax,DS:[22h]	; DS:22h -- make sure EGA or VGA
	cmp	ax,"GV"		; = "VG" -- Is if Olivetti VGA?
	je	GotOGA		; brif -- use OGA
	cmp	ax,"GE"		; = "EG" -- Is if Olivetti EGA?
	jne	NotOGA		; brif not -- non-Olivetti graphics card

; Olivetti EGA Card 2
	xor	ax,ax		; Must have OEC2 card -- check switches
	mov	ds,ax		
	mov	ax,DS:[488h]	; make sure OEC2 640x400 mode enabled
	and	ax,0A0h		; mask out irrelevent bits
	cmp	ax,0A0h		; If bits 7 and 5 are set, no 640x400 mode
	je	NotOGA		; brif mode not enabled

GotOGA:				; use OGA screen mode!
	mov	al,OGA-1
	inc	al		; al = OGA; PSW.Z = 0
	jmp	short RetValue
NotOGA:
	xor	al,al		; default return value
RetValue:
cEnd

;*** 
; OgaCsr -- Toggle a generated graphics mode text cursor (DOS 3 only)
;
;Purpose:
;	Mode-specific portion of GRPCSR from llscnio.asm.
;
;Entry:
;	AX = cursor type
;	CX = ES = 0
;
;Exit:
;	None
;Uses:
;	AX,BX,CX
;
;******************************************************************************

cProc	OgaCsr,<NEAR>		; version of GRPCSR for Olivetti graphics mode
cBegin
	mov	bx,cs
	xchg	bx,es:[486h]	; segment of alternate table
	push	bx		; save original master table pointer segment

	mov	bx,GR_TEXTOFFSET OGAALTTAB ; offset of alternate table
	xchg	bx,es:[484h]	; change master table pointer temporarily
	push	bx		; save original master table pointer offset

	CMP	AX,[b$InsCsrTyp] ; is it an insert cursor?
	MOV	AL,128		; Char code for Box
	JZ	OGACS1		; brif it is insert cursor
	INC	AL		; Map to 128 or 129..
OGACS1: 			; Half Box (128) If INS_MODE
				; Whole Box (129) for normal (NOT INS_MODE)
	MOV	BL,81H		; Select Invert (xor) Mode
				; bit 7 of [BL] = 1 for XOR mode and
				; low nibble =1, foreground attribute
	MOV	BH,[b$ActPage]	; Active Page
	INC	CX		; CX = 1 -- One Character
	SCNIOS	vWriteChar

	pop	word ptr es:[484h] ; restore original master table pointer
	pop	word ptr es:[486h]
cEnd

;***
; B$xINITOGA - initialize OGA 640 x 400 mode.
;
;Purpose:
;	Put the address of Olivetti screen mode support routine into the
;	dispatch table used by the screen statement.
;
;Entry:
;	None
;Exit:
;	ScreenTab updated
;Uses:
;	None
;Exceptions:
;******************************************************************************
cProc	B$xINITOGA,<FAR,PUBLIC>
cBegin
	MOV	WORD PTR [b$ScreenTab + (4*2) + 1],OFFSET B$Screen4
	MOV	[b$pChkOlivetti], GR_TEXTOFFSET B$ChkOlivetti
	MOV	[b$pOgaCsr], GR_TEXTOFFSET OgaCsr
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\lllpt.asm ===
TITLE   LLLPT - GW-BASIC Printer Interface
;***
; LLLPT - GW-BASIC Printer Interface
;
;       Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
        INCLUDE switch.inc
	INCLUDE rmacros.inc	

	useSeg	_DATA		
	useSeg	DV_TEXT 	

	INCLUDE seg.inc 	
        INCLUDE ibmunv.inc

sBegin	_DATA			

LPTNAM  DB      "LPT"           ;name for use in printer open
LPTNUM  DB      " ",0           ;number of printer to open (1 to 3)

sEnd	_DATA			


sBegin	DV_TEXT 		

externNP B$DOS3CHECK		; Check for dos 3

assumes CS,DV_TEXT		

;***
;B$OPNLPT - OPEN selected printer
;OEM-interface routine
;
;Purpose:
;	This routine will open a communications channel to a printer
;	and return a file handle to this channel and a status flag.
;
;	There are two ways to implement the three LPT routines
;	(B$OPNLPT, B$SNDLPT, and B$CLSLPT). They are based
;	on the fact that the file handle used by all three is
;	never checked or used outside of these routines.  The rest
;	of the runtime will just store it away and pass it back to
;	these routines.
;
;	1.) Direct output to a printer.  In this case, there would be
;	    no file handle, and the value passed can be ignored.
;	    B$OPNLPT would have no work to do, and could just return
;	    with AH=0.	B$CLSLPT would just return.  The disadvantage
;	    to this is that it will not work over networks or for
;	    redirected output.
;
;	2.) Use DOS file handles.  This is probably the most standard
;	    method as it allows for redirected printers and network
;	    printing.  In this case, B$OPNLPT would open the printer
;	    as a file, possibly do hardware checks for the existence
;	    of the printer if it is not redirected, and return the
;	    handle for use in other two routines.  B$SNDLPT would
;	    use the file for writing, and B$CLSLPT would close the
;	    file.
;
;	If the B$OPNLPT returns [AH] = 1, the runtime will signal
;	a Device Not Available Error.
;
;
;Entry:
;	[AH]  = printer number (0-2)
;
;Exit:
;	[BX]  = file handle
;	[AH]  = 0 if open successful, 1 if open failed.
;
;Uses:
;	Per convention
;
;Preserves:
;	CX,DX
;
;Exceptions:
;	None.
;******************************************************************************
cProc	B$OPNLPT,<NEAR,PUBLIC>,<DX,SI> 
cBegin				

        CMP     AH,2            ;test against upper limit
        JA      OPNLPT_UNAVAIL  ;if too high, then not available
        MOV     BL,AH           ;move index into register
        XOR     BH,BH           ;make it a 16-bit value
        SHL     BX,1            ;shift to make it a word index
        MOV     SI,BX           ;keep word index for later

        ADD     AH,"1"          ;map 0 to "1", 1 to "2", etc.
        MOV     LPTNUM,AH       ;put unit number in device name
        MOV     DX,OFFSET DGROUP:LPTNAM ;define name string to open
        MOV     AX,3D01H        ;ready to open file for writing
        INT     21H             ;open the file
        JC      OPNLPT_UNAVAIL  ;jump if device not available

        MOV     BX,AX           ;move handle
        MOV     AX,4400H        ;get device status
        INT     21H             ;perform the action
        TEST    DL,80H          ;test if character device
        JZ      OPNLPT_CLOSE    ;jump if error to close and exit

        MOV     AX,4401H        ;IOCTL to set device status
        OR      DL,20H          ;change to raw mode
        XOR     DH,DH           ;clear upper byte...
        INT     21H             ;set the mode

	cCall	B$DOS3CHECK	; See if DOS 3
        JB      OPNLPT_DOS2     ;jump if DOS2

        MOV     AX,440AH        ;get IOCTL call for redirection
        INT     21H             ;flag is in DH
        TEST    DH,80H          ;flag set if redirected
        JNZ     OPNLPT_SUCCESS  ;jump if redirected, done

OPNLPT_DOS2:
        PUSH    DS              ;save BASCOM data segment
        MOV     AX,40H          ;get BIOS data segment
        MOV     DS,AX           ;establish addressability
        TEST    DS:8[SI],0FFFFH ;test if adapter exists
        POP     DS              ;restore data segment
        JNZ     OPNLPT_SUCCESS  ;if so, success, jump

OPNLPT_CLOSE:
        MOV     AH,3EH          ;system code for closing
        INT     21H             ;close the file opened

OPNLPT_UNAVAIL:
        MOV     AH,1            ;error code for device unavailable
        XOR     BX,BX           ;clear BX for error condition
	JMP	SHORT OPNLPT_DONE ;jump to exit

OPNLPT_SUCCESS:
        XOR     AH,AH           ;clear error code for success
OPNLPT_DONE:

cEnd				

;***
;B$SNDLPT - Send a character to selected printer
;OEM-interface routine
;
;Purpose:
;	This routine takes a character and a file handle from
;	B$OPNLPT and sends the character to the printer specified
;	by the file handle.  If there are any errors, they are
;	returned in AH.
;
;	See the documentation for B$OPNLPT for more information.
;
;Entry:
;	[AL]  = character
;	[BX]  = file handle
;
;Exit:
;	[AH]  = 0: success
;		1: device not available
;		2: time out
;		3: out of paper
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;
;******************************************************************************
cProc	B$SNDLPT,<NEAR,PUBLIC>,<DX,CX> 
cBegin				
	PUSH	AX		; store byte in stack
	MOV	DX,SP		; [DS:DX] points to data to be output
	.ERRE	ID_SSEQDS	; assumes DS=SS
        MOV     CX,1            ;[CX] = # of bytes to be written
        MOV     AH,40H          ;read operation
        INT     21H             ;success reflected in carry
	POP	DX		; even stack
        JC      SNDLPT_UNAVAIL  ;jump if error on write
        XOR     AH,AH           ;return 0 in AH for no error
        JMP     SHORT SNDLPT_DONE ;jump to finish up
SNDLPT_UNAVAIL:
        MOV     AH,1            ;set error code
SNDLPT_DONE:

cEnd				

;***
; B$CLSLPT - Close selected printer
;OEM-interface routine
;
;Purpose:
;	This routine takes a file handle prepared by B$OPNLPT
;	for a line printer and closes the associated communications
;	channel.  All needed termination for the printer should be
;	done at this point.  All errors are ignored.
;
;	See the documentation for B$OPNLPT for more information.
;
;Entry:
;	[BX]  = file handle
;
;Exit:
;	None
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;******************************************************************************
cProc	B$CLSLPT,<NEAR,PUBLIC>,AX 
cBegin				

        MOV     AH,3EH          ;system code for closing
        INT     21H             ;close the file opened

cEnd				

sEnd	DV_TEXT 		

        END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llque.asm ===
TITLE	LLQUE - Queue Management
;***
; LLQUE - Queue Management
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

	INCLUDE switch.inc	;switch file [new]
	INCLUDE rmacros.inc	;useseg macro

	USESEG	RT_TEXT 	;core runtime segment
	USESEG	_DATA		

	INCLUDE seg.inc 	;segment definitions
	INCLUDE oscalls.inc	;Dos 5 structures
	INCLUDE ibmunv.inc
	INCLUDE intmac.inc
	INCLUDE idmac.inc	


	externFP	B$ULDataRelease ;dealloc UL data images
	externFP	CompressHelp	


	externFP	B$ERR_MEM	;arena destroyed error
	externNP	B$ERR_FHC	;bad memory block address

;***
;b$pFHLowerTop - vector for Memory Management
;OEM-interface routine
;
;Purpose:
;	Move the top of the Far Heap (Basic data not in DGROUP) down
;	if at all possible so that there is more memory available
;	for DOS allocation.  This is used to try to free enough space
;	for B$FHHighAlloc.  If the far heap cannot be move to free up
;	the amount of memory requested, it releases the maximum amount
;	of memory that it can.
;
;	NOTE: b$pFHLowerTop is a variable through which the routine
;	      is indirectly called.
;
;Entry:
;	AX = number of paragraphs of memory to release.
;
;Exit:
;	AX = number of paragraphs of memory actually released.
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	Fatal error due to far heap inconsistency.
;
;Indirection Information:
;	The indirection variable b$pFHLowerTop is allocated in the _DATA
;	segment by the OEM.  It should be statically initialized to a
;	RET statement.	Once set, the OEM should not modify this variable.
;	If a Far Heap exist, the OEM-Independent code will change the
;	variable so that it points to a routine which performs the
;	indicated function.
;
;****
sBegin	_DATA				
	globalW b$pFHLowerTop,Near_Ret,1 ;vector for FHLowerTop
sEnd	_DATA				






sBegin	RT_TEXT 		
	assumes CS,RT_TEXT	


;***
;B$INIQUE
;
;PURPOSE:
;	This routine initializes the top and bottom pointers
;	of the queue. It also initializes the number
;	of notes and the number of bytes in the queue to 0.
;
;ENTRY:
;	[BX] = addr of music queue ctrl block.
;	[AX] = addr of music queue
;
;EXIT:
;	None
;
;MODIFIED:
;	None
;
;****
cProc	B$INIQUE,<PUBLIC,NEAR>	
cBegin				
	MOV	[BX].QUEGET,AX	;reset pointers to
	MOV	[BX].QUEPUT,AX	;beginning of queue buffer
	MOV	[BX].QUENUM,0	;clear queue counter
	MOV	[BX].QUNOTE,0	;clear # of notes in queue
Near_Ret:			;Near return for vector
cEnd				; End of B$INIQUE

;***
;B$QUE
;
;PURPOSE:
;	This routine queues in a byte contained in [AL] into
;	the appropriate music control queue. Address of the music
;	control queue is contained in [BX].
;
;ENTRY:
;	[AL] = Byte to be queued
;	[BX] = Address of appropriate music queue
;	[ES] = either [DS] or $COMBUF
;
;EXIT:
;
;MODIFIED:
;	QUENUM, QUEPUT, QUEGET
;
;****
cProc	B$QUE,<PUBLIC,NEAR>,<SI> 
cBegin				
	MOV	SI,[BX].QUEPUT	;get put PTR
	MOV	ES:[SI],AL	;queue in the byte
	INC	SI		;advance put PTR
	CMP	SI,[BX].QUETOP	;wrap around ?
	JNZ	NWRQUE		;No
	MOV	SI,[BX].QUEBOT	;get queue bottom
NWRQUE:
	MOV	[BX].QUEPUT,SI	;store new put PTR
	INC	[BX].QUENUM
cEnd				; End of B$QUE

;***
;B$DQUE
;
;PURPOSE:
;	This routine supports GETSND by dequeueing one byte from
;	the music queue and updating the associated variables.
;
;ENTRY:
;	[BX] = Adrress of the music queue
;	[ES] = either [DS] or $COMBUF
;
;EXIT:
;	[AL] = dequeued byte
;
;MODIFIED:
;	QUENUM, QUEGET, QUEPUT
;
;****
cProc	B$DQUE,<PUBLIC,NEAR>,<SI>	
cBegin				
	MOV	SI,[BX].QUEGET	;fetch get PTR
	MOV	AL,ES:[SI]	;get the byte
	INC	SI
	CMP	SI,[BX].QUETOP	;wraparound?
	JNZ	NWRDQU		;Brif not
	MOV	SI,[BX].QUEBOT	;get queue bottom PTR
NWRDQU:
	MOV	[BX].QUEGET,SI	;store new get PTR
	DEC	[BX].QUENUM	;dec # of bytes in queue
cEnd				; End of B$DQUE



;
;	(Moved here from fhinit with revision [11].)
;
;***
;B$FHHighAlloc - Allocate a block of memory outside of BASIC's normal access
;OEM-Interface Routine
;
;Purpose:
;	Allocate a block of memory.  This is done by calling the
;	Operating System, thus the memory returned will not be
;	in DGROUP and will not be under the control of the rest
;	of BASICS memory management routines. The far and near
;	heaps may be moved down if necessary to make adequate room.
;
;	The size of the block of memory will be rounded up to the nearest
;	word for OS/2 and to the nearest paragraph for DOS 3.
;
;	Note that the memory will only be deallocated by an explicit call
;	to B$FHHighDealloc.
;
;Entry:
;	DX:AX = Size of block to allocate.
;
;Exit:
;	CX = segment of the memory block allocated or 0 if memory
;	     could not be allocated.
;	     The segment will be an SB (not a physical segment) if FV_SBPTR.
;Uses:
;	Per convention.
;
;Preserves:
;	AX, DX
;
;Exceptions:
;	None.
;******************************************************************************


cProc	B$FHHighAlloc,<NEAR,PUBLIC>,<AX,DX,SI>	
cBegin

;	Convert allocation size to paragraphs in DX:AX.

	ADD	AX,0FH		; Round up to nearest paragraph
	ADC	DL,0		
	MOV	CX,4		; Divide by 32 (shift right 4 times)
CvrtLoop:
	SHR	DX,1		
	RCR	AX,1		
	LOOP	CvrtLoop	
	OR	DX,DX		;test if allocation over 1 megabyte
	JNZ	FHHighError	;if so, then immediate error

;	Try to allocate block from any available memory first.

	MOV	SI,AX		;save paragraph size
	CALL	FHMemAllocCall	;call to perform INT and handle fatal errors
	JNC	FHHighDone	;if successful, use this block, jump

;	Lower the top of the far heap and try to allocate the block
;	using the released memory.  The call to FHLowerTop may not
;	release all the memory requested, but try the allocation
;	anyway in case enough is there.

	CALL	FHMemAllocCall_Lower  ; CY clear if memory allocated

	JNC	FHHighDone	;if successful, use allocated block

	CALL	B$ULDataRelease ;release UL data images (if present)
	CALL	FHMemAllocCall_Lower  ; CY clear if memory allocated
	JNC	FHHighDone	;if successful, use allocated block

	CALL	CompressHelp	;release UL data images (if present)
	CALL	FHMemAllocCall_Lower  ; CY clear if memory allocated

	JNC	FHHighDone	;if successful, return

FHHighError:
	XOR	AX,AX		;return 0 for error

FHHighDone:
	XCHG	CX,AX		;block starts at far pointer CX:0
cEnd

;
;	(Moved here from fhinit with revision [11].)
;
;***
; B$FHHighDealloc - deallocate high memory allocated with B$FHHighAlloc
;OEM-Interface Routine
;
;Purpose:
;	To deallocate a block of memory outside the runtime heap
;	management at the top of memory.  The block must have been
;	allocated by B$FHHighAlloc.  There is no check that the
;	segment was ever allocated or that multiple deallocations
;	on the same segment are being attempted.
;
;Entry:
;	AX = segment of block to be deallocated.
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;******************************************************************************


cProc	B$FHHighDealloc,<NEAR,PUBLIC>,<AX,ES>
cBegin

;	Deallocate the block through a DOS call.

	MOV	ES,AX		;put memory segment in for call
	MOV	AH,49H		;DOS function to deallocate a memory block
	CALL	FHMemDosCall	;call to perform INT and handle fatal errors

cEnd

;***
; FHZeroEntry - Zero fill a DOS 5 allocation (DOS 5)
;
;Purpose:
;	Fill a DOS 5 memory allocation with zeros.
;	(Moved here from fhinit with revision [11].)
;Entry:
;	DX:AX = 32 Bit size of block in bytes.
;	CX = segment of the memory block allocated.
;Exit:
;	None.
;Uses:
;	AX,CX,SI
;Exceptions:
;	None.
;******************************************************************************


; Added with [22] for size
;***
; FHMemAllocCall_Lower - perform memory allocation DOS call (DOS 3)
;
;Purpose:
;	Performs the INT21H for the DOS allocate call, after requesting the
;	far heap lower the top of memory.  Error checking is done here to
;	save space.
;
;Entry:
;	SI = # paragraphs of memory to allocate
;
;Exit:
;	Post-INT 21H register changes.
;
;Exceptions:
;	B$ERR_MEM if arena is trashed.
;	B$ERR_FHC if bad memory block address.
;****
cProc	FHMemAllocCall_Lower,<NEAR>
cBegin
	MOV	AX,SI		;AX = size of memory requested
	INC	AX		;add one for DOS memory header
	CALL	[b$pFHLowerTop] ;try to lower the top of the far heap
cEnd	<nogen> 		;Fall into FHMemAllocCall

; Added with [22] for size
;***
; FHMemAllocCall - perform memory allocation DOS call (DOS 3)
;
;Purpose:
;	Performs the INT21H for the DOS allocate call.	Error checking is
;	done here to save space.
;
;Entry:
;	SI = # paragraphs of memory to allocate
;
;Exit:
;	Post-INT 21H register changes.
;
;Exceptions:
;	B$ERR_MEM if arena is trashed.
;	B$ERR_FHC if bad memory block address.
;****
cProc	FHMemAllocCall,<NEAR>
cBegin
	MOV	BX,SI		;BX = size of memory request
	MOV	AH,48H		;DOS function to allocate memory block
cEnd	<nogen> 		;Fall into FHMemDosCall

;***
; FHMemDosCall - perform memory DOS call (DOS 3)
;
;Purpose:
;	Performs the INT 21H for the DOS allocate, deallocate, and
;	reallocate calls.  Error checking is done here to save space.
;	(Copied here from fhinit with revision [11].)
;Entry:
;	Setup for the appropriate DOS call, this call replaces the
;	INT 21H instruction.  The DOS calls used are allocate memory
;	(48H), deallocate memory (49H), and reallocate memory (4AH).
;Exit:
;	Post-INT 21H register changes.
;Uses:
;	Post-INT 21H register changes.
;Exceptions:
;	B$ERR_MEM if arena is trashed.
;	B$ERR_FHC if bad memory block address.
;******************************************************************************

cProc	FHMemDosCall,<NEAR>
cBegin

	INT	21H		;perform the DOS call
	JNC	FHMemDosReturn	;if successful, then exit now
	CMP	AX,8		;test if out of memory
	JNE	FHMemDosError	;if not, then jump to trap error
	STC			;set the carry again
FHMemDosReturn:

cEnd

FHMemDosError:
	CMP	AX,7		;test if error was arena destroyed
	JNE	FHMemDosBlock	;if not, then invalid block was used
	JMP	B$ERR_MEM	;jump to fatal error for arena destroyed
FHMemDosBlock:
	JMP	B$ERR_FHC	;jump to fatal error for inconsistenct FH

sEnd	RT_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llparam.asm ===
TITLE	LLPARAM - Parameters
;***
; LLPARAM.ASM - parameters
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

	INCLUDE switch.inc	;switch file [new]
	INCLUDE rmacros.inc	;useseg macro

	USESEG	RT_TEXT 	;core runtime segment
	USESEG	_BSS		
	USESEG	_DATA		

	INCLUDE seg.inc 	;segment definitions
	INCLUDE idmac.inc	;internal debug macros
	INCLUDE oscalls.inc	;Dos 5 structures


sBegin	_BSS			

	externB b$ScreenMode	
	externW b$HorzRes	
	externW b$VertRes	
	externW b$FBColors	
	externB b$BackColor	
	externB b$CharColor	
	externB b$BLDSP 	
	externB b$WHDSP 	

;***
;b$ComPort - Memory Address of COM ports
;OEM-interface routine (variable)
;
;Purpose:
;	This variable stores the memory locations of the two COM
;	ports.	It may actually be used for any purpose, as long
;	as the restrictions mentioned below are followed.
;
;Allocation:
;	b$ComPort is 2 consecutive WORDS allocated in the _BSS segment
;	by the OEM independent code.
;
;Values:
;	As defined by the operating system
;
;Initally Set:
;	Both words are statically initialized to 0.
;
;Modified by:
;	These values are only modified by the OEM-dependent code.
;
;Used by:
;	The OEM-Independent code uses these values to determine if a
;	COM port needs to be initialized after a SHELL command.  At the
;	time of the shell, it copies both words to a safe location and
;	if a word is non-zero the corresponding COM port is disabled by
;	a call to B$TRMCOM.  After the SHELL returns, all the COM ports
;	that were disabled are re-enabled with calls to B$INICOM.
;****
	globalW b$ComPort,,2	;communications port addresses
	staticW BUF,,1		;Two byte buffer for B$STDGET and B$STDPUT

sEnd	_BSS			

sBegin	RT_TEXT 		
	assumes CS,RT_TEXT	



;***
;B$STDGET - Get a character from STDIN
;OEM-interface routine
;
;Purpose:
;	Gets a character from the Operating System's standard input.
;	This routine is used to read a character from an input that
;	might have been redirected.
;
;	The existence of this routine allows the OEM to do pre-
;	processing of characters.  If this feature is not needed,
;	the routine will just ask the Operating System for a character.
;	Under DOS, this would be function 3FH of interrupt 21H.  Under
;	OS/2, this function DOSREAD will perform the action.
;
;	For system that support double byte charters, this routine should
;	return a double byte character as a single character, not as two
;	separate bytes as in previous versions.
;
;Entry:
;	None
;
;Exit:
;	[AX] = character
;	PSW.Z set indicates no character was available
;	PSW.C set if the character is two bytes
;	PSW.C reset if the character is only one byte ([AH] ignored)
;Uses:
;	Per convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****
cProc	B$STDGET,<PUBLIC,NEAR>,<BX,CX,DX> 
cBegin
	XOR	BX,BX		;file handle in BX
	MOV	CX,1		;no. of bytes in CX
	MOV	DX,OFFSET DGROUP:BUF ;offset of BUF in DX
	MOV	AH,3FH		;Function 3FH and
	INT	21H		;INT 21H
	OR	AX,AX		;is AX = 0?
	JE	STDRET		;Brif so PSW.Z is set (error)
	MOV	AL,BYTE PTR BUF ;move byte into AL
STDRET:

cEnd



;***
;B$STDPUT - Write a character to STDOUT
;OEM-interface routine
;
;Purpose:
;	Writes a character to the Operating System's standard output.
;	This routine is used to write a character to an output that
;	might have been redirected.
;
;	The existence of this routine allows the OEM to do pre-
;	processing of characters.  If this feature is not needed,
;	the routine will just send the character to the Operating
;	System.
;
;Entry:
;	[AX] = character
;	PSW.C set indicates a two byte character
;
;Exit:
;	None
;
;Uses:
;	Per convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None
;****

cProc	B$STDPUT,<PUBLIC,NEAR>,<BX,CX,DX> 
cBegin					   
	MOV	BX,1		;BX contains the file handle
	MOV	CX,1		;CX contains the no. of bytes
	MOV	BYTE PTR BUF,AL ;move the byte into BUF
	JNC	ONEBYT		;if no carry then write one byte
	INC	CX		;else it is two bytes
	XCHG	AL,AH		; set proper byte order
	MOV	BUF,AX		;move the byte into AX
ONEBYT:
	MOV	DX,OFFSET DGROUP:BUF ;DS:DX contains address of the data
	MOV	AH,40H		;Function 40H and
	INT	21H		;INT 21H
PUTRET:
cEnd

;
;	Rewritten with [7].
;
;***
;B$GrScreenSize - Get size of Graphics Screen in Pixels
;OEM-interface routine
;
;Purpose:
;	This routine returns the pixel dimensions of the current graphics
;	screen.  The dimension are returned in 0-relative form as the
;	number of pixels per line and the number of pixel lines per
;	screen page.
;
;Entry:
;	none
;
;Exit:
;	[CX] = the number of pixels per pixel (0-relative)
;	[DX] = the number of pixel lines per screen page (0-relative)
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX
;
;Exceptions:
;	none
;****

cProc	B$GrScreenSize,<PUBLIC,NEAR>
cBegin
	mov	cx,b$HorzRes
	dec	cx		    ;make 0-relative
	mov	dx,b$VertRes
	dec	dx		    ;make 0-relative
cEnd
;
;	Rewritten with [7].
;
;***
;B$GRMODE - Check for a graphics mode
;OEM-interface routine
;
;Purpose:
;	This routine returns the current screen mode. PSW.Z will
;	be set if the screen is in text only mode. PSW.Z will be
;	cleared if the screen is in a graphics mode. This routine
;	is called whenever a graphics routine is to be executed to
;	make sure that graphics are allowed in the current screen
;	mode.
;
;	To disable all graphics statements with a Function Call
;	Error, always return with PSW.Z set.
;
;Entry:
;	None.
;
;Exit:
;	PSW.Z set if in text only screen mode
;	PSW.Z cleared if in a graphics screen mode
;
;Uses:
;	Per convention
;
;Preserves:
;	All registers
;
;Exceptions:
;	None.
;****

cProc	B$GRMODE,<PUBLIC,NEAR>
cBegin
	cmp	b$ScreenMode,0
cEnd

;***
;B$GETFBC - Get foreground and background attributes
;OEM-interface routine
;
;Purpose:
;	The routine B$GETFBC retrieves the current foreground and
;	background attributes of the screen.  It supports graphics
;	and function key display capability.  The attributes are in
;	external format (single byte integer corresponding to the
;	documented color encoding) and are returned in the low byte
;	of the register.
;
;	On entry, the Carry flag determines whether the color attributes
;	will be for text or for graphics.  In most systems, these will
;	be the same.
;
;Entry:
;	PSW.C = set implies graphics attribute request
;	PSW.C = reset implies text attribute request
;
;Exit:
;	AX = foreground attribute
;	BX = background attribute
;
;Uses:
;	Per convention
;
;Preserves:
;	CX, DX
;
;Exceptions:
;	None.
;****
;NOTE:	the current version of this routine will not distinguish
;	between text or graphics requests
;
cProc	B$GETFBC,<PUBLIC,NEAR> 
cBegin
	mov	ax,b$FBColors	;al=fore, ah=background color
	xor	bx,bx		;HOBytes 0 after xchg
	xchg	bl,ah		;bx=background
cEnd

;***
;B$SETFBC - Set foreground and background colors
;OEM-interface routine
;
;Purpose:
;	The routine B$SETFBC sets the current foreground and
;	background attributes for effecting reverse video
;	on the function key display line.   The attributes are in
;	external format (single byte integer corresponding to the
;	documented color encoding) and are passed in the low byte
;	of the register.
;
;	On entry, the Carry flag determines whether the color attributes
;	will be for text or for graphics.  In most systems, these will
;	be the same.
;
;	Since the attributes from B$GETFBC are not saved across a
;	statement boundary, the attributes passed to B$SETFBC should
;	be valid with respect to the current configuration.
;
;Entry:
;	[AX] = foreground attribute
;	[BX] = background attribute
;	PSW.C = set implies graphics attribute request
;	PSW.C = reset implies text attribute request
;
;Exit:
;	none
;
;Uses:
;	Per Convention
;
;Preserves
;	All registers
;
;Exceptions:
;	none
;****

cProc	B$SETFBC,<PUBLIC,NEAR>,<CX> 
cBegin
	JB	SETRET		;br. if graphics
	MOV	CL,b$CharColor	;get current attributes
	CMP	b$BackColor,0	;is background black?
	JA	CLRTBG		;br. if not
	XCHG	CL,b$BLDSP	;swap reverse video for black and current attributes
	JMP	SHORT SetExit	;finished swap for black background, return.
CLRTBG:
	XCHG	CL,b$WHDSP	;swap reverse video for color bg and current attributes
SetExit:
	MOV	b$CharColor,CL	;store reverse attributes as current attributes
SETRET:
cEnd

sEnd	RT_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llscnfcn.asm ===
TITLE	LLSCNFCN - Low Level Screen Function Support
;***
; LLSCNFCN - Low Level Screen Function Support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module has the following low level routines:
;	1. B$SWIDTH .... screen width support
;	2. B$SCREEN .... screen FUNCTION support
;	3. B$SETCLR .... color statement support
;	4. B$CSTATR .... Cursor support for LOCATE statement
;
;*****************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	USESEG	_DATA
	USESEG	_BSS
	USESEG	CN_TEXT
	USESEG	RT_TEXT

	INCLUDE seg.inc
	INCLUDE oscalls.inc
	INCLUDE idmac.inc
	INCLUDE ibmunv.inc
	INCLUDE intmac.inc
	INCLUDE llgrp.inc

sBegin	_BSS

	globalW b$OldScrnBurst,,1	;old Screen Mode and burst
	staticW OldDim,,1		;old screen dimensions

	externB b$ScreenMode
	externB b$Burst
	externB b$ActPage
	externB b$ScrWidth
	externB b$ScrHeight
	externW	b$FBColors		; defined in llcgrp.asm
	externB	b$ForeColor		; defined in llcgrp.asm
	externB	b$NullColor		; defined in llcgrp.asm
	externB	b$CharColor		; defined in llcscn.asm
	externB	b$BorderColor		; border color (overscan)
	externW b$SetMode
	externW b$AlphaDim
	externW b$SetPages
	externW b$SetColor
	externW	b$SetAttr		

sEnd	_BSS


sBegin	_DATA

	externW b$CURSOR
	externW b$CSRTYP
	externB b$UsrCsrOn	; Is the cursor being displayed?
	externB b$UsrCsrStart	; user-defined cursor start line
	externB b$UsrCsrStop	; user-defined cursor stop line
	externB b$InsCsrStop	; insert cursor stop line

sEnd	_DATA



sBegin	RT_TEXT
	externNP B$FixTextPage	
	externNP B$ChkMonitor	; set VGA mono/color monitor

sEnd	RT_TEXT


sBegin	CN_TEXT
	assumes CS,CN_TEXT

	externNP B$SCNCLR
	externNP B$CSRDSP	;Display cursor
	externNP B$OFFCSR	;Turn off cursor
	externNP B$SCINIT
	externNP B$SCNSWI
	externNP B$ScreenN	;Initialize screen mode AL

;***
; B$SWIDTH - support for WIDTH statement
;OEM-interface routine
;
;Purpose:
;	This routine supports the width statement by attempting to set
;	the screen dimensions to those specified.  This routine is called
;	only if a change in the number of lines or columns is needed.
;
;	If the parameters are legal, the following must occur:
;	1.) Set hardware to reflect new conditions.
;	2.) Update OEM state variables.
;	3.) Call B$SCNSWI to inform runtime of dimension changes.
;	4.) Call B$SCNCLR to initialize screen, viewport, and cursor.
;	5.) Clear the screen (OS/2 only) (Call B$CLRSCN with a parameter of 0)
;
;	NOTE: If delayed screen initialization is being supported,
;	      B$SCNINIT must be called before any changes are made.
;
;Entry:
;	AL = prospective number of columns
;	CL = prospective number of lines
;
;Exit:
;	PSW.C = set to indicate error
;	PSW.C = reset to indicate update completed
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;****

cProc	B$SWIDTH,<PUBLIC,NEAR>
cBegin
	CALL	B$SCINIT	;init screen if not already done
	mov	dl,b$ScrWidth	;get old width and height
	mov	dh,b$ScrHeight
	mov	OldDim,dx	;save for later restorations
	mov	bh,b$Burst	;get burst
	mov	bl,b$ScreenMode    ;get screen mode
	mov	b$OldScrnBurst,bx ;save old values for later
	xchg	bl,al		;bl=columns
	xchg	bh,cl		;bh=lines
	cmp	bl,dl		;width change?
	jne	DimChg		;go if so
	cmp	bh,dh		;height change?
	je	WidthExit	;go if not
DimChg:
	push	bx		;save dimensions
	call	[b$AlphaDim]	;change to new dimensions
	pop	cx
	jc	WidthError	;go if errors
	cmp	al,-1		;width satisfied
	je	WidthMode	;go setup mode if so
	;this mode suggested trying another for these dimensions
	mov	ah,b$Burst	;setup burst for B$ScreenN
	cmp	al,b$ScreenMode ;going to a different mode?
	je	NoBstChg	;leave burst alone if not
	xor	ah,ah		;clear burst
	cmp	al,ah		;going to mode 0?
	jne	NoBstChg	;go if not, with burst = 0 for modes > 0
	inc	ah		;burst = 1 for mode 0
NoBstChg:			
	call	C_ScreenN	; try that one (save colors)
	jc	WidthError	;go if error

	xchg	bx,cx		;width/height to BX
	cmp	bh,b$ScrHeight ;different height?
	jne	DimChg		;go if so
	cmp	bl,b$ScrWidth	;diferent width?
	jne	DimChg		;go if so

WidthMode:
	call	B$ChkMonitor	; Set VGA monitor type before setting mode
	call	[b$SetMode]	;set the actual mode
	mov	al,b$ScrWidth
	mov	cl,b$ScrHeight
	cCALL	B$SCNSWI	;Inform Hi-Level about dimensions change
	CALL	B$SCNCLR	; initialize the screen (homes cursor, etc.)
	call	B$FixTextPage	
	xor	ax,ax		;clear both pages
	call	[b$SetPages]	;set current page data
	clc			;no error
	JMP	SHORT WidthExit

WidthError:
	mov	cx,OldDim	; restore old screen mode data
	mov	ax,b$OldScrnBurst
	call	C_ScreenN	; reset mode-dependent data (save colors)
	xchg	bx,cx		; width/height to BX
	call	[b$AlphaDim]	; reset text dimensions
	call	B$FixTextPage	
	STC			; return with error
WidthExit:
cEnd

;*** 
;C_ScreenN - Save colors and call B$ScreenN
;
;Purpose:
;	Preserve Colors over call to B$Screen.  Can only be used if
;	the actual screen mode is not changing.  (just dimensions)
;
;Entry:
;	AX = Screen mode and burst
;	CX = Screen Dimensions
;
;Exit:
;	PSW.C set indicates error in B$ScreenN.
;
;Uses:
;	Per convention.
;
;Preserves:
;	CX.
;
;******************************************************************************
cProc	C_ScreenN,<NEAR>,<CX> ; entire routine
cBegin
	MOV	BH,[b$BorderColor] ; save colors
	MOV	BL,[b$NullColor]
	MOV	DL,[b$CharColor]
	PUSH	[b$FBColors]
	CALL	B$ScreenN	; AX = mode & burst (preserves AX,BX,CX,DX)
	POP	[b$FBColors]	; restore colors
	MOV	[b$CharColor],DL
	MOV	[b$NullColor],BL
	MOV	[b$BorderColor],BH
	MOV	AL,[b$ForeColor]
	PUSHF			; save PSW.C
	CALL	[b$SetAttr]	; ignore error return
	POPF			; restore error status from B$ScreenN
cEnd

;***
;B$SCREEN - SCREEN function support
;OEM-interface routine
;
;Purpose:
;	This routine provides OEM dependent support for the SCREEN function
;	by returning the character and its encoded attributes at a specified
;	position on the screen.	For the IBM-PC the attributes are encoded
;	as follows:
;
;		1. bits 0-3 contain the foreground color of the character
;		2. bits 4-6 contain the background color of the character
;		3. bit 7 contains the blinking attribute
;
;	The value returned for the encoded attributes should conform
;	to your machine's standard, as this is the value that is passed
;	back to the user.  The coordinates are guaranteed to be legal
;	for the current screen mode.
;
;	For systems with a hardware character generator, this routine
;	can act directly upon the CRT RAM.  Systems that have software
;	character generation and that do not have two byte characters
;	may have a separate buffer or may reverse translate the
;	characters from the video RAM.	For systems that have software
;	character generation and support two byte character codes, a
;	separate buffer or some other data structure must be maintained
;	so that two byte characters can be read from the "screen".
;
;	If the current screen mode support double byte characters,
;	it is possible that this routine will ask for the value
;	of either half of the character.
;
;	For FL_JAPAN, B$SCREEN should return the value of the entire
;	character (as defined for B$SCROUT). The OEM Independent code
;	will negate the MS-Continuous code for the character if it is
;	the second half of a double byte character.  All other
;	OEMs should return for a character code the value that
;	they want the SCREEN() function to return to the user.	No
;	further mapping or manipulation will be done for it.
;
;	NOTE: If you are supporting delayed screen initialization,
;	      B$SCNINIT has to be called before any attempt to read
;	      from the screen.
;
;Entry:
;	DH = requested column position (1-relative)
;	DL = requested row position (1-relative)
;
;Exit:
;	AX = character			(as defined for B$SCROUT)
;	BX = encoded attributes		(Hi-byte = 0)
;	PSW.C = set if we tried to read the middle of a double byte
;		character
;	PSW.C = reset in all other cases
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;****
;ALGORITHM:
;
;	save current cursor type
;	move cursor to requested position
;	read character &attributes at that position
;	replace cursor to original position and type
;

cProc	B$SCREEN,<PUBLIC,NEAR>,<SI>
cBegin

	CALL	B$SCINIT	;init screen if not already done

	MOV	CX,b$CSRTYP	; save current cursor type in CX
	CALL	B$OFFCSR	; position invisible cursor at (DH,DL)
	MOV	BH,b$ActPage	; get active display page

	SCNIO	vReadChar	;read encoded attributes at current csr position

	OR	AL,AL		; vReadChar returns NULL in graphics modes
	JNZ	NOT_NULL	;  if no char is present in char cell
	MOV	AL,' '		; so we must compensate here
NOT_NULL:			
	XOR	BX,BX		; zero BX
	XCHG	AH,BL		; BX = Attribute
	XCHG	AX,CX		; AX = b$CSRTYP (Old)
				; CX = Character
	MOV	DX,b$CURSOR	; get original cursor position
	CALL	B$CSRDSP	; restore original cursor position and type

	XOR	CH,CH		; Set Hi Byte zero
	XCHG	AX,CX		; AX = Character


cEnd


;***
;B$SETCLR - COLOR statement support
;OEM-interface routine
;
;Purpose:
;	This routine provides support for the COLOR statement.
;	The parameters to this function are implementation and
;	screen mode dependent.	For all machines, the first
;	parameter is the ForeGround Color and the second parameter
;	is the Border Color.  If it is desired to indicate an
;	error from this routine (such as wrong number of parameters,
;	parameter out of range, etc), return with PSW.C set.
;
;	If delayed screen initialization is being supported,
;	the routine B$SCNINT must be called before any
;	changes are made.
;
;Entry:
;	[SI] = address of the high end of the parameter list
;	       (parameters run from high to low memory).
;	[CX] = count of words in parameter list
;
;	This list is in the format for B$GetParm to parse.
;
;Exit:
;	PSW.C = set indicates that an error was encountered
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;****
;	Since the meaning and number of parameters for the COLOR
;	statement is dependent on the screen mode, this routine
;	just calls the mode-dependent routine and hands off the
;	parameters entirely.
;

cProc	B$SETCLR,<PUBLIC,NEAR>
cBegin
	CALL	B$SCINIT	; init screen if not already done
	call	[b$SetColor]	; call mode-dependent module
cEnd

;***
;B$CSRATR - Set cursor attribute
;OEM-interface routine
;
;Purpose:
;	This routine handles a request to set the cursor attribute of
;	the user cursor.  There are three cursor attribute bytes.  They
;	correspond to parameters three, four, and five of the LOCATE
;	statement.
;
;	These parameters are:
;
;	  3.  cursor - is a value indicating whether the cursor is
;		       visible or not. 0 (zero) for off, 1 (one) for
;		       on.
;	  4.  start  - is the cursor starting scan line. Must be in
;		       the range [0,31].
;	  5.  stop   - is the cursor stop scan line.  Must be in the
;		       range [0,31].
;
;	B$SCRATR must check the start and stop values to make sure that
;	they are in the range [0,31].  If they are not in that range,
;	return with PSW.C set to indicate an error.  If these values are
;	legal, but will produce unusual results when the cursor is set
;	to them (i.e. the cursor is invisible or split), the cursor
;	should be updated anyway.  After all, the user asked for it.
;	Note that changing the stop line of the user cursor will also
;	change the stop line of the insert cursor to the same value.
;
;Entry:
;	[AH] - LOCATE parameter 3 existence flag
;		(0 iff the user specified no value)
;	[AL] - LOCATE parameter 3 value
;	[BH] - LOCATE parameter 4 existence flag
;	       (0 iff the user specified no value)
;	[BL] - LOCATE parameter 4 value
;	[CH] - LOCATE parameter 5 existence flag
;	       (0 iff the user specified no value)
;	[CL] - LOCATE parameter 5 value
;
;Exit:
;	PSW.C - set indicates a cursor attribute parameter error
;
;Uses:
;	Per convention
;
;Exceptions:
;	None.
;****
;Algorithm:
;	if param 3 exists then
;	  if in valid range then store cursor toggle
;	    else error
;	if param 4 exists then
;	    if in valid range then
;		update user cursor start line
;		if param 5 exists then
;		    if in valid range then
;			update user cursor stop line
;			update insert cursor stop line
;		      else error
;		  else
;		    update user cursor stop line := user cursor start line
;		    update insert cursor stop line := user cursor start line
;	   else
;	     if param 5 exists then error
;Modified:
;	b$InsCsrTyp - insert mode cursor attributes possibly changed
;	b$UsrCsrTyp - user mode cursor attributes possibly changed
;
;#**

cProc	B$CSRATR,<PUBLIC,NEAR>
cBegin

	OR	AH,AH		;see if value is given for cursor toggle
	JZ	CSR4TH		;br. if no value is given
	CMP	AL,1		;check valid range [0,1]
	JA	CATRER		;br. if out of range error
	MOV	B$UsrCsrOn,AL	;store cursor toggle
CSR4TH:
	OR	BH,BH		;see if value is given for cursor start line
	JZ	CSR5TH		;br. if no value is given
	CMP	BL,31D		;check valid range [0,31]
	JA	CATRER		;br. if out of range error
	MOV	b$UsrCsrStart,BL ;store startline for user cursor

	OR	CH,CH		;see if value is given for cursor stop line
	JZ	NO5VAL		;br. if no value is given
	CMP	CL,31D		;check valid range [0,31]
	JA	CATRER		;br. if out of range error
	MOV	b$InsCsrStop,CL ; store insert cursor stop line
	MOV	b$UsrCsrStop,CL ; store user cursor stop line
	JMP	SHORT CSRDON	; valid return
NO5VAL:
	MOV	b$InsCsrStop,BL ;default insert csr stop line = stop line
	MOV	b$UsrCsrStop,BL ;default user csr stop line = stop line
CSR5TH: 			;no value was given for cursor start line
	OR	CH,CH		;see if value was given for cursor stop line
	JNZ	CATRER		;error if stop value given without start value
CSRDON:
	CLC			;clear flag for valid return
	RET
CATRER:
	STC			;set flag for parameter error
cEnd

sEnd	CN_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llkeys.asm ===
TITLE	LLKEYS - Keyboard support and mapping routines
;***
; LLKEYS.ASM - keyboard support and mapping routines
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

	INCLUDE switch.inc	;switch file [new]
	INCLUDE rmacros.inc	;useseg macro

	USESEG	RT_TEXT 	;core runtime segment
	USESEG	_DATA		
	USESEG	CONST		
	USESEG	_BSS		

	INCLUDE seg.inc 	;segment definitions
	INCLUDE idmac.inc	;internal debug macros
	INCLUDE oscalls.inc	;Dos 5 structures
	INCLUDE ibmunv.inc
	INCLUDE intmac.inc
	INCLUDE const.inc	

	SUBTTL	local constant definitions
	page

	HidScn1		= 0E0H	; hidden scan code for 101-key keyboard
	HidScn2		= 0F0H	; hidden scan code for 101-key keyboard

	CharSlash	= 2FH	; character code for keypad /
	CharEnter	= 0DH	; character code for keypad Enter
	CharCTRLEnter	= 0AH	; character code for CTRL keypad Enter

	ScanSlash	= 35H	; scan code for keypad /
	ScanEnter	= 1CH	; scan code for keypad Enter



	SUBTTL	data definitions
	page			


sBegin	CONST			

PAGE

;List of Microsoft Key codes and their significance (all key codes 
;are in Hex)
;
;KeyCode(Hex)			Remarks
;________________________________________________________________________
;
;00		Null (but printable if a font exists)
;
;01-0C		Printable 1-byte characters
;
;0D		Carriage Return
;
;0E-0F		Printable 1-byte characters
;
;20-7E		ASCII characters
;
;7F		DELETE character
;
;80		First byte of 2-byte character set
;		Softkey implementation
;  8000-801F	**Unimplemented**
;  8020-803F	Function Keys (mapped by INPUT routines)
;  8040		**Unimplemented**
;  8041-805A	Super-shift Keys
;  805B-807E	**Unimplemented**
;  8080		printable character 80 (if a font exists)
;			Font is 1 byte only
;  8081-80FC	**Unimplemented**
;
;81-9F		First byte of 2-byte character set
;  40-FC		Second byte of 2-byte character set (7F is illegal)
;
;A0-DF		Printable 1-byte character set
;
;E0-FC		First byte of 2-byte character set
;  40-FC		Second byte of 2-byte character set (7F is illegal)
;
;FE		First byte of 3-byte character set
;  0000-FFFF	Second and third bytes of a 3-byte character
;		mapped to 1- or 2- byte character by INPUT routines
;
;FF		First byte of 2-byte character set
;  00-0F	Editor control characters (as input keys)
;  10		Editor control key ( as input key)
;		Printable character FE, if font exists (as print code)
;			Font is 1 byte only
;  FF11-FFFE	Editor control characters (as input keys)
;  FFFF 	Editor control key ( as input key)
;		Printable character FF, (font is space) as print code
;			Font is 1 byte only
;
;Note:
;	**Unimplemented** key codes are also valid but currently they have no
;	assigned function.
;
PAGE

FKPARM	LABEL	WORD
FKCCNT	DB	6		;# of chars/function key to display
FKDCNT	DB	10D		;# of function keys to display
FKNUM	DB	1		;# of first function key to display

sEnd	CONST			

sBegin	_BSS			

	externB	b$RcoFlg	; flag for 101-key keyboard

	externB b$ScrWidth
	externB b$BiosMode


sEnd	_BSS			

PAGE

sBegin	RT_TEXT 		
	assumes CS,RT_TEXT	



; Moved FAR with revision [18].
;	Let function-key mapping table have entries for 0-13 & 28,29,30, & 31

FKYMAP_TABLE	LABEL	BYTE	; Mapped to

	DB	0		; Null (no mapping)
	DB	1		; No special mapping
	DB	2		; No special mapping
	DB	3		; No special mapping
	DB	4		; No special mapping
	DB	5		; No special mapping
	DB	6		; No special mapping
	DB	14		; music bar character
	DB	254		; Small square block char
	DB	26		; Right arrow (->)
	DB	27		; Left arrow (<-)
	DB	127		; House char
	DB	22		; Lower-half block char
	DB	27		; Left arrow (<-)
	DB	16		; Right wedge char
	DB	17		; Lefht wedge char
	DB	24		; Up arrow char
	DB	25		; Down arrow char
;	B$PRTMAP uses this table to determine 1- or 2-byte code
;	The table entry's MSB is set (=1) if it is a 2-byte code
;	else it is cleared (value < 128)
;	This table contains translation bytes for ascii 0-31

PRTMAP_TABLE	LABEL	BYTE	; Mapping done is as follows:

	DB	0D		; No special mapping
	DB	1D		; No special mapping
	DB	2D		; No special mapping
	DB	3D		; No special mapping
	DB	4D		; No special mapping
	DB	5D		; No special mapping
	DB	6D		; No special mapping
	DB	080H+07H	; Backspace
	DB	8D		; No special mapping
	DB	080H+09H	; TAB
	DB	080H+0AH	; LineFeed
	DB	080H+0BH	; Home cursor 
	DB	080H+0CH	; Clear scroll window
	DB	080H+0DH	; Carriage Return
	DB	14D		; No special mapping
	DB	15D		; No special mapping
	DB	16D		; No special mapping
	DB	17D		; No special mapping
	DB	18D		; No special mapping
	DB	19D		; No special mapping
	DB	20D		; No special mapping
	DB	21D		; No special mapping
	DB	22D		; No special mapping
	DB	23D		; No special mapping
	DB	24D		; No special mapping
	DB	25D		; No special mapping
	DB	26D		; No special mapping
	DB	27D		; No special mapping
	DB	080H+1CH	; Cursor Right
	DB	080H+1DH	; Cursor Left
	DB	080H+1EH	; Cursor Up
	DB	080H+1FH	; Cursor Down

PAGE

;	B$EDTMAP uses a table to determine 1- or 2-byte code
;	The table entry's MSB is set (=1) if it is a 2-byte code
;	else it is cleared (value < 128)
;	This table contains translation bytes for ascii 0-31
	
EDTMAP_TABLE	LABEL	BYTE	

	DB	080H+10H	
	DB	0001H		
	DB	080H+02H	
	DB	080H+03H	
	DB	0004H		
	DB	080H+05H	
	DB	080H+06H	
	DB	080H+07H	
	DB	080H+08H	
	DB	080H+09H	
	DB	080H+0AH	
	DB	080H+0BH	
	DB	080H+0CH	
	DB	080H+0DH	
	DB	080H+0EH	
	DB	000FH		
	DB	0010H		
	DB	0011H		
	DB	080H+12H	
	DB	0013H		
	DB	080H+14H	
	DB	080H+15H	
	DB	0016H		
	DB	0017H		
	DB	0018H		
	DB	0019H		
	DB	001AH		
	DB	080H+15H	
	DB	080H+1CH	
	DB	080H+1DH	
	DB	080H+1EH	
	DB	080H+1FH	

PAGE

;KEYCODE TABLE FORMAT : <raw-code>,<new-AL>	;<new-AH>
;
;	Remarks on the KEYINP_TABLE table arrangement
;
;	Currently, the arrangement is as follows:
; <raw-code>	 = All sorts of values found (i.e. cannot make any assumptions)
; <new-AL  >	0 - 1F	20 - 7E	7F	80	FE	FF
; <new-AH  >	  FF	  80	FF	80	Scan	FF
; Byte-category	  2	  1	2	2	3	2
;
;It can be seen, that by arranging the table in such a fashion that <new-AL>
; is ordered so that the returned <new-AH> would be 80,FF,Scan
; we eliminate the need to store <new-AH> in the table. Of course, this would
; need some comparisons once a match has been found in this table but the
; overall search is improved with the expected (or by design) reduction in
; code size.
;
;	In the following table the third entry is commented out
;	The original table is ordered as suggested above
;	The intervening labels identify various <new-AH> types
;	Within each type, the table is ordered by <new-AL> (ascending)
;	To assist the search better (less code), the table has been organized
;	in this order
;	<new-AL>, <scan>	;<new-AH>


KEYINP_TABLE	LABEL	WORD		; Word access

;	<new-AL>, <scan>	;<new-AH>

	DB	032D,059D	;128D	;function keys 1
	DB	033D,060D	;128D	;    2
	DB	034D,061D	;128D	;    3
	DB	035D,062D	;128D	;    4
	DB	036D,063D	;128D	;    5
	DB	037D,064D	;128D	;    6
	DB	038D,065D	;128D	;    7
	DB	039D,066D	;128D	;    8
	DB	040D,067D	;128D	;    9
	DB	041D,068D	;128D	;   10
	DB	042D,133D	;128D	; F11
	DB	043D,134D	;128D	; F12
	DB	044D,135D	;128D	; Shift-F11
	DB	045D,136D	;128D	; Shift-F12
	DB	046D,137D	;128D	; Ctrl-F11
	DB	047D,138D	;128D	; Ctrl-F12
	DB	048D,139D	;128D	; Alt-F11
	DB	049D,140D	;128D	; Alt-F12
	DB	065D,030D	;128D	;super shift A
	DB	066D,048D	;128D	;    B
	DB	067D,046D	;128D	;    C
	DB	068D,032D	;128D	;    D
	DB	069D,018D	;128D	;    E
	DB	070D,033D	;128D	;    F
	DB	071D,034D	;128D	;    G
	DB	072D,035D	;128D	;    H
	DB	073D,023D	;128D	;    I
	DB	074D,036D	;128D	;    J
	DB	075D,037D	;128D	;    K
	DB	076D,038D	;128D	;    L
	DB	077D,050D	;128D	;    M
	DB	078D,049D	;128D	;    N
	DB	079D,024D	;128D	;    O
	DB	080D,025D	;128D	;    P
	DB	081D,016D	;128D	;    Q
	DB	082D,019D	;128D	;    R
	DB	083D,031D	;128D	;    S
	DB	084D,020D	;128D	;    T
	DB	085D,022D	;128D	;    U
	DB	086D,047D	;128D	;    V
	DB	087D,017D	;128D	;    W
	DB	088D,045D	;128D	;    X
	DB	089D,021D	;128D	;    Y
	DB	090D,044D	;128D	;    Z
	DB	128D,253D	;128D	;special M.S. code uses 128D
KEY_128	EQU	THIS WORD + 2		; 2-Byte and <new-AH> = 80H
					; Note that '+2' is used because
					; LODSW increments SI by 2 and
					; 'jump below' condition is used
KEY_128_LEN	EQU	(KEY_128 - KEYINP_TABLE)/2 ; No. of entries for 128

KEY_255_START	LABEL	WORD		; From here it is '255' code
	DB	002D,115D	;255D	;previous word
	DB	005D,117D	;255D	;erase --> EOLN
	DB	006D,116D	;255D	;next word
	DB	011D,071D	;255D	;home cursor
	DB	012D,119D	;255D	;clear screen and home cursor
	DB	014D,079D	;255D	;--> EOLN
	DB	016D,254D	;255D	;special since M.S. code uses 254D
	DB	018D,082D	;255D	;toggle insert mode
	DB	026D,118D	;255D	;clear to end of window
	DB	028D,077D	;255D	;right cursor
	DB	029D,075D	;255D	;left cursor
	DB	030D,072D	;255D	;up cursor
	DB	031D,080D	;255D	;down cursor
	DB	127D,083D	;255D	;delete char under cursor
	DB	255D,255D	;255D	;special since M.S. code uses 255D
KEY_255	EQU	THIS WORD + 2		; end of '255' codes
					; Note that '+2' is used because
					; LODSW increments SI by 2 and
					; 'jump below' condition is used
KEY_255_LEN	EQU	(KEY_255-KEY_255_START)/2 ; No. of entries for 255

	DB	254D,003D	;003D	;unimplemented
	DB	254D,015D	;015D	;	"
	DB	254D,073D	;073D	;	"
	DB	254D,081D	;081D	;	"
	DB	254D,114D	;114D	;	"
	DB	254D,120D	;120D	;	"
	DB	254D,121D	;121D	;	"
	DB	254D,122D	;122D	;	"
	DB	254D,123D	;123D	;	"
	DB	254D,124D	;124D	;	"
	DB	254D,125D	;125D	;	"
	DB	254D,126D	;126D	;	"
	DB	254D,127D	;127D	;	"
	DB	254D,128D	;128D	;	"
	DB	254D,129D	;129D	;	"
	DB	254D,130D	;130D	;	"
	DB	254D,131D	;131D	;	"
	DB	254D,132D	;132D	;	"
	DB	000D,000D	;000D	;end of table specifier
KEYINP_TABLE_END	LABEL	WORD

PAGE

;***
;B$FKYFMT - return format of Function Key display line
;OEM-interface routine
;
;Purpose:
;	This routine supports the function key display line feature by
;	providing the function key display format.  The format is made
;	up of three parts as follows:
;
;		FKCCNT - 1 byte count of the number of bytes
;			 to be displayed for each function key
;			 description.
;		FKDCNT - 1 byte count of the number of function
;			 keys to be displayed.
;		FKNUM  - 1 byte number of the first key to be
;			 displayed.
;
;	The format must be in the preceding order since the address
;	of the format descriptor is what will be returned.  The
;	current screen width must be sufficient to display this format.
;
;	The function key line is displayed as FKDCNT iterations of
;	a single digit key number, FKCCNT characters from the function
;	key expansion table, and a space.  Thus, there will be FKDCNT
;	fields of size (1+FKCCNT+1).  If two digits are necessary to
;	display the function key number, then FKCCNT-1 function key
;	characters are displayed.  If there are fewer than FKDCNT+
;	FKNUM-1 keys to display, then the display will wrap around to
;	the first function key, like thus:
;
;	     8 xxx 9 xxx 10 xx 1 xxx 2 xxx
;
;	for FKCCNT = 3, FKDCNT = 5, FKNUM = 8
;
;	If you are supporting double byte characters, take note that this
;	routine takes the number of bytes of the function key name, not
;	the number of characters.  When it is printed, if the last
;	character would be the first of a two byte sequence, a space
;	will be used instead.
;
;Entry:
;	none
;
;Exit:
;	[BX] = address of format descriptor
;		->	FKCCNT
;			FKDCNT
;			FKNUM
;
;Uses:
;	Per Convention.
;
;Preserves:
;	DX
;
;Modifies:
;	None.
;*****
;ALGORITHM:
;
;	If the width = 40 then count = 5 else (width = 80), count = 10
;	Hence it can just divide by 8 to achieve the result
;

;	Actually this routine need only to return the format descriptor address
;	as the number of function keys can be set by B$SCRSTT when the mode
;	changes. It is assumed, of course, that the user would not want to
;	change the number of softkeys displayed without changing the screen
;	dimension. In this case, the first 4 lines of code can be removed.

cProc	B$FKYFMT,<PUBLIC,NEAR>	
cBegin				

	MOV	BX,OFFSET DGROUP:FKPARM ;get address of format descriptor
	MOV	AL,b$ScrWidth	; Get the current screen width
	MOV	CL,3		; Setup to divide by 8
	SHR	AL,CL		; AL = 5/10
	MOV	FKDCNT,AL	; Store it in the structure

cEnd				; End of FKYFMT

;***
;B$FKYMAP - map character to printable form for Function Key display
;OEM-interface routine
;
;Purpose:
;	This routine is is called to map characters for the function
;	key display. This routine allows certain key codes to be replaced
;	by a different key code.  For example, CHR$(13) might be mapped
;	to the character '<'.
;
;	This mapping should be done for any character that is unprintable
;	or that would cause Screen Editor functions to be performed.  Note
;	that this routine must always return a legal key code, which should
;	be a printable graphic character.  No further mapping of the
;	character will take place before it is printed.
;
;Entry:
;	[AX] = character
;	PSW.C set indicates a two byte character
;
;Exit:
;	[AX] = character
;	PSW.C set indicates a two byte character
;
;Uses:
;	Per convention
;
;Preserves:
;	CX, DX
;
;Exceptions:
;	None.
;****
;	ALGORITHM:
;	If the input character is two-byte then return as it is
;	else
;		if input range is 0-13 or 28-31 (inclusive ranges)
;		then map it using FKYMAP_TABLE
;		else return input character itself

cProc	B$FKYMAP,<PUBLIC,NEAR>	
cBegin				

	JC	FKYRET		; If char = 2-byte then exit
	CMP	AL,31		; Is character in control range?
	JA	FKYRET		; NO, can be printed as is
	CMP	AL,13		; Below 14, use the mapper
	JBE	FKY_XLAT	; Brif need to translate
	CMP	AL,28		; Is 13 < char < 28?
	JB	FKY_RET1	; Brif no mapping
	SUB	AL,(28-14)	; Bring it in range for mapping

FKY_XLAT:			
	CBW			; AL < 31 ; Therefore AH = 0
	XCHG	AX,BX		; BX need to be saved
	MOV	BL,CS:FKYMAP_TABLE[BX]	; Get the substitute char
	XCHG	AX,BX		; Restore back BX

FKY_RET1:			; Clear carry to indicate 1-byte
	CLC			
FKYRET:				; Exit...

cEnd				; End of FKYMAP



;***
;B$KEYINP - input key from keyboard
;OEM-interface routine
;
;Purpose:
;	This routine gets a key from the keyboard and translates it
;	to a code from the Microsoft Standard Keyboard code set.
;	This routine will wait until a character is ready if PSW.Z
;	is set, else it will return immediately with a flag if there
;	was no available character.
;
;	The host keyboard support may return a multiple code sequence
;	for a given key depression rather than a single code.  This
;	routine must collect these codes and return a single Microsoft
;	Standard Keyboard code.
;
;	A goal in key mapping is to allow special keys (such as
;	<backspace>) to cause the same action as a key in the control
;	code range (such as ^H).  Yet it is still desirable to return
;	unique key codes to the user for the INKEY$ function.  This
;	is accomplished by having multiple mapping routines.
;
;	This is one of many different routines that map characters from
;	a machine specific form to and from the MicroSoft Key Codes.
;	These codes are used within BASIC for all functions, and are
;	only translated only on input, for INPUT$, and for INKEY$.
;	This is the only routine which will get characters from the
;	hardware, so it is the only one that has to map from the
;	machine specific format to the MicroSoft format.  The following
;	routines are used to map from MicroSoft format to a different
;	format for printing or for presenting to the user:
;
;		B$EDTMAP - map a character during Screen Editing
;		B$FKYMAP - map a character for the Function Key display
;		B$INFMAP - map a character for INPUT$
;		B$INKMAP - map a character for INKEY$
;		B$PRTMAP - map a character for printing
;
;	See the documentation with each function for the specifics of
;	the particular mapping.  Note that all characters that are sent
;	to OEM functions for displaying, printing, device I/O, etc are
;	Microsoft Key Codes.
;
;	Note that all characters that are presented to the user go
;	through mapping twice.	First they go through B$KEYINP to
;	convert them to Microsoft Standard Key Codes, then through
;	either B$INFMAP, B$INKMAP, or B$EDTMAP before being
;	presented to the user.
;
;Interim Character Support Considerations:
;
;	All entry and exit conditions are unchanged except for two-byte
;	characters (PSW.C set).  Not, the value of DX determines
;	whether the character is interim or final.  If DX is 0, the
;	character in AX is treated as an interim character.
;
;
;MicroSoft Key Codes:
;
;	KeyCode(Hex)		       Remarks
;	_______________________________________________________________
;
;	00	       Null (but printable if a font exists)
;	01-0C	       Printable 1-byte characters
;	0D	       Carriage Return
;	0E-0F	       Printable 1-byte characters
;	20-7E	       ASCII characters
;	7F	       DELETE character
;
;	80	       First byte of 2-byte character set
;	    00-1F      Unimplemented
;	    20-3F      Function Keys (mapped by INPUT routines)
;	    40	       Unimplemented
;	    41-5A      Super-shift Keys
;	    5B-7E      Unimplemented
;	    80	       printable character 80 (if a font exists)
;	    81-FC      Unimplemented
;
;	81-9F	       First byte of 2-byte character set
;	    40-FC      Second byte of 2-byte character set (7F is illegal)
;
;	A0-DF	       Printable 1-byte character set
;
;	E0-FC	       First byte of 2-byte character set
;	    40-FC      Second byte of 2-byte character set (7F is illegal)
;
;	FE	       First byte of 3-byte character set
;	    0000-FFFF  Second and third bytes of a 3-byte character
;		       mapped to 1- or 2- byte character by INPUT routines
;
;	FF	       First byte of 2-byte character set (Editor Control)
;	    00-0F      Editor control characters (as input keys)
;	    10	       Editor control key ( as input key)
;		       Printable character FE (as print code)
;	    11-FE      Editor control characters (as input keys)
;	    FF	       Editor control key ( as input key)
;		       Printable character FF, (font is space) as print code
;
;	Note:
;	    Unimplemented key codes are also valid but currently they have no
;	    assigned function.
;
;
;Entry:
;	PSW.Z  set if B$KEYINP may wait for a key
;
;Exit:
;	[AX] = Microsoft Standard Keyboard code
;	[DX] = bytes 2 and 3 of three byte codes
;	     = 0 to signal a non-interim character (when PSW.C set)
;	     = 1 to signal a interim character (when PSW.C set)
;	PSW.C = set indicates a 2 byte character
;	PSW.C = reset indicates a 1 or 3 byte character code
;	PSW.Z = set if no keys have been typed
;		(the code is in AL in the 1 byte case, AX in the 2 byte
;		 case, and AL and DX in the 3 byte case)
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX
;
;Exceptions:
;	None.
;****
;	For this implementation all control range codes and printable
;	characters will be passed through as one byte keycodes except
;	for the special codes 128D, 254D, and 255D (&H 80, FE, FF)
;	which will be mapped as 2-byte codes.  The IBM extended
;	character set will be mapped as two or three byte codes
;	in the Microsoft Standard Keyboard code set.
;
;ALGORITHM:
;	if PSW.Z is set then
;	    wait for a character to be typed
;	    if IBM 2-byte char then
;		if char is control-break then make it MS control break
;		  else
;		    if char is shifted function key then
;			make it M.S. three byte code
;		      else
;			map to M.S. code
;	      else
;		if char is 128D or 254D or 255D then map to M.S. code
;	else
;	     set PSW.Z and return
;#****

cProc	B$KEYINP,<PUBLIC,NEAR>,<SI,BX>	
cBegin				
GET_A_KEY:
	PUSHF			;save flags


	KYBIO	kPollKeyBoard	;loop while character

	JNZ	CHECK_KEY	; Key is available
NO_KEY:				
	POPF			; Get back flags
	JZ	GET_A_KEY	; Wait until a key is available
	XOR	AH,AH		; Indicate no key is available
	JMP	SHORT KEY_RET	; & Exit...

CHECK_KEY:			; Process the key


	KYBIO	kReadKeyBoard	;get key from buffer


	MOV	SI,RT_TEXTOFFSET KEYINP_TABLE; Get scancode table
	CLD			; Set for autoincrement
	OR	AL,AL		;is it a two byte code?
	JNZ	Chk_One_Byte	; br. if not
	OR	AH,AH		; Check for BREAK key
	JNZ	Supershift_check	; Brif may be supershift key
	OR	AX,0FF03H	; Set BREAK key code
	STC			; ZF = 0 ; CF = 1 (2-BYTE CODE)
	JMP	SHORT KEY_EXIT	; & Exit...

Chk_One_Byte:
	TEST	b$RcoFlg,0FFH	; is ronco installed ?
	JZ	Single_Byte	; Brif not
	CMP	AL,HidScn1	; is hidden char code ?
	JE	SuperShift	; Brif yes
	CMP	AL,HidScn2	; is hidden char code ?
	JE	SuperShift	; Brif yes

;	     CMP     AH,HidScn1      ; KEYPAD / & ENTER need special care
;	     JNE     Single_Byte     ; Brif not, this is a normal character

;	The following comparisons are done only for the RONCO KBD. Still it
;	has to be ascertained as to why these are done as they seem to serve
;	no purpose (judged by the existing code)


;	     CMP     AL,CharSlash    ; is Keypad / ?
;	     MOV     AH,ScanSlash    ; make it normal
;	     JE      Single_Byte     ; Brif yes
;	     CMP     AL,CharEnter    ; is Keypad enter ?
;	     MOV     AH,ScanEnter    ; make it normal
;	     JE      Single_Byte     ; Brif yes
;	     CMP     AL,CharCTRLEnter; is keypad CTRL enter ?
;	JMP	SHORT Single_Byte ; Brif not, a normal character

Single_Byte:
				; If al = 253 then return 3-byt code
	MOV	AH,0		; Assume 1-byte
	CMP	AL,253D 	;is it special char?
	JE	KEY_EXIT	; br. if so - Exit
	JA	KEY_MAP		; Map it to 3-byte code
	CMP	AL,128D 	;is it special char?
	JNE	KEY_EXIT2	; br. if 1-byte char : ZF = CF = 0
	MOV	AL,253D		; Scan code for ALT-128
	JMP	SHORT KEY_MAP	; Map to 8080H

SuperShift:			
	XOR	AL,AL		; make it normal

SuperShift_Check:		
	XCHG	AL,AH		; Copy scan code
				; AH = 0

	CMP	AL,84D		;lower bound of shifted fctn. key?
	JB	KEY_MAP		;br. if below
	CMP	AL,114D 	; upper bound of shifted fctn. key?
	JB	KEY_3_BYTE	; indicate 3-byte M.S. code

KEY_MAP:
	XCHG	AX,BX		; BL = Scan code of key
				; BH = 0 at this point always
KEY_LOOP:
	LODS	KEYINP_TABLE	; [AH] = next <raw-code> entry in table
	TEST	AX,AX		; test for last table entry
	JZ	NO_KEY		; End of table - try again
	CMP	AH,BL		; look for match on scan code
	JNE	KEY_LOOP	; loop back if not found

KEY_FOUND:
	MOV	AH,80H		; Assume AH will have 80H
	CMP	SI,RT_TEXTOFFSET KEY_128; Is it two-byte code?
	JB	KEY_EXIT	; Exit 2-byte code CF = 1 already
	MOV	AH,255D		
	CMP	SI,RT_TEXTOFFSET KEY_255; Is it 2-byte with AH=0FFH
	JB	KEY_EXIT	; Set AH = 0FFH and return

	XCHG	AX,BX		; Get scan code in AL
				; AH = 0
KEY_3_BYTE:			; It is a 3-byte code
				; When control comes here, AH = 0 always
	MOV	DX,0FEH		; 254 indicates 3-byte code
	XCHG	AX,DX		; DL is the keycode and AH = 0

KEY_EXIT2:			; Set ZF & CF to zero
	SAHF			; CF = ZF = 0 at this point

KEY_EXIT:			
	POP	BX		; Discard the flags on stack

KEY_RET:			; Generic Exit...

cEnd				; End of B$KEYINP


;***
;B$CTRLMAP
;
;PURPOSE:
;
; B$CTRLMAP will map the character in AL according to the table
; pointed to by BX. However, if the input character = 0FFFFH, then 
; the returned character will be requested to be ignored in Graphics
; modes 4,5, & 6.
;
;ENTRY:
;	[BX]	= Character-Translation-Table-Address
;	[AX]	= Character to be translated
;
;EXIT:
;	[AX]	= Translated code 
;	PSW.C	= Set to indicate 2-byte char
;	PSW.Z	= Set to indicate ignore the char
;
;MODIFIED:
;	NONE
;
;****

cProc	B$CTRLMAP,<NEAR>	; Map if it is a control character
cBegin				

	CMP	AL,255D		; See if FFh
	JNE	MAP_IT		; Brif it is not 0FFFFH
				; Now if the char is 0FFFFh, do not
				; allow this in Graphics modes
	MOV	AH,b$BiosMode	; Get BIOS mode value
	CMP	AH,4		; If 3 < AH < 6 then graphics
	JB	MAP255		; Brif Text
	CMP	AH,7		; Check for upper limit
	CMC			; CF = 0 if Graphics
MAP255:				; Set AH accordingly
	SBB	AH,AH		; AH = 0/-1
	JMP	SHORT MAP_RET	; That's it.

MAP_IT:
	CMP	AL,31		; Is 0 <= AL < 32
	JA	MAP_RET		; Brif not a control char

MAP_XLAT:			; Translate control char
	XLAT	PRTMAP_TABLE	; Do it now
	CBW			; AH = -1 if 2-byte char
	AND	AL,07FH		; Knock off MSB
				; AH  is either 0 or 0FFH
	CMP	AH,80H		; This sets CF if AH = 0
				; but ZF = 0 always
	CMC			; Reverse the sense of CF for reporting

MAP_RET:

cEnd				; End of B$CTRLMAP

;***
;B$PRTMAP - Map a character into a form for printing
;OEM-interface routine
;
;Purpose:
;	This routine is called to translate character codes from the
;	Microsoft Standard Keyboard code set to either:
;
;	1. another code from the Microsoft Standard Keyboard set for
;	   printing.
;	2. a function code from the Microsoft Standard Keyboard set.
;	3. a request to ignore the character (it has no printable form)
;
;	B$PRTMAP is called as a result of a requests to print characters.
;	This routine must filter out all characters which are non-printable.
;	If a printable character code is returned, then it must not
;	cause any BIOS/VIO functions to be executed when it is sent to
;	either the screen or a device.	These codes must either be ignored
;	or mapped to a Microsoft Standard Keyboard Function code.  Examples
;	of characters that have to be mapped are Function Keys and many
;	of the control characters.
;
;	This routine may return the code for any character, allowing
;	characters to be moved around in the character set. For more
;	information on character mapping, see the documentation for the
;	function B$KEYINP.
;
;	Note:  If you want to use PRINT for escape sequences, B$PRTMAP
;	must not map the ESC character &H3F to &HFF3F.
;
;Entry:
;	[AX] = Microsoft Standard Keyboard code (1 or 2 byte only)
;	PSW.C = set indicates a 2-byte char
;
;Exit:
;	[AX] = code to be printed or function to be executed
;	PSW.Z = set indicates to ignore the current char - AX don't care
;	PSW.Z = reset indicates to process the char
;	PSW.C = set indicates a two byte character
;	PSW.C = reset indicates a one byte character ([AH] = 0)
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****
;ALGORITHM:
;	if 2-byte char then
;	    if char is supershift or soft key then ignore
;	      else process char
;	  else
;	    if char is 255D then
;		if mode is graphics then ignore char
;		  else process as 2-byte 255D,255D
;	      else
;		if control char then map (1 or 2 bytes)
;		process char
;	NOTE:	If ZF = 1 (ignore char) then AX is undefined. Currently, the
;		callers (REDMAP, $SCREEN_OUT in IOTTY.ASM)
;		ignore AX under this condition.


cProc	B$PRTMAP,<PUBLIC,NEAR>	
cBegin				

	JNC	PRT_1_BYTE	; Process 1-byte code

PRT_2_BYTE:			; Process 2-byte chars
	CMP	AH,255D		; See if ctl char
	JE	PRT_1_BYTE	; Nope--1-byte char
	CMP	AH,80H		; If so, then it is a 1-byte char
	JE	PRT_EXIT	; Brif true. CF = 0
	STC			; Indicate 2-byte char
	JMP	SHORT PRT_EXIT	
				; CF = 0 implies 2-byte code
PRT_1_BYTE:			; Check for control char range

	PUSH	BX		; Save BX
	MOV	BX,RT_TEXTOFFSET PRTMAP_TABLE	; Translation table
	cCALL	B$CTRLMAP	; Map the control char
	POP	BX		; Restore BX
PRT_EXIT:			; Generic exit...

cEnd				; End of B$PRTMAP


;***
;B$EDTMAP - map a character into a form for displaying
;OEM-interface routine
;
;Purpose:
;	This routine is called to translate character codes from the
;	Microsoft Standard Keyboard code set to either:
;	1. another code from the MIcrosoft Standard Keyboard set.
;	2. a function code from the Microsoft Standard Keyboard set.
;	3. a request to ignore the character.
;
;	B$EDTMAP is called as a result of Screen editor requests to echo
;	characters.  It may be noted that Screen Editor screen control
;	functions will be active only if this routine exits with the
;	screen control function in AX, PSW.Z reset, and PSW.C set (indicating
;	to process the associated editor function).
;
;	This routine allows the OEM to map characters to Screen Editor
;	functions and to change character codes.  Screen Editor functions
;	are performed when the associated control characters are printed.
;	These control codes must be mapped to the appropriate function code
;	by this routine.  For example, if a carriage return should be
;	mapped to FF0D (Carriage Return Function).  Any character that
;	is printable is printed without any further mapping.
;
;Entry:
;	[AX] = Microsoft Standard Keyboard code (1 or 2 byte only)
;	PSW.C = set indicates a 2-byte char
;
;Exit:
;	[AX] = code to be printed or function to be executed
;	PSW.Z = set indicates to ignore the current char - AX is don't care
;	PSW.Z = reset indicates to process the char
;	PSW.C = set indicates  a 2-byte char
;	PSW.C = reset indicates a single byte char in AL
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	none
;****


cProc	B$EDTMAP,<PUBLIC,NEAR>		
cBegin					

;	The processing of edit mappint is almost identical to that of
;	print map except that the lookup table is different. Hence setup
;	BX to point to EDTMAP_TABLE and use B$PRTMAP control-char processing
;	code.

	JNC	EDT_1_BYTE		; CF =0 means it is 1-byte char
					; check graphics context also
EDT_2_BYTE:				; If special (AX = 0FFFFH) then
	CMP	AX,-1			
	JNE	EDT_EXIT		; Brif not exit

EDT_1_BYTE:				; 1-Byte or 2-byte 0FFFFH char
	PUSH	BX			; Save BX, B$PRTMAP will unsave it
	MOV	BX,RT_TEXTOFFSET EDTMAP_TABLE; Lookup table address
	cCALL	B$CTRLMAP		; Process 1-byte chars
	POP	BX			; Restore BX

EDT_EXIT:				; Generic exit...

cEnd					; End of B$EDTMAP


;***
;B$INFMAP - map character for INPUT$
;OEM-interface routine
;
;Purpose:
;	This routine is called to translate character codes from the
;	Microsoft Standard Keyboard set to an OEM specific key code set.
;	B$INFMAP is called during the processing of the INPUT$ function,
;	when the characters are coming from the keyboard.
;	Since there may be differences in the code values returned
;	by the INPUT$ and INKEY$ functions, two separate support
;	routines are required for these functions.  Codes returned
;	by B$INFMAP may be one or two byte codes.
;
;	The way that a string for INPUT$ from KYBD: is created
;	is by asking for characters from B$KEYINP, passing them
;	to B$INFMAP, and storing the results in the string.
;
;Entry:
;	[AX] = Microsoft Standard Keyboard code
;	[DX] = bytes 2 and 3 of three byte codes
;	PSW.C = set indicates a 2 byte character
;	PSW.C = reset indicates a 1 or 3 byte character code
;		(the code is in AL in the 1 byte case, AX in the 2 byte
;		 case, and AL and DX in the 3 byte case)
;
;Exit:
;	[AX] = OEM code to be returned by INPUT$
;	PSW.C = set indicates a 2 byte character
;	PSW.C = reset indicates a 1 byte character code in AL
;	PSW.Z = set indicates that there is no OEM code to  associate
;		with the Microsoft Code - AX is don't care
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$INFMAP,<PUBLIC,NEAR>
cBegin					

	JC	INF_2_CHK		; If CF = 1 then it is 2-byte
	CMP	AL,254			; Check if 3-byte char
	JNE	INF_EXIT		; Br if not a 3-byte char

; Return zero for 3-byte character codes. The following comparisons will
; ALL FAIL and hence the return code will be zero in AX

INF_2_CHK:				; Process 1-byte chars
	CMP	AX,-1			; If AX is special 2-byte
	JE	INF_EXIT		; Then treat it as 1-byte only
	CMP	AX,8080H		; Is it special 80H?
	JE	INF_EXIT		; Brif so
	CMP	AX,0FF10H		; Is it special 0FEH?
	MOV	AL,254			
	JE	INF_EXIT		; Br if true

INF_RET0:
	XOR	AX,AX			; Return ignore char AX = 0

INF_EXIT:				; Reset ZF & CF and exit
	OR	SP,SP			
					; Exit.
cEnd					; End of B$INFMAP


;***
;B$INKMAP - map character for INKEY$
;OEM-interface routine
;
;Purpose:
;	This routine is called to translate character codes from the
;	Microsoft Standard Keyboard set to an OEM specific key code set.
;	B$INKMAP is called during the processing of the INKEY$ function.
;	Since there are differences in IBM BASIC for the code values
;	returned by the INPUT$ and INKEY$ functions, two separate
;	support routines are required for these functions.  One or
;	two byte values will be returned from this code for the
;	INKEY$ function.
;
;Entry:
;	[AX] = Microsoft Standard Keyboard code
;	[DX] = bytes 2 and 3 of three byte codes
;	PSW.C = set indicates a 2 byte character
;	PSW.C = reset indicates a 1 or 3 byte character code
;		(the code is in AL in the 1 byte case, AX in the 2 byte
;		 case, and AL and DX in the 3 byte case)
;
;Exit:
;	[AX] = OEM code to be returned by INKEY$.
;	PSW.C = set indicates a 2 byte character
;	PSW.C = reset indicates a 1 byte character code in AL
;	PSW.Z = set indicates that there is no OEM code to  associate
;		with the Microsoft Code. AX is don't care
;
;Uses:
;	Per Convention.
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****
;
;	ALGORITHM:
;	If input is 3-byte code then restore extended code and exit
;	else
;		if 1-byte code then return with same code
;		else 	REM input is 2-byte code
;		if input is special 1-byte then return 1-byte code
;		else search the table for match
;		if match found then return mapped char 
;		else return zero in AX and request to ignore it.
;
;	NOTE:	If ZF = 1 (ignore char) then AX is undefined. Currently, the
;		caller (B$INKY in IOTTY.ASM) ignores AX under this condition.
;
;	IMPLEMENTATION:
;	This function is exact opposite of B$KEYINP in the sense that the
;	mapping is reversed. This assists us in sharing the same keyscan table
;	for mapping. However, the main difference is in setting up the start
;	address for key searching and the count of entries to be searched.
;	The first one is determined the input high-byte (AH) value and
;	the second one by the number of entries for each AH-type. The equates
;	KEY_128_LEN & KEY_255_LEN provide the count values that can be
;	moved into CX for looping. Also, notice that the 3-byte entries
;	<new-AL> = 254 will not be used and  separate in-line check would
;	be made to detect both 3-byte characters and special 1-byte characters
;


cProc	B$INKMAP,<PUBLIC,NEAR>,<BX,CX,SI>	
cBegin				

	JC	INK_2_BYTE	; Process 2-byte codes separately
	CMP	AL,254		; Is it a 3-byte code?
	CLC			; Assume 1-byte return code
	JNE	INK_EXIT	; NO, it is 1-byte, return the same code
	SHL	AL,1		; CF = 1, ZF = 0 to indicate 2-byte code
	XCHG	AX,DX		; Restore extended code and say it is
				; a 2-byte code (CF = 1)
	JMP	SHORT INK_EXIT	

;	Come here for 2-byte code and special 1-byte codes

INK_2_BYTE:			
	CMP	AX,0FFFFH	; Is it 2-byte code for 255?
	JE	INK_1_BYTE	; Yes, set CF=ZF = 0 and exit
	CMP	AX,08080H	; Is it 2-byte code for 128?
	JE	INK_1_BYTE	; Brif so
	CMP	AX,0FF10H	; Is it 2-byte code for 254
	JNE	INK_MAP		; Brif not to map it
	MOV	AL,254		; 0XFF10 maps to 0XFE

INK_1_BYTE:			; Set ZF = CF = 0
	OR	SP,SP
	JMP	SHORT INK_EXIT	; & Exit...

INK_MAP:			; Map the character using KEYINP_TABLE table

;	It is really a 2-byte character. Try to map it to the scan code
;	Examine High-byte to determine the table start

	MOV	CX,KEY_128_LEN	; Assume high-byte would be 128
	MOV	SI,RT_TEXTOFFSET KEYINP_TABLE	; Same as above
	CMP	AH,128		; Is it 128?
	JE	INKMAP_LOOP	; Br to search the table
	MOV	CL,KEY_255_LEN	; Setup count and start address for
	MOV	SI,RT_TEXTOFFSET KEY_255_START	; High-byte = 255

;	If AH <> 255 invalid input code - raise an alarm
DbAssertRelB	AH,E,255,RT_TEXT,<Illegal 2-byte code in INKMAP>

INKMAP_LOOP:			
	XCHG	AX,BX		; BL = Keycode
	CLD			; Autoincrement

INK_LOOP:			; Search Loop
	LODS	KEYINP_TABLE	; Get both keycode and scancode
	CMP	AL,BL		; Is key found
	JE	INK_FOUND	; Brif match occurred
	LOOP	INK_LOOP	; Try again until end of table

INK_NOTFOUND:			; The key was not found. Simply return
	XOR	AX,AX		; zero in AX and request to ignore it.
	JMP	SHORT INK_EXIT	; Exit...

INK_FOUND:			; A match has been found
				; Return the code in correct registers
	MOV	AL,AH		; Get the mapped character
	XOR	AH,AH		; Set High byte zero
	SAHF			; ZF = 0
INK_CEXIT:			
	STC			; CF = 1

INK_EXIT:			; Exit...

cEnd				; End of B$INKMAP



sEnd	RT_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llscnio.asm ===
TITLE	LLSCNIO - screen I/O initialization
;***
; LLSCNIO.ASM - screen I/O initialization
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

	INCLUDE switch.inc	;switch file
	INCLUDE rmacros.inc	;useseg macro

	USESEG	RT_TEXT 	;core runtime segment
	USESEG	CN_TEXT 	;Console IO
	USESEG	_DATA		
	USESEG	_BSS		

	INCLUDE seg.inc 	;segment definitions
	INCLUDE idmac.inc	;internal debug macros
	INCLUDE oscalls.inc	;Dos 5 structures
	INCLUDE ibmunv.inc
	INCLUDE intmac.inc
	INCLUDE baslibma.inc	; SKIP macro
	INCLUDE llgrp.inc	; constant definitions
	INCLUDE const.inc	; bit flag definitions
	INCLUDE files.inc	; CALLOS macro



sBegin	_DATA			

	externB b$ForeColor	
	externB b$NullColor	;encoded color attributes for blank/_BSCROLL
	externB b$ForeMapped	;graphics foreground
	externW b$CURSOR 	; high-level cursor position (where we
	externB b$WDOTOP	; top line of text window (1-relative)
	externB b$WDOBOT	; bottom line of text window (1-relative)
	externB b$CRTWIDTH	; rightmost column (1-relative)
	externW b$CharPage	; b$CharColor and b$ActPage in one word
	externB b$ActPage	; active display page.
	externW b$CSRTYP	; Current Cursor type


	externW b$VideoBase	

sEnd	_DATA			


sBegin	_BSS			

	globalB b$MUSIC,,1	; music currently active or not byte

	externB b$ScrWidth	
	externB b$ScrHeight	
	externB b$ScreenMode	
	externB b$Adapter	

	externW b$PageTable	

sEnd	_BSS			

sBegin	RT_TEXT 		
	assumes CS,RT_TEXT	

	externNP B$SCNIO	


	externNP B$SCINIT	; Performs screen initialization
	externNP B$SELAPG	; Select active screen page
	externNP B$SELVPG	; Select visual screen page
	externNP B$OFFCSR	
	externNP B$SlowUsrCsr	

;***
;B$CLRSCN - Clear screen and home cursor
;OEM-interface routine
;
;Purpose:
;	Low level support for the CLS statement and ^L function.
;	This routine supports the clearing of the text window.
;
;	Note that since the graphics cursor in DOS is generated
;	by the OEM code, it may have to be redrawn on the new screen.
;
;	The parameters that this routine is passed are only indirectly
;	related to the ones to the CLS statement.  The CLS statement
;	parameter may be modified to reflect the current screen/graphics/
;	viewport/window that is in effect.
;
;	NOTE: If you are supporting delayed screen initialization,
;	      B$SCNINIT has to be called before any changes are
;	      made.
;
;Entry:
;	[AL] = 0 indicates clear all text and graphics	(entire screen)
;	       1 indicates clear graphics viewport only (do nothing)
;	       2 indicates clear text window only
;
;Exit:
;	[AL] = 0, 1 or 2 as described above
;	PSW.C - set indicates a function call error
;
;Uses:
;	Per convention
;
;Preserves:
;	AX,BX,CX,DX
;
;Exceptions:
;	None.
;****
;Algorithm:
;	if parameter passed is 0 then
;	    get current screen mode
;	    get 0-relative width
;	    get background color
;	    blank screen from bottom up
;	else
;	    if parameter passed is 1 then
;		return with parameter unchanged
;	    else
;		if parameter passed is 2 then
;		    get text window limits
;		    fill text window with ASCII spaces
;		else
;		    set [AL] to 0
;		    set PSW.C to indicate function call error
;#**

cProc	B$CLRSCN,<PUBLIC,NEAR> 
cBegin
	PUSH	DX
	PUSH	CX
	PUSH	BX
	PUSH	AX
	CALL	B$SCINIT	; make sure screen is initialized.
	PUSH	AX		
	cCALL	B$SELAPG 	; select active page
	POP	AX		
	CMP	AL,1
	JE	CLRET_1 	;return with parameter unchanged
	JA	TXONLY		;clear text only
TXNGRA: 			;clear the whole screen
	MOV	DX,101H
	PUSH	DX

	MOV	DL,b$ScrWidth	;screen width
	dec	dl		;make 0-relative
	MOV	DH,b$ScrHeight ;Get screen height
	DEC	DH		; Ignore function key display line
	DEC	DH		; Make it 0-relative
	XOR	CX,CX		;upper left hand corner (0,0)
	JMP	SHORT CLR_IT

CLRET_1:			
	JMP	SHORT CLRET	

TXONLY:
	XOR	CX,CX		; CH = left column (0-relative)
	MOV	CL,b$WDOTOP	; get window top (1-relative)
	PUSH	CX		; save for B$CSRDSP
	DEC	CX		; CL = top row (0-relative)
	XCHG	CH,CL		; (CH,CL) = (top row, left column)
	MOV	DL,b$CRTWIDTH	; get right column (1-relative)
	MOV	DH,b$WDOBOT	; get window bottom (1-relative)
	DEC	DX		; DL = right column (0-relative)
	DEC	DH		; DH = bottom row (0-relative)
CLR_IT:

	MOV	BH,b$NullColor	;get current background color

	XOR	AL,AL		;blank entire window
	SCNIOS	vScrollPageUp	;from bottom up

	POP	DX		;unsave window top
	MOV	DH,1		; column = 1
	MOV	BYTE PTR b$CSRTYP,-1 ; invalidate previous cursor type so
				; that it will get reset
	CALL	B$SlowUsrCsr	; display user cursor, forcing relocation
CLRET:
	cCALL	B$SELVPG	; select visual page
	POP	AX
	POP	BX
	POP	CX
	POP	DX
	CMP	AL,2		;was the parameter <= 2 ?
	JA	CLRERR		;Brif not
	CLC			;else carry clear to indicate no error
	RET
CLRERR:
	MOV	AL,0		;entry parameter altered, CLS 0 is
				;supported
	STC			;carry set to indicate error
cEnd				

;
;	Rewritten [35] to use B$STRSOUT.
;***
;B$SCROUT - Print a character on the screen
;OEM-interface routine
;
;Purpose:
;	This routine puts the specified character at the specified screen
;	position.  For systems with support for 16 bit printable characters,
;	the OEM-independent code ensures that double byte characters will
;	not be half-overwritten.
;
;	B$SCROUT must use a nonredirectable function call to write
;	characters.
;
;Entry:
;	[AX] = character (printable, not control)
;	[DH] = one relative column number
;	[DL] = one relative line number
;
;Exit:
;	Cursor turned off.
;
;Uses:
;	Per convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;****
cProc	B$SCROUT,<NEAR,PUBLIC>,<CX,DX,SI>
cBegin
	PUSH	AX		;place character in memory
	MOV	SI,SP		;[SI] = pointer to it
	MOV	CX,1		;[CX] = string length
	call	B$STRSOUT	;direct video access if text mode
	POP	AX		;Restore character (even stack)
cEnd


;***
;B$STRSOUT - output a 'normal' string to the screen
;OEM-interface routine
;
;Purpose:
;	Print a string to the screen. We know that there are no control
;	characters in the string, and that wrap-around will not occur.
;	This routine is provided to allow fast printing of strings
;	through a OS call or by direct access to the screen memory if
;	it is allowed.	If this speed improvement can not be implemented,
;	this routine can be implemented as multiple calls to B$SCROUT.
;
;	Note that for systems that have double byte character support
;	this routine takes the number of bytes in the string to
;	be output, not the number of characters.  It is guarenteed that
;	this string will not have any double byte characters in it.
;
;Entry:
;	[CX] == number of bytes to output
;	[DH] == one relative column number
;	[DL] == one relative line number
;	[SI] == pointer to first char in string
;
;Exit:
;	[DH] == (updated) one relative column number
;	[DL] == one relative line number
;	Cursor turned off if graphics mode
;
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX
;
;Exceptions:
;	None.
;****

cProc	B$STRSOUT,<NEAR,PUBLIC>,<BX,CX,SI>	
cBegin				

	CALL	B$SCINIT	; make sure screen is initialized.
	MOV	BX,b$CharPage	; [BL] = char attribute, [BH] = active page
	CMP	b$ScreenMode,0 ;Text mode ?
	jz	OUT_CHAR	;BRIF not
	CALL	B$OFFCSR 	; request cursor off and position
	MOV	BL,b$ForeMapped;char color is graphics foreground color
OUT_CHAR:


; Note that the string output function of the BIOS can't be used,
; since the original PC and XT didn't have it.

	DEC	DX		; make 0-based
	XCHG	DH,DL		; DH = 0-based row
	DEC	DX		; DL = 0-based column	
	PUSH	DI		
	call	B$FastOutStr	;direct video access if text mode
	POP	DI		; restore registers
	INC	DX		; make 1-based
	XCHG	DH,DL		; DH = 1-based column
	INC	DX		; DL = 1-based row	

cEnd				

; (start)
;***
;B$FastOutStr
;
;Purpose:
;	Write a block of characters to video RAM.  The characters must
;	fit on one line (no scrolling)
;Inputs:
;	bh = display page
;	bl = attribute/color
;	cx = count of characters
;	dl = 0-based column number
;	dh = 0-based row number
;	ds:si = pointer to characters
;	If graphics mode, cursor position must already be set with BIOS
;Outputs:
;	dl updated for next column (dl=dl+cl)
;	ds:si points past end of string
;	BIOS data area updated for next column
;Preserves:
;	dh,es
;Modifies:
;	si,di
;****
assumes	DS,NOTHING			; WARNING: DS not always DGROUP!
assumes	ES,NOTHING
cProc	B$FastOutStr,<PUBLIC,NEAR>	
cBegin
	cmp	[b$ScreenMode],0	;In text mode?
	jnz	GraphOutStr
TextOutStr:
	push	es			; must preserve ES if modified
	call	GetPos			;es:di points to video RAM
	mov	ah,bl			;Attribute to ah
	test	[b$Adapter],CGA		;CGA card needs video sync
	jz	NoSyncLoop
;Wait for start of horizontal sync, or anywhere in vertical sync
	push	dx
	mov	dx,CGA_STATUS
CheckStatus:
	sti
	nop				;One instruction delay on STI
	cli				;Can't interrupt between IN and STOSB
	in	al,dx			;Get status port
	test	al,VERT_SYNC		;In vertical sync?
	jnz	VsyncOut		;If so, do whole string right now
	test	al,HORZ_SYNC		;In horizontal sync?
	jnz	CheckStatus		;Wait till we're out of it
	lodsb				;Get character
	xchg	bx,ax			;Save char & attrib in bx
WaitHorz:
	in	al,dx
	test	al,HORZ_SYNC
	jz	WaitHorz		;Wait for start of horizontal sync
	xchg	ax,bx			;Get char & attrib to ax
	stosw				;Store in video RAM
	loop	CheckStatus
	sti
	pop	dx
	pop	es			
cEnd					

VsyncOut:
	sti
	pop	dx
NoSyncLoop:
	lodsb				;Get character to output
	stosw
	loop	NoSyncLoop
	pop	es			
	ret

GraphOutStr:
	mov	di,cx			;Keep char. count in di
	mov	cx,1			;1 character per BIOS call
GraphLoop:
	lodsb
	mov	ah,vWriteChar		;Write character and attribute
	int	10H
	inc	dx			; Increment column
	mov	ah,vSetCursorPos
	int	10H			;Bump cursor position
	dec	di			;Count characters
	jnz	GraphLoop
	ret

; (continued)

;***
;GetPos
;
;Inputs:
;	bh = display page
;	cx = count of characters
;	dl = 0-based column number
;	dh = 0-based row number
;Outputs:
;	es:di = pointer to video RAM location
;	dl updated for next column (dl=dl+cl)
;	BIOS data area updated for next column
;Preserves:
;	bx,cx,dh,si
;****
cProc	GetPos,<NEAR>			
cBegin
	xor	ax,ax
	mov	es,ax			;Access BIOS data area

;Compute ending cursor position for BIOS
	mov	al,bh			;Page no.
	xchg	di,ax			;   to di
	shl	di,1			;Use page no. as word index
	mov	ax,dx
	add	al,cl			;Compute ending column
	mov	es:[di].BIOS_CursorPos,ax ;Set final cursor position for BIOS

;Compute video RAM address
	mov	al,[b$ScrWidth]
	mul	ah			;Start of row
	add	al,dl			; Add column
	adc	ah,0
	shl	ax,1			;Two bytes/character
	add	ax,[di].b$PageTable	;Add start address for this page
	xchg	di,ax			;Video RAM offset to di
	mov	es,[b$VideoBase]	;Start segment of video

	add	dl,cl			; Compute ending column return value
cEnd					
; (end)

assumes	DS,DGROUP			
assumes	ES,DGROUP
;***
;B$CLREOL - Clear from specified position to end of line
;OEM-interface routine
;
;Purpose:
;	This OEM routine is responsible for clearing a line from
;	the given row and column position to the width of the screen.
;
;	Some systems support two byte printable characters by using
;	both a hardware and a software character generator.  In these
;	systems, it is necessary to clear both the character RAM and
;	the corresponding area of the graphics RAM.
;
;Entry:
;	[DL] = line number
;	[DH] = column number
;
;Exit:
;	none
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;****
;Algorithm:
;	determine number of spaces to write
;	set up params for bios call
;	erase to end of line
;	display off cursor at b$CURSOR  
;
;#**
cProc	B$CLREOL,<PUBLIC,NEAR>,<AX,BX,CX,DX> 
cBegin

	CALL	B$OFFCSR 	; request off cursor and position
	MOV	CL,b$ScrWidth	;get current screen width
	SUB	CL,DH		;[CL] = number of spaces to end of line
	INC	CL
	XOR	CH,CH		;zero CH
	MOV	BH,b$ActPage	;get active display page
	MOV	BL,[b$NullColor] ; b$NullColor must be used in text modes!
	CMP	[b$ScreenMode],4 ; Is this Olivetti 640x400 mode?
	JNE	NotMode4	; brif not
	MOV	BL,[b$ForeColor] ;  must use foreground color!
NotMode4:			
	MOV	AL," "		;load a blank
	SCNIOS	vWriteChar	;erase to end of line
	MOV	DX,b$CURSOR	; DX = previous cursor position
	CALL	B$OFFCSR 	; request off cursor and re-position
cEnd				

; Moved here with revision [40].
;
;***
;B$BLEEP -- Beep the speaker.
;OEM-interface routine
;
;Purpose:
;	Beep the speaker.  This routine has been separated from
;	B$DONOTE so that the entire sound support does not have
;	to exist in order to Beep the speaker.	This routine
;	should wait until any music currently playing (foreground
;	or background) has finished.
;
;	Moved here from LLQUE.ASM for increased /O modularity.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	None
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;****

cProc	B$BLEEP,<PUBLIC,NEAR>,<AX,DX>
cBegin


	MOV	DL,07H		; [DL] = ^G (beep the speaker)
	MOV	AX,0601H	; [AH] = Console I/O
				; [AL] = 1 for comparison purposes
BEEP_WAIT:			
	CMP	b$MUSIC,AL	; is music running ?
	JE	BEEP_WAIT	; wait until all notes are played
	INT	21H		

cEnd				; End of B$BLEEP

sEnd	RT_TEXT 		


sBegin	CN_TEXT

;Moved here from IOCONS.ASM with [41]
;
;***
;B$CON_SOUT - Write one byte to the console.
;OEM-Interface routine
;
;Purpose:
;	This routine will send a single byte to the CONS: device.
;	This is a redirectable output only device.
;
;Entry:
;	AL = Byte to output
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX,BX,CX,DX
;
;Exceptions:
;	Device unavailable if a detached process
;****
cProc	B$CON_SOUT,<PUBLIC,NEAR>,<AX,BX,CX,DX>
cBegin
	CMP	AL,255		
	JZ	CONSOX		;Don't allow outputing FFH
	MOV	DL,AL
	CALLOS	DCIO		;Direct Console I/O
CONSOX:
cEnd


sEnd	CN_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llsnd.asm ===
TITLE	LLSND - multivoice music and sound interface
;***
; LLSND - multivoice music and sound interface
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;       This module has the following support routines :
;
;       1. B$DONOTE
;       2. B$TICTOC.... The TIMER interrupt vectors here before
;                       updating the time of the day. Normal
;                       frequency of the timer interrupt is 18.2
;                       times per second. This frequency is changed
;                       so that it interrupts at 572.4 times per
;                       second (exactly 32 times faster). This increase
;                       in speed gives better music performance. The
;                       basic philosophy in handling music is described
;                       below :
;
;               Music is composed of notes and a note consists of:
;               1. Frequency
;               2. Duration
;                       The frequency is loaded into the 8253 timer
;               chip. The duration is saved in some memory location and each
;		time the timer interrupts, we decrement the duration by 1 and
;               when the duration becomes zero we are all done. It is
;               important to note that the 8253 operates in the mode
;               wherein it reloads itself each time it counts down to
;               zero.
;               We have to remember one important thing, since we
;               change the frequency of the TIMER interrupt whenever
;               music is playing, we should see to it that the actual
;               timer interrupt (one which updates the time of the day)
;               gets called once every 32 times our timer interrupt
;               gets called. The figure 32 comes from the fact that
;               the TIMER is 32 times as fast as what it used to be.
;               Also when music stops playing we SHOULD change the
;               timer frequency back to its original rate.
;               The figure below illustrates how the TIMER interrupt
;               ( INT 8H ) is handled :
;
;                 Timer INT
;                  vectors
;                ------------        IF MUSIC      --------------
;               |     -------|------------------->| B$TICTOC      |
;                ------------    |     ACTIVE     |    Interrupt |
;               |    CS      |   |                |   service    |
;                ------------    |                |   routine for|
;                                |                |   handling   |
;                                |                |   music      |
;                                |                |     _________|______
;                                | ELSE IF         --------------       |
;                                | MUSIC NOT                            |
;                                | ACTIVE                               |
;                                |                                      |
;                                |                 ------------         |
;                                 --------------->| ROM Timer  |        |
;                                                 | interrupt  |<-------
;                                                 | service    |
;                                                 | routine    |
;                                                 | updates    |
;                                                 | time of    |
;                                                 | day.       |
;                                                 |            |
;                                                 | (F000:FEA5)|
;                                                 |            |  INT 1CH
;                                                 |  -------------------
;                                                 |            |        |
;                                                  ------------         |
;                                                                       |
;                                                                       |
;                                                  ------------         |
;                                                 | CLOCK_INT  |        |
;                                                 |   This     |<-------
;                                                 |  routine   |
;                                                 |  checks for|
;                                                 |  timer, pen|
;                                                 |  and TRIG  |
;                                                 |  traps.    |
;                                                 |            |    JUMP TO
;                                                 |    --------|------------->
;                                                  ------------     OLD 1CH
;                                                                   VECTOR
;
;               The routine B$TICTOC calls on the following routines:
;
;               1. B$NXTSND.... This looks to see if any more entries
;                             are present in the sound queue and if so
;				gets the frequency and duration information,
;				and starts that note. It also check if any play
;                             event occured and if so sets the PLYFLG
;                             and the EVTFLG.
;
;******************************************************************************
	INCLUDE	switch.inc	;switch file
	INCLUDE rmacros.inc	

	UseSeg	_BSS		
	UseSeg	_DATA		
	UseSeg	EV_TEXT 	


	INCLUDE seg.inc 	
	INCLUDE	idmac.inc	
	INCLUDE	ibmunv.inc	; include control block & DONOTE input values
	INCLUDE	intmac.inc	
	INCLUDE event.inc 	

CLK_DELTA	EQU	8	; 8 = 256/32
QUE_BYTES	EQU	1+2+2	; Note + Duration + Frequency

sBegin	_BSS			

	globalB b$PLAFLG,,1	;play event flag
	globalB b$PLENBL,,1	;play trapping enabled or not flag
	globalW b$PLYCNT,,1	;# of notes specified in ON PLAY(n)
	globalW b$NOTES,,1	;keeps running total of the music notes
	globalW b$SNDTIM,,1	

	PUBLIC	b$SNDQCB	; Sound control block
b$SNDQCB QUE_CTRL_BLOCK <>	

	externB b$MUSIC		; defined in LLSCNIO.ASM
	externW b$SNQueSeg	;SNINIT - sound queue buffer segment

	staticB b$SNDFLG,,1	;flag set if music started
	staticB CLK_TICS,8,1	;Clock tic modulo counter at any time
	externW b$pTrapEvent	; pointer to B$TrapEvent if event code
				; present

sEnd	_BSS			


assumes CS,EV_TEXT		
sBegin	EV_TEXT 		


	externW  b$BASDSG	
	externNP B$INIQUE	
	externNP B$QUE 		
	externNP B$DQUE		

POPFF	MACRO			;; macro to insure that POPF instruction
LOCAL	L1,L2			;; is executed correctly on 286. It seems

	JMP	SHORT L2	;;to enable interrupts after POPF instruction
L1:	IRET			;; even if the stack image says 'disabled'
L2:	PUSH	CS
	CALL	L1

	ENDM

;***
;B$DONOTE - Support for sound
;OEM-interface routine
;
;Purpose:
;	This routine supports speaker activity.  The support is subdivided
;	into several subfunctions as follows:
;
;	a. Queue a note:
;          This function is passed a frequency and a duration. The note is
;	   queued, if the frequency is legal, otherwise nothing it put in
;	   in the queue. No attempt to start the speaker is made.
;
;	   The definition of a legal frequency are machine dependent.  For
;	   an IBM, a frequency must be within the range 37 <= f <= 32767.
;
;	b. Queue a rest:
;          This function is passed a duration. Stacatto and Normal mode notes
;	   are built from a note and a short pause. This function is used
;	   to play the fraction of a note that defines a short pause in case
;          of Stacatto and Normal notes.
;
;	c. Query if voice is active:
;          This function is used to test the current activity of the
;          sound queue. If queued items are currently being processed
;          in the sound queue, this function code should return
;          FF in [AL], else it should return 0 in [AL].
;
;	d. Start Music:
;	   This function requests that notes that have been queued are
;	   to start playing. Notes should be played until the queue is
;	   empty. This function can be called if notes are currently
;	   playing, in which case it simply returns.  Notes may be added
;	   to the queue while it is being played. No event other than
;	   this subfunction should start music.
;
;	e. Stop Music and flush the queue:
;          This function requests that the voice be stopped and that
;          queue for the voice be flushed.
;
;
;       Certain of the above functions must add queue entries. If no room
;       remains in the queue then the routine must return immediately to
;       specify that the queue is full. This event must not cause speaker
;       activity to begin.
;
;Entry:
;       [AL] = Function number
;               0: Queue rest
;                       [DX] = Duration ( 1 = 2.5 milliseconds )
;               1: Queue note
;                       [CX] = Frequency in Hz
;                       [DX] = Duration ( 1 = 2.5 milliseconds )
;               2: Query if voice is active
;                       Return in [AL]
;                         0 - voice is not currently active
;                        FF - voice is active
;              FE: Start music
;              FF: Stop music and flush queue
;
;Exit:
;       PSW.C set indicates that [AL] contains return information
;	[AL] =	1 - No room in the queue for this request
;		2 - Illegal function request
;               3 - Unsupported frequency
;	PSW.C reset indicates successful completion.
;
;
;Uses:
;	Per convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****
;
;ALGORITHM:
;	case [AL] of
;	0,1 : begin
;		B$QNOTE (AX,CX,DX)
;		/* queues either the note or the rest */
;		end
;	  2 : B$QUERY
;		/* checks if the voice is active */
;	  3 : begin	/* in practice, this is ignored */
;		B$QSYNC()
;		end
;	4,5 : ENVELOPE SHAPE/DURATION
;		/* These functions are not supported */
;         6 : $MKNSE /* this function is not supported */
;         FC : SOUND ON/OFF /* this function is not supported */
;         FD : BEEP ON/OFF /* this function is not supported */
;         FE : B$QSTART
;              /* starts music */
;         FF : B$QFLUSH
;             /* stops music and flushes the queues */
;       endcase
;

DONOTE_TABLE	LABEL	WORD	; Dispatch table

	DW	B$QSTART	; start the music
	DW	B$QFLUSH	; stop the music & flush the queue
	DW	B$QNOTE	; queue a rest
	DW	B$QNOTE	; queue a note
	DW	B$QUERY	; query if voice is active or not

MAX_DONOTE	EQU	($ - DONOTE_TABLE)/2 ; Permissible entry value in AL
	
cProc	B$DONOTE,<PUBLIC,NEAR>,<BX,CX,DX,SI>	
cBegin				

	MOV	BX,OFFSET DGROUP:b$SNDQCB ; get addr of music queue in BX
	CMP	b$SNDFLG,0	;initialization been done?
	JNZ	DONOT1		;jump if already initialized
	INC	b$SNDFLG	;mark as initialized

	PUSH	AX
	XOR	AX,AX		;music queue starts at zero
	MOV	[BX].QUEBOT,AX	; set the bottom
	cCALL	B$INIQUE	; set put, get, num, note..
	MOV	AX,QLENTH	;    get length
	MOV	[BX].QUELEN,AX	; and set it in the block
	MOV	[BX].QUETOP,AX	;    to set the top of queue.
	POP	AX

DONOT1:
	CBW			; AH = 0/-1
	MOV	SI,AX		; SI will be used to point to the dispatcher
	INC	SI		; Add 2 to SI to make it 0-relative
	INC	SI		
	CMP	SI,MAX_DONOTE	; Check if arg within range
	JA	DONOTE_ERR	; Brif no - issue error

	SHL	SI,1		; Make it a word index
	CLD
	cCALL	DONOTE_TABLE[SI] ; Invoke respective handler
	JNC	DONOTE_EXIT	; No error - else error code is in DL
	XCHG	AX,DX		; Else get error code in AL

DONOTE_EXIT:			; Common exit point

cEnd				; End of B$DONOTE

DONOTE_ERR:			; Error case
	MOV	AL,2		; Issue voice-id invalid
	STC			; CF = 1 indicates error
	JMP	SHORT DONOTE_EXIT ; Exit...

	PAGE

;***
;B$QNOTE
;
;PURPOSE:
;       This routine queues either a note or a rest. By rest we mean
;       the short pause that goes to make Stacatto and Normal notes.
;       This routine calls a number of device dependent routines. These
;       device dependent routines check for the validity of frequency and
;       duration. They also output these quantities to the 8253 timer chip.
;       It either queues in the whole note or does'nt queue at all.
;
;ENTRY:
;	[BX] = QUEUE BLOCK BASE ADDR
;       [CX] = Frequeuncy
;       [DX] = Duration
;       [AL] = 0 OR 1 depending on whether it is a rest or
;               a music note respectively.
;
;EXIT:
;	[DL] = Error codes as specified by the routine B$DONOTE
;
;MODIFIED:
;       None
;
;****
cProc	B$QNOTE,<NEAR>,<AX,ES>	

localV	QBLK,QUE_BYTES 		; This block is used to temporarily
				; queue the note as it is processed
cBegin				

	OR	AL,AL		; was it a note ?
	JNZ	QNOTE		; brif so
	SUB	CX,CX		; Else queue in very high frequency

QNOTE:
	CMP	[BX].QUENUM,QLENTH-QUE_BYTES	; Is there enough space?
	JA	QUE_ERR1	; Brif not
	LEA	SI,QBLK 	; [si] = address of qblk
	MOV	BYTE PTR [SI],AL; temporarily queue the attribute

CHECK_DURATION:

;       [DX] = duration (1 = 2.5 millisecs)
;       [AX] = [AX] * 1.5
	
	MOV	AX,DX		;copy duration for adjustment
	SHR	AX,1		;divide by 2
	ADD	AX,DX		;duration = 1.5 * original duration
	JNC	DUROK		;Brif no overflow
	SBB	AX,AX		; else use maximum duration

DUROK:
	MOV	WORD PTR [SI+1],AX ; temporarily queue the duration

CHECK_FREQ:

; check for valid frequency and convert it to tics

	CMP	CX,37D		;check for valid frequency (37 <= CX <= 32767)
	JGE	FRQOK		; Brif in range
	MOV	DL,3		; Error code in AL (if needed)
	INC	CX		; If zero, then set it to some high value
	LOOP	QUE_ERR2	; Brif not zero - Error in freq value

FRQ_0:
	NOT	CX		; CX = -1 ; Play an inaudible frequency

FRQOK:				; Convert frequency to tics
	MOV	AX,34DCH	; 1.193180 MHz
	MOV	DX,12H		
	DIV	CX		; [AX] = COUNT = CLOCK/FREQUENCY
	CLC			; CF = 0

	MOV	WORD PTR [SI+3],AX ; temporarily queue the frequency
	MOV	ES,b$SNQueSeg	;music queue has its own buffer segment
	MOV	CX,QUE_BYTES	; 5 bytes to be queued
	CLI			;CLI,bcos this is an indivisable operation

QUETHEM:			;[si] = address of QBLK

.erre	ID_SSEQDS		; Assert SS = DS

	LODSB			; [al] = byte to be queued
	cCALL	B$QUE		; queue the byte
	LOOP	QUETHEM

	MOV	AL,BYTE PTR QBLK ; get the note/rest (1/0)
	CBW			; AH = 0
				; For rest, the following additions are NOPs
	ADD	[BX].QUNOTE,AX	; Suitably update # of notes in queue
	ADD	b$NOTES,AX	  ; and total note count
	CLC			; Clear carry to indicate no error

QUERET:
	STI			;restore interrupts

cEnd				; End of B$QNOTE

QUE_ERR1:
	MOV	DL,1		; error code in [al]
QUE_ERR2:
	STC			; indicate error
	JMP	SHORT QUERET

	PAGE

;***
;B$QUERY
;
;PURPOSE:
;       Checks to see if any voices are active
;
;ALGORITHM:
;	If the timer is turned on of off frequently, then an irritating
;	'click' sound is heard between two play statements. In order to
;	avoid this 'click', when (b$NOTES | b$SNDTIM) > 2 then say that
;	music is inactive. This lets Hi-Level to queue the next note
;	and the speaker is not turned off in-between.
;
;ENTRY:
;       None
;
;EXIT:
;       [AL] = 0 if voice is not currently active
;              FF if voice is active
;
;MODIFIED:
;       None
;
;****
cProc	B$QUERY,<NEAR>	
cBegin				

	MOV	AX,b$NOTES	; Get number of notes (may be zero)
	OR	AX,b$SNDTIM	; Add any music-ticks still left
	CMP	AX,2		; If zero or 1 then zero else -1
	CMC			; CF =1 if AX > 2
	SBB	AL,AL		; AL = -1 if speaker active
	CLC			; No error for this call


QUERY_RET:			; Just exit...

cEnd				; End of B$QUERY


	PAGE

;***
;B$TICTOC
;
;PURPOSE:
;       The timer interrupt, vectors here BEFORE updating the
;       time of the day. This routine helps support the
;       Music routines. B$TICTOC keeps decrementing the duration
;       count until it becomes zero at which point it
;       either gets the next sound from the sound
;       queue or else it turns off the voice by calling B$QFLUSH.
;ENTRY:
;       None
;
;EXIT:
;       None
;
;MODIFIED:
;       None
;
;****

cProc	B$TICTOC,<NEAR>	
cBegin				

	STI			; Enable interrupts now itself - there
				; is no chance of another timer intterupt
				; occurring since EOI is sent only later.
	PUSH	AX
	PUSH	BX
	PUSH	CX		; Save temp registers AX,BX,CX
	PUSH	DX		; Save this also
	PUSH	DS
	PUSH	ES

	MOV	DS,CS:b$BASDSG ;get BASIC's data seg
	MOV	ES,b$SNQueSeg	;point to music buffer

	XOR	AX,AX		; Get ready for some zero comparisons
	CMP	b$SNDTIM,AX	; has SND_TIM zeroed out?
	JZ	NXTONE		;Brif so to get next sound
	DEC	b$SNDTIM	; SND_TIM - 1
	JNZ	CLK_TIC
NXTONE:
	MOV	BX,OFFSET DGROUP:b$SNDQCB ; BX = address of music queue	
	CMP	[BX].QUENUM,AX	; Is the queue empty
	JE	TURN_OFF	; If so, then turn music off
	cCALL	B$DQUE		; Get first entry in queue
	OR	AL,AL		; Check if it is note or rest
	JZ	GETSND1		; Brif rest : no need to check play trap
				; AL = 1 for note
	CMP	b$PLENBL,AL	; Check if play trapping is enabled
	JNE	GETS1		; Brif disabled
	MOV	AX,b$PLYCNT	; Get the number of notes set for trapping
	CMP	[BX].QUNOTE,AX	; and compare it with current # of notes
	JNE	GETS1		; Brif event has not occurred
	MOV	b$PLAFLG,1	; Else set the flag
	MOV	AL,PLAOFF	; AL = trap number for B$TrapEvent
	CALL	[b$pTrapEvent]	; set the global flag if events linked in

GETS1:
	DEC	[BX].QUNOTE	; One more note has been played
	DEC	b$NOTES	; update overall count also

GETSND1:
	cCALL	B$DQUE		; Get the duration LSB
	XCHG	AX,CX		; CL = LSB
	cCALL	B$DQUE		; Get the duration MSB
	MOV	CH,AL		; CH = MSB
	MOV	b$SNDTIM,CX	
	cCALL	B$DQUE		; Get the frequency LSB
	OUT	TIMER2,AL	; & set the timer counter Lo-byte
				; 8253 will wait until hi-byte is loaded.
	cCALL	B$DQUE		; Get the frequency MSB
	OUT	TIMER2,AL	; & set the timer counter Hi-byte
	JMP	SHORT CLK_TIC	; All done

TURN_OFF:			; Turn off the music
	PUSH	DS		; B$FLUSH requires ES = DS
	POP	ES		
	cCALL	B$QFLUSH	

CLK_TIC:
	SUB	CLK_TICS,CLK_DELTA ; clock tick  -= CLK_DELTA
				; wait for 32 interrupts to invoke ROMCLK
	POP	ES
	POP	DS
	POP	DX		
	POP	CX
	POP	BX
	JNZ	CLKTIX		;don't do ROM clock INT now
	POP	AX
	INT	ROMCLK		;to ROM clock INT service routine
	IRET			

CLKTIX:
	MOV	AL,EOI		; send End-of-Interrupt
	OUT	INTA0,AL	; to 8259
	POP	AX		
	IRET

cEnd	<nogen>			; End of B$TICTOC

	PAGE

;***
;B$QSTART
;
;PURPOSE:
;       This routine starts the music. It does the following
;       things:
;       1. Change the interrupt vector to point at our handler
;       2. Modify timer2 to interrupt 32 times faster
;       3. Turn on the speaker and start timer2 only if timer2
;          is active.
;
;ENTRY:
;       None
;
;EXIT:
;       None
;
;MODIFIED:
;       None
;
;****
cProc	B$QSTART,<NEAR>,<AX>	
cBegin				

	MOV	AH,01		; Comes useful
; DON'T reset the counter every time: only once at program load.  This is
; a modulo counter that should be retained.
;	MOV	CLK_TICS,CLK_DELTA	; Reset the counter
	PUSHF			; Save caller's IF
	CLI
	IN	AL,MSKREG	;get IMR into [AL]
	OR	AL,AH		;mask out timer interrupt
	PAUSE			;make sure instruction fetch has occurred
	OUT	MSKREG,AL	;write mask to IMR

	XCHG	b$MUSIC,AH	; get b$MUSIC flag and set it to 1
	OR	AH,AH		; Check if music is already on
	JNZ	STRTMXT		; Brif so - timer is already changed

	PUSH	DS
	PUSH	CS
	POP	DS		;[DS] := [CS]
	SETVEC	CLKINT/4,B$TICTOC ;modify timer2 interrupt vector
	POP	DS
	MOV	AL,0		;modify timer2 to interrupt
	OUT	TIMER0,AL	;at 32 times the
	MOV	AL,8H		;original
	PAUSE			;make sure instruction fetch has occurred
	OUT	TIMER0,AL	;rate
	MOV	AL,SQUARE	;else set timer2 in square
	PAUSE			;make sure instruction fetch has occurred
	OUT	TMRCMD,AL	;wave mode
	PAUSE			;make sure instruction fetch has occurred
	IN	AL,SPEAKER	;turn on the
	OR	AL,SPKRON	;speaker
	PAUSE			;make sure instruction fetch has occurred
	OUT	SPEAKER,AL
	PAUSE			;make sure instruction fetch has occurred

STRTMXT:
	IN	AL,MSKREG	;get IMR into [AL]
	AND	AL,0FEH		;unmask timer interrupt
				; CF = 0 to indicate no error
	PAUSE			;make sure instruction fetch has occurred
	OUT	MSKREG,AL	;write mask to IMR
	POPFF			; Restore caller's IF

cEnd				; End of B$QSTART

;***
;B$QFLUSH
;
;PURPOSE:
;	This routine stops music, initializes the music block, resets the timer
;	count, restores the original timer ISR and clears the flag b$SNDTIM
;
;ENTRY:
;	None
;
;EXIT:
;	None
;
;MODIFIED:
;	None
;
;****
;
cProc	B$QFLUSH,<NEAR>,<AX>	
cBegin				

	PUSHF			; Save caller's IF
	CLI
	IN	AL,MSKREG	; get IMR into [AL]
	OR	AL,01H		; mask out timer interrupt
	PAUSE			; make sure instruction fetch has occurred
	OUT	MSKREG,AL	; write mask to IMR
	cCALL	B$SNDOFF	
	JMP	STRTMXT		; Share code

cEnd	<nogen>			; End of B$QFLUSH

; B$SNDOFF moved here from LLQUE.ASM to increase /O modularity
; revision [6] applies to the entire routine:

;***
;B$SNDOFF - Turn off Sound and Clean Up
;OEM-interface routine
;
;Purpose:
;	This routine stops music and flushes the music queue(s).
;	It also performs all needed functions to disable sound.
;	B$SNDOFF is called before the RUN command is executed
;	and at program termination.
;
;	The sound queue is allocated and deallocated by the
;	runtime, so this routine need not worry about it.  The
;	queue will exist when this routine is called.
;
;Entry:
;	None
;
;Exit:
;	None
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;***************************************************************************

DB	"<LEO>"			; This is used via a separate tool to
				; actually modify the .EXE file to stub
				; out B$SNDOFF. This is necessary for
				; profiling, as B$SNDOFF modifies the
				; timer hook, as does the profiler.
				; (chosen string pure vanity on Leo's part)

cProc	B$SNDOFF, <PUBLIC,NEAR>,<AX,BX>	
cBegin					
	XOR	AX,AX		;zero out [AX]
	MOV	b$NOTES,AX	; zero out b$NOTES
	MOV	b$SNDTIM,AX	; SND_TIM = 0
	MOV	b$MUSIC,AL	;music is currently OFF
	MOV	BX,OFFSET DGROUP:b$SNDQCB ; Get music block offset
	cCALL	B$INIQUE 	; init music queue at zero offset
	
	IN	AL,SPEAKER
	AND	AL,NOT SPKRON	;turn off speaker
	PAUSE			;ensure instruction fetch has occurred
	OUT	SPEAKER,AL
	XOR	BX,BX		; CF = 0 to indicate no error
	PUSH	DS
	MOV	DS,BX		; [DS] = interrupt vectors segment
	PUSHF			; Save flags
	CLI			;make sure interrupts are off
	SVINT	DS:CLKINT,DS:CLKVEC
	POPFF			; Restore flags
	POP	DS
	XCHG	AX,BX		; AX = 0
	OUT	TIMER0,AL	;restore timer2 count
	PAUSE			;ensure instruction fetch has occurred
	OUT	TIMER0,AL

cEnd				; End of B$SNDOFF

sEnd	EV_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llxgasup.asm ===
TITLE	LLXGASUP - LowLevel graphic support shared by all LL?GA modules
;***
; LLXGASUP - LowLevel graphic support shared by all LL?GA modules
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This module contains support routines which are shared by CGA, EGA
;	VGA, and TEXT functions.
;
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_BSS
	USESEG	GR_TEXT

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE llgrp.inc	; constant definitions

sBegin	_BSS
;
;
; ***************************************************************************
; External variables
; ***************************************************************************
;
externB b$EgaPalSup
externD b$InitPalette
externB b$MaxAttr
externB b$MaxColor
externB b$Monitor
externB b$BorderColor		;border color (overscan)
;
; ***************************************************************************
; Eternal function vectors
; ***************************************************************************
;
externW b$PalTrans
externW b$PalPut
;
; ***************************************************************************
; Local variables
; ***************************************************************************
;
staticB b$EgaPalette,,17	    

sEnd	_BSS

assumes CS,GR_TEXT

sBegin	GR_TEXT
;
; b$ColorPalette - used to initialize the EGA palette for 16-color
;		    modes with a std Color Display.
;		    Moved from LLTEXT and LLEGA with [5].
;
labelB	<PUBLIC,b$ColorPalette>
	;	 I RGB
	DB	000000B 	;black
	DB	000001B 	;blue
	DB	000010B 	;green
	DB	000011B 	;cyan
	DB	000100B 	;red
	DB	000101B 	;magenta
	DB	000110B 	;brown
	DB	000111B 	;white
	DB	010000B 	;gray
	DB	010001B 	;light blue
	DB	010010B 	;light green
	DB	010011B 	;light cyan
	DB	010100B 	;light red
	DB	010101B 	;light magenta
	DB	010110B 	;light yellow
	DB	010111B 	;bright white
;
; b$EnhPalette - used to initialize the EGA palette for 16-color
;		  modes with an Enhanced Color Display.
;		  Moved from LLTEXT and LLEGA with [5].
;
labelB	<PUBLIC,b$EnhPalette>
	;	RGBrgb
	DB	000000B 	;black
	DB	000001B 	;blue
	DB	000010B 	;green
	DB	000011B 	;cyan
	DB	000100B 	;red
	DB	000101B 	;magenta
	DB	010100B 	;brown
	DB	000111B 	;white
	DB	111000B 	;gray
	DB	111001B 	;light blue
	DB	111010B 	;light green
	DB	111011B 	;light cyan
	DB	111100B 	;light red
	DB	111101B 	;light magenta
	DB	111110B 	;light yellow
	DB	111111B 	;bright white


;***
; B$EgaPalReset
;
;Purpose:
;	Reset the PALETTE to the initial, default colors.
;
;	This routine is used by many modes which use the EGA palette
;	to fill the b$PalReset function vector.
;Entry:
;Exit:
;Uses:
;Exceptions:
;	exit thru B$VgaPalReset for 256K palette in QCG
;******************************************************************************

cProc	B$EgaPalReset,<PUBLIC,NEAR>
cBegin
labelNP <PUBLIC,B$EgaPalResetB>;entry for mono modes not using VGA palette
	cmp	b$EgaPalSup,0	;support for EGA PALETTE?
	jz	PalResX 	;go if not
	mov	al,b$BorderColor;prepare border color for overscan reg.
	push	si		
	push	di		
	push	es		
	push	ds		
	push	ds
	pop	es
	mov	di,OFFSET DGROUP:b$EgaPalette ;destination for palette
	push	di
	lds	si,b$InitPalette   ;ptr to palette initializer
	mov	cx,16
    rep movsb			;copy palette
	stosb			;set overscan to border color
	pop	dx
	pop	ds		
	MOV	AL,2		;BIOS sub-function - set all palette registers
				;and the overscan register (for border color)
	SCNIO	vSetEgaPalette	;set real palette
	pop	es		
	pop	di		
	pop	si		
PalResX:
cEnd

;***
; B$EgaPalPut
;
;Purpose:
;	Change palette entry (with translation/verification done by
;	b$PalTrans.)
;	A color value of negative one indicates that the associated
;	palette entry is not to be modified.
;
;	This routine is used by many modes which use the EGA palette
;	to fill the b$PalPut function vector.
;
;Entry:
;	DX:AX = color
;	BL    = attribute
;Exit:
;	PSW.C reset indicates successful operation
;		set indicates PALETTE function call error
;Uses:
;	per conv.
;Exceptions:
;	exit thru B$VgaPalPut for 256K palette in QCG
;******************************************************************************
cProc	B$EgaPalPut,<PUBLIC,NEAR>
cBegin
labelNP <PUBLIC,B$EgaPalPutB>	;entry for mono modes not using VGA palette
	cmp	b$EgaPalSup,0	;support for EGA PALETTE?
	jz	PalPutErr	;exit if not w/error
	cmp	ax,-1		;lo word of color == -1?
	jne	PalPut1 	;go if not, can't ignore
	cmp	dx,ax		;hi word too?
	je	PalPutExit	;exit if color == -1
PalPut1:			
	call	[b$PalTrans]	;translate to external form
	jc	PalPutErr	;exit if invalid w/error
	XCHG	BH,AL		;BH:BL = color:attribute
	MOV	AL,0		;subfunction "Set Individual Palette Register"
	SCNIO	vSetEgaPalette	;set background color
	clc			;no error
	ret			
PalPutErr:
	stc
PalPutExit:
cEnd


;***
; B$EgaPalTrans
;
;Purpose:
;	Verify and translate an internal palette attribute
;	and color into the actual palette attribute and color.
;
;	This routine is used by many modes which use the EGA palette
;	to fill the b$PalTrans function vector.
;
;	This particular PalTrans routine verifies the Attribute
;	as being in the range from 0 to b$MaxAttr with no translation.
;	The Color range is also verified as 0 to b$MaxColor.  If a
;	standard Color Monitor is being driven, the Color value is
;	translated so that bit 3 of the Color drives the monitor's
;	intensity signal.  In modes supporting the std color monitor,
;	Color values range from 0 to 15, and this translation causes
;	the upper 8 colors to be intensified versions of the lower 8
;	for the EGA palette.
;
;Entry:
;	DX:AX = internal color
;	BL    = internal attribute
;Exit:
;	PSW.C reset if entry OK
;	DX:AX = actual color
;	BL    = actual attribute
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaPalTrans,<PUBLIC,NEAR>
cBegin
	cmp	bl,b$MaxAttr	;is legal attribute ?
	ja	PalPutErr	;error return
	or	dh,dl		;hi 3 bytes of color must be 0
	or	dh,ah		
	jnz	PalPutErr	;error if not
	cmp	al,b$MaxColor	;is legal color ?
	ja	PalPutErr	;error return
	cmp	b$MaxColor,15	;16 color mode?
	jne	PalTrExit	;go if not
	MOV	AH,8		;adjust to 4-bit color
	AND	AH,AL		;get the intensified bit (bit 3)
	SHL	AH,1		;slide to bit 4
	OR	AL,AH		;put it in bit 4
	xor	ah,ah		; clear AH:
PalTrExit:
	clc			;no error
cEnd

;***
; B$EgaPalSet
;
;Purpose:
;	Set the entire palette from an array where an element value
;	of -1 indicates the entry should be left alone.
;
;	This routine is used by many modes which use the EGA or VGA palette
;	to fill the b$PalSet function vector.
;
;	This particular routine uses the mode-dependent function vector
;	b$PalTrans to verify all entries before any are set using
;	b$PalPut.  Thus mode and even palette (EGA or VGA) independence
;	is maintained.
;	Special consideration is made for the number of bytes per
;	element in the array.  And that enough elements exist to fill
;	the palette.
;
;Entry:
;	AX    = size of the array in elements
;	ES:SI = address of the array
;	CX    = size of each array element in bytes (2 or 4) (unused if QCG)
;Exit:
;	PSW.C set indicates function call error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$EgaPalSet,<PUBLIC,NEAR>,<DI>
cBegin
	cld			
	mov	di,cx		;save element size
	MOV	CL,b$MaxAttr	;max attribute
	inc	cx		;number of attributes in array
	CMP	AX,CX		;elements in array vs required size
	JB	PalSetErr	;go if not big enough
CHKETY: 			;check each entry
	lods	word ptr es:[si];get lo (only?) word
	cwd			;dx:ax = I2 color
	cmp	di,4		;I4 element?
	jne	GotColor	;go if not
	xchg	ax,dx		;save lo word
	lods	word ptr es:[si];get hi word
	xchg	ax,dx		;dx:ax = I4 color
GotColor:			
	cmp	dx,-1		;hi word of color == -1?
	jne	CheckIt 	;go if not, can't ignore
	cmp	dx,ax		;lo word too?
	je	CHKNXT		;ok (ignore) if color == -1
CheckIt:			
	xor	bx,bx		;attr=0 (always valid) for PalTrans checks
	push	cx		;save loop count
	call	[b$PalTrans]	;use PalTrans to verify color value
	pop	cx		
	jc	PalSetErr	;exit if error
CHKNXT: 			;next entry
	LOOP	CHKETY

	MOV	CL,b$MaxAttr	;max attribute
	inc	cx		;number of attributes in array
	MOV	BX,CX
	DEC	SI
	DEC	SI		;now point to the last entry
	STD
EXCETY: 			;execute set up each palette entry
	DEC	bx		;BL=attribute number
	lods	word ptr es:[si];get hi (only?) word
	cwd			;dx:ax = I2 color
	cmp	di,4		;I4 element?
	jne	GotColor1	;go if not
	xchg	ax,dx		;save hi word
	lods	word ptr es:[si];get lo word, dx:ax = I4 color
GotColor1:			
	PUSH	BX
	push	cx
	CALL	[b$PalPut]	;set the palette register
	pop	cx
	pop	bx
	jc	PalSetErr	;go if error
	LOOP	EXCETY
	CLC			;indicate no error
	jmp	SHORT PalSetExit
PalSetErr:
	stc
PalSetExit:
	CLD
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\messages.asm ===
TITLE	messages.asm - message text module
;***
;messages.asm - message text module
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; Single module which contains all runtime text messages.
;
;******************************************************************************

	INCLUDE	switch.inc	

;
; Segment definitions for message isolation
;
; Far messages
;
FAR_HDR segment byte public 'FAR_MSG'
FAR_HDR ends
FAR_MSG segment byte public 'FAR_MSG'
FAR_MSG ends
FAR_PAD segment byte common 'FAR_MSG'
FAR_PAD ends
FAR_EPAD segment byte common 'FAR_MSG'
FAR_EPAD ends
FMGROUP group FAR_HDR,	FAR_MSG,  FAR_PAD,  FAR_EPAD

public	__acrtmsg		
__acrtmsg=	9876h		

;
;	Far Messages. Get the message text from the include file
;
FAR_MSG SEGMENT

	PUBLIC	b$messages	;a public to force inclusion of messages
b$messages label byte

RTEDEF	MACRO	code,label,number,text	;; just want the C startup messages
	ENDM				;; for QB5

RCEDEF	MACRO	code,label,number,text	;
	IFNB	<text>		;; Be sure text is to be generated
	IFNB	<number>	;; Be sure number is to be generated
	DW	number		;;message number
	ENDIF			;
	DB	text		;;message text
	DB	0		;;null terminator
	ENDIF			;
	ENDM


	INCLUDE messages.inc

FAR_MSG ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\mid.asm ===
TITLE	MID - Left-hand MID$
	PAGE	56,132
;***
; MID - Left-hand MID$
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - MID$ Statement:
;
;      MID$(v$,n[,m]) = y$
;	|
;     B$SMID
;
;******************************************************************************
	INCLUDE switch.inc	
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	ST_TEXT 	; String package

	INCLUDE seg.inc 	; define segments

assumes CS,ST_TEXT		
sBegin	ST_TEXT 		

	externNP B$STDALCTMP	
	externNP B$ERR_FC	

	SUBTTL	B$SMID - MID$ statement
	PAGE
;***
; B$SMID - MID$ statement
; void pascal B$SMID(I2 offStart, I2 maxLen, sd *psdSource, data far *pDest,
;		I2 cbDest)
;
;Function:
; Copy the source string into the destination string. Copying limited to
; present length of destination.
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Inputs:
; pDest 	= destination far address
; cbDest	= length of destination, if fixed length string.
; psdSource	= source string descriptor
; maxLen	= maximum string length to copy
; offStart	= starting offset in the destination string
;
;Outputs:
; None.
;
;Uses:
; Per convention.
;
;Exceptions:
; B$ERR_FC - Invalid params
;
;******************************************************************************
cProc	B$SMID,<PUBLIC,FAR>,<ES,SI,DI> 
parmD	pDest			; destination string descriptor
parmW	cbDest			; length of the destination
parmW	psdSource		; source string descriptor
parmW	maxLen			; Maximum length to copy
parmW	offStart		; starting offset in destination string
cBegin				
	MOV	CX,offStart	;get starting offset in dest string
	DEC	CX		;offset starts at 0, not 1
	JL	ARGERR		;Must be greater than zero

	MOV	AX,maxLen	;get max length to copy
	OR	AX,AX		;Test for valid length
	JL	ARGERR		;Must be zero or more

	LES	DI,pDest	; [ES:DI] = pointer to destination
	MOV	DX,cbDest	; [DX] = length thereof
	OR	DX,DX		; see if fixed or variable length string
	JNZ	SMID_5		; Jump if fixed length
	MOV	DX,[DI] 	; [DX] = length of variable length string
	MOV	DI,[DI+2]	; [DI] = pointer to (ES assumed already DS)
SMID_5: 			

	CMP	CX,DX		; compare offset to current length of string
	JAE	ARGERR		;Offset must not exceed string size
	ADD	DI,CX		;Add in offset
	SUB	CX,DX		; [CX] = offset - length
	NEG	CX		;Length - Offset
	CMP	CX,AX		;Take minimum of this and count parameter
	JB	MIN1
	MOV	CX,AX		;Count parameter was lower
MIN1:
	MOV	BX,psdSource	;Get source where we can address with it
	CMP	CX,[BX] 	;Compare current move length to string length
	JBE	MIN2
	MOV	CX,[BX] 	;Source string was smaller
MIN2:
	MOV	SI,[BX+2]	;Get pointer to source data
	REP	MOVSB		;Must use bytes for case when source = dest
	CALL	B$STDALCTMP	;Delete source if temp string
cEnd				

ARGERR:
	JMP	B$ERR_FC	;Illegal function call

sEnd	ST_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llscreen.asm ===
TITLE	LLSCREEN - Screen Statement Interface
;***
;LLSCREEN - Screen Statement Interface
;
; Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
; This module contains B$SCRSTT, the screen statement support routine.
;
;*****************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	USESEG	_DATA
	USESEG	_BSS
	USESEG	GR_TEXT
	USESEG	RT_TEXT

	INCLUDE seg.inc
	INCLUDE ibmunv.inc

sBegin	_BSS
; Warning!!!  These two bytes must be contiguous!!!
staticB ModeSpec,,1		;Set = 1 iff Mode/burst specified in SCREEN
staticB PageSpec,,1		; Set iff Act/Vis page specified in SCREEN
; Warning!!!  These two bytes must be contiguous!!!

staticB OldBiosMode,,1		;old BIOS mode

externW b$AlphaDim
externB b$BiosMode
externW b$CurPages
externB b$MaxPage
externW b$ModeBurst
externW b$OldScrnBurst		;old Screen Mode and burst
externB b$ScreenMode
externB b$ScrHeight
externB b$ScrWidth
externW b$SetMode
externW b$SetPages

externW b$PalReset
externB b$CurEquip		
sEnd

sBegin	_DATA
externW b$CURSOR		; current cursor location
sEnd

sBegin	RT_TEXT
externNP B$FixTextPage		
externNP B$ChkMonitor		; set VGA monitor type
sEnd

sBegin	GR_TEXT
assumes CS,GR_TEXT

externNP B$GETCSRDATA
externNP B$GetParm
externNP B$SCINIT
externNP B$SCNCLR
externNP B$SCNLOC
externNP B$SCNSWI
externNP B$ScreenN
externNP B$OFFCSR		

externNP B$SetAdapter

;***
;B$SCRSTT - SCREEN Statement parsing and execution support
;OEM-interface routine
;
;Purpose:
;	This routine provides mode-independent support for the SCREEN
;	statement.
;
;Syntax:
;	The syntax of the IBM screen statement is:
;
;		SCREEN [mode] [,[burst] [,[apage] [,vpage]]]
;
;	The semantics of the statement are as follows:
;
;	mode  = requested BASIC screen mode
;
;	burst = 0 - request black and white screen (configuration dependent)
;		x - request color screen
;
;	apage = desired active display page
;
;	vpage = requests visual page to display
;
;	These values are interpreted only in this routine, so
;	an alternate set of semantics can easily be assigned.
;
;Algorithm:
;	Each mode is supported in a mode-dependent module whose only
;	PUBLIC symbols are of the form "B$ScreenX", where X is the
;	BASIC screen mode.  B$SCRSTT calls these routines to set up
;	mode-dependent data and function vectors to be used later by
;	various higher-level functions in as mode-independent a manner
;	as possible.
;
;	This routine must also do the following:
;	1.) If delayed screen initialization is being supported,
;	    B$SCNINIT must be called before any changes.
;	2.) lets BASIC know new screen dimensions via B$SCNSWI
;	3.) Home cursors and clear screen via B$SCNCLR
;	    (must be done after #2 and after all screen state variables
;	     have been set)
;	4.) Set the default foreground and background colors.
;	5.) (OS/2 only) Clear the screen by calling B$CLRSCN with
;	    a parameter of 0.
;
;Entry:
;	[SI] = address of the high end of the parameter list
;	       (parameters run from high to low memory)
;	[CX] = count of words in parameter list
;	(uses B$GetParm to get parameters)
;
;Exit:
;	PSW.C = set indicates that an error was encountered
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;****

cProc	B$SCRSTT,<PUBLIC,NEAR>	;NOTE: B$SCRSTT and B$WIDTH share a common
				;      exit at ErrorRestore
cBegin

	CALL	B$SCINIT	;init screen if not already done
	XOR	AX,AX
	MOV	WORD PTR ModeSpec,AX ; assume mode for screen not specified

;	Check to see if the user has executed a POKE statement to change
;	the equipment list.

;	NOTE: This could be better done through the POKE filter.

	PUSH	DS		;look at equipment flag in low memory
	MOV	DS,AX		;(located at 0:410) to see whether user
	MOV	AL,DS:[BiosEquip] ;has POKEd a new value to toggle monitors
	POP	DS
	CMP	AL,b$CurEquip	;this compares with previous setting
	JZ	SCREN0		;BRIF no change; continue
	MOV	b$CurEquip,AL	;otherwise update BASIC's current equip
	CALL	B$SetAdapter	;check out new hardware
SCREN0:
;
; Start of new parameter parsing
; For BASICA compatibility, if the mode is specified, the default burst is not
; the present one, but 1 for screen mode 0, 0 for screen modes 1 and above.
; This always sets the color burst on for modes 0 & 1 and ignores the burst of
; rmodes 2 and above. The following table gives the logic coded below:
;
; --------------  --------------- -----------
; Mode specified  Burst specified Value in BH
; --------------  --------------- -----------
; Yes		  Yes		  Specified Burst
; Yes		  No		  BH = 1/0 for text/mode 1
; No		  Yes		  Specified Burst
; No		  No		  Old burst value
;
	JCXZ	ScrError	;Error if no args passed
	cCALL	B$GetParm	;Get first parameter - mode value
	mov	bx,b$ModeBurst	;get old BIOS mode and burst
	mov	OldBiosMode,bl	;save old BIOS mode for later
	mov	bl,b$ScreenMode ;Get old screen mode
	mov	b$OldScrnBurst,bx ;save old values for later
	MOV	DX,b$CurPages
	JZ	GET_BURST	;Brif no mode specified
	MOV	ModeSpec,1	;Mode was specified
	OR	AL,AL		; graphics mode?  (AH = 0 after B$GetParm)
	JNZ	NO_BURST	; brif so -- default to zero burst
	INC	AH		; burst defaults to 1 if text
NO_BURST:			
	XCHG	BX,AX		;BX = BURST:MODE
GET_BURST:
	cCALL	B$GetParm	;See if burst is also specified
	JZ	GET_APAGE	;Brif not
	MOV	ModeSpec,1	;Mode was specified
	NEG	AL		;PSW.C = AL==0?0:1
	rcl	bh,1		;carry to LSB of BH
GET_APAGE:
	AND	BH,01		;Retain only LSB of burst
	cCALL	B$GetParm	;Check if active-page given
	JZ	GET_VPAGE	;Brif not
	INC	PageSpec	; pages were specified
	XCHG	AX,DX		;DL = Active-page
	MOV	DH,DL		;DH = default visual-page
GET_VPAGE:
	cCALL	B$GetParm	;Check if visual-page specified
	JZ	CHECK_REST	;Brif not
	INC	PageSpec	; pages were specified
	MOV	DH,AL		;DH = visual-page
CHECK_REST:			;At this point CX should be zero
	JCXZ	PROCESS_SCRSTT	;No more arguments - all is well
ScrError:
	jmp	SCREEN_ERROR	;exit w/error if not

PROCESS_SCRSTT:
	xchg	ax,bx		;ax = new BURST:MODE
;
;at this point:
;	AL = new Mode
;	AH = new Burst
;	DL = new Active-page
;	DH = new Video-page
;
; To be compatible with QB, let us first check if any of the input parameters
; changed. This needs to be done only if the caller is not WIDTH statement
; (where at least the screen height would have changed).
;
	cmp	b$CurPages,dx	; Apage/Vpage changed?
	jne	SCRSTT_CONT	;go if so
	cmp	b$OldScrnBurst,ax ; Mode/Burst changed?
	je	SCRSTT_RETURN	;go if not - simply exit
	cmp	PageSpec,0	; were pages specified?
	jnz	SCRSTT_CONT	; brif so - use specified pages
	xor	dx,dx		; else use page zero in new mode
SCRSTT_CONT:
;
; Now for establishing the new mode. But one problem: We want to error check
; the new active and visual pages before we set the new mode. But we can't
; determine valid ranges in a mode-independent way until the mode has been
; established. To do that, b$ScreenX and b$AlphaDim function vectors only set
; up the mode-dependent data and make no actual screen changes. Then we can
; verify the page ranges and, if valid, set the mode via the b$SetMode function
; vector. If invalid, we must restore the old mode data again and exit with an
; error.
;
	push	ax		
	push	dx		
	mov	dx,b$CURSOR	; turn cursor off at present location, in
	call	B$OFFCSR	; order to physically move the cursor prior
				; to possibly changing pages
	pop	dx		
	pop	ax		
	mov	cl,b$ScrWidth	;Get current width of the screen
	mov	ch,b$ScrHeight	;  and height
	call	B$ScreenN	;invoke screen AL to set mode-dependent data
	jc	SCREEN_ERROR	;go if error, (nothing was done)
	xchg	bx,cx		;width/height to BX
	push	bx		;save:	old width/height
	push	dx		;	pages
	mov	bl,b$ScrWidth	;new width is fine
	call	[b$AlphaDim]	;set text dimensions
	pop	dx
	pop	cx
	cmp	dl,b$MaxPage	;check active page range
	ja	ErrorRestore	;go if bad to restore old mode data
	cmp	dh,b$MaxPage	;check visual page range
	ja	ErrorRestore	;go if bad to restore old mode data
	push	dx		;save pages
	mov	al,b$ScrWidth
	mov	cl,b$ScrHeight
	cCALL	B$SCNSWI	;Inform Hi-Level about dimensions change
	cmp	ModeSpec,0	;SetMode only if
	je	NoSetMode	;  mode was specified
	mov	al,b$BiosMode	;and
	cmp	al,OldBiosMode	;  BIOS mode actually changed
	je	NoSetMode
	call	B$ChkMonitor	; Set VGA monitor type before setting mode
	call	[b$SetMode]	;set the actual mode
	CALL	B$SCNCLR	;setup the screen (homes user cursor)
	call	[b$PalReset]	;initialize the palette
NoSetMode:			; jump past the call to [b$PalReset]
	call	B$FixTextPage	
	pop	ax
	call	[b$SetPages]	;set current page data
	CALL	B$GETCSRDATA	;get cursor position for this page, since
				;the active page might have changed.
	CALL	B$SCNLOC	;update high-level cursor postion and turn
				;on the user cursor

SCRSTT_RETURN:
	CLC			;Indicate no error and exit
	jmp	short SCRSTT_EXIT

ErrorRestore:			;restore old screen mode data and return w/error
	mov	ax,b$OldScrnBurst
	call	B$ScreenN	;reset mode-dependent data
	xchg	bx,cx		;width/height to BX
	call	[b$AlphaDim]	;reset text dimensions
	call	B$FixTextPage	

SCREEN_ERROR:			;indicate error and exit
	STC
SCRSTT_EXIT:
cEnd

sEnd

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\lltext.asm ===
TITLE		LLTEXT - text screen mode support
;***
;LLTEXT - text screen mode support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Support for text screen modes (BIOS 0,1,2,3,7).
;	Note that this module module contains support
;	code for all adapters capable of handling these
;	screen modes and also attempts to compensate for
;	the subtle differences in their treatment.
;
;	This module sets hooks in the mode-independent
;	modules to routines here for mode-dependent
;	graphics support.  See the mode-independent
;	modules for more precise descriptions of the
;	purposes and interfaces of these routines.
;
;	The following table summarizes the information for
;	the modes and configurations covered:
;
;    C		  |	A			     B
;    O		  |  B	T			     I
;    L		  |  I	T		 P	     T
;    O	     A	M |  O	R		 A    C      S
;  S R	     D	O |  S	I    C		 G    H      / P
;  C B	     A	N |	B    O		 E    A   P  P L
;  R U	C  R P	I |  M	U    L	 X   Y	 S    R   A  I A
;  E R	O  O T	T |  O	T    O	 R   R	 I    B   G  X N
;  E S	L  W E	O |  D	E    R	 E   E	 Z    O   E  E E
;  N T	S  S R	R |  E	S    S	 S   S	 E    X   S  L S
; -- - -- -- - -- | -- --- ---- --- --- --- ---- --- - -
;  0 0 40 25 C	x |  0	16  N/A 320 200   2 8x8   8
;  0 x 40 25 m	x |  "   "   "  320 400   " 8x16  "
;  0 0 40 25 E	C |  "   "  16	320 200   " 8x8   "
;  0 x 40 25 E	E |  "   "  64	320 350   " 8x14  "
;  0 x 40 25 V	x |  "   "   "  360 400   " 9x16  "
;  0 x 40 43 E	E |  "   "   "  320 350   4 8x8   "	(4 pgs w/64K)
;  0 x 40 43 V	x |  "   "   "  320 350   " 8x8   "
;  0 x 40 50 V	x |  "   "   "  320 400   8 8x8   4
;  0 1 40 25 C	x |  1	 "  N/A 320 200   2 8x8   8
;  0 1 40 25 E	C |  "   "  16	320 200   " 8x8   "
;  0 0 80 25 C	x |  2	 "  N/A 640 200   4 8x8   4
;  0 x 80 25 m	x |  "   "   "  640 400   " 8x16  8
;  0 0 80 25 E	C |  "   "  16	640 200   " 8x8   "	(4 pgs w/64K)
;  0 x 80 25 E	E |  "   "  64	640 350   " 8x14  "	(4 pgs w/64K)
;  0 x 80 25 V	x |  "   "   "  720 400   " 9x16  "
;  0 x 80 43 E	E |  "   "   "  640 350   8 8x8   4     (2 pgs w/64K)
;  0 x 80 43 V	x |  "   "   "  640 350   " 8x8   "
;  0 x 80 50 V	x |  "   "   "  640 400   " 8x8   "
;  0 1 80 25 C	x |  3	 "  N/A 640 200   4 8x8   "
;  0 1 80 25 E	C |  "   "  16	640 200   " 8x8   8     (4 pgs w/64K)
;  0 x 80 25 M	M |  7	 "   3  720 350   " 9x14  1
;  0 x 80 25 E	M |  "   "   "  720 350   " 9x14  8	(4 pgs w/64K)
;  0 x 80 25 V	x |  "   "   "  720 400   " 9x16  "
;  0 x 80 43 E	M |  "   "   "  720 350   8 8x8   4     (2 pgs w/64K)
;  0 x 80 43 V	x |  "   "   "  720 350   " 8x8   "
;  0 x 80 50 V	x |  "   "   "  720 400   " 8x8   "
;
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_BSS
	USESEG	_DATA		
	USESEG	GR_TEXT
	USESEG	CN_TEXT

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE llgrp.inc	; Constant definitions
	INCLUDE grmac.inc	;ModeData macros
	INCLUDE oscalls.inc	;Dos 5 structures



sBegin	_DATA			
externW b$UsrCsrTyp		
externB b$InsCsrStop		
sEnd	_DATA			

sBegin	_BSS
;
; ***************************************************************************
; External variables
; ***************************************************************************
;
externB b$BiosMode
externW b$ModeBurst
externW b$CurPages
externB b$ScreenMode
externB b$ScrWidth
externD b$InitPalette		
externB b$MaxAttr
externB b$MaxColor
globalW b$PageTable,,8		;Offset to start of each video page
externB b$OrgBiosMode
externB b$Monitor
externB b$Adapter
externW b$VideoMem
externB b$PageSize
externB b$MaxPage
externB b$ScrHeight
externB b$ForeColor
externW b$FBColors
externB b$CharColor
externW b$CurrPSize
externB b$NullColor		
externW b$DSP
externW b$CURSOR		
externW b$CSRTYP		
;
; ***************************************************************************
; Local variables
; ***************************************************************************
;
externB b$BorderColor		;border color (overscan)
sEnd	_BSS

sBegin	CN_TEXT
externNP B$USRCSR		
sEnd	CN_TEXT

assumes CS,GR_TEXT
sBegin	GR_TEXT

externNP B$InitModeData
externNP B$GetParm
externNP B$EgaPalReset
externNP B$EgaPalResetB	
externNP B$EgaPalPut
externNP B$EgaPalPutB		
externNP B$EgaPalTrans
externNP B$EgaPalSet
externNP b$ColorPalette	
externNP b$EnhPalette		

;
; PAGE SIZES for each screen dimension possibility:
;
; These are calculated here as the BIOS initializes them (for the 25-line
; cases), or as it calculates them (for the 43/50-line cases).	The added
; "slop" separates the pages and apparently eases scrolling troubles
; while increasing our troubles.
;
; NOTE: 4 pages of 80x50 is 8100H bytes, 100H over the 8000H max for the
;	memory map, but 100H is the 256 byte slop between pages, so its OK.
;	BUT, 8 pages of 40x50 is 8500H which is more than the slop will
;	allow so we cut the supported pages in half to 4 in the code.
;	(40x50 could actually support 7 pages, but 4 is a nicer number??)
;

P40x25	EQU	((40*25*2+255) AND (NOT 255)) SHR 4	;0800H bytes
P80x25	EQU	((80*25*2+255) AND (NOT 255)) SHR 4	;1000H bytes
P40x43	EQU	(40*43*2+256) SHR 4			;0E70H bytes
P80x43	EQU	(80*43*2+256) SHR 4			;1BE0H bytes
P40x50	EQU	(40*50*2+256) SHR 4			;10A0H bytes [4]
P80x50	EQU	(80*50*2+256) SHR 4			;2040H bytes [4]

;===========================================================================
mModeData	Mode0Data
;
; SCREEN 0, BIOS modes 0 & 1
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	0
mBiosMode	0		;BIOS mode and burst may be adjusted later
mBurst		0
mScrWidth	40
mScrHeight	25
mHorzRes	320
mVertRes	200
mVideoBase	0B800H
mMaxAttr	15
mMaxColor	63
mPageSize	2		;page size in K
mCurrPSize	P40x25		;page size in paragraphs (1 plane)
mMaxPage	7
mNullColor	7
mForeColor	7
mBackColor	0
mEgaWrMd	0
mInitPalette	b$ColorPalette ;moved to LLXGASUP for sharing
mInitVgaPal	b$VgaPalette	;use regular VGA palette
mAlphaDim	AlphaDim0
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$EgaPalReset
mPalPut 	B$EgaPalPut
mPalTrans	B$EgaPalTrans
mPalSet 	B$EgaPalSet
mSetColor	SetColor
mEnd		,TextDataLen
;===========================================================================

;===========================================================================
mModeData	Mode2Data
;
; SCREEN 0, BIOS modes 2 & 3
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	0
mBiosMode	2		;BIOS mode and burst may be adjusted later
mBurst		0
mScrWidth	80
mScrHeight	25
mHorzRes	640
mVertRes	200
mVideoBase	0B800H
mMaxAttr	15
mMaxColor	63
mPageSize	4		;page size in K
mCurrPSize	P80x25		;page size in paragraphs (1 plane)
mMaxPage	3
mNullColor	7
mForeColor	7
mBackColor	0
mEgaWrMd	0
mInitPalette	b$ColorPalette ;moved to LLXGASUP for sharing
mInitVgaPal	b$VgaPalette	;use regular VGA palette
mAlphaDim	AlphaDim2
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$EgaPalReset
mPalPut 	B$EgaPalPut
mPalTrans	B$EgaPalTrans
mPalSet 	B$EgaPalSet
mSetColor	SetColor
mEnd		,TextDataLen
;===========================================================================

;===========================================================================
mModeData	Mode7Data
;
; SCREEN 0, BIOS mode 7
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	0
mBiosMode	7
mBurst		0
mScrWidth	80
mScrHeight	25
mHorzRes	720
mVertRes	350
mVideoBase	0B000H
mMaxAttr	15
mMaxColor	2
mPageSize	4		;page size in K
mCurrPSize	P80x25		;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	7
mForeColor	7
mBackColor	0
mEgaWrMd	0
mInitPalette	MonoPalette
mInitVgaPal	0		;not applicable
mAlphaDim	AlphaDim7
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$EgaPalResetB
mPalPut 	B$EgaPalPutB
mPalTrans	PalTrans7
mPalSet 	B$EgaPalSet
mSetColor	SetColor
mEnd		,TextDataLen
;===========================================================================

;
; MonoPalette - used to initialize the EGA palette for SCREEN 0,
;		BIOS mode 7, for a Mono Display.
;
labelB	MonoPalette		;EGA palette for Mono Display, mode 7
	DB	0		;black
	DB	7 DUP (001000B) ;video
	DB	0		;black
	DB	7 DUP (011000B) ;intensified

;*** 
; B$Screen0
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 0.
;	NOTE:  No actual change in screen mode occurs until SetMode is called!
;Entry:
;	AL = screen mode (0)
;	AH = burst (0 or 1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen0,<PUBLIC,NEAR>
cBegin
	mov	bx,GR_TEXTOFFSET Mode7Data
	mov	al,7		;assume mono mode
	test	b$Monitor,Monochrome ;is this a monochrome monitor?
	jnz	Scr7		;go if so
	cmp	b$Monitor,AnalogMono ; VGA working only in MONO modes?
	je	Scr7		; go if so
	and	al,b$OrgBiosMode;get entry bios mode and mask down to 3 bits
	cmp	al,7		;if AL=7 then entry mode was 7 or F (both mono)
	je	Scr7		;branch if entry mode was mono.  use mode 7
	xor	al,al		;mode base = 0
	mov	bx,GR_TEXTOFFSET Mode0Data
	cmp	cl,40		;40 columns?
	je	Got40		;go if so w/mode base = 0
	mov	bx,GR_TEXTOFFSET Mode2Data
	mov	al,2		;mode base = 2
Got40:
	add	al,ah		;new BIOS mode = 0/2 if no burst
				;		 1/3 if burst
Scr7:
	mov	cx,TextDataLen	
	push	ax
	call	B$InitModeData ;initialize table data
	pop	ax
	mov	b$ModeBurst,ax ;save new mode and burst
	test	b$Adapter,CGA + MDPA + HGC  ;CGA or MDPA or HGC adapters?
	jnz	SkipPage	;go if so
	mov	ah,7		;8 (max=7) pages for EGA/VGA/MCGA w/25 lines
	test	b$Adapter,EGA	; EGA adapter?
	jz	MaxPg		; brif not, 8 pages is right
	cmp	b$VideoMem,64	; only 64K EGA?
	ja	MaxPg		; go if more, 8 pages is right
	cmp	al,1		;BIOS mode 0 or 1? (40 columns)
	jbe	MaxPg		;go if so, 8 pages is right
	shr	ah,1		;limit to 4 pages (max=3) if 64K EGA & 80x25
MaxPg:
	mov	b$MaxPage,ah	;save corrected max page value
	test	b$Monitor,StdColor ;std color monitor?
	jz	SkipPage	;go if not
	mov	b$MaxColor,15	;it can only handle 16 colors
SkipPage:
	cmp	al,7		;BIOS mode 7?
	jz	ScrExit 	;if mono, don't setup enhanced palette
	test	b$Monitor,AnalogColor + AnalogMono + EnhColor
				;enhanced or analog monitor?
	jz	ScrExit 	;go if not
	;set up enhanced palette for >= enhanced color monitor
	mov	WORD PTR b$InitPalette,GR_TEXTOFFSET b$EnhPalette 
ScrExit:
	mov	al,b$ForeColor ;set character color for text mode
	mov	b$CharColor,al
	mov	b$DSP,770H	;text mode function key attributes
	clc			;indicate no error
cEnd


;***
; AlphaDim0
;
;Purpose:
;	Validate the proposed text dimensions for 40 column Screen mode 0
;	and set up several screen-dependent variables if dimensions are OK.
;Entry:
;	BH = number of lines
;	BL = number of columns
;Exit:
;	If dimensions ok
;	   PSW.C reset
;	   AL = -1
;	   b$MaxPage, b$BiosMode, b$VideoMem, b$CurrPSize,
;	      and b$ScrHeight set appropriately.
;	Else (error)
;	   PSW.C set
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	AlphaDim0,<NEAR>
cBegin
	mov	cl,80		;80 is "other" columns
ADim0_2:			;common entry point from AlphaDim2
	xor	al,al		;flag request for screen 0
	cmp	bl,cl		;"other" columns?
	je	ADim0Exit	;exit if so w/request to reenter screen 0
ADim0_7:			;common entry point from AlphaDim7
	cmp	bl,b$ScrWidth	;same as current?
	stc
	jne	ADim0Exit	;go if not w/error, only 80 or 40 columns
	cmp	bh,25		;25 lines?
	je	ADim0Ok 	;go if so, w/request to reenter screen 0
				;  to get back to 25 lines
	dec	al		;flag request satisfied (or error)
	test	b$Adapter,EGA + VGA ;EGA or VGA?
	stc			;set error, just in case
	jz	ADim0Exit	;go if not w/error, only 25 lines
	test	b$Monitor,StdColor ;disallow StdColor monitor for 43 lines
	stc			;set error, just in case
	jnz	ADim0Exit	;go if StdColor w/error
	cmp	bh,43		;43 lines?
	je	LinesOk 	;43 lines is ok
	test	b$Adapter,VGA	;VGA?
	stc			;set error, just in case
	jz	ADim0Exit	;exit with error if not VGA
	cmp	bh,50		;50 lines?
	stc			;set error, just in case
	jne	ADim0Exit	;exit with error if not 50 lines
	mov	cx,P40x50	;larger page size
	cmp	bl,40		;40 columns?
	je	ADim0_50	;go if so
	mov	cx,P80x50	;larger page size
	jmp	short ADim0_50	
LinesOK:			
	mov	cx,P40x43	;larger page size
	cmp	bl,40		;40 columns?
	je	ADim0_43	;go if so
	mov	cx,P80x43	;larger page size
ADim0_50:			
	mov	b$MaxPage,3	;only 4 pages in 80x43 or 80x50 or 40x50
ADim0_43:
	;64K EGA has half the pages for all text dimensions except
	;40x25, which is handled by B$Screen0 and never reaches here
	cmp	b$VideoMem,64	;only 64K?
	ja	PgOk		;go if more, MaxPage is right
	shr	b$MaxPage,1	;halve number of pages if 64K mode 7
PgOk:				

ADim0Ok:
	mov	b$ScrHeight,bh ;set alpha rows
	clc			;no error
ADim0Exit:
cEnd

;***
; AlphaDim2
;
;Purpose:
;	Validate the proposed text dimensions for 80 column Screen mode 0
;	and set up several screen-dependent variables if dimensions are OK.
;Entry:
;	BH = number of lines
;	BL = number of columns
;Exit:
;	exits through AlphaDim0
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	AlphaDim2,<NEAR>
cBegin
	mov	cl,40		;40 is "other" columns
	jmp	ADim0_2		;rest is just like mode 0 case
cEnd	<nogen>

;***
; AlphaDim7
;
;Purpose:
;	Validate the proposed text dimensions for monochrome Screen mode 0
;	and set up several screen-dependent variables if dimensions are OK.
;Entry:
;	BH = number of lines
;	BL = number of columns
;Exit:
;	exits through AlphaDim0
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	AlphaDim7,<NEAR>
cBegin
	xor	al,al		;setup for request to reenter screen 0
	jmp	ADim0_7		;rest is just like mode 0 case
cEnd	<nogen> 		


;***
; B$FixTextPage
;
;Purpose:
;	Fix up b$CurrPSize (for 43/50 lines) and initialize b$PageTable.
;
;Entry:
;	b$CurrPSize initialized to 25-line default.
;	b$ScrHeight must be initialized (call Alphadim).
;
;Exit:
;	b$CurrPSize updated.
;	b$PageTable initialized.
;
;Uses:
;	per conv.
;
;Preserves:
;	DI.
;
;******************************************************************************
cProc	B$FixTextPage,<PUBLIC,NEAR>,<DI>
cBegin
	xor	ax,ax		; get a zero
	cmp	b$ScreenMode,al	; make sure we're in text mode
	jnz	PSizeExit	; else just return
	push	es
	cmp	b$ScrHeight,25	; 25-line mode?
	je	PSizeOkay	; brif so--b$CurrPSize already set correctly

	mov	es,ax
	mov	ax,es:[CRT_LEN]	; get actual page size from BIOS, in bytes
	mov	cl,4
	shr	ax,cl		; convert to paragraphs
	mov	b$CurrPSize,ax	; and update current page size
PSizeOkay:
	mov	di,offset DGroup:b$PageTable
	mov	bx,[b$CurrPSize]	; size of page in paragraphs
	mov	cl,4
	shl	bx,cl			; convert to size in bytes
	xor	ax,ax			; first page always at offset zero
	mov	cx,8			; assume 8 pages
	push	ds
	pop	es			; es=ds
SetPageTable:
	stosw				; set offset for this page
	add	ax,bx			; compute offset of next page
	loop	SetPageTable
	pop	es
PSizeExit:
cEnd

;***
; SetMode
;
;Purpose:
;	Set screen mode according to the characteristics established
;	by previous call to B$Screenx and b$AlphaDim.  Set 8x8 character
;	font if new mode is to be 43 or 50 lines.
;Entry:
;	b$BiosMode is mode to set
;	b$ScrHeight is number of lines
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	SetMode,<NEAR>
cBegin
	test	b$Adapter,VGA + MCGA ;MCGA or VGA?
	jz	SkipScanSet	;no, don't set scan lines
	mov	ax,1202H	;assume we want 400 scan lines
	cmp	b$ScrHeight,43 ;43 lines mode?
	jne	SetScans	;no, go set to 400 scan lines
	mov	ax,1201H	;set 350 scan lines for 43 line mode
SetScans:			
	mov	bl,30H		;subfunction for set scan lines
	SCNIO			;set the scan lines
SkipScanSet:			
	mov	al,b$BiosMode	;set BIOS mode
	SCNIO	vSetMode
	cmp	b$ScrHeight,43 ;43 lines?
	je	Set8x8		;branch if so
	cmp	b$ScrHeight,50 ;50 lines?
Set8x8: 			
	jne	SetMode25	;go if not
	mov	ax,1112H	;character generator request
	xor	bl,bl		;  to load 8x8 font
	SCNIO			;  which gets 43 lines [2]or 50 lines
	MOV	AX,0707H	; cursor type for 8x8 font
	JMP	SHORT sm_1	
SetMode25:

	MOV	AX,0707H	; assume 7,7 cursor (all bios modes but 7)
	CMP	b$BiosMode,AL	; bios mode 7?  (AL = 7)
	JNE	StoreCsr	; no, use normal cursor
	MOV	AX,0C0CH	; bios mode 7 cursor is 12,12
sm_1:				
StoreCsr:			
	MOV	b$UsrCsrTyp,AX	; store cursor type
	MOV	b$UsrCsrTyp,AX	; store cursor type
	MOV	b$InsCsrStop,AL ; and make insert cursor match
	MOV	DX,b$CURSOR	; Get current cursor position
	MOV	BYTE PTR b$CSRTYP,-1 ; invalidate present cursor type so it
				; will get changed
	CALL	B$USRCSR	; display user cursor
NoStore:
cEnd

;***
; SetPages
;
;Purpose:
;	Set the current active and visual pages for text modes.
;Entry:
;	AL = active page
;	AH = visual page
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	SetPages,<NEAR>
cBegin
	mov	b$CurPages,ax	;save page numbers
	mov	al,ah
	SCNIO	vSelActivePage	;set visual page
cEnd

;***
; PalTrans7
;
;Purpose:
;	Translate a user supplied color for monochrome Screen mode 0
;	to the corresponding hardware value after verifying that the
;	attribute value and the color value are in the legal ranges.
;	    Color mapping:  0 --> 0
;			    1 --> 01000B
;			    2 --> 11000B
;Entry:
;	DX:AX = user supplied color value
;	BL    = user supplied attribute value
;Exit:
;	PSW.C set if illegal value, reset if Ok
;	DX:AX = translated color value
;	BL    = unchanged
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	PalTrans7,<NEAR>
cBegin
	cmp	bl,b$MaxAttr	;is legal attribute ?
	ja	PalTrErr	;error return
	or	dh,dl		;hi word of color 0?
	or	dh,ah		;hi byte of lo word of color 0?
	jnz	PalTrExit	;error if not
	cmp	al,b$MaxColor	;is legal color ?
	ja	PalTrErr	;error return
	cmp	al,1		;translate color
	jb	PalTrExit	;  0 ->     0
	mov	al,01000B	;  1 -> 01000B
	je	PalTrExit
	mov	al,11000B	;  2 -> 11000B
PalTrExit:
	clc			;no error
	ret
PalTrErr:
	STC			;indicate error
cEnd

;***
; SetColor
;
;Purpose:
;	Process the color statement for text modes (BASIC Screen mode 0).
;	Syntax for text mode color statement is as follows:
;
;		COLOR	[foreground],[background],[border]
;
;	where "foreground" is the attribute to be used for the foreground
;			   (0-15 are normal, 16-31 are 0-15 plus blinking)
;	  and "background" is the attribute to be used for the background
;	  and "border"	   is the color to be used for the overscan border
;
;	Any omitted parameter(s) indicate no change for that parameter.
;Entry:
;	parameter list
;		WORD 1 = flag 0 if param not present
;		WORD 2 = parameter if WORD 1 <> 0, else second param flag
;		etc.
;Exit:
;	PSW.C set if error, reset if Ok.
;	b$FBColors is set to foreground/background attributes
;	b$CharColor is set to character attribute (fg & bg in one byte)
;	b$NullColor is set to null attribute (same as character attribute)
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	SetColor,<NEAR>
cBegin
	MOV	DX,b$FBColors	;dl=ForeColor dh=BackColor
	MOV	BH,b$BorderColor
	JCXZ	SetColErr	;error if no params
	jmp	short SetCol1
SetColErr:
	stc
	jmp	SetColExit	
SetCol1:
	cCall	B$GetParm	;[AL] = parm if not psw.z
	JZ	TXTCL1		;brif no parm given
	CMP	AL,31		;is foreground color in range [0-31]?
	JA	SetColErr	;error if not
	XCHG	AL,DL		;save new foreground color
TXTCL1:
	cCall	B$GetParm	;get bkgrnd color if specified
	JZ	TXTCL2		;brif no parm given
	CMP	AL,15		;range check background color [0-15]
	JA	SetColErr	;brif out of range
	XCHG	AL,DH		;save new background color
TXTCL2:
	cCall	B$GetParm	;get border color if specified
	JZ	TXTCL3		;brif no parm given
	JCXZ	NoError
	JMP	SHORT SetColErr
NoError:
	CMP	AL,15		;range check border color [0-15]
	JA	SetColErr	;brif out of range
	XCHG	AL,BH		;save new border color
TXTCL3:
	cmp	b$BiosMode,7	;mode 7?
	jne	SetColOk	;skip if not
	test	b$Adapter,EGA	;EGA?
	jz	SetColOk	;skip if not
	;this fixes a bug in the EGA card mode 7 ???
	;if Fg=0/8/16/24 and Bg=7/15 let it go else force Bg to 0
	mov	al,dh		;BackColor
	not	al		;low 3 bits = 0 iff BackColor = 7|15
	or	al,dl		;low 3 bits = 0 iff ForeColor = 0|8|16|24
	and	al,7		;low 3 bits = 0 iff both
	jz	SetColOk
	xor	dh,dh		;in all other cases make Bg = 0
SetColOk:
	MOV	AX,DX		;get fg/bk colors in AX
	MOV	b$FBColors,AX	;new fore and back
	XCHG	DH,DL		;swap forground/background colors
	AND	DH,0FH		;strip off blink
	SHL	DL,1		;shift background intensity bit into d4
	AND	DL,10H		;leave intensity
	OR	DL,BH		;[DL] = border color + background intensity
	AND	AH,7		;strip background intensity from char attribute
	MOV	CL,4
	SHL	AH,CL		;move background color bits to d6-d4 for char
				;attribute
	TEST	AL,10H		;is blink enabled?
	JZ	NOBLNK		;br. if not
	OR	AH,80H		;add blink
NOBLNK:
	OR	AH,DH		;add foreground color
	MOV	CH,AH		;place char attribute in CH
	MOV	b$NullColor,AH ;char attribute
	MOV	b$CharColor,AH ;null attribute
	TEST	b$Monitor,AnalogColor + AnalogMono + EnhColor
				;enhanced or analog monitor?
	jnz	NO_BORDER	;Brif so

	MOV	b$BorderColor,BH;new border color
	MOV	BL,DL		;need border color in BL
	XOR	BH,BH		;zero BH
	SCNIO	vSetPalette	;set border color
NO_BORDER:
	clc			;indicate no error
SetColExit:
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\llvga.asm ===
TITLE		LLVGA - VGA screen mode support
;***
;LLVGA - VGA screen mode support
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Support for VGA graphics screen modes (BIOS 11,12,13).
;	Note that this module module contains support
;	code for all adapters capable of handling these
;	screen modes and also attempts to compensate for
;	the subtle differences in their treatment.
;
;	This module sets hooks in the mode-independent
;	modules to routines here for mode-dependent
;	graphics support.  See the mode-independent
;	modules for more precise descriptions of the
;	purposes and interfaces of these routines.
;
;	The following table summarizes the information for
;	the modes and configurations covered:
;
;    C		  |	A			     B
;    O		  |  B	T			     I
;    L		  |  I	T		 P	     T
;    O	     A	M |  O	R		 A    C      S
;  S R	     D	O |  S	I    C		 G    H      / P
;  C B	     A	N |	B    O		 E    A   P  P L
;  R U	C  R P	I |  M	U    L	 X   Y	 S    R   A  I A
;  E R	O  O T	T |  O	T    O	 R   R	 I    B   G  X N
;  E S	L  W E	O |  D	E    R	 E   E	 Z    O   E  E E
;  N T	S  S R	R |  E	S    S	 S   S	 E    X   S  L S
; -- - -- -- - -- | -- --- ---- --- --- --- ---- --- - -
; 11 x 80 30 S	x | 11	 2 256K 640 480  64 8x16  1  1 1
; 11 x 80 30 I	x |  "   "   "   "   "    "  "    "  " "
; 11 x 80 60 S	x |  "   "   "   "   "    " 8x8   "  " "
; 11 x 80 60 I	x |  "   "   "   "   "    "  "    "  " "
;
; 12 x 80 30 S	x | 12	16 256K 640 480 256 8x16  1  1 4
; 12 x 80 60 S	x |  "   "   "   "   "    " 8x8   "  " "
;
; 13 x 40 25 S	x | 13 256 256K 320 200  64 8x8   1  8 1
; 13 x 40 25 I	x |  "   "   "   "   "    "  "    "  " "
;
;******************************************************************************

	INCLUDE switch.inc	;feature switches
	INCLUDE rmacros.inc

	USESEG	_DATA
	USESEG	_BSS
	USESEG	GR_TEXT
	USESEG	CN_TEXT
	USESEG	XIB		
	USESEG	XI		
	USESEG	XIE		

	INCLUDE seg.inc
	INCLUDE ibmunv.inc
	INCLUDE baslibma.inc
	INCLUDE llgrp.inc
	INCLUDE idmac.inc
	INCLUDE grmac.inc	;ModeData macros

	INITIALIZER B$xINITVGA	;Put B$xINITVGA in initializer list

sBegin	_BSS
;
; ***************************************************************************
; External function vectors
; ***************************************************************************
;
externW b$PalTrans
;
; ***************************************************************************
; External variables
; ***************************************************************************
;
externB b$BiosMode
externB b$Adapter
externB b$Monitor
externB b$VGAmodesH		; hardware support for BIOS modes 10h-13h
externW b$CurPages
externW b$VideoBase
externB b$MaskC
externB b$AttrC
externD b$AddrC
externW b$OffC
externW b$SegC
externB b$MaxAttr
externW B$VLOFST
externW B$VROFST
externW B$LEOFST
externW B$REOFST
externB b$ForeColor
externB b$ScrHeight
externW b$PutVector
externB b$PaintBorder
externW b$Incr1
externW b$Incr2
externW b$IncrY
externB b$ForeMapped		
externW b$CURSOR		
externW b$CSRTYP		
externB b$EgaPalSup
externW b$SaveCa

externW b$UpSub 		
externW b$DnSub 		
externW b$UpDnAdd		
externW b$ScreenTab		

;
; ***************************************************************************
; Local variables
; ***************************************************************************
;
sEnd	_BSS

sBegin	CN_TEXT
externNP B$USRCSR		
sEnd	CN_TEXT

assumes CS,GR_TEXT
sBegin	GR_TEXT

externNP B$ErrorReturn
externNP B$BumpDS
externNP B$BumpES		
externNP B$InitModeData
externNP B$GetParm
externNP B$ResetEGA
externNP B$EgaPalSet
externNP B$EgaMapXYC
externNP B$EgaSetAttr
externNP B$EgaSetC
externNP B$EgaSetPixC
externNP B$EgaSetPixFirstC
externNP B$EgaLineX
externNP B$EgaLineY
externNP B$EgaLineV
externNP B$EgaNSetC
externNP B$EgaDownC
externNP B$EgaLeftC
externNP B$EgaLeftC_13
externNP B$EgaChkUpC
externNP B$EgaReadC
externNP B$EgaPutAction
externNP B$EgaNReadL
externNP B$EgaNWriteL
externNP B$EgaPaintBound
externNP B$EgaPaintBound_11
externNP B$EgaSetTile
externNP B$EgaScanL
externNP B$EgaScanR
externNP B$EgaUpC
externNP B$EgaChkDownC
externNP B$CgaSetC
externNP B$CgaSetAttr
externNP B$CgaSetPixC
externNP B$CgaSetPixFirstC
externNP B$CgaSetPixLastC
externNP B$CgaNSetC
externNP B$CgaReadC
externNP B$CgaPutAction
externNP B$CgaNReadL
externNP B$CgaNWriteL
externNP B$CgaSetTile
externNP B$CgaScanL
externNP B$CgaScanR
externNP B$CgaLineX
externNP B$CgaLineY
externNP B$CgaLineV

;===========================================================================
mModeData	Mode11Data
;
; SCREEN 11, BIOS mode 11
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	11
mBiosMode	11H
mBurst		0
mScrWidth	80
mScrHeight	30
mHorzRes	640
mVertRes	480
mVideoBase	0A000H
mMaxAttr	1
mMaxColor	-1		    ;maximum color  (unused for this mode)
mPageSize	64		    ;page size in K
mCurrPSize	<(64*1024) shr 4>   ;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	1
mBackColor	0
mEgaWrMd	0
mInitPalette	b$VgaPalette
mInitVgaPal	b$VgaPalette
mAlphaDim	AlphaDim_11_12
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$VgaPalReset
mPalPut 	B$VgaPalPut
mPalTrans	B$VgaPalTrans11
mPalSet 	PalSet
mSetColor	B$ErrorReturn
mForeMapped	1
mBitsPerPixel	1
mPlanes 	1
mMapXYC 	B$EgaMapXYC
mLeftC		B$EgaLeftC
mChkUpC 	B$EgaChkUpC
mUpC		B$EgaUpC
mChkDownC	B$EgaChkDownC
mDownC		B$EgaDownC
mSetAttr	B$CgaSetAttr
mReadC		B$CgaReadC
mSetC		B$CgaSetC
mSetPixC	B$CgaSetPixC
mSetPixFirstC	B$CgaSetPixFirstC
mSetPixLastC	B$CgaSetPixLastC
mLineX		B$CgaLineX
mLineY		B$CgaLineY
mLineV		B$CgaLineV
mPutAction	B$CgaPutAction
mNReadL 	B$CgaNReadL
mNWriteL	B$CgaNWriteL
mNSetC		B$CgaNSetC
mPaintBound	B$EgaPaintBound_11
mSetTile	B$CgaSetTile
mScanL		B$CgaScanL
mScanR		B$CgaScanR
mEnd		GraphDataLen
;===========================================================================

;===========================================================================
mModeData	Mode12Data
;
; SCREEN 12, BIOS mode 12
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	12
mBiosMode	12H
mBurst		0
mScrWidth	80
mScrHeight	30
mHorzRes	640
mVertRes	480
mVideoBase	0A000H
mMaxAttr	15
mMaxColor	-1			;maximum color (unused for this mode)
mPageSize	-1			;page size in K (unused for this mode)
mCurrPSize	<(256/4*1024) shr 4>	;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	15
mBackColor	0
mEgaWrMd	2
mInitPalette	b$VgaPalette
mInitVgaPal	b$VgaPalette
mAlphaDim	AlphaDim_11_12
mSetMode	SetMode
mSetPages	SetPages
mPalReset	B$VgaPalReset
mPalPut 	B$VgaPalPut
mPalTrans	PalTrans_12
mPalSet 	PalSet
mSetColor	SetColor
mForeMapped	15
mBitsPerPixel	1
mPlanes 	4
mMapXYC 	B$EgaMapXYC
mLeftC		B$EgaLeftC
mChkUpC 	B$EgaChkUpC
mUpC		B$EgaUpC
mChkDownC	B$EgaChkDownC
mDownC		B$EgaDownC
mSetAttr	B$EgaSetAttr
mReadC		B$EgaReadC
mSetC		B$EgaSetC
mSetPixC	B$EgaSetPixC
mSetPixFirstC	B$EgaSetPixFirstC
mSetPixLastC	B$ResetEGA
mLineX		B$EgaLineX
mLineY		B$EgaLineY
mLineV		B$EgaLineV
mPutAction	B$EgaPutAction
mNReadL 	B$EgaNReadL
mNWriteL	B$EgaNWriteL
mNSetC		B$EgaNSetC
mPaintBound	B$EgaPaintBound
mSetTile	B$EgaSetTile
mScanL		B$EgaScanL
mScanR		B$EgaScanR
mEnd		GraphDataLen
;===========================================================================

;===========================================================================
mModeData	Mode13Data
;
; SCREEN 13, BIOS mode 13
;
; Mode-dependent data follows to initialize the the "b$ModeData" table
; in LLCGRP.
;
;===========================================================================
mScreenMode	13
mBiosMode	13H
mBurst		0
mScrWidth	40
mScrHeight	25
mHorzRes	320
mVertRes	200
mVideoBase	0A000H
mMaxAttr	255
mMaxColor	-1		    ;maximum color (unused for this mode)
mPageSize	64		    ;page size in K
mCurrPSize	<(64*1024) shr 4>   ;page size in paragraphs (1 plane)
mMaxPage	0
mNullColor	0
mForeColor	15
mBackColor	0
mEgaWrMd	2
mInitPalette	b$VgaPalette
mInitVgaPal	b$VgaPalette
mAlphaDim	AlphaDim_13
mSetMode	SetMode
mSetPages	SetPages
mPalReset	PalReset_13
mPalPut 	B$VgaPalPut
mPalTrans	PalTrans_13
mPalSet 	PalSet
mSetColor	SetColor
mForeMapped	15
mBitsPerPixel	8
mPlanes 	1
mMapXYC 	MapXYC_13
mLeftC		B$EgaLeftC_13
mChkUpC 	B$EgaChkUpC
mUpC		B$EgaUpC
mChkDownC	B$EgaChkDownC
mDownC		B$EgaDownC
mSetAttr	SetAttr_13
mReadC		ReadC_13
mSetC		SetC_13
mSetPixC	SetPixC_13
mSetPixFirstC	B$CgaSetPixFirstC
mSetPixLastC	B$CgaSetPixLastC
mLineX		LineX_13
mLineY		LineY_13
mLineV		LineV_13
mPutAction	PutAction_13
mNReadL 	NReadL_13
mNWriteL	NWriteL_13
mNSetC		NSetC_13
mPaintBound	PaintBound_13
mSetTile	B$CgaSetTile
mScanL		ScanL_13
mScanR		ScanR_13
mEnd		GraphDataLen
;===========================================================================
;
; Mode11Palette/Mode12Palette
;   These default palettes are used in VGA modes 11H & 12H (screen 11 & 12)
;   to make the EGA palette transparent.  EGA palette entries 0-16 (includes
;   overscan) are mapped directly to the VGA palette.  Any palette
;   manipulations are then done only to the VGA palette.
;
labelB	Mode11Palette		;[24] designed to also work on certain clones
	DB	0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0 ;[24]
;
labelB	Mode12Palette		;[24]
	DB	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16	;[24]

;
; b$VgaPalette
;   is identical to that setup by the BIOS for mode 13H (screen 13).  The
;   first 17 entries happen to match what we want for modes 11H & 12H as
;   well.  This includes entry #16 which is black for overscan.
;   NOTE: It would be nice to find a way to avoid keeping such a huge
;   table around, even in CS!
;

labelB	b$VgaPalette
	;	RED GREEN BLUE
	;	--- ----- ----
	DB	00H, 00H, 00H
	DB	00H, 00H, 2AH
	DB	00H, 2AH, 00H
	DB	00H, 2AH, 2AH
	DB	2AH, 00H, 00H
	DB	2AH, 00H, 2AH
	DB	2AH, 15H, 00H
	DB	2AH, 2AH, 2AH
	DB	15H, 15H, 15H
	DB	15H, 15H, 3FH
	DB	15H, 3FH, 15H
	DB	15H, 3FH, 3FH
	DB	3FH, 15H, 15H
	DB	3FH, 15H, 3FH
	DB	3FH, 3FH, 15H
	DB	3FH, 3FH, 3FH
	DB	00H, 00H, 00H
	DB	05H, 05H, 05H
	DB	08H, 08H, 08H
	DB	0BH, 0BH, 0BH
	DB	0EH, 0EH, 0EH
	DB	11H, 11H, 11H
	DB	14H, 14H, 14H
	DB	18H, 18H, 18H
	DB	1CH, 1CH, 1CH
	DB	20H, 20H, 20H
	DB	24H, 24H, 24H
	DB	28H, 28H, 28H
	DB	2DH, 2DH, 2DH
	DB	32H, 32H, 32H
	DB	38H, 38H, 38H
	DB	3FH, 3FH, 3FH
	DB	00H, 00H, 3FH
	DB	10H, 00H, 3FH
	DB	1FH, 00H, 3FH
	DB	2FH, 00H, 3FH
	DB	3FH, 00H, 3FH
	DB	3FH, 00H, 2FH
	DB	3FH, 00H, 1FH
	DB	3FH, 00H, 10H
	DB	3FH, 00H, 00H
	DB	3FH, 10H, 00H
	DB	3FH, 1FH, 00H
	DB	3FH, 2FH, 00H
	DB	3FH, 3FH, 00H
	DB	2FH, 3FH, 00H
	DB	1FH, 3FH, 00H
	DB	10H, 3FH, 00H
	DB	00H, 3FH, 00H
	DB	00H, 3FH, 10H
	DB	00H, 3FH, 1FH
	DB	00H, 3FH, 2FH
	DB	00H, 3FH, 3FH
	DB	00H, 2FH, 3FH
	DB	00H, 1FH, 3FH
	DB	00H, 10H, 3FH
	DB	1FH, 1FH, 3FH
	DB	27H, 1FH, 3FH
	DB	2FH, 1FH, 3FH
	DB	37H, 1FH, 3FH
	DB	3FH, 1FH, 3FH
	DB	3FH, 1FH, 37H
	DB	3FH, 1FH, 2FH
	DB	3FH, 1FH, 27H
	DB	3FH, 1FH, 1FH
	DB	3FH, 27H, 1FH
	DB	3FH, 2FH, 1FH
	DB	3FH, 37H, 1FH
	DB	3FH, 3FH, 1FH
	DB	37H, 3FH, 1FH
	DB	2FH, 3FH, 1FH
	DB	27H, 3FH, 1FH
	DB	1FH, 3FH, 1FH
	DB	1FH, 3FH, 27H
	DB	1FH, 3FH, 2FH
	DB	1FH, 3FH, 37H
	DB	1FH, 3FH, 3FH
	DB	1FH, 37H, 3FH
	DB	1FH, 2FH, 3FH
	DB	1FH, 27H, 3FH
	DB	2DH, 2DH, 3FH
	DB	31H, 2DH, 3FH
	DB	36H, 2DH, 3FH
	DB	3AH, 2DH, 3FH
	DB	3FH, 2DH, 3FH
	DB	3FH, 2DH, 3AH
	DB	3FH, 2DH, 36H
	DB	3FH, 2DH, 31H
	DB	3FH, 2DH, 2DH
	DB	3FH, 31H, 2DH
	DB	3FH, 36H, 2DH
	DB	3FH, 3AH, 2DH
	DB	3FH, 3FH, 2DH
	DB	3AH, 3FH, 2DH
	DB	36H, 3FH, 2DH
	DB	31H, 3FH, 2DH
	DB	2DH, 3FH, 2DH
	DB	2DH, 3FH, 31H
	DB	2DH, 3FH, 36H
	DB	2DH, 3FH, 3AH
	DB	2DH, 3FH, 3FH
	DB	2DH, 3AH, 3FH
	DB	2DH, 36H, 3FH
	DB	2DH, 31H, 3FH
	DB	00H, 00H, 1CH
	DB	07H, 00H, 1CH
	DB	0EH, 00H, 1CH
	DB	15H, 00H, 1CH
	DB	1CH, 00H, 1CH
	DB	1CH, 00H, 15H
	DB	1CH, 00H, 0EH
	DB	1CH, 00H, 07H
	DB	1CH, 00H, 00H
	DB	1CH, 07H, 00H
	DB	1CH, 0EH, 00H
	DB	1CH, 15H, 00H
	DB	1CH, 1CH, 00H
	DB	15H, 1CH, 00H
	DB	0EH, 1CH, 00H
	DB	07H, 1CH, 00H
	DB	00H, 1CH, 00H
	DB	00H, 1CH, 07H
	DB	00H, 1CH, 0EH
	DB	00H, 1CH, 15H
	DB	00H, 1CH, 1CH
	DB	00H, 15H, 1CH
	DB	00H, 0EH, 1CH
	DB	00H, 07H, 1CH
	DB	0EH, 0EH, 1CH
	DB	11H, 0EH, 1CH
	DB	15H, 0EH, 1CH
	DB	18H, 0EH, 1CH
	DB	1CH, 0EH, 1CH
	DB	1CH, 0EH, 18H
	DB	1CH, 0EH, 15H
	DB	1CH, 0EH, 11H
	DB	1CH, 0EH, 0EH
	DB	1CH, 11H, 0EH
	DB	1CH, 15H, 0EH
	DB	1CH, 18H, 0EH
	DB	1CH, 1CH, 0EH
	DB	18H, 1CH, 0EH
	DB	15H, 1CH, 0EH
	DB	11H, 1CH, 0EH
	DB	0EH, 1CH, 0EH
	DB	0EH, 1CH, 11H
	DB	0EH, 1CH, 15H
	DB	0EH, 1CH, 18H
	DB	0EH, 1CH, 1CH
	DB	0EH, 18H, 1CH
	DB	0EH, 15H, 1CH
	DB	0EH, 11H, 1CH
	DB	14H, 14H, 1CH
	DB	16H, 14H, 1CH
	DB	18H, 14H, 1CH
	DB	1AH, 14H, 1CH
	DB	1CH, 14H, 1CH
	DB	1CH, 14H, 1AH
	DB	1CH, 14H, 18H
	DB	1CH, 14H, 16H
	DB	1CH, 14H, 14H
	DB	1CH, 16H, 14H
	DB	1CH, 18H, 14H
	DB	1CH, 1AH, 14H
	DB	1CH, 1CH, 14H
	DB	1AH, 1CH, 14H
	DB	18H, 1CH, 14H
	DB	16H, 1CH, 14H
	DB	14H, 1CH, 14H
	DB	14H, 1CH, 16H
	DB	14H, 1CH, 18H
	DB	14H, 1CH, 1AH
	DB	14H, 1CH, 1CH
	DB	14H, 1AH, 1CH
	DB	14H, 18H, 1CH
	DB	14H, 16H, 1CH
	DB	00H, 00H, 10H
	DB	04H, 00H, 10H
	DB	08H, 00H, 10H
	DB	0CH, 00H, 10H
	DB	10H, 00H, 10H
	DB	10H, 00H, 0CH
	DB	10H, 00H, 08H
	DB	10H, 00H, 04H
	DB	10H, 00H, 00H
	DB	10H, 04H, 00H
	DB	10H, 08H, 00H
	DB	10H, 0CH, 00H
	DB	10H, 10H, 00H
	DB	0CH, 10H, 00H
	DB	08H, 10H, 00H
	DB	04H, 10H, 00H
	DB	00H, 10H, 00H
	DB	00H, 10H, 04H
	DB	00H, 10H, 08H
	DB	00H, 10H, 0CH
	DB	00H, 10H, 10H
	DB	00H, 0CH, 10H
	DB	00H, 08H, 10H
	DB	00H, 04H, 10H
	DB	08H, 08H, 10H
	DB	0AH, 08H, 10H
	DB	0CH, 08H, 10H
	DB	0EH, 08H, 10H
	DB	10H, 08H, 10H
	DB	10H, 08H, 0EH
	DB	10H, 08H, 0CH
	DB	10H, 08H, 0AH
	DB	10H, 08H, 08H
	DB	10H, 0AH, 08H
	DB	10H, 0CH, 08H
	DB	10H, 0EH, 08H
	DB	10H, 10H, 08H
	DB	0EH, 10H, 08H
	DB	0CH, 10H, 08H
	DB	0AH, 10H, 08H
	DB	08H, 10H, 08H
	DB	08H, 10H, 0AH
	DB	08H, 10H, 0CH
	DB	08H, 10H, 0EH
	DB	08H, 10H, 10H
	DB	08H, 0EH, 10H
	DB	08H, 0CH, 10H
	DB	08H, 0AH, 10H
	DB	0BH, 0BH, 10H
	DB	0CH, 0BH, 10H
	DB	0DH, 0BH, 10H
	DB	0FH, 0BH, 10H
	DB	10H, 0BH, 10H
	DB	10H, 0BH, 0FH
	DB	10H, 0BH, 0DH
	DB	10H, 0BH, 0CH
	DB	10H, 0BH, 0BH
	DB	10H, 0CH, 0BH
	DB	10H, 0DH, 0BH
	DB	10H, 0FH, 0BH
	DB	10H, 10H, 0BH
	DB	0FH, 10H, 0BH
	DB	0DH, 10H, 0BH
	DB	0CH, 10H, 0BH
	DB	0BH, 10H, 0BH
	DB	0BH, 10H, 0CH
	DB	0BH, 10H, 0DH
	DB	0BH, 10H, 0FH
	DB	0BH, 10H, 10H
	DB	0BH, 0FH, 10H
	DB	0BH, 0DH, 10H
	DB	0BH, 0CH, 10H
	DB	00H, 00H, 00H
	DB	00H, 00H, 00H
	DB	00H, 00H, 00H
	DB	00H, 00H, 00H
	DB	00H, 00H, 00H
	DB	00H, 00H, 00H
	DB	00H, 00H, 00H
	DB	00H, 00H, 00H

labelNP <PUBLIC,B$VGAUSED>	

;***
; B$Screen11
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 11.
;Entry:
;	AL = screen mode (11)
;	AH = burst (0 or 1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen11,<PUBLIC,NEAR>
cBegin
	MOV	BX,GR_TEXTOFFSET Mode11Data  ;mode-specific data
	TEST	b$Monitor,AnalogColor ;must be analog supporting color
	JZ	ScrErr		;exit w/error if not
	TEST	[b$VGAmodesH],VGAmode11h ; hardware supports BIOS mode 11h? 
	JZ	ScrErr		; exit w/error if not
	;set up variables for shared CGA/HGC line code
	mov	b$UpSub,80	;subtract 80 to move up a line
	mov	b$DnSub,-80	;subtract -80 (add 80) to move down a line
	mov	b$UpDnAdd,0	;no correction necessary
	JMP	SHORT ScrCommon ;common routine
cEnd	<nogen>

;***
; B$Screen12
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 12.
;Entry:
;	AL = screen mode (12)
;	AH = burst (0 or 1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen12,<PUBLIC,NEAR>
cBegin
	MOV	BX,GR_TEXTOFFSET Mode12Data  ;mode-specific data
	TEST	b$Monitor,AnalogColor ;must be analog supporting color
	JZ	ScrErr		;exit w/error if not
;	TEST	b$Adapter,VGA	;must be VGA
	TEST	[b$VGAmodesH],VGAmode12h ; hardware supports BIOS mode 12h? 
	JZ	ScrErr		;exit w/error if not
ScrCommon:
	MOV	CX,GraphDataLen 
	CALL	B$InitModeData ;initialize table data
	CLC			;indicate no error
cEnd

;*** 
; B$Screen13
;
;Purpose:
;	Establish all relevent mode dependent data values and function
;	vectors for BASIC screen mode 13.
;Entry:
;	AL = screen mode (13)
;	AH = burst (0 or 1)
;	CL = alpha columns
;Exit:
;	PSW.C = set indicates error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$Screen13,<PUBLIC,NEAR>
cBegin
	MOV	BX,GR_TEXTOFFSET Mode13Data  ;mode-specific data
	TEST	b$Monitor,AnalogColor ;must be analog supporting color
	JZ	ScrErr		; exit w/error if not
	TEST	[b$VGAmodesH],VGAmode13h ; hardware supports BIOS mode 13h? 
	JNZ	ScrCommon	;out through common exit if ok
SCrErr:
	STC			;signal error and exit
cEnd

;***
; AlphaDim_11_12
;
;Purpose:
;	Validate the proposed text dimensions for Screen 11 or Screen 12.
;	  If 80x30 or 80x60 is requested, this mode satisfies the request
;	  else suggest screen mode 0.
;Entry:
;	BH = number of lines
;	BL = number of columns
;Exit:
;	AL = -1 if this mode satisfies the request, otherwise
;		AL is suggested screen mode to invoke for desired dimensions
;	b$ScrHeight set to value in BH if this mode satisfies request
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	AlphaDim_11_12
cProc	AlphaDim_11_12,<NEAR>
cBegin
	MOV	AL,-1		;flag request satisfied (maybe)
	CMP	BX,80+30*256	;80x30?
	JE	ADimSet 	;exit if so, standard stuff
	CMP	BX,80+60*256	;80x60?
	JE	ADimSet 	;exit if so, standard stuff
	XOR	AL,AL		;flag request for screen 0
	JMP	SHORT ADimOk	;  and exit
cEnd	<nogen>

;***
; AlphaDim_13
;
;Purpose:
;	Validate the proposed text dimensions for Screen 13.
;	If 40x25 is requested, this mode satisfies the request
;	else suggest screen mode 0.
;Entry:
;	BH = number of lines
;	BL = number of columns
;Exit:
;	AL = -1 if this mode satisfies the request, otherwise
;		AL is suggested screen mode to invoke for desired dimensions
;	b$ScrHeight set to value in BH if this mode satisfies request
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	AlphaDim_13
cProc	AlphaDim_13,<NEAR>
cBegin
	MOV	AL,-1		;flag request satisfied (maybe)
	CMP	BX,40+25*256	;40x25?
	JE	ADimSet 	;exit if so, standard stuff
	XOR	AL,AL		;flag request for screen 0
	JMP	SHORT ADimOk	;  and exit

ADimSet:
	mov	b$ScrHeight,bh ;set alpha rows
ADimOk:
	clc			;no error
cEnd

;***
; SetMode
;
;Purpose:
;	Set VGA screen mode according to the characteristics established
;	by previous call to B$Screenx and b$AlphaDim.  Set 8x8 character
;	font if new mode is to be 60 lines.
;Entry:
;	b$BiosMode is mode to set
;	b$ScrHeight is number of lines
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	SetMode,<NEAR>
cBegin
	MOV	AL,b$BiosMode	;set BIOS mode
	SCNIO	vSetMode
	CMP	b$ScrHeight,60 ;60 lines?
	JNE	NormalHeight
	MOV	DL,60		; char gen call wants # of lines in DL
	MOV	AX,1123H	;character generator request
	XOR	BL,BL		;  to load 8x8 font
	SCNIO			;  which gets 60 lines
NormalHeight:
	MOV	DX,b$CURSOR	; Get current cursor position
	MOV	BYTE PTR b$CSRTYP,-1	; invalidate present cursor type so
				; it will get changed
	CALL	B$USRCSR	; display user cursor
cEnd

;***
; SetPages
;
;Purpose:
;	Set the current active and visual pages and video segment for
;	Screen modes 11, 12, and 13.
;Entry:
;	AL = active page (will always be 0 for these modes)
;	AH = visual page (will always be 0 for these modes)
;Exit:
;	b$CurPages set to new active and visual pages
;	b$SegC set to video segment
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	SetPages,<NEAR>
cBegin
DbAssertRel	AX,E,0,GR_TEXT,<Non-zero page requested in VGA SetPages (LLVGA)>
	mov	b$CurPages,ax	;save page numbers
	mov	ax,b$VideoBase ;set video segment
	mov	b$SegC,ax
cEnd

;***
; SetColor
;Purpose:
;	Process the color statement for Bios mode 12h-13h (BASIC Screen
;	modes 12-13).  Syntax for Screen 12-13 color statement is as follows:
;
;		COLOR	[foreground]
;
;	where "foreground" is the attribute to be used for the foreground
;
;Entry:
;	parameter list
;Exit:
;	PSW.C set error, reset if Ok.
;	b$ForeColor is set to foreground attribute
;	b$ForeMapped is set to foreground attribute mapped to internal value
;
;Uses
;	per conv.
;Exceptions:
;***************************************************************************
cProc	SetColor,<NEAR>
cBegin
DbAssertRelB	b$ForeColor,E,b$ForeMapped,GR_TEXT,<b$ForeColor NE b$ForeMapped in SetColor (LLVGA)>
	cCall	B$GetParm	;AL=foreground parameter
	MOV	BH,b$ForeColor ;use old values as default
	JZ	GotFore 	;go if none supplied
	CMP	AL,b$MaxAttr	;legal attribute?
	JA	ColorError	;branch if out of range
	MOV	BH,AL		;attribute to BH
GotFore:
	MOV	b$ForeColor,BH ;save foreground values
	MOV	b$ForeMapped,BH
	CLC			;indicate no error
	JCXZ	SetColDun	;if we got all params, thats true
ColorError:
	STC			;otherwise set error
SetColDun:
cEnd

;***
; PalReset_13
;
;Purpose:
;	Reset the PALETTE to the initial, default colors for Screen 13.
;Entry:
;	None
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;	exits through B$VgaPalReset common exit
;******************************************************************************
DbPub	PalReset_13
cProc	PalReset_13,<NEAR>,<ES>
cBegin
	push	cs
	pop	es
	mov	cx,256		;set 256 color palette registers
	jmp	short PalResetCommon
cEnd	<nogen>

;***
; B$VgaPalReset
;
;Purpose:
;	Reset the PALETTE to the initial, default colors for Screen 11
;	or Screen 12.  If EGA palette is supported, initialize it to
;	be map directly to the VGA DAC so it is transparent to the user.
;Entry:
;	None
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$VgaPalReset,<NEAR>,<ES>  
cBegin
	push	cs
	pop	es
	cmp	b$EgaPalSup,0	;support for EGA PALETTE?
	jz	NoEgaPal	;go if not
	mov	al,10H		;sub-function 10H, set VGA palette entry
	mov	bx,16		;VGA palette index to be used for overscan
	xor	dx,dx		;clear color to black
	xor	cx,cx		
	SCNIO	vSetEgaPalette	;set the overscan register in VGA palette
	;if there is an EGA palette we need to make it transparent
	mov	dx,GR_TEXTOFFSET Mode11Palette
	cmp	[b$biosMode], 11h ;[16] correct bios mode for this table?
	je	PalOk		;[16] brif so
	mov	dx, GR_TEXTOFFSET Mode12Palette ;[16] else use Mode 12 table
PalOk:

	mov	al,2		;BIOS sub-function - set all palette registers
				;and the overscan register (for border color)
	SCNIO	vSetEgaPalette	;set the palette
NoEgaPal:
	mov	cx,16		;set 16 color palette registers
PalResetCommon:
	xor	bx,bx		;starting at register 0
	mov	dx,GR_TEXTOFFSET b$VgaPalette
	mov	al,12H		;BIOS sub-function - set block of VGA DAC
				;palette registers
	SCNIO	vSetEgaPalette	;set the palette
cEnd

;***
; B$VgaPalPut
;
;Purpose:
;	Change palette entry for VGA modes with translation/verification.
;	A color value of -1 indicates that the associated palette entry
;	is not to be modified.
;Entry:
;	AX = color
;	BL = attribute
;Exit:
;	PSW.C reset indicates successful operation
;		set indicates PALETTE function call error
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
cProc	B$VgaPalPut,<NEAR>	
cBegin
	cmp	ax,-1		;lo word of color == -1?
	jne	PalPut1 	;go if not, can't ignore
	cmp	dx,ax		;hi word too?
	je	PalPutExit	;exit if color == -1
PalPut1:
	call	[b$PalTrans]	;translate to external form
	jc	PalPutExit	;exit if invalid w/error
	mov	bh,dh		;bx=attribute (bh=0)
	xchg	dh,al		;dh=red
	xchg	ch,ah		;ch=green
	xchg	cl,dl		;cl=blue
	mov	al,10H		;subfunction "Set Individual Color Register"
				;  for VGA DAC color palette
	SCNIO	vSetEgaPalette	;set VGA palette entry
	clc			;no error
PalPutExit:
cEnd

;***
; B$VgaPalTrans11/PalTrans_12/PalTrans_13
;
;Purpose:
;	Verify that user supplied attribute value and color value are
;	within the legal range for Screen 12 or Screen 13, depending
;	on entry point.
;	An attribute translation is required for mode 11.
;	It somehow always maps the 1-bit pixel to palette index 0FH
;	(which is bright-white on the VGA palette).  Thus to change the
;	color for attribute 1 we must manipulate entry 0FH of the VGA
;	palette.
;	NOTE: B$VgaPalTrans11 is also used by mode 6 (SCREEN 2) in QCG
;	      with an MCGA.
;Entry:
;	DX:AX = user supplied color value
;	BL    = user supplied attribute value
;Exit:
;	PSW.C set if illegal value, reset if Ok
;	DX:AX = unchanged
;	BL    = unchanged
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************

cProc	B$VgaPalTrans11,<PUBLIC,NEAR>
cBegin
	cmp	bl,1		;is legal attribute ?
	ja	PalTrErr	;error return
	neg	bl		;leave 0 alone
	and	bl,0Fh		;0=0 1=0F
	jmp	short PalTrExit
cEnd	<nogen>

DbPub	PalTrans_12
DbPub	PalTrans_13
cProc	PalTrans_12,<NEAR>
cBegin
	cmp	bl,15		;is legal attribute ?
	ja	PalTrErr	;error return

labelNP PalTrans_13		;any byte value for mode 13 is OK!!

PalTrExit:
	test	dx,0FFC0H	;only lo 6 bits of color hi word allowed
	jnz	PalTrErr	;error return
	test	ax,0C0C0H	;only lo 6 bits of bytes in lo word allowed
	jnz	PalTrErr	;error return
	clc			;no error
	ret
PalTrErr:
	stc			;indicate error
cEnd

;***
; PalSet
;
;Purpose:
;	Set the entire VGA palette for Screens 11/12/13 from an array where
;	an element value of -1 indicates the entry should be left alone.  All
;	entries are verified before any are set.
;
;	This routine doesn't really do any of the work; it just verifies that
;	the specified array is of I4 (long integers) and then passes off to
;	B$EgaPalSet which does the actual palette setting.
;Entry:
;	AX    = size of array in elements
;	ES:SI = address of array
;	CX    = size of each array element in bytes (2 or 4)
;Exit:
;	PSW.C set if array is not I4
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	PalSet
cProc	PalSet,<NEAR>
cBegin
	cmp	cx,4		;must be array of I4 (long) words
	jne	PalTrErr	;exit if not w/error
	jmp	B$EgaPalSet	;B$EgaPalSet uses b$PalTrans and b$PalPut
				;  for generality and works for us too
cEnd	<nogen>


;NOTE: b$MaskC should be set to 0FFH and left there!!!

;***
; MapXYC_13
;
;Purpose:
;	Map given X and Y coordinates to the graphics cursor for Screen 13.
;Entry:
;	CX = X coordinate
;	DX = Y coordinate
;Exit:
;	b$OffC, b$MaskC updated
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	MapXYC_13
cProc	MapXYC_13,<NEAR>
cBegin
	mov	ax,cx		;save x
	mov	bx,dx		;multiply y by 320 to compute row displacement
	shl	dx,1		;dx=2*Y
	shl	dx,1		;dx=4*Y
	add	dx,bx		;dx=5*Y
	mov	cl,6		
	shl	dx,cl		;dx=5*Y*64=320*Y
	add	ax,dx		;add x byte offset to y row address
	mov	b$OffC,ax	;save byte offset

	;NOTE:	b$MaskC should be set to 0FFH and left there for mode 13!!!
	;	But, some higher level code uses it for generality.

	mov	b$MaskC,0FFH
cEnd

;***
; SetAttr_13
;
;Purpose:
;	Set current attribute to user-supplied value for Screen 13.
;	No error checking needs to be done because the input value is
;	a byte and the legal range for Screen 13 is 0-255.
;Entry:
;	AL = attribute to set
;Exit:
;	b$AttrC set to user-supplied attribute
;Uses:
;	per conv
;Exceptions:
;******************************************************************************
DbPub	SetAttr_13
cProc	SetAttr_13,<NEAR>
cBegin
	mov	b$AttrC,al
	clc			;exit no error
cEnd

;NOTE:	LeftC, ChkUpC, UpC, ChkDownC, DownC, SetAttr use EGA
;NOTE:	SetColor use VGA

;***
; ReadC_13
;
;Purpose:
;	Return the attribute of the pixel defined by the current
;	graphics cursor.
;Entry:
;	b$AddrC specifies pixel to read
;Exit:
;	AL = attribute of pixel
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	ReadC_13
cProc	ReadC_13,<NEAR>,<DS>
cBegin
	lds	bx,b$AddrC	;get memory address of cursor
	mov	al,[bx] 	;return with attribute in [al]
cEnd

;***
; SetC_13
;
;Purpose:
;	Set the pixel defined by the current graphics cursor to the
;	current attribute.
;Entry:
;	b$AddrC specifies pixel to set
;	b$AttrC = attribute to use
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	SetC_13
cProc	SetC_13,<NEAR>,<DS>
cBegin
	mov	al,b$AttrC	;[al] = attribute
	lds	bx,b$AddrC	;[BX] = cursor offset, [DS] = segment
	mov	[bx],al 	;set color value
cEnd

;***
; SetPixC_13
;
;Purpose:
;	Set the pixel defined by the current graphics cursor to the
;	current attribute.  This is identical to SetC_13 except that
;	this routine assumes ES is set to video segment.
;Entry:
;	ES = video segment (set up by b$SetPixFirstC)
;	b$OffC specifies pixel to set
;	b$AttrC = attribute to use
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	SetPixC_13
cProc	SetPixC_13,<NEAR>
cBegin
	mov	al,b$AttrC	;[al] = attribute
	mov	bx,b$OffC	;[BX] = cursor offset
				;[ES] = setup by SetPixFirstC
	mov	es:[bx],al	;set color value
cEnd

;NOTE:	SetPixFirstC, SetPixLastC use CGA

;***
; LineX_13
;
;Purpose:
;	Draw an X-major line for Screen 13.
;Entry:
;	AH    = color (b$AttrC)
;	AL    = bit accumulator (0)
;	BX    = major axis delta update value (Incr1)
;	CX    = point count
;	DX    = BP change for Y movement
;	SI    = delta decision value
;	DI    = line style
;	BP    = video offset
;	ES    = video segment
;	Incr2 = minor axis delta update value
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	LineX_13
cProc	LineX_13,<NEAR>
cBegin
	mov	bx,b$Incr1	;to register here

Line13Xloop:

	ROL	DI,1		;next line style bit
	JNC	Line13X2	;go if bit is 0 not to plot

	mov	es:[bp],ah	;set this pixel
Line13X2:
	OR	SI,SI		;time to move in Y (+ or 0 delta)?
	JNS	Line13X4	;go if so
	ADD	SI,BX		;update delta for X movement
	INC	BP		;go to next byte
	loop	Line13Xloop
	ret
Line13X4:
	ADD	SI,b$Incr2	;update delta for Y movement
	inc	bp		;move to next X
	add	BP,DX		;move to next Y
	loop	Line13Xloop	;go for more
cEnd

;***
; LineY_13
;
;Purpose:
;	Draw a Y-major line for Screen 13.
;Entry:
;	AH    = color (b$AttrC)
;	BX    = major axis delta update value (Incr1)
;	CX    = point count
;	DX    = BP change for Y movement (swapped with IncrY)
;	SI    = delta decision value
;	DI    = line style
;	BP    = video offset
;	ES    = video segment
;	Incr2 = minor axis delta update value
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	LineY_13
cProc	LineY_13,<NEAR>
cBegin
	mov	bx,b$Incr1	;to register here

Line13Yloop:

	ROL	DI,1		;next line style bit
	JNC	Line13Y2	 ;go if bit is 0 not to plot

	mov	es:[bp],ah	;set this pixel
Line13Y2:
	OR	SI,SI		;time to move in X (+ or 0 delta)?
	JNS	Line13Y3	;go if so
	ADD	SI,BX		;update delta for Y movement
	ADD	BP,DX		;move to next Y
	loop	Line13Yloop
	ret
Line13Y3:
	ADD	SI,b$Incr2	;update delta for X movement
	inc	bp		;move to next X
	add	BP,DX		;move to next Y
	loop	Line13Yloop	;go for more
cEnd

;***
; LineV_13
;
;Purpose:
;	Draw a vertical line for Screen 13.
;Entry:
;	AH    = color (b$AttrC)
;	CX    = point count
;	DX    = BP change for Y movement
;	SI    = IncrY = BP change for Y movement
;	DI    = line style
;	BP    = video offset
;	ES    = video segment
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	LineV_13
cProc	LineV_13,<NEAR>
cBegin
	MOV	SI,b$IncrY	;to register here

Line13Vloop:

	ROL	DI,1		;next line style bit
	JNC	Line13V2	;go if bit is 0 not to plot

	mov	es:[bp],ah	;set this pixel
Line13V2:
	ADD	BP,DX		;to next Y
	LOOP	Line13Vloop	;go for more
cEnd

labelW	PutTable_13		;Put Vectors according to put action value
	DW	PutOr_13, PutAnd_13, PutPreset_13, B$BumpDS ,PutXor_13 
	;B$BumpDS entry is signal for PSET to use faster movsb and
	;becomes the array segment bumper for NRWMove

;***
; PutAction_13
;
;Purpose:
;	Set b$PutVector to appropriate PUT action routine for Screen 13.
;	Requested action is used to index into a table of entry points.
;Entry:
;	AL = PUT action [0..4] representing (OR, AND, PRESET, PSET, XOR)
;Exit:
;	b$PutVector set to entry point of appropriate PUT action routine
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	PutAction_13
cProc	PutAction_13,<NEAR>
cBegin
	xor	ah,ah		;make word index
	shl	ax,1
	mov	bx,ax
	mov	ax,cs:PutTable_13[BX]	;get our vector
	mov	b$PutVector,ax ;save it
cEnd

	ASSUME	DS:NOTHING

;***
; NReadL_13
;
;Purpose:
;	Read a line of pixels from the screen to an array for Screen 13.
;Entry:
;	DS:SI = screen address
;	ES:DI = array address
;	BP    = count of bits (not pixels) to read
;Exit:
;	ES:DI = updated to array byte past point filled
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	NReadL_13
cProc	NReadL_13,<NEAR>
cBegin
	mov	cx,bp		;convert bit count to byte count in cx
	shr	cx,1
	shr	cx,1
	shr	cx,1

	mov	bx,GR_TEXTOFFSET B$BumpES  ;array segment bumper
	mov	dx,di		;dx = array offset
NRWMove:			
	neg	dx		;compute space remaining in array's segment
	cmp	cx,dx		;enough room?
	ja	NRdOvl		;go if not, segment will overflow
NRWNoOvl:			
    rep movsb			;move remainder
cEnd

NRdOvl: 			
	sub	cx,dx		;compute overflow count
	xchg	cx,dx		;use remaining segment space as move count
    rep movsb			;move to end of segment
	xchg	cx,dx		;use overflow count for second move
	;NOTE: only two moves are required since a MODE 13 screen is < 64K
	;	  and could only cross one segment boundary
	call	bx		;move array pointer over segment boundary
	jmp	short NRWNoOvl	

;***
; NWriteL_13
;
;Purpose:
;	Write a line of pixels from an array to the screen for Screen 13.
;Entry:
;	ES:DI = screen address
;	DS:SI = array address
;	BP    = count of bits (not pixels) to write
;Exit:
;	DS:SI = updated to array byte past point used
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	NWriteL_13
cProc	NWriteL_13,<NEAR>
cBegin
.erre	ID_SSEQDS		;assumes ss = ds
	mov	bx,ss:[b$PutVector]	;preload the put routine address
	mov	dx,si		;dx = array offset for NRWMove
	mov	cx,bp		;convert bit count to byte count in cx
	shr	cx,1
	shr	cx,1
	shr	cx,1
	cmp	bx,GR_TEXTOFFSET B$BumpDS  ;is this for PSET?
	jz	NRWMove 	;go if so
NWrLoop13:
	lodsb			;load byte from array
	or	si,si		;array pointer overflowed to next segment?
	jz	NWrOvfl2	;go if so
	jmp	bx		;put the byte
;
;The following Put routines perform the actual logical operation where
;	[AL]	= data value
;	[ES:DI] = screen address
;
;
; PutAnd_13
;
PutAnd_13:
	and	es:[di],al	;AND WITH SCREEN
	jmp	short PutEnd
;
; PutOr_13
;
PutOr_13:
	or	es:[di],al	;OR WITH SCREEN
	jmp	short PutEnd
;
; PutPreset_13
;
PutPreset_13:
	not	al		;NEGATE DATA FOR PRESET
	stosb			;set screen pixel
	jmp	short PutEnd2
;
; PutXor_13
;
PutXor_13:
	xor	es:[di],al	;XOR WITH SCREEN
PutEnd:
	inc	di
PutEnd2:
	loop	NWrLoop13
cEnd

NWrOvfl2:			
	call	B$BumpDS	;move array pointer over segment boundary
	jmp	bx		;put the byte

	ASSUME	DS:DGROUP

;***
; NSetC_13
;
;Purpose:
;	Set a horizontal line of pixels to the current attribute for
;	Screen 13.  The line starts at the current cursor position
;	and moves right.
;Entry:
;	b$AddrC specifies start pixel
;	b$AttrC specifies attribute to use
;	BX = pixel count
;Exit:
;	None
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	NSetC_13
cProc	NSetC_13,<NEAR>,<ES,DI>
cBegin
	les	di,b$AddrC	;graphics cursor address
	mov	al,b$AttrC	;al = attribute
	mov	cx,bx		;cx = pixel count
	rep	stosb		;block write full bytes
NSetExit:
cEnd

;***
; PaintBound_13
;
;Purpose:
;	Called by PAINT before painting each scan line to facilitate
;	fast viewport edge detection.  Set VIEW left and right cursor
;	addresses.
;Entry:
;	b$OffC specifies current cursor position
;Exit:
;	B$LEOFST = left edge offset
;	B$REOFST = right edge offset
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	PaintBound_13
cProc	PaintBound_13,<NEAR>
cBegin
	MOV	AX,b$OffC	 ;get cursor position

;  Compute the addr of the 1st pixel on the line by computing the
;  line number and then multiplying by BytesPerRow
;	LineNumber = INT(OffC/BytesPerRow)
;	first pixel in line = LineNumber * BytesPerRow

	xor	dx,dx
	MOV	cx,320		;LineNumber = INT(OffC/BytesPerRow)
	DIV	cx
	mov	bx,ax		;multiply y by 320 to compute row displacement
	shl	ax,1		;dx=2*Y
	shl	ax,1		;dx=4*Y
	add	ax,bx		;dx=5*Y
	mov	cl,6		
	shl	ax,cl		;dx=5*Y*64=320*Y
	mov	dx,ax

;  b$OffC addr of 1st pixel in current row is now in DX - compute boundries

	MOV	AX,B$VLOFST
	ADD	AX,DX
	MOV	B$LEOFST,AX	;Left margin= (x1,0)+b$OffC
	add	dX,B$VROFST
	MOV	B$REOFST,dx	;Right margin= (x2,0)+b$OffC
cEnd

;NOTE:	SetTile use CGA

;***
; ScanL_13
;
;Purpose:
;	For Screen 13, scan left beginning with the pixel to the left
;	of cursor, and paint pixels until:
;		(1) the viewport edge is encounteered (edge painted)
;		(2) a border pixel is encountered (border not painted)
;
;Entry:
;	b$AddrC       = pixel to right of starting pixel
;	b$PaintBorder = attribute of paint region border
;	b$AttrC       = attribute to paint
;	B$LEOFST        = left viewport edge
;Exit:
;	BX	       = number of pixels scanned
;	CL	       = 0 iff no pixels changed color
;	b$OffC        = the last non-border pixel examined/painted
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	ScanL_13
cProc	ScanL_13,<NEAR>,<DX,DI,ES>
cBegin
	les	di,b$AddrC	;di=cursor offset, es=video seg
	mov	dl,b$PaintBorder   ;dl=border attribute
	mov	dh,b$AttrC	;dh=paint attribute
	xor	cx,cx		;cx=clear already-painted-flag
	xor	bx,bx		;bx=clear paint count

;	The registers are set up and used as follows:
;	ES:DI = Video segment address (b$AddrC)
;	DL    = border attribute
;	DH    = paint attribute
;	CL    = already painted flag
;	AL    = screen byte
;	BX    = paint count

;	Scan left beginning with the pixel to the left of the cursor,
;	and paint pixels until:
;		1. edge of screen/VIEWPORT is encountered (edge painted)
;		2. a border pixel is encountered (border not painted)

SL13Loop:
	cmp	di,B$LEOFST	;are we at left viewport edge?
	je	SL13Edge	;exit if so, can't go left
	dec	di		;move left one byte
	mov	al,es:[di]	;get the screen byte
	cmp	al,dl		;screen byte == border?
	je	SL13Border	;go if border
	xor	al,dh		;AL = 0 if screen byte == paint attribute
	or	cl,al		;set the already-painted-flag
	inc	bx		;increment paint count
	jmp	short SL13Loop	;keep going
SL13Border:
	inc	di		;back up away from the border
SL13Edge:
	mov	b$OffC,di	;paint start point
	or	bx,bx		;any pixels to paint
	jz	SL13NoSet	;go if none
	push	bx		
	push	cx		
	call	NSetC_13	;paint 'em all at once (and tile)
	pop	cx		
	pop	bx		
SL13NoSet:			

;	Scan encountered a border pixel or viewport edge,
;	now exit with:
;		BX = number of pixels scanned
;		CL = 0 iff no pixels changed color

cEnd

;***
; ScanR_13
;
;Purpose:
;	For Screen 13, starting with the current pixel, search right until:
;		(1) a non-border pixel is found
;		(2) [DX] pixels have been tested
;		(3) the viewport edge is encountered
;
;	If (2) or (3) terminated the scan, exit with:
;		DX = remaining border bount = 0
;
;	If (1) terminated the scan, scan and paint non-border pixels until:
;		(1) the viewport edge is encountered (edge painted)
;		(2) a border pixel is encountered (border not painted)
;
;Entry:
;	DX	       = count of border pixels which may be skipped
;	b$AddrC       = starting pixel
;	b$PaintBorder = attribute of paint region border
;	b$AttrC       = attribute to paint
;	B$REOFST        = right viewport edge
;Exit:
;	BX	       = number of pixels painted
;			    (whether or not they changed color)
;	CL	       = 0 iff no pixels changed color
;	DX	       = remaining border pixel count
;	b$OffC        = the last non-border pixel examined/painted
;	SI, AL	       = the first non-border pixel encountered
;Uses:
;	per conv.
;Exceptions:
;******************************************************************************
DbPub	ScanR_13
cProc	ScanR_13,<NEAR>,<DI,BP,ES>
cBegin
	mov	bx,dx		;bx=skip count
	les	di,b$AddrC	;di=cursor offset, es=video seg
	mov	dl,b$PaintBorder   ;dl=border attribute
	mov	dh,b$AttrC	;dh=paint attribute
	xor	cx,cx		;cl=clear already-painted-flag

;	The registers are set up as follows:
;	ES:DI = Video segment address (b$AddrC)
;	DL = border attribute
;	DH = paint attribute
;	CL = already painted flag
;	AL = screen byte

;	Starting with the current pixel, scan right until:
;		1. [BX] pixels have been tested
;		2. edge of screen/VIEWPORT is encountered
;		3. a non-BORDER pixel is found

SR13Loop1:
	mov	al,es:[di]	;get screen byte
	cmp	al,dl		;screen byte == border?
	jnz	SR13Paint	;go if not
	dec	bx		;decrement border count
	jz	SR13NoCnt	;brif border count zero
	inc	di		;move right one pixel
	cmp	di,B$REOFST	;past viewport edge?
	jbe	SR13Loop1	;go if not, keep scanning
	dec	di		;back to edge
	xor	bx,bx		;pretend to run out of skip count
SR13NoCnt:

;	[BX] pixels have been tested, or the viewport edge encountered,
;	now exit with:
;		BX = number of pixels painted = 0
;		CL = already painted flag     = 0
;		DX = border count	      = 0

	mov	dx,bx		;return skip count = 0, and no pixels painted
	jmp	short SR13Exit	;go exit

;	Original scan encountered a non-border pixel.
;	Now scan and paint non-border pixels until:
;		1. edge of screen/VIEWPORT is encountered (edge painted)
;		2. a border pixel is encountered (border not painted)

SR13Paint:
	mov	b$SaveCa,di	;saving _bSaveCa
	mov	b$OffC,di	;set the cursor offset for paint start
	push	bx		;save border count
	xor	bx,bx		;clear paint count
SR13Loop2:
	cmp	di,B$REOFST	;past viewport edge?
	ja	SR13Edge	;go if so
	mov	al,es:[di]	;[al] = screen byte
	cmp	al,dl		;screen byte == border?
	je	SR13Border	;go if so
	XOR	al,DH		;detect any differences from paint color
	OR	cl,al		;combine with the already painted flag
	inc	bx		;increment paint count
	INC	DI		;move right by one byte
	JMP	SHORT SR13Loop2 ;keep scanning and counting
SR13Edge:
	dec	di		;back up
SR13Border:
	or	bx,bx		;any pixels to paint
	jz	SR13NoSet	;go if none
	push	bx		
	push	cx		
	call	NSetC_13	;paint 'em all at once (and tile)
	pop	cx		
	pop	bx		
SR13NoSet:			
	pop	dx		;return skip count

;	Second scan encountered a border pixel or viewport edge,
;	now exit with:
;		BX = count of pixels painted
;		     (whether or not they changed color)
;		CL = 0 iff no pixels changed color
;		DX = count of BORDER pixels searched in the first search
;		b$OffC = the last pixel examined/painted
;		SI = specifies the first non-BORDER pixel encountered

SR13Exit:
	mov	b$OffC,di	;return cursor offset
	mov	si,b$SaveCa	;returning b$SaveCa
cEnd

;***
; B$xINITVGA - initialize VGA modes
;
;Purpose:
;	Added with revision [10].
;	Put the addresses of VGA screen mode support routines into the
;	dispatch table used by the screen statement.
;
;Entry:
;	None
;Exit:
;	ScreenTab updated
;Uses:
;	None
;Exceptions:
;******************************************************************************
cProc	B$xINITVGA,<FAR,PUBLIC> 
cBegin
	MOV	WORD PTR [b$ScreenTab + (11*2) + 1],OFFSET B$Screen11
	MOV	WORD PTR [b$ScreenTab + (12*2) + 1],OFFSET B$Screen12
	MOV	WORD PTR [b$ScreenTab + (13*2) + 1],OFFSET B$Screen13
cEnd

sEnd	GR_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\mclprc.asm ===
TITLE	MCLPRC - MACRO LANGUAGE DRIVER
;***
; MCLPRC - MACRO LANGUAGE DRIVER
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************


	INCLUDE switch.inc
	INCLUDE	rmacros.inc	; Runtime Macro Definitions

	useSeg	_DATA		
	useSeg	_BSS		
	useSeg	MT_TEXT		
	useSeg	RT_TEXT		
	useSeg	NH_TEXT 	

	INCLUDE	seg.inc		
	INCLUDE	rtps.inc	
	INCLUDE string.inc	
	INCLUDE idmac.inc	

sBegin	_DATA			

	externW	B$AC		; floating-point accumulator
	externW	B$DAC		; used as aux. fp. acc.

	externW	b$pendchk	

sEnd	_DATA			

sBegin	_BSS			


	externW	B$MCLLEN	; defined in GWDATA.ASM
	externW	B$MCLPTR	; defined in GWDATA.ASM
	externW	B$MCLTAB	; defined in GWDATA.ASM
	externW	B$MCLPSD	; defined in GWDATA.ASM

	externB	b$VTYP		; defined in IODATA.ASM


sEnd	_BSS			



sBegin	RT_TEXT

	ASSUME	CS:CODE,DS:DGROUP,ES:DGROUP,SS:DGROUP ; Fix this up

;MICROSOFT GRAPHICS AND SOUND MACRO LANGUAGES
;
;MCLPRC -      Is the Basic (8086) Macro Language Driver for
;	       Music (MML) and Graphics (GML).
;
;--------- --- ---- ---- ---- -- ---------
;COPYRIGHT (C) 1982 1983 1988 BY MICROSOFT
;--------- --- ---- ---- ---- -- ---------
;
;Written by:	 M Courtney	 Microsoft
;Reorganized by: T Corbett	 Microsoft  Feb. 25, 1983
;Revised by:	 K Simonsen	 Microsoft  Jan. 12, 1988
;

	.SALL
	.RADIX	10

	externNP	B$UPCASE	

	externNP	B$ERR_FC
	externNP	B$ERR_TM
	externNP	B$ERR_OSS
	externNP	B$STDALCTMP	
	externNP	B$FRCINT

;***
;B$MACLNG
;
;Purpose:
;	Parses the Macro Text String and execute
;	commands from the Command Table (passed in [DX])
;	until the string is exhausted.	Some connectives
;	are eaten (+,-,;) and lower case converted to upper
;	case.  Signed numeric arguments are converted to
;	16 bit integer.
;
;Entry:
;	[DX] = Pointer to the Macro Command Table (CS relative).
;	[BX] = Pointer to descriptor for macro language string
;
;Exit:
;	String is parsed.
;
;Uses:
;	Per convention.
;
;****
cProc	B$MACLNG,<PUBLIC,NEAR>
cBegin
	MOV	WORD PTR B$MCLTAB,DX ;SAVE POINTER TO COMMAND TABLE
	MOV	B$AC,BX		;B$AC:=ptr to string descriptor
	PUSH	BX		; save ptr to string descriptor
	CALL	MACSCN		;scan contents of string, dispatching to
				; routines in B$MCLTAB to carry out work.
	POP	BX		; [BX] = ptr to string descriptor
	CALL	B$STDALCTMP	; compiler temp string deallocator
RET01:				; used as a NEAR RET
cEnd

;***
;MACSCN
;Purpose:
;	Parses entire Macro Text String pointed to by [B$AC].
;	Dispatches to routines for commands defined in the Command Table
;	pointed to by B$MCLTAB until string is exhausted.
;Input:
;	[B$MCLTAB] = Ptr to the Macro Command Table (CS relative).
;	BX = Ptr to string descriptor.
;Outputs:
;	[B$MCLPTR] = Ptr beyond end of string
;	[B$MCLLEN] = 0
;****
MACSCN:
	CALL	B$SETMCL 	;set B$MCLPTR, B$MCLLEN based on string
				;in FAC
MACSCL:
	CMP	[B$MCLLEN],0	;until entire string is consumed
	JE	RET01		;return if string is empty
	CALL	B$MACCMD 	;comsume and dispatch to 1 command in string
	JMP	SHORT MACSCL

;***
;B$MACCMD
;
;Purpose:
;	Parses one command in the Macro Text String pointed to by B$MCLPTR
;	which is B$MCLLEN bytes in length.
;	Dispatches to routines for commands defined in the Command Table
;	pointed to by B$MCLTAB until the string is exhausted.
;
;Entry:
;	[B$MCLTAB] = Ptr to the Macro Command Table (CS relative).
;	[B$MCLPTR] = Ptr to 1st byte of string to be interpreted (DS relative).
;	[B$MCLLEN] = Length of string to be interpreted.
;
;Exit:
;	[B$MCLPTR] = Ptr beyond command which was interpreted.
;	[B$MCLLEN] = Updated length of string (after command is consumed).
;
;Uses:
;	Per convention.
;
;****
cProc	B$MACCMD,<PUBLIC,NEAR>
cBegin
	CALL	B$FETCHR 	;GET A CHAR FROM STRING
	JZ	MSCNX		;END OF STRING - Exit
	ADD	AL,AL		;PUT CHAR * 2 INTO [CL]
	MOV	CL,AL
	MOV	BX,B$MCLTAB	;POINT TO COMMAND TABLE
MSCNLP:
	MOV	AL,BYTE PTR CS:[BX] ;GET CHAR FROM COMMAND TABLE
	ADD	AL,AL		;CHAR = CHAR * 2 (CLR HI BIT FOR CMP)
GOFCER:
	JZ	GFCERR		;END OF TABLE.
	CMP	CL,AL		;HAVE WE GOT IT?
	JZ	MISCMD		;YES - dispatch to this command's executor
	INC	BX		;MOVE TO NEXT ENTRY
	INC	BX
	INC	BX
	JMP	SHORT MSCNLP
MISCMD:
	MOV	AL,BYTE PTR CS:[BX] ;SEE IF A VALUE NEEDED
	MOV	CL,AL		;PASS GOTTEN CHAR IN [C]
	ADD	AL,AL
	JNB	MNOARG		;COMMAND DOESN'T REQUIRE ARGUMENT
	SHR	AL,1		;MAKE IT A CHAR AGAIN
	MOV	CL,AL		;PUT IN [CL]
	PUSH	CX
	PUSH	BX		;SAVE PTR INTO CMD TABLE
	CALL	B$FETCHR	;GET A CHAR
	JZ	VSNAR0		;NO ARG IF END OF STRING
	CALL	LETTER		;SEE IF POSSIBLE LETTER
	JNB	VSNARG
	CALL	SCN_WORD	; get the value
DoCmd:				
	JNC	VSNAR1		; brif none specified -- use default
	JMP	SHORT ISCMD3


VSNARG:
	CALL	B$DECFET 	;PUT CHAR BACK INTO STRING
VSNAR0:
	CLC			
VSNAR1:				
	MOV	DX,1		; DEFAULT ARG=1
ISCMD3:
	POP	BX
	POP	CX		;GET BACK COMMAND CHAR
MNOARG:
	JMP	WORD PTR CS:[BX+1] ; Dispatch to Macro command, then return
				; to B$MACCMD's caller
MSCNX:				; No command, just return to B$MACCMD's
cEnd				; caller



GFCERR:				
	JMP	B$ERR_FC	

;***
;B$MCLXEQ
;
;Purpose:
;	This routine is dispatched to by the X command in DRAW or
;	single voice PLAY statements.  It is equivalent to a
;	macro-language subroutine call, in that it specifies a
;	variable which is to be inserted in the Macro String.  It:
;	 1)  calls B$GETSTKC to make sure we haven't eaten all stack space
;	 2)  stacks the current string pointer & length,
;	 3)  sets B$MCLPTR & B$MCLLEN to point to new nested string,
;	 4)  calls MACSCN to scan and process the nested string,
;	 5)  restores B$MCLPTR & B$MCLLEN from the stack
;	 6)  returns to its caller
;	NOTE: This routine may be called recursively.
;
;Entry:
;	B$MCLPSD points to current string descriptor
;	B$MCLPTR points to next element of current string
;	B$MCLLEN = remaining length of current string
;	b$VTYP = VT_SD, else error
;	B$AC = ptr to string descripter of sub-string to parse
;
;Exit:
;	Sub-string is fully parsed.
;	B$MCLPSD and B$MCLLEN are restored.
;	B$MCLPTR is recalculated based on B$MCLPSD and B$MCLLEN.
;
;Uses:
;	Per convention.
;
;Exceptions:
;	Will generate "Out of Stack Space" error if not enough room on stack.
;
;****
cProc	B$MCLXEQ,<PUBLIC,NEAR>
cBegin
	MOV	CL,100		;MAKE SURE OF ROOM ON STACK
	CALL	B$GETSTKC
	CALL	B$SCNVAR 	;scan variable name, [B$AC] points to
				;desc.
	CMP	[b$VTYP],VT_SD	; Is this a string?
	JNZ	TYPERR		;Type mismatch error if not a string
	PUSH	B$MCLPSD	; save pointer to current string descriptor
;	PUSH	B$MCLPTR	;save pointer to current string
	PUSH	B$MCLLEN	; length of current string
	MOV	BX,OFFSET DGROUP:B$AC ;BX:= ptr to string descriptor
	PUSH	BX		; save pointer to string descriptor
	CALL	MACSCN		;scan new string pointed to by [B$AC]

	POP	BX		; restore string descriptor
	CALL	B$STDALCTMP	; deallocate temp string
	POP	B$MCLLEN	; restore parent string's length
;	POP	B$MCLPTR	;restore parent string's pointer
	POP	BX		; restore saved PSD
	MOV	B$MCLPSD,BX	; restore parent string's pointer
	MOV	CX,[BX]		; CX = string length
	ADD	CX,[BX+2]	; CX = pointer to end of string
	SUB	CX,B$MCLLEN	; CX = original B$MCLPTR offset
	MOV	B$MCLPTR,CX	; restore parent string's pointer
cEnd

TYPERR: 			;Type mismatch error
	JMP	B$ERR_TM	; Return

;***
;B$SETMCL
;
;Purpose:
;	Set B$MCLPTR and B$MCLLEN to the data pointer and length of a
;	given string. If the string data pointer is NULL (0),
;	B$MCLLEN will be set to 0.
;
;Entry:
;	BX=ptr to string descriptor
;
;Exit:
;	B$MCLPSD ptr to string descripter
;	B$MCLPTR points to start of string's data
;	B$MCLLEN = number of bytes in string
;
;Uses:
;	
;	AX, CX, DX, ES, PSW
;
;Preserves:
;	BX.
;
;****
cProc	B$SETMCL,<PUBLIC,NEAR>
cBegin
	XOR	DX,DX		; default length is zero
	MOV	CX,[BX+2]	; CX := ptr
	JCXZ	PTNOT0		; branch if null string pointer
	MOV	DX,[BX]		; DX := length
PTNOT0:
	MOV	B$MCLLEN,DX	;Save length
	MOV	B$MCLPTR,CX	;SET UP POINTER
	MOV	[B$MCLPSD],BX	; save pointer to string descripter
cEnd

;***
;B$FETCHZ
;
;Purpose:
;	Get next byte from string [B$MCLPTR, B$MCLLEN]
;
;Entry:
;	B$MCLPTR points to character to be parsed from string.
;
;Exit:
;	[AL]=byte fetched
;	B$MCLPTR incremented, B$MCLLEN decremented.
;
;Uses:
;	ES, PSW.
;
;Preserves:
;	BX.
;
;Exceptions:
;	Generates an "Illegal function call" error if end-of-string.
;
;****
cProc	B$FETCHZ,<PUBLIC,NEAR>
cBegin
	CALL	B$FETCHR 	;GET A CHAR FROM STRING
	JZ	GFCERR		;GIVE ERROR IF END OF LINE
cEnd

;***
;B$FETCHR - Get next byte from string [B$MCLPTR, B$MCLLEN]
;
;Purpose:
;	Get next byte from string [B$MCLPTR, B$MCLLEN].
;
;Entry:
;	B$MCLPTR points to character to be parsed from string.
;
;Exit:
;	[AL]=byte fetched
;	PSW.Z set if end-of-string, reset if not.
;	B$MCLPTR incremented, B$MCLLEN decremented.
;
;Uses:
;	AX, PSW.
;
;Preserves:
;	BX.
;
;****
cProc	B$FETCHR,<PUBLIC,NEAR>,<BX>
cBegin
FETCH2:
	CMP	B$MCLLEN,0	;POINT TO STRING LENGTH
	JZ	POPTRT		;RETURN TZ IF END OF STRING
	DEC	B$MCLLEN	;UPDATE COUNT FOR NEXT TIME
	MOV	BX,B$MCLPTR	;GET PTR TO STRING
	MOV	AL,BYTE PTR [BX] ;GET CHARACTER FROM STRING
	INC	B$MCLPTR
	CMP	AL,' '		; SKIP SPACES
	JZ	FETCH2
	CMP	AL,9		; Skip TAB
	JZ	FETCH2
	Call	B$UPCASE	; Convert lowercase to UPPERCASE
POPTRT:
cEnd

;***
;B$DECFET
;
;Purpose:
;	Rescind the last byte fetched from the string [B$MCLPTR, B$MCLLEN]
;	by decrementing B$MCLPTR and incrementing B$MCLLEN.
;
;Entry:
;	B$MCLPTR, B$MCLLEN valid.  B$MCLPTR must not point to start of string.
;
;Exit:
;	B$MCLPTR decremented, B$MCLLEN incremented.
;	PSW.C = 1 if CX < 5
;
;Uses:
;	PSW.
;
;****
cProc	B$DECFET,<PUBLIC,NEAR>
cBegin
	INC	B$MCLLEN	;INCREMENT LENGTH
	DEC	B$MCLPTR	;BACK UP POINTER
CRET:				
	CMP	CX,5		; for B$VALSCN, set CARRY if digit read
cEnd

;***
;B$VALSCN
;Purpose:
;	Fetch a value from the string [B$MCLPTR, B$MCLLEN]
;Entry:
;	B$MCLPTR could be pointing to an ASCII numeric constant,
;	A string generated by VARPTR$, or an ASCII variable name.
;Exit:
;	[DX] = 2's complement signed integer result
;	Generates an "Illegal function call" error if end-of-string.
;Uses:
;	Per convention.
;Exceptions:
;	Generates an "Illegal function call" error if unexpected end-of-string
;	or other unrecognized syntax.
;****
	PUBLIC	B$VALSCN
B$VALSCN:
	CALL	B$FETCHZ 	;GET FIRST CHAR OF ARGUMENT
SCN_WORD:			; temp fix
	MOV	DL,VT_I2	; want integer value
	CMP	AL,'='		;NUMERIC?
	JZ	B$VARGET
	CMP	AL,'+'		;PLUS SIGN?
	JZ	B$VALSCN 	;THEN SKIP IT
	CMP	AL,'-'		;NEGATIVE VALUE?
	JNZ	B$VALSC2 	;Brif not
	CALL	B$VALSCN 	; else eat the '-'
	NEG	DX		; and negate value before returning
SRET:
	RET
	PUBLIC	B$VALSC2
B$VALSC2:
 	MOV	[b$VTYP],VT_I2	; want I2
	XOR	DX,DX		;INITIAL VALUE OF ZERO
	MOV	CX,5		;MAXIMUM 4 DIGITS.
NUMLOP:
	CMP	AL,','
	JZ	B$DECFET 	;If comma, backup and return
	CMP	AL,';'
	JZ	CRET		; Retif semicolon
	CMP	AL,'9'		; NOW SEE IF ITS A DIGIT
	JA	B$DECFET 	; IF NOT, BACK UP AND RETURN
	CMP	AL,'0'
	JB	B$DECFET
	MOV	BX,DX		;ARG=ARG*10+DIGIT
	ADD	BX,BX		;*5
	ADD	BX,BX
	ADD	BX,DX
	ADD	BX,BX		;*5*2
	SUB	AL,'0'		;ADD IN THE DIGIT
	MOV	AH,0
	ADD	BX,AX
NUMLO2:
	XCHG	DX,BX		;VALUE SHOULD BE IN [DX]
	CALL	B$FETCHR 	;GET NEXT CHAR
	STC			
	JZ	SRET		;Done if end of string
	LOOP	NUMLOP		;If more than 4 digits, then..
	JMP	SHORT SCNFC	;Complain since too many


labelNP	<PUBLIC,B$SCNVAR>
	CALL	VARPTR		;won't return if VARPTR$ string...
SCNFC:
	JMP	B$ERR_FC	; ERROR - VARIABLE TOO LONG


;*** 
;B$VARGET - scan variable and return either I2 or R4
;
;Purpose:
;	Scan variable and return either I2 or R4.
;
;Entry:
;	B$MCLPTR points to the varptr variable embedded in the string.
;	B$MCLLEN > 2 else error.
;	DL = 4 to return R4, else return I2
;
;Exit:
;	[b$VTYP] = VT_I2 and DX = I2 or
;	[b$VTYP] = VT_R4 and B$AC = CX:DX = R4.
;	B$MCLPTR += 3.
;	B$MCLLEN -= 3.
;	PSW.C set if non-default argument was scanned
;
;Uses:
;	Per convention.
;
;Preserves:
;	SI.
;
;Exceptions:
;	Type mismatch error if STRING variable.
;
;******************************************************************************
cProc	B$VARGET,<PUBLIC,NEAR>,<SI> ; preserve SI for PLAY code
cBegin
	CALL	B$SCNVAR 	;SCAN & EVALUATE VARIABLE
	CALL	B$FRCINT 	;MAKE IT AN INTEGER
	XCHG	DX,BX		;IN [DX]
	STC			; indicate value was scanned
cEnd


;*** 
;VARPTR - parse variable from varptr string.
;
;Purpose:
;	Parse variable from varptr string.
;
;Entry:
;	B$MCLPTR points to the varptr variable embedded in the string.
;	B$MCLLEN > 2 else error.
;
;Exit:
;	Variable returned in B$FAC/B$AC.
;	B$MCLPTR += 3.
;	B$MCLLEN -= 3.
;
;Uses:
;	Per convention.
;
;Exceptions:
;	Illegal function call if not varptr string.
;
;******************************************************************************
cProc	VARPTR,<NEAR>
cBegin
	MOV	BX,[B$MCLPTR]	;Get pointer into string
	CMP	BYTE PTR [BX],9 ;If length .gt. 8 then not VARPTR$ string
	JNB	SCNFC		;must be varptr$ string; if not, issue IFC
	CMP	B$MCLLEN,3	;Must be at least 3
	JB	SCNFC		;Not enough data: issue function call error
	POP	DX		;Trash ret
	MOV	AL,[BX] 	;assume Byte 1 is Type
	MOV	[b$VTYP],AL	; store in FAC
	MOV	DX,[BX+1]	;[DX] = Var address.
	ADD	B$MCLPTR,3	;New pntr
	SUB	B$MCLLEN,3	;New Length
	JMP	SHORT B$RETVARC	; Go return value in FAC
cEnd	<nogen>

;***
;LETTER
;
;Purpose:
;	See if ASCII character in [AL] is in the range [A..Z]
;
;Entry:
;	[AL] = ASCII code
;
;Exit:
;	Carry is set if not in the range [A..Z]
;	Carry is clear if it is in the range [A..Z]
;
;Uses:
;	PSW.
;
;****
cProc	LETTER,<NEAR>
cBegin
	CMP	AL,LOW "A"
	JB	ISLETX		;TOO SMALL FOR LETTER
	CMP	AL,"Z"+1
	CMC			;SET CARRY IF NOT LETTER
ISLETX:
cEnd


;***
;B$GETSTKC	Get stack space
;
;Purpose:
;	Make sure a minimum amount of stack space is available for recursive
;	calls.
;	B$GETSTKC and GETSTK, its interpreter equivalent, are not entirely plug-
;	compatible. GETSTK checks for a minimum amount of stack space (in bytes)
;	using the following formula:
;		minimum stack space = 2*CL + 2*NUMLEV,
;		where  CL is an entry condition
;	   	and NUMLEV is a switch (=110 decimal in features.h)
;
;	B$GETSTKC checks for a minimum amount of stack space using the following
;	formula:
;
;		minimum stack space = CL
;		where CL is an entry condition
;
;	If the minimum stack space is not available GETSTK and B$GETSTKC
;	issue out of memory errors.
;
;Entry:
;	CL= number of stack bytes needed
;
;Exit:
;	CX= number of stack bytes needed
;
;Uses:
;	None.
;
;Exceptions:
;	Will generate "Out of Stack Space" error if no room on stack.
;
;****
cProc	B$GETSTKC,<PUBLIC,NEAR>	; Make sure of room on the stack
cBegin
	PUSH	BX		;Save BX
	MOV	BX,[b$pendchk] ; Stack can grow down to b$pendchk
	MOV	CH,0		;Zero out high byte of CX
	ADD	BX,CX		;Add CX to bottom of stack
;This will provide 100 bytes for one recursion:  should be more than enough
	JB	ERR_OM		;Out of memory if BX overflowed
	CMP	BX,SP		;Compare stack ptr to b$pendchk + CX
	JNB	ERR_OM		;If BX>SP issue out of memory error
	POP	BX		;Restore BX
cEnd

ERR_OM:
	JMP	B$ERR_OSS	; out of memory error routine

;***
;B$RETVARC - Return variable in accumulator (compiler version)
;
;Purpose:
;	Return variable in accumulator.  Use variable type to determine
;	how many bytes to move and where to move them.  Double precision
;	variables begin at B$DAC (an 8 byte accumulator), all others begin
;	at B$AC.  If the variable is double precision, move 8 bytes, if string
;	or single precision, move 4 bytes, if integer move 2 bytes.
;	This routine is plug-compatible with the compiler routine RETVAR.
;
;Entry:
;	DX=ptr to variable (ES:DX if FV_FARSTR)
;	AL=variable type
;
;Exit:
;	If var is integer: B$AC contains integer (2 bytes)
;	If var is s.p.	 : B$AC contains s.p. #	(4 bytes)
;	If var is d.p.	 : B$DAC contains d.p. # (8 bytes)
;	If var is string : B$AC contains string descriptor (4 bytes)
;
;Uses:
;	None.
;	(the interpreter equivalent routine, RETVAR, may modify all regs
;	except BX, and segment registers.  Its effects are not documented.)
;
;****
cProc	B$RETVARC,<PUBLIC,NEAR>,<CX,SI,DI,AX,ES> ; return var in accumulator
cBegin
	MOV	SI,DX		;Move var ptr to source index reg
	CBW			;extend var type to full word in AX
	XCHG	CX,AX		;CX:=AX (saves 1 byte over mov cx,ax)
	CMP	CL,VT_R8	; Is var double precision?
	JNE	NOTDP		;No: load DI differently
	MOV	DI,OFFSET DGROUP:B$DAC ;Use 8 byte accumulator
	JMP	SHORT MOVVAR	;go move the var to accumulator
NOTDP:				;not a double precision variable
;assume var type in CL is either 2 (integer), 3(string) or 4(single precision)
	MOV	DI,OFFSET DGROUP:B$AC ;Use 4 byte accumulator
	CMP	CL,VT_I2	; Is var integer?
	JE	MOVVAR		;Yes: CX contains correct value for string move
	MOV	CX,4		;CX:=4 (must move four bytes)
MOVVAR: 			;CX=# bytes to move, SI=source, DI=destination
				;repeat until CX=0: move a byte
	PUSH	DS		
	POP	ES		; ES = DS
	REP	MOVSB		; copy variable
cEnd

sEnd	RT_TEXT			
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\nhinit.asm ===
TITLE	NHINIT.ASM - Near Heap Initialization/Termination module
;***
;NHINIT.ASM - Near Heap  initialization/termination module
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains near heap managment initialization and termination
;	support for the BASIC 3.0 runtime.  This module will only be present
;	in a user's program when a program contains statements which need
;	dynamic memory management.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;
;	Code Segments
;
	USESEG	<INIT_CODE>	;Initialization
	USESEG	<NH_TEXT>	;Near Heap
	USESEG	<ER_TEXT>	;Error handler
	USESEG	<RT_TEXT>	;RunTime Core
	USESEG	<DV_TEXT>	

;
;	Data Segments
;
	USESEG	<_BSS>		;runtime data (uninitialized)
	USESEG	<_DATA> 	;runtime data (initialized)
	USESEG	<XIB>		; XIB and XIE must bracket XI!
	USESEG	<XI>		;initializer segment
	USESEG	<XIE>		

	INCLUDE seg.inc

	INCLUDE compvect.inc	;component vectors
	INCLUDE messages.inc	;error/message definitions.
	INCLUDE idmac.inc	; debugging macros

	INITIALIZER	B$xNHINI	;put B$xNHINI in initializer list.

	SUBTTL	Code Externals
	PAGE

sBegin	DV_TEXT 			
	externNP	B$NearRet	;for disp vectors in compvect.inc
sEnd	DV_TEXT 			

sBegin	ER_TEXT
	externNP	B$ERR_OM_NH	; Runtime Out of Memory error
	externNP	B$RUNERR	;runtime error handler
sEnd	ER_TEXT

sBegin	NH_TEXT
	externNP B$NHINIT	;routine to initialize and reset near heap.
	externNP B$NHCLEAN	; Clean local heap and string space.
	externNP B$VarHeap_CPCT ;crunches down var heap
	externNP B$LHDALC_CPCT	
	externNP B$STDALCTMP	;erprococ all string temps
	externNP B$STDALCALLTMP ;erprococ all string temps
sEnd	NH_TEXT

	PAGE
	SUBTTL	Runtime data definitions for BASIC Near Heap
sBegin	_DATA

;
;	Global Data
;
	globalW b$NH_first,0	;first word of near heap space
	globalW b$NH_last,0	;last word of near heap space

;
;	external data
;
	externW b$ini_disp	;One time initialization dispatch table
	externW b$run_disp	;RUN time initialization dispatch table
	externW b$clrt_disp	; CLEAR statement support dispatch table
	externW b$err_disp	; error dispatch table
	externW b$pSTDALCALLTMP ; indirect B$STDALCALLTMP vector
	externW b$pSTDALCTMP	; indirect B$STDALCTMP vector
	externW b$pLHDALC_CPCT	; indirect B$LHDALC_CPCT vector

	externW __atopsp	;top word allocated to stack
	externW __asizds	;top of allocated DGROUP (64K or max avail)
	externW b$HugeDelta	
	externB b$HugeShift	

sEnd	_DATA

sBegin	_BSS			
	externW b$curlevel	;defined in NHSTUTIL.ASM
sEnd	_BSS			


	SUBTTL	Runtime Near Heap  Initialization
	PAGE
assumes CS,INIT_CODE
sBegin	INIT_CODE

;***
;B$xNHINI - Near Heap	initializer
;PLM B$xNHINI()
;
;Purpose:
;	Initializer for Near Heap  component.  This routine is called
;	by the Crt0 startup before _main is called.  It will update the
;	indirect dispatch tables for the Near Heap  routines.  This
;	insures that the only time that Near Heap  is accessed is when
;	this module is linked into the user program.
;
;Entry:
;	None.
;
;Exit:
;	Appropriate dispatch vectors filled.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xNHINI,<FAR>
cBegin
;
;	update "ONE" time initialization dispatch address to B$NHINI
;
	MOV	WORD PTR [b$ini_disp].NH_IVEC,NH_TEXTOFFSET B$NHINI 

;
;	update "RUN" time initialization dispatch address to B$NHCLR
;
	MOV	WORD PTR [b$run_disp].NH_RVEC,NH_TEXTOFFSET B$NHCLR

;
;	update CLEAR statement termination dispatch address to B$NHCLR
;
	MOV	WORD PTR [b$clrt_disp].NH_CLTVEC,NH_TEXTOFFSET B$NHCLR 

;
;	update error dispatch address to B$NHERR
;
	MOV	WORD PTR [b$err_disp].XH_ERVEC,NH_TEXTOFFSET B$NHERR	

;
;	initialize /O granularity vectors
;
	MOV	[b$pSTDALCALLTMP],NH_TEXTOFFSET B$STDALCALLTMP 
	MOV	[b$pSTDALCTMP],NH_TEXTOFFSET B$STDALCTMP       
	MOV	[b$pLHDALC_CPCT],NH_TEXTOFFSET B$LHDALC_CPCT   


cEnd
sEnd	INIT_CODE	

assumes CS,NH_TEXT	
sBegin	NH_TEXT 	

;***
;B$NHINI	- One time initialization for Near Heap
;void pascal B$NHINI()
;
;Purpose:
; BC3
; ---
;	Initializes near heap manager.
;	B$NHINI does the following:
;		allocates all free space in DGROUP.
;		initializes global heap shadow variables.
;
;Entry:
;	None.
;
;Exit:
;	b$NH_first - points to first unallocated word in DGROUP.
;	b$NH_last  - points to last unallocated word in DGROUP.
;
;	Note: these variables must lie on the first byte of an eight
;	byte boundary.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;
;****
cProc	B$NHINI,<NEAR,PUBLIC>	
cBegin

	MOV	b$HugeShift,12	;Huge shift is 12 for DOS 3
	MOV	b$HugeDelta,1000H ;save seg increment for DOS 3
	MOV	CX,__atopsp	;get top of stack
	MOV	AX,__asizds	;get top of allocated DGROUP (64K or max
	AND	AL,0FEH 	;available - round down to next word
	CMP	AX,CX		;check to see if any room for heap
	JB	FATAL		;out of memory if not

;	(CX) = first available byte
;	(AX) = last available byte
	MOV	b$NH_first,CX	;Set starting offset of near heap
	MOV	b$NH_last,AX	;Set ending offset of near heap

	cCall	B$NHRST 	;only reset NH once for interp
cEnd

FATAL:
	MOV	BX,FE_MEMORY	;OUT OF MEMORY error code
	JMP	FAR PTR B$RUNERR	;fatal error - get out of town

;***
;B$NHERR - Reset the Near Heap at error time
;void pascal B$NHERR()
;
;Purpose:
; Deallocates all temp strings
;
;Entry:
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$NHERR,<NEAR>		
cBegin				
	MOV	AX,b$curlevel	;at or above current level...
	CALL	B$STDALCALLTMP ;deallocate all string temps.
cEnd				

;***
;B$NHRST - Reset the Near Heap based upon the shadow values.
;void pascal B$NHRST()
;
;Purpose:
;
;Entry:
;	b$NH_first - points to first byte of the near heap
;	b$NH_last  - points to last word of the near heap
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$NHRST,<NEAR>		
cBegin
	MOV	AX,b$NH_first	;get first word of dynamic space
	MOV	CX,b$NH_last	;get last word of dynamic space
	cCall	B$NHINIT	;Initialize Near Heap
	JNC	RESET_OK	;Was memory set up ok?
	JMP	B$ERR_OM_NH	;Issue "out of memory" error
RESET_OK:
cEnd

;***
;B$NHCLR - Clean string space and local heap
;Purpose:
;	To clean the string space and local heap of entries whose
;	descriptors are not in interpreter entries or other special areas.
;	This routine is used during the RUN init, NEW and CLEAR process.
;
;Entry:
;	None.
;Exit:
;	None.
;Modifies:
;	Per Convention.
;Exceptions:
;	None.
;
;Added as part of [7]
;****
cProc	B$NHCLR,<PUBLIC,NEAR>,ES
cBegin
	XOR	AX,AX		
	MOV	b$curlevel,AX	;set current level to main (0)
	CALL	B$STDALCALLTMP ;deallocate all string temps.
	PUSH	DS		
	POP	ES		; requires ES set
	CALL	B$NHCLEAN	; clean local heap and string space.
	CALL	B$VarHeap_CPCT	
cEnd


sEnd	NH_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\nhdebug.asm ===
TITLE   NHDEBUG - Local Heap debug utilities
;***
; NHDEBUG - Local Heap debug utilities
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;
;	Heap related debug support (heap dumpers, heap checkers, etc).
;
;******************************************************************************
	INCLUDE switch.inc

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\nhlhcore.asm ===
TITLE	NHLHCORE - Core Local Heap utilities
;***
;NHLHCORE - Core Local Heap utilities
;
; Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
; This module contains the core local heap utilities that are required to
; support /O programs which use string space and simple OPEN statements. Field
; manipulations and additional CHAIN support is elsewhere.
;
;******************************************************************************
;
; Near Heap Support
;
; The near heap support code deals with three pieces:
;
;	Local Heap	- Contains FDBs & Dynamic (small) arrays & QBI tables
;	String Space	- Strings and FIELDed string entries
;	Variable Heap	- Interpeter Only, value tables
;
; In memory, the heaps, associated variables and stack are layed out as
; follows:
;
;			   High Memory (DGROUP)
;
;			+--+--+--+--+--+--+--+--+
; b$HEAP_FIRST	-->	|			| odd:	last useable physical
;			+--+--+--+--+--+--+--+--+	byte of Heap
; b$NH_last	-->	|			| even: last useable physical
;			\ 			\ 	word of Heap
;				Local Heap
;			\ 			\
;			|			|
;			+--+--+--+--+--+--+--+--+
; b$HEAP_END	-->	|    LH_END Constant	| odd: ?
;			+--+--+--+--+--+--+--+--+
;			|			|
;			+			+
; b$STRING_END	-->	|			| even: word containing 0xFFFF
;			\ 			\
;				String Space
; b$NH_First	-\ 	\ 			\
; b$STRING_FIRST --\-->	|			| first useable byte/word
;			+--+--+--+--+--+--+--+--+ \
; b$HEAP_FIRST_SWAP --> |			|  \
;			\ 			\   \
;			      Variable Heap	     Interpeter Only
;			\ 			\   /
; b$HEAP_END_SWAP   --> |			|  /
;			+--+--+--+--+--+--+--+--+ /
;			|			|
;			+			+
; __atopsp	-->	|			| last useable word of stack
;			\ 			\
;				  Stack
;			\ 			\
; b$pend	-->	|			| first useable word of stack
;			+--+--+--+--+--+--+--+--+
;
;==============================================================================
;
;
; Heap Entry:
;
;			+--+--+--+--+--+--+--+--+	High memory
; Pointer to entry -->	|    Entry Type Byte	|
;			+--+--+--+--+--+--+--+--+
;			| File #, if applicable |
;			+--+--+--+--+--+--+--+--+
;			|			|
;			+   Total Entry Size	+
;			|			|
;			+--+--+--+--+--+--+--+--+
;			|     Back Pointer	|
;			+ (Pointer to		+
;			|	 owner pointer) |
;			+--+--+--+--+--+--+--+--+
;			| (offset part of sd	|
;			+  for fielded string	+
;			|  if applicable)	|
;			+--+--+--+--+--+--+--+--+
;			| (length part of sd	|
;			+  for fielded string	+
;			|  if applicable)	|
;			+--+--+--+--+--+--+--+--+
;			|			|
;			\ 			\
;				 Data
;			\ 			\
; Start of Data -->	|			|
;			+--+--+--+--+--+--+--+--+
;			|			|
;			+   Total Entry Size	+
;			|  (Same as in header)	|
;			+--+--+--+--+--+--+--+--+	Low memory
;
; The pointer to an entry normally points to the type byte in the header; since
; length of the entry (hdr + data + trailer length word) is kept at the start
; and the end of the block, it is easy to access; subtract that length from the
; current entry pointer, and it will be pointing to the same place in the next
; hdr - - - yes, since the heap grows down, subtracting from the pointer moves
; you "forward" in the heap. Heap entries can be of any even-byte size; headers
; are 6 bytes in length, except for fdb's, which have 10-byte headers.
;
;==============================================================================
;
; Internal structure of (simple) fielded strings.
;
; FDB:
;
;    /--+-----------------------+--/ /--+---------------+--/ /--+-------+
;	|   Field Buffer	|	|  String Desc	|	|LH_FILE|
;    /--+-----------------------+--/ /--+------------+--+--/ /--+-------+
;	       ^   ^	   ^		      ^      |
;	       |   |	   |		      |      |
; Individual   |   |	   +-----------+      |      |
; Static       |   |		       |      |      |
; String       |   +-------+	       |      |      |
; Descriptors: |	   |	       |      |      |
;	       |	   |	       |      |      |
;	  +-------+   +-------+   +-------+   |      |
;	  |  SD   |   |   SD  |   |  SD   |   |      |
;	  +-------+   +-------+   +-------+   |      |
;		^	    ^		^     |      |
; Fielded	|	    |		|     |      |
; String	+----+	    ++	     +--+     |      |
; BackPointer	     |	     |	     |	      |      |
; String:	     |	     |	     |	      |      |
;		     |	     |	     |	      |      |
;	    +---------------------------------+      |
;	    |	     |	     |	     |		     |
;	    |	  +----------------------------------+
;	    |	 \/  |	     |	     |
;	+---+---+----+--+----+--+----+--+--/
;	| BkPtr | SD Ptr| SD Ptr| SD Ptr|
;	+-------+-------+-------+-------+--/
;
; In summary, the FDB contains a string descriptor which references a string
; (the fielded string backpointer string) containing pointers to several string
; descriptors. These string descriptors (static, in this example) reference
; locations in the FIELD buffer in the FDB, and define the position and length
; of the individual FIELDs.
;
; The backpointer string can grow as additional FIELD statements are executed,
; and can shrink at CHAIN time. Since it is a string, it is also subject to
; movement as string-space compaction occurs. The compaction code must be
; sensitive to the pointers involved in such movement.
;
; When the fielded strings are defined in  a static string array, operation is
; essentially the same as individual static strings. The static SD's do not
; move, and dereferencing performed by any calling code looks exactly like
; static individual SD's.
;
;
; Internal structure of fielded strings in dynamic arrays.
;
; FDB:
;
;    /--+-----------------------+--/ /--+---------------+--/ /--+-------+
;	|   Field Buffer	|	|  String Desc	|	|LH_FILE|
;    /--+-----------------------+--/ /--+------------+--+--/ /--+-------+
;	       ^   ^	   ^		      ^      |
;	       |   |	   |		      |      +------------------+
; Array of     |   |	   +---+	      | 			|
; String       |   |	       |	      +---------------------+	|
; Descriptors: |   +---+       |				    |	|
;	       |       |       |				    |	|
;	+------++------++------++--/ /--+-------+--/ /--+-------+   |	|
;	|  SD	|   SD	|  SD	|	| BkPtr |	|LH_ARRA|   |	|
;	+-------+-------+-------+--/ /--+-----+-+--/ /--+-------+   |	|
;	       ^       ^       ^	      | 		    |	|
; Fielded      |       |       |	      | 		    |	|
; String       +-----+ +-----+ +-----+	      +----+		    |	|
; BackPointer  ^     |	     |	     |		   |		    |	|
; String:      +-----|-------|-------|----------+  |		    |	|
;		     |	     |	     |		|  |		    |	|
;	    +-------------------------------------------------------+	|
;	    |	     |	     |	     |		|  |			|
;	    |	  +-----------------------------------------------------+
;	    |	 \/  |	     |	     |		|  |
;	+---+---+----+--+----+--+----+--+--/	|  |
;	| BkPtr | SD Ptr| SD Ptr| SD Ptr|	|  |
;	+-------+-------+-------+-------+--/	|  |
;						|  |
; String	 +------------------------------+  |
; Array 	 |				   |
; Descriptor:	 |     +---------------------------+
;		 |    \/
;		++------+--/
;		|DatPtr |
;		+-------+--/
;
;
; The added complication of dynamic fielded string arrays is that the string
; descriptors live in the local heap, and hence can move, in addition to the
; backpoint string, which lives in string space and can also move. Both LH and
; SS code must update pointers appropriately.
;
;==============================================================================
	INCLUDE switch.inc
	INCLUDE baslibma.inc
	INCLUDE files.inc
	INCLUDE rmacros.inc

	USESEG	_DATA
	USESEG	_BSS
	USESEG	NH_TEXT

	INCLUDE seg.inc
	INCLUDE nhutil.inc	;for heap definitions
	INCLUDE idmac.inc
	INCLUDE array.inc	;for array definitions


sBegin	_BSS

	externW b$STRING_END		;defined in NHSTUTIL.ASM
	externW b$STRING_FREE		; defined in NHSTUTIL.ASM
	externW b$NH_first		;defined in NHINIT.ASM
	externW b$PTRFIL		;defined in GLOBAL.INC

;NOTE: Variable Heap support code requires next 4 data items be contiguous [23]

	globalW b$HEAP_FIRST,,1 	;heap start pointer
	globalW b$HEAP_FREE,,1
	globalW b$HEAP_END,,1
	globalW b$P_HEAP_GROW,,1	

;NOTE: Variable Heap support code requires next 4 data items be contiguous [23]

	globalW b$HEAP_FIRST_SWAP,,1	 
	globalW b$HEAP_FREE_SWAP,,1	 
	globalW b$HEAP_END_SWAP,,1	 
	staticW P_HEAP_GROW_SWAP,,1	 

	globalW b$fVarHeapActive,,1	 ; non-0 when variable heap
					 ; is active

sEnd	_BSS

sBegin	_DATA

	globalW b$pFHRaiseBottom,Near_Ret,1  ;vector for B$FHRaiseBottom

	globalB b$Clearing,0,1		; CLEAR statement in process flag
sEnd	_DATA

	externFP B$ULDataRelease ;releases ul Data images
	externFP CompressHelp	

sBegin	NH_TEXT

	ASSUMES CS,NH_TEXT

	PUBLIC	B$LHNXTFIL	; find next file entry in heap

	PUBLIC	B$LHADJ	;adjust heap entry
	PUBLIC	B$LHDALC	;deallocate heap entry

	PUBLIC	B$LHFLDDESCADJ	; delete/adjust descriptor in backpointer string
	PUBLIC	B$LHDALCALLFLD	; deallocate all fielded strings from heap entry

	PUBLIC	B$LHSetFree	;set free heap entry pointer
	PUBLIC	B$LH_ALC_FREE	;[ln]
	PUBLIC	B$LH_PTR_FROM_DATA 
	PUBLIC	B$LH_CPCT	
	PUBLIC	B$LH_FROM_SS	;[ln]
	PUBLIC	B$LH_PTR_CHECK	;[ln] check entry at [SI] for consistency
	PUBLIC	B$LH_SCAN	;[ln]

	PUBLIC	B$NHINIT	;initialize dynamic space


	externNP B$LH_I_ADJ	;[ln] adjust backptrs to any owners in this entry
	externNP B$VAR_ALC_GROW ;[ln]

	externNP B$ERR_SSC		 
	externNP B$STCPCT
	externNP B$STADJ
	externNP B$STINIT
	externNP B$STSetFree
	externNP B$SSClean	; clean string space

ASSERT_NOT_VARHEAP	MACRO	SEG	;
	ENDM				;


	PAGE
;***
; LH_ALC_GROW - Grow local heap to support allocation of a block of given size
; Purpose:
;	Added with revision [23].
;
; Inputs:
;	ES = DS
;	BX = total size of local heap space to be allocated
;	DL = type of heap entry to allocate.
;	CL = if DL=LH_FILE, file number
;	CX = if DL anything else, ptr to owner (where backptr should point to)
; Outputs:
;	Carry Clear if allocation accomplished successfully
; Modifies:
;	SI
; Exceptions:
;
;****
DbPub	LH_ALC_GROW
LH_ALC_GROW:
;	Step 3 - Get free string entry to heap space, test free entry.

	CALL	B$LH_FROM_SS	;[ln] get free string from string space
	CALL	B$LH_ALC_FREE	;test free entry for room
	JNC	LH_ALC_GROW_DONE; allocated - jump to return to string

;	Step 4 - Perform string compaction, get free string, test free entry.

	CALL	B$STCPCT	;perform the string compaction
	CALL	B$LH_FROM_SS	;[ln] get free string from string space
	CALL	B$LH_ALC_FREE	;test free entry for room
	JNC	LH_ALC_GROW_DONE; allocated - jump to return to string
;
;	Step 5 - Kick FH out of DS if possible
;
	CALL	[b$pFHRaiseBottom] ;[46]
	CALL	B$LH_FROM_SS	;[ln] get free string from string space
	CALL	B$LH_ALC_FREE	; test free entry for room
	JNC	LH_ALC_GROW_DONE;allocated jump to return string

;
;	Step 6 - Kick UL data images out of FH and raise the bottom

	PUSH	AX		;preserve AX-DX across call to
	PUSH	BX		;B$ULDataRelease, as the far
	PUSH	CX		;call dispatcher to the quicklibrary
	PUSH	DX		;can honk on these registers.
	CALL	B$ULDataRelease ;free UL data images if allocated
	POP	DX		
	POP	CX		
	POP	BX		
	POP	AX		;recover regs

	CALL	[b$pFHRaiseBottom] ;give FH's free space to NH
	CALL	B$LH_FROM_SS	;[ln]get free string from string space
	CALL	B$LH_ALC_FREE	;test free entry for room
	JNC	LH_ALC_GROW_DONE;allocated jump to return string

;
;	Step 7 - Kick Help out of FH and raise the bottom

	PUSH	AX		;preserve AX-DX across call to
	PUSH	BX		;CompressHelp
	PUSH	CX		
	PUSH	DX		
	CALL	CompressHelp	;Free the help system
	POP	DX		
	POP	CX		
	POP	BX		
	POP	AX		;recover regs

	CALL	[b$pFHRaiseBottom] ;give FH's free space to NH
	CALL	B$LH_FROM_SS	;get free string from string space
	CALL	B$LH_ALC_FREE	;test free entry for room

Near_Ret:			;Near Return for vector
LH_ALC_GROW_DONE:
	RET

;***
; B$LH_FROM_SS - get local heap space from string space
; Purpose:
;	Determine if a free entry exists at the end of
;	string space.  If so, change the string and heap
;	space pointers so that it is now part of the local
;	heap space.
;
;	Mostly rewritten with revision [53].
;
; Strategy (order of attempts swapped with revision [64]):
; (1)	If the last entry in the LH is a free entry, tack the free
;	string bytes onto that entry and move b$HEAP_END past it.
;
; (2)	If the last entry in the LH is NOT a free entry and the free
;	string is large enough to create a heap entry (LH_STD_HDR_LEN
;	bytes + 2 bytes for back length), then create a new LH entry
;	with the free space.
;
;	If neither (1) or (2) is possible, then we can't give any of
;	the free string to the LH, just exit.
;
; Inputs:
;	None.
; Outputs:
;	[b$HEAP_FREE] = pointer to new (or enlarged) free heap entry.
; Modifies:
;	None.
; Exceptions:
;	None.
;****
B$LH_FROM_SS:
	ASSERT_NOT_VARHEAP NH_TEXT	
	PUSH	AX			;save registers...
	PUSH	SI
	PUSH	DI
	CALL	B$STSetFree		;SI points to trailing free string
	MOV	AX,[b$STRING_END]	;get end pointer in AX
	SUB	AX,SI			;compute size of free string
	JZ	LH_SS_RETURN		;if no free bytes, exit quickly

;	Size of free string (including header) is in AX.
;	Pointer to free string header is in SI.

DbAssertTst AX,Z,1,NH_TEXT,<Free string size odd in B$LH_FROM_SS>

;	(1) If the last entry in the LH is free, tack the new empty space
;	    on to it.

	MOV	DI,[b$HEAP_END] 	;[DI] = heap END entry
	CMP	DI,[B$HEAP_FIRST]	; is END the only entry?
	JE	LH_SS_TRY_2		; yes, go create a free entry
	ADD	DI,[DI+1]		;[DI] = last entry before END
	CMP	[DI].LHTYPE,LOW LH_FREE ;is entry unallocated?
	JNE	LH_SS_TRY_2		;no, go try next option
	ADD	AX,[DI].LHLEN		;compute new length
	JMP	SHORT LH_SS_FINISH_UP	; finish updating pointers and exit

;	(2) If there are enough free bytes to create a new free entry at the
;	    end of the LH, do that.

LH_SS_TRY_2:
	CMP	AX,LH_STD_HDR_LEN+2	;enough free space?
	JB	LH_SS_RETURN		;if not, we can't do anything

;	Create the new heap entry from the empty space.

	MOV	DI,SI			;[DI] = what will be string END entry
	ADD	DI,LH_STD_HDR_LEN+1	;[DI] = what will be heap END entry
	ADD	DI,AX			;[DI] = new entry being created

LH_SS_FINISH_UP:
;	When we get here:
;		SI points to new string space end location
;		DI points to new (or enlarged) free heap entry
;		AX = size of new (or enlarged) free heap entry

;	Define the new string space end entry and its pointer.

	MOV	[SI],0FFFFH		;set string end entry
	MOV	[b$STRING_END],SI	;set string end pointer
	MOV	[b$STRING_FREE],SI	;set free string pointer

;	Define the new heap END entry and its pointer.

	ADD	SI,LH_STD_HDR_LEN+1	;point to new END entry
	MOV	[SI].LHTYPE,LOW LH_END	;define the entry type
	MOV	[b$HEAP_END],SI 	;define the heap end pointer

;	Update header for new or enlarged free heap entry and set
;	b$HEAP_FREE to point to it.

	MOV	[DI].LHTYPE,LOW LH_FREE ;set heap entry type
	MOV	[DI].LHLEN,AX		;set free heap entry length
	MOV	[SI+1],AX		;set free heap entry backlength
	MOV	[b$HEAP_FREE],DI	;set heap free entry pointer

LH_SS_RETURN:
	POP	DI			;restore registers...
	POP	SI
	POP	AX
	RET				;return with new heap free entry

;***
;	B$LH_SCAN -Scan the entire local heap area for an entry of the
;		   requested amount of storage.  Adjacent unallocated
;		   entries are combined before tested for allocation.
;
;	Inputs: 	BX - amount of heap storage to allocate.
;			DL - type of heap entry to allocate.
;			CL - if DL=LH_FILE, file number
;			CX - if DL=LH_ARRAY, array descriptor offset
;			[b$HEAP_FIRST] - pointer to first entry to test
;
;	Outputs:	CF=0 - allocation was successful.
;			     SI - pointer to data in allocated entry.
;			CF=1 - allocation failed.
;
;	Start the scan with the entry pointed by [b$HEAP_FIRST].
;****
B$LH_SCAN:
	MOV	SI,[b$HEAP_FIRST] ;starting point of scan

;	No pending unallocated entries.  If END entry, then failed.
;	If FREE entry, then jump to try to combine subsequent ones.

LH_SCAN_NEXT:
	CMP	[SI].LHTYPE,LOW LH_END ;test if last local heap entry
	JE	LH_SCAN_FAIL	;if so, then allocation failed
	CMP	[SI].LHTYPE,LOW LH_FREE ;test if entry is unallocated
	JE	LH_SCAN_FREE	;if so, jump to scan for next free entries
	SUB	SI,[SI].LHLEN	;move pointer to the next entry
	JMP	SHORT LH_SCAN_NEXT ;and try again

;	Pending unallocated entry.  Test the next entry.  If END, try
;	a final allocation attempt.  If allocated, attempt allocation
;	and continue scan if it fails.	If FREE, combine the two entries
;	and loop back.	Keep size of free entry in AX until allocation.

LH_SCAN_FREE:
	MOV	AX,[SI].LHLEN	;get size of first free block
LH_SCAN_NEXT_FREE:
	MOV	DI,SI		;get copy of present scan pointer
	SUB	DI,AX		;now points to following entry
	CMP	[DI].LHTYPE,LOW LH_END ;test if next entry is END
	JE	LH_SCAN_TRY	;if so, try a final allocation
	CMP	[DI].LHTYPE,LOW LH_FREE ;test if next entry is FREE
	JNE	LH_SCAN_TRY	;if not, try allocation, but continue
	ADD	AX,[DI].LHLEN	;add for length of both FREE entries
	JMP	SHORT LH_SCAN_NEXT_FREE ;and loop to try again

;	Try to allocate from the entry at [SI].  If failure, point
;	past the allocated entry at [DI] and continue scan if not at
;	heap end.  If at heap end, return with failure.

LH_SCAN_TRY:
	MOV	[SI].LHLEN,AX	;set the new length of the combined block
	SUB	SI,AX		;point to next block (one after backlength)
	MOV	[SI+1],AX	;set the backlength
	ADD	SI,AX		;return pointer to start of combined block
	CMP	AX,BX		;test entry against allocation needed
	JAE	LH_ALC		;if enough room, finish allocation
	CMP	[DI].LHTYPE,LOW LH_END ;test if at end of heap
	JE	LH_SCAN_FAIL	;if so, then just fail
	SUB	DI,[DI].LHLEN	;point to entry after allocated one
	MOV	SI,DI		;move pointer to continue scan
	JMP	SHORT LH_SCAN_NEXT ;and jump to continue it

;	Allocate not possible, return with carry set for failure.

LH_SCAN_FAIL:
	MOV	[b$HEAP_FREE],SI ;set free entry to last unallocated one
	STC			;carry set for failure
	RET			;and return to caller
;	B$LH_ALC_FREE - test if free heap entry can allocate the
;			requested amount of storage

;	Inputs: 	BX - amount of heap storage to allocate.
;			DL - type of heap entry to allocate.
;			CL - if DL=LH_FILE, file number
;			CX - if DL=LH_ARRAY, array descriptor offset
;			[b$HEAP_FREE] - pointer to entry to test

;	Outputs:	CF=0 - allocation was successful.
;			     SI - pointer to data in allocated entry.
;			CF=1 - allocation failed.

;	Test if free local heap entry is unallocated and large enough.
;	If so, then allocate it, otherwise fail.

B$LH_ALC_FREE:
	MOV	SI,[b$HEAP_FREE] ;point to free local heap entry
	CMP	[SI].LHTYPE,LOW LH_FREE ;test if free entry is unallocated
	JNE	LH_ALC_FAIL	;if not free, then jump to fail
	MOV	AX,[SI].LHLEN	;get length of the entry
	CMP	AX,BX		;test if entry is large enough
	JAE	LH_ALC		;if so, then jump to allocate
LH_ALC_FAIL:
	STC			;set carry to note failure
	RET			;return to caller

;	There wasn't enough room to split entry and allocate a new FREE
;	entry.	Allocate the whole entry instead of splitting it.

LH_ALC_ALL:			
	ADD	BX,AX		;change requested block size to whole entry
	JMP	SHORT LH_ALC_EXACT ;allocate whole block

;	The entry at [SI] can be allocated.  If the entry is larger than
;	the size needed, split it into two entries with the higher one
;	used in the allocation.

LH_ALC:
	JE	LH_ALC_EXACT	;if exact allocation, then no split needed
	SUB	AX,BX		;size of remainder block
	CMP	AX,LH_STD_HDR_LEN ;is there enough room for new header?
	JB	LH_ALC_ALL	;allocate whole entry if not enough room
	SUB	SI,BX		;point to header of new remainder entry
	MOV	[SI].LHTYPE,LOW LH_FREE ;set type for FREE entry
	MOV	[SI].LHLEN,AX	;put size into new entry header
	SUB	SI,AX		;point to next entry (byte before backlength)
	MOV	[SI+1],AX	;put in backlength for the present entry
	ADD	SI,AX		;point back to remainder block
	ADD	SI,BX		;point back to newly allocated block
LH_ALC_EXACT:

;	Clear the new heap entry to zeroes.

	PUSH	CX		;save registers for clear...
	PUSH	DI
	PUSH	ES		
	PUSH	DS		
	POP	ES		;set ES = DS
	MOV	DI,SI		;copy pointer to header of allocated block
	SUB	DI,BX		;point to header of previous block
	MOV	[b$HEAP_FREE],DI ;free entry is now previous block
	INC	DI		;now point to data of block to be allocated
	XOR	AX,AX		;value to set entry locations
	MOV	CX,BX		;get size of entry in bytes
	SHR	CX,1		;convert size to words
	REP	STOSW		;clear the entry
	POP	ES		
	POP	DI		;restore registers...
	POP	CX

;	Finish by setting the header values

	MOV	[SI].LHTYPE,DL	;set the heap entry type
	MOV	[SI].LHLEN,BX	;set the heap entry length
	SUB	SI,BX		;point to next entry (byte before backlength)
	MOV	[SI+1],BX	;set the backlength
	ADD	SI,BX		;set point back to entry header

	CMP	[SI].LHTYPE,LOW LH_FILE ;test if FILE entry
	JNE	LH_ALC_NOT_FILE ;if not, then branch
	MOV	[SI].LHFNUM,CL	;set file number
	JMP	SHORT LH_ALC_EXIT

LH_ALC_NOT_FILE:
	MOV	[SI].LHBAKP,CX	;all entries have backpointers except fdb's

LH_ALC_EXIT:
	SUB	SI,BX		;point to previous entry
	ADD	SI,3		;set to start of entry data (past backlength)
	RET			;return with carry clear



	page
;*** 
; B$LHDALC_CPCT -- deallocate heap entry and compact heap.  Added with [44].
;
;Purpose:
;	Deallocates heap entry, and then compacts local heap, so that no 
;	no "holes" develop in the heap.
;
;Entry/Exit/Uses/Exceptions:
;	Same as B$LHDALC/B$LH_CPCT.
;
;******************************************************************************
cProc	B$LHDALC_CPCT,<PUBLIC,NEAR>
cBegin
	CALL	B$LHDALC		; deallocate heap entry
cEnd	<nogen>				; fall into B$LH_CPCT

;***
; B$LH_CPCT - compact local heap space
; Purpose:
;	Compacts all allocated local heap entries to the top of
;	the local heap space.  The backpointers in the ARRAY and FILE
;	entries are adjusted appropriately to reflect their movement.
;	The remaining unallocated space is made into the free entry.
;	NOTE: The scan (and compaction) moves from high memory to low.
;
; Inputs:
;	None
; Outputs:
;	[b$HEAP_FREE] points to the new free heap entry.
; Exceptions:
;	B$ERR_SSC - nontrappable error if compaction finds corruption
;		  in the local heap space structure.
;****

B$LH_CPCT PROC    NEAR
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	PUSH	AX		;save registers used...
	PUSH	BX
	PUSH	CX
	PUSH	SI
	PUSH	DI

	MOV	SI,[b$HEAP_FIRST] ;pointer to heap scan

;	Skip over leading allocated entries which can be ignored since
;	they will not be moved.  While skipping, an END entry implies
;	no compaction need to be done.	Check all allocated entries.

B$LH_CPCT_SKIP:
	CMP	[SI].LHTYPE,LOW LH_END ;test for end of local heap
	JE	B$LH_CPCT_DONE    ;if so, no compact, just return
	CALL	B$LH_PTR_CHECK	  ;check entry at [SI] for consistency
	CMP	[SI].LHTYPE,LOW LH_FREE ;test if leading allocated entry
	JE	B$LH_CPCT_FIRST_FREE ;if not, then skipping is over
	SUB	SI,[SI].LHLEN	;point to next entry
	JMP	SHORT B$LH_CPCT_SKIP ;and try again

;	First unallocated heap entry found.  Initialize compacted pointer DI.

B$LH_CPCT_FIRST_FREE:
	MOV	DI,SI		;SI=scan pointer - DI=compacted pointer

;	Unallocated heap entry just advances the scan pointer SI.

B$LH_CPCT_NEXT_FREE:
	SUB	SI,[SI].LHLEN	;point to entry after unallocated one

;	Process the entry at [SI].  First check consistency of entry.

B$LH_CPCT_NEXT:

;	If END entry, compaction is done - jump to finish up.

	CMP	[SI].LHTYPE,LOW LH_END ;test for END entry
	JE	B$LH_CPCT_SETUP_FREE ;jump to set up free entry

;	If FREE entry, jump to advance scan pointer SI.

	CALL	B$LH_PTR_CHECK	  ;check entry at [SI]
	CMP	[SI].LHTYPE,LOW LH_FREE ;test for FREE entry
	JE	B$LH_CPCT_NEXT_FREE ;jump to advance scan pointer

;	Allocated entry - adjust the entry backpointers to reflect
;	its new location at [DI].

	MOV	AX,DI		;set to new entry location
	SUB	AX,SI		;subtract to get adjustment factor
	CALL	B$LHADJ	;adjust the entry using the factor in AX

;	Move the entry from [SI] to [DI] with direction flag SET.

	MOV	CX,[SI].LHLEN	;get length of entry in bytes
	SHR	CX,1		;make the length in words
	DEC	SI		;point to word address in source
	DEC	DI		;point to word address in destination
	STD			;all strings move down in memory
	REP	MOVSW		;move the entry to its new location
	CLD			;restore direction flag
	INC	SI		;point back to byte in source
	INC	DI		;also in destination

;	Now make the space between the moved entry and the next entry
;	a free heap entry.  This will ensure heap consistency and
;	allow routines called during the middle of compaction to
;	walk the heap.

	MOV	[DI].LHTYPE,LOW LH_FREE ;set type of FREE entry
	MOV	[DI].LHLEN,AX	;set size of new entry
	MOV	[SI+1],AX	;also set backlength of new entry
	JMP	SHORT B$LH_CPCT_NEXT ;try again (SI and DI are already adjusted)

;	Compaction is done - set up the unused space as a FREE entry and
;	point to it for the next allocation.

B$LH_CPCT_SETUP_FREE:
	MOV	AX,DI		;get length of remaining entry...
	SUB	AX,SI		;by the difference of the pointers
	JZ	B$LH_CPCT_NO_FREE ;if no entry left, then jump
	MOV	[DI].LHTYPE,LOW LH_FREE ;set type of FREE entry
	MOV	[DI].LHLEN,AX	;set size of new entry
	MOV	[SI+1],AX	;also set backlength of new entry
B$LH_CPCT_NO_FREE:
	MOV	[b$HEAP_FREE],DI ;new entry for next allocation

;	Restore registers and return.

B$LH_CPCT_DONE:
	POP	DI		;restore registers...
	POP	SI
	POP	CX
	POP	BX
	POP	AX
B$LH_CPCT_EXIT:
	POP	ES		
	RET			;return to caller
B$LH_CPCT ENDP


;***
; B$LHDALC - deallocate heap entry
; Purpose:
;	To deallocate the heap entry whose data area is pointed by SI.
;
; Inputs:
;	SI = pointer to heap entry data area
; Outputs:
;	None.
; Modifies:
;	ES, if interpreter version
; Exceptions:
;	None.
;****
B$LHDALC	PROC	NEAR
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	PUSH	AX		;save registers...
	PUSH	SI
	CALL	B$LH_PTR_FROM_DATA ;get entry pointer from SI data pointer
	XOR	AX,AX		;set flag for entry deallocation
	CALL	B$LHADJ	;call to deallocate all string data in entry
	MOV	[SI].LHTYPE,LOW LH_FREE ;set array type to FREE
	POP	SI		;restore registers...
	POP	AX
	POP	ES		
	RET			;return to caller
B$LHDALC	ENDP


;***
; B$LHADJ - delete/adjust a heap entry
; Function:
;	Deallocates or adjusts the heap entry pointed by SI.
;	If AX=0, all string data referenced by descriptors within
;	the entry is deallocated.
;	If AX<>0, all backpointers referenced within the entry are
;	adjusted by the value of AX.
;
;	NOTE: In QB versions, B$LHDALC can call this routine to deallocate [23]
;	NOTE: an entry in the variable heap while the local heap is active. [23]
;	NOTE: This causes no problems in this routine as it is now, because [23]
;	NOTE: we'll never have an LH_FILE or LH_ARRAY entry in the variable [23]
;	NOTE: heap.                                                         [23]
;
; Inputs:
;	AX = adjustment value
;	     AX=0  - deallocate all entry string data.
;	     AX<>0 - adjust all entry backpointers.
;	SI = address of heap entry.
;	DS = segment that heap is in
;	ES = segment that state vars are in
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	None.
;****
assumes	ES,DGROUP		
assumes	DS,NOTHING		

B$LHADJ  PROC	  NEAR		
	PUSH	BX		;save registers...
	PUSH	CX
	CMP	[SI].LHTYPE,LOW LH_FILE ;test if entry is FILE
	JNE	ADJLHP_NOT_FILE ;if not, then jump [23]

	ASSERT_NOT_VARHEAP NH_TEXT 

	LEA	BX,[SI+3]	;point to 1 word past heap header
	SUB	BX,[SI].LHLEN	;point at heap entry data
	CMP	BX,ES:[b$PTRFIL] ;are we moving PTRFIL?
	JNZ	NotPtrFil	;brif not

	ADD	ES:[b$PTRFIL],AX ;adjust if moving ptrfil

NotPtrFil:

;	Entry is FILE - deallocate/adjust the fielded string backpointer
;	if it exists.

	CMP	WORD PTR [SI].LHPLEN,0 ;test if fielded string is null
	JZ	ADJLHP_EXIT	;if so, then just return
	MOV	BX,[SI].LHPOFF	;get offset of fielded string data
	ADD	[BX-2],AX	;add adjustment to the string backpointer
	OR	AX,AX		;test if deallocation was requested
;	JNZ	ADJLHP_QUIT	;if just adjustment, then jump
	JNZ	ADJLHP_ALL_FLDS ;if adjustment, then adust fielded strings
	MOV	[SI].LHTYPE,LOW LH_FREE ;mark the deallocated block free
	CALL	B$LHDALCALLFLD	; otherwise deallocate all fielded strings
	JMP	SHORT ADJLHP_QUIT ;jump to return to caller

;	Entry contains fielded strings - adjust pointers into field buffer

ADJLHP_ALL_FLDS:
	MOV	CX,[SI].LHPLEN	;get size of string entry for fielded strs
	SHR	CX,1		;compute number of fielded strings
	PUSH	SI		;preserve heap pointer
ADJ_FLD_LOOP:
	MOV	SI,[BX] 	;get pointer to field variable
	ADD	[SI+2],AX	;adjust pointer into field buffer
	INC	BX		;move to next field variable
	INC	BX
	LOOP	ADJ_FLD_LOOP	;loop until all ptrs to field buffer have
				;been adjusted
	POP	SI		;recover heap pointer
ADJLHP_EXIT:
	JMP	SHORT ADJLHP_QUIT ;jump to return to caller

;	If entry is not ARRAY, then return.

ADJLHP_NOT_FILE:
	CMP	[SI].LHTYPE,LOW LH_ARRAY ;test if entry is ARRAY
	JNE	ADJLHP_INTERP	;if not, consider interp. entries (if any)

;	Entry is ARRAY, first clear/adjust the array descriptor pointer.

	MOV	BX,[SI].LHBAKP	;get offset of array descriptor
	OR	AX,AX		;test if array is being deallocated
	JNZ	ADJLHP_ADJUST	;if just being adjusted, then jump
	MOV	[BX].AD_fhd.FHD_hData,AX ;deallocated - clear the descriptor
	MOV	[SI].LHBAKP,AX	;also clear the heap backpointer
	MOV	[SI].LHTYPE,LOW LH_FREE ;mark the deallocated block free
ADJLHP_ADJUST:

;	Next, get pointer to start of array data and deallocate/adjust
;	the backpointers of all nonnull strings in the array.

	MOV	CX,[SI].LHLEN	;get length of heap entry (hdr+data+backlen)
	MOV	BX,SI		;get copy of heap entry pointer
	SUB	BX,CX		;point to next heap entry
	ADD	BX,3		;move past backlength to array start
	SUB	CX,LH_STD_HDR_LEN+2 ;data length less header and backlength
	SHR	CX,1		;data length in words...
	SHR	CX,1		;length in doublewords (number of descs)

;	For each nonnull descriptor, deallocate/adjust the string data.
; Process null strings through B$STADJ, fielded ones must be adjusted.

ADJLHP_LOOP:
;	CMP	WORD PTR [BX],0 ;test if string is nonnull
;	JZ	ADJLHP_NEXT	;if so, then skip this entry
	CALL	B$STADJ	;deallocate/adjust the string at desc [BX]
ADJLHP_NEXT:
	ADD	BX,4		;point to next descriptor
	LOOP	ADJLHP_LOOP	;loop to process the next one

ADJLHP_INTERP:

	OR	AX,AX
	JZ	ADJLHP_QUIT	;brif deallocation - the below is for adjustment
	CALL	B$LH_I_ADJ	;[ln] adjust backptrs to any owners in this entry

ADJLHP_DONE:
	;NOTE: important to update the owner LAST, after interpreter call
	;	back work is done.
	MOV	BX,[SI].LHBAKP	;get pointer to owner
	ADD	[BX],AX 	;add adjustment to owner pointer
	CMP	[SI].LHTYPE,LOW LH_ARRAY; test if entry is ARRAY
	JNE	ADJLHP_QUIT		; jump if not
	ADD	[BX].AD_oAdjusted,AX	; else update adjusted pointer

ADJLHP_QUIT:
	POP	CX		;restore registers...
	POP	BX
	RET			;return to caller
B$LHADJ  ENDP			
assumes	DS,DGROUP		
assumes	ES,NOTHING		


;***
; B$LHDALCALLFLD - deallocate all fielded strings for heap entry
; Purpose:
;	To deallocate all fielded strings associated with the heap
;	entry pointed by SI.  The heap backpointer string is also
;	deallocated.
;
; Inputs:
;	SI = pointer to heap entry
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	None.
;****

B$LHDALCALLFLD:		
	ASSERT_NOT_VARHEAP NH_TEXT 
	PUSH	AX		;save registers...
	PUSH	BX
	PUSH	CX
	PUSH	DI
	XOR	AX,AX		;clear AX to zero
	MOV	BX,AX		;same for BX...
	MOV	CX,AX		;and CX
	XCHG	CX,[SI].LHPLEN	;swap bkptr str len and 0
	XCHG	BX,[SI].LHPOFF	;swap bkptr str off and 0
	INC	CX		;add one for backpointer value
	MOV	[BX-2],CX	;free string by setting backpointer value
	SHR	CX,1		;number of words to process
DALCALLFLD_LOOP:
	MOV	DI,[BX] 	;get next word from string
	MOV	[DI],AX 	;clear descr length
	MOV	[DI+2],AX	;clear descr offset
	ADD	BX,2		;point to next descriptor in string
	LOOP	DALCALLFLD_LOOP ;if not done, then loop
	POP	DI		;restore registers...
	POP	CX
	POP	BX
	POP	AX
	RET			;return to caller


;***
; B$LHFLDDESCADJ - delete/adjust descriptor in field backpointer string.
; Purpose:
;	Search through the local heap FILE entries for the descriptor
;	address specified in BX.  If AX=0, then remove it from the
;	field backpointer string.  If AX<>0, then just adjust the
;	backpointer string element by adding AX to it.
;
; Inputs:
;	AX = adjustment factor
;	     AX=0 - delete descriptor BX from backpointer string.
;	     AX<>0 - adjust descriptor BX in backpointer string by AX.
;	BX = address of descriptor to be deleted/adjusted.
;	DS = segment that heap is in
;	ES = segment that state vars are in
; Outputs:
;	None.
; Modifies:
;	SI.
; Exceptions:
;	B$ERR_SSC if descriptor offset not found.
;****

B$LHFLDDESCADJ:
assumes	ES,DGROUP		
assumes	DS,NOTHING		

	ASSERT_NOT_VARHEAP NH_TEXT 

	PUSH	AX		;save registers...
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	DI

	XCHG	DX,AX		; [DX] = adjustment factor
	XCHG	AX,BX		; [AX] = object of searches
	XOR	BX,BX		;start at beginning of heap
FLDDESCADJ_NEXT:
	MOV	SI,BX		;put current FDB point in for test
	CALL	NXTFIL_ES	;get next FILE data pointer in SI
	JZ	FLDDESCADJ_ERROR ;if no more entries, then done

	MOV	BX,SI		;save current FDB point for next time
	CALL	B$LH_PTR_FROM_DATA ;get heap entry pointer in SI

;	Heap entry is for a file.  Determine if a backpointer string
;	is defined.  If so, then scan string for descriptor value in AX.

	MOV	CX,[SI].LHPLEN	;get length of string
	JCXZ	FLDDESCADJ_NEXT ;if null string, then try next entry
	SHR	CX,1		;make it in words
	MOV	DI,[SI].LHPOFF	;get offset of the string
	PUSH	ES		;make sure that we use the proper
	PUSH	DS		;segment in case that
	POP	ES		;we are in the middle of unwinding a CHAIN
	REPNE	SCASW		;scan for word in AX
	POP	ES		;recover correct ES = BASIC DS
	JNZ	FLDDESCADJ_NEXT ;if not there, try next

;	Word found in string.  DI is pointing just after the word
;	while CX contains the number of words in the string AFTER
;	the one searched.  If modifying (DX<>0), just add the adjustment
;	factor to the word.

	ADD	[DI-2],DX	;assume adjustment is made (deleted otherwise)
	OR	DX,DX		;test if adjustment really wanted
	JNZ	FLDDESCADJ_DONE ;if so, then jump to return now

;	If deleting (DX=0), start at DI and move CX words left by two
;	and put a null free string header where the last word of the
;	string was.

	SUB	WORD PTR [SI].LHPLEN,2 ;string size is less by 2
	JZ	FLDDESCADJ_CLR	;jump if string is now empty
	MOV	SI,DI		;SI points to byte after
	DEC	DI		;point DI to...
	DEC	DI		;the word before (AX value)
	PUSH	ES		;make sure that we use the proper
	PUSH	DS		;segment in case that
	POP	ES		;we are in the middle of unwinding a CHAIN
	REP	MOVSW		;move the string left 2
	POP	ES		;recover correct ES = BASIC DS
	MOV	WORD PTR [DI],1 ;null string free header
	JMP	SHORT FLDDESCADJ_DONE ;done, jump to finish
FLDDESCADJ_CLR:
	XOR	DI,DI		;clear register
	XCHG	DI,[SI].LHPOFF	;clear descr offset, get it
	MOV	WORD PTR [DI-2],3 ;set ptr to empty string
FLDDESCADJ_DONE:
	POP	DI		;restore registers...
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET			;return to caller

FLDDESCADJ_ERROR:
	JMP	B$ERR_SSC	; report string space corruption
assumes	DS,DGROUP		
assumes	ES,NOTHING		

;***
; B$LHNXTFIL, NXTFIL_ES - return FDB pointer of next file in heap after [SI]
; Purpose:
;	To return a pointer to the next FDB in the heap.  The
;	local heap is searched from the last FDB specified in SI
;	(or the first if SI=0).
;
; Inputs:
;	SI = pointer to FDB to start search from (0 if first FDB
;	     pointer is to be returned).
; Outputs:
;	SI = pointer to next FDB after the one specified on routine
;	     entry (0 if no more FDB's in the heap).
;	ZF = clear if FDB returned
;	     set if none returned
; Modifies:
;	None.
; Exceptions:
;	None.
;****
NXTFIL_ES:			;Assumes ES already set up
	PUSH	ES		
	JMP	SHORT NXTFIL_COMMON 

B$LHNXTFIL:			
	PUSH	ES		
	PUSH	DS		
	POP	ES		;set ES = DS

NXTFIL_COMMON:			;common entry
	ASSERT_NOT_VARHEAP NH_TEXT 
assumes	ES,DGROUP		
assumes	DS,NOTHING		
	OR	SI,SI		;test if first file is to be searched
	JNZ	NXTFIL_NEXT	;if so, then branch
	MOV	SI,ES:[b$HEAP_FIRST] ;initialize to start of local heap
	ADD	SI,3		;adjust to avoid extra jump
NXTFIL_NEXT:
	SUB	SI,3		;move from FDB over backlength to next entry
NXTFIL_LOOP:
	CMP	[SI].LHTYPE,LOW LH_END ;test if last entry in heap
	JE	NXTFIL_END	;if so, then jump
	CMP	[SI].LHTYPE,LOW LH_FILE ;test if entry is file
	JE	NXTFIL_FILE	;if so, then jump
	SUB	SI,[SI].LHLEN	;point to next heap entry
	JMP	SHORT NXTFIL_LOOP ;and continue the search
NXTFIL_FILE:
	SUB	SI,[SI].LHLEN	;point to previous entry
	ADD	SI,3		;move over backlength to entry FDB
assumes	ES,NOTHING		
	POP	ES		
	RET			;return to caller (ZF clear)
NXTFIL_END:
	XOR	SI,SI		;clear to show no more files
	POP	ES		
	RET			;return to caller (ZF set)

;***
;B$LH_PTR_FROM_DATA - get heap entry pointer from data pointer
;LH_PTR_FROM_BLEN - get heap entry pointer from backlength pointer
;B$LH_PTR_CHECK     - check heap entry referenced by its pointer
;
;Purpose:
; From the pointer given return the heap entry data pointer. Also check the
; heap entry by matching its length and backlength values and confirming that
; the length is nonzero.
;
;Inputs:
; SI = specified pointer
;
;Outputs:
;
; SI = heap entry header pointer
;
;Modifies:
; None.
;
;Exceptions:
; If heap entry is inconsistent, jump to B$ERR_SSC.
;****

B$LH_PTR_FROM_DATA:
	SUB	SI,2		;now point to entry backlength
LH_PTR_FROM_BLEN:
	ADD	SI,[SI] 	;point to one past header entry
	DEC	SI		;point to header entry
B$LH_PTR_CHECK:
	PUSH	AX		;save registers...
	PUSH	DI
	MOV	AX,[SI].LHLEN	;get length of heap entry
	MOV	DI,SI		;compute offset of entry backlength...
	SUB	DI,AX		;by moving the pointer to before backlength
	CMP	[DI+1],AX	;compare entry length and backlength
	JNE	LH_PTR_ERROR	;if not equal, then report error
	OR	AX,AX		;test for illegal zero value
	JZ	LH_PTR_ERROR	;if so, then jump
	POP	DI		;restore registers...
	POP	AX
	RET			;return to caller

LH_PTR_ERROR:
	PUSH	ES		;force DS = basic dgroup in case
	POP	DS		;we are unwinding chain
assumes	DS,DGROUP		
	DbHalt NH_TEXT,<B$LH_PTR_CHECK found inconsistent heap entry>
	JMP	B$ERR_SSC	;note heap is inconsistent if ID_RELEASE version

;***
; B$LHSetFree - set free heap entry pointer
; Purpose:
;	Determines if the current free heap entry is both the last
;	heap entry and unallocated.  If so, its current value is
;	returned in DI.  Otherwise, the free heap entry pointer
;	[b$HEAP_FREE] is set to the heap space end and its value returned
;	in DI.
;
; Inputs:
;	None.
; Outputs:
;	DI = pointer to free heap entry [b$HEAP_FREE].
; Modifies:
;	AX.
; Exceptions:
;	None.
;****
B$LHSetFree	PROC	NEAR
	MOV	DI,[b$HEAP_FREE] ;point to free heap entry
	CMP	[DI].LHTYPE,LOW LH_FREE ;test if entry unallocated
	JNE	LH_SET_END	;if allocated, then jump
	MOV	AX,DI		;get pointer to free entry
	SUB	AX,[DI].LHLEN	;point to entry after free one
	CMP	AX,[b$HEAP_END] ;test if free entry was last in space
	JE	LH_SET_RETURN	;if so, jump leaving pointer unchanged
LH_SET_END:
	MOV	DI,[b$HEAP_END] ;get pointer to heap end
	CMP	DI,[b$HEAP_FIRST] ; Empty heap?
	JZ	LH_SET_FREE	; then don't try anything fancy
	MOV	AX,DI		; [AX] = pointer to end entry
	ADD	AX,[DI+1]	; [AX] = pointer to entry before end
	XCHG	AX,DI		; [AX] = ptr to end, [DI] = entry before
	CMP	[DI].LHTYPE,LOW LH_FREE ; test if entry after unallocated
	JZ	LH_SET_FREE	; if so, that's the free entry
	XCHG	AX,DI		; else use end entry
LH_SET_FREE:
	MOV	[b$HEAP_FREE],DI ;and set the free pointer to it
LH_SET_RETURN:
	RET			;return with DI pointing to free entry
B$LHSetFree	ENDP

	SUBTTL	B$NHINIT - Initialize dynamic space
	PAGE
;***
; B$NHINIT - Initialize dynamic space
; Purpose:
;	Initialize the necessary pointers and structures for string and
;	local heap space.
; Inputs:
;	AX = first word of dynamic space.
;	CX = last word of dynamic space.
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	None.
;****
cProc	B$NHINIT,<PUBLIC,NEAR>,<AX,BX,CX,SI,DI>	
cBegin					

	MOV	SI,CX			;get last word of dynamic space
	INC	SI			;point to last byte of space
	MOV	[b$HEAP_FIRST],SI	;the local heap starts here...
	MOV	[b$HEAP_FREE],SI	;has its free entry here...
	MOV	[b$HEAP_END],SI 	;and ends here
	MOV	[SI].LHTYPE,LOW LH_END	;set the heap entry type

	ADD	AX,LH_STD_HDR_LEN	; dyn space starts after var heap
	MOV	[b$NH_first],AX	
	MOV	BX,AX			
	DEC	BX			; point to last byte of var heap
	MOV	[b$HEAP_FIRST_SWAP],BX	; the variable heap starts here...
	MOV	[b$HEAP_FREE_SWAP],BX	; has its free entry here...
	MOV	[b$HEAP_END_SWAP],BX	; and ends here
	MOV	[BX].LHTYPE,LOW LH_END	; set heap entry type
	;Set up pointers to routine to be called when B$ILHALC needs to
	;  grow the appropriate heap
	MOV	[P_HEAP_GROW_SWAP],NH_TEXTOFFSET B$VAR_ALC_GROW ;[ln]
	MOV	[b$P_HEAP_GROW],NH_TEXTOFFSET LH_ALC_GROW	;[ln]
	SUB	SI,LH_STD_HDR_LEN+1	;point to even address before entry
	CMP	b$Clearing,0		;are we doing a CLEAR statement?
	JZ	NotClearing		;no, go initialize string space
	CALL	B$SSClean		; clean out entries, so we don't
	JMP	SHORT InitExit		; bash function keys
NotClearing:				
	CALL	B$STINIT		;initialize string space
InitExit:				

cEnd					

sEnd	NH_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\nhstutil.asm ===
TITLE	NHSTUTIL - String space utilities
;***
; NHSTUTIL - String space utilities
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

		USESEG	_DATA
		USESEG	_BSS
		USESEG	NH_TEXT
		USESEG	COMMON	


	INCLUDE seg.inc
	INCLUDE idmac.inc
	INCLUDE nhutil.inc	


ASSERT_NOT_VARHEAP	MACRO	SEG	;
	ENDM				;

sBegin	_DATA

	PUBLIC	b$nuldes	

NULSTR		DW	DGROUP:b$nuldes  ;Backpointer to descriptor
b$nuldes	DW	0,DGROUP:NULSTR+2 ;Descriptor for zero-length string

	NUMTEMP = 20D		;number of string temps
	LENTEMP = 6		;descriptor length is six bytes

TMPL		DW	NUMTEMP*(LENTEMP/2) DUP(-1) ;temp string descriptors
TMPH		LABEL	WORD

	externW	b$NH_first	; defined in nhinit.asm
sEnd	_DATA

sBegin	_BSS

	PUBLIC	b$STRING_FIRST
b$STRING_FIRST	DW	1 DUP(?)	;String space FWA (even)
	PUBLIC	b$STRING_FREE
b$STRING_FREE	DW	1 DUP(?)	;Scan for free string space from here
	PUBLIC	b$STRING_END
b$STRING_END	DW	1 DUP(?)	;String space LWA (odd)

	EXTRN	b$HEAP_FREE:WORD ;defined in LHUTIL.ASM
	EXTRN	b$HEAP_END:WORD	;defined in LHUTIL.ASM

	EXTRN	b$STRTAB:WORD		
	EXTRN	b$STRTAB_END:WORD	

	EXTRN	b$HEAP_FIRST_SWAP:WORD	;defined in LHUTIL.ASM
	EXTRN	b$HEAP_END_SWAP:WORD	;defined in LHUTIL.ASM

TMPHDR		DW	1 DUP(?)

	externW b$curlevel		;current program level

	externW b$fVarHeapActive	; non-0 when variable heap is

	externB b$Chaining	; in chain flag
	externW b$commonfirst	
	externW b$commonlast	


sEnd	_BSS

PAGE
sBegin	NH_TEXT

	ASSUMES CS,NH_TEXT

	PUBLIC	B$STINIT	;initialize string space
	PUBLIC	B$STCHKTMP	;check if temp string
	PUBLIC	B$STALCTMP	;allocate temp string
	PUBLIC	B$STALCTMPCPY	;allocate temp string copy
	PUBLIC	B$STALCTMPSUB	;allocate temp substring copy
	PUBLIC	B$STALCMAXTMP	;allocate maximum length temp string
	PUBLIC	B$STALCMAXTMPNC ; allocate max len temp str w/o compacting
	PUBLIC	B$STDALCTMP	;deallocate if temp string
	PUBLIC	B$STDALCTMPDSC ;deallocate temporary string desc
	PUBLIC	B$STDALCALLTMP ;deallocate all temp strings
	PUBLIC	B$STADJ	;deallocate/adjust string

	PUBLIC	B$STALC	;allocate string data
	PUBLIC	B$STDALC	;deallocate string
	PUBLIC	B$STMOV	;move string space start

	PUBLIC	B$STCPCT	;compact string space

	PUBLIC	B$STGETFRESIZ	;get size of free string in string space
	PUBLIC	B$STSWAPDESC	;swap the given string descriptors
	PUBLIC	B$STGETSTRLEN	;get string length

	PUBLIC	B$STFromLH
	PUBLIC	B$STSetFree

	PUBLIC	B$STPUTZ

PAGE
externNP B$ERR_SSC		

	externNP B$LHFLDDESCADJ 
	EXTRN	B$LHSetFree:NEAR
	EXTRN	B$ERR_OS:NEAR	
	EXTRN	B$ERR_ST:NEAR	

externNP B$TglHeapSptNEAR	; switch context to local heap

;*** 
;B$ISTALCTMPSUB - Allocate temporary substring copy
;
;Purpose:
;	FAR entry point for Interpreter added with revison [42].
;Entry:
;	Same as B$STALCTMPSUB
;Exit:
;	Same as B$STALCTMPSUB
;Uses:
;	Same as B$STALCTMPSUB
;Preserves:
;	Same as B$STALCTMPSUB
;Exceptions:
;	Same as B$STALCTMPSUB
;******************************************************************************
cProc	B$ISTALCTMPSUB,<FAR,PUBLIC>
cBegin
	call	B$STALCTMPSUB		; do a near call to do the work
cEnd

;*** 
;B$ISTDALCTMP - Deallocate if temporary string
;
;Purpose:
;	FAR entry point for Interpreter added with revison [42].
;Entry:
;	Same as B$STDALCTMP
;Exit:
;	Same as B$STDALCTMP
;Uses:
;	Same as B$STDALCTMP
;Preserves:
;	Same as B$STDALCTMP
;Exceptions:
;	Same as B$STDALCTMP
;******************************************************************************
cProc	B$ISTDALCTMP,<FAR,PUBLIC>
cBegin
	call	B$STDALCTMP		; do a near call to do the work
cEnd


PAGE
;***
; B$STALC - allocate string
; Purpose:
;	Find and allocate an appropriate chunk of string space.
;	The requested length will be rounded up if odd because
;	allocation is by 16-bit words only.  An extra word is
;	added to the front as required by the string format for
;	the backpointer.  This backpointer is NOT set up but it
;	must be before any scan of string space is made (by
;	B$STALC, B$STCPCT, etc.).
;
;	Each successive step is tried until the allocation is done:
;
;	1. Test the free string entry.	This entry, pointed by [b$STRING_FREE],
;	   can usually allocate the desired storage unless the space is
;	   nearly filled or extremely fragamented.  It usually follows
;	   last allocated entry or is the unallocated storage after a
;	   string space compaction.
;
;	2. String space is searched for the first unallocated space large
;	   enough to satisfy the requested length.  Adjacent unallocated
;	   entries are concatenated as they are found before any
;	   allocation is attempted.  The string space segment from the
;	   free pointer [b$STRING_FREE] to the end pointer [b$STRING_END] is
;	   scanned first. The segment from the start pointer [b$STRING_FIRST]
;	   to the free pointer is then scanned if allocation did not occur.
;
;	3. If the local heap free entry is unallocated and last in the
;	   heap space, the heap-string boundary is moved to reclaim the
;	   entry into string space.  The space now becomes part of the
;	   free string which is then tested for allocation.
;
;	4. The string space is compacted, with all allocated strings
;	   adjacent in lower memory and the remaining space made into
;	   the free string.  The free string is then tested.
;
;	5. The local heap is compacted with all allocated entries adjacent
;	   in upper dgroup, and the remaining free space given to string
;	   space.  The free string is then tested.
;
;	6. The Far Heap is asked to move its bottom....in case it had
;	   previously robbed space from DS. We then grab any additional space
;	   from near heap, and try the resulting free string.
;
;	7. If QBI version, the user library data images are released, the
;	   far heap is moved up in memory, the local heap is moved up, and
;	   and any resulting free space is returned to string space.
;
;	If no allocation can be done, the program is aborted by
;	   the nontrappable  "Out of Memory" error.
;
; Inputs:
;	BX = Length of string space required (may be odd).
; Outputs:
;	BX = Address of string data.  BX-2 is the header location.
; Modifies:
;	None.
; Exceptions:
;	None.
;****
B$STALC:

DbAssertRel	[b$STRING_FREE],BE,[b$STRING_END],NH_TEXT,<B$STALC: b$STRING_FREE past b$STRING_END> 
DbAssertRel	[b$STRING_FREE],AE,[b$STRING_FIRST],NH_TEXT,<B$STALC: b$STRING_FREE prior to b$STRING_FIRST> 

	PUSH	AX		;save the registers used...
	PUSH	SI

;	Round up BX to an even value and then add one.	This value
;	would be the unallocated string header value that could just
;	accomodate the allocation.

	INC	BX		;add one and...
	JZ	OutOfSS		; brif overflow -- out of string space
	OR	BL,1		;set bit for header value

;	Step 1 - Test if free string can perform allocation.

	CALL	SS_ALC_FREE	;try to allocate from free string
	JNC	ALCSTR_FREE	;if successful, then jump to return

	PUSH	CX		;push more registers...
	PUSH	DX
	PUSH	DI

;	Step 2 - Scan [b$STRING_FREE] to [b$STRING_END],
;		 then [b$STRING_FIRST] to [b$STRING_FREE].

	CALL	SS_SCAN 	;scan around the free pointer
	JNC	ALCSTR_DONE	;jump if allocation successful

;	Step 3 - Combine adjoining heap entries, test free string.

	CALL	B$STFromLH	;combine trailing entries into free string
	CALL	SS_ALC_FREE	;test if free string can handle allocation
	JNC	ALCSTR_DONE	;jump if allocation successful

;	Step 4 - Perform string space compaction, test free string.

	CALL	B$STCPCT	;perform the compaction
	CALL	SS_ALC_FREE	;test free string for room
	JNC	ALCSTR_DONE	;jump if allocation successful

;	No allocation possible, jump to error routine.

OutOfSS:			
	JMP	B$ERR_OS	; give "Out of string space" error

;	Allocation successful - clean stack and return.

ALCSTR_DONE:
	POP	DI		;restore registers used...
	POP	DX
	POP	CX

ALCSTR_FREE:
	POP	SI
	POP	AX

DbAssertRel	BX,BE,[b$STRING_END],NH_TEXT,<B$STALC: String alloc past b$STRING_END> 
DbAssertRel	BX,AE,[b$STRING_FIRST],NH_TEXT,<B$STALC: String alloc prior to b$STRING_FIRST> 

	RET			;return with BX pointing to new data
PAGE
;***
; SS_ALC_FREE - test if free string can allocate the request length
;
; Inputs:
;	BX - length of string data to allocate.
;	[b$STRING_FREE] - pointer to string to test
;
; Outputs:
;	CF=0 - allocation was successful.
;	     BX - pointer to data in new string.
;	     [b$STRING_FREE] - updated to new free string.
;	CF=1 - allocation failed.
;****

SS_ALC_FREE:
	MOV	SI,[b$STRING_FREE] ;point to the free string
	MOV	AX,[SI] 	;get free string header
	TEST	AL,1		;test if free string allocated
	JZ	SS_ALC_NO_ALLOC ;if so, cannot allocate from it
	CMP	AX,0FFFFH	;test if free string at string space end
	JZ	SS_ALC_NO_ALLOC ;if so, cannot allocate from it
	CMP	BX,AX		;test requested header against free header
	JA	SS_ALC_NO_ALLOC ;if requested too large, cannot allocate

;	SS_ALC - allocate string from string space entry pointed by SI.
;		 BX - header of requested string allocation
;		 AX - header of current entry pointed by SI
;		 ZF - set if BX=AX else cleared

SS_ALC:
	JE	SS_ALC_EXACT	;jump if exact allocation to be done

;	Split the current string into the requested allocation in lower
;	addressed portion and the new free string in the higher portion.

	MOV	[SI],BX 	;move in new allocated string header
	INC	BX		;length of allocated string entry (hdr+data)
	SUB	AX,BX		;subtract to get new free header value
	XCHG	BX,SI		;BX=alloc string entry ptr - SI=alloc length
	ADD	SI,BX		;pointer to new free string entry
	MOV	[SI],AX 	;move in new free string header value
	MOV	[b$STRING_FREE],SI ;update free string pointer
	ADD	BX,2		;pointer to allocated string data (carry clear)
	RET			;return to caller in B$STALC

;	Exact allocation just updates the free string pointer [b$STRING_FREE]
;	and points to the data location of the current string entry.

SS_ALC_EXACT:
	STC			;set carry for add to follow
	ADC	[b$STRING_FREE],AX ;add current entry length (hdr+data)
	MOV	BX,SI		;get current entry pointer
	ADD	BX,2		;and point to the data part (carry clear)
	RET			;return to caller in B$STALC

;	If failure, then set carry for return

SS_ALC_NO_ALLOC:
	STC			;carry set for failure
	RET			;return to caller in B$STALC
PAGE
;***
; SS_SCAN - scan string space for allocation
; Purpose:
;	Scan string space for a first-fit allocation of the specified
;	amount of space.  The scan starts from the free string to
;	string space end.  If unsuccessful, the scan continues from
;	string space start to the free string.
;
; Inputs:
;	BX = amount of space to allocate
; Outputs:
;	CF=0 - allocation successful
;	       BX = pointer to string data
;	       [b$STRING_FREE] = points to entry past one allocated
;	CF=1 - allocation failed
;	       [b$STRING_FREE] = points past last allocated entry
;****

SS_SCAN:

;	Scan from free string to end of string space.

	MOV	SI,[b$STRING_FREE] ;start of search
	MOV	DX,[b$STRING_END]	;end of search
	CALL	SS_SCAN_START	;start the scan...
	JNC	SS_SCAN_RETURN	;jump if allocation successful

;	Scan from start of string space to free string.
;	DX contains the pointer past the last allocated entry

	MOV	SI,[b$STRING_FIRST] ;start of search
	XCHG	DX,[b$STRING_FREE] ;swap last entry and end of search
	CALL	SS_SCAN_START	;start the scan...
	JNC	SS_SCAN_RETURN	;jump if allocation successful

;	Determine the last allocated entry in string space and
;	set the free string pointer just past it.  This will be needed
;	for the next allocation step of combining the free heap entry.

	CMP	DX,[b$STRING_FREE] ;test if the pointer should be changed
	JA	SS_SCAN_FREE	;if not, then jump
	MOV	[b$STRING_FREE],DX ;update the pointer
SS_SCAN_FREE:
	STC			;note allocation failure
SS_SCAN_RETURN:
	RET			;and return to B$STALC
PAGE
;***
; SS_SCAN_START - scan string for allocation of length requested.
;
; Inputs:
;	BX - length of string data to allocate.
;	SI - pointer to start of search.
;	DX - pointer to end of search.
; Outputs:
;	CF=0 - search was successful.
;	       BX - pointer to data in new string.
;	       [b$STRING_FREE] - updated to new free string.
;	CF=1 - search failed.
;	       DX - pointer past last allocated entry
;		    (either string space end or the last entry
;		     when it is unallocated)
;****

;	Test if string at scan pointer (SI) is allocated.
;	If so, get length of string header and data in AX.
;	Jump if string space end encountered (0FFFFH entry).

SS_SCAN_START:
	MOV	AX,[SI] 	;get scan ptr string header
	TEST	AL,1		;test if string is allocated
	JZ	SS_SCAN_SKIP	;if allocated, then jump
	INC	AX		;get length of string header and data
	JZ	SS_SCAN_FAILED	;jump if string space end was read

;	Compute pointer to next entry in DI.

	MOV	DI,SI		;get copy of current entry pointer
	ADD	DI,AX		;add entry length (header and data) for next
	DEC	AX		;return header value (data+1)

;	Test next block (pointed by DI) for possible combination with
;	the current block (pointed by SI).
;	If both are unallocated, then combine and try again.

SS_SCAN_NEXT:
	MOV	CX,[DI] 	;get header of next string entry
	TEST	CL,1		;test if next entry is allocated
	JZ	SS_SCAN_TRY_ALLOC ;if so, then try allocation with current
	INC	CX		;get length of string header and data
	JZ	SS_SCAN_TRY_FINAL ;if string end, then try final allocation
	ADD	AX,CX		;add entry length to current header value
	ADD	DI,CX		;move the next block pointer along
	JMP	SHORT SS_SCAN_NEXT ;and continue the scanning

;	Check entry at SI (with header AX) for sufficient room.
;	If not enough, compute the pointer to the entry after the
;	allocated one that stopped the combining.

SS_SCAN_TRY_ALLOC:
	MOV	[SI],AX 	;update the header in the current entry
	CMP	AX,BX		;compare current header with needed one
	JAE	SS_SCAN_ALC	;if enough room, then finish allocation
	MOV	AX,CX		;move header (descriptor) of allocated entry
	MOV	SI,DI		;skip past allocated entry pointed by DI

;	Compute pointer after the allocated entry at SI whose descriptor
;	is pointed by AX.

SS_SCAN_SKIP:
	MOV	DI,AX		;move descriptor pointer for referencing
	ADD	SI,[DI] 	;add length of string to pointer
	ADD	SI,3		;add 2 for header and 1 for even roundup
	AND	SI,NOT 1	;finish roundup process
	CMP	SI,DX		;test new pointer to scan finish
	JBE	SS_SCAN_START	;if not finished, then try again

;	The scan has failed, set carry and return.
;	Set DX to string space end since last entry was allocated.

SS_SCAN_FAILED:
	MOV	DX,SI		;points to string space end
	STC			;set carry to show failure
	RET			;and return to caller

;	Try a final allocation.  If the allocation fails, then scan fails.

SS_SCAN_TRY_FINAL:
	MOV	[SI],AX 	;update current string entry
	CMP	AX,BX		;compare current header with needed one
	JNAE	SS_SCAN_BYPASS	;if not enough room, bypass long jump
SS_SCAN_ALC:
	MOV	[b$STRING_FREE],SI ;set scanned entry as free string
	JMP	SS_ALC		;if room, jump to finish allocation
SS_SCAN_BYPASS:
	MOV	DX,SI		;point to last unallocated entry
	RET			;return to caller with carry set
PAGE
;***
; B$STCPCT - compact string space
; Purpose:
;	Compacts all allocated strings to the bottom of string space.
;	The string descriptors referenced by the string header are
;	adjusted to reflect their movement.
;	The remaining unallocated space is made into the free string.
;
; Inputs:
;	None.
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	B$ERR_SSC - nontrappable error if compaction finds corruption
;		  in string space structure.
;****

B$STCPCT:
	PUSH	AX		;save registers used...
	PUSH	BX
	PUSH	CX
	PUSH	SI
	PUSH	DI
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS

	MOV	SI,[b$STRING_FIRST] ;pointer to string scan

;	Skip over leading allocated entries which can be ignored since
;	they will not be moved.

SS_CPCT_SKIP:
	MOV	BX,[SI] 	;get header of scanned string entry
	TEST	BL,1		;test if entry is allocated
	JNZ	SS_CPCT_FIRST_FREE ;if not allocated, skipping is over

;	Entry is allocated.  First test for backpointer consistency.

	MOV	AX,[BX+2]	;get descriptor pointer to string data
	SUB	AX,2		;adjust to point to string header
	CMP	AX,SI		;test for backpointer consistency
	JNE	SSC_ERR 	; if not, signal string space corruption

;	Compute from descriptor string length the entry length and
;	therefore, the next string entry.  Jump to process this new entry

	ADD	SI,[BX] 	;add string length from descriptor
	ADD	SI,3		;add 2 for header length and 1 for roundup
	AND	SI,NOT 1	;complete roundup to next word
	JMP	SHORT SS_CPCT_SKIP ;and try again for next entry

;	First unallocated string found.  Initialize compacted pointer DI.

SS_CPCT_FIRST_FREE:
	MOV	DI,SI		;SI=scan pointer - DI=compacted pointer

;	Unallocated entry encountered in scan.	First test if string space
;	end (0FFFFH) and if so, jump to finish up.  Otherwise advance the
;	scan pointer SI by the entry size.

SS_CPCT_NEXT_FREE:
	INC	BX		;entry size from header value (hdr+size)
	JZ	SS_CPCT_END	;if it was 0FFFFH, then jump for end
	ADD	SI,BX		;advance scan pointer to next entry

;	Process next entry at scan pointer SI.	If entry unallocated, jump
;	to process it above.

SS_CPCT_NEXT_STRING:
	MOV	BX,[SI] 	;get header of scanned entry
	TEST	BL,1		;test if entry is allocated
	JNZ	SS_CPCT_NEXT_FREE ;if not, then jump to advance scan pointer

;	Entry is allocated.  First test for backpointer consistency.

	MOV	AX,[BX+2]	;get string data offset from descriptor
	SUB	AX,2		;adjust to point to string entry
	CMP	AX,SI		;test for consistency
	JNE	SSC_ERR 	; jump to process corruption error

;	Allocated entry at SI must be moved down to compacted space at DI.
;	First adjust descriptor pointer from SI+2 to DI+2.

	MOV	AX,DI		;get compacted space pointer
	ADD	AX,2		;point to new data portion of moved string
	MOV	[BX+2],AX	;and move it to the descriptor pointer

;	Move the string entry at SI to DI.

	MOV	CX,[BX] 	;get length of string to move
	ADD	CX,3		;add 2 for header and 1 for roundup
	SHR	CX,1		;length of entry in words
	REP	MOVSW		;move the string - SI and DI updated
	JMP	SHORT SS_CPCT_NEXT_STRING ;jump to process next entry

;	String space end encountered.  Put space between pointers SI and
;	DI into one unallocation string entry and make it the free string.

SS_CPCT_END:
	SUB	SI,DI		;get length of new free string entry at DI
	JE	SS_CPCT_NO_FREE ;if no space, then just update [b$STRING_FREE]
	DEC	SI		;new value of header (string data + 1)
	MOV	[DI],SI 	;move in new free string header
SS_CPCT_NO_FREE:
	MOV	[b$STRING_FREE],DI ;update new free string pointer

;	Finished with compaction - restore registers and return.

	POP	ES		
	POP	DI		;restore registers...
	POP	SI
	POP	CX
	POP	BX
	POP	AX
	RET			;return to caller

SSC_ERR:			
	JMP	B$ERR_SSC	;[23]
PAGE
;***
; B$STMOV - move string space
; Purpose:
;	Moves string space to the offset specified in AX.  String space
;	start [b$STRING_FIRST] is now set to AX and the free string entry
;	is adjusted since the string space end at [b$STRING_END] remains
;	as the same value.  The space is returned compacted.
;
; Inputs:
;	SI = offset for new string space start.
; Outputs:
;	CF = 0 - no error
;	     1 - error, not enough memory for move
; Modifies:
;	None.
; Exceptions:
;	B$ERR_SSC - nontrappable error if compaction finds corruption
;		  in string space structure.
;****

B$STMOV:
	PUSH	AX		;save registers...
	PUSH	SI


;	Determine if string space is to be expanded, contracted, or
;	neither.

	MOV	AX,[b$STRING_FIRST] ;get present start of string space
	CMP	SI,AX		;test new start with present start offset
	JE	MOVSTR_COMPACT	;if no difference, then just return
	JB	MOVSTR_DOWN	;if less, then expand space

;	Contract string space by compacting, moving allocated
;	strings up in memory, and adjusting the free string size.

	CALL	B$STCPCT	;compact the string space
	CALL	B$STFromLH	;get any leading heap entries
	CALL	SS_MOV_UP	;move allocated strings up to [SI]
				;this call sets carry if not enough memory
	JMP	SHORT MOVSTR_RETURN ;finished - jump to return

;	Expand string space by prefixing an unallocated string entry
;	located from the new offset to the old and then compacting.

MOVSTR_DOWN:
	SUB	AX,SI		;get size of string entry to create
	DEC	AX		;header is data length plus one
	MOV	[SI],AX 	;place header value in string entry
	MOV	[b$STRING_FIRST],SI ;new value of string space start
	MOV	[b$NH_first],SI ; start of string space is start of dynamic
				 ; space for QB4
MOVSTR_COMPACT:
	CALL	B$STCPCT	;compact strings with new entry
	CALL	B$STFromLH	;get any leading heap entries
	CLC			;clear carry for no error

MOVSTR_RETURN:
	POP	SI		;restore registers...
	POP	AX
	RET			;return...
PAGE
;***
; SS_MOV_UP - move allocated string entries up
; Purpose:
;	Assuming a compacted string space, move all allocated entries
;	starting at offset [SI].  This is done by updating the string
;	descriptor offsets to point to the new entry locations and
;	then moving the allocated strings up as a block.  The new free
;	string is then created as well as the new [b$STRING_FIRST] and
;	[b$STRING_FREE] pointers.
;
; Inputs:
;	AX = offset of present string space start.
;	SI = offset for new string space start.
; Outputs:
;	CF = 0 - no error
;	     1 - error, not enough memory for move
; Modifies:
;	AX, SI.
; Exceptions:
;	None.
;****

SS_MOV_UP:
	PUSH	BX		;save registers...
	PUSH	CX
	PUSH	DI
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	XCHG	AX,SI		;AX=new offset - SI=present offset
	SUB	AX,SI		;compute adjustment factor for move up

;	Test if enough room exists to move the strings down in memory.
;	The present free string will be reduced by the adjustment factor,
;	so a negative string length sets carry to denote the error.

	CALL	B$STGETFRESIZ	;get size of free string in BX
	CMP	BX,AX		;compare present free length with adj factor
	JB	SS_MOV_RETURN	;return immediately with carry set

;	Scan through the compacted string space using pointer [SI] and
;	adjust the string descriptor referenced by the backpointer by
;	adding AX to the offset word.

SS_MOV_SCAN_LOOP:
	MOV	BX,[SI] 	;get header of current scanned entry
	TEST	BL,1		;test if entry is allocated
	JNZ	SS_MOV_BLOCK	;if not allocated, then end of scan, jump
	ADD	[BX+2],AX	;adjust the descriptor offset up
	ADD	SI,[BX] 	;add string length to scan pointer
	ADD	SI,3		;add for header and round up to next word...
	AND	SI,NOT 1	;if string length was odd
	JMP	SHORT SS_MOV_SCAN_LOOP ;loop to try for next entry

;	Move all allocated strings together up AX bytes in memory.

SS_MOV_BLOCK:
	MOV	SI,[b$STRING_FREE] ;entry past last allocated one
	MOV	CX,SI		;get offset to compute block length...
	SUB	CX,[b$STRING_FIRST] ;by subtracting start of string space
	SHR	CX,1		;get number of words to move
	SUB	SI,2		;point to highest word to move
	MOV	DI,SI		;compute destination...
	ADD	DI,AX		;by adding amount to move up
	STD			;moving up requires direction flag set
	REP	MOVSW		;perform the move of CX words
	CLD			;restore direction flag

;	Adjust string space pointer and create new free entry.

	ADD	[b$STRING_FIRST],AX ;adjust new start of string space
	ADD	[b$NH_first],AX ; start of string space is start of dynamic
				 ; space for QB4
	MOV	BX,[b$STRING_FREE] ;get original free entry offset
	ADD	BX,AX		;compute new free entry offset
	MOV	[b$STRING_FREE],BX ;put in new free entry offset
	MOV	CX,[b$STRING_END]	;get unchanging end offset of string space
	SUB	CX,BX		;get size of new free entry
	DEC	CX		;header is data length + 1 (entry length - 1)
	MOV	[BX],CX 	;define new free entry by inserting header

SS_MOV_RETURN:
	POP	ES		
	POP	DI		;restore registers...
	POP	CX
	POP	BX
	RET			;return to caller
PAGE
;***
; B$STALCMAXTMP	- allocate maximum-sized temporary string
; B$STALCMAXTMPNC      - Allocate maximum-sized temp string w/o compact
; Purpose:
;	Allocate the maximum-sized string availiable and attach it to a temp
;	descriptor. Backpointer in string space set but data is not moved in.
;
; Inputs:
;	None.
; Outputs:
;	DX = Address of string data area.
;	BX = Address of temp string descriptor
; Modifies:
;	None.
; Exceptions:
;	None.
;****

cProc	B$STALCMAXTMP,<PUBLIC,NEAR>	
cBegin					
	CALL	B$STCPCT	;compact the string space

labelNP	<B$STALCMAXTMPNC>	; Alloc after compaction

	CALL	B$STFromLH	;append any leading local heap entries
	CALL	B$STGETFRESIZ	;get the resulting free string size in BX
	PUSH	[b$STRING_FREE]	; Save ptr to free size
	CALL	B$STALCTMP	;use the size in BX to allocate temp string
	POP	[b$STRING_FREE]	; Get back saved value
				; return to caller (PAINT)
cEnd				; End of B$STALCMAXTMP,B$STALCMAXTMPNC

PAGE
;***
;B$STALCTMP - allocate temporary string
;DBCS-callback
;
;Purpose:
;	Allocate the requested amount of free space and attach it to a temp
;	descriptor. Backpointer in string space set but data is not moved in.
;
;Inputs:
;	BX = Length of string
;
;Outputs:
;	DX = Address of string data area.
;	BX = Address of temp string descriptor
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, CX
;
;Exceptions:
;	None
;****

B$STALCTMP:
	OR	BX,BX
	JZ	ATSNUL		;Nul strings have special descriptor
	CMP	WORD PTR[TMPHDR],0 ;See if we have any temps left
	JZ	TEMPOV
	PUSH	SI
	PUSH	BX
	CALL	B$STALC	;[C1]Allocate the space

ALCTMP: 			;jumped to from MakeTemp
	MOV	SI,[TMPHDR]	;Get the next temp
	MOV	DX,[SI] 	;Make the one after that
	MOV	[TMPHDR],DX	;   the new "next temp"
	POP	[SI]		;Set length in descriptor
	MOV	[BX-2],SI	;Set backpointer
	MOV	[SI+2],BX	;Set pointer in descriptor
	MOV	DX,b$curlevel	;set program level of allocation
	MOV	[SI+4],DX	;  in descriptor
	MOV	DX,BX		;Put data pointer in DX
	MOV	BX,SI		;Need temp descriptor in BX
	POP	SI
	RET

;	Return pointer to null string.

ATSNUL:
	MOV	DX,OFFSET DGROUP:NULSTR
	MOV	BX,OFFSET DGROUP:b$nuldes 
	RET

TEMPOV:
	JMP	B$ERR_ST	; Clean stack and report string temporary ovfl.
PAGE
;***
;B$STMakeTemp - transfer ownership of a string to a temp. (QBI only).
;
;Purpose:
;	Added with revision [22].
;	Transfers ownership of a string to a temp.  This is used
;	for QBI string functions where the return sd lives on the
;	stack and will be lost at exit.  The string will be transferred
;	to a temp just before the sd is trashed.  It is guaranteed that
;	b$curlevel will be adjusted appropriately before this routine
;	is called. If the SD is 0 length, a ptr to b$nuldes will be returned.
;Entry:
;	psdOwner - pointer to sd currently owning string.
;Exit:
;	AX - pointer to temp sd that is new owner of string
;	     (b$nuldes if 0 length).
;Uses:
;	Per convention.
;Exceptions:
;	B$ERR_ST if no temps are left.
;****

cProc	B$STMakeTemp,<PUBLIC,FAR>
parmW	psdOwner
cBegin
	XOR	AX,AX		
	CMP	WORD PTR[TMPHDR],AX ;are there any temps left
	JZ	TEMPOV		;brif not - error out

	MOV	BX,[psdOwner]
	CMP	[BX],AX 	;is this a null (0-length) string?
	JNZ	NotNullstr	;brif not

	MOV	AX,OFFSET DGROUP:b$nuldes ;get ptr to b$NulDes
	JMP	SHORT BSTMakeTempX ;return it in ax

NotNullStr:			
	cCall	MakeTemp	;call near routine to do the work
	XCHG	AX,BX		;return new sd in AX
BSTMakeTempX:			
cEnd

cProc	MakeTemp,<NEAR>
cBegin	<nogen>
	PUSH	SI		;preserve SI
	PUSH	[BX]		;push size of string
	MOV	BX,[BX+2]	;[BX] = ptr to string data
	JMP	SHORT ALCTMP	;jump to common code to make the temp
				;the new owner
cEnd	<nogen>

PAGE
;***
; B$STCHKTMP - Check for temporary string descriptor
; Function:
;	Check to see if the string descriptor is a temporary.
; Inputs:
;	BX = Address of string descriptor
; Outputs:
;	Carry flag set if a temp
;	Carry clear in not
; Modifies:
;	None
; Exceptions:
;	None
;****

B$STCHKTMP:			;[C1]
	CMP	BX,OFFSET DGROUP:TMPH
	JNC	RETL		;If above high end, not a temp
	CMP	BX,OFFSET DGROUP:TMPL
	CMC
	RET
PAGE
;***
; B$STGETSTRLEN - get string length
; Purpose:
;	Computes the byte length of a zero-terminated ASCII string.
;
; Inputs:
;	BX = offset of string
; Outputs:
;	AX = Length of the line (not including 00)
; Modifies:
;	None.
; Exceptions:
;	None.
;****

B$STGETSTRLEN:
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	PUSH	CX
	PUSH	DI
	MOV	CX,-1		;Scan up to 65535 characters
	MOV	AL,0		;Search for a zero
	MOV	DI,BX
	REPNE	SCASB		;Scan for a 00
	MOV	AX,CX		;Amount of the 65535 left
	NOT	AX
	DEC	AX
	POP	DI
	POP	CX
	POP	ES		
	RET
PAGE
;***
;B$STALCTMPCPY - Allocate a temp string copy.
;DBCS-callback
;
;Purpose:
;	Allocate a temporary string of the length specified.  Copy the
;	data from the string whose descriptor was passed to the new string.
;	Does not deallocate the original string.
;
;Inputs:
;	BX = Length of string to copy.
;	DX = Address of string data to copy
;
;Outputs:
;	BX = Address of temp string descriptor
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, CX
;
;Exceptions:
;	None
;****

B$STALCTMPCPY: 		;[C1]
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	PUSH	CX
	MOV	CX,BX		;Get length in CX
	PUSH	SI
	MOV	SI,DX		;Point to source of string data
	CALL	B$STALCTMP	;[C1]Get a temporary string of the right length
	PUSH	DI
	MOV	DI,DX		;String data destination
	MOV	DX,SI		;Restore DX
	INC	CX		;Round up if odd
	SHR	CX,1		;Move by words
	REP	MOVSW
	POP	DI
	POP	SI
	POP	CX
	POP	ES		
	RET
PAGE
;***
; B$STDALCALLTMP - Deallocate all temporary strings
; Purpose:
;	Free all temporary strings and descriptors which were
;	allocated at or above the specified level.
;
; Inputs:
;	AX = program level at or above which temporary strings
;	     will be deallocated.  Use 0 (the minimum level) to
;	     deallocate ALL temporary strings.
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	None.
;****

B$STDALCALLTMP:			;[C1]
	PUSH	BX
	MOV	BX,OFFSET DGROUP:TMPL ;First string descriptor
DTSLOOP:
	CMP	WORD PTR[BX+4],AX ;string allocation level >= specified
	JL	NEXTMP		;skip if not
	CALL	DELTMP		;otherwise delete it
NEXTMP:
	ADD	BX,LENTEMP	;Next temp descriptor
	CMP	BX,OFFSET DGROUP:TMPH ;Done yet?
	JB	DTSLOOP
	POP	BX
RETL:
	RET
PAGE
;***
;B$STDALCTMP - Deallocate if temporary string
;DBCS-callback
;
;Purpose:
;	Check to see if the descriptor is a temporary one.
;	If so, deallocate its string data and release the descriptor
;	for future use.
;
;Inputs:
;	BX = Address of string descriptor
;
;Outputs:
;	None.
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, BX, CX, DX
;
;Exceptions:
;	None.
;****

B$STDALCTMP:			;[C1]
	CALL	B$STCHKTMP	;[C1]See if temp string
	JNC	RETL		 ;If not, leave it
DELTMP:
	CALL	B$STDALC	;[C1]Free the space

;***
; B$STDALCTMPDSC - deallocate temporary descriptor
; Purpose:
;	Deallocate the temporary string descriptor pointed by BX and
;	relink it in the temporary descriptor chain for subsequent
;	allocation.
;
; Inputs:
;	BX = address of temporary string descriptor
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	None.
;****

B$STDALCTMPDSC:

;	Make sure that we do not attempt to deallocate a temp twice

DbAssertRel	[BX+4],NZ,-1,NH_TEXT,<Attempted to dealloc an already dealloced string temp>

	PUSH	AX
	MOV	AX,BX
	XCHG	AX,[TMPHDR]	;Make this one the first free
	MOV	[BX],AX 	;Set link to former first one
;	MOV	WORD PTR[BX+2],-1 ;Make it easy to see its free
	MOV	WORD PTR[BX+4],-1 ; < min level (0) means free temp desc
	POP	AX
	RET
PAGE
;***
;B$STALCTMPSUB - Allocate temporary substring copy
;DBCS-callback
;
;Purpose:
;	Create a temporary string and copy the specified portion of the given
;	string into it. The given string is deleted if it is a temp.
;
;	The starting position in the string is specified as an offset from
;	the beginning of the string.  Thus 0 <= CX <= Len(BX)-DX
;
;Inputs:
;	BX = Address of string descriptor
;	CX = Starting position within string
;	DX = Length
;
;Outputs:
;	BX = Address of temp string descriptor
;
;Uses:
;	Per Convention
;
;Preserves:
;	AX, CX, DX
;
;Exceptions:
;	None.
;****

B$STALCTMPSUB: 			;[C1]
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	PUSH	AX		;Save registers
	PUSH	CX
	PUSH	SI
	PUSH	DI

	MOV	SI,CX		;SI = offset into string
	MOV	AX,BX		;AX = source string descriptor
	MOV	CX,DX		;CX = length
	MOV	BX,DX		;BX = length
	CALL	B$STALCTMP	;[C1]Allocate temp string
	MOV	DI,DX		;DI = temp string contents address
	XCHG	AX,BX		;AX = temp string descriptor
				;BX = source string descriptor
	ADD	SI,[BX+2]	;add in old string contents address
	CALL	B$STDALCTMP	;[C1]delete old temp string
	XCHG	AX,BX		;BX = new string descriptor
	MOV	DX,CX		;get length back in DX to leave it unchanged
	INC	CX		;if odd, round up to even
	SHR	CX,1		;bytes to words
	REP	MOVSW		;move into temp string

	POP	DI
	POP	SI
	POP	CX
	POP	AX
	POP	ES		
	RET
PAGE
;***
; B$STDALC - Deallocate string
; Purpose:
;	Deallocate the string data pointed by the string descriptor.
;
; Inputs:
;	BX = Address of string descriptor.
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	None.
;****

B$STDALC:			;[C1]
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	PUSH	AX		;save register
	XOR	AX,AX		;clear to set flag for deletion
	CALL	B$STADJ	;call routine for string data deallocation
	POP	AX		;restore register
	POP	ES		
	RET			;return to caller
PAGE
;***
; B$STADJ - deallocate/adjust string data
; Function:
;	Deallocates or adjusts the string data pointed by the
;	string descriptor in BX.  If AX=0, the data is deallocated.
;	If AX<>0, the string backpointer is adjusted by the value
;	of AX.
;
; Inputs:
;	AX = adjustment value
;	     AX=0  - deallocate string.
;	     AX<>0 - adjust string backpointer.
;	BX = Address of string descriptor.
;	DS = segment that heap is in
;	ES = segment that state vars are in
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	None.
;****
assumes	ES,DGROUP		
assumes	DS,NOTHING		
B$STADJ:
	CMP	WORD PTR [BX],0 ; is string allocated?
	JZ	ADJSTR_EXIT	; brif not

	PUSH	CX		;save register
	PUSH	SI
	MOV	SI,[BX+2]	;Get pointer to string data

;	Test if string is in string space - from [b$STRING_FIRST] to
;	[b$STRING_END].

	CMP	SI,ES:[b$STRING_FIRST] ;test if before string space
	JB	ADJSTR_RETURN	;if less, then constant, do not deallocate
	CMP	SI,ES:[b$STRING_END]	;test if after string space
	JA	ADJSTR_FIELDED	;if more, then fielded string, jump

;	String is in string space.  First adjust the backpointer by AX.
;	Then test if deallocation is requested and, if so, replace
;	backpointer with free string header with <data length>+1.

	ADD	[SI-2],AX	;adjust backpointer of string
	OR	AX,AX		;test if deallocation was requested
	JNZ	ADJSTR_RETURN	;if so, then finished, jump
	MOV	CX,[BX] 	;Get length of string to free
	INC	CX		;Round up if odd
	OR	CL,1		;And set free bit
	XCHG	CX,[SI-2]	;Get backpointer and set free length
	CMP	CX,BX		;Check backpointer
	JE	ADJSTR_RETURN	;if equal, then just return
	PUSH	ES		;force DS = ES incase of CHAIN
	POP	DS		;sets up DS = BASIC DS
	JMP	B$ERR_SSC	;jump to error routine

;	String is in the local heap, probably a fielded string.
;	Call routine to delete descriptor from the appropriate heap
;	entry backpointer string.

ADJSTR_FIELDED:
	CALL	B$LHFLDDESCADJ	;delete descriptor in BX for heap entry

ADJSTR_RETURN:
	POP	SI		;restore registers
	POP	CX
ADJSTR_EXIT:			
	RET			;return to caller
assumes	DS,DGROUP		
assumes	ES,NOTHING		
PAGE
;***
; B$STPUTZ - Put zero at end of string
;
; Inputs:
;	BX = Address of string descriptor
; Function:
;	Make into a string with a zero byte on the end. If length is presently
;	odd, just jam a zero into the extra byte. If even, create a temp
;	one byte longer and put the zero there.
; Outputs:
;	BX = Address of string descriptor
; Registers:
;	Only BX and F affected.
;****

B$STPUTZ:
	PUSH	DX
	MOV	DX,[BX]
	PUSH	CX
	XOR	CX,CX		;Offset = 0
	INC	DX		;Length = old length + 1
	CALL	B$STALCTMPSUB	;[C1]Always copy string into string space
	DEC	DX
	POP	CX
	PUSH	BX
	MOV	BX,[BX+2]	;Get pointer to data
	ADD	BX,DX
	MOV	BYTE PTR [BX],0
	POP	BX
	POP	DX
	RET
PAGE
;***
; B$STSetFree - set free string entry pointer
; Purpose:
;	Determines if the current free string is both the last string
;	entry and unallocated.	If so, its current value is returned
;	in SI.	Otherwise, the free string pointer b$STRING_FREE is set to
;	the string space end and its value returned in SI.
;
; Inputs:
;	None.
; Outputs:
;	SI = pointer to free string (b$STRING_FREE).
; Modifies:
;	AX.
; Exceptions:
;	None.
;****

B$STSetFree:
	MOV	SI,[b$STRING_FREE] ;get pointer to current free string
	MOV	AX,[SI] 	;get header of free string
	TEST	AL,1		;test if free string allocated
	JZ	SS_SET_END	;if so, then jump
	INC	AX		;get length of free entry
	JZ	SS_SET_RETURN	;jump if free entry was at end of string space
	ADD	AX,SI		;get pointer to entry after free string
	CMP	AX,[b$STRING_END] ;test if free was last string in space
	JE	SS_SET_RETURN	;if so, jump to leave pointer unchanged
SS_SET_END:
	MOV	SI,[b$STRING_END] ;get end pointer of string space
	MOV	[b$STRING_FREE],SI ;and set the free string to it
SS_SET_RETURN:
	RET			;return with SI set to new free string
PAGE
;***
; B$STFromLH - get string space from local heap space
; Purpose:
;	Determine if a free entry exists at the end of the
;	local heap.  If so, change the string and heap space
;	pointers so that it is now part of string space.
;
; Inputs:
;	None.
; Outputs:
;	[b$STRING_FREE] = pointer to new free string containing any space
;		   retrieved from the local heap.
; Modifies:
;	None.
; Exceptions:
;	None.
;****

B$STFromLH:
	PUSH	AX		;save registers...
	PUSH	SI
	PUSH	DI

	CALL	B$LHSetFree	;DI points to trailing heap free entry
	CMP	DI,[b$HEAP_END]	;test if any free space at all
	JE	SS_LH_RETURN	;if not, nothing to reclaim

;	The new END heap entry is now at [DI].	Setup the entry and
;	set the heap end pointer [b$HEAP_END].  If the heap free pointer
;	[b$HEAP_FREE] pointed within the reclaimed area, set it to
;	[b$HEAP_END] to give it a valid value.

	MOV	[DI].LHTYPE,LOW LH_END ;define the new END heap entry
	MOV	[b$HEAP_END],DI	;define heap end pointer
	CMP	DI,[b$HEAP_FREE] ;test if free pointer in reclaimed area
	JB	SS_LH_FREE	;if not, then do not set it
	MOV	[b$HEAP_FREE],DI ;otherwise, set it to the heap end
SS_LH_FREE:

;	The new end of string space is the word before the heap END
;	entry.

	SUB	DI,LH_STD_HDR_LEN+1 ;point to new string space end
	MOV	[DI],0FFFFH	;set string space end entry
	CALL	B$STSetFree	;get free string pointer in SI
	MOV	[b$STRING_END],DI ;define new end of string space

;	Form new free string entry from [SI] up to [DI].

	SUB	DI,SI		;get length of new entry
	DEC	DI		;make header for entry
	MOV	[SI],DI 	;put header into entry

SS_LH_RETURN:
	POP	DI		;restore registers...
	POP	SI
	POP	AX
	RET			;return with new free string
PAGE
;***
; B$STGETFRESIZ - get size of free string
; Purpose:
;	Return the current size of the free string in string space.
;
; Inputs:
;	None.
; Outputs:
;	BX = size of free string in bytes.
; Modifies:
;	None.
; Exceptions:
;	None.
;****

B$STGETFRESIZ:
	MOV	BX,[b$STRING_FREE] ;get location of free entry in string space
	MOV	BX,[BX] 	;get free string header
	TEST	BL,1		;test if string entry is allocated
	JZ	GETFRESIZ_ZERO	;if so, then return zero as size
	CMP	BX,0FFFFH	;test if at end of string space
	JNE	GETFRESIZ_NZERO ;if not, header is one more than size
GETFRESIZ_ZERO:
	MOV	BX,1		;size will be zero after decrementing
GETFRESIZ_NZERO:
	DEC	BX		;get the free string size
	RET			;return to caller
PAGE
;***
; B$STSWAPDESC - swap string descriptor contents
; Purpose:
;	Swap the contents of the two string descriptors and adjust the
;	string backpointers, if necessary.
;
; Inputs:
;	SI = pointer to first string descriptor
;	DI = pointer to second string descriptor
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	None.
;****

B$STSWAPDESC:
	PUSH	BX		;save register

	MOV	BX,[SI] 	;get length in first descriptor
	XCHG	BX,[DI] 	;exchange with length in second
	MOV	[SI],BX 	;put exchanged length back in first

	MOV	BX,[SI+2]	;get offset in first descriptor
	XCHG	BX,[DI+2]	;exchange with offset in second
	MOV	[SI+2],BX	;put exchanged offset back in first

	MOV	BX,[SI+2]	;get offset to first descriptor
	CMP	BX,[b$STRING_FIRST] ;test if before string space
	JB	SWAP_NO_FIX	;if so, then do not adjust
	CMP	BX,[b$STRING_END] ;test if after string space
	JAE	SWAP_NO_FIX	;if so, then do not adjust
	MOV	[BX-2],SI	;adjust the first backpointer
SWAP_NO_FIX:
	MOV	BX,[DI+2]	;get offset to second descriptor
	CMP	BX,[b$STRING_FIRST] ;test if before string space
	JB	SWAP_RETURN	;if so, then do not adjust
	CMP	BX,[b$STRING_END] ;test if after string space
	JAE	SWAP_RETURN	;if so, then do not adjust
	MOV	[BX-2],DI	;adjust the first backpointer
SWAP_RETURN:
	POP	BX		;restore register
	RET			;return to caller in SWAP.ASM
PAGE
;***
; B$STINIT - Initialize string space
; Purpose:
;	Initialize the necessary pointers and structures for string space.
; Inputs:
;	SI = last word of string space
;	AX = first word of string space
; Outputs:
;	None.
; Modifies:
;	SI, DI
; Exceptions:
;	None.
;****

B$STINIT:
	MOV	[b$STRING_END],SI	;string space ends here
	MOV	[SI],0FFFFH		;mark end of string space
	MOV	[b$STRING_FIRST],AX	;dynamic space start is string start
	MOV	DI,AX			;get offset of string space start
	MOV	[b$STRING_FREE],DI	;and set it as the free string
	SUB	SI,DI			;get the total size of string space
	DEC	SI			;allow for header size less one
	MOV	[DI],SI 		;and set the string header
$$XSTS:
	MOV	b$curlevel,0		;main program level is zero
	MOV	CX,NUMTEMP		;Number of string temporaries
	MOV	DI,OFFSET DGROUP:TMPL	;First temp
	MOV	[TMPHDR],DI
	MOV	BX,-1			;Flag for each temp indicates free
	MOV	AX,OFFSET DGROUP:TMPL+LENTEMP ;second temp
	PUSH	ES			
	PUSH	DS			
	POP	ES			;Set ES = DS
LINKTMP:
	STOSW				;Link to next temp
	XCHG	AX,BX
	STOSW				;Store free flag
	STOSW				;in level field of descriptor too
	XCHG	AX,BX
	ADD	AX,LENTEMP		;bytes per temp
	LOOP	LINKTMP
	POP	ES			

	MOV	WORD PTR [DI-LENTEMP],0 ;Last temp must point to nul
	RET
PAGE
	SUBTTL	B$SSClean - Clean String Space
	PAGE
;***
;B$SSClean - Clean String Space
;
;Purpose:
; Scan string space and delete all strings not in the function key table or the
; local heap, or if chaining not in blank common.
;
;Entry:
; [DS]	= segment that heap is in
; [ES]	= segment that state vars are in
;	  Normally, this means ES=DS=DGROUP, execpt for DOS 5 chain, during
;	  which this routine is called with ES = DGROUP, DS = the shared memory
;	  selector.
;
;Exit:
; None.
;
;Modifies:
; Per Convention.
;
;****
assumes	ES,DGROUP		
assumes	DS,NOTHING		
cProc	B$SSClean,<NEAR,PUBLIC>
cBegin
	XOR	AX,AX
	CMP	ES:b$Chaining,AL ; If we are not chaining, clear 0-ffff
	JZ	SSCleanAll
;
; clear out all items from 0 to b$commonfirst
;
	MOV	BX,ES:[b$commonfirst]
	CMP	BX,AX		; nothing to clear?
	JE	ClearNext	
	DEC	BX		;Range is inclusive
	CALL	B$SSClearRange

ClearNext:			
;
; Clear out all items from b$commonlast (or start of COMMON if chaining and
; not EI_QB) to 0FFFFH.
;
	MOV	AX,ES:[b$commonlast]



SSCleanAll:
	MOV	BX,0FFFFH
cEnd	nogen			;Fall into B$SSClearRange

	SUBTTL	B$SSClearRange - Clear SS of entries in a range
	PAGE
;***
;B$SSClearRange - Clear SS of entries in a range
;
;Purpose:
; Scan the string space and deallocate all strings whose descriptors are in
; range, and not in the local heap area. (When this routine is used, the local
; heap must be cleaned before, such that the only strings left are fielded
; string backpointer strings or string dynamic array elements.
;
;Entry:
;	AX	= Start address of range in which to delete
;	BX	= End address of range in which to delete (range is inclusive)
;	DS	= Segment containing the near heap
;	ES	= Segment containing heap state vars (& stack)
;
;		    Normally, this means ES=DS=DGROUP, execpt for DOS 5 chain,
;		    during which this routine is called with ES = DGROUP, DS =
;		    the shared memory selector.
;
;Exit:
; None.
;
;Modifies:
; Per Convention
;
;****
cProc	B$SSClearRange,<NEAR,PUBLIC>,SI
cBegin
	MOV	SI,ES:[b$STRING_FIRST] ;initialize scanning pointer
	MOV	CX,BX		;[CX] = end address
;
; Test if string entry is allocated.  If not, then compute the next entry and
; try again. If string space end, then jump to exit.
;
SS_CLEAN_LOOP:
	MOV	BX,[SI] 	;[BX] = string entry header
	TEST	BL,1		;test if entry is allocated
	JZ	SS_CLEAN_ALLOC	;if not, then jump to test if kept
	INC	BX		;[BX] = total length of entry
	JZ	SS_CLEAN_DONE	;if string space end, then jump to finish
	ADD	SI,BX		;[SI] = pointer to next entry in string space
	JMP	SHORT SS_CLEAN_LOOP ;jump to process next entry
;
; String entry is allocated.  Keep string if in blank COMMON.
;
SS_CLEAN_ALLOC:
	CMP	BX,AX		;test if before range
	JB	SS_CLEAN_SKIP	;if so, skip deletion
	CMP	BX,CX		;test if after range
	JA	SS_CLEAN_SKIP	;if so, skip deletion
;
; Keep string if in softkey string table.
;
	CMP	BX,OFFSET DGROUP:B$STRTAB	;test if before softkey table
	JB	SS_CLEAN_VAR_HEAP_TEST		;if so, then jump to next test
	CMP	BX,OFFSET DGROUP:B$STRTAB_END	;test if in the softkey table
	JB	SS_CLEAN_SKIP			;if so, then keep the string

SS_CLEAN_VAR_HEAP_TEST:
	CMP	BX,ES:[b$HEAP_END_SWAP]	;test if before VarHeap
	JB	SS_CLEAN_HEAP_TEST	;if so, then jump to next test
	CMP	BX,ES:[b$HEAP_FIRST_SWAP];test if in VarHeap
	JB	SS_CLEAN_SKIP		;if so, then keep the string

;
; Keep string if descriptor is in the local heap.  Since the local heap was
; cleaned first, the string is either fielded to a file block heap entry or an
; element of a dynamic array.
;
SS_CLEAN_HEAP_TEST:
	CMP	BX,ES:[b$HEAP_END]	;test if in the local heap
	JAE	SS_CLEAN_SKIP		;if so, then keep the string
;
; String is to be deallocated. Compute next entry offset and jump.
;
	MOV	BX,[BX] 	;get length of string data
	INC	BX		;roundup to next word...
	OR	BL,1		;and add one to get unallocated header value
	MOV	[SI],BX 	;put header into string entry
	STC			;set carry
	ADC	SI,BX		;add string header plus one for next entry
	JMP	SHORT SS_CLEAN_LOOP ;branch to process next string entry
;
;	String is to be kept - just compute next offset.
;
SS_CLEAN_SKIP:
	ADD	SI,[BX] 	;add length of string data
	ADD	SI,3		;add two for header and one for roundup...
	AND	SI,NOT 1	;finish roundup to next word
	JMP	SHORT SS_CLEAN_LOOP ;branch to process next string entry

;	Done - restore registers and return.

SS_CLEAN_DONE:
cEnd
assumes	DS,DGROUP		
assumes	ES,NOTHING		

	PAGE
;***
;B$ISdUpd - Adjust string entry backptr when sd moves
;
;Purpose:
;	Added with revision [16].
; QB calls this routine to adjust a string entry backptr when the variable
; table owning the string moves. The variable table is allocated in the local
; heap. Assumes that the variable heap is active.
;
;Entry:
;	pSd	- pointer to string descriptor that is moving
;	Delta	- distance that descriptor is moving
;Exit:
;	string entry backpointer is adjusted
;Uses:
;	AX, BX
;Exceptions:
;	None.
;****

labelFP <PUBLIC,B_ISdUpd>		;Intepreter reachable Label
cProc	B$ISdUpd,<PUBLIC,FAR>,ES	
parmW	pSd
parmW	Delta
cBegin

	CALL	B$TglHeapSptNEAR	; switch context to local heap
	ASSERT_NOT_VARHEAP NH_TEXT	

	MOV	AX,Delta	
DbAssertRel	AX,NE,0,NH_TEXT,<Invalid Delta passed to B$ISdUpd>

	MOV	BX,pSd		;get ptr to string descriptor

	PUSH	DS		; set ES=DS
	POP	ES		
	cCall	B$STADJ	; Adjust backpointer

	CALL	B$TglHeapSptNEAR	; switch context to var heap

cEnd
PAGE


sEnd	NH_TEXT


	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\nhlhutil.asm ===
TITLE	NHLHUTIL - Local Heap utilities
;***
; NHLHUTIL - Local Heap utilities
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE baslibma.inc
	INCLUDE files.inc
	INCLUDE rmacros.inc

		USESEG	_DATA
		USESEG	_BSS
		USESEG	NH_TEXT


	INCLUDE seg.inc
	INCLUDE nhutil.inc	;for heap definitions
	INCLUDE idmac.inc
	INCLUDE array.inc	;for array definitions

sBegin	_BSS


	externW b$STRING_FIRST		;defined in NHSTUTIL.ASM
	externW b$NH_first		;defined in NHINIT.ASM
	externW b$NH_last		;defined in NHINIT.ASM

	externW b$HEAP_FIRST		; heap start pointer
	externW b$HEAP_FREE		
	externW b$HEAP_END		
	externW b$P_HEAP_GROW		

CW_SWAP_VARS	EQU	4		; must swap 4 words to chg context
	externW b$HEAP_FIRST_SWAP	
	externW b$HEAP_END_SWAP 	

	externW b$fVarHeapActive	; non-0 when variable heap
					; is active

	externB b$Chaining	; in chain flag
	externW b$commonfirst	
	externW b$commonlast	

sEnd	_BSS

sBegin	_DATA

	externW b$pFHRaiseBottom	;vector for B$FHRaiseBottom

sEnd	_DATA



sBegin	NH_TEXT

	ASSUMES CS,NH_TEXT

	PUBLIC	B$NHCPCT	;compact all dynamic space
	PUBLIC	B$NHMOV	;mov dynamic space boundaries


	PUBLIC	B$LHFDBLOC	; find file entry for file number given
	PUBLIC	B$LHLOCFDB	; find file number for file entry given

	PUBLIC	B$ILHALC	;allocate heap entry - error code return

	PUBLIC	B$LHFLDDESCADD	; add descriptor to heap backpointer string

	PUBLIC	B$LHChgBakPtr	;called to change the location of an LH owner
	PUBLIC	B$LHREALC	;reallocate heap entry
	PUBLIC	B$ILHADJ	;update backpointer in a given LH entry
	PUBLIC	B$LHForEachEntry ;call given function for each LH entry
	PUBLIC	B$LH_SPLIT

	externNP B$LHADJ	; adjust heap entry
	externNP B$LHDALC	; deallocate heap entry
	externNP B$LHSetFree	; set free heap entry pointer
	externNP B$LH_ALC_FREE	; try to allocate the free heap entry
	externNP B$LH_CPCT	
	externNP B$LH_FROM_SS	

	externNP B$LH_PTR_CHECK ; check entry at [SI] for consistency
	externNP B$LH_PTR_FROM_DATA 
	externNP B$LH_SCAN	

	externNP B$STDALC
	externNP B$STALCTMPSUB
	externNP B$STCPCT
	externNP B$STFromLH
	externNP B$STMOV
	externNP B$STDALCTMPDSC
	externNP B$ERR_OM_NH		 

	externNP B$SSClean	

	externNP B$IHeapEntryMoved


SET_ES_TO_DS	MACRO
	PUSH	DS
	POP	ES
	ENDM

ASSERT_NOT_VARHEAP	MACRO	SEG	;
	ENDM				;


;Given a user requested size, convert to total resulting size of entry
GET_ENTRY_SIZE	MACRO	CBGIVEN,LHTYPE
	LOCAL	CONTINUE
	.xlist
	ADD	CBGIVEN,LH_STD_HDR_LEN+2+1 ;add for hdr, backlength, & roundup
	AND	CBGIVEN,0FFFEh	;finish roundup
	CMP	LHTYPE,LOW LH_FILE
	JNZ	CONTINUE	;brif not an fdb entry
	ADD	CBGIVEN,(LH_FDB_HDR_LEN - LH_STD_HDR_LEN)
				;fdb header is bigger than standard header
CONTINUE:
	.list
	ENDM


;***
; B$LHALC_CPCT - Compact local heap and allocate heap entry.  Added with [44]
;
; Purpose:
;	Combined with B$LHALC as part of [44]
;	Same as B$ILHALC, below, but jumps to B$ERR_OM on out of memory error.
;	Also, compacts heap before allocation.
;
; Inputs:
;	BX = Length of local heap space required.
;	DL = type of heap entry to allocate.
;	CL = if DL=LH_FILE, file number
;	CX = if DL anything else, ptr to owner (where backptr should point to)
; Outputs:
;	SI = Address of start of data of the allocated entry.
; Modifies:
;	None.
; Preserves:
;	ES
; Exceptions:
;	Will jump to B$ERR_OM if insufficient memory for allocation.
;****

cProc	B$LHALC_CPCT,<NEAR,PUBLIC>
cBegin
	CALL	B$LH_CPCT		; compact heap before allocation
	CALL	B$ILHALC		; allocate the entry
	JC	BLHALC_OM_ERR		; psw.c set on error
cEnd

BLHALC_OM_ERR:
	JMP	B$ERR_OM_NH		; out of memory error

;***
; B$ILHALC - allocate local heap entry
; Purpose:
;	Find and allocate an appropriate entry of the local heap.
;	Ten bytes will be added to the requested length with 2 bytes
;	for the backlength and 8 bytes for the heap header.  The
;	This value is rounded up to the next 8-byte value since all
;	allocations are multiples of this value.
;
;	Each successive step is performed until the allocation is done:
;
;	1. Test the free heap entry pointed by [b$HEAP_FREE] for
;	   being unallocated and having the adequate room.
;
;	2. The local heap space is searched from start to end for the
;	   first unallocated entry large enough to satisfy the allocation.
;	   Adjacent unallocated entries are concatenated as they are
;	   found before the allocation is attempted.  If no allocation
;	   can be done, the free heap entry is moved to just past the
;	   last allocated entry in the heap.
;
;	3. If the free string entry is unallocated and the last in string
;	   space, the string-heap boundary is moved so that its space
;	   is added to the free heap entry.  The free entry is tested.
;
;	4. A compaction of string space is performed, leaving a free
;	   unallocated string in high memory.  This storage is placed
;	   in the local heap as in step 3.  The free entry is then tested.
;
;	5. If this is an interpreter-version of the runtime, compact the
;	   Local Heap, and try the free heap entry again.
;
;	If no allocation cannot be done, the program is aborted by
;	   an "Out of Memory" error.
;
;	If the allocation is successful and string space was converted
;	   to heap space, the remaining free heap space is given back
;	   to the string space.
;
;	NOTE: it is assumed that the input owner-to-be is NOT in
;	the local heap (and thus, that heap movement will not cause the
;	owner to move).
;
; Inputs:
;	BX = Length of local heap space required.
;	DL = type of heap entry to allocate.
;	CL = if DL=LH_FILE, file number
;	CX = if DL anything else, ptr to owner (where backptr should point to)
;
; Outputs:
;	if PSW.C is clear
;		SI = Address of start of data of the allocated entry.
;	else (PSW.C set) out of memory error return.
; Modifies:
;	SI
; Preserves:
;	ES
; Exceptions:
;	None.
;****

B$ILHALC	PROC	NEAR
	PUSH	AX		;save the registers used...
	PUSH	BX
	PUSH	ES		


	SET_ES_TO_DS		;set ES = DS if interpreter version

	GET_ENTRY_SIZE	BX,DL	;convert input size to total entry size needed

;	Step 1 - Test if free heap entry can perform allocation.

	CALL	B$LH_ALC_FREE	; try to allocate the free heap entry
	JNC	ALCLHP_FIRST	;if successful, then jump to return

	PUSH	CX		;push more registers...
	PUSH	DX
	PUSH	DI

;	Step 2 - Scan local heap from beginning to end.

	CALL	B$LH_SCAN	;scan the local heap
	JNC	ALCLHP_DONE	;jump if allocation successful

	CALL	[b$P_HEAP_GROW] ; call appropriate routine to complete
				;   allocation (carry clear on return if 
				;   successful)
ALCLHP_DONE:
	POP	DI		;restore registers used...
	POP	DX
	POP	CX

ALCLHP_FIRST:
	POP	ES		
	POP	BX
	POP	AX
	RET			;return with SI pointing to heap data area
B$ILHALC	ENDP

;***
; B$VAR_ALC_GROW - Grow var heap to support allocation of a block of given size
; Purpose:
;	Added with revision [23].
;	Called when B$ILHALC called to [re]alloc a var heap entry and has
;	insufficient space in the var heap.
;	Grows the var heap by (just) the required amount, recurses to B$ILHALC
;	to actually do the allocation.
; Inputs:
;	ES = DS
;	BX = total size of local heap space to be allocated
;	DL = type of heap entry to allocate.
;	CL = if DL=LH_FILE, file number
;	CX = if DL anything else, ptr to owner (where backptr should point to)
; Outputs:
;	Carry Clear if allocation accomplished successfully
; Modifies:
;	SI
; Exceptions:
;
;****
cProc	B$VAR_ALC_GROW,<NEAR,PUBLIC> 
	LocalW	junk
cBegin
;	Step 3 - Compress the variable heap and try to alloc again
	CALL	B$LH_CPCT	;combine all free entries into one
	CALL	B$LH_SCAN	;scan the local heap
	JNC	VAR_ALC_EXIT	;jump if allocation successful

;	Step 4 - Allocate a local heap entry of required size. If this fails,
;		 quit. If it succeeds, free that entry, move string space up
;		 (putting the required freespace in variable heap), and
;		 recurse to B$ILHALC to do the allocation.
	PUSH	BX			; save original request size
	PUSH	DX
	PUSH	CX
	ADD	BX,LH_STD_HDR_LEN+2	; grab enough space from LH for
					; required entry PLUS overhead
	DbAssertRelB  dl,nz,<LOW LH_FILE>,NH_TEXT,<VAR_ALC_GROW: FDB entry>
	; the above assertion is due to the fact that we're just adding
	; in overhead for a standard heap entry, not an FDB

	PUSH	BX
	CALL	B$TglHeapSptNEAR	; switch context to local heap
	LEA	CX,[junk]		;for back ptr
	CALL	B$ILHALC		;If this succeeds, we now have
					;  sufficient space in DGROUP for alloc
	JC	VAR_ALC_FAIL		; brif insufficient space in system

	CALL	B$LHDALC		;deallocate that space now
	POP	SI			
	PUSH	SI			
	ADD	SI,[b$STRING_FIRST]	; we want to move SS up to here
	CALL	B$STMOV
	JNC	BSTMOV_SUCCESS  	; brif success

	CALL	B$LH_CPCT		; compact local heap
	CALL	B$STMOV		; try again

BSTMOV_SUCCESS:				
	CALL	B$TglHeapSptNEAR	; switch context back to var heap
	POP	BX
	POP	CX
	POP	DX
	;Move top of Var Heap up to string space
	ADD	[b$HEAP_FIRST],BX	
	MOV	SI,[b$HEAP_FIRST]	
	;Mark this as a free entry
	MOV	[SI].LHTYPE,LOW LH_FREE
	MOV	[SI].LHLEN,BX
	MOV	[b$HEAP_FREE],SI
	SUB	SI,BX			
	MOV	[SI+1],BX		; backlength of free entry
	POP	BX			; restore original size request
	CALL	B$ILHALC		;MUST succeed
	JNC	VAR_ALC_EXIT

	DbHalt NH_TEXT,<VAR_ALC_GROW: B$ILHALC call failed!>
VAR_ALC_FAIL:
	CALL	B$TglHeapSptNEAR	; switch context back to var heap
	POP	BX			; restore stack for exit
	POP	CX			
	POP	DX			
	POP	BX			
	STC				; signal failure
VAR_ALC_EXIT:
cEnd

;***
; B$VarHeap_CPCT - Compact the Variable heap down, put free space in SS.
; Purpose:
;	Added with revision [23].
;	Compact the variable heap down, give all resulting free space to
;	string space.
; Inputs:
;	None
; Outputs:
;	None
; Modifies:
; Exceptions:
;	None
;****
cProc	B$VarHeap_CPCT,<PUBLIC,NEAR>,<SI>
cBegin
	ASSERT_NOT_VARHEAP NH_TEXT	
	CALL	B$TglHeapSptNEAR	; switch context to variable heap
	CALL	LH_MOV_DOWN		;crunches heap down, leaving hole
					;  above; returns new b$HEAP_FIRST in SI
	INC	SI			;SI points to where SS is to start at
	CALL	B$STMOV		;mov SS down
	CALL	B$TglHeapSptNEAR	; switch context back to local heap
cEnd






;***
; B$LHREALC - reallocate a Local Heap entry
; Purpose:
;	Given a pointer to the start of data in an existing local heap
;	entry (which is guaranteed to have a back pointer in the header)
;	and a byte count, reallocate the entry to be of the given byte
;	count size.
;	Note that, if the reallocation results in a reduction or no
;	change in the size, this routine is guaranteed not to cause
;	heap movement.
;	Note also that this routine will succeed if sufficient space
;	exists for the reallocation; it does NOT require the heap to
;	have the full input size free, as it just grabs the additionally
;	required space and combines it with the given entry.
;
;	NOTE: it is assumed that the owner of the given entry is NOT in
;	the local heap if the entry is growing (and thus, that heap movement
;	will not cause the owner to move).
;
; Inputs:
;	AX = number of bytes to realloc to.
;	SI = pointer to start of data in an LH entry; note that the
;		entry is assumed to have a back pointer.
; Outputs:
;	AX = FALSE if insufficient memory for reallocation,
;	     TRUE (non-zero) if operation successful.
;	SI = pointer to the start of data for the reallocated entry if
;		AX = TRUE (note, however, that SI is trashed if AX = FALSE).
;		This may or may not be different from the entry. Note that,
;		although we do have a backpointer, this routine does not
;		update the pointer - - - the return value of SI is provided
;		for the caller to do that.
; Modifies:
;	AX & SI are outputs, plus BX,CX,DX are be modified, and ES = DS,
;		regardless of input value.
; Exceptions:
;
;****
B$LHREALC	PROC	NEAR
	SET_ES_TO_DS		;set ES = DS if interpreter version
	PUSH	DI
	MOV	DI,AX		;DI = copy of input size request
	CALL	B$LH_PTR_FROM_DATA ;get entry pointer from SI data pointer

 	; The below assertion is based on assumptions below on the size
 	; of the entry header - - - which is just to save bytes
 	DbAssertRelB [SI].LHTYPE,NZ,LH_FILE,NH_TEXT,<can't realloc fdb's>
 	ADD	AX,LH_STD_HDR_LEN+2+1 ; add for hdr, backlength, & roundup
 	AND	AX,0FFFEh	; finish roundup

	MOV	CX,AX		;save size of desired entry in CX
	MOV	BX,[SI].LHLEN	;get length of existing entry
	SUB	AX,BX		;subtract existing size from desired size
	JA	BLHREALC_Grow	;brif we must grow the existing entry

	NEG	AX		;make difference a positive number
	CALL	B$LH_SPLIT	;split this entry; free entry out of spare space
	MOV	SI,DI		;SI = pointer to realloc'd entry
	SUB	SI,[SI].LHLEN	;move SI back to previous entry, and then
	ADD	SI,3		;  make it data pointer to realloc'd entry
	JMP	REALC_TRUE_Exit ;done - return TRUE to signal success

BLHREALC_Grow:
;	Algorithm:
;		get and save backpointer
;	    STEP1:
;		call B$ILHALC with the input byte count
;		if this succeeds, block copy the contents of the original
;			entry and free it; ensure the back pointer in the
;			new entry is correct - exit and return TRUE
;	    STEP2:
;		call B$ILHALC for the additional space required
;		if this fails, return FALSE
;		free the newly obtained entry, but keep a pointer to it.
;		if this entry is above entry to realloc in memory, collapse
;			the Local Heap, split resulting free entry so that
;			higher of two is required size, set free ptr to that
;		else set free ptr to newly free'd entry.
;		call LH_MOV_DN_RG to move all from free ptr and entry to
;			realloc down
;		change header and trailer to combine free entry with given
;			entry


	;----------------------------------------------------------------------
	;Start of code to Grow an existing entry - at this point:
	;	AX = additional space needed (on top of what current entry has)
	;	BX = size of existing entry
	;	CX = total size of entry needed to satisfy users request
	;	DI = input size request
	;	SI = pointer to header of entry-to-realloc
	;----------------------------------------------------------------------

	;growing an entry - STEP 1: try to allocate a block of size to
	;				accomodate entire entry, then copy
	;				original entry contents, free original

	PUSH	AX		;save additional space required
	MOV	CX,[SI].LHBAKP	;get backpointer
	MOV	DL,[SI].LHTYPE	;input to B$ILHALC
	MOV	BX,DI		;input realloc size request
	CALL	B$ILHALC	;try to alloc a block of size caller requested

	MOV	DI,SI		;DI = ptr to start of data in new entry
	MOV	DX,SI		;DX = ptr to start of data in new entry
	MOV	SI,CX		;SI = backpointer
	MOV	SI,[SI] 	;SI = ptr to start of data in old entry
	JC	REALC_STEP2	;brif insufficient memory for whole block

	;now just block copy data from old entry to new, & free old entry
	PUSH	AX		;save additional space required across call
	PUSH	SI		;save pointer to data in entry across call
	PUSH	BX		;modified by call to b$LH_I_ADJ
	MOV	AX,DI
	SUB	AX,SI		;AX = adjustment factor for backpointers to
				;	any owners contained in this entry
	CALL	B$LH_PTR_FROM_DATA ;get entry pointer from SI data pointer
	CALL	B$LH_I_ADJ	; adjust backpointers to any owners in entry
	POP	BX
	POP	SI
	POP	AX
	MOV	CX,[SI-2]	;CX = number of bytes in original entry
 	SUB	CX,LH_STD_HDR_LEN+2 ; only copy data, not old header ...
	SHR	CX,1		;CX = number of words in original entry
	PUSH	SI
	REP	MOVSW		;copy contents of old entry to new
	POP	SI		;need this ptr for deallocation
	CALL	B$LHDALC	;deallocate original entry
	POP	AX		;clean up stack
	MOV	SI,DX		;return value SI = ptr to start of entry data
DJMP	JMP	SHORT REALC_TRUE_Exit 

	;growing an entry - STEP 2: try to allocate a block of the size of
	;				the additional space required, then
	;				free this block; if this entry is
	;				above entry to realloc in memory,
	;				collapse the Local Heap, split
	;				resulting free entry, set ptr to higher
	;				of the two free entries; call
	;				LH_MOV_DN_RG to move all from free
	;				ptr to entry to realloc down in memory.
	;				Change hdr to combine free entry with
	;				given entry.
REALC_STEP2:
	CALL	B$LH_PTR_FROM_DATA ;get entry pointer from SI data pointer
	POP	BX		;additional space required for realloc
	PUSH	BX		;still want this saved
	PUSH	CX		;save backpointer to input entry
	PUSH	AX		;put a word on stack to act as backptr for alloc
	MOV	CX,SP		;backpointer
	MOV	DL,[SI].LHTYPE
	CALL	B$ILHALC	;try to alloc block of additional size required
	POP	CX		;clean stack
	POP	BX		;backpointer to input entry
	POP	DX		;additional space required for realloc
	JC	JB_REALC_FALSE_Exit ;brif insuff. memory - can't realloc [52]

	MOV	DI,SI		;DI = ptr to start of data in new entry
	CALL	B$LH_PTR_FROM_DATA ;get entry pointer from SI data pointer
	XCHG	SI,DI
	CALL	B$LHDALC	;now free this entry - keep its hdr ptr in DI
	MOV	SI,[BX] 	;SI = ptr to start of data in entry to realloc
	CMP	SI,DI		;is entry-to-realloc above free entry?
	JA	REALC_MOV_DOWN	;  brif so - don't need to collapse

	;free entry is above entry-to-realloc; must collapse the local heap to
	;  get it below, then split resulting free entry so we can then 'bubble
	;  up' a free entry of the size we wish to add to the input entry
	CALL	B$LH_CPCT	   ;compact current entries to top of heap
	MOV	SI,[BX] 	;SI = ptr to start of data in input entry
	MOV	DI,[b$HEAP_FREE] ;DI = pointer to resulting free entry at bottom
	MOV	AX,[b$HEAP_END]
	MOV	[b$HEAP_FREE],AX ;no longer a b$HEAP_FREE - - - we'll move it
				;  all up in memory to realloc a piece of it
REALC_MOV_DOWN:
	CALL	B$LH_PTR_FROM_DATA ;get entry pointer from SI data pointer
	PUSH	DX
	MOV	DX,SI
	MOV	SI,DI		;hdr pointer for free entry
	CALL	LH_MOV_DN_RG	;mov all in this range down
	POP	DX
	;Now, DI points to hdr of entry to realloc. If next entry up is
	;  a free entry of sufficient size, split it (if necessary), and
	;  tack on the extra amount needed to fulfill reallocation request.
	MOV	SI,DI
	ADD	SI,[SI+1]	;SI = pointer to next entry up
	CMP	[SI].LHTYPE,LOW LH_FREE
	JNZ	REALC_FALSE_Exit ;brif next entry up is not a free one - fail

	MOV	AX,[SI].LHLEN
	SUB	AX,DX		;subtract amount needed from amount free
JB_REALC_FALSE_Exit:		; rel jmp out of range made this necessary
	JB	REALC_FALSE_Exit ;brif insufficient amount for realloc request

	PUSH	DI		;save hdr ptr to entry to realloc
	CALL	B$LH_SPLIT	   ;split entry
	JNC	REALC_CONT1	;brif split succeeded
	MOV	DI,SI		;will grab all of existing entry

REALC_CONT1:
	;now combine entry-to-realloc and free entry pointed to by DI
	POP	SI		;ptr to hdr for entry to realloc
	MOV	AX,[DI].LHLEN	;length of free header being added

	DbAssertRelB  <[SI].LHTYPE>,ne,<LOW LH_FILE>,NH_TEXT,<can't realloc fdb's>
				;assuming here that realloc header size is STD
	SUB	SI,(LH_STD_HDR_LEN - 1)
	SUB	DI,(LH_STD_HDR_LEN - 1)
	MOV	CX,LH_STD_HDR_LEN
	REP	MOVSB		;copy existing header to new (top) location
	DEC	DI
	ADD	AX,[DI].LHLEN	;add in size of original entry
	MOV	[DI].LHLEN,AX	;save new entry size
	SUB	DI,AX
	MOV	[DI+1],AX	;save it as the back-length too
	MOV	SI,DI
	ADD	SI,3		;make SI = data ptr for realloc'd entry (retval)

REALC_TRUE_Exit:
	MOV	AL,1		;return non-zero in AX for successful realloc
REALC_Exit:
	POP	DI
	RET

REALC_FALSE_Exit:
	XOR	AX,AX
	JMP	SHORT REALC_Exit

B$LHREALC	ENDP


;***
; B$LHChgBakPtr
; Purpose:
;	When the ownership of an LH entry is changed or an owner moves, this
;	routine is called to change the back pointer.
; Inputs:
;	SI = ptr to data of entry whose owner is being changed.
;	CX = new value for the backpointer (i.e., a pointer to the new owner)
; Outputs:
;	none. ON exit, the back pointer is modified to point to the new owner.
;	Note, however, that the new owner contents are not changed to point
;	to this entry; the caller must do that.
; Modifies:
;	SI only.
; Exceptions:
;	B$ERR_ssc if heap entry is inconsistent.
;****
B$LHChgBakPtr	PROC	NEAR
	CALL	B$LH_PTR_FROM_DATA ;get entry pointer from SI data pointer
	MOV	[SI].LHBAKP,CX	;change back pointer
	RET
B$LHChgBakPtr	ENDP

;***
; B$ILHADJ - adjust the backpointer for a given heap entry
; Purpose:
;	This routine provides a mechanism by which the interpreter call-back
;	routine B$IHeapEntryMoved can update the back pointer for a single
;	heap entry.
;
; Inputs:
;	AX = pointer to start of data for a Local Heap entry.
;	DI = adjustment factor (same as B$LHADJ passes to B$IHeapEntryMoved)
; Outputs:
;	none.
; Modifies:
;	none.
; Exceptions:
;	none.
;****
B$ILHADJ	PROC	NEAR
	PUSH	SI
	MOV	SI,AX
	CALL	B$LH_PTR_FROM_DATA ;get entry pointer from SI data pointer
	ADD	[SI].LHBAKP,DI
	POP	SI
	RET
B$ILHADJ	ENDP


;***
;B$IAdUpd - Adjust string array entry backptr when ad moves
;
;Purpose:
;	Added with revision [18].
;	QB calls this routine to adjust a string array entry backptr
;	when the variable table owning the array moves.  The
;	variable table is allocated in the local heap.
;Entry:
;	pAdStr	- pointer to string array descriptor that is moving
;	Delta	- distance that descriptor is moving
;Exit:
;	Array entry backpointer is adjusted
;Uses:
;	AX
;Exceptions:
;	None.
;****
labelFP <PUBLIC,B_IAdUpd>		;Interpeter Reachable Label
cProc	B$IAdUpd,<PUBLIC,FAR>,<SI>
parmW	pAdStr
parmW	Delta
cBegin
	MOV	SI,pAdStr	;get AD ptr

	CMP	[SI].AD_fhd.FHD_hData,0 ; is the array allocated?
	JZ	AdUpd_Exit		; brif not

	MOV	SI,[SI].AD_fhd.FHD_oData ;get ptr to array data
	CALL	B$LH_PTR_FROM_DATA ;[SI] = ptr to heap header
DbAssertRel	<WORD PTR[SI].LHBAKP>,Z,pAdStr,NH_TEXT,<Invalid pAD passed to B$ISdUpd>
	MOV	AX,Delta	;get adjustment value
	ADD	[SI].LHBAKP,AX	;adjust backptr to reflect new location
AdUpd_Exit:			
cEnd


;***
; B$LH_SPLIT - split an entry into two pieces
; Purpose:
;	Given a header pointer to an entry and a size (must be a size rounded
;	to the current header size) for a new free entry, split the entry
;	into a free entry (of exactly the requested size) in high mem., with
;	the existing entry in low mem. - - - no heap movement takes place.
;
; Inputs:
;	SI = hdr ptr to an entry
;	AX = size of new entry to be split off
;	ES = DS
; Outputs:
;	SI is unchanged but is now the hdr ptr for the new free entry
;	DI is the new hdr ptr for the existing entry (lower in mem. than SI)
;	PSW.C is clear if successful; if input split-off size was zero, PSW.C
;		will be set and the block will be unmodified.
; Modifies:
;	DI only
; Exceptions:
;	none.
;****
B$LH_SPLIT	   PROC    NEAR
	PUSH	BX
	PUSH	CX
	MOV	DI,SI		;in case AX = 0 on entry
	CMP	AX,LH_STD_HDR_LEN
	JC	B$LH_SPLIT_EXIT   ;brif wish to split off less than a hdr's worth

	MOV	CX,LH_STD_HDR_LEN
	CMP	[SI].LHTYPE,LOW LH_FILE
	JNZ	B$LH_SPLIT_CONT1

	ADD	CX,(LH_FDB_HDR_LEN - LH_STD_HDR_LEN)
B$LH_SPLIT_CONT1:
	MOV	BX,[SI].LHLEN
	SUB	BX,AX
	CMP	BX,CX
	JC	B$LH_SPLIT_EXIT   ;brif can't take AX worth from entry and leave
				;  enough for existing header
	SUB	SI,CX
	INC	SI		;SI now points to start of header
	MOV	DI,SI
	SUB	DI,AX		;set DI to point to start of new header block
				;  i.e., new header for existing entry. SI
				;  points to start of old header block
	REP	MOVSB		;copy header
	DEC	SI		;SI = hdr pointer for new (free) entry

	MOV	[DI],AX 	;set back length for new free entry
	DEC	DI
	MOV	[SI].LHLEN,AX	;set length of new free entry
	MOV	[SI].LHTYPE,LOW LH_FREE
	MOV	CX,[DI].LHLEN
	SUB	CX,AX		;new length of existing entry
	MOV	[DI].LHLEN,CX	;update length of existing entry
	SUB	DI,CX
	MOV	[DI+1],CX	;set new back length for existing entry
	ADD	DI,CX		;set DI back as entry hdr ptr for return
	CLC			;signal successful return
B$LH_SPLIT_EXIT:
	POP	CX
	POP	BX
	RET
B$LH_SPLIT	   ENDP


;***
; B$TglHeapSptNEAR - Toggle near heap support code between near heap & var heap
;
; Purpose:
;	Added with revision [23].
; Entry:
;	For non-RELEASE use, b$fVarHeapActive is non-zero if the variable
;		heap is the currently active heap.
; Exit:
;	b$fVarHeapActive is updated.
; Uses:
;	ES set to DS on exit, otherwise None.
; Exceptions:
;	None
;****
cProc	B$TglHeapSptNEAR,<PUBLIC,NEAR>,<AX,CX,SI,DI>	
cBegin
	SET_ES_TO_DS			;movement code requires ES == DS
	MOV	CX,CW_SWAP_VARS
	MOV	SI,OFFSET DGROUP:b$HEAP_FIRST
	MOV	DI,OFFSET DGROUP:b$HEAP_FIRST_SWAP
TglHeap_Loop:
	;exchange [si] with [di], advancing si & di
	LODSW
	XCHG	AX,[DI]
	MOV	[SI-2],AX
	INC	DI
	INC	DI
	LOOP	TglHeap_Loop

	CMP	[b$fVarHeapActive],CX
	JNZ	Set_NR_Flag		;brif flag was true; set it false
	INC	CX			;set flag true - - var heap now active
	DbAssertRel b$HEAP_FIRST,b,b$HEAP_END_SWAP,NH_TEXT,<TglHeapSpt error>
Set_NR_Flag:
	MOV	[b$fVarHeapActive],CX	;set flag for assertion checking
cEnd

;***
; B$TglHeapSpt - Toggle near heap support code between near heap & var heap
;
; Purpose:
;	Added with revision [23].
;	This is just a PUBLIC FAR interface to a NEAR routine.
; Entry, Exit, Uses, Exceptions:
;	Same as for B$TglHeapSptNEAR, above.
;****
cProc	B$TglHeapSpt,<PUBLIC,FAR>
cBegin
	CALL	B$TglHeapSptNEAR	
cEnd



;***
; B$NHCPCT - compact all dynamic space
; Purpose:
;	Compacts all allocated strings to the bottom of string space.
;	Compacts all allocated heap entries to the top of the local
;	heap. All free heap space is given to the string space.
;
; Inputs:
;	None.
; Outputs:
;	None.
; Modifies:
;	None
; Exceptions:
;	B$ERR_SSC - nontrappable error if compaction finds corruption
;		  in string space structure.
;****
B$NHCPCT:
	ASSERT_NOT_VARHEAP NH_TEXT 
	CALL	B$STCPCT	;compact the string space
	CALL	B$LH_CPCT	   ;compact the local heap space
	CALL	B$STFromLH	;return free heap entry to string space
	RET			;return to caller

	SUBTTL	B$NHMOVALL - Move ALL of dgroup heaps around
	PAGE
;*** 
;B$NHMOVALL - Move ALL of dgroup heaps around
; Addedm revision [26]
;
;Purpose:
; Move everything in the dgroup above __atopsp up or down. This includes
; EVERYTHING above the stack. (Generally precipitated by the movement of the
; top of stack).
;
;Entry:
; [AX]		= Proposed delta to __atopsp. Move everything in the heap to
;		  fit just above this.
; Carry 	= Set if moving stack DOWN, else reset.
;
;Exit:
; Carry set on error (out of memory).
; [b$NH_First] Updated.
;
;Uses:
; Per convention.
;
;Preserves:
; AX
;
;Exceptions:
; Branches to B$ERR_OM for out of memory.
;
;******************************************************************************
cProc	B$NHMOVALL,<NEAR,PUBLIC>,AX
cBegin

	JC	NHMOVALL_DOWN	;Jump if we are moving __atopsp DOWN
	ASSERT_NOT_VARHEAP NH_TEXT ;Should be local heap at this time
;
; Moving up.
; 1) Move the near heap up by the change delta.
; 2) Move the var heap up to the new _atopsp.
; 3) Chop the var heap trailing free entry off by the move amount.
;
	PUSH	AX		;Save delta
	ADD	AX,[b$NH_First];[AX] = proposed phyiscal base of near heap
	JC	NHMOVALL_EXIT_POP ;Jump if bad error.
	MOV	CX,[b$NH_Last] ;[CX] = unchanged phyiscal end of near heap
	PUSH	AX		;Save prposed base
	cCall	B$NHMOV	;[AX] = resulting phyiscal base of near heap
	POP	AX		;[AX] = proposed phyiscal base of near heap
	JNC	NHMOVALL_VARUP	;Jump if not out of memory
	CALL	[b$pFHRaiseBottom];Ask Far Heap to move out of the way
	CALL   B$NHMOV 	;[AX] = resulting phyiscal base of near heap
NHMOVALL_VARUP:
	MOV	[b$NH_First],AX
	JC	NHMOVALL_EXIT_POP  ;If didn't work, go return right away
	CALL	B$TglHeapSptNEAR ; switch context to variable heap
	XCHG	AX,SI		;[SI] = phyiscal base of near heap
	DEC	SI		;[SI] = physical top of var heap
	CALL	LH_MOV		;Move the var heap up.  
				;SI = offset of new local heap start

	MOV	SI,[b$HEAP_END] ;[SI] = physical base of var heap
	POP	BX		;[BX] = distance changed
	ADD	SI,BX		;[SI] = proposed new physical base of var heap
	CALL	LHSetEnd	;Set the new physical base
	CALL	B$TglHeapSptNEAR ; switch context to back to local heap
	JMP	SHORT NHMOVALL_DONE

NHMOVALL_EXIT_POP:		;Error exit, with register pop
	POP	AX		;Discard TOS
	JMP	SHORT NHMOVALL_EXIT
;
; Moving Down
; 1) create a trailing free space entry in the var heap
; 2) Move the var heap down
; 3) Move the near heap down
;
NHMOVALL_DOWN:
	ASSERT_NOT_VARHEAP NH_TEXT ;Should be local heap at this time
	CALL	B$TglHeapSptNEAR  ; use var heap pointers
	ADD	AX,[b$HEAP_END] ;[AX] = proposed new physical heap end
	XCHG	AX,SI		;[SI] = proposed new physical heap end
	CALL	LHSetEnd	;Set the new end of var heap

	CALL	LH_MOV_DOWN	;Move the var heap down

	XCHG	AX,SI		;[AX] = var heap's new b$HEAP_FIRST
	CALL	B$TglHeapSptNEAR ; use local heap pointers

	INC	AX		;[AX] = new b$NH_First
	MOV	CX,[b$NH_Last]	;[CX] = unchanged last
	CALL	B$NHMOV		;Move near heap around
	MOV	[b$NH_First],AX

NHMOVALL_DONE:
	OR	AX,AX		;Successfull return
NHMOVALL_EXIT:

cEnd

	SUBTTL

;***
; B$NHMOV - move dynamic space (strings and local heap)
; Purpose:
;	Moves the contents of the string and local heaps to the beginning
;	and ending word offsets given.
;
; Inputs:
;	AX = offset to define start of dynamic space
;	CX = (if nonzero) offset to define end of dynamic space
;	     (if zero) offset is to be minimum possible
; Outputs:
;	AX = starting offset of dynamic space
;	CX = ending offset of dynamic space
;	CF = 0 - move successful - offsets reflect those requested
;	     1 - move unsuccesssful - request space too small
; Modifies:
;	None.
; Exceptions:
;	None.
;****

B$NHMOV  PROC	  NEAR		
	ASSERT_NOT_VARHEAP NH_TEXT 
	PUSH	SI		;save register...

;	If CX=0, the local heap is to be adjacent to the string heap
;	with no intervening free space.  Assume here that the local
;	heap will move down.

	JCXZ	MOVDYN_LH_DOWN	;heap will move down

;	Test that dynamic space start is before the end.  If not,
;	then report the error by returning with carry set.

	INC	CX		;heap header index is on odd byte of last word
	CMP	CX,AX		;test if start is before end
	JB	MOVDYN_DONE	;if not, then jump with carry set for error

;	Jump if local heap will move down.

	CMP	CX,[b$HEAP_FIRST] ;test if heap moves down
	JBE	MOVDYN_LH_DOWN	;brif so

;	Local heap moves up to offset in CX.  Then move the string heap
;	to offset in AX.

	MOV	SI,CX		;get offset to move local heap
	CALL	LH_MOV	;move the local heap up
	MOV	CX,SI		;update end offset of dynamic space (+1)
	MOV	SI,AX		;get offset to move string heap
	CALL	B$STMOV	;move the string heap (up or down)
	XCHG	AX,SI		; [AX] = offset of dynamic space
	JMP	SHORT MOVDYN_DONE_CLC ;jump to nonerror return

;	Local heap is to be moved down in memory.  Test if string heap
;	is moved down or up.

MOVDYN_LH_DOWN:
	CMP	AX,[b$STRING_FIRST] ;test if strings moving down
	JBE	MOVDYN_SS_DOWN	;if so, then jump

;	The string heap is moving up and the local heap is moving down.
;	First, compact the heap and give any free space to string heap.

	CALL	B$LH_CPCT	   ;compact local heap
	CALL	B$STFromLH	;give any local heap free space to string heap

;	Move string heap to requested location.

MOVDYN_SS_DOWN:
	MOV	SI,AX		;get request offset for string heap
	CALL	B$STMOV	;move the string heap
	XCHG	AX,SI		; [AX] = starting offset of dynamic heap
	JC	MOVDYN_DONE	;if error moving string heap, return with carry

;	If local heap need not be moved, then finished.

;MOVDYN_SS_SAME:
	CMP	CX,[b$HEAP_FIRST] ;test if local heap need be moved
	JE	MOVDYN_DONE	;if not, done, return with carry clear

;	Move local heap down be first making it adjacent to the string
;	heap.  If this was originally requested, then finished.

	XOR	SI,SI		;clear for minimum local heap offset
	CALL	LH_MOV	;move local heap next to string heap
	XCHG	CX,SI		;swap requested offset and return offset
	OR	SI,SI		;test if requested offset was zero
	JZ	MOVDYN_DONE	;if so, then return with carry clear

;	Move heap to final requested location.

	CMP	SI,CX		;compare requested location with returned one
	JBE	MOVDYN_DONE	;if less, ran out of room, return with carry
				;if equal, request finished, return w/o carry
	CALL	LH_MOV	;move the local heap to requested offset in SI
	MOV	CX,SI		;update end offset of dynamic space

;	Finished with no error - return carry cleared.

MOVDYN_DONE_CLC:
	CLC			;clear carry for no error

;	Finished - carry set or cleared appropriately.

MOVDYN_DONE:
	DEC	CX		;point to even byte of ending offset
	POP	SI		;restore register
	RET			;near return to caller
B$NHMOV  ENDP			

;***
; LH_MOV - move local heap
; Purpose:
;
; Moves local heap to the offset specified in SI if SI<>0.  IF SI=0, then move
; heap just under allocated string space. Local heap start [b$HEAP_FIRST] is set
; appropriately. The space is returned compacted.
;
; Inputs:
;	SI = offset for new local heap start, or 0 for reverse compaction.
; Outputs:
;	SI = offset of new local heap start.
; Modifies:
;	None.
; Exceptions:
;	B$ERR_SSC - nontrappable error if compaction finds corruption
;		  in local heap structure.
;****
LH_MOV	PROC	NEAR
	PUSH	AX		;save register
	OR	SI,SI		;test if moving heap to under string space
	JNZ	LH_MOV_UP	;if not, then jump to move heap up

;	SI=0, so perform the reverse compaction of the local heap just
;	under string space and return the new heap start offset in SI.

	CALL	B$LH_FROM_SS	;get any leading string entries to heap
	CALL	LH_MOV_DOWN	;perform reverse compaction to under strings
	JMP	SHORT LH_MOV_RETURN ;jump to set new heap start and return

;	SI nonzero, so prefix the heap with an unallocated entry from the
;	new start offset to the present start offset, then perform a
;	heap compaction.

LH_MOV_UP:
	MOV	AX,SI		;compute length of new entry to prefix...
	SUB	AX,[b$HEAP_FIRST] ;by difference between the two offsets
	CMP	AX,LH_STD_HDR_LEN
	JC	LH_MOV_NOMOVE	; If not moving by enough, don't add free
	MOV	[SI].LHTYPE,LOW LH_FREE ;set type of unallocated heap block
	MOV	[SI].LHLEN,AX	;set length of new heap block
	MOV	[b$HEAP_FIRST],SI ;set new entry as heap start
	SUB	SI,AX		;point to old heap start offset
	MOV	[SI+1],AX	;set new heap backlength
LH_MOV_NOMOVE:			
	CALL	B$LH_CPCT	   ;compact heap including new entry

LH_MOV_RETURN:
	MOV	SI,[b$HEAP_FIRST] ;report back start of heap
	POP	AX		;restore register
	RET			;return to caller
LH_MOV	ENDP

;***
; LH_MOV_DOWN - move local heap down in memory
; Purpose:
;	Compacts the local heap to low memory starting at the last
;	entry to the first.  Sets b$HEAP_FIRST to the new location of
;	the first allocated entry as no unallocated entry exists.
;	The heap will be just after the string space.
;
; Inputs:
;	None.
; Outputs:
;	[b$HEAP_FIRST] and [b$HEAP_FREE] of compacted heap.
;	[SI] - new value of b$HEAP_FIRST
; Modifies:
;	AX,SI
; Exceptions:
;	None.
;****

LH_MOV_DOWN:
	PUSH	CX		;save registers...
	PUSH	DI
	PUSH	DX

;	Scan local heap from [b$HEAP_END] to [b$HEAP_FIRST] by using the
;	entry backlengths to determine the next entry.

	MOV	SI,[b$HEAP_END] ;initialize pointer for scan
	MOV	[b$HEAP_FREE],SI ;free pointer will point to last heap entry

;	Skip over allocated entries as these are not moved.  If the last
;	entry to be scanned in [b$HEAP_FIRST], exit with no compaction.

LH_MOV_SKIP_LOOP:
	CMP	SI,[b$HEAP_FIRST]  ;test if end of scanning
	JE	LH_MOV_NO_COMPACT ;if so, then no compaction needed
	ADD	SI,[SI+1]	; [SI] = pointer to next entry header
	CMP	[SI].LHTYPE,LOW LH_FREE ;test if entry is allocated
	JNE	LH_MOV_SKIP_LOOP ;try for next allocated entry

	MOV	DX,[b$HEAP_FIRST] ;end of range to move
	CALL	LH_MOV_DN_RG	;given 1st unallocated entry, move all down

;	Finish reverse compaction by setting [b$HEAP_FIRST] to the last
;	entry in the compacted heap.

	MOV	[b$HEAP_FIRST],DI;put into pointer of heap start
LH_MOV_NO_COMPACT:
	MOV	SI,[b$HEAP_FIRST];return new pointer to new first entry
	POP	DX
	POP	DI		;restore registers...
	POP	CX
	RET			;return to caller

;***
; LH_MOV_DN_RG
; Purpose:
;	Compacts the local heap to low memory starting at a given unallocated
;	entry (bottom of range to be compacted) and ending with a given
;	allocated entry (the last entry (entry at highest memory of the
;	range) to be compacted).
;	Note that nothing is done to the free space which bubbles up to
;	the top of the range; no header is given to it.
;	NOTE: if the interpreter refuses permission for LH entries to move,
;		this routine will result in no movement (exit values will
;		be correctly set up for this case).
;
; Inputs:
;	SI = pointer to heap entry hdr for unallocated entry at bottom of
;		range to be compacted.
;	DX = pointer to heap entry hdr for allocated entry at top of range
;		to be compacted.
; Outputs:
;	DI = pointer to heap entry hdr for allocated entry at top of range
;		after compaction
;	DX = same as input value of DX, i.e., pointer to top of range allocated
;		heap entry hdr prior to compaction
; Modifies:
;	AX,CX,SI,DI
;
; Exceptions:
;	None.
;****
LH_MOV_DN_RG:
;	Set up pointer DI as the destination offset as the first byte of the
;	given unallocated entry.
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	MOV	DI,SI		;get pointer to the unallocated entry
	SUB	DI,[SI].LHLEN	;point to one less than entry backlength
	INC	DI		;entry backlength - compaction starts here

;	Loop for entries after the given unallocated entry.
;	Check for entry consistency and heap end.

LH_MOV_ENTRY_LOOP:
	CMP	SI,DX		;test if end of scanning
	JE	LH_MOV_FINISH	;if so, then jump to finish
	ADD	SI,[SI+1]	; [SI] = pointer to next entry header
	CALL	B$LH_PTR_CHECK	 ;check entry at [SI] for consistency
	CMP	[SI].LHTYPE,LOW LH_FREE ;test if entry is allocated
	JE	LH_MOV_ENTRY_LOOP ;if so, loop to check it, etc.
;
;	Allocated entry needs to be block transferred to ES:DI.
;	First adjust the entry, then move the entry itself.
;
	LEA	CX,[SI+1]	; get pointer one past entry to be moved
	SUB	CX,[SI].LHLEN	;point to backlength, ready for transfer

	MOV	AX,DI		;compute adj by destination backlength ptr...
	SUB	AX,CX		;less the source backlength pointer
	CALL	B$LHADJ	;adjust the entry backpointers

	MOV	SI,CX		;put source backlength pointer in reg
	MOV	CX,[SI] 	;backlength number of bytes
	SHR	CX,1		;convert to number of words to transfer
	REP	MOVSW		;perform the transfer - DI ready for next

; Now there is a void between two entries and the heap is not walkable.
; Make the void a free entry.
	NEG	AX			;convert back to positive byte count
	DEC	SI			; si = pHdr for new free entry
	MOV	[SI].LHLEN,AX		; stuff in length
	MOV	[SI].LHTYPE,LOW LH_FREE	; mark it as free
	MOV	[DI],AX 		; fill in backlength for new free entry
	NEG	AX			; back to negative adjustment factor

	JMP	SHORT LH_MOV_ENTRY_LOOP ;jump to process next entry

LH_MOV_FINISH:
	DEC	DI		;last byte is header offset

	;now set the free block up with a hdr & backlength in case this is req'd
	MOV	CX,DX
	SUB	CX,DI		;CX = size of new free block
	MOV	SI,DX
	MOV	[SI].LHLEN,CX
	MOV	[SI].LHTYPE,LOW LH_FREE
	MOV	[DI+1],CX	;backlength for free block
LH_MOV_RG_EXIT:
	POP	ES		
	RET



;***
; B$LH_I_ADJ
; Purpose:
;	Update the backpointers to any owners contained in an entry that's
;	about to be moved.
; Inputs:
;	SI = hdr ptr to entry about to be moved
;	AX = adjustment factor (to be added to backpointers to any owners
;		in this entry).
; Outputs:
;	none.
; Modifies:
;	BX, CX
;****
cProc	B$LH_I_ADJ,<PUBLIC,NEAR>
cBegin				
	MOV	CL,[SI].LHTYPE
	TEST	CL,LOW LH_IM_CALL_BACK
	JZ	LH_I_ADJ_DONE	;brif no owners in entry being moved

	TEST	CL,LH_IM_ENTRY
	JZ	LH_I_ADJ_DONE	;brif not an interpreter entry

	MOV	BX,[SI].LHBAKP	;put backpointer in BX
	CALL	B$IHeapEntryMoved ;call interpreter to do the work of
				;  updating backptrs to owners in this entry
				;  AX,BX,CL are parms
LH_I_ADJ_DONE:
cEnd				



;***
; B$LHForEachEntry
; Purpose:
;	Given a pointer to a (NEAR) function, walk the local heap, calling
;	This function for each entry, with the entry backpointer (pointer
;	to the entry owner) and the entry type byte.
;
;	On entry to routines called for each entry,
;		BX = pointer to entry owner,
;		DL = entry type byte
;	Users within this module can also use the fact the SI will be a pointer
;		to the header for the current entry.
;	Called functions must preserve all registers except BX and DX.
;	Callers of this function may pass other parameters to their called
;		function via AX and/or DI, which are not used by this routine.
;
;	NOTE: for entries which do not have backpointers, the called function
;		will receive (in BX) whatever is in the field corresponding
;		to the backpointer for that entry.
;
; Inputs:
;	CX = pointer to function to call for each entry.
;	ES = segment that the state vars are in
;	other parameters may be in AX and/or DI, to be passed to the function
;		whose pointer is given in CX. (BC only)
; Outputs:
;	none.
; Modifies:
;	none, unless called function modifies some register(s).
; Exceptions:
;	none (does not check entries for integrity).
;****
assumes	ES,DGROUP			
B$LHForEachEntry	PROC	NEAR
	PUSH	DX
	PUSH	BX
	PUSH	SI
	MOV	SI,[b$HEAP_FIRST]	
ForEach_Loop:
	CMP	SI,[b$HEAP_END] 	; done searching heap?
	JBE	ForEach_Exit		;  brif so

	MOV	DL,[SI].LHTYPE		;get type byte
	MOV	BX,[SI].LHBAKP		;get pointer to owner
	CALL	CX			;call function

	SUB	SI,[SI].LHLEN		;move down to next entry
	JMP	SHORT ForEach_Loop

ForEach_Exit:
	POP	SI
	POP	BX
	POP	DX
	RET
B$LHForEachEntry	ENDP
assumes	ES,NOTHING			

	SUBTTL	LHSetEnd - Set new HEAP_END
	PAGE
;*** 
;LHSetEnd - Set new HEAP_END
; Added, revision [26]
;
;Purpose:
; Truncate or expand the trailing free entry in the heap in order to set a new
; b$HEAP_END pointer.
;
;Entry:
; [SI]	= Proposed new b$HEAP_END
;
;Exit:
; Carry set on failure
;
;Uses:
; Per convention
;
;******************************************************************************
cProc	LHSetEnd,NEAR,DI
cBegin
	CALL	B$LHSetFree	;[DI] = trailing free heap entry
	CMP	SI,[b$HEAP_END] ;Determine which way the pointer is moving
	JC	LHSetEnd_DOWN	;Jump if we're expanding down

	CMP	DI,SI		;See if trying to move above the free entry
	JC	LHSetEnd_EXIT	;Jump if we are (carry set). Can't do that
	JZ	LHSetEnd_Empty	;Jump if we are not moving (carry not set).

LHSetEnd_DOWN:
	MOV	AX,DI		;[AX] = trailing free heap entry
	SUB	AX,SI		;[AX] = new size of free entry in AX
	MOV	[DI].LHTYPE,LOW LH_FREE ;set heap entry type
	MOV	[DI].LHLEN,AX	;set free heap entry length
	MOV	[SI+1],AX	;set free heap entry backlength

LHSetEnd_Empty:
	MOV	[SI].LHTYPE,LOW LH_END ;define the entry type
	MOV	[b$HEAP_END],SI ;define the heap end pointer
	OR	AX,AX		;Done, clear carry

LHSetEnd_EXIT:

cEnd

;***
; B$LHFLDDESCADD - add descriptor to field backpointer string.
; Purpose:
;	Add the descriptor value specified to the backpointer string
;	in the heap entry in SI.
;
; Inputs:
;	BX = address of descriptor to be added.
;	SI = FDB address of heap entry.
; Outputs:
;	None.
; Modifies:
;	SI.
; Exceptions:
;	None.
;****


B$LHFLDDESCADD:		
	ASSERT_NOT_VARHEAP NH_TEXT 
	PUSH	AX		;save registers...
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	DI

;	Compute heap entry descriptor from the FDB address specified.

	CALL	B$LH_PTR_FROM_DATA ;heap entry pointer is now SI
	ADD	SI,LHPLEN	;move pointer to heap backpointer descriptor

;	Copy backpointer string to temp string two bytes longer.

	MOV	AX,BX		;save added descriptor value
	MOV	BX,SI		;get copy of heap descriptor pointer
	XOR	CX,CX		;copy from the string start
	MOV	DX,[BX] 	;get backpointer string length
	ADD	DX,2		;new string is to be two bytes longer
	CALL	B$STALCTMPSUB	;BX is ptr to desc of longer copy of string

;	Add fielded descriptor to string at the end.

	MOV	DI,DX		;get length of new string
	ADD	DI,[BX+2]	;point past end of the new string
	MOV	[DI-2],AX	;add descriptor to string at last two bytes

;	Deallocate old string data pointed by SI.

	XCHG	BX,SI		;BX=old string desc - SI=new string desc
	CALL	B$STDALC	;deallocate old string data (BX desc)

;	Copy new descriptor at SI to old descriptor at BX and then adjust
;	the new string backpointer to point to BX. (BX is in heap entry)

	ADD	WORD PTR [BX],2 ;new string is always two bytes longer
	MOV	DI,[SI+2]	;get new string data offset
	MOV	[BX+2],DI	;put into heap entry descriptor
	MOV	[DI-2],BX	;set new string backpointer

;	Free the temp descriptor at SI.

	MOV	BX,SI		;get temp descriptor pointer
	CALL	B$STDALCTMPDSC ;and free the descriptor

	POP	DI		;restore registers...
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	RET			;return to caller

;***
; B$LHLOCFDB - return file number from FDB pointer
; Purpose:
;	Return the file number of the heap entry containing the
;	FDB pointed by the specified value.
;
; Inputs:
;	SI = pointer to FDB
; Outputs:
;	BL = file number
; Modifies:
;	None.
; Exceptions:
;	B$ERR_ssc if heap entry is inconsistent.
;****

B$LHLOCFDB:			
	PUSH	SI		;save FDB pointer
	CALL	B$LH_PTR_FROM_DATA ;get heap entry pointer (check entry lengths)
	MOV	BL,[SI].LHFNUM	;get file number from heap entry
	POP	SI		;restore FDB pointer
	RET			;return

;***
;B$LHFDBLOC - locate FDB with a specified file number
;DBCS-callback
;
;Purpose:
;	Return a pointer to the FDB in the local heap FILE
;	entry that contains the specified file number.
;
;Inputs:
;	BL = file number
;
;Outputs:
;	SI = pointer to FDB (if found) or 0 (if not found).
;	ZF = clear (if found) or set (if not found)
;
;Modifies:
;	None.
;
;Exceptions:
;	None.
;****

B$LHFDBLOC:			
	MOV	SI,[b$HEAP_FIRST];start pointer at start of local heap
FDBLOC_LOOP:
	CMP	[SI].LHTYPE,LOW LH_END ;test if at heap end
	JE	FDBLOC_END	;if so, jump to note failure
	CMP	[SI].LHTYPE,LOW LH_FILE ;test if file entry
	JNE	FDBLOC_NEXT	;if not, then jump to try for next entry
	CMP	[SI].LHFNUM,BL	;test if correct file number
	JE	FDBLOC_FOUND	;jump to show success
FDBLOC_NEXT:
	SUB	SI,[SI].LHLEN	;point to next entry
	JMP	SHORT FDBLOC_LOOP ;and jump to try the next one
FDBLOC_FOUND:
	SUB	SI,[SI].LHLEN	;point to entry after one found
	ADD	SI,3		;point past backlength to FDB start
	RET			;return (with ZF clear)
FDBLOC_END:
	XOR	SI,SI		;clear SI to show failure
	RET			;return (with ZF set)

	SUBTTL	B$NHCLEAN - Clean string space and local heap
	PAGE
;***
;B$NHCLEAN - Clean string space and local heap
;
;Purpose:
; To clean the string space and local heap of entries whose descriptors are not
; in blank COMMON or other special areas. This routine is used during the
; CHAINing process.
;
;Entry:
; [DS]	= segment that heap is in
; [ES]	= segment that state vars are in
;	  Normally, this means ES=DS=DGROUP, execpt for DOS 5 chain, during
;	  which this routine is called with ES = DGROUP, DS = the shared memory
;	  selector.
;
;Exit:
; None.
;
;Modifies:
; NONE
;
;Preserves:
; ALL (for previous compatibility)
;
;******************************************************************************
assumes	ES,DGROUP		
assumes	DS,NOTHING		
cProc	B$NHCLEAN,<PUBLIC,NEAR>,<AX,BX,CX,DX>
cBegin
	CALL	B$LHClean	;the local heap must be cleaned first
	CALL	B$SSClean	;then the string space can be cleaned
cEnd

	SUBTTL	B$LHClean - Clean the local heap
	PAGE
;***
;B$LHClean - Clean the local heap
;
;Purpose:
; Scan the heap and process each entry accordingly:
;
; If CHAINing (b$Chaining <> 0):
;
;     FILE:	deallocate the fielded strings not in COMMON and update the
;		fielded string backpointer string.
;     ARRAY:	determine if the array descriptor is wholly within COMMON and
;		if not, delete the array using LH_ADJ.
;
; ELSE:
;
;     FILE:	deallocate all fielded strings
;     ARRAY:	delete the array
;
;Entry:
; [DS]	= segment that heap is in
; [ES]	= segment that state vars are in
;	  Normally, this means ES=DS=DGROUP, execpt for DOS 5 chain, during
;	  which this routine is called with ES = DGROUP, DS = the shared memory
;	  selector.
;
;Exit:
; None.
;
;Modifies:
; Per Convention.
;
;****
cProc	B$LHClean,<NEAR,PUBLIC>
cBegin
;
; If chaining, clear out all items from 0 to b$commonfirst
;
	XOR	AX,AX
	CMP	ES:b$Chaining,AL ; If we are not chaining, clear 0-ffff
	JZ	LHCleanAll

	MOV	BX,ES:[b$commonfirst]
	DEC	BX		;Range is inclusive
	XOR	CX,CX		; only release string arrays and fdb's
	CALL	B$LHClearRange
;
; Clear out all items from b$commonlast to 0FFFFH
;
	MOV	AX,ES:[b$commonlast]
LHCleanAll:
	MOV	BX,0FFFFH
	XOR	CX,CX		; only release string arrays and fdb's
cEnd	nogen			;Fall into B$LHClearRange

	SUBTTL	B$LHClearRange - Clean the local heap of entries
	PAGE
;***
;B$LHClearRange - Clean the local heap of entries
;
;Purpose:
;
; Scan the heap and process each entry accordingly:
;
;   FILE:	fielded strings whose descriptors fall into the passed range
;		deallocated, and the fielded string back pointer string is
;		updated.
;
;   ARRAY:	If the array descriptor falls into the range, delete the array
;		using LH_ADJ.
;
;Entry:
;	AX	= Start address of range in which to delete
;	BX	= End address of range in which to delete (Range is inclusive)
;	CX	= non-zero if we're to release ALL owners in given range
;		  zero if we should release only string arrays and fdb's
;	DS	= Segment containing the near heap
;	ES	= Segment containing heap state vars (& stack)
;
;		    Normally, this means ES=DS=DGROUP, execpt for DOS 5 chain,
;		    during which this routine is called with ES = DGROUP, DS =
;		    the shared memory selector.
;
;Exit:
;
;Modifies:
; Per Convention.
;
;Exceptions:
; None.
;
;******************************************************************************
cProc	B$LHClearRange,<NEAR,FORCEFRAME,PUBLIC>,DI
cBegin
	PUSH	CX		; [BP-2] = flag - release ALL owners if TRUE
	PUSH	BX		; [BP-4] = end offset
	PUSH	AX		; [BP-6] = start offset

	MOV	DI,SP		;[SS:DI] = pointer to start and end data
	MOV	CX,OFFSET LHCleanRangeEntry	;[CX] = routine to call
	CALL	B$LHForEachEntry		;Scan Local Heap

	POP	AX		;Clean stack
	POP	BX
	POP	CX		
cEnd
;*** 
; LHCleanRangeEntry - Clear local heap entry, if conditions are right
;
;Purpose:
;
; Process heap entry accordingly:
;
;   FILE:	fielded strings whose descriptors fall into the passed range
;		deallocated, and the fielded string back pointer string is
;		updated.
;
;   ARRAY:	If the array descriptor falls into the range, delete the array
;		using LH_ADJ.
;
;Entry:
;	DL	= Heap entry type
;	BX	= Offset of heap entry owner
;	SS:DI	= Pointer to range words:
;			[SS:DI]   = start
;			[SS:DI+2] = end
;			[SS:DI+4] = flag - only in EI_QB versions. 
;					zero means release only LH_FILE and
;					LH_ARRAY entries. non-zero means
;					release ALL entries. 
;	DS:SI	= Pointer to heap entry
;	DS	= Segment containing the near heap
;	ES	= Segment containing heap state vars (& stack)
;
;Exit:
; None
;
;Uses:
; Per Convention
;
;******************************************************************************
cProc	LHCleanRangeEntry,NEAR
cBegin
;
;	If file entry, test if any fielded strings and call FIELD
;	to remove any fielded strings from the backpointer string.
;
	CMP	DL,LH_FILE	;test if file entry
	JNE	LH_NOT_FILE	;if not, then jump

	CMP	WORD PTR [SI].LHPLEN,0 ;test if any fielded strings
	JE	LH_DONE 	;if not, then try for the next entry
	CALL	LHCleanRangeField ;clean out entries
	JMP	SHORT LH_DONE	;done - try for the next entry
;
;	If ARRAY entry, compute the offset of the LAST word of the array
;	descriptor, and base decisions on that.
;
LHCleanQBIEntry:		
	CMP	WORD PTR SS:[DI+4],0	
	JNE	LHClean_Dealc	
	JMP	SHORT LH_DONE	; brif we only want to free arrays & fdb's

LH_NOT_FILE:
	MOV	BX,[SI].LHBAKP	;get backpointer to owner
	CMP	DL,LH_ARRAY	;test if array entry
	JNE	LHCleanQBIEntry ; brif not array entry

;  QB allocates static arrays at scan time.  We can't blindly release
;  the array data, or we will get SSC.  So, we treat this like other
;  QBI heap entries. They get released at new, rude edit, etc.

	TEST	[BX].AD_fFeatures,FADF_STATIC ;QBI static string array?
	JNE	LHCleanQBIEntry ;brif so, treat like QB entry
	MOV	AL,[BX].AD_cDims;get the number of dimensions of array
	CBW			;make it a word value in AX
	SHL	AX,1		;now make in a word index in AX
	ADD	BX,AD_tDM-2	;point to word before first dimension entry
	ADD	BX,AX		;one word per dimension - so last in desc.
LHClean_Dealc:			
	CMP	BX,SS:[DI]	;before start?
	JB	LH_DONE 	;jump if so, don't touch
	CMP	BX,SS:[DI+2]	;after end?
	JA	LH_DONE 	;jump if so, don't touch

	XOR	AX,AX		;set flag for deletion
	CALL	B$LHADJ	;unallocate the heap entry
	MOV	[SI].LHTYPE,LOW LH_FREE ; set entry type to FREE, in case
					; this is not a string array entry
LH_DONE:
cEnd

;***
;LHCleanRangeField - clean out fielded strings
;
;Purpose:
; fielded strings whose descriptors fall into the passed range deallocated, and
; the fielded string back pointer string is updated. Ignores strings whose
; descriptors are in the local heap, as they are part of dynamic strign arrays,
; dealt with elsewhere.
;
;Entry:
;	SS:DI	= Pointer to range words:
;			[SS:DI]   = start
;			[SS:DI+2] = end
;	DS:SI	= Pointer to file heap entry
;	DS	= Segment containing the near heap
;	ES	= Segment containing heap state vars (& stack)
;
;Exit:
; None.
;
;Modifies:
; Per Convention
;
;******************************************************************************
cProc	LHCleanRangeField,NEAR,
cBegin
;
;	Compute pointers to starting and ending word offsets of the
;	fielded string backpointer string.
;
	PUSH	SI		;Save heap entry pointer
	MOV	BX,[SI].LHPLEN	;[BX] = length of backpointer string
	MOV	SI,[SI].LHPOFF	;[SI] = pointer to start of backpointer string
	LEA	BX,[BX+SI-2]	;[BX] = pointer to end of backpointer string
;
;	Loop here for each backpointer string word element.
;
FIELD_LOOP:

	LODSW			;[AX] = next string element to process

	CMP	AX,ES:[b$HEAP_END] ;String in near heap?
	JA	FIELD_NOTIN	;jump if so, don't touch
	CMP	AX,SS:[DI]	;before start?
	JB	FIELD_NOTIN	;jump if so, don't touch
	CMP	AX,SS:[DI+2]	;after end?
	JA	FIELD_NOTIN	;jump if so, don't touch
;
; Delete the element but keep the backpointer string at the same offset (as
; well as the same backpointer). This is done by moving the last element of the
; string (at [BX]) over the deleted element (at [SI]), setting the entry at
; [BX] to 1 (a null string entry), and finally moving BX forward to point to
; the new last element. Note that the setting of [BX] occurs before setting
; [SI] so the case of a one-element string (BX=SI) works.
;
	DEC	SI
	DEC	SI		;[SI] = ptr back to processed element
	MOV	AX,[BX] 	;[AX] = last element value; last elem = null
	MOV	[SI],AX 	;overwrite deleted element with last one
	MOV	WORD PTR [BX],1
	DEC	BX
	DEC	BX		;backup over null string header
;
;	Test if last element to process.  If not, then loop for next.
;
FIELD_NOTIN:
	CMP	SI,BX		;test if last element to process
	JBE	FIELD_LOOP	;if not, then loop
;
;	Compute new string length for descriptor.
;
	XCHG	AX,SI		;[AX] = address of last element
	POP	SI		;[SI] = pointer to heap entry
	SUB	AX,[SI].LHPOFF	;get new length of backpointer string
	MOV	[SI].LHPLEN,AX	;put new length in descriptor
	JNZ	FIELD_NOT_EMPTY ;if new string not empty, then jump
;
;	Backpointer string empty, deallocate string header and clear offset.
;
	MOV	WORD PTR [BX],1 ;clear string header
	MOV	[SI].LHPOFF,AX	;clear the heap descriptor offset

FIELD_NOT_EMPTY:
cEnd

sEnd	NH_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\mtfloat.asm ===
TITLE	MTFLOAT - Floating call helper functions
;***
; MTFLOAT - Float call helper functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	The majority of floating point math support for the runtime is via
;	'Float Calls', i.e., calls to floating point routines at a level
;	that utilize an 80[2]87 if present, and the emulator mathpack if not.
;	Functions in this module augment those float calls to provide
;	additional functionality not provided by the current float call
;	interface.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	USESEG	<DV_TEXT>	
	USESEG	MT
	USESEG	_DATA
	USESEG	_BSS

	INCLUDE seg.inc
	INCLUDE compvect.inc	; component dispatch vectors
	INCLUDE idmac.inc
	INCLUDE	rtps.inc	

sBegin	DV_TEXT 			
	externNP	B$NearRet	;for disp vectors in compvect.inc
sEnd	DV_TEXT 			

sBegin	_DATA
	externW	B$AC
	externW	B$DAC			
sEnd	_DATA

sBegin	_BSS
	externB	b$VTYP		
sEnd	_BSS


	externFP B$FIST		; IEEE round to nearest integer in DX:AX

sBegin	MT_TEXT
	ASSUMES CS,MT_TEXT

	externNP B$ERR_TM	

;***
;B$fmldw - push integer in BX onto top of numeric stack (ST0)
;Purpose:
;	This routine is used as an interface to __fldw when the
;	2-byte integer is already in a register.
;Entry:
;	BX contains the 2-byte integer to be put on the numeric stack.
;Exit:
;	ST0 contains floating point equivalent of the given integer.
;Preserves:
;	SI, DI, BX
;******************************************************************************
cProc	B$fmldw,<NEAR,PUBLIC> 	
cBegin				

	push	bx		; put integer in memory
	mov	bx,sp		; bx = address of integer
	fild	word ptr [bx]	; load integer
	pop	bx		; restore BX

cEnd				

;***
;B$fmlds - push s.p. number in CXDX onto top of numeric stack (ST0)
;Purpose:
;	This routine is used as an interface to __flds when the
;	4-byte real is already in registers.
;Entry:
;	CXDX contains the 4-byte s.p. number; the high byte is in CH,
;	low byte is in DL.
;Exit:
;	ST0 contains floating point equivalent of the given s.p. number.
;Preserves:
;	SI, DI, CX, DX
;******************************************************************************
cProc	B$fmlds,<NEAR,PUBLIC> 	
cBegin				

	PUSH	CX		;push high word first
	PUSH	DX
	MOV	BX,SP		;now BX points to s.p. number
	fld	dword ptr [bx]	; load number into ST0
	add	sp,4		; reset SP

cEnd				

;***
;B$ftolrup - Round ST0 up and pop, result in DX:AX
;Purpose:
;	This routine acts the same as __ftol, except the number is rounded
;	up instead of being truncated toward zero.
;Entry:
;	ST0 contains number to pop and round up.
;Exit:
;	ST0 is popped, rounded 32-bit integer equivalent in DX:AX
;Preserves:
;	SI, DI, BX, CX
;******************************************************************************
cProc	B$ftolrup,<NEAR,PUBLIC>	
cBegin				
	call	B$FIST		; temp (incorrect) rounding hack
cEnd				

;***
;B$ftolrnd - Round ST0 to nearest integer & pop, result in DX:AX
;Purpose:
;	This routine acts the same as __ftol, except the number is rounded
;	to the nearest integer (rounded to even number if equidistant) instead
;	of being truncated toward zero.
;Entry:
;	ST0 contains number to pop and round.
;Exit:
;	ST0 is popped, rounded 32-bit integer equivalent in DX:AX
;Preserves:
;	SI, DI, BX, CX
;******************************************************************************
cProc	B$ftolrnd,<NEAR,PUBLIC>	
cBegin				
	call	B$FIST
cEnd				


;***
;B$FRCINT - Force to integer routine compiler runtime interface routine
; Purpose:
;	   Convert contents of floating point accumulator to integer as
;	   follows:  Determine the type of variable contained in the FAC by
;	   checking the contents of b$VTYP.  If the variable is a string
;	   (b$VTYP = 3), issue a type mismatch error.  If b$VTYP is greater
;	   than 3, assume single precision and return the integer equivalent
;	   in BX.  If the b$VTYP is less than 3, assume integer and simply
;	   move the leftmost two bytes of the FAC contents to BX.
;
; Entry:
;	 FAC contains a variable, b$VTYP contains its type (integer is type 2,
;	 string is type 3, single precision is type 4, double precision is type
;	  8). Most often the variable in the FAC is a single precision number.
; Exit:
;	BX = integer result
;	If no error occurred, b$VTYP = 2.
; Preserves:
;	ES,SI,DI
;****
cProc	B$FRCINT,<NEAR,PUBLIC>	
cBegin				

	MOV	BX,OFFSET DGROUP:B$AC
	MOV	DL,[b$VTYP]	
	CMP	DL,VT_SD	; Is value type less than or equal to 3?
	JNB	ISFLPT		;No: assume it is single precision
	JZ	STRERR		;String: type mismatch error
	MOV	BX,[BX] 	;Put integer in BX
	RET
STRERR: 			;String: issue type mismatch error
	JMP	B$ERR_TM	;Type mismatch error routine
ISFLPT: 			;Floating pt number in accumulator
	PUSH	ES		;save across float calls
	PUSH	BX		;save pointer to B$AC
	CMP	DL,VT_R4	
	JNZ	FRC_DUBL	;brif vtyp not s.p.

	fld	dword ptr [bx]	; load s.p. number to ST0
	JMP	SHORT FRC_CONT
FRC_DUBL:
	DbAssertRelB DL,z,8d,MT_TEXT,<MTFLOAT.ASM: B$FRCINT: invalid var type>
	fld	qword ptr [bx]	; load d.p. number to ST0
FRC_CONT:
	CALL	B$ftolrnd	;DX:AX = integer equiv. of number


	AND	DX,08000H	; mask off all but sign bit
	OR	AX,DX		;mask sign bit into 2-byte integer

	POP	BX		;BX points to B$AC
	POP	ES
	MOV	[BX],AX 	;save integer in B$AC
	XCHG	AX,BX		;BX is retval
	MOV	[b$VTYP],VT_I2	; Make value type integer

cEnd				



sEnd	MT_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\oscmd.asm ===
TITLE	OSCMD - Operating System Command line access

;***
;OSCMD.ASM - Operating System  command line access
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This module contains routines to access and manipulate the
;	command line.  This is used by statements such as OPEN "PIPE:",
;	RUN/CHAIN/SHELL/COMMAND$.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;
;	Code Segments
;
	USESEG	<OS_TEXT>	;Operating System
	USESEG	<NH_TEXT>	;Near Heap
	USESEG	<RT_TEXT>	;Runtime Core

;
;	Data Segments
;
	USESEG	<_DATA>
	USESEG	<_BSS>		;runtime data (uninitialized)

	INCLUDE seg.inc
	INCLUDE ascii.inc
	INCLUDE idmac.inc

	SUBTTL	Code Externals
	PAGE

sBegin	NH_TEXT
	externNP B$STALCTMPCPY
sEnd	NH_TEXT



sBegin	RT_TEXT
sEnd	RT_TEXT

	SUBTTL	Runtime data definitions for BASIC Operating System
	PAGE

sBegin	_BSS
	externW __acmdln	;command line pointer
	externB	b$Buf1		;defined in GWINI.ASM
sEnd	_BSS

	SUBTTL	Runtime Operating System  Initialization
	PAGE
assumes CS,OS_TEXT
sBegin	OS_TEXT

;***
;B$Arg0Skip - Skip past the program name on command line.
;Purpose:
;	The DOS 5 command line now has the program name as the
;	first element of the command line string.  This element
;	needs to be skipped for compatability in things like
;	Command$, RUN and CHAIN.
;
;	NOTE: this routine works for KANJI characters because all of
;	the items that we are testing (" ", 0, ASCCR) are less than
;	any possible second byte of a Kanji Character.
;
;Entry:
;	DS:SI - points to command line
;Exit:
;	DS:AX - points to command line past program name
;Modifies:
;	None.
;Exceptions:
;	None.
;*****************************************************************************

;***
;B$CmdCopy - copy DOS command line from DS:SI to ES:DI
;Purpose:
;	Copies the MSDOS command line into a buffer.  This routine is
;	called by COMMAND$, CHAIN, and RUN.
;Entry:
;	DS:SI - points to command line
;	ES:DI - points to place to put command line
;		For DOS 3, this is limited to 128 bytes, but OS/2 could
;		could have up to 256 bytes.
;Exit:
;	BX - count of chars copied
;	Command line is copied into ES:DI
;Modifies:
;	None.
;Exceptions:
;	None.
;***************************************************************************
cProc	B$CmdCopy,<PUBLIC,NEAR>,<SI,DI>
cBegin
	XOR	BX,BX		; initialize character count
CMD_IGNORE:
	LODSB			; fetch next char from command line
	CMP	AL," "
	JE	CMD_IGNORE	; ignore leading blanks
CMD_LOOP:
	OR	AL,AL		; 0 terminates command string
	JZ	CMD_TERM	
	CMP	AL,ASCCR
	JE	CMD_TERM	; CR terminates command string
	CMP	AL,"a"
	JB	CMD_COPY	; just copy if not lower case
	CMP	AL,"z"
	JA	CMD_COPY	; just copy if not lower case
	XOR	AL,20H		; convert lower case to upper case
CMD_COPY:
	STOSB			; copy char into temporary buffer
	INC	BX		; increment char count
DbAssertRelB	BH,E,0,OS_TEXT,<Buffer overflow in B$CmdCopy>
	LODSB			; fetch next char from command line
	JMP	SHORT CMD_LOOP	; repeat until end of command string
CMD_TERM:
cEnd

;***
;B$FCMD - return command line
;Purpose:
;	Implement COMMAND$ function by returning a string containimg
;	the MS-DOS command line.
;
;Inputs:
;	None.
;Outputs:
;	AX = ptr to string desc for temp with command line.
;Modifies:
;	None.
;Exceptions:
;	None.
;******************************************************************************


	externNP B$FrameAFE		

cProc	B$FCMD,<PUBLIC,FAR>		
cBegin	<nogen> 			
	jmp	B$FrameAFE		
cEnd	<nogen> 			

sEnd	OS_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\osdate.asm ===
TITLE	OSDATE - MS-DOS DATE$ and TIME$ Support
;***
; OSDATE - MS-DOS DATE$ and TIME$ Support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - DATE$ Statement:
;
;      DATE$ = datestring
;	 |
;      B$SDAT
;
;
; - DATE$ Function:
;
;      stringvar = DATE$
;		     |
;		   B$FDAT
;
;
; - TIME$ Function:
;
;      stringvar = TIME$
;		     |
;		   B$FTIM
;
;
; - TIME$ Statement:
;
;      TIME$ = string
;	 |
;      B$STIM
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	_DATA		
	USESEG	CONST		
	USESEG	_BSS
	USESEG	OS_TEXT 	
	USESEG	NH_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE files.inc	
	INCLUDE idmac.inc
	INCLUDE oscalls.inc
	INCLUDE string.inc	

sBegin	CONST			

C_GETDAT	EQU	42	;Get Date Function
C_SETDAT	EQU	43	;Set Date Function
C_GETTIM	EQU	44	;Get Time Function
C_SETTIM	EQU	45	;Set Time Function


sEnd	CONST			


sBegin	_BSS

sEnd	_BSS


sBegin	NH_TEXT 		
	externNP B$STDALCTMP
	externNP B$STALCTMP
sEnd	NH_TEXT 		

sBegin	OS_TEXT 		
	externNP B$ERR_FC

	assumes CS,OS_TEXT

	SUBTTL	B$SDAT - Set Date.
	PAGE

;***
; B$SDAT - Set Date
;
; Purpose:
;	Call DOS to set the system DATE
; Input:
;	sdDat -  is a string descriptor for the new date string
; Output:
;	NONE
; Modifies:
;	NONE
; Exceptions:
;	B$ERR_FC may be called
;****
cProc	B$SDAT,<PUBLIC,FAR>,<SI>
parmSD	sdDate			
cBegin
	MOV	BX,sdDate	;put date string desc in BX
	PUSH	BX
	MOV	SI,[BX+2]	;[SI] has addr of string.
	MOV	CX,[BX] 	; [CX] has string length
	JCXZ	DAT_ERR 	; Brif null str
	CALL	GETNUM		;Get 1 or 2 digit number
	MOV	DH,AH		;[DH] = month
	CALL	DATSEP
	CALL	GETNUM
	MOV	DL,AH		;[DL] = day
	CALL	DATSEP
	CALL	GETNUM
	MOV	BX,1900 	; [BX] = Bias in case only 2-digit year
	JCXZ	DATE2		; Brif End-of-string
	MOV	AL,100
	MUL	AH		;Mult decade by 100
	XCHG	BX,AX		; Save bias for year add
	CALL	GETNUM		;Get year (digits 3 & 4).
	JC	DAT_ERR		; jif only digit 3 was there (3-digit year)
DATE2:
	MOV	AL,AH
	MOV	AH,0
	ADD	BX,AX		; Add 2 digits of base to century

	XCHG	BX,CX		; [CX] = year

	CALLOS	SETDAT		;Give date to DOS.
$TIM_RET:
	OR	AL,AL		;Date (or Time) OK?
	JNZ	DAT_ERR 	;Brif not.
	POP	BX
	CALL	B$STDALCTMP	;delete the temp
cEnd

DAT_ERR:
	JMP	SHORT DATE_ERROR


	SUBTTL	B$FDAT - Get Date.
	PAGE

;***
; B$FDAT - Get Date
;
; Input:
;	NONE
; Output:
;	[AX] == ptr to string descriptor for country-specific date string
; Modifies:
;	BX
; Exceptions:
;	Could call $ERC_OM
;****
cProc	B$FDAT,<PUBLIC,FAR,FORCEFRAME>,SI 
cBegin
	MOV	BX,10
	CALL	B$STALCTMP	;Get space for 10 char string
	PUSH	BX		;Save String Descriptor
	PUSH	DX		;Save addr of string
	CALLOS	GETDAT		;Get Date from DOS
	POP	BX		;Restore addr of String
	MOV	AL,DH
	CALL	PUTCHR		;Store ascii month
	MOV	AL,"-"
	CALL	PUTCH2
	MOV	AL,DL
	CALL	PUTCHR		;Store ascii day
	MOV	AL,"-"
	CALL	PUTCH2
	SUB	CX,1900 	;Reduce year by two digits
	CMP	CL,100		;See if in 20th century
	MOV	CH,19		;Setup 20th century in case
	JB	DATEF2		;Brif so.
	SBB	CL,100		;subtract into next century
	INC	CH		;21st century
DATEF2:
	MOV	AL,CH
	CALL	PUTCHR		;Store ascii century
	MOV	AL,CL
	CALL	PUTCHR		;Store ascii year.
	POP	AX		;return descriptor in AX
cEnd

DATE_ERROR:
	JMP	B$ERR_FC	;Complain


	SUBTTL	B$STIM - Set Time.
	PAGE
;***
; B$STIM - Set Time
;
; Input:
;	sdTime == string descriptor for time string to set
; Output:
;	NONE
; Modifies:
;	NONE
; Exceptions:
;	B$ERR_FC could be called
;****
cProc	B$STIM,<PUBLIC,FAR>,<SI>
parmSD	sdTime			
cBegin
	MOV	BX,sdTime	;[BX] = time string desc.
	PUSH	BX
	MOV	SI,[BX+2]	;[SI] has addr of string.
	MOV	CX,[BX] 	; [CX] has string length
	JCXZ	DATE_ERROR	; Brif null str
	CALL	GETNUM		;Get 1 or 2 digit number
	MOV	BH,AH		; [BH] = hours
	CALL	TIMSEP
	CALL	GETNUM
	MOV	BL,AH		; [BL] = minutes
	CALL	TIMSEP
	CALL	GETNUM
	MOV	DH,AH		;[DH] = seconds.
	XOR	DL,DL		;Zero 100ths.
	XCHG	BX,CX		; [CX] = hours/minutes
	CALLOS	SETTIM		;Give Time to DOS.
	JMP	$TIM_RET	;Check Time Ok & Exit.
cEnd	<nogen>

	SUBTTL	B$FTIM - Get Time.
	PAGE
;***
; B$FTIM - Get Time
;
; Input:
;	NONE
; Output:
;	[AX] == ptr to time string obtained from DOS
; Modifies:
;	NONE
; Exceptions:
;	Can call $ERC_OM
;****
cProc	B$FTIM,<PUBLIC,FAR,FORCEFRAME>,SI	
cBegin
	MOV	BX,8
	CALL	B$STALCTMP	;Get space for 8 char string
	PUSH	BX		;Save String Descriptor
	PUSH	DX		;Save addr of string
	CALLOS	GETTIM		;Get Time from DOS
	CMP	DL,50
	JB	TIMEF2		;Brif .lt. 1/2 sec
	INC	DH		;Bump secs.
	CMP	DH,60
	JB	TIMEF2		;Brif no ovf
	MOV	DH,0
	INC	CL		;Bump mins.
	CMP	CL,60
	JB	TIMEF2		;Brif no ovf
	MOV	CL,0
	INC	CH		;Bump hrs.
TIMEF2:
	POP	BX		;Restore addr of String
	MOV	AL,CH
	CALL	PUTCHR		;Store ascii hours
	MOV	AL,":"
	CALL	PUTCH2
	MOV	AL,CL
	CALL	PUTCHR		;Store ascii minutes
	MOV	AL,":"
	CALL	PUTCH2
	MOV	AL,DH
	CALL	PUTCHR		;Store ascii seconds.
	POP	AX		;return psd to time string in AX
cEnd

TIME_ERROR:
	JMP	DATE_ERROR	;Complain

	SUBTTL	$DATE and $TIME Utility Subroutines
	PAGE

	PAGE
;***
;DATTSEP - Searches for valid date seperator ( '-' or '/')
;Purpose:
;	Checks next char in search string for a valid date seperator.
;Entry:
;	CX - char count for search string
;	SI - pointer to search string
;Exit:
;	CX - count of chars left in search string
;	SI - points to next char in string
;	AL - date seperator char
;Uses:
;	SI
;Exceptions:
;	B$ERR_FC - if end of string or next char wasn't a valid seperator.
;****
cProc	DATSEP,<NEAR>
cBegin
	JCXZ	TIM_ERR 	; error if string empty
	DEC	CX		; Length -1
	LODSB
	CMP	AL,"/"
	JZ	GOT_DATSEP
	CMP	AL,"-"
	JNZ	TIM_ERR
GOT_DATSEP:
cEnd

	PAGE
;***
;TIMSEP - Searches for valid time seperator ( ':' or '.')
;Purpose:
;	Checks next char in search string for a valid time seperator.
;Entry:
;	CX - char count for search string
;	SI - pointer to search string
;Exit:
;	CX - count of chars left in search string
;	SI - points to next char in string
;	AL - time seperator char
;Uses:
;	SI
;Exceptions:
;	B$ERR_FC - if next char wasn't a valid seperator.
;****
cProc	TIMSEP,<NEAR>
cBegin
	JCXZ	GOT_TIMSEP	
	DEC	CX
	LODSB
	CMP	AL,":"
	JZ	GOT_TIMSEP
	CMP	AL,"."
	JNZ	TIM_ERR
GOT_TIMSEP:
cEnd

TIM_ERR:
	JMP	TIME_ERROR

	PAGE
;***
;GETNUM - Gets an ascii number, 1 or 2 characters long, and converts
;	  it to an integer.
;
;Purpose:
; Gets the next 1 or 2 ascii chars from string in SI and converts
; them to an unsigned intger which is returned in AH.  It is also returned in
; AL.
;
;Entry:
; [CX]	= char count for search string
; [SI]	= pointer to search string
;
;Exit:
; [AH]	= integer representation of ascii digit
; [CX]	= count of chars left in search string
; [SI]	= points to next char in string
; PSW.C set if only one character read, clear if two characters read
;
;Uses:
; Per convention
;
;Preserves:
; BX
;
;Exceptions:
; B$ERR_FC - if next char wasn't a valid digit.
;
;******************************************************************************
cProc	GETNUM,<NEAR>
cBegin
	CALL	DIGIT
	JB	TIM_ERR 	;required to handle relative jump
				;beyond 128 bytes
	MOV	AH,AL
	STC			; default: only one digit
	JCXZ	GETNUX		; Number complete if end of string.
	CALL	DIGIT
	JB	GETNUX
	AAD			;Convert BCD to Binary
	MOV	AH,AL
	CLC			; PSW.C clear for 2 characters read
GETNUX:
cEnd

	PAGE
;***
;DIGIT - Gets an ascii character and checks if it is in the range '0' - '9'
;
;Purpose:
; Gets the next ascii char from string in SI and checks to see if it is a
; character representation of a valid digit. If valid then the char is
; converted to BCD representation of the digit. Returns 0 if no chars are left
; in the string.
;
;Entry:
; [CX]	= char count for search string
; [SI]	= pointer to search string
;
;Exit:
; [AL]	= BCD representation of ascii digit
; [CX]	= count of chars left in search string
; [SI]	= points to next char in string
;
;Uses:
; Per convention
;
;Preserves:
; BX
;
;******************************************************************************
cProc	DIGIT,<NEAR>
cBegin
	MOV	AL,CL		; Init to 0 if string exhausted
	JCXZ	DIGIX		; Brif so, returns 0
	MOV	AL,[SI]
	SUB	AL,"0"		
	JB	DIGIX
	CMP	AL,10
	CMC
	JB	DIGIX
	DEC	CX		;Length -1
	INC	SI
DIGIX:
cEnd

	PAGE
;***
;PUTCHR - Converts a packed BCD number in AX into a char string and puts in BX
;Purpose:
;	Converts the packed BCD number into an ascii character string which
;	is then placed into the buffer pointed to by [BX].  BX is updated
;	to point past the added chars.
;Entry:
;	AX - pack BCD number
;	BX - buffer to place string into
;Exit:
;	BX - points past added chars
;Uses:
;	None.
;Exceptions:
;	None.
;****
cProc	PUTCHR,<NEAR>
cBegin
	AAM			;Convert to unpacked BCD
	OR	AX,"00" 	;Add "0" bias to both digits.
	MOV	[BX],AH 	; store char in string
	INC	BX
PUTCH2:
	MOV	[BX],AL 	; store char in string
	INC	BX
cEnd

sEnd	OS_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\osinit.asm ===
TITLE	OSINIT - Operating System Initialization/Termination module

;***
;OSINIT.ASM - Operating System	initialization/termination module
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains Operating System specific initialization
;	and termination support for the BASIC 3.0 runtime.  This module
;	will only be present in a user's program when a program contains
;	statements or features which need Operating system specific support.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;
;	Code Segments
;
	USESEG	<INIT_CODE>	;Initialization
	USESEG	<OS_TEXT>	;Operating System
	USESEG	<NH_TEXT>	;Near Heap
	USESEG	<ER_TEXT>	; Runtime errors
	USESEG	<DV_TEXT>	

;
;	Data Segments
;
	USESEG	<_BSS>		;runtime data (uninitialized)
	USESEG	<_DATA> 	;runtime data (initialized)
	USESEG	<CONST> 	;runtime constants
	USESEG	<XIB>		; XIB and XIE must bracket XI!
	USESEG	<XI>		;initializer segment
	USESEG	<XIE>		

	INCLUDE seg.inc
	INCLUDE files.inc	; buffer length constant
	INCLUDE idmac.inc	
	INCLUDE rtps.inc	; constants shared with QBI

	INCLUDE compvect.inc	;component vectors

	INITIALIZER	B$xOSINI	;put B$xOSINI in initializer list.

	SUBTTL	Code Externals
	PAGE

sBegin	DV_TEXT 			
	externNP	B$NearRet	;for disp vectors in compvect.inc
sEnd	DV_TEXT 			

sBegin	NH_TEXT 			
	externNP	B$STDALCTMP	;deallocate sd if temp
sEnd	NH_TEXT 			

sBegin	ER_TEXT 			
	externNP	B$ERR_FC	
sEnd	ER_TEXT 			

	SUBTTL	Runtime data definitions for BASIC Operating System
	PAGE

sBegin	CONST

COMSPEC		DB	"COMSPEC="	;environment header string
ComSpecLength	EQU	$ - COMSPEC	;length of environment header

ComSpecFile	DB	"\COMMAND.COM",0 ;default COMSPEC for DOS3

sEnd	CONST

sBegin	_DATA

;
;	external data
;
	externW b$ini_disp	;One time initialization dispatch table

sEnd	_DATA

sBegin	_BSS

	globalW b$env_len,?	;length of environment table.
	externW __aenvseg	;environment segment
	externB b$PATHNAM 	;buffer for filname parsing


sEnd	_BSS

	SUBTTL	Runtime Operating System  Initialization
	PAGE
assumes CS,INIT_CODE
sBegin	INIT_CODE

;***
;B$xOSINI - Operating System	initializer
;PLM B$xOSINI()
;
;Purpose:
;	Initializer for Operating System  component.  This routine is called
;	by the Crt0 startup before _main is called.  It will update the
;	indirect dispatch tables for the Operating System  routines.  This
;	insures that the only time that Operating System support is accessed
;	is when this module is linked into the user program.
;
;Entry:
;	None.
;
;Exit:
;	b$ini_disp.OS_IVEC	- contains pointer to B$OSINI
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xOSINI,<FAR>
cBegin
;
;	update "ONE" time initialization dispatch address to B$OSINI
;
	MOV	WORD PTR [b$ini_disp].OS_IVEC,OS_TEXTOFFSET B$OSINI
cEnd
sEnd	INIT_CODE		

	PAGE
assumes CS,OS_TEXT		
sBegin	OS_TEXT 		

;***
;B$OSINI	- One time initialization for Operating System
;void pascal B$OSINI()
;
;Purpose:
; BC3
; ---
;	Initializes Operating System component.
;	B$OSINI does the following:
;		determines the length of the environment table.
;
;Entry:
;	None.
;
;Exit:
;	b$env_len	- contains the length of the environment table.
;
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;
;****
cProc	B$OSINI,<NEAR>,<SI>	
cBegin
	PUSH	DS		;B$FIRST_ENV uses DS,SI
	CALL	B$FIRST_ENV	;DS:SI points to next env entry
	JZ	ENV_DONE	;if done, then jump

ENV_LOOP:
	CALL	B$NEXT_ENV	;keep getting the next env entry
				;SI points to beginning of next entry
	JNZ	ENV_LOOP	;if still not done, then jump

ENV_DONE:
	POP	DS		;restore data segment
	MOV	b$env_len,SI	;store offset of end (segment length)
cEnd

;***
; B$BldExecCmdLine - Parse command line for SHELL into acceptable form
; Purpose:
;	Parse command line into acceptable form for DOS exec call.
;	This routine is used by SHELL and OPEN "PIPE:".
;
;	Callers should have called B$HoldBuf1 if ID_DEBUG.	
;	(B$HoldBuf2 also if OS/2)				
;
; Inputs:
;	BX - psd of EXEC command string
; Outputs:
;	b$PATHNAM
;	If DOS5:
;		AX - contains CMD.EXE file spec to exec into. (= b$Buf2)
;		b$PATHNAM - contains parsed command line.
;	If DOS3:
;		DX:AX - far pointer to COMSPEC file spec.
;		b$PATHNAM - parsed command tail for EXEC.
; Modifies:
;	per conv.
; Uses:
;	per conv.
; Exceptions:
;	B$ERR_FC upon buffer overflow (> 128)
;******************************************************************************

cProc	B$BldExecCmdLine,<PUBLIC,NEAR>,<SI,DI,ES>
cBegin

;	Put string argument into b$PATHNAM zero-terminated.

	MOV	CX,[BX] 	;get length of string
	MOV	SI,[BX+2]	;get starting offset of string

	PUSH	DS		; set ES = DS before STOS
	POP	ES		

	MOV	DI,OFFSET DGROUP:b$PATHNAM+1 ;start with second byte

	JCXZ	NO_ARGS 	;branch if null argument

	MOV	AX,'C/' 	;want command /C
	STOSW
	MOV	AL,' '		;put a space after /C
	STOSB

	CMP	CX,FILNAML -1 -3 -1	; will we overflow buffer?
	JA	Overflow	; Brif so
	REP	MOVSB		;move the string to b$PATHNAM

NO_ARGS:			

;	For DOS5, just terminate with a null byte.
;	For DOS3, terminate with a carraige-return and set the first
;	byte of the buffer with the length of the string (not including
;	the appended carraige-return).

	MOV	BYTE PTR [DI],13 ;put a carriage-return at line end [10]
	SUB	DI,OFFSET DGROUP:b$PATHNAM+1 ;length of line without CR
	XCHG	AX,DI		;put length to a "byte-able" register
	MOV	b$PATHNAM,AL	;...and put into the first byte of buffer

	CALL	B$STDALCTMP	;deallocate the argument string if temporary

;	Determine far pointer to ENV table value for COMSPEC.

	MOV	ES,__aenvseg	; set ES to environment segment
	XOR	DI,DI		;start at beginning of segment
	MOV	AX,DI		;clear for scanning and tests

;	See if entry header in ENV table is "COMSPEC=".

COM_SEARCH:
	MOV	SI,OFFSET DGROUP:COMSPEC
	MOV	CX,ComSpecLength ;length of environment header
	REPZ	CMPSB
	JE	GOT_COMSPEC	;found it, proceed.

	MOV	CX,0FFFFH	;scan maximum amount until match
	REPNZ	SCASB		;scan so ES:DI points to byte after zero
	CMP	ES:[DI],AL	;test for double zero at ENV table end
	JNZ	COM_SEARCH	;if not table end, then try again

	MOV	DI,OFFSET DGROUP:ComSpecFile ;get the default file spec
	PUSH	DS
	POP	ES		;set ES = BASIC DS
GOT_COMSPEC:

;	For DOS5, copy the COMSPEC value into the buffer at b$Buf2.


;	For DOS3, put far pointer of ENV value in DX:AX.

	MOV	DX,ES		;for DOS 3, save the pathname segment...
	MOV	AX,DI		;...and offset

	PUSH	DS		;put DGROUP segment on stack...
	POP	ES		;...and set ES = DS = DGROUP

cEnd

Overflow:			
	JMP	B$ERR_FC	

;***
; B$FIRST_ENV - get first ENV entry
; B$NEXT_ENV - get next ENV entry
; Purpose:
;	Establish segment addressibility for environment segment and
;	return offset of the first entry. (B$FIRST_ENV)
;	Return offset the next next entry. (B$NEXT_ENV)
;
; Inputs:
;	None. (B$FIRST_ENV)
;	DS = environment segment. (B$NEXT_ENV)
;	BX = start of search for entry. (B$NEXT_ENV)
; Outputs:
;	DS = environment segment
;	SI = start of string or end of environment
;	BX = start of search for next entry
;	CX = length of string returned (zero if end of environment)
;	ZF = set if CX=0
; Modifies:
;	None.
; Exceptions:
;	None.
;****


cProc	B$FIRST_ENV,<NEAR,PUBLIC>	
cBegin				

	MOV	DS,__aenvseg	;get environment segment
	XOR	SI,SI		;DS:SI points to first environment entry

cEnd	<nogen>			; fall into B$FIRST_ENV


cProc	B$NEXT_ENV,<NEAR,PUBLIC>,<AX>	
cBegin				

	MOV	BX,SI		;return with bx = si at entry
	XOR	CX,CX		;length = 0
	CMP	DS:[SI],CL	;end or empty ?
	JZ	NXTENX		; yes
	INC	SI
NXTEN1:
	INC	CX
	LODSB
	OR	AL,AL		;eos ?
	JNZ	NXTEN1		;no, continue
NXTENX:
	OR	CX,CX		;set non-zero if not end of table

cEnd				


sEnd	OS_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\ovlmul.asm ===
TITLE	ovlmul - I4 Multiply with overflow checking
;***
;ovlmul - I4 Multiply with overflow checking
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; 8086 Signed Long Multiply Routine, which checks overflows
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	UseSeg	_TEXT

	INCLUDE seg.inc

sBegin	_TEXT			
assumes CS,_TEXT		

;*** 
; ovlmul - I4 Multiply with overflow checking
;
;Purpose:
; 8086 Signed Long Multiply Routine, which checks overflows
;
;Entry:
; A & B 	= Numbers to multiply
;
;Exit:
; [DX:AX]	= result
; C		= set on overflow
;
;Uses:
;
;Preserves: (optional)
;
;Exceptions:
;
;******************************************************************************

labelFP <PUBLIC,__aFlmul>	
cProc  __aFulmul,<PUBLIC>,<si,di>

parmD	A
parmD	B

cBegin
	MOV	DX,SEG_A
	MOV	AX,OFF_A	;DX:AX == A
	MOV	SI,SEG_B
	MOV	DI,OFF_B	;SI:DI == B

;first get result sign and absolute value of numbers

	MOV	BX,DX		; will hold result sign flag
	OR	DX,DX		; is A negative ?
	JNS	MULABA		; jump if positive
	NEG	AX		; neg A lo
	ADC	DX,0		; inc A hi
	NEG	DX		; neg A lo

MULABA: XOR	BX,SI		; BP Most signifcant bit = result sign
	OR	SI,SI		; is B negative ?
	JNS	MULABB		; jump if positive
	NEG	DI		; neg B lo
	ADC	SI,0		; inc B hi
	NEG	SI		; neg B hi
;
;four cases: A hi is significant, and/or B hi is significant
MULABB: OR	SI,SI		; anything in B hi ?
	JNZ	MULYHI		; if not, fall through
	XCHG	SI,DX		; swap hi parts
	OR	SI,SI		; anything in A hi ?
	JNZ	MULXHI		; if not, fall through
	MUL	DI		; just multiply lo parts
	OR	DX,DX		; set sign flag for result
;
; Result in DX:AX, sign flag is for DX, sign wanted is in BP
MULFIN: JS	MULOVR		; check later signed overflow
	OR	BX,BX		; check sign bit
	JNS	MULEND		; jump if positive
	NEG	AX		; neg result lo
	ADC	DX,0		; inc result hi
	NEG	DX		; neg result hi
MULEND:
	CLC
	JMP	SHORT MULEAVE	; finished
;
MULYHI: OR	DX,DX		; anything in A hi ?
	JNE	MULOVR		; if so, go overflow
	XCHG	AX,DI		; correct lo parts
;
;Result wanted is DI times SI:AX, times sign
MULXHI: XCHG	AX,SI		; swap lo and hi parts
	MUL	DI		; one lo times the other hi
	JC	MULOVR		; check for hi part nonzero
	XCHG	AX,SI		; swap lo and result parts
	MUL	DI		; one lo times the other lo
	ADD	DX,SI		; final accumulate
	JNC	MULFIN		; check unsigned overflow
;Overflow, set carry flag and return
MULOVR:	STC

MULEAVE:

cEnd

sEnd
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\out.asm ===
TITLE	OUT - Output utilities
;***
; OUT - Text Output utilities
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
	INCLUDE switch.inc	;Runtime switch file
	INCLUDE rmacros.inc	;General runtime macros

	useSeg	_DATA		;Uses the Data segment
	useSeg	_BSS		;and the BSS segment
	useSeg	RT_TEXT 	;and the core code segment
	useSeg	NH_TEXT 	

	INCLUDE seg.inc 	;Segment definitions

	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE ascii.inc
	INCLUDE idmac.inc
	INCLUDE const.inc	

sBegin	_DATA			

	externB	b$IOFLAG	; Misc. IO flags.  Defined in GWINI.ASM
	externW	b$CURSOR	; (1,1)-relative screen cursor
	externB	b$CSRX		; 1-relative x-coordinate cursor

sEnd	_DATA			

sBegin	_BSS			

	externW	b$PTRFIL	;defined in GOSTOP.ASM

sEnd	_BSS			


	externFP __FMSG_TEXT	;Get message text from number


sBegin	RT_TEXT 		

	PUBLIC	B$TYPSTR
	PUBLIC	B$TYPSTR1
	PUBLIC	B$TYPCNT
	PUBLIC	B$OUTCNT

	externNP B$TTY_SOUT
	externNP B$STRSOUT
	externNP B$CHKLASTCOL	; check for last column on screen
	externNP B$UPDATE_CSR	; update cursor position after write


assumes CS,RT_TEXT		

	PAGE

;*** 
; B$ITCR -- type CR/LF on console.  Added with [15].
;
;Purpose:
;
;Entry:
;	None
;Exit:
;	b$PTRFIL is reset
;Uses:
;	None
;Exceptions:
;	None
;******************************************************************************
cProc	B$ITCR,<PUBLIC,FAR>
cBegin
	CALL	B$$TCR
cEnd


;*** 
; B$$TCR -- type CR/LF on console.
;
;Purpose:
;
;Entry:
;	None
;Exit:
;	b$PTRFIL is reset
;Uses:
;	None
;Exceptions:
;	None
;******************************************************************************
cProc	B$$TCR,<PUBLIC,NEAR>,<AX> 
cBegin				

	MOV	AL,ASCCR	;  Output CR only
	CALL	B$$WCHT		

cEnd				

;*** 
; B$$WCHT -- type char on console.
;
;Purpose:
;
;Entry:
;	None
;Exit:
;	b$PTRFIL is reset
;Uses:
;	None
;Execptions:
;	None
;******************************************************************************
cProc	B$$WCHT,<PUBLIC,NEAR>	
cBegin				
	MOV	[b$PTRFIL],0	  ;must be zero for TTY output
	JMP	B$TTY_SOUT
cEnd	<nogen>			; return via B$TTY_SOUT


;***
; B$PRINTNUM - Print numbered message to the screen [17]
;
;Purpose:
; Prints a string to the console device (B$PTRFIL = 0), as referenced by the
; passed message number.  Must not be used for fatal errors or if you don't
; want PRINT code pulled in.  Use B$PUTNUM in ERPROC.ASM instead. 
;
;Entry:
; [AX] = Message number
;
;Exit:
; None.
;
;Uses:
; Per convention.
;
;NOTE:	The interpreter provides a version of this routine (B$PUTNUM)
;	to print strings their way.
;
;******************************************************************************

;***
; B$PUTS - Print a null terminated string to console
;
;Purpose:
; Prints a string to the console device (B$PTRFIL = 0).
;
;Entry:
; [DX:AX] = Address of string
;
;Uses:
; Per convention
;
;NOTE:	The interpreter uses this routine, so if we change the interface
;	to use a far ptr, we need to notify them.
;
;******************************************************************************
cProc	B$PUTS,<NEAR,PUBLIC>,ES 
cBegin				
	MOV	[b$PTRFIL],0	; must be zero for TTY output
	MOV	ES,DX		; set up seg reg
	XCHG	AX,BX		; [ES:BX] points to string
	OR	DX,DX		; See if null pointer
	JNZ	PUTS_10 	; Enter the loop if not
	JMP	SHORT PUTS_15	

PUTS_5: 			
	CALL	B$TTY_SOUT	; output char
PUTS_10:			
	MOV	AL,ES:[BX]	; Get byte from string
	INC	BX		
	OR	AL,AL		; see if end
	JNZ	PUTS_5		; jump if it isn't
PUTS_15:			
cEnd				

;***
;B$TYPSTR - Output string defined by string decsriptor
;
;Purpose:
;	Output string defined by string decsriptor to the screen.
;
;Entry:
;	[BX]  = Address of string descriptor
;
;Exit:
;	String output
;
;Uses:
;	Per convention, plus SI.
;
;******************************************************************************
B$TYPSTR:
	MOV	CX,[BX]

;***
;B$TYPCNT, B$TYPSTR1 - Output n bytes of a string defined by string decsriptor
;
;Purpose:
;	Output n bytes of a string defined by string decsriptor to the
;	console.  The alternate entry point B$TYPSTR1 is used by B$PTRSTR
;	and does not check for a 0 length string nor does it update
;	b$PTRFIL.
;
;Entry:
;	[BX]  = Address of string descriptor
;	[CX]  = Count of bytes to output
;
;Exit:
;	String output
;
;Uses:
;	Per convention, plus SI.
;
;******************************************************************************
B$TYPCNT:
	JCXZ	RETL
	MOV	[b$PTRFIL],0	;must be zero for TTY output
B$TYPSTR1:			;entry point used by B$PRTSTR
	MOV	SI,[BX+2]	; SI = string address
; See if we can pump the whole string out at once, or if we must do it a
; character at a time ---

;	CMP	CX,4
;	JBE	B$OUTCNT 	;brif 4 or less chars in string: not worth it
	TEST	b$IOFLAG,RED_OUT OR LPR_ECHO OR F_EDIT	
	JNZ	B$OUTCNT 	;BRIF user wants output to echo to printer
				;or in INPUT mode or redirected output
	MOV	AL,b$CSRX	; horizontal cursor position (1-relative)
	CBW			; clear high byte
	DEC	AX		; make 0-relative
	ADD	AX,CX		;add in number of chars in string
	OR	AH,AH		; string size + cursor loc > 255?
	JNZ	B$OUTCNT 	;brif so
	XCHG	DH,AL		; DH = column to test (one less than what
				; we'll get when done)
	CALL	B$CHKLASTCOL	; more than one past last column on screen?
	JA	B$OUTCNT	; brif so -- we'll have to wrap to print it
				; If we get b$CSRX = 81 when done, that's
				; OK.
	PUSH	CX		; save string length and address
	PUSH	SI		
CTL_CHK:
	LODSB			; AL = next char
	CMP	AL,31		; is this character a control character?
	JBE	CTL_CH_FOUND	;BRIF so
	LOOP	CTL_CHK 	;loop until all chars in string are checked


CTL_CH_FOUND:
	;here if we found a ctl char in our string; print it the slower way
	POP	SI		; restore string address and length
	POP	CX		

	;Fall through into B$OUTCNT

;***
;B$OUTCNT - Output a string of characters one at a time
;
;Purpose:
;	Print a string of characters to the screen one at a time.
;	A count is given of the number of characters to be printed,
;	the string does not have to be nul terminated.
;
;	If FK_KANJI, then we also have to flush the one byte buffer
;	that B$TTY_SOUT uses to hold the first part of a double
;	byte character.  This is done in case this string contains
;	pieces of a KANJI character.
;
;Entry:
;	CX - Count of characters to be printed
;	DS:SI - Pointer to first character
;
;Exit:
;	DS:SI - Points to position after the CXth character.
;
;Uses:
;	SI as a pointer to the string, it is updated upon exit.
;
;Exceptions:
;	None.
;****
B$OUTCNT:
	LODSB
	CALL	B$TTY_SOUT
	LOOP	B$OUTCNT
RETL:	RET

	SUBTTL	TTY input supporting routine -- B$INPCRLF
	page

;***
;B$INPCRLF -- print the terminating CR/LF(s).
; Moved here from inptty.asm with revision [18] for /O granularity.
;
;Purpose:
;	This routine prints a terminating CR/LF after an INPUT or
;	LINE INPUT statement that did not have a ';' to suppress the
;	CR.  It also writes a CR/LF to the screen when output is
;	redirected and input is not redirected, in order to keep
;	successive INPUT statements from writing over each other.
;
;Entry:
;	b$IOFLAG set correctly
;Exit:
;Uses:
;	none
;Exceptions:
;	none
;***********************************************************************

cProc	B$INPCRLF,<PUBLIC,NEAR>,<AX>

cBegin
	CALL	B$$TCR			; write terminating CR/LF to either
					; screen/printer or redir. file
	MOV	AL,b$IOFLAG		
	AND	AL,RED_OUT OR RED_INP	; is output redirected and input
	CMP	AL,RED_OUT		; 	not redirected?
	JNZ	NO_EXTRA		; brif not -- no extra CR required

	; output a CR/LF to the screen and possibly the printer when output
	; redirected and input not redirected.
					; notice AL = RED_OUT !!!
	XOR	b$IOFLAG,AL		; Fake B$TTY_SOUT into thinking it
					; should to print to the screen
					; (and printer) instead of to the
					; redirected file.
	CALL	B$$TCR			; write CR/LF to screen
	OR	b$IOFLAG,AL		; Reset RED_OUT flag.
NO_EXTRA:				

cEnd					; return to caller

sEnd	RT_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\peek.asm ===
TITLE	PEEK - PEEK and POKE runtime functions
;***
; PEEK - PEEK and POKE runtime functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - PEEK Function:	- POKE Statement:
;
;      v = PEEK(n)	     POKE n,m
;	     |		       |
;	  B$PEEK	     B$POKE
;
;
; - INP Function:	- OUT Statement:
;
;      v = INP(port)	     OUT port,v
;	     |			|
;	  B$PINP	     B$POUT
;
;
; - WAIT Statement:
;
;      WAIT port, AND_mask [,XOR_mask]
;	     |
;	  B$WAIT
;
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	_BSS		
	useSeg	RT_TEXT 	

	INCLUDE seg.inc 	


sBegin	_BSS			
	externW b$seg		;current DEF SEG
sEnd	_BSS			

sBegin	RT_TEXT 		
assumes CS,RT_TEXT		


	SUBTTL	B$PEEK & B$POKE
	PAGE
;***
; B$PEEK - PEEK location
;
;Purpose:
; Get byte value at a far location.
;
;Input:
; addr	= far pointer to location
;
;Output:
; [AX]	= byte fetched from specified location
;
;Modifies:
; Per convention
;
;******************************************************************************
cProc	B$PEEK,<FAR,PUBLIC>,<ES> 
parmW	addr			; Offset from b$seg to fetch from
cBegin				


	MOV	ES,[b$seg]	; [ES] = cur DEF SEG value
	MOV	BX,addr 	; [ES:BX] = address to read from


	XOR	AX,AX		; init return value
	MOV	AL,ES:[BX]	; [AL] = byte to return

cEnd

;***
;B$POKE - POKE location
;
;Purpose:
; Put byte value at a far location.
;
;Input:
; addr	= address to be poked
; val	= value to be placed there
;
;Output:
; NONE
;
;Modifies:
; Per convention
;
;******************************************************************************
cProc	B$POKE,<FAR,PUBLIC>,<ES,BX> 
parmW	addr			; Offset from b$seg to put to
parmW	val			; value to put
cBegin				


	MOV	ES,[b$seg]	; [ES] = cur DEF SEG value
	MOV	BX,addr 	; [ES:BX] = address to write to


	MOV	AX,val		; get value to place
	MOV	ES:[BX],AL	; put it

cEnd

	SUBTTL	B$WVERIFY & B$RVERIFY - verify validity of address
	PAGE



;***
;B$PINP - Input byte from port into AL.  Added as part of [5]. 
;
;Purpose:
;
;Entry:
;	port_num = port number from which to input
;Exit:
;	AL = value input from port
;	AH = 0
;Modifies:
;	DX
;Preserves:
;	BX,CX
;Exceptions:
;	Permission denied error for DOS 5
;
;******************************************************************************
cProc	B$PINP,<FAR,PUBLIC>
parmW	port_num		; port number
cBegin
	MOV	DX,port_num	; get port number in DX
	IN	AL,DX		; input value from port into AL
	XOR	AH,AH		; clear high byte
cEnd


;***
;B$POUT - Output byte to port.  Added as part of [5]. 
;
;Purpose:
;
;Entry:
;	port_num = port number to which to output
;	value = byte to output to the port
;Exit:
;	None
;Modifies:
;	AL,DX
;Preserves:
;	AH,BX,CX
;Exceptions:
;	Permission denied error for DOS 5
;
;******************************************************************************
cProc	B$POUT,<FAR,PUBLIC>
parmW	port_num		; port number
parmB	value			; data to output
				; (allocated as a word on the stack)
cBegin
	MOV	DX,port_num	; get port number in DX
	MOV	AL,value	; get value to output into AL
	OUT	DX,AL		; output value to port
cEnd


;***
;B$WAIT - Wait for value to appear at port.  Added as part of [5]. 
;
;Purpose:
;	Wait for a non-zero value to appear at a port.  Continues to
;	wait until ((port_value XOR xor_mask) AND and_mask) is non-zero.
;
;Entry:
;	port = port number on which to wait
;	AND_mask = expression to AND against port value
;	XOR_mask = expression to XOR against port value
;Exit:
;	None
;Modifies:
;	None
;Preserves:
;	All
;Exceptions:
;	Permission denied error for DOS 5
;
;******************************************************************************
cProc	B$WAIT,<FAR,PUBLIC>
parmW	port_num		; port number
parmB	AND_mask		; expression to AND against port value
				; (allocated as a word on the stack)
parmB	XOR_mask		; expression to XOR against port value
				; (allocated as a word on the stack)
cBegin
	MOV	DX,port_num	; get port number in DX
WAIT_LOOP:
	IN	AL,DX		; input value from port into AL
	XOR	AL,XOR_mask	; XOR the value read from port with mask
	AND	AL,AND_mask	; AND the value read from port with mask
	JZ	WAIT_LOOP	; brif still zero -- continue to wait
cEnd



sEnd	RT_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\osstmt.asm ===
TITLE	OSSTMT - OS Unique features for BASCOM-86

;***
; OSSTMT - OS Unique features for BASCOM-86
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains Operating system-unique features for supporting
;	BASIC-callable DOS functions.
;
; BASIC Syntax mapping to the included runtime entry points:
;
; - ENVIRON Statement:
;
;      ENVIRON string
;	  |
;      B$SENV
;
; - ENVIRON$ Function:
;
;    Two types of arguments produce unique runtime calls:
;
;      stringvar = ENVIRON$(num)	 stringvar = ENVIRON$(string)
;		      | 				|
;		   B$FEVI			      B$FEVS
;
; - ERDEV Variable:
;
;      v = ERDEV
;	     |
;	  B$ERDV
;
; - ERDEV$ Variable:
;
;      v = B$ERDEV
;	      |
;	   B$ERDS
;
; - IOCTL$ Function:
;
;      IOCTL$ ([#]filenumber)
;	 |
;     B$FICT
;
; - IOCTL Statement:
;
;      IOCTL [#]filenumber, string
;	 |
;     B$SICT
;
; - SHELL Statement:
;
;      SHELL [commandstring]
;	 |
;     B$SSHL
;
; - SHELL Function:
;	x = SHELL(commandstring)
;	      |
;	    B$FSHL
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	<LOADRTM>	
	USESEG	<OS_TEXT>	
	USESEG	<ER_TEXT>	
	USESEG	<RT_TEXT>	
	USESEG	<ST_TEXT>	
	USESEG	<NH_TEXT>	
	USESEG	<FH_TEXT>	

	USESEG	<_DATA> 	
	USESEG	<_BSS>		

	INCLUDE seg.inc 	
	INCLUDE oscalls.inc	
	INCLUDE baslibma.inc
	INCLUDE files.inc
	INCLUDE devdef.inc
	INCLUDE addr.inc
	INCLUDE ascii.inc
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE string.inc	
	INCLUDE idmac.inc	
	INCLUDE const.inc	



ExecParamStruc	STRUC		

ExecEnvSeg	DW	?	;environment segment
CmdLineOff	DW	?	;offset of command line tail
CmdLineSeg	DW	?	;segment of command line tail
FileBlock1Off	DW	?	;offset of first FCB (offset 5CH in PSP)
FileBlock1Seg	DW	?	;segment of first FCB
FileBlock2Off	DW	?	;offset of second FCB (offset 6CH in PSP)
FileBlock2Seg	DW	?	;segment of second FCB

ExecParamStruc	ENDS		



	externFP UiReInit	;hooks interrupts for UI
	externFP UiPause 	;unhooks UI interrupts

;	Operating System Equates and Macros

sBegin	_DATA			

	externW b$pCommSave	;conditional vector to B$CommSave
	externW b$pCommRestore	;conditional vector to B$CommRestore
	externW b$nuldes	
	externW b$shli_disp	;SHELL initialization dispatch vectors
	externW b$shlt_disp	;SHELL termination dispatch vectors
	externW b$CURSOR	; current cursor position
	externB b$WDOBOT	; text window bottom

sEnd	_DATA			

sBegin	_BSS			

	externB b$PATHNAM	
	externW b$ERDEV
	externW b$ERDEVP
	externW b$env_len


	externB b$Buf2		; overlaid with EXEC parameter blocks

Fcb1Blk EQU	b$Buf2		;block for first FCB
Fcb2Blk EQU	b$Buf2+10H	;block for second FCB
ExecBlk EQU	b$Buf2+20H	;parameter block for EXEC call
IF	(20H + SIZE ExecParamStruc) GT FILNAML		
	ERROR -- b$Buf2 not big enough for EXEC parameter blocks
ENDIF							



sEnd	_BSS			

	externFP __ctermsub	; C math termination (returns)
	externFP B$cinitsub	; C math initialion (returns)

sBegin	ER_TEXT 		

	externNP B$FrameAFE	
	externNP B$ERR_FC
	externNP B$ERR_OM
	externNP B$ERR_IOE
	externNP B$ERR_IFN

sEnd	ER_TEXT 		

sBegin	NH_TEXT 		
	externNP B$STDALCTMP	
	externNP B$STALCTMP	
sEnd	NH_TEXT 		

sBegin	FH_TEXT			
	externNP B$FHShlTerm	; trick to drag in fhchn.asm!
sEnd	FH_TEXT			

	externFP B$COMP_DISP	;generalized dispatcher

	externFP B$RTMInstall	;routine to install RTM dispatch vector
	externFP B$RTMDeinstall ;routine to deinstall RTM vector

sBegin	RT_TEXT 		

	externNP B$$TCR		; do a CR/LF
	externNP B$GETCSRDATA	; get current cursor position and type.
	externNP B$SCNLOC	; update cursor position
	externNP B$OVWCSR	; turn on overwrite cursor
	externNP B$OFFCSR	; turn off cursor
	externNP B$GRMODE	; test for graphics mode


sEnd	RT_TEXT 		

	SUBTTL	SHELL support shared with QBI RTM loader
	PAGE
assumes CS,LOADRTM		
sBegin	LOADRTM 		

;***
; B$SHELL - SHELL the specified process.
;
;Purpose:
;	Added with revision [21].
;	SHELL the requested process and return an error code.
;Entry:
;	AX = environment seg to use					
;	CX:DX = ptr to program pathname to be execed.
;	BX = DGROUP ptr to argument list.
;	SI = DGROUP ptr to argrments to be parsed into FCB blocks.
;Exit:
;	AX = 0 if no error occurred.
;Uses:
;	Per Convention.
;Exceptions:
;	None.
;******************************************************************************

assumes	ES,DGROUP		
cProc	B$Shell,<PUBLIC,FAR>,<SI,DI,ES>
cBegin
;	Perform the DOS 3 shell operation.

	PUSH	DS		;set ES to DS
	POP	ES

;	Fill the EXEC parameter block.

	MOV	WORD PTR ExecBlk.ExecEnvSeg,AX	;use specified ENV block
	MOV	WORD PTR ExecBlk.CmdLineOff,BX	;set command line offset
	MOV	WORD PTR ExecBlk.CmdLineSeg,DS ;set cmdline far ptr
	MOV	WORD PTR ExecBlk.FileBlock1Off,OFFSET DGROUP:Fcb1Blk
	MOV	WORD PTR ExecBlk.FileBlock1Seg,DS ;set first FCB far ptr
	MOV	WORD PTR ExecBlk.FileBlock2Off,OFFSET DGROUP:Fcb2Blk
	MOV	WORD PTR ExecBlk.FileBlock2Seg,DS ;set second FCB far ptr

;	Parse the program name to point to first parameter.
;	Parse the first two parameters to the default FCB blocks.

	MOV	DI,OFFSET DGROUP:Fcb1Blk ;point to first FCB block
	MOV	AX,2901H	;function to parse - strip leading blanks
	INT	21H		;dummy FCB fill - SI points to first param
	INT	21H		;fill first FCB - SI points to second param
	MOV	DI,OFFSET DGROUP:Fcb2Blk ;point to second FCB block
	INT	21H		;fill second FCB - (unused params null)

;	Set up the registers for the EXEC, save SS:SP in CS, and
;	perform the EXEC call.

	PUSH	DS		;save DGROUP segment on stack
	PUSH	BP		;save frame pointer on stack
	MOV	DS,CX		;set COMSPEC segment in data segment

assumes DS,NOTHING

	MOV	BX,OFFSET DGROUP:ExecBlk ;ES:BX has pointer to param block
	MOV	AX,4B00H	;DOS function to EXEC program


	MOV	CS:SavedSSinCS,SS ;save the stack segment in CS
	MOV	CS:SavedSPinCS,SP ;save the stack pointer in CS

	INT	21H		;EXEC - all regs changed except CS:IP

;	After EXEC return, restore the stack and save any error code.

	CLI			;turn off interrupts
	MOV	SS,CS:SavedSSinCS ;restore the stack segment
	MOV	SP,CS:SavedSPinCS ;restore the stack pointer
	STI			;turn interrupts back on


	POP	BP		;restore frame pointer from stack
	POP	DS		;restore the data segment

assumes DS,DGROUP
	JC	ExecError	;jump if error, AX has error code
	XOR	AX,AX		;if no error, then no error code
ExecError:

cEnd

;	Stack segment and offset pointer must be saved in the
;	current code segment for restoration after the EXEC call.


SavedSPinCS	DW	?	;saved stack pointer before EXEC
SavedSSinCS	DW	?	;saved stack segment before EXEC

assumes	ES,NOTHING		

sEnd	LOADRTM 		

	PAGE
assumes CS,OS_TEXT		
sBegin	OS_TEXT 		
	externNP B$LHFDBLOC	
	externNP B$SHLSAV	
	externNP B$SHLRST	
	externNP B$SEGINI

	externNP B$BldExecCmdLine ;parse and build command line for exec
	externNP B$FIRST_ENV
	externNP B$NEXT_ENV

;***
; B$ShellSetup - Set up runtime for a SHELL.
;
;Purpose:
;	Added with revision [21].
;	Prepares runtime for a SHELL by getting off of interrupts,
;	and compressing near and far heaps as much as possible.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	Per Convention.
;Exceptions:
;	None.
;******************************************************************************
cProc	B$ShellSetup,<PUBLIC,FAR>,<SI>
cBegin

;	For QBI, let User Interface off of it's interrupts.

	PUSH	ES		
	CALL	UiPause		; Let UI Get it's BUTT out of the way.
	POP	ES		

;	Disable and preserve the runtime state.

	MOV	SI,OFFSET DGROUP:b$shlt_disp ;SHELL term disp vector
	cCall	B$COMP_DISP	;do SHELL termination

	CALL	B$SHLSAV	;perform low-level SHELL save routine
	CALL	[b$pCommSave]	
	CALL	__ctermsub	; terminate math

;	give the shelled program a cursor
	MOV	AX,OFFSET CS:B$OVWCSR	; assume to turn on cursor
	call	B$GRMODE	; graphics mode?
	JZ	DSPL_CURSOR	; brif not -- display overwrite cursor
	MOV	AX,OFFSET CS:B$OFFCSR	; turn off the cursor
DSPL_CURSOR:
	MOV	DX,b$CURSOR	; at current position
	CALL	AX		; display appropriate cursor
NoCursor:			


;	For DOS 3 RTM and QBI UL, deinstall the RTM dispatch interrupt

	CALL	B$RTMDeinstall ;remove the vector

cEnd
	PAGE
;***
; B$ShellRecover - Restore runtime after a SHELL.
;
;Purpose:
;	Added with revision [21].
;	Restores runtime to the pre-SHELL state by reinstalling interrupts,
;	and expanding near and far heaps as much as possible.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	Per Convention.
;Exceptions:
;	None.
;******************************************************************************
cProc	B$ShellRecover,<PUBLIC,FAR>,<SI>
cBegin
;	For DOS 3 RTM, reinstall the RTM dispatch interrupt

	CALL	B$RTMInstall	;relink the interrupt vector

;	Restore the runtime state.

	CALL	B$cinitsub	; re-init math
	CALL	B$SEGINI 	;establish the new DGROUP value
	CALL	B$SHLRST	;perform low-level initialize after SHELL

	CALL	B$GETCSRDATA	; DX,CX = current cursor position,type
	CALL	B$SCNLOC	; update cursor position variables, since
				; the SHELL might have modified it, and
				; display user cursor.
	CMP	DL,b$WDOBOT	; outside of current text window now?
	JBE	NoCursorRestore	; brif not -- don't scroll
	CALL	B$$TCR		; do a CR/LF to scroll the screen and
				; (possibly) bring cursor position back
				; into current text window range
NoCursorRestore:		

	MOV	SI,OFFSET DGROUP:b$shli_disp	;SHELL init disp vector
	cCall	B$COMP_DISP	;do SHELL reinitialization



	CALL	[b$pCommRestore] ;restore the communication device state

;	For QBI, let User Interface off of it's interrupts.

	CALL	UiReInit	;Let UI Get it's BUTT back in the way.

cEnd
	PAGE
;***
; B$FSHL - asynchronous SHELL function runtime routine (DOS 5)
; Purpose:
;	B$FSHL performs an asynchronous SHELL function and
;	returns the process ID of the executing task.
;
; Inputs:
;	BX - string descriptor of EXEC command string
; Outputs:
;	AX - Process ID of spawned process.
; Modfies:
;	None.
; Uses:
;	None.
; Exceptions:
;	Advanced feature error if not OS/2
;******************************************************************************

cProc	B$FSHL,<PUBLIC,FAR>,<SI,DI,ES>

cBegin				
	JMP	B$FrameAFE	; advanced feature error + frame setup
cEnd	<nogen>


;***
; B$SSHL - SHELL command runtime routine
; Purpose:
;	B$SSHL saves its current environment and
;	performs an EXEC call with the string argument given.  The
;	saved environment is then restored.
;
; Inputs:
;	sdExec/psdExec - sd or psd of EXEC command string
; Outputs:
;	None.
; Modifies:
;	None.
; Uses:
;	None.
;*****************************************************************************

cProc	B$SSHL,<PUBLIC,FAR>,<SI,DI,ES>
parmSD	sdExec			
cBegin


	PUSH	DS		;get DGROUP on stack...
	POP	ES		;...and set ES to DGROUP
assumes	ES,DGROUP		

	GetpSD	BX,sdExec	; [BX] = psdExec
	cCall	B$BldExecCmdLine ;parse command line into b$PATHNAM

	PUSH	AX		;save COMSPEC far ptr offset
	PUSH	DX		;save COMSPEC far ptr segment

	cCall	B$ShellSetup	;prepare for SHELL operation

;	Perform the DOS 5 shell operation.


;	Perform the DOS 3 shell operation.

	POP	CX		;get COMSPEC segment (saved as DX)
	POP	DX		;get COMSPEC offset (saved as AX)

	MOV	SI,OFFSET DGROUP:b$PATHNAM ;get pointer to cmdline byte count
	MOV	BX,SI		;get ptr to command tail.
	CMP	BYTE PTR [SI],0	;test if null string given
	JZ	ExecNullCmd	;if so, process to get null FCB's
	MOV	SI,OFFSET DGROUP:b$PATHNAM+4 ;point to program name (past /C)

ExecNullCmd:			
	XOR	AX,AX		;tell B$SHELL to use current ENV block
	cCall	B$Shell	;call common code to do the SHELL.

	PUSH	AX		;Save return code for later

	cCall	B$ShellRecover ;reset runtime to PreSHELL state.

;	Now that runtime is restored, check return code

	POP	AX		;recover error code
	OR	AX,AX		;error
	JZ	SHL_NOT_FAILED	;if not, then jump
	CMP	AX,8		;test if out of memory
	JE	ShellMemErr	;if so, then jump
	JMP	B$ERR_FC	;else illegal function call
ShellMemErr:			
	JMP	B$ERR_OM	;give out-of-memory error
SHL_NOT_FAILED:


cEnd


;***
; B$SENV - Environ statement
; Purpose:
;	Argument is a string of the syntax <env_name>=<env_value>.
;	If <env_value> is nonnull and <env_name> exists, replace it.
;	If <env_value> is nonnull and <env_name> does not exist, add it.
;	If <env_value> is null, delete <env_name> if it exists.
;
; Inputs:
;	string descriptor of argument string
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	B$ERR_FC if function argument error.
;******************************************************************************

cProc	B$SENV,<PUBLIC,FAR>,<SI,DI,ES> 
parmSD	sdEnviron		
cBegin
	PUSH	DS		; Set es=DS
	POP	ES
	MOV	BX,sdEnviron	;get environment descriptor in BX
	mov	cx,[bx] 	;length of string
	mov	si,[bx+2]	;count in string
	push	bx
	mov	dx,cx
	push	dx
	push	si
	jcxz	errfc
envsf1: 			;look for blank or equals:  address of
	lodsb			;string to move into environment
	cmp	al,' '
	jz	envsf2
	cmp	al,'='
	jz	envsf2
	loop	envsf1
	JMP	SHORT ERRFC	;error if no delimiter

envsf2:
	sub	dx,cx		;size of parm
	jz	errfc		;zero is bad
envsf3:
	dec	cx		;adjust length
	jz	envsf4		;no text follows - delete
	lodsb
	CMP	AL,'='		;test for equals sign
	JNZ	ENVS3A		;if not, then jump
	DEC	CX		;adjust length
	JZ	ENVSF4		;no text follows - delete
	LODSB			;get character after '='
	JMP	SHORT ENVS3B	;jump to test for semicolon, etc.
ENVS3A:
	cmp	al,' '
	jz	envsf3		;strip leading blanks
ENVS3B:
	cmp	cx,1		;if 1 left
	jne	envsf4
	cmp	al,';'		; and it is semi-colon
	jz	envsf3		;then assume delete
envsf4:
	dec	si		;adjust to beginning of text
	pop	di		;start of string
	push	cx		;save length of arg text
	CALL	B$FIRST_ENV	;get start of env in bx
	mov	cx,dx		;cx = length of parm
envsf5:
	mov	dx,si		;dx = start of next
	mov	si,bx		;si = start of this
	push	di		;save string start
	jz	envsf9		;if end, add new parm and text
	push	cx		;save parm length
	cld
	repz	cmpsb		;compare parm with env parm
	je	envsf7		;matched
envsf6:
	mov	si,dx		;don't want tz unless real end
	CALL	B$NEXT_ENV	;go to next env parm
	pop	cx		;length and
	pop	di		; parm start back
	jmp	envsf5

errfc:	jmp	B$ERR_fc

envsf7:
	lodsb			;get next byte from environment
	cmp	al,'='		;must have equals to be a match
	jne	envsf6		;try next
	pop	ax		;trash parm length
	mov	si,dx		;si = address of next parm
	mov	di,bx		;di = address of this parm
	mov	cx,es:b$env_len ;get total length of environment
	sub	cx,dx		;cx=endnext (length to compress)
	inc	cx		;copy includes table terminator
	push	di
	push	es		;save seg of string
	push	ds		;move env. seg into es
	pop	es
	rep	movsb		;compress
	pop	es		;restore seg of string
	pop	si		;start of this parm or end
envsf9:
	CALL	B$NEXT_ENV	;find end of table
	jnz	envsf9
	mov	di,si		;di = end of env table
	push	ds
	push	es
	pop	ds
	pop	es		;ds = string seg, es = env seg
	pop	si		;string start
	pop	ax		;ax = length of arg text
	pop	cx		;string length

	or	ax,ax
	jz	envsfx		;if arg text length then done
	mov	ax,di		;ax = current length of environ
	add	ax,cx		;+ new size
;INC	AX		;include terminator byte in length
assumes	ES,NOTHING		
	cmp	ax,b$env_len	;check if overflow
	jb	envs10		; no overflow
	push	ds
	pop	es
	jmp	B$ERR_om	;give out of memory error
envs10:
	lodsb
	cmp	al,'='		;blanks to right of '=' are included
	jz	envs11
	cmp	al,' '		;skip blanks
	jz	envs11
	stosb
	loop	envs10
	jmp	SHORT envsft	;terminate
envs11:
	DEC	CX		;one less character
	CMP	AL,' '		;test for blank character
	JNE	ENVS12		;if not blank, then jump
	JCXZ	ENVSFT		;if end of string, jump
	LODSB			;get the next character
	JMP	SHORT ENVS11	;process the character
ENVS12: 			;character after leading blanks
	CMP	AL,'='		;test for equals sign
	JE	ENVS13		;process rest of string as is
	PUSH	AX		;save character after blanks
	MOV	AL,'='		;put in equals sign
	STOSB			;and place it in the table
	POP	AX		;restore old character
ENVS13: 			;start of text string
	STOSB			;store first char (or explicit =)
	rep	movsb
envsft: 			;terminate label
	xor	ax,ax
	stosw			;00 ends env table
envsfx: 			;exit label
	push	ds
	pop	es
	pop	bx
	CALL	B$STDALCTMP	; delete if temp string desciptor
cEnd

;***
; B$SICT - IOCTL statement
; Purpose:
;	Send the specified string argument as an I/O-control
;	function to the file.
;
; Inputs:
;	file number
;	string to send
; Outputs:
;	None.
; Modifies:
;	None.
; Exceptions:
;	B$ERR_IFN if illegal file number.
;	B$ERR_FC if function error.
;	B$ERR_IOC if IOCTL error.
;******************************************************************************


cProc	B$SICT,<PUBLIC,FAR>,<SI> 
parmW	fileNum
parmSD	sdCtl			
cBegin
	MOV	BX,fileNum	;put file number in BX
	CALL	B$LHFDBLOC	; find FDB
	JZ	BADIFN2
	MOV	BX,sdCtl	; [BX] = string desc
	MOV	DX,[BX+2]	
	MOV	CX,[BX] 	
	PUSH	BX		; save
	MOV	AL,3
	FDB_PTR ES,SI,SI	;get FDB pointer
	MOV	BX,FileDB.FD_HANDLE 
	OR	BX,BX		;if zero, one of basic's devices
	JZ	ERRCTL2		
	CALLOS	IOCTL,ERRCTL,BX,CX,DX
	POP	BX		
	cCall	B$STDALCTMP	; deallocate it if it was temp
cEnd

ERRCTL2:			
	JMP	SHORT ERRCTL	
BADIFN2:			
	JMP	SHORT BADIFN	



;***
; B$FEVS - ENVIRON$ function with string argument
; Purpose:
;	With <env_name> as an input argument, return <env_value> if
;	the entry "<env_name>=<env_value>" is in the environment table.
;
; Inputs:
;	string descriptor of <env_name>
; Outputs:
;	AX = ptr to string descriptor of <env_value>
; Modifies:
;	None.
; Exceptions:
;	B$ERR_FC if function error.
;******************************************************************************

cProc	B$FEVS,<PUBLIC,FAR>,<SI,DI,DS,ES>	
parmSD	sdEnv			
cBegin
	PUSH	DS		
	POP	ES		
assumes	ES,DGROUP		
	MOV	BX,sdEnv	;get string desc. in BX
	MOV	SI,[BX+2]	;address of string
	MOV	CX,[BX] 	;length
	MOV	DX,CX		;save
	PUSH	SI
	JCXZ	BADFC
ENVRS1:
	LODSB
	CMP	AL,' '		;error if embedded blanks
	JZ	BADFC
	CMP	AL,'='		;or '='
	JZ	BADFC
	LOOP	ENVRS1
	POP	DI		;address of string
	PUSH	DX		;save length
	CALL	B$FIRST_ENV	;get first env parm
	MOV	AX,CX		;save length of env table entry
	POP	CX		;length back
ENVRS5:
	MOV	DX,SI		;start of next
	MOV	SI,BX		;start of this
	JNZ	ENVR5A		;not end of list (yet)
	XOR	CX,CX		;end of list returns null string
	JMP	SHORT GOGOTENV	;and jump to process it
ENVR5A:
	PUSH	DI		;save
	PUSH	CX
	REPZ	CMPSB		;compare parms
	JZ	ENVRS7		;matched
ENVRS6:
	MOV	SI,DX
	CALL	B$NEXT_ENV	;get next
	MOV	AX,CX		;save length of env table entry
	POP	CX
	POP	DI
	JMP	ENVRS5
ENVRS7:
	CMP	BYTE PTR [SI],'=' ;must have equals
	JNE	ENVRS6
	INC	SI		;SI points after '=' now
	POP	CX		;restore string length
	POP	DI
	XCHG	CX,AX		;CX now length of table entry...
				;AX now length of string parameter
	SUB	CX,AX		;CX now length of '=' and value
	DEC	CX		;CX now length of just value
GOGOTENV:			
	CALL	GOTENV		; do the common code (returns DX:AX = sd)
	PUSH	AX		; save psd returned by GOTENV
	MOV	BX,sdEnv	
	PUSH	ES		
	POP	DS		; [DS] = dgroup again
assumes	ES,NOTHING		
	cCall	B$STDALCTMP	; deallocate it if it was temp
	POP	AX		; ax = pointer to descriptor
cEnd

ERRCTL:
	CMP	AX,ERRIDT
	JNE	BADFC		
	JMP	B$ERR_IOE

BADIFN:				
	JMP	B$ERR_IFN	
BADFC:
	JMP	B$ERR_FC


;***
; B$FEVI - ENVIRON$ function with integer argument
; Purpose:
;	Returns the ordinal i environment table entry, where
;	i is the input integer argument.
;
; Inputs:
;	integer value in range 1 to 255.
; Outputs:
;	AX = ptr to string descriptor to a copy of the table entry.
; Modifies:
;	None.
; Exceptions:
;	B$ERR_FC if function error.
;******************************************************************************

cProc	B$FEVI,<PUBLIC,FAR>,<SI,DI,DS,ES> 
parmW	EnvInt
cBegin
	PUSH	DS		
	POP	ES		;set es=ds
	MOV	BX,EnvInt	;get integer in BX
	MOV	DX,BX
	OR	BX,BX		;test for zero argument
	JZ	BADFC		;and error if so...
	CMP	BX,255
	JA	BADFC
	CALL	B$FIRST_ENV	;get first parm in env
ENVNF1:
	JZ	ENVNF2		;end, return null
	DEC	DX
	JZ	ENVNF2		;return pointer in BX
	CALL	B$NEXT_ENV
	JMP	SHORT ENVNF1
ENVNF2:
	MOV	SI,BX		;GOTENV needs pointer in SI
	CALL	GOTENV		;call common code (returns DX:AX = sd)
cEnd				

GOTENV:
	PUSH	DS		;save ENV segment
	PUSH	ES		;put DGROUP seg on stack
	POP	DS		;restore DS to DGROUP
	PUSH	CX		;save length
	MOV	BX,CX
	CALL	B$STALCTMP	; allocate string temp
	POP	CX		;count
	POP	DS		;get ENV segment back in DS
	XCHG	AX,BX		; [AX] = psd
	MOV	DI,DX		;target
	REP	MOVSB		;move into target
	RET			; return with [DX:AX] = sd or [AX] = psd

;***
; B$FICT - IOCTL$ function
; Purpose:
;	Returns a status string from the specified file using
;	an IOCTL call.
;
; Inputs:
;	 file number to get status
; Outputs:
;	AX = pointer to string descriptor of status string
; Modifies:
;	None.
; Exceptions:
;	B$ERR_FC if function call error.
;	B$ERR_IOC if IOCTL error.
;******************************************************************************

cProc	B$FICT,<PUBLIC,FAR>,<SI,DI,ES> 
parmW	fileNum
cBegin
	MOV	BX,fileNum	;get file number in BX
	CALL	B$LHFDBLOC	
	JZ	BADIFN		
	FDB_PTR ES,SI,SI	;get FDB pointer
	MOV	BX,FileDB.FD_HANDLE 
	OR	BX,BX		;if zero, one of basic's devices
	JZ	ERRCTL
	MOV	DX,OFFSET DGROUP:b$PATHNAM ; DX = buffer address
	MOV	AL,2		;read IOCTL info
	CALLOS	IOCTL,ERRCTL,BX,255,DX
	MOV	CX,AX		;[CX] = number of bytes read
	XCHG	AX,BX
	MOV	SI,DX		;address of ioctl data
	CALL	B$STALCTMP	; allocate string temp
	MOV	DI,DX		;target work area
	PUSH	DS		
	POP	ES		
	REP	MOVSB
	XCHG	AX,BX		;return sd in AX
cEnd


;***
; B$ERDV - return device error word
; Purpose:
;	Return the value of the device error word set by the
;	last error.
;
; Inputs:
;	None.
; Outputs:
;	AX = device error word.
; Modifies:
;	None.
; Exceptions:
;	None.
;******************************************************************************

cProc	B$ERDV,<PUBLIC,FAR>
cBegin
	MOV	AX,b$ERDEV
cEnd

;***
; B$ERDS - get device error string
; Purpose:
;	Returns the descriptor of the device error string.
;
; Inputs:
;	None.
; Outputs:
;	AX = address of device error string if set, otherwise null string.
; Modifies:
;	None.
; Exceptions:
;	None.
;******************************************************************************

cProc	B$ERDS,<PUBLIC,FAR>
cBegin
	MOV	BX,OFFSET DGROUP:b$ERDEVP ;address of string
	CMP	WORD PTR [BX],0 ;set yet ?
	MOV	AX,BX		;put sd in AX
	JNE	DVRET
	MOV	AX,OFFSET DGROUP:b$nuldes ;no - use null
DVRET:
cEnd

sEnd	OS_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\paint.asm ===
PAGE	56,132
	TITLE	PAINT - iAPX 88/86 PAINT STATEMENT SUPPORT
;***
; PAINT - iAPX 88/86 PAINT STATEMENT SUPPORT
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - PAINT Statement - Calls B$PAIN or B$PNTC, depending on 'paint' attribute
;
;     PAINT (x,y) [[,paint [,boundary] ,background]]
;	|     |
;	|  Coord routines	    B$PAIN (if "paint" is numeric attribute)
;	|			       or
;	|			    B$PNTC (if "paint" is tile string)
;	|			       |
;	+------------------------------+
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	_DATA		
	USESEG	_BSS		
	USESEG	GR_TEXT 	

	INCLUDE seg.inc 	;define segments
	INCLUDE baslibma.inc
	INCLUDE idmac.inc	
	INCLUDE string.inc	

sBegin	_DATA			

	externW B$AC


sEnd	_DATA			

sBegin	_BSS			
;
;****************************************************************************
; External low-level function vectors
;****************************************************************************
;
externW b$LeftC		
externW b$ChkDownC		
externW b$ChkUpC		
externW b$ScanL		
externW b$ScanR		
externW b$MapXYC		
externW b$SetTile		
externW b$PaintBound		

	externW B$C1SAVE 	;defined in GWDATA.ASM
	externW B$C2SAVE 	;defined in GWDATA.ASM
	externW B$C3SAVE 	;defined in GWDATA.ASM
	externW B$MOVCNT 	;defined in GWDATA.ASM
	externW B$SKPCNT 	;defined in GWDATA.ASM
	externB B$LFPROG 	;defined in GWDATA.ASM
	externB B$RTPROG 	;defined in GWDATA.ASM
	externB B$PDIREC 	;defined in GWDATA.ASM
	externW B$GXPOS		;defined in GWDATA.ASM
	externW B$GYPOS		;defined in GWDATA.ASM
	externW B$GX_OLD 	;defined in GWDATA.ASM
	externW B$GY_OLD 	;defined in GWDATA.ASM

	externW B$BGTLOC 	;defined in GWDATA.ASM
	externB	b$Buf3		; > 16-byte buffer, defined in GWINI.ASM
	$BGTNUL EQU b$Buf3	
	externB B$TILFLG 	;defined in GWDATA.ASM
	externB B$TIPROG 	;defined in GWDATA.ASM
	externB B$TILLEN 	;GWDATA - length of fground tile string (0-rel)
	externB B$TILNDX 	;GWDATA - index to pixel of fground tile string
	externB B$TILPTR 	;GWDATA - byte ptr to fground tile string
	externW B$TILLOC 	;GWDATA - pointer to start of fground tile str
	externB B$TILHGT 	;GWDATA - height of foreground tile
	externB B$GRPLAN 	;GWDATA - number of graphics planes
	externW B$PQLEN		;defined in GWDATA.ASM
	externW B$PQNUM		;defined in GWDATA.ASM
	externW B$PQGET		;defined in GWDATA.ASM
	externW B$PQPUT		;defined in GWDATA.ASM

	externB b$Buf1		; foreground tile string buffer
	externB b$VTYP 	;defined in GLOBAL.INC



sEnd	_BSS			

	.RADIX	10

assumes CS,GR_TEXT		
sBegin	GR_TEXT 		


	PUBLIC	B$PAINTBEG
	externNP B$STALCTMP	
	externNP B$STALCMAXTMPNC ; Allocate max string w/o compaction

	externNP B$INVIEW
	externNP B$COORD1	
	externNP B$CLRATR

;low-level routines:
	externNP B$StoreC	
	externNP B$FetchC	
	externNP B$PaintInit	

	externNP B$GETFBC
	externNP B$TileMod	
	externNP B$STALCMAXTMP
	externNP B$STDALCTMP

	externNP B$SCINIT	; Performs screen initialization

	externNP B$ERR_FC
	externNP B$ERR_OM



	PAGE
	SUBTTL	PAINT ALGORITHM


B$PAINTBEG:			;Begin painting


	CALL	[b$PaintBound] ;Set Left and Right "C" for this line
	MOV	SI,1		;ENTRY COUNT IS ONE (SKIP NO BORDER)
	CALL	SCANR1		;SCAN RIGHT FROM INITIAL POSITION
	JZ	PNTEXT		;STARTED ON BORDER - GET TXTPTR & QUIT
	PUSH	BX		;SAVE NO. OF POINTS PAINTED TO RIGHT
	CALL	SCANL1		;NOW SCAN LEFT FROM INITIAL POS.
	POP	SI		;GET RIGHT SCAN COUNT.
	ADD	SI,BX		;ADD TO LEFT SCAN COUNT
	MOV	DL,64		;MAKE ENTRY FOR GOING DOWN
	CALL	ENTST1
	MOV	DL,0C0H 	;CAUSE PAINTING UP
	OR	DL,B$TILNDX	;Add Tile index
	JMP	SHORT STPAIN	;START PAINTING.
PNTEXT: 			;Exit PAINT statement


	MOV	B$TILFLG,0	;Turn Tiling off
	RET

;Register usage: (approximately)
;	In main paint loop: SI=B$SKPCNT, BX=B$MOVCNT, DL=Direction/Tile Index
;	In SCANR1,SCANL1:   AX=Word 1 of graphics cursor,BX=Word 2,CX=Word 3

;	MAIN PAINT LOOP

PNTLOP:
PNTLP1:
	CALL	GETQ		;Get one entry from queue
	CALL	B$StoreC	
STPAIN:
	MOV	AL,DL		;GET DIRECTION

	AND	AL,63		;Isolate Tile index
	MOV	B$TILNDX,AL	;and store it
	MOV	AH,B$GRPLAN	;get number of graphics planes
	MUL	AH		;product is in AX
	MOV	B$TILPTR,AL	;get real offset to fground tile string
	MOV	AL,DL		;reget direction byte
	AND	AL,0C0H 	;Isolate direction bits
	MOV	B$PDIREC,AL
	ADD	AL,AL		;SEE WHETHER TO GO UP, DOWN, OR QUIT
	JZ	PNTEXT		;IF ZERO, ALL DONE.
	JNB	PDOWN		;IF POSITIVE, GO DOWN FIRST
	CALL	[b$ChkUpC]	;MOVE UP BEFORE SCANNING
	JB	PNTLP1		;Off viewport - get next entry
	CALL	TILNDD		;Decrement tile index
	JMP	SHORT PNTLP2
PDOWN:
	CALL	[b$ChkDownC]	;SEE IF AT BOTTOM & MOVE DOWN IF NOT
	JB	PNTLP1		;Off viewport - get next entry
	CALL	TILNDI		;Increment tile index
PNTLP2:
	CALL	[b$PaintBound] ;Set Left and Right "C" for this line
	CALL	SCANR1		;SCAN RIGHT & SKIP UP TO B$SKPCNT BORDER
	JZ	PNTLP1		;IF NO POINTS PAINTED, GET NEXT ENTRY
	CALL	SCANL1		;NOW SCAN LEFT FROM START POINT
	MOV	SI,BX		;[SI] = LEFT B$MOVCNT
	TEST	B$TIPROG,255	;Is this a background tile?
	JNZ	TPROG1		;Yes: skip already painted check
	OR	CL,CL		;SEE IF LINE WAS ALREADY PAINTED
	JZ	PNTLP3		;IT WAS - DON'T MAKE OVERHANG ENTRY
TPROG1:
	CMP	BX,1		;SEE IF LEFT B$MOVCNT WAS .GT. 1
	JLE	PNTLP3		;No: go make entry for left+right move count
				;Yes: make entry in opposite direction for
				;overhang
	MOV	AL,B$PDIREC
	XOR	AL,128
	AND	AL,0C0H 	;Isolate new direction
	OR	AL,B$TILNDX	;Reverse direction and/or tile index
;++added 1 line (faster than doing it all in DL!)
	MOV	DL,AL
	CALL	B$FetchC	;Get current point address
	CALL	PUTQ
PNTLP3:
	ADD	SI,WORD PTR B$MOVCNT ;ADD COUNT PAINTED DURING RIGHT SCAN TO LEFT B$MOVCNT
	CALL	ENTSLR		;GO MAKE ENTRY.
;added 1 line
	MOV	CX,WORD PTR B$C3SAVE
	MOV	BX,WORD PTR B$C2SAVE ;SET CURRENT LOCATION BACK TO END
	MOV	AX,WORD PTR B$C1SAVE ;OF RIGHT SCAN.
	CALL	B$StoreC	
PNTLP4:
	MOV	SI,WORD PTR B$SKPCNT ;CALC B$SKPCNT - B$MOVCNT TO SEE IF
	SUB	SI,WORD PTR B$MOVCNT ;ANY MORE BORDER TO SKIP
	JZ	GOPLOP		;NO MORE - END OF THIS SCAN
	JB	PNTLP6		;RIGHT OVERHANG - SEE IF ENTRY NEEDED
	CALL	SCANR1		;HERE IF NEED TO CONTINUE RIGHT SCAN
	JZ	GOPLOP		;NO MORE POINTS.
	TEST	B$TIPROG,255	;Is this a background tile?
	JNZ	TPROG0		;Yes: enter regardless if already painted or not
	OR	CL,CL		;SEE IF LINE ALREADY PAINTED
	JZ	PNTLP4		;YES, DON'T ENTER ANYTHING
TPROG0:
	MOV	SI,BX		;ENTRY COUNT TO [SI]
;added 1 line
	MOV	CX,WORD PTR B$C3SAVE
	MOV	BX,WORD PTR B$C2SAVE ;MAKE ENTRY AT LOCATION SAVED BY ScanR
	MOV	AX,WORD PTR B$C1SAVE ;SO WE CAN ENTER A POSITIVE B$SKPCNT
	MOV	DL,B$PDIREC
	CALL	ENTSTK		;MAKE ENTRY
	JMP	SHORT PNTLP4	;CONTINUE UNTIL B$SKPCNT .LE. 0
PNTLP6:
	CMP	SI,WORD PTR -1	;If B$SKPCNT-B$MOVCNT .LT. -1
	JGE	GOPLOP		;No: overhang too small for entry
	NEG	SI		;Yes: Make right overhang entry
	DEC	SI		;     of at least one point wide overhang
	MOV	CX,SI		; LeftC protects CX
RTOVH1:
	CALL	[b$LeftC]	;START IS -(B$SKPCNT-B$MOVCNT)-1 TO LEFT
	LOOP	RTOVH1		
	MOV	AL,B$PDIREC	;MAKE ENTRY IN OPPOSITE DIRECTION
	XOR	AL,128
;++added 1 line (faster than doing it all in DL!)
	MOV	DL,AL
	CALL	ENTST1		;MAKE ENTRY
GOPLOP:
	JMP	PNTLOP		;GO PROCESS NEXT ENTRY
ENTSLR:
	MOV	AL,B$LFPROG	;DON'T STACK IF LINE ALREADY PAINTED
	OR	AL,B$RTPROG
	OR	AL,B$TIPROG
	JNZ	ENTST0
	RET			;Z IF SCAN LINE ALREADY PAINTED

ENTST0:
	MOV	DL,B$PDIREC
ENTST1:
	CALL	B$FetchC	;LOAD REGS WITH CURRENT "C"
ENTSTK:
	OR	DL,B$TILNDX	;Add tile index to direction
ENTST9:
	JMP	PUTQ
SCANR1:
;added 1 line
	MOV	DX,SI		;Can't change entry conditions for ScanR now...
	CALL	[b$ScanR]	;PERFORM LOW LEVEL RIGHT SCAN
	MOV	WORD PTR B$SKPCNT,DX ;SAVE UPDATED B$SKPCNT
	MOV	WORD PTR B$MOVCNT,BX ;SAVE B$MOVCNT
;added 3 lines
	MOV	WORD PTR B$C1SAVE,AX ;Save the "first non-BRDATR pixel
	MOV	WORD PTR B$C2SAVE,SI ; found during scan" in temp
	MOV	WORD PTR B$C3SAVE,DI
	OR	BX,BX		;SET CC'S ON B$MOVCNT
	MOV	AL,CL		;GET ALREADY-PAINTED FLAG FROM [C]
	MOV	B$RTPROG,AL
	RET
SCANL1:
	CALL	B$FetchC	;GET CURRENT LOCATION
;added 1 line
	PUSH	CX
	PUSH	BX		;AND SWAP WITH CSV
	PUSH	AX
;added 1 line
	MOV	CX,WORD PTR B$C3SAVE
	MOV	BX,WORD PTR B$C2SAVE
	MOV	AX,WORD PTR B$C1SAVE
	CALL	B$StoreC	;REPOS AT BEGINNING OF SCAN
	POP	AX		;REGET PLACE WHERE RT SCN STOPPED
	POP	BX
;added 2 lines
	POP	CX
	MOV	WORD PTR B$C3SAVE,CX
	MOV	WORD PTR B$C2SAVE,BX ;AND SAVE IT IN TEMP LOCATION
	MOV	WORD PTR B$C1SAVE,AX
	CALL	[b$ScanL]	;NOW DO LOW LEVEL LEFT SCAN
	MOV	AL,CL		;GET ALREADY-PAINTED FLAG FROM [C]
	MOV	B$LFPROG,AL	;WHETHER IT WAS ALREADY PAINTED (faster than
				;  doing MOV B$LFPROG,CL!)
	RET

	PAGE
	SUBTTL	PAINT AND TILE SUPPORT ROUTINES
; Little helpers for PAINT and TILE

;
;FGSTRINI		initialize foreground string
;
;Purpose:
;	  Check string for validity:  its length must be less than 256 and
;	  greater than 0.  Fill string buffer b$Buf1 with paint tile padded on the
;	  right with zeros.  Initialize B$TILLOC to point at b$Buf1.  Initialize
;	  B$GRPLAN to the number of graphics planes.  Stores rounded up tile
;	  length in B$TILLEN and pixel height of tile in B$TILHGT (must be less
;	  than or equal to 64).
;
;Entry:
;		BX = ptr to string descriptor
;
;Exit:
;	variables updated as noted
;
;Modifies:
;		CX,SI,DI
;

FGSTRINI:			;initialize paint string
	MOV	CX,WORD PTR 0[BX] ;[CX]= len
	MOV	SI,WORD PTR 2[BX] ;[SI]= addr
	OR	CH,CH		;Is CH=0?
	JNE	MATERR		;Length must be .LE. 255
	MOV	DI,OFFSET DGROUP:b$Buf1 ;DI points to b$Buf1
	MOV	WORD PTR B$TILLOC,DI ;Store adr
	PUSH	CX		;Save string length
	CLD			;Clear direction flag
				;Repeat until CX=0:
	REP	MOVSB		;Put Fill String in b$Buf1
	POP	CX		;Restore  string length
	PUSH	CX		;Resave string length
	SUB	CX,256d 	;CX:=CX-256
	NEG	CX		;CX:=-CX=remainder of BUF
	XOR	AL,AL		;Clear AL
				;Repeat until CL=0:
	REP	STOSB		;Fill the rest of BUF with zeros
;tile string is now saved in the temp buffer so temp string can be deallocated
	CALL	B$STDALCTMP	; deallocate temp string pointed to by BX
;Check tile height
	CALL	B$TileMod	;Get number of graphics planes
	POP	CX		;Restore CL
	MOV	B$GRPLAN,AL	;in this screen mode
	JCXZ	MATERR		;See if at least one byte in tile string
	XCHG	AX,CX		
	DEC	AX
	DIV	CL		;AX=(B$TILLEN-1)/B$GRPLAN
	XOR	AH,AH
	INC	AX		;AX=INT((B$TILLEN-1)/B$GRPLAN)+1=height in pixels rounded up
	CMP	AL,65
	JNB	MATERR		;Tile can only be 64 pixels long (IBM compatibility)
	MOV	B$TILHGT,AL	;Save pixel height of tile (always.LE.64)
	MUL	CL		;AX=INT(((B$TILLEN-1)/B$GRPLAN)+1)*B$GRPLAN
	DEC	AX		;make 0 based, guaranteed 1 or more
	OR	AH,AH		;Rounded up length must be .le. 255
	JNZ	materr		;Yes: this must be a multiplane with four or more planes
	MOV	B$TILLEN,AL	;Store rounded up length
	RET			;return to caller

MATERR:
	MOV	B$TILFLG,0	;Turn Tiling off
	JMP	B$ERR_FC

;***
; BGSTRINI - initialize background tile string
; Purpose:
;	Insures that string length is between 1 and 255 inclusive.
;	Initializes background string to specified background string.
;
; Entry:
;	BX = ptr to string descriptor
;	$BGTNUL = ptr to background tile string area
; Exit:
;	None.
; Modifies:
;	SI,DI,CX
;****

BGSTRINI:
	MOV	CX,[BX] 	;[CX]= len
	OR	CH,CH
	JNE	materr		;Max len is 255
	JCXZ	materr		;See if at least one byte in background string
	CMP	CL,B$GRPLAN	;Ignore any extra bytes
	JBE	FILL_BGSTR
	MOV	CL,B$GRPLAN
FILL_BGSTR:			;Fill background string
	MOV	SI,WORD PTR 2[BX] ;[SI]= addr
	MOV	DI,OFFSET DGROUP:$BGTNUL ;Point DI at backgrd tile area
	CLD			;Clear direction flag
	REP	MOVSB		;Fill with as much as user gave,
				;rest are chr$(0)
	JMP	B$STDALCTMP	; deallocate temp string pointed to by BX

;***
; B$ClrBgStr - clear background string area
; Purpose:
;	Initialize background string area by filling with zeros.
;	Make sure there are no more than 16 graphics planes.
;
; Entry:
;	$BGTNUL points to background string area
; Exit:
;	None.
; Modifies:
;	CX,DI,AX.
;****

cProc	B$ClrBgStr,<NEAR>	;Clear background string
cBegin				
	MOV	CX,16
	CMP	CL,B$GRPLAN	;Only allocated space for at most 16 planes
	JB	MATERR		;function call error
	MOV	DI,OFFSET DGROUP:$BGTNUL
	XOR	AL,AL
	CLD
	REP	STOSB		;Fill 16 bytes with CHR$(0)
	MOV	B$BGTLOC,OFFSET DGROUP:$BGTNUL ;No BG tile, use null (00)
cEnd				

;	Set starting tile index to Starting Y axis and
;	store in B$TILNDX.
;	Set B$TILNDX to (Y MOD pixel height)*B$GRPLAN
;
;Entry - [DX] = Starting Y line
;
;	Uses:	[BX]

cProc	B$SetTileIndex,<NEAR>	
cBegin				
	CMP	B$TILFLG,0
	JZ	STIND2		;nothing if not tile
	PUSH	AX
	PUSH	DX		;Protect DX
	MOV	BX,DX		;[BX]=Y coord
	MOV	DL,B$TILHGT	;[DX]= height of tile
	XOR	DH,DH
STIND1:
	SUB	BX,DX
	JNB	STIND1		;Find Y MOD pixel height
	ADD	BX,DX		;+len since overflowed
	MOV	B$TILNDX,BL	;get index of tile pixel
	MOV	AL,B$GRPLAN
	XOR	AH,AH
	MUL	BL		;AX=(Y MOD pixel height)*B$GRPLAN
	MOV	B$TILPTR,AL	;store fground tile string offset
	POP	DX		;get  Y coord
	POP	AX
STIND2:
cEnd				

;	Scan Fill argument,  set Fill color attr if numeric
;	or set up tile attr if string.
;	If string, check that its length .LE. 64*number of graphics planes
;	and round up length to even multiple of number of graphics planes.

; MATCH3	Checks 3 consecutive lines in TILE$ for match
;		with the background color or tile.  If 3 lines
;		are there, then give Illegal Function Call error.
;		If this was not done, PAINT might infinite loop.

; Uses	AX,BX,CX,DX,SI,DI

MATCH3:
	CMP	B$TILFLG,0
	JZ	MATC3X		;Do nothing if Tile wasn't given
	XOR	DH,DH
	MOV	DL,B$GRPLAN	;DX=tile "width"
	MOV	SI,WORD PTR B$TILLOC ;SI=pointer to tile string
	XOR	AH,AH
	MOV	AL,B$TILLEN
	ADD	AX,SI		;AX=end of tile string
	CLD
MAT3LP:
	CMP	SI,AX		;Done entire tile string yet?
	JA	MATC3X		;Yes:
	MOV	DI,WORD PTR B$BGTLOC
	CALL	CMPST		;Matched 3 tiles in a row?
	JE	PNTERR		;Yes: barf
	ADD	SI,DX		;No: look at next set in tile string
	JMP	SHORT MAT3LP	;Loop
MATC3X:
	RET

CMPST:
	PUSH	SI		;Save tile string pointer
	MOV	BX,3
	PUSH	ES		
	PUSH	DS		
	POP	ES		
CMPST2:
	MOV	CL,DL		;Look for 3 in a row matches of B$GRPLAN bytes
	XOR	CH,CH
CMPST0: CMPSB			;Compare [SI],[DI]
	JNE	CMPST1		;Different already, exit with Z clear
	CALL	WRAPSI
	LOOP	CMPST0		;Matched B$GRPLAN in a row yet?
	MOV	DI,WORD PTR B$BGTLOC ;Yes: reset background pointer
	DEC	BX		;Matched 3 sets of B$GRPLAN in a row?
	JNZ	CMPST2		;No:
				;Yes: exit with Z set
CMPST1:
	POP	ES		
	POP	SI
	RET

WRAPSI:
	CMP	SI,AX		;Wrap around to beginning of tile string yet?
	JBE	NoWrap		;No:
	MOV	SI,WORD PTR B$TILLOC ;Yes: back to go
NoWrap: RET

;***
; TILATR
;	Set ATRBYT from tile and set B$TIPROG if current tile
;	attribute equals BG tile attribute.
; USES BX,DI
;****

TILATR:
	CMP	B$TILFLG,0
	MOV	BL,B$TILPTR
	JNZ	B$TILAT1	;Update ATRBYT
	RET			;do nothing if not tile

;***
; TILNDD
;	Decrement Tile index
;	and store tile in ATRBYT if B$TILFLG True...
; USES AX,BX
;****

TILNDD:
	CMP	B$TILFLG,0
	JNZ	TILNDD1 	;do nothing if not tile
	RET
TILNDD1:
	DEC	B$TILNDX 	;index is one less
	MOV	BL,B$TILPTR	;get offset to fground tile string
	OR	BL,BL		;At beginning of tile string?
	JNZ	TILDN1		;Brif not underflowing
	MOV	BL,B$TILHGT	;get tile height
	DEC	BL		;make 0-relative
	MOV	B$TILNDX,BL	;put into index
	MOV	BL,B$TILLEN	;else wrap to top end
	INC	BL		;make 1 based
TILDN1:
	SUB	BL,B$GRPLAN	;Decrement index to beginning of prev tile
	JMP	SHORT TILND2	;Update index, ATRBYT


PNTERR:
	MOV	B$TILFLG,0	;Turn Tiling off
	JMP	B$ERR_FC


;***
; TILNDI
;	Increment Tile index (called after DOWNC)
;	and store tile in ATRBYT if B$TILFLG True...
; USES AX,BX
;****
TILNDI:
	CMP	B$TILFLG,0
	JNZ	TILNDI1 	;do nothing if not tile
	RET
TILNDI1:
	INC	B$TILNDX 	;increment tile pixel index
	MOV	BL,B$TILPTR	;get fground tile byte offset
	ADD	BL,B$GRPLAN	;Increment index to beginning of next tile
	CMP	BL,B$TILLEN
	JBE	TILND2		;Brif not overflowing
	XOR	BL,BL		;else wrap to bottom end
	MOV	B$TILNDX,BL	;also clear tile pixel index
TILND2:
	MOV	B$TILPTR,BL	;update tile byte offset pointer

;***
; B$TILAT1
;
;****

cProc	B$TILAT1,<NEAR>,<SI>	
cBegin				
	MOV	BH,0		;[BL]=[BL]*GRPLAN, [BH]=0
	ADD	BX,WORD PTR B$TILLOC
	MOV	SI,BX		;SI points into tile string
	MOV	DI,WORD PTR B$BGTLOC ;DI points into background string
	MOV	B$TIPROG,0	;Clear progress flag
	XOR	BH,BH
TILAT2: INC	BH
	CMP	BH,B$GRPLAN
	JA	TILAT4		;For BH = 1 to gplanes
	MOV	BL,[SI] 	;Get curr tile attr
	PUSH	BX
	CALL	[b$SetTile]	;Set OEM's 'ATRBYT' to tile attr
	POP	BX
	CMP	BL,[DI] 	;Compare FG attr to BG attr
	JNZ	TILAT3		;Brif not equal
	INC	B$TIPROG 	;Count matches
TILAT3:
	INC	SI		;Check next planes bytes
	INC	DI
	JMP	SHORT TILAT2	;next BH
TILAT4:
	MOV	BL,B$TIPROG
	MOV	B$TIPROG,0
	CMP	BL,B$GRPLAN	;Did all FG match BG?
	JNE	TILAT6		;No:  not all matched so say none did.
	MOV	B$TIPROG,1	;Yes: flag all matched
TILAT6:
cEnd				


	PAGE
	SUBTTL	PAINT QUEUE ROUTINES

cProc	B$INTQNOCPCT,<PUBLIC,NEAR>,<BX,DX>	
cBegin						

;	PUSH	BX		;save registers...
;	PUSH	DX		
;	cCALL	B$STGETFRESIZ	;get size of free string
;	OR	BX,BX		;test if no free string
;	JZ	PQOMER		;if not, give out of memory error
;	cCALL	B$STALCTMP	; Allocate all string space as temporary

	cCALL	B$STALCMAXTMPNC	; Allocate max-string w/o compaction
	JMP	SHORT INTQUE_COMMON ;jump to common code point

cEnd	<nogen>			; End of B$INTQNOCPCT

	PUBLIC	B$INTQUE

B$INTQUE:
	PUSH	BX		;Save x coord
	PUSH	DX		;SAVE Y COORD
	CALL	B$STALCMAXTMP	;allocate maximum temporary string
INTQUE_COMMON:			
	MOV	AX,0[BX]	;AX:=size of free string space
	MOV	CX,2[BX]	;CX:=location of free string space
	CMP	AX,9		;is temp string too small?
	JB	TEMP_TOO_SMALL	;if so, do not subtract
	SUB	AX,9		;give string room for test
TEMP_TOO_SMALL:

;Note: B$GY_OLD is the previous x coord accumulator.  Since this variable is
;never used in the PAINT statement, it is used here to save the location
;of the temporary string being used for the paint queue.
	MOV	B$GY_OLD,CX	;save string location in B$GY_OLD
	ADD	CX,AX		;CX points just past end of free string
	DEC	CX		;CX=highest byte of in-use string space
				;omit check for overflow
;Note: B$GX_OLD is the previous y coord accumulator.  Since this variable is
;never used in the PAINT statement, it is used here to save the pointer to
;the end of the temporary string being used for the paint queue.
	MOV	B$GX_OLD,CX	;Save this value in B$GX_OLD
	CALL	B$STDALCTMP	;mark temp string as deallocated
	CMP	AX,18d
	JNB	INTQU3		;Ok if at least 18 bytes (2 entries)
PQOMER:
	JMP	B$ERR_OM	  ; else Out of Memory
INTQU3:
	MOV	WORD PTR B$PQLEN,AX ;len is free size
	MOV	WORD PTR B$PQNUM,0 ;present number is 0
	XCHG	AX,DX		;AX:=beginning of usable free space
	MOV	WORD PTR B$PQGET,AX ;Init head
	MOV	WORD PTR B$PQPUT,AX ; and tail
	POP	DX		;Restore y coord
	POP	BX		;Restore X coord
	RET

; PUTQ - Enqueue entry in paint queue
; Entry - AX,BX,CX = OEM's graphics cursor
;	  SI = B$SKPCNT
;	  DL = Direction (and tiling) flag
; Exit	- B$PQNUM,B$PQPUT updated
; AX,DI Used
DbPub	PUTQ			
PUTQ:
	PUSH	ES		
	PUSH	DS		
	POP	ES		
	PUSH	DX
;added 1 line
	PUSH	SI
	PUSH	CX
	PUSH	BX
;added 1 line
	PUSH	AX
	ADD	WORD PTR B$PQNUM,9d ;len= len+9
	MOV	AX,WORD PTR B$PQLEN
	CMP	WORD PTR B$PQNUM,AX
	JNB	PQOMER		;Out of Memory if at end or higher
	MOV	AX,WORD PTR B$PQPUT ;[AX]= queue ptr
	CALL	WRAP		;check wrap
	MOV	DI,AX		;[DI]= queue ptr
	POP	AX
	CLD
	STOS	WORD PTR [SI]	;Graphics cursor
	POP	AX
	STOS	WORD PTR [SI]	;Graphics cursor
	POP	AX
	STOS	WORD PTR [SI]	;Graphics cursor
	POP	AX
	STOS	WORD PTR [SI]	;B$SKPCNT
;added 2 lines
	POP	AX
	STOSB			;Direction flag
	MOV	WORD PTR B$PQPUT,DI
	POP	ES		
	RET

WRAP:
	PUSH	AX


	ADD	AX,9
;Note: B$GX_OLD is the previous x coord accumulator.  Since this variable is
;never used in the PAINT statement, it is used here to save the location
;of the temporary string being used for the paint queue.
	CMP	AX,WORD PTR B$GX_OLD ;Are we at end of free space?

	POP	AX		;Restore AX
	JB	WRAPX		;Brif not off end of queue


;Note: B$GY_OLD is the previous y coord accumulator.  Since this variable is
;never used in the PAINT statement, it is used here to save the pointer to
;the end of the temporary string being used for the paint queue.  This
;value is set at the beginning of B$INTQUE.
	MOV	AX,B$GY_OLD	;else set to beginning of queue

WRAPX:
	RET

; GETQ - Dequeue entry from paint queue
; Entry - none
; Exit	- AX,BX,CX = OEM's graphics cursor
;	  SI = B$SKPCNT
;	  DL = Direction (and tiling) flag
;	  B$PQNUM,B$PQGET updated
; No other registers used.
DbPub	GETQ			
GETQ:
	MOV	DL,0		;preset "Direction=0" in case no entries
	CMP	WORD PTR B$PQNUM,0
	JZ	GETQX		;Brif empty
	SUB	WORD PTR B$PQNUM,9d ;len = len-9
	MOV	AX,WORD PTR B$PQGET ;[AX]= dequeue ptr
	CALL	WRAP		;check wrap
	MOV	SI,AX		;[SI]= dequeue ptr
;added 3 lines
	CLD
	LODS	WORD PTR [SI]	;Graphics cursor
	PUSH	AX
	LODS	WORD PTR [SI]	;Graphics cursor
	MOV	BX,AX
	LODS	WORD PTR [SI]	;Graphics cursor
	MOV	CX,AX
	LODS	WORD PTR [SI]	;B$SKPCNT
	PUSH	AX
;added 2 lines
	LODSB			;Direction flag
	MOV	DL,AL
	MOV	WORD PTR B$PQGET,SI
;added 2 lines
	POP	SI		;SI = B$SKPCNT
	POP	AX
GETQX:
	RET

	PAGE
	SUBTTL	COMPILER ENTRY POINTS FOR PAINT

; PAINT - FILL AN AREA WITH COLOR
;
; SYNTAX: PAINT [STEP](X,Y)[,<iexp>[,iexp]]|[,<sexp>[,<iexp>[,<sexp>]]]
;	where <iexp>=integer expression, <sexp>=string expression
;

;***
;B$PAIN - Process PAINT statement without tiling
;
;Purpose:
;	This routine will be called by the parsing routine PAINT in PRSG86
;	in the interpreter version or by the compiler in the compiler version
;	if the PAINT statement scanned does not contain a paint tile
;	attribute but uses a integer paint color instead.  The call to
;	BNDS_CHK tests the start coordinates of the PAINT against the current
;	viewport boundaries.  The paint and border colors are checked for
;	validity before the jump to B$PAINTBEG begins the actual painting.
;
;Entry:
;	Color	= paint color spec or -1 if default
;	Border	= border color spec or -1 if default
;Exit:
;	None.
;Uses:
;	Per convention
;Exceptions:
;	Control may be transfered to B$ERR_FC
;****
cProc	B$PAIN,<PUBLIC,FAR>,<SI,DI> 
parmW	Color			
parmW	Border			
cBegin				

	CALL	B$SCINIT	; init screen if not already done
	cCall	B$COORD1	;do any necessary translations
	MOV	BX,Color	;[BX] = paint color
	MOV	DX,Border	;[DX] = border color
	CALL	OLD_PA1 	; Perform
cEnd				


OLD_PA1:			; Entry point for PAINT with no tiling
	MOV	B$TILFLG,0	;tiling is not active
	MOV	B$TIPROG,0	
	CALL	B$INTQUE 	;Init the Queue
	PUSH	DX		;Save border color
	CALL	BNDS_CHK	;Check if coordinates are inside
				;screen or viewport
	JC	MAPIT		
	JMP	DONT_PAINT	;Don't PAINT if coordinates out of bounds
MAPIT:				
	push	bx		;preserve bx across call to MapXYC
	CALL	[b$MapXYC]	;Graphics Cursor:=(CX,DX)
	pop	ax		;restore paint color
	POP	DX		;Restore border color
	CALL	B$CLRATR 	;Returns paint color attribute in AL
	CMP	DX,-1		;Is border color defaulted?
	JZ	BRDCHK		;Yes: AL contains valid paint color which is
				;border color default when no tiling
	MOV	AX,DX		;AX:=border color
BRDCHK: 			;check for valid border color
	CALL	B$PaintInit	;OEM check for legal border color
	JC	ERR_PAINT	;carry set if invalid border color
	JMP	B$PAINTBEG	;Go begin painting

;***
;B$PNTC - Process PAINT statement with tiling option
;
;Purpose:
;	This routine will be called if the PAINT statement scanned contains
;	a paint tile attribute instead of an integer paint color.  The
;	call to BNDS_CHK checks to see if the PAINT coordinates are within
;	bounds of the current viewport (the screen if there is no viewport).
;	The call to FGSTRINI initializes a buffer area (b$Buf1) to the tile
;	specified in the PAINT statement or to the default value.  B$ClrBgStr
;	initializes the default background string.  TILEINIT checks for a
;	valid border color, initializes B$TILNDX to index the appropriate byte
;	of the tile string, initializes ATRBYT (variable containing tile
;	mask) and checks for three consecutive matches between the foreground
;	and background tiles.  If everything is ok the jump to B$PAINTBEG is
;	taken to begin the actual painting procedure.
;Entry:
;	sdTile = sd for tiling string
;	Border = border spec or -1 if default
;	sdBkgd = sd for background string or -1 if none
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	B$ERR_FC
;****
cProc	B$PNTC,<PUBLIC,FAR>,<ES,SI,DI>	
parmSD	sdTile			
parmW	Border			
parmSD	sdBkgd			
cBegin				

	CALL	B$SCINIT	; init screen if not already done

	cCall	B$COORD1	;do any necessary translations
	GetpSD	BX,sdTile	;[BX] = psdTile
	GetpSD	CX,sdBkgd	;[CX] = psdBkgd
	MOV	DX,Border	;[DX] = border color
	PUSH	DS		; set es=ds
	POP	ES		
	CALL	OLD_PA2 	; Perform

cEnd				

ERR_PAINT:
	MOV	B$TILFLG,0	;Turn Tiling off
	JMP	B$ERR_FC


OLD_PA2:			; Entry point for PAINT with tiling
	MOV	B$TILFLG,-1	;Tile is active
	PUSH	DX		;Save border color
	PUSH	CX		;Save ptr to backgrd string descriptor
	CALL	B$INTQUE 	;Init the Queue
	CALL	BNDS_CHK	;Check if coordinates are inside screen or viewport
	JNC	POPNRET 	;coords out of bounds: don't do PAINT
	push	bx		;preserve bx across mapxyc call
	CALL	[b$MapXYC]	;Graphics Cursor:=(CX,DX)
	pop	bx		;restore ptr to fg string desc
	CALL	FGSTRINI	;Initialize foreground paint string
	POP	BX		;Restore ptr to background string descriptor
	CALL	B$ClrBgStr	;initialize null string for background
	CMP	BX,-1		;is background string defaulted?
	JZ	TILEINIT	;yes: branch to tile ATRBYT initialization
	CALL	BGSTRINI	;initialize background string
	CALL	MATCH3		;check for three consecutive matching
				;bytes in paint tile and background
				;tile and abort if found
	JC	ERR_PAINT	;Three matches found: issue error
TILEINIT:			;Tile initialization
	POP	AX		;Restore border color attribute
	CMP	AX,-1		;Is border color defaulted?
	JNZ	BORDER_CHK	;NO: Go check for valid border color
	STC			;Set carry
	CALL	B$GETFBC 	;Get foreground color in AL
BORDER_CHK:
	CALL	B$PaintInit	;OEM routine to check for valid border color
	MOV	DX,WORD PTR B$GYPOS ;DX:=current y coord
	CALL	B$SetTileIndex ;set B$TILNDX to proper byte of tile string
	CALL	TILATR		;set up tiling mask in ATRBYT
	JMP	B$PAINTBEG	;Valid border: go begin painting
POPNRET:			;Pop stack and abort PAINT statement
	POP	CX		;pop backgrd string ptr
DONT_PAINT:
	POP	DX		;pop border color
	MOV	B$TILFLG,0	;clear tiling flag
	RET			;Return

;***
; BNDS_CHK - routine checks for valid PAINT coordinates,
; Purpose:
;	To see if the coordinates specified in the PAINT statement
;	are within the current viewport.  May be called from B$PAIN
;	or B$PNTC.
;
;	If clipping is supported:
;		If the coordinates are inside the viewport, then continue
;		to process the PAINT statement, otherwise, return with
;		carry clear to indicate that PAINT statement should be
;		aborted without issuing an error message.
;	If clipping is not supported:
;		If the coordinates are inside the viewport, then continue
;		to process the PAINT statement, otherwise, issue a
;		function call error.
;
; Entry:
;	None.
; Exit:
;	Graphics cursor updated if coordinates inside current viewport.
; Modifies:
;	AX,CX,DX.
;****

BNDS_CHK:
	MOV	CX,WORD PTR B$GXPOS ;CX:=Graphics accumulator x position
	MOV	DX,WORD PTR B$GYPOS ;DX:=Graphics accumulator y position
	PUSH	BX		;Save paint parameter
	CALL	B$INVIEW 	;Returns carry set if coords within
				;current viewport
	POP	BX		;Restore paint parameter
	RET			;return with carry flag


sEnd	GR_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\ostimer.asm ===
TITLE	OSTIMER - MS-DOS TIMER support
;***
; OSTIMER - MS-DOS TIMER Support
;
;	Copyright <C> 1988, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - TIMER Function:
;
;      var = TIMER
;	       |
;	     B$TIMR
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	USESEG	OS_TEXT
	USESEG	MT_TEXT

	USESEG	_BSS
	USESEG	_DATA

	INCLUDE seg.inc
	INCLUDE oscalls.inc
	INCLUDE files.inc


C_GETTIM	EQU	44	;Get Time Function (for CALLOS)

sBegin	_BSS
	externB b$Buf1		;Floating point temporary storage
sEnd	_BSS

sBegin	MT_TEXT
	externNP B$fmldw
sEnd	MT_TEXT


sBegin	OS_TEXT
assumes CS,OS_TEXT


	SUBTTL	B$TIMR - elapsed time since midnight
	PAGE

;***
; B$TIMR - returns number of seconds past midnight of current day.
;
; Input:
;	NONE
; Output:
;	AX = ptr to s.p. number of seconds since midnight
; Modifies:
;	NONE
; Exceptions:
;****
cProc	B$TIMR,<PUBLIC,FAR,FORCEFRAME>,<SI,ES>
cBegin
	CALLOS	GETTIM		;CH=hour, CL=min, DH=sec, DL=Hundreths of sec
	MOV	AL,60		;convert hours to minutes, stay int as long as
	MUL	CH		;as possible, result in ax
	XOR	CH,CH		;cx = minutes
	ADD	AX,CX		;ax = number of minutes past midnight
	MOV	BX,AX		;bx = number of minutes past midnight
	PUSH	DX
	CALL	B$fmldw 	;ST0 = number of minutes past midnight
	POP	DX
	MOV	AX,60		;ah = 0 so "op" will be "*" in ST0 = ST0 op AL
	CALL	ST0OpAl 	;  (convert minutes to seconds)
	MOV	AL,DH		;al = number of seconds
	MOV	AH,1		;ah is 1 so "op" will be "+" in
	CALL	ST0OpAl 	;   ST0 = ST0 op AL
	MOV	AX,100		;[ah] = 0 so "op" will be "*" in ST0OpAl
	CALL	ST0OpAl 	;convert ST0 to hundreths of seconds
	MOV	AL,DL		;[al] = hundreths of seconds
	MOV	AH,1		;[ah] is 1 so "op" will be "+"
	CALL	ST0OpAl 	;in ST0 = ST0 op AL
	MOV	AX,0200H + 100d ;[ah] = 2 so "op" will be "/" in ST0OpAl
	CALL	ST0OpAl 	;convert ST0 to seconds from hundreths


	MOV	BX,OFFSET DGROUP:b$Buf1 ; BX = ptr to s.p. temp store loc.
				;of seconds
	FSTP	DWORD PTR [BX]	;put s.p. equivalent into FAC
	XCHG	AX,BX		;restore pointer to result (retval)
	FWAIT			;ensure result in RAM prior to return

cEnd

	PAGE
;***
;ST0OpAl - Add or multiply contents of AL and the ST0, returning result in ST0
;Purpose:
;	Either adds or mulitplies the contents of ST0 by the value in AL.
;	The result is returned in the ST0.
;Entry:
;	AH  -	0 then multiply
;		1 then add
;		else divide ST0 by AL
;	AL  - value to multiply/add to or divide into ST0
;Exit:
;	ST0 - contains result
;Preserves:
;	SI, DI, DX
;Exceptions:
;	None.
;****
cProc	ST0OpAl,<NEAR>,<DX>
cBegin
	PUSH	AX
	MOV	BL,AL
	XOR	BH,BH
	CALL	B$fmldw 	; ST0 = input value
	POP	AX
	OR	AH,AH
	JZ	ST0MUL		; brif we're to multiply ST1 by ST0
	DEC	AH
	JZ	ST0ADD		; brif we're to add ST0 to ST1


	FDIV			; ST0 = ST1/ST0
	JMP	SHORT ST0Ret
ST0MUL:
	FMUL			; ST0 = ST1 * ST0
	JMP	SHORT ST0Ret
ST0ADD:
	FADD			; ST0 = ST1 + ST0


ST0Ret:

cEnd	ST0OpAl


sEnd	OS_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\prnvalfp.asm ===
TITLE	PRNVALFP - Print floaing point values
	page	56,132
;***
; PRNVALFP - Print values
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;	This module contains B$P<term><type> for floating point
;
;	The PRINT, WRITE, and LPRINT statements have a large number of
;	runtime calls that can be generated, based on the list of
;	expressions given. There is a unique preamble call for each such
;	statement (except PRINT), to correctly set up flags, vectors, etc.
;	The actual printing call itself is one of 15 possibilities, based
;	on the argument type, and one of three possible ways of terminating
;	the print: ',', ';', or EOL. Each of these 15 calls is in the
;	form B$P<term><type> where <term> specifies the print termination
;	method, and <type> specifies the type of the argument.
;
;	<term>:
;		C == ',' (i.e., something like 'PRINT X,' was specified)
;		S == ';'
;		E == EOL (neither ',' nor ';' was specified)
;
;	<type>:
;		R4 == single precision real
;		R8 == double precision real
;		CY == currency
;
;	Thus, for example, a call to B$PER4 would be used to print a s.p.
;	value and terminate with a EOL.
;
;	The list of expressions can be of any size; for each additional
;	expression, another one of the fifteen possible runtime calls is
;	generated. After the last such expression, a call to B$PEOS is
;	generated (if not terminated with EOL). If no expression is
;	specified, a NULL string is printed, so 'PRINT' would generate a
;	call to B$PESD with a null string as the parameter (print a string,
;	terminate with EOL).
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	useSeg	DK_TEXT

	INCLUDE seg.inc
	INCLUDE rtps.inc

	SUBTTL	local constant definitions
	page


	COMA	EQU	0	;comma
	SEMI	EQU	1	;semicolumn
	EOL	EQU	2	;forced EOL


	externFP B$PRINT	;Common Print routine


	assumes CS,DK_TEXT
sBegin	DK_TEXT

	externNP B$FloatCONASC	;Pull in floating point conversion routines


	SUBTTL	print interfaces -- B$P<term><type>(<param>)
	page
;***
; B$P<term><type>(<param>) -- print an item for :
;	PRINT, PRINT #, PRINT USING, PRINT # USING,
;	WRITE, WRITE #,
;	LPRINT, LPRINT USING.
;
;Purpose:
;	These are interfaces to the compiler.  Each entry point sets up
;	(1) types of value & terminator, and
;	(2) a pointer to that item,
;	 and then fall through PRINT, which performs actual printing job.
;
;	<term>, <type> & <param> may vary as follows:
;	<term>:
;		C:	Comma used as terminator
;		S:	Semi used as terminator
;		E:	End of statement used as terminator
;	<type>:
;		R4:	Single precision real (sp)
;		R8:	Double precision real (dp)
;		CY:	Currency
;	<param>:
;		A parameter of type <type> to be printed.
;
;
;Entry:
;	Parameter was pushed in stack.
;	<type>	Val = Number if <type> is numerical type
;
;Exit:
;	through B$PRINT
;Uses:
;	none
;Exceptions:
;
;*******************************************************************************

;========================
;	Print R4,	|
;========================

cProc	B$PCR4,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,COMA SHL 8 + VT_R4 ;AX=[terminator type | value type]
	JMP	B$PRINT 	;print the item
cEnd	nogen			;no code generated

;========================
;	Print R4;	|
;========================

cProc	B$PSR4,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,SEMI SHL 8 + VT_R4 ;AX=[terminator type | value type]
	JMP	B$PRINT 	;print the item
cEnd	nogen			;no code generated

;========================
;	Print R4	|
;========================

cProc	B$PER4,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,EOL SHL 8 + VT_R4 ;AX=[terminator type | value type]
	JMP	B$PRINT 	;print the item
cEnd	nogen			;no code generated

;========================
;	Print R8,	|
;========================

cProc	B$PCR8,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,COMA SHL 8 + VT_R8 ;AX=[terminator type | value type]
	JMP	B$PRINT 	;print the item
cEnd	nogen			;no code generated

;========================
;	Print R8;	|
;========================

cProc	B$PSR8,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,SEMI SHL 8 + VT_R8 ;AX=[terminator type | value type]
	JMP	B$PRINT 	;print the item
cEnd	nogen			;no code generated

;========================
;	Print R8	|
;========================

cProc	B$PER8,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,EOL SHL 8 + VT_R8 ;AX=[terminator type | value type]
	JMP	B$PRINT 	;print the item
cEnd	nogen			;no code generated



sEnd	DK_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\prnval.asm ===
TITLE	PRNVAL - Print values
	page	56,132
;***
; PRNVAL - Print values
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;	This module contains B$P<term><type> and B$PEOS interfaces.
;
;	The PRINT, WRITE, and LPRINT statements have a large number of
;	runtime calls that can be generated, based on the list of
;	expressions given. There is a unique preamble call for each such
;	statement (except PRINT), to correctly set up flags, vectors, etc.
;	The actual printing call itself is one of 15 possibilities, based
;	on the argument type, and one of three possible ways of terminating
;	the print: ',', ';', or EOL. Each of these 15 calls is in the
;	form B$P<term><type> where <term> specifies the print termination
;	method, and <type> specifies the type of the argument.
;
;	<term>:
;		C == ',' (i.e., something like 'PRINT X,' was specified)
;		S == ';'
;		E == EOL (neither ',' nor ';' was specified)
;
;	<type>:
;		I2 == two byte integer
;		I4 == four byte integer
;		R4 == single precision real
;		R8 == double precision real
;		SD == string
;
;	Thus, for example, a call to B$PER4 would be used to print a s.p.
;	value and terminate with a EOL.
;
;	The list of expressions can be of any size; for each additional
;	expression, another one of the fifteen possible runtime calls is
;	generated. After the last such expression, a call to B$PEOS is
;	generated (if not terminated with EOL). If no expression is
;	specified, a NULL string is printed, so 'PRINT' would generate a
;	call to B$PESD with a null string as the parameter (print a string,
;	terminate with EOL).
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

;Code segments:
	useSeg	DK_TEXT 	;disk I/O
	useSeg	MT_TEXT 	;floating point math.
	useSeg	NH_TEXT 	;near heap
	useSeg	ER_TEXT 	;error handling
	useSeg	CN_TEXT 	;concole I/O

;Data segments:
	useSeg	CONST		;constant definitions
	useSeg	_DATA		;initialized variables
	useSeg	_BSS		;uninitialized variables

	INCLUDE seg.inc
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE idmac.inc

	SUBTTL	local constant definitions
	page

	CLMWID	EQU	14	;column width

	COMA	EQU	0	;comma
	SEMI	EQU	1	;semicolumn
	EOL	EQU	2	;forced EOL

	TTY	EQU	0	;default for b$PTRFIL is TTY

	PRSTM	EQU	0	;print statement
	CHANL	EQU	1	;#
	USING	EQU	2	;using
	WRSTM	EQU	4	;write statement
	LPSTM	EQU	8	;lprint statement

	InpDefault	EQU	0FFH ;default for b$Finput


	SUBTTL	data definitions
	page

sBegin	CONST
	labelW	TTYVEC		;vector for PRINT
	staticW ,B$TTY_GPOS	;cursor position
	staticW ,B$TTY_GWID	;line width
	staticW ,B$$TCR		;force EOL
	staticW ,B$TTY_SOUT	;write one character
	staticW ,B$TYPSTR	;write a string with BX=*sd
	staticW ,B$TYPCNT	;write a string with CX=length
	staticW ,B$OUTCNT	;write a string char. by char.
	staticW ,TTY_PRTCHK	; check if EOL needs to be forced
sEnd

sBegin	_DATA
	externB b$PRFG		;print flag, may be combined from below
				;0: PRINT stmt
				;1: # (channel)
				;2: USING
				;4: WRITE stmt
				;8: LPRINT stmt
				;e.g. 3 means PRINT # USING

	labelW	<PUBLIC,b$VECS> ; print value vectors
	staticW VPOS,B$TTY_GPOS		;cursor position
	staticW VWID,B$TTY_GWID		;line width
	staticW VWCLF,B$$TCR		;force EOL
	staticW VWCH,B$TTY_SOUT		;write one character
	staticW VTYP,B$TYPSTR		;BX=*sd
	staticW VTYPCNT,B$TYPCNT 	;BX=*sd, CX=length
	staticW VOUTCNT,B$OUTCNT 	;SI=point to string, CX=length
	staticW VPRTCHK,TTY_PRTCHK	; check if EOL needs to be forced
SizeOfVecs	EQU	(($-b$VECS)/2)	;length of b$VECS table in words
	globalB b$FInput,InpDefault	;Where is input comming from
	globalW b$GetOneVal,<DK_TEXTOFFSET NoGetValAssert> ; vector
					;to routine which INPUT will
					;will use to get next data
	globalW b$pGetValDefault,<DK_TEXTOFFSET NoGetValAssert> 
					;if no input statement is
					;present, attempts to call
					;indirect through b$GetOneVal
					;will die by assertion in
					;non-release runtimes.
	globalW b$pFLUSH,Near_Ret,1	;conditional vector for B$FLUSH
	externB b$CRTWIDTH 	; screen width
sEnd

sBegin	_BSS
	globalW b$PUSG,,1	;print using routine
EVEN				; for safety
	externW b$TempSD	; static string descriptor

	globalW b$StkBottom,,1	; used to clean the stack after TTY inp

	externW b$?TYP		; [b$VTYP|b$TTYP] (defined in global.inc)
	externB b$VTYP		; value type (defined in global.inc)
	externB b$TTYP		; terminator type (defined in global.inc)

	externW b$PTRFIL	; print channel #
	externW b$pSTDALCTMP	; indirect B$STDALCTMP vector

	externB b$LPTFDB 	; FDB for line printer
	externB b$Buf1		
sEnd

	SUBTTL	code externals
	page


sBegin	DK_TEXT
	externNP	B$CNTRL		; needed during B$WRIT
sEnd

sBegin	MT_TEXT
	externNP	B$FOUTBX
sEnd

sBegin	CN_TEXT
	externNP	B$TTY_GPOS	;cursor position
	externNP	B$TTY_GWID	;line width
	externNP	B$$TCR		;force EOL
	externNP	B$TTY_SOUT	;write one character
	externNP	B$TYPSTR 	;write a string with BX=*sd
	externNP	B$TYPCNT 	;write a string with CX=length
	externNP	B$OUTCNT 	;write a string char. by char.
sEnd

	assumes CS,DK_TEXT
sBegin	DK_TEXT


	SUBTTL	print interfaces -- B$P<term><type>(<param>)
	page
;***
; B$P<term><type>(<param>) -- print an item for :
;	PRINT, PRINT #, PRINT USING, PRINT # USING,
;	WRITE, WRITE #,
;	LPRINT, LPRINT USING.
;
;Purpose:
;	These are interfaces to the compiler.  Each entry point sets up
;	(1) types of value & terminator, and
;	(2) a pointer to that item,
;	 and then fall through PRINT, which performs actual printing job.
;
;	<term>, <type> & <param> may vary as follows:
;	<term>:
;		C:	Comma used as terminator
;		S:	Semi used as terminator
;		E:	End of statement used as terminator
;	<type>:
;		I2:	Two byte integer
;		I4:	Four byte integer
;		SD:	String (string descriptor)
;	<param>:
;		A parameter of type <type> to be printed.
;
;
;Entry:
;	Parameter was pushed in stack.
;	<type>	Val = Number if <type> is numerical type
;		    = String descriptor if <type> is string
;
;Exit:
;	through B$PRINT
;Uses:
;	none
;Exceptions:
;
;*******************************************************************************

;========================
;	Print I2,	|
;========================

cProc	B$PCI2,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,COMA SHL 8 + VT_I2 ;AX=[terminator type | value type]
	JMP	SHORT B$PRINT	;print this item
cEnd	nogen			;no code generated

;========================
;	Print I2;	|
;========================

cProc	B$PSI2,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,SEMI SHL 8 + VT_I2 ;AX=[terminator type | value type]
	JMP	SHORT B$PRINT	;print the item
cEnd	nogen			;no code generated

;========================
;	Print I2	|
;========================

cProc	B$PEI2,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,EOL SHL 8 + VT_I2 ;AX=[terminator type | value type]
	JMP	SHORT B$PRINT	;print the item
cEnd	nogen			;no code generated

;========================
;	Print I4,	|
;========================
cProc	B$PCI4,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,COMA SHL 8 + VT_I4 ;AX=[terminator type | value type]
	JMP	SHORT B$PRINT	;print the item
cEnd	nogen			;no code generated

;========================
;	Print I4;	|
;========================
cProc	B$PSI4,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,SEMI SHL 8 + VT_I4 ;AX=[terminator type | value type]
	JMP	SHORT B$PRINT	;print the item
cEnd	nogen			;no code generated

;========================
;	Print I4	|
;========================
cProc	B$PEI4,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,EOL SHL 8 + VT_I4 ;AX=[terminator type | value type]
	JMP	SHORT B$PRINT	;print the item
cEnd	nogen			;no code generated

;========================
;	Print a$,	|
;========================

cProc	B$PCSD,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,COMA SHL 8 + VT_SD ;AX=[terminator type | value type]
	JMP	SHORT B$PRINT	;print the item
cEnd	nogen			;no code generated

;========================
;	Print a$;	|
;========================

cProc	B$PSSD,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,SEMI SHL 8 + VT_SD ;AX=[terminator type | value type]
	JMP	SHORT B$PRINT	;print the item
cEnd	nogen			;no code generated

;========================
;	Print a$	|
;========================

cProc	B$PESD,<PUBLIC,FAR>

cBegin	nogen			;no stack frame generated
	MOV	AX,EOL SHL 8 + VT_SD ;AX=[terminator type | value type]
cEnd	nogen			;no code generated

	SUBTTL	actual routine to print an item
	page
;***
;B$PRINT - continue the print interfaces to print an item
;
;Purpose:
;	Print an item for PRINT/WRITE/LPRINT statement.
;
;	Printing an item is affected by:
;	(1) whether it's a 'print using'
;	(2) whether it prints a string (numbers need to be translated)
;	(3) whether it is a print stmt or is a write stmt.
;		In case of write stmt, the following are different:
;		(a) no leading blank for a positive number if '+' omitted
;		(b) no ending space for a number
;		(c) string delimited by '"'
;		(d) comma delimiting items
;
;	One major difference here is that numbers also use the string output
;	routine to print on a device.  The string output routine outputs one
;	string a time, if it fits the rest of the line, which is faster than
;	iteratively outputs one character a time.
;
;	Certainly, one piece of code, which serves such many functions, can't
;	be as clean as some simple routines do.  However, there still has its
;	logic as follows:
;
;	B$PRINT (TerminatorType_&_ValueType)
;	{
;	    if channel on, test the mode is not input
;		if error then give "bad file mode"
;	    get pointer of the item to be printed from stack
;	    set up types
;
;	    /* print the item */
;
;	    if the request was PRINT USING, then
;		call print using routine
;	    else	/* not a PRINT USING */
;		if the request was printing a number, then
;		    translate the number into digital string
;		    if the request was a WRITE statement, then
;			special process the leading & ending space
;		else	/* printing a string */
;		    if the request was a WRITE statement, then
;			special process the string delimitor
;		print the string
;
;	    /* process the terminator */
;
;	    if the terminator was a EOL, then force a carrage return
;	    if the terminator was a COMMA, then fill the rest of the column
;		with blanks
;	    if the terminator was a SEMI-COLUMN and the request was a WRITE
;		statement, then print a ','
;
;	    /* handle the exit process explicitly */
;
;	    play around with BP and SP
;
;	    /*	When exit the stack looks like :	*/
;	    /*			__________________	*/
;	    /*			|	SI	 |	*/
;	    /*			|----------------|	*/
;	    /*			|  DS (if ?WIN)  |	*/
;	    /*		  BP -->|----------------|	*/
;	    /*			|	BP	 |	*/
;	    /*			|----------------|	*/
;	    /*			|    Ret offset  |	*/
;	    /*			|----------------|	*/
;	    /*			|    Ret segment |	*/
;	    /*		 Val -->|----------------|	*/
;	    /*			|    Parameter	 |	*/
;	    /*	(variable len)	\................\ 	*/
;	    /*			\................\ 	*/
;	    /*	      old SP -->|----------------|	*/
;	    /*			|________________|	*/
;	    /*						*/
;	}
;Entry:
;	[AH] = [terminator type]
;	[AL] = [value type]
;	in stack,
;	Val = first word of item, where item is either I2,I4,R4,R8 or sd/psd
;Exit:
;	none
;Uses:
;	none
;Exceptions:
;	bad file mode
;	I/O error or Disk full error when flush the buffer if a EOL encountered
;*******************************************************************************

				;NOTE!: This routine has a manually
				;generated epilogue due to variable number
				;of parameters.  If you change the prologue,
				;here you must also change the epilogue
				;further down.

cProc	B$PRINT,<PUBLIC,FAR>,<SI> ;common routine, has to be declared
				; as FAR for setting up stack frame correctly.
				; SI saved
	ParmW	Val		;dummy parameter, which points to the first
				; byte of the actual parameter regardless how
				; many bytes it is;  this also forces to set
				; up the stack frame
cBegin				;stack frame is set up and SI is saved
	MOV	[b$?TYP],AX	;set up b$VTYP & b$TTYP
	LEA	BX,Val		;get the address of parameter

	CMP	AL,VT_SD	; is this a string parm?
	JNZ	ChkString	; brif not - BX has the pointer to the value
	MOV	BX,[BX] 	; if SD, BX has the value, not pointer
ChkString:

	TEST	[b$PRFG],USING	;is print using on ?
	JNZ	PRTUSG		;Brif yes
	CMP	AL,VT_SD	;printing a string ?
	JZ	PRTSTR		;Brif yes

;[2] At this moment, [BX]=*I2,*I4,*R4 or *R8. 
;	Currently B$FOUTBX changes all registers except BP.  This has to be
;	changed later on.

	CALL	B$FOUTBX	; Hopefully, the return from B$FOUTBX
				;  are BX containing the address of the
				;	string and AX is the length
	MOV	SI,BX		; SI=*Number
	TEST	[b$PRFG],WRSTM	;is write statement on ?
	JNZ	WRTVAL		;Brif is write stmt
	ADD	BX,AX		;bx points to the terminate byte (00)
	INC	AX		;increment the length of the digital string
	MOV	BYTE PTR [BX]," " ;Number always followed by " "
				;Note:	the static buffer for translating a
				;	number must at least one byte longer
				;	than the maximum possible length.
	cCall	MAKESD		;[BX]=*sd on return
PRTIT1: 			;at this entry, check whether a EOL is needed
	PUSH	BX		;save psd
	cCall	[VPRTCHK]	; CY if room is not enough (possibly a EOL
				; was already forced), needs AX=len of string
	POP	BX		;get back psd
PRTIT2: 			;at this entry, no check for EOL (write)
	PUSH	BX		; save psd
	CALL	[VTYP]		;print the string, needs [BX]=psd
	POP	BX		; get back psd
	CALL	[b$pSTDALCTMP]	; deallocate the temp if it is
PRTEND:
	MOV	AL,[b$TTYP]	; get delimiter type
	CBW			; extend to use word ops
	DEC	AX		; test for EOL delimiter
	JG	PRTCLF		; Brif end with LF-CR
	TEST	[b$PRFG],WRSTM	;is write stmt on ?
	JZ	PRTEND2 	; Brif not
	MOV	AL,","		; here if comma or semi and write stmt
	CALL	[VWCH]		;write the character
	JMP	SHORT PRINTX	;exit to caller

WRTVAL: 			;write stmt take off the leading " "
	CMP	BYTE PTR [BX]," " ;is first a blank ?
	JNZ	WTMKSD		;Brif not, go make sd & print it
	INC	SI		;skip the leading blank if write statement
	DEC	AX		;decrement the length
WTMKSD:
	cCall	MAKESD		;[BX]=*sd
	JMP	SHORT PRTIT2	;go print it
PRTUSG:
				; print using, so make QBI compatable.
	CMP	AH,COMA		; PRINT USING COMMA?
	JNE	NotComma	; brif not -- don't alter terminator
	MOV	b$TTYP,SEMI	; change comma to semicolon
NotComma:			
	CALL	[b$PUSG]	;print using is handled specially
	JMP	SHORT PRTEND	;process the terminator
PRTSTR: 			;when enter, BX=*sd
	MOV	AX,[BX] 	; AX = length of string
	TEST	[b$PRFG],WRSTM	; is write stmt on ?
	JZ	PRTIT1		;Brif not, go printing string
	MOV	AL,'"'		;'"' is the delimitor of write string
	PUSH	BX		; save psd
	CALL	[VWCH]		;print '"'
	POP	BX		; restore psd
	CALL	[VTYP]		;output the string
	CALL	[b$pSTDALCTMP]	; deallocate the temp if it is
	MOV	AL,'"'		;'"' is the delimitor of write string
	CALL	[VWCH]		;print it
	JMP	SHORT PRTEND	;process the terminator
PRTCLF:
	CALL	[VWCLF] 	;force a EOL
	cCall	BPEOS		;epilog for PRINT
	JMP	SHORT PRINTX	;exit to caller
PRTEND2:			; here if comma or semi and NOT write stmt
	INC	AX		; test for semi delimitor
	JNZ	PRINTX		; go exit, done if semi-colon
PRTCMA:
	CALL	[VPOS]		;[AH]=current cursor position
	MOV	AL,AH		;position in AL
	XOR	AH,AH		;prepare for DIV
				;Note: can't use CBW here, since the range
				;	is 0 - 255 (unsigned)
	MOV	CL,CLMWID	;get field length
	DIV	CL		;AH=remainder, is the position in this column
	SUB	CL,AH		;spaces needed to fill this column
	XCHG	AX,CX		; put count in AL
	CBW			;extend to a word
	PUSH	AX		;save count of patching spaces
	ADD	AX,CLMWID	;account for width of next column
	cCall	[VPRTCHK]	; CY if room is not enough to fit (possibly
				; a EOL was forced)
	POP	CX		;get back count in CX
	JB	PRINTX		;no need to patch spaces
	CALL	B$OutBlanks	; output CX blanks
PRINTX: 			;pop SI & exit to caller

	POP	SI		; restore
	POP	BP		
	POP	CX		; [CX] = return offset
	POP	DX		; [DX:CX] = return address
	POP	BX		; discard 1st word of parameter
	MOV	AL,BYTE PTR [b$?TYP]	; [AL] = type byte
	TEST	AL,VT_SD	; NZ if I2 or SD, i.e., if 1-word parm
	JNZ	PRINTX_5	; Jump if we don't need to pop more
	POP	BX		; Discard 2nd word of parameter
	TEST	AL,8		; R8 or currency (8-byte values)?
	JZ	PRINTX_5	; no, don't pop any more
	POP	BX		; discard 3rd word of parameter
	POP	BX		; discard 4th word of parameter
PRINTX_5:			
	PUSH	DX		; put back seg...
	PUSH	CX		; ... and offset of far return address
	RET			; and return

cEnd	nogen			;no code generated

	SUBTTL	supporting routines for print an item
	page
;***
;PRTCHK -- check whether there is room for the printing string
;
;Purpose:
;	Check whether there is room for the printing string.  If it isn't,
;	force a EOL if the current position is not in col. 1.
;
;	Prtchk(len_of_str)
;	register int len_of_str
;	{
;	    register int d_width
;	    register int current_pos
;
;	    if ((d_width=vwid()) != 255)
;		if ( (len_of_str > 255) ||
;		     ((d_width - (current_pos=vpos()) - len_of_str) < 0) )
;		{   if (current_pos != 0) /* 0-relative */
;			vclf()
;		    Set_CY
;		}
;	}
;
;Entry:
;	register AX = len_of_str
;
;Exit:
;	CY if room left is not enough (may or may not force a EOL)
;
;Uses:
;	None
;
;Exceptions:
;	None
;*******************************************************************************

cProc	B$PRTCHK,<NEAR,PUBLIC>	

cBegin
	XCHG	DX,AX		; length in DX
	CALL	[VWID]		;[AH] = device width
	CMP	AH,255		;is device a file ?
	JZ	CHKEXT		;exit (with NC)
	MOV	AL,AH		;[AL] = device width
	JMP	SHORT PRTCHK1	
cEnd	<nogen>

cProc	TTY_PRTCHK,<NEAR>	
cBegin				
	XCHG	DX,AX		; length in DX
	MOV	AL,b$CRTWIDTH	; AL = device width

PRTCHK1:			
	CALL	[VPOS]		;[AH] = current position
	OR	DH,DH		; more than 255 char to print?
	JNZ	FORCE		; force a EOL
	SUB	AL,AH		;amount left on line
	JB	FORCE		;If no room on line, need new line
	CMP	AL,DL		;will amount requested fit?
	JAE	CHKEXT		;exit (with NC)
FORCE:
	OR	AH,AH		;is current position 0 (at col 1)
	JZ	NOCRLF		;do not print EOL if at col 1
	CALL	[VWCLF] 	;force EOL
NOCRLF:
	STC			;indicate room is not enough
Near_Ret:			;near return for vector
CHKEXT:
cEnd				;end of PRTCHK

;***
;MAKESD -- make a static string descriptor
;
;Purpose:
;	Make a static string descriptor (in b$TempSD) which points to the
;	input string.  Major changes with revision [38].
;
;	WARNING !!! This routine assumes that the word preceding the string
;	WARNING !!! is available to be used as the string header
;
;Entry:
;	[SI] = address of the string
;	[AX] = length of the string
;
;Exit:
;	[BX] = address of static descriptor (b$TempSD)
;	b$TempSD & b$TempStrPtr set up as SD.
;
;Uses:
;	Backs up SI by 2.
;
;*******************************************************************************

cProc	MAKESD,<NEAR>		;private local routine

cBegin
	MOV	BX,OFFSET DGROUP:b$TempSD	; get the offset
	MOV	WORD PTR [BX],AX		; length goes first
	MOV	WORD PTR [BX+2],SI		; string pointer next
cEnd

;***
;BPEOS -- actual code to terminate a print statement.
;
;Purpose:
;	This routine is called by either the interface B$PEOS or B$PExx
;	(print an item which terminated with a EOL)
;	If FV_FARSTR, deallocate "using" string here if it was a temp.
;Entry:
;	b$PTRFIL is the pointer/handle to FDB
;Exit:
;	b$PTRFIL & b$PRFG are reset
;Uses:
;	none
;Exceptions:
;	I/O error or disk full error (when flush the buffer)
;*******************************************************************************

cProc	BPEOS,<NEAR>,<SI>	;was part of $PV4, SI saved

cBegin
	MOV	SI,[b$PTRFIL]	;get the pointer to FDB
	OR	SI,SI		;is file 0 ? (TTY)
	JZ	PEOSX		;Brif tty output, reset flags and exit
	MOV	[b$PTRFIL],TTY ; clear out active FDB block
	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB
	CMP	SI,OFFSET DGROUP:b$LPTFDB ;is line printer ?
	JE	PEOSX		;Brif LPRINT
	TEST	FileDB.FD_FLAGS,FL_CHAR ;check for character device file
	JZ	PEOSX		;Brif not character device
	CALL	[b$pFLUSH]	; is character device, flush buffer
				; was save and restore registers AX,BX,CX &
				; DX in $PV4
PEOSX:
	TEST	[b$PRFG],WRSTM+LPSTM+CHANL ;was LPRINT, WRITE or # ?
	MOV	[b$PRFG],PRSTM ;reset the print flag
	JZ	NoSetVec
	MOV	SI,OFFSET DGROUP:TTYVEC
				;get source to fill in
	cCall	B$WCHSET	;reset vector to default, needs SI
NoSetVec:
cEnd				;pop SI & exit to caller

	SUBTTL	print/input interface -- B$PEOS [4]
	page
;***
;B$PEOS -- epilog for PRINT/WRITE/LPRINT/INPUT[#]/READ
;
;Purpose:
;	if print, then clear out active FDB block, and flush buffer in case
;		of a character device, also reset print flags
;	if input, reset input flag & variable
;
;	NOTE: this routine plays around with the stack pointer and stack frame
;		pointer (BP).  Be really careful when save something in the
;		stack.
;Entry:
;	[b$PTRFIL] is the pointer to FDB
;	[b$FInput] is the flag for input
;	[b$PRFG] is the flag for print
;Exit:
;	b$PTRFIL & b$PRFG & b$FInput (also b$GetOneVal) are reset
;Uses:
;	none
;Exceptions:
;	I/O error or disk full error (when flush the buffer (BPEOS))
;*******************************************************************************

cProc	B$PEOS,<PUBLIC,FAR>	

cBegin
	PUSH	BP		
	MOV	BP,SP		;set up stack frame explicitly, since error
				; could happen when flushing the buffer
	PUSH	ES		
	MOV	AL,[b$Finput]	; get flag
	OR	AL,AL		; test it
	JS	TryPrint	; either READ stmt or default, try print
	JNZ	RstFlags	; was disk input, just reset flags
	PUSH	SI		; save SI
	PUSH	DI		; save DI
	MOV	DI,[b$StkBottom]	; DI is the stack bottom
	DEC	DI		; one word above
	DEC	DI
	MOV	SI,SP		; SI points to the BP
	ADD	SI,10		;[12] SI points to ret_seg
	MOV	CX,3		; 3 words to move
	STD			; the move has to be from memory high to
				;  low to avoid overlapping
	PUSH	DS		
	POP	ES		
	REP	MOVSW		; mov BP and return addr to new location
	CLD			; clear direction

	MOV	BP,DI		; stack frame has to be changed
	ADD	BP,2		; new locaton of old BP (later on,
				;  "MOV SP,BP" will clean the stack)
	POP	DI		; get back DI
	POP	SI		; get back SI
RstFlags:			
	cCall	B$InpReset	; reset input flag if this is input stmt
	JMP	SHORT EosExit	
TryPrint:			; either print or READ stmt may be here,
				;  however, next call, BPEOS, won't hurt
				;  if it is READ stmt
	cCall	BPEOS		;try print flush the buffer and reset flags
EosExit:			


	POP	ES		
	MOV	SP,BP		;remove stack frame
	POP	BP		
cEnd				;pop BP & exit

	SUBTTL	set up print dispatch vector
	page
;***
;B$WCHSET -- set up print dispatch vector
;
;Purpose:
;	b$VECS is the dispatch vector for PRINT/WRITE/LPRINT, which contains
;	the address for different functions.  The functions are:
;		b$VECS:
;			VPOS	-- current cursor position
;			VWID	-- device line width
;			VWCLF	-- force EOL
;			VWCH	-- write one character
;			VTYP	-- write a string with a given *sd
;			VTYPCNT -- write a string with length in CX
;			VOUTCNT -- write a string char. by char.
;			VPRTCHK -- check if EOL needs to be forced
;Entry:
;	[SI] points to the source which will fill in the b$VECS
;Exit:
;	b$VECS is set up
;Uses:
;	SI
;Exceptions:
;	none
;*******************************************************************************

cProc	B$WCHSET,<PUBLIC,NEAR>,<DI,ES> ;save ES,DI

cBegin
	PUSH	DS		
	POP	ES		; can't assume ES=DS, set them equal
	MOV	DI,OFFSET DGROUP:b$VECS
	MOV	CX,SizeOfVecs	;count of words to copy
	REP	MOVSW
cEnd				;pop DI,ES and exit to caller


;*** 
; B$OutBlanks -- output a string of blanks.  Added with [22].
;
;Purpose:
;	Save some code, and eliminate a static buffer of blanks.
;	Doesn't print anything if count not in range 1-32767.
;
;Entry:
;	CX = number of blanks to output
;Exit:
;	None
;Uses:
;	Per convention
;Exceptions:
;	None
;
;******************************************************************************

cProc	B$OutBlanks,<PUBLIC,NEAR>,<SI,DI>	; Save SI,DI

cBegin
	OR	CX,CX		; negative or zero byte count
	JLE	OutExit 	; brif no blanks to output


DbAssertRel CX,BE,2*FILNAML,DK_TEXT,<B$OutBlanks: cnt too large>    

	PUSH	CX		;save cnt
	PUSH	SS		;ES = DGROUP
	POP	ES		
	MOV	DI,OFFSET DGROUP:b$Buf1 
	PUSH	DI		
	INC	CX		;round byte count to word count
	SHR	CX,1		
	MOV	AX,'  ' 	
    REP STOSW			;fill with spaces
	POP	SI		;DS:SI = string
	POP	CX		;CX = count
	CALL	[VOUTCNT]	;print the spaces


OutExit:
cEnd				;exit to caller

	page
;***
;NoGetValAssert - Assertion code for calls through [b$GetOneVal].
;
;Purpose:
;	The variable [b$GetVal] is reset with common code to point to
;	the default READ/INPUT entry point.  When no INPUT/READ statement
;	is used in a program linked /O, there is no need to drag in the
;	READ code.  So, b$GetVal is initialized to point to this routine
;	for this case.	If someone inadvertently tries to call through
;	b$GetVal when no READ/INPUT code is loaded, it will be caught here.
;	Added with revision [27].
;Entry:
;	none
;Exit:
;	none
;Uses:
;	none
;Exceptions:
;	none
;*******************************************************************************

cProc	NoGetValAssert,<NEAR>
cBegin
	DbHalt <DK_TEXT>,<Tried to call B$ReadVal when it wasn't loaded>
cEnd
	page
;***
;B$InpReset -- reset flag and variables for INPUT related statement
;
;Purpose:
;	Reset flag and variables for input related statement.
;	Moved to this file with [23]
;
;Entry:
;	none
;
;Exit:
;	[b$FInput]	= InpDefault
;	[b$GetOneItem] = OFFSET B$ReadItem
;	[b$PTRFIL]	= TTY
;
;Uses:
;	none
;
;Exceptions:
;	none
;*******************************************************************************

cProc	B$InpReset,<PUBLIC,NEAR>

cBegin
	MOV	[b$FInput],InpDefault
				;reset input flag

; If input was pulled in, then this points to B$ReadVal, if no READ/INPUT
; statement was used, then this really points to the assertion routine
; NoGetValAssert

	PUSH	AX		
	MOV	AX,[b$pGetValDefault] ;get default value for READ/INPUT

	MOV	[b$GetOneVal],AX ;reset get item routine
	POP	AX
	MOV	[b$PTRFIL],TTY ;reset to TTY
cEnd				;exit to caller

	SUBTTL	interface for WRITE preamble
	page
; B$WRIT moved here from PR0A.ASM and modified for greater /O modularity.
;Revision number [25] applies to entire routine.
;***
;B$WRIT -- preamble for WRITE statement [25]
;void B$WRIT(void)
;
;Purpose:
;	This is the only preamble for WRITE statement.	This routine sets up
;	flag for WRITE statement.  BASCOM 2.0 uses two preambles,
;	$WRI for WRITE and $WRD for WRITE #.
;
;	The flag, b$PRFG, is set to 4 (WRSTM) to indicate a WRITE statement
;	is processing.	If it is a WRITE #, then B$CHOU will OR the flag,
;	b$PRFG, with 1 (CHANL) to indicate a special channel is being used.
;Entry:
;	none
;Exit:
;	b$PRFG is set to WRSTM (WRITE statement is on going)
;	uses default vectors, same as PRINT.
;Uses:
;	none
;Exceptions:
;	none
;*******************************************************************************

cProc	B$WRIT,<PUBLIC,FAR,FORCEFRAME>	; stack frame generated explicitly

cBegin
	OR	[b$PRFG],WRSTM	; set flag indicating WRITE stmt is on going
	CALL	B$CNTRL		; check for control chars during print
cEnd				; return to caller

sEnd				;end of DK_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\random.asm ===
TITLE	RANDOM - Random number generator and RANDOMIZE
	page	,132
;***
; RANDOM - Random number generator and RANDOMIZE
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - RANDOMIZE Statement - calls B$RNZ1 if parm
;
;    Example:
;
;	RANDOMIZE 1
;	-----------
;	    |
;	  B$RNZ1
;
;
; - RND Function - calls B$RND0 if no parm, B$RND1 otherwise:
;
;      v = RND[(x)]
;
;    Examples:
;
;      RND			RND(1)
;      ---			------
;	|			   |
;    B$RND0			 B$RND1
;
;
; Algorithm:
;
; We use the "linear congruential" method for random numnber generation. The
; formula is:
;
;	x1 = (x0 * a + c) mod 2^24
;
; where
;
;	x1 = is a new random number in the range [0..1^24]
;	x0 = the previous random number (or the seed, for the first one)
;	a  = 214,013
;	c  = 2,531,011
;
; The RND function returns a floating point number:
;
;	x1 / (2^24)
;
; which changes the range to [0..1].
;
;******************************************************************************
	INCLUDE switch.inc	
	INCLUDE rmacros.inc	; Runtime Macro Defintions

;Code segments			
	useSeg	INIT_CODE	
	useSeg	MT_TEXT 	
	useSeg	DV_TEXT 	
;Data segments			
	useSeg	CONST		
	useSeg	_DATA		
	useSeg	<XIB>		; XIB and XIE must bracket XI!
	useSeg	<XI>		; initializer segment
	useSeg	<XIE>		

	INCLUDE seg.inc 	
	INCLUDE compvect.inc	

	INITIALIZER B$xMTINI	;put B$xMTINI in initializer list
	INCLUDE messages.inc	; message symbols


	SUBTTL	Data definitions
	page			

sBegin	CONST			

	staticW RndA,<43FDH,0003H>	;[4] Double word -  343FDH =  214013D
	staticW RndC,<9EC3H,0026H>	;[4] Double word - 269EC3H = 2531011D
	.8087			
	staticD FP_2T24,16777216.0 

sEnd	;CONST			

sBegin	_DATA			
	externD b$RndVar	; Random number seed
	externW B$AC		
	externW b$run_disp	; Runtime initialization dispatch table
sEnd	;_DATA			

	SUBTTL	code externals
	page

sBegin	DV_TEXT 			
	externNP	B$NearRet	;for disp vectors in compvect.inc
sEnd	DV_TEXT 			



	assumes CS,INIT_CODE	
sBegin	INIT_CODE		

;***
;B$xMTINI - Math initializer
;PLM B$xMTINI()
;
;Purpose:
;	Initializer for Math component.  This routine is called
;	by the Crt0 startup before _main is called.  It will update the
;	indirect dispatch tables for the Math routines.  This
;	insures that the only time that Math is accessed is when
;	this module is linked into the user program.
;
;Entry:
;	None.
;
;Exit:
;	Appropriate dispatch vectors filled.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xMTINI,<FAR>
cBegin
;
;	update "RUN" time initialization dispatch address to B$MTRUNINI
;
	MOV	WORD PTR [b$run_disp].MT_RVEC,MT_TEXTOFFSET B$MTRUNINI
cEnd

sEnd	INIT_CODE		

	SUBTTL	Math RUNtime interpreter initialization
	PAGE
	assumes CS,MT_TEXT	
sBegin	MT_TEXT 		

;***
;B$MTRUNINI - Do RUN time initialization for Math.
;void pascal B$MTRUNINI()
;
;Purpose:
;	Initializes random number seed.  This routine
;	routine gets called during initialization and during RUN.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$MTRUNINI,<PUBLIC,NEAR>
cBegin				
	MOV	[WORD PTR b$RndVar],0	 ;re-init random number
	MOV	[WORD PTR b$RndVar+2],5  ;seed
cEnd				

	SUBTTL	RND interfaces -- B$RND0 & B$RND0
	page
;*** [2]
;B$RND1, B$RND0 - RND function
;R4 B$RND1(R4 RndParm)
;R4 B$RND0(void)
;
;Purpose:
;	Both B$RND1 & B$RND0 return a random number.	If the argument given
;	by the user is positive (or B$RND0), this routine returns the next
;	random in sequence.  If the argument is zero, it returns the same as
;	the previous one.  If the argument is negative, it starts a new pseudo
;	random sequence.
;Entry:
;	None if B$RND0.
;	R4 RndParm on stack if B$RND1.
;Exit:
;	[AX]	= *R4 random number in [0,1)
;Exceptions:
;
;*******************************************************************************

cProc	B$RND0,<PUBLIC,FAR,FORCEFRAME> 
cBegin				
	cCall	GetNextRnd	; on return, AX=*Rndnum
cEnd				; exit

	page

cProc	B$RND1,<PUBLIC,FAR>	
	ParmD	RndParm 	;[2] R4
cBegin				; set up the stack frame
	MOV	AX,SEG_RndParm	; fetch high word of R4 parm
	OR	AX,AX		; Microsoft IEEE: if high word of s.p. is 0,
				;	the number is 0
	JZ	SameNum 	;input is 0; return same result as last time
	JNS	NewRnd		; Brif input positive, give next in sequence

	MOV	DX,OFF_RndParm	; fetch low	word of R4 parm
	ADD	DL,AH		;[4] fold m.s.b. into l.s.b.
	ADC	DH,0
	ADC	AL,0
	XOR	AH,AH		; new 24-bit integer seed in AX:DX
	MOV	[WORD PTR b$RndVar],DX	 
	MOV	[WORD PTR b$RndVar+2],AX 
NewRnd: 			
	cCall	GetNextRnd	; on return AX=*RndNum
	JMP	SHORT RndExit	
SameNum:			
	cCall	MakeFloat	; on return AX=*RndNum
RndExit:			
cEnd				; clean stack and exit to caller

	SUBTTL	RND supporting routine -- GetNextRnd & MakeFloat
	page
;***
;GetNextRnd -- get next random number
;MakeFloat -- make the number in [b$RndVar] into a R4
;
;Purpose:
;	Get next random number in sequence.
;Entry:
;	[b$RndVar] has the seed.
;Exit:
;	[AX]	= *B$AC which contains the R4 result
;Exceptions:
;	none
;*******************************************************************************

cProc	GetNextRnd,<NEAR>	

cBegin				
	PUSH	DI		
	MOV	AX,[WORD PTR b$RndVar]	 ;low half of previous number
	MOV	CX,[RndA]	;low half of A
	MUL	CX
	XCHG	AX,DI		;save low half in DI
	MOV	BX,DX		;  high half in BX
	MOV	AX,[WORD PTR b$RndVar+2] ;high half of previous
	MUL	CX
	ADD	BX,AX		;sum partial products
	MOV	AX,[RndA]
	MUL	[WORD PTR b$RndVar]	 
	ADD	BX,AX		;last partial product (since we're mod 2^24)
	ADD	DI,[RndC]	;add in constant C
	ADC	BL,BYTE PTR [RndC]
	XOR	BH,BH		;extended 24-bit number to 32 bits for NORM
	MOV	DX,DI		;number in BX:DX
	MOV	[WORD PTR b$RndVar],DX	 ;save for next time
	MOV	[WORD PTR b$RndVar+2],BX 
	POP	DI		
MakeFloat:			

	FILD	b$RndVar	; put 24-bit integer on numeric stack
	FDIV	FP_2T24 	; ST0 = seed/2^24
	MOV	BX,OFFSET DGROUP:B$AC 
	FSTP	DWORD PTR [BX]	; put s.p. equivalent into FAC
	XCHG	AX,BX		; result is *R4 in AX
	FWAIT			; ensure result in RAM prior to return

cEnd				; exit to caller

	SUBTTL	RANDOMIZE interface - B$RNZ1
	page
;***[6]
;B$RNZP - RANDOMIZE statement
;void B$RNZP (R8 SeedNum)
;
;Purpose:
;	The number is set into the middle word of the current random
;	number as the seed for the next one.
;Entry:
;	R8 SeedNum
;Exit:
;	A new seed is created in RndVar, based on the seed value at entry
;	and the least significant 2-words of the input parameter.
;Exceptions:
;	none
;*******************************************************************************

cProc	B$RNZP,<PUBLIC,FAR>	
	ParmQ	SeedNum 	; R8 seed number
cBegin				
	LEA	BX,SeedNum+4	; get MOST significant digits
	MOV	AX,[BX] 	; get word of D.P. number
	XOR	AX,[BX+2]	; xor with the next word
	MOV	[WORD PTR b$RndVar+1],AX ; replace middle word of current s.p. seed
				;	with this value - - now we're reseeded.
cEnd				; exit


sEnd	;MT_TEXT		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\read.asm ===
TITLE	READ - Read and Restore statements
	PAGE	56,132
;***
; READ - Read and Restore statements
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
	INCLUDE switch.inc	;Rutime switch file
	INCLUDE rmacros.inc	;General runtime macros

;Code segments
	useSeg	<INIT_CODE>	;Initialization
	useSeg	DK_TEXT
	useSeg	MT_TEXT
	useSeg	ST_TEXT
	useSeg	NH_TEXT
	useSeg	ER_TEXT
	useSeg	<XIB>		; XIB and XIE must bracket XI!
	useSeg	<XI>		;initializer segment
	useSeg	<XIE>		

;Data segments
	useSeg	_DATA
	useSeg	_BSS

	INCLUDE seg.inc 	;Segment definitions
	INCLUDE addr.inc	;Frame and module specific data definitions
	INCLUDE baslibma.inc	; get SKIP macro
	INCLUDE idmac.inc	; debug macros
	INCLUDE rtps.inc	
	INCLUDE pointers.inc	

	INITIALIZER	B$xRDINI	;put B$xRDINI in initializer list.

	SUBTTL	location constant definitions
	page

	InpDefault	EQU	0FFH

	TTY		EQU	0H

	SUBTTL	data definitions
	page

sBegin	_DATA

	externW b$pGetValDefault ; conditional vector for default read
				 ; routine B$READVAL
	externW B$AC

	externW b$cCSubs	; flag indicating compiler in execution
sEnd	;_DATA

sBegin	_BSS
	externB b$VTYP 	;defined in GLOBAL.INC
	externW b$GetOneVal	;function to get next input element

sEnd	;_BSS

	SUBTTL	code segment externals
	page

externFP B$IRDPTR		; return pointer to DATA
externFP B$IRDPTRUPD		; update pointer to DATA

sBegin	MT_TEXT
	externNP	B$FIN
	externNP	B$GETCH	
sEnd	;MT_TEXT

sBegin	ST_TEXT
	externFP	B$ASSN 	
sEnd

sBegin	ER_TEXT
	externNP	B$ERR_OD
	externNP	B$ERR_SN
sEnd	;ER_TEXT

sBegin	NH_TEXT
	externNP	B$GETMODCODE	;Get module specific code
sEnd	;NH_TEXT



	assumes CS,INIT_CODE				
sBegin	INIT_CODE					
;***
;B$xRDINI - Initialize default input vector
;PLM B$xRDINI()
;
;Purpose:
;	Added with revision [18].
;	Initialize default input vector for READ statement.
;
;Entry:
;	None.
;
;Exit:
;	b$pGetValDefault - contains near pointer to B$READVAL
;	b$GetOneVal - contains near pointer to B$READVAL
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xRDINI,<FAR>
cBegin
	MOV	AX,DK_TEXTOFFSET B$READVAL	;get address of default routine
	MOV	b$pGetValDefault,AX		;store it in default vector
	MOV	b$GetOneVal,AX			;and in actual use vector
cEnd
sEnd	INIT_CODE

	assumes CS,DK_TEXT
sBegin	DK_TEXT

	SUBTTL	B$RSTA -- restore pointer to the begining of the DATA list
	PAGE
;***
;B$RSTA -- restore pointer to the begining of the DATA list
;void B$RSTA (void)
;
;Purpose:
; Restore the pointer to the begining of the DATA list.
;
;Entry:
; none
;
;Exit:
; [AX]	= offset of first byte of DATA in the module
; [BX]	= offset of the module specific data area
; data pointer in module_data location (OFD_DATA) is set to the begining of the
; data list. restore flag in module_data location (OFD_RESTORE) is set.
;
;Uses:
; per convention
;
;*******************************************************************************
cProc	B$RSTA,<PUBLIC,FAR,FORCEFRAME> 
cBegin
	MOV	AL,OF_DAT	
	cCall	B$GETMODCODE	;[3] get module data base
	PUSH	AX		; save pointer to module data
	MOV	AL,OF_DS	
	cCall	B$GETMODCODE	; on return, AX=*data
	POP	BX		; get back pointer to module_data
	MOV	[BX].OFD_DATA,AX ;save current data statement pointer
	MOV	[BX].OFD_RESTORE,1 ;note the restore was done
cEnd				;exit to caller

	SUBTTL	RESTORE interface -- RESTORE <line #>
	page
;***
;B$RSTB -- restore DATA list to a specific line number
;void B$RSTB(I2 lineNum)
;
;Purpose:
;	Reset data pointer to a specific line #.
;Entry:
;	Parameter is in stack.
;	U2	LineNum
;Exit:
;	data pointer in module_data location (OFD_DATA) is set to the
;	specified line number.
;	restore flag in module_data location (OFD_RESTORE) is set.
;Uses:
;	none
;Exceptions:
;	none
;*******************************************************************************

cProc	B$RSTB,<PUBLIC,FAR>,<DI,ES>
	ParmW	LineNum 	;U2 line number
cBegin
	cCall	B$RSTA 	; [AX] = ptr to first data, [BX] = mod data
	XCHG	DI,AX		; [DI] = ptr to first data
	DEC	DI
	DEC	DI		;Point to first line number address
	PUSH	DS		
	POP	ES		; make sure ES=DS
	XOR	AX,AX		;AX=0
	MOV	DX,LineNum	;get line #
	JMP	SHORT RSTB_10	

RSTB_5: 			
	XCHG	AX,DX		;AX=0, DX=line #
	MOV	CX,-1		;Allow maximum search range
	REPNE	SCASB		;Scan for zero, which is EOL
RSTB_10:			
	XCHG	AX,DX		;AX=line #, DX=0
	SCASW			;compare requested address with this address
	JA	RSTB_5		; If this line is as big, use it

	MOV	[BX].OFD_DATA,DI ;save new pointer
cEnd				;exit to the caller

	SUBTTL	READ interfaces -- B$RD<type>
	page
;***
;B$RD<type> -- assign a value into the variable
;void B$RD<type> (<type> far *pDest, [I2 cbDest])
;
;	Where,
;		<type>	=	I2:	Two byte integer
;				I4:	Four byte integer
;				R4:	Single precision real
;				R8:	Double precision real
;				SD:	String descriptor
;				FS:	Fixed length string
;
;Purpose:
;	Get the input value and assign it to the variable.  These routines
;	are shared by READ and INPUT [#] statements.
;
;	The functionality of these assignment routines, B$RD<type>, may be
;	roughly split into two parts -- namely, getting one value and then
;	assigning it to the variable.  General speaking, the second part of
;	the assignment routines DOESN'T discriminate among the statements
;	which share its use.  However, the first part of the assignment
;	routines MUST discriminate among the statements which share its use.
;
;	In order to achieve this, the first part of the assignment routines
;	uses an indirect call, CALL [b$GetOneVal], to get one value.
;	[b$GetOneVal] is default to the address of B$ReadVal, which gets one
;	value for READ stmt, or may contain either the address of TTYInpVal
;	for TTY input or the address of DskInpVal for disk (device) input.
;
;	B$RD<type> only sets the type, [b$VTYP], and then jump to a common
;	routine, CommRead, to perform most works there.  The stack frame is
;	not set in B$RD<type>; instead, it is set in CommRead.
;
;	B$InpReset should be called to reset the flag and variables in
;	the routine B$LNIN and B$PEOS.
;
;Entry:
; pDest 	= far pointer to the destination for the data
; cbDest	= for SD and FS only, a byte count of the length of the fixed
;		  length string, or zero indicating an SD.
;
;	[b$GetOneVal] = OFFSET B$ReadVal if READ stmt
;	[b$GetOneVal] = OFFSET TTYInpVal if INPUT from TTY
;	[b$GetOneVal] = OFFSET DskInpVal if INPUT from disk (device)
;Exit:
;	Via CommRead.  When call CommRead, BL has the type
;Uses:
; per convention
;Exceptions:
;	if b$FInput = InpDefault (for READ stmt)
;		B$ERR_OD -- out of DATA
;		B$ERR_SN -- syntax error
;	if b$FInput = InpDsk (for disk (device) input)
;		B$ERR_RPE -- read pass end
;		B$ERR_OV -- overflow
;*******************************************************************************

cProc	B$RDI2,<PUBLIC,FAR>

cBegin	nogen			;no code generated
	MOV	BL,VT_I2	; set type
	SKIP	2		; skip next two bytes
cEnd	nogen

cProc	B$RDI4,<PUBLIC,FAR>

cBegin	nogen			;no code generated
	MOV	BL,VT_I4	; set type
	SKIP	2		; skip next two bytes
cEnd	nogen

cProc	B$RDR4,<PUBLIC,FAR>

cBegin	nogen			;no code generated
	MOV	BL,VT_R4	; set type
	SKIP	2		; skip next two bytes
cEnd	nogen

cProc	B$RDR8,<PUBLIC,FAR>

cBegin	nogen			;no code generated
	MOV	BL,VT_R8	; set type
	SKIP	2		; skip next two bytes
cEnd	nogen


cProc	B$RDSD,<PUBLIC,FAR>

cBegin	nogen			;no code generated
	MOV	BL,VT_SD	; set type
cEnd	nogen

	SUBTTL	common assign routine
	page
;***
;CommRead -- Common assign routine for input & read
;
;Purpose:
;	Assign the value into the variable.  This is the common assigning
;	routine for READ, and INPUT [#] statements.  This routine first
;	gets the value via indirect call to [b$GetOneVal], and then
;	assign it to the destination, which is passed in stack.
;Entry:
;	Parameter is in stack.
;	item	far *pDest; where item is I2, I4, R4, R8 or SD
;
;	[BL]		= type
;	[b$FInput]	= input flag
;	[b$GetOneVal]	= offset of get one value routine for READ, InpTTY,
;				or InpDsk
;Exit:
;	variable is assigned
;Uses:
;	none
;Exceptions:
;	if b$FInput = InpDefault (for READ stmt)
;		B$ERR_OD -- out of DATA
;		B$ERR_SN -- syntax error
;	if b$FInput = InpDsk (for disk (device) input)
;		B$ERR_RPE -- read pass end
;		B$ERR_OV -- overflow
;*******************************************************************************

cProc	CommRead,<PUBLIC,FAR>,<SI,DI,ES>
	ParmD	pDest		; far *item of destination
cBegin
	MOV	[b$VTYP],BL	;save type
	PUSH	BX		; save for later

	PUSH	DS		
	POP	ES		; make sure ES=DS
	CALL	[b$GetOneVal]	; on return SI = *item

	POP	CX		; [CL] = valtype again
	SHR	CL,1		;is string ? (NOTE: CL=1,2,4 or 9 now)
	JB	AssignStr	;Brif yes

	GETPTR	,ES,DI,pDest,,<SIZE,LOAD>   ; ES:DI has the destination
	AND	CX,7H		; [CX] = word count of move
	REP	MOVSW		;store in destination

cEnd				;pop registers and exit to caller

cProc	AssignStr,FAR,<SI,DI,ES>
parmD	pDest			; far pointer to destination
parmW	cbDest			; length thereof
cBegin	nogen			; arelread set up in commread

	XOR	AX,AX		
	cCall	B$ASSN,<DS,[SI],AX,seg_pDest,off_pDest,cbDest> 
cEnd

	SUBTTL	READ supporting routine -- B$ReadVal
	page
;***
;B$ReadVal -- read one value for READ statement
;
;Purpose:
;	Read one value from DATA list for READ statement.
;
;	This routine first gets the pointer to the module_data, which stores
;	the information for RESTORE flag, pointer to DATA list, etc.  It then
;	gets the pointer to the begining of the DATA list, and reset it to
;	the begining of the DATA list if RESTORE has been requested.
;
;	Next this routine gets one value by calling B$GETCH & B$FIN.	B$GETCH
;	purges the leading white spaces from the DATA list, and then B$FIN
;	converts it to the value desired.  B$FIN needs [b$VTYP] being set and
;	SI pointing to the source character stream.
;
;	Finally, this routine moves the pointer of the DATA list to the next
;	item.
;Entry:
;	[b$VTYP]	= type
;Exit:
;	[SI]		= *value
;	OFD_DATA in module_data location is updated
;Uses:
;	none
;Exceptions:
;	B$ERR_OD -- out of data
;	others will handled by B$RUNERR
;*******************************************************************************

cProc	B$ReadVal,<PUBLIC,NEAR>,<DI,ES>

localV	buf,100 		; local buffer for stuff
cBegin				
;
; WARNING: we set DS to a NON-DGROUP value for the operations below. This is
; so that we can use B$GETCH unmodified. NOTE however, that this breaks the
; KANJI version of GETCH, which we'll have to fix someday.
;
; In reality, DS is set to a non-DGROUP value, ONLY if we are in the
; interpreter, and we are trying to read a string. All other cases are forced
; DGROUP, either by virtue of the compilers data being there, or ther
; interpreters numeric data being placed in the local space allocated above.
;
DbAssertRel	SP,A,b$pendchk,DK_TEXT,<Insufficient stack space in B$ReadVal>
	PUSH	DS		; save DGROUP
	LEA	BX,buf		; give get address routine temp space


	cCall	GETADDR 	; [DS:SI] = [ES:SI] = DATA source pointer
				;NOTE:	DS != DGROUP !!
	POP	BX		; [BX] = DGROUP
	PUSH	BX		;	 ...on stack

	PUSH	SI		; Save starting pointer

	CALL	B$GETCH		;Skip over blanks
	MOV	DS,BX		; DS = DGROUP (before error checking)
	CMP	[b$cCSubs],0	; See if we were interpreting
	JZ	moreDATA	; Jump if interpreting
	DEC	AL		;end of data list?
	JZ	ERCOD		;out of DATA
moreDATA:			; not out of DATA

	DEC	SI		;Re-read first character
	PUSH	ES		; save segment of source
	CALL	B$FIN		;Get data item (DS:SI points, ES:SI if string)
				;AL = next byte of string
	POP	DS		; [DS] = source segment

	POP	BX		; [BX] = starting pointer
	SUB	BX,SI		; [BX] = negative difference
	NEG	BX		; [BX] = number of bytes eaten
	POP	DS		; restore DS
	CMP	AL,","		;More values on this line?
	JZ	ReadEnd
	OR	AL,AL		;Better be EOL (zero) if no more values
	JNZ	ERCSN		;Syntax error

ReadEnd:
	cCall	PUTADDR 	; store ending address
	MOV	SI,OFFSET DGROUP:B$AC
				;result in SI
	TEST	[b$VTYP],8	;is 8-byte value ?
	JZ	ReadValExit	;Brif not
	SUB	SI,4		;offset of B$DAC
ReadValExit:
cEnd				;pop di, exit to caller

ERCOD:	JMP	B$ERR_OD	;Out of Data
ERCSN:	JMP	B$ERR_SN	;Syntax error in DATA

;***
; GETADDR - get address of next available DATA item
;
;Purpose:
; Determines what environment we're in, and gets the address of the next
; available DATA item.
;
;Entry:
; [BX]	= offset of local storage to copy FAR numbers to. EI_QB only.
;
;Exit:
; [DS:SI] = [ES:SI] = far address of value.
; [DI]	= Compilers module data area offset. (If compiler)
;
;Uses:
;
;Preserves: (optional)
;
;Exceptions:
;
;******************************************************************************
cProc	GETADDR,NEAR		
cBegin

	CMP	[b$cCSubs],0	; See if we were interpreting
	JZ	GETADDR_50	; Jump if interpreting

	MOV	AL,OF_DAT	; offset of data
	cCall	B$GETMODCODE	; on return base of module_data is in AX
	XCHG	AX,DI		; module_data area pointer
	CMP	[DI].OFD_RESTORE,0 ;have we ever restored?
	JNZ	GETADDR_5	
	cCall	B$RSTA 	; set the pointer to the begining of data
GETADDR_5:			
	MOV	SI,[DI].OFD_DATA ;Get pointer to next data item

	JMP	SHORT GETADDR_90 
GETADDR_50:			
	PUSH	DS		; save dgroup
	PUSH	BX		; [BX] is address of temp buffer
	cCall	B$IRDPTR	; [DS:SI] = pointer to data
	POP	DI		
	POP	ES		; [ES:DI] = address of temp buffer
	.erre	ID_SSEQDS	; temp buffer is on stack
	CMP	SS:[b$VTYP],VT_SD ; is this a string?
	JZ	GETADDR_90	; Then skip the local copy
	PUSH	DI		
	MOV	CX,50		
	REP	MOVSW		; copy to buffer
	PUSH	ES		
	POP	DS		; [DS] = DGROUP
	POP	SI		; [DS:SI] = pointer to local buffer
GETADDR_90:			
	PUSH	DS		
	POP	ES		

cEnd				

;***
; PUTADDR - Save updated READ pointer
;
;Purpose:
; Updates the appropriate READ data pointer.
;
;Entry:
; [AL]	= 0 if EOL, else end of item.
; [BX]	= number of bytes eaten (Interpreter only)
; [DI]	= Compilers module data area offset
; [SI]	= DATA offset to be stored (Compiler only)
;
;Exit:
; none
;
;Uses:
; Might adjust SI.
;
;******************************************************************************
cProc	PUTADDR,NEAR
cBegin

	CMP	[b$cCSubs],0	; See if we were interpreting
	JZ	PUTADDR_50	; Jump if interpreting
	OR	AL,AL		; End of line?
	JNZ	PUTADDR_5	; jump if not
	INC	SI		;Skip over line number
	INC	SI
PUTADDR_5:
	MOV	[DI].OFD_DATA,SI ;Save pointer

	JMP	SHORT PUTADDR_90	

PUTADDR_50:			
	cCall	B$IRDPTRUPD	; update read pointer

PUTADDR_90:			

cEnd				

sEnd	;DK_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\pr0a.asm ===
TITLE	PR0A - Prepare for printing
	page	56,132
;***
; PR0A - Prepare for printing
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - LPRINT [USING] Statement :
;
;      LPRINT [USING "...";] [list of expressions]
;      ------ -------------- ---------------------
;      |	 |		   |
;     B$LPRT  B$USNG	    (see comments in prnval.asm header)
;
; - PRINT [#] [USING] Statement:
;
;      PRINT [#filenumber,] [USING "...";] [list of expresions]
;	      ------------- -------------- --------------------
;	       |	     |			  |
;	     B$CHOU	  B$USNG      (see comments in prnval.asm header)
;
; - WRITE [#] Statement:
;
;      WRITE [#filenumber,] [list of expressions]
;      -----  ------------  ---------------------
;	 |	   |		  |
;      B$WRIT	 B$CHOU   (see comments in prnval.asm header)
;
;	PRINT		-- no preamble
;	WRITE		-- B$WRIT
;	LPRINT		-- B$LPRT
;
;	#		-- B$CHOU
;	USING		-- B$USNG
;
;	Note:	Currently, there are two routines which set up channels,
;		namely, B$CHAN, and B$CHOU.  B$CHAN sets up channel
;		number without checking mode, and B$CHOU excludes the
;		input mode.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;Code segments:
	useSeg	DV_TEXT 	;device independent I/O
	useSeg	DK_TEXT 	;disk I/O
	useSeg	NH_TEXT 	;near heap
	useSeg	ER_TEXT 	;error handling
;Data segments:
	useSeg	CONST		;constant definitions
	useSeg	_DATA		;initialized variables
	useSeg	_BSS		;uninitialized variables

	INCLUDE seg.inc
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE rtps.inc	; constants shared with QBI

	SUBTTL	local constant definitions
	page

	TTY	EQU	0	;default for b$PTRFIL is TTY

	PRSTM	EQU	0	;print statement
	CHANL	EQU	1	;#
	USING	EQU	2	;using
	WRSTM	EQU	4	;write statement
	LPSTM	EQU	8	;lprint statement


	SUBTTL	data definitions
	page

sBegin	CONST
	labelW	<PUBLIC,b$FILVEC> ;vector for PRINT
	staticW ,B$$POS		;cursor position
	staticW ,B$$WID		;line width
	staticW ,B$$WCLF 	;force EOL
	staticW ,B$$WCH		;write one character
	staticW ,B$PRTSTR	;write a string with BX=*sd
	staticW ,B$PRT_TYPCNT	;write a string with CX=length
	staticW ,B$PRT_OUTCNT	;write a string char. by char.
	staticW ,B$PRTCHK	; force EOL if string too long
sEnd				;end of CONST

sBegin	_DATA

	externB b$PRFG		;flag for PRINT/LPRINT/WRITE [#][USING]
	externW B$ENTRY_BUFCNT	; fdb position before exec of current
				; statment.
sEnd	;_DATA

sBegin	_BSS
	externW b$PTRFIL	;defined in GOSTOP.ASM

sEnd	;_BSS

	SUBTTL	code segment definitions
	page

sBegin	DK_TEXT
	externNP	B$WCHSET	; in prnval.asm, set dispatch vector
sEnd	;DK_TEXT

sBegin	DV_TEXT
	externNP	B$$POS
	externNP	B$$WID
	externNP	B$$WCLF
	externNP	B$$WCH
	externNP	B$PRTSTR
	externNP	B$PRT_TYPCNT
	externNP	B$PRT_OUTCNT
	externNP	B$PRTCHK	
sEnd	;DV_TEXT

sBegin	NH_TEXT
	externNP	B$LHFDBLOC	
sEnd

sBegin	ER_TEXT
	externNP	B$ERR_IFN	
	externNP	B$ERR_BFM	
sEnd	;ER_TEXT

	assumes CS,DK_TEXT
sBegin	DK_TEXT

	SUBTTL	interface for set up channel -- B$CHAN & B$CHOU
	page
;***
;B$CHAN -- set up channel for statements
;void B$CHAN(I2 channel)
;
;Purpose:
;	Check and make the I/O channel active for current statement.
;Entry:
;	Parameter is in stack.
;	int	Channel
;Exit:
;	AL = device type
;	[b$PTRFIL] is set to the active FDB
;Uses:
;	none
;Exceptions:
;	illegal file number -- ERC_IFN
;*******************************************************************************

cProc	B$CHAN,<PUBLIC,FAR>,<SI>	;save SI
	ParmW	Channel 		;channel #
cBegin
	MOV	BX,Channel	;BX has the channel #
	cCall	B$ChkFNUM	;check file number, must be 1-255
	CALL	B$LHFDBLOC	; [SI] = *FDB & NZ if channel is active
	JZ	ERCIFN		;illegal file number
	MOV	[b$PTRFIL],SI	;store the pointer/handle
	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB
	MOV	AX,FileDB.FD_BUFCNT ;Save current fdb position
	MOV	B$ENTRY_BUFCNT,AX   ;Used to reset on error
	MOV	AL,FileDB.FD_DEVICE ;return device number
cEnd				;pop SI, exit to caller

;***
;B$CHOU -- set up channel for statements
;void B$CHOU(I2 channel)
;
;Purpose:
;	Check and make the I/O channel active for current print statement.
;	It also checks whether the file mode is correct.  If the mode is
;	input, this routine gives error message.  If mode is O.K., it
;	sets up flag, b$PRFG, to indicate a special channel is using.
;Entry:
;	Parameter is in stack.
;	int	Channel
;Exit:
;	[b$PTRFIL] is set to the active FDB
;	[b$PRFG] OR CHANL (=1)
;Uses:
;	none
;Exceptions:
;	illegal file number (B$ERR_IFN)
;	Bad file mode -- B$ERR_BFM
;*******************************************************************************

cProc	B$CHOU,<PUBLIC,FAR>,<SI>	;save SI
	ParmW	Channel 		;channel #
cBegin
	MOV	BX,Channel	;BX has the channel #
	cCall	B$ChkFNUM	;go check file number, must be 1-255
	CALL	B$LHFDBLOC	; [SI] = *FDB & NZ if channel is active
	JZ	ERCIFN		;illegal file number
	MOV	AX,FileDB.FD_BUFCNT ; Save current fdb position
	MOV	B$ENTRY_BUFCNT,AX   ; Used to reset on error
	CMP	FileDB.FD_MODE,MD_SQI ;can't be input
	JE	ERCBFM		;give bad file mode
	MOV	[b$PTRFIL],SI	;store the pointer/handle
	OR	[b$PRFG],CHANL ;set the flag for print
				; (note: can't use MOV here)
	MOV	SI,OFFSET DGROUP:b$FILVEC
	cCall	B$WCHSET	;set the dispatch vector for print items
cEnd				;pop SI, exit to caller

ERCBFM: JMP	B$ERR_BFM
ERCIFN: JMP	B$ERR_IFN

;***
;B$ChkFNUM -- check file number
;
;Purpose:
;	Check file number is within 1-255.  Otherwise give "illegal file
;	number"
;Entry:
;	[BX]	= file number
;Exit:
;	none
;Uses:
;	none
;Preserves: (optional)
;	all
;Exceptions:
;	illegal file number -- ERC_IFN
;*******************************************************************************

cProc	B$ChkFNUM,<PUBLIC,NEAR>

cBegin
	OR	BX,BX		;can't be 0
	JZ	ERCIFN		;Brif yes, give "illegal file number"
	OR	BH,BH		;can't exceed 255
	JNZ	ERCIFN		;Brif yes, give "illegal file number"
cEnd				;if no error, exit to caller

sEnd	;DK_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\prtu.asm ===
TITLE	PRTU - PRINT USING Driver
	page	56,132
;***
; PRTU - PRINT USING Driver
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	When USING clause encountered, B$USNG is called and sets b$PUSG
;	with the address of B$PREN.  For each print item, B$PREN is
;	indirectly called to perform the job of PRINT USING.
;
;	Note: this is a terrible module.  There had only one routine $$PREN
;		and it was unreadable.	I split it into B$PREN, PUSCAN &
;		PLSPRT according its logic and make the modifications which
;		are needed.  Even though, PUSCAN is still awful.  Be patient
;		to read it.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc
	INCLUDE rtps.inc	; constants shared with QBI

;Code segment
	useSeg	DK_TEXT 	; disk I/O
	useSeg	ST_TEXT
	useSeg	ER_TEXT
;Data segment
	useSeg	CONST
	useSeg	_DATA
	useSeg	_BSS

	INCLUDE seg.inc
	INCLUDE string.inc	

	SUBTTL	local constant definitions
	page

	USING	EQU	2	; using
	NOPEND	EQU	0	; no type pending (used by USING)

	CURNCY= "$"		;Currency symbol
	CSTRNG= "\"             ;String USING symbol
	VSTRNG= "&"		;Whole string symbol

	SCIENCE EQU	00000001B
	STRING	EQU	00000010B
	SIGN	EQU	00000100B
	PLUS	EQU	00001000B
	DOLLAR	EQU	00010000B
	STAR	EQU	00100000B
	COMMA	EQU	01000000B
	PUSING	EQU	10000000B

	BIGSCI	EQU	00000001B	; 3 digit sci-notation

	SUBTTL	data segment definitions
	page

sBegin	_DATA
	externB b$PRFG 	; flag for PRINT/LPRINT/WRITE [#][USING]
	externW b$VECS 	;defined in PRNVAL.ASM
	VPOS	EQU	b$VECS+2*0
	VWID	EQU	b$VECS+2*1
	VWCLF	EQU	b$VECS+2*2
	VWCH	EQU	b$VECS+2*3
	VTYP	EQU	b$VECS+2*4
	VTYPCNT EQU	b$VECS+2*5
	VOUTCNT EQU	b$VECS+2*6
sEnd	;_DATA

sBegin	_BSS

	globalW b$DIGCNT,,1	;Count of digits before and after d.p.

	globalW b$PUFLG,,1	; Flag word
;
;Bits of the flag word are used as follows:
;
;bit 0	1=Scientific notation		0=Fixed format
;bit 1	1=Print string			0=Print number
;bit 2	1=Place sign after number	0=No sign after number
;bit 3	1=Print "+" for positive number 0=No "+"
;bit 4	1=Print "$" in front of number	0=No "$"
;bit 5	1=Pad with leading "*"		0=Pad with leading spaces
;bit 6	1=Put commas every three digits 0=No commas
;bit 7	1=Print using output,		0=Free format output
;bit 8	1=3 digit scientific notation (bit 0 is one also)
;
	staticW PUSC,,1 	;PRINT USING scan count
	staticB PUVS,,1 	;PRINT USING value seen flag

	externW b$PUSG 	; store the actual address for PRINT USING

	externW b$PUDS 	;defined in GOSTOP.ASM

	externB b$VTYP 	; defined in GLOBAL.INC
	externW b$pSTDALCTMP	; indirect B$STDALCTMP vector

sEnd	;_BSS

	SUBTTL	code segment externals
	page


sBegin	ST_TEXT
	externFP	B$SASS 	
	externNP	B$PUFOUT	;in pufout.asm
	externNP	B$OutBlanks	
sEnd	;ST_TEXT

sBegin	ER_TEXT
	externNP	B$ERR_FC
	externNP	B$ERR_TM
sEnd	;ER_TEXT

	assumes CS,ST_TEXT
sBegin	ST_TEXT

	SUBTTL	B$PREN -- main body of PRINT USING
	page
;***
;B$PREN -- PRINT USING
;
;Purpose:
;	Perform the format print according to b$PUFLG.  This routine first
;	prints the item according to the format in b$PUFLG, if it is nonzero,
;	and then sets the b$PUFLG for next item.  b$PUFLG is reset to zero
;	by B$USNG (the preamble of PRINT USING), and then is set each time
;	this routine is called.
;
;	Actually, except the field size, there is not much to consider if
;	printing a string.  For printing a number, there are a lot of
;	varieties.  However, the formatting is done in B$PUFOUT.
;Entry:
;	[BX]		= *SD, *I2, *I4, *R4, or *R8
;	[b$PUFLG]	= print using format flag
;	[b$PUDS]	= USING string descriptor
;Exit:
;	[b$PUFLG] is set for next item (or 0 if none)
;Uses:
;	none
;Exceptions:
;	illegal function call -- B$ERR_FC
;	type mismatch -- B$ERR_TM
;*******************************************************************************

cProc	B$PREN,<PUBLIC,NEAR>,<SI,DI>	;save di,si

cBegin
	MOV	AX,[b$PUFLG]	; test if type pending
	OR	AX,AX		; is this the first print using item ?
	JNZ	PrtItem 	;Brif not, go print it
	MOV	PUVS,AL 	; clear PUVS
	PUSH	BX		;save item to be printed
	MOV	AX,[b$PUDS]	;get length of PRINT USING string
	MOV	PUSC,AX 	;save scan count remaining
	OR	AX,AX		;null string?
	JZ	FARG		;If so, illegal function call
	CALL	PUSCAN		;scan the format for the first item
				;[b$PUFLG] is set on return
	POP	BX		;get item back
	MOV	AL,BYTE PTR [b$PUFLG]	; AL has the format of the printing item
PrtItem:
	MOV	PUVS,AL 	;save information in PUVS
	MOV	CX,b$DIGCNT	;load [CX]
	TEST	AL,STRING	;does the field define a string?
	JNZ	PrtStr		;go printing a string
	CMP	b$VTYP,VT_SD	;is it a string ?
	JZ	TMER		;Brif yes, give "type mismatch"
	cCall	B$PUFOUT	;translate and format the printing number
				; needs [BX] = *I2, *I4, *R4 or *R8
				; and [b$PUFLG] = format
				;on return,
				; [SI] point to the digit string
				; [AX] count of length
				; DI is used
	XCHG	AX,CX		;cut count in CX
	CALL	[VOUTCNT]	;output string with CX=length
	JMP	SHORT ScanNext	;try next, set b$PUFLG for next item
PrtStr:

	; Throughout the following code, CX = length of string to print
	; and DX = number of spaces to follow it.

	CMP	b$VTYP,VT_SD	;type better be string
	JNZ	TMER		;Brif not, give "type mismatch"
	MOV	DX,CX		;save length of print field into DX
	MOV	CX,[BX] 	;get length of string
	SUB	DX,CX		;DX = padding count

;-------------------------------
;Note that if we have a variable length string field, DX will be -1.
;The result of the above subtraction will never carry (so we will take the
;JAE below), but the number left in DX will always be negative. Thus when
;we get to the padding check, no blanks will be added.
;-------------------------------

	JAE	PrtIt		;if field is big enough, proceed
	ADD	CX,DX		;CX = CX + (old DX-CX) = old DX = size of field


PrtIt:
	PUSH	DX		; save DX, DX is used by [VTYPCNT]
	CALL	[VTYPCNT]	;output CX bytes of string
	CALL	[b$pSTDALCTMP]	;deallocate the temp string if it is
	POP	CX		; padding count in CX (could be negative!)
	CALL	B$OutBlanks	; output CX spaces
ScanNext:
	CALL	PUSCAN		;scan & set the format for next item
cEnd				;pop si,di and exit to caller

FARG:	JMP	B$ERR_FC		;Illegal function call
TMER:	JMP	B$ERR_TM		;Type mismatch

	SUBTTL	scan one print format from USING string
	page
;***
;PUSCAN -- scan and set up the print format for one item
;
;Purpose:
;	This routine scans the Using string, b$PUDS, and sets up the flag
;	b$PUFLG, so the next print item may be formated.
;
;	The possible formats for a print item are:
;
;	for string item:
;		!	print first character of that string
;		\...\ 	print 2+n characters, n is the spaces between two "\"
;		&	print variable length (b$DIGCNT is set to -1)
;	for numeric item
;		#	print one digit
;		.	print "."
;		+	print sign
;		-	print minus sign at the end of the number
;		**	print "*" as the leading character
;		$$	print "$" preceeding the number
;		,	print "," each three digits
;		^^^^	print scientific notation
;		^^^^^	print scientific notation, 3 digits
;		_	print next character as a literal character
;
;	Also, a "%" will be printed preceeding the number if the field specified
;	is not big enough.
;Entry:
;	[PUSC]		= scan count
;	[b$PUDS]	= SD of Using string
;Exit:
;	[b$PUFLG] is set
;Uses:
;	SI
;Exceptions:
;	illegal function call -- B$ERR_FC
;*******************************************************************************

PUSCAN:
	MOV	[b$PUFLG],0	;reset the format flag
	MOV	SI,[b$PUDS+2]	;start of string (could change if G.C.!)
	MOV	AX,[b$PUDS]	;length of the string
	MOV	CX,PUSC 	;get scan count
	SUB	AX,CX		;offset into string
	ADD	SI,AX		;move the string pointer
	JCXZ	RETL		;at end of string?
	JMP	SHORT PRCCHR	;If not, scan for next value (or EOS)

REUSIN: cCall	PLSPRT		;print a "+" if necessary
	CALL	[VWCH]		;output the character in AL
REUSN1:
	MOV	PUSC,CX 	;save scan count ( = 0 )
	MOV	BYTE PTR [b$PUFLG],CL	; set the b$PUFLG
	CMP	CL,PUVS 	;any values seen in string?
	JZ	FARG		;if not, we'll never get anywhere
RETL:	RET			;exit to caller

;-------------------------------
; Here to handle a literal character in the using string preceded by "_".
;-------------------------------

LITCHR: cCall	PLSPRT		;print previous "+" if there is any
	LODSB			;fetch literal character

	CALL	[VWCH]		;output that literal character
	LOOP	PRCCHR		;decrement count (CX)
	JMP	SHORT REUSN1	;Brif no more

;-------------------------------
; Here to handle variable length string field specified with "&".
;-------------------------------

VARSTR:
	MOV	BX,-1		;SET LENGTH TO MAXIMUM POSSIBLE
ISSTRF:
	DEC	CX		;DECREMENT THE "USING" STRING CHARACTER COUNT
	cCall	PLSPRT		;PRINT A "+" IF ONE CAME BEFORE THE FIELD
	MOV	PUSC,CX 	;Save scan count
	MOV	b$DIGCNT,BX	;Save field width
	MOV	BYTE PTR [b$PUFLG],2	; Flag string type
	RET

BGSTRF:
	;MOV	BP,CX		;SAVE THE "USING" STRING CHARACTER COUNT
				;can't use BP, but we exhaust all registers
				; we have to use another way to solve it
	MOV	DI,SI		;SAVE THE POINTER INTO THE "USING" STRING
	MOV	BX,2		;THE \\ STRING FIELD HAS 2 PLUS
				;NUMBER OF ENCLOSED SPACES WIDTH

;There does not have to be a test for KANJI characters in this loop, as
;We know that we are not in the middle of one, and no KANJI can start with
;either a CSTRNG or a SPACE

LPSTRF:
	LODSB			;GET THE NEXT CHARACTER
	CMP	AL,CSTRNG	;THE FIELD TERMINATOR?
	JZ	ISSTRF		;GO EVALUATE A STRING AND PRINT
	INC	BX		;INCREMENT THE FIELD WIDTH
	CMP	AL," "		;A FIELD EXTENDER?
	LOOPZ	LPSTRF		;KEEP SCANNING FOR THE FIELD TERMINATOR

;-------------------------------
; Since  string field wasn't found, the "using" string character count and the
; pointer into it's data must be restored and the "\" printed.
;
; The way to restore CX has to pay a little bit attention, since we can't
; use BP as tempopary saving register.	Note that the SI incremented by one
; and CX decrement by one in the LPSTRF loop, if we don't find the string
; field.  So that, when enter NOSTRF, the amount of SI's increment is equal
; to the amoutn of the CX's decrement.  We may then restore CX using this
; calculation.	How lucky we are !
;-------------------------------

NOSTRF:
	SUB	SI,DI		;calculate the bytes we have scaned, put in SI
	ADD	CX,SI		;restore the count in CX
	MOV	SI,DI		;RESTORE THE POINTER INTO "USING" STRING'S DATA
	;MOV	CX,BP		; can't use BP
	MOV	AL,CSTRNG	;RESTORE THE CHARACTER

;-------------------------------
; Here to print the character in [al] since it wasn't part of any field.
;-------------------------------

NEWUCH: cCall	PLSPRT		;IF A "+" CAME BEFORE THIS CHARACTER
				;MAKE SURE IT GETS PRINTED
	CALL	[VWCH]		;Print the char that wasn't part of a field
;-------------------------------
; Scan one value field from USING string, and set up print using flags.
; On entry:
;	[SI]	= Points to next byte in PRINT USING string
;	[CX]	= Count of characters left in PRINT USING string
;	[DH]	= Flag byte used by B$PUFOUT (stored in b$PUFLG - see above)
;	[BH]	= Number of digits to left of decimal point (numbers only)
;	[BL]	= Number of digits to right of decimal point (numbers only)
;	[BX]	= Length of string field (strings only)
;-------------------------------

PRCCHR: XOR	AL,AL		;SET [DH]=0 SO IF WE DISPATCH
	MOV	DH,AL		;DON'T PRINT "+" TWICE
PLSFIN: cCall	PLSPRT		;ALLOW FOR MULTIPLE PLUSES IN A ROW
	MOV	DH,AL		;SET "+" FLAG
	LODSB			;GET A NEW CHARACTER

	CMP	AL,"!"		;CHECK FOR A SINGLE CHARACTER
	MOV	BX,1		;Set string length to 1
	JZ	ISSTRF		;STRING FIELD
	CMP	AL,"#"		;CHECK FOR THE START OF A NUMERIC FIELD
	JZ	NUMNUM		;GO SCAN IT
	CMP	AL,VSTRNG	;See if variable string field
	JZ	VARSTR		;GO PRINT ENTIRE STRING
	DEC	CX		;ALL THE OTHER POSSIBILITIES
				;REQUIRE AT LEAST 2 CHARACTERS
	JZ	REUSIN		;IF THE VALUE LIST IS NOT EXHAUSTED
				;GO REUSE "USING" STRING
	CMP	AL,"+"		;A LEADING "+" ?
	MOV	AL,PLUS 	;SETUP [DH] WITH THE PLUS-FLAG ON IN
	JZ	PLSFIN		;CASE A NUMERIC FIELD STARTS
	MOV	AL,[SI-1]	;GET BACK THE CURRENT CHARACTER
	CMP	AL,"."		;NUMERIC FIELD WITH TRAILING DIGITS
	JZ	DOTNUM		;IF SO GO SCAN WITH [BH]=
				;NUMBER OF DIGITS BEFORE THE "."=0
	CMP	AL,"_"		;CHECK FOR LITERAL CHARACTER DECLARATION
	JZ	LITCHR
	CMP	AL,CSTRNG	;CHECK FOR A BIG STRING FIELD STARTER
	JZ	BGSTRF		;GO SEE IF IT REALLY IS A STRING FIELD
	CMP	AL,[SI] 	;SEE IF THE NEXT CHARACTER MATCHES THE
				;CURRENT ONE
	JNZ	NEWUCH		;IF NOT, CAN'T HAVE $$ OR ** SO ALL THE
				;POSSIBILITIES ARE EXHAUSTED
	CMP	AL,CURNCY	;IS IT $$ ?
	JZ	DOLRNM		;GO SET UP THE FLAG BIT
	CMP	AL,"*"		;IS IT ** ?
	JNZ	NEWUCH		;IF NOT, ITS NOT PART
				;OF A FIELD SINCE ALL THE POSSIBILITIES
				;HAVE BEEN TRIED
	OR	DH,STAR 	;Set "*" bit
	INC	SI
	CMP	CX,2		;SEE IF THE "USING" STRING IS LONG
				;ENOUGH FOR THE SPECIAL CASE OF
	JC	SPCNUM		; **$
	MOV	AL,[SI]
	CMP	AL,CURNCY	;IS THE NEXT CHARACTER $ ?
	JNZ	SPCNUM		;IF IT NOT THE SPECIAL CASE, DON'T
				;SET THE DOLLAR SIGN FLAG
	DEC	CX		;DECREMENT THE "USING" STRING CHARACTER COUNT
				;TO TAKE THE $ INTO CONSIDERATION
	INC	BH		;INCREMENT THE FIELD WIDTH FOR THE
				;FLOATING DOLLAR SIGN
DOLRNM:
	OR	DH,DOLLAR	;SET BIT FOR FLOATING DOLLAR SIGN FLAG
	INC	SI		;POINT BEYOND THE SPECIAL CHARACTERS
SPCNUM: INC	BH		;SINCE TWO CHARACTERS SPECIFY
				;THE FIELD SIZE, INITIALIZE [BH]=1
NUMNUM: INC	BH		;INCREMENT THE NUMBER OF DIGITS BEFORE
				;THE DECIMAL POINT
	MOV	BL,0		;SET THE NUMBER OF DIGITS AFTER
				;THE DECIMAL POINT = 0
	DEC	CX		;SEE IF THERE ARE MORE CHARACTERS
	JZ	NOTSCI		;IF NOT, WE ARE DONE SCANNING THIS
				;NUMERIC FIELD
	LODSB			;GET THE NEW CHARACTER
	CMP	AL,"."		;DO WE HAVE TRAILING DIGITS?
	JZ	AFTDOT		;IF SO, USE SPECIAL SCAN LOOP
	CMP	AL,"#"		;MORE LEADING DIGITS ?
	JZ	NUMNUM		;INCREMENT THE COUNT AND KEEP SCANNING
	CMP	AL,","		;DOES HE WANT A COMMA
				;EVERY THREE DIGITS?
	JNZ	FINNUM		;NO MORE LEADING DIGITS, CHECK FOR ^^^
	OR	DH,COMMA	;TURN ON THE COMMA BIT
	JMP	NUMNUM		;GO SCAN SOME MORE

;-------------------------------
; Here when a "." is seen in the "using" string.  It starts a numeric field
; if and only if it is followed by a "#".  Once again, we do not have to
; test for KANJI characters because "#" and "^" can not be a legal first
; character for a double byte character.
;-------------------------------

DOTNUM:
	MOV	AL,[SI] 	;GET THE CHARACTER THAT FOLLOWS
	CMP	AL,"#"		;IS THIS A NUMERIC FIELD?
	MOV	AL,"."		;IF NOT, GO BACK AND PRINT "."
	JZ	DOTNU1		;[RDK]
	JMP	NEWUCH		;[RDK]cannot reach by short jump
DOTNU1: 			;[RDK]
	MOV	BL,1		;INITIALIZE THE NUMBER OF
				;DIGITS AFTER THE DECIMAL POINT
	INC	SI
AFTDOT: INC	BL		;INCREMENT THE NUMBER OF DIGITS
				;AFTER THE DECIMAL POINT
	DEC	CX		;SEE IF THE "USING" STRING HAS MORE
	JZ	NOTSCI		;CHARACTERS, AND IF NOT, STOP SCANNING
	LODSB			;GET THE NEXT CHARACTER
	CMP	AL,"#"		;MORE DIGITS AFTER THE DECIMAL POINT?
	JZ	AFTDOT		;IF SO, INCREMENT THE COUNT AND KEEP
				;SCANNING

;-------------------------------
; Check for the "^^^^" that indicates scientific notation.
;-------------------------------

FINNUM:
	DEC	SI		;Point back to current character
	CMP	WORD PTR [SI],"^^" ;Two "^"s in a row?
	JNZ	NOTSCI
	CMP	WORD PTR [SI+2],"^^" ;Four "^"s in a row?
	JNZ	NOTSCI
	CMP	CX,4		;WERE THERE ENOUGH CHARACTERS FOR "^^^^"?
	JC	PUSCAX
	SUB	CX,4
	ADD	SI,4
	INC	DH		;TURN ON THE SCIENTIFIC NOTATION FLAG

	JCXZ	NOTSCI		; jump if no more using to look at
	CMP	BYTE PTR [SI],"^" ; check for 5th "^"
	JNZ	NOTSCI		; no need to play games
	INC	SI		; eat the character
	DEC	CX		
	MOV	[b$PUFLG+1],BIGSCI ; Indicate 3 digit scientific

NOTSCI:
	INC	BH		;INCLUDE LEADING "+" IN NUMBER OF DIGITS
	TEST	DH,PLUS 	;DON'T CHECK FOR A TRAILING SIGN
	JNZ	ENDNUM		;ALL DONE WITH THE FIELD IF SO
				;IF THERE IS A LEADING PLUS
	DEC	BH		;NO LEADING PLUS SO DON'T INCREMENT THE
				;NUMBER OF DIGITS BEFORE THE DECIMAL POINT
	JCXZ	ENDNUM		;SEE IF THERE ARE MORE CHARACTERS
	LODSB			;GET THE CURRENT CHARACTER
	CMP	AL,"-"		;TRAIL MINUS?
	JZ	SGNTRL		;SET THE TRAILING SIGN FLAG
	CMP	AL,"+"		;A TRAILING PLUS?
	JNZ	ENDNUM		;IF NOT, WE ARE DONE SCANNING
	OR	DH,PLUS 	;TURN ON THE POSITIVE="+" FLAG
SGNTRL:
	OR	DH,SIGN 	;TURN ON THE TRAILING SIGN FLAG
	DEC	CX		;DECREMENT THE "USING" STRING CHARACTER
				;COUNT TO ACCOUNT FOR THE TRAILING SIGN
ENDNUM:
	MOV	PUSC,CX 	;Save scan count
	MOV	b$DIGCNT,BX
	ADD	BH,BL		;Digit count must not exceed 24
	CMP	BH,25
	JNC	ARGERR		;IF SO, "ILLEGAL FUNCTION CALL"
	OR	DH,PUSING	;TURN ON THE "USING" BIT
	MOV	BYTE PTR [b$PUFLG],DH	
PUSCAX:
	RET			;GET OUT

ARGERR: JMP	B$ERR_FC

	SUBTTL	check/print "+"
	page
;***
;PLSPRT -- decide whether a "+" should be printed or not
;
;Purpose:
;	If the "+" flag in [DH] is set, and a character which is decided
;	not part of a numeric field is found, a "+" is printed.
;
;	When a "+" is detected in the "using" string, if a numeric field
;	follows, a bit in [DH] should be set, otherwise a "+" should be
;	printed.  Since deciding whether a numeric field follows is very
;	difficult, the bit is always set in [DH].  At the point a character
;	which is decided not part of a numeric field is found, this routine
;	is called to see if the bit in [DH] is set.  If it is, then a plus
;	is printed.
;Entry:
;	[DH]	= print using flag (refer the definition of b$PUFLG)
;Exit:
;	none
;Uses:
;	none
;Preserves:
;	[AX]	= current character
;Exceptions:
;	none
;*******************************************************************************

cProc	PLSPRT,<NEAR>

cBegin
	OR	DH,DH		;check the plus bit in DH
	JZ	RT
	PUSH	AX		;save current character
	MOV	AL,"+"		;print "+"
	CALL	[VWCH]		;do it
	POP	AX		;get back character
RT:
cEnd				;exit to caller
sEnd	;ST_TEXT

; Moved B$PUSG here from PR0A.ASM to increase /O modularity
; Revision applies to entire routine B$PUSG.
	assumes CS,DK_TEXT	
sBegin	DK_TEXT			

	SUBTTL	interface for USING preamble
	page
;***
;B$USNG -- USING preamble [7]
;void B$USNG(sd *psdPUexp)
;
;Purpose:
;	This is the preamble for USING clause found in PRINT/LPRINT stmt.
;	It ORs the flag, b$PRFG, with USING (=2) to indicate an USING
;	clause is on going.  It also set up the b$PUSG with the actual
;	working routine, B$PREN.  The using expression is copied into
;	b$PUDS for further use.
;Entry:
;	Parameter is in stack:
;	sd	*psdPUexp
;Exit:
;	[b$PRFG] OR USING (=2)
;	[b$PUFLG] = NOPEND (set to no type pending)
;	[b$PUDS] = string of the print using
;	[b$PUSG] = address of actual working routine (B$PREN)
;Uses:
;	none
;Exceptions:
;	none
;*******************************************************************************

cProc	B$USNG,<PUBLIC,FAR>		
ParmSD	sdPUexp 			; sd of using expression
cBegin
	MOV	AX,OFFSET DGROUP:b$PUDS 
	cCall	B$SASS,<sdPUexp,AX>	;copy "using" string
	OR	[b$PRFG],USING 		;set up USING flag
	MOV	[b$PUSG],OFFSET B$PREN
					;set up the entry address for USING
	MOV	[b$PUFLG],NOPEND 	;set to no type pending
cEnd					;exit to caller

sEnd	;DK_TEXT			
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\pufout.asm ===
TITLE	PUFOUT - PRINT USING output formatter
	page	56,132
;***
; PUFOUT - PRINT USING output formatter
;
;	Copyright <C> 1986 - 1988, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
	INCLUDE switch.inc	
	INCLUDE rmacros.inc	

;Code segment
	useSeg	ST_TEXT 	
	useSeg	MT_TEXT 	
;Data segment
	useSeg	_DATA		
	useSeg	_BSS		

	INCLUDE seg.inc 	
	INCLUDE idmac.inc	
	INCLUDE	rtps.inc	

	SUBTTL	local constant definitions
	page

	CURNCY= "$"			;Currency symbol

;Definition of bits in flag byte

	COMMABIT =	40H	;Commas every 3 digits in integer part
	STARBIT =	20H	;Fill with leading "*" instead of blanks
	DOLLARBIT =	10H	;Floating "$" in front of number
	PLUSBIT =	08H	;Force "+" in positive
	TRAILING =	04H	;Put sign at end of number
	SCIBIT	=	01H	;Use scientific notation

	BIGSCI =	01H	; 3 digit sci notation

	SUBTTL	data definitions
	page
				; whole section redifined
sBegin	_DATA
	externW B$AC
sEnd

sBegin	_BSS

	externB b$FOBUF		; defined in CONASC.ASM
	externB b$SIGN 		; defined in CONASC.ASM
	externB b$VTYP		
	externB b$DIGCNT	;defined in PRTU.ASM as word
	DECDIG	EQU	b$DIGCNT	;No. of digits to right of D.P.
	INTDIG	EQU	b$DIGCNT+1	;No. of digits to left of D.P.

	externW b$PUFLG	; defined in PRTU.ASM

sEnd	;_BSS

sBegin	MT_TEXT
	externNP B$FOUTBX	; Integer formating routine
sEnd	MT_TEXT

	SUBTTL	code segment externals
	page
sBegin	ST_TEXT
	EXTRN	B$ASCRND:NEAR	

	externNP B$FloatCONASC	

sEnd

	assumes CS,ST_TEXT
sBegin	ST_TEXT
	SUBTTL	convert the number into a formatted ASCII string
	page

;***[1]
;B$PUFOUT -- convert the number into a formatted ASCII string according to
;		b$PUFLG
;Purpose:
;	PRINT USING output formatter.
;
;	Note: can't assume ES=DS
;Entry:
;	[BX] = *I2, *I4, *R4 or *R8
;	[b$DIGCNT+1] = field width to left of decimal point
;	[b$DIGCNT] = field width to right & including decimal point
;	[b$PUFLG] = Formatting flags (see equates above)
;	[b$VTYP] = Type of number
;Exit:
;	[SI] = Address of first character of formatted output
;	[AX] = Count of characters (not including terminating zero)
;Uses:
;	DI
;Exceptions:
;	none
;*******************************************************************************

cProc	B$PUFOUT,<PUBLIC,NEAR>,<ES>	;save ES
localW	EXP			
localW	RestartEXP		; value of DX from B$CONASC if we need to
				; restart the conversion.
cBegin
	PUSH	DS		
	POP	ES		; can't assume ES=DS, set them equal
	MOV	AL,[b$VTYP]	
	CBW			; convert to word for use as count
	MOV	DI,OFFSET DGROUP:B$AC 
	CMP	AL,VT_I2	
	JZ	PUFOUT_I2	
	AND	AX,0FH		; Number of bytes to move

	ADD	DI,4		;[ ]
	SUB	DI,AX		; AC or DAC
PUFOUT_I2:			
	MOV	SI,BX		
	XCHG	AX,CX		
	SHR	CX,1		; Count of words
	REP	MOVSW		
	CALL	B$CONASC	; Convert to ASCII digits

	MOV	RestartEXP,DX	; save DX if we need to jump to PUFOUT

; Number has been converted to ASCII and is sitting at buffer pointed
;	to by DI.
;	SI = address of result buffer
;	CX = number of significant figures
;	DX = base 10 exponent of the right end of the digit string.

PUFOUT:
DbAssertRel	DX,e,RestartEXP,ST_TEXT,<B$PUFOUT:Exponent not restored>

	XOR	BX,BX		;No position-eating symbols yet
	MOV	AL,BYTE PTR [b$PUFLG]	; Get PRINT USING flags
	TEST	AL,DOLLARBIT	;Need floating dollar sign?
	JZ	NODOL
	INC	BX		;Chalk up a position for the "$"
NODOL:
	CMP	[b$SIGN],"-"	; Is number negative?
	JZ	HAVSGN		;If so, leave sign alone
	TEST	AL,PLUSBIT	;Do we force "+"?
	JZ	NOSGN		;No - leave it a blank
	MOV	[b$SIGN],"+"	
HAVSGN:
	TEST	AL,TRAILING	;Is it in front, eating a digit position?
	JNZ	NOSGN
	INC	BH		;Count one position for the sign
NOSGN:
	TEST	AL,SCIBIT	;Scientific notation?
	JNZ	SCILEN
	ADD	BL,BH		;Sum positions needed for sign and "$"
	MOV	AX,DX		; Power of 10 of digit string
	ADD	AX,CX		; Plus count of digits gives number of digits
				;to left of decimal point
				;This is assuming the number would be printed
				;in the form 0.xxxxx   where xxxx are the digits
				;In actuality, we need to print in the form
				; (INTDIG).(DECDIG-1), possibly with exponents,
				;commas, etc.

	DEC	[DECDIG]	; Number of digits requested to right of d.p.
	JL	ROUND		; Any decimal digits?
	ADD	AL,[DECDIG]	; Add to count of digits needed
	ADC	AH,0		
ROUND:
	INC	[DECDIG]	; Restore
	MOV	DI,OFFSET DGROUP:b$FOBUF ;In case B$ASCRND not called
	OR	AX,AX		
	JL	NOROUND 	;Don't ask for negative digits
	CALL	B$ASCRND	; Round ASCII digits
NOROUND:
	CMP	BYTE PTR [SI],"0" ;Is number zero?
	JNZ	NOTZERO
	MOV	DX,-1		; If so, set exponent to no integer part
NOTZERO:
	MOV	AX,CX		;Number of digits in number now
	ADD	AX,DX		; New count of integer digits

	MOV	DH,AL		;Save it for output loop
	MOV	AH,0
	JG	COMCHK		;If we have integer digits, do comma check
	MOV	AL,0		;No integer digits
	JMP	SHORT GETFILL

SCILEN:
;Compute digit counts and round for scientific notation
	MOV	AL,[INTDIG]
	SUB	AL,BL		;Count a digit position if "$" needed
	ADD	BL,BH		;Sum positions needed for "$" and sign
	TEST	[b$PUFLG],TRAILING ; test if trailing sign
	JNZ	SCI1		;if so, no sign in front
	DEC	AL		;Always take one for the sign
	JNS	SCI1		;If there's room, that is
	XOR	AL,AL
SCI1:
	MOV	BH,AL		;Save count of digits to left of d.p.
	MOV	AL,[DECDIG]
	DEC	AL		;Count one position for d.p. itself
	JNS	SCI2
	XOR	AL,AL
SCI2:
	ADD	AL,BH		;Sum total digits needed
	JG	SCI3		;Need at least one
	INC	AX		;Request one digit
	INC	BH		;And print it to left of d.p.
SCI3:
	CALL	B$ASCRND	; Round to correct number of digits
	CMP	BYTE PTR [SI],"0" ;Is result zero?
	JNZ	FIGEXP		;If not, we're OK - go figure exponent
	XOR	AL,AL		;Set exponent to zero
	OR	BH,BH		;Print digits to left of d.p.?
	JZ	SAVEXP		;If not, that's O.K.
	MOV	BH,1		;If so, print at most 1
FIGEXP:
	MOV	AX,CX
	ADD	AX,DX		; AX = Number of integer digits
	SUB	AL,BH		;Subtract number to be printed left of d.p.
	SBB	AH,0		
SAVEXP:
	MOV	[EXP],AX	;Exponent to be printed later
	MOV	AL,BH		;Set up digit count
	MOV	DH,BH
	JMP	SHORT GETFILL

COMCHK:
	TEST	[b$PUFLG],COMMABIT ; Need commas?
	JZ	GETFILL

;Perform comma computation. We need a comma every 3 digits, so we'll divide
;the number of digits by 3 to see how many we need. Since we don't need the
;first comma until we have 4 digits, the digit count is decremented before
;the division. The remainder of the division represents the number of digits
;to print before the first comma is needed.

	DEC	AX
	MOV	BH,3
	DIV	BH		;AL=number of commas
	ADD	AL,DH		;Add up number of positions needed
	INC	AH		;Adjust delay to first comma to range 1-3

;Let's see if all this stuff will fit. If so, compute amount of extra room
;for leading filler. Otherwise, print a "%".

GETFILL:
	TEST	[b$PUFLG],2	; Already had field overflow?
	JZ	FITCHK
	MOV	BYTE PTR [DI],"%"
	INC	DI
FITCHK:
	ADD	AL,BL		;Add digits needed by "$" and sign
	SUB	AL,[INTDIG]	;Do we have enough room?
	JBE	FILCNT		;AL is negative of amount of extra room
	CMP	AL,4		;Exceeding width by more that 4?
	JBE	OVERFIELD
	OR	[b$PUFLG],SCIBIT+2
				; scientific notation and field overflow

	MOV	DX,RestartEXP	; restore DX to proper value
	JMP	PUFOUT		;Try again
OVERFIELD:
	MOV	AL,"%"		;Didn't fit - print field overflow character
	STOSB
	XOR	AL,AL		;Zero fill count

;Leading-fill field with blanks or "*"s as requested

FILCNT:
	MOV	DL,AH		;Save delay to first comma (zero if no commas)
	JZ	GETCNT		;Any filling necessary?
	OR	DH,DH		;And do we have integer digits to print?
	JG	GETCNT		;If not, we'll add a leading zero
	INC	AL		;Make room by reducing fill count
	INC	CH		;Set leading zero flag
GETCNT:
	NEG	AL		;Make fill count positive
	CBW
	XCHG	AX,CX		;Put count in CX
	XCHG	AX,BX		;Save digit count (from CX) in BX
	MOV	AL," "		;Fill character
	MOV	AH,BYTE PTR [b$PUFLG]	; Get flag byte
	TEST	AH,STARBIT	;Fill with "*" instead?
	JZ	FILL
	MOV	AL,"*"
FILL:
	REP	STOSB		;Leading fill

;Print leading sign, if needed

	TEST	AH,TRAILING	;Leading or trailing sign?
	JNZ	DOLLARCHK
	MOV	AL,[b$SIGN]	; Pick up leading sign
	CMP	AL," "		;If blank, already counted in fill count
	JZ	DOLLARCHK
	STOSB			;Store sign

;Print floating "$" if requested

DOLLARCHK:
	TEST	AH,DOLLARBIT	;Floating "$"
	JZ	NODOLLAR
	MOV	AL,CURNCY
	STOSB
NODOLLAR:

;Copy integer digits, if any

	MOV	CL,DH		;Count of digits to left of d.p.
	NEG	DH		;Count of zeros to fill after d.p.
	JL	NOCOM		;Don't check for comma first time through
	DEC	BH		;Force leading zero?
	JNZ	DPCHK
	MOV	AL,"0"
	STOSB
	JMP	SHORT DPCHK

INTDIGITS:
	DEC	DL		;Need a comma yet?
	JNZ	NOCOM
	MOV	AL,","
	STOSB
	MOV	DL,3		;Reset comma count down
NOCOM:
	MOV	AL,"0"		;In case we're out of digits, use trailing "0"
	DEC	BL		;Any digits left?
	JS	STOINTDIG	;No - go store trailing zero
	LODSB			;Yes - get next digit
STOINTDIG:
	STOSB
	LOOP	INTDIGITS

;Check for fraction part and print decimal point if so

DPCHK:
	MOV	CL,[DECDIG]	;Number of digits to right of d.p.
	DEC	CX		;Count off decimal point itself
	JS	SCICHK		;No decimal point?
	MOV	AL,"."
	STOSB
	JZ	SCICHK		;A d.p., but no decimal digits?

;Print the zeros, if any, between after the decimal point but before the MSD

	OR	DH,DH		;Any fill zeros after d.p.?
	JLE	MOVFRAC
	MOV	AL,"0"
AFTDP:
	STOSB
	DEC	DH		;Limit to fill count
	LOOPNZ	AFTDP		;Limit to field width

;Print the fraction digits, if any

MOVFRAC:
	JCXZ	SCICHK		;Filled out field width?
	OR	BL,BL		;Any digits left?
	JLE	POSTFILL
MOVDECDIG:
	MOVSB			;Copy a digit
	DEC	BL		;Limit to digits available
	LOOPNZ	MOVDECDIG	;Limit to field width

;Fill out the field with zeros

POSTFILL:
	MOV	AL,"0"
	REP	STOSB		;Force fill with zeros

;Print exponent if in scientific notation

SCICHK:
	TEST	AH,SCIBIT	;Scientfic notation?
	JZ	SIGNCHK

	PUSH	AX		;Save flags from AH
	MOV	AX,"+E"
	CMP	[b$VTYP],VT_R8	; Is it double precision?
	JNZ	SCISNGL
	DEC	AX		; Convert "E" to "D"
SCISNGL:
	MOV	BX,[EXP]	; Get exponent
	OR	BX,BX		
	JNS	EXPSGN
	NEG	BX		;Get magnitude of exponent
	MOV	AH,"-"		;Display sign
EXPSGN:
	STOSW
	XCHG	AX,BX		; [AX] = exponent
	MOV	BL,100		
	DIV	BL		; [AL] = exp div 100, [AH] = exp mod 100
	TEST	BYTE PTR [b$PUFLG+1],BIGSCI	; see if 3 digit desired
	JZ	NOT_3DIGIT	; jump if not
	OR	AL,"0"		; ascii'ize the digit to be stored
	STOSB			; Put the high order digit in.
	XOR	AL,AL		; so test below will pass
NOT_3DIGIT:			
	OR	AL,AL		; set flags NZ if exp >= 100
	PUSHF			
	XCHG	AL,AH		; AL = exp mod 100
	AAM			;Convert exponent to unpacked BCD
	OR	AX,"00" 	;Add ASCII bias
	POPF			; get result of that compare again
	JZ	NO_EXP_OVERFLOW ; jump if not
	MOV	AH,"%"		; else replace with overflow char
NO_EXP_OVERFLOW:		
	XCHG	AL,AH		;MSD in AL
	STOSW			;Save both digits at once
	POP	AX		;Restore flags to AH

;Print trailing sign if needed

SIGNCHK:
	TEST	AH,TRAILING	;AH still has flags
	JZ	ENDNUM		;Need a trailing sign?
	MOV	AL,[b$SIGN]	
	STOSB

;Finish up with trailing 00 and compute line length

ENDNUM:
	MOV	BYTE PTR[DI],0	;Terminating zero
	MOV	SI,OFFSET DGROUP:b$FOBUF 
	XCHG	AX,DI
	SUB	AX,SI		;Length of string
cEnd				;pop ES, and exit to caller

;
; Added with revision [9]
;
;***
;B$CONASC - Convert number to ASCII
;
;Purpose:
;	Convert number to a string of ASCII digits with no leading or
;	trailing zeros. Return base 10 exponent and count of digits.
;
;Inputs:
;	B$AC has SP number OR B$DAC has DP or CY number
;	b$VTYP has type
;	No integer values will be passed to this routine.
;
;Outputs:
;	CX = number of significant figures (decimal point to right)
;	DL = base 10 exponent
;	SI = Address of first digit (non-zero unless number is zero)
;	[b$SIGN] has sign - blank if positive, "-" if negative
;
;Registers:
;	Uses all.
;****

cProc	B$CONASC,<NEAR> 	;NOTE: Prolog doesn't put anything on stack
cBegin
	MOV	CL,b$VTYP	;get val typ in CX
	CMP	CL,VT_I2	;We only handle I2 and I4
	JE	GotNum
	CMP	CL,VT_I4
	JNE	FloatingCONASC	;Do the floating point variety
GotNum:
	MOV	BX,OFFSET DGROUP:B$AC ;Get pointer to number
	CALL	B$FOUTBX	;And convert it to a string
	MOV	SI,BX		;We want to return the string in SI
	MOV	CX,AX		;CX = Length of string
	LODSB			;Get the sign
	MOV	b$Sign,AL	;And store it for later use
	XOR	DL,DL		;No base 10 exponent (a simplification)
	DEC	CX		;Don't count the sign
cEnd

FloatingCONASC:
	JMP	B$FloatCONASC	;Call the routine directly

sEnd	ST_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\rlset.asm ===
TITLE	RLSET - RSET and LSET statements
	PAGE	56,132
;***
; RLSET - RSET and LSET statements
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - LSET Statement:
;
;      LSET stringvar = x$
;	 |
;      B$LSET
;
; - RSET Statement:
;
;      RSET stringvar = x$
;	 |
;      B$RSET
;
;******************************************************************************
	INCLUDE switch.inc	
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	DK_TEXT 	

	INCLUDE seg.inc 	

assumes CS,DK_TEXT		
sBegin	DK_TEXT 		

	externNP B$STDALCTMP	

	SUBTTL	B$RSET, B$LSET - RSET and LSET statements
	PAGE
;***
; B$RSET, B$LSET - RSET and LSET statements
;
;Function:
; Copy source to destination. If destination is larger than source,
; pad with blanks. RSET has leading blanks, LSET trailing blanks.
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Inputs:
; psdSource	= Address of source string descriptor
; pDest 	= far address of destination
; cbDest	= length of destination foixed length string, or 0 if sd
;
;Outputs:
; None.
;
;Registers:
; per convention
;
;******************************************************************************
cProc	B$RSET,<PUBLIC,FAR>,<ES,SI,DI> 
parmW	psdSource		
parmD	psdDest 		
parmW	cbDest			; length of destination string
cBegin				
	CALL	PREP		;Set up registers (source in SI, dest in DI)
	PUSH	AX		;Save count of characters to copy
	XCHG	AX,DX		;put blanks in AX
	REP	STOSW
	JNC	SKPSTO		;See if we need an odd number
	STOSB			;Put in that last blank
SKPSTO:
	POP	CX		;Count of characters to copy
	REP	MOVSB		;Must move bytes for case source=dest
POPSET:
	CALL	B$STDALCTMP	;Delete source if a temp
cEnd				

cProc	B$LSET,<PUBLIC,FAR>,<ES,SI,DI> 
parmW	psdSource		
parmD	psdDest 		
parmW	cbDest			; length of destination string
cBegin				
	CALL	PREP
	XCHG	AX,CX		;Get move count in CX - save fill in AX
	REP	MOVSB		;Must use bytes for case source = dest
	XCHG	CX,AX		;Get count of blanks to fill in CX
	XCHG	AX,DX		;put blanks in AX
	REP	STOSW
	JNC	POPSET		;See if an odd count
	STOSB			;Do that last byte
	JMP	SHORT POPSET	
cEnd	<nogen>


;***
;PREP - sets up registers for RSET and LSET
;
;Purpose:
; This routine sets up the registers for LSET and RSET.
;
;Entry:
; psdSource = Source string descriptor
; pDest     = Destination
; cbDest    = length of destination (0 if sd)
;
;Exit:
; [AX]	  = Number of byte to move from source to dest.
; [BX]	  = offset of source string descriptor
; [CX]	  = Number of blanks to pad (in words,zero if source size > dest size)
; [DX]	  = "  " 2 spaces for blank filling
; [ES:DI] = Destination data address
; [SI]	  = Source DS offset
;
;Uses:
; eveything it returns
;
;******************************************************************************
cProc	PREP,<NEAR>
cBegin

psdSource  equ word ptr [bp+12] 
pDest	   equ dword ptr [bp+8]  
cbDest	   equ word ptr [bp+6]	

	MOV	SI,psdSource	;get source sd
	PUSH	SI		; save it for later
	LODSW			;Get size of source string
	MOV	SI,[SI] 	;Get source data address (LODSW added 2 to SI)

	LES	DI,pDest	; [ES:DI] = address of dest data or sd
	MOV	CX,cbDest	; Get size of dest string
	OR	CX,CX		; if non-zer, we have what we need
	JNZ	PREP_5		; jump if ready
	MOV	CX,[DI] 	; else get size of variable length string
	MOV	DI,[DI+2]	; and ds offset (es assummed == ds)
PREP_5:
	SUB	CX,AX		;Number of blanks to pad with (dest - source)
	JAE	RETL		;If not negative, we're done
	ADD	AX,CX		;Set move count to size of dest string
	XOR	CX,CX		;Set blank fill to zero
RETL:				
	SHR	CX,1		;Make byte count a word count
	MOV	DX,"  " 	;2 blanks at a time
	POP	BX		; [BX] = source sd
cEnd				

sEnd	DK_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\rtinit.asm ===
TITLE	RTINIT - Initialization module for BASIC runtime
;***
;RTINIT.ASM - Initialization module for BASIC runtime
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains the main entry point and initialization
;	routines for the BASIC 3.0 runtime.  The runtime is designed
;	to achieve modularity and granularity between components of
;	the runtime.  Detailed documentation about the structure of the
;	runtime is presented below.
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - DEF SEG Statement - calls B$DSG0 if no parm, B$DSEG if segment addr given:
;
;      DEF SEG [ = seg]
;
;    Examples:
;
;      DEF SEG				       DEF SEG = 3000
;      -------				       --------------
;	  |					      |
;	B$DSG0					    B$DSEG
;
;******************************************************************************

	INCLUDE switch.inc	;assembly switch file
	INCLUDE rmacros.inc	;segment/C macros

;
;	Code Segments
;
	USESEG	<RT_TEXT>	;runtime core segment
	USESEG	<FH_TEXT>	;far heap segment
	USESEG	<NH_TEXT>	;near heap segment
	USESEG	<DV_TEXT>	;device segment
	USESEG	<INIT_CODE>	;initialization
	USESEG	_TEXT		; c
;
;	Data Segments
;
	USESEG	<NULL>		;BegData

	USESEG	<BR_DATA>	;Hole for runtime module
	USESEG	<_DATA> 	;runtime data (initialized)
	USESEG	<_BSS>		;runtime data (uninitialized)

	USESEG	<NMALLOC>
	USESEG	<ENMALLOC>
	USESEG	<XIB>		;beginning of C initializers
	USESEG	<XI>		;C initializers
	USESEG	<XIE>		;end of C initializers
	USESEG	<BC_DATA>	;users variables
	USESEG	<BC_FT> 	;end of users variables
	USESEG	<BC_SAB>	;beginning of user module start address table
	USESEG	<BC_SA> 	;user module start address table

	INCLUDE seg.inc 	;segment definitions
	INCLUDE compvect.inc	;component vector structures
	INCLUDE fdb.inc		
	INCLUDE const.inc	; bit flag constants
	INCLUDE stack2.inc	; stack related constants
	INCLUDE stack.inc	
	INCLUDE string.inc	

;bring in our versions of C runtime routines.

	externFP __chkstk	; drag in CHKSTK


	externFP __exit 	
	externFP __ctermsub	
	externB	_end		
	externFP _exit		; C _exit proc




	externFP B$ULtoRTFar	;UL to RT far call helper
	externFP B$ULtoRTNear	;UL to RT near call helper

	externFP fEditorActive	

sBegin	NULL			
	INCLUDE global.inc	;global data definitions
sEnd	NULL			




	INCLUDE addr.inc	;compiled module header structure
	INCLUDE idmac.inc	; internal debug macros
	INCLUDE ibmunv.inc	

	INITIALIZER	B$xRTINI	;Put B$xRTINI in initializer list

	SUBTTL	Runtime design
	PAGE
;*****************************************************************************
;*		BASCOM 3.0 and Quick BASIC Interpreter 3.0
;*
;*	The runtime system has been reworked considerably since BASCOM 2.0.
;*	The major goals which prompted the revision of the runtime are
;*	numerous.  A major deficiency in the BASIC language to this point
;*	has been the lack of a truly compatable compiler/interpreter pair.
;*	In order to resolve this deficiency, the BASIC 3.0 runtime
;*	will attempt to achieve this goal without compromising size and
;*	speed goals of either the interpreter or the compiler.
;*
;*	Another major reason for reworking the runtime is to provide support
;*	for the OS/2 environment.  The runtime has been enhanced to
;*	take advantage of new features provided by the DOS.  In addition to
;*	the support of new features. Some existing features have been
;*	reworked to execute under the constraints of OS/2, while still
;*	supporting previous versions of DOS.
;*
;*	There have been several new language enhancements made which
;*	the runtime has been modified to support.  Such items as 4 byte
;*	integers, EGA support, and Advanced 101-key Keyboard support have
;*	been added to the runtime.
;*
;*	The runtime has also been reworked to improve its granularity
;*	through a series of techniques to segment and conditionally
;*	initialize components of the runtime system.
;*****************************************************************************

	SUBTTL	Runtime components, segmentation, and granularity
	PAGE
;*****************************************************************************
;*		Segmentation and Granularity
;*
;*	The initialization and segmentation schemes used by the runtime
;*	attempt to view the runtime as a collection of individual components
;*	which are unique and independent of each other.  The intent is that
;*	a compiled basic module should have the minimal amount of runtime
;*	code present to correctly complete its assigned task.  There are
;*	two major ways to achieve this goal: 1) conditional initialization
;*	of components on an as needed basis and 2) segmentation of compon-
;*	ents, therby allowing the operating system to swap out unused segments
;*	through an LRU mechanism.  We have combined both of these techniques
;*	to produce what we hope is the best of both worlds.
;*
;*
;*	The common runtime is organized into several components, as follows:
;*
;*	Code	Contents
;*	------	---------------------------------------------------------------
;*	CN:	Screen and Keyboard text I/O.
;*	DB:	User debug code /D.
;*	DK:	Disk file related I/O.
;*	DV:	Device Independant IO support.
;*	ER:	Error handling & trapping.
;*	EV:	Event trapping.
;*	FH:	Far heap manager.
;*	GR:	Graphics.
;*	ID:	Internal (development) debugging aids.
;*	MT:	Floating point math.
;*	NH:	Near heap manager.
;*	OI:	Comm/Printer I/O.
;*	OS:	Operating System functions & features.
;*	RT:	Runtime core.
;*	SN:	Sound and music.
;*	ST:	String package.
;*
;*	Each component is further divided into 6 areas, which may or may not
;*	be present for each component:
;*
;*	Initializer	- Updates core dispatch tables for ordered
;*			  initialization, termination, and indirect dispatches.
;*	Initialization	- Component-specific initialization.
;*	Termination	- Component-specific termination.
;*	Dispatch	- Dispatch tables used for indirect access to routines
;*			  within the component which may not always be present.
;*	Core Code	- Code which must always be present for the component.
;*	Component Code	- Code which is present on an as needed basis.
;*
;*	Each component may be contained in its own physical segment, or
;*	combined with other components into common segments. Throughout the
;*	runtime source code, each component is placed in a segment with a
;*	unique logical name. The global segment definitions control the
;*	actual physical segment names used.
;*
;*	In order to minimize the size of user programs, portions of each
;*	component, or the entire component itself, may be optional and
;*	linked/loaded only if referenced by the user program. An "optional
;*	initialization" mechanism is used to initialize components which
;*	require initialization only if they are present. In some cases stubs
;*	or crippled versions of some component routines may be required, even
;*	when the complete component is not present. In these cases indirect
;*	calls are used. The target of the call defaults to the stub, or is
;*	updated as appropriate by the component initialization routine.
;*
;*	If a component needs specialized initialization then this is done
;*	in an ordered manner through indirect dispatches performed on an
;*	as needed basis. This is done by defining far pointers to initializers
;*	in a special segment (XI) which is known to the startup.  When a
;*	module containing the pointer to the initializer gets linked into
;*	the exe file, the pointer to the initializer also gets appended to
;*	the XI segment.  The startup will then indirectly call each routine
;*	which has a pointer in the XI segment before _main is called.  The
;*	initializers for the runtime do not actually initialize the individual
;*	components.  Instead they change a pointer in an initialization vector
;*	to the real initialization routine for the component.  This mechanism
;*	allows the runtime to initialize its components in a well defined
;*	order when _main gets called.  If a component needs specialized
;*	termination then its initializer should also place a pointer to
;*	the termination routine in the termination vector (analogous to
;*	the initialization vector).  When the runtime terminates it will
;*	indirectly call all routines in the termination vector.
;*
;*	Access between some components should be done through
;*	indirect calls.  An example of this would be the
;*	floating input processor FIN.  FIN can handle ints, longs, sp
;*	and dp numbers.  You shouldn't need to load the floating point
;*	math pack if you want to call FIN with an integer.  This can
;*	be accomplished by indirectly calling FIN through a pointer.
;*	If the floating math pack is not loaded then the routine
;*	pointed to by the fin ptr only understands ints and longs.
;*	If the math pack is loaded then the math pack initializer
;*	will change the fin ptr to point to a fin routine which
;*	understands all numeric types.	This type of indirection
;*	can greatly improve the granularity of the runtime.
;*
;*	In addition each component can be composed of other components
;*	(sub components).  With the definition of what a component is
;*	we can come up with a suggested module naming convention.  A
;*	module can be named as follows:
;*
;*		xx(yy)zzzz.ext
;*	where
;*		xx	- is abbreviation of major component (as listed above).
;*		yy	- is the optional abbreviation of a subcomponent such
;*			  as: HL for high level, LL for low level, etc.
;*		zzzz	- description of modules action such as: init, data,
;*			  term, disp, etc.
;*		ext	- is extension for file .asm .c .h .inc .doc etc.
;******************************************************************************

	SUBTTL	Runtime memory maps for BASIC 3.0
	PAGE
;==============================================================================
;
;					      HIGH MEMORY
; Top of MEMORY ----------------------> +-----------------------+
;					| QuickLIB symbols	|
;					| QuickLIB code 	|
;					+-----------------------+
;					|			|
;					| Far heap entries and	|
;					| free space for Huge	|
;					| Numeric arrays Comm	|
;					| buffers and interp	|
; 64k DGROUP boundary ----------+	| tables		|
; b$dynamic_end ----------------+-----> +-----------------------+ LH grows down
;					| Local Heap Space	| -------------
;					|			|	|
;					| contains FDBs 	|	|
;					| Dynamic String Array	|	|
;					| entries and interp	|	|
; flexible boundary between the 	| tables		|	v
; Local Heap and String Space	------> |/\/\/\/\/\/\/\/\/\/\/\/|	-
;					| String Heap Space	|	^
;					|			|	|
;					| contains string	|	|
;					| entries		|------------
;					|			| SS grows up
; b$dynamic_start --------------------> +-----------------------+
; __atopsp ---------------------------> | STACK (class STACK)	| Stack grows
;					|			| down
;					|			| -----------
;					|\/\/\/\/\/\/\/\/\/\/\/\|	|
;					|			|	|
;					|			|	v
; _end -------------------------------> +-----------------------+
;			+-------------> | BC_SA (class BC_SEGS) |
;			|		+-----------------------+
;			|		| BC_SAB (class BC_SEGS)|
;			|		+-----------------------+
;			|		| BC_DS (class BC_SEGS) |
;			|		+-----------------------+
; BASIC program data ---+		| BC_CN (class BC_SEGS) |
;			|		+-----------------------+
;			|		| BC_FT (class BC_SEGS) |
;			|		+-----------------------+
;			+-------------> | BC_DATA (BC_DATA)	|
;					+-----------------------+
;			+-------------> | XCE (class DATA)	|
;			|		+-----------------------+
;			|		| XC (class DATA)	|
;			|		+-----------------------+
;			|		| XCB (class DATA)	|
;			|		+-----------------------+
;			|		| XPE (class DATA)	|
;			|		+-----------------------+
; Initializers ---------+		| XP (class DATA)	|
; and terminators	|		+-----------------------+
;			|		| XPB (class DATA)	|
;			|		+-----------------------+
;			|		| XIE (class DATA)	|
;			|		+-----------------------+
;			|		| XI (class DATA)	|
;			|		+-----------------------+
;			+-------------> | XIB (class DATA)	|
;					+-----------------------+
;					| CDATA (class DATA)	|
; b$common_end -----------------------> +-----------------------+
;					| COMMON (class BLANK)	| <-+preserved
;					+-----------------------+   |
; Soft key string descriptors --------> | BR_SKYS (class BLANK) | --+
; b$common_start ---------------------> +-----------------------+ across chain
; Uninitialized runtime data ---------> | _BSS (class DATA)	|
;					+-----------------------+
; BASIC runtime data (initialized) ---> | _DATA (class DATA)	|
;					+-----------------------+
; BASIC constants --------------------> | CONST (class DATA)	|
;					+-----------------------+
;					| NULL (class BEGDATA)	|
; Beginning of DGROUP ----------------> +-----------------------+
;					| C_ETEXT(class ENDCODE)|
;					+-----------------------+
; BASIC runtime init code ------------> | INIT_CODE(INIT_CODE)	|
;					+-----------------------+
; FAR BASIC runtime code -------------> | *_TEXT (class CODE)	|
;					+-----------------------+
; BASIC runtime code	--------------> | CODE	(class CODE)	|
;					+-----------------------+
; Interpreter code	--------------> | _TEXT (class CODE)	|
;					+-----------------------+
;
;					       LOW MEMORY
;
; _end		- last word of useable stack space.
; __atopsp	- points to first useable word of stack space.
; The BP register is assumed to point to a valid stack frame upon
; entry to the runtime.
;
; b$dynamic_start - points to the first useable word of dynamic space.
; b$dynamic_end   - points to the last useable word of dynamic space.
; NOTE:
;    1) b$dynamic_start and b$dynamic_end are shadow values for dynamic space.
;	the real heap management variables are internal to nh*.asm.
;    2) For OS/2 the above segments may be in any physical order (except
;	for DGROUP).  No assumptions can be made about selectors and the
;	address correlation with physical memory.
;    3) The segments CONST, _DATA, _BSS, and BR_SKYS are aliased by BR_DATA
;	in user programs using the common runtime module.  BR_DATA is filled
;	with blank storage and overlayed by the runtime module during RTM
;	initialization.
;=============================================================================
	SUBTTL Component Initialization and Termination
	PAGE
;******************************************************************************
;	There are several classes of initialization and termination for
;	the runtime.  There is "ONE time" intialization/termination,
;	"RUN/END time" initialization/termination, and
;	initialization/termination actions that take place during
;	"SHELL", "CHAIN", "CLEAR", and "NEW" (QB4 only).
;
;	"ONE time" initialization occurs once when the system is initialized.
;	"RUN time" initialization takes place whenever a program
;	is restarted (RUN, LOAD, NEW).	The other functions occur
;	whenever a "SHELL", "CHAIN", or "CLEAR" statement is executed.
;
;	"One time" termination occurs once when the system is terminated.
;	For the interpreter this occurs when a SYSTEM statement is
;	executed.  For the compiler this happens whenever an END, SYSTEM,
;	Cntrl-Break, end of module, RUN "filename", or CHAIN "filename"
;	(non DOS 3 runtime module) is executed.  The compiler RUN/CHAIN
;	case is somewhat special since we aren't actually returning
;	to the OS.  However, the actions taken are identical to terminating
;	to the OS except that another program is started.  The new program
;	will reinitialize the whole runtime system as if it were started
;	from the DOS command line.
;
;	"END time" termination is specific to the interpreter.	The only
;	thing that happens here is that all files and devices are closed.
;	This will only occur when the interpreter executes an END statement.
;
;	"CHAIN time" and "SHELL time" termination occur whenever a
;	CHAIN (only applicable for interpreter and DOS 3 runtime module
;	for the compiler) or SHELL statement is executed.
;
;	Initialization/termination of each runtime component may need to
;	take specific actions based on the context of the execution
;	environment (compiled or interpreted), the product (QB4, BC3),
;	the DOS (3,5), and (for the compiler) the runtime environment (/O,
;	runtime module).
;******************************************************************************

	SUBTTL C runtime CRT0 support for BASIC runtime
	PAGE
;******************************************************************************
;	Assumptions the runtime makes about startup.
;
;	The runtime assumes that crt0 provides the following
;	initialization support for us:
;		all initializers in XI are called before _main
;		DS, ES, SS are set up to DGROUP
;		__osversion is a word containing DOS major and
;			minor version numbers.
;		__osfile[] is a static array of system file handles
;			which can be checked against 40H to determine
;			if redirection has occurred.
;		__psp contains the PSP segment value
;		__aenvseg contains selector to environment segment for OS/2
;		__psp:[2C] contains environment segment for non-OS/2.
;		_end points to last useable word of STACK
;		__atopsp points to first useable word of stack
;
;	__osversion is a word containing the DOS major and minor
;	version numbers.  The version is stored as MinMaj in
;	a decimal value.  For example DOS 5.00 is 0005H, DOS 2.10
;	is 0A02H etc.
;
;	To determine if input and/or output is redirected,
;	check the file handle in the __osfile[] array against
;	40H (bit 6).  If bit 6 is clear then there is redirection.
;	__osfile[] is a static array of file handles managed by C.
;	__osfile[0] is stdin, __osfile[1] is stdout, etc.
;	NOTE: this is valid for DOS 3, but C is uncertain if this
;	will stay this way for OS/2.
;
;******************************************************************************

	SUBTTL	Code Externals
	PAGE

sBegin	DV_TEXT 			
	externNP	B$IOCLOS	;to de-install interrupt vectors
	externNP	B$IOINI 	;to install interrupt vectors
	externNP	B$NearRet	
sEnd	DV_TEXT 			

	externFP	__fpreset	; floating point reset
	externFP	B$ERR_LLI	; low-level init error
	externFP	B$ERR_DOS	; bad DOS version error




sBegin	FH_TEXT 			
	externNP	B$FHClear	;cleans far heap
sEnd	FH_TEXT 			

sBegin	NH_TEXT 			
	externNP	B$NHCLR 	;cleans near heap
sEnd	NH_TEXT 			

	externFP	B$ULInit	;calls UL "C" initializers
	externFP	B$SETM		; SETMEM function
 	externFP	B$RTMInstall	;install the RTM interrupt vector


	externFP	B$?EVT 		; event initialization



sBegin	RT_TEXT
	externFP	B$GWINI		;Low level initialization
	externNP	B$CNINI 	;drag in console io
	externNP	B$RTLLINI	; Low Level one time core init


externNP B$LHClearRange			; Clear local heap
externNP B$SSClearRange			; Clear string space
externNP B$FHClearRange			; Clear far heap
externNP B$TglHeapSptNEAR		; Toggle to/from var heap support

	externNP	B$DONOTE	;turns off sound for QBI CHAIN


sEnd	RT_TEXT

	SUBTTL	Runtime data definitions for BASIC Runtime Core
	PAGE


sBegin	_BSS
	globalW b$UcodeOff,?		;offset to user code module header
	globalW b$UcodeSeg,?		;segment of user code module

LabelW	<PUBLIC,b_cbComBuffer>	;Interpreter reachable symbol
	globalW b$cbComBuffer,? ;combuffer size specified on QB command line

	externW b$STRTAB 		;Beginning of soft key table

	globalB b$fRTInit,?		;TRUE if RT initialization complete

sEnd	_BSS

sBegin	_DATA

;
;	Global data
;
	EVEN				;insure disp vectors are word aligned

	PUBLIC	b$ini_disp
	PUBLIC	b$term_disp
	PUBLIC	b$run_disp
	PUBLIC	b$end_disp
	PUBLIC	b$clrt_disp		
	PUBLIC	b$clr_disp
	PUBLIC	b$shli_disp
	PUBLIC	b$shlt_disp
	PUBLIC	b$err_disp		

b$ini_disp	INIT_VECTORS	<>	;One time initialization dispatch table
b$term_disp	TERM_VECTORS	<>	;One time termination dispatch table
b$run_disp	RUN_VECTORS	<>	;"RUN" initialization dispatch table
b$end_disp	END_VECTORS	<>	;"END" termination dispatch table
b$clrt_disp	CLRT_VECTORS	<>	; CLEAR "termination" dispatch table
b$clr_disp	CLR_VECTORS	<>	;CLEAR statement dispatch table
b$shli_disp	SHLI_VECTORS	<>	;SHELL re-initialization dispatch table
b$shlt_disp	SHLT_VECTORS	<>	;SHELL "termination" dispatch table
b$err_disp	ERROR_VECTORS	<>	; error vectors

	globalW b$commonfirst,0		;first word of COMMON block
	globalW b$commonlast,0 		;last word of COMMON block
					;output is also sent to lpt.

	PUBLIC	b$fCompErr		
b$fCompErr = OFFSET DGROUP:b$errmod+2	;seg of errmod 0 if interp error
	PUBLIC	b_fCompErr		;Interpeter reachable symbol
b_fCompErr = b$fCompErr 		;Interpeter reachable symbol

sEnd	_DATA


sBegin	NMALLOC 		
	DB	NMALLOC_MIN DUP(?) ; Default malloc buffer - room
sEnd	NMALLOC 		; for header.


	SUBTTL	Runtime Core Initializer
	PAGE
assumes CS,INIT_CODE
sBegin	INIT_CODE

;***
;B$xRTINI - Initializer for the runtime core.
;PLM B$xRTINI()
;
;Purpose:
;	This is the initializer for the BASIC runtime core.  It is placed
;	in the same module as _main so that it is guaranteed to always
;	be present at initialization time.  It's sole responsiblility
;	is to update the initialization and termination dispatch vectors
;	to include the true initialization and termination entry points
;	for the runtime core.
;
;Entry:
;	None.
;
;Exit:
;	Appropriate dispatch vectors filled.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xRTINI,<FAR>
cBegin
;
;	update "ONE" time initialization dispatch address to B$RTINI
;
	MOV	WORD PTR [b$ini_disp].RT_IVEC,RT_TEXTOFFSET B$RTINI 
;
;	update "ONE" time termination dispatch address to B$IOCLOS	
;
	MOV	WORD PTR [b$term_disp].RT_TVEC,RT_TEXTOFFSET B$IOCLOS 
;
;	update "RUN" time initialization dispatch address to B$RTRUNINI
;
	MOV	WORD PTR [b$run_disp].RT_RVEC,RT_TEXTOFFSET B$RTRUNINI
;
;	update CLEAR statement dispatch address to B$RTCLR
;
	MOV	WORD PTR [b$clr_disp].RT_CVEC,RT_TEXTOFFSET B$RTCLR
cEnd
	SUBTTL	Runtime Initialization Code
	PAGE
;***
;_main,B$IINIT - Main entry point into the runtime
;main()
;void pascal B$IINIT()
;
;Purpose:
;	This is the main entry point into the runtime.	It is responsible for
;	initializing the components of the runtime which are present and
;	need initializing.  This is done by indirectly calling each routine
;	which has an address defined in b$ini_disp.  This table is built
;	up by conditional initializers which are dragged in at link time.
; BC3
; ---
;	A BASCOM compiled program enters in the C library startup(crt0).  Crt0
;	calls each routine which has its address defined in the segment XI.
;	These initializers will update the dispatch table b$ini_disp.
;	Crt0 will then call runtime at _main.  _main will call all routines in
;	b$ini_disp.  After all components of the runtime have been initialized,
;	_main needs to determine where to begin execution of the user program.
;	BASIC has no concept of a "main" module the compiler does not generate
;	an _main label (the first module in the link is considered to be the
;	entry point).
;	   NOTE: the compiler generates modulename_CODE as the segment name for
;		  the user code.  Therefore the runtime does not know what
;		  segment the users code resides in.
;	The compiler generates a segment called BC_SA of CLASS 'BC_SEGS'
;	which contains the segmented address of every module linked.  Therefore
;	the runtime can pick out the first dword of this segment to obtain the
;	address of the user code module that was linked FIRST.	This address
;	points to the module header of the module.  The actual beginning of
;	the users code is at a fixed offset (O_ENT) from this address.	We can
;	then call the users module to begin execution of the BASIC program.
; QB4
; ---
;	The routine B$IINIT is identical to the compilers _main except
;	that it does not need to find the users program.  All components
;	will be inited in the interpreter.  The initializers will be set
;	up identically for the compiler and interpreter.  Note that B$IINIT
;	is called by the interpreter, initializes and returns.
;
;Entry:
;	DS = ES = user DS for DOS3 RTM
;	SS:SI = ptr to command parameters (QB4 only)
;		[SI]   - UlibNameOffset
;		[SI+2] - UlibNameSegment
;		[SI+4] - cbLibName
;		[SI+6] - cbComBuffer
;Exit:
;	None
;
;Uses:
;	None
;
;Exceptions:
;	May not return if initialization error occurrs.
;****
cProc	B$IINIT,<PUBLIC,FAR>,<SI,ES>	
cBegin

?PLM = 1				

	PUSH	DS			
	POP	ES			
	MOV	AX,[SI+6]		;get requested com buffer size
	MOV	b$cbComBuffer,AX	;save combuffer size



;
;	Call "ONE" time and "RUN" time initialization routines for
;	each component which has an entry defined in b$ini_disp and
;	b$run_disp.  Components not needing initialization point
;	to B$FAR_RET, which just does a far return.
;
	MOV	SI,OFFSET DGROUP:b$ini_disp ;get dispatch table addr
	CALL	FAR PTR B$COMP_DISP	;routine to do table dispatches
	MOV	SI,OFFSET DGROUP:b$run_disp ;get "run" time dispatch table
	CALL	FAR PTR B$COMP_DISP	;do "RUN" time initialization
	call	fEditorActive		; did we start with /EDITOR
	jnz	InEditor		; brif so, don't restrict memory
	MOV	AH,7Fh			; request 7Fxx7Fxx bytes more in
	cCall	B$SETM,<AX,AX>		; order to REDUCE max available
					; memory to 128K (far) + 32K (near)
InEditor:				

	inc	b$fRTInit		; indicate RT is inited

cEnd
?PLM = 1

; common error entry points to save NEAR jumps
BADLL:					
	JMP	B$ERR_LLI		; Low level initialization error

	SUBTTL	Post-RTM-load initialization
	PAGE
;*** 
; B$RTMInit - initialization for RTM programs.
;
;Purpose:
;	Moved from RTMLOAD.ASM with revision [64]. (was called ChainInit)
;	Moved into segment INIT_CODE from RT_TEXT with revision [75].
;
;	To perform initialization specific to RTM programs.
;Entry:
;	SS = DGROUP segment.
;Exit:
;	None.
;Uses:
;	None
;Exceptions:
;
;******************************************************************************


sEnd	INIT_CODE

	SUBTTL	Top Level "RUN" time initialization for QB4
	PAGE
assumes CS,RT_TEXT
sBegin	RT_TEXT

;***
;B$INIT - Initialization prior to XI processing.
;PLM B$INIT()
;
;Purpose:
;	This is the FIRST entry point into the BASIC runtime.  It gets called
;	prior to any of the initialization vectors.  It's primary purpose in
;	life is to clear BC user variables prior to the XI dispatches.
;	The reason that we need to do this here is that near malloc() space
;	comes out of the NMALLOC BASIC common block, and we would wipe out
;	any initial mallocs done in the XI dispatches. Fortran and Pascal
;	both do this kind of allocation.
;	Added with revision [68].
;
;	This routine move from INIT_CODE to RT_TEXT with [88].
;
;Entry:
;	None.
;Exit:
;	The bit flag b$CtrlFlags.BCVarsCleard is set.
;Uses:
;	None.
;Exceptions:
;	None.
;****
cProc	B$Init,<PUBLIC,FAR>,<ES,SI>
cBegin
	MOV	SI,b$pBC_SAB		;get offset to beginning of table
	LES	SI,[SI] 		;ES:SI = module header ptr
	MOV	b$ucodeoff,SI
	MOV	b$ucodeseg,ES
	CALL	B$RTRUNINI		;clear user vars
	OR	b$CtrlFlags,NoInitBcVars ;We have already inited BcVars,
					;B$RtRunini doesn't need to.

cEnd

GenericError:

BADLLI: 				
	JMP	B$ERR_LLI		; Low level initialization error
BADDOS: 				
	JMP	B$ERR_DOS		; Invalid dos version error

	SUBTTL	Runtime Core "ONE" time initialization
	PAGE
;***
;B$RTINI - One time Initializion routine for the runtime core.
;PLM B$RTINI()
;
;Purpose:
;	This is the routine responsible for initializing the runtime
;	core.  This routine checks to make sure that the runtime is
;	running under a reasonable version of DOS.  It also checks
;	to make sure that each object module was compiled with the
;	correct version of the compiler, and that each module was
;	linked with the correct library.  For DOS 3 RTM module versions,
;	this routine causes the runtime module to get loaded.
;	We will also determine if IO has been redirected.
;	We will set up the signal/interrupt handlers for divide by 0,
;	overflow, and HARD disk errors.  For OS/2 versions,
;	if we have been chained to we will get the data that was
;	passed across shared memory.
;	This routine move from INIT_CODE to RT_TEXT with [88].
;
;
; BC3	- void pascal B$RTINI()
; ---
;	This entry point is called B$RTINI.  It has no parameters and
;	performs initialization that is only needed once.  This initialization
;	includes:
;		Checking for reasonable versions of DOS
;		Checking each user module for proper linkage
;			and compiler version
;	  DOS 3 specific:
;		Get/Save machine ID (low level)
;		Set /0, overflow, and int24 handlers
;		Have low level save runtime DS in LL CS (chain/shell/ints)
;	  RTM module specific:
;		Load and fixup RTM module
;		Init RTM module interrupt vectors
;	  OS/2 specific:
;		Set /0, and overflow signal handlers
;		set ignore int24 signal to return an error code
;
; QB4	- void pascal B$RTINI()
; ---
;	The interpreter entry point will also be B$RTINI for "ONE time" init.
;	The interpreter runtime will not need as much "ONE time" initialization
;	as the compiler.  It will still be sensitive to differences in DOS 3 vs
;	OS/2.
;		Checking for reasonable versions of DOS
;	  DOS 3 specific:
;		Get/Save machine ID (low level)
;		Set /0, overflow, and int24 handlers
;		Have low level save runtime DS in LL CS (ints)
;	  OS/2 specific:
;		Set /0, and overflow signal handlers
;		set ignore int24 signal and return an error code
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	Doesn't return in following conditions:
;		Wrong version of DOS.
;		Wrong runtime module.(BC3)
;		Linked with wrong library. (BC3)
;		Bad runtime module. (BC3)
;		Not enough memory to load runtime module. (BC3)
;****
cProc	B$RTINI,<NEAR>,<SI>	
cBegin
	PUSH	ES			;ensure ES is preserved.

;	Install the RTM interrupt vector.  This is placed first to
;	to ensure that the vector is always installed and deinstalled
;	once under all circumstances.

; RTM already installed for DOS3.  Couldn't have reached here if not.
	cCall	B$RTMInstall	;install the RTM interrupt vector

;
;	Check for the correct version of DOS.  BASIC .EXEs created for
;	DOS 3 can run in greater than or equal to DOS 2.10.  BASIC .EXEs
;	created for OS/2 can run in only OS/2.	The DOS or OS/2 program
;	loader will ensure that the user can't run a DOS 3 exe in OS/2 or
;	vice versa, so all we have to check here is that we aren't trying
;	to execute a DOS3 .EXE in a DOS less than 2.10.  The current dos
;	version is defined in the C startup in a variable called __osversion.
;	The high byte of this variable contains the decimal value for the
;	minor version number.  The low byte of this variable contains the
;	decimal value for the major version number of dos.  For example
;	2.10 is represented as 0A02H.
;

	MOV	AX,__osversion		; get dos version
	XCHG	AH,AL			; AH = major #, AL = minor #
	CMP	AX,020Ah		; all versions run on >= 2.10
	JB	BADDOS			; brif bad dos version

;
;	Each user module that gets linked into the executable file
;	contains a header which is ~30 bytes.  This header contains
;	information about the module.  The module code begins after
;	the header.  The header is described in addr.inc.  We need
;	to check each module to ensure that it was compiled with
;	the correct version of the compiler, and linked with the
;	appropriate runtime libraries.	A table of module start
;	addresses is emitted by the compiler into the BC_SA segment.
;
	MOV	BX,b$pBC_SAB		;offset from DS of BC_SAB seg
	MOV	AX,[BX+2]		;get user code segment
	MOV	b$ucodeseg,AX		;save user code segment
	MOV	SI,[BX] 		;get user code offset
	MOV	b$ucodeoff,SI		;save user code offset
CHECK_MODULE:
	PUSH	AX			;save segment
	OR	AX,SI			;at end of zero terminated list?
	POP	AX			;recover segment
	JZ	CHECK_MODULE_DONE	;finished if so
	ADD	BX,4			;point to next entry in module table
	MOV	ES,AX			;mov segment to seg reg (AFTER CHECK
					;so no segmentation fault will occur
	MOV	AX,ES:[SI].U_FLAG	;get compile switches
	OR	b$userflags,AX 		;update user flags

NEXT_MODULE:				; label used to save code for RTM
	MOV	SI,[BX] 		;get offset of users module
	MOV	AX,[BX+2]		;get segment of users module
	JMP	SHORT CHECK_MODULE	;check all modules in link

CHECK_MODULE_DONE:


	cCall	B$IOINI			; Init /0, OVF, 24H interrupts


	cCall	B$RTLLINI		;do low level init
	OR	AX,AX			;check for low level error
	JNZ	GenericError		;error out if LL init failed

	cCall	B$GWINI			;do low level init
	JC	BADLLI			;low level error


LLSkip: 				
	POP	ES			;recover ES
cEnd

	PAGE	
;***
;B$CHNINI - CHAIN initialization for QB interpreter.
;void pascal B$CHNINI(*sd)
;
;Purpose:
;	Added with revision [40].
;	This routine provides QBI specific CHAIN support.
;	It will call user library reinitialization, stop
;	any currently playing music, clear any arrays or
;	strings that are not in blank COMMON, reset rt
;	state variables, and reinitialize the EVENT queues.
;Entry:
;	psdCommon - non-zero indicates an sd describing the
;	QBI blank COMMON value table.
;Exit:
;	None.
;Uses:
;	Per convention.
;Exceptions:
;	None.
;****
cProc	B$CHNINI,<PUBLIC,FAR>
parmW	psdCommon
cBegin
	PUSH	b$commonfirst	;save start of compiled common block
	PUSH	b$commonlast	;save end of compiled common block
	INC	b$chaining	;we are chaining, not running
	MOV	BX,psdCommon	;get ptr to common block descriptor
	OR	BX,BX		;should we use interpreters COMMON?
	JZ	UseCompiledCommon ;brif not, use Compiled COMMON

	MOV	CX,[BX+2]	;get ptr to start of QBI common block
	MOV	b$commonfirst,CX ;save it
	ADD	CX,[BX] 	;get ptr to end of QBI common block
	MOV	b$commonlast,CX ;save it

UseCompiledCommon:
	MOV	AL,STPSND	;flag to turn off noise
	cCall	B$DONOTE	;turn off any pending music
	cCall	B$FHClear	;clear non-COMMON huge arrays
	cCall	B$NHCLR	;clear non-COMMON arrays and strings
	cCall	B$CLEAR	;clear rt state variables
	cCall	B$?EVT 	;reset event queue
	cCall	B$ULInit	;reinit user library
	MOV	b$Chaining,0	;clear chaining flag
	POP	b$commonlast	;recover end of compiled common
	POP	b$commonfirst	;recover start of compiled common
cEnd
	PAGE
;***
;B$RUNINI - "RUN time" initialization for QB4 Interpreter.
;void pascal B$RUNINI()
;
;Purpose:
;	This routine is a common runtime entry point for the interpreter.
;	It is responsible for providing the necessary initialization to
;	support the interpreter concept of restartability.  The interpreter
;	will call this routine whenever a RUN or NEW statement is executed.
;	This routine will cause all components needing initialization
;	to be re-initialized.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$RUNINI,<PUBLIC,FAR,FORCEFRAME>
cBegin
	PUSH	SI
	MOV	SI,OFFSET DGROUP:b$run_disp ;get "run" time dispatch table
	CALL	FAR PTR B$COMP_DISP	     ;do "RUN" time initialization
	POP	SI		
	CALL	B$ULInit	;reinitialize user library.

	MOV	AH,7Fh		; request 7Fxx7Fxx bytes more in order
	cCall	B$SETM,<AX,AX>	; to get back the maximum space for BASIC
cEnd
	SUBTTL	Component generalized dispatcher
	PAGE
;***
;B$COMP_DISP - Indirect component dispatch routine.
;void pascal B$COMP_DISP()
;
;Purpose:
;	This routine will indirectly call each routine which
;	is in the dispatch table which is passed into this
;	routine.  The first word in the dispatch table should
;	contain the number of routines to be called in the table.
;
;Entry:
;	SI	- points to first word of dispatch table.
;
;Exit:
;	None.
;
;Uses:
;	SI
;
;Exceptions:
;	None.
;****
cProc	B$COMP_DISP,<PUBLIC,FAR>
cBegin
	MOV	CX,[SI] 		;number of entries in dispatch table
	JCXZ	DISP_EXIT		;no entries, don't go into loop
DISP_LOOP:				
	LODSW				;point to first routine in table.
	PUSH	CX			;preserve count of routines to check
	CALL	WORD PTR [SI]		;dispatch to init routine (ret if
					;component is not present).
	POP	CX			;restore routine counter
	LOOP	DISP_LOOP		;continue until all routines called
DISP_EXIT:				
cEnd
	SUBTTL	RT Component "RUN" time Initilization
	PAGE
;***
;B$RTRUNINI -	RT Core component "RUN" time initialization.
;void pascal B$RTRUNINI()
;
;Purpose:
;   BC3
;   ---
;	This routine performs the runtime core component initialization that is
;	necessary whenever the runtime system is initialized, a CHAIN statement
;	is executed in the DOS 3 /O environment, or a RUN "filename" statement
;	is executed in the DOS 3 environment.  B$RTRUNINI does the following:
;		Clear user variables (share with CLEAR by calling B$RTCLR)
;		Reset b$traceon and LPR_ECHO flag. [43]
;   QB4
;   ---
;	Same as BC3.
;
;Entry:
;	None.
;
;Exit:
;	b$CtrlFlags & traceon = 0 [61]
;	User variables and runtime state variables cleared.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$RTRUNINI,<NEAR>	
cBegin
	CALL	B$RTCLR 		;Clear all user variables
	AND	b$CtrlFlags,NOT(traceon OR NoInitBcVars) ;reset trace on
					; tracking, and init BC_VARS all
					; subsequent times called.
	cCall	__fpreset		;reset numeric stack
cEnd

	SUBTTL	Interpreter helper
	PAGE
;***
;B$IRTCLR -	B$RTCLR for the interpreter
;
;Purpose:
;	Added with revision [97] to clear QuickLib variables.
;	clear items in blank common, BC_DATA, named common (except NMALLOC).
;	Re-written with revision [98].
;
;	This should not be called if chaining.  B$CHNINI will do the
;	work in that case.
;
;	This should also not be called unless common is shared between
;	the interpreter and the QuickLib.
;
;Entry:
;	None.
;Exit:
;	Variables deallocated, and owners in common or BC_VARS cleared.
;Uses:
;	Per convention.
;
;Exceptions:
;	None.
;****
cProc	B$IRTCLR,<FAR,PUBLIC>,<ES,DI>
cBegin

	cmp	b$ucodeseg,0		; compiled code present?
	jz	NoQlbCode		; brif not -- nothing to do.
	test	b$CtrlFlags,ULInited	; has QuickLib been initialized yet?
	jz	NoQlbCode		; brif not -- nothing to do.
					; (b$nmalloc_start and b$nmalloc_end
					; haven't been properly initialized).

	les	BX,DWORD PTR b$ucodeoff ; ES:BX = ptr to users module

	mov	DI,ES:[BX].OF_COM	; DI = ptr to COMMON block
	mov	CX,b$nmalloc_start	; CX = start of NMALLOC

	cmp	cx,di			; before start of COMMON
	jbe	NoNMALLOC		; brif so -- no QLB nmalloc
	cmp	cx,ES:[BX].OF_FT	; past end of BC_FT? 
	jae	NoNMALLOC		; brif so -- no QLB nmalloc

	push	bx			; save module addr
	call	ClearHelper		; deallocate owners in range + zero
	pop	bx			; restore module addr

	mov	DI,b$nmalloc_end	; DI = end of NMALLOC
NoNMALLOC:
	mov	CX,ES:[BX].OF_FT	; CX = start of BC_FT
	call	ClearHelper		; deallocate owners in range + zero

NoQlbCode:
cEnd

;*** 
;ClearHelper -- helper routine for B$IRTCLR
;
;Purpose:
;	Deallocate all items are in a given range, and zero the range
;	Added with revision [98].
;
;Entry:
;	DI = start addr to zero
;	CX = end addr to zero
;
;Exit:
;	None
;
;Uses:
;	Per convention + DI
;
;Preserves:
;
;Exceptions:
;	None
;
;******************************************************************************
cProc	ClearHelper,<NEAR>,<ES>
cBegin

	push	ds			; set ES=DS
	pop	es

	push	cx			; save end addr
	cCall	<FAR PTR B$ClearRange>,<DI,CX>	; clean out entries whose
					; owners are in range DI ==> CX
	pop	cx			; restore end address

	sub	CX,DI			; CX = count of bytes to clear
	shr	CX,1			; move words not bytes
	xor	AX,AX			; fill with zeros
	REP	STOSW			; clear block at ES:DI
cEnd


	SUBTTL	RT Component CLEAR statement support
	PAGE
;***
;B$RTCLR -	RT Core CLEAR statement support
;void pascal B$RTCLR()
;
;Purpose:
;	Resets all user variables, runtime state variables,
;	and DEF SEG segment.
;
;Entry:
;	None.
;
;Exit:
;	b$seg = DS
;	BC3:
;		COMMON variables cleared
;		USER variables cleared
;	runtime state vars reset
;
;Uses:
;	Per convention.
;
;Exceptions:
;	None.
;****
cProc	B$RTCLR,<NEAR>,<ES,DI>		
cBegin

	CMP	b$ucodeseg,0		;compiled code present?
	JZ	NoCompiledCode		;brif not

	LES	BX,DWORD PTR b$ucodeoff ;load ES:BX with ptr to users module
	MOV	DI,ES:[BX].OF_COM	;get ptr to COMMON block
	MOV	CX,ES:[BX].OF_DAT	; get end of blank COMMON for
					; normal RTM's
	SUB	CX,DI			; get size of blank COMMON

;
;	Set up pointers into COMMON block.  b$commonfirst points to
;	first word of the soft key function table which immediately preceeds
;	the blank COMMON block.  b$commonlast to the end of COMMON block.
;
	PUSH	DS			;get dgroup
	POP	ES			;force ES = DS

	MOV	b$commonfirst,DI	;QB common and soft keys are
	SHR	CX,1			;move words not bytes
	XOR	AX,AX			;fill common with zeros
	REP	STOSW			;CLEAR COMMON block
	MOV	b$commonlast,DI 	;save end of common block

NoCompiledCode: 			
	MOV	b$seg,DS		;Initialize the default DEF SEG segment
	cCall	B$CLEAR 		;clear other user vars and RT data
cEnd
	SUBTTL	B$ClearRange - Clear heap entries in ranges
	PAGE
;***
;B$ClearRange - Clear heap entries in ranges
;void far pascal B$ClearRange(ushort start, ushort end)
;
;Purpose:
; Release all local heap, variable heap, far heap and string entries whose 
; owners fall into a particular range. Except for updating the affected owners,
; other data in range is untouched.
; Exception: Not to be called to clear a range in the variable heap. WILL
;		handle variable heap entries whose owners are in the given
;		range, but the range must not be in the variable heap (the
;		string code, at least, doesn't support this)
;
; The range is inclusive, and must/may include any valid DGROUP range.
; Assumption is made that the heaps will not move during this operation. If
; start>=end, no operation occurs. Debug code asserts that end is greater than
; start. Release code checks, but skips the operation on an invalid range.
;
;Entry:
; rstart = low address of range
; rend	 = ending address of range.
;
;
;Exit:
; none
;
;Uses:
; Per convention, plus preserves ES
;
;******************************************************************************
cProc	B$ClearRange,<FAR,PUBLIC>,ES 
parmW	rstart
parmW	rend
cBegin
	PUSH	DS		; Set ES = DS
	POP	ES		
	MOV	AX,rstart
	MOV	BX,rend


	CMP	AX,BX		; Anything to do?
	JAE	ClearRangeExit	; skip the work if not

	cCall	B$FHClearRange	;Clear far heap

	MOV	AX,rstart
	MOV	BX,rend
	MOV	CX,SP		; CX != 0: release ALL owners in range
	cCall	B$LHClearRange	;Clear local heap

	call	B$TglHeapSptNEAR 
	MOV	AX,rstart	
	MOV	BX,rend		
	MOV	CX,SP		; CX != 0: release ALL owners in range
	cCall	B$LHClearRange	; Clear variable heap
	call	B$TglHeapSptNEAR 
	MOV	AX,rstart
	MOV	BX,rend
	cCall	B$SSClearRange	;Clear string space

ClearRangeExit: 		

cEnd

	SUBTTL
	PAGE
;***
;B$CLEAR - common CLEAR statement support
;void pascal B$CLEAR()
;
;Purpose:
;	Resets user variables, and runtime state variables.
;Entry:
;	None.
;Exit:
;	BC3:
;		USER variables cleared
;	runtime state vars reset
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	B$CLEAR,<NEAR,PUBLIC>,<ES,SI,DI> 
cBegin
	PUSH	DS			;Get dgroup
	POP	ES			;force ES = DS
	XOR	AX,AX			;fill user data with zeros

	TEST	b$CtrlFlags, NoInitBcVars ; have BC_Vars already been
	JNZ	NoCompiledData		; cleared?  brif so -- don't
					; clear them again.  An NMALLOC
					; could have been done by an XI
					; initializer!

	CMP	b$ucodeseg,AX		;compiled code present?
	JZ	NoCompiledData		;brif not

; Clear the named common segments, including NMALLOC
	PUSH	ES			;Save ES
	LES	BX,DWORD PTR b$ucodeoff ;load ES:BX with ptr to users module
	MOV	DI,ES:[BX].OF_DAT	;get ptr to start of user data
	MOV	CX,ES:[BX].OF_FT	;get ptr to end of user data
	POP	ES			;recover ES
	SUB	CX,DI			;compute size of user data
	SHR	CX,1			;move words not bytes
	REP	STOSW			;CLEAR user data block

NoCompiledData: 			
	MOV	DI,OFFSET DGROUP:STARTZERO	;get ptr to start of RT data
	MOV	CX,STOPZERO-STARTZERO	;compute size of RT data
	REP	STOSB			;clear runtime data state vars


;
; Fill the stack from [b$pend] to [SP] for known data, for use by FRE(-2)
;
	MOV	BX,SP			; location to end at
	cCall	<FAR PTR B$STACKINIT>	
cEnd
	SUBTTL	B$STACKINIT - Init Stack Area
	PAGE
;*** 
;B$STACKINIT - Init Stack Area
;
;Purpose:
; Load stack area with known data for use by FRE(-2)
;
;Entry:
; [BX]	=  Stack Address at which to STOP filling
;
;Exit:
; none
;
;Uses:
; per convention + DI & ES
;
;******************************************************************************
cProc	B$STACKINIT,<FAR,PUBLIC>
cBegin				
	TEST	b$CtrlFlags,NoSTACKINIT ; B$STACKINIT disabled?
	JNZ	StackInitExit	; brif so -- just exit
	SUB	BX,4		; Adjust BX for return address on stack
	PUSH	SS		
	POP	ES		
	MOV	DI,[b$pend]	; [ES:DI] points to stack area
	MOV	AX,-STACK_MIN	; word to be written to stack area
InitStackLoop:			
	STOSW			; put into unused stack space
	INC	AX		; bump count of available bytes
	INC	AX		
	CMP	DI,BX		; have we reached our stack?
	JC	InitStackLoop	; loop until stack filled

StackInitExit:			
cEnd				

	SUBTTL	Def Seg setup routines.
	PAGE

;***
; B$DSG0 - Set BASIC Segment Address to Data Segment (DEF SEG w/no parameter)
;
; Purpose:
;  Runtime Entry Point. Save DS in b$seg
;
; Input:
;  NONE
;
; Output:
;  [b$seg] == DS
;
; Modifies:
;	NONE
;
;******************************************************************************
cProc	B$DSG0,<PUBLIC,FAR>	
cBegin				
	MOV	[b$seg],DS	;Save initial data seg
cEnd				

;***
; B$DSEG - Set BASIC Segment Address (DEF SEG w/parameter)
;
; Purpose:
;  Runtime Entry Point. Save given segment address in b$seg
;
; Input:
;  new segment address
;
; Output:
;  [b$seg] set.
;
; Modifies:
;	NONE
;
;******************************************************************************
cProc	B$DSEG,<PUBLIC,FAR>	
parmW	newseg			
cBegin				
	MOV	AX,newseg	; get...
	MOV	[b$seg],AX	; and save new b$seg value
cEnd				

;*** 
;B$GetCompSwitches
;
;Purpose:
;	Added with revision [85].  The interpreter calls this routine
;	to find out whether or not any QuickLIB modules were compiled
;	with /V or /W.	Since the interpreter uses both or neither of
;	these, we just return TRUE or FALSE with no differentiation
;	between V or W.
;Entry:
;	None
;Exit:
;	AX=0  if no QuickLIB modules were compiled with /V or /W
;	AX<>0 if at least one QuickLIB routine was compiled /V or /W
;Uses:
;	None
;Exceptions:
;	None
;******************************************************************************
cProc	B$GetCompSwitches,<PUBLIC,FAR>
cBegin
	MOV	AX,[b$userflags]	;get switches used
	AND	AX,u_sw_w + u_sw_v	;mask down to just /V and /W
cEnd					;AX = 0 if no /V or /W, else nonzero

	page

sEnd	RT_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\rtseg.asm ===
TITLE	RTSEG - Segment ordering for the BASIC runtime
;***
;RTSEG.ASM - Segment ordering for the BASIC runtime
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This module contains the segment ordering for the BASIC
;	runtime module.
;
;******************************************************************************

	INCLUDE switch.inc	;assembly switch file
	INCLUDE rmacros.inc	;segment/C macros

;
;	Define segment order for runtime module
;
;
;	Data Segments
;
	USESEG	<NULL>		; BEGDATA (empty for RTMs)
	USESEG	<BR_DATA>	;Hole for user program data

	USESEG	<CONST> 	;runtime constants
	USESEG	<_BSS>		;runtime data (uninitialized)
	USESEG	<_DATA> 	;runtime data (initialized)


	USESEG	<BC_DATA>	;users variables
	USESEG	<BC_FT> 	
	USESEG	<BC_CN> 	
	USESEG	<BC_DS> 	
	USESEG	<BC_SAB>	;beginning of user module start address table
	USESEG	<BC_SA> 	;user module start address table
	USESEG	<BC_SAE>	;end of user module start address table
				; creation of BR_DATA, class BLANK before
				; these segments
	USESEG	<BR_SKYS>	;Soft key definitions
	USESEG	<COMMON>	;User blank COMMON data
	USESEG	<NMALLOC>	;start of near malloc buffer
	USESEG	<ENMALLOC>	;end of near malloc buffer space
	USESEG	<STACK> 	;runtime stack


;
;	Code Segments
;
	USESEG	<RT_TEXT>	;runtime core segment
	USESEG	<NH_TEXT>	;near heap manager
	USESEG	<FH_TEXT>	;far heap manager
	USESEG	<ST_TEXT>	;string functions
	USESEG	<GR_TEXT>	;graphics
	USESEG	<MT_TEXT>	;floating point math
	USESEG	<ER_TEXT>	;error trapping
	USESEG	<EV_TEXT>	;event trapping
	USESEG	<SN_TEXT>	;sound and music
	USESEG	<DV_TEXT>	;device I/O
	USESEG	<CN_TEXT>	;console I/O
	USESEG	<DK_TEXT>	;disk I/O
	USESEG	<OI_TEXT>	;comm/printer I/O
	USESEG	<OS_TEXT>	;operating system functions/features
	USESEG	<DB_TEXT>	;debug utilities /D
	USESEG	<ID_TEXT>	;internal runtime debugging
	USESEG	<INIT_CODE>	;initialization
	USESEG	_TEXT		;c


	INCLUDE seg.inc 	;segment definitions

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\rtm86.asm ===
TITLE	RTM86 - 8086 Runtime Module Dispatcher

;***
; RTM86 - 8086 Runtime Module Dispatcher
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Contains the runtime module entry point for direct
;	execution which outputs the copyright messages.
;	It also contains the RTM software interrupt handler
;	and the runtime entry dispatch tables.
;
;******************************************************************************
INCLUDE switch.inc
INCLUDE rmacros.inc

	USESEG	<CONST>
	USESEG	<_DATA>
	USESEG	<_BSS>
	USESEG	<CDATA>
	USESEG	<_TEXT>
	USESEG	<RT_TEXT>


INCLUDE seg.inc

INCLUDE idmac.inc
INCLUDE intasg.inc
INCLUDE	intmac.inc
INCLUDE	files.inc
INCLUDE	addr.inc
INCLUDE	stack.inc
INCLUDE ulib.inc			

sBegin	_BSS

	externW 	b$pULVars	;ptr to shared data items
					;defined in User lib.

sEnd	_BSS

sBegin	_TEXT			
externW VecTbl				; Start of dispatch table
externW _TEXT_START			; Start of _TEXT entries
externW _TEXT_END			; Past end of _TEXT entries
sEnd	_TEXT			

assumes	CS,RT_TEXT
sBegin	RT_TEXT


; values saved in code segment:

staticW	SaveAX,,1		;saved AX register
staticW	SaveBX,,1		;saved BX register
staticW	SaveSI,,1		;saved SI register
staticW	SaveDS,,1		;saved DS register
staticD	RTMChainPtr,,1		; RTM interrupt chain pointer
staticB UserTableFlag,,1	;flag whether or not we're using user-table

;*** 
; B$RTMInstall - install the RTM interrupt vector
;
;Purpose:
;	To install the RTM interrupt vector by first saving the
;	current vector and then setting it to the new value.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	B$RTMInstall,<FAR,PUBLIC>,<AX,BX,DX,DS,ES>
cBegin
	PUSH	CS			; DS = code segment for SAVINT
	POP	DS			; storage and SETVEC
	SAVINT	RTMChainPtr,(W0__NM*4)	;save the vector
	SETVEC	W0__NM,RTMVector	;set vector to the new value
cEnd

;*** 
; B$RTMDeinstall - deinstall the RTM vector
;
;Purpose:
;	To deinstall the RTM interrupt vector by setting it
;	to its previous value.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	B$RTMDeinstall,<FAR,PUBLIC>,<AX,DX,DS>
cBegin
	RSTVEC	W0__NM,RTMChainPtr	;restore to the old vector
cEnd

;***
; RTMVector - Runtime module interrupt service routine.
;
;Purpose:
;	This routine is executed when a compiled (non /O) module
;	requests runtime support.  The routine address is looked
;	up in a table based upon the index postbyte (which may be
;	preceded by a flag postbyte indicating special handling).
;	If the requested routine is found, the far call to the
;	interrupt request is backpatched into a far call to the
;	requested routine and reexecuted.  If a valid request is
;	made that does not have a defined entry, an advanced
;	feature error is issued.
;
;	Before backpatch:
;	    <FAR CALL stubroutine> --> <INT + postbyte(s)> --> RTMVector
;
;	After backpatch:
;	    <FAR CALL realroutine>
;Entry:
;	[SS:SP] - far pointer to first post byte.
;Exit:
;	FAR CALL to the Interrupt is backpatched and execution is restarted
;	at the backpatched call.
;Uses:
;	None.
;Exceptions:
;	B$ERR_AFE.
;****

;	These two code fragments are out here so that the normal case (single
;	postbyte) can be a complete fall through for speed.  If either of
;	the double postbyte cases are encountered, the code will jump out
;	here to one of these fragments which will jump back when they are done.

Part2:	LODSB			; [AL] = second post byte
	INC	AH		; [AX] = index into table (adjusted)
	JMP	SHORT DoIt	; continue


DbPub	RTMVector
cProc	RTMVector,<FAR>		
cBegin	<nogen>			

	MOV	CS:[SaveAX],AX	;save AX, but not on stack
	MOV	CS:[SaveBX],BX	;...and BX
	MOV	CS:[SaveSI],SI	;...and SI
	MOV	CS:[SaveDS],DS	;...and DS
	POP	SI		;get return offset (third byte in call)
	POP	DS		;get return segment
	POPF			; enable ints

;	Some trickery for handling table indicies:
;	The RTM dispatch table is "missing" the entry corresponding to
;	255 because a postbyte of FF is a special flag, and IF NOT EI_QB
;	it is also "missing" the entry at 254 (another flag).  To allow
;	addressing the table as a contiguous block, indicies in part 1
;	of the table (single postbyte entries) are bumped up (as a side
;	effect of testing for flag values).  This makes the index set
;	contiguous but 2 bytes (or 4 IF NOT EI_QB) too high.  We adjust
;	for this by addressing 2 bytes (or 4) below the table base.

	MOV	BX,_TEXTOFFSET VecTbl - 2 ;base of table minus 2 bytes
	LODSB			; [AL] = dispatch table index or flag
	XOR	AH,AH		; [AX] = dispatch table index or flag
	INC	AL		; part 2 of table? (2 post bytes)
	JZ	Part2		; yes, go read second post byte


DoIt:	ADD	AX,AX		; [AX] = word offset+2 into dispatch table
	ADD	BX,AX		; [BX] = CS Pointer into dispatch table
	MOV	AX,SEG _TEXT	
	MOV	DS,AX		; [DS:BX] points to table
	MOV	AX,[BX] 	; [AX] = target offset
	POP	SI		
	POP	DS		; [DS:SI] = return address into USER code
	SUB	SI,5		; [DS:SI] = call instruction in USER code
	PUSH	DS		; restore return segment
	PUSH	SI		; stack far pointer will execute new far CALL
	MOV	[SI+1],AX	; backpatch OFFSET part of far call

;	Determine target segment for backpatch

	MOV	AX,RT_TEXTBASE	; [AX] = target segment
	CMP	BX,_TEXTOFFSET _TEXT_START ; past start of _TEXT entries?
	JB	RTMVEC_20	; Jump if not
	CMP	BX,_TEXTOFFSET _TEXT_END ; past end of _TEXT entries?
	JAE	RTMVEC_20	; brif so
	MOV	AX,_TEXTBASE	; _TEXTBASE = target segment

RTMVEC_20:			
	MOV	[SI+3],AX	

	MOV	DS,CS:[SaveDS]	;restore original DS
	MOV	SI,CS:[SaveSI]	;restore original SI
	MOV	BX,CS:[SaveBX]	;restore original BX
	MOV	AX,CS:[SaveAX]	;restore original AX
	RET			;far return to routine address just pushed

cEnd	<nogen>			



labelNP <PUBLIC,B$Undef1>	; This is a list of empty slots in
labelNP <PUBLIC,B$Undef2>	; the RTMINT table.  Remove them when
labelNP <PUBLIC,B$Undef3>	; the slot is re-used to eliminate
labelNP <PUBLIC,B$Undef4>	; confusion and extranious labels.

externNP  B$FrameFC		
	JMP	B$FrameFC	; Give "Illegal Function Call"


sEnd	RT_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\rtterm.asm ===
TITLE	RTTERM - Termination module for BASIC runtime
;***
;RTTERM.ASM - Termination module for BASIC runtime
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains the termination routines for the BASIC 3.0
;	core runtime.  This module will always be present.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;
;	Code Segments
;
	USESEG	<RT_TEXT>	;runtime core
	USESEG	<DV_TEXT>	; DV component I/O deinstall
	USESEG	<ER_TEXT>	;runtime error handler

;
;	Data Segments
;
	USESEG	<_DATA> 	;runtime data (initialized)
	USESEG	<_BSS>		;runtime data (uninitialized)
	USESEG	<BC_SAB>	;beginning of table of module start addresses
	USESEG	<BC_SA> 	;table of module start addresses
	USESEG	<BC_SAE>	;end of table of module start addresses
	USESEG	<XCB>		;beginning of C terminators
	USESEG	<XC>		;C terminators
	USESEG	<XCE>		;end of C terminators

	INCLUDE seg.inc
	INCLUDE messages.inc	;message/error definitions
	INCLUDE addr.inc
	INCLUDE files.inc
	INCLUDE event.inc	

	SUBTTL	Runtime data definitions for BASIC Runtime Core
	PAGE
;
;	Code externals
;
	externFP	B$IStop ;executor for STOP/BREAK in interpreter.
	externFP	exStEnd ;executor for SYSTEM/END in interpreter
	externFP	B$ULTerm ;user library termination
	externFP	UiTerm	;unhook UI interrupt vectors

	externFP	B$RTMDeinstall ;deinstall the RTM interrupt vector

	externFP	_exit	; C startup exit routine

sBegin	ER_TEXT 		
	externNP	B$ERR_NR	;No Resume error
sEnd	ER_TEXT 		


sBegin	RT_TEXT 		
	externFP	B$COMP_DISP	;common component dispatcher
	externNP	B$PUTNUM	;put numbered message
sEnd	RT_TEXT

sBegin	BC_SAE			
	DD	0		;terminate the start address list
sEnd	BC_SAE			

sBegin	XC			
	DD	B$TERM 		;stuff address of BEND in c-term vectors
sEnd	XC			

sBegin	_DATA

	externW b$term_disp	;"ONE" time termination dispatch vectors
	externW b$end_disp	;"END" time termination dispatch vectors
	externB b$inonerr	;on error in progress flag
	externW b$errnum	;Error number
	externB b$EventFlags	;Break key hit flag

sEnd	_DATA

sBegin	_BSS

	externB b$fRTInit

sEnd	_BSS


	SUBTTL	Runtime Core Termination
	PAGE
assumes CS,RT_TEXT		
sBegin	RT_TEXT			

;***
;B$CENP - Default termination routine for the runtime core.
;PLM B$CENP()
;
;Purpose:
;	Runtime entry point.  The last call in any basic module is a
;	call to B$CENP.  This is the default end procedure when no
;	explicit END or SYSTEM is performed.  This routine checks
;	to make sure that we are not in the middle of an ON ERROR.  If
;	ON ERROR is in progress then we issue a NO RESUME error and
;	let the error handler take over.  Otherwise we call a common
;	routine to clean up and terminate.
;
;Entry:
;	b$inonerr - non zero if ON ERROR is in progress.
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	Does not return.
;****
cProc	B$CENP,<PUBLIC,FAR,FORCEFRAME> 
cBegin
	CMP	b$inonerr,0	;Is error in progress?
	JZ	NOTERR		;continue if not
	JMP	FAR PTR B$ERR_NR ;No RESUME error
NOTERR:
	MOV	b$errnum,0	;reset error number for non error exit.
	JMP	exStEnd 	;branch to interpreter END executor
cEnd	nogen			
	PAGE
;***
;B$CEND,B$IEND - Termination routine for the runtime core.
;PLM B$CEND()
;PLM B$IEND()
;
;Purpose:
;	Runtime entry point for SYSTEM and END.  Calls common routine
;	to clean up and terminate runtime.
;	B$CEND is specific to the compiler, B$IEND is specific to
;	the interpreter.  Note that compiled code executing an END in
;	the interpreter environment will cause the runtime to JMP to
;	the interpreter END executor.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	Does not return.
;****
cProc	B$CEND,<PUBLIC,FAR,FORCEFRAME> 
cBegin
	MOV	b$errnum,0	;reset error number for non error exit.
	JMP	exStEnd 	;branch to interpreter END executor
				;fall into B$END (doesn't return)
cEnd	nogen			

labelFP <PUBLIC,B_IEND> 	;Intepreter reachable label
cProc	B$IEND,<PUBLIC,FAR,FORCEFRAME> 
cBegin				
	CALL	CloseFiles	; close all files NOW, while we can still
				; print error messages
	cCall	B$ULTerm	;terminate user libraries
	MOV	b$errnum,0	;reset error number for non error exit.
	JMP	SHORT EndNoClose ; go into B$END (doesn't return)
cEnd	nogen			
	PAGE
;***
;B$END - Common termination routine for the runtime core.
;PLM B$END()
;DBCS-callback
;
;Purpose:
;	Common routine to perform runtime termination.	Indirectly
;	dispatches to all routines in the b$rtterm dispatch vector.
;	This routine exits to DOS by calling the c termination routine
;	_exit.	_exit will then call B$TERM to finish runtime termination
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	Does not return.
;****
cProc	B$END,<PUBLIC,NEAR>			
cBegin

	CALL	CloseFiles	; close all files NOW, while we can still
				; print error messages.  If we do get an
				; error, we will eventually make it back
				; here.

EndNoClose:			; entry point for B$IEND
	XOR	AX,AX		;0 termination code
	cCall	_exit,<AX> 	; does not return
cEnd	<nogen> 		

cProc	CloseFiles,<NEAR>	
cBegin
	MOV	b$inonerr,-1	; don't allow ON ERROR after this point
	CMP	b$fRTInit,0	; was RT ever initiliazed?
	JZ	@F		; brif no, the following would hang
	MOV	SI,OFFSET DGROUP:b$end_disp ; "END" time termination vecs
	cCall	B$COMP_DISP	; indirectly call END time term, which
				; will close all files.  Do this NOW so
				; that errors are recoverable.


@@:				
cEnd				
	PAGE
;***
;B$TERM - Common termination routine for the runtime core.
;PLM B$TERM ()
;
;Purpose:
;	Common routine to perform runtime termination.	Indirectly
;	dispatches to all routines in the b$rtterm dispatch vector.
;	This routine is called by _exit (c termination) when all XC
;	segment routines are dispatched to.
;
;Entry:
;	b$enddisp - contains dispatch addresses for component specific
;		    "END" time termination routines.  Points to B$NearRET if
;		    no specific termination is needed.
;	b$termdisp - contains dispatch addresses for component specific
;		    "One" time termination routines.  Points to B$NearRET if
;		    no specific termination is needed.
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	Does not return.
;****
cProc	B$TERM,<PUBLIC,FAR>,<SI>		
cBegin

;	If chaining in progress, just return.  No BASCOM termination
;	should be done.


;	NOTE: QBI calls UiInit after B$IINIT.	This is the matching
;	call to UiTerm.  It is placed in the runtime for code size,
;	as all exit paths will come through this code.

	cCall	UiTerm				;Unhook UI interrupts
@@:						

;	Deinstall the RTM interrupt vector.  This is placed first to
;	to ensure that the vector is always installed and deinstalled
;	once under all circumstances.

	cCall	B$RTMDeinstall 		;deinstall the RTM interrupt vector

	CMP	b$errnum,FE_NOTHINGBASE	;check for fatal init errors
	JAE	EXITQUICK		;brif fatal init error
	CALL	CloseFiles		; "End" time termination.  Should
					; already be done.  Just doing
					; it to be safe.
	MOV	SI,OFFSET DGROUP:b$term_disp	;"One" time termination vecs
	cCall	B$COMP_DISP			;do ONE time termination
EXITQUICK:
	mov	b$fRtInit,0		; Runtime no longer initialized
cEnd						


;***
; B$BREAK
;
;Purpose:
; Moved with revision [16].
; Internal entry point to print Break message and terminate.
;
;Entry:
; none
;
;Exit:
; Doesn't
;
;Modifies:
;	ALL
;*****
cProc	B$BREAK,<NEAR,PUBLIC>
cBegin

	AND	b$EventFlags,NOT CNTLC ; reset break flag
	JMP	B$IStop		; let interpter stop execution

cEnd	nogen

;***
; B$IEndSt   - END Statement support for interpreter.
;PLM B$IEndSt()
;
;Purpose:
;	Added as part of [13].
;	This routine supports the interpreter end statement.  This routine
;	closes files, resets devices etc.
;
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	None.
;****
cProc	B$IEndSt,<PUBLIC,FAR>,<SI>
cBegin
	MOV	SI,OFFSET DGROUP:b$end_disp	;"END" time termination vecs
	cCall	B$COMP_DISP			;indirectly call END time term.
	MOV	b$inonerr,0			;reset on error flag
cEnd
sEnd	RT_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\rtllinit.asm ===
TITLE	RTLLINIT - Low Level Core initialization module
	PAGE	56,132
;***
;RTLLINIT.ASM - Low Level core initialization module
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains low level initialization support for the
;	BASIC 3.0 runtime.  This module will always be present in a user's
;	program.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc
;
;	Code Segments
;
	USESEG	<RT_TEXT>	;runtime core
;
;	Data Segments
;
	useSeg	_DATA		
	useSeg	_BSS		;runtime data (uninitialized)

	INCLUDE seg.inc
	INCLUDE idmac.inc	


	SUBTTL	Runtime data definitions for Low level BASIC Runtime Core
	PAGE

sBegin	_DATA			
sEnd	_DATA			

sBegin	_BSS

;
;	Global data
;
;***
;b$RcoFlg - Flag to indicate if Ronco keyboard is present
;OEM-interface routine (variable)
;
;Purpose:
;	This variable is a flag used to indicate if a Ronco (101 key or
;	extended) keyboard is attached to the system.  This keyboard has
;	to be handled specially in the runtime code because of the extra
;	function keys.
;
;Allocation:
;	b$RcoFlg is a BYTE value declared in the _BSS segment by
;	the OEM.
;
;Values:
;	0   - Normal keyboard present
;	10H - Extended (Ronco) keyboard present
;
;Initially Set:
;	b$RcoFlg will be initialized by the OEM-Dependent code during
;	the call to B$RTLLINI or B$GWINI.
;
;Modified By:
;	Once set, this value is never changed.
;
;Used By:
;	OEM-Dependent code and any code dealing with the function keys.
;****
	staticW b$llequipflags,?	; hardware equipment flags.
	staticB b$llmachineid,?		; machine id. PC,XT,AT,JR,etc.
	globalB b$RcoFlg,?		; NZ if ronco present

sEnd	_BSS


assumes CS,RT_TEXT			
sBegin	RT_TEXT				

	externNP	B$SEGINI	

	SUBTTL	Runtime Low Level Core Initialization
	PAGE
;***
;B$RTLLINI - OEM-Dependent runtime initialization.
;OEM-interface routine
;
;Purpose:
;	OEM-Dependent initialization for all of the BASIC runtime.
;
;	There are two different OEM-Dependent initialization routines
;	B$RTLLINI and B$GWINI. In terms of functionality, there is no
;	difference between the two routines.  B$GWINI is from an earlier
;	concept of the organization of the runtime while B$RTLLINI is from
;	a newer, more structured approach to the runtime.  Eventually,
;	we hope to be able to distribute the code currently in B$GWINI
;	but until that time there are two initialization routines.
;
;	The following differences exist between the two routines:
;
;		B$RTLLINI		B$GWINI
;		Called before B$GWINI	called after B$RTLLINI
;
;	Currently, this routine only sets b$RcoFlg and then calls
;	B$SEGINI.
;
;Entry:
;	None.
;
;Exit:
;	AX != 0 if initialization failed.
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None.
;******************************************************************************
;
;     Get Machine ID.
;     Get keyboard type.
;     Save equipment flag.
;
;#**

cProc	B$RTLLINI,<PUBLIC,NEAR>,<ES>
cBegin

;
;	Get the machine ID and save it in b$llmachineid.
;	The machine ID is located at 0FFFF:0E and are mapped as
;	follows:
;		PC	0FFH
;		XT	0FEH
;		JR	0FDH
;		AT	0FCH
;
	MOV	BX,0FFFFH		;segment 0FFFFH
	MOV	ES,BX			;address with ES
	MOV	AL,ES:[000EH]		;get machine ID
	MOV	b$llmachineid,AL	;save machine ID

;
;	Check whether the Ronco is presented.  Ronco may be installed on
;	XT or AT only.	If presented, bit 4 at 0000:496H (actually 40:96H)
;	is on.

	XOR	AX,AX			;segment 0000H
	MOV	ES,AX			;address with ES
	CMP	b$llmachineid,0FCH	; AT or newer model ?
	JBE	ChkRco			; Brif yes
	CMP	b$llmachineid,0FEH	; XT is another possibility
	JNZ	KybChkEnd		; Brif not
ChkRco: 				
	MOV	AL,ES:[496H]		; get KB_FLAG_3 in BIOS data seg
	AND	AL,10H			; mask the other bits
	MOV	[b$RcoFlg],AL		; save the result (either 0 or 10H)

;	Save the equipment flags in b$llequipflags.
;	The equipment flags are located at 0000:410H.
;
KybChkEnd:				
	MOV	AX,ES:[410H]		;get equipment flags.
	MOV	b$llequipflags,AX	;save equipment flags.
	cCall	B$SEGINI		

	XOR	AX,AX			;return 0 => init OK, no errors
cEnd

	SUBTTL	D5OPEN - DOS 5 OPEN helper
	PAGE



sEnd	RT_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\rtmload.asm ===
TITLE	RTMLOAD - Runtime module loader
;***
; RTMLOAD - DOS 2/3 Runtime Module Loader
;
;	Copyright <C> 1986, Microsoft Corporation
;
; Purpose:
;	This module is linked to a BASCOM-generated object
;	file created with the RTM option (no /O).  This code
;	will load the RTM EXE directly and place the code in
;	high memory and the data to the compiled program DGROUP.
;	The RTM code will then finish the initialization and
;	start execution of the compiled program.
;
;	This module is also used to load a user libraries EXE file
;	into high memory, along with it's symbol table, for the
;	QB4 interpreter.  QB4 user libraries are very similar to the
;	compiler DOS 3 RTM except that user libraries also contain
;	a symbol table concatenated to the end of the file.
;
;******************************************************************************

INCLUDE	switch.inc
INCLUDE	rmacros.inc			

	USESEG	<_DATA>			

INCLUDE seg.inc				
INCLUDE	addr.inc
INCLUDE baslibma.inc
INCLUDE files.inc			
INCLUDE array.inc			
INCLUDE rtps.inc			
INCLUDE ulib.inc			
INCLUDE const.inc			
INCLUDE string.inc


CondEnd	MACRO	entrypoint		; generate END
	END				
	ENDM				

	CreateSeg	LOADRTM,LOADRTM,BYTE,	PUBLIC, CODE		
	CreateSeg	LOADRTMEND, LOADRTMEND, PARA, PUBLIC, CODE	
	CreateSeg	CODE,	UL_TEXT,BYTE,	PUBLIC, CODE		


INCLUDE idmac.inc			

;	QBI message numbers used to call QBI message mapper

	EXTRN	ER_DMA:ABS		;Dos Arena error
	EXTRN	ER_ULM:ABS		;Memory allocation error
	EXTRN	ER_ULO:ABS		;Out of memory error
	EXTRN	ER_ULI:ABS		;Invalid user library format error
	EXTRN	ER_ULD:ABS		;Disk IO error
	EXTRN	ER_ULF:ABS		;Cannot find file error (if redirected IO)
	EXTRN	ER_ULE:ABS		;Error message preamble
	EXTRN	ER_ULG:ABS		;Error message postamble
	EXTRN	ER_ULP:ABS		;Path prompt preamble
	EXTRN	ER_ULT:ABS		;Path prompt postamble

	externFP B$END			;Quick exit routine
	externFP B$Pause		;Displays - Hit any key to continue
	externFP B$Shell		;QBC Exec helper
	externFP B$ShellSetup		;Prepares runtime for QBC Exec
	externFP B$ShellRecover 	;Recovers state after QBC exec
	externFP B$ULDataRelease	;releases data images
	externFP B$ULTerm		;calls UL terminators
	externFP B$ULGetCommon		;search for compiled common
	externFP B$ITCR 		; print CR-LF 
	externFP OpenCheckDrive		
	externFP FindAndOpenFile
	externFP B$FHAllocFAR		
	externFP B$FHDeallocFAR 	
	externFP __ctermsub		; terminates math and restores
					; divide-by-zero interrupts


INCLUDE	exehdr.inc		;structure for EXE file header area



sBegin	_DATA			
	externW	__psp		;program prefix
	externB bufStdMsg	;QBI message buffer
	externW b$pBC_SAB	;ptr to BC start address table
	externW __asizds	;max DGROUP space
	externW STKHQQ		;C low water mark for stack
	externW __atopsp	;top of allocated stack space
	externW b$pend 	;bottom of allocated stack space
	externW b$pendchk	;low water mark for stack
	externW b$ULSymSeg	;User Library symbol table segment
	externW b$ULDataLength ;length of UL static data
	externW b$ULDataStart	;offset of UL static data in DGROUP
	externW b$FHDStart	;terminating Far heap descriptor
	globalW b$pULVars,0	;address of shared data defined in UL
	externB fDebugScr	; address of shared data defined in UL
	externB b$Buf1		; general purpose filename buffer
	externB qbIniFName	; Literal "qb.ini"
	externW bdExePath	; bd for user-specified exe path
	externW bdLibPath	; bd for user-specified lib path
	externW bdInclPath	;bd for user-specified include path
QBINC	db	'_QB_INC='	;our own environment variable name
	cbQBINC = $ - QBINC	;length of the string

	public	CB_bufPath	
	public	CB_bufLib	

	globalB bufPath,<"PATH">	
	CB_bufPath	=   $ - bufPath 
	globalB bufLib,<"LIB">
	CB_bufLib	=   $ - bufLib	
	globalB bufCurDir,<".\",0>      



sEnd	DATA



assumes	CS,LOADRTM
assumes	DS,LOADRTM
assumes	ES,NOTHING

sBegin	LOADRTM


;	Data for runtime module loader.

EHBuffer	DB	SIZE ExeHeader DUP(?) ;buffer for RTM EXE header

	externNP ListStdMsgRtmNear	;QBI message mapper

ULBuffer	DB	SIZE UserLib_Hdr DUP(?) ;buffer for UL header


ProgramPSP	DW	1 DUP(?)	;PSP of program

RtmCodeSeg	DW	1 DUP(?)	;local copy of code Seg
RtmCodeSize	DW	1 DUP(?)	;size of RTM code

ULSymSeg	DW	1 DUP(?)	;segment of user lib symbol table
ULSymSize	DW	1 DUP(?)	;size of user lib symbol table
DbPub		ULSquishSize		
DbPub		ULCodeSquishSize	
ULSquishSize	DW	1 DUP(?)	;byte count of compressed leading
					;  zeros in QLB, both DATA and CODE
ULCodeSquishSize DW	1 DUP(?)	;byte count of compressed leading
					;  zeros at start of QLB code

ULCheckSum	DW	1 DUP(?)	;check sum for user library
fQBCExec	DB	0		;non-zero if QBC compile in progress
fULQBCReload	DB	0		;non-zero if we need to reload
					;UL because of QBC exec.
fNoIntHooked	DB	0		; non-zero if no interrupts are
					; hooked (during make-exe) and
					; __ctermsub shouldn't be done upon
					; error.

PathEnvPtr	LABEL	DWORD		
RelocBufPtr	LABEL	DWORD

SavedSSinCS	LABEL	WORD		
PathEnvOffset	LABEL	WORD
RelocBufOffset	LABEL	WORD
		DW	1 DUP(?)	;offset to ENV PATH or reloc item

SavedSPinCS	LABEL	WORD		
PathEnvSegment	LABEL	WORD
RelocBufSegment	LABEL	WORD
		DW	1 DUP(?)	;segment to ENV PATH or reloc item

QBCDataBlock	STRUC
	CommandList	DW	?	;Set by UI - psd of commands to exec.
	fErrorCode	DW	?	;Set by Loader - non zero if an error
					;occurred in one of the execs (contains
					;error code returned by the exec.
QBCDataBlock	ENDS

PUBLIC	b$QBCData
b$QBCData	QBCDataBlock<>		;QBCData block - defined in LOADRTM seg


QBExe	DB	'QB.EXE',0		;name of QB interpreter
	EXEExt	EQU OFFSET QBExe + 2	;pts to .EXE extension


	QBExeLength = $ - QBExe 	;length of the file name
LibString	DB	"LIB="		;environment variable for LIB
	LibStringLength = $ - LibString 


Filename	DB	"QB.QLB",0	;default userlib filename
	FilenameLength	= $ - Filename	;length of just the filename
	QLBExt EQU OFFSET Filename + 2	;pts to .QLB extension

;	The following three items are order-dependent.

PUBLIC	b$ULfsd
PUBLIC	b$ULNameLen
PUBLIC	b_ULfsd 			;Interpreter Reachable Label
PUBLIC	b_ULNameLen			;Interpreter Reachable Label

b_ULfsd LABEL	WORD			;Interpreter Reachable Label
b$ULfsd	DW	OFFSET Filename		;Offset of user lib name
		DW	SEG LOADRTM	;Segment of user lib name
b_ULNameLen	LABEL	WORD		;Interpreter Reachable Label
b$ULNameLen	DW	FilenameLength	;Length of user lib name


;
;Definition of Bits for fUserPrompt
;

F_SAVED  = 1 ; We have saved the QLIB name (TRUE) vs not been saved (FALSE)
F_PRPATH = 2 ; We should print path with msgs (TRUE) vs. base name only (FALSE)

fUserPrompt	DB	0		; Flags for loading a file.


;	The following string descriptors are order dependent.

sdNull	DW	szNullLength,OFFSET szNull ;string desc for NULL
sdStack DW	szStackLength,OFFSET szStack ;string desc for STACK
sdSym	DW	szSymLength, OFFSET szSym  ;string desc for SYMBOLS
sdBSA	DW	szBSALength, OFFSET szBSA  ;string desc for BC_SAB


szNull	DB	'NULL',0
	szNullLength = $ - szNull

szStack DB	'STACK',0		
	szStackLength = $ - szStack	

szSym	DB	'SYMBOL',0
	szSymLength  = $ - szSym

szBSA	DB     'BC_SAB',0
	szBSALength = $ - szBSA

;	String descriptor for b_ULVars (shared data defined in UL).

sdULVars DW	szVarLength,OFFSET szVars ;string desc for b_ULVars

szVars	DB	'B_ULVARS',0		
	szVarLength = $ - szVars	

; Note:  The Name Buffer Length only needs to be a byte.  However by
; wasting one byte here, we save several bytes later in the file by
; not having to clear CH when we do a MOV CX,FNameBuffLen

	MaxFNameBuff = 13		; Maximum length of a filename

	DbPub	FNameBuff
	DbPub	FNameBuffLen
FNameBuff	DB  MaxFNameBuff DUP(?) ;Buffer for filename as it is created
FNameBuffLen	DW  1 DUP(0)		;Length of FNameBuff (must be inited)

;	The following three items are order-dependent.
	DbPub	SpecBuffer
InputMaxLen	DB	SpecBufLength	;max length for DOS 0AH input
InputStrLen	DB	1 DUP(?)	;length returned by DOS 0AH input
SpecBuffer	DB	FILNAML DUP(?)	;buffer for RTM file specification
	SpecBufLength	= FILNAML -1 -FilenameLength ;max path that will fit

;	Error messages are defined in the include file for localization.

INCLUDE	messages.inc

;***
;StartupStub - runtime module startup code (RTM Only).  Added with [41].
;
;Purpose:
;	This code is executed BEFORE the C startup.  The RTM is loaded
;	(if the program has not been chanined to), and the C startup (in
;	the RTM is jumped to).
;Entry:
;	DS = ES = PSP of new program.
;Exit:
;	RTM loaded if not chaining.
;Uses:
;	All.
;Exceptions:
;	None
;******************************************************************************


;***
; B$RtmLoad - runtime module loader (RTM Only)
;
;Purpose:
;	This code is executed BEFORE the C startup if the program has
;	not been chained.  The RTM is loaded and DGROUP is built.
;Entry:
;	SS = DGROUP of new program.
;	ES = LOADRTM
;Exit:
;	DS, ES destroyed.
;Uses:
;	All
;Exceptions:
;	Various errors given if error occurs in loading RTM.
;******************************************************************************


;***
; B$ULLoad - User library loader and initialization (UL Only)
;
;Purpose:
;	Added as part of revision [10].
;	This code is executed after the C startup.  QB4 has parsed the
;	command line and called B$IINIT to init the runtime.  B$IINIT
;	calls B$ULLOAD to load a user library.  B$ULLoad will determine
;	if a library is to be loaded, load it, and build DGROUP.
;Entry:
;	DS = DGROUP of new program.
;	SS:SI = ptr to command parameters
;		[SI]   - UlibNameOffset
;		[SI+2] - UlibNameSegment
;		[SI+4] - cbLibName
;	If [SI] = 0, then no /L was found
;	If [SI] = FFFF, then /L without filename found
;	else [SI+2]:[SI] = far pointer to filename, [SI+4] = length of filename
;
;Exit:
;	DS = ES = DGROUP of new program.
;	BP = 0
;	b$pULSyms = far pointer to symbol table for user library.
;
;Uses:
;	All.
;Exceptions:
;	Initialization errors:
;		"memory allocation" error
;		"disk I/O" error
;		"invalid format" error
;		"out of memory" error
;		"DOS memory arena corrupted" error
;******************************************************************************

;	Assume C startup has been done - program memory has been
;	cut back to top of STACK.

;	Code for user library loader.  Set up segment registers.


;*** 
; ULLoad - Core user library loader (UL Only)
;
;Purpose:
;	Added as part of revision [18].
;	Does the core user library loading.
;Entry:
;	DX:SI = Filename to load
;	CX    = Length of that file
;Exit:
;	AX - end of static data after load.
;Uses:
;	All.
;Exceptions:
;	Initialization errors:
;		"memory allocation" error
;		"disk I/O" error
;		"invalid format" error
;		"out of memory" error
;		"DOS memory arena corrupted" error
;******************************************************************************


;***
;	Standalone error messages - output and exit to DOS. (RTM and UL)
;
;******************************************************************************

NoFileError:			
	MOV	AX,ER_ULF	;get error number
	JMP	SHORT PrintError ;jump to give "cannot find file" error
MemAllocError:
	MOV	AX,ER_ULM	 ;get error number
	JMP	SHORT PrintError ;jump to give "memory allocation" error
OutOfMemError:
	MOV	AX,ER_ULO	 ;get error number
	JMP	SHORT PrintError ;jump to give "out of memory" error
ArenaBadError:
	MOV	AX,ER_DMA	 ;get error number
	JMP	SHORT PrintError ;jump to give "Arena trashed" error
InvalidError:
	MOV	AX,ER_ULI	 ;get error number
	JMP	SHORT PrintError ;jump to give "invalid userlib" error
DiskIOError:
	MOV	AX,ER_ULD	 ;get error number give "UL disk I/O" error

assumes DS,LOADRTM

PrintError:
	PUSH	SS		
	POP	DS		;set DS to current DGROUP

assumes DS,DGROUP


	PUSH	AX		;save error number
	MOV	AX,ER_ULE	;get number of UL error message preamble
	CALL	PrintMessage	;print message preamble
	CALL	PrintFileName	;print file name
	MOV	AX,ER_ULG	;get number of postamble
	CALL	PrintMessage	;print message postamble
	POP	AX		;recover error number
	CALL	PrintMessage	;Print error message
	CMP	b$ULSymSeg,0	;non zero if we have finished initialization
	JZ	Scram		;brif we haven't finished initialization
	JMP	B$END		;print error message and terminate

labelFP <PUBLIC,B$IScram>	;Kill QBI entry point

Scram:
	cmp	cs:fNoIntHooked,0	; do we have any interrupts hooked?
	jnz	NoIntHooked		; brif not
	push	ss			; DS = DGROUP
	pop	ds			
	cCall	__ctermsub		; de-install math and divide by zero
NoIntHooked:				; interrupts.
	MOV	AX,(C_EXIT SHL 8)+1;dos exit with error return code
	INT	21H		;exit

assumes DS,NOTHING



;*** 
; B$ShellEntry - runtime EXEC routine for SHELL (RTM only)
;
;Purpose:
;	[Added within revision 5.]
;	Since the runtime module code is discarded during a SHELL
;	operation, this routine deallocates the RTM code, performs
;	the EXEC specified, and then reloads the RTM code with fixups.
;Entry:
;	Parameters set for DOS EXEC call.
;Exit:
;	AX = post-INT 21 value.
;	CF = post-INT 21 value.
;Uses:
;	All.  RTM saved the registers it needs.
;Exceptions:
;	InvalidError if bad EXE format.
;	DiskIOError if error during RTM disk operations.
;******************************************************************************


;***
; B$ULReload - reload a user library. (UL only).
;
;Purpose:
;	Added as part of revision [10].
;	Reloads user library code and data, effectively
;	reinitializing static data for subsequent execution.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	AX, BX, CX, DX.
;Exceptions:
;	Initialization errors:
;		"disk I/O" error
;		"invalid format" error
;****


cProc	B$ULReload,<PUBLIC,FAR>	
cBegin				
cEnd				


;***
; ULSaveName - Allocate a high memory block for UL name (UL Only)
;
;Purpose:
;	Added as part of revision [12].
;	Allocate a high memory block to save user library
;	file name in.  Update b$ULfsd to point to the
;	allocated block.
;Entry:
;	Filename is in SpecBuffer
;	Length is in InputStrLen
;
;Exit:
;	[b$ULfsd] = 0
;	[b$ULfsd+2] = allocated segment
;	[b$ULNameLen] = byte size of user library name string
;Uses:
;	BX, CX, DX, SI, DI, BP
;
;Preserves
;	AX
;
;Exceptions:
;	DOS Memory allocatation error.
;	Out of memory error.
;****


;***
; ULAllocHighSeg - Allocate high memory block <= 64K from (UL only)
;
;Purpose:
;	Added as part of revision [12].
;	Allocate a high memory block from DOS.	The block
;	will be a max of 64K in length.
;Entry:
;	DX = byte size of block to allocate
;Exit:
;	BP = segment of allocated block
;Uses:
;	CX, DX, DI.
;Exceptions:
;	DOS Memory allocatation error.
;	Out of memory error.
;****


;***
; PrintMessage - print a numbered message. (UL only)
;
;Purpose:
;	Added with revision [19].
;	Takes the numbered message, calls a QB helper routine to
;	put the message in bufStdMsg and then prints the message to
;	through DOS.
;Entry:
;	AX - number of message to print.
;Exit:
;	None.
;Uses:
;	AX,CX,SI.
;Exceptions:
;	None.
;******************************************************************************

cProc	PrintMessage,<NEAR>,<DS>
cBegin

	PUSH	SS
	POP	DS

assumes DS,DGROUP

;	AX has message number.

	PUSH	ES		;preserve ES across ListStdMsgRtmNear
	cCall	ListStdMsgRtmNear ;AX = char count, bufStdMsg = msg text
	POP	ES
	MOV	SI,OFFSET DGROUP:bufStdMsg ;[DS:SI] = ptr to message text
	XCHG	AX,CX		;[CX] = message length
	JMP	SHORT PrintFileLoop ;jump and print message
cEnd	<nogen>

;***
; PrintFileName - print file name in SpecBuffer or FNameBuff. (UL only)
;
;Purpose:
;	This routine prints the current UserLib Filename.  If F_PRPATH
;	in fUserPrompt is true, then we will a print path with the name
;	(both comming from SpecBuffer).  Otherwise, we will print the
;	name only (from FNameBuff).
;
;	Since FNameBuffLen is statically initialized to 0, this routine
;	will work even if no name has yet been parsed.
;
;Entry:
;	if (fUserPrompt & F_PRPATH)
;	    FNameBuff	 - filename to print.
;	    FNameBuffLen - length of file name.
;	else
;	    SpecBuffer	 - path and filename to print.
;	    InputStrLen  - Length of SpecBuffer.
;Exit:
;	None.
;Uses:
;	AX,CX,SI.
;Exceptions:
;	None.
;******************************************************************************

cProc	PrintFileName,NEAR,DS ; Added
cBegin
	PUSH	CS
	POP	DS

assumes DS,LOADRTM

	TEST	fUserPrompt,F_PRPATH	;Should we print path?
	JE	NoPrintPath		;No, get filename from FNameBuff

	MOV	SI,OFFSET SpecBuffer	;get ptr to file name and path
	XOR	CH,CH			;Clear CH for length
	MOV	CL,InputStrLen		;Get length of filename and path
	JMP	SHORT PrintFileMain	;Go print the string

NoPrintPath:
	MOV	SI,OFFSET FNameBuff	;get ptr to filename
	MOV	CX,FNameBuffLen 	;get length of filename

PrintFileMain:
	JCXZ	EmptyFileName	;Eliminate degenerate case

PrintFileLoop:
	LODSB			;get char in AL
	MOV	DL,AL		;[DL]=char to output
	MOV	AH,2		;DOS char output function
	INT	21H		;print char
	LOOP	PrintFileLoop	;repeat until all chars are printed

EmptyFileName:
cEnd

;***
; B$IInitPrint - print a numbered message before runtime inited. (QBI only)
;
;Purpose:
;	Added with revision [20].
;	Takes the numbered message, calls a QB helper routine to
;	put the message in bufStdMsg and then prints the message to
;	through DOS.
;Entry:
;	AX - number of message to print.
;Exit:
;	None.
;Uses:
;	AX,CX,SI.
;Exceptions:
;	None.
;******************************************************************************

cProc	B$IInitPrint,<PUBLIC,FAR>
cBegin

;	AX has message number.

	cCall	PrintMessage	;print the numbered message
cEnd


LoadRtmInfoInvalid:
	JMP	InvalidError	;jump to report invalid EXE error

;***
; LoadRtmData - load the runtime data segment (RTM only)
;
;Purpose:
;	[Extracted from LoadRtmFile in revision 5.]
;	From the start of the load image, load the data segment
;	into the program DGROUP.  The region loaded starts at
;	segment CONST up to, but not including, segment COMMON.
;Entry:
;	BX - handle of opened RTM file.
;Exit:
;	DGROUP from CONST up to COMMON overlaid.
;Uses:
;	AX, CX, DX, SI, DI, BP.
;Exceptions:
;	None.
;******************************************************************************


;*** 
; LoadULData - load the user library data into DGROUP (UL only)
;
;Purpose:
;	Added as part of revision [10].
;	Load data from the user library data segment into DGROUP.
;	The region loaded starts from the end of the DGROUP
;	static data to the end of the user library static data.
;	DGROUP will be grown by the size of the user library
;	static data, and the stack will be moved into the highest
;	memory of the grown DGROUP.  Any pointers into the stack
;	will be invalidated.
;Entry:
;	BX - handle of opened RTM file.
;	ES = DS - LoadRtm segment
;Exit:
;	AX = new end of DGROUP static data
;	Stack moved, and user library data read into hole vacated
;	by the stack.
;	__atopsp - points to new beginning of stack
;	b$pend  - points to new end of stack
;	b$pendchk - points to new stack check boundary
;Uses:
;	AX, CX, DX, SI, DI, BP.
;Exceptions:
;	Out of memory.	Invalid UL format.
;******************************************************************************


;***
;ReloadULData - load/reload UL data into hole created in DGROUP (UL Only)
;
;Purpose:
;	Added with revision [10].
;	Loads initial copy of data, or reloads copy of data for each RUN.
;	The user library data is recopied into DGROUP.	This will
;	cause any preinited static data to be correct for a subsequent
;	run.
;
;	If blank COMMON is in preinited data, this procedure would
;	reinitialize it, trashing user's values across CHAIN.  To avoid
;	this, a check is done for the existence of blank COMMON.  If found,
;	the data is moved in two chunks: "Part1" is the data before the
;	COMMON block, "Part2" is the data after the COMMON block.  This
;	will preserve the blank COMMON in the middle for CHAIN.
;
;	Note: Not loading COMMON here is ok for RUN also, because it
;	      would only be zeros, and the RUN initialization will
;	      zero the common for us.
;
;Entry:
;	CX - start of DGROUP area to copy UL data into
;	DI - byte size of UL data
;	DS - DGROUP
;Exit:
;	data copied into DGROUP (unfixed up)
;Uses:
;	AX, CX, DX, SI, DI, BP, DS, ES.
;Exceptions:
;	None.
;****

;*** 
; GetRtmCodeSize - compute the runtime module code size (RTM only)
;
;Purpose:
;	(Mostly rewritten with revision [60].)
;	[Extracted from LoadRtmFile in revision 5.]
;	Compute the size of the load image from the EXE header
;	information.  Then use the CODE segment value from the
;	frame buffer to compute the code size of the runtime module.
;Entry:
;	EHBuffer has EXE header.
;	RLBuffer has entry point frame.
;Exit:
;	DX:AX - code size in bytes.
;Uses:
;	AX, CX, DX.
;Exceptions:
;	None.
;******************************************************************************


;*** 
; LoadRtmCode - load the rtm code, or user lib syms (RTM Only)
;
;Purpose:
;	[Extracted from LoadRtmFile in revision 5.]
;	Read the code section of the runtime module
;	into memory.
;Entry:
;	BX - handle of opened RTM file.
;	DX:AX - size in code segment in bytes.
;	BP - segment to load code.
;Exit:
;	Block at segment BP has RTM code with no fixups.
;Uses:
;	AX, CX, DX, SI, DI.
;Exceptions:
;	DiskIOError if error during RTM file reading.
;******************************************************************************


;***
; LoadULCode - load the user lib code into high memory (UL Only)
;
;Purpose:
;	Added as part of revision [10].
;	Compute the size of the user library code. Allocate
;	memory from DOS as high as possible.
;	Read the code sections of the user lib
;	into their appropriate locations in memory.
;Entry:
;	BX - handle of opened RTM file.
;Exit:
;	Block at segment RtmCodeSeg has UL code with no fixups.
;	RtmCodeSize has paragraph size of UL code.
;Uses:
;	AX, CX, DX, SI, DI, BP.
;Exceptions:
;	Memory error if memory could not be allocated.
;	DiskIOError if error during RTM file reading.
;******************************************************************************


;***
;ReloadULCode - Load/Reload UL code into allocated space (UL only)
;
;Purpose:
;	Added as part of revision [10].
;	Loads/Reloads user library code into allocated block.
;Entry:
;	BP - segment to load code into.
;	DX - paragraph size of code to load.
;Exit:
;	The unfixed up code is loaded into the specified location.
;Uses:
;	AX, CX, DX, SI, DI, ES
;Exceptions:
;	None.
;****


;***
; LoadULSymbols - load the user lib symbol table into high memory (UL Only)
;
;Purpose:
;	Added as part of revision [10].
;	Compute the size of the user library symbol table.
;	Allocate memory from DOS as high as possible.
;	Read the symbol table of the user lib into memory.
;Entry:
;	BX - handle of opened RTM file.
;Exit:
;	Block at segment ULSymSeg has UL symbol table with no fixups.
;	ULSymSize has byte size of symbol table.
;Uses:
;	AX, CX, DX, SI, DI, BP.
;Exceptions:
;	Memory error if memory could not be allocated.
;	DiskIOError if error during RTM file reading.
;******************************************************************************


;***
; ULUpcaseSymbols - convert all symbol table names to upper case (UL only)
;
;Purpose:
;	Added as part of revision [10].
;	Converts all symbol table names to uppercase to simplify
;	and speedup symbol table lookup routines.
;Entry:
;	BP - segment of symbol table
;Exit:
;	None.
;Uses:
;	AX, SI, DI, ES.
;Exceptions:
;	None.
;****


;***
; ULAdjustDXAX - back up far ptr in DX:AX by number of bytes in ULSquishSize
;
;Purpose:
;	Because of leading-zero compression in QLib files, the file pointers
;	need to be adjusted before calling LoadRtmBlock to load the Data
;	and Symbol segments.  The number of bytes compressed from the file
;	is in ULSquishSize.  This routine takes a far pointer in DX:AX and
;	backs it up ULSquishSize bytes. (Added with revision [38].)
;Entry:
;	DX:AX - far pointer to be adjusted
;	DS:[ULSquishSize] - number of bytes for adjustment
;	DS - LOADRTM
;Exit:
;	DX:AX - adjusted far pointer
;Uses:
;	None
;Exceptions:
;	None
;******************************************************************************


;***
; FixupRtmFile - apply fixups to RTM load  (RTM only)
;
;Purpose:
;	Read the fixup items from the RTM file and apply them
;	appropriately to the code and data section loaded into
;	memory.
;Entry:
;	BX - handle of opened RTM file
;	SI - zero to fixup both code and data (used in init)
;	     nonzero to fixup just code (used in SHELL)
;	BP - segment RTM is loaded in
;Exit:
;	None.
;Uses:
;	AX, CX, DX, DI, BP, ES.
;Exceptions:
;	DiskIOError if error during disk read of RTM file.
;******************************************************************************


;*** 
; FixupULFile - apply fixups to UL load  (UL only)
;
;Purpose:
;	Added as part of revision [10].
;	Read the fixup items from the UL file and apply them
;	appropriately to the code, data, and segment sections
;	loaded into memory.
;Entry:
;	BX - handle of opened RTM file
;	CX - symbol table fixup value (0 if already done).
;Exit:
;	None.
;Uses:
;	AX, CX, DX, SI, DI, BP, ES.
;Exceptions:
;	DiskIOError if error during disk read of RTM file.
;******************************************************************************




;*** 
; AppendExt - Append def extension to Filename in SpecBuffer if needed (UL Only)
;
;Purpose:
;	Added with revision [24].
;	Appends appropriate extension to the file in SpecBuffer if an extension
;	does not already exist.  If we are opening a user library, then .QLB
;	will be appended, otherwise .EXE is appended.
;
;	In addition to appending an extension to the file in SpecBuffer,
;	this routine will also save a copy of the basename and extension
;	in FNameBuff
;
;	If SpecBuffer contains a pathname without a filename (recognized by
;	the last char being a path char), then append the filename in FNameBuff
;	to the path in SpecBuffer.
;
;	No matter what the entry conditions, on exit from this routine the
;	following will be set up:
;	  FNameBuff has null-terminated filename part of filespec
;	  FNameBuffLen has length of what is in FNameBuff
;	  SpecBuffer has null-terminated filespec (ready for dos open)
;	  InputStrLen has length of what is in SpecBuffer
;
;Entry:
;	ES:DI = pointer in spec buffer after last byte of filespec.
;Exit:
;	ES:DI = pointer to first byte of filename part of filespec.
;		(if DI = OFFSET SpecBuffer, then there is no path specified)
;Uses:
;	AX, CX, DX, SI.
;Exceptions:
;	None.
;******************************************************************************


SearchChars	DB ':','/','\','.'      ;List of chars in order of search
cbSearchChars = $ - SearchChars 	;size of list

DbPub	AppendExt
cProc	AppendExt,<NEAR>
cBegin
	MOV	AX,DI			; In case buffer is empty
	CMP	DI,OFFSET SpecBuffer	; Is the buffer empty?
	JE	JE_NoFileName		; Yes, go special-case it

	MOV	CX,cbSearchChars	;get number of chars to search for
	MOV	SI,OFFSET SearchChars	;point to list
	XOR	DX,DX

;	Search for path chars, '/' and '\'.  Remember the address of
;	the last such char found.  Then search for an extension char
;	'.'.  If the address of this char is > than the address of the
;	last path char, then the filename had an extension.  This is
;	true since it is impossible to have a '.' after a path char
;	and not have it be part of a filename (eg it cannot be part
;	of a directory spec.


AppendSearchLoop:
	PUSH	CX			;save loop count
	PUSH	DI			;save end of file name
	MOV	CX,DI
	DEC	DI			;point to last char in name
	SUB	CX,OFFSET SpecBuffer	;compute char count in SpecBuffer
	LODSB				;[AL] = search char
	STD				;search backwards in file name
	REPNE	SCASB			;search backward for char
	CLD				;go forward again
	JNE	CharNotFound		;brif we did not find character
	INC	DI			;Set DI to char before last
CharNotFound:
	INC	DI			; REPNE SCASB subtracts 1 at end.
	XCHG	AX,DI			;save address of char/start of buffer

;NOTE:	Be careful here.  The results of the Next compare are used after
;	the loop is terminated. The current algorithm ensures that the
;	instructions used between this compare and the next branch after
;	the loop is terminated do not alter the carry and/or zero flag.


	CMP	AX,DX			;Is this char after prev char?
	JB	AppendSearchNext	;brif not
	XCHG	AX,DX			;remember address of char

AppendSearchNext:
	POP	DI			;recover end of filename
	POP	CX			;recover loop count
	LOOP	AppendSearchLoop	;continue until all chars searched for


;NOTE:	See NOTE above.

	JA	AppendExtExit		;brif already have the extension

; There are two conditions in which we do not have a filename:
;	 1.) An empty buffer, in which case we wont get here.
;	 2.) A path without a name, when DX = DI

	MOV	AX,DX			; Set AX = ptr to last path char
	CMP	DI,DX			; Check for no name specified
JE_NoFileName:
	JE	NoFileName		; None given, append the old one

;	File name needs an extension appended.	If we are loading a user lib,
;	then the extension is .QLB, otherwise, we must be loading an .EXE
;	file as the result of a QBC exec.  All of these files are .EXE
;	files.

	MOV	SI,EXEExt		;get ptr to .EXE extension
	CMP	fQBCExec,CL		;are we loading a user lib?
	JNZ	AddExt			;brif not - QBC exec loads .EXE files
	MOV	SI,QLBExt		;get ptr to .QLB extension for ulib

AddExt:
	MOVSW				; add 4-byte extension to file name
	MOVSW				

AppendExtExit:

DbAssertRel	CX,Z,0,LOADRTM,<AppendExt: trying to use CX for 0 and it's not>

	XCHG	CX,AX			; AL = zero, saving AX in CX
	STOSB				; null terminate the filename
	XCHG	CX,AX			; restore AX

; The starting point to copy is AX	=> SI
; The number of characters in the name is DI - AX => CX

	MOV	CX,DI			; Calculate Length of name
	SUB	CX,AX			;	without path
	CMP	CX,MaxFNameBuff 	; Are there too many characters
					;	in filename?
	JBE	ValidLength		; No, name is valid

;	There are a couple cases where we will have a double-null terminated
;	name here.  That could create a name 1 byte longer than ValidLength,
;	but it's not really a problem.  The release code will fall through
;	and cut back the length by 1, removing 1 null.	If there is a name
;	even longer than that, it's a bug.  Assert it.

DbAssertRel	CX,E,<MaxFNameBuff+1>,LOADRTM,<AppendExt: filename is too long>

	MOV	CX,MaxFNameBuff 	; Truncate name to max length
ValidLength:
	MOV	FNameBuffLen,CX 	; Save Length of FName
	MOV	SI,AX			; DS:SI points to begining of name
	MOV	DI,OFFSET FNameBuff	; ES:DI points to FNameBuff
	REP	MOVSB			; Copy the name only into FNameBuff
	MOV	DI,SI			; DI points 1 past end of filespec

;	Set InputStrLen = length of filespec in SpecBuffer

Return:
	SUB	DI,OFFSET LOADRTM:SpecBuffer ; DI = length of filespec
	XCHG	AX,DI			; DI = return value, AX = length
	MOV	[InputStrLen],AL	; Store the length

DbAssertRelB	AH,Z,0,LOADRTM,<AppendExt: filespec longer than 127 characters>

cEnd

NoFileName:
;	If we get here, SpecBuffer has a pathname (terminated with a path char)
;	but no filename.  If we already have a filename in FNameBuff, we'll
;	append it to the path in SpecBuffer

	MOV	CX,FNameBuffLen 	; length of name in FNameBuff
	MOV	SI,OFFSET LOADRTM:FNameBuff ; source pointer
	REP	MOVSB			; append the filename
	JMP	SHORT Return		; set return value and exit

;***
; OpenFile - Open the file specified in SpecBuffer.
;
;Purpose:
;	Added with revision [13].
;	Opens the filespec in SpecBuffer
;Entry:
;	SpecBuffer set up.
;Exit:
;	if open worked
;	    PSW.C reset
;	    AX = file handle
;	else
;	    PSW.C set
;	endif
;Uses:
;	Per convention.
;Exceptions:
;	Disk IO Error.
;******************************************************************************
cProc	OpenFile,<NEAR> 	;common routine to open file
cBegin				
	MOV	DX,OFFSET SpecBuffer ;DS:DX has pointer to file specification
OpenFile2:
	cmp	ss:fDebugScr,0		; brif not initialized and not
	jz	NoCheckDrive		; displaying QB's screen
	push	ds			; save LOADRTM segment

	mov	bx,dx			; put ptr into index register
	push	ds:[bx]			; OpenCheckDrive parm = first 2
					; of file spec (possible DRIVE:)

	push	ss			; DS = DGROUP for UI call
	pop	ds			
	call	OpenCheckDrive		; if required, switch DOS's logical
					; disk drive, and display message
					; "insert disk in drive X:"
					; PRESERVES ALL REGISTERS
	pop	ds			; restore register
NoCheckDrive:				
	MOV	AX,(C_OPEN SHL 8)+0  ;DOS function to open the file for input only
	INT	21H		;perform the open - carry set if failed
cEnd

;***
; CloseFile - Close the file handle in BX (RTM and UL)
;
;Purpose:
;	Added with revision [18].
;	Closes the file handle in BX.
;Entry:
;	BX - file handle to close.
;Exit:
;	None.
;Uses:
;	AX.
;Exceptions:
;	Disk IO Error.
;******************************************************************************

cProc	CloseFile,<NEAR>
cBegin
	MOV	AH,C_CLOSE
	INT	21H			;close the file
	JC	DiskError		;brif error
cEnd

DiskError:
	JMP	DiskIOError		;report the error and die.


assumes	DS,DGROUP


;***
; ULConsisCheck - performs consistency checks on user libs (UL only)
;
;Purpose:
;	Added as part of [10].
;	Does user library consistency checking.  Verifies correct
;	segment ordering and size of hole allocated in UL for
;	QB4 static data.
;Entry:
;	SI - size of QB4 static data
;Exit:
;	SI - offset of XIB in UL data
;	DI - offset of XIE in UL data
;	CX - offset of BC_SAB in UL data
;Uses:
;	AX, BX, DX
;Exceptions:
;	Consistency errors.
;****


;***
; ULCheckNextName - Verify that next segment is expected. (UL only)
;
;Purpose:
;	Added as part of [10].
;	Checks the next segment name in the symbol table and see
;	if it matches the expected segment name.  If not then
;	segments are out of order, and a consistency error is issued.
;Entry:
;	DX - points to expected segment name string descriptor
;	ES:BX - points to previous symbol table entry
;Exit:
;	DX - advanced to next sd in segment name list
;	ES:BX - advanced to next symbol table entry
;Uses:
;	CX, SI, DI
;Exceptions:
;	Consistency error if next segment isn't the expected segment.
;****


;***
; ULFindName - Finds a specified segment name in symbol table (UL Only)
;
;Purpose:
;	Added as part of revision [10].
;	Finds the specified segment name in the symbol table.
;	If the segment name is not found, a consistency error
;	is detected.
;Entry:
;	ES:BX - points to next symbol table entry
;	SI - points to segment name to search for
;	CX - count of characters in segment name
;Exit:
;	ES:BX - points to symbol table entry containing segment name
;Uses:
;	DI
;Exceptions:
;	Consistency error if name not found.
;****



;***
; ULFindNameBegin - Finds a specified segment name in symbol table (UL Only)
;
;Purpose:
;	Added as part of revision [10].
;	Finds the specified segment name in the symbol table.
;	This routine starts searching from beginning of symbol table
;	If the segment name is not found, a consistency error
;	is detected.
;Entry:
;	ES - symbol table segment
;	DX - points to sd of segment to search for
;Exit:
;	ES:BX - points to symbol table entry containing segment name
;	AX - offset of segment that was found from DS:0
;	DX - advanced to next sd in segment name list
;Uses:
;	CX, DI
;Exceptions:
;	Consistency error if name not found.
;****


;***
; ULNextName - Get ptr to next expected segment name. (UL only)
;
;Purpose:
;	Added as part of revision [10].
;	Get next segment name from list of segment name string
;	descriptors.  Set up a ptr to the actual name in SI
;	and the length of the name in CX.  Advance DX to point
;	to next sd in list.
;Entry:
;	DX - points to expected segment name string descriptor
;Exit:
;	SI - points to zero terminated segment name.
;	CX - contains count of bytes in name pointed to by SI.
;	DX - advanced to next sd in segment name list.
;Uses:
;	None.
;Exceptions:
;	None.
;****


;***
; ULFindData - Get ptr to Data item. (UL only)
;
;Purpose:
;	Added as part of revision [15].
;	Find a data item in user library.
;Entry:
;	DX - points to string descriptor for data item.
;Exit:
;	AX - DGROUP offset of data item (0 if not found).
;Uses:
;	BX, CX, DX, SI, DI
;Exceptions:
;	Consistency error if not found.
;****

	SUBTTL QBC Exec support
	PAGE
;***
; LoadQBExe - Reload the interpreter into memory (QBI only)
;
;Purpose:
;	Added with revision [18].
;	Reloads the interpreter into memory after completing a COMPILE
;	Dialog.
;Entry:
;	BX - QB.EXE file handle.
;Exit:
;	None.
;Uses:
;	AX,CX,DX,SI,DI,BP.
;Exceptions:
;	DOS Memory allocation error.
;	Out of memory error.
;******************************************************************************

	PAGE
;***
; SearchForChar - Search for specified char in buffer (QBI Only)
;
;Purpose:
;	Added with revision [18].
;	Searches for a specified char in a buffer and returns
;	the distance from buffer start to the specified char.
;	ASSUMES THAT CHAR WILL ALWAYS BE FOUND.
;Entry:
;	AL - Char to search for.
;	ES:DI - points to buffer
;Exit:
;	CX - distance from ES:DI on entry to specified Char (not including char)
;	ES:DI - points to requested char.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

	PAGE
;***
; ExecCommands - Exec list of commands for COMPILE dialog (QBI Only)
;
;Purpose:
;	Added with revision [18].
;	Execs the list of commands built from the COMPILE dialog box.
;Entry:
;	envSeg = ENV seg to pass on to B$SHELL
;Exit:
;	b$QBCData.fErrorCode - non-zero if error occurred.
;Uses:
;	AX,BX,CX,DX,SI,DI,ES,BP.
;Exceptions:
;	Disk IO Error.
;******************************************************************************


	PAGE
;***
; B$ExecQBC - Exec list of commands as requested from COMPILE Dialog (QBI Only)
;
;Purpose:
;	Added with revision [18].
;	Invokes list of commands generated by the user interface in
;	response to a COMPILE dialog box.  The interpreter will be
;	released except for this loader, the error messages, and DGROUP.
;	The list of commands will then be processed.
;Entry:
;	psdCommands - ptr to sd containing command list.
;Exit:
;	AX = 0 if no error occurred.
;Uses:
;	Per Convention.
;Exceptions:
;	Out of memory error.
;	Disk IO error.
;****


;****
;B$FindFileOnPaths (pszFile, pszUserPath, pEnvVar, cbEnvVar)
;
;Purpose:
;	Moved here from uipaths.asm with revision [69].
;	Searches the current directory, the appropriate user-specified
;	search path, and the appropriate environment variable for the
;	file pszFile and returns a pointer to a fully-qualified pathfile
;	name where the file was found.	If the filename contains a path
;	then we just look in that one place and no further searching is
;	done.
;
;Input:
;	pszFile     - far pointer to null-terminated file name to open
;	pszUserPath - near pointer to user-specified path from Options menu
;	pEnvVar     - far pointer to environment variable name specifying
;			  last-chance search path
;	cbEnvVar    - length of environment variable pointed to by pEnvVar
;
;Output:
;	if successful
;	   DX:AX == pointer to pathfile name where file was found
;	else
;	   AX == 0
;
;****
cProc	B$FindFileOnPaths,<PUBLIC,FAR>,<SI>
	parmD	pszFile
	parmW	pszUserPath
	parmD	pEnvVar
	parmW	cbEnvVar
cBegin
ASSUMES DS,NOTHING

; First check for a path/file name.

	LES	SI,[pszFile]		; es:si points to file name
SearchLoop:
	LODS	BYTE PTR ES:[SI]	; read a byte
	OR	AL,AL			; end of string?
	JZ	NotPathFile		; yes, no path found, go do search
	CMP	AL,'\'                  ; found a path specifier?
	JE	PathSpecified		; yes, go try open without search
	CMP	AL,'/'			; found a path specifier?
	JE	PathSpecified		; yes, go try open without search
	CMP	AL,':'			; found a path specifier?
	JNE	SearchLoop		; no, keep searching

; If we fall through to here then the filename contains an explicit path.
; Check for existence of the specified path/file and do no more searching.
PathSpecified:
	PUSH	DS
	LDS	DX,[pszFile]		; ds:dx points to path/file name
	CALL	OpenFile2		; try to open the file
	XCHG	AX,BX			; BX = file handle (if open worked)
	MOV	AX,0			; can't use XOR because we need PSW.C
	JC	FileNotFound		; it's not there, exit with ax = 0
	PUSH	DX			; save offset of successful filespec
	CALL	CloseFile		; close the file
	MOV	DX,DS
	POP	AX			; DX:AX = ptr to successful filespec
FileNotFound:
	POP	DS
	JMP	SHORT FindFileExit	; exit

; Look for file in current directory first

NotPathFile:
; Note: We have to use fully-qualified pathspec to current directory for
;	many reasons, including checking for "File already loaded" and
;	disabling DPATH.

	PUSH	DS			; preserve ds
	PUSH	CS			
	POP	DS			; DS = LOADRTM
	MOV	SI,OFFSET LOADRTM:SpecBuffer ; point to target buffer
	PUSH	SI			; save ptr to SpecBuffer for call
	MOV	AH,19h			; "get current drive" function
	INT	21h			
	PUSH	AX			; save drive number (0 relative)
	ADD	AL,'A'			; drive number -> drive letter
	MOV	[SI],AL 		; store drive letter
	MOV	WORD PTR [SI+1],"\:"	; store ":" and "\"
	ADD	SI,3			; DS:SI points to target
	POP	DX			; DL = drive number (0 relative)
	INC	DX			; make 1 relative
	MOV	AH,47h			; "get current dir" function
	INT	21h			; get the current directory
	POP	BX			; CS:BX = ptr to SpecBuffer for call
	POP	DS			; restore DS
	JC	NotInCurDir		; current dir is invalid, the file
					;  we're looking for can't be there
	XOR	AX,AX
	cCall	B$SearchOnePath,<seg_pszFile,off_pszFile,AX,CS,BX>
	OR	AX,AX			; find file in current directory?
	JNZ	FindFileExit		; yes, exit with DX:AX = pointer

NotInCurDir:				
; Didn't find it in the current directory, try the user-specified
; search path from the options menu.

	cCall	B$SearchOnePath,<seg_pszFile,off_pszFile,AX,SS,pszUserPath>
	OR	AX,AX			; find file on that path?
	JNZ	FindFileExit		; yes, exit with DX:AX = pointer

; Didn't find it there either, try the path defined by the
; specified environment variable.

	cCall	B$SearchEnv,<seg_pEnvVar,off_pEnvVar,cbEnvVar>
	OR	AX,AX			; find the environment variable?
	JZ	FindFileExit		; no, exit with AX = 0

	XOR	BX,BX			; get a zero
	cCall	B$SearchOnePath,<seg_pszFile,off_pszFile,BX,DX,AX>

; B$SearchOnePath returns exactly what we want to return here,
; so no further processing is necessary.

FindFileExit:
cEnd

;****
;B$SearchOnePath - find a file on a search path
;
;Purpose:
;	Searches the specified path for the specified file.
;	Return a pointer to a fully-qualified pathname if search
;	is successful, otherwise return AX = 0.
;
;Input:
;	pFileName	far pointer to filename to open
;	cbFileName	length of filename
;	pSearchPath	far pointer to search path (list of directories
;				separated by ";" terminated by null)
;Output:
;	if successful
;	   DX:AX = far pointer to fully-qualified pathname
;	else
;	   AX = 0
;
;****

cProc	B$SearchOnePath,<NEAR>,<DS,SI,DI>
ParmD	pFileName
ParmW	cbFileName
ParmD	pszSearchPath

CalcLength:
	XOR	AX,AX			; get a zero for scanning
	DEC	CX			; CX = -1 for long search
	LES	DI,[pFileName]		; ES:DI points to filename
	REPNE	SCASB			; scan for a 0
	NOT	CX			; length of string (including null)
	DEC	CX			; length without null
	MOV	[cbFileName],CX 	; store that length
	JMP	SHORT HaveLength
cBegin
	MOV	CX,[cbFileName]
	JCXZ	CalcLength
HaveLength:

ASSUMES DS,NOTHING

	LDS	SI,[pszSearchPath]	; DS:SI points to search path
SearchPathLoop:
	PUSH	CS
	POP	ES
	MOV	DI,OFFSET LOADRTM:SpecBuffer ; ES:DI points to buffer
CopyPathToBuf:
	XOR	CX,CX			; initialize count of bytes moved
CopyLoop:
	LODSB				; get next byte
	OR	AL,AL			; done with list?
	JE	CopyEnd 		; yes

	CMP	AL,';'			; is it path separator?
	JE	CopyDone		; yes, copy is done
	STOSB				; put the byte in the buffer
	INC	CX			; count this byte
	XCHG	AH,AL			; save stored byte in AH
	JMP	SHORT CopyLoop

CopyEnd:
	XOR	DX,DX			; if CX=0, we want to jump with DX=0
	JCXZ	OpenError		; ran out of paths, file not found
	DEC	SI			; point to null terminator

CopyDone:
	JCXZ	CopyPathToBuf		; skip null path, go get next one
	MOV	AL,'\'
	CMP	AH,AL			; was last char backslash?
	JE	AppendFileName		; yes, don't add another
	CMP	AH,'/'			; was last char forward slash?
	JE	AppendFileName		; yes, don't add backslash
	CMP	AH,':'			; was last char from drive spec?
	JE	AppendFileName		; yes, don't add backslash
	STOSB				; append a backslash to pathname

AppendFileName:
	PUSH	DS
	PUSH	SI			; save pointer to next pathname in list
	LDS	SI,[pFileName]		; DS:SI points to filename
	MOV	CX,[cbFileName] 	; CX = length of filename
	REP	MOVSB			; append filename to pathname
	XCHG	AX,CX			; AX = zero
	STOSB				; null terminate the filename
	PUSH	ES
	POP	DS			; DS = LOADRTM
	CALL	OpenFile		; attempt to open the file
	MOV	DI,DS			; save DS in DI in case open worked
	POP	SI
	POP	DS			; get back pointer to next path in list
	JNC	FoundIt 		; found it, stop looking
	XOR	DX,DX			; DX=0 in case we go to OpenError
	CMP	[off_pszSearchPath],OFFSET LOADRTM:SpecBuffer 
	JNE	SearchPathLoop		; brif input path not in SpecBuffer
	MOV	AX,CS			; can't use CS for CMP
	CMP	[seg_pszSearchPath],AX	
	JNE	SearchPathLoop		; brif input path not in SpecBuffer

;	If we fall through to here, [pszSearchPath] was really pointing to a
;	single-directory path which had been placed in SpecBuffer.  Now that
;	we have changed SpecBuffer, we can't loop back up.  But we don't have
;	to because we have already checked the single directory and not found
;	the file.  So we just exit with "Not Found".

	JMP	SHORT OpenError 	

; DI:DX = pointer to pathspec that worked
; AX = file handle returned by open
FoundIt:				
	XCHG	AX,BX			; put handle in BX
	CALL	CloseFile		; close the file

DbAssertFlags	nc,LOADRTM,<B$SearchOnePath: error on close>

OpenError:
	XCHG	AX,DX
	MOV	DX,DI			; DX:AX = ptr to filespec that worked,
					; or AX = 0 if got here via OpenError
cEnd

;****
;B$SearchEnv - search the environment table
;
;Purpose:
;	Searches the environment table for the specified variable.
;	If found, return a pointer to the value associated with the
;	variable.  Otherwise return 0.
;
; Note: we can make no assumptions about the value of DS on input.
;
;Input:
;	pEnvVar 	far pointer to environment variable name
;	cbEnvVar	length of EnvVar
;
;Output:
;	if EnvVar found in environment table
;	    DX:AX = ptr to value associated with the variable
;	else
;	    AX = 0
;
;****
cProc	B$SearchEnv,<NEAR>,<DS,DI,SI>
parmD	pEnvVar
parmW	cbEnvVar
cBegin
	MOV	ES,SS:[__psp]	; ProgramPSP doesn't get set up for LQB
	MOV	ES,ES:[2Ch]	   ;...get segment of environment table
	XOR	AX,AX		;zero AX for scan test and zero test
	XOR	DI,DI		;ES:DI = ptr to start of environment table

SearchEnvLoop:
	LDS	SI,[pEnvVar]	;DS:SI = ptr to string to search for
	MOV	CX,[cbEnvVar]	;CX = length of string to search for
	REP	CMPSB
	JE	SearchEnvFound	;brif found a match
TryAgain:
	MOV	CX,0FFFFh	;search for a long time
	REPNZ	SCASB		;scan to past next zero byte
	CMP	ES:[DI],AL	;test for double zero for end of table
	JNZ	SearchEnvLoop	;brif not end of table

; Got to end of table without finding a match.	Return zero.

	JMP	SHORT SearchEnvExit

SearchEnvFound:
	CMP	BYTE PTR ES:[DI],'=' ;did we match the whole name or just part?
	JNE	TryAgain	;brif partial match, not good enough
	INC	DI		;bump pointer past equal sign to value
	MOV	DX,ES
	MOV	AX,DI		;DX:AX = pointer to value
SearchEnvExit:

cEnd

sEnd	LOADRTM

;	The data below is used when the QBI interpreter is reloaded
;	after a compile dialog.  The values are used prior to fixup, to
;	determine what the Fixup boundaries of the reloaded code should
;	be.
sBegin	LOADRTMEND			;end of Resident loader

QBVersion DW	BINSAV_BASICVersion	;QB version
QBRevision DB	BINSAV_REVISION_BYTE	;QB revision number
QBCode	DW	SEG LOADRTMEND		;start of code that gets reloaded
QBData	DW	DGROUP			;start of DGROUP for QB
sEnd	LOADRTMEND			

	CondEnd	StartupStub		; END StartupStub if NOT EI_QB
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\rttoul.asm ===
TITLE		RTTOUL - Transfers control to user lib from runtime.
;***
;RTtoUL - Transfers control from QB runtime to UL specific runtime.
;
;	Copyright <C> 1986, 1987, Microsoft Corporation
;
;Purpose:
;	This module causes control transfers from the QB runtime
;	to the user library specific runtime.  This module is linked
;	into QB.EXE and is used to interface with ULtoRT.asm which is
;	linked into the user library.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;
;	Code Segments
;
	USESEG	<RT_TEXT>

;
;	Data Segments
;
	USESEG	<_DATA>
	USESEG	<_BSS>

	INCLUDE seg.inc
	INCLUDE idmac.inc

externFP exStRunFile
externFP exStChain

sBegin	_BSS
	staticW retseg,,1
	staticW retoff,,1
	staticW SISave,,1
	staticW DISave,,1

	externW b$ULSymSeg
	externW b$pULVars	;ptr to user lib vars
sEnd	_BSS

;	Macro to define code externs for UL to RT dispatch table

	PURGE RTFar,RTFarOrg,RTNear,RTNearOrg,ULRTFar,ULRTNear,ULEntry
RTFar MACRO  name
EXTRN	&name:FAR
	ENDM		;;RTFar Macro

	FirstInclude = TRUE	;define ULVars on first include

	INCLUDE ulib.inc
	PURGE RTFar,RTFarOrg,RTNear,RTNearOrg,ULRTFar,ULRTNear,ULEntry

assumes CS,RT_TEXT
sBegin	RT_TEXT

	SUBTTL	Compiler entry points handled by interpreter
;***
; Runtime entry points which are handled by the interpreter.
;	B$SRUN - RUN entry point
;	B$SCHN - CHAIN entry point
;****

cProc	B$SRUN,<PUBLIC,FAR>
cBegin	<nogen>
	ADD	SP,4		; bash return address
	JMP	exStRunFile	;vector to QB RUN executor
cEnd	<nogen>

cProc	B$SCHN,<PUBLIC,FAR>
cBegin	<nogen>
	ADD	SP,4		; bash return address
	JMP	exStChain	;vector to QB CHAIN executor
cEnd	<nogen>

	PAGE
	SUBTTL	User lib RTM entry points
;***
; User library specific entry points (called from compiled code) which are
; present in user libraries.
; These entry points are equated to 0 in the RTM tables to signify
; that the entry point is in the user library.	The real address will
; be looked up in a UL resident table.
;****

ULEntry MACRO	name
	PUBLIC	&name		;
	&name:			;
	DbHalt 	RT_TEXT,<&name not defined in resident runtime - to call use ULRTFar in ULIB.INC> ;
	ENDM

	SUBTTL Interface from UL runtime to QB runtime
	PAGE
;***
; B$ULtoRTNear - UL rt to resident rt near call mapper
;
;Purpose:
;	This routine performs a near call to a requested
;	near QB resident runtime routine.  This is called
;	when a user library specific runtime routine needs to
;	call a QB resident runtime routine.
;
;Entry:
;	SI - table offset from RTNearStart containing routine address
;	Other regs as setup for requested routine (except for DI)
;	(cannot be on stack).
;Exit:
;	As returned by requested routine (cannot return values through DI).
;Uses:
;	As defined by requested routine.
;Exceptions:
;	As defined by requested routine.
;****

;	Macro to define start of Near UL to RT table

RTNearOrg MACRO
RTNearStart:
	ENDM		;;RTNearOrg

;	Macro to define Near UL to RT table entry

RTNear MACRO  name
EXTRN	&name:NEAR
	DW	&name
	ENDM		;;RTNear Macro

cProc	B$ULtoRTNear,<PUBLIC,FAR>
cBegin
	ADD	DI,RT_TEXTOffset RTNearStart
	CALL	CS:[DI]
cEnd
	PAGE
;***
; B$ULtoRTFar - UL rt to resident rt Far call mapper
;
;Purpose:
;	This routine performs a far call to a requested
;	far QB resident runtime routine.  This is called
;	when a user library specific runtime routine needs to
;	call a QB resident runtime routine.
;
;Entry:
;	BX - table offset from RTFarStart containing routine address
;	Other regs as setup for requested routine (except for BX).
;Exit:
;	As returned by requested routine.
;Uses:
;	As defined by requested routine.
;Exceptions:
;	As defined by requested routine.
;****

;	Macro to define start of Far UL to RT table

RTFarOrg MACRO
RTFarStart:
	ENDM		;;RTFarOrg

;	Macro to define Far UL to RT table entry

RTFar MACRO  name
	DD	&name
	ENDM		;;RTFar Macro

cProc	B$ULtoRTFar,<PUBLIC,FAR>
cBegin
	ADD	BX,RT_TEXTOffset RTFarStart
	JMP	DWORD PTR CS:[BX] ;jump to routine and let it do the far return
cEnd	<nogen>

	SUBTTL Interface from QB runtime to UL runtime
	PAGE
;***
; CallULFar - perform a Far call to a UL specific runtime routine
;
;Purpose:
;	This routine interfaces a Far resident runtime call to
;	a UL specific runtime routine that is defined as Far.
;	We set up an index into a UL resident table and call
;	a far UL specific mapper with the index in AX.	The
;	mapper will then do a Far call to the requested routine.
;Entry:
;	[b$pULVars].RTtoULFarProc - is the far address of the mapper.
;	Parameters set up for requested routine. (Cannot be passed
;	through BX-CX).
;Exit:
;	return value of requested routine.
;	DX:AX = 0 if no user lib loaded
;Uses:
;	None.
;Exceptions:
;	Defined by requested routine.
;****

	FarIndex = 0

ULRTFar MACRO  name, nParms
PUBLIC	&name
&name:
	.ERRE	(FarIndex * 2) LE 255	;;index no larger than 1 byte
	.ERRE	(nParms EQ 0) OR (nParms EQ 1) ;;CallULFar assumes 0 or 1 parm
	MOV	CX,(nParms SHL 8) + (FarIndex * 2) ;;get offset from ulib table
						   ;; base(CL) num of parms(CH)
	JMP	CallULFar	;;jump to common code to call UL runtime
	FarIndex = FarIndex + 1
	ENDM		;;ULRTFar Macro

cProc	CallULFar,<FAR>
cBegin	<nogen>
	CMP	b$ULSymSeg,0	;user lib around?
	JZ	NoUlib		;brif not

DbAssertRel b$pULVars,NZ,0,RT_TEXT,<Invalid b$pULVars in userlib (CallULFar)>
	XOR	CH,CH		;clear number of parms
	MOV	BX,[b$pULVars] ;get ptr to shared user lib variables
	JMP	DWORD PTR [BX].RTtoULFarProc ;jmp to RT to UL far call helper

NoUlib:
	XOR	AX,AX		
	CWD			;return DX:AX = 0 if no user lib loaded
	MOV	BX,AX		;return BX=0 also in case it's B$ULGetCommon
	OR	CH,CH		;any parms?
	JZ	NoParm		;brif not, just RETF
	RET	2		;else RETF and pop a parm
NoParm:
cEnd
	PAGE
;***
; CallULNear - perform a near call to a UL specific runtime routine
;
;Purpose:
;	This routine interfaces a near resident runtime call to
;	a UL specific runtime routine that is defined as near.
;	We set up an index into a UL resident table and call
;	a far UL specific mapper with the index in SI.	The
;	mapper will then do a near call to the requested routine.
;Entry:
;	[b$pULVars].RTtoULNearProc - is the far address of the mapper.
;	Parameters set up for requested routine (cannot be on stack).
;	Can't currently use SI or DI to pass to requested routine.
;Exit:
;	return value of requested routine (Can't currently return SI or DI).
;Uses:
;	None.
;Exceptions:
;	Defined by requested routine.
;****

	NearIndex = 0

ULRTNear MACRO	name
PUBLIC	&name
&name:
	PUSH	SI		 ;;preserve si
	PUSH	DI		 ;;preserve di
	MOV	DI,NearIndex * 2 ;;get offset from ulib table base
	JMP	SHORT CallULNear ;;jump to common code to call UL runtime
	NearIndex = NearIndex + 1
	ENDM			 ;;ULRTNear Macro

cProc	CallULNear,<NEAR>
cBegin
DbAssertRel b$ULSymSeg,NZ,0,RT_TEXT,<Tried to call UL runtime routine when UL not present(CallULNear).>
DbAssertRel b$pULVars,NZ,0,RT_TEXT,<Invalid b$pULVars in userlib (CallULNear)>
	MOV	SI,[b$pULVars] ;get ptr to shared user lib variables
	CALL	DWORD PTR [SI].RTtoULNearProc ;call RT to UL near call helper
	POP	DI		;recover entry di
	POP	SI		;recover entry si
cEnd

;***
; Define interface routines to user library specific runtime.
;****

	FirstInclude = FALSE	;don't define ULVars on second include

	INCLUDE ulib.inc	;define entry points

	PAGE
;***
;B$FRAMESETUP	- set up initial stack frame for error handling.
;void pascal B$FRAMESETUP()
;
;Purpose:
;	B$FrameSetup is defined in user library specific runtime.
;	Since this is a critical routine with complex entry/exit
;	conditions, it is defined seperately from the dispatches
;	above.
;
;Entry:
;	DX:AX	= contains long pointer to start of user module.
;	CL	= value to which the GOSUB count should be set
;Exit:
;	SP	- points to stack after initial frame.
;	BP	- points to initial stack frame.
;Uses:
;	BX.
;Exceptions:
;	Out of memory. (Will vector to error handler with >old< frame, so that
;	the error will be reported on the call, and not the SUB entry, for
;	example).
;****
cProc	B$FRAMESETUP,<PUBLIC,FAR>
cBegin	<nogen>
DbAssertRel b$ULSymSeg,NZ,0,RT_TEXT,<Tried to call UL runtime routine when UL not present(B$FrameSetup)>
DbAssertRel b$pULVars,NZ,0,RT_TEXT,<Invalid b$pULVars in userlib (B$FrameSetup)>
	MOV	BX,[b$pULVars] ;get ptr to shared user lib variables
	JMP	DWORD PTR [BX].FrameSetup ;jmp to B$FrameSetup
cEnd	<nogen>

sEnd	RT_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\sninit.asm ===
TITLE	SNINIT - Sound and Play Initialization/Termination module
;***
;SNINIT.ASM - Sound/Play initialization/termination module
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains Sound/Music specific initialization
;	and termination support for the BASIC 3.0 runtime.  This module
;	will only be present in a user's program when a program contains
;	statements or features which need Sound/Play support.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;
;	Code Segments
;
	useSeg	<INIT_CODE>	;Initialization
	useSeg	<SN_TEXT>	;Operating System
	useSeg	<DV_TEXT>	

;
;	Data Segments
;
	useSeg	<_BSS>		;runtime data (uninitialized)
	useSeg	<_DATA> 	;runtime data (initialized)
	useSeg	<XIB>		; XIB and XIE must bracket XI!
	useSeg	<XI>		;initializer segment
	useSeg	<XIE>		

	INCLUDE seg.inc
	INCLUDE compvect.inc	; component vectors
	INCLUDE idmac.inc	
	INCLUDE	ibmunv.inc	

sBegin	DV_TEXT 			
	externNP	B$NearRet	;for disp vectors in compvect.inc
sEnd	DV_TEXT 			

	INITIALIZER	B$xSNINI	;put B$xSNINI in initializer list.

	SUBTTL	Runtime data definitions for BASIC Sound/Music
	PAGE
sBegin	_DATA

;
;	external data
;
	externW b$ini_disp	;One time initialization dispatch table
	externW b$run_disp	;Run time initialization dispatch table
	externW b$term_disp	;One time termination dispatch table
	externW b$clrt_disp	;Clear termination dispatch table
	externW b$shlt_disp	;Shell termination dispatch table
	externW b$shli_disp	;Shell initialization dispatch table

sEnd	_DATA

sBegin	_BSS

;
;	Global Uninitialized Data
;


;***
;b$SNQueSeg - Sound Queue Segment
;
;Purpose:
;	This variable gives the segment in which the sound queue exists.
;	The sound queue is the first 256 bytes of this segment.  It is also
;	used as a flag to prevent multiple deallocations.  If the value of
;	b$SNQueSeg is 0, then the segment is not currently allocated.
;
;	The sound queue is used to hold notes that have been specified by
;	the PLAY statement.  It holds unplayed notes for both the foreground
;	and background music.
;
;Allocation:
;	b$SNQueSeg is a WORD value declared in the _BSS segment by
;	the OEM-Independent code.
;
;Values:
;	0 - No sound queue allocated
;	not 0 - Segment in which sound queue exists.
;
;Initially Set:
;	This variable is statically initialized to be 0 (No Sound Queue).
;	At program initialization (after B$GWINI is called but before
;	any user code is executed) it is set to the location of the
;	sound queue.
;
;Modified By:
;	Once set, this variable should not be modified as long as the
;	sound queue exists.  The sound queue exists until the end of
;	the program or until a RUN command is executed.
;
;Used By:
;	The sound queue is only used by the OEM-Dependent code.  It is
;	not accessed or modified by any OEM-Independent code.
;************************************************************************
	globalW b$SNQueSeg,?,1	;music queue buffer segment
	globalB B$MMODE,?,1
	EVEN

	globalW B$VCEVOL,?,NUM_VOICES
	globalB B$BEATS, ?,NUM_VOICES
	globalB B$NOTE1L,?,NUM_VOICES
	globalB B$NOTELN,?,NUM_VOICES
	globalB B$NOTFLG,?,NUM_VOICES
	globalB B$MSCALE,?,NUM_VOICES
	globalB B$OCTAVE,?,NUM_VOICES


sEnd	_BSS


	externNP	B$BREAK_CHK
	externNP	B$ERR_FC
	externNP	B$DONOTE	
	externNP	B$SNDOFF	
	externNP	B$ERR_OM_FH	
	externNP	B$FHHighAlloc	
	externNP	B$FHHighDealloc 


	SUBTTL	Runtime Sound/Music Initialization
	PAGE
assumes CS,INIT_CODE
sBegin	INIT_CODE

;***
;B$xSNINI - Sound/Music initializer
;PLM B$xSNINI()
;
;Purpose:
;	Initializer for Sound/Music component.	This routine is called
;	by the Crt0 startup before _main is called.  It will update the
;	indirect dispatch tables for the Sound/Music routines.	This
;	insures that the only time that Sound/Music support is accessed
;	is when this module is linked into the user program.
;
;Entry:
;	None.
;
;Exit:
;	Appropriate dispatch vector entries filled.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xSNINI,<FAR>
cBegin
;
;	update "ONE" time initialization dispatch address to B$SNINI
;
	MOV	WORD PTR [b$ini_disp].SN_IVEC,SN_TEXTOFFSET B$SNINI 
;
;	update "RUN" time initialization dispatch address to B$SNRUN
;
	MOV	WORD PTR [b$run_disp].SN_RVEC,SN_TEXTOFFSET B$SNRUN 
;
;	update "ONE" time termination dispatch address to B$SNTERM
;
	MOV	WORD PTR [b$term_disp].SN_TVEC,SN_TEXTOFFSET B$SNTERM
;
;	update "CLEAR" time termination dispatch address to B$SNCLEAR
;
	MOV	WORD PTR [b$clrt_disp].SN_CLTVEC,SN_TEXTOFFSET B$SNCLEAR
;
;	update "SHELL" time termination dispatch address to B$SNTEM
;
	MOV	WORD PTR [b$shlt_disp].SN_STVEC,SN_TEXTOFFSET B$SNTERM 

;
;	update "SHELL" time initializatiom dispatch address to B$SNINI
;
	MOV	WORD PTR [b$shli_disp].SN_SIVEC,SN_TEXTOFFSET B$SNINI 
cEnd
sEnd	INIT_CODE

assumes CS,SN_TEXT
sBegin	SN_TEXT


;***
;B$SNINI - One time initialization for Sound/Music
;void pascal B$SNINI()
;
;Purpose:
;	Allocate and initialize the music queue.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	AX, BX.
;Exceptions:
;	Out of memory error if allocation fails.
;****

cProc	B$SNINI,<NEAR>		
cBegin

;	First, allocate the memory for the music queue.

	MOV	AX,256		;queue size is 256 bytes
	CWD			;clear DX for doubleword size
	CALL	B$FHHighAlloc	;allocate the music queue buffer
	JCXZ	SNIniOMErr	;Out of memory if no room for buffer
	MOV	b$SNQueSeg,CX	;save segment of memory block
cEnd				

SNIniOMErr:			
	JMP	B$ERR_OM_FH	;out of memory - no room for sound buffer


;***
;B$SNRUN - RUN time initialization for Sound/Music
;void pascal B$SNRUN()
;
;Purpose:
;	Added as part of [5].
;	Reset and initialize the music queue.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	Per convention.
;Exceptions:
;	None.
;****

cProc	B$SNRUN,<NEAR>		
cBegin

;	Turn off any sound and initialize the queue.

	cCall	B$SNDOFF	
	JMP	SHORT INI_QUE
cEnd	<nogen> 		

;***
;B$SNCLEAR - CLEAR time termination for Sound/Music
;void pascal B$SNCLEAR()
;
;Purpose:
;	Reset and reinitialize music.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	None.
;
;****

cProc	B$SNCLEAR,<NEAR>	
cBegin
	cCall	SNDRST
INI_QUE:			
	cCall	B$SNDINI
cEnd

;***
;B$SNTERM - One time termination for Sound/Music
;void pascal B$SNTERM()
;
;Purpose:
;	Flush music queues and deallocate sound buffer if needed.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****

cProc	B$SNTERM,<NEAR> 	
cBegin
	cCall	B$SNDOFF	


;	Deallocate the music queue memory block.
;	Because of the way that RUN/CHAIN works, it is possible for
;	B$SNTERM to be called multiple times.	Make sure that the
;	Sound Queue is deallocated only once.  The value 0 is used
;	to indicate a non-init queue, as it can not occur as a legal
;	segment in either DOS3 or DOS5

	MOV	AX,b$SNQueSeg	;get the memory block segment
	OR	AX,AX		;If the value is zero..
	JZ	NoDealloc	;do not deallocate block
	CALL	B$FHHighDealloc ;deallocate the block
	XOR	AX,AX		;Clear AX
	MOV	b$SNQueSeg,AX	;And flag memory as unallocated
NoDealloc:


cEnd


;***
;B$STRTSD - Start Playing Background Sound
;Purpose:
;	Signal background task to start emptying voice queues and playing
;	music.
;Input:
;	None.
;Output:
;	None.
;Uses:
;	None.
;Exceptions:
;	B$ERR_FC
;****

cProc	B$STRTSD,<PUBLIC,NEAR>
cBegin
	MOV	AL,LOW STRSND	;Function code to start sound
	cCALL	B$DONOTE 	; Pass command to the OEM
	JC	FCERR
cEnd


;***
;B$SNDWAT - Wait until foreground sound has stopped
;Purpose:
;	If Music mode is foreground, wait until all sound
;	activity has stopped, and all voices are silent.  If
;	Music mode is background, return immediately.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	B$ERR_FC
;****

cProc	B$SNDWAT,<PUBLIC,NEAR>
cBegin
	CMP	[B$MMODE],0	;Test Music Mode (0=FG, 255=BG)
	JNE	SNDWAX		;Continue if Music Background

	PUSH	AX		;Save registers used
WAITFG:
	CALL	B$BREAK_CHK	;Check for user break
	MOV	AL,LOW TSTVOC	;Function to test for active voices
	cCALL	B$DONOTE 	; Ask the OEM about it
	JNC	SNDWAT_OK
FCERR:
	JMP	B$ERR_FC	;bad fn call if no data returned
SNDWAT_OK:
	OR	AL,AL		;See if any of them are active
	JNE	WAITFG		;and wait until they aren't
	POP	AX		;Restore the registers
SNDWAX:
cEnd

;***
;SNDRST - Reset Backgound Music
;
;Purpose:
;	SNDRST is called to reset background music.  It is called during
;	initialization from INIT and during the processing of CTL-C
;	from B$BREAK_CHK.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	B$ERR_FC
;****

cProc	SNDRST,<NEAR>
cBegin
	MOV	AX,STPSND	;Flush queue function
	cCALL	B$DONOTE 	; Disable background music, init music queue
	JC	FCERR
cEnd

	SUBTTL	Sound initialization

;***
;B$SNDINI - Initialize Sound Variables
;
;Purpose:
;	B$SNDINI is called to set B$OCTAVE, B$BEATS, B$NOTELN, B$NOTE1L, B$MSCALE,
;	and B$MMODE to appropriate initial settings.
;	B$SNDINI is called at CLEARC and during initialization.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	None.
;****
cProc	B$SNDINI,<PUBLIC,NEAR>,<SI>
cBegin
	MOV	[B$MMODE],LOW 0D

	XOR	SI,SI		;Start with voice 0
SDIN10: MOV	B$BEATS[SI], low 120d
	MOV	B$MSCALE[SI],low 3d
	MOV	B$NOTELN[SI],low 4d
	MOV	B$NOTE1L[SI],low 4d
	MOV	B$OCTAVE[SI],low 4d
	MOV	B$NOTFLG[SI],low 0d

; Initialize the default volume for each voice

	ADD	SI,SI
	MOV	B$VCEVOL[SI],DFLVOL


cEnd


sEnd	SN_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\stcore.asm ===
TITLE	STCORE - Core string assignment, concatenate & compare
	PAGE	56,132
;***
;STCORE - Core string assignment, concatenate & compare
;
; Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; String Addition:	String Assignment:	String Comparision:
;
;   Example:		  Example:		  Example:
;
;     a$ = b$ + c$	    A$ = B$		    IF A$ = B$ THEN 100
;	      | 	       |			  |
;	  B$SCAT	    B$SASS		       B$SCMP
;
; CHR$ Function:
;
;   v$ = CHR$(numeric)
;	   |
;      B$FCHR
;
;
; This module contains the most commonly used "core" string routines.
;
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	useSeg	_DATA
	useSeg	ST_TEXT

	INCLUDE seg.inc
	INCLUDE idmac.inc

sBegin	ST_TEXT
	ASSUMES CS,ST_TEXT

externNP B$ERR_FC
externNP B$STALCTMP
externNP B$STALCTMPSUB
externNP B$STCHKTMP
externNP B$STDALC
externNP B$STDALCTMP
externNP B$STDALCTMPDSC


	SUBTTL	B$SASS - String assignment
	PAGE
;***
; B$SASS - String assignment
;DBCS-callback
;
;Function:
; 1. Copy the source string into a temp, if it wasn't already.
; 2. Free any string data space of the destination
; 3. Copy the source descriptor to the destination descriptor
; 4. Reset the backpointer (unless it's a null string)
; 5. Free the (temporary) source descriptor
;
;Inputs:
; psdSource = Address of Source string descriptor
; psdDest   = Address of Destination string descriptor
;
;Outputs:
; None.
;
;Registers:
; per convention
;******************************************************************************
cProc	B$SASS,<FAR,PUBLIC>
parmW	psdSource
parmW	psdDst
cBegin
	MOV	BX,psdSource
DbAssertTst	BX,Z,1,ST_TEXT,<Source SD has odd address in B$SASS>
	CALL	B$STCHKTMP	;See if source is a temp
	JNC	NOTEMP		;go if not
HAVTEMP:
	XCHG	BX,DX
	MOV	BX,psdDst	;Need destination string in BX
DbAssertTst	BX,Z,1,ST_TEXT,<Destination SD has odd address in B$SASS>
DbAssertRel	BX,NE,DX,ST_TEXT,<Source == Dest in B$SASS>
	CALL	B$STDALC	;Free destination string, if any
;Copy the descriptor
	XCHG	BX,DX		;BX=psdSource (or temp), DX=psdDest
	MOV	CX,[BX] 	;CX=length
	MOV	AX,[BX+2]	;AX=data pointer
	XCHG	BX,DX		;BX=psdDest, DX=psdSource (or temp)
	MOV	[BX],CX 	;save length
	MOV	[BX+2],AX	;save data pointer
	JCXZ	NOBACK		;if null str, don't fix backpointer
	XCHG	BX,AX		;BX=data pointer, AX=psdDest
	MOV	[BX-2],AX	;Set backpointer
	XCHG	BX,DX		;Need source (temp) string in BX
	CALL	B$STDALCTMPDSC ;Free temp header
NOBACK:

cEnd

NOTEMP: 			;Copy the source string into a temp
	XOR	CX,CX		;offset of 0
	MOV	DX,[BX] 	;DX = length of string to assign
	CALL	B$STALCTMPSUB	;Create temp string and copy in data
	JMP	SHORT HAVTEMP

	SUBTTL	B$SCAT - Concatenate strings
	PAGE
;***
; B$SCAT - Concatenate strings
;DBCS-callback
;
;Function:
; Create a string containing the concatenation of the two given strings.
;
;Inputs:
; psd1	= Address of left string descriptor
; psd2	= Address of right string descriptor
;
;Outputs:
; [AX]	= Address of result string descriptor
;
;Registers:
;
;******************************************************************************
cProc	B$SCAT,<FAR,PUBLIC>,<ES,DI,SI>
parmW	psd1
parmW	psd2
cBegin

	PUSH	DS		;string package assumes ES = DS
	POP	ES

	MOV	SI,psd1 	;First string to move
	MOV	DI,psd2 	;Save second string
	MOV	BX,[SI] 	;Get length of first string
	ADD	BX,[DI] 	;Sum is length of result string
	JO	ERRFC		;Make sure no overflow
	CALL	B$STALCTMP	;Allocate temp string
	XCHG	DI,DX		;Put data address in DI, save second string
	PUSH	BX		;Save result string descriptor address
	CALL	MOVSTR		;Move first string into temp
	MOV	SI,DX
	CALL	MOVSTR		;Move second string in
	POP	AX		;Restore result

cEnd

MOVSTR:
	MOV	BX,SI		;Need descriptor address here for B$STDALCTMP
	LODSW			;[AX] = length of string
	XCHG	AX,CX		;[CX] = length of string
	LODSW			;[AX] = address of data
	XCHG	AX,SI		;[SI] = address of data
	SHR	CX,1		;Convert to word count
	REP	MOVSW
	JNC	DITS		;Is is odd?
	MOVSB			;Move last byte if odd
DITS:
	JMP	B$STDALCTMP	;Delete source string if temp

ERRFC: JMP     B$ERR_FC

	SUBTTL	B$SCMP - String comparison
	PAGE
;***
;B$SCMP,B$ISCMPNoRel - String comparison
;
;Function:
; Compare strings and set flags. For each byte of the strings, the flags
; are set based on [left operand] - [right operand] until inequality is
; found or one the strings end. If the end a string is reached, the
; flags are set with [LEN(left operand)] - [LEN(right operand)].
; B$ISCMPNoRel will do the comparison without releasing the LEFT side
; string if it is a temp.
;
;Inputs:
; psdL	= Address of left operand string descriptor
; psdR	= Address of right operand string descriptor
;
;Outputs:
; Result is flags, as noted above.
;
;Registers:
; Per convention
;******************************************************************************
cProc	B$ISCMPNoRel,<FAR,PUBLIC>
cBegin	<nogen>
	MOV	DX,-1		;Don't dealloc flag
	JMP	SHORT SCMP
cEnd	<nogen>

cProc	B$SCMP,<FAR,PUBLIC>
cBegin	<nogen>
	XOR	DX,DX		;Dealloc flag
cEnd	<nogen>

cProc	SCMP,<FAR>,<ES,SI,DI>
parmW	psdL
parmW	psdR
cBegin

	PUSH	DS		;string package assumes ES = DS
	POP	ES

	MOV	BX,psdR
	MOV	AX,psdL
	MOV	DI,[BX+2]	;Pointer to right side data
	MOV	CX,[BX] 	;Length of right string
	XCHG	AX,BX
	MOV	SI,[BX+2]	;Pointer to left side data
	CMP	CX,[BX] 	;See which string is shorter
	JBE	HAVLEN
	MOV	CX,[BX] 	;Use whichever length is shortest
HAVLEN:
	CMP	AX,AX		;Set zero flag in case CX=0
	REPE	CMPSB		;String compare
	JNZ	NOTEQ		;Strings equal so far?
	MOV	CX,[BX] 	;String data equal, so get lengths again
	XCHG	AX,BX
	CMP	CX,[BX] 	;Longer string is larger
	XCHG	AX,BX		;Left side back in BX
NOTEQ:
	PUSHF			;Save comparison flags
	OR	DX,DX		;should we dealloc left side string temp?
	JNZ	NoDealc 	;brif not
	CALL	B$STDALCTMP	;Free up temp strings
NoDealc:
	XCHG	AX,BX
	CALL	B$STDALCTMP
	POPF			;Restore flags

cEnd

				; use the B$FCHR function which is
				; currently part of the KANJI sources.
	SUBTTL	B$FCHR - CHR$ function
	PAGE
;***
;B$FCHR - CHR$ function
;sd * pascal B$FCHR(I2 val)
;
;Function:
; Create a temp string 1 character (1 or 2 bytes) long with the given value.
;
;Inputs:
; val	= Value, which will be checked to be sure it's valid ASCII (<256)
;	  if Kanji supported, valid ASCII (<65536)
;
;Outputs:
; [AX]	= Address of string descriptor
;
;Registers:
; Per convention
;******************************************************************************
cProc	B$FCHR,<FAR,PUBLIC>
parmW	val
cBegin

	MOV	AX,val		;[AX] = value
	MOV	BX,1
	OR	AH,AH		;See if value OK (<256)

	JNZ	ERRFC		;If not, argument error

	PUSH	AX		;Save character on stack
	CALL	B$STALCTMP	;Allocate a one or two byte string
	XCHG	BX,DX		;Get pointer to data in BX
	POP	[BX]		;Put character in string
	XCHG	AX,DX		;[AX] = descriptor address
cEnd


sEnd	ST_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\stringfp.asm ===
TITLE	STRINGFP - Floating Point String Functions
	PAGE	56,132
;***
; STRINGFP - Floating Point ST$ functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - STR$ Function -
;
;      v$ = STR$(x)
;
;    Examples:
;
;      v$ = STR$(b@)   v$ = STR$(a!)	    v$ = STR$(x#)
;	     |		     |			  |
;	   B$STCY	   B$STR4		B$STR8
;
;
;****

	INCLUDE switch.inc
	INCLUDE rmacros.inc

	useSeg	_DATA
	USESEG	_BSS
	useSeg	ST_TEXT

	INCLUDE seg.inc
	INCLUDE rtps.inc
	INCLUDE baslibma.inc


sBegin	ST_TEXT

	ASSUMES CS,ST_TEXT

	externNP B$FloatCONASC	;Pull in floating point conversion routines
	externNP B$STR_COMMON	;Common support for STR$

	SUBTTL	STR$ - Create String from number
	PAGE
;***
;B$STR4, B$STR8, B$STCY - STR$ function support
;
;Purpose:
;	Runtime Entry Points
;	Create a string representing the number in ASCII
;
;Entry:
;	parameter value is on the stack (R4, R8 or CY)
;
;Exit:
;	AX = Address of string descriptor
;
;Uses:
;	Per Convention
;
;Exceptions:
;	Out of memory
;****

cProc	B$STR4,<PUBLIC,FAR>
parmD	arg4
cBegin
	MOV	AL,VT_R4
	LEA	BX,arg4
	cCall	B$STR_COMMON
cEnd


cProc	B$STR8,<PUBLIC,FAR>
ParmQ	R8Arg
cBegin
	MOV	AL,VT_R8	;AL = data type
	LEA	BX,R8Arg	;BX = ptr to data
	cCall	B$STR_COMMON	;call common routine to convert
cEnd


sEND	ST_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\string.asm ===
TITLE	STRING - String assignment, concatenate, compare
	PAGE	56,132
;***
; STRING - String assignment, concatenate, compare
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; Fixed length string manipulations
;
;     a$ = a.foo	a.foo = a$	swap a.foo a.bar
;	  |		    |			|
;	B$ASSN		  B$ASSN 	      B$SWPN
;
; - STR$ Function - calls $STI for integer arg, $STR for s.p., or $STD for d.p.:
;
;      v$ = STR$(x)
;
;    Examples:
;
;      v$ = STR$(50)	v$ = STR$(b&)
;	     |		      |
;	   B$STI2	    B$STI4
;
;******************************************************************************
	INCLUDE switch.inc	
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	_DATA
	USESEG	_BSS		
	useSeg	ST_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE	baslibma.inc	
	INCLUDE idmac.inc	

externFP B$LSET 		

sBegin	_BSS
externB b$VTYP			; defined in GWDATA.ASM
sEnd	_BSS

externFP B$SASS 		

sBegin	ST_TEXT 		

externNP B$STALCTMP		
externNP B$STALCTMPSUB		
externNP B$STDALC		
externNP B$STDALCTMP		
externNP B$STSWAPDESC		; swap string descriptors
externNP B$STALCTMPCPY		
externNP B$FOUTBX		

	ASSUMES CS,ST_TEXT	

	SUBTTL	STR$ - Create String from number
	PAGE
;***
;B$STI2, B$STI4 - STR$ function support
;
;Purpose:
;	Runtime Entry Points
;	Create a string representing the number in ASCII
;	Moved here with revision [21].
;Entry:
;	parameter value is on the stack (I2, or I4)
;Exit:
;	AX = Address of string descriptor
;Uses:
;	Per Convention
;Exceptions:
;	Out of memory
;****
cProc	B$STI2,<PUBLIC,FAR>
ParmW	I2Arg
cBegin
	MOV	AL,VT_I2	;AL = data type
	LEA	BX,I2Arg	;BX = ptr to data
	cCall	B$STR_COMMON	
cEnd

cProc	B$STI4,<PUBLIC,FAR>
parmD	arg4
cBegin
	MOV	AL,VT_I4	;AL = data type
	LEA	BX,arg4
	cCall	B$STR_COMMON	
cEnd

;***
;B$STR_COMMON - support routine for STR$ function
;
;Purpose:
;	Converts numeric data to a string.
;Entry:
;	AL - data type
;	BX - pointer to data
;Exit:
;	AX - pointer to sd containing converted string
;Uses:
;	Per convention
;Exceptions:
;	Out of memory
;****
cProc	B$STR_COMMON,<PUBLIC,NEAR> 
cBegin
	MOV	b$VTYP,AL	; store data type
	CALL	B$FOUTBX	;do conversion - [AX] = cbStr, [BX] = pszStr
	XCHG	AX,BX		;Get length in BX
	XCHG	AX,DX		;Get address in DX
	CALL	B$STALCTMPCPY	;Create temp string
	XCHG	AX,BX		;return psd in AX
cEnd

	SUBTTL	B$LDFS - load fixed length string
	PAGE
;***
; B$LDFS - load fixed length string
; ushort B$LDFS(char far *pString, ushort cbString)
;
;Purpose:
;	Given a far pointer to a string (not zero-terminated) and count
;	of bytes in the string, allocate a string temporary, copy the
;	string data into it, and return a pointer to the temp string sd.
;
;Entry:
;	pString -	a far pointer to string data to copy
;	cbString -	count of bytes of string data to copy
;
;Exit:
;	AX = ptr to the newly allocated string temp.
;Uses:
;	none.
;
;Exceptions:
;	Runtime error can occur (such as 'insufficient string space'), in
;	which case control is transfered to runtime error code.
;******************************************************************************
cProc	B$LDFS,<PUBLIC,FAR>,<ES,SI,DI>
parmD	pString
parmW	cbString
cBegin	B$LDFS 			
	PUSH	DS		; string package assumes ES = DS
	POP	ES		
	MOV	BX,[cbString]	;input to B$STALCTMP
	PUSH	BX		;save string length
	CALL	B$STALCTMP	;BX = psdTmp, DX = pData for temp string
	POP	CX		;CX = string length
	PUSH	BX		;save for retval
	MOV	DI,DX		;ES:DI = destination
	PUSH	DS		;save across block copy
	LDS	SI,[pString]	;DS:SI = given string pointer
	INC	CX		;round up if odd
	SHR	CX,1		;CX = string length in words
	REP	MOVSW		;copy string
	POP	DS		;restore
	POP	AX		;retval - psdTmp
cEnd	B$LDFS

	SUBTTL	B$ASSN - fixed length string assignment
	PAGE
;***
;B$ASSN - fixed length string assignment [7]
;void pascal B$ASSN(data far *pSrc, I2 cbSrc, data far *pDest, I2 cbDest)
;
;Purpose:
; Assign the contenst of a fixed or variable length string to a fixed or
; variable length string.
;
;Entry:
; pSrc	= far pointer to source data or sd
; cbSrc = length of source string, or 0 if sd
; pDest = far pointer to destination data or sd
; cbDest= length of destination string, or 0 if sd
;
;Uses:
; per convention
;
;******************************************************************************
labelFP <PUBLIC,B_ASSN> 	;Interpreter reachable entry
cProc	B$ASSN,<FAR,PUBLIC>,<DI,SI,ES>
parmD	pSrc			;far pointer to source data or sd
parmW	cbSrc			;length of source string, or 0 if sd
parmD	pDest			;far pointer to destination data or sd
parmW	cbDest			;length of destination string, or 0 if sd
cBegin
	LES	SI,pSrc 	;[ES:SI] = pointer to source data
	MOV	BX,ES		;[BX:SI] = pointer to source data
	MOV	CX,cbSrc	;[CX] = length of source

	LES	DI,pDest	;[ES:DI] = pointer to destination
	MOV	AX,cbDest	;[AX] = length of destination fs
	OR	AX,AX		; Set flags on that.
	JCXZ	ASSN_50 	;Jump if the source is an sd
;
; source is a fixed length string, [BX:SI] points to data, [CX] has length
;
	JZ	ASSN_10 	; jump if destination is a string descriptor
;
; destination is an fs, [ES:DI] points to data, [AX] has length
;
	SUB	AX,CX		;[AX] = dest length - source len
	JNC	ASSN_30 	;Jump if source less than destination
;
; src>dst, copy cbDest bytes with no padding
;
	MOV	CX,cbDest	;[CX] = len to copy (dst)
	XOR	AX,AX		;[AX] = length to pad 0 since dest len used
;
; fixed length string assignment
;  [BX:SI]	= address of source data
;  [ES:DI]	= address of destination data
;  [CX] 	= number of bytes to copy
;  [AX] 	= number of bytes to pad
;
ASSN_30:
	PUSH	DS		;Save this
	MOV	DS,BX		;[DS:SI] = address of source data
	REP	MOVSB		;copy copy-able data
	XCHG	AX,CX		;get pad count
	MOV	AL," "		;get pad data
	REP	STOSB		;pad data
	POP	DS		;restore
	JMP	SHORT ASSN_90	;go exit
;
; destination is a string descriptor. create a temp string out of the fs,
; and then do a normal string assignment.
;
ASSN_10:
	cCall	B$LDFS,<BX,SI,CX> ;[AX] = address of temp sd
ASSN_15:
	cCall	B$SASS,<AX,DI> ;do normal string assign
	JMP	SHORT ASSN_90	;and quit
;
; Source is an sd. Use LSET
;
ASSN_50:
	XCHG	AX,SI		; [AX] = source sd, [SI] = cbDest
	JZ	ASSN_15 	; jump if target is also an sd
	cCall	B$LSET,<AX,ES,DI,SI>

ASSN_90:

cEnd

	SUBTTL	B$SWPN = SWAP strings
	PAGE
;***
; B$SWPN - Swap strings
; void pascal B$SWPN(data far *pOp1, I2 cbOp1, data far *pOp2, I2 cbOp2)
;
;Purpose:
; swap fixed or variable length strings
;
;Entry:
; pOp1	= pointer to first string operand
; cbOp1 = length thereof
; pOp2	= pointer to second string operand
; cbOp2 = length thereof
;
;Exit:
; swapped
;
;Uses:
; per convention
;
;******************************************************************************
cProc	B$SWPN,<FAR,PUBLIC>,<DI,SI,ES,DS>
parmD	pOp1			;pointer to first string operand
parmW	cbOp1			;length thereof
parmD	pOp2			;pointer to second string operand
parmW	cbOp2			;length thereof
cBegin

	LES	DI,pOp2 	;[ES:DI] points to second one
	MOV	DX,cbOp2	;[DX] = length of #2
	LDS	SI,pOp1 	;[DS:SI] points at the first
	MOV	CX,cbOp1	;[CX] = length of #1

	MOV	BX,DX		;[BX] = length of #2
	SUB	BX,CX		;[BX] = len2 - len1 (Pad length)
	JNZ	SWPN_20 	;Jump if the lengths differ
	JCXZ	SWPN_50 	;Jump if both strings are sd's
;
; We have two fixed length strings, and their lengths are the same.
;
SWPN_10:
;
;  [ES:DI] points to one, [DS:SI] points to the other, [CX] has the length
;  to be swapped, and [BX] has the length to pad.
;
	MOV	AL,ES:[DI]
	XCHG	AL,DS:[SI]
	STOSB			;Bytes swapped
	INC	SI
	LOOP	SWPN_10 	;Loop for shorter of the strings

	MOV	CX,BX		;[CX] = length to pad
	MOV	AL," "		;[AL] = character to pad with
	REP	STOSB		;pad string
	JMP	SHORT SWPN_90	;Exit
;
; The lengths are different. At least one must be an FS.
;
SWPN_20:
	JCXZ	SWPN_40 	;Jump if [DS:SI] points to an sd
	XCHG	CX,DX		;[CX] = length of [ES:DI]
	JCXZ	SWPN_30 	;Jump if [ES:DI] points to an sd
;
; Both point to FS's, but their lengths differ
; NOTE: flags for the JNC were set WAY WAY up there at the SUB BX,CX
;
	XCHG	CX,DX
	JNC	SWPN_10 	;Jump if len2 > len1
	MOV	CX,DX		;[CX] = copy length (smaller of the lengths)
	NEG	BX		;[BX] = pad length (absolute difference)
	LES	DI,pOp1 	;[ES:DI] points to first one
	LDS	SI,pOp2 	;[DS:SI] points at the second
	JMP	SWPN_10 	;Go swap fixed length strings
;
; [ES:DI] points to an sd, [DS:SI] points to an FS, with length in [DX]
;
SWPN_30:
	LES	DI,pOp1 	;[ES:DI] points to first one
	LDS	SI,pOp2 	;[DS:SI] points at the second
;
; [DS:SI] points to an sd, [ES:DI] points to an FS, with length in [DX]
;
SWPN_40:
	PUSH	DX		;Save length of FS
	cCall	B$LDFS,<ES,DI,DX> ;[AX] = pointer to temp sd
	POP	DX		;[DX] = length of FS
	XCHG	AX,DI		;[DI] = pointer to temp sd
	XOR	BX,BX
	cCall	B$ASSN,<DS,SI,BX,ES,AX,DX>	;original sd to original fs
	cCall	B$SASS,<DI,SI> ;temp sd to original sd
	JMP	SHORT SWPN_90
;
; We have two string descriptors. Swap 'em
;
SWPN_50:
	cCall	B$STSWAPDESC	;else swap string descriptors

SWPN_90:

cEnd

	SUBTTL	B$SWSD = SWAP string descriptors
	PAGE
;***
; B$SWSD - Swap string descrtiptors
; void pascal B$SWSD(SI: *psd1,DI: *psd2)
; Added rev [17]
;
;Purpose:
; swap variable length strings
;
;Entry:
; SI	= pointer to first string operand
; DI	= pointer to second string operand
;
;Exit:
; swapped
;
;Uses:
; per convention
;
;******************************************************************************
cProc	B$SWSD,<FAR,PUBLIC>
cBegin
	cCall	B$STSWAPDESC	;swap string descriptors
cEnd


	SUBTTL	B$SCPY - copy string to temp string
	PAGE
;***
;B$SCPY - String copy to temporary string
;
;Entry:
;	parmW = SDESC of string to copy
;Exit:
;	AX = SDESC of temp string (copy)
;Uses:
;	Per convention
;Exceptions:
;	B$ERR_OM
;****
cProc	B$SCPY,<PUBLIC,FAR>
parmW	psdSource
cBegin
	XOR	CX,CX		;CX = offset = 0
	MOV	BX,psdSource	;get ptr to sd
	MOV	DX,[BX] 	;DX = length
	CALL	B$STALCTMPSUB	;create copy of string
	XCHG	AX,BX		;return psd in AX
cEnd

	SUBTTL	B$STDL - deallocate a string
	PAGE
;***
; B$STDL - deallocate a string
; void B$STDL(sd *)
;
;Purpose:
;	Given a pointer to an sd, deallocate it.
;Entry:
;	pSd -	a pointer to a string descriptor
;Exit:
;	none.
;Uses:
;	Per convention
;Exceptions:
;	none.
;******************************************************************************
cProc	B$STDL,<PUBLIC,FAR>	
parmW	pSd
cBegin	B$STDL 			
	MOV	BX,[pSd]
	PUSH	BX		
	CALL	B$STDALC
	POP	BX		
	MOV	WORD PTR [BX],0 ; Indicate deallcated with zero length
cEnd	B$STDL


	SUBTTL	B$SCPF - copy string to temp string for recursive functions
	PAGE
;***
;B$SCPF - String copy to temporary string for recursive string functions
;
;Entry:
;	parmW = SDESC of string to copy
;Exit:
;	AX = SDESC of temp string (copy)
;Uses:
;	Per convention
;Exceptions:
;	B$ERR_OM
;****
cProc	B$SCPF,<PUBLIC,FAR>	; new for recursive string functions
parmW	psdSource
cBegin
	push	psdSource
	call	B$SCPY 		;make a copy of string function result
	push	ax		;save it
	push	psdSource
	call	B$STDL 		;delete string function result
	pop	ax		;restore copy of string function result
cEnd

sEnd	ST_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\stfree.asm ===
TITLE	STFREE - FRE String functions
;***
; STFREE - Free String function package
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	BASIC intrinsic FRE string function support.
;
; BASIC Syntax mapping to included runtime entry points:
;
; - FRE Function
;
;      v = FRE(arg)	   where 'arg' can be a numeric or a string
;
;    Examples:
;
;      v = FRE(1)		   v = FRE(a$)
;	    |				|
;	 B$FRI2		     B$FRSD
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	USESEG	_DATA		
	USESEG	FH_TEXT 	
	USESEG	ST_TEXT

	INCLUDE seg.inc
	INCLUDE stack2.inc	
	INCLUDE string.inc	
	INCLUDE idmac.inc	

sBegin	_DATA			
	externW b$pend		
sEnd				

sBegin	FH_TEXT

	externNP B$FHCompact	;FHINIT - compact far heap
	externNP B$FHByteSize	;FHINIT - get size of far heap after compaction

sEnd	FH_TEXT


sBegin	ST_TEXT

	externNP B$STDALCTMP	; deallocate if temp string
	externNP B$NHCPCT	
	externNP B$STGETFRESIZ	

assumes CS,ST_TEXT

;***
;B$FRSD - FREE function with string parameter
;
;Purpose:
; Perform a compaction on the string sb containing the input parm
; and return amount of free space in that string sb.
;
;Inputs:
; dummy = string desc
;
;Outputs:
; [DX:AX] =  size of free space
;
;Modifies:
; per convention
;
;******************************************************************************
cProc	B$FRSD,<FAR,PUBLIC>	
parmSD	dummy			; dummy sd (never -1, for fall)
cBegin				

	GetpSD	BX,dummy	; BX = psdDummy
	cCall	B$STDALCTMP	; deallocate it if it was a temp
	XOR	BX,BX		;clear flag for just NH compaction
	JMP	SHORT FRE_ENTRY ;perform NH compaction and return its size

cEnd	nogen			


;***
;B$FRI2 - FREE function with numeric parameter [5]
;
;Purpose:
; If BX is -1, the space in the FH heap is returned.
; If BX is -2, the unused stack space is returned.
; Else, returns the size of the next free block in string space.
;
; IF FV_FARSTR, "string space" is defined as the module-level/static string
; sb.
;
;Inputs:
; flag	= integer parameter
;
;Outputs:
; [DX:AX] =  size of free space
;
;Modifies:
; per convention
;
;******************************************************************************
cProc	B$FRI2,<FAR,PUBLIC>	
parmW	flag			; integer arg
cBegin

	MOV	BX,flag 	; get the flag
FRE_ENTRY:			;Common entry point for B$FRSD
	PUSH	SI		
	XOR	AX,AX		;set DX:AX to zero in case of...
	CWD			;...a non-far heap size is requested
	INC	BX		; test if FH space is to be returned
	JZ	FRE_FH		; if so, then do the FH compression
	INC	BX		; test if stack space to be returned
	JNZ	FRE_NOT_FH	; jump if not returning stack space

;
; FRE(-2): Determine available stack space. We do this by scanning from the
; bottom of the stack area [b$pend], looking for known data placed there at
; init/clear time. Once we find something other than that data, we have
; determined how much stack was used. The data expected tells us how much space
; was left.
;
FRE_STACK:			
	.erre	ID_SSEQDS	; we assume DS points at stack
	MOV	SI,[b$pend]	; start search for new data from _end
	MOV	BX,-STACK_MIN-2 ; for loop entry
FRE_STACK_LOOP: 		
	INC	BX		; move up in the stack
	INC	BX		
	CMP	BX,[SI] 	; is it what we expected?
	LODSW			; inc si by two
	JZ	FRE_STACK_LOOP	; loop until it isn't
	MOV	DX,-1		
	XCHG	AX,BX		; [AX] = # of bytes left
	CMP	AX,-STACK_MIN	; See if real bytes, or dipped into reserve
	JMP	SHORT FRE_EXIT_2; inc DX to zero if valid byte count

FRE_FH: 			
	CALL	B$FHCompact	;compact the far heap. SI = next to last FHD
	CALL	B$FHByteSize	;DX:AX = FH entry size

FRE_NOT_FH:
	CALL	B$NHCPCT	;compact all strings and heap
	CALL	B$STGETFRESIZ	;  [BX] =  free string size
	ADD	AX,BX		;add string size to FH size...
FRE_EXIT_2:			
	ADC	DX,0		;...propagate any carry
FRE_EXIT:			
	POP	SI		;recover original SI
cEnd				


sEnd	ST_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\swap.asm ===
TITLE	SWAP - Swap values
	PAGE	56,132
;***
; SWAP - Swap values
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; SWAP Statement - calls one of 4 entry points, based on arg type:
;
;      SWAP var1, var2
;
;    Examples:
;
;     SWAP a!,b!	    SWAP c#,d#		 SWAP e%,f%	      SWAP g$,h$
;	|		      | 		   |			|
;     $SWPA		    $SWPB		 $SWPC		      $SWPD
;
;******************************************************************************
	INCLUDE switch.inc	
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	RT_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE baslibma.inc	
	INCLUDE pointers.inc	


sBegin	RT_TEXT 		

assumes CS,RT_TEXT		

;***
; B$SWP2, B$SWP4, B$SWP8 - Swap values
;
;Purpose:
; Runtime Entry Points. Interchange values.
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Entry:
; pOp1	= Far address of one operand
; pOp2	= FAR address of other operand
;
;******************************************************************************

cProc	B$SWP8,<FAR,PUBLIC>
cBegin	nogen			
	MOV	AL,4		;[AL] = number of words to swap
	SKIP	2		;skip the next
cEnd	nogen

cProc	B$SWP4,<FAR,PUBLIC>
cBegin	nogen			
	MOV	AL,2		;[AL] = number of words to swap
	SKIP	2		;skip the next
cEnd	nogen

cProc	B$SWP2,<FAR,PUBLIC>
cBegin	nogen			
	MOV	AL,1		;[AL] = number of words to swap
cEnd	nogen

cProc	SWAP_COMMON,FAR,<DI,ES,DS>  
parmD	pOp1			
parmD	pOp2			
cBegin
	GETPTR	,ES,DI,pOp1,,<SIZE,LOAD>    ; [ES:DI] = pointer to Op1
	GETPTR	,DS,BX,pOp2,,<SIZE,LOAD>    ; [DS:BX] = pointer to Op2
	CBW			;[AX] = number of words
	XCHG	AX,CX		;[CX] = number of words
SWAPLOOP:
	MOV	AX,ES:[DI]
	XCHG	AX,[BX]
	STOSW			;swap!
	INC	BX
	INC	BX
	LOOP	SWAPLOOP
cEnd				

sEnd	RT_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\stinkey.asm ===
TITLE	STINKEY - INKEY Function
	PAGE	56,132
;***
;STINKEY - INKEY Function
;
; Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;   INKEY$ Function:
;
;     v$ = INKEY$
;	     |
;	   B$INKY
;
; Includes the INKEY function. This is pulled out to isolate it from both the
; string and input packages, to avoid one or the other being called in if INKEY
; is NOT used, and they are not needed.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	useSeg	_BSS
	useSeg	_DATA
	useSeg	ST_TEXT

	INCLUDE seg.inc
	INCLUDE const.inc

sBegin	_DATA
externB b$IOFLAG		;Misc. IO flags.  Defined in GWINI.ASM

externW b$nuldes
sEnd	_DATA

sBegin	_BSS
externW b$PTRFIL		;defined in GOSTOP.ASM
sEnd	_BSS

externFP B$FCHR 		;CHR$ function

sBegin	ST_TEXT
assumes CS,ST_TEXT

externNP B$STDGET
externNP B$INKMAP
externNP B$STALCTMP
externNP B$TTYIN
externNP B$TTYST
externNP B$END			


	SUBTTL	B$INKY - INKEY$ function
	PAGE
;***
; B$INKY - INKEY$ function
; sd * pascal B$INKY(void)
;
;Function:
; If a character is waiting at the console, return it in a 1-char temp string.
; Otherwise, return null string descriptor.
;
;Inputs:
; None.
;
;Outputs:
; [AX]	= Address of string descriptor
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$INKY,<FAR,PUBLIC,FORCEFRAME>	; set up frame for error recovery
cBegin

INKGET: 			;If we have to get another character
				;check for redirection again.
	TEST	b$IOFLAG,RED_INP;Is input redirected ?
	JZ	NOT_REDIT	;Jump if not redirected
;
; Since redirected input should always have a character ready, INKEY$ will
; always return a character until the end of the redirected input file is
; reached. At this point, the program should gracefully exit.
;
	MOV	b$PTRFIL,0
	CALL	B$STDGET 	;[AL] = character from standard input
	jnz	contin		;got one, continue
	JMP	B$END		;End of redirected input seen, exit program
NOT_REDIT:

	CALL	B$TTYST 	;See if anything out there
	MOV	AX,OFFSET DGROUP:b$nuldes
	JZ	INKY_90 	;exit if not
	CALL	B$TTYIN		;read the char if there
contin:

	cCALL	B$INKMAP	;OEM's routine to map char
	JZ	INKGET		;OEM has no associated character
	JAE	inknrm		;branch if not 2-byte sequence

inkfun:
	CMP	AX,00FEH	;The only way [ax]=00feh for the
				;2-byte case is when one of the fn keys
				;is assigned to chr$(254)
	JE	inknrm		;If true, treat this as a single character
				;set equal to 254.
	XCHG	AL,AH		;Yes:Get in order for POP [BX] in chrsub
	PUSH	AX		;Save 2 characters
	MOV	BX,2		;Want a 2 character string
	CALL	B$STALCTMP	;Allocate a one-byte string
	XCHG	BX,DX		;Get pointer to data in BX
	POP	[BX]		;Put character in string
	XCHG	AX,DX		;[AX] = descriptor address
	JMP	SHORT INKY_90	;and exit

inknrm:

	XOR	AH,AH		;[AX] has character
	cCall	B$FCHR,AX	;[AX] has pointer to sd
INKY_90:

cEnd

sEnd	ST_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\strnum.asm ===
TITLE	STRNUM - String to number and number to string conversions
;***
; STRNUM - String to number and number to string conversions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; CVI Function: 		CVL Function:
;
;   v = CVI(2-byte string)	  v = CVL(4-byte string)
;	    |				  |
;	 B$FCVI		       B$FCVL
;
;
; CVS Function: 		CVD Function:
;
;   v = CVS(4-byte string)	  v = CVD(8-byte string)
;	    |				  |
;	 B$FCVS		       B$FCVD
;
;
; CVSMBF Function:		CVDMBF Function:
;
;   v = CVSMBF(4-byte string)	  v = CVDMBF(8-byte string)
;	    |				  |
;	 B$FCSF		       B$FCDF
;
;
; MKI$ Function:		MKL$ Function:
;
;   v$ = MKI$(integer exp)	  v$ = MKL$(long integer exp)
;	     |				   |
;	 B$FMKI		       B$FMKL
;
;
; MKS$ Function:		MKD$ Function:
;
;   v$ = MKS$(s.p. exp) 	  v$ = MKD$(d.p. exp)
;	     |				   |
;	 B$FMKS		       B$FMKD
;
;
; MKSMBF$ Function:		MKDMBF$ Function:
;
;   v$ = MKSMBF$(s.p. exp)	  v$ = MKDMBF$(d.p. exp)
;	     |				   |
;	  B$FMSF			B$FMDF
;
;******************************************************************************
	INCLUDE switch.inc	
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	ST_TEXT
	useSeg	_TEXT
	useSeg	_DATA
	useSeg	_BSS

	INCLUDE seg.inc
	INCLUDE	baslibma.inc	
	INCLUDE string.inc	

sBegin	_DATA

externW B$AC
externW B$DAC

sEnd	_DATA

sBegin	_BSS

	externB	b$Buf3		; temporary space

sEnd	_BSS

	externFP B$ERR_OV	; FAR because it's JMP'ed to from _TEXT

sBegin	_TEXT			
	externNP $i4_m4		
	externNP $i8_m8		
	externNP $m4_i4		
	externNP $m8_i8		
sEnd	_TEXT

sBegin	ST_TEXT

	externNP B$STDALCTMP
	externNP B$STALCTMPCPY
	externNP B$STALCTMP
	externNP B$ERR_FC

	ASSUMES CS,ST_TEXT

	SUBTTL
	PAGE
;***
;STRCPY - copy CX bytes from string to given location & free string if temp.
;
;Purpose:
; This routine is shared code for the CVS/CVD/... routines. Must be far, since
; it is called from another segment in some routines defined below.
;
;Entry:
; [BX] = pointer to a string descriptor.
; [CX] = count of bytes to copy from the string
; [DI] = target address for the copy.
;
;Exit:
; The copy is made, and the string is deallocated it temp.
; [AX] = pointer to the start of the target address (input DI)
;
;Modifies:
; Per Convention
;
;******************************************************************************
cProc	STRCPY,FAR,<DI,SI,ES>  ; added this routine to save code
cBegin

	CMP	BYTE PTR[BX],CL ;See if string is long enough
	JB	ARGERR

	PUSH	DS
	POP	ES		;[ES] = [DS]
	MOV	SI,[BX+2]	;Get address of data area
	PUSH	DI		;save for retval

	REP	MOVSB		;copy the string data
	CALL	B$STDALCTMP	;Delete string if temp
	POP	AX		;pointer to target address
cEnd

ARGERR: JMP	B$ERR_FC	;Illegal function call

;***
; B$FCVI - Convert string to integer
;
;Function:
; Make sure string is at least 2 bytes long, then return the first 2 bytes
; as an integer.
;
;Inputs:
; sdNum = string descriptor
;
;Outputs:
; [AX]	= number
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$FCVI,<FAR,PUBLIC>	
cBegin	<nogen>			
	MOV	CL,2		;[CL] = length to do
	SKIP	2		; fall through - share code
cEnd	nogen

;***
; B$FCVL - Convert string to long integer
;
;Function:
; Make sure string is at least 4 bytes long, then return the first 4 bytes
; as a long integer.
;
;Inputs:
; sdNum = string descriptor
;
;Outputs:
; [DX:AX]  = number
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$FCVL,<FAR,PUBLIC>
cBegin	<nogen>			
	MOV	CL,4		;[CL] = length to be copied
	XOR	CH,CH		
cEnd	<nogen>			; fall through to common code

cProc	BFCV_Int,<FAR>,DI	
parmSD	sdNum			
cBegin				
	GetpSD	BX,sdNum	; [BX] = psdNum
	MOV	DI,OFFSET DGROUP:B$AC	;[DI] = pointer to dummy place to copy
	CALL	STRCPY
	XCHG	AX,BX		;[BX] = pointer to number
	MOV	AX,[BX] 	;[AX] = low word of number (both CVL and CVS)
	MOV	DX,[BX+2]	;[DX] = high word (CVL only, else garbage)
cEnd

;***
; B$FCVS, B$FCVD - Convert string to single or double precision number
;
;Function:
; Convert the string to single or double precision number. Make sure it's long
; enough first.
;
;Inputs:
; sdNum = string descriptor
;
;Outputs:
; [AX] = pointer to resulting number in FAC/DAC
;
;Registers:
; per convention
;******************************************************************************
cProc	B$FCVS,<FAR,PUBLIC>	
cBegin	<nogen>			
	MOV	CL,4		
	SKIP	2
cEnd	<nogen>			; fall through to share code

cProc	B$FCVD,<FAR,PUBLIC>	
cBegin	<nogen>			
	MOV	CL,8		
	XOR	CH,CH		
cEnd	<nogen>

cProc	BFCV_Real,<FAR>,DI	
parmSD	sdNum			
cBegin				
	MOV	DI,OFFSET DGROUP:B$DAC
	GetpSD	BX,sdNum	; [BX] = psdNum
	CALL	STRCPY		
cEnd

;***
; B$FMKI, B$FMKL, B$FMKS, B$FMKD - Convert number to string
;
;Function:
; Create a 2-, 4-, or 8-byte temp string and put the number in it.
;
;Inputs:
; ivar	= Integer to be converted (MKI)
; lvar	= Long integer to be converted (MKL)
; R4var = real (s.p.) number to be converted (MKS)
; R8var = real (d.p.) number to be converted (MKD)
;
;Outputs:
; [AX]	= Address of string descriptor
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$FMKI,<FAR,PUBLIC>
parmW	ivar
cBegin
	MOV	BX,2		;Create a string of length 2
	LEA	DX,ivar		; [DX] = pointer to input parm
	CALL	B$STALCTMPCPY	; Allocate string and copy data in
	XCHG	AX,BX		; [AX] = pointer to descriptor
cEnd

cProc	B$FMKL,<FAR,PUBLIC>
cBegin	<nogen>			
cEnd	<nogen>			; share code with B$FMKS

cProc	B$FMKS,<FAR,PUBLIC>
parmD	R4num			
cBegin
MK_4:				
	MOV	BX,4		;Create a string of length 4
	LEA	DX,R4num	; [DX] = pointer to input parm
	CALL	B$STALCTMPCPY	; Allocate string and copy data in
	XCHG	AX,BX		; [AX] = pointer to descriptor
cEnd

cProc	B$FMKD,<FAR,PUBLIC>
parmQ	R8num			
cBegin
	MOV	BX,8		;4 Bytes in single precision number
	LEA	DX,R8num 	;[DX] = pointer to data
	CALL	B$STALCTMPCPY	;Allocate string and copy data in
	XCHG	AX,BX		;[AX] = pointer to descriptor
cEnd

sEnd	ST_TEXT			

sBegin	_TEXT			
assumes CS,_TEXT		

;***
;Ix_Mx
;
;Purpose:
; Since the low-level conversion functions (MBF to/from IEEE) are near routines
; in _TEXT, B$MCVS & B$MCVD call this routine to do the actual conversion
; (so they can be in ST_TEXT).
;
;Entry:
; AX is 4 if $i4_m4 is to called, 8 if $i8_m8 is to be called.
;
;******************************************************************************
;***
;Mx_Ix
;
;Purpose:
; Since the low-level conversion functions (MBF to/from IEEE) are near routines
; in _TEXT, B$FMSF & B$FMDF call this routine to do the actual conversion
; (so they can be in ST_TEXT).
;
;Entry:
; CX is 4 if $m4_i4 is to called, 8 if $m8_i8 is to be called.
;
;******************************************************************************
IX_MX_DISP:
	DW	_TEXTOFFSET $i4_m4 
	DW	_TEXTOFFSET $i8_m8 
MX_IX_DISP:
	DW	_TEXTOFFSET $m4_i4 
	DW	_TEXTOFFSET $m8_i8 

cProc	Ix_Mx,<FAR>		
cBegin	<nogen>			
	MOV	BX,_TEXTOFFSET IX_MX_DISP 
	JMP	SHORT Convert_Common 
cEnd	<nogen>			

cProc	Mx_Ix,<FAR>		
cBegin	<nogen>			
	XCHG	AX,CX		; put input into AX for common code, below
	MOV	BX,_TEXTOFFSET MX_IX_DISP 
cEnd	<nogen>			

cProc	Convert_Common,<FAR>	
cBegin
	SHR	AL,1		; convert AL = 4 or 8 to AL = 0 or 2
	SHR	AL,1		
	AND	AL,0FEH		
	ADD	BL,AL		; add offset to dispatch table start
	CALL	CS:[BX]		; call appropriate mathpack routine
	OR	AX,AX		; Overflow?
	JZ	Convert_done	; Jump if not
	JMP	B$ERR_OV	; Else declare error
Convert_done:			
cEnd

sEnd	_TEXT			


sBegin	ST_TEXT			
assumes CS,ST_TEXT		

;***
;B$MCVS - CVSMBF function
;
;Purpose:
; Given a string containing a 4-byte s.p. number in Microsoft Binary Format,
; return a pointer to an s.p. number in IEEE format.
;
;Entry:
; sdNum - string descriptor for the 4-byte string
;
;Exit:
; [AX]	= pointer to resulting number in FAC.
;
;Uses:
; Per convention
;******************************************************************************
cProc	B$MCVS,<PUBLIC,FAR,NODATA>	
cBegin	<nogen>			
	MOV	CL,4		
	SKIP	2		
cEnd	<nogen>			

;***
;B$MCVD - CVDMBF function
;
;Purpose:
; Given a string containing a 8-byte d.p. number in Microsoft Binary Format,
; return a pointer to an d.p. number in IEEE format.
;
;Entry:
; sdNum - string descriptor for the 4-byte string
;
;Exit:
; [AX]	= pointer to result in DAC
;
;Uses:
; Per convention
;******************************************************************************
cProc	B$MCVD,<PUBLIC,FAR,NODATA>	
cBegin	<nogen>
	MOV	CL,8		
	XOR	CH,CH		
cEnd	<nogen>			

cProc	BMCV_Real,<FAR,NODATA>,<ES,SI,DI> 
parmSD	sdNum				

cBegin				
	MOV	SI,OFFSET DGROUP:B$DAC
	GetpSD	BX,sdNum	;BX = psdNum
	MOV	DI,OFFSET DGROUP:b$Buf3 ; temporary storage (>= 8 bytes)
	PUSH	CX		;Save the byte count
	CALL	STRCPY		;copy data to $FTMP, delete string if temp
	POP	AX		;[AX] = count of bytes
	XCHG	SI,DI		;SI points to B$FTMP1 (input number)
	PUSH	DS
	POP	ES		;ES = DS for math format mapping call

	PUSH	DI		;save pointer to result for retval
	CALL	Ix_Mx		; perform actual conversion
	POP	AX		;restore pointer to converted number in DAC
cEnd

;***
;B$FMDF - MKDMBF$ function
;
;Purpose:
; Given an 8-byte d.p. number in IEEE format, return a pointer to
; an sd containing the d.p. number in Microsoft Binary Format.
;
;Entry:
; R8parm - a d.p. number
;
;Exit:
; [AX]	= pointer to a string descriptor
;
;Uses:
; Per convention
;******************************************************************************
cProc	B$FMDF,<PUBLIC,FAR,NODATA> ;[6][3]
parmQ	R8parm			
cBegin				
	MOV	BX,8		; 8 Bytes in d.p. # (required string size)
	LEA	AX,R8parm	
	CALL	MK_MBF_SHARED	
cEnd				

;***
;B$FMSF - MKSMBF$ function
;
;Purpose:
; Given a 4-byte s.p. number in IEEE format, return a pointer to
; an sd containing the s.p. number in Microsoft Binary Format.
;
;Entry:
; R4parm - a s.p. number
;
;Exit:
; [AX]	= pointer to a string descriptor
;
;Uses:
; Per convention
;******************************************************************************
cProc	B$FMSF,<PUBLIC,FAR,NODATA> ;[6][3]
parmD	R4parm
cBegin				
	MOV	BX,4		; 4 Bytes in s.p. # (required string size)
	LEA	AX,R4parm	
	CALL	MK_MBF_SHARED	
cEnd				

cProc	MK_MBF_SHARED,<NEAR>,<ES,SI,DI>	;[6]
cBegin
	XCHG	AX,SI		; DS:SI = source address
	PUSH	BX		; save size of number
	CALL	B$STALCTMP	;allocate temp string; DX points to data area
	MOV	DI,DX		;DI = target address
	PUSH	DS
	POP	ES		;ES:DI = target address
	POP	CX		; restore size of number
	PUSH	BX		;save address of string descriptor (for retval)

	CALL	Mx_Ix		; do the actual conversion
	POP	AX		;restore pointer to string descriptor
cEnd

sEnd	ST_TEXT			

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\strfcn.asm ===
TITLE	STRFCN - String function package
	PAGE	56,132
;***
; STRFCN - String function package
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	BASIC intrinsic string function support.
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; INSTR Function - calls B$INS3 if optional parameter given, otherwise B$INS2:
;
;   v = INSTR(5, a$, b$)  v = INSTR (x$, y$)
;	   |			 |
;	B$INS3		      B$INS2
;
;
; LEFT$ Statement:	LEN Function:		LSET Statement:
;
;   v$ = LEFT$(x$,n)	  v = LEN(x$)		  LSET v$ = x$
;	  |		       |		       |
;	B$LEFT		    B$FLEN		     B$LSET
;
;
; MID$ Function:	RIGHT$ Function:	SPACE$ Function:
;
;   v$ = MID$(x$,n,[m])   v$ = RIGHT$(x$,n)	  v$ = SPACE$(n)
;	  |			|			 |
;      B$FMID		     B$RGHT		      B$SPAC
;
;
; STRING$ Function - Two possible syntaxes map to two runtime entry points:
;
;   v$ = STRING$(n,m)	  v$ = STRING$(n,x$)
;	    |			 |
;	B$STRI		      B$STRS
;
;
; VARPTR$ Function:-	       ASC Function:
;
;   v$ = VARPTR$(a)		 v = ASC(string)
;	    |			       |
;	B$VARP(addr, type)	    B$FASC
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	_DATA		
	useSeg	NH_TEXT 	
	useSeg	ST_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE baslibma.inc
	INCLUDE files.inc
	INCLUDE devdef.inc
	INCLUDE const.inc	

sBegin	_DATA

externW b$nuldes 		;[6]

sEnd	_DATA			

sBegin	ST_TEXT 		
assumes CS,ST_TEXT		

externNP B$STALCTMP		
externNP B$STALCTMPSUB		

externNP B$ERR_FC		
externNP B$ERR_FC		
externNP B$STDALCTMP		


	SUBTTL	B$SADD & B$FLEN - get address & length of string
	PAGE
;***
;B$SADD - get address of string
;char * pascal B$SADD(sd *psd)
;
;Function:
; Implement SADD function by returning the address of the specified string.
;
;Inputs:
; psd	= ptr to sdesc
;
;Outputs:
; [AX]	= integer address (0 if null string)
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$SADD,<FAR,PUBLIC>	
parmW	psd			; Pointer to sd to get address from
cBegin				
	MOV	BX,psd		; [BX] = pointer to sd
	MOV	CX,[BX] 	; [CX] = length of string
	JCXZ	FLEN_10 	; If zero length, just return 0
	PUSH	[BX+2]		; Put address on stack
	JMP	SHORT FLEN_20	; go share some code
cEnd	nogen			

;***
;B$FLEN - Compute LEN function
;I2 pascal B$FLEN(sd *psd)
;
;Inputs:
; psd	= Address of string descriptor
;
;Outputs:
; [AX]	= Value of LEN function
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$FLEN,<FAR,PUBLIC>	
parmW	psd			
cBegin				
	MOV	BX,psd		; get string descriptor
FLEN_10:
	PUSH	[BX]		;Put length on stack
FLEN_20:			
	CALL	B$STDALCTMP	;Delete if temp string
	POP	AX		; [AX] has length/addr
FLEN_90:			
cEnd				

	SUBTTL	B$FASC - Compute ASC function
	PAGE
;***
;B$FASC - Compute ASC function
;I2 pascal B$FASC(sd *psd)
;DBCS-callback
;
;Purpose:
;	This routine is used to support the ASC() function.
;
;Entry:
;	psd   = Address of string descriptor
;
;Exit:
;	[AX]  = Value of ASC function
;
;Uses:
;	Per convention
;
;Preserves:
;	None.
;
;Exceptions:
;	B$ERR_FC for an empty string or illegal double byte character.
;******************************************************************************
cProc	B$FASC,<FAR,PUBLIC>,SI 
parmW	psd			
cBegin				
	MOV	BX,psd		
	CMP	WORD PTR[BX],0	;See if nul string
	JZ	ERRFC


	MOV	SI,[BX+2]	;Get pointer to string data
	MOV	SI,[SI] 	;Save first char of string
	CALL	B$STDALCTMP	;Delete if temp string
	XCHG	AX,SI		; [AL] = first character of string


ONEBYT: XOR	AH,AH		; [AX] = character
TWOBYT:

cEnd				
ERRFC:	JMP	B$ERR_FC	  ;Report illegal function call


	SUBTTL	B$INS3 - INSTR function for three arguments
	PAGE
;***
;B$INS3 - INSTR function for three arguments
;I2 pascal B$INS3(I2 start, sd *psdSource, sd *psdMatch)
;
;Function:
; Perform INSTR(I,A$,B$).
;
;Inputs:
; start     = Starting position in A$ of search (I)
; psdSource = Address of descriptor of string to be searched (A$)
; psdMatch  = Address of search string descriptor (B$)
;
;Outputs:
; [AX]	    = Position of B$ in A$; zero if not found.
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$INS3,<FAR,PUBLIC>,<DI,SI,ES> 
parmW	start			
parmW	psdSource		
parmW	psdMatch		
cBegin				
	MOV	BX,start	
	OR	BX,BX
	JLE	ERRFC		

	MOV	DI,psdSource	;Get A$ descriptor where we can address with it
	MOV	SI,psdMatch	;Get B$ descriptor where we can address with it
	LODSW			;Length of B$
	XCHG	AX,DX		;Length of B$ in DX
	MOV	SI,[SI] 	;Address of B$ data
	MOV	CX,[DI] 	;Length of A$
	JCXZ	NOTFND		;IF	LEN(A$) = 0  - return zero
	DEC	DX		;DX = LEN(B$)-1
	JNS	instr1		;  B$ is not null string
	CMP	BX,CX		;Offset : LEN(A$)
	JG	NOTFND		;  > - return 0
	JMP	short EXITFND	; <= - return Offset
instr1:
	MOV	DI,[DI+2]	;Address of A$ data
	DEC	BX		;Starting offset in A$
	ADD	DI,BX		;Add in starting offset
	SUB	CX,DX		;Last pos. search position
	XCHG	AX,BX		;AX = offset
	MOV	BX,CX		;Save in BX
	SUB	CX,AX		;Number of 1st chars to search
	JLE	NOTFND		;If search string won't fit, say not found
	LODSB			;Get first character of search string

; Top of search loop. The following conditions exist here:
;	AL = First character of search string (B$).
;	BX = Last position in A$ for 1st char match
;	CX = Amount of A$ left for first-character scan.
;	DX = Length of B$-1, used for string compares.
;	SI = Address of B$+1, used for string compares.
;	DI = Current position to scan in A$.

SEARCH:
	PUSH	DS		
	POP	ES		; [ES] = [DS]
	JCXZ	NOTFND		;If nothing left in A$, not found
	REPNE	SCASB		;Scan for first letter
	JNZ	NOTFND		;Was first letter found?

;Found a match in first letter. Do string compare on remaining letters

	PUSH	CX		;Save condition should compare be unsuccessful
	PUSH	SI		;  and we need to continue first-character
	PUSH	DI		;  search.
	MOV	CX,DX		;Get length of B$-1 for string compare
	REPE	CMPSB
	POP	DI
	POP	SI
	POP	CX
	JNZ	SEARCH		;If it didn't match, just continue searching
	SUB	BX,CX		;Compute position of match from start of string
EXITFND:
	XCHG	BX,DX		;[DX] = result return
	MOV	BX,psdSource	
	CALL	B$STDALCTMP	;Get rid of temporary strings
	MOV	BX,psdMatch	
	CALL	B$STDALCTMP	
	XCHG	AX,DX		; [AX] = result

cEnd

NOTFND:
	XOR	BX,BX
	JMP	EXITFND

	SUBTTL	B$INS2 - INSTR function with 2 arguments
	PAGE
;***
;B$INS2 - INSTR function with 2 arguments
;I2 pascal B$INS2(sd *psdSource, sd *psdMatch)
;
;Function:
; Perform INSTR(A$,B$).
;
;Inputs:
; psdSource = Address of descriptor of string to be searched (A$)
; psdMatch  = Address of search string descriptor (B$)
;
;Outputs:
; [AX]	    = Position of B$ in A$; zero if not found.
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$INS2,<FAR,PUBLIC>	
parmW	psdSource		
parmW	psdMatch		
cBegin				
	MOV	BX,1		;Start with position 1
	cCall	<FAR PTR B$INS3>,<BX,psdSource,psdMatch>	
cEnd				

	SUBTTL	B$LEFT & B$RGHT - Compute LEFT$ & RIGHT$ functions
	PAGE
;***
;B$LEFT - Compute LEFT$ function
;sd * pascal B$LEFT(sd * pas, I2 len)
;
;Function:
; Return a string made up of the leftmost ($LEF) characters of the source
; string. If the requested length is less than zero, then give error; if
; greater than the length of the source string, the source string itself is
; returned; otherwise, a temporary string is created.
;
; NOTE: The characters are assumed to be 1 byte characters.  It is possible
;	for the user to split a KANJI character with this function.
;
;Inputs:
; psd	= Address of string descriptor
; len	= Length of string wanted
;
;Outputs:
; [AX]	= Address of result string descriptor
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$LEFT,<FAR,PUBLIC>	
parmW	psd			
parmW	len			
cBegin				
	XOR	CX,CX		;Start at left end
	MOV	BX,psd		
	MOV	DX,len		
	JMP	SHORT RIG1	;Go to common code
cEnd	nogen			

;***
;B$RGHT - Compute RIGHT$ function
;sd * pascal B$RGHT(sd * pas, I2 len)
;
;Function:
; Return a string made up of the rightmost ($RIG) characters of the source
; string. If the requested length is less than zero, then give error; if
; greater than the length of the source string, the source string itself is
; returned; otherwise, a temporary string is created.
;
; NOTE: The characters are assumed to be 1 byte characters.  It is possible
;	for the user to split a KANJI character with this function.
;
;Inputs:
; psd	= Address of string descriptor
; len	= Length of string wanted
;
;Outputs:
; [AX]	= Address of result string descriptor
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$RGHT,<FAR,PUBLIC>	
parmW	psd			
parmW	len			
cBegin				
	MOV	BX,psd		
	MOV	DX,len		
	MOV	CX,[BX] 	;Get length
	SUB	CX,DX		;Starting point (from left)
RIG1:
	CALL	LEFRIG
cEnd				

ARGER2: JMP	B$ERR_FC	  ;Clean stack and report illegal function call

	SUBTTL	B$FMID - Compute MID$ function
	PAGE
;***
;B$FMID - Compute MID$ function
;sd * pascal B$FMID(sd *psdSource, I2 iStart, I2 cbLen)
;
;Function:
; If (iStart < 1) or (cbLen < 0) then give error; if (iStart = 1) and
; (cbLen >= length of source string) then return source string; otherwise
; create a temp string of length CX with the specified portion of the source
; string.
;
; NOTE: The characters are assumed to be 1 byte characters.  It is possible
;	for the user to split a KANJI character with this function. See the
;	MID\ (MID yen) function for a version that works with double byte
;	characters.
;
;Inputs:
; psdSource = Address of string descriptor
; iStart    = Starting offset in string (1 is first)
; cbLen     = Length of string desired
;
;Outputs:
; [AX] = Address of result string descriptor
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$FMID,<FAR,PUBLIC>	
parmW	psdSource		
parmW	iStart			
parmW	cbLen			
cBegin				

	MOV	BX,psdSource	
	MOV	CX,cbLen	
	OR	CX,CX		;test string length
	JL	ARGER2		;error if negative
	MOV	DX,iStart	
	DEC	DX		;Offset should start at zero, not 1
	XCHG	DX,CX		;Set up for future call
	JL	ARGER2		;Error if now negative
	JNZ	MID_10		
	CALL	LEFRIG		; Offset is zero, so treat just like LEFT$
	JMP	SHORT MID_90	
MID_10: 			
	MOV	AX,[BX] 	;Get length of string
	SUB	AX,CX		;Reduce length by the offset
	JNLE	MID_20		
	CALL	B$STDALCTMP	;Delete if temp string
	MOV	AX,OFFSET DGROUP:b$nuldes ; Null string descriptor
	JMP	SHORT MID_90	
MID_20: 			
	CMP	AX,DX		;Need smaller of request and amount remaining
	JGE	MIDLEN
	MOV	DX,AX		;Limited by length of string
MIDLEN:
	CALL	B$STALCTMPSUB	;Create temp string from descriptor
	XCHG	AX,BX		; [AX] has return value
MID_90:

cEnd				


;***
; LEFRIG - support routine
;
;Purpose:
; This subroutine is used for $LEF, $RIG, and some $MID.
;
;Entry:
; [BX]	 = Address of string descriptor
; [DX]	 = Length requested
; [CX]	 = Starting offset
;
;Exit:
; [AX]	 = new descriptor
;
;Uses:
; CX   - only for special RIGHT$ case
;
;Preserves: (optional)
;
;Exceptions:
;
;******************************************************************************
cProc	LEFRIG,NEAR
cBegin

	OR	DX,DX		;Test requested length
	JL	ARGERR		;If negative, give error
	JNZ	LEFRIG_10	;If zero, return null string
	CALL	B$STDALCTMP	;ensure we get rid of any temps
	MOV	AX,OFFSET DGROUP:b$nuldes 
	RET
LEFRIG_10:
	CMP	DX,[BX] 	;See if requested length is shorter than string
	JLE	MAKTMP		;  Yes - create temp string
	MOV	DX,[BX] 	;  No - use actual string length
	OR	CX,CX		;If offset is negative from RIGHT$
	JGE	MAKTMP		;  No - OK
	XOR	CX,CX		;  Yes - just make it zero
MAKTMP:
	CALL	B$STALCTMPSUB	;Create temp from string descriptor
	XCHG	AX,BX		; [AX] = new descriptor
cEnd				


	SUBTTL	B$SPAC - SPACE$ function
	PAGE
;***
;B$SPAC - SPACE$ function
;sd * pascal B$SPAC(I2 cbDesired)
;
;Function:
; Produce temporary string with a blank (' ') character repeated BX times.
;
;Inputs:
; cbDesired = Length of string desired
;
;Outputs:
; [AX]	= Address of result temp string descriptor
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$SPAC,<FAR,PUBLIC>	
parmW	cbDesired		
cbegin

	MOV	DL," "		;Provide a space to be repeated
	MOV	BX,cbDesired	; [BX] = count
	CALL	STRING		; [AX] = pointer to sd

cEnd

;***
; STRING - Create a temp string of length n containing something.
;
;Purpose:
;	Creates a temp string of n characters, where character is specified.
;	If we are compiled with KANJI enabled, DL contains the first byte
;	of the character to go into the string.  DH contains the second byte
;	unless it is 0 in which case it is a single byte character.
;
;Entry:
; [DL]	= Character (DX for kanji)
; [BX]	= desired length
;
;Exit:
; [AX]	= pointer to temp sd
;
;Uses:
; Per convention
;
;******************************************************************************
cProc	STRING,NEAR,ES
cBegin
	MOV	AX,OFFSET DGROUP:b$nuldes ;[7]
	OR	BX,BX		;Check character count
	JZ	STRING_90	; Return null string if zero
	JL	ARGERR		;Error if negative


NOTKAN: MOV	CX,BX		;Put count in count register
	MOV	AL,DL		;Character to copy
	MOV	AH,DL		;Repeat it by words for speed
	CALL	B$STALCTMP	;Allocate string
	INC	CX		;Round up to whole word if odd
ISKAN:	XCHG	DI,DX		;Get address of data in destination register
	SHR	CX,1		;Divide byte count by 2 for word move
	PUSH	DS		
	POP	ES		; [ES] = [DS]
	REP	STOSW
	MOV	DI,DX		;Restore DI
	XCHG	AX,BX		;[AX] has string desc
STRING_90:
cEnd

ARGERR: JMP	B$ERR_FC	  ;Clean stack and report illegal function call

	SUBTTL	B$STRI & B$STRS - STRIN& functions
	PAGE
;***
;B$STRI & B$STRS - STRING$ functions
;sd * pascal B$STRI(I2 cbdesired, I2 ascCode)
;sd * pascal B$STRS(I2 cbDesired, sd *psdChar)
;
;Function:
; Produce temporary string with a single character repeated BX times. B$STRI
; provides the character to be repeated, and B$STRS provides a string
; descriptor, the first character of which is to be repeated.
;
;Inputs:
; cbDesired = Length of string desired
; ascCode   = Character to repeat (B$STRI only)
; psdChar   = Descriptor of string with character to repeat (B$STRS only)
;
;Outputs:
; [AX]	= Address of result temp string descriptor
;
;Registers:
; Per convention
;
;******************************************************************************
cProc	B$STRI,<FAR,PUBLIC>	
parmW	cbDesired		
parmW	ascCode 		
cBegin

	MOV	DX,ascCode	
	JMP	SHORT STRI_10	
cEnd	nogen

cProc	B$STRS,<FAR,PUBLIC>	
parmW	cbDesired		
parmW	psdChar 		
cBegin

	MOV	BX,psdChar	; Put descriptor where we can address with it
	CMP	WORD PTR[BX],0	;Length of string must not be zero
	JZ	ARGERR
	PUSH	BX		
	MOV	BX,[BX+2]	;Get address of string data
	POP	AX		; [AX] = pointer to descriptor

	PUSH	[BX]		; Push first character in string
	XCHG	AX,BX		; [BX] = pointer to descriptor
	CALL	B$STDALCTMP	;Delete if temp string
	POP	DX		; [DX] = character
STRI_10:			
	MOV	BX,cbDesired	; [BX] = length to do it
	CALL	STRING		; [AX] = pointer to sd
cEnd

	SUBTTL	B$VARP - VARPTR$ function
	PAGE

;***
;B$VARP - VARPTR$ function
;sd * pascal B$VARP(U2 addr, I2 type)
;
;Function:
; Create a 3 byte string of following:
;	Byte 1		contains variable type, one of:
;		2 - Integer
;		3 - String
;		4 - Single
;		8 - Double
;	       14h- Long
;	Byte 2 & 3	contain the address of the variable
;
;Inputs:
; addr	= Address of Variable
; typ	= type of the variable
;
;Outputs:
; [AX]	= Address of String Descriptor
;
;Registers:
; Per convention
;******************************************************************************
cProc	B$VARP,<FAR,PUBLIC>	
parmW	addr			
parmW	typ			
cBegin				
	MOV	BX,3
	CALL	B$STALCTMP	;Get a 3 byte string
	XCHG	BX,DX		;[BX] has its address
	MOV	AX,typ		
	MOV	[BX],AL 	
	MOV	AX,addr 	
	MOV	[BX+1],AX	
	XCHG	AX,DX		; [AX]= String Descriptor

cEnd



	SUBTTL	B$LCAS/B$UCAS - convert string to lower/upper case
	PAGE
;***
; B$UCAS - Convert string to upper case
; B$LCAS - Convert string to lower case
;
;Purpose:
; String case conversion.
;
;Entry:
; psd	= Pointer to string descriptor to be converted
;
;Exit:
; [AX]	= Pointer to string descriptor of result
;
;Uses:
; Per convention
;
;******************************************************************************
cProc	B$UCAS,<FAR,PUBLIC>
cBegin
	MOV	AX,'za'
	JMP	SHORT	CASE_5	;go perform case conversion
cEnd	nogen

cProc	B$LCAS,<FAR,PUBLIC>
cBegin
	MOV	AX,'ZA'
cEnd	nogen			

cProc	CASE_5,FAR,<DI,SI,ES>	
parmW	psd			
cBegin				

	MOV	BX,psd		;get string descriptor
	MOV	DX,[BX] 	;(DX) = length of string to convert
	OR	DX,DX		;is this a null string ?
	JZ	uca_ret 	;yes, just return it
	XOR	CX,CX
	CALL	B$STALCTMPSUB	;no, copy string to temporary
	PUSH	BX
	XCHG	CX,DX		;(CX) = length of string to convert
	MOV	SI,[BX+2]	;(SI) = ptr to string data
	MOV	DI,SI		;ditto for DI
	XCHG	AX,BX		;(BX) = chars to check
	PUSH	DS		; set ES=DS
	POP	ES
uca_loop:
	LODSB			;fetch next char from string
	CMP	AL,BL
	JB	uca_cont	;ignore if not wrong case
	CMP	AL,BH
	JA	uca_cont	;ignore if not wrong case
	XOR	AL,20H		;flip upper case bit
uca_cont:
	STOSB			;put character back
	LOOP	uca_loop	;repeat until entire string is checked
uca_abort:
	POP	BX		;restore descriptor address
uca_ret:
	XCHG	AX,BX		;return sd in AX

cEnd

	SUBTTL	$TRL/$TRM/$TRR - Trim blanks off string
	PAGE
;***
; B$TRIM, B$LTRM, B$RTRM - Trim family
;
;Purpose:
; Trim leading, trailing or both blanks from a string.
;
;Entry:
; psd	= Pointer to string descriptor to be converted
;
;Exit:
; [AX]	= Pointer to string descriptor of result
;
;Uses:
; Per convention
;
;******************************************************************************
TR_LEFT= 1
TR_RIGHT= 2

; cProc	B$TRIM,<PUBLIC,FAR>
; cBegin
; 	MOV	AH,TR_LEFT+TR_RIGHT
; 	SKIP	2		; fall into TRIM
; cEnd	nogen

cProc	B$LTRM,<PUBLIC,FAR>
cBegin				
	MOV	AH,TR_LEFT
	SKIP	2		; fall into TRIM
cEnd	nogen

cProc	B$RTRM,<PUBLIC,FAR>
cBegin				
	MOV	AH,TR_RIGHT
cEnd	nogen			; fall into TRIM

cProc	TRIM,FAR,<DI,ES>	
parmW	psd			
cBegin				

;When scanning for a blank character, we know that we will never take
;any part of a KANJI character as a space, as this value is illegal in
;a KANJI.

	PUSH	DS		; set es=ds
	POP	ES		
	MOV	BX,psd		;Get source SD
	MOV	CX,[BX] 	; get string length
	JCXZ	trim_ret	;   null string - return
	MOV	DI,[BX+2]	; (DI) = address of string contents
	MOV	AL,' '		; AL = blank - trim char
	TEST	AH,TR_LEFT	; trim left blanks?
	JZ	trim_right	;   no - trim right
trim_left:			
	REPE	SCASB		; scan blanks off front
	JZ	trim_done	;   all blanks

	INC	CX		; backup one character
	DEC	DI

trim_right:
	MOV	DX,DI		; (DX) = 1st nonblank address
	SUB	DX,[BX+2]	; (DX) = offset of 1st nonblank
	TEST	AH,TR_RIGHT	; trim right blanks?
	JZ	trim_done	;   no - done
	ADD	DI,CX
	DEC	DI		; (DI) = last char in string
re_trim_right:
	STD			; direction is down
	REPE	SCASB		; scan blanks off back
	CLD			; direction is up
	JZ	trim_done	;   all blanks
	INC	CX		; backup one character

trim_done:
	XCHG	CX,DX		; CX=offset , DX=length , BX=sdesc
	CALL	B$STALCTMPSUB	; copy into temp string

trim_ret:
	XCHG	AX,BX		;Return sd in AX
cEnd

sEnd	ST_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\tabspc.asm ===
TITLE	TABSPC - TAB and SPC functions
;***
; TABSPC - TAB and SPC functions
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
	INCLUDE switch.inc	
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	_BSS		
	USESEG	DV_TEXT 	
	USESEG	_DATA		

	INCLUDE seg.inc 	
	INCLUDE idmac.inc	

sBegin	_BSS			

	externW b$VECS		

VPOS	EQU	b$VECS+2*0	
VWID	EQU	b$VECS+2*1	
VWCLF	EQU	b$VECS+2*2	

sEnd	_BSS			

assumes CS,DV_TEXT		
sBegin	DV_TEXT 		

	externNP B$OutBlanks	
;***
;B$FSPC - SPC function
;
;Purpose:
;	Runtime Entry Point.
;	Convert negative numbers to zero, then modulo it with line width.
;	Then print that many spaces.
;Entry:
;	cSpaces = number of spaces
;Exit:
;	None.
;Uses:
;	Per convention.
;Exceptions:
;	None.
;****
cProc	B$FSPC,<PUBLIC,FAR>	

parmW	cSpaces 		
cBegin				
	MOV	AX,cSpaces	
	CALL	RNGCHK		;[CL]=cSpaces to print
OUTSPC:
	XOR	CH,CH		
	CALL	B$OutBlanks	; output CX blanks
cEnd				

;***
;B$FTAB - TAB function of PRINT statement
;
;Purpose:
;	Runtime Entry Point.
;	Convert arg<1 to 1, then modulo with line length.  Tab to position,
;	send CR/LF if already beyond position.
;Entry:
;	TabPos = position to tab to (1 is first)
;Exit:
;	None.
;Uses:
;	Per convention.
;Exceptions:
;	None.
;****
cProc	B$FTAB,<PUBLIC,FAR>	
parmW	TabPos			
cBegin				
	MOV	AX,TabPos	
	DEC	AX
	CALL	RNGCHK		;[CL]=new pos, [CH] = current pos
	CMP	CL,CH		;Check against current position
	JAE	FIGSPC
	CALL	[VWCLF] 	; Output CR/LF if too far
	XOR	CH,CH
FIGSPC:
	SUB	CL,CH		;Number of spaces needed
	JMP	SHORT OUTSPC	
cEnd	<nogen> 		


;***
;RNGCHK - computes new position MOD line width.
;
;Purpose:
;	Converts negative numbers to Zero and computes requested
;	position MOD current line width.
;Entry:
;	AX - requested position
;Exit:
;	CH - current position
;	CL - requested position MOD line width
;Uses:
;	Per convention
;Exceptions:
;	None.
;****
cProc	RNGCHK,<NEAR>		
cBegin				
	CWD			;sign extend AX into DX
	NOT	DX		;DX = 0 if AX was negative
	AND	AX,DX		;Make negative numbers zero
	XCHG	AX,BX
	CALL	[VWID]
	XCHG	AL,AH
	MOV	AH,0
	DbAssertRelB al,ne,0,DV_TEXT,<RNGCHK:WIDTH=0> 
	XCHG	AX,BX		;(BX) = width
	XOR	DX,DX
	DIV	BX
	CALL	[VPOS]		; (AH) = position
	MOV	AL,DL		;DIV remainder is <arg> MOD <width>
	XCHG	AX,CX		;(AX) = now has original (CX)
cEnd				

sEnd	DV_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\vwclr.asm ===
TITLE	VWCLR - IAPX 88/86 CLEAR GRAPHICS VIEWPORT SUPPORT
;***
; VWCLR - IAPX 88/86 CLEAR GRAPHICS VIEWPORT SUPPORT
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
	INCLUDE switch.inc	;Rutime switch file
	INCLUDE rmacros.inc	; General runtime macros

	useSeg	_DATA		
	useSeg	_BSS		
	useSeg	GR_TEXT 	

	INCLUDE seg.inc 	

sBegin	_DATA			

	externB b$ScreenMode	; defined in LLCGRP.ASM
	externW B$GXPOS
	externW B$GYPOS
	externW B$VXMIN
	externW B$VXMAX
	externW B$VYMIN
	externW B$VYMAX
	externW B$LINSTL

sEnd	_DATA			

sBegin	_BSS			
;
;============================================================================
; External low-level function vectors
;============================================================================
;
externW b$SetAttr		
externW b$MapXYC		
externW b$NSetC 		
externW b$DownC 		
;============================================================================

	externW B$GXHPOS	;defined in GWDATA.ASM
	externW B$GXLPOS	;defined in GWDATA.ASM
	externW B$GYHPOS	;defined in GWDATA.ASM
	externW B$GYLPOS	;defined in GWDATA.ASM
sEnd	_BSS			

sBegin	GR_TEXT 		
assumes CS,GR_TEXT		

	externNP B$ERR_FC	


	externNP B$GRMODE		


	externNP B$VWMAPC

	externNP B$GETFBC

cProc	B$VWCLR,<PUBLIC,NEAR>
cBegin
	cCall	B$GRMODE	
	JZ	NO_VWCLR	;if not, just return
	PUSH	BX		;Save text pointer
	STC			;Flag to get graphics colors
	CALL	B$GETFBC 	;Get forground/background colors
	PUSH	AX		;Save current colors
	MOV	AL,BL		;Default Fill is Background
	CALL	B$VWFILL
	POP	AX		;Restore original colors
	CALL	[b$SetAttr]	
	POP	BX		;Retrieve text pointer
NO_VWCLR:
cEnd

cProc	B$VWFILL,<PUBLIC,NEAR>
cBegin
	CALL	[b$SetAttr]	;Set fill attr

	JNB	VWFIL0		;ERROR IF ILLEGAL ATTRIBUTE
	JMP	B$ERR_FC	; Function call error
VWFIL0:
	MOV	AX,WORD PTR B$VXMAX
	MOV	WORD PTR B$GXPOS,AX ;vx2
	MOV	AX,WORD PTR B$VYMAX
	MOV	WORD PTR B$GYPOS,AX ;vy2
	MOV	CX,WORD PTR B$VXMIN ;[CX]= vx1
	MOV	DX,WORD PTR B$VYMIN ;[DX]= vy1
	CALL	B$DOBOXF 	;Box Fill..
	JMP	B$VWMAPC 	;Set view "C"'s and GAC
cEnd	<nogen>

cProc	B$DOBOXF,<PUBLIC,NEAR>
cBegin				;ENTRY FOR CALL FROM VWFIL0 IN ADVG86

	CALL	BOXTST
	JB	B$LINEXT	;Brif box out of view

	CALL	B$SCALXY 	;SCALE FIRST POINT
	XCHG	CX,[B$GXPOS]	;ensure CX = MIN(X1,X2)
	XCHG	DX,[B$GYPOS]	;ensure DX = MIN(Y1,Y2)
				;CALL	 $XCHGAC		  ;SWITCH POINTS
	CALL	B$SCALXY 	;SCALE SECOND POINT


	CALL	B$YDELT		;SEE HOW MANY LINES AND SET CARRY
	JNB	DOBOX1
	XCHG	DX,[B$GYPOS]	;ensure DX = MIN(Y1,Y2)
DOBOX1:
	INC	BX		;MAKE [BX] INTO A COUNT
	push	bp		;save bp across MapXYC call
	PUSH	BX		;SAVE COUNT OF LINES
	CALL	B$XDELT		;GET WIDTH AND SMALLEST X
	JNB	DOBOX2
	XCHG	CX,[B$GXPOS]	;ensure CX = MIN(X1,X2)
DOBOX2:
	INC	BX		;MAKE [BX] INTO A WIDTH COUNT
	PUSH	BX		;SAVE WIDTH COUNT
	CALL	[b$MapXYC]	;MAP INTO A "C"
	POP	BX		;GET WIDTH COUNT
	POP	CX		;GET LINE COUNT

BOXLOP:
	PUSH	CX		;[speed]
	PUSH	BX		;[speed]
	CALL	[b$NSetC]	;IN [BX] ORF POINTS TO $SETC
	CALL	[b$DownC]	;MOVE TO NEXT LINE DOWN IN Y
	POP	BX		;[speed]
	POP	CX		;GET BACK NUMBER OF LINES
	LOOP	BOXLOP		;[speed] COUNT DOWN LINES
				;KEEP DRAWING MORE LINES

	pop	bp		;[speed]

labelNP <PUBLIC,B$LINEXT>	;EXIT LINE STATEMENT
	MOV	WORD PTR B$LINSTL,-1 ;RESTORE LINE STYLE TO SOLID
cEnd


cProc	BOXTST,<NEAR>,<DX>
cBegin
	MOV	AX,WORD PTR B$GXPOS
	MOV	DX,CX
	CMP	AX,DX
	JGE	BOXTS1
	XCHG	AX,DX
BOXTS1:
	MOV	WORD PTR B$GXHPOS,AX
	MOV	WORD PTR B$GXLPOS,DX
	POP	DX
	PUSH	DX
	MOV	AX,WORD PTR B$GYPOS
	CMP	AX,DX
	JGE	BOXTS2
	XCHG	AX,DX
BOXTS2:
	MOV	WORD PTR B$GYHPOS,AX
	MOV	WORD PTR B$GYLPOS,DX
	CALL	BOXCLP
cEnd

cProc	BOXCLP,<NEAR>
cBegin
	MOV	AX,WORD PTR B$GXHPOS
	CMP	AX,WORD PTR B$VXMIN ;Is Xmax .LT. B$VXMIN?
	JL	BOXCLX		;Yes: exit with carry set since fill won't show
	MOV	AX,WORD PTR B$VXMAX
	CMP	AX,WORD PTR B$GXLPOS
	JL	BOXCLX		
	MOV	AX,WORD PTR B$GYHPOS
	CMP	AX,WORD PTR B$VYMIN
	JL	BOXCLX		
	MOV	AX,WORD PTR B$VYMAX
	CMP	AX,WORD PTR B$GYLPOS
	JL	BOXCLX		
	CLC			;Clear carry if any fill will show
BOXCLX:
cEnd

cProc	B$CLIPCK,<PUBLIC,NEAR>
cBegin
	XOR	AL,AL		;Clear view bits
	CMP	WORD PTR B$VXMIN,CX ;B$VXMIN .lt. coord?
	JLE	CLIPC2		;Yes, in view
	INC	AX		;Set D0 if out of view left
CLIPC2:
	CMP	WORD PTR B$VXMAX,CX ;B$VXMAX .gt. coord?
	JGE	CLIPC3		;Yes, in view
	OR	AL,BYTE PTR 2	;Set D1 if out of view right
CLIPC3: 			;See if y is in view
	CMP	WORD PTR B$VYMIN,DX ;B$VYMIN .lt. coord?
	JLE	CLIPC4		;Yes, in view
	OR	AL,4		;Set D2 if out of view top
CLIPC4:
	CMP	WORD PTR B$VYMAX,DX ;B$VYMAX .gt. coord?
	JGE	CLIPCX		;Yes, in view
	OR	AL,8		;Set D3 if out of view bottom
CLIPCX:
cEnd				;return view status in [AL]

;***
;
;B$SCALXY		 Force (x,y) coordinates within viewport boundaries
;
;Purpose:
;	  Test the (x,y) coordinates in (CX,DX) against the current viewport
;	  boundaries.  If either coordinate is outside the viewport, replace it
;	  with the nearest viewport boundary value (B$VXMIN or B$VXMAX for X,
;	  B$VYMIN or B$VYMAX for Y).  The carry flag is cleared if either
;	  coordinate was outside the viewport boundary.
;
;Entry:
;	  CX=x coordinate DX=y coordinate
;
;Exit:
;	CX=updated x, DX=updated y
;	carry set if no coords changed, clear if either coord changed
;
;Modifies: AX,BX
;
;****
cProc	B$SCALXY,<PUBLIC,NEAR>
cBegin
	CMP	b$ScreenMode,0	; graphics mode?
	JNZ	SCALX0		;Brif Graphics mode
	JMP	B$ERR_FC	; else Illegal
SCALX0:
	CALL	B$CLIPCK 	;[AL] non-zero if x or y out of bounds
	OR	AL,AL		;check for no clipping
	JZ	NOSCAL		;no clipping required
	MOV	BX,WORD PTR B$VXMIN
	TEST	AL,BYTE PTR 1
	JNZ	SCALX1		;Brif x is less than min
	MOV	BX,WORD PTR B$VXMAX
	TEST	AL,BYTE PTR 2
	JZ	SCALY0		;Brif x is within min/max
SCALX1:
	MOV	CX,BX		;Return min or max x
SCALY0:
	LAHF			;[AH]=flags
	MOV	BX,WORD PTR B$VYMIN
	TEST	AL,BYTE PTR 4
	JNZ	SCALY1		;Brif y is less than min
	MOV	BX,WORD PTR B$VYMAX
	TEST	AL,BYTE PTR 8
	JZ	SCALY2		;Brif y is within min/max
SCALY1:
	LAHF			;[AH]=flags
	MOV	DX,BX		;Return min or max y
SCALY2:
	SAHF			;Update flags
NOSCAL: 			;no clipping required
	STC
	JZ	SCALY3
	CMC			;Return no-carry if out of bounds
SCALY3:
cEnd


	PAGE
	SUBTTL	UTILITY ROUTINES FOR LINE CODE

;
; B$XDELT SETS [BX]=ABS(B$GXPOS-[CX]) AND SETS CARRY IF [CX].GT.B$GXPOS
; NOTE: [BX] WILL BE A DELTA BETWEEN B$GXPOS AND [CX] - ADD 1 FOR AN X "COUNT"
;
cProc	B$XDELT,<PUBLIC,NEAR>
cBegin
	MOV	BX,WORD PTR B$GXPOS ;GET ACCUMULATOR POSITION
	SUB	BX,CX
CNEGHL:
	JNB	CNEGHX		;IF NO CARRY, NO NEED TO NEGATE COUNT
	NEG	BX
CNEGHX:
cEnd

; B$YDELT SETS [BX]=ABS(B$GYPOS-[DX]) AND SETS CARRY IF [DX].GT.B$GYPOS
;

cProc	B$YDELT,<PUBLIC,NEAR>
cBegin
	MOV	BX,WORD PTR B$GYPOS
	SUB	BX,DX
	JMP	SHORT CNEGHL
cEnd	<nogen>

sEnd	GR_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\width.asm ===
TITLE	WIDTH - WIDTH "device" Statement
;***
; WIDTH - WIDTH "device" Statement
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - WIDTH Statement:
;
;    Four different Syntax possibilities map to four runtime entry points:
;
;      WIDTH size			 WIDTH LPRINT size
;	 |				   |
;      B$WIDT				 B$LWID
;
;
;      WIDTH filenumber, size		 WIDTH device, size
;	 |				   |
;      B$DWID				 B$DWID
;
;******************************************************************************
	include switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	DV_TEXT 	
	USESEG	_DATA

	INCLUDE seg.inc 	
	include baslibma.inc
	include devdef.inc
	include files.inc
	include string.inc	

assumes CS,DV_TEXT		
sBegin	DV_TEXT 		

	externNP B$GET_DEV_NUM	
	externNP B$STDALCTMP
	externNP B$DevDispatch	
	externNP B$ERR_FC	

	PAGE


;***
; B$DWID - WIDTH "device" Statement
;
; Purpose:
;
; Entry:
;	sdDevName  = device name string
;	newWidth   = width
; Exit:
;	None
; Modifies:
;	Per convention
; Exceptions:
;	B$ERR_BFN -- for bad device name
;**************************************************
cProc	B$DWID,<PUBLIC,FAR>	
parmSD	sdDevName		
parmW	newWidth		
cBegin				
	GetpSD	BX,sdDevName	
	CALL	B$GET_DEV_NUM	; (AL) = device number, NZ if valid device
				; DISK_DWID gives "illegal function call"
wdd1:
	CALL	B$STDALCTMP	;Delete if temporary string

	MOV	AH,DV_DWID	; device width function
	MOV	DX,newWidth	
	or	dh,dh		; if width > 255 then error
	jnz	ercfc		; and
	or	dl,dl		; if width = 0 then error
	jz	ercfc		

	CALL	B$DevDispatch	; dispatch to the device width set routine
cEnd				

ercfc:	JMP	B$ERR_FC

sEnd	DV_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\assert.h ===
/***
*assert.h - define the assert macro
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines the assert(exp) macro.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef _ASSERT_DEFINED

#ifndef NDEBUG

static char _assertstring[] = "Assertion failed: %s, file %s, line %d\n";

#define assert(exp) { \
    if (!(exp)) { \
        fprintf(stderr, _assertstring, #exp, __FILE__, __LINE__); \
        fflush(stderr); \
        abort(); \
        } \
    }

#else

#define assert(exp)

#endif /* NDEBUG */

#define _ASSERT_DEFINED

#endif /* _ASSERT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\bse.h ===
/****************************** Module Header ******************************\
*
* Module Name: BSE.H
*
* This file includes the definitions necessary for writing Base OS/2 applications.
*
* This file is compatible with OS/2 version 1.0.
*
* Copyright (c) 1988  Microsoft Corporation
* Copyright (c) 1988  IBM Corporation
*
* ===========================================================================
*
* The following symbols are used in this file for conditional sections.
*
*   INCL_BASE      -  ALL of OS/2 Base
*   INCL_DOS       -  OS/2 DOS Kernel
*   INCL_SUB       -  OS/2 VIO/KBD/MOU
*   INCL_DOSERRORS -  OS/2 Errors       - only included if symbol defined
*
\***************************************************************************/

#define INCL_BASEINCLUDED

/* if INCL_BASE defined then define all the symbols */
#ifdef INCL_BASE
    #define INCL_DOS
    #define INCL_SUB
    #define INCL_DOSERRORS
#endif /* INCL_BASE */

#include <bsedos.h>       /* Base definitions */
#include <bsesub.h>       /* VIO/KBD/MOU definitions */
#include <bseerr.h>       /* Base error code definitions */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\bsedos.h ===
/***************************************************************************\
*
* Module Name: BSEDOS.H
*
* OS/2 Base Include File
*
* This file is compatible with OS/2 version 1.0.
*
* Copyright (c) 1988  Microsoft Corporation
*
*****************************************************************************
*
* Subcomponents marked with "+" are partially included by default
*
*   #define:                To include:
*
* + INCL_DOSPROCESS         Process and thread support
*   INCL_DOSINFOSEG         InfoSeg support
* + INCL_DOSFILEMGR         File Management
* + INCL_DOSMEMMGR          Memory Management
* + INCL_DOSSEMAPHORES      Semaphore support
* + INCL_DOSDATETIME        Date/Time and Timer support
*   INCL_DOSMODULEMGR       Module manager
* + INCL_DOSRESOURCES       Resource support
*   INCL_DOSNLS             National Language Support
*   INCL_DOSMISC            Miscellaneous
*   INCL_DOSSIGNALS         Signals
*   INCL_DOSMONITORS        Monitors
*   INCL_DOSQUEUES          Queues
*   INCL_DOSSESMGR          Session Manager Support
*
\***************************************************************************/

#define INCL_DOSINCLUDED

#ifdef INCL_DOS

#define INCL_DOSPROCESS
#define INCL_DOSINFOSEG
#define INCL_DOSFILEMGR
#define INCL_DOSMEMMGR
#define INCL_DOSMISC
#define INCL_DOSSEMAPHORES
#define INCL_DOSDATETIME
#define INCL_DOSMODULEMGR
#define INCL_DOSRESOURCES
#define INCL_DOSNLS
#define INCL_DOSSIGNALS
#define INCL_DOSMONITORS
#define INCL_DOSQUEUES
#define INCL_DOSSESMGR

#endif /* INCL_DOS */

#ifdef INCL_ERRORS
#define INCL_DOSERRORS
#endif /* INCL_ERRORS */

#if (defined(INCL_DOSPROCESS) | !defined(INCL_NOCOMMON))

/*** General services */

USHORT APIENTRY DosBeep(USHORT, USHORT);

/*** Process and Thread support */

VOID APIENTRY DosExit(USHORT, USHORT);

/* DosExit codes */

#define EXIT_THREAD         0
#define EXIT_PROCESS        1

#endif /* common INCL_DOSPROCESS stuff */

#ifdef INCL_DOSPROCESS

typedef struct _PIDINFO {         /* pidi */
    PID pid;
    TID tid;
    PID pidParent;
} PIDINFO;
typedef PIDINFO FAR *PPIDINFO;

USHORT APIENTRY DosCreateThread(VOID (FAR *)(VOID), PTID, PBYTE);
USHORT APIENTRY DosResumeThread(TID);
USHORT APIENTRY DosSuspendThread(TID);

/* Action code values */

#define DCWA_PROCESS        0
#define DCWA_PROCESSTREE    1

/* Wait option values */

#define DCWW_WAIT   0
#define DCWW_NOWAIT 1

typedef struct _RESULTCODES {     /* resc */
    USHORT codeTerminate;
    USHORT codeResult;
} RESULTCODES;
typedef RESULTCODES FAR *PRESULTCODES;

USHORT APIENTRY DosCWait(USHORT, USHORT, PRESULTCODES, PPID, PID);
USHORT APIENTRY DosSleep(ULONG);

/* codeTerminate values (also passed to ExitList routines) */

#define TC_EXIT          0
#define TC_HARDERROR     1
#define TC_TRAP          2
#define TC_KILLPROCESS   3

VOID   APIENTRY DosEnterCritSec(VOID);
VOID   APIENTRY DosExitCritSec(VOID);
USHORT APIENTRY DosExitList(USHORT, VOID (FAR *)(USHORT));

/* DosExitList functions */

#define EXLST_ADD       1
#define EXLST_REMOVE    2
#define EXLST_EXIT      3

USHORT APIENTRY DosExecPgm(PCHAR, USHORT, USHORT, PSZ, PSZ, PRESULTCODES, PSZ);

/* DosExecPgm functions */

#define EXEC_SYNC           0
#define EXEC_ASYNC          1
#define EXEC_ASYNCRESULT    2
#define EXEC_TRACE          3
#define EXEC_BACKGROUND     4
#define EXEC_LOAD           5

USHORT APIENTRY DosGetPid(PPIDINFO);

USHORT APIENTRY DosGetPrty(USHORT, PUSHORT, USHORT);
USHORT APIENTRY DosSetPrty(USHORT, USHORT, SHORT, USHORT);

/* Priority scopes */

#define PRTYS_PROCESS       0
#define PRTYS_PROCESSTREE   1
#define PRTYS_THREAD        2

/* Priority classes */

#define PRTYC_NOCHANGE      0
#define PRTYC_IDLETIME      1
#define PRTYC_REGULAR       2
#define PRTYC_TIMECRITICAL  3

USHORT APIENTRY DosKillProcess(USHORT, PID);

#define DKP_PROCESS         0
#define DKP_PROCESSTREE     1

#endif /* INCL_DOSPROCESS */


/*** InfoSeg support */

#ifdef INCL_DOSINFOSEG

/* Global Info Seg */

typedef struct _GINFOSEG {      /* gis */
    ULONG   time;
    ULONG   msecs;
    UCHAR   hour;
    UCHAR   minutes;
    UCHAR   seconds;
    UCHAR   hundredths;
    USHORT  timezone;
    USHORT  cusecTimerInterval;
    UCHAR   day;
    UCHAR   month;
    USHORT  year;
    UCHAR   weekday;
    UCHAR   uchMajorVersion;
    UCHAR   uchMinorVersion;
    UCHAR   chRevisionLetter;
    UCHAR   sgCurrent;
    UCHAR   sgMax;
    UCHAR   cHugeShift;
    UCHAR   fProtectModeOnly;
    USHORT  pidForeground;
    UCHAR   fDynamicSched;
    UCHAR   csecMaxWait;
    USHORT  cmsecMinSlice;
    USHORT  cmsecMaxSlice;
    USHORT  bootdrive;
    UCHAR   amecRAS[32];
} GINFOSEG;
typedef GINFOSEG FAR *PGINFOSEG;

/* Local Info Seg */

typedef struct _LINFOSEG {      /* lis */
    PID     pidCurrent;
    PID     pidParent;
    USHORT  prtyCurrent;
    TID     tidCurrent;
    USHORT  sgCurrent;
    USHORT  sgSub;
    BOOL    fForeground;
} LINFOSEG;
typedef LINFOSEG FAR *PLINFOSEG;

/* Process Type codes (local info seg typeProcess field) */

#define PT_FULLSCREEN       0
#define PT_REALMODE         1
#define PT_WINDOWABLEVIO    2
#define PT_PM               3
#define PT_DETACHED         4

USHORT APIENTRY DosGetInfoSeg(PSEL, PSEL);

/* Helper macros used to convert selector to PINFOSEG or LINFOSEG */

#define MAKEPGINFOSEG(sel)  ((PGINFOSEG)MAKEP(sel, 0))
#define MAKEPLINFOSEG(sel)  ((PLINFOSEG)MAKEP(sel, 0))

#endif /* INCL_DOSINFOSEG */

#if (defined(INCL_DOSFILEMGR) | !defined(INCL_NOCOMMON))

/*** File manager */

USHORT APIENTRY DosOpen(PSZ, PHFILE, PUSHORT, ULONG, USHORT, USHORT, USHORT, ULONG);
USHORT APIENTRY DosClose(HFILE);
USHORT APIENTRY DosRead(HFILE, PVOID, USHORT, PUSHORT);
USHORT APIENTRY DosWrite(HFILE, PVOID, USHORT, PUSHORT);

/* File time and date types */

typedef struct _FILESTATUS {    /* fsts */
    FDATE  fdateCreation;
    FTIME  ftimeCreation;
    FDATE  fdateLastAccess;
    FTIME  ftimeLastAccess;
    FDATE  fdateLastWrite;
    FTIME  ftimeLastWrite;
    ULONG  cbFile;
    ULONG  cbFileAlloc;
    USHORT attrFile;
} FILESTATUS;
typedef FILESTATUS FAR *PFILESTATUS;

typedef struct _FSALLOCATE {    /* fsalloc */
    ULONG  idFileSystem;
    ULONG  cSectorUnit;
    ULONG  cUnit;
    ULONG  cUnitAvail;
    USHORT cbSector;
} FSALLOCATE;
typedef FSALLOCATE FAR *PFSALLOCATE;

typedef SHANDLE HDIR;        /* hdir */
typedef HDIR FAR *PHDIR;

USHORT APIENTRY DosDelete(PSZ, ULONG);
USHORT APIENTRY DosDupHandle(HFILE, PHFILE);

USHORT APIENTRY DosQFHandState(HFILE, PUSHORT);
USHORT APIENTRY DosSetFHandState(HFILE, USHORT);
USHORT APIENTRY DosQHandType(HFILE, PUSHORT, PUSHORT);

USHORT APIENTRY DosReadAsync (HFILE, PULONG, PUSHORT, PVOID, USHORT, PUSHORT);
USHORT APIENTRY DosWriteAsync(HFILE, PULONG, PUSHORT, PVOID, USHORT, PUSHORT);

USHORT APIENTRY DosFindFirst(PSZ, PHDIR, USHORT, PFILEFINDBUF, USHORT, PUSHORT, ULONG);
USHORT APIENTRY DosFindNext(HDIR, PFILEFINDBUF, USHORT, PUSHORT);
USHORT APIENTRY DosFindClose(HDIR);

USHORT APIENTRY DosNewSize(HFILE, ULONG);
USHORT APIENTRY DosBufReset(HFILE);

USHORT APIENTRY DosChgFilePtr(HFILE, LONG, USHORT, PULONG);

USHORT APIENTRY DosFileLocks(HFILE, PLONG, PLONG);

USHORT APIENTRY DosMove(PSZ, PSZ, ULONG);
USHORT APIENTRY DosMkdir(PSZ, ULONG);
USHORT APIENTRY DosRmdir(PSZ, ULONG);
USHORT APIENTRY DosSelectDisk(USHORT);
USHORT APIENTRY DosQCurDisk(PUSHORT, PULONG);

USHORT APIENTRY DosChdir(PSZ, ULONG);
USHORT APIENTRY DosQCurDir(USHORT, PBYTE, PUSHORT);

USHORT APIENTRY DosQFSInfo(USHORT, USHORT, PBYTE, USHORT);
USHORT APIENTRY DosSetFSInfo(USHORT, USHORT, PBYTE, USHORT);
USHORT APIENTRY DosQVerify(PUSHORT);
USHORT APIENTRY DosSetVerify(USHORT);
USHORT APIENTRY DosSetMaxFH(USHORT);

USHORT APIENTRY DosQFileInfo(HFILE, USHORT, PFILESTATUS, USHORT);
USHORT APIENTRY DosSetFileInfo(HFILE, USHORT, PFILESTATUS, USHORT);

USHORT APIENTRY DosQFileMode(PSZ, PUSHORT, ULONG);
USHORT APIENTRY DosSetFileMode(PSZ, USHORT, ULONG);

#endif /* common INCL_DOSFILEMGR */

#if (defined(INCL_DOSMEMMGR) | !defined(INCL_NOCOMMON))
/*** Memory management */

USHORT APIENTRY DosAllocSeg(USHORT, PSEL, USHORT);
USHORT APIENTRY DosReallocSeg(USHORT, SEL);
USHORT APIENTRY DosFreeSeg(SEL);
USHORT APIENTRY DosGiveSeg(SEL, PID, PSEL);
USHORT APIENTRY DosGetSeg(SEL);

/* Segment attribute flags (used with DosAllocSeg) */

#define SEG_GIVEABLE        0x0001
#define SEG_GETTABLE        0x0002
#define SEG_DISCARDABLE     0x0004

#endif /* common INCL_DOSMEMMGR */

#ifdef INCL_DOSMEMMGR

USHORT APIENTRY DosAllocHuge(USHORT, USHORT, PSEL, USHORT, USHORT);
USHORT APIENTRY DosReallocHuge(USHORT, USHORT, SEL);
USHORT APIENTRY DosGetHugeShift(PUSHORT);

USHORT APIENTRY DosAllocShrSeg(USHORT, PSZ, PSEL);

USHORT APIENTRY DosLockSeg(SEL);
USHORT APIENTRY DosUnlockSeg(SEL);

USHORT APIENTRY DosGetShrSeg(PSZ, PSEL);

USHORT APIENTRY DosMemAvail(PULONG);
USHORT APIENTRY DosCreateCSAlias(SEL, PSEL);

USHORT APIENTRY DosSubAlloc(SEL, PUSHORT, USHORT);
USHORT APIENTRY DosSubFree(SEL, USHORT, USHORT);
USHORT APIENTRY DosSubSet(SEL, USHORT, USHORT);

#endif /* INCL_DOSMEMMGR */

#if (defined(INCL_DOSSEMAPHORES) | !defined(INCL_NOCOMMON))

/*** Semaphore support */

USHORT APIENTRY DosSemClear(HSEM);
USHORT APIENTRY DosSemSet(HSEM);
USHORT APIENTRY DosSemWait(HSEM, LONG);
USHORT APIENTRY DosSemSetWait(HSEM, LONG);
USHORT APIENTRY DosSemRequest(HSEM, LONG);

#endif /* common INCL_DOSSEMAPHORES */

#ifdef INCL_DOSSEMAPHORES

typedef LHANDLE HSYSSEM;          /* hssm */
typedef HSYSSEM FAR *PHSYSSEM;

USHORT APIENTRY DosCreateSem(USHORT, PHSYSSEM, PSZ);

#define CSEM_PRIVATE    0
#define CSEM_PUBLIC     1

USHORT APIENTRY DosOpenSem(PHSEM, PSZ);
USHORT APIENTRY DosCloseSem(HSEM);

typedef struct _MUXSEM {        /* mxs */
    USHORT zero;
    HSEM   hsem;
} MUXSEM;
typedef MUXSEM FAR *PMUXSEM;

typedef struct _MUXSEMLIST {    /* mxsl */
    USHORT  cmxs;
    MUXSEM  amxs[16];
} MUXSEMLIST;
typedef MUXSEMLIST FAR *PMUXSEMLIST;

/*
 * Since a MUXSEMLIST structure is actually a variable length
 * structure, the following macro may be used to define a MUXSEMLIST
 * structure having size elements, named "name".
 */
#define DEFINEMUXSEMLIST(name, size) \
    struct {                         \
        USHORT cmxs;                 \
        MUXSEM amxs[size];           \
    } name;

/*
 * This function actually takes a far pointer to a MUXSEMLIST structure
 * as its second parameter, but in order to allow its use with the
 * DEFINEMUXSEMLIST macro, it is declared here as PVOID.
 */
USHORT APIENTRY DosMuxSemWait(PUSHORT, PVOID, LONG);

#endif /* INCL_DOSSEMAPHORES */

#if (defined(INCL_DOSDATETIME) | !defined(INCL_NOCOMMON))

/*** Time support */

typedef struct _DATETIME {    /* date */
    UCHAR   hours;
    UCHAR   minutes;
    UCHAR   seconds;
    UCHAR   hundredths;
    UCHAR   day;
    UCHAR   month;
    USHORT  year;
    SHORT   timezone;
    UCHAR   weekday;
} DATETIME;
typedef DATETIME FAR *PDATETIME;

USHORT APIENTRY DosGetDateTime(PDATETIME);
USHORT APIENTRY DosSetDateTime(PDATETIME);

#endif /* common INCL_DOSDATETIME */

#ifdef INCL_DOSDATETIME

typedef SHANDLE HTIMER;
typedef HTIMER FAR *PHTIMER;

USHORT APIENTRY DosTimerAsync(ULONG, HSEM, PHTIMER);
USHORT APIENTRY DosTimerStart(ULONG, HSEM, PHTIMER);
USHORT APIENTRY DosTimerStop(HTIMER);

#endif /* INCL_DOSDATETIME */


/*** Module manager */

#ifdef INCL_DOSMODULEMGR

USHORT APIENTRY DosLoadModule(PSZ, USHORT, PSZ, PHMODULE);
USHORT APIENTRY DosFreeModule(HMODULE);
USHORT APIENTRY DosGetProcAddr(HMODULE, PSZ, PPFN);
USHORT APIENTRY DosGetModHandle(PSZ, PHMODULE);
USHORT APIENTRY DosGetModName(HMODULE, USHORT, PCHAR);

#endif /* INCL_DOSMODULEMGR */


/*** NLS Support */

#ifdef INCL_DOSNLS

typedef struct _COUNTRYCODE { /* ctryc */
    USHORT country;
    USHORT codepage;
} COUNTRYCODE;
typedef COUNTRYCODE FAR *PCOUNTRYCODE;

typedef struct _COUNTRYINFO { /* ctryi */
    USHORT country;
    USHORT codepage;
    USHORT fsDateFmt;
    CHAR   szCurrency[5];
    CHAR   szThousandsSeparator[2];
    CHAR   szDecimal[2];
    CHAR   szDateSeparator[2];
    CHAR   szTimeSeparator[2];
    UCHAR  fsCurrencyFmt;
    UCHAR  cDecimalPlace;
    UCHAR  fsTimeFmt;
    USHORT abReserved1[2];
    CHAR   szDataSeparator[2];
    USHORT abReserved2[5];
} COUNTRYINFO;
typedef COUNTRYINFO FAR *PCOUNTRYINFO;

USHORT APIENTRY DosGetCtryInfo(USHORT, PCOUNTRYCODE, PCOUNTRYINFO, PUSHORT);
USHORT APIENTRY DosGetDBCSEv(USHORT, PCOUNTRYCODE, PCHAR);
USHORT APIENTRY DosCaseMap(USHORT, PCOUNTRYCODE, PCHAR);
USHORT APIENTRY DosGetCollate(USHORT, PCOUNTRYCODE, PCHAR, PUSHORT);
USHORT APIENTRY DosGetCp(USHORT, PUSHORT, PUSHORT);
USHORT APIENTRY DosSetCp(USHORT, USHORT);

#endif /* INCL_DOSNLS */


/*** Signal support */

#ifdef INCL_DOSSIGNALS

/* Signal Numbers for DosSetSigHandler  */

#define SIG_CTRLC           1       /* Control C            */
#define SIG_BROKENPIPE      2       /* Broken Pipe          */
#define SIG_KILLPROCESS     3       /* Program Termination  */
#define SIG_CTRLBREAK       4       /* Control Break        */
#define SIG_PFLG_A          5       /* Process Flag A       */
#define SIG_PFLG_B          6       /* Process Flag B       */
#define SIG_PFLG_C          7       /* Process Flag C       */
#define SIG_CSIGNALS        8       /* number of signals plus one */

/* Flag Numbers for DosFlagProcess      */

#define PFLG_A              0       /* Process Flag A       */
#define PFLG_B              1       /* Process Flag B       */
#define PFLG_C              2       /* Process Flag C       */

/* Signal actions */

#define SIGA_KILL           0
#define SIGA_IGNORE         1
#define SIGA_ACCEPT         2
#define SIGA_ERROR          3
#define SIGA_ACKNOWLEDGE    4

/* DosHoldSignal constants */

#define HLDSIG_ENABLE       0
#define HLDSIG_DISABLE      1

/* DosFlagProcess codes */

#define FLGP_SUBTREE        0
#define FLGP_PID            1

typedef VOID (FAR PASCAL *PFNSIGHANDLER)(USHORT, USHORT);

USHORT APIENTRY DosSetSigHandler(PFNSIGHANDLER, PFNSIGHANDLER FAR *, PUSHORT, USHORT, USHORT);
USHORT APIENTRY DosFlagProcess(PID, USHORT, USHORT, USHORT);
USHORT APIENTRY DosHoldSignal(USHORT);
USHORT APIENTRY DosSendSignal(USHORT, USHORT);

#endif /* INCL_DOSSIGNALS */


/*** Monitor support */

#ifdef INCL_DOSMONITORS

typedef SHANDLE HMONITOR;    /* hmon */
typedef HMONITOR FAR *PHMONITOR;

USHORT APIENTRY DosMonOpen(PSZ, PHMONITOR);
USHORT APIENTRY DosMonClose(HMONITOR);
USHORT APIENTRY DosMonReg(HMONITOR, PBYTE, PBYTE, USHORT, USHORT);
USHORT APIENTRY DosMonRead(PBYTE, USHORT, PBYTE, PUSHORT);
USHORT APIENTRY DosMonWrite(PBYTE, PBYTE, USHORT);

#endif /* INCL_DOSMONITORS */


/*** Pipe and queue support */

#ifdef INCL_DOSQUEUES

typedef SHANDLE HQUEUE;  /* hq */
typedef HQUEUE FAR *PHQUEUE;

USHORT APIENTRY DosMakePipe(PHFILE, PHFILE, USHORT);
USHORT APIENTRY DosCloseQueue(HQUEUE);
USHORT APIENTRY DosCreateQueue(PHQUEUE, USHORT, PSZ);
USHORT APIENTRY DosOpenQueue(PUSHORT, PHQUEUE, PSZ);
USHORT APIENTRY DosPeekQueue(HQUEUE, PULONG, PUSHORT, PULONG, PUSHORT, USHORT, PBYTE, HSEM);
USHORT APIENTRY DosPurgeQueue(HQUEUE);
USHORT APIENTRY DosQueryQueue(HQUEUE, PUSHORT);
USHORT APIENTRY DosReadQueue(HQUEUE, PULONG, PUSHORT, PULONG, USHORT, USHORT, PBYTE, HSEM);
USHORT APIENTRY DosWriteQueue(HQUEUE, USHORT, USHORT, PBYTE, USHORT);

#endif /* INCL_DOSQUEUES */


/*** Miscellaneous functions */

#ifdef INCL_DOSMISC

USHORT APIENTRY DosError(USHORT);
USHORT APIENTRY DosSetVec(USHORT, PFN, PPFN);
USHORT APIENTRY DosGetMessage(PCHAR FAR *, USHORT, PCHAR, USHORT, USHORT, PSZ, PUSHORT);
USHORT APIENTRY DosErrClass(USHORT, PUSHORT, PUSHORT, PUSHORT);
USHORT APIENTRY DosInsMessage(PCHAR FAR *, USHORT, PSZ, USHORT, PCHAR, USHORT, PUSHORT);
USHORT APIENTRY DosPutMessage(HFILE, USHORT, PCHAR);
USHORT APIENTRY DosGetEnv(PUSHORT, PUSHORT);
USHORT APIENTRY DosScanEnv(PSZ, PSZ  FAR *);
USHORT APIENTRY DosSearchPath(USHORT, PSZ, PSZ, PBYTE, USHORT);
USHORT APIENTRY DosGetVersion(PUSHORT);
USHORT APIENTRY DosGetMachineMode(PBYTE);

#endif /* INCL_DOSMISC */


/*** Session manager support */

#ifdef INCL_DOSSESMGR

typedef struct _STARTDATA {   /* stdata */
    USHORT cb;
    USHORT Related;
    USHORT FgBg;
    USHORT TraceOpt;
    PSZ    PgmTitle;
    PSZ    PgmName;
    PBYTE  PgmInputs;
    PBYTE  TermQ;
} STARTDATA;
typedef STARTDATA FAR *PSTARTDATA;

typedef struct _STATUSDATA { /* stsdata */
    USHORT cb;
    USHORT SelectInd;
    USHORT BindInd;
} STATUSDATA;
typedef STATUSDATA FAR *PSTATUSDATA;

USHORT APIENTRY DosStartSession(PSTARTDATA, PUSHORT, PUSHORT);
USHORT APIENTRY DosSetSession(USHORT, PSTATUSDATA);
USHORT APIENTRY DosSelectSession(USHORT, ULONG);
USHORT APIENTRY DosStopSession(USHORT, USHORT, ULONG);

#endif /* INCL_DOSSESMGR */


/*** Device support */

#ifdef INCL_DOSDEVICES

USHORT APIENTRY DosDevConfig(PVOID, USHORT, USHORT);
USHORT APIENTRY DosDevIOCtl(PVOID, PVOID, USHORT, USHORT, USHORT);
USHORT APIENTRY DosSystemService(USHORT, PVOID, PVOID);

USHORT APIENTRY DosCLIAccess(VOID);
USHORT APIENTRY DosPortAccess(USHORT, USHORT, USHORT, USHORT);
USHORT APIENTRY DosPhysicalDisk(USHORT, PBYTE, USHORT, PBYTE, USHORT);

#endif /* INCL_DOSDEVICES */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\bios.h ===
/***
*bios.h - declarations for bios interface functions and supporting definitions
*
*   Copyright (c) 1987-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file declares the constants, structures, and functions
*   used for accessing and using various BIOS interfaces.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else   /* extensions not enabled */
    #define _CDECL
#endif  /* NO_EXT_KEYS */

/* manifest constants for BIOS serial communications (RS-232) support */

/* serial port services */

#define _COM_INIT       0   /* init serial port */
#define _COM_SEND       1   /* send character */
#define _COM_RECEIVE    2   /* receive character */
#define _COM_STATUS     3   /* get serial port status */

/* serial port initializers.  One and only one constant from each of the
 * following four groups - character size, stop bit, parity, and baud rate -
 * must be specified in the initialization byte.
 */

/* character size initializers */

#define _COM_CHR7       2   /* 7 bits characters */
#define _COM_CHR8       3   /* 8 bits characters */

/* stop bit values - on or off */

#define _COM_STOP1      0   /* 1 stop bit */
#define _COM_STOP2      4   /* 2 stop bits */

/*  parity initializers */

#define _COM_NOPARITY   0   /* no parity */
#define _COM_ODDPARITY  8   /* odd parity */
#define _COM_EVENPARITY 24  /* even parity */

/*  baud rate initializers */

#define _COM_110        0       /* 110 baud */
#define _COM_150        32      /* 150 baud */
#define _COM_300        64      /* 300 baud */
#define _COM_600        96      /* 600 baud */
#define _COM_1200       128     /* 1200 baud */
#define _COM_2400       160     /* 2400 baud */
#define _COM_4800       192     /* 4800 baud */
#define _COM_9600       224     /* 9600 baud */


/* manifest constants for BIOS disk support */

/* disk services */

#define _DISK_RESET     0   /* reset disk controller */
#define _DISK_STATUS    1   /* get disk status */
#define _DISK_READ      2   /* read disk sectors */
#define _DISK_WRITE     3   /* write disk sectors */
#define _DISK_VERIFY    4   /* verify disk sectors */
#define _DISK_FORMAT    5   /* format disk track */

/* struct used to send/receive information to/from the BIOS disk services */

#ifndef NO_EXT_KEYS     /* extensions must be enabled */

#ifndef _DISKINFO_T_DEFINED

struct diskinfo_t {
    unsigned drive;
    unsigned head;
    unsigned track;
    unsigned sector;
    unsigned nsectors;
    void far *buffer;
    };

#define _DISKINFO_T_DEFINED

#endif

#endif /* NO_EXT_KEYS */


/* manifest constants for BIOS keyboard support */

/* keyboard services */

#define _KEYBRD_READ        0   /* read next character from keyboard */
#define _KEYBRD_READY       1   /* check for keystroke */
#define _KEYBRD_SHIFTSTATUS 2   /* get current shift key status */


/* manifest constants for BIOS printer support */

/* printer services */

#define _PRINTER_WRITE  0   /* write character to printer */
#define _PRINTER_INIT   1   /* intialize printer */
#define _PRINTER_STATUS 2   /* get printer status */


/* manifest constants for BIOS time of day support */

/* time of day services */

#define _TIME_GETCLOCK  0   /* get current clock count */
#define _TIME_SETCLOCK  1   /* set current clock count */


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

/* segment registers */

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#define _REGS_DEFINED

#endif /* _REGS_DEFINED */


/* function prototypes */

unsigned _CDECL _bios_equiplist(void);
unsigned _CDECL _bios_keybrd(unsigned);
unsigned _CDECL _bios_memsize(void);
unsigned _CDECL _bios_printer(unsigned, unsigned, unsigned);
unsigned _CDECL _bios_serialcom(unsigned, unsigned, unsigned);
unsigned _CDECL _bios_timeofday(unsigned, long *);
int _CDECL int86(int, union REGS *, union REGS *);
int _CDECL int86x(int, union REGS *, union REGS *, struct SREGS *);

#ifndef NO_EXT_KEYS     /* extensions must be enabled */

unsigned _CDECL _bios_disk(unsigned, struct diskinfo_t *);

#endif /* NO_EXT_KEYS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\bseerr.h ===
/****************************** Module Header ******************************\
*
* Module Name: BSEERR.H
*
* This file includes the error codes for Base OS/2 applications.
*
* This file is compatible with OS/2 version 1.0.
*
* Copyright (c) 1988  Microsoft Corporation
* Copyright (c) 1988  IBM Corporation
*
* ===========================================================================
*
* The following symbols are used in this file for conditional sections.
*
*   INCL_DOSERRORS -  OS/2 Errors         - only included if symbol defined
*
\***************************************************************************/
/*** Error codes */

#ifdef INCL_ERRORS

#define INCL_DOSERRORS

#endif /* INCL_ERRORS */

#ifdef INCL_DOSERRORS

#define NO_ERROR                        0

#define ERROR_INVALID_FUNCTION          1
#define ERROR_FILE_NOT_FOUND            2
#define ERROR_PATH_NOT_FOUND            3
#define ERROR_TOO_MANY_OPEN_FILES       4
#define ERROR_ACCESS_DENIED             5
#define ERROR_INVALID_HANDLE            6
#define ERROR_ARENA_TRASHED             7
#define ERROR_NOT_ENOUGH_MEMORY         8
#define ERROR_INVALID_BLOCK             9
#define ERROR_BAD_ENVIRONMENT           10
#define ERROR_BAD_FORMAT                11
#define ERROR_INVALID_ACCESS            12
#define ERROR_INVALID_DATA              13

#define ERROR_INVALID_DRIVE             15
#define ERROR_CURRENT_DIRECTORY         16
#define ERROR_NOT_SAME_DEVICE           17
#define ERROR_NO_MORE_FILES             18
#define ERROR_WRITE_PROTECT             19
#define ERROR_BAD_UNIT                  20
#define ERROR_NOT_READY                 21
#define ERROR_BAD_COMMAND               22
#define ERROR_CRC                       23
#define ERROR_BAD_LENGTH                24
#define ERROR_SEEK                      25
#define ERROR_NOT_DOS_DISK              26
#define ERROR_SECTOR_NOT_FOUND          27
#define ERROR_OUT_OF_PAPER              28
#define ERROR_WRITE_FAULT               29
#define ERROR_READ_FAULT                30
#define ERROR_GEN_FAILURE               31
#define ERROR_SHARING_VIOLATION         32
#define ERROR_LOCK_VIOLATION            33
#define ERROR_WRONG_DISK                34
#define ERROR_FCB_UNAVAILABLE           35
#define ERROR_SHARING_BUFFER_EXCEEDED   36
#define ERROR_NOT_SUPPORTED             50

#define ERROR_FILE_EXISTS               80
#define ERROR_DUP_FCB                   81
#define ERROR_CANNOT_MAKE               82
#define ERROR_FAIL_I24                  83
#define ERROR_OUT_OF_STRUCTURES         84
#define ERROR_ALREADY_ASSIGNED          85
#define ERROR_INVALID_PASSWORD          86
#define ERROR_INVALID_PARAMETER         87
#define ERROR_NET_WRITE_FAULT           88
#define ERROR_NO_PROC_SLOTS             89
#define ERROR_NOT_FROZEN                90
#define ERR_TSTOVFL                     91
#define ERR_TSTDUP                      92
#define ERROR_NO_ITEMS                  93
#define ERROR_INTERRUPT                 95
#define ERROR_TOO_MANY_SEMAPHORES       100
#define ERROR_EXCL_SEM_ALREADY_OWNED    101
#define ERROR_SEM_IS_SET                102
#define ERROR_TOO_MANY_SEM_REQUESTS     103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104
#define ERROR_SEM_OWNER_DIED            105
#define ERROR_SEM_USER_LIMIT            106
#define ERROR_DISK_CHANGE               107
#define ERROR_DRIVE_LOCKED              108
#define ERROR_BROKEN_PIPE               109
#define ERROR_OPEN_FAILED               110
#define ERROR_BUFFER_OVERFLOW           111
#define ERROR_DISK_FULL                 112
#define ERROR_NO_MORE_SEARCH_HANDLES    113
#define ERROR_INVALID_TARGET_HANDLE     114
#define ERROR_PROTECTION_VIOLATION      115
#define ERROR_VIOKBD_REQUEST            116
#define ERROR_INVALID_CATEGORY          117
#define ERROR_INVALID_VERIFY_SWITCH     118
#define ERROR_BAD_DRIVER_LEVEL          119
#define ERROR_CALL_NOT_IMPLEMENTED      120
#define ERROR_SEM_TIMEOUT               121
#define ERROR_INSUFFICIENT_BUFFER       122
#define ERROR_INVALID_NAME              123
#define ERROR_INVALID_LEVEL             124
#define ERROR_NO_VOLUME_LABEL           125
#define ERROR_MOD_NOT_FOUND             126
#define ERROR_PROC_NOT_FOUND            127
#define ERROR_WAIT_NO_CHILDREN          128
#define ERROR_CHILD_NOT_COMPLETE        129
#define ERROR_DIRECT_ACCESS_HANDLE      130
#define ERROR_NEGATIVE_SEEK             131
#define ERROR_SEEK_ON_DEVICE            132
#define ERROR_IS_JOIN_TARGET            133
#define ERROR_IS_JOINED                 134
#define ERROR_IS_SUBSTED                135
#define ERROR_NOT_JOINED                136
#define ERROR_NOT_SUBSTED               137
#define ERROR_JOIN_TO_JOIN              138
#define ERROR_SUBST_TO_SUBST            139
#define ERROR_JOIN_TO_SUBST             140
#define ERROR_SUBST_TO_JOIN             141
#define ERROR_BUSY_DRIVE                142
#define ERROR_SAME_DRIVE                143
#define ERROR_DIR_NOT_ROOT              144
#define ERROR_DIR_NOT_EMPTY             145
#define ERROR_IS_SUBST_PATH             146
#define ERROR_IS_JOIN_PATH              147
#define ERROR_PATH_BUSY                 148
#define ERROR_IS_SUBST_TARGET           149
#define ERROR_SYSTEM_TRACE              150
#define ERROR_INVALID_EVENT_COUNT       151
#define ERROR_TOO_MANY_MUXWAITERS       152
#define ERROR_INVALID_LIST_FORMAT       153
#define ERROR_LABEL_TOO_LONG            154
#define ERROR_TOO_MANY_TCBS             155
#define ERROR_SIGNAL_REFUSED            156
#define ERROR_DISCARDED                 157
#define ERROR_NOT_LOCKED                158
#define ERROR_BAD_THREADID_ADDR         159
#define ERROR_BAD_ARGUMENTS             160
#define ERROR_BAD_PATHNAME              161
#define ERROR_SIGNAL_PENDING            162
#define ERROR_UNCERTAIN_MEDIA           163
#define ERROR_MAX_THRDS_REACHED         164
#define ERROR_MONITORS_NOT_SUPPORTED    165

#define ERROR_INVALID_SEGMENT_NUMBER    180
#define ERROR_INVALID_CALLGATE          181
#define ERROR_INVALID_ORDINAL           182
#define ERROR_ALREADY_EXISTS            183
#define ERROR_NO_CHILD_PROCESS          184
#define ERROR_CHILD_ALIVE_NOWAIT        185
#define ERROR_INVALID_FLAG_NUMBER       186
#define ERROR_SEM_NOT_FOUND             187
#define ERROR_INVALID_STARTING_CODESEG  188
#define ERROR_INVALID_STACKSEG          189
#define ERROR_INVALID_MODULETYPE        190
#define ERROR_INVALID_EXE_SIGNATURE     191
#define ERROR_EXE_MARKED_INVALID        192
#define ERROR_BAD_EXE_FORMAT            193
#define ERROR_ITERATED_DATA_EXCEEDS_64K 194
#define ERROR_INVALID_MINALLOCSIZE      195
#define ERROR_DYNLINK_FROM_INVALID_RING 196
#define ERROR_IOPL_NOT_ENABLED          197
#define ERROR_INVALID_SEGDPL            198
#define ERROR_AUTODATASEG_EXCEEDS_64k   199
#define ERROR_RING2SEG_MUST_BE_MOVABLE  200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM  201
#define ERROR_INFLOOP_IN_RELOC_CHAIN    202
#define ERROR_ENVVAR_NOT_FOUND          203
#define ERROR_NOT_CURRENT_CTRY          204
#define ERROR_NO_SIGNAL_SENT            205
#define ERROR_FILENAME_EXCED_RANGE      206
#define ERROR_RING2_STACK_IN_USE        207
#define ERROR_META_EXPANSION_TOO_LONG   208
#define ERROR_INVALID_SIGNAL_NUMBER     209
#define ERROR_THREAD_1_INACTIVE         210
#define ERROR_INFO_NOT_AVAIL            211
#define ERROR_LOCKED                    212
#define ERROR_BAD_DYNALINK              213
#define ERROR_TOO_MANY_MODULES          214
#define ERROR_NESTING_NOT_ALLOWED       215

#define ERROR_USER_DEFINED_BASE         0xF000

#define ERROR_I24_WRITE_PROTECT         0
#define ERROR_I24_BAD_UNIT              1
#define ERROR_I24_NOT_READY             2
#define ERROR_I24_BAD_COMMAND           3
#define ERROR_I24_CRC                   4
#define ERROR_I24_BAD_LENGTH            5
#define ERROR_I24_SEEK                  6
#define ERROR_I24_NOT_DOS_DISK          7
#define ERROR_I24_SECTOR_NOT_FOUND      8
#define ERROR_I24_OUT_OF_PAPER          9
#define ERROR_I24_WRITE_FAULT           10
#define ERROR_I24_READ_FAULT            11
#define ERROR_I24_GEN_FAILURE           12
#define ERROR_I24_DISK_CHANGE           13
#define ERROR_I24_WRONG_DISK            14
#define ERROR_I24_UNCERTAIN_MEDIA       15
#define ERROR_I24_CHAR_CALL_INTERRUPTED 16
#define ERROR_I24_NO_MONITOR_SUPPORT    17
#define ERROR_I24_INVALID_PARAMETER     18

#define ALLOWED_FAIL                    0x0001
#define ALLOWED_ABORT                   0x0002
#define ALLOWED_RETRY                   0x0004
#define ALLOWED_IGNORE                  0x0008

#define I24_OPERATION                   0x01
#define I24_AREA                        0x06
#define I24_CLASS                       0x80

/* Values for error CLASS */

#define ERRCLASS_OUTRES                 1
#define ERRCLASS_TEMPSIT                2
#define ERRCLASS_AUTH                   3
#define ERRCLASS_INTRN                  4
#define ERRCLASS_HRDFAIL                5
#define ERRCLASS_SYSFAIL                6
#define ERRCLASS_APPERR                 7
#define ERRCLASS_NOTFND                 8
#define ERRCLASS_BADFMT                 9
#define ERRCLASS_LOCKED                 10
#define ERRCLASS_MEDIA                  11
#define ERRCLASS_ALREADY                12
#define ERRCLASS_UNK                    13
#define ERRCLASS_CANT                   14
#define ERRCLASS_TIME                   15

/* Values for error ACTION */

#define ERRACT_RETRY                    1
#define ERRACT_DLYRET                   2
#define ERRACT_USER                     3
#define ERRACT_ABORT                    4
#define ERRACT_PANIC                    5
#define ERRACT_IGNORE                   6
#define ERRACT_INTRET                   7

/* Values for error LOCUS */

#define ERRLOC_UNK                      1
#define ERRLOC_DISK                     2
#define ERRLOC_NET                      3
#define ERRLOC_SERDEV                   4
#define ERRLOC_MEM                      5

/* Abnormal termination codes */

#define TC_NORMAL                       0
#define TC_HARDERR                      1
#define TC_GP_TRAP                      2
#define TC_SIGNAL                       3

#define ERROR_INVALID_PROCID            303
#define ERROR_INVALID_PDELTA            304
#define ERROR_NOT_DESCENDANT            305
#define ERROR_NOT_SESSION_MANAGER       306
#define ERROR_INVALID_PCLASS            307
#define ERROR_INVALID_SCOPE             308
#define ERROR_INVALID_THREADID          309
#define ERROR_DOSSUB_SHRINK             310
#define ERROR_DOSSUB_NOMEM              311
#define ERROR_DOSSUB_OVERLAP            312
#define ERROR_DOSSUB_BADSIZE            313
#define ERROR_DOSSUB_BADFLAG            314
#define ERROR_DOSSUB_BADSELECTOR        315
#define ERROR_MR_MSG_TOO_LONG           316
#define ERROR_MR_MID_NOT_FOUND          317
#define ERROR_MR_UN_ACC_MSGF            318
#define ERROR_MR_INV_MSGF_FORMAT        319
#define ERROR_MR_INV_IVCOUNT            320
#define ERROR_MR_UN_PERFORM             321
#define ERROR_TS_WAKEUP                 322
#define ERROR_TS_SEMHANDLE              323
#define ERROR_TS_NOTIMER                324
#define ERROR_TS_HANDLE                 326
#define ERROR_TS_DATETIME               327
#define ERROR_SYS_INTERNAL              328
#define ERROR_QUE_CURRENT_NAME          329
#define ERROR_QUE_PROC_NOT_OWNED        330
#define ERROR_QUE_PROC_OWNED            331
#define ERROR_QUE_DUPLICATE             332
#define ERROR_QUE_ELEMENT_NOT_EXIST     333
#define ERROR_QUE_NO_MEMORY             334
#define ERROR_QUE_INVALID_NAME          335
#define ERROR_QUE_INVALID_PRIORITY      336
#define ERROR_QUE_INVALID_HANDLE        337
#define ERROR_QUE_LINK_NOT_FOUND        338
#define ERROR_QUE_MEMORY_ERROR          339
#define ERROR_QUE_PREV_AT_END           340
#define ERROR_QUE_PROC_NO_ACCESS        341
#define ERROR_QUE_EMPTY                 342
#define ERROR_QUE_NAME_NOT_EXIST        343
#define ERROR_QUE_NOT_INITIALIZED       344
#define ERROR_QUE_UNABLE_TO_ACCESS      345
#define ERROR_QUE_UNABLE_TO_ADD         346
#define ERROR_QUE_UNABLE_TO_INIT        347
#define ERROR_VIO_INVALID_MASK          349
#define ERROR_VIO_PTR                   350
#define ERROR_VIO_APTR                  351
#define ERROR_VIO_RPTR                  352
#define ERROR_VIO_CPTR                  353
#define ERROR_VIO_LPTR                  354
#define ERROR_VIO_MODE                  355
#define ERROR_VIO_WIDTH                 356
#define ERROR_VIO_ATTR                  357
#define ERROR_VIO_ROW                   358
#define ERROR_VIO_COL                   359
#define ERROR_VIO_TOPROW                360
#define ERROR_VIO_BOTROW                361
#define ERROR_VIO_RIGHTCOL              362
#define ERROR_VIO_LEFTCOL               363
#define ERROR_SCS_CALL                  364
#define ERROR_SCS_VALUE                 365
#define ERROR_VIO_WAIT_FLAG             366
#define ERROR_VIO_UNLOCK                367
#define ERROR_SGS_NOT_SESSION_MGR       368
#define ERROR_SMG_INVALID_SGID          369
#define ERROR_SMG_INVALID_SESSION_ID    369
#define ERROR_SMG_NOSG                  370
#define ERROR_SMG_NO_SESSIONS           370
#define ERROR_SMG_GRP_NOT_FOUND         371
#define ERROR_SMG_SESSION_NOT_FOUND     371
#define ERROR_SMG_SET_TITLE             372
#define ERROR_KBD_PARAMETER             373
#define ERROR_KBD_NO_DEVICE             374
#define ERROR_KBD_INVALID_IOWAIT        375
#define ERROR_KBD_INVALID_LENGTH        376
#define ERROR_KBD_INVALID_ECHO_MASK     377
#define ERROR_KBD_INVALID_INPUT_MASK    378
#define ERROR_MON_INVALID_PARMS         379
#define ERROR_MON_INVALID_DEVNAME       380
#define ERROR_MON_INVALID_HANDLE        381
#define ERROR_MON_BUFFER_TOO_SMALL      382
#define ERROR_MON_BUFFER_EMPTY          383
#define ERROR_MON_DATA_TOO_LARGE        384
#define ERROR_MOUSE_NO_DEVICE           385
#define ERROR_MOUSE_INV_HANDLE          386
#define ERROR_MOUSE_INV_PARMS           387
#define ERROR_MOUSE_CANT_RESET          388
#define ERROR_MOUSE_DISPLAY_PARMS       389
#define ERROR_MOUSE_INV_MODULE          390
#define ERROR_MOUSE_INV_ENTRY_PT        391
#define ERROR_MOUSE_INV_MASK            392
#define NO_ERROR_MOUSE_NO_DATA          393
#define NO_ERROR_MOUSE_PTR_DRAWN        394
#define ERROR_INVALID_FREQUENCY         395
#define ERROR_NLS_NO_COUNTRY_FILE       396
#define ERROR_NLS_OPEN_FAILED           397
#define ERROR_NLS_NO_CTRY_CODE          398
#define ERROR_NO_COUNTRY_OR_CODEPAGE    398
#define ERROR_NLS_TABLE_TRUNCATED       399
#define ERROR_NLS_BAD_TYPE              400
#define ERROR_NLS_TYPE_NOT_FOUND        401
#define ERROR_VIO_SMG_ONLY              402
#define ERROR_VIO_INVALID_ASCIIZ        403
#define ERROR_VIO_DEREGISTER            404
#define ERROR_VIO_NO_POPUP              405
#define ERROR_VIO_EXISTING_POPUP        406
#define ERROR_KBD_SMG_ONLY              407
#define ERROR_KBD_INVALID_ASCIIZ        408
#define ERROR_KBD_INVALID_MASK          409
#define ERROR_KBD_REGISTER              410
#define ERROR_KBD_DEREGISTER            411
#define ERROR_MOUSE_SMG_ONLY            412
#define ERROR_MOUSE_INVALID_ASCIIZ      413
#define ERROR_MOUSE_INVALID_MASK        414
#define ERROR_MOUSE_REGISTER            415
#define ERROR_MOUSE_DEREGISTER          416
#define ERROR_SMG_BAD_ACTION            417
#define ERROR_SMG_INVALID_CALL          418
#define ERROR_SCS_SG_NOTFOUND           419
#define ERROR_SCS_NOT_SHELL             420
#define ERROR_VIO_INVALID_PARMS         421
#define ERROR_VIO_FUNCTION_OWNED        422
#define ERROR_VIO_RETURN                423
#define ERROR_SCS_INVALID_FUNCTION      424
#define ERROR_SCS_NOT_SESSION_MGR       425
#define ERROR_VIO_REGISTER              426
#define ERROR_VIO_NO_MODE_THREAD        427
#define ERROR_VIO_NO_SAVE_RESTORE_THD   428
#define ERROR_VIO_IN_BG                 429
#define ERROR_VIO_ILLEGAL_DURING_POPUP  430
#define ERROR_SMG_NOT_BASESHELL         431
#define ERROR_SMG_BAD_STATUSREQ         432
#define ERROR_QUE_INVALID_WAIT          433
#define ERROR_VIO_LOCK                  434
#define ERROR_MOUSE_INVALID_IOWAIT      435
#define ERROR_VIO_INVALID_HANDLE        436
#define ERROR_VIO_ILLEGAL_DURING_LOCK   437
#define ERROR_VIO_INVALID_LENGTH        438
#define ERROR_KBD_INVALID_HANDLE        439
#define ERROR_KBD_NO_MORE_HANDLE        440
#define ERROR_KBD_CANNOT_CREATE_KCB     441
#define ERROR_KBD_CODEPAGE_LOAD_INCOMPL 442
#define ERROR_KBD_INVALID_CODEPAGE_ID   443
#define ERROR_KBD_NO_CODEPAGE_SUPPORT   444
#define ERROR_KBD_FOCUS_REQUIRED        445
#define ERROR_KBD_FOCUS_ALREADY_ACTIVE  446
#define ERROR_KBD_KEYBOARD_BUSY         447
#define ERROR_KBD_INVALID_CODEPAGE      448
#define ERROR_KBD_UNABLE_TO_FOCUS       449
#define ERROR_SMG_SESSION_NON_SELECT    450
#define ERROR_SMG_SESSION_NOT_FOREGRND  451
#define ERROR_SMG_SESSION_NOT_PARENT    452
#define ERROR_SMG_INVALID_START_MODE    453
#define ERROR_SMG_INVALID_RELATED_OPT   454
#define ERROR_SMG_INVALID_BOND_OPTION   455
#define ERROR_SMG_INVALID_SELECT_OPT    456
#define ERROR_SMG_START_IN_BACKGROUND   457
#define ERROR_SMG_INVALID_STOP_OPTION   458
#define ERROR_SMG_BAD_RESERVE           459
#define ERROR_SMG_PROCESS_NOT_PARENT    460
#define ERROR_SMG_INVALID_DATA_LENGTH   461
#define ERROR_SMG_NOT_BOUND             462
#define ERROR_SMG_RETRY_SUB_ALLOC       463
#define ERROR_KBD_DETACHED              464
#define ERROR_VIO_DETACHED              465
#define ERROR_MOU_DETACHED              466
#define ERROR_VIO_FONT                  467
#define ERROR_VIO_USER_FONT             468
#define ERROR_VIO_BAD_CP                469
#define ERROR_VIO_NO_CP                 470
#define ERROR_VIO_NA_CP                 471
#define ERROR_INVALID_CODE_PAGE         472
#define ERROR_CPLIST_TOO_SMALL          473
#define ERROR_CP_NOT_MOVED              474
#define ERROR_MODE_SWITCH_INIT          475
#define ERROR_CODE_PAGE_NOT_FOUND       476
#define ERROR_UNEXPECTED_SLOT_RETURNED  477
#define ERROR_SMG_INVALID_TRACE_OPTION  478
#define ERROR_VIO_INTERNAL_RESOURCE     479
#define ERROR_VIO_SHELL_INIT            480
#define ERROR_SMG_NO_HARD_ERRORS        481
#define ERROR_CP_SWITCH_INCOMPLETE      482
#define ERROR_VIO_TRANSPARENT_POPUP     483
#define ERROR_CRITSEC_OVERFLOW          484
#define ERROR_CRITSEC_UNDERFLOW         485
#define ERROR_VIO_BAD_RESERVE           486
#define ERROR_INVALID_ADDRESS           487
#define ERROR_ZERO_SELECTORS_REQUESTED  488
#define ERROR_NOT_ENOUGH_SELECTORS_AVA  489
#define ERROR_INVALID_SELECTOR          490

/* New Equates For OS/2 1.1 */
#define ERROR_SMG_INVALID_PROGRAM_TYPE  491
#define ERROR_SMG_INVALID_PGM_CONTROL   492

/* */
/* intercomponent error codes (from 8000H or 32768) */
/* */
#define ERROR_SWAPPER_NOT_ACTIVE        32768
#define ERROR_INVALID_SWAPID            32769
#define ERROR_IOERR_SWAP_FILE           32770
#define ERROR_SWAP_TABLE_FULL           32771
#define ERROR_SWAP_FILE_FULL            32772
#define ERROR_CANT_INIT_SWAPPER         32773
#define ERROR_SWAPPER_ALREADY_INIT      32774
#define ERROR_PMM_INSUFFICIENT_MEMORY   32775
#define ERROR_PMM_INVALID_FLAGS         32776
#define ERROR_PMM_INVALID_ADDRESS       32777
#define ERROR_PMM_LOCK_FAILED           32778
#define ERROR_PMM_UNLOCK_FAILED         32779
#define ERROR_PMM_MOVE_INCOMPLETE       32780
#define ERROR_UCOM_DRIVE_RENAMED        32781
#define ERROR_UCOM_FILENAME_TRUNCATED   32782
#define ERROR_UCOM_BUFFER_LENGTH        32783
#define ERROR_MON_CHAIN_HANDLE          32784
#define ERROR_MON_NOT_REGISTERED        32785
#define ERROR_SMG_ALREADY_TOP           32786
#define ERROR_PMM_ARENA_MODIFIED        32787
#define ERROR_SMG_PRINTER_OPEN          32788
#define ERROR_PMM_SET_FLAGS_FAILED      32789
#define ERROR_INVALID_DOS_DD            32790
#define ERROR_CPSIO_CODE_PAGE_INVALID   65026
#define ERROR_CPSIO_NO_SPOOLER          65027
#define ERROR_CPSIO_FONT_ID_INVALID     65028
#define ERROR_CPSIO_INTERNAL_ERROR      65033
#define ERROR_CPSIO_INVALID_PTR_NAME    65034
#define ERROR_CPSIO_NOT_ACTIVE          65037
#define ERROR_CPSIO_PID_FULL            65039
#define ERROR_CPSIO_PID_NOT_FOUND       65040
#define ERROR_CPSIO_READ_CTL_SEQ        65043
#define ERROR_CPSIO_READ_FNT_DEF        65045
#define ERROR_CPSIO_WRITE_ERROR         65047
#define ERROR_CPSIO_WRITE_FULL_ERROR    65048
#define ERROR_CPSIO_WRITE_HANDLE_BAD    65049
#define ERROR_CPSIO_SWIT_LOAD           65074
#define ERROR_CPSIO_INV_COMMAND         65077
#define ERROR_CPSIO_NO_FONT_SWIT        65078

#endif /* INCL_DOSERRORS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\bsesub.h ===
/***************************************************************************\
*
* Module Name: BSESUB.H
*
* OS/2 Base Include File
*
* This file is compatible with OS/2 version 1.0.
*
* Copyright (c) 1988  Microsoft Corporation
*
*****************************************************************************
*
* Subcomponents marked with "+" are partially included by default
*   #define:                To include:
*
*   INCL_SUB                KBD, VIO, MOU
*
\***************************************************************************/

#ifdef INCL_SUB

typedef SHANDLE         HKBD;
typedef HKBD    far *   PHKBD;

USHORT APIENTRY KbdRegister (PSZ, PSZ, ULONG);

#define KR_KBDCHARIN        0x00000001
#define KR_KBDPEEK          0x00000002
#define KR_KBDFLUSHBUFFER   0x00000004
#define KR_KBDGETSTATUS     0x00000008
#define KR_KBDSETSTATUS     0x00000010
#define KR_KBDSTRINGIN      0x00000020
#define KR_KBDOPEN          0x00000040
#define KR_KBDCLOSE         0x00000080
#define KR_KBDGETFOCUS      0x00000100
#define KR_KBDFREEFOCUS     0x00000200
#define KR_KBDGETCP         0x00000400
#define KR_KBDSETCP         0x00000800
#define KR_KBDXLATE         0x00001000
#define KR_KBDSETCUSTXT     0x00002000

#define IO_WAIT     0
#define IO_NOWAIT   1

USHORT APIENTRY KbdDeRegister ( void );

/* KBDKEYINFO structure, for KbdCharIn and KbdPeek */

typedef struct _KBDKEYINFO {    /* kbci */
        UCHAR    chChar;
        UCHAR    chScan;
        UCHAR    fbStatus;
        UCHAR    bNlsShift;
        USHORT   fsState;
        ULONG    time;
        }KBDKEYINFO;
typedef KBDKEYINFO far *PKBDKEYINFO;

USHORT APIENTRY KbdCharIn ( PKBDKEYINFO, USHORT, HKBD );
USHORT APIENTRY KbdPeek ( PKBDKEYINFO, HKBD );

/* structure for KbdStringIn() */

typedef struct _STRINGINBUF {   /* kbsi */
        USHORT cb;
        USHORT cchIn;
        } STRINGINBUF;
typedef STRINGINBUF far *PSTRINGINBUF;

USHORT APIENTRY KbdStringIn ( PCH, PSTRINGINBUF, USHORT, HKBD );

USHORT APIENTRY KbdFlushBuffer ( HKBD );

/* KBDINFO structure, for KbdSet/GetStatus */
typedef struct _KBDINFO {       /* kbst */
        USHORT cb;
        USHORT fsMask;
        USHORT chTurnAround;
        USHORT fsInterim;
        USHORT fsState;
        }KBDINFO;
typedef KBDINFO far *PKBDINFO;

USHORT APIENTRY KbdSetStatus ( PKBDINFO, HKBD );
USHORT APIENTRY KbdGetStatus ( PKBDINFO, HKBD );

USHORT APIENTRY KbdSetCp ( USHORT, USHORT, HKBD);
USHORT APIENTRY KbdGetCp ( ULONG, PUSHORT, HKBD );

USHORT APIENTRY KbdOpen ( PHKBD );
USHORT APIENTRY KbdClose ( HKBD );

USHORT APIENTRY KbdGetFocus ( USHORT, HKBD );
USHORT APIENTRY KbdFreeFocus ( HKBD );

USHORT APIENTRY KbdSynch ( USHORT );

/* structure for KbdXlate() */
typedef struct _KBDTRANSLATE {      /* kbxl */
        UCHAR      chChar;
        UCHAR      chScan;
        UCHAR      fbStatus;
        UCHAR      bNlsShift;
        USHORT     fsState;
        ULONG      time;
        USHORT     fsDD;
        USHORT     fsXlate;
        USHORT     fsShift;
        USHORT     sZero;
        } KBDTRANSLATE;
typedef KBDTRANSLATE far *PKBDTRANSLATE;

USHORT APIENTRY KbdXlate ( PKBDTRANSLATE, HKBD );
USHORT APIENTRY KbdSetCustXt ( PUSHORT, HKBD );

typedef SHANDLE         HVIO;
typedef HVIO    far *   PHVIO;

USHORT APIENTRY VioRegister ( PSZ, PSZ, ULONG, ULONG );

USHORT APIENTRY VioDeRegister ( void );

USHORT APIENTRY VioGetBuf ( PULONG, PUSHORT, HVIO );

USHORT APIENTRY VioGetCurPos ( PUSHORT, PUSHORT, HVIO );
USHORT APIENTRY VioSetCurPos ( USHORT, USHORT, HVIO );

/* structure for VioSet/GetCurType() */
typedef struct _VIOCURSORINFO { /* vioci */
        USHORT   yStart;
        USHORT   cEnd;
        USHORT   cx;
        USHORT   attr;
        } VIOCURSORINFO;
typedef VIOCURSORINFO FAR *PVIOCURSORINFO;

USHORT APIENTRY VioGetCurType ( PVIOCURSORINFO, HVIO );
USHORT APIENTRY VioSetCurType ( PVIOCURSORINFO, HVIO );

/* structure for VioSet/GetMode() */
typedef struct _VIOMODEINFO {   /* viomi */
        USHORT cb;
        UCHAR  fbType;
        UCHAR  color;
        USHORT col;
        USHORT row;
        USHORT hres;
        USHORT vres;
        UCHAR  fmt_ID;
        UCHAR  attrib;
        } VIOMODEINFO;
typedef VIOMODEINFO FAR *PVIOMODEINFO;

#define VGMT_OTHER          0x01
#define VGMT_GRAPHICS       0x02
#define VGMT_DISABLEBURST   0x04

USHORT APIENTRY VioGetMode ( PVIOMODEINFO, HVIO );
USHORT APIENTRY VioSetMode ( PVIOMODEINFO, HVIO );

/* structure for VioGetPhysBuf() */

typedef struct _VIOPHYSBUF {    /* viopb */
        PBYTE    pBuf;
        ULONG    cb;
        SEL      asel[1];
        } VIOPHYSBUF;
typedef VIOPHYSBUF far *PVIOPHYSBUF;

USHORT APIENTRY VioGetPhysBuf ( PVIOPHYSBUF, USHORT );

USHORT APIENTRY VioReadCellStr ( PCH, PUSHORT, USHORT, USHORT, HVIO );
USHORT APIENTRY VioReadCharStr ( PCH, PUSHORT, USHORT, USHORT, HVIO );
USHORT APIENTRY VioWrtCellStr ( PCH, USHORT, USHORT, USHORT, HVIO );
USHORT APIENTRY VioWrtCharStr ( PCH, USHORT, USHORT, USHORT, HVIO );

USHORT APIENTRY VioScrollDn ( USHORT, USHORT, USHORT, USHORT,
                              USHORT, PBYTE,  HVIO );
USHORT APIENTRY VioScrollUp ( USHORT, USHORT, USHORT, USHORT,
                              USHORT, PBYTE,  HVIO );
USHORT APIENTRY VioScrollLf ( USHORT, USHORT, USHORT, USHORT,
                              USHORT, PBYTE,  HVIO );
USHORT APIENTRY VioScrollRt ( USHORT, USHORT, USHORT, USHORT,
                              USHORT, PBYTE,  HVIO );

USHORT APIENTRY VioWrtNAttr ( PBYTE, USHORT, USHORT, USHORT, HVIO );
USHORT APIENTRY VioWrtNCell ( PBYTE, USHORT, USHORT, USHORT, HVIO );
USHORT APIENTRY VioWrtNChar ( PCH, USHORT, USHORT, USHORT, HVIO );
USHORT APIENTRY VioWrtTTy ( PCH, USHORT, HVIO );
USHORT APIENTRY VioWrtCharStrAtt ( PCH, USHORT, USHORT, USHORT, PBYTE, HVIO );

USHORT APIENTRY VioShowBuf ( USHORT, USHORT, HVIO );


#define ANSI_ON     1
#define ANSI_OFF    0

USHORT APIENTRY VioSetAnsi ( USHORT, HVIO );
USHORT APIENTRY VioGetAnsi ( PUSHORT, HVIO );

USHORT APIENTRY VioPrtSc ( HVIO );
USHORT APIENTRY VioPrtScToggle ( HVIO );

#define VSRWI_SAVEANDREDRAW  0
#define VSRWI_REDRAW         1

#define VSRWN_SAVE           0
#define VSRWN_REDRAW         1

#define UNDOI_GETOWNER          0
#define UNDOI_RELEASEOWNER      1

#define UNDOK_ERRORCODE         0
#define UNDOK_TERMINATE         1

USHORT APIENTRY VioSavRedrawWait ( USHORT, PUSHORT, USHORT);
USHORT APIENTRY VioSavRedrawUndo ( USHORT, USHORT, USHORT );

#define VMWR_POPUP  0
#define VMWN_POPUP  0

USHORT APIENTRY VioModeWait ( USHORT, PUSHORT, USHORT );
USHORT APIENTRY VioModeUndo ( USHORT, USHORT, USHORT );

#define LOCKIO_NOWAIT   0
#define LOCKIO_WAIT     1

#define LOCK_SUCCESS    0
#define LOCK_FAIL       1

USHORT APIENTRY VioScrLock ( USHORT, PBYTE, HVIO );
USHORT APIENTRY VioScrUnLock ( HVIO );

#define VP_NOWAIT       0x0000
#define VP_WAIT         0x0001
#define VP_OPAQUE       0x0000
#define VP_TRANSPARENT  0x0002

USHORT APIENTRY VioPopUp ( PUSHORT, HVIO );
USHORT APIENTRY VioEndPopUp ( HVIO );

/* structure for VioGetConfig() */

typedef struct _VIOCONFIGINFO { /* vioin */
        USHORT  cb     ;
        USHORT  adapter;
        USHORT  display;
        ULONG   cbMemory;
        } VIOCONFIGINFO;
typedef VIOCONFIGINFO far *PVIOCONFIGINFO;

USHORT APIENTRY VioGetConfig ( USHORT, PVIOCONFIGINFO, HVIO );

/* structure for VioGet/SetFont() */
typedef struct _VIOFONTINFO {   /* viofi */
        USHORT  cb;
        USHORT  type;
        USHORT  cxCell;
        USHORT  cyCell;
        PVOID   pbData;
        USHORT  cbData;
        } VIOFONTINFO;
typedef VIOFONTINFO far *PVIOFONTINFO;

#define VGFI_GETCURFONT     0
#define VGFI_GETROMFONT     1

USHORT APIENTRY VioGetFont ( PVIOFONTINFO, HVIO );
USHORT APIENTRY VioSetFont ( PVIOFONTINFO, HVIO );

USHORT APIENTRY VioGetCp ( USHORT, PUSHORT, HVIO );
USHORT APIENTRY VioSetCp ( USHORT, USHORT, HVIO );

typedef struct _VIOPALSTATE {   /* viopal */
        USHORT  cb;
        USHORT  type;
        USHORT  iFirst;
        USHORT  acolor[1];
        }VIOPALSTATE;
typedef VIOPALSTATE far *PVIOPALSTATE;

typedef struct _VIOOVERSCAN {   /* vioos */
        USHORT  cb;
        USHORT  type;
        USHORT  color;
        }VIOOVERSCAN;
typedef VIOOVERSCAN far *PVIOOVERSCAN;

typedef struct _VIOINTENSITY {  /* vioint */
        USHORT  cb;
        USHORT  type;
        USHORT  fs;
        }VIOINTENSITY;
typedef VIOINTENSITY far *PVIOINTENSITY;

USHORT APIENTRY VioGetState ( PVOID, HVIO );
USHORT APIENTRY VioSetState ( PVOID, HVIO );

typedef SHANDLE         HMOU;
typedef HMOU    far *   PHMOU;

USHORT APIENTRY MouRegister ( PSZ, PSZ, ULONG );

USHORT APIENTRY MouDeRegister ( void );

USHORT APIENTRY MouFlushQue ( HMOU );

#define MHK_BUTTON1         0x0002
#define MHK_BUTTON2         0x0004
#define MHK_BUTTON3         0x0008

USHORT APIENTRY MouGetHotKey ( PUSHORT, HMOU );
USHORT APIENTRY MouSetHotKey ( PUSHORT, HMOU );

/* structure for MouGet/SetPtrPos() */
typedef struct _PTRLOC {    /* moupl */
        USHORT row;
        USHORT col;
        } PTRLOC;
typedef PTRLOC far *PPTRLOC;

USHORT APIENTRY MouGetPtrPos ( PPTRLOC, HMOU );
USHORT APIENTRY MouSetPtrPos ( PPTRLOC, HMOU );

/* structure for MouGet/SetPtrShape() */
typedef struct _PTRSHAPE {  /* moups */
        USHORT cb;
        USHORT col;
        USHORT row;
        USHORT colHot;
        USHORT rowHot;
        } PTRSHAPE;
typedef PTRSHAPE far *PPTRSHAPE;

USHORT APIENTRY MouSetPtrShape ( PBYTE, PPTRSHAPE, HMOU );
USHORT APIENTRY MouGetPtrShape ( PBYTE, PPTRSHAPE, HMOU );

USHORT APIENTRY MouGetDevStatus ( PUSHORT, HMOU );

USHORT APIENTRY MouGetNumButtons ( PUSHORT, HMOU );
USHORT APIENTRY MouGetNumMickeys ( PUSHORT, HMOU );

/* structure for MouReadEventQue() */
typedef struct _MOUEVENTINFO {  /* mouev */
        USHORT fs;
        ULONG  Time;
        USHORT row;
        USHORT col;
        }MOUEVENTINFO;
typedef MOUEVENTINFO far *PMOUEVENTINFO;

USHORT APIENTRY MouReadEventQue ( PMOUEVENTINFO, PUSHORT, HMOU );

/* structure for MouGetNumQueEl() */
typedef struct _MOUQUEINFO {    /* mouqi */
        USHORT cEvents;
        USHORT cmaxEvents;
        } MOUQUEINFO;
typedef MOUQUEINFO far *PMOUQUEINFO;

USHORT APIENTRY MouGetNumQueEl ( PMOUQUEINFO, HMOU );

USHORT APIENTRY MouGetEventMask ( PUSHORT, HMOU );
USHORT APIENTRY MouSetEventMask ( PUSHORT, HMOU );

/* structure for MouGet/SetScaleFact() */
typedef struct _SCALEFACT { /* mousc */
        USHORT rowScale;
        USHORT colScale;
        } SCALEFACT;
typedef SCALEFACT far *PSCALEFACT;

USHORT APIENTRY MouGetScaleFact ( PSCALEFACT, HMOU );
USHORT APIENTRY MouSetScaleFact ( PSCALEFACT, HMOU );

USHORT APIENTRY MouOpen ( PSZ, PHMOU );
USHORT APIENTRY MouClose ( HMOU );

/* structure for MouRemovePtr() */
typedef struct _NOPTRRECT { /* mourt */
        USHORT row;
        USHORT col;
        USHORT cRow;
        USHORT cCol;
        } NOPTRRECT;
typedef NOPTRRECT far *PNOPTRRECT;

USHORT APIENTRY MouRemovePtr ( PNOPTRRECT, HMOU );

USHORT APIENTRY MouDrawPtr ( HMOU );

USHORT APIENTRY MouSetDevStatus ( PUSHORT, HMOU );
USHORT APIENTRY MouInitReal ( PSZ );

USHORT APIENTRY MouSynch ( USHORT );

#endif /* INCL_SUB */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   the MS C V2.03 compatible console and port I/O routines.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */

/* function prototypes */

char * _CDECL cgets(char *);
int _CDECL cprintf(char *, ...);
int _CDECL cputs(char *);
int _CDECL cscanf(char *, ...);
int _CDECL getch(void);
int _CDECL getche(void);
int _CDECL inp(unsigned int);
unsigned _CDECL inpw(unsigned int);
int _CDECL kbhit(void);
int _CDECL outp(unsigned int, int);
unsigned _CDECL outpw(unsigned int, unsigned int);
int _CDECL putch(int);
int _CDECL ungetch(int);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the library
*   functions related to directory handling and creation.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */

/* function prototypes */

int _CDECL chdir(char *);
char * _CDECL getcwd(char *, int);
int _CDECL mkdir(char *);
int _CDECL rmdir(char *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines macros for character classification/conversion.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

extern unsigned char _NEAR _CDECL _ctype[];

/* set bit masks for the possible character types */

#define _UPPER        0x1       /* upper case letter */
#define _LOWER        0x2       /* lower case letter */
#define _DIGIT        0x4       /* digit[0-9] */
#define _SPACE        0x8       /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT       0x10       /* punctuation character */
#define _CONTROL     0x20       /* control character */
#define _BLANK       0x40       /* space char */
#define _HEX         0x80       /* hexadecimal digit */

/* the character classification macro definitions */

#define isalpha(c)      ( (_ctype+1)[c] & (_UPPER|_LOWER) )
#define isupper(c)      ( (_ctype+1)[c] & _UPPER )
#define islower(c)      ( (_ctype+1)[c] & _LOWER )
#define isdigit(c)      ( (_ctype+1)[c] & _DIGIT )
#define isxdigit(c)     ( (_ctype+1)[c] & _HEX )
#define isspace(c)      ( (_ctype+1)[c] & _SPACE )
#define ispunct(c)      ( (_ctype+1)[c] & _PUNCT )
#define isalnum(c)      ( (_ctype+1)[c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(c)      ( (_ctype+1)[c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(c)      ( (_ctype+1)[c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(c)      ( (_ctype+1)[c] & _CONTROL )

#define toupper(c)      ( (islower(c)) ? _toupper(c) : (c) )
#define tolower(c)      ( (isupper(c)) ? _tolower(c) : (c) )

#define _tolower(c)     ( (c)-'A'+'a' )
#define _toupper(c)     ( (c)-'a'+'A' )

#define isascii(c)      ( (unsigned)(c) < 0x80 )
#define toascii(c)      ( (c) & 0x7f )

/* MS C version 2.0 extended ctype macros */

#define iscsymf(c)      (isalpha(c) || ((c) == '_'))
#define iscsym(c)       (isalnum(c) || ((c) == '_'))
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines the structs and unions used for the direct DOS interface
*   routines; includes macros to access the segment and offset
*   values of far pointers, so that they may be used by the routines; and
*   provides function prototypes for direct DOS interface functions.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };


/* byte registers */

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };


/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };


/* segment registers */

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#define _REGS_DEFINED

#endif


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED

struct DOSERROR {
    int exterror;
    char class;
    char action;
    char locus;
    };

#define _DOSERROR_DEFINED

#endif


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED

struct find_t {
    char reserved[21];
    char attrib;
    unsigned wr_time;
    unsigned wr_date;
    long size;
    char name[13];
    };

#define _FIND_T_DEFINED

#endif


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED

struct dosdate_t {
    unsigned char day;          /* 1-31 */
    unsigned char month;        /* 1-12 */
    unsigned int year;          /* 1980-2099 */
    unsigned char dayofweek;    /* 0-6, 0=Sunday */
    };

struct dostime_t {
    unsigned char hour;     /* 0-23 */
    unsigned char minute;   /* 0-59 */
    unsigned char second;   /* 0-59 */
    unsigned char hsecond;  /* 0-99 */
    };

#define _DATETIME_T_DEFINED

#endif


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct diskfree_t {
    unsigned total_clusters;
    unsigned avail_clusters;
    unsigned sectors_per_cluster;
    unsigned bytes_per_sector;
    };

#define _DISKFREE_T_DEFINED

#endif


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE     0   /* Ignore the error */
#define _HARDERR_RETRY      1   /* Retry the operation */
#define _HARDERR_ABORT      2   /* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL       3   /* Fail the system call in progress */
                                /* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_VOLID        0x08    /* Volume ID file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* macros to break MS C "far" pointers into their segment and offset
 * components
 */

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))


/* external variable declarations */

extern unsigned int _NEAR _CDECL _osversion;


/* function prototypes */

int _CDECL bdos(int, unsigned int, unsigned int);
void _CDECL _disable(void);
unsigned _CDECL _dos_allocmem(unsigned, unsigned *);
unsigned _CDECL _dos_close(int);
unsigned _CDECL _dos_creat(char *, unsigned, int *);
unsigned _CDECL _dos_creatnew(char *, unsigned, int *);
unsigned _CDECL _dos_findfirst(char *, unsigned, struct find_t *);
unsigned _CDECL _dos_findnext(struct find_t *);
unsigned _CDECL _dos_freemem(unsigned);
void _CDECL _dos_getdate(struct dosdate_t *);
void _CDECL _dos_getdrive(unsigned *);
unsigned _CDECL _dos_getdiskfree(unsigned, struct diskfree_t *);
unsigned _CDECL _dos_getfileattr(char *, unsigned *);
unsigned _CDECL _dos_getftime(int, unsigned *, unsigned *);
void _CDECL _dos_gettime(struct dostime_t *);
void _CDECL _dos_keep(unsigned, unsigned);
unsigned _CDECL _dos_open(char *, unsigned, int *);
unsigned _CDECL _dos_setblock(unsigned, unsigned, unsigned *);
unsigned _CDECL _dos_setdate(struct dosdate_t *);
void _CDECL _dos_setdrive(unsigned, unsigned *);
unsigned _CDECL _dos_setfileattr(char *, unsigned);
unsigned _CDECL _dos_setftime(int, unsigned, unsigned);
unsigned _CDECL _dos_settime(struct dostime_t *);
int _CDECL dosexterr(struct DOSERROR *);
void _CDECL _enable(void);
void _CDECL _hardresume(int);
void _CDECL _hardretn(int);
int _CDECL intdos(union REGS *, union REGS *);
int _CDECL intdosx(union REGS *, union REGS *, struct SREGS *);
int _CDECL int86(int, union REGS *, union REGS *);
int _CDECL int86x(int, union REGS *, union REGS *, struct SREGS *);
void _CDECL segread(struct SREGS *);


#ifndef NO_EXT_KEYS /* extensions enabled */
void _CDECL _chain_intr(void (_CDECL interrupt far *)());
void (_CDECL interrupt far * _CDECL _dos_getvect(unsigned))();
unsigned _CDECL _dos_read(int, void far *, unsigned, unsigned *);
void _CDECL _dos_setvect(unsigned, void (_CDECL interrupt far *)());
unsigned _CDECL _dos_write(int, void far *, unsigned, unsigned *);
void _CDECL _harderr(void (far *)());
#endif /* NO_EXT_KEYS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1987
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 3.xx.a - 02/26/87>
??_out <Copyright (C) Microsoft Corp. 1984-1987. All rights reserved.>
outif memS,0,<Small Model>
outif memM,0,<Medium model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
outif memS,0,<Small model>
else
??error <must have only 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
outif ?PLM,1,<PL/M calling convention>
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ?&&x
n=n or ?&&x
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the system-wide error numbers (set by
*   system calls).  Conforms to the XENIX standard.  Extended
*   for compatibility with Uniforum standard.
*   [System V]
*
*******************************************************************************/

#define  EZERO      0
#define  EPERM      1
#define  ENOENT     2
#define  ESRCH      3
#define  EINTR      4
#define  EIO        5
#define  ENXIO      6
#define  E2BIG      7
#define  ENOEXEC    8
#define  EBADF      9
#define  ECHILD    10
#define  EAGAIN    11
#define  ENOMEM    12
#define  EACCES    13
#define  EFAULT    14
#define  ENOTBLK   15
#define  EBUSY     16
#define  EEXIST    17
#define  EXDEV     18
#define  ENODEV    19
#define  ENOTDIR   20
#define  EISDIR    21
#define  EINVAL    22
#define  ENFILE    23
#define  EMFILE    24
#define  ENOTTY    25
#define  ETXTBSY   26
#define  EFBIG     27
#define  ENOSPC    28
#define  ESPIPE    29
#define  EROFS     30
#define  EMLINK    31
#define  EPIPE     32
#define  EDOM      33
#define  ERANGE    34
#define  EUCLEAN   35
#define  EDEADLOCK 36
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\float.h ===
/***
*float.h - constants for floating point values
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains defines for a number of implementation dependent
*   values which are commonly used by sophisticated numerical (floating
*   point) programs.
*   [ANSI]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  -307                    /* min decimal exponent
#define DBL_MIN_EXP     -1021                   /* min binary exponent */
#define DBL_RADIX       2                       /* exponent radix */
#define DBL_ROUNDS      0                       /* addition rounding: chops */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07         /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38         /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38         /* min positive value */
#define FLT_MIN_10_EXP  -37                     /* min decimal exponent */
#define FLT_MIN_EXP     -125                    /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      0                       /* addition rounding: chops */

#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min deimal exponent
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define LDBL_RADIX      DBL_RADIX               /* exponent radix */
#define LDBL_ROUNDS     DBL_ROUNDS              /* addition rounding: chops */


/*
 *  8087/80287 math control information
 */


/* User Control Word Mask and bit definitions.
 * These definitions match the 8087/80287
 */

#define     MCW_EM          0x003f      /* interrupt Exception Masks */
#define     EM_INVALID      0x0001      /*   invalid */
#define     EM_DENORMAL     0x0002      /*   denormal */
#define     EM_ZERODIVIDE   0x0004      /*   zero divide */
#define     EM_OVERFLOW     0x0008      /*   overflow */
#define     EM_UNDERFLOW    0x0010      /*   underflow */
#define     EM_INEXACT      0x0020      /*   inexact (precision) */

#define     MCW_IC          0x1000      /* Infinity Control */
#define     IC_AFFINE       0x1000      /*   affine */
#define     IC_PROJECTIVE   0x0000      /*   projective */

#define     MCW_RC          0x0c00      /* Rounding Control */
#define     RC_CHOP         0x0c00      /*   chop */
#define     RC_UP           0x0800      /*   up */
#define     RC_DOWN         0x0400      /*   down */
#define     RC_NEAR         0x0000      /*   near */

#define     MCW_PC          0x0300      /* Precision Control */
#define     PC_24           0x0000      /*    24 bits */
#define     PC_53           0x0200      /*    53 bits */
#define     PC_64           0x0300      /*    64 bits */


/* initial Control Word value */

#define CW_DEFAULT ( IC_AFFINE + RC_NEAR + PC_64 + EM_DENORMAL + EM_UNDERFLOW + EM_INEXACT )


/* user Status Word bit definitions */

#define SW_INVALID          0x0001      /*   invalid */
#define SW_DENORMAL         0x0002      /*   denormal */
#define SW_ZERODIVIDE       0x0004      /*   zero divide */
#define SW_OVERFLOW         0x0008      /*   overflow */
#define SW_UNDERFLOW        0x0010      /*   underflow */
#define SW_INEXACT          0x0020      /*   inexact (precision) */


/* invalid subconditions (SW_INVALID also set) */

#define SW_UNEMULATED       0x0040      /* unemulated instruction */
#define SW_SQRTNEG          0x0080      /* square root of a neg number */
#define SW_STACKOVERFLOW    0x0200      /* FP stack overflow */
#define SW_STACKUNDERFLOW   0x0400      /* FP stack underflow */


/*  Floating point error signals and return codes */

#define FPE_INVALID         0x81
#define FPE_DENORMAL        0x82
#define FPE_ZERODIVIDE      0x83
#define FPE_OVERFLOW        0x84
#define FPE_UNDERFLOW       0x85
#define FPE_INEXACT         0x86

#define FPE_UNEMULATED      0x87
#define FPE_SQRTNEG         0x88
#define FPE_STACKOVERFLOW   0x8a
#define FPE_STACKUNDERFLOW  0x8b

#define FPE_EXPLICITGEN     0x8c    /* raise( SIGFPE ); */

/* function prototypes */

unsigned int _CDECL _clear87(void);
unsigned int _CDECL _control87(unsigned int,unsigned int);
void _CDECL _fpreset(void);
unsigned int _CDECL _status87(void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines constants for the file control options used
*   by the open() function.
*   [System V]
*
*******************************************************************************/

#define O_RDONLY    0x0000  /* open for reading only */
#define O_WRONLY    0x0001  /* open for writing only */
#define O_RDWR      0x0002  /* open for reading and writing */
#define O_APPEND    0x0008  /* writes done at eof */

#define O_CREAT     0x0100  /* create and open file */
#define O_TRUNC     0x0200  /* open and truncate */
#define O_EXCL      0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define O_TEXT      0x4000  /* file mode is text (translated) */
#define O_BINARY    0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define O_RAW   O_BINARY

/* Open handle inherit bit */

#define O_NOINHERIT 0x0080      /* child process doesn't inherit file */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\limits.h ===
/***
*limits.h - implementation dependent values
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   contains defines for a number of implementation dependent values
*   which are commonly used in C programs.
*   [ANSI]
*
*******************************************************************************/

#ifndef _CHAR_UNSIGNED
#define CHAR_MAX         127            /* maximum char value */
#define CHAR_MIN        -127            /* mimimum char value */
#else
#define CHAR_MAX         255
#define CHAR_MIN         0
#endif
#define SCHAR_MAX        127            /* maximum signed char value */
#define SCHAR_MIN       -127            /* minimum signed char value */
#define UCHAR_MAX        255            /* maximum unsigned char value */
#define CHAR_BIT         8              /* number of bits in a char */
#define USHRT_MAX        0xffff         /* maximum unsigned short value */
#define SHRT_MAX         32767          /* maximum (signed) short value */
#define SHRT_MIN        -32767          /* minimum (signed) short value */
#define UINT_MAX         0xffff         /* maximum unsigned int value */
#define ULONG_MAX        0xffffffff     /* maximum unsigned long value */
#define INT_MAX          32767          /* maximum (signed) int value */
#define INT_MIN         -32767          /* minimum (signed) int value */
#define LONG_MAX         2147483647     /* maximum (signed) long value */
#define LONG_MIN        -2147483647     /* minimum (signed) long value */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the low-level
*   file handling and I/O functions.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */

/* function prototypes */

int _CDECL access(char *, int);
int _CDECL chmod(char *, int);
int _CDECL chsize(int, long);
int _CDECL close(int);
int _CDECL creat(char *, int);
int _CDECL dup(int);
int _CDECL dup2(int, int);
int _CDECL eof(int);
long _CDECL filelength(int);
int _CDECL isatty(int);
int _CDECL locking(int, int, long);
long _CDECL lseek(int, long, int);
char * _CDECL mktemp(char *);
int _CDECL open(char *, int, ...);
int _CDECL read(int, char *, unsigned int);
int _CDECL remove(const char *);
int _CDECL rename(const char *, const char *);
int _CDECL setmode(int, int);
int _CDECL sopen(char *, int, int, ...);
long _CDECL tell(int);
int _CDECL umask(int);
int _CDECL unlink(const char *);
int _CDECL write(int, char *, unsigned int);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains the function declarations for memory allocation functions;
*   also defines manifest constants and types used by the heap routines.
*   [System V]
*
*******************************************************************************/


#define _HEAPEMPTY      -1
#define _HEAPOK         -2
#define _HEAPBADBEGIN   -3
#define _HEAPBADNODE    -4
#define _HEAPEND        -5
#define _HEAPBADPTR     -6
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#if (!defined(NO_EXT_KEYS))

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
    int far * _pentry;
    size_t _size;
    int _useflag;
    } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

#else   /* NO_EXT_KEYS */
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))

#ifndef _HEAPINFO_DEFINED

typedef struct _heapinfo {
    int * _pentry;
    size_t _size;
    int _useflag;
    } _HEAPINFO;

#define _HEAPINFO_DEFINED
#endif

#endif  /* M_I86CM || M_I86LM || M_I86HM */

#endif  /* NO_EXT_KEYS */


#if (defined(M_I86SM) || defined(M_I86MM))
#define _heapchk  _nheapchk
#define _heapset  _nheapset
#define _heapwalk _nheapwalk
#endif
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
#define _heapchk  _fheapchk
#define _heapset  _fheapset
#define _heapwalk _fheapwalk
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* external variable declarations */
extern unsigned int _NEAR _CDECL _amblksiz;

/* function prototypes */

void * _CDECL alloca(size_t);
void * _CDECL calloc(size_t, size_t);
void * _CDECL _expand(void *, size_t);
int _CDECL _fheapchk(void);
int _CDECL _fheapset(unsigned int);
unsigned int _CDECL _freect(size_t);
void _CDECL free(void *);
void * _CDECL malloc(size_t);
size_t _CDECL _memavl(void);
size_t _CDECL _memmax(void);
size_t _CDECL _msize(void *);
int _CDECL _nheapchk(void);
int _CDECL _nheapset(unsigned int);
void * _CDECL realloc(void *, size_t);
void * _CDECL sbrk(int);
size_t _CDECL stackavail(void);


#ifndef NO_EXT_KEYS /* extensions enabled */

void cdecl _ffree(void far *);
void far * cdecl _fmalloc(size_t);
size_t cdecl _fmsize(void far *);
#ifndef _QC
void huge * cdecl halloc(long, size_t);
void cdecl hfree(void huge *);
#endif
void cdecl _nfree(void near *);
void near * cdecl _nmalloc(size_t);
size_t cdecl _nmsize(void near *);
int cdecl _nheapwalk(struct _heapinfo *);
int cdecl _fheapwalk(struct _heapinfo *);

#else
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))

int _nheapwalk(struct _heapinfo *);
int _fheapwalk(struct _heapinfo *);

#endif  /* M_I86CM || M_I86LM || M_I86HM */

#endif /* NO_EXT_KEYS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\graph.h ===
/***
*graph.h - declare constants, functions, and macros for graphics library
*
*   Copyright (c) 1987, 1988, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file declares the graphics library functions and
*   the manifest constants that are used with them.
*
***************************************************************************/

/* user-visible declarations for Quick-C Graphics Library */

#ifndef _GRAPH_T_DEFINED
/* structure for _getvideoconfig() as visible to user */
struct videoconfig {
	short numxpixels;	/* number of pixels on X axis */
	short numypixels;	/* number of pixels on Y axis */
	short numtextcols;	/* number of text columns available */
	short numtextrows;	/* number of text rows available */
	short numcolors;	/* number of actual colors */
	short bitsperpixel;	/* number of bits per pixel */
	short numvideopages;	/* number of available video pages */
	short mode;		/* current video mode */
	short adapter;		/* active display adapter */
	short monitor;		/* active display monitor */
	short memory;		/* adapter video memory in K bytes */
};

/* return value of _setvieworg(), etc. */
struct xycoord {
	short xcoord;
	short ycoord;
};

/* structure for text position */
struct rccoord {
	short row;
	short col;
};

/* structure for window coordinate pair */
struct _wxycoord {
	double wx;	/* window x coordinate */
	double wy;	/* window y coordinate */
	};


#define _GRAPH_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
	#define _CDECL	cdecl
	#define _FAR	far
#else /* extensions not enabled */
	#define	_CDECL
	#define _FAR
#endif /* NO_EXT_KEYS */

/* SETUP AND CONFIGURATION */

short _FAR _CDECL _setvideomode(short);
short _FAR _CDECL _setvideomoderows(short,short); /* return rows; 0 if error */

/* arguments to _setvideomode() */
#define _DEFAULTMODE	-1	/* restore screen to original mode */
#define _TEXTBW40	0	/* 40-column text, 16 grey */
#define _TEXTC40	1	/* 40-column text, 16/8 color */
#define _TEXTBW80	2	/* 80-column text, 16 grey */
#define _TEXTC80	3	/* 80-column text, 16/8 color */
#define _MRES4COLOR	4	/* 320 x 200, 4 color */
#define _MRESNOCOLOR	5	/* 320 x 200, 4 grey */
#define _HRESBW		6	/* 640 x 200, BW */
#define _TEXTMONO	7	/* 80-column text, BW */
#define _HERCMONO	8	/* 720 x 348, BW for HGC */
#define _MRES16COLOR	13	/* 320 x 200, 16 color */
#define _HRES16COLOR	14	/* 640 x 200, 16 color */
#define _ERESNOCOLOR	15	/* 640 x 350, BW */
#define _ERESCOLOR	16	/* 640 x 350, 4 or 16 color */
#define _VRES2COLOR	17	/* 640 x 480, BW */
#define _VRES16COLOR	18	/* 640 x 480, 16 color */
#define _MRES256COLOR	19	/* 320 x 200, 256 color */
#define _ORESCOLOR	64	/* 640 x 400, 1 of 16 colors (Olivetti) */

short _FAR _CDECL _setactivepage(short);
short _FAR _CDECL _setvisualpage(short);
short _FAR _CDECL _getactivepage(void);
short _FAR _CDECL _getvisualpage(void);

/* videoconfig adapter values */
/* these manifest constants can be used to determine the type of the active  */
/* adapter, using either simple comparisons or the bitwise-AND operator (&)  */
#define _MDPA		0x0001	/* Monochrome Display Adapter	      (MDPA) */
#define _CGA		0x0002	/* Color Graphics Adapter	      (CGA)  */
#define _EGA		0x0004	/* Enhanced Graphics Adapter	      (EGA)  */
#define _VGA		0x0008	/* Video Graphics Array		      (VGA)  */
#define _MCGA		0x0010	/* MultiColor Graphics Array	      (MCGA) */
#define _HGC		0x0020	/* Hercules Graphics Card	      (HGC)  */
#define _OCGA		0x0042	/* Olivetti Color Graphics Adapter    (OCGA) */
#define _OEGA		0x0044	/* Olivetti Enhanced Graphics Adapter (OEGA) */
#define _OVGA		0x0048	/* Olivetti Video Graphics Array      (OVGA) */

/* videoconfig monitor values */
/* these manifest constants can be used to determine the type of monitor in */
/* use, using either simple comparisons or the bitwise-AND operator (&) */
#define _MONO		0x0001	/* Monochrome */
#define _COLOR		0x0002	/* Color (or Enhanced emulating color) */
#define _ENHCOLOR	0x0004	/* Enhanced Color */
#define _ANALOGMONO	0x0008	/* Analog Monochrome only */
#define _ANALOGCOLOR	0x0010	/* Analog Color only */
#define _ANALOG		0x0018	/* Analog Monochrome and Color modes */

struct videoconfig _FAR * _FAR _CDECL _getvideoconfig(struct videoconfig _FAR *);


/* COORDINATE SYSTEMS */

struct xycoord _FAR _CDECL _setvieworg(short, short);
struct xycoord _FAR _CDECL _setlogorg(short, short); /* obsolescent */

struct xycoord _FAR _CDECL _getviewcoord(short, short);
struct xycoord _FAR _CDECL _getlogcoord(short, short); /* obsolescent */

struct xycoord _FAR _CDECL _getphyscoord(short, short);

void _FAR _CDECL _setcliprgn(short, short, short, short);
void _FAR _CDECL _setviewport(short, short, short, short);


/* OUTPUT ROUTINES */

/* control parameters for Rectangle, Ellipse and Pie */
#define _GBORDER	2	/* draw outline only */
#define _GFILLINTERIOR	3	/* fill using current fill mask */

#define _GCLEARSCREEN	0
#define _GVIEWPORT	1
#define _GWINDOW	2

void _FAR _CDECL _clearscreen(short);

struct xycoord _FAR _CDECL _moveto(short, short);
struct xycoord _FAR _CDECL _getcurrentposition(void);

short _FAR _CDECL _lineto(short, short);
short _FAR _CDECL _rectangle(short, short, short, short, short);
short _FAR _CDECL _ellipse(short, short, short, short, short);
short _FAR _CDECL _arc(short, short, short, short, short, short, short, short);
short _FAR _CDECL _pie(short, short, short, short, short, short, short, short, short);

short _FAR _CDECL _setpixel(short, short);
short _FAR _CDECL _getpixel(short, short);
short _FAR _CDECL _floodfill(short, short, short);


/* PEN COLOR, LINE STYLE, FILL PATTERN */

short _FAR _CDECL _setcolor(short);
short _FAR _CDECL _getcolor(void);

void _FAR _CDECL _setlinestyle(unsigned short);
unsigned short _FAR _CDECL _getlinestyle(void);

void _FAR _CDECL _setfillmask(unsigned char _FAR *);
unsigned char _FAR * _FAR _CDECL _getfillmask(unsigned char _FAR *);

/* COLOR SELECTION */

long _FAR _CDECL _setbkcolor(long);
long _FAR _CDECL _getbkcolor(void);

long _FAR _CDECL _remappalette(short, long);
short _FAR _CDECL _remapallpalette(long _FAR *);
short _FAR _CDECL _selectpalette(short);


/* TEXT */
#define _GCURSOROFF	0
#define _GCURSORON	1

#define _GWRAPOFF	0
#define _GWRAPON	1

short _FAR _CDECL _settextrows(short); /* returns # rows set; 0 if error */
void _FAR _CDECL _settextwindow(short, short, short, short);
void _FAR _CDECL _outtext(unsigned char _FAR *);
short _FAR _CDECL _wrapon(short);

short _FAR _CDECL _displaycursor(short);
short _FAR _CDECL _settextcursor(short);
short _FAR _CDECL _gettextcursor(void);

struct rccoord _FAR _CDECL _settextposition(short, short);
struct rccoord _FAR _CDECL _gettextposition(void);

short _FAR _CDECL _settextcolor(short);
short _FAR _CDECL _gettextcolor(void);


/* SCREEN IMAGES */

void _FAR _CDECL _getimage(short, short, short, short, char _FAR *);
void _FAR _CDECL _putimage(short, short, char _FAR *, short);
long _FAR _CDECL _imagesize(short, short, short, short);

/* "action verbs" for _putimage() */
#define _GPSET		3
#define _GPRESET	2
#define _GAND		1
#define _GOR		0
#define _GXOR		4

/* universal color values: */
#define _BLACK		0x000000L
#define _BLUE		0x2a0000L
#define _GREEN		0x002a00L
#define _CYAN		0x2a2a00L
#define _RED		0x00002aL
#define _MAGENTA	0x2a002aL
#define _BROWN		0x00152aL
#define _WHITE		0x2a2a2aL
#define _GRAY		0x151515L
#define _LIGHTBLUE	0x3F1515L
#define _LIGHTGREEN	0x153f15L
#define _LIGHTCYAN	0x3f3f15L
#define _LIGHTRED	0x15153fL
#define _LIGHTMAGENTA	0x3f153fL
#define _LIGHTYELLOW	0x153f3fL
#define _BRIGHTWHITE	0x3f3f3fL

/* mono mode F color values: */
#define _MODEFOFF	0L
#define _MODEFOFFTOON	1L
#define _MODEFOFFTOHI	2L
#define _MODEFONTOOFF	3L
#define _MODEFON	4L
#define _MODEFONTOHI	5L
#define _MODEFHITOOFF	6L
#define _MODEFHITOON	7L
#define _MODEFHI	8L

/* mono mode 7 color values: */
#define _MODE7OFF	0L
#define _MODE7ON	1L
#define _MODE7HI	2L


/* define real coordinate window - returns non-zero if successful */
short _FAR _CDECL _setwindow(short,double,double,double,double);

/* convert from view to window coordinates */
struct _wxycoord _FAR _CDECL _getwindowcoord(short,short);
struct _wxycoord _FAR _CDECL _getwindowcoord_xy(struct xycoord);

/* convert from window to view coordinates */
struct xycoord _FAR _CDECL _getviewcoord_w(double,double);
struct xycoord _FAR _CDECL _getviewcoord_wxy(struct _wxycoord _FAR *);

/*	return the window coordinates of the current graphics output
	position as an _wxycoord structure. no error return. */
struct _wxycoord _FAR _CDECL _getcurrentposition_w(void);


/* window coordinate entry points for graphics output routines */

#define _arc_wxy(pwxy1, pwxy2, pwxy3, pwxy4) \
	_arc_xy(_getviewcoord_wxy(pwxy1), _getviewcoord_wxy(pwxy2), \
		_getviewcoord_wxy(pwxy3), _getviewcoord_wxy(pwxy4))

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _arc_xy(struct xycoord,struct xycoord,struct xycoord,struct xycoord);

#define _ellipse_w(control, wx1, wy1, wx2, wy2) _ellipse_xy(control, \
		_getviewcoord_w(wx1,wy1), _getviewcoord_w(wx2,wy2))

#define _ellipse_wxy(control, pwxy1, pwxy2) _ellipse_xy(control, \
	_getviewcoord_wxy(pwxy1), _getviewcoord_wxy(pwxy2))

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _ellipse_xy(short,struct xycoord,struct xycoord);


#define _floodfill_w(wx, wy, boundary) \
	_floodfill_xy(_getviewcoord_w(wx,wy), boundary)

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _floodfill_xy(struct xycoord, short);


#define _getpixel_w(wx, wy) \
	_getpixel_xy(_getviewcoord_w(wx,wy))

/*	returns pixel value at given point; -1 if unsuccessful. */
short _FAR _CDECL _getpixel_xy(struct xycoord);


#define _lineto_w(wx, wy) \
	_lineto_xy(_getviewcoord_w(wx,wy))

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _lineto_xy(struct xycoord);


#define _moveto_w(wx, wy) \
	_getwindowcoord_xy(_moveto_xy(_getviewcoord_w(wx,wy)))

/*	returns the view coordinates of the previous output
	position as an _xycoord structure. no error return */
struct xycoord _FAR _CDECL _moveto_xy(struct xycoord);


#define _pie_wxy(control, pwxy1, pwxy2, pwxy3, pwxy4) _pie_xy(control, \
		_getviewcoord_wxy(pwxy1), _getviewcoord_wxy(pwxy2), \
		_getviewcoord_wxy(pwxy3), _getviewcoord_wxy(pwxy4))

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _pie_xy(short,struct xycoord,struct xycoord,struct xycoord,struct xycoord);


#define _rectangle_w(control, wx1, wy1, wx2, wy2) _rectangle_xy(control, \
		_getviewcoord_w(wx1,wy1), _getviewcoord_w(wx2,wy2))

#define _rectangle_wxy(control, pwxy1, pwxy2) _rectangle_xy(control, \
		_getviewcoord_wxy(pwxy1), _getviewcoord_wxy(pwxy2))

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _rectangle_xy(short,struct xycoord,struct xycoord);


#define _setpixel_w(wx, wy) \
	_setpixel_xy(_getviewcoord_w(wx,wy))

/*	returns previous color; -1 if unsuccessful */
short _FAR _CDECL _setpixel_xy(struct xycoord);


/* window coordinate image routines */
#define _getimage_w( wx1, wy1, wx2, wy2, buffer) \
		_getimage_xy( _getviewcoord_w(wx1,wy1), \
		_getviewcoord_w(wx2,wy2), buffer)

#define _getimage_wxy( pwxy1, pwxy2, buffer) \
		_getimage_xy( _getviewcoord_wxy(pwxy1), \
		_getviewcoord_wxy(pwxy2), buffer)

/*	no return value */
void _FAR _CDECL _getimage_xy(struct xycoord,struct xycoord, char _FAR *);


#define _imagesize_w( wx1, wy1, wx2, wy2) _imagesize_xy( \
		_getviewcoord_w(wx1,wy1), _getviewcoord_w(wx2,wy2))

#define _imagesize_wxy( pwxy1, pwxy2) _imagesize_xy( \
		_getviewcoord_wxy(pwxy1), _getviewcoord_wxy(pwxy2))

/*	returns the image's storage size in bytes */
long _FAR _CDECL _imagesize_xy(struct xycoord,struct xycoord);


#define _putimage_w(wx, wy, image, action) \
	_putimage_xy(_getviewcoord_w(wx,wy), image, action)

/*	no return value */
void _FAR _CDECL _putimage_xy(struct xycoord,char _FAR *,short);


/* FONTS */

struct _fontinfo {
	int	Type;		/* b0 set = vector,clear = bit map	*/
	int	Ascent;		/* pix dist from top to baseline	*/
	int	PixWidth;	/* character width in pixels, 0=prop	*/
	int	PixHeight;	/* character height in pixels		*/
	int	AvgWidth;	/* average character width in pixels	*/
	char	FileName[66];	/* file name including path		*/
	char	FaceName[32];	/* font name				*/
	};
typedef struct _fontinfo _fontdisc;

short	_FAR _CDECL	_registerfonts( unsigned char _FAR *);
void	_FAR _CDECL	_unregisterfonts( void );
short	_FAR _CDECL	_setfont( unsigned char _FAR * );
short	_FAR _CDECL	_getfontinfo( _fontdisc _FAR * );
void	_FAR _CDECL	_outgtext( unsigned char _FAR * );
short	_FAR _CDECL	_getgtextextent( unsigned char _FAR * );
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the
*   buffer (memory) manipulation routines.
*   [System V]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */


/* function prototypes */

void * _CDECL memccpy(void *, void *, int, unsigned int);
void * _CDECL memchr(const void *, int, size_t);
int _CDECL memcmp(const void *, const void *, size_t);
void * _CDECL memcpy(void *, const void *, size_t);
int _CDECL memicmp(void *, void *, unsigned int);
void * _CDECL memset(void *, int, size_t);
void _CDECL movedata(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the modeflag values for spawnxx calls.  Only
*   P_WAIT and P_OVERLAY are currently implemented on DOS 2 & 3.
*   P_NOWAIT is also enabled on DOS 4.  Also contains the function
*   argument declarations for all process control related routines.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* modeflag values for spawnxx routines */

extern int _NEAR _CDECL _p_overlay;

#define P_WAIT      0
#define P_NOWAIT    1
#define P_OVERLAY   _p_overlay
#define OLD_P_OVERLAY  2
#define P_NOWAITO   3


/* Action Codes used with Cwait() */

#define WAIT_CHILD 0
#define WAIT_GRANDCHILD 1


/* function prototypes */

void _CDECL abort(void);
int _CDECL cwait(int *, int, int);
int _CDECL execl(char *, char *, ...);
int _CDECL execle(char *, char *, ...);
int _CDECL execlp(char *, char *, ...);
int _CDECL execlpe(char *, char *, ...);
int _CDECL execv(char *, char * *);
int _CDECL execve(char *, char * *, char * *);
int _CDECL execvp(char *, char * *);
int _CDECL execvpe(char *, char * *, char * *);
void _CDECL exit(int);
void _CDECL _exit(int);
int _CDECL getpid(void);
int _CDECL spawnl(int, char *, char *, ...);
int _CDECL spawnle(int, char *, char *, ...);
int _CDECL spawnlp(int, char *, char *, ...);
int _CDECL spawnlpe(int, char *, char *, ...);
int _CDECL spawnv(int, char *, char * *);
int _CDECL spawnve(int, char *, char * *, char * *);
int _CDECL spawnvp(int, char *, char * *);
int _CDECL spawnvpe(int, char *, char * *, char * *);
int _CDECL system(const char *);
int _CDECL wait(int *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\os2def.h ===
/***************************************************************************\
*
* Module Name: OS2DEF.H
*
* OS/2 Common Definitions file
*
* This file is compatible with OS/2 version 1.0.
*
* Copyright (c) 1988  IBM Corporation
* Copyright (c) 1988  Microsoft Corporation
*
\***************************************************************************/

#define PASCAL  pascal
#define FAR     far
#define NEAR    near
#define VOID    void

typedef unsigned short SHANDLE;
typedef void far      *LHANDLE;

#define EXPENTRY pascal far
#define APIENTRY pascal far

#define CHAR    char            /* ch  */
#define SHORT   int             /* s   */
#define LONG    long            /* l   */
#define INT     int             /* i   */

typedef unsigned char UCHAR;    /* uch */
typedef unsigned int  USHORT;   /* us  */
typedef unsigned long ULONG;    /* ul  */
typedef unsigned int  UINT;     /* ui  */

typedef unsigned char BYTE;     /* b   */

typedef char far *PSZ;
typedef char     *NPSZ;

typedef char far *PCH;
typedef char     *NPCH;

typedef int   (pascal far  *PFN)();
typedef int   (pascal near *NPFN)();
typedef int   (pascal far * far *PPFN)();

typedef BYTE   FAR *PBYTE;
typedef BYTE       *NPBYTE;

typedef CHAR   FAR *PCHAR;
typedef SHORT  FAR *PSHORT;
typedef LONG   FAR *PLONG;
typedef INT    FAR *PINT;

typedef UCHAR  FAR *PUCHAR;
typedef USHORT FAR *PUSHORT;
typedef ULONG  FAR *PULONG;
typedef UINT   FAR *PUINT;

typedef VOID   FAR *PVOID;

typedef unsigned short BOOL;    /* f */
typedef BOOL FAR *PBOOL;

#define FALSE   0
#define TRUE    1

typedef unsigned short SEL;     /* sel */
typedef SEL FAR *PSEL;

typedef SHANDLE HFILE;          /* hf */
typedef HFILE FAR *PHFILE;

/*
 * The HSEM type is used in structures and functions that take both
 * a system semaphore handle, or a far pointer to a RAM semaphore.
 * It is declared as VOID FAR * so that the use of both types of
 * semaphores will not result in a compiler warning.
 */
typedef VOID FAR *HSEM;         /* hsem */
typedef HSEM FAR *PHSEM;

/*** Useful Helper Macros */

/* Create untyped far pointer from selector and offset */
#define MAKEP(sel, off)     ((PVOID)MAKEULONG(off, sel))

/* Extract selector or offset from far pointer */
#define SELECTOROF(p)       (((PUSHORT)&(p))[1])
#define OFFSETOF(p)         (((PUSHORT)&(p))[0])

/* Cast any variable to an instance of the specified type. */
#define MAKETYPE(v, type)   (*((type far *)&v))

/* Calculate the byte offset of a field in a structure of type type. */
#define FIELDOFFSET(type, field)    ((SHORT)&(((type *)0)->field))

/* Combine l & h to form a 32 bit quantity. */
#define MAKEULONG(l, h)  ((ULONG)(((USHORT)(l)) | ((ULONG)((USHORT)(h))) << 16))
#define MAKELONG(l, h)   ((LONG)MAKEULONG(l, h))

/* Combine l & h to form a 16 bit quantity. */
#define MAKEUSHORT(l, h) (((USHORT)(l)) | ((USHORT)(h)) << 8)
#define MAKESHORT(l, h)  ((SHORT)MAKEUSHORT(l, h))

/* Extract high and low order parts of 16 and 32 bit quantity */
#define LOBYTE(w)       LOUCHAR(w)
#define HIBYTE(w)       HIUCHAR(w)
#define LOUCHAR(w)      ((UCHAR)(w))
#define HIUCHAR(w)      (((USHORT)(w) >> 8) & 0xff)
#define LOUSHORT(l)     ((USHORT)(l))
#define HIUSHORT(l)     ((USHORT)(((ULONG)(l) >> 16) & 0xffff))

/*** Common Error definitions ****/

typedef ULONG ERRORID;  /* errid */
typedef ERRORID FAR *PERRORID;

/* Combine severity and error code to produce ERRORID */
#define MAKEERRORID(sev, error) (ERRORID)(MAKEULONG((error), (sev)))

/* Severity codes */
#define SEVERITY_NOERROR                    0x0000
#define SEVERITY_WARNING                    0x0004
#define SEVERITY_ERROR                      0x0008
#define SEVERITY_SEVERE                     0x000C
#define SEVERITY_UNRECOVERABLE              0x0010

/* Base component error values */

#define WINERR_BASE     0x1000  /* Window Manager                  */
#define GPIERR_BASE     0x2000  /* Graphics Presentation Interface */
#define DEVERR_BASE     0x3000  /* Device Manager                  */
#define SPLERR_BASE     0x4000  /* Spooler                         */

/*** Common types used across components */

/*** Common DOS types */

typedef USHORT    HMODULE;  /* hmod */
typedef HMODULE FAR *PHMODULE;

typedef USHORT    PID;      /* pid  */
typedef PID FAR *PPID;

typedef USHORT    TID;      /* tid  */
typedef TID FAR *PTID;

/*** Common SUP types */

typedef LHANDLE   HAB;      /* hab  */
typedef HAB FAR *PHAB;

/*** Common GPI/DEV types */

typedef LHANDLE   HPS;      /* hps  */
typedef HPS FAR *PHPS;

typedef LHANDLE   HDC;      /* hdc  */
typedef HDC FAR *PHDC;

typedef LHANDLE   HRGN;     /* hrgn */
typedef HRGN FAR *PHRGN;

typedef LHANDLE   HBITMAP;  /* hbm  */
typedef HBITMAP FAR *PHBITMAP;

typedef LHANDLE   HMF;      /* hmf  */
typedef HMF FAR *PHMF;

typedef ULONG     COLOR;    /* clr  */
typedef COLOR FAR *PCOLOR;

/* common DOS/SHL types */

/* File time and date types */

typedef struct _FTIME {         /* ftime */
    unsigned twosecs : 5;
    unsigned minutes : 6;
    unsigned hours   : 5;
} FTIME;
typedef FTIME FAR *PFTIME;

typedef struct _FDATE {         /* fdate */
    unsigned day     : 5;
    unsigned month   : 4;
    unsigned year    : 7;
} FDATE;
typedef FDATE FAR *PFDATE;

typedef struct _FILEFINDBUF {   /* findbuf */
    FDATE  fdateCreation;
    FTIME  ftimeCreation;
    FDATE  fdateLastAccess;
    FTIME  ftimeLastAccess;
    FDATE  fdateLastWrite;
    FTIME  ftimeLastWrite;
    ULONG  cbFile;
    ULONG  cbFileAlloc;
    USHORT attrFile;
    UCHAR  cchName;
    CHAR   achName[13];
} FILEFINDBUF;
typedef FILEFINDBUF FAR *PFILEFINDBUF;

/*** Common WIN types */

typedef LHANDLE HWND;      /* hwnd */
typedef HWND FAR *PHWND;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\os2.h ===
/****************************** Module Header ******************************\
*
* Module Name: OS2.H
*
* This is the top level include file that includes all the files necessary
* for writing an OS/2 application.
*
* This file is compatible with OS/2 version 1.0.
*
* Copyright (c) 1988  Microsoft Corporation
* Copyright (c) 1988  IBM Corporation
*
\***************************************************************************/

#define OS2_INCLUDED

/* Common definitions */

#include "os2def.h"

/* OS/2 Base Include File */

#include "bse.h"

/* OS/2 Presentation Manager Include File */

/* pm.h is for future versions of OS/2, not needed for v. 1.0 */
/* #include "pm.h" */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the machine-dependent buffer used by
*   setjmp/longjmp to save and restore the program state, and
*   declarations for those routines.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */


/* define the buffer type for holding the state information */

#define _JBLEN  9  /* bp, di, si, sp, ret addr, ds */

#ifndef _JMP_BUF_DEFINED
typedef  int  jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* function prototypes */

int _CDECL setjmp(jmp_buf);
void _CDECL longjmp(jmp_buf, int);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the declarations for the sorting and
*   searching routines.
*   [System V]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */


/* function prototypes */

char * _CDECL lsearch(char *, char *, unsigned int *, unsigned int, int (_CDECL *)(void *, void *));
char * _CDECL lfind(char *, char *, unsigned int *, unsigned int, int (_CDECL *)(void *, void *));
void * _CDECL bsearch(const void *, const void *, size_t, size_t, int (_CDECL *)(const void *, const void *));
void _CDECL qsort(void *, size_t, size_t, int (_CDECL *)(const void *, const void *));
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\math.h ===
/***
*math.h - definitions and declarations for math library
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains constant definitions and external subroutine
*   declarations for the math subroutine library.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL   cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */


/* definition of exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct exception {
    int type;           /* exception type - see below */
    char *name;   /* name of function where error occured */
    double arg1;        /* first argument to function */
    double arg2;        /* second argument (if any) to function */
    double retval;      /* value to be returned by function */
    } ;
#define _EXCEPTION_DEFINED
#endif


/* definition of a complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct complex {
    double x,y;     /* real and imaginary parts */
    } ;
#define _COMPLEX_DEFINED
#endif


/* Constant definitions for the exception type passed in the exception struct
 */

#define DOMAIN      1   /* argument domain error */
#define SING        2   /* argument singularity */
#define OVERFLOW    3   /* overflow range error */
#define UNDERFLOW   4   /* underflow range error */
#define TLOSS       5   /* total loss of precision */
#define PLOSS       6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* definitions of HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */

extern double HUGE;
#define HUGE_VAL HUGE



/* function prototypes */

int    _CDECL abs(int);
double _CDECL acos(double);
double _CDECL asin(double);
double _CDECL atan(double);
double _CDECL atan2(double, double);
double _CDECL atof(const char *);
double _CDECL cabs(struct complex);
double _CDECL ceil(double);
double _CDECL cos(double);
double _CDECL cosh(double);
int    _CDECL dieeetomsbin(double *, double *);
int    _CDECL dmsbintoieee(double *, double *);
double _CDECL exp(double);
double _CDECL fabs(double);
int    _CDECL fieeetomsbin(float *, float *);
double _CDECL floor(double);
double _CDECL fmod(double, double);
int    _CDECL fmsbintoieee(float *, float *);
double _CDECL frexp(double, int *);
double _CDECL hypot(double, double);
double _CDECL j0(double);
double _CDECL j1(double);
double _CDECL jn(int, double);
long   _CDECL labs(long);
double _CDECL ldexp(double, int);
double _CDECL log(double);
double _CDECL log10(double);
int    _CDECL matherr(struct exception *);
double _CDECL modf(double, double *);
double _CDECL pow(double, double);
double _CDECL sin(double);
double _CDECL sinh(double);
double _CDECL sqrt(double);
double _CDECL tan(double);
double _CDECL tanh(double);
double _CDECL y0(double);
double _CDECL y1(double);
double _CDECL yn(int, double);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the file sharing modes for sopen().
*
*******************************************************************************/

#define SH_COMPAT   0x00    /* compatibility mode */
#define SH_DENYRW   0x10    /* deny read/write mode */
#define SH_DENYWR   0x20    /* deny write mode */
#define SH_DENYRD   0x30    /* deny read mode */
#define SH_DENYNO   0x40    /* deny none mode */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines ANSI-style macros for accessing arguments
*   of functions which take a variable number of arguments.
*   [ANSI]
*
*******************************************************************************/

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif

#define va_start(ap,v) ap = (va_list)&v + sizeof(v)
#define va_arg(ap,t) ((t *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\signal.h ===
/***
*signal.h - defines signal values and routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the signal values and declares the signal functions.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif


#define NSIG 23     /* maximum signal number + 1 */

/* signal types */
/* SIGINT, SIGFPE, SIGILL, SIGSEGV, and SIGABRT are recognized on DOS 3.x */

#define SIGINT      2   /* interrupt - corresponds to DOS 3.x int 23H */
#define SIGILL      4   /* illegal instruction - invalid function image */
#define SIGFPE      8   /* floating point exception */
#define SIGSEGV     11  /* segment violation */
#define SIGTERM     15  /* Software termination signal from kill */
#define SIGUSR1     16  /* User defined signal 1 */
#define SIGUSR2     17  /* User defined signal 2 */
#define SIGUSR3     20  /* User defined signal 3 */
#define SIGBREAK    21  /* Ctrl-Break sequence */
#define SIGABRT     22  /* abnormal termination triggered by abort call */


/* signal action codes */
/* SIG_DFL and SIG_IGN are recognized on DOS 3.x */

#define SIG_DFL (void (*)())0 /* default signal action */
#define SIG_IGN (void (*)())1 /* ignore */
#define SIG_SGE (void (*)())3 /* signal gets error */
#define SIG_ACK (void (*)())4 /* error if handler not setup */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (*)())-1    /* signal error value */


/* function prototypes */

void (_CDECL * _CDECL signal(int, void (_CDECL *)()))();
int _CDECL raise(int);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains definitions and declarations for some commonly
*   used constants, types, and variables.
*   [ANSI]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* define NULL pointer value */

#if (defined(M_I86SM) || defined(M_I86MM))
#define  NULL    0
#elif (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
#define  NULL    0L
#endif


/* declare reference to errno */

extern int _NEAR _CDECL errno;


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   used by the level 2 I/O ("standard I/O") routines.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* buffered I/O macros */

#define  BUFSIZ  512
#define  _NFILE  20
#define  EOF     (-1)

#ifndef _FILE_DEFINED
#define  FILE    struct _iobuf
#define _FILE_DEFINED
#endif

/* P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of P_tmpdir
 *      + 1 (in case P_tmpdir does not end in "\\")
 *      + 6 (for the temp number string)
 *      + 1 (for the null terminator)
 */

#define  P_tmpdir "\\"
#define  L_tmpnam sizeof(P_tmpdir)+8

#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define  SYS_OPEN 20
#define  TMP_MAX  32767


/* define NULL pointer value */

#if (defined(M_I86SM) || defined(M_I86MM))
#define  NULL    0
#elif (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
#define  NULL    0L
#endif


/* define file control block */

#ifndef _IOB_DEFINED
extern FILE {
    char *_ptr;
    int   _cnt;
    char *_base;
    char  _flag;
    char  _file;
    } _NEAR _CDECL _iob[];
#define _IOB_DEFINED
#endif

#define  fpos_t  long   /* file position variable */

#define  stdin  (&_iob[0])
#define  stdout (&_iob[1])
#define  stderr (&_iob[2])
#define  stdaux (&_iob[3])
#define  stdprn (&_iob[4])

#define  _IOREAD    0x01
#define  _IOWRT     0x02

#define  _IOFBF     0x0
#define  _IOLBF     0x40
#define  _IONBF     0x04

#define  _IOMYBUF   0x08
#define  _IOEOF     0x10
#define  _IOERR     0x20
#define  _IOSTRG    0x40
#define  _IORW      0x80

#define getc(f)         (--(f)->_cnt >= 0 ? 0xff & *(f)->_ptr++ : _filbuf(f))
#define putc(c,f)       (--(f)->_cnt >= 0 ? 0xff & (*(f)->_ptr++ = (char)(c)) \
                        :  _flsbuf((c),(f)))
#define getchar()       getc(stdin)
#define putchar(c)      putc((c),stdout)

#define feof(f)         ((f)->_flag & _IOEOF)
#define ferror(f)       ((f)->_flag & _IOERR)
#define fileno(f)       ((f)->_file)


/* function prototypes */

int _CDECL _filbuf(FILE *);
int _CDECL _flsbuf(int, FILE *);
void _CDECL clearerr(FILE *);
int _CDECL fclose(FILE *);
int _CDECL fcloseall(void);
FILE * _CDECL fdopen(int, char *);
int _CDECL fflush(FILE *);
int _CDECL fgetc(FILE *);
int _CDECL fgetchar(void);
int _CDECL fgetpos(FILE *, fpos_t *);
char * _CDECL fgets(char *, int, FILE *);
int _CDECL flushall(void);
FILE * _CDECL fopen(const char *, const char *);
int _CDECL fprintf(FILE *, const char *, ...);
int _CDECL fputc(int, FILE *);
int _CDECL fputchar(int);
int _CDECL fputs(const char *, FILE *);
size_t _CDECL fread(void *, size_t, size_t, FILE *);
FILE * _CDECL freopen(const char *, const char *, FILE *);
int _CDECL fscanf(FILE *, const char *, ...);
int _CDECL fsetpos(FILE *, const fpos_t *);
int _CDECL fseek(FILE *, long, int);
long _CDECL ftell(FILE *);
size_t _CDECL fwrite(const void *, size_t, size_t, FILE *);
char * _CDECL gets(char *);
int _CDECL getw(FILE *);
void _CDECL perror(const char *);
int _CDECL printf(const char *, ...);
int _CDECL puts(const char *);
int _CDECL putw(int, FILE *);
int _CDECL remove(const char *);
int _CDECL rename(const char *, const char *);
void _CDECL rewind(FILE *);
int _CDECL rmtmp(void);
int _CDECL scanf(const char *, ...);
void _CDECL setbuf(FILE *, char *);
int _CDECL setvbuf(FILE *, char *, int, size_t);
int _CDECL sprintf(char *, const char *, ...);
int _CDECL sscanf(const char *, const char *, ...);
char * _CDECL tempnam(char *, char *);
FILE * _CDECL tmpfile(void);
char * _CDECL tmpnam(char *);
int _CDECL ungetc(int, FILE *);
int _CDECL unlink(const char *);
int _CDECL vfprintf(FILE *, const char *, va_list);
int _CDECL vprintf(const char *, va_list);
int _CDECL vsprintf(char *, const char *, va_list);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file has declarations of time routines and defines
*   the structure returned by the localtime and gmtime routines and
*   used by asctime.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* define the implementation defined time type */

#ifndef _TIME_T_DEFINED
typedef long time_t;            /* time value */
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
    int tm_sec;         /* seconds after the minute - [0,59] */
    int tm_min;         /* minutes after the hour - [0,59] */
    int tm_hour;        /* hours since midnight - [0,23] */
    int tm_mday;        /* day of the month - [1,31] */
    int tm_mon;         /* months since January - [0,11] */
    int tm_year;        /* years since 1900 */
    int tm_wday;        /* days since Sunday - [0,6] */
    int tm_yday;        /* days since January 1 - [0,365] */
    int tm_isdst;       /* daylight savings time flag */
    };
#define _TM_DEFINED
#endif

#define CLK_TCK 1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

extern int _NEAR _CDECL daylight;     /* non-zero if daylight savings time is used */
extern long _NEAR _CDECL timezone;    /* difference in seconds between GMT and local time */
extern char * _NEAR _CDECL tzname[2]; /* standard/daylight savings time zone names */


/* function prototypes */

char * _CDECL asctime(const struct tm *);
char * _CDECL ctime(const time_t *);
clock_t _CDECL clock(void);
double _CDECL difftime(time_t, time_t);
struct tm * _CDECL gmtime(const time_t *);
struct tm * _CDECL localtime(const time_t *);
time_t _CDECL mktime(struct tm *);
char * _CDECL _strdate(char *);
char * _CDECL _strtime(char *);
time_t _CDECL time(time_t *);
void _CDECL tzset(void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\style.h ===
/* Window styles */
#define WS_TILED        0x00000000L
#define WS_ICONICPOPUP  0xc0000000L
#define WS_POPUP        0x80000000L
#define WS_CHILD        0x40000000L
#define WS_MINIMIZE     0x20000000L
#define WS_VISIBLE      0x10000000L
#define WS_DISABLED     0x08000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_MAXIMIZE     0x01000000L

#define WS_BORDER       0x00800000L
#define WS_CAPTION      0x00c00000L
#define WS_DLGFRAME     0x00400000L
#define WS_VSCROLL      0x00200000L
#define WS_HSCROLL      0x00100000L
#define WS_SYSMENU      0x00080000L
#define WS_SIZEBOX      0x00040000L
#define WS_GROUP        0x00020000L
#define WS_TABSTOP      0x00010000L

#define WS_ICONIC       WS_MINIMIZE

/* Class styles */
#define CS_VREDRAW      0x0001
#define CS_HREDRAW      0x0002
#define CS_KEYCVTWINDOW 0x0004
#define CS_DBLCLKS      0x0008
#define CS_OEMCHARS     0x0010
#define CS_OWNDC        0x0020
#define CS_CLASSDC      0x0040
#define CS_MENUPOPUP    0x0080
#define CS_NOKEYCVT     0x0100
#define CS_SAVEBITS     0x0800

/* Shorthand for the common cases */
#define WS_TILEDWINDOW   (WS_TILED | WS_CAPTION | WS_SYSMENU | WS_SIZEBOX)
#define WS_POPUPWINDOW   (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW   (WS_CHILD)

/* Edit control styles */
#define ES_LEFT           0L
#define ES_CENTER         1L
#define ES_RIGHT          2L
#define ES_MULTILINE      4L
#define ES_AUTOVSCROLL    64L
#define ES_AUTOHSCROLL    128L
#define ES_NOHIDESEL      256L

/* button control styles */
#define BS_PUSHBUTTON    0L
#define BS_DEFPUSHBUTTON 1L
#define BS_CHECKBOX      2L
#define BS_AUTOCHECKBOX  3L
#define BS_RADIOBUTTON   4L
#define BS_3STATE        5L
#define BS_AUTO3STATE    6L
#define BS_GROUPBOX      7L
#define BS_USERBUTTON    8L
#define BS_AUTORADIOBUTTON 9L
#define BS_PUSHBOX       10L
#define BS_LEFTTEXT      0x20L

/* Dialog style bits */
#define DS_ABSALIGN   0x000000001L
#define DS_SYSMODAL   0x000000002L
#define DS_LOCALEDIT  0x000000020L  /* Edit items get Local storage. */

/* listbox style bits */
#define LBS_NOTIFY        0x0001L
#define LBS_SORT          0x0002L
#define LBS_NOREDRAW      0x0004L
#define LBS_MULTIPLESEL   0x0008L
#define LBS_STANDARD      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

/* scroll bar styles */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L

/* Conventional dialog box and message box command IDs */
#define IDOK         1
#define IDCANCEL     2
#define IDABORT      3
#define IDRETRY      4
#define IDIGNORE     5
#define IDYES        6
#define IDNO         7

/* Static control constants */
#define SS_LEFT       0L
#define SS_CENTER     1L
#define SS_RIGHT      2L
#define SS_ICON       3L
#define SS_BLACKRECT  4L
#define SS_GRAYRECT   5L
#define SS_WHITERECT  6L
#define SS_BLACKFRAME 7L
#define SS_GRAYFRAME  8L
#define SS_WHITEFRAME 9L
#define SS_USERITEM   10L

/* Virtual Keys, Standard Set */

#define VK_LBUTTON  0x01
#define VK_RBUTTON  0x02
#define VK_CANCEL   0x03
#define VK_MBUTTON  0x04    /* NOT contiguous with L & RBUTTON */
#define VK_BACK     0x08
#define VK_TAB      0x09
#define VK_CLEAR    0x0c
#define VK_RETURN   0x0d
#define VK_SHIFT    0x10
#define VK_CONTROL  0x11
#define VK_MENU     0x12
#define VK_PAUSE    0x13
#define VK_CAPITAL  0x14
#define VK_ESCAPE   0x1b
#define VK_SPACE    0x20

#define VK_PRIOR    0x21
#define VK_NEXT     0x22
#define VK_END      0x23
#define VK_HOME     0x24
#define VK_LEFT     0x25
#define VK_UP       0x26
#define VK_RIGHT    0x27
#define VK_DOWN     0x28

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#define VK_SELECT   0x29
#define VK_PRINT    0x2a
#define VK_EXECUTE  0x2b
#define VK_INSERT   0x2d
#define VK_DELETE   0x2e
#define VK_HELP     0x2f

#define VK_NUMPAD0  0x60
#define VK_NUMPAD1  0x61
#define VK_NUMPAD2  0x62
#define VK_NUMPAD3  0x63
#define VK_NUMPAD4  0x64
#define VK_NUMPAD5  0x65
#define VK_NUMPAD6  0x66
#define VK_NUMPAD7  0x67
#define VK_NUMPAD8  0x68
#define VK_NUMPAD9  0x69
#define VK_MULTIPLY 0x6A
#define VK_ADD      0x6B
#define VK_SEPARATOR 0x6C
#define VK_SUBTRACT 0x6D
#define VK_DECIMAL  0x6E
#define VK_DIVIDE   0x6F

#define VK_F1       0x70
#define VK_F2       0x71
#define VK_F3       0x72
#define VK_F4       0x73
#define VK_F5       0x74
#define VK_F6       0x75
#define VK_F7       0x76
#define VK_F8       0x77
#define VK_F9       0x78
#define VK_F10      0x79
#define VK_F11      0x7a
#define VK_F12      0x7b
#define VK_F13      0x7c
#define VK_F14      0x7d
#define VK_F15      0x7e
#define VK_F16      0x7f
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines XENIX style macros for accessing arguments of a
*   function which takes a variable number of arguments.
*   [System V]
*
*******************************************************************************/

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ((t *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   commonly used library functions which either don't fit somewhere
*   else, or, like toupper/tolower, can't be declared in the normal
*   place (ctype.h in the case of toupper/tolower) for other reasons.
*   [ANSI]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
    #define _NEAR   near
#else /* extensions not enabled */
    #define _CDECL
    #define _NEAR
#endif /* NO_EXT_KEYS */


/* definition of the return type for the onexit() function */

#ifndef _ONEXIT_T_DEFINED
typedef int (_CDECL * _CDECL onexit_t)();
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct {
    int quot;
    int rem;
} div_t;

typedef struct {
    long quot;
    long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff


/* min and max macros */

#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH      144      /* max. length of full pathname */
#define _MAX_DRIVE   3      /* max. length of drive component */
#define _MAX_DIR       130      /* max. length of path component */
#define _MAX_FNAME   9      /* max. length of file name component */
#define _MAX_EXT     5      /* max. length of extension component */

/* external variable declarations */

extern int _NEAR _CDECL errno;              /* XENIX style error number */
extern int _NEAR _CDECL _doserrno;          /* MS-DOS system error value */
extern char * _NEAR _CDECL sys_errlist[];   /* perror error message table */
extern int _NEAR _CDECL sys_nerr;           /* # of entries in sys_errlist table */

extern char ** _NEAR _CDECL environ;        /* pointer to environment table */

extern unsigned int _NEAR _CDECL _psp;      /* Program Segment Prefix */

extern int _NEAR _CDECL _fmode;             /* default file translation mode */

/* DOS major/minor version numbers */

extern unsigned char _NEAR _CDECL _osmajor;
extern unsigned char _NEAR _CDECL _osminor;

#define DOS_MODE    0   /* Real Address Mode */
#define OS2_MODE    1   /* Protected Address Mode */

extern unsigned char _NEAR _CDECL _osmode;


/* function prototypes */

double _CDECL atof(const char *);
double _CDECL strtod(const char *, char * *);
ldiv_t _CDECL ldiv(long, long);

void   _CDECL abort(void);
int    _CDECL abs(int);
int    _CDECL atexit(void (_CDECL *)(void));
int    _CDECL atoi(const char *);
long   _CDECL atol(const char *);
void * _CDECL bsearch(const void *, const void *, size_t, size_t, int (_CDECL *)(const void *, const void *));
void * _CDECL calloc(size_t, size_t);
div_t  _CDECL div(int, int);
char * _CDECL ecvt(double, int, int *, int *);
void   _CDECL exit(int);
void   _CDECL _exit(int);
char * _CDECL fcvt(double, int, int *, int *);
void   _CDECL free(void *);
char * _CDECL gcvt(double, int, char *);
char * _CDECL getenv(const char *);
char * _CDECL itoa(int, char *, int);
long   _CDECL labs(long);
unsigned long _CDECL _lrotl(unsigned long, int);
unsigned long _CDECL _lrotr(unsigned long, int);
char * _CDECL ltoa(long, char *, int);
void   _CDECL _makepath(char *, char *, char *, char *, char *);
void * _CDECL malloc(size_t);
onexit_t _CDECL onexit(onexit_t);
void   _CDECL perror(const char *);
int    _CDECL putenv(char *);
void   _CDECL qsort(void *, size_t, size_t, int (_CDECL *)(const void *, const void *));
unsigned int _CDECL _rotl(unsigned int, int);
unsigned int _CDECL _rotr(unsigned int, int);
int    _CDECL rand(void);
void * _CDECL realloc(void *, size_t);
void   _CDECL _searchenv(char *, char *, char *);
void   _CDECL _splitpath(char *, char *, char *, char *, char *);
void   _CDECL srand(unsigned int);
long   _CDECL strtol(const char *, char * *, int);
unsigned long _CDECL strtoul(const char *, char * *, int);
void   _CDECL swab(char *, char *, int);
int    _CDECL system(const char *);
char * _CDECL ultoa(unsigned long, char *, int);

#ifndef tolower         /* tolower has been undefined - use function */
int _CDECL tolower(int);
#endif  /* tolower */

#ifndef toupper         /* toupper has been undefined - use function */
int    _CDECL toupper(int);
#endif  /* toupper */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the string
*   manipulation functions.
*   [ANSI/System V]
*
*******************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
    #define _CDECL  cdecl
#else /* extensions not enabled */
    #define _CDECL
#endif /* NO_EXT_KEYS */


/* function prototypes */

void * _CDECL memccpy(void *, void *, int, unsigned int);
void * _CDECL memchr(const void *, int, size_t);
int _CDECL memcmp(const void *, const void *, size_t);
int _CDECL memicmp(void *, void *, unsigned int);
void * _CDECL memcpy(void *, const void *, size_t);
void * _CDECL memmove(void *, const void *, size_t);
void * _CDECL memset(void *, int, size_t);
void _CDECL movedata(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);

char * _CDECL strcat(char *, const char *);
char * _CDECL strchr(const char *, int);
int _CDECL strcmp(const char *, const char *);
int _CDECL strcmpi(const char *, const char *);
int _CDECL stricmp(const char *, const char *);
char * _CDECL strcpy(char *, const char *);
size_t _CDECL strcspn(const char *, const char *);
char * _CDECL strdup(const char *);
char * _CDECL _strerror(char *);
char * _CDECL strerror(int);
size_t _CDECL strlen(const char *);
char * _CDECL strlwr(char *);
char * _CDECL strncat(char *, const char *, size_t);
int _CDECL strncmp(const char *, const char *, size_t);
int _CDECL strnicmp(const char *, const char *, size_t);
char * _CDECL strncpy(char *, const char *, size_t);
char * _CDECL strnset(char *, int, size_t);
char * _CDECL strpbrk(const char *, const char *);
char * _CDECL strrchr(const char *, int);
char * _CDECL strrev(char *);
char * _CDECL strset(char *, int);
size_t _CDECL strspn(const char *, const char *);
char * _CDECL strstr(const char *, const char *);
char * _CDECL strtok(char *, const char *);
char * _CDECL strupr(char *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\sys\locking.h ===
/***
*sys\locking.h - flags for locking() function
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the flags for the locking() function.
*   [System V]
*
*******************************************************************************/

#define LK_UNLCK    0   /* unlock the file region */
#define LK_LOCK     1   /* lock the file region */
#define LK_NBLCK    2   /* non-blocking lock */
#define LK_RLCK     3   /* lock for writing */
#define LK_NBRLCK   4   /* non-blocking lock for writing */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\windows.inc ===
;*************************************************************************
;
;       WINDOWS.INC - Windows assembly language structures & constants
;
;*************************************************************************
;
; Conditional Block includes:   (True states)
;     NOTEXT - don't include TextMetric struc & text drawing modes & stock objs.
;     NORASTOPS - don't include binary and ternary raster ops.
;     NOVK      - don't include virtual key definitions
;     NOMB      - don't include message box definitions
;     NOWM      - don't include window messages
;
;
FALSE   =       0
TRUE    =       1
NULL    =       0

;*******************************************************************
;
;       Rectangle
;
;*******************************************************************

RECT    struc
        rcLeft          dw      ?
        rcTop           dw      ?
        rcRight         dw      ?
        rcBottom        dw      ?
RECT    ends

;*******************************************************************
;
;  Window Class structure
;
;*******************************************************************

WNDCLASS struc
        clsStyle        dw      ?       ; class style
        clsLpfnWndProc  dd      ?
        clsCbClsExtra   dw      ?
        clsCbWndExtra   dw      ?
        clsHInstance    dw      ?       ; instance handle
        clsHIcon        dw      ?       ; class icon handle
        clsHCursor      dw      ?       ; class cursor handle
        clsHbrBackground dw     ?       ; class background brush
        clsLpszMenuName dd      ?       ; menu name
        clsLpszClassName dd     ?       ; far ptr to class name
WNDCLASS ends

IFNDEF NOTEXT
TEXTMETRIC struc
tmHeight        dw      ?
tmAscent        dw      ?
tmDescent       dw      ?
tmIntLeading    dw      ?
tmExtLeading    dw      ?
tmAveCharWidth  dw      ?
tmMaxCharWidth  dw      ?
tmWeight        dw      ?
tmItalic        db      ?
tmUnderlined    db      ?
tmStruckOut     db      ?
tmFirstChar     db      ?
tmLastChar      db      ?
tmDefaultChar   db      ?
tmBreakChar     db      ?
tmPitch         db      ?
tmCharSet       db      ?
tmOverhang      dw      ?
tmAspectX       dw      ?
tmAspectY       dw      ?
TEXTMETRIC ends
;
;  Text Drawing modes
;
TRANSPARENT     = 1
OPAQUE          = 2
;
;  Stock Logical Objects
;
WHITE_BRUSH     =  0
LTGRAY_BRUSH    =  1
GRAY_BRUSH      =  2
DKGRAY_BRUSH    =  3
BLACK_BRUSH     =  4
HOLLOW_BRUSH    =  5
WHITE_PEN       =  6
BLACK_PEN       =  7
NULL_PEN        =  8
DOT_MARKER      =  9
OEM_FIXED_FONT  = 10
ANSI_FIXED_FONT = 11
ANSI_VAR_FONT   = 12
ENDIF

;
ANSI_CHARSET    = 0
OEM_CHARSET     = 255
;
;  styles for CombineRgn
;
RGN_AND  = 1
RGN_OR   = 2
RGN_XOR  = 3
RGN_DIFF = 4
RGN_COPY = 5
;
;  Predefined cursor & icon IDs
;
IDC_ARROW       = 32512
IDC_IBEAM       = 32513
IDC_WAIT        = 32514
IDC_CROSS       = 32515
IDC_UPARROW     = 32516
IDC_SIZE        = 32640
IDC_ICON        = 32641

IDI_APPLICATION = 32512
IDI_HAND        = 32513
IDI_QUESTION    = 32514
IDI_EXCLAMATION = 32515
IDI_ASTERISK    = 32516
;
;   Scroll bar constants
;
SB_HORZ = 0
SB_VERT = 1
;
;   Scroll Commands
;
SB_LINEUP        = 0
SB_LINEDOWN      = 1
SB_PAGEUP        = 2
SB_PAGEDOWN      = 3
SB_THUMBPOSITION = 4
SB_THUMBTRACK    = 5
;
;  MessageBox type flags
;
IFNDEF                  NOMB
MB_OK                   = 0000H
MB_OKCANCEL             = 0001H
MB_ABORTRETRYIGNORE     = 0002H
MB_YESNOCANCEL          = 0003H

MB_ICONHAND             = 0010H
MB_ICONQUESTION         = 0020H
MB_ICONEXCLAMATION      = 0030H
MB_ICONASTERISK         = 0040H

MB_DEFBUTTON1           = 0000H
MB_DEFBUTTON2           = 0100H
MB_DEFBUTTON3           = 0200H

MB_APPLMODAL            = 0000H
MB_SYSTEMMODAL          = 1000H
;
;  Conventional dialog box and message box command IDs
;
IDOK     =   1
IDCANCEL =   2
IDABORT  =   3
IDRETRY  =   4
IDIGNORE =   5
IDYES    =   6
IDNO     =   7
;
;  Flags for OpenFile
;
OF_REOPEN       = 8000H
OF_EXIST        = 4000H
OF_PROMPT       = 2000H
OF_CREATE       = 1000H
OF_CANCEL       = 0800H

TF_FORCEDRIVE   = 80H

OPENSTRUC       STRUC
opLen   db      ?
opDisk  db      ?
opXtra  dw      ?
opDate  dw      ?
opTime  dw      ?
opFile  db      120 dup (?)
OPENSTRUC       ENDS
;
;  DrawText format flags
;
DT_LEFT         = 00H
DT_CENTER       = 01H
DT_RIGHT        = 02H
DT_TOP          = 00H
DT_VCENTER      = 04H
DT_BOTTOM       = 08H
DT_WORDBREAK    = 10H
DT_SINGLELINE   = 20H
DT_EXPANDTABS   = 40H
DT_TABSTOP      = 80H
ENDIF
;
; Memory manager flags
;
LMEM_FIXED      =   00h
LMEM_MOVEABLE   =   02h
LMEM_ZEROINIT   =   40h
LMEM_DISCARDABLE=   0F00h
LHND    =    LMEM_MOVEABLE+LMEM_ZEROINIT
LPTR    =    LMEM_FIXED+LMEM_ZEROINIT

GMEM_FIXED      =   00h
GMEM_MOVEABLE   =   02h
GMEM_ZEROINIT   =   40h
GMEM_DISCARDABLE=   0F00h
GMEM_SHARE	=   2000h
GHND    =    GMEM_MOVEABLE+GMEM_ZEROINIT
GPTR    =    GMEM_FIXED+GMEM_ZEROINIT

;  Virtual Keys, Standard Set

IFNDEF          NOVK
VK_LBUTTON      = 01H
VK_RBUTTON      = 02H
VK_CANCEL       = 03H
VK_BACK         = 08H
VK_TAB          = 09H
VK_CLEAR        = 0cH
VK_RETURN       = 0dH
VK_SHIFT        = 10H
VK_CONTROL      = 11H
VK_MENU         = 12H
VK_PAUSE        = 13H
VK_CAPITAL      = 14H
VK_ESCAPE       = 1bH
VK_SPACE        = 20H

VK_PRIOR        = 21H
VK_NEXT         = 22H
VK_END          = 23H
VK_HOME         = 24H
VK_LEFT         = 25H
VK_UP           = 26H
VK_RIGHT        = 27H
VK_DOWN         = 28H

;  VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z'
;  VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0'

VK_PRINT        = 2aH
VK_EXECUTE      = 2bH
VK_INSERT       = 2dH
VK_DELETE       = 2eH
VK_HELP         = 2fH

VK_NUMPAD0      = 60H
VK_NUMPAD1      = 61H
VK_NUMPAD2      = 62H
VK_NUMPAD3      = 63H
VK_NUMPAD4      = 64H
VK_NUMPAD5      = 65H
VK_NUMPAD6      = 66H
VK_NUMPAD7      = 67H
VK_NUMPAD8      = 68H
VK_NUMPAD9      = 69H
VK_MULTIPLY     = 6AH
VK_ADD          = 6BH
VK_SEPARATER    = 6CH
VK_SUBTRACT     = 6DH
VK_DECIMAL      = 6EH
VK_DIVIDE       = 6FH

VK_F1           = 70H
VK_F2           = 71H
VK_F3           = 72H
VK_F4           = 73H
VK_F5           = 74H
VK_F6           = 75H
VK_F7           = 76H
VK_F8           = 77H
VK_F9           = 78H
VK_F10          = 79H
VK_F11          = 7aH
VK_F12          = 7bH
VK_F13          = 7cH
VK_F14          = 7dH
VK_F15          = 7eH
VK_F16          = 7fH
ENDIF

;*************************************************************************
;
;       Misc structures & constants
;
;*************************************************************************

IFNDEF  NOMST
POINT   struc
        ptX             dw      ?
        ptY             dw      ?
POINT   ends

BITMAP STRUC
        bmType         DW ?
        bmWidth        DW ?
        bmHeight       DW ?
        bmWidthBytes   DW ?
        bmPlanes       DB ?
        bmBitsPixel    DB ?
        bmBits         DQ ?
BITMAP ENDS

WNDSTRUC struc
        WSwndStyle        dd      ?
        WSwndID           dw      ?
        WSwndText         dw      ?
        WSwndParent       dw      ?
        WSwndInstance     dw      ?
        WSwndClassProc    dd      ?
WNDSTRUC ends
;
;  Message structure
;
MSGSTRUCT       struc
msHWND          dw      ?
msMESSAGE       dw      ?
msWPARAM        dw      ?
msLPARAM        dd      ?
msTIME          dd      ?
msPT            dd      ?
MSGSTRUCT       ends

NEWPARMS struc
        nprmHwnd        dw      ?
        nprmCmd         db      ?
NEWPARMS ends
ENDIF

PAINTSTRUCT STRUC
    PShdc         DW ?
    PSfErase      DW ?
    PSrcPaint     DB size RECT dup(?)
    PSfRestore    DW ?
    PSfIncUpdate  DW ?
    PSrgbReserved DB 16 dup(?)
PAINTSTRUCT ENDS
;
; ShowWindow commands
;
HIDE_WINDOW     = 0
SHOW_OPENWINDOW = 1
SHOW_ICONWINDOW = 2
;
;       PostError constants
;
WARNING     = 0           ; command codes
MINOR_ERROR = 1
FATAL_ERROR = 2

IGNORE      = 0           ; response codes
RETRY       = 1
ABORT       = 2
;
; GDI-related constants & commands
;
ERRORREGION     = 0
NULLREGION      = 1
SIMPLEREGION    = 2
COMPLEXREGION   = 3

IFNDEF NORASTOPS
;
; Binary raster ops
;
R2_BLACK        =  1
R2_NOTMERGEPEN  =  2
R2_MASKNOTPEN   =  3
R2_NOTCOPYPEN   =  4
R2_MASKPENNOT   =  5
R2_NOT          =  6
R2_XORPEN       =  7
R2_NOTMASKPEN   =  8
R2_MASKPEN      =  9
R2_NOTXORPEN    = 10
R2_NOP          = 11
R2_MERGENOTPEN  = 12
R2_COPYPEN      = 13
R2_MERGEPENNOT  = 14
R2_MERGEPEN     = 15
R2_WHITE        = 16
;
; Ternary raster ops
;
SRCCOPY_L     = 0020h   ;dest=source
SRCCOPY_H     = 00CCh
SRCPAINT_L    = 0086h   ;dest=source OR dest
SRCPAINT_H    = 00EEh
SRCAND_L      = 00C6h   ;dest=source AND   dest
SRCAND_H      = 0088h
SRCINVERT_L   = 0046h   ;dest= source XOR      dest
SRCINVERT_H   = 0066h
SRCERASE_L    = 0328h   ;dest= source AND (not dest )
SRCERASE_H    = 0044h
NOTSRCCOPY_L  = 0008h   ;dest= (not source)
NOTSRCCOPY_H  = 0033h
NOTSRCERASE_L = 00A6h   ;dest= (not source) AND (not dest)
NOTSRCERASE_H = 0011h
MERGECOPY_L   = 00CAh   ;dest= (source AND pattern)
MERGECOPY_H   = 00C0h
MERGEPAINT_L  = 0226h   ;dest= (source AND pattern) OR dest
MERGEPAINT_H  = 00BBh
PATCOPY_L     = 0021h   ;dest= pattern
PATCOPY_H     = 00F0h
PATPAINT_L    = 0A09h   ;DPSnoo
PATPAINT_H    = 00FBh
PATINVERT_L   = 0049h   ;dest= pattern XOR     dest
PATINVERT_H   = 005Ah
DSTINVERT_L   = 0009h   ;dest= (not dest)
DSTINVERT_H   = 0055h
BLACKNESS_L   = 0042h   ;dest= BLACK
BLACKNESS_H   = 0000h
WHITENESS_L   = 0062h   ;dest= WHITE
WHITENESS_H   = 00FFh
;
; StretchBlt modes
;
BLACKONWHITE    = 1
WHITEONBLACK    = 2
COLORONCOLOR    = 3
;
; PolyFill modes
;
ALTERNATE       = 1
WINDING         = 2
ENDIF
;
; Menu flags for Change/Check/Enable MenuItem
;
MF_CHANGE       = 0080h
MF_INSERT       = 0000h
MF_APPEND       = 0100h
MF_DELETE       = 0200h
MF_BYPOSITION   = 0400h
MF_BYCOMMAND    = 0000h
MF_GRAYED       = 0001h
MF_DISABLED     = 0002h
MF_ENABLED      = 0000h
MF_CHECKED      = 0008h
MF_BITMAP       = 0004h
MF_STRING       = 0000h
MF_POPUP        = 0010h
MF_DIVIDER      = 0020h
MF_BREAK        = 0040h
;
;  System Menu Command Values
;
SC_SIZE         = 0F000H
SC_MOVE         = 0F010H
SC_ICON         = 0F020H
SC_ZOOM         = 0F030H
SC_NEXTWINDOW   = 0F040H
SC_PREVWINDOW   = 0F050H
SC_CLOSE        = 0F060H
SC_VSCROLL      = 0F070H
SC_HSCROLL      = 0F080H
SC_DUPLICATE    = 0F090H
SC_MOUSEMENU    = 0F100H
SC_KEYMENU      = 0F110H
;
;  Window State Messages
;
IFNDEF  NOWM
WM_STATE            = 0000H

WM_NULL             = 0000H
WM_CREATE           = 0001H
WM_DESTROY          = 0002H
WM_QUERYDESTROY     = 0003H
WM_SYNCSIZE         = 0004H
WM_SIZE             = 0005H
WM_ACTIVATE         = 0006H
WM_SETFOCUS         = 0007H
WM_KILLFOCUS        = 0008H
WM_SETVISIBLE       = 0009H
WM_ENABLE           = 000aH
WM_SETREDRAW        = 000bH
WM_SETTEXT          = 000cH
WM_GETTEXT          = 000dH
WM_GETTEXTLENGTH    = 000eH
WM_PAINT            = 000fH
WM_CLOSE            = 0010H
WM_QUERYQUIT        = 0011H
WM_QUIT             = 0012H
WM_QUERYOPEN        = 0013H
WM_ERASEBKGND       = 0014H
WM_SYSCOLORCHANGE   = 0015H
WM_ENDSESSION       = 0016H
WM_SYSTEMERROR      = 0017H
WM_SHOWWINDOW       = 0018H

WM_QUERYDEFPROC     = 0080H
WM_NCCREATE         = 0081H
WM_NCDESTROY        = 0082H
WM_NCCALCSIZE       = 0083H
WM_NCHITTEST        = 0084H
WM_NCPAINT          = 0085H
WM_NCACTIVATE       = 0086H
WM_GETDLGCODE       = 0087H
WM_ENDDIALOG        = 0088H

WM_NCMOUSEMOVE      = 00a0H
WM_NCLBUTTONDOWN    = 00a1H
WM_NCLBUTTONUP      = 00a2H
WM_NCLBUTTONDBLCLK  = 00a3H
WM_NCRBUTTONDOWN    = 00a4H
WM_NCRBUTTONUP      = 00a5H
WM_NCRBUTTONDBLCLK  = 00a6H

WM_KEYFIRST         = 0100H
WM_KEYDOWN          = 0100H
WM_KEYUP            = 0101H
WM_CHAR             = 0102H
WM_DEADCHAR         = 0103H
WM_SYSKEYDOWN       = 0104H
WM_SYSKEYUP         = 0105H
WM_SYSCHAR          = 0106H
WM_SYSDEADCHAR      = 0107H
WM_KEYLAST          = 0107H

WM_INITDIALOG       = 0110H
WM_COMMAND          = 0111H
WM_SYSCOMMAND       = 0112H
WM_TIMER            = 0113H
WM_HSCROLL          = 0114H
WM_VSCROLL          = 0115H
WM_INITMENU         = 0116H

WM_MOUSEFIRST       = 0200H
WM_MOUSEMOVE        = 0200H     ;  mouse related stuff
WM_LBUTTONDOWN      = 0201H
WM_LBUTTONUP        = 0202H
WM_LBUTTONDBLCLK    = 0203H
WM_RBUTTONDOWN      = 0204H
WM_RBUTTONUP        = 0205H
WM_RBUTTONDBLCLK    = 0206H
WM_MOUSELAST        = 0206H

;  clipboard messages
WM_RENDERFORMAT     = 0300H
WM_RENDERALLFORMATS = 0301H
WM_DESTROYCLIPBOARD = 0302H
WM_DRAWCLIPBOARD    = 0303H

;  private window messages start here
WM_USER             = 0400H
ENDIF           ; NOWM

; Size message commands
SIZENORMAL       = 0
SIZEICONIC       = 1
SIZEFULLSCREEN   = 2
SIZEZOOMSHOW     = 3
SIZEZOOMHIDE     = 4

;  identifiers for the WM_SHOWWINDOW message
SW_PARENTCLOSING =  1
SW_OTHERZOOM     =  2
SW_PARENTOPENING =  3
SW_OTHERUNZOOM   =  4
;
; Key state masks for mouse messages
;
MK_LBUTTON       = 0001h
MK_RBUTTON       = 0002h
MK_SHIFT         = 0004h
MK_CONTROL       = 0010h
;
; Class styles
;
CS_VREDRAW      = 0001h
CS_HREDRAW      = 0002h
CS_KEYCVTWINDOW = 0004H
CS_DBLCLKS      = 0008h
CS_OEMCHARS     = 0010h
CS_OWNDC        = 0020h
CS_CLASSDC      = 0040h
CS_PARENTDC     = 0080h
CS_NOKEYCVT     = 0100h
CS_SAVEBITS     = 0800h
CS_NOCLOSE      = 0200h
CS_BYTEALIGNCLIENT = 1000h
CS_BYTEALIGNWINDOW = 2000h
;
; Windows styles (the high words)
;
WS_TILED        = 0000h
WS_POPUP        = 8000h
WS_CHILD        = 4000h
WS_ICONIC       = 2000h
WS_VISIBLE      = 1000h
WS_DISABLED     = 0800h
WS_CLIPSIBLINGS = 0400h
WS_CLIPCHILDREN = 0200h
WS_BORDER       = 0080h
WS_CAPTION      = 0040h
WS_VSCROLL      = 0020h
WS_HSCROLL      = 0010h
WS_SYSMENU      = 0008h
WS_SIZEBOX      = 0004H
WS_HREDRAW      = 0002h
WS_VREDRAW      = 0001h
WS_TILEDWINDOW  = WS_TILED + WS_BORDER + WS_CAPTION + WS_SYSMENU + WS_SIZEBOX
WS_POPUPWINDOW  = WS_POPUP + WS_BORDER
WS_CHILDWINDOW  = WS_CHILD
;
; predefined clipboard formats
;
CF_TEXT         = 1
CF_BITMAP       = 2
CF_METAFILE     = 3
CF_BINARY       = 4
CF_SYLK         = 5
CF_DIF          = 6
CF_OEMTEXT      = 7

CF_OWNERDISPLAY = 80h       ; owner display
CF_DSPTEXT      = 81h       ; display text
CF_DSPBITMAP    = 82h       ; display bitmap
CF_DSPMETAFILE  = 83h       ; display metafile
;
; Private clipboard format range
;
CF_PRIVATEFIRST       = 200h       ; Anything in this range doesn't
CF_PRIVATELAST        = 2ffh       ; get GlobalFree'd
CF_GDIOBJFIRST        = 300h       ; Anything in this range gets
CF_GDIOBJLAST         = 3ffh       ; DeleteObject'ed

MAKEINTRESOURCE MACRO a
        mov     ax,a
        xor     dx,dx
        ENDM
;
;  Predefined resource types
;
RT_CURSOR       = 1              ; must be passed through MAKEINTRESOURCE
RT_BITMAP       = 2
RT_ICON         = 3
RT_MENU         = 4
RT_DIALOG       = 5
RT_STRING       = 6
RT_FONTDIR      = 7
RT_FONT         = 8
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\windows.h ===
/*  If defined, the following flags inhibit definition
    of the indicated constants.

    NOGDICAPMASKS	CC_*, LC_*, PC_*, CP_*, TC_*, RC_
    NOVIRTUALKEYCODES	VK_*
    NOWINMESSAGES	WM_*
    NONCMESSAGES	WM_NC* and HT*
    NOWINSTYLES		WS_*, CS_*, ES_*, LBS_*
    NOSYSMETRICS	SM_*
    NODRAWFRAME		DF_*
    NOMENUS		MF_*
    NOICON		IDI_*
    NOKEYSTATE		MK_*
    NOSYSCOMMANDS	SC_*
    NORASTEROPS		binary and tertiary raster ops
    NOSHOWWINDOW	SHOW_* and HIDE_*

    The following flags inhibit declarations of the following groups
    of procedures and type definitions.
    "associated routines" refers to routines with parameters or return
     values of the given type.

    OEMRESOURCE	    - define this and get the Oem Resource values.
    NOSYSMETRICS    - GetSystemMetrics
    NOATOM	    - Atom Manager routines
    NOBITMAP	    - typedef HBITMAP and associated routines
    NOBRUSH	    - typedef HBRUSH and associated routines
    NOCLIPBOARD	    - clipboard routines
    NOCOLOR
    NOCREATESTRUCT  - typedef CREATESTRUCT
    NOCTLMGR	    - control and dialog routines
    NODRAWTEXT	    - DrawText() and DT_*
    NOFONT	    - typedef FONT and associated routines
    NOGDI	    - StretchBlt modes and gdi logical objects
    NOHDC	    - typedef HDC and associated routines
    NOMB	    - MB_* and MessageBox()
    NOMEMMGR	    - GMEM_*, LMEM_*, GHND, LHND, associated routines
    NOMENUS	    - HMENU and associated routines
    NOMETAFILE	    - typedef METAFILEPICT
    NOMINMAX	    - Macros min(a,b) and max(a,b)
    NOMSG	    - typedef MSG and associated routines
    NOOPENFILE	    - OpenFile(), OemToAnsi, AnsiToOem, and OF_*
    NOPEN	    - typedef HPEN and associated routines
    NOPOINT	    - typedef POINT and associated routines
    NORECT	    - typedef RECT and associated routines
    NOREGION	    - typedef HRGN and associated routines
    NOSCROLL	    - SB_* and scrolling routines
    NOSOUND	    - Sound driver routines
    NOTEXTMETRIC    - typedef TEXTMETRIC and associated routines
    NOWH	    - SetWindowsHook and WH_*
    NOWINOFFSETS    - GWL_*, GCL_*, associated routines
    NOWNDCLASS	    - typedef WNDCLASS and associated routines
    NOCOMM	    - COMM driver routines
    NOKANJI	    - Kanji support stuff.
*/

#ifdef RC_INVOKED
/*
 Turn off a bunch of stuff to ensure that RC files compile OK
*/
#define NOCOMM
#define NOKANJI
#define NOWH
#define NOTEXTMETRIC
#define NOSOUND
#define NOSCROLL
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NORASTEROPS
#define NOATOM
#define NOFONT
#define NOREGION
#define NORECT
#define NOPEN
#define NOPOINT
#define NOOPENFILE
#define NOMSG
#define NOMINMAX
#define NOMETAFILE
#define NOHDC
#define NOGDI
#endif

#ifndef PASCAL
#define PASCAL	pascal
#endif

#define FALSE	0
#define TRUE	1
#define NULL	0

#define FAR	far
#define NEAR	near
#define LONG	long
#define VOID	void

typedef unsigned char	BYTE;
typedef unsigned short	WORD;
typedef unsigned long  DWORD;
typedef int	  BOOL;
typedef char	 *PSTR;
typedef char NEAR*NPSTR;
typedef char FAR *LPSTR;
typedef int  FAR *LPINT;

#ifndef NOMINMAX
#define max(a,b)	((a) > (b) ? (a) : (b))
#define min(a,b)	((a) < (b) ? (a) : (b))
#endif

#define MAKELONG(a, b)	((long)(((unsigned)(a)) | ((unsigned long)((unsigned)(b))) << 16))
#define LOWORD(l)	((WORD)(l))
#define HIWORD(l)	((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)	((BYTE)(w))
#define HIBYTE(w)	(((WORD)(w) >> 8) & 0xff)

#ifndef NOPOINT
#define MAKEPOINT(l)	(*((POINT *)&(l)))
#endif

#ifdef OEMRESOURCE
#define OBM_CLOSE	32767
#define OBM_SIZE	32766
#define OBM_UPARROW	32765
#define OBM_DNARROW	32764
#define OBM_RGARROW	32763
#define OBM_LFARROW	32762
#define OBM_BTSIZE	32761
#define OBM_CHECK	32760
#define OBM_CHECKBOXES	32759
#define OBM_BTNCORNERS	32758
#define OBM_REDUCE	32757
#define OBM_ZOOM	32756
#define OBM_RESTORE	32755
#define OCR_NORMAL	32512
#define OCR_IBEAM	32513
#define OCR_WAIT	32514
#define OCR_CROSS	32515
#define OCR_UP		32516
#define OCR_SIZE	32640
#define OCR_ICON	32641
#define OCR_SIZENWSE	32642
#define OCR_SIZENESW	32643
#define OCR_SIZEWE	32644
#define OCR_SIZENS	32645
#define OCR_SIZEALL	32646

#define OIC_SAMPLE	32512
#define OIC_HAND	32513
#define OIC_QUES	32514
#define OIC_BANG	32515
#define OIC_NOTE	32516
#endif

/*  Scroll bar constants */
#ifndef NOSCROLL
#define SB_HORZ		    0
#define SB_VERT		    1
#define SB_CTL		    2
#define SB_BOTH		    3

/*  Scroll Commands */
#define SB_LINEUP	    0
#define SB_LINEDOWN	    1
#define SB_PAGEUP	    2
#define SB_PAGEDOWN	    3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK	    5
#define SB_TOP		    6
#define SB_BOTTOM	    7
#define SB_ENDSCROLL	    8
#endif

#ifndef NOSHOWWINDOW

/* ShowWindow commands */

#define SW_HIDE		    0
#define SW_SHOWNORMAL	    1
#define SW_RESTORE	    1
#define SW_NORMAL	    1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE	    3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW		    5
#define SW_MINIMIZE	    6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA	    8

/* Old showwindow commands */

#define HIDE_WINDOW	0
#define SHOW_OPENWINDOW 1
#define SHOW_ICONWINDOW 2
#define SHOW_FULLSCREEN 3
#define SHOW_OPENNOACTIVATE 4

/* identifiers for the WM_SHOWWINDOW message */
#define SW_PARENTCLOSING    1
#define SW_OTHERZOOM	    2
#define SW_PARENTOPENING    3
#define SW_OTHERUNZOOM	    4
#endif

/* flags for regions */
#ifndef NOREGION
#define ERROR		0
#define NULLREGION	1
#define SIMPLEREGION	2
#define COMPLEXREGION	3

/* styles for CombineRgn */
#define RGN_AND	 1
#define RGN_OR	 2
#define RGN_XOR	 3
#define RGN_DIFF 4
#define RGN_COPY 5
#endif

#ifndef NOVIRTUALKEYCODES
/* Virtual Keys, Standard Set */

#define VK_LBUTTON  0x01
#define VK_RBUTTON  0x02
#define VK_CANCEL   0x03
#define VK_MBUTTON  0x04    /* NOT contiguous with L & RBUTTON */
#define VK_BACK	    0x08
#define VK_TAB	    0x09
#define VK_CLEAR    0x0C
#define VK_RETURN   0x0D
#define VK_SHIFT    0x10
#define VK_CONTROL  0x11
#define VK_MENU	    0x12
#define VK_PAUSE    0x13
#define VK_CAPITAL  0x14
#define VK_ESCAPE   0x1B
#define VK_SPACE    0x20

#define VK_PRIOR    0x21
#define VK_NEXT	    0x22
#define VK_END	    0x23
#define VK_HOME	    0x24
#define VK_LEFT	    0x25
#define VK_UP	    0x26
#define VK_RIGHT    0x27
#define VK_DOWN	    0x28

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#define VK_SELECT   0x29
#define VK_PRINT    0x2A
#define VK_EXECUTE  0x2B
#define VK_COPY	    0x2C
#define VK_INSERT   0x2D
#define VK_DELETE   0x2E
#define VK_HELP	    0x2F

#define VK_NUMPAD0  0x60
#define VK_NUMPAD1  0x61
#define VK_NUMPAD2  0x62
#define VK_NUMPAD3  0x63
#define VK_NUMPAD4  0x64
#define VK_NUMPAD5  0x65
#define VK_NUMPAD6  0x66
#define VK_NUMPAD7  0x67
#define VK_NUMPAD8  0x68
#define VK_NUMPAD9  0x69
#define VK_MULTIPLY 0x6A
#define VK_ADD	    0x6B
#define VK_SEPARATOR 0x6C
#define VK_SUBTRACT 0x6D
#define VK_DECIMAL  0x6E
#define VK_DIVIDE   0x6F

#define VK_F1	    0x70
#define VK_F2	    0x71
#define VK_F3	    0x72
#define VK_F4	    0x73
#define VK_F5	    0x74
#define VK_F6	    0x75
#define VK_F7	    0x76
#define VK_F8	    0x77
#define VK_F9	    0x78
#define VK_F10	    0x79
#define VK_F11	    0x7A
#define VK_F12	    0x7B
#define VK_F13	    0x7C
#define VK_F14	    0x7D
#define VK_F15	    0x7E
#define VK_F16	    0x7F

#define VK_NUMLOCK  0x90

#endif

/* SetWindowsHook codes */
#ifndef NOWH
#define WH_MSGFILTER	    -1
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1
#define WH_KEYBOARD	    2
#define WH_GETMESSAGE	    3
#define WH_CALLWNDPROC	    4
#define WH_CBT		    5
#define WH_SYSMSGFILTER	    6
#define WH_WINDOWMGR	    7

/* HC_* Hook Codes */
#define HC_LPLPFNNEXT -2
#define HC_LPFNNEXT   -1
#define HC_ACTION      0
#define HC_GETNEXT     1
#define HC_SKIP	       2
#define HC_NOREM       3
#define HC_NOREMOVE    3

/* CBT hook codes */
#define HCBT_MOVESIZE  0
#define HCBT_MINMAX    1
#define HCBT_QS	       2

/* WH_MSGFILTER filter proc codes */
#define MSGF_DIALOGBOX	    0
#define MSGF_MESSAGEBOX	    1
#define MSGF_MENU	    2
#define MSGF_MOVE	    3
#define MSGF_SIZE	    4
#define MSGF_SCROLLBAR	    5
#define MSGF_NEXTWINDOW	    6

/* Define window manager hook codes */
#define WC_INIT		    1
#define WC_SWP		    2
#define WC_DEFWINDOWPROC    3
#define WC_MINMAX	    4
#define WC_MOVE		    5
#define WC_SIZE		    6
#define WC_DRAWCAPTION	    7

/* message structure used in journaling	 */
typedef struct eventmsg {
    unsigned message;
    WORD paramL;
    WORD paramH;
    DWORD time;
} EVENTMSG;

typedef EVENTMSG *PEVENTMSGMSG;
typedef EVENTMSG NEAR *NPEVENTMSGMSG;
typedef EVENTMSG FAR *LPEVENTMSGMSG;


#endif

/*  Binary raster ops */
#ifndef NORASTEROPS
#define R2_BLACK	    1	/*  0	    */
#define R2_NOTMERGEPEN	    2	/* DPon	    */
#define R2_MASKNOTPEN	    3	/* DPna	    */
#define R2_NOTCOPYPEN	    4	/* PN	    */
#define R2_MASKPENNOT	    5	/* PDna	    */
#define R2_NOT		    6	/* Dn	    */
#define R2_XORPEN	    7	/* DPx	    */
#define R2_NOTMASKPEN	    8	/* DPan	    */
#define R2_MASKPEN	    9	/* DPa	    */
#define R2_NOTXORPEN	   10	/* DPxn	    */
#define R2_NOP		   11	/* D	    */
#define R2_MERGENOTPEN	   12	/* DPno	    */
#define R2_COPYPEN	   13	/* P	    */
#define R2_MERGEPENNOT	   14	/* PDno	    */
#define R2_MERGEPEN	   15	/* DPo	    */
#define R2_WHITE	   16	/*  1	    */

/*  Ternary raster operations */
#define SRCCOPY	    (DWORD)0x00CC0020  /* dest=source			     */
#define SRCPAINT    (DWORD)0x00EE0086  /* dest=source OR dest		     */
#define SRCAND	    (DWORD)0x008800C6  /* dest = source AND dest	     */
#define SRCINVERT   (DWORD)0x00660046  /* dest = source XOR	 dest	     */
#define SRCERASE    (DWORD)0x00440328  /* dest = source AND (not dest )	     */
#define NOTSRCCOPY  (DWORD)0x00330008  /* dest = (not source)		     */
#define NOTSRCERASE (DWORD)0x001100A6  /* dest = (not source) AND (not dest) */
#define MERGECOPY   (DWORD)0x00C000CA  /* dest = (source AND pattern)	     */
#define MERGEPAINT  (DWORD)0x00BB0226  /* dest = (NOT source) OR dest	     */
#define PATCOPY	    (DWORD)0x00F00021  /* dest = pattern		     */
#define PATPAINT    (DWORD)0x00FB0A09  /* dest = DPSnoo			     */
#define PATINVERT   (DWORD)0x005A0049  /* dest = pattern XOR dest	     */
#define DSTINVERT   (DWORD)0x00550009  /* dest = (not dest)		     */
#define BLACKNESS   (DWORD)0x00000042  /* dest = BLACK			     */
#define WHITENESS   (DWORD)0x00FF0062  /* dest = WHITE			     */
#endif

#ifndef NOGDI
/* StretchBlt() modes */
#define BLACKONWHITE	1
#define WHITEONBLACK	2
#define COLORONCOLOR	3

/* PolyFill modes */
#define ALTERNATE	1
#define WINDING		2

/* text alignment options */
#define TA_UPDATECP	1
#define TA_NOUPDATECP	0

#define TA_LEFT		0
#define TA_RIGHT	2
#define TA_CENTER	6

#define TA_TOP		0
#define TA_BOTTOM	8
#define TA_BASELINE	24

#define ETO_GRAYED	1
#define ETO_OPAQUE	2
#define ETO_CLIPPED	4



#define ASPECT_FILTERING 0x00000001

#ifndef NOMETAFILE
/* Meta file function numbers	*/
#define META_SETBKCOLOR		     0x0201
#define META_SETBKMODE		     0x0102
#define META_SETMAPMODE		     0x0103
#define META_SETROP2		     0x0104
#define META_SETRELABS		     0x0105
#define META_SETPOLYFILLMODE	     0x0106
#define META_SETSTRETCHBLTMODE	     0x0107
#define META_SETTEXTCHAREXTRA	     0x0108
#define META_SETTEXTCOLOR	     0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG	     0x020B
#define META_SETWINDOWEXT	     0x020C
#define META_SETVIEWPORTORG	     0x020D
#define META_SETVIEWPORTEXT	     0x020E
#define META_OFFSETWINDOWORG	     0x020F
#define META_SCALEWINDOWEXT	     0x0400
#define META_OFFSETVIEWPORTORG	     0x0211
#define META_SCALEVIEWPORTEXT	     0x0412
#define META_LINETO		     0x0213
#define META_MOVETO		     0x0214
#define META_EXCLUDECLIPRECT	     0x0415
#define META_INTERSECTCLIPRECT	     0x0416
#define META_ARC		     0x0817
#define META_ELLIPSE		     0x0418
#define META_FLOODFILL		     0x0419
#define META_PIE		     0x081A
#define META_RECTANGLE		     0x041B
#define META_ROUNDRECT		     0x061C
#define META_PATBLT		     0x061D
#define META_SAVEDC		     0x001E
#define META_SETPIXEL		     0x041F
#define META_OFFSETCLIPRGN	     0x0220
#define META_TEXTOUT		     0x0521
#define META_BITBLT		     0x0922
#define META_STRETCHBLT		     0x0B23
#define META_POLYGON		     0x0324
#define META_POLYLINE		     0x0325
#define META_ESCAPE		     0x0626
#define META_RESTOREDC		     0x0127
#define META_FILLREGION		     0x0228
#define META_FRAMEREGION	     0x0429
#define META_INVERTREGION	     0x012A
#define META_PAINTREGION	     0x012B
#define META_SELECTCLIPREGION	     0x012C
#define META_SELECTOBJECT	     0x012D
#define META_SETTEXTALIGN	     0x012E
#define META_DRAWTEXT		     0x062F
#define META_CHORD		     0x0630
#define META_CREATEBRUSH	     0x00F8
#define META_CREATEPATTERNBRUSH	     0x01F9
#define META_CREATEPENINDIRECT	     0x02FA
#define META_CREATEFONTINDIRECT	     0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP	     0x06FE
#define META_CREATEREGION	     0x06FF
#endif

/* GDI escapes */
#define NEWFRAME	    1
#define ABORTDOC	    2
#define NEXTBAND	    3
#define SETCOLORTABLE	    4
#define GETCOLORTABLE	    5
#define FLUSHOUTPUT	    6
#define DRAFTMODE	    7
#define QUERYESCSUPPORT	    8
#define SETABORTPROC	    9
#define STARTDOC	    10
#define ENDDOC		    11
#define GETPHYSPAGESIZE	    12
#define GETPRINTINGOFFSET   13
#define GETSCALINGFACTOR    14
#define MFCOMMENT	    15	      /* Metafile comment escape */
#define GETPENWIDTH	    16
#define SETCOPYCOUNT	    17
#define SELECTPAPERSOURCE   18
#define DEVICEDATA	    19
#define PASSTHROUGH	    19
#define GETTECHNOLGY	    20
#define SETENDCAP	    21
#define SETLINEJOIN	    22
#define SETMITERLIMIT	    23
#define BANDINFO	    24
#define DRAWPATTERNRECT	    25
#define GETVECTORPENSIZE    26
#define GETVECTORBRUSHSIZE  27
#define ENABLEDUPLEX	    28
#define ENABLEMANUALFEED    29



#define GETEXTENDEDTEXTMETRICS	256
#define GETEXTENTTABLE		257
#define GETPAIRKERNTABLE	258
#define GETTRACKKERNTABLE	259

#define EXTTEXTOUT		512

#define ENABLERELATIVEWIDTHS	768
#define ENABLEPAIRKERNING	769
#define SETKERNTRACK		770
#define STRETCHBLT		2048


/* spooler error code */
#define SP_NOTREPORTED	    0x4000  /* set if GDI did not report error */
#define SP_ERROR	    (-1)    /* general errors who know what went wrong */
#define SP_APPABORT	    (-2)    /* app aborted the job - callback function returned false */
#define SP_USERABORT	    (-3)    /* user aborted the job through spooler's front end */
#define SP_OUTOFDISK	    (-4)    /* not enough disk space to spool */
#define SP_OUTOFMEMORY	    (-5)
/* spooler WM_SPOOLERSTATUS wparm classes   */


#define PR_JOBSTATUS	    0x0000
#endif

/* Object definitions for GDI EnumObjects. */
#define OBJ_PEN		1
#define OBJ_BRUSH	2

#ifndef WIN_INTERNAL
typedef WORD HANDLE;
#endif
typedef HANDLE	     *PHANDLE;
typedef HANDLE	NEAR *SPHANDLE;
typedef HANDLE	FAR *LPHANDLE;

typedef int (FAR PASCAL *FARPROC)();
typedef int (NEAR PASCAL *NEARPROC)();
typedef HANDLE GLOBALHANDLE;
typedef HANDLE LOCALHANDLE;

#ifndef NOBITMAP
typedef struct tagBITMAP {
    short      bmType;
    short      bmWidth;
    short      bmHeight;
    short      bmWidthBytes;
    BYTE       bmPlanes;
    BYTE       bmBitsPixel;
    LPSTR      bmBits;
} BITMAP;
typedef BITMAP *PBITMAP;
typedef BITMAP NEAR *NPBITMAP;
typedef BITMAP FAR *LPBITMAP;
#endif

typedef HANDLE	HSTR;
typedef HANDLE	HICON;
typedef HANDLE	HDC;
typedef HANDLE	HMENU;
typedef HANDLE	HPEN;
typedef HANDLE	HFONT;
typedef HANDLE	HBRUSH;
typedef HANDLE	HBITMAP;
typedef HANDLE	HCURSOR;
typedef HANDLE	HRGN;

typedef struct tagPOINT {
    int x;
    int y;
} POINT;
typedef POINT *PPOINT;
typedef POINT NEAR *NPPOINT;
typedef POINT FAR *LPPOINT;

#ifndef NORECT
#ifndef WIN_INTERNAL
typedef struct tagRECT {
    int left;
    int top;
    int right;
    int bottom;
} RECT;
#endif

typedef RECT *PRECT;
typedef RECT NEAR *NPRECT;
typedef RECT FAR *LPRECT;
#endif

#ifndef NOWNDCLASS
#ifndef NOBRUSH
typedef struct tagWNDCLASS {
    WORD    style;
    long    (FAR PASCAL *lpfnWndProc)();
    int	    cbClsExtra;
    int	    cbWndExtra;
    HANDLE  hInstance;
    HICON   hIcon;
    HCURSOR hCursor;
    HBRUSH  hbrBackground;
    LPSTR   lpszMenuName;
    LPSTR   lpszClassName;
} WNDCLASS;
typedef WNDCLASS     *PWNDCLASS;
typedef WNDCLASS NEAR *NPWNDCLASS;
typedef WNDCLASS FAR *LPWNDCLASS;
#endif
#endif

#ifndef WIN_INTERNAL
typedef HANDLE HWND;
#endif

#ifndef NOMSG
#ifndef NOPOINT
/* Message structure */
typedef struct tagMSG {
    HWND hwnd;
    WORD message;
    WORD wParam;
    LONG lParam;
    DWORD time;
    POINT pt;
} MSG;
typedef MSG *PMSG;
typedef MSG NEAR *NPMSG;
typedef MSG FAR *LPMSG;
#endif
#endif

/* Window field offsets for GetWindowLong & GetWindowWord */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC	-4
#define GWW_HINSTANCE	-6
#define GWW_HWNDPARENT	-8
#define GWW_HWNDTEXT	-10
#define GWW_ID		-12
#define GWL_STYLE	-16

/* Class field offsets for GetClassLong & GetClassWord */
#define GCL_MENUNAME	    -8
#define GCW_HBRBACKGROUND   -10
#define GCW_HCURSOR	    -12
#define GCW_HICON	    -14
#define GCW_HMODULE	    -16
#define GCW_CBWNDEXTRA	    -18
#define GCW_CBCLSEXTRA	    -20
#define GCL_WNDPROC	    -24
#define GCW_STYLE	    -26
#endif

#ifndef NOWINMESSAGES
/* ** Window Procedure Messages */

#define WM_NULL		    0x0000
#define WM_CREATE	    0x0001
#define WM_DESTROY	    0x0002
#define WM_MOVE		    0x0003
#define WM_SIZEWAIT	    0x0004
#define WM_SIZE		    0x0005
#define WM_ACTIVATE	    0x0006
#define WM_SETFOCUS	    0x0007
#define WM_KILLFOCUS	    0x0008
#define WM_SETVISIBLE	    0x0009
#define WM_ENABLE	    0x000a
#define WM_SETREDRAW	    0x000b
#define WM_SETTEXT	    0x000c
#define WM_GETTEXT	    0x000d
#define WM_GETTEXTLENGTH    0x000e
#define WM_PAINT	    0x000f
#define WM_CLOSE	    0x0010
#define WM_QUERYENDSESSION  0x0011
#define WM_QUIT		    0x0012
#define WM_QUERYOPEN	    0x0013
#define WM_ERASEBKGND	    0x0014
#define WM_SYSCOLORCHANGE   0x0015
#define WM_ENDSESSION	    0x0016
#define WM_SYSTEMERROR	    0x0017
#define WM_SHOWWINDOW	    0x0018
#define WM_CTLCOLOR	    0x0019
#define WM_WININICHANGE	    0x001A
#define WM_DEVMODECHANGE    0x001B
#define WM_ACTIVATEAPP	    0x001C
#define WM_FONTCHANGE	    0x001D
#define WM_TIMECHANGE	    0x001E
#define WM_CANCELMODE	    0x001F
#define WM_SETCURSOR	    0x0020
#define WM_MOUSEACTIVATE    0x0021
#define WM_CHILDACTIVATE    0x0022
#define WM_QUEUESYNC	    0x0023
#define WM_GETMINMAXINFO    0x0024
#define WM_PAINTICON	    0x0026
#define WM_ICONERASEBKGND   0x0027
#define WM_NEXTDLGCTL	    0x0028
#define WM_ALTTABACTIVE	    0x0029	    /* for win386 only */
#define WM_SPOOLERSTATUS    0x002A


#ifndef NONCMESSAGES
#define WM_NCCREATE	    0x0081
#define WM_NCDESTROY	    0x0082
#define WM_NCCALCSIZE	    0x0083
#define WM_NCHITTEST	    0x0084
#define WM_NCPAINT	    0x0085
#define WM_NCACTIVATE	    0x0086
#define WM_GETDLGCODE	    0x0087
#define WM_SYNCPAINT	    0x0088
#define WM_SYNCTASK	    0x0089

#define ST_BEGINSWP	    0
#define ST_ENDSWP	    1

#define WM_NCMOUSEMOVE	    0x00a0
#define WM_NCLBUTTONDOWN    0x00a1
#define WM_NCLBUTTONUP	    0x00a2
#define WM_NCLBUTTONDBLCLK  0x00a3
#define WM_NCRBUTTONDOWN    0x00a4
#define WM_NCRBUTTONUP	    0x00a5
#define WM_NCRBUTTONDBLCLK  0x00a6
#define WM_NCMBUTTONDOWN    0x00a7
#define WM_NCMBUTTONUP	    0x00a8
#define WM_NCMBUTTONDBLCLK  0x00a9

/* WINWhere area codes */
#define HTERROR	      -2
#define HTTRANSPARENT -1
#define HTNOWHERE      0
#define HTCLIENT       1
#define HTCAPTION      2
#define HTSYSMENU      3
#define HTGROWBOX      4
#define HTSIZE HTGROWBOX
#define HTMENU	       5
#define HTHSCROLL      6
#define HTVSCROLL      7
#define HTREDUCE       8
#define HTZOOM	       9
#define HTLEFT	       10
#define HTRIGHT	       11
#define HTTOP	       12
#define HTTOPLEFT      13
#define HTTOPRIGHT     14
#define HTBOTTOM       15
#define HTBOTTOMLEFT   16
#define HTBOTTOMRIGHT  17
#define HTSIZEFIRST HTLEFT
#define HTSIZELAST  HTBOTTOMRIGHT
#endif

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE	    1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE	    3

#define WM_KEYFIRST	    0x0100
#define WM_KEYLAST	    0x0108

#define WM_KEYDOWN	    0x0100
#define WM_KEYUP	    0x0101
#define WM_CHAR		    0x0102
#define WM_DEADCHAR	    0x0103
#define WM_SYSKEYDOWN	    0x0104
#define WM_SYSKEYUP	    0x0105
#define WM_SYSCHAR	    0x0106
#define WM_SYSDEADCHAR	    0x0107
#define WM_YOMICHAR	    0x0108
#define WM_CONVERTREQUEST   0x010A
#define WM_CONVERTRESULT    0x010B

#define WM_INITDIALOG	    0x0110
#define WM_COMMAND	    0x0111
#define WM_SYSCOMMAND	    0x0112
#define WM_TIMER	    0x0113
#define WM_HSCROLL	    0x0114
#define WM_VSCROLL	    0x0115
#define WM_INITMENU	    0x0116
#define WM_INITMENUPOPUP    0x0117
#define WM_SYSTIMER	    0x0118
#define WM_MENUSELECT	    0x011f
#define WM_MENUCHAR	    0x0120
#define WM_ENTERIDLE	    0x0121


#define WM_MOUSEFIRST	    0x0200
#define WM_MOUSELAST	    0x0209

#define WM_MOUSEMOVE	    0x0200	/* mouse related constants */
#define WM_LBUTTONDOWN	    0x0201
#define WM_LBUTTONUP	    0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN	    0x0204
#define WM_RBUTTONUP	    0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN	    0x0207
#define WM_MBUTTONUP	    0x0208
#define WM_MBUTTONDBLCLK    0x0209

#define WM_KANJIFIRST	    0x0280
#define WM_KANJILAST	    0x029f

/* clipboard messages */
#define WM_CUT		    0x0300
#define WM_COPY		    0x0301
#define WM_PASTE	    0x0302
#define WM_CLEAR	    0x0303
#define WM_UNDO		    0x0304
#define WM_RENDERFORMAT	    0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_SIZECLIPBOARD    0x030B
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D
#define WM_HSCROLLCLIPBOARD 0x030E

/* 0x03f0 to 0x03ff are reserved */
/* private window messages start here */
#define WM_USER		    0x0400

unsigned FAR PASCAL RegisterWindowMessage(LPSTR);

/* Size message commands */
#define SIZENORMAL	0
#define SIZEICONIC	1
#define SIZEFULLSCREEN	2
#define SIZEZOOMSHOW	3
#define SIZEZOOMHIDE	4
#endif

/* Key state masks for mouse messages */
#ifndef NOKEYSTATE
#define MK_LBUTTON	0x0001
#define MK_RBUTTON	0x0002
#define MK_SHIFT	0x0004
#define MK_CONTROL	0x0008
#define MK_MBUTTON	0x0010
#endif

#ifndef NOWINSTYLES
/* Window styles */
#define WS_TILED	0x00000000L
#define WS_OVERLAPPED	WS_TILED
#define WS_ICONICPOPUP	0xc0000000L
#define WS_POPUP	0x80000000L
#define WS_CHILD	0x40000000L
#define WS_MINIMIZE	0x20000000L
#define WS_VISIBLE	0x10000000L
#define WS_DISABLED	0x08000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_MAXIMIZE	0x01000000L

#define WS_BORDER	0x00800000L
#define WS_CAPTION	0x00c00000L
#define WS_DLGFRAME	0x00400000L
#define WS_VSCROLL	0x00200000L
#define WS_HSCROLL	0x00100000L
#define WS_SYSMENU	0x00080000L
#define WS_SIZEBOX	0x00040000L
#define WS_THICKFRAME	0x00040000L
#define WS_GROUP	0x00020000L
#define WS_TABSTOP	0x00010000L

#define WS_MINIMIZEBOX	0x00020000L
#define WS_MAXIMIZEBOX	0x00010000L

#define WS_ICONIC	WS_MINIMIZE

/* Class styles */
#define CS_VREDRAW	0x0001
#define CS_HREDRAW	0x0002
#define CS_KEYCVTWINDOW 0x0004
#define CS_DBLCLKS	0x0008
#define CS_OEMCHARS	0x0010
#define CS_OWNDC	0x0020
#define CS_CLASSDC	0x0040
#define CS_PARENTDC	0x0080
#define CS_NOKEYCVT	0x0100
#define CS_SAVEBITS	0x0800
#define CS_NOCLOSE	0x0200
#define CS_BYTEALIGNCLIENT 0x1000
#define CS_BYTEALIGNWINDOW 0x2000

/* Shorthand for the common cases */
#define WS_TILEDWINDOW	 (WS_TILED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_OVERLAPPEDWINDOW  WS_TILEDWINDOW
#define WS_POPUPWINDOW	 (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW	 (WS_CHILD)
#endif

/* clipboard metafile picture structure */
#ifndef NOMETAFILE

typedef struct tagHANDLETABLE {
    HANDLE  objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE	*PHANDLETABLE;
typedef HANDLETABLE FAR *LPHANDLETABLE;

typedef struct tagMETARECORD {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  rdParm[1];
} METARECORD;
typedef METARECORD	  *PMETARECORD;
typedef METARECORD    FAR *LPMETARECORD;

typedef struct tagMETAFILEPICT {
    int mm;
    int xExt, yExt;
    HANDLE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR *LPMETAFILEPICT;
#endif

#ifndef NOCLIPBOARD
/* predefined clipboard formats */
#define CF_TEXT		1
#define CF_BITMAP	2
#define CF_METAFILEPICT 3
#define CF_SYLK		4
#define CF_DIF		5
#define CF_TIFF		6
#define CF_OEMTEXT	7

#define CF_OWNERDISPLAY	    0x80       /* owner display */
#define CF_DSPTEXT	    0x81       /* display text */
#define CF_DSPBITMAP	    0x82       /* display bitmap */
#define CF_DSPMETAFILEPICT  0x83       /* display metafile */

/* Private clipboard format range */
#define CF_PRIVATEFIRST 0x200	    /* Anything in this range doesn't */
#define CF_PRIVATELAST	0x2FF	    /* get GlobalFree'd */
#define CF_GDIOBJFIRST	0x300	    /* Anything in this range gets */
#define CF_GDIOBJLAST	0x3FF	    /* DeleteObject'ed */
#endif

#ifndef NOHDC
#ifndef NORECT
typedef struct tagPAINTSTRUCT {
    HDC hdc;
    BOOL fErase;
    RECT rcPaint;
    BOOL fRestore;
    BOOL fIncUpdate;
    BYTE rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT *PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR *NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR *LPPAINTSTRUCT;
#endif
#endif

#ifndef NOCREATESTRUCT
typedef struct tagCREATESTRUCT {
    LPSTR lpCreateParams;
    HANDLE hInstance;
    HANDLE hMenu;
    HWND hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    long style;
    LPSTR lpszName;
    LPSTR lpszClass;
} CREATESTRUCT;
typedef CREATESTRUCT FAR *LPCREATESTRUCT;
#endif

#ifndef NOTEXTMETRIC
/* TextMetric structure */
typedef struct tagTEXTMETRIC {
    short int tmHeight;
    short int tmAscent;
    short int tmDescent;
    short int tmInternalLeading;
    short int tmExternalLeading;
    short int tmAveCharWidth;
    short int tmMaxCharWidth;
    short int tmWeight;
    BYTE      tmItalic;
    BYTE      tmUnderlined;
    BYTE      tmStruckOut;
    BYTE      tmFirstChar;
    BYTE      tmLastChar;
    BYTE      tmDefaultChar;
    BYTE      tmBreakChar;
    BYTE      tmPitchAndFamily;
    BYTE      tmCharSet;
    short int tmOverhang;
    short int tmDigitizedAspectX;
    short int tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC	*PTEXTMETRIC;
typedef TEXTMETRIC NEAR *NPTEXTMETRIC;
typedef TEXTMETRIC FAR *LPTEXTMETRIC;
#endif

#ifndef NOGDI
/* GDI logical objects */
/* Pel Array */
typedef struct tagPELARRAY {
    short int paXCount;
    short int paYCount;
    short int paXExt;
    short int paYExt;
    BYTE      paRGBs;
} PELARRAY;
typedef PELARRAY     *PPELARRAY;
typedef PELARRAY NEAR *NPPELARRAY;
typedef PELARRAY FAR *LPPELARRAY;

/* Logical Brush */
typedef struct tagLOGBRUSH {
    WORD      lbStyle;
    DWORD     lbColor;
    short int lbHatch;
} LOGBRUSH;
typedef LOGBRUSH	*PLOGBRUSH;
typedef LOGBRUSH NEAR	*NPLOGBRUSH;
typedef LOGBRUSH    FAR *LPLOGBRUSH;

/* A PATTERN and a LOGBRUSH are the same thing */
typedef LOGBRUSH     PATTERN;
typedef PATTERN	    *PPATTERN;
typedef PATTERN NEAR *NPPATTERN;
typedef PATTERN FAR *LPPATTERN;

#ifndef NOPOINT
/* Logical Pen */
typedef struct tagLOGPEN {
    WORD   lopnStyle;
    POINT  lopnWidth;
    DWORD  lopnColor;
} LOGPEN;
typedef LOGPEN	    *PLOGPEN;
typedef LOGPEN	NEAR *NPLOGPEN;
typedef LOGPEN	FAR *LPLOGPEN;
#endif

/* Logical Font */

#define LF_FACESIZE 32

typedef struct tagLOGFONT {
    short int lfHeight;
    short int lfWidth;
    short int lfEscapement;
    short int lfOrientation;
    short int lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT	    *PLOGFONT;
typedef LOGFONT NEAR *NPLOGFONT;
typedef LOGFONT FAR *LPLOGFONT;


/* Logical font constants */

#define OUT_DEFAULT_PRECIS    0
#define OUT_STRING_PRECIS     1
#define OUT_CHARACTER_PRECIS  2
#define OUT_STROKE_PRECIS     3

#define CLIP_DEFAULT_PRECIS   0
#define CLIP_CHARACTER_PRECIS 1
#define CLIP_STROKE_PRECIS    2

#define DEFAULT_QUALITY	      0
#define DRAFT_QUALITY	      1
#define PROOF_QUALITY	      2

#define DEFAULT_PITCH	      0
#define FIXED_PITCH	      1
#define VARIABLE_PITCH	      2

#define ANSI_CHARSET	      0
#define SHIFTJIS_CHARSET      128	    /* Kanji CharSet */
#define OEM_CHARSET	      255

/* GDI font families. */
#define FF_DONTCARE	(0<<4)	/* Don't care or don't know. */
#define FF_ROMAN	(1<<4)	/* Variable stroke width, serifed. */
				/* Times Roman, Century Schoolbook, etc. */
#define FF_SWISS	(2<<4)	/* Variable stroke width, sans-serifed. */
				/* Helvetica, Swiss, etc. */
#define FF_MODERN	(3<<4)	/* Constant stroke width, serifed or sans-serifed. */
				/* Pica, Elite, Courier, etc. */
#define FF_SCRIPT	(4<<4)	/* Cursive, etc. */
#define FF_DECORATIVE	(5<<4)	/* Old English, etc. */

/* Font weights lightest to darkest. */
#define FW_DONTCARE	0
#define FW_THIN		100
#define FW_EXTRALIGHT	200
#define FW_LIGHT	300
#define FW_NORMAL	400
#define FW_MEDIUM	500
#define FW_SEMIBOLD	600
#define FW_BOLD		700
#define FW_EXTRABOLD	800
#define FW_HEAVY	900

#define FW_ULTRALIGHT	FW_EXTRALIGHT
#define FW_REGULAR	FW_NORMAL
#define FW_DEMIBOLD	FW_SEMIBOLD
#define FW_ULTRABOLD	FW_EXTRABOLD
#define FW_BLACK	FW_HEAVY


/* EnumFonts masks. */
#define RASTER_FONTTYPE 0x0001
#define DEVICE_FONTTYPE 0X0002


/* GDI rgb values packed into a dword */

#define RGB(r,g,b) (((DWORD) ((b) << 8 | (g)) << 8) | (r))
#define GetRValue(rgb) ((BYTE)(rgb))
#define GetGValue(rgb) ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb) ((BYTE)((rgb)>>16))

/* GDI Background Modes */

#define TRANSPARENT    1
#define OPAQUE	       2

/* GDI map modes */
#define MM_TEXT		    1
#define MM_LOMETRIC	    2
#define MM_HIMETRIC	    3
#define MM_LOENGLISH	    4
#define MM_HIENGLISH	    5
#define MM_TWIPS	    6
#define MM_ISOTROPIC	    7
#define MM_ANISOTROPIC	    8

/* GDI coordinate modes */

#define ABSOLUTE	    1
#define RELATIVE	    2

/* Stock Logical Objects */
#define WHITE_BRUSH	    0
#define LTGRAY_BRUSH	    1
#define GRAY_BRUSH	    2
#define DKGRAY_BRUSH	    3
#define BLACK_BRUSH	    4
#define NULL_BRUSH	    5
#define HOLLOW_BRUSH	    NULL_BRUSH
#define WHITE_PEN	    6
#define BLACK_PEN	    7
#define NULL_PEN	    8
#define OEM_FIXED_FONT	   10
#define ANSI_FIXED_FONT	   11
#define ANSI_VAR_FONT	   12
#define SYSTEM_FONT	   13
#define DEVICEDEFAULT_FONT 14

/* GDI Brush Style definitions. */

#define BS_SOLID	    0
#define BS_NULL		    1
#define BS_HOLLOW	    BS_NULL
#define BS_HATCHED	    2
#define BS_PATTERN	    3
#define BS_INDEXED	    4

/* GDI Hatch Style definitions. */

#define HS_HORIZONTAL	    0	    /* ----- */
#define HS_VERTICAL	    1	    /* ||||| */
#define HS_FDIAGONAL	    2	    /* ///// */
#define HS_BDIAGONAL	    3	    /* \\\\\ */
#define HS_CROSS	    4	    /* +++++ */
#define HS_DIAGCROSS	    5	    /* xxxxx */


/* GDI Pen Style definitions */
#define PS_SOLID	    0	    /* solid pen */
#define PS_DASH		    1	    /* -------	*/
#define PS_DOT		    2	    /* .......	*/
#define PS_DASHDOT	    3	    /* _._._._	*/
#define PS_DASHDOTDOT	    4	    /* _.._.._	*/
#define PS_NULL		    5	    /*		*/

/* Device Parameters for GetDeviceCaps() */

#define DRIVERVERSION 0	    /*	Device driver version		      */
#define TECHNOLOGY    2	    /*	Device classification		      */
#define HORZSIZE      4	    /*	Horizontal size in millimeters	      */
#define VERTSIZE      6	    /*	Vertical   size in millimeters	      */
#define HORZRES	      8	    /*	Horizontal width in pixels	      */
#define VERTRES	      10    /*	Vertical   width in pixels	      */
#define BITSPIXEL     12    /*	Number of bits per pixel	      */
#define PLANES	      14    /*	Number of planes		      */
#define NUMBRUSHES    16    /*	Number of brushes the device has      */
#define NUMPENS	      18    /*	Number of pens the device has	      */
#define NUMMARKERS    20    /*	Number of markers the device has      */
#define NUMFONTS      22    /*	Number of fonts the device has	      */
#define NUMCOLORS     24
#define PDEVICESIZE   26    /*	Size required for device descriptor   */
#define CURVECAPS     28    /*	Curves	  capabilities		      */
#define LINECAPS      30    /*	Line	  capabilities		      */
#define POLYGONALCAPS 32    /*	Polygonal capabilities		      */
#define TEXTCAPS      34    /*	Text	  capabilities		      */
#define CLIPCAPS      36    /*	Clipping  capabilities		      */
#define RASTERCAPS    38    /*	Bitblt	  capabilities		      */
#define ASPECTX	      40    /*	Length of the X leg		      */
#define ASPECTY	      42    /*	Length of the Y leg		      */
#define ASPECTXY      44    /*	Length of the hypotenuse	      */

#define LOGPIXELSX    88    /*	Logical pixels/inch in X	      */
#define LOGPIXELSY    90    /*	Logical pixels/inch in Y	      */

#ifndef NOGDICAPMASKS

/* Device capability masks */
/*   Device Technologies */

#define DT_PLOTTER	0   /* Vector plotter	       */
#define DT_RASDISPLAY	1   /* Raster display	       */
#define DT_RASPRINTER	2   /* Raster printer	       */
#define DT_RASCAMERA	3   /* Raster camera	       */
#define DT_CHARSTREAM	4   /* Character-stream, PLP   */
#define DT_METAFILE	5   /* Metafile, VDM	       */
#define DT_DISPFILE	6   /* Display-file	       */

/*   Curve Capabilities */

#define CC_NONE		0   /* Curves not supported    */
#define CC_CIRCLES	1   /* Can do circles	       */
#define CC_PIE		2   /* Can do pie wedges       */
#define CC_CHORD	4   /* Can do chord arcs       */
#define CC_ELLIPSES	8   /* Can do ellipese	       */
#define CC_WIDE		16  /* Can do wide lines       */
#define CC_STYLED	32  /* Can do styled lines     */
#define CC_WIDESTYLED	64  /* Can do wide styled lines*/
#define CC_INTERIORS	128 /* Can do interiors	       */

/*   Line Capabilities */

#define LC_NONE		0   /* Lines not supported     */
#define LC_POLYLINE	2   /* Can do polylines	       */
#define LC_MARKER	4   /* Can do markers	       */
#define LC_POLYMARKER	8   /* Can do polymarkers      */
#define LC_WIDE		16  /* Can do wide lines       */
#define LC_STYLED	32   /* Can do styled lines	*/
#define LC_WIDESTYLED	64   /* Can do wide styled lines*/
#define LC_INTERIORS	128  /* Can do interiors	*/

/*   Polygonal Capabilities */

#define PC_NONE		0   /* Polygonals not supported*/
#define PC_POLYGON	1   /* Can do polygons	       */
#define PC_RECTANGLE	2   /* Can do rectangles       */
#define PC_TRAPEZOID	4   /* Can do trapezoids       */
#define PC_SCANLINE	8   /* Can do scanlines	       */
#define PC_WIDE		16  /* Can do wide borders     */
#define PC_STYLED	32   /* Can do styled borders	*/
#define PC_WIDESTYLED	64   /* Can do wide styled borders*/
#define PC_INTERIORS	128  /* Can do interiors	*/

/*   Polygonal Capabilities */

#define CP_NONE		0   /* no clipping of Output   */
#define CP_RECTANGLE	1   /* Output clipped to Rects */

/*   Text Capabilities */

#define TC_OP_CHARACTER 0x0001	/* Can do OutputPrecision   CHARACTER	   */
#define TC_OP_STROKE	0x0002	/* Can do OutputPrecision   STROKE	   */
#define TC_CP_STROKE	0x0004	/* Can do ClipPrecision	    STROKE	   */
#define TC_CR_90	0x0008	/* Can do CharRotAbility    90		   */
#define TC_CR_ANY	0x0010	/* Can do CharRotAbility    ANY		   */
#define TC_SF_X_YINDEP	0x0020	/* Can do ScaleFreedom	    X_YINDEPENDENT */
#define TC_SA_DOUBLE	0x0040	/* Can do ScaleAbility	    DOUBLE	   */
#define TC_SA_INTEGER	0x0080	/* Can do ScaleAbility	    INTEGER	   */
#define TC_SA_CONTIN	0x0100	/* Can do ScaleAbility	    CONTINUOUS	   */
#define TC_EA_DOUBLE	0x0200	/* Can do EmboldenAbility   DOUBLE	   */
#define TC_IA_ABLE	0x0400	/* Can do ItalisizeAbility  ABLE	   */
#define TC_UA_ABLE	0x0800	/* Can do UnderlineAbility  ABLE	   */
#define TC_SO_ABLE	0x1000	/* Can do StrikeOutAbility  ABLE	   */
#define TC_RA_ABLE	0x2000	/* Can do RasterFontAble    ABLE	   */
#define TC_VA_ABLE	0x4000	/* Can do VectorFontAble    ABLE	   */
#define TC_RESERVED	0x8000	/* Reserved.				   */
#endif

/*   Raster Capabilities */

#define RC_BITBLT	1   /* Can do standard non-stretching, non-inverting BLT. */
#define RC_BANDING	2   /* Device requires banding support			  */
#define RC_SCALING	4   /* Device requires scaling support */
#define RC_BITMAP64	8   /* Device can support >64K bitmap  */

#endif


#ifndef NOMSG
BOOL FAR PASCAL GetMessage(LPMSG, HWND, unsigned, unsigned);
BOOL FAR PASCAL TranslateMessage(LPMSG);
LONG FAR PASCAL DispatchMessage(LPMSG);
BOOL FAR PASCAL PeekMessage(LPMSG, HWND, unsigned, WORD, WORD);

/* PeekMessage options */
#define PM_REMOVE   TRUE
#define PM_NOREMOVE FALSE
#define PM_NOYIELD  0x02
#endif

BOOL  FAR PASCAL SwapMouseButton(BOOL);
DWORD FAR PASCAL GetMessagePos(void);
long  FAR PASCAL GetMessageTime(void);

HWND FAR PASCAL GetSysModalWindow(void);
HWND FAR PASCAL SetSysModalWindow(HWND);

#ifndef NOWINMESSAGES
long FAR PASCAL SendMessage(HWND, unsigned, WORD, LONG);
BOOL FAR PASCAL PostMessage(HWND, unsigned, WORD, LONG);
BOOL FAR PASCAL PostAppMessage(HANDLE, unsigned, WORD, LONG);
void FAR PASCAL ReplyMessage(long);
void FAR PASCAL WaitMessage(void);
long FAR PASCAL DefWindowProc(HWND, unsigned, WORD, LONG);
void FAR PASCAL PostQuitMessage(int);
long FAR PASCAL CallWindowProc(FARPROC, HWND, unsigned, WORD, LONG);
BOOL FAR PASCAL InSendMessage(void);
#endif

WORD FAR PASCAL GetDoubleClickTime( void );
void FAR PASCAL SetDoubleClickTime(WORD);

#ifndef NOWNDCLASS
#ifndef NOBRUSH
BOOL FAR PASCAL RegisterClass(LPWNDCLASS);
#endif
#endif

BOOL FAR PASCAL SetMessageQueue(int);

HWND FAR PASCAL CreateWindow(LPSTR, LPSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPSTR);
#define	    CW_USEDEFAULT	((int)0x8000)	   /*used on both x and cx */


BOOL FAR PASCAL IsWindow(HWND);
BOOL FAR PASCAL DestroyWindow(HWND);

BOOL FAR PASCAL ShowWindow(HWND, int);
BOOL FAR PASCAL FlashWindow(HWND, BOOL);
void FAR PASCAL ShowOwnedPopups(HWND, BOOL);

BOOL FAR PASCAL OpenIcon(HWND);
void FAR PASCAL CloseWindow(HWND);
void FAR PASCAL MoveWindow(HWND, int, int, int, int, BOOL);
void FAR PASCAL SetWindowPos(HWND, HWND, int, int, int, int, WORD);
BOOL FAR PASCAL IsWindowVisible(HWND);
BOOL FAR PASCAL IsIconic(HWND);
BOOL FAR PASCAL AnyPopup(void);
void FAR PASCAL BringWindowToTop(HWND);
BOOL FAR PASCAL IsZoomed(HWND);

/* SetWindowPos flags */

#define SWP_NOSIZE	 0x01
#define SWP_NOMOVE	 0x02
#define SWP_NOZORDER	 0x04
#define SWP_NOREDRAW	 0x08
#define SWP_NOACTIVATE	 0x10
#define SWP_DRAWFRAME	 0x20
#define SWP_SHOWWINDOW	 0x40
#define SWP_HIDEWINDOW	 0x80
#define SWP_NOCOPYBITS	 0x0100
#define SWP_NOREPOSITION 0x200


#ifndef NODRAWFRAME
#ifndef NORECT
#ifndef NOHDC

/* DrawFrame and associated defines */
#define DF_SHIFT0	    0x0000
#define DF_SHIFT1	    0x0001
#define DF_SHIFT2	    0x0002
#define DF_SHIFT3	    0x0003
#define DF_PATCOPY	    0x0000
#define DF_PATINVERT	    0x0004

#define DF_SCROLLBAR	    (COLOR_SCROLLBAR << 3)
#define DF_BACKGROUND	    (COLOR_BACKGROUND << 3)
#define DF_ACTIVECAPTION    (COLOR_ACTIVECAPTION << 3)
#define DF_INACTIVECAPTION  (COLOR_INACTIVECAPTION << 3)
#define DF_MENU		    (COLOR_MENU << 3)
#define DF_WINDOW	    (COLOR_WINDOW << 3)
#define DF_WINDOWFRAME	    (COLOR_WINDOWFRAME << 3)
#define DF_MENUTEXT	    (COLOR_MENUTEXT << 3)
#define DF_WINDOWTEXT	    (COLOR_WINDOWTEXT << 3)
#define DF_CAPTIONTEXT	    (COLOR_CAPTIONTEXT << 3)
#define DF_ACTIVEBORDER	    (COLOR_ACTIVEBORDER << 3)
#define DF_INACTIVEBORDER   (COLOR_INACTIVEBORDER << 3)
#define DF_APPWORKSPACE	    (COLOR_APPWORKSPACE << 3)
#define DF_GRAY		    (DF_APPWORKSPACE + (1 << 3))

#endif
#endif
#endif


/* DrawText format flags */
#ifndef NODRAWTEXT
#define DT_LEFT		   0x00
#define DT_CENTER	   0x01
#define DT_RIGHT	   0x02
#define DT_TOP		   0x00
#define DT_VCENTER	   0x04
#define DT_BOTTOM	   0x08
#define DT_WORDBREAK	   0x10
#define DT_SINGLELINE	   0x20
#define DT_EXPANDTABS	   0x40
#define DT_TABSTOP	   0x80
#define DT_NOCLIP	   0x100
#define DT_EXTERNALLEADING 0x200
#define DT_CALCRECT	   0x400
#define DT_NOPREFIX	   0x800
#define DT_INTERNAL	   0x1000

#ifndef NOHDC
#ifndef NORECT
int  FAR PASCAL DrawText(HDC, LPSTR, int, LPRECT, WORD);
#endif
BOOL FAR PASCAL DrawIcon(HDC, int, int, HICON);
#endif
#endif

#ifndef NOCTLMGR
HWND FAR PASCAL CreateDialog(HANDLE, LPSTR, HWND, FARPROC);
HWND FAR PASCAL CreateDialogIndirect(HANDLE, LPSTR, HWND, FARPROC);
int  FAR PASCAL DialogBox(HANDLE, LPSTR, HWND, FARPROC);
int  FAR PASCAL DialogBoxIndirect(HANDLE, HANDLE, HWND, FARPROC);
void FAR PASCAL EndDialog(HWND, int);
HWND FAR PASCAL GetDlgItem(HWND, int);
void FAR PASCAL SetDlgItemInt(HWND, int, unsigned, BOOL);
unsigned FAR PASCAL GetDlgItemInt(HWND, int, BOOL FAR *, BOOL);
void FAR PASCAL SetDlgItemText(HWND, int, LPSTR);
int  FAR PASCAL GetDlgItemText(HWND, int, LPSTR, int);
void FAR PASCAL CheckDlgButton(HWND, int, WORD);
void FAR PASCAL CheckRadioButton(HWND, int, int, int);
WORD FAR PASCAL IsDlgButtonChecked(HWND, int);
long FAR PASCAL SendDlgItemMessage(HWND, int, unsigned, WORD, LONG);
HWND FAR PASCAL GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND FAR PASCAL GetNextDlgTabItem(HWND, HWND, BOOL);
#endif

#ifndef NOMSG
BOOL FAR PASCAL CallMsgFilter(LPMSG, int);
#endif

#ifndef NOCLIPBOARD
/* Clipboard manager routines */
BOOL   FAR PASCAL OpenClipboard(HWND);
BOOL   FAR PASCAL CloseClipboard(void);
HWND   FAR PASCAL GetClipboardOwner(void);
HWND   FAR PASCAL SetClipboardViewer(HWND);
HWND   FAR PASCAL GetClipboardViewer(void);
BOOL   FAR PASCAL ChangeClipboardChain(HWND, HWND);
HANDLE FAR PASCAL SetClipboardData(WORD, HANDLE);
HANDLE FAR PASCAL GetClipboardData(WORD);
WORD   FAR PASCAL RegisterClipboardFormat(LPSTR);
int    FAR PASCAL CountClipboardFormats(void);
WORD   FAR PASCAL EnumClipboardFormats(WORD);
int    FAR PASCAL GetClipboardFormatName(WORD, LPSTR, int);
BOOL   FAR PASCAL EmptyClipboard(void);
BOOL   FAR PASCAL IsClipboardFormatAvailable(WORD);
#endif

HWND FAR PASCAL SetFocus(HWND);
HWND FAR PASCAL GetFocus(void);
HWND FAR PASCAL GetActiveWindow(void);

int  FAR PASCAL GetKeyState(int);
int  FAR PASCAL GetAsyncKeyState(int);
void FAR PASCAL GetKeyboardState(BYTE FAR *);
void FAR PASCAL SetKeyboardState(BYTE FAR *);
BOOL FAR PASCAL EnableHardwareInput(BOOL);
BOOL FAR PASCAL GetInputState();

HWND FAR PASCAL GetCapture(void);
HWND FAR PASCAL SetCapture(HWND);
void FAR PASCAL ReleaseCapture(void);

/* Windows Functions */
WORD FAR PASCAL SetTimer(HWND, short, unsigned, FARPROC);
BOOL FAR PASCAL KillTimer(HWND, short);

BOOL FAR PASCAL EnableWindow(HWND,BOOL);
BOOL FAR PASCAL IsWindowEnabled(HWND);

HANDLE FAR PASCAL LoadAccelerators(HANDLE, LPSTR);

#ifndef NOMSG
int  FAR PASCAL TranslateAccelerator(HWND, HANDLE, LPMSG);
#endif

#ifndef NOSYSMETRICS

/* GetSystemMetrics codes */
#define SM_CXSCREEN	   0
#define SM_CYSCREEN	   1
#define SM_CXVSCROLL	   2
#define SM_CYHSCROLL	   3
#define SM_CYCAPTION	   4
#define SM_CXBORDER	   5
#define SM_CYBORDER	   6
#define SM_CXDLGFRAME	   7
#define SM_CYDLGFRAME	   8
#define SM_CYVTHUMB	   9
#define SM_CXHTHUMB	  10
#define SM_CXICON	  11
#define SM_CYICON	  12
#define SM_CXCURSOR	  13
#define SM_CYCURSOR	  14
#define SM_CYMENU	  15
#define SM_CXFULLSCREEN	  16
#define SM_CYFULLSCREEN	  17
#define SM_CYKANJIWINDOW  18
#define SM_MOUSEPRESENT	  19
#define SM_CYVSCROLL	  20
#define SM_CXHSCROLL	  21
#define SM_DEBUG	  22
#define SM_SWAPBUTTON	  23
#define SM_RESERVED1	  24
#define SM_RESERVED2	  25
#define SM_RESERVED3	  26	    /* new additions since 2.0 */
#define SM_RESERVED4	  27
#define SM_CXMIN	  28
#define SM_CYMIN	  29
#define SM_CXSIZE	  30
#define SM_CYSIZE	  31
#define SM_CXFRAME	  32
#define SM_CYFRAME	  33
#define SM_CXMINTRACK	  34
#define SM_CYMINTRACK	  35
#define SM_CMETRICS	  36

int FAR PASCAL GetSystemMetrics(int);
#endif

#ifndef NOMENUS
BOOL  FAR PASCAL HiliteMenuItem(HWND, HMENU, WORD, WORD);
int   FAR PASCAL GetMenuString(HMENU, WORD, LPSTR, int, WORD);
WORD  FAR PASCAL GetMenuState(HMENU, WORD, WORD);
void  FAR PASCAL DrawMenuBar(HWND);
HMENU FAR PASCAL GetSystemMenu(HWND, BOOL);
HMENU FAR PASCAL CreateMenu(void);
BOOL  FAR PASCAL DestroyMenu(HMENU);
BOOL  FAR PASCAL ChangeMenu(HMENU, WORD, LPSTR, WORD, WORD);
BOOL  FAR PASCAL CheckMenuItem(HMENU, WORD, WORD);
BOOL  FAR PASCAL EnableMenuItem(HMENU, WORD, WORD);
HMENU FAR PASCAL GetSubMenu(HMENU, int);
WORD  FAR PASCAL GetMenuItemID(HMENU, int);
WORD  FAR PASCAL GetMenuItemCount(HMENU);
#endif

BOOL FAR PASCAL GrayString(HDC, HBRUSH, FARPROC, DWORD, int, int, int, int, int);
void FAR PASCAL UpdateWindow(HWND);
HWND FAR PASCAL SetActiveWindow(HWND);

#ifndef NOHDC
HDC FAR PASCAL GetWindowDC(HWND);
HDC FAR PASCAL GetDC(HWND);
int FAR PASCAL ReleaseDC(HWND, HDC);

#ifndef NORECT
HDC FAR PASCAL BeginPaint(HWND, LPPAINTSTRUCT);

void FAR PASCAL EndPaint(HWND, LPPAINTSTRUCT);
BOOL FAR PASCAL GetUpdateRect(HWND, LPRECT, BOOL);
int  FAR PASCAL GetUpdateRgn(HWND, HRGN, BOOL);
#endif
#endif
short FAR PASCAL ExcludeUpdateRgn(HDC, HWND);

#ifndef NORECT
void FAR PASCAL InvalidateRect(HWND, LPRECT, BOOL);
void FAR PASCAL ValidateRect(HWND, LPRECT);
#endif

#ifndef NOREGION
void FAR PASCAL InvalidateRgn(HWND, HRGN, BOOL);
void FAR PASCAL ValidateRgn(HWND, HRGN);
#endif

#ifndef NORECT
void FAR PASCAL ScrollWindow(HWND, int, int, LPRECT, LPRECT);
BOOL FAR PASCAL ScrollDC(HDC, int, int, LPRECT, LPRECT, HRGN, LPRECT);
#endif


#ifndef NOSCROLL
int  FAR PASCAL SetScrollPos(HWND, int, int, BOOL);
int  FAR PASCAL GetScrollPos(HWND, int);
void FAR PASCAL SetScrollRange(HWND, int, int, int, BOOL);
void FAR PASCAL GetScrollRange(HWND, int, LPINT, LPINT);
void FAR PASCAL ShowScrollBar(HWND, WORD, BOOL);
#endif

BOOL   FAR PASCAL SetProp(HWND, LPSTR, HANDLE);
HANDLE FAR PASCAL GetProp(HWND, LPSTR);
HANDLE FAR PASCAL RemoveProp(HWND, LPSTR);
int    FAR PASCAL EnumProps(HWND, FARPROC);
void   FAR PASCAL SetWindowText(HWND, LPSTR);
int    FAR PASCAL GetWindowText(HWND, LPSTR, int);
int    FAR PASCAL GetWindowTextLength(HWND);
#ifndef NOMENUS
BOOL   FAR PASCAL SetMenu(HWND, HMENU);
HMENU  FAR PASCAL GetMenu(HWND);
#endif

#ifndef NORECT
void FAR PASCAL GetClientRect(HWND, LPRECT);
void FAR PASCAL GetWindowRect(HWND, LPRECT);
void FAR PASCAL AdjustWindowRect(LPRECT, long, BOOL);
#endif

/* MessageBox type flags */
#ifndef NOMB
#define MB_OK		    0x0000
#define MB_OKCANCEL	    0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL	    0x0003
#define MB_YESNO	    0x0004
#define MB_RETRYCANCEL	    0x0005

#define MB_ICONHAND	    0x0010
#define MB_ICONQUESTION	    0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK	    0x0040

#define MB_DEFBUTTON1	    0x0000
#define MB_DEFBUTTON2	    0x0100
#define MB_DEFBUTTON3	    0x0200

#define MB_APPLMODAL	    0x0000
#define MB_SYSTEMMODAL	    0x1000
#define MB_NOFOCUS	    0x8000
#define MB_MISCMASK	    0xC000
#define MB_TYPEMASK	    0x000F
#define MB_ICONMASK	    0x00F0
#define MB_DEFMASK	    0x0F00
#define MB_MODEMASK	    0x3000

int  FAR PASCAL MessageBox(HWND, LPSTR, LPSTR, WORD);
BOOL FAR PASCAL MessageBeep(WORD);
#endif

int  FAR PASCAL ShowCursor(BOOL);

HCURSOR FAR PASCAL SetCursor(HCURSOR);

void FAR PASCAL SetCursorPos(int, int);

#ifndef NOPOINT
void FAR PASCAL GetCursorPos(LPPOINT);
#endif

#ifndef NORECT
void FAR PASCAL ClipCursor(LPRECT);
#endif

#ifndef NOBITMAP
void FAR PASCAL CreateCaret(HWND, HBITMAP, int, int);

#endif

WORD FAR PASCAL GetCaretBlinkTime();
void FAR PASCAL SetCaretBlinkTime(WORD);
void FAR PASCAL DestroyCaret(void);
void FAR PASCAL HideCaret(HWND);
void FAR PASCAL ShowCaret(HWND);
void FAR PASCAL SetCaretPos(int, int);
void FAR PASCAL GetCaretPos(LPPOINT);

#ifndef NOPOINT
void FAR PASCAL ClientToScreen(HWND, LPPOINT);
void FAR PASCAL ScreenToClient(HWND, LPPOINT);
HWND FAR PASCAL WindowFromPoint(POINT);
HWND FAR PASCAL ChildWindowFromPoint(HWND, POINT);
#endif

/* color type indices		*/
#ifndef NOCOLOR
/* for the WM_CTLCOLOR message */
#define CTLCOLOR_MSGBOX		0
#define CTLCOLOR_EDIT		1
#define CTLCOLOR_LISTBOX	2
#define CTLCOLOR_BTN		3
#define CTLCOLOR_DLG		4
#define CTLCOLOR_SCROLLBAR	5
#define CTLCOLOR_STATIC		6
#define CTLCOLOR_MAX		8     /* three bits max */

#define COLOR_SCROLLBAR		0
#define COLOR_BACKGROUND	1
#define COLOR_ACTIVECAPTION	2
#define COLOR_INACTIVECAPTION	3
#define COLOR_MENU		4
#define COLOR_WINDOW		5
#define COLOR_WINDOWFRAME	6
#define COLOR_MENUTEXT		7
#define COLOR_WINDOWTEXT	8
#define COLOR_CAPTIONTEXT	9
#define COLOR_ACTIVEBORDER	10
#define COLOR_INACTIVEBORDER	11
#define COLOR_APPWORKSPACE	12

DWORD FAR PASCAL GetSysColor(int);
void  FAR PASCAL SetSysColors(int, LPINT, long FAR *);
#endif

#define CP_GETBEEP	1
#define CP_SETBEEP	2
#define CP_GETMOUSE	3
#define CP_SETMOUSE	4
#define CP_GETBORDER	5
#define CP_SETBORDER	6
#define CP_TIMEOUTS	7
#define CP_KANJIMENU	8
#define CP_GETKSPEED 	10
#define CP_SETKSPEED 	11
void FAR PASCAL ControlPanelInfo(WORD, WORD, LONG);

#ifndef NOHDC
HDC   FAR PASCAL CreateDC(LPSTR, LPSTR, LPSTR, LPSTR);
HDC   FAR PASCAL CreateIC(LPSTR, LPSTR, LPSTR, LPSTR);
HDC   FAR PASCAL CreateCompatibleDC ( HDC );
BOOL  FAR PASCAL DeleteDC(HDC);
short FAR PASCAL SaveDC(HDC);
BOOL  FAR PASCAL RestoreDC(HDC, short);
DWORD FAR PASCAL MoveTo(HDC, short, short);
DWORD FAR PASCAL GetCurrentPosition(HDC);
BOOL  FAR PASCAL LineTo(HDC, short, short);
DWORD FAR PASCAL GetDCOrg(HDC);

#ifndef NORECT
BOOL  FAR PASCAL ExtTextOut(HDC, short, short, WORD, LPRECT, LPSTR, WORD, LPINT);
BOOL  FAR PASCAL FastWindowFrame( HDC, LPRECT, WORD, WORD, DWORD);
#endif

#ifndef NOPOINT
BOOL FAR PASCAL Polyline(HDC, LPPOINT, short);
BOOL FAR PASCAL Polygon( HDC, LPPOINT, short);
#endif

BOOL  FAR PASCAL Rectangle(HDC, short, short, short, short);
BOOL  FAR PASCAL RoundRect(HDC, short, short, short, short, short, short);
BOOL  FAR PASCAL Ellipse(HDC, short, short, short, short);
BOOL  FAR PASCAL Arc(HDC, short, short, short, short, short, short, short, short);
BOOL  FAR PASCAL Chord(HDC, short, short, short, short, short, short, short, short);
BOOL  FAR PASCAL Pie(HDC, short, short, short, short, short, short, short, short);
BOOL  FAR PASCAL PatBlt(HDC, short, short, short, short, DWORD);
BOOL  FAR PASCAL BitBlt(HDC, short, short, short, short, HDC, short, short, DWORD);
BOOL  FAR PASCAL StretchBlt(HDC, short, short, short, short, HDC, short, short, short, short, DWORD);
BOOL  FAR PASCAL TextOut(HDC, short, short, LPSTR, short);
BOOL  FAR PASCAL GetCharWidth(HDC, WORD, WORD, LPINT);
DWORD FAR PASCAL SetPixel( HDC, short, short, DWORD);
DWORD FAR PASCAL GetPixel( HDC, short, short);
BOOL  FAR PASCAL FloodFill( HDC, short, short, DWORD);
#endif

void  FAR PASCAL LineDDA(short, short, short, short, FARPROC, LPSTR);

#ifndef NORECT
#ifndef NOHDC
#ifndef NOBRUSH
int FAR PASCAL FillRect(HDC, LPRECT, HBRUSH);
int FAR PASCAL FrameRect(HDC, LPRECT, HBRUSH);
#endif
int FAR PASCAL InvertRect(HDC, LPRECT);
#endif
#endif


#ifndef NOREGION
#ifndef NOHDC
#ifndef NOBRUSH
BOOL FAR PASCAL FillRgn(HDC, HRGN, HBRUSH);
BOOL FAR PASCAL FrameRgn(HDC, HRGN, HBRUSH, short, short);
#endif
BOOL FAR PASCAL InvertRgn(HDC, HRGN);
BOOL FAR PASCAL PaintRgn(HDC, HRGN);
BOOL FAR PASCAL PtInRegion(HRGN, short, short);
#endif
#endif

HANDLE FAR PASCAL GetStockObject(short);

#ifndef NOPEN
HPEN FAR PASCAL CreatePen(short, short, DWORD);
HPEN FAR PASCAL CreatePenIndirect(LOGPEN FAR *);
#endif

#ifndef NOBRUSH
HBRUSH FAR PASCAL CreateSolidBrush(DWORD);
HBRUSH FAR PASCAL CreateHatchBrush(short,DWORD);
DWORD  FAR PASCAL SetBrushOrg(HDC, int, int);
DWORD  FAR PASCAL GetBrushOrg(HDC);
BOOL   FAR PASCAL UnrealizeObject(HBRUSH);
#endif

#ifndef NOBRUSH
#ifndef NOBITMAP
HBRUSH FAR PASCAL CreatePatternBrush(HBITMAP);
#endif
#ifndef NOGDI
HBRUSH FAR PASCAL CreateBrushIndirect(LOGBRUSH FAR *);
#endif
#endif


#ifndef NOBITMAP
HBITMAP FAR PASCAL CreateBitmap(short, short, BYTE, BYTE, LPSTR);
HBITMAP FAR PASCAL CreateBitmapIndirect(BITMAP FAR *);
#ifndef NOHDC
HBITMAP FAR PASCAL CreateCompatibleBitmap(HDC, short, short);
HBITMAP FAR PASCAL CreateDiscardableBitmap(HDC, short, short);
#endif
long  FAR PASCAL SetBitmapBits(HBITMAP, DWORD, LPSTR);
long  FAR PASCAL GetBitmapBits(HBITMAP, long, LPSTR);
DWORD FAR PASCAL SetBitmapDimension(HBITMAP, short, short);
DWORD FAR PASCAL GetBitmapDimension(HBITMAP);
#endif

#ifndef NOFONT
HFONT FAR PASCAL CreateFont(short, short, short, short, short, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPSTR);
#ifndef NOGDI
HFONT FAR PASCAL CreateFontIndirect(LOGFONT FAR *);
#endif
#endif

#ifndef NOREGION
HRGN FAR PASCAL CreateRectRgn(short, short, short, short);
void FAR PASCAL SetRectRgn(HRGN, short, short, short, short);

#ifndef NORECT
HRGN FAR PASCAL CreateRectRgnIndirect(LPRECT);
HRGN FAR PASCAL CreateEllipticRgnIndirect(LPRECT);
#endif

HRGN FAR PASCAL CreateEllipticRgn(short, short, short, short);
#ifndef NOPOINT
HRGN FAR PASCAL CreatePolygonRgn(LPPOINT, short, short);
#endif
#endif

BOOL FAR PASCAL DeleteObject(HANDLE);
#ifndef NOHDC
HANDLE FAR PASCAL SelectObject(HDC, HANDLE);
#endif

#ifndef NOREGION
#ifndef NOHDC
short FAR PASCAL SelectClipRgn(HDC, HRGN);
#endif
#endif

short FAR PASCAL GetObject(HANDLE, short, LPSTR);

#ifndef NOHDC
short FAR PASCAL SetRelAbs(HDC, short);
short FAR PASCAL GetRelAbs(HDC);
DWORD FAR PASCAL SetBkColor(HDC, DWORD);
DWORD FAR PASCAL GetBkColor(HDC);
short FAR PASCAL SetBkMode(HDC, short);
short FAR PASCAL GetBkMode(HDC);
DWORD FAR PASCAL SetTextColor(HDC, DWORD);
DWORD FAR PASCAL GetTextColor(HDC);
WORD  FAR PASCAL SetTextAlign(HDC, WORD);
WORD  FAR PASCAL GetTextAlign(HDC);
DWORD FAR PASCAL SetMapperFlags(HDC, DWORD);
DWORD FAR PASCAL GetAspectRatioFilter(HDC);
DWORD FAR PASCAL GetNearestColor(HDC, DWORD);
short FAR PASCAL SetROP2(HDC, short);
short FAR PASCAL GetROP2(HDC);
short FAR PASCAL SetStretchBltMode( HDC, short);
short FAR PASCAL GetStretchBltMode( HDC );
short FAR PASCAL SetPolyFillMode( HDC, short);
short FAR PASCAL GetPolyFillMode( HDC );
short FAR PASCAL SetMapMode(HDC, short);
short FAR PASCAL GetMapMode(HDC);
DWORD FAR PASCAL SetWindowOrg(HDC, short, short);
DWORD FAR PASCAL GetWindowOrg(HDC);
DWORD FAR PASCAL SetWindowExt(HDC, short, short);
DWORD FAR PASCAL GetWindowExt(HDC);
DWORD FAR PASCAL SetViewportOrg(HDC, short, short);
DWORD FAR PASCAL GetViewportOrg(HDC);
DWORD FAR PASCAL SetViewportExt(HDC, short, short);
DWORD FAR PASCAL GetViewportExt(HDC);

DWORD FAR PASCAL OffsetViewportOrg(HDC, short, short);
DWORD FAR PASCAL ScaleViewportExt(HDC, short, short, short, short);
DWORD FAR PASCAL OffsetWindowOrg(HDC, short, short);
DWORD FAR PASCAL ScaleWindowExt(HDC, short, short, short, short);

#ifndef NORECT
short FAR PASCAL GetClipBox(HDC, LPRECT);
#endif

short FAR PASCAL IntersectClipRect(HDC, short, short, short, short);
short FAR PASCAL OffsetClipRgn(HDC, short, short);
short FAR PASCAL ExcludeClipRect(HDC, short, short, short, short);
BOOL  FAR PASCAL PtVisible(HDC, short, short);
#endif

#ifndef NORECT
int  FAR PASCAL SetRect(LPRECT, int, int, int, int);
int  FAR PASCAL SetRectEmpty(LPRECT);
int  FAR PASCAL CopyRect(LPRECT, LPRECT);
int  FAR PASCAL InflateRect(LPRECT, int, int);
int  FAR PASCAL IntersectRect(LPRECT, LPRECT, LPRECT);
int  FAR PASCAL UnionRect(LPRECT, LPRECT, LPRECT);
int  FAR PASCAL OffsetRect(LPRECT, int, int);
BOOL FAR PASCAL IsRectEmpty(LPRECT);
BOOL FAR PASCAL EqualRect(LPRECT, LPRECT);

#ifndef NOPOINT
BOOL FAR PASCAL PtInRect(LPRECT, POINT);
#endif

#ifndef NOHDC
BOOL FAR PASCAL RectVisible(HDC, LPRECT);
#endif
#endif

#ifndef NOREGION
short FAR PASCAL CombineRgn(HRGN, HRGN, HRGN, short);
BOOL  FAR PASCAL EqualRgn(HRGN, HRGN);
short FAR PASCAL OffsetRgn(HRGN, short, short);
#endif

#ifndef NOHDC
short FAR PASCAL SetTextJustification(HDC, short, short);
DWORD FAR PASCAL GetTextExtent(HDC, LPSTR, short);
short FAR PASCAL SetTextCharacterExtra(HDC, short);
short FAR PASCAL GetTextCharacterExtra(HDC);
#endif

HANDLE FAR PASCAL  GetMetaFile(LPSTR);
BOOL   FAR PASCAL  DeleteMetaFile(HANDLE);
HANDLE FAR PASCAL  CopyMetaFile(HANDLE, LPSTR);

#ifndef NOHDC

#ifndef NOMETAFILE
void FAR PASCAL PlayMetaFileRecord(HDC, LPHANDLETABLE, LPMETARECORD, WORD);
BOOL FAR PASCAL EnumMetaFile(HDC, LOCALHANDLE, FARPROC, BYTE FAR *);
#endif

BOOL  FAR PASCAL  PlayMetaFile(HDC, HANDLE);
short FAR PASCAL Escape(HDC, short, short, LPSTR, LPSTR);
short FAR PASCAL EnumFonts(HDC, LPSTR, FARPROC, LPSTR);
short FAR PASCAL EnumObjects(HDC, short, FARPROC, LPSTR);
short FAR PASCAL GetTextFace(HDC, short, LPSTR);
#ifndef NOTEXTMETRIC
BOOL  FAR PASCAL GetTextMetrics(HDC, LPTEXTMETRIC );
#endif
short FAR PASCAL GetDeviceCaps(HDC, short);
#endif

LPSTR FAR PASCAL DeviceModes(HWND, HANDLE, LPSTR, LPSTR);
short FAR PASCAL SetEnvironment(LPSTR, LPSTR, WORD);
short FAR PASCAL GetEnvironment(LPSTR, LPSTR, WORD);

#ifndef NOHDC
#ifndef NOPOINT
BOOL FAR PASCAL DPtoLP(HDC, LPPOINT, short);
BOOL FAR PASCAL LPtoDP(HDC, LPPOINT, short);
#endif
#endif

/* Interface to the dynamic loader/linker */

WORD	FAR PASCAL GetVersion( void );
WORD	FAR PASCAL GetNumTasks( void );
HANDLE	FAR PASCAL GetCodeHandle( FARPROC );
HANDLE	FAR PASCAL GetModuleHandle( LPSTR );
int	FAR PASCAL GetModuleUsage( HANDLE );
int	FAR PASCAL GetModuleFileName( HANDLE, LPSTR, int );
int	FAR PASCAL GetInstanceData( HANDLE, NPSTR, int );
FARPROC FAR PASCAL GetProcAddress(  HANDLE, LPSTR );
FARPROC FAR PASCAL MakeProcInstance( FARPROC, HANDLE );
void	FAR PASCAL FreeProcInstance( FARPROC );
HANDLE	FAR PASCAL LoadLibrary( LPSTR );
HANDLE	FAR PASCAL FreeLibrary( HANDLE );

BOOL  FAR PASCAL AnsiToOem( LPSTR, LPSTR );
BOOL  FAR PASCAL OemToAnsi( LPSTR, LPSTR );
LPSTR FAR PASCAL AnsiUpper( LPSTR );
LPSTR FAR PASCAL AnsiLower( LPSTR );
LPSTR FAR PASCAL AnsiNext( LPSTR );
LPSTR FAR PASCAL AnsiPrev( LPSTR, LPSTR );

#ifndef NOOPENFILE

typedef struct tagOFSTRUCT {
    BYTE    cBytes;		    /* length of structure */
    BYTE    fFixedDisk;		    /* non-zero if file located on non- */
				    /* removeable media */
    WORD    nErrCode;		    /* DOS error code if OpenFile fails */
    BYTE    reserved[4];
    BYTE    szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT      *POFSTRUCT;
typedef OFSTRUCT NEAR *NPOFSTRUCT;
typedef OFSTRUCT FAR  *LPOFSTRUCT;

BYTE FAR PASCAL GetTempDrive( BYTE );

int  FAR PASCAL GetTempFileName( BYTE, LPSTR, WORD, LPSTR );
int  FAR PASCAL OpenFile( LPSTR, LPOFSTRUCT, WORD );

/* Flags for GetTempFileName */

#define TF_FORCEDRIVE	(BYTE)0x80  /* Forces use of current dir of passed */
				    /* drive */
/* Flags for OpenFile */

#define OF_REOPEN 0x8000
#define OF_EXIST  0x4000
#define OF_PROMPT 0x2000
#define OF_CREATE 0x1000
#define OF_CANCEL 0x0800
#define OF_VERIFY 0x0400
#define OF_DELETE 0x0200
#define OF_PARSE  0x0100

#define OF_READ	     0
#define OF_WRITE     1
#define OF_READWRITE 2
#endif

#ifndef NOMEMMGR
/* Interface to global memory manager */
#define GMEM_FIXED	    0x0000
#define GMEM_MOVEABLE	    0x0002
#define GMEM_NOCOMPACT	    0x0010
#define GMEM_NODISCARD	    0x0020
#define GMEM_ZEROINIT	    0x0040
#define GMEM_MODIFY	    0x0080
#define GMEM_DISCARDABLE    0x0F00
#define GHND	(GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR	(GMEM_FIXED    | GMEM_ZEROINIT)
#define GMEM_SHARE	    0x2000
#define GMEM_DDESHARE	    0x2000
#define GMEM_NOT_BANKED     0x1000
#define GMEM_NOTIFY	    0x4000
#define GMEM_LOWER	    GMEM_NOT_BANKED


HANDLE FAR PASCAL GlobalAlloc( WORD, DWORD );
DWORD  FAR PASCAL GlobalCompact( DWORD );
#define GlobalDiscard( h ) GlobalReAlloc( h, 0L, GMEM_MOVEABLE )
HANDLE FAR PASCAL GlobalFree( HANDLE );
DWORD  FAR PASCAL GlobalHandle( WORD );
LPSTR  FAR PASCAL GlobalLock( HANDLE );
HANDLE FAR PASCAL GlobalReAlloc( HANDLE, DWORD, WORD );
DWORD  FAR PASCAL GlobalSize( HANDLE );
BOOL   FAR PASCAL GlobalUnlock( HANDLE );
WORD   FAR PASCAL GlobalFlags( HANDLE );
LPSTR  FAR PASCAL GlobalWire( HANDLE );
BOOL   FAR PASCAL GlobalUnWire( HANDLE );
BOOL   FAR PASCAL GlobalUnlock( HANDLE );
HANDLE FAR PASCAL GlobalLRUNewest( HANDLE );
HANDLE FAR PASCAL GlobalLRUOldest( HANDLE );
VOID   FAR PASCAL GlobalNotify( LPSTR );

/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED	    0x4000
#define GMEM_LOCKCOUNT	    0x00FF

#define LockData( dummy )   LockSegment( 0xFFFF )
#define UnlockData( dummy ) UnlockSegment( 0xFFFF )
HANDLE FAR PASCAL LockSegment( WORD );
HANDLE FAR PASCAL UnlockSegment( WORD );

/* Interface to local memory manager */

#define LMEM_FIXED	    0x0000
#define LMEM_MOVEABLE	    0x0002
#define LMEM_NOCOMPACT	    0x0010
#define LMEM_NODISCARD	    0x0020
#define LMEM_ZEROINIT	    0x0040
#define LMEM_MODIFY	    0x0080
#define LMEM_DISCARDABLE    0x0F00
#define LHND		(LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR		(LMEM_FIXED    | LMEM_ZEROINIT)
#define NONZEROLHND	(LMEM_MOVEABLE)
#define NONZEROLPTR	(LMEM_FIXED)

#define LNOTIFY_OUTOFMEM 0
#define LNOTIFY_MOVE	 1
#define LNOTIFY_DISCARD	 2

HANDLE	FAR PASCAL LocalAlloc( WORD, WORD );
WORD	FAR PASCAL LocalCompact( WORD );
#define LocalDiscard( h ) LocalReAlloc( h, 0, LMEM_MOVEABLE )
HANDLE	FAR PASCAL LocalFree( HANDLE );
HANDLE	FAR PASCAL LocalHandle( WORD );
WORD	NEAR * PASCAL pLocalHeap;
#define LocalFreeze( dummy ) ( *(pLocalHeap+1) += 1 )
#define LocalHandleDelta( delta ) ( (delta) ? (*(pLocalHeap+9) = (delta)) : *(pLocalHeap+9))
BOOL	FAR PASCAL LocalInit( WORD, char NEAR *, char NEAR * );
char NEAR * FAR PASCAL LocalLock( HANDLE );
#define LocalMelt( dummy )   ( *(pLocalHeap+1) -= 1 )
FARPROC FAR PASCAL LocalNotify( FARPROC );
HANDLE	FAR PASCAL LocalReAlloc( HANDLE, WORD, WORD );
WORD	FAR PASCAL LocalSize( HANDLE );
BOOL	FAR PASCAL LocalUnlock( HANDLE );
WORD	FAR PASCAL LocalFlags( HANDLE );
WORD	FAR PASCAL LocalShrink( HANDLE, WORD );

/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED	    0x4000
#define LMEM_LOCKCOUNT	    0x00FF
#endif

/* SetSwapAreaSize really returns 2 words - 
    lo word is Size actually set (or current size if you passed in 0)
    hi word is Max size you can get
*/
LONG   FAR PASCAL SetSwapAreaSize ( WORD );
LPSTR  FAR PASCAL ValidateFreeSpaces ( void );

VOID   FAR PASCAL LimitEmsPages ( DWORD );

BOOL   FAR PASCAL SetErrorMode ( WORD );

/* Interface to the resource manager */

HANDLE FAR PASCAL FindResource( HANDLE, LPSTR, LPSTR );
HANDLE FAR PASCAL LoadResource( HANDLE, HANDLE );
BOOL   FAR PASCAL FreeResource( HANDLE );

LPSTR  FAR PASCAL LockResource( HANDLE );
#define UnlockResource( h ) GlobalUnlock( h )

FARPROC FAR PASCAL SetResourceHandler( HANDLE, LPSTR, FARPROC );
HANDLE	FAR PASCAL AllocResource( HANDLE, HANDLE, DWORD );
WORD	FAR PASCAL SizeofResource( HANDLE, HANDLE );
int	FAR PASCAL AccessResource( HANDLE, HANDLE );


#define MAKEINTRESOURCE(i)  (LPSTR)((DWORD)((WORD)(i)))

#ifndef NORESOURCE
/* Predefined resource types */
#define RT_CURSOR	MAKEINTRESOURCE( 1 )
#define RT_BITMAP	MAKEINTRESOURCE( 2 )
#define RT_ICON		MAKEINTRESOURCE( 3 )
#define RT_MENU		MAKEINTRESOURCE( 4 )
#define RT_DIALOG	MAKEINTRESOURCE( 5 )
#define RT_STRING	MAKEINTRESOURCE( 6 )
#define RT_FONTDIR	MAKEINTRESOURCE( 7 )
#define RT_FONT		MAKEINTRESOURCE( 8 )
#define RT_ACCELERATOR	MAKEINTRESOURCE( 9 )
#define RT_RCDATA	MAKEINTRESOURCE( 10 )
#endif

/* Interface to the task scheduler */

BOOL   FAR PASCAL Yield( void );
HANDLE FAR PASCAL GetCurrentTask( void );
int    FAR PASCAL SetPriority(HANDLE, int);

/* Interface to the atom manager */

#ifndef NOATOM
typedef WORD ATOM;
#endif

BOOL FAR PASCAL InitAtomTable( int );

#ifndef NOATOM
ATOM   FAR PASCAL AddAtom( LPSTR );
ATOM   FAR PASCAL DeleteAtom( ATOM );
ATOM   FAR PASCAL FindAtom( LPSTR );
WORD   FAR PASCAL GetAtomName( ATOM, LPSTR, int	 );
ATOM   FAR PASCAL GlobalAddAtom( LPSTR );
ATOM   FAR PASCAL GlobalDeleteAtom( ATOM );
ATOM   FAR PASCAL GlobalFindAtom( LPSTR );
WORD   FAR PASCAL GlobalGetAtomName( ATOM, LPSTR, int  );
HANDLE FAR PASCAL GetAtomHandle( ATOM );
#define MAKEINTATOM(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif

/* Interface to the user profile */

int  FAR PASCAL GetProfileInt( LPSTR, LPSTR, int );
int  FAR PASCAL GetProfileString( LPSTR, LPSTR, LPSTR, LPSTR, int );
BOOL FAR PASCAL WriteProfileString( LPSTR, LPSTR, LPSTR );

/* Interface to FatalExit procedure */

void FAR PASCAL FatalExit( int );

/* Interface to Catch and Throw procedures */

typedef int CATCHBUF[ 9 ];
typedef int FAR *LPCATCHBUF;
int  FAR PASCAL Catch( LPCATCHBUF );
void FAR PASCAL Throw( LPCATCHBUF, int );

HANDLE FAR PASCAL CreateMetaFile(LPSTR);
HANDLE FAR PASCAL CloseMetaFile(HANDLE);
HANDLE FAR PASCAL GetMetaFileBits(HANDLE);
HANDLE FAR PASCAL SetMetaFileBits(HANDLE);

DWORD FAR PASCAL GetCurrentTime(void);
DWORD FAR PASCAL GetTickCount();
DWORD FAR PASCAL GetTimerResolution();

BOOL  FAR PASCAL IsChild(HWND, HWND);

#ifndef NOWINOFFSETS
WORD FAR PASCAL GetWindowWord(HWND, int);
WORD FAR PASCAL SetWindowWord(HWND, int, WORD);
LONG FAR PASCAL GetWindowLong(HWND, int);
LONG FAR PASCAL SetWindowLong(HWND, int, LONG);
WORD FAR PASCAL GetClassWord(HWND, int);
WORD FAR PASCAL SetClassWord(HWND, int, WORD);
LONG FAR PASCAL GetClassLong(HWND, int);
LONG FAR PASCAL SetClassLong(HWND, int, LONG);
#endif

HWND  FAR PASCAL GetParent(HWND);
HWND  FAR PASCAL SetParent(HWND, HWND);
BOOL  FAR PASCAL EnumChildWindows(HWND, FARPROC, LONG);
HWND  FAR PASCAL FindWindow(LPSTR, LPSTR);
BOOL  FAR PASCAL EnumWindows(FARPROC, LONG);
BOOL  FAR PASCAL EnumTaskWindows(HANDLE, FARPROC, LONG);
int   FAR PASCAL GetClassName(HWND, LPSTR, int);
HWND  FAR PASCAL GetTopWindow(HWND);
HWND  FAR PASCAL GetNextWindow(HWND, WORD);
HANDLE FAR PASCAL GetWindowTask(HWND);

/* GetWindow() and constants */
HWND FAR PASCAL GetWindow(HWND, WORD);
#define GW_HWNDFIRST 0
#define GW_HWNDLAST  1
#define GW_HWNDNEXT  2
#define GW_HWNDPREV  3
#define GW_OWNER     4
#define GW_CHILD     5

#ifndef NOWH
FARPROC FAR PASCAL SetWindowsHook(int, FARPROC);
BOOL  FAR PASCAL UnhookWindowsHook(int, FARPROC);
DWORD FAR PASCAL DefHookProc(int, WORD, DWORD, FARPROC FAR *);
#endif

/* Key conversion window */
BOOL FAR PASCAL IsTwoByteCharPrefix( char );
#ifndef NOMENUS

/* Menu flags for Add/Check/EnableMenuItem */
#define MF_CHANGE	0x0080
#define MF_INSERT	0x0000
#define MF_APPEND	0x0100
#define MF_DELETE	0x0200
#define MF_BYPOSITION	0x0400
#define MF_SEPARATOR	0x0800
#define MF_REMOVE	0x1000
#define MF_BYCOMMAND	0x0000
#define MF_GRAYED	0x0001
#define MF_DISABLED	0x0002
#define MF_ENABLED	0x0000
#define MF_CHECKED	0x0008
#define MF_UNCHECKED	0x0000
#define MF_BITMAP	0x0004
#define MF_STRING	0x0000
#define MF_POPUP	0x0010
#define MF_MENUBARBREAK 0x0020
#define MF_MENUBREAK	0x0040
#define MF_HILITE	0x0080
#define MF_UNHILITE	0x0000
#define MF_HELP		0x4000
#define MF_SYSMENU	0x2000
#define MF_MOUSESELECT	0x8000

#endif /* of NOMENU */

/* System Menu Command Values */
#ifndef NOSYSCOMMANDS
#define SC_SIZE		0xF000
#define SC_MOVE		0xF010
#define SC_MINIMIZE	0xF020
#define SC_MAXIMIZE	0xF030
#define SC_NEXTWINDOW	0xF040
#define SC_PREVWINDOW	0xF050
#define SC_CLOSE	0xF060
#define SC_VSCROLL	0xF070
#define SC_HSCROLL	0xF080
#define SC_MOUSEMENU	0xF090
#define SC_KEYMENU	0xF100
#define SC_ARRANGE	0xF110
#define SC_RESTORE	0xF120
#define SC_ICON		SC_MINIMIZE
#define SC_ZOOM		SC_MAXIMIZE
#endif

/* Resource loading routines */
#ifndef NOBITMAP
HBITMAP FAR PASCAL LoadBitmap( HANDLE, LPSTR );
#endif

HCURSOR FAR PASCAL LoadCursor( HANDLE, LPSTR );

/* Standard cursor IDs */
#define IDC_ARROW	MAKEINTRESOURCE(32512)
#define IDC_IBEAM	MAKEINTRESOURCE(32513)
#define IDC_WAIT	MAKEINTRESOURCE(32514)
#define IDC_CROSS	MAKEINTRESOURCE(32515)
#define IDC_UPARROW	MAKEINTRESOURCE(32516)
#define IDC_SIZE	MAKEINTRESOURCE(32640)
#define IDC_ICON	MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE	MAKEINTRESOURCE(32642)
#define IDC_SIZENESW	MAKEINTRESOURCE(32643)
#define IDC_SIZEWE	MAKEINTRESOURCE(32644)
#define IDC_SIZENS	MAKEINTRESOURCE(32645)



HICON FAR PASCAL LoadIcon( HANDLE, LPSTR );

#ifndef NOICON
/* Standard icon IDs */
#define IDI_APPLICATION MAKEINTRESOURCE(32512)
#define IDI_HAND	MAKEINTRESOURCE(32513)
#define IDI_QUESTION	MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION MAKEINTRESOURCE(32515)
#define IDI_ASTERISK	MAKEINTRESOURCE(32516)
#endif


#ifndef NOMENUS
HMENU FAR PASCAL LoadMenu( HANDLE, LPSTR );
HMENU FAR PASCAL LoadMenuIndirect( LPSTR );
#endif

int FAR PASCAL LoadString( HANDLE, unsigned, LPSTR, int );

short FAR PASCAL AddFontResource( LPSTR );
BOOL  FAR PASCAL RemoveFontResource( LPSTR );

#ifndef NOKANJI

#define CP_HWND			0
#define CP_OPEN			1
#define CP_DIRECT		2

/* VK from the keyboard driver */
#define VK_KANA		0x15
#define VK_ROMAJI	0x16
#define VK_ZENKAKU	0x17
#define VK_HIRAGANA	0x18
#define VK_KANJI	0x19

/* VK to send to Applications */
#define VK_CONVERT	0x1C
#define VK_NONCONVERT	0x1D
#define VK_ACCEPT	0x1E
#define VK_MODECHANGE	0x1F


/* Conversion function numbers */
#define KNJ_START	0x01
#define KNJ_END		0x02
#define KNJ_QUERY	0x03

#define KNJ_LEARN_MODE	0x10
#define KNJ_GETMODE	0x11
#define KNJ_SETMODE	0x12

#define KNJ_CODECONVERT 0x20
#define KNJ_CONVERT	0x21
#define KNJ_NEXT	0x22
#define KNJ_PREVIOUS	0x23
#define KNJ_ACCEPT	0x24

#define KNJ_LEARN	0x30
#define KNJ_REGISTER	0x31
#define KNJ_REMOVE	0x32
#define KNJ_CHANGE_UDIC 0x33

/* note: DEFAULT	= 0
	 JIS1		= 1
	 JIS2		= 2
	 SJIS2		= 3
	 JIS1KATAKANA	= 4
	 SJIS2HIRAGANA	= 5
	 SJIS2KATAKANA	= 6
	 OEM		= F
*/

#define KNJ_JIS1toJIS1KATAKANA	0x14
#define KNJ_JIS1toSJIS2		0x13
#define KNJ_JIS1toSJIS2HIRAGANA 0x15
#define KNJ_JIS1toSJIS2KATAKANA 0x16
#define KNJ_JIS1toDEFAULT	0x10
#define KNJ_JIS1toSJIS2OEM	0x1F
#define KNJ_JIS2toSJIS2		0x23
#define KNJ_SJIS2toJIS2		0x32

/* see KNJ_GETMODE for definition */
#define KNJ_MD_ALPHA		0x01
#define KNJ_MD_HIRAGANA		0x02
#define KNJ_MD_HALF		0x04
#define KNJ_MD_JIS		0x08
#define KNJ_MD_SPECIAL		0x10

/* conversion modes, low word of lParam when VK_CONVERT is sent to the app */
#define KNJ_CVT_NEXT		0x01
#define KNJ_CVT_PREV		0x02
#define KNJ_CVT_KATAKANA	0x03
#define KNJ_CVT_HIRAGANA	0x04
#define KNJ_CVT_JIS1		0x05
#define KNJ_CVT_SJIS2		0x06
#define KNJ_CVT_DEFAULT		0x07
#define KNJ_CVT_TYPED		0x08

typedef struct
{
    short   fnc;
    short   wParam;
    LPSTR   lpSource;
    LPSTR   lpDest;
    short   wCount;
    LPSTR   lpReserved1;
    LPSTR   lpReserved2;
} KANJISTRUCT, FAR *LPKANJISTRUCT;

short	    FAR PASCAL	ConvertRequest (HWND, LPKANJISTRUCT);
BOOL	    FAR PASCAL	SetConvertParams(short, short);
VOID	    FAR PASCAL	SetConvertHook(BOOL);
#endif

/* Conventional dialog box and message box command IDs */
#define IDOK	  1
#define IDCANCEL  2
#define IDABORT	  3
#define IDRETRY	  4
#define IDIGNORE  5
#define IDYES	  6
#define IDNO	  7

#ifndef NOCTLMGR

/* Control manager structures & definitions */
/* Edit control class stuff */

/* styles */
#ifndef NOWINSTYLES
#define ES_LEFT		  0L
#define ES_CENTER	  1L
#define ES_RIGHT	  2L
#define ES_MULTILINE	  4L
#define ES_AUTOVSCROLL	  64L
#define ES_AUTOHSCROLL	  128L
#define ES_NOHIDESEL	  256L
#endif

/* notification codes */
#define EN_SETFOCUS   0x0100
#define EN_KILLFOCUS  0x0200
#define EN_CHANGE     0x0300
#define EN_UPDATE     0x0400
#define EN_ERRSPACE   0x0500
#define EN_HSCROLL    0x0601
#define EN_VSCROLL    0x0602

/* control messages: */
#ifndef NOWINMESSAGES
#define EM_GETSEL	 (WM_USER+0)
#define EM_SETSEL	 (WM_USER+1)
#define EM_GETRECT	 (WM_USER+2)
#define EM_SETRECT	 (WM_USER+3)
#define EM_SETRECTNP	 (WM_USER+4)
#define EM_SCROLL	 (WM_USER+5)
#define EM_LINESCROLL	 (WM_USER+6)
#define EM_GETMODIFY	 (WM_USER+8)
#define EM_SETMODIFY	 (WM_USER+9)
#define EM_GETLINECOUNT	 (WM_USER+10)
#define EM_LINEINDEX	 (WM_USER+11)
#define EM_SETHANDLE	 (WM_USER+12)
#define EM_GETHANDLE	 (WM_USER+13)
#define EM_GETTHUMB	 (WM_USER+14)
#define EM_LINELENGTH	 (WM_USER+17)
#define EM_REPLACESEL	 (WM_USER+18)
#define EM_SETFONT	 (WM_USER+19)
#define EM_GETLINE	 (WM_USER+20)
#define EM_LIMITTEXT	 (WM_USER+21)
#define EM_CANUNDO	 (WM_USER+22)
#define EM_UNDO		 (WM_USER+23)
#define EM_FMTLINES	 (WM_USER+24)
#define EM_LINEFROMCHAR	 (WM_USER+25)
#define EM_SETWORDBREAK	 (WM_USER+26)
#endif

/* button control styles */
#define BS_PUSHBUTTON	 0L
#define BS_DEFPUSHBUTTON 1L
#define BS_CHECKBOX	 2L
#define BS_AUTOCHECKBOX	 3L
#define BS_RADIOBUTTON	 4L
#define BS_3STATE	 5L
#define BS_AUTO3STATE	 6L
#define BS_GROUPBOX	 7L
#define BS_USERBUTTON	 8L
#define BS_AUTORADIOBUTTON 9L
#define BS_PUSHBOX	 10L
#define BS_LEFTTEXT	 0x20L

/* user button notification codes */
#define BN_CLICKED	 0
#define BN_PAINT	 1
#define BN_HILITE	 2
#define BN_UNHILITE	 3
#define BN_DISABLE	 4
#define BN_DOUBLECLICKED 5

/* control messages */
#define BM_GETCHECK	WM_USER+0
#define BM_SETCHECK	WM_USER+1
#define BM_GETSTATE	WM_USER+2
#define BM_SETSTATE	WM_USER+3
#define BM_SETSTYLE	WM_USER+4

/* Static control constants */

#define SS_LEFT	      0L
#define SS_CENTER     1L
#define SS_RIGHT      2L
#define SS_ICON	      3L
#define SS_BLACKRECT  4L
#define SS_GRAYRECT   5L
#define SS_WHITERECT  6L
#define SS_BLACKFRAME 7L
#define SS_GRAYFRAME  8L
#define SS_WHITEFRAME 9L
#define SS_USERITEM   10L
#define SS_SIMPLE     11L
#define SS_NOPREFIX  128L   /* 0x80 - don't do "&" character translation */

/* Dialog manager routines */

#ifndef NOMSG
BOOL FAR PASCAL IsDialogMessage(HWND, LPMSG);
#endif

#ifndef NORECT
void FAR PASCAL MapDialogRect(HWND, LPRECT);
#endif

#ifndef NOCTLMGR
int  FAR PASCAL DlgDirList(HWND, LPSTR, int, int, unsigned);
BOOL FAR PASCAL DlgDirSelect(HWND, LPSTR, int);

/* Dialog style bits */
#define DS_ABSALIGN   0x000000001L
#define DS_SYSMODAL   0x000000002L
#define DS_LOCALEDIT  0x000000020L  /* Edit items get Local storage. */

#define DM_GETDEFID (WM_USER+0)
#define DM_SETDEFID (WM_USER+1)
#define DC_HASDEFID (0x534B)

/*  Dialog codes (returned by WM_GETDLGCODE message): */

#define DLGC_WANTARROWS		0x01	/* control wants arrow keys */
#define DLGC_WANTTAB		0x02	/* control wants tab keys */
#define DLGC_WANTALLKEYS	0x04	/* control wants all keys */
#define DLGC_WANTMESSAGE	0x04	/* pass message to control */
#define DLGC_HASSETSEL		0x08	/* understands EM_SETSEL message */
#define DLGC_DEFPUSHBUTTON	0x10	/* Default pushbutton	  */
#define DLGC_UNDEFPUSHBUTTON	0x20	/* Non-default pushbutton */
#define DLGC_RADIOBUTTON	0x40	/* radio button		  */
#define DLGC_WANTCHARS		0x80	/* Want WM_CHAR messages  */
#define DLGC_STATIC		0x100	/* Static item: don't include */
#define DLGC_BUTTON		0x2000	/* Button item: can be checked */

#define LB_CTLCODE   0L

/* Listbox control return values */
#define LB_OKAY	     0
#define LB_ERR	     -1
#define LB_ERRSPACE  -2

/* listbox notification codes */
#define LBN_ERRSPACE	-2
#define LBN_SELCHANGE	1
#define LBN_DBLCLK	2
#endif

/* listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING	 (1+WM_USER)
#define LB_INSERTSTRING	 (2+WM_USER)
#define LB_DELETESTRING	 (3+WM_USER)
#define LB_RESETCONTENT	 (5+WM_USER)
#define LB_SETSEL	 (6+WM_USER)
#define LB_SETCURSEL	 (7+WM_USER)
#define LB_GETSEL	 (8+WM_USER)
#define LB_GETCURSEL	 (9+WM_USER)
#define LB_GETTEXT	 (10+WM_USER)
#define LB_GETTEXTLEN	 (11+WM_USER)
#define LB_GETCOUNT	 (12+WM_USER)
#define LB_SELECTSTRING	 (13+WM_USER)
#define LB_DIR		 (14+WM_USER)
#define LB_GETTOPINDEX	 (15+WM_USER)
#define LB_MSGMAX	 (16+WM_USER)
#endif

/* listbox style bits */
#ifndef NOWINSTYLES
#define LBS_NOTIFY	  0x0001L
#define LBS_SORT	  0x0002L
#define LBS_NOREDRAW	  0x0004L
#define LBS_MULTIPLESEL	  0x0008L
#define LBS_STANDARD	  (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif

/* scroll bar styles */
#ifndef NOWINSTYLES
#define SBS_HORZ		    0x0000L
#define SBS_VERT		    0x0001L
#define SBS_TOPALIGN		    0x0002L
#define SBS_LEFTALIGN		    0x0002L
#define SBS_BOTTOMALIGN		    0x0004L
#define SBS_RIGHTALIGN		    0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN	    0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX		    0x0008L
#endif
#endif

#ifndef NOSOUND
int FAR PASCAL OpenSound();
int FAR PASCAL CloseSound();
int FAR PASCAL SetVoiceQueueSize(int, int);
int FAR PASCAL SetVoiceNote(int, int, int, int);
int FAR PASCAL SetVoiceAccent(int, int, int, int, int);
int FAR PASCAL SetVoiceEnvelope(int, int, int);
int FAR PASCAL SetSoundNoise(int, int);
int FAR PASCAL SetVoiceSound(int, long, int);
int FAR PASCAL StartSound();
int FAR PASCAL StopSound();
int FAR PASCAL WaitSoundState(int);
int FAR PASCAL SyncAllVoices();
int FAR PASCAL CountVoiceNotes(int);
LPINT FAR PASCAL GetThresholdEvent();
int FAR PASCAL GetThresholdStatus();
int FAR PASCAL SetVoiceThreshold(int, int);

/* constants used to specify return condition for WaitSoundState */

#define S_QUEUEEMPTY   0
#define S_THRESHOLD    1
#define S_ALLTHRESHOLD 2

/* constants used to specify accent mode */

#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* constants used to specify source in SetSoundNoise */
#define S_PERIOD512   0	  /* freq = N/512 high pitch, less coarse hiss */
#define S_PERIOD1024  1	  /* freq = N/1024 */
#define S_PERIOD2048  2	  /* freq = N/2048 low pitch, more coarse hiss */
#define S_PERIODVOICE 3	  /* source is frequency from voice channel (3) */

#define S_WHITE512    4	  /* freq = N/512 high pitch, less coarse hiss */
#define S_WHITE1024   5	  /* freq = N/1024 */
#define S_WHITE2048   6	  /* freq = N/2048 low pitch, more coarse hiss */
#define S_WHITEVOICE  7	  /* source is frequency from voice channel (3) */

#define S_SERDVNA     -1  /* device not available */
#define S_SEROFM      -2  /* out of memory */
#define S_SERMACT     -3  /* music active */
#define S_SERQFUL     -4  /* queue full */
#define S_SERBDNT     -5  /* invalid note */
#define S_SERDLN      -6  /* invalid note length */
#define S_SERDCC      -7  /* invalid note count */
#define S_SERDTP      -8  /* invalid tempo */
#define S_SERDVL      -9  /* invalid volume */
#define S_SERDMD      -10 /* invalid mode */
#define S_SERDSH      -11 /* invalid shape */
#define S_SERDPT      -12 /* invalid pitch */
#define S_SERDFQ      -13 /* invalid frequency */
#define S_SERDDR      -14 /* invalid duration */
#define S_SERDSR      -15 /* invalid source */
#define S_SERDST      -16 /* invalid state */
#endif


#ifndef NOCOMM
/*************************************************************************
**
** dcb field definitions.
**
*************************************************************************/

#define NOPARITY    0
#define ODDPARITY   1
#define EVENPARITY  2
#define MARKPARITY  3
#define SPACEPARITY 4

#define ONESTOPBIT  0
#define ONE5STOPBITS 1
#define TWOSTOPBITS 2

#define IGNORE	    0	    /* Ignore signal	*/
#define INFINITE    0xFFFF  /* Infinite timeout */



/*************************************************************************
**
** Comm Device Driver Error Bits.
**
*************************************************************************/

#define CE_RXOVER   0x0001  /* Receive Queue overflow	       */
#define CE_OVERRUN  0x0002  /* Receive Overrun Error	       */
#define CE_RXPARITY 0x0004  /* Receive Parity Error	       */
#define CE_FRAME    0x0008  /* Receive Framing error	       */
#define CE_BREAK    0x0010  /* Break Detected		       */
#define CE_CTSTO    0x0020  /* CTS Timeout		  */
#define CE_DSRTO    0x0040  /* DSR Timeout		  */
#define CE_RLSDTO   0x0080  /* RLSD Timeout		  */
#define CE_TXFULL   0x0100  /* TX Queue is full		  */
#define CE_PTO	    0x0200  /* LPTx Timeout		  */
#define CE_IOE	    0x0400  /* LPTx I/O Error		  */
#define CE_DNS	    0x0800  /* LPTx Device not selected	  */
#define CE_OOP	    0x1000  /* LPTx Out-Of-Paper	  */
#define CE_MODE	    0x8000  /* Requested mode unsupported */


/*************************************************************************
**
** Initialization Error Codes
**
*************************************************************************/

#define IE_BADID    -1	/* Invalid or unsupported id	   */
#define IE_OPEN	    -2	/* Device Already Open		   */
#define IE_NOPEN    -3	/* Device Not Open		   */
#define IE_MEMORY   -4	/* Unable to allocate queues	   */
#define IE_DEFAULT  -5	/* Error in default parameters	   */
#define IE_HARDWARE -10 /* Hardware Not Present		   */
#define IE_BYTESIZE -11 /* Illegal Byte Size		   */
#define IE_BAUDRATE -12 /* Unsupported BaudRate		   */


/*************************************************************************
**
** Event Definitions
**
*************************************************************************/

#define EV_RXCHAR   0x0001  /* Any Character received	   */
#define EV_RXFLAG   0x0002  /* Received certain character  */
#define EV_TXEMPTY  0x0004  /* Transmitt Queue Empty	   */
#define EV_CTS	    0x0008  /* CTS changed state	   */
#define EV_DSR	    0x0010  /* DSR changed state	   */
#define EV_RLSD	    0x0020  /* RLSD changed state	   */
#define EV_BREAK    0x0040  /* BREAK received		   */
#define EV_ERR	    0x0080  /* Line status error occurred  */
#define EV_RING	    0x0100  /* Ring signal detected	   */
#define EV_PERR	    0x0200  /* Printer error occured	   */


/*************************************************************************
**
** Escape Functions
**
*************************************************************************/

#define SETXOFF	  1 /* Simulate XOFF received	  */
#define SETXON	  2 /* Simulate XON received	  */
#define SETRTS	  3 /* Set RTS high		  */
#define CLRRTS	  4 /* Set RTS low		  */
#define SETDTR	  5 /* Set DTR high		  */
#define CLRDTR	  6 /* Set DTR low		  */
#define RESETDEV  7 /* Reset device if possible	  */



/*************************************************************************
**
** Device Descriptor Block Definition
**
*************************************************************************/

#define LPTx	0x80			/* Set if ID is for LPT device	  */

typedef struct tagDCB {
    BYTE Id;		  /* Internal Device ID		     */
    WORD BaudRate;	  /* Baudrate at which runing	     */
    BYTE ByteSize;	  /* Number of bits/byte, 4-8	     */
    BYTE Parity;	  /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;	  /* 0,1,2 = 1, 1.5, 2		     */
    WORD RlsTimeout;	  /* Timeout for RLSD to be set	     */
    WORD CtsTimeout;	  /* Timeout for CTS to be set	     */
    WORD DsrTimeout;	  /* Timeout for DSR to be set	     */

    BYTE fBinary: 1;	  /* Binary Mode (skip EOF check     */
    BYTE fRtsDisable:1;   /* Don't assert RTS at init time   */
    BYTE fParity: 1;	  /* Enable parity checking	     */
    BYTE fOutxCtsFlow:1;  /* CTS handshaking on output	     */
    BYTE fOutxDsrFlow:1;  /* DSR handshaking on output	     */
    BYTE fDummy: 2;	  /* Reserved			     */
    BYTE fDtrDisable:1;   /* Don't assert DTR at init time   */

    BYTE fOutX: 1;	  /* Enable output X-ON/X-OFF	     */
    BYTE fInX: 1;	  /* Enable input X-ON/X-OFF	     */
    BYTE fPeChar: 1;	  /* Enable Parity Err Replacement   */
    BYTE fNull: 1;	  /* Enable Null stripping	     */
    BYTE fChEvt: 1;	  /* Enable Rx character event.      */
    BYTE fDtrflow: 1;	  /* DTR handshake on input	     */
    BYTE fRtsflow: 1;	  /* RTS handshake on input	     */
    BYTE fDummy2: 1;

    char XonChar;	  /* Tx and Rx X-ON character	     */
    char XoffChar;	  /* Tx and Rx X-OFF character	     */
    WORD XonLim;	  /* Transmit X-ON threshold	     */
    WORD XoffLim;	  /* Transmit X-OFF threshold	     */
    char PeChar;	  /* Parity error replacement char   */
    char EofChar;	  /* End of Input character	     */
    char EvtChar;	  /* Recieved Event character	     */
    WORD TxDelay;	  /* Amount of time between chars    */
} DCB;


/*************************************************************************
**
** Status record returned by GetCommError
**
*************************************************************************/

typedef struct tagCOMSTAT {
    BYTE fCtsHold: 1;	/* Transmit is on CTS hold	   */
    BYTE fDsrHold: 1;	/* Transmit is on DSR hold	   */
    BYTE fRlsdHold: 1;	/* Transmit is on RLSD hold	   */
    BYTE fXoffHold: 1;	/* Received handshake		   */
    BYTE fXoffSent: 1;	/* Issued handshake		   */
    BYTE fEof: 1;	/* End of file character found	   */
    BYTE fTxim: 1;	/* Character being transmitted	   */
    WORD cbInQue;	/* count of characters in Rx Queue */
    WORD cbOutQue;	/* count of characters in Tx Queue */
} COMSTAT;

short FAR PASCAL OpenComm(LPSTR, WORD, WORD);
short FAR PASCAL SetCommState(DCB FAR *);
short FAR PASCAL GetCommState(short, DCB FAR *);
short FAR PASCAL ReadComm(short, LPSTR, int);
short FAR PASCAL UngetCommChar(short, char);
short FAR PASCAL WriteComm(short, LPSTR, int);
short FAR PASCAL CloseComm(short);
short FAR PASCAL GetCommError(short, COMSTAT FAR *);
short FAR PASCAL BuildCommDCB(LPSTR, DCB FAR *);
short FAR PASCAL TransmitCommChar(short, char);
WORD FAR * FAR PASCAL SetCommEventMask(short, WORD);
WORD  FAR PASCAL GetCommEventMask(short, int);
short FAR PASCAL SetCommBreak(short);
short FAR PASCAL ClearCommBreak(short);
short FAR PASCAL FlushComm(short, int);
short FAR PASCAL EscapeCommFunction(short, int);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\sys\stat.h ===
/***
*sys\stat.h - defines structure used by stat() and fstat()
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the structure used by the stat() and fstat()
*   routines.
*   [System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define CDECL   cdecl
#else /* extensions not enabled */
    #define CDECL
#endif /* NO_EXT_KEYS */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* define structure for returning status information */

#ifndef _STAT_DEFINED
struct stat {
    dev_t st_dev;
    ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    dev_t st_rdev;
    off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
    };
#define _STAT_DEFINED
#endif

#define S_IFMT      0170000         /* file type mask */
#define S_IFDIR     0040000         /* directory */
#define S_IFCHR     0020000         /* character special */
#define S_IFREG     0100000         /* regular */
#define S_IREAD     0000400         /* read permission, owner */
#define S_IWRITE    0000200         /* write permission, owner */
#define S_IEXEC     0000100         /* execute/search permission, owner */


/* function prototypes */

int CDECL fstat(int, struct stat *);
int CDECL stat(char *, struct stat *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\sys\types.h ===
/***
*sys\types.h - types returned by system level calls for file and time info
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines types used in defining values returned by system
*   level calls for file status and time information.
*   [System V]
*
*******************************************************************************/

#ifndef _INO_T_DEFINED
typedef unsigned short ino_t;       /* i-node number (not used on DOS) */
#define _INO_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef short dev_t;                /* device code */
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long off_t;                 /* file offset value */
#define _OFF_T_DEFINED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\sys\timeb.h ===
/***
*sys\timeb.h - definition/declarations for ftime()
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file define the ftime() function and the types it uses.
*   [System V]
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define CDECL   cdecl
#else /* extensions not enabled */
    #define CDECL
#endif /* NO_EXT_KEYS */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* structure returned by ftime system call */

#ifndef _TIMEB_DEFINED
struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
    };
#define _TIMEB_DEFINED
#endif


/* function prototypes */

void CDECL ftime(struct timeb *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\access.h ===
extern int dummyInt;

   /* start function protocols */

void Initialize(void);
void SetColorsForColor(void);
void SetColorsForMono(void);
void SetColorsForLCD(void);
void GetEquipmentListAndParameters(void);
void GetSerialPortInformation(void);
void PatchMenus(void);
void CleanUp(int installFlag, int forceDialogFlags);
void WaitForAnyKey(void);
void ClearKeyboardBuffer(void);
void DummyFunction(void);
int DisplayStartupScreenText(int line, int center, int titleFlag, int autoLoadFlag);
int DisplayStartUpScreen(int autoLoadFlag);
int RunCountdownTimer(int line);

   /* end Function Protocols */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\inc\sys\utime.h ===
/***
*sys\utime.h - definitions/declarations for utime()
*
*   Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the structure used by the utime routine to set
*   new file access and modification times.  NOTE - MS-DOS
*   does not recognize access time, so this field will
*   always be ignored and the modification time field will be
*   used to set the new time.
*
*******************************************************************************/


#ifndef NO_EXT_KEYS /* extensions enabled */
    #define CDECL   cdecl
#else /* extensions not enabled */
    #define CDECL
#endif /* NO_EXT_KEYS */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* define struct used by utime() function */

#ifndef _UTIMBUF_DEFINED
struct utimbuf {
    time_t actime;      /* access time */
    time_t modtime;     /* modification time */
    };
#define _UTIMBUF_DEFINED
#endif


/* function prototypes */

int CDECL utime(char *, struct utimbuf *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\comm.h ===
/*  COMM.H  */

void processSetComputerId(void);
void processSingleUser(void);
void processGen(void);
void processComm(void);
void processBaudrate(void);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\access.c ===
#include <bios.h>          /* Microsoft Library Includes */
#include <graph.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <dos.h>
#include <string.h>
#include <memory.h>
#include <process.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "defines.h"       /* Access DOS Header Files */
#include "messages.h"
#include "menudata.h"
#include "access.h"
#include "dialogs.h"
#include "datablk.h"
#include "frontend.h"

#define peek(addr)		 (*(unsigned char far *)addr)

	/* the following buffers are used to construct lines of text for printing with _outtext()
		backgroundString holds a copy of the characters that make up the desktop */
char charBuffer[2*LINE_LENGTH+1], tempBuffer[2*LINE_LENGTH+1], backgroundString[LINE_LENGTH+1];
int charBufferLength, tempBufferLength;

	/* The following variables hold the original values for the screen color and cursor size so we can reset after */
long oldBkColor;
short oldTextColor, oldTextCursor;

	/* Used to hold the values for reading the keyboard using _bios_keybrd() */
int keybrdRead, keybrdReady, keybrdShiftStatus;

	/* address of shared parameter block in the first instance of ADOS.COM */
unsigned char _far *currentParameters;

int dummyInt;		/* used for in menus as place holder */

	/* the variables below are local copies of data from the shared parameter block */
unsigned char skSerialKeysOn, skSerialKeysLoaded, skInterrupt;
unsigned int  skPortAddress, skBaudRate, oldPortAddress;
unsigned int  serialPort1, serialPort2, serialPort3, serialPort4, numberOfSerialPorts;

unsigned char fFilterKeysOn, fOnOffFeedback;
unsigned int  fWaitTicks, fDelayTicks, fRepeatTicks, fBounceTicks;
unsigned char fMaxDefault, fClickOn, fBounceOn, fDialogFilterKeysOff;

unsigned char sStickyKeysOn, sOnOffFeedback, sAudibleFeedback, sTriState, sTwoKeysOff, sDialogStickyKeysOff, sClickOn;

unsigned char mMouseKeysOn, mOnOffFeedback;
unsigned int  mMaxSpeed, mTimeToMaxSpeed;
unsigned char mDialogMouseKeysOff, mMouseKeysOverride;

unsigned char tToggleKeysOn, tOnOffFeedback, tDialogToggleKeysOff;

unsigned char toTimeOut, toOnOffFeedback;
unsigned int  toValue;
unsigned char toDialogTimeOutOff;

unsigned char compDialog, compDialogId, compDialogAction, fSpaceSaver;
unsigned char fComputerNotFound, fHearingOn, fVideoFlash, fAccessAlreadyLoaded;

unsigned char eqButton1, eqButton2, eqCurrentButton, eqComputerId, eqMouseDriver, eqMouseId;
unsigned int  eqCommBase, eqExtendedSegment;
unsigned char eqVector, eqInjectKeys, eqVideoType, eqComputerFlag;

	/* boolean flags to determine whether or not to install AccessDOS, quit the user interface,
		what video mode to run in, and whether or not to display debug information throughout the user inferface */
int installFlag = FALSE, quitFlag = FALSE, displayModeFlag = DEFAULT_MODE, debug = FALSE;

   /* Colors for various features of the menu */
long desktopBG, titleBarBG, hintBarBG, menuBarBG, menuBarHotBG, menuBarHotKeyBG;
long menuLineBG, menuLineHotBG, menuLineDeadBG, menuLineHotKeyBG, menuBoxBG;
long dialogBoxBG, dialogBoxHotBG, dialogBoxDeadBG, dialogBoxBorderBG, dialogBoxArrowBG, alertBoxBG;
short desktopFG, titleBarFG, hintBarFG, menuBarFG, menuBarHotFG, menuBarHotKeyFG;
short menuLineFG, menuLineHotFG, menuLineDeadFG, menuLineHotKeyFG, menuBoxFG;
short dialogBoxFG, dialogBoxHotFG, dialogBoxDeadFG, dialogBoxBorderFG, dialogBoxArrowFG, alertBoxFG;

	/* global storage used to construct the configuration filename from the data on the command line */
char driveLetter[_MAX_DRIVE], directoryName[_MAX_DIR], fileName[_MAX_FNAME], fileExtension[_MAX_EXT];
char configurationFilename[_MAX_PATH], *configurationFileExtension = "CFG";

int main(int argc, char *argv[])
{
	int autoLoadFlag = FALSE, forceDialogFlags = FALSE;
	int aCommandLineSwitchFlag = FALSE, xCommandLineSwitchFlag = FALSE;
	int i, desiredOperation;
	int CommandSwitchWatch = FALSE;
		/* read the command line and set the appropriate flags */
   for (i=1; i<argc; i++)
   {
      char *charPtr = argv[i];

      if (*charPtr == '-' || *charPtr == '/')
      {
         charPtr++;

         switch (toupper(*charPtr))
         {
			 	case 'X' :	xCommandLineSwitchFlag = TRUE;
							 	break;

            case 'A' :  aCommandLineSwitchFlag = TRUE;
                        break;

            case 'C' :  displayModeFlag = COLOR_MODE;
                        break;

            case 'M' :  displayModeFlag = MONO_MODE;
                        break;

            case 'L' :  displayModeFlag = LCD_MODE;
                        break;

            case 'D' :  debug = TRUE;
                        break;

	     case 'I' :  CommandSwitchWatch = TRUE;
								break;
		
            case 'S' :	if (toupper(*(charPtr+1)) == 'K') break;		/* SerialKeys -- access.c doesn't need to do anything */

            default  :  

/* changed 11/92 _outtext due to a request since it caused DOS line 25 read problems, and also to conform more
closely with what other DOS 5.0 programs output for messages when typping /? for help   */

			 /* _outtext("\n\nAn invalid command line switch was entered\n");  don't need this */
                        /* _outtext("Valid switches are:\n");  or this */
			
			 printf(" Starts AccessDOS, which is a package of DOS extensions \n");
			 printf(" for keyboard, mouse and sound access.\n\n");
			 printf(" ados [/A] [/C] [/M] [/L] [/X] \n\n");
                        printf("   /A -- Automatically install AccessDOS. \n");
                        printf("   /C -- force AccessDOS to run in Color mode.\n");
                        printf("   /M -- force AccessDOS to run in Monochrome mode.\n");
                        printf("   /L -- force AccessDOS to run in LCD mode.\n");
                        printf("   /X -- force AccessDOS to run in minimal mode.\n");

/*	     		_outtext("   /I -- inhibit mouse hook in Task Switcher mode.\n\n");  keep hidden */
                        exit(FALSE);
                        break;
         }
      }
   }

		/* create the configuration file name from the path passed on the command line */
   _splitpath(argv[0], driveLetter, directoryName, fileName, fileExtension);
   _makepath(configurationFilename, driveLetter, directoryName, fileName, configurationFileExtension);

	Initialize();

	if ((fAccessAlreadyLoaded)&&(CommandSwitchWatch))
		{
/* removed _outtext here also, see note above */
			printf("\n\nYou cannot change MouseKeys status after AccessDOS \n");
			printf("is loaded.  Please unload AccessDOS and use this switch \n");
			printf("when installing AccessDOS.\n\n");
			exit(FALSE);
		}

	if (aCommandLineSwitchFlag) autoLoadFlag = TRUE;
	else autoLoadFlag = FALSE;

   if (fComputerNotFound)
   {
       int height = 11, width = 58;
	_clearscreen(_GCLEARSCREEN);
       DisplayAlertBox(ComputerNotFoundAlertText, height, width);
       autoLoadFlag = FALSE;
   }

	if (fAccessAlreadyLoaded)
	{																				/* if AccessDOS is already running */
		autoLoadFlag = FALSE;												/*		force the user to the menu */

	}
	else																			/* if this is the initial running of AccessDOS */
	{
		if (eqMouseId == 2) mMaxSpeed = 4;								/* Slow the default mouse speed for a Serial Mouse */
		if (xCommandLineSwitchFlag && !aCommandLineSwitchFlag)	/* if there is an X on the command line, there was an error */
		{																			/*		opening the configuration file, (the X should have */
			int height = 9, width = 60;									/* 	been trapped by the parent program and control should */
																					/* 	not have been passed to us here) */
			DisplayAlertBox(LoadFailedAlertText, height, width);
			autoLoadFlag = FALSE;
		}
		if (aCommandLineSwitchFlag)										/* if there is an A on the command line, make sure that the */
		{																			/* file can be read before starting the count down */
			int height = 9, width = 60, fileHandle = open(configurationFilename, O_RDWR | O_BINARY);
			if (fileHandle == -1)											/* if the file cannot be read, display error and go to menu */
			{
				DisplayAlertBox(LoadFailedAlertText, height, width);
				autoLoadFlag = FALSE;
			}
			else close(fileHandle);
		}
	}

	if (fAccessAlreadyLoaded)
		{
		desiredOperation = CONTROL_PANEL;
		}
	else if (autoLoadFlag) /* if starting with '/a', do count down screen */
		{
		desiredOperation = DisplayStartUpScreen(autoLoadFlag);		
		}
	else /* for all other cold starts, go to menus  when not previously loaded! */
		{
		desiredOperation = CONTROL_PANEL;
		}
		 
	switch (desiredOperation)
   {
		case CONTROL_PANEL	:	ManageMenu();
										break;

		case AUTOLOAD			:	if (LoadParameters()) installFlag = forceDialogFlags = TRUE;
                              else ManageMenu();
										break;
   }
	CleanUp(installFlag, forceDialogFlags);

	if (installFlag) return(INSTALL_ACCESS);
	else return (ABORT_ACCESS);
}  /* end main() */


void Initialize(void)
{
   keybrdRead        = _KEYBRD_READ;
   keybrdReady       = _KEYBRD_READY;
   keybrdShiftStatus = _KEYBRD_SHIFTSTATUS;

   /* If bit 4 of the byte at 0x0040:0x0096 is set, the new keyboard
    * is present.
    */
/*
	if(peek(0x00400096) & 0x10)
   {
      keybrdRead = _NKEYBRD_READ;
      keybrdReady = _NKEYBRD_READY;
      keybrdShiftStatus = _NKEYBRD_SHIFTSTATUS;
   }
*/

	GetInterruptNumber();
   GetEquipmentListAndParameters();
   PatchMenus();

		/* if there was not a switch on the command line for the video mode,
			set mode as detected by the Find_Computer routine (eqVideoType) */
   if (displayModeFlag == DEFAULT_MODE)
		switch (eqVideoType)
		{
			case 1 :														/* Monochrome Display Adapter */
			case 4 :	displayModeFlag = MONO_MODE;	break;	/* Monochrome EGA */

			case 3 :														/* CGA */
			case 5 :														/* EGA */
			case 7 : displayModeFlag = COLOR_MODE;	break;	/* VGA */

			default: displayModeFlag = MONO_MODE;	break;	/* Unknown video */
		}

   switch (displayModeFlag)
   {
      case COLOR_MODE   :  _setvideomode(_TEXTC80);
                           SetColorsForColor();
                           break;

      case MONO_MODE    :  _setvideomode(_TEXTBW80);
                           SetColorsForMono();
                           break;

      case LCD_MODE     :  _setvideomode(_TEXTMONO);
                           SetColorsForLCD();

										/* make all characters lowercase and Hot key uppercase */
									{
										int i, j;
										MENU_LIST_RECORD *currentMenuList;
										char *charPtr;

										i=0;
										do
										{
											currentMenuList = menuList[i].menuList;
											j=0;
											do
											{
												charPtr = currentMenuList[j].leftText;
												do
												{
													*charPtr = (char) tolower(*charPtr);
													charPtr++;
												}	while (*charPtr);

												charPtr = currentMenuList[j].midText;
												*charPtr = (char) toupper(*charPtr);

												charPtr = currentMenuList[j].rightText;
												do
												{
													*charPtr = (char) tolower(*charPtr);
													charPtr++;
												}	while (*charPtr);

											} while (currentMenuList[j++].lastRecord == FALSE);
										} while (menuList[i++].lastRecord == FALSE);
									}
                           break;
   }
	oldTextCursor = _settextcursor(0x2000);

   memset(backgroundString, '', 80);     /* <176> = ; <177> = ; <178> =  */
   backgroundString[80] = '\0';
}  /* end Initialize() */


void SetColorsForColor(void)
{
   desktopFG         = CYAN;
   desktopBG         = BLUE;

   titleBarFG        = BLACK;
   titleBarBG        = CYAN;

   hintBarFG         = YELLOW;
   hintBarBG         = BLUE;

   menuBarFG         = YELLOW;
   menuBarBG         = BLUE;
   menuBarHotFG      = BLUE;
   menuBarHotBG      = WHITE;
   menuBarHotKeyFG   = LIGHT_CYAN;
   menuBarHotKeyBG   = BLUE;

   menuLineFG        = YELLOW;
   menuLineBG        = BLUE;
   menuLineHotFG     = BLUE;
   menuLineHotBG     = WHITE;
   menuLineDeadFG    = WHITE;
   menuLineDeadBG    = BLUE;
   menuLineHotKeyFG  = LIGHT_CYAN;
   menuLineHotKeyBG  = BLUE;

   menuBoxFG         = YELLOW;
   menuBoxBG         = BLUE;

   dialogBoxFG       = YELLOW;
   dialogBoxBG       = BLUE;
	dialogBoxHotFG		= BLUE;
	dialogBoxHotBG		= WHITE;
	dialogBoxDeadFG	= WHITE;
	dialogBoxDeadBG	= BLUE;
   dialogBoxBorderFG = BRIGHT_WHITE;
   dialogBoxBorderBG = BLUE;
   dialogBoxArrowFG  = BRIGHT_WHITE;
   dialogBoxArrowBG  = BLUE;

   alertBoxFG        = BRIGHT_WHITE;
   alertBoxBG        = RED;
}  /* end SetColordForColor() */


void SetColorsForMono(void)
{
   desktopFG         = BLACK;
   desktopBG         = WHITE;

   titleBarFG        = BRIGHT_WHITE;
   titleBarBG        = BLACK;

   hintBarFG         = BLACK;
   hintBarBG         = WHITE;

   menuBarFG         = BLACK;
   menuBarBG         = WHITE;
   menuBarHotFG      = WHITE;
   menuBarHotBG      = BLACK;
   menuBarHotKeyFG   = BRIGHT_WHITE;
   menuBarHotKeyBG   = BLACK;

   menuLineFG        = BRIGHT_WHITE;
   menuLineBG        = BLACK;
   menuLineHotFG     = BLACK;
   menuLineHotBG     = WHITE;
   menuLineDeadFG    = WHITE;
   menuLineDeadBG    = BLACK;
   menuLineHotKeyFG  = WHITE;
   menuLineHotKeyBG  = BLACK;

   menuBoxFG         = BRIGHT_WHITE;
   menuBoxBG         = BLACK;

   dialogBoxFG       = WHITE;
   dialogBoxBG       = BLACK;
	dialogBoxHotFG		= BLACK;
	dialogBoxHotBG		= WHITE;
	dialogBoxDeadFG	= WHITE;
	dialogBoxDeadBG	= BLACK;
   dialogBoxBorderFG = BRIGHT_WHITE;
   dialogBoxBorderBG = BLACK;
   dialogBoxArrowFG  = BRIGHT_WHITE;
   dialogBoxArrowBG  = BLACK;

   alertBoxFG        = BLACK;
   alertBoxBG        = WHITE;
}  /* end SetColorsForMono() */


void SetColorsForLCD(void)
{
   desktopFG         = BLACK;
   desktopBG         = BLACK;

   titleBarFG        = WHITE;
   titleBarBG        = BLACK;

   hintBarFG         = BLACK;
   hintBarBG         = WHITE;

   menuBarFG         = BLACK;
   menuBarBG         = WHITE;
   menuBarHotFG      = WHITE;
   menuBarHotBG      = BLACK;
   menuBarHotKeyFG   = BLACK;
   menuBarHotKeyBG   = WHITE;

   menuLineFG        = BRIGHT_WHITE;
   menuLineBG        = BLACK;
   menuLineHotFG     = BLACK;
   menuLineHotBG     = WHITE;
   menuLineDeadFG    = WHITE;
   menuLineDeadBG    = BLACK;
   menuLineHotKeyFG  = WHITE;
   menuLineHotKeyBG  = BLACK;

   menuBoxFG         = BRIGHT_WHITE;
   menuBoxBG         = BLACK;

   dialogBoxFG       = WHITE;
   dialogBoxBG       = BLACK;
	dialogBoxHotFG		= BLACK;
	dialogBoxHotBG		= WHITE;
	dialogBoxDeadFG	= WHITE;
	dialogBoxDeadBG	= BLACK;
   dialogBoxBorderFG = BRIGHT_WHITE;
   dialogBoxBorderBG = BLACK;
   dialogBoxArrowFG  = BRIGHT_WHITE;
   dialogBoxArrowBG  = BLACK;

   alertBoxFG        = WHITE;
   alertBoxBG        = BLACK;
}  /* end SetColorsForLCD() */


void GetEquipmentListAndParameters(void)
{
   GetAddressOfParameterBlock();       /* this routine checks for the existance of ACCESS.COM in RAM and aborts if not found */
	GetAccessParameters();
/*
   if (fAccessAlreadyLoaded == FALSE)
   {
	   FindMouse();
	   FindComputer();
   	SetEquipmentParameters();
   	GetAccessParameters();
   }
   else GetEquipmentParameters();
*/
   GetEquipmentParameters();
	GetSerialPortInformation();

	if (debug)
	{
   	DisplayEquipmentParameters();
   	DisplayCurrentParameters();
	}
}  /* end GetEquipmentListAndParameters() */


void GetSerialPortInformation(void)
{
	_segment biosSegment = 0x040;
	unsigned int _based(biosSegment) *commPorts = 0;
	int i;

	numberOfSerialPorts = 0;
	serialPort1 = serialPort2 = serialPort3 = serialPort4 = 0;

	if (debug) _settextposition(11, 1);

	for (i=0; i<4; i++)
	{
		if (debug)
		{
			charBufferLength = sprintf(charBuffer, "40:%02X=0x%04X  ", i, commPorts[i]);
			_outtext(charBuffer);
		}

		if (commPorts[i])
		{
			++numberOfSerialPorts;
			switch (commPorts[i])
			{
				case 0x03f8	: serialPort1 = commPorts[i]; break;

				case 0x02f8	: serialPort2 = commPorts[i]; break;

				case 0x03e8	:
				case 0x3220	:
				case 0xb220	: serialPort3 = commPorts[i]; break;

				case 0x02e8	:
				case 0x3228	:
				case 0xb228	: serialPort4 = commPorts[i]; break;

				default		: --numberOfSerialPorts; break;
			}
		}
	}

	if (debug)
	{
		charBufferLength = sprintf(charBuffer, "\nnumberOfSerialPorts found: %d\n", numberOfSerialPorts);
		_outtext(charBuffer);
		charBufferLength = sprintf(charBuffer, "serial1: 0x%04X  serial2: 0x%04X  serial3: 0x%04X  serial4: 0x%04X\n",
											serialPort1, serialPort2, serialPort3, serialPort4);
		if (charBufferLength > LINE_LENGTH) exit(ABORT_ACCESS);
		else _outtext(charBuffer);
	}
}	/* end GetSerialPortInformation() */


void PatchMenus(void)
{
	int i, validSerialPort = FALSE;

	if (serialPort1) serialPortOption[0].paramValue = serialPort1;
	else serialPortOption[0].selectable = SELECTABLE_NO;
	if (serialPort2) serialPortOption[1].paramValue = serialPort2;
	else serialPortOption[1].selectable = SELECTABLE_NO;
	if (serialPort3) serialPortOption[2].paramValue = serialPort3;
	else serialPortOption[2].selectable = SELECTABLE_NO;
	if (serialPort4) serialPortOption[3].paramValue = serialPort4;
	else serialPortOption[3].selectable = SELECTABLE_NO;

   if (eqMouseId == 0)
   {
      i = 0;
      do
      {
         if (adjustMenuList[i].dialogProcPtr == MouseKeys)
         {
            adjustMenuList[i].selectable = SELECTABLE_NO;
				adjustMenuList[i].hotKey = '\0';
				if (displayModeFlag == LCD_MODE)
				{
					*(adjustMenuList[i].leftText) = '(';
 					*((adjustMenuList[i].rightText)+strlen(adjustMenuList[i].rightText)-1) = ')';
				}
            break;
         }
      } while (adjustMenuList[i++].lastRecord == FALSE);
   }

	if (eqCommBase == 0x3f8) serialPortOption[0].selectable = SELECTABLE_NO;	/* mouse is on comm1 so serialKeys can't be */
	if (eqCommBase == 0x2f8) serialPortOption[1].selectable = SELECTABLE_NO;	/* mouse is on comm2 so serialKeys can't be */

	for (i=0; i<4; i++) validSerialPort |= (serialPortOption[i].selectable == SELECTABLE_YES);
   if (validSerialPort == FALSE)
   {
      i = 0;
      do
      {
         if (adjustMenuList[i].dialogProcPtr == SerialKeys)
         {
            adjustMenuList[i].selectable = SELECTABLE_NO;
				adjustMenuList[i].hotKey = '\0';
				if (displayModeFlag == LCD_MODE)
				{
					*(adjustMenuList[i].leftText) = '(';
 					*((adjustMenuList[i].rightText)+strlen(adjustMenuList[i].rightText)-1) = ')';
				}
            break;
         }
      } while (adjustMenuList[i++].lastRecord == FALSE);
   }
	else
	{
		for (i=0; i<4; i++)
		{
			if (serialPortOption[i].selectable == SELECTABLE_YES)
			{
				serialPortOption[i].hot = TRUE;
				skPortAddress = serialPortOption[i].paramValue;
				break;
			}
		}
	}

   if (fComputerNotFound)
   {
      i = 0;
      do
      {
         if (miscellaneousDialogList[i].optionList == computerOption)
         {
            miscellaneousDialogList[i].selectable = SELECTABLE_YES;
            break;
         }
      } while (miscellaneousDialogList[i++].lastRecord == FALSE);
      compDialog = TRUE;
   }

		/* if the computer is a PS/2 model 25 or 30/86 then we can't flash the video */
	if (eqComputerId == 6)
	{
      i = 0;
      do
      {
         if (showSoundsDialogList[i].optionList == screenFlashOnOption)
         {
            showSoundsDialogList[i].selectable = SELECTABLE_NEVER;
            break;
         }
      } while (showSoundsDialogList[i++].lastRecord == FALSE);
	}
}  /* end PatchMenus() */


void CleanUp(int installFlag, int forceDialogFlags)
{
   _settextwindow(1, 1, 25, 80);
   _clearscreen(_GCLEARSCREEN);

   if (installFlag) SetAccessParameters(currentParameters, forceDialogFlags);
   if (fComputerNotFound)
   {
/*      FindComputer();    /* call this again so Mark can reset the computer type */
      SetEquipmentParameters();
   }

	if (debug)
	{
   	DisplayEquipmentParameters();
   	DisplayCurrentParameters();
	}

	_setvideomode(_DEFAULTMODE);
	if (eqComputerId == 6) _settextcursor(0x0707);
	else _settextcursor(oldTextCursor);
}	/* end CleanUp() */


void WaitForAnyKey(void)
{
   _bios_keybrd(keybrdRead);
}  /* end WaitForAnyKey() */


void ClearKeyboardBuffer(void)
{
	while (_bios_keybrd(keybrdReady)) _bios_keybrd(keybrdRead);
}	/* ClearKeyboardBuffer() */


void DummyFunction(void)
{
}	/* end DummyFunction() */


int DisplayStartupScreenText(int line, int center, int titleFlag, int autoLoadFlag)
{
	int timeOutLine;

	if (titleFlag)
	{
		charBufferLength = sprintf(charBuffer, "AccessDOS 1.1");
   	_settextposition(line++, center-charBufferLength/2);
   	_outtext(charBuffer);
	}
	line++;

	charBufferLength = sprintf(charBuffer, "A package of DOS extensions");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "for keyboard, mouse and sound access. ");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);

	if (autoLoadFlag)
	{
		timeOutLine = line+1;
		line += 8;
	}
	else
	{
		timeOutLine = 0;
		line += 3;
	}

	charBufferLength = sprintf(charBuffer, "Trace R&D Center");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "Waisman Center and Industrial Engineering Department");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "University of Wisconsin-Madison");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "Copyright - Board of Regents, University of Wisconsin System");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);
   line++;

	charBufferLength = sprintf(charBuffer, "Support for this work was provided in part by");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "IBM Corporation");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "and by the");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "National Institute on Disability and Rehabilitation Research (NIDRR)");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "US Department of Education under Grant #H133E80021");
   _settextposition(line++, center-charBufferLength/2);
   _outtext(charBuffer);

   return timeOutLine;
}  /* end DisplayStartupScreenText() */


int DisplayStartUpScreen(int autoLoadFlag)
{
	int line, timeOutLine;
	int key, ascii;
   int keyPressed = FALSE, helpMessageFlag = FALSE;

	if (autoLoadFlag)
   {
      line = 3;
      charBufferLength = sprintf(charBuffer, "");
   }
   else
   {
   	line = 5;
   	charBufferLength = sprintf(charBuffer, "Press any key to continue.");
   }

//  	OutputHintBar(charBuffer, JUSTIFY_CENTER, helpMessageFlag);
//	OutputTitleBar();

//	_settextwindow(2, 1, 24, 80);
   _settextcolor(dialogBoxFG);
   _setbkcolor(dialogBoxBG);
   _clearscreen(_GWINDOW);
	_settextwindow(1, 1, 25, 80);

// removed since we do not want to display any text in this screen on cold install
// unless user does '/a' command line switch, then give them the count down option   
//   timeOutLine = DisplayStartupScreenText(line, 40, displayModeFlag == COLOR_MODE, autoLoadFlag);

// borrowed from 'DisplayStartupScreenText' since it is no longer called
	if (autoLoadFlag)
	{
		timeOutLine = line+1;
		line += 8;
	}
	else
	{
		timeOutLine = 0;
		line += 3;
	}

	_settextwindow(1, 1, 25, 80);

   if (autoLoadFlag) keyPressed = RunCountdownTimer(timeOutLine);

   if (autoLoadFlag == FALSE)
   {
		ClearKeyboardBuffer();
      _bios_keybrd(keybrdRead);
      return(CONTROL_PANEL);
   }

   if (keyPressed == TRUE) key = _bios_keybrd(keybrdRead);
   else key = 0;
   ascii = key & 0x00ff;
   if (ascii == ENTER)  return(CONTROL_PANEL);
   if (ascii == ESCAPE) return(ABORT);
   return(AUTOLOAD);
}  /* end DisplayStartUpScreen */


int RunCountdownTimer(int line)
{
   unsigned lastSecond;
   struct dostime_t time;
	int secsRemaining = TIMEOUT_SECONDS, timeLine, keyPressed = FALSE;

	charBufferLength = sprintf(charBuffer, "ͻ");
   _settextposition(line++, 41-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    Press Escape now to abort loading AccessDOS.                      ");
   _settextposition(line++, 41-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    Press Enter now to go to the main menu.                           ");
   _settextposition(line++, 41-charBufferLength/2);
   _outtext(charBuffer);
   timeLine = line;
	charBufferLength = sprintf(charBuffer, "    Press any other key (or wait 20 seconds) to install AccessDOS     ");
	_settextposition(line++, 41-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "          with the settings saved in the ADOS.CFG file.               ");
   _settextposition(line++, 41-charBufferLength/2);
   _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "ͼ");
   _settextposition(line++, 41-charBufferLength/2);
   _outtext(charBuffer);

	ClearKeyboardBuffer();

      /* wait for next second */
   _dos_gettime(&time);
   lastSecond = time.second;
   do
   {
      _dos_gettime(&time);
   } while (lastSecond == time.second);
   lastSecond = time.second;

	while (secsRemaining)
	{
		if (_bios_keybrd(keybrdReady))
		{
			keyPressed = TRUE;
			break;
		}
		charBufferLength = sprintf(charBuffer, "    Press any other key (or wait %2d seconds) to install AccessDOS     ",
											secsRemaining);
		_settextposition(timeLine, 41-charBufferLength/2);
      _outtext(charBuffer);

      while (lastSecond == time.second) _dos_gettime(&time);
      lastSecond = time.second;
		secsRemaining--;
	}
   return keyPressed;
}  /* end RunCountdownTimer() */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\datablk.c ===
#include <bios.h>
#include <graph.h>
#include <stdio.h>
#include <string.h>
#include <dos.h>
#include <fcntl.h>
#include <process.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>

#include "datablk.h"
#include "defines.h"
#include "globals.h"
#include "messages.h"
#include "access.h"
#include "dialogs.h"

#define  ACCESS_FUNCTION   0xAD        /******* any changes here must also be made in KEYBOARD.INC */

#define  TSR_HERE          0xACCE      /******* any changes here must also be made in KEYBOARD.INC */
#define  TSR_DETECT        0xe1        /******* any changes here must also be made in KEYBOARD.INC */
#define  TSR_PARAMS        0xe2        /******* any changes here must also be made in KEYBOARD.INC */


/* Offsets into dataBlock for shared parameters to Mark's code */

#define SK_SERIAL_KEYS_ON            0    /* db */    /* Serial Keys Parameters */
#define SK_PORT_ADDRESS              1    /* dw */
#define SK_BAUD_RATE                 3    /* dw */

#define F_FILTER_KEYS_ON			    5 	/* db */		/* FilterKeys (SlowKeys and RepeatKeys) */
#define F_ON_OFF_FEEDBACK			    6 	/* db */
#define F_USER_SETUP_OPTION_1 	    7 	/* db */
#define F_USER_SETUP_OPTION_2 	    8 	/* db */
#define F_WAIT_TICKS 				    9 	/* dw */
#define F_DELAY_TICKS				   11 	/* dw */
#define F_REPEAT_TICKS				   13 	/* dw */
#define F_RECOVERY_TICKS			   15 	/* dw */
#define F_MAX_DEFAULT				   17 	/* db */
#define F_CLICK_ON					   18 	/* db */
#define F_RECOVERY_ON				   19 	/* db */
#define F_DIALOG_FILTER_KEYS_OFF    20    /* db */

#define S_STICKEY_KEYS_ON			   21		/* db */		/* StickyKeys */
#define S_ON_OFF_FEEDBACK			   22		/* db */
#define S_AUDIBLE_FEEDBACK			   23		/* db */
#define S_TRI_STATE					   24		/* db */
#define S_TWO_KEYS_OFF				   25		/* db */
#define S_DIALOG_STICKEY_KEYS_OFF   26		/* db */
#define S_STICKEY_CLICK_ON			   27		/* db */

#define M_MOUSE_KEYS_ON				   28		/* db */		/* MouseKeys */
#define M_ON_OFF_FEEDBACK			   29		/* db */
#define M_MAX_SPEED					   30		/* dw */
#define M_TIME_TO_MAX_SPEED		   32		/* dw */
#define M_DIALOG_MOUSE_KEYS_OFF     34    /* db */
#define M_MOUSE_KEYS_OVERRIDE       35    /* db */

#define T_TOGGLE_KEYS_ON			   36		/* db */		/* ToggleKeys */
#define T_ON_OFF_FEEDBACK			   37		/* db */
#define T_DIALOG_TOGGLE_KEYS_OFF    38    /* db */

#define TO_TIME_OUT					   39		/* db */		/* TimeOut Parameters */
#define TO_ON_OFF_FEEDBACK			   40		/* db */
#define TO_VALUE						   41		/* dw */
#define TO_DIALOG_TIMEOUT_OFF       43    /* db */

#define COMP_DIALOG                 44    /* db */
#define COMP_DIALOG_ID              45    /* db */
#define COMP_DIALOG_ACTION          46    /* db */

#define F_SPACE_SAVER               47    /* db */
#define F_COMPUTER_NOT_FOUND        48    /* db */
#define F_HEARING_ON                49    /* db */
#define SK_SERIAL_KEYS_LOADED  		50	   /* db */
#define F_ACCESS_ALREADY_LOADED     51    /* db */

#define SK_INTERRUPT                52    /* db */
#define F_VIDEO_FLASH					53		/* db */
#define FILLER_SPACE                54    /* room for expansion */
#define DATA_BLOCK_LENGTH           61    /* length of the datablock */

#define BUTTON_1                    61    /* db */
#define BUTTON_2                    62    /* db */
#define CURRENT_BUTTON              63    /* db */
#define COMPUTER_ID						64		/* db */
#define MOUSE_DRIVER						65		/* db */
#define MOUSE_ID							66		/* db */
#define COMM_BASE							67		/* dw */
#define EXTENDED_SEGMENT				69		/* dw */
#define VECTOR								71		/* db */
#define INJECT_KEYS						72		/* db */
#define VIDEO_TYPE						73		/* db */
#define COMPUTER_FLAG					74		/* db */


char _far *accessString = "ACCESS";
unsigned char transferBuffer[DATA_BLOCK_LENGTH];
int interruptNumber = 0;

void GetInterruptNumber(void)
{
	int i;
	size_t count = _fstrlen(accessString);
	unsigned char _far *strPtr;
	void (_interrupt _far *interruptHandler)();

	if (debug)	_clearscreen(_GCLEARSCREEN);

	for (i=0x60; i<0x68; i++)
	{
		interruptHandler = _dos_getvect(i);
		strPtr = (unsigned char _far *) interruptHandler;
		if (_fstrncmp(accessString, strPtr+3, count) == 0) interruptNumber = i;

		if (debug)
		{
			printf("0x%02X: %Fp", i, strPtr);
			if	(strPtr)	printf(" %.15Fs\n", strPtr+3);
			else printf("\n");
		}
	}

	if	(debug) printf("Interrupt Number: 0x%02X\n", interruptNumber);

	if (interruptNumber == 0)
	{
		printf("TSR not installed.  An error has occured installing TSR helper routine.");
		exit(ABORT_ACCESS);
	}
}	/* end GetInterruptNumber() */


void GetAddressOfParameterBlock(void)
{
	union REGS inputRegisters, outputRegisters;
	unsigned int _far *paramAddressPtr = (unsigned int _far *) &currentParameters;

	inputRegisters.h.ah = ACCESS_FUNCTION;
	inputRegisters.h.al = TSR_DETECT;
	int86(interruptNumber, &inputRegisters, &outputRegisters);
	if (outputRegisters.x.ax == TSR_HERE)
	{
		inputRegisters.h.ah = ACCESS_FUNCTION;
		inputRegisters.h.al = TSR_PARAMS;
		int86(interruptNumber, &inputRegisters, &outputRegisters);
		*paramAddressPtr = outputRegisters.x.ax;
		paramAddressPtr++;
		*paramAddressPtr = outputRegisters.x.bx;
	}
	else
	{
		printf("TSR not installed.  An error has occured reading shared parameter block.");
		exit(ABORT_ACCESS);
	}
}  /* end GetAddressOfParameterBlock() */


void GetAccessParameters(void)
{
   skSerialKeysOn             = *((unsigned char _far *)  (currentParameters+SK_SERIAL_KEYS_ON));
   skPortAddress              = *((unsigned int  _far *)  (currentParameters+SK_PORT_ADDRESS));  oldPortAddress = skPortAddress;
   skBaudRate                 = *((unsigned int  _far *)  (currentParameters+SK_BAUD_RATE));
   skSerialKeysLoaded         = *((unsigned char _far *)  (currentParameters+SK_SERIAL_KEYS_LOADED));
   skInterrupt                = *((unsigned char _far *)  (currentParameters+SK_INTERRUPT));

	fFilterKeysOn			      = *((unsigned char _far *)	(currentParameters+F_FILTER_KEYS_ON));
	fOnOffFeedback			      = *((unsigned char _far *)	(currentParameters+F_ON_OFF_FEEDBACK));
	fWaitTicks				      = *((unsigned int  _far *)	(currentParameters+F_WAIT_TICKS));
	fDelayTicks				      = *((unsigned int  _far *)	(currentParameters+F_DELAY_TICKS));
	fRepeatTicks			      = *((unsigned int  _far *)	(currentParameters+F_REPEAT_TICKS));
	fBounceTicks			      = *((unsigned int  _far *)	(currentParameters+F_RECOVERY_TICKS));
	fMaxDefault				      = *((unsigned char _far *)	(currentParameters+F_MAX_DEFAULT));
	fClickOn					      = *((unsigned char _far *)	(currentParameters+F_CLICK_ON));
	fBounceOn					   = *((unsigned char _far *)	(currentParameters+F_RECOVERY_ON));
	fDialogFilterKeysOff       = *((unsigned char _far *)	(currentParameters+F_DIALOG_FILTER_KEYS_OFF));

	sStickyKeysOn			      = *((unsigned char _far *)	(currentParameters+S_STICKEY_KEYS_ON));
	sOnOffFeedback			      = *((unsigned char _far *)	(currentParameters+S_ON_OFF_FEEDBACK));
	sAudibleFeedback		      = *((unsigned char _far *)	(currentParameters+S_AUDIBLE_FEEDBACK));
	sTriState				      = *((unsigned char _far *)	(currentParameters+S_TRI_STATE));
	sTwoKeysOff				      = *((unsigned char _far *)	(currentParameters+S_TWO_KEYS_OFF));
	sDialogStickyKeysOff			= *((unsigned char _far *)	(currentParameters+S_DIALOG_STICKEY_KEYS_OFF));
	sClickOn							= *((unsigned char _far *)	(currentParameters+S_STICKEY_CLICK_ON));

	mMouseKeysOn			      = *((unsigned char _far *)	(currentParameters+M_MOUSE_KEYS_ON));
	mOnOffFeedback			      = *((unsigned char _far *)	(currentParameters+M_ON_OFF_FEEDBACK));
	mMaxSpeed				      = *((unsigned int  _far *)	(currentParameters+M_MAX_SPEED));
	mTimeToMaxSpeed		      = *((unsigned int  _far *)	(currentParameters+M_TIME_TO_MAX_SPEED));
	mDialogMouseKeysOff        = *((unsigned char _far *)	(currentParameters+M_DIALOG_MOUSE_KEYS_OFF));
	mMouseKeysOverride         = *((unsigned char _far *)	(currentParameters+M_MOUSE_KEYS_OVERRIDE));

	tToggleKeysOn			      = *((unsigned char _far *)	(currentParameters+T_TOGGLE_KEYS_ON));
	tOnOffFeedback			      = *((unsigned char _far *)	(currentParameters+T_ON_OFF_FEEDBACK));
	tDialogToggleKeysOff       = *((unsigned char _far *)	(currentParameters+T_DIALOG_TOGGLE_KEYS_OFF));

	toTimeOut						= *((unsigned char _far *)	(currentParameters+TO_TIME_OUT));
	toOnOffFeedback				= *((unsigned char _far *)	(currentParameters+TO_ON_OFF_FEEDBACK));
	toValue							= *((unsigned int  _far *)	(currentParameters+TO_VALUE));
	toDialogTimeOutOff			= *((unsigned char _far *)	(currentParameters+TO_DIALOG_TIMEOUT_OFF));

   compDialog						= *((unsigned char _far *)  (currentParameters+COMP_DIALOG));
   compDialogId					= *((unsigned char _far *)  (currentParameters+COMP_DIALOG_ID));
   compDialogAction				= *((unsigned char _far *)  (currentParameters+COMP_DIALOG_ACTION));
   fSpaceSaver						= *((unsigned char _far *)  (currentParameters+F_SPACE_SAVER));
   fComputerNotFound				= *((unsigned char _far *)  (currentParameters+F_COMPUTER_NOT_FOUND));
   fHearingOn						= *((unsigned char _far *)  (currentParameters+F_HEARING_ON));
   fVideoFlash						= *((unsigned char _far *)  (currentParameters+F_VIDEO_FLASH));
   fAccessAlreadyLoaded			= *((unsigned char _far *)  (currentParameters+F_ACCESS_ALREADY_LOADED));
}	/* end GetAccessParameters() */


void SetAccessParameters(unsigned char _far *paramBlockPtr, int forceDialogFlags)
{
	unsigned char _far *charPtr;
	unsigned int _far *intPtr;
   compDialogAction = TRUE;

      /* Set fDialogFilterKeysOff to TRUE if a FilterKeys Parameter has changed */
   if (forceDialogFlags) fDialogFilterKeysOff = TRUE;
   else fDialogFilterKeysOff = (unsigned char)
      (*((unsigned char _far *) (paramBlockPtr + F_FILTER_KEYS_ON))        != fFilterKeysOn     ||
       *((unsigned char _far *) (paramBlockPtr + F_ON_OFF_FEEDBACK))       != fOnOffFeedback    ||
       *((unsigned int  _far *) (paramBlockPtr + F_WAIT_TICKS))            != fWaitTicks        ||
       *((unsigned int  _far *) (paramBlockPtr + F_DELAY_TICKS))           != fDelayTicks       ||
       *((unsigned int  _far *) (paramBlockPtr + F_REPEAT_TICKS))          != fRepeatTicks      ||
       *((unsigned int  _far *) (paramBlockPtr + F_RECOVERY_TICKS))        != fBounceTicks      ||
       *((unsigned char _far *) (paramBlockPtr + F_MAX_DEFAULT))           != fMaxDefault       ||
       *((unsigned char _far *) (paramBlockPtr + F_CLICK_ON))              != fClickOn          ||
       *((unsigned char _far *) (paramBlockPtr + F_RECOVERY_ON))           != fBounceOn);

      /* store the globals back into the shared parameter block */
	charPtr	= (unsigned char _far *)	(paramBlockPtr + F_FILTER_KEYS_ON);				*charPtr = fFilterKeysOn;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + F_ON_OFF_FEEDBACK);			*charPtr = fOnOffFeedback;
	intPtr	= (unsigned int  _far *)	(paramBlockPtr + F_WAIT_TICKS);					*intPtr	= fWaitTicks;
	intPtr	= (unsigned int  _far *)	(paramBlockPtr + F_DELAY_TICKS);					*intPtr	= fDelayTicks;
	intPtr	= (unsigned int  _far *)	(paramBlockPtr + F_REPEAT_TICKS);				*intPtr	= fRepeatTicks;
	intPtr	= (unsigned int  _far *)	(paramBlockPtr + F_RECOVERY_TICKS);				*intPtr	= fBounceTicks;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + F_MAX_DEFAULT);					*charPtr = fMaxDefault;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + F_CLICK_ON);						*charPtr	= fClickOn;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + F_RECOVERY_ON);					*charPtr	= fBounceOn;
   charPtr  = (unsigned char _far *)   (paramBlockPtr + F_DIALOG_FILTER_KEYS_OFF);	*charPtr = fDialogFilterKeysOff;



      /* Set sDialogStickyKeysOff to TRUE if a StickyKeys Parameter has changed */
   if (forceDialogFlags) sDialogStickyKeysOff = TRUE;
   else sDialogStickyKeysOff = (unsigned char)
      (*((unsigned char _far *)	(paramBlockPtr + S_STICKEY_KEYS_ON))        != sStickyKeysOn       ||
	    *((unsigned char _far *)	(paramBlockPtr + S_ON_OFF_FEEDBACK))        != sOnOffFeedback       ||
	    *((unsigned char _far *)	(paramBlockPtr + S_AUDIBLE_FEEDBACK))       != sAudibleFeedback     ||
  	    *((unsigned char _far *)	(paramBlockPtr + S_TRI_STATE))              != sTriState            ||
  	    *((unsigned char _far *)	(paramBlockPtr + S_TWO_KEYS_OFF))           != sTwoKeysOff          ||
  	    *((unsigned char _far *)	(paramBlockPtr + S_STICKEY_CLICK_ON))       != sClickOn);

      /* store the globals back into the shared parameter block */
	charPtr	= (unsigned char _far *)	(paramBlockPtr + S_STICKEY_KEYS_ON);			*charPtr	= sStickyKeysOn;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + S_ON_OFF_FEEDBACK);			*charPtr	= sOnOffFeedback;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + S_AUDIBLE_FEEDBACK);			*charPtr	= sAudibleFeedback;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + S_TRI_STATE);					*charPtr	= sTriState;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + S_TWO_KEYS_OFF);				*charPtr	= sTwoKeysOff;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + S_DIALOG_STICKEY_KEYS_OFF);	*charPtr	= sDialogStickyKeysOff;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + S_STICKEY_CLICK_ON);			*charPtr	= sClickOn;



      /* Set sDialogMouseKeysOff to TRUE if a MouseKeys Parameter has changed */
	if (forceDialogFlags) mDialogMouseKeysOff = TRUE;
   else mDialogMouseKeysOff = (unsigned char)
      (*((unsigned char _far *)	(paramBlockPtr + M_MOUSE_KEYS_ON))       != mMouseKeysOn      ||
	    *((unsigned char _far *)	(paramBlockPtr + M_ON_OFF_FEEDBACK))     != mOnOffFeedback    ||
	    *((unsigned int  _far *)	(paramBlockPtr + M_MAX_SPEED))           != mMaxSpeed         ||
	    *((unsigned int  _far *)	(paramBlockPtr + M_TIME_TO_MAX_SPEED))   != mTimeToMaxSpeed   ||
	    *((unsigned char _far *)	(paramBlockPtr + M_MOUSE_KEYS_OVERRIDE)) != mMouseKeysOverride);

      /* store the globals back into the shared parameter block */
	charPtr	= (unsigned char _far *)	(paramBlockPtr + M_MOUSE_KEYS_ON);			   *charPtr	= mMouseKeysOn;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + M_ON_OFF_FEEDBACK);		   *charPtr	= mOnOffFeedback;
	intPtr	= (unsigned int  _far *)	(paramBlockPtr + M_MAX_SPEED);			      *intPtr	= mMaxSpeed;
	intPtr	= (unsigned int  _far *)	(paramBlockPtr + M_TIME_TO_MAX_SPEED);			*intPtr	= mTimeToMaxSpeed;
	intPtr	= (unsigned int  _far *)	(paramBlockPtr + M_DIALOG_MOUSE_KEYS_OFF);	*intPtr	= mDialogMouseKeysOff;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + M_MOUSE_KEYS_OVERRIDE);		*charPtr	= mMouseKeysOverride;



      /* Set sDialogToggleKeysOff to TRUE if a ToggleKeys Parameter has changed */
	if (forceDialogFlags) tDialogToggleKeysOff = TRUE;
   else tDialogToggleKeysOff = (unsigned char)
      (*((unsigned char _far *)	(paramBlockPtr + T_TOGGLE_KEYS_ON))         != tToggleKeysOn  ||
       *((unsigned char _far *)	(paramBlockPtr + T_ON_OFF_FEEDBACK))        != tOnOffFeedback);

      /* store the globals back into the shared parameter block */
	charPtr	= (unsigned char _far *)	(paramBlockPtr + T_TOGGLE_KEYS_ON);				*charPtr	= tToggleKeysOn;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + T_ON_OFF_FEEDBACK);			*charPtr	= tOnOffFeedback;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + T_DIALOG_TOGGLE_KEYS_OFF);	*charPtr	= tDialogToggleKeysOff;



      /* Set sDialogTimeoutOff to TRUE if a Timeout Parameter has changed */
	if (forceDialogFlags) toDialogTimeOutOff = TRUE;
   else toDialogTimeOutOff = (unsigned char)
      (*((unsigned char _far *)	(paramBlockPtr + TO_TIME_OUT))        != toTimeOut       ||
	    *((unsigned char _far *)	(paramBlockPtr + TO_ON_OFF_FEEDBACK)) != toOnOffFeedback ||
	    *((unsigned int  _far *)	(paramBlockPtr + TO_VALUE))           != toValue);

      /* store the globals back into the shared parameter block */
	charPtr	= (unsigned char _far *)	(paramBlockPtr + TO_TIME_OUT);				*charPtr	= toTimeOut;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + TO_ON_OFF_FEEDBACK);		*charPtr	= toOnOffFeedback;
	intPtr	= (unsigned int  _far *)	(paramBlockPtr + TO_VALUE);					*intPtr	= toValue;
	charPtr	= (unsigned char _far *)	(paramBlockPtr + TO_DIALOG_TIMEOUT_OFF);	*charPtr	= toDialogTimeOutOff;


   charPtr  = (unsigned char _far *) (paramBlockPtr + SK_SERIAL_KEYS_ON);	*charPtr = skSerialKeysOn;
   charPtr  = (unsigned char _far *) (paramBlockPtr + SK_INTERRUPT);			*charPtr = skInterrupt;
   intPtr   = (unsigned int  _far *) (paramBlockPtr + SK_PORT_ADDRESS);		*intPtr  = skPortAddress;
   intPtr   = (unsigned int  _far *) (paramBlockPtr + SK_BAUD_RATE);			*intPtr  = skBaudRate;


	compDialog = fComputerNotFound;
   charPtr  = (unsigned char _far *) (paramBlockPtr + COMP_DIALOG);				*charPtr = compDialog;
   charPtr  = (unsigned char _far *) (paramBlockPtr + COMP_DIALOG_ID);			*charPtr = compDialogId;
   charPtr  = (unsigned char _far *) (paramBlockPtr + COMP_DIALOG_ACTION);		*charPtr = compDialogAction;
   charPtr  = (unsigned char _far *) (paramBlockPtr + F_SPACE_SAVER);			*charPtr = fSpaceSaver;
   charPtr  = (unsigned char _far *) (paramBlockPtr + F_COMPUTER_NOT_FOUND);	*charPtr = fComputerNotFound;
   charPtr  = (unsigned char _far *) (paramBlockPtr + F_HEARING_ON);				*charPtr = fHearingOn;
   charPtr  = (unsigned char _far *) (paramBlockPtr + F_VIDEO_FLASH);			*charPtr = fVideoFlash;
}	/* end SetAccessParameters() */


void GetEquipmentParameters(void)
{
   skSerialKeysOn             = *((unsigned char _far *) (currentParameters+SK_SERIAL_KEYS_ON));
   eqButton1                  = *((unsigned char _far *) (currentParameters + BUTTON_1));
   eqButton2                  = *((unsigned char _far *) (currentParameters + BUTTON_2));
   eqCurrentButton            = *((unsigned char _far *) (currentParameters + CURRENT_BUTTON));
   eqComputerId               = *((unsigned char _far *) (currentParameters + COMPUTER_ID));
   eqMouseDriver              = *((unsigned char _far *) (currentParameters + MOUSE_DRIVER));
   eqMouseId                  = *((unsigned char _far *) (currentParameters + MOUSE_ID));
   eqCommBase                 = *((unsigned int  _far *) (currentParameters + COMM_BASE));
   eqExtendedSegment          = *((unsigned int  _far *) (currentParameters + EXTENDED_SEGMENT));
   eqVector                   = *((unsigned char _far *) (currentParameters + VECTOR));
   eqInjectKeys               = *((unsigned char _far *) (currentParameters + INJECT_KEYS));
   eqVideoType                = *((unsigned char _far *) (currentParameters + VIDEO_TYPE));
   compDialog                 = *((unsigned char _far *) (currentParameters + COMP_DIALOG));
   compDialogId               = *((unsigned char _far *) (currentParameters + COMP_DIALOG_ID));
   eqComputerFlag             = *((unsigned char _far *) (currentParameters + COMPUTER_FLAG));
   fComputerNotFound          = *((unsigned char _far *) (currentParameters + F_COMPUTER_NOT_FOUND));
}  /* end GetEquipmentParameters() */


void SetEquipmentParameters(void)
{
	unsigned char _far *charPtr;
	unsigned int _far *intPtr;

	charPtr	= (unsigned char _far *)	(currentParameters + BUTTON_1);				   *charPtr = eqButton1;
	charPtr	= (unsigned char _far *)	(currentParameters + BUTTON_2);				   *charPtr = eqButton2;
	charPtr	= (unsigned char _far *)	(currentParameters + CURRENT_BUTTON);		   *charPtr = eqCurrentButton;
	charPtr	= (unsigned char _far *)	(currentParameters + COMPUTER_ID);			   *charPtr = eqComputerId;
	charPtr	= (unsigned char _far *)	(currentParameters + MOUSE_DRIVER);			   *charPtr = eqMouseDriver;
	charPtr	= (unsigned char _far *)	(currentParameters + MOUSE_ID);				   *charPtr = eqMouseId;
	intPtr	= (unsigned int  _far *)	(currentParameters + COMM_BASE);				   *intPtr  = eqCommBase;
	intPtr	= (unsigned int  _far *)	(currentParameters + EXTENDED_SEGMENT);	   *intPtr  = eqExtendedSegment;
	charPtr	= (unsigned char _far *)	(currentParameters + VECTOR);					   *charPtr = eqVector;
	charPtr	= (unsigned char _far *)	(currentParameters + INJECT_KEYS);			   *charPtr = eqInjectKeys;
	charPtr	= (unsigned char _far *)	(currentParameters + VIDEO_TYPE);			   *charPtr = eqVideoType;
   charPtr  = (unsigned char _far *)	(currentParameters + COMP_DIALOG);           *charPtr = compDialog;
   charPtr  = (unsigned char _far *)	(currentParameters + COMP_DIALOG_ID);        *charPtr = compDialogId;
	charPtr	= (unsigned char _far *)	(currentParameters + COMPUTER_FLAG);		   *charPtr = eqComputerFlag;
	charPtr	= (unsigned char _far *)	(currentParameters + F_COMPUTER_NOT_FOUND);	*charPtr = fComputerNotFound;
}	/* end SetEquipmentParameters() */


int LoadParameters(void)
{
   int height = 9, width = 60;
   int fileHandle = open(configurationFilename, O_RDWR | O_BINARY);

   if (fileHandle != -1)
   {
      unsigned bytesRead;

      lseek(fileHandle, 0L, SEEK_SET);
      bytesRead = read(fileHandle, (void *) transferBuffer, DATA_BLOCK_LENGTH);
      close (fileHandle);
   	if (bytesRead == DATA_BLOCK_LENGTH)
      {
         int i;
         unsigned char _far *charPtr = currentParameters;

         for (i=0; i<DATA_BLOCK_LENGTH; i++)
         {
            *charPtr = transferBuffer[i];
            charPtr++;
         }
         GetAccessParameters();
         return TRUE;
      }
   }

   DisplayAlertBox(LoadFailedAlertText, height, width);
   return FALSE;
}  /* end LoadParameters() */


void SaveParameters(void)
{
   unsigned key;
   int scanCode, ascii, notDone = TRUE, helpMessageFlag = FALSE, saveParametersFlag = FALSE;
   int top=11, bottom=15, left=13, right=67, width;
	char *title = "Save AccessDOS Settings";

	width = right-left+1;

	DrawDialogBox(top, left, bottom, right, dialogBoxBorderFG, dialogBoxBorderBG, dialogBoxFG, dialogBoxBG, title);
	charBufferLength = sprintf(charBuffer, "Are you sure you want to save the current settings?");
	_settextposition(2, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

	charBufferLength = sprintf(charBuffer, "Press Enter to proceed");
	_settextposition(4, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

	charBufferLength = sprintf(charBuffer, "Press Escape to return to menu");
	_settextposition(5, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

	OutputHintBar("This will save the current settings to the ADOS.CFG file.", JUSTIFY_LEFT, helpMessageFlag);

   while (notDone)
   {
         /* Get a key and process it */
	   key = _bios_keybrd(keybrdRead);
	   ascii = key & 0x00ff;
	   scanCode = ascii ? 0 : key >> 8;

	   if (ascii)
	   {
         notDone = FALSE;
			switch (ascii)
			{
				case ENTER		:	saveParametersFlag = TRUE;
										break;

				case ESCAPE		:	saveParametersFlag = FALSE;
										break;

				default			:	putchar('\07');
										ClearKeyboardBuffer();
										notDone = TRUE;
										break;
			}
      }
	   else
		{
			putchar('\07');
			ClearKeyboardBuffer();
		}
   }

	if (saveParametersFlag)
	{
   	int height = 5, width = 60;
	   int fileHandle, forceDialogFlags = FALSE;

      	/* move the current values of the local variables into the transfer buffer */
   	SetAccessParameters(transferBuffer, forceDialogFlags);

      	/* Don't let the user save parameters with SlowKeys or BounceKeys On!! */
			/* if SlowKeys of BounceKeys is on, turn off FilterKeys in the Transfer Buffer */
   	if ((fWaitTicks > 0 || fBounceTicks < 32760) && fFilterKeysOn == TRUE) transferBuffer[F_FILTER_KEYS_ON] = FALSE;

      	/* write the current data to the configuration file */
   	fileHandle = open(configurationFilename, O_CREAT | O_TRUNC | O_RDWR | O_BINARY, S_IREAD | S_IWRITE);
   	if (fileHandle != -1)
   	{
      	unsigned bytesWritten = write(fileHandle, (void *) transferBuffer, DATA_BLOCK_LENGTH);
      	close (fileHandle);
			if (bytesWritten == DATA_BLOCK_LENGTH)	DisplayAlertBox(SaveSuccessfulAlertText, height, width);
	   	else
			{
				DisplayAlertBox(SaveFailedAlertText, height, width);
				remove(configurationFilename);
			}
   	}
   	else DisplayAlertBox(SaveFailedAlertText, height, width);
	}
}	/* end SaveParameters() */


void DisplayCurrentParameters(void)
{
   _settextwindow(1, 1, 25, 80);
	_clearscreen(_GCLEARSCREEN);
	_settextposition(2, 1);

   charBufferLength = sprintf(charBuffer, "SerialKeys:\n");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    skSerialKeysOn: %s  skSerialKeysLoaded: %s\n",
						  				skSerialKeysOn ? "True" : "False", skSerialKeysLoaded ? "True" : "False");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
   charBufferLength = sprintf(charBuffer, "    skPortAddress: 0x%04X  skInterrupt: %d  skBaudRate: 0x%04X\n",
										skPortAddress, skInterrupt, skBaudRate);
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);

   charBufferLength = sprintf(charBuffer, "Keyboard Package:\n");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    fDialog: %s  fFilterKeysOn: %s  fOnOffFeedback: %s\n",
						  				fDialogFilterKeysOff ? "True" : "False",
						  				fFilterKeysOn ? "True" : "False",
						  				fOnOffFeedback ? "True" : "False");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    fWaitTicks: %u  fDelayTicks: %u  fRepeatTicks: %u  fBounceTicks: %u\n",
										fWaitTicks, fDelayTicks, fRepeatTicks, fBounceTicks);
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    fMaxDefault: %s  fClickOn: %s  fBounceOn: %s\n",
										fMaxDefault ? "True" : "False",
										fClickOn ? "True" : "False",
										fBounceOn ? "True" : "False");
   if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);

   charBufferLength = sprintf(charBuffer, "StickyKeys:\n");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
   charBufferLength = sprintf(charBuffer, "    sDialog: %s  sStickyKeysOn: %s  sClickOn: %s\n",
										sDialogStickyKeysOff ? "True" : "False",
										sStickyKeysOn ? "True" : "False",
										sClickOn ? "True" : "False");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    sOnOffFeedback: %s  sAudibleFeedback: %s\n",
										sOnOffFeedback ? "True" : "False",
										sAudibleFeedback ? "True" : "False");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    sTriState: %s  sTwoKeysOff: %s\n",
										sTriState ? "True" : "False",
										sTwoKeysOff ? "True" : "False");
   if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);


   charBufferLength = sprintf(charBuffer, "MouseKeys:\n");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    mDialog: %s  mMouseKeysOn: %s  mOnOffFeedback: %s\n",
										mDialogMouseKeysOff ? "True" : "False",
										mMouseKeysOn ? "True" : "False",
										mOnOffFeedback ? "True" : "False");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    mMouseKeysOverride: %s  mMaxSpeed: %u  mTimeToMaxSpeed: %u\n",
										mMouseKeysOverride ? "True" : "False", mMaxSpeed, mTimeToMaxSpeed);
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);


   charBufferLength = sprintf(charBuffer, "ToggleKeys:\n");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    tDialog: %s  tToggleKeysOn: %s  tOnOffFeedback: %s\n",
										tDialogToggleKeysOff ? "True" : "False",
										tToggleKeysOn ? "True" : "False",
										tOnOffFeedback ? "True" : "False");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);


   charBufferLength = sprintf(charBuffer, "TimeOut:\n");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    toDialog: %s  toTimeOut: %s  toOnOffFeedback: %s  toValue: %u\n",
										toDialogTimeOutOff ? "True" : "False",
										toTimeOut ? "True" : "False",
										toOnOffFeedback ? "True" : "False",
                              toValue);
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);


   charBufferLength = sprintf(charBuffer, "Handicap:\n");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    compDialog: %s  compDialogId: %s  compDialogAction: %s\n",
										compDialog ? "True" : "False",
										compDialogId ? "True" : "False",
										compDialogAction ? "True" : "False");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "    fSpaceSaver: %s  fComputerNotFound: %s  fHearingOn: %s\n",
										fSpaceSaver ? "True" : "False",
										fComputerNotFound ? "True" : "False",
										fHearingOn ? "True" : "False");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);
   charBufferLength = sprintf(charBuffer, "    fAccessAlreadyLoaded: %s\n", fAccessAlreadyLoaded ? "True" : "False");
	if (charBufferLength > LINE_LENGTH) exit(FALSE); else _outtext(charBuffer);

	ClearKeyboardBuffer();
   WaitForAnyKey();
	_clearscreen(_GCLEARSCREEN);
}	/* end DisplayCurrentParameters() */


void DisplayEquipmentParameters(void)
{
   _settextposition(16, 1);
   printf("eqButton1: %d, eqButton2: %d, eqCurrentButton: %d\n", eqButton1, eqButton2, eqCurrentButton);
   printf("eqComputerId: %d, eqMouseDriver: %d, eqMouseId: %d\n", eqComputerId, eqMouseDriver, eqMouseId);
   printf("eqCommBase: 0x%04x, eqExtendedSegment: 0x%04x\n", eqCommBase, eqExtendedSegment);
   printf("eqVector: %d, eqInjectKeys: %d, eqVideoType: %d\n", eqVector, eqInjectKeys, eqVideoType);
   printf("compDialig: %d, compDialogId: %d\n", compDialog, compDialogId);
   printf("eqComputerFlag: %d, fComputerNotFound: %d\n", eqComputerFlag, fComputerNotFound);
   printf("\n\nPress any key to continue");
	ClearKeyboardBuffer();
   WaitForAnyKey();
}  /* end DisplayEquipmentParameters() */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\comm.c ===
/*  COMM.C  */

#include "skdefs.h"
#include "gideidef.h"
#include "vars.h"
#include "comm.h"
#include "init.h"


/****************************************************************************/
void processSetComputerId(void)
{
	switch(gCode)
		{
		case TERMCODE:
			switch (skCompId) {
				case 5:
				case 4:
				case 3:
				case 1:
					/* only let them change if int 15 / 4F intercept supported */
					if (vector == 0x15) {
						skCompId = tempSkCompId;
						selectInjectMethod();
						}
					break;
				default:
					skCompId = tempSkCompId;
					selectInjectMethod();
					break;
				}
		default:
			tempSkCompId = gCode;
			break;
		}
}

/****************************************************************************/
void processSingleUser(void)
{
	switch(gCode)
		{
		case TERMCODE:
			singleUserSetup = TRUE;
			break;
		default:
			errDetect();
			break;
		}
}



/****************************************************************************/
void processGen(void)
{
	switch(gCode)
		{
		case TERMCODE:
			break;
		case COMPUTERID:
			tempSkCompId = 0;
			cmdVector = processSetComputerId;
			aliasPtr = nullTable;
			beginOK = FALSE;
			break;
		case SINGLEUSER:
			cmdVector = processSingleUser;
			aliasPtr = nullTable;
			beginOK = FALSE;
			break;
		default:
			break;
		}
	return;
}

/****************************************************************************/
void processComm(void)
{
	return;
}


/****************************************************************************/
/*
	FUNCTION:	processBaudrate()

	PURPOSE:	Processes the baudrate commands.

	COMMENTS:

****************************************************************************/

void processBaudrate(void)
{
	switch(gCode)
		{
		case TERMCODE:
			switch (tempskBaudRate)
				{
				case BAUD300:
 				case BAUD600:
				case BAUD1200:
				case BAUD2400:
				case BAUD4800:
				case BAUD9600:
/*				case BAUD19200:*/
					if (skBaudRate != tempskBaudRate) {
						skBaudRate = tempskBaudRate;
						turnOffHandshake();
						disableComm();
						putPosSBuf = commBuf;
						getPosSBuf = commBuf;
						numCommChars = 0;
						while (!(inp(LSR+skCommPortAddr) & (THRE_FLAG | TSRE_FLAG)));
						setBaudRate();
						doBeep();
						doBeep();
						doBeep();
						clearOutComm();
						turnOnHandshake();
						enableComm();
						}
					break;
				default:
					errDetect();
					break;
				}
			break;
		case BAUD300CODE:
			tempskBaudRate = BAUD300;
			break;
		case BAUD600CODE:
			tempskBaudRate = BAUD600;
			break;
		case BAUD1200CODE:
			tempskBaudRate = BAUD1200;
			break;
		case BAUD2400CODE:
			tempskBaudRate = BAUD2400;
			break;
		case BAUD4800CODE:
			tempskBaudRate = BAUD4800;
			break;
		case BAUD9600CODE:
			tempskBaudRate = BAUD9600;
			break;
/*		case BAUD19200CODE:
			tempskBaudRate = BAUD19200;
			break;
*/
		default:
			errDetect();
			break;
		}
}




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\datablk.h ===
/* start prototypes here */

void GetInterruptNumber(void);
void GetAddressOfParameterBlock(void);
void GetAccessParameters(void);
void SetAccessParameters(unsigned char _far *paramBlockPtr, int forceDialogFlags);
void GetEquipmentParameters(void);
void SetEquipmentParameters(void);
int LoadParameters(void);
void SaveParameters(void);
void DisplayCurrentParameters(void);
void DisplayEquipmentParameters(void);

	/* end prototypes */

#define FILTER_USER_OPTION_OFF	   1
#define FILTER_USER_OPTION_1		   2
#define FILTER_USER_OPTION_2		   3

/*extern void *dataBlock;					/* address of the shared datablock */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\defines.h ===
#include "skDefs.h"

#define	LINE_LENGTH			80

#define	TRUE					 1
#define	FALSE					 0

#define  INSTALL_ACCESS     1
#define  ABORT_ACCESS       2

#define	ABORT					 3
#define	CONTROL_PANEL		 1
#define	AUTOLOAD				 2

#define  DEFAULT_MODE      0
#define  COLOR_MODE        1
#define  MONO_MODE         2
#define  LCD_MODE          3

#define	SELECTABLE_YES		0
#define	SELECTABLE_NO		1
#define	SELECTABLE_NEVER	2
#define	SELECTABLE_TITLE	3

#define  JUSTIFY_LEFT      1
#define  JUSTIFY_CENTER    2
#define  JUSTIFY_RIGHT     3

#define	NO_CHAIN				 0
#define	CHAIN 				 1

#define  TIMEOUT_SECONDS   20


   /* Define Colors Here */
#define BLACK            0
#define BLUE				 1
#define GREEN				 2
#define CYAN				 3
#define RED					 4
#define MAGENTA			 5
#define BROWN				 6
#define WHITE				 7
#define DARK_GRAY			 8
#define LIGHT_BLUE	    9
#define LIGHT_GREEN	   10
#define LIGHT_CYAN	   11
#define LIGHT_RED			12
#define LIGHT_MAGENTA   13
#define YELLOW				14
#define BRIGHT_WHITE    15
#define UNDERLINE       16

   /* Define Keys Here */
#define	UP					  72
#define	DOWN				  80
#define	LEFT				  75
#define	RIGHT				  77
#define  PAGE_UP          73
#define  PAGE_DOWN        81
#define  F1_KEY           59

#define	ESCAPE			  27
#define	ENTER				  13

#define	SCAN_A			  30
#define	SCAN_F			  33
#define	SCAN_H			  35

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dialogs.c ===
#include <graph.h>
#include <stdio.h>
#include <bios.h>
#include <string.h>
#include <ctype.h>

#include "defines.h"
#include "globals.h"
#include "menudata.h"
#include "messages.h"
#include "frontend.h"
#include "access.h"
#include "dialogs.h"

#define	ROUTINE_INSTALL	1
#define	ROUTINE_CANCEL		2


void DisplayNotImplementedMessage(char *messageText)
{
	int helpMessageFlag = FALSE;

	_setbkcolor(dialogBoxBG);
	_settextcolor(dialogBoxFG);
	_settextwindow(3, 1, 24, 80);
	_clearscreen(_GWINDOW);
	charBufferLength = sprintf(charBuffer, "%s", messageText);
	_settextposition(12, 40-charBufferLength/2);
	_outtext(charBuffer);
	charBufferLength = sprintf(charBuffer, "(function not implemented yet)");
	_settextposition(13, 40-charBufferLength/2);
	_outtext(charBuffer);
	OutputHintBar("", JUSTIFY_LEFT, helpMessageFlag);
	charBufferLength = sprintf(charBuffer, "Press any key to continue.");
	_settextposition(1, 40-charBufferLength/2);
	_outtext(charBuffer);

	WaitForAnyKey();
}	/* DisplayNotImplementedMessage() */

void AboutAccess(void)
{
	int top=5, bottom=22, left=3, right=78;
	int height, width, line=2;
	int helpMessageFlag = FALSE, titleFlag = TRUE, autoLoadFlag = FALSE;

	height = bottom-top+1;
	width = right-left+1;

	DrawDialogBox(top, left, bottom, right, dialogBoxBorderFG, dialogBoxBorderBG, dialogBoxFG, dialogBoxBG, "About AccessDOS");
	line = DisplayStartupScreenText(line, width/2+1, titleFlag, autoLoadFlag);
	OutputHintBar("Press any key to continue.", JUSTIFY_CENTER, helpMessageFlag);
	ClearKeyboardBuffer();
	WaitForAnyKey();
}	/* end AboutAccess() */


void QuitAccess(int callingRoutine)
{
   unsigned key;
   int scanCode, ascii, notDone = TRUE, helpMessageFlag = FALSE;
   int top=11, bottom=15, left=15, right=65, width;
	char *title;

	width = right-left+1;

	if (callingRoutine == ROUTINE_INSTALL) title = "Install/Run AccessDOS";
	else title = "Cancel/Quit AccessDOS";

	DrawDialogBox(top, left, bottom, right, dialogBoxBorderFG, dialogBoxBorderBG, dialogBoxFG, dialogBoxBG, title);

	if (callingRoutine == ROUTINE_INSTALL)
		charBufferLength = sprintf(charBuffer, "Are you sure you want to Install/Run AccessDOS?");
	else
		charBufferLength = sprintf(charBuffer, "Are you sure you want to Cancel/Quit AccessDOS?");
	_settextposition(2, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

	charBufferLength = sprintf(charBuffer, "Press Enter to proceed");
	_settextposition(4, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

	charBufferLength = sprintf(charBuffer, "Press Escape to return to menu");
	_settextposition(5, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

	if (callingRoutine == ROUTINE_INSTALL)
		OutputHintBar("This will install AccessDOS or, if already running, change the settings.", JUSTIFY_LEFT, helpMessageFlag);
	else
		OutputHintBar("This will quit AccessDOS or, if already running, cancel any changes.", JUSTIFY_LEFT, helpMessageFlag);

   while (notDone)
   {
         /* Get a key and process it */
	   key = _bios_keybrd(keybrdRead);
	   ascii = key & 0x00ff;
	   scanCode = ascii ? 0 : key >> 8;

	   if (ascii)
	   {
         notDone = FALSE;
			switch (ascii)
			{
				case ENTER		:	switch (callingRoutine)
            						{
               						case ROUTINE_INSTALL : installFlag = TRUE;	break;
               						case ROUTINE_CANCEL	: installFlag = FALSE;	break;
            						}
										quitFlag = TRUE;
										break;

				case ESCAPE		:	installFlag = FALSE;
										quitFlag = FALSE;
										break;

				case 'C'			:
				case 'c'			:
				case 'Q'			:
				case 'q'			:	if (callingRoutine == ROUTINE_CANCEL)
										{
											installFlag = FALSE;
											quitFlag = TRUE;
										}
										break;

				case 'R'			:
				case 'r'			:
				case 'I'			:
				case 'i'			:	if (callingRoutine == ROUTINE_INSTALL)
										{
											installFlag = TRUE;
											quitFlag = TRUE;
										}
										break;

				default			:	putchar('\07');
										ClearKeyboardBuffer();
										notDone = TRUE;
										break;
			}
      }
	   else
		{
			putchar('\07');
			ClearKeyboardBuffer();
		}
   }
}	/* end QuitAccess() */


void InstallAccess(void)
{
	QuitAccess(ROUTINE_INSTALL);
}	/* end InstallAccess() */


void CancelAccess(void)
{
	QuitAccess(ROUTINE_CANCEL);
}	/* end CancelAccess() */


void StickyKeys(void)
{
   ManageDialogBox(stickyKeysDialogList, "StickyKeys", StickyKeysHelp);
}	/* end StickyKeys() */


void MouseKeys(void)
{
	ManageDialogBox(mouseKeysDialogList, "MouseKeys", MouseKeysHelp);
   if (eqMouseId == FALSE && mMouseKeysOn)
   {
      int height = 10, width = 58;
      DisplayAlertBox(NoMouseFoundAlertText, height, width);
      mMouseKeysOn = FALSE;
   }
}	/* end MouseKeys() */


void ToggleKeys(void)
{
	ManageDialogBox(toggleKeysDialogList, "ToggleKeys", ToggleKeysHelp);
}	/* end ToggleKeys() */


void SerialKeys(void)
{
   unsigned int numberOfSerialPorts = (_bios_equiplist() & 0x0e00) >> 9;

	ManageDialogBox(serialKeysDialogList, "SerialKeys", SerialKeysHelp);
   if (skSerialKeysOn)
   {
      if (skSerialKeysLoaded == FALSE && fAccessAlreadyLoaded)
      {
         int height = 11, width = 58;
         DisplayAlertBox(SerialKeysNotLoadedAlertText, height, width);
         skSerialKeysOn = FALSE;
/*
		} else if (numberOfSerialPorts == 0)
		{
			int height = 9, width = 58;
			DisplayAlertBox(NoSerialPortAvailableAlertText, height, width);
			skSerialKeysOn = FALSE;
      } else if (numberOfSerialPorts == 1 && eqCommBase == COM1)
      {
         int height = 13, width = 68;
         DisplayAlertBox(OneSerialPortWithMouseAlertText, height, width);
         skSerialKeysOn = FALSE;
      } else if (numberOfSerialPorts == 1 && skPortAddress == COM2)
      {
         int height = 10, width = 58;
         DisplayAlertBox(NoCommTwoAlertText, height, width);
         skPortAddress = COM1;
      } else if (!fAccessAlreadyLoaded && skPortAddress == eqCommBase)
      {
         int height = 13, width = 58;
         DisplayAlertBox(SerKeysMouseConflictAlertText, height, width);
         switch (eqCommBase)
         {
            case COM1  :  skPortAddress = COM2; break;
            case COM2  :  skPortAddress = COM1; break;
         }
*/
      } else if (skSerialKeysLoaded && skPortAddress != oldPortAddress)
      {
         int height = 11, width = 58;
         DisplayAlertBox(CannotChangeCommPortAlertText, height, width);
         skPortAddress = oldPortAddress;
      }

		if (skPortAddress == serialPort1 || skPortAddress == serialPort3) skInterrupt = 4;
		if (skPortAddress == serialPort2 || skPortAddress == serialPort4) skInterrupt = 3;
   }
}	/* end SerialKeys() */


void KeyboardPackage(void)
{
	int i=0, repeatRateSelectableState;


		/* set the selectable flag for the 'delay until repeat' option */
		/* if the repeat rate is 'Off' then do not allow adjustment of the 'delay until repeat' */
		/* repeat rate is 'Off' when it has the value 32760 */
   if (fRepeatTicks == 32760) repeatRateSelectableState = SELECTABLE_NO;
   else repeatRateSelectableState = SELECTABLE_YES;
   do
   {
      if (keyboardDialogList[i].optionList == repeatDelayOption)
      {
         keyboardDialogList[i].selectable = repeatRateSelectableState;
         break;
      }
   } while (keyboardDialogList[i++].lastRecord == FALSE);

		/* manage the Keyboard Response Group dialog box */
	ManageDialogBox(keyboardDialogList, "Keyboard Response", KeyboardPackageHelp);

		/* validate the responses */
		/* if repeat rate is 'Off' set delay ticks to 32760 */
		/* if repeat rate is not 'Off' and delay ticks has the value 32760, give it the default time of 1 second (18 ticks ) */
   if (fRepeatTicks == 32760)	fDelayTicks = 32760;
   else if (fDelayTicks == 32760) fDelayTicks = 18;

		/* can't have both bounceKeys and slowKeys on at the same time */
   fBounceOn = (char) (fBounceTicks != 32760);
   if (fFilterKeysOn)
   {
      if (fWaitTicks && fBounceOn)
      {
         int height = 4, width = 38;
         DisplayAlertBox(NoSlowWithBounceAlertText, height, width);
         fFilterKeysOn = FALSE;
      }
   }
}	/* end KeyboardPackage() */


void ShowSounds(void)
{
	ManageDialogBox(showSoundsDialogList, "ShowSounds", ShowSoundsHelp);
   if (fHearingOn && fVideoFlash)
   {
      int height = 4, width = 48;
      DisplayAlertBox(NoNoteWithFlashAlertText, height, width);
      fHearingOn = fVideoFlash = FALSE;
   }
}	/* end ShowSounds() */


void TimeOut(void)
{
	ManageDialogBox(timeOutDialogList, "TimeOut", TimeOutHelp);
}	/* end TimeOut() */


void Miscellaneous(void)
{
	ManageDialogBox(miscellaneousDialogList, "Miscellaneous Adjustments", MiscellaneousHelp);
}	/* end Miscellaneous() */




void SaveParametersHelp(void)
{
   ManageHelpDialogBox(helpTextSaveParameters, "Save Settings Help");
}	/* end SaveParametersHelp() */


void InstallAccessHelp(void)
{
   ManageHelpDialogBox(helpTextInstallAccess, "Install Access Help");
}	/* end InstallAccessHelp() */


void CancelAccessHelp(void)
{
   ManageHelpDialogBox(helpTextCancelAccess, "Cancel Access Help");
}	/* end CancelAccessHelp() */


void MenuHelp(void)
{
   ManageHelpDialogBox(helpTextMenu, "Menu Help");
}	/* end MenuHelp() */


void GeneralInfo(void)
{
   ManageHelpDialogBox(helpTextGeneral, "General Information");
}	/* end GeneralInfo() */


void StickyKeysHelp(void)
{
   ManageHelpDialogBox(helpTextSticky, "StickyKeys Help");
}	/* end StickyKeysHelp() */


void MouseKeysHelp(void)
{
   ManageHelpDialogBox(helpTextMouse, "MouseKeys Help");
}	/* end MouseKeysHelp() */


void ToggleKeysHelp(void)
{
   ManageHelpDialogBox(helpTextToggle, "ToggleKeys Help");
}	/* end ToggleKeysHelp() */


void SerialKeysHelp(void)
{
   ManageHelpDialogBox(helpTextSerial, "SerialKeys Help");
}	/* end SerialKeysHelp() */


void KeyboardPackageHelp(void)
{
   ManageHelpDialogBox(helpTextKeyboard, "Keyboard Response Help");
}	/* end KeyboardPackageHelp() */


void ShowSoundsHelp(void)
{
   ManageHelpDialogBox(helpTextShowSounds, "ShowSounds Help");
}	/* end ShowSoundsHelp() */


void TimeOutHelp(void)
{
   ManageHelpDialogBox(helpTextTimeOut, "TimeOut Help");
}	/* end TimeOutHelp() */


void MiscellaneousHelp(void)
{
   ManageHelpDialogBox(helpTextMisc, "Miscellaneous Help");
}	/* end MiscellaneousHelp() */


void DisplayTextInHelpDialogBox(char *dialogText, int height, int width)
{
   int i, line=1, lineWidth=0;
	int bold, quit = FALSE;
   char currentChar;

	currentChar = dialogText[i=0];
   charBuffer[charBufferLength=0] = '\0';
	bold = FALSE;
   _setbkcolor(dialogBoxBG);
	_settextcolor(dialogBoxFG);
	_settextposition(line, 2);

	while (quit == FALSE)
	{
         /* If the current character is a space, gather all spaces and print */
      if (currentChar == ' ')
      {
         while (currentChar == ' ')
         {
            charBuffer[charBufferLength] = currentChar;
            charBuffer[++charBufferLength] = '\0';
            currentChar = dialogText[++i];
         }
         lineWidth += charBufferLength;
         _outtext(charBuffer);
         charBuffer[charBufferLength=0] = '\0';
      }

         /* get the next word */
		while (currentChar != ' ' && currentChar != '\n' && currentChar != '\0' && currentChar != '^')
		{
         charBuffer[charBufferLength] = currentChar;
         charBuffer[++charBufferLength] = '\0';
         currentChar = dialogText[++i];
		}

         /* if the word will fit on the line, print it; else put it on the next line */
         /* don't forget to adjust the lineWidth as necessary */
      if (lineWidth + charBufferLength > width)
      {
         _settextposition(++line, 2);
         lineWidth = 0;
         if (line > height)
         {
            putchar('\07');
            break;
         }
      }
      if (charBufferLength)    /* don't print if there is nothing in the buffer */
      {
         _outtext(charBuffer);
         lineWidth += charBufferLength;
         charBuffer[charBufferLength=0] = '\0';
      }

         /* if currentChar is a newline then start next line */
      if (currentChar == '\n')
      {
         _settextposition(++line, 2);
         lineWidth = 0;
         currentChar = dialogText[++i];
         if (line > height)
         {
            putchar('\07');
            break;
         }
      } else

			/* if the current character is a '^' toggle the bold attribute */
		if (currentChar == '^')
		{
			if (bold)
			{
				bold = FALSE;
				_settextcolor(dialogBoxFG);
			}
			else
			{
				bold = TRUE;
				_settextcolor(dialogBoxArrowFG);
			}
         currentChar = dialogText[++i];
		} else

            /* if the currentChar is a NULL then this is the end of the dialogText and we can quit */
		if (currentChar == '\0') quit = TRUE;
	}
}  /* end DisplayTextInHelpDialogBox() */


void ManageHelpDialogBox(HELP_SCREEN_RECORD *helpScreen, char *title)
{
	unsigned key;
	int ascii, scanCode;
	int top=5, bottom=22, left=3, right=78;
	int width, height, i=0, quit = FALSE, helpMessageFlag = FALSE, legalKey;

	width = right-left+1;
	height = bottom-top+1;

   DrawDialogBox(top, left, bottom, right, dialogBoxBorderFG, dialogBoxBorderBG, dialogBoxFG, dialogBoxBG, title);
	OutputHintBar("Press ESC to exit help   PgDn or Enter = Next Screen   PgUp = Previous Screen", JUSTIFY_LEFT, helpMessageFlag);

	do
	{
		_settextwindow(top, left, bottom, right);
      _setbkcolor(dialogBoxBG);
   	_settextcolor(dialogBoxFG);
		_clearscreen(_GWINDOW);
	   DisplayTextInHelpDialogBox(helpScreen[i].text, height, width-2);
		
      do
      {
		   key = _bios_keybrd(keybrdRead);
		   ascii = key & 0x00ff;
		   scanCode = ascii ? 0 : key >> 8;
         legalKey = TRUE;

		   if (ascii)
		   {
			   switch (ascii)
			   {
				   case ENTER	:	if (helpScreen[i].lastRecord != TRUE) i++;
									   else legalKey = FALSE;
									   break;

				   case ESCAPE	:	quit = TRUE;
									   break;

				   default		:	legalKey = FALSE;
									   break;
			   }
		   }
		   else switch (scanCode)
		   {
			   case PAGE_DOWN	:	if (helpScreen[i].lastRecord != TRUE) i++;
									   else legalKey = FALSE;
									   break;

			   case PAGE_UP	:	if (i) i--;
									   else legalKey = FALSE;
									   break;

			   default			:	legalKey = FALSE;
									   break;
		   }

		   if (legalKey == FALSE)
			{
				putchar('\07');
				ClearKeyboardBuffer();
			}
      } while (legalKey == FALSE);
	}