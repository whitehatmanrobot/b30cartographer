

//---------------------------------------------------------------------
// CIOSTATUS::CIOSTATUS()
//
//---------------------------------------------------------------------
CIOSTATUS::CIOSTATUS()
    {
    m_dwMainThreadId = 0;
    m_hIoCompletionPort = INVALID_HANDLE_VALUE;
    m_lNumThreads = 0;
    m_lNumPendingThreads = 0;
    }

//---------------------------------------------------------------------
// CIOSTATUS::~CIOSTATUS()
//
//---------------------------------------------------------------------
CIOSTATUS::~CIOSTATUS()
    {
    CloseHandle(m_hIoCompletionPort);
    }

//------------------------------------------------------------------------
//  CIOSTATUS::operator new()
//
//------------------------------------------------------------------------
void *CIOSTATUS::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    return pObj;
    }

//------------------------------------------------------------------------
//  CIOSTATUS::operator delete()
//
//------------------------------------------------------------------------
void CIOSTATUS::operator delete( IN void *pObj,
                                 IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);

        #ifdef DBG_MEM
        if (dwStatus)
            {
            DbgPrint("IrXfer: IrTran-P: CIOSTATUS::delete Failed: %d\n",
                     dwStatus );
            }
        #endif
        }
    }

//---------------------------------------------------------------------
// CIOSTATUS::Initialize();
//
//---------------------------------------------------------------------
DWORD CIOSTATUS::Initialize()
    {
    DWORD  dwStatus = NO_ERROR;

    m_dwMainThreadId = GetCurrentThreadId();

    // Create an IO completion port to use in our asynchronous IO.
    m_hIoCompletionPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE,
                                                  0,
                                                  0,
                                                  0 );
    if (!m_hIoCompletionPort)
        {
        dwStatus = GetLastError();
        #ifdef DBG_ERROR
        DbgPrint("CreateIoCompletionPort(): Failed: %d\n",dwStatus);
        #endif
        return dwStatus;
        }

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irtranp\irtranp.cpp ===
//---------------------------------------------------------------------
//  Copyright (C)1998 Microsoft Corporation, All Rights Reserved.
//
//  irtranp.cpp
//
//  This file holds the main entry points for the IrTran-P service.
//  IrTranP() is the entry point that starts the listening, and
//  UninitializeIrTranP() shuts it down (and cleans everything up).
//
//  Author:
//
//    Edward Reus (edwardr)     02-26-98   Initial coding.
//
//---------------------------------------------------------------------

#include "precomp.h"
#include <mbstring.h>
#include "eventlog.h"

#include <irtranpp.h>

#define WSZ_REG_KEY_IRTRANP     L"Control Panel\\Infrared\\IrTranP"
#define WSZ_REG_DISABLE_IRCOMM  L"DisableIrCOMM"

//---------------------------------------------------------------------
// Listen ports array:
//---------------------------------------------------------------------

typedef struct _LISTEN_PORT
    {
    char  *pszService;      // Service to start.
    BOOL   fIsIrCOMM;       // TRUE iff IrCOMM 9-wire mode.
    DWORD  dwListenStatus;  // Status for port.
    } LISTEN_PORT;

static LISTEN_PORT aListenPorts[] =
    {
    // Service Name   IrCOMM  ListenStatus
    {IRTRANP_SERVICE, FALSE,  STATUS_STOPPED },
    {IRCOMM_9WIRE,    TRUE,   STATUS_STOPPED },
//  {IR_TEST_SERVICE, FALSE,  STATUS_STOPPED }, 2nd test listen port.
    {0,               FALSE,  STATUS_STOPPED }
    };

#define  INDEX_IRTRANPV1        0
#define  INDEX_IRCOMM           1

CCONNECTION_MAP  *g_pConnectionMap = 0;
CIOSTATUS        *g_pIoStatus = 0;
HANDLE            g_hShutdownEvent;


IRTRANP_CONTROL   GlobalIrTranpControl={0};

//
// The following globals and functions are defined in ..\irxfer\irxfer.cxx
//
extern "C" HINSTANCE  ghInstance;
extern HKEY       g_hUserKey;
extern BOOL       g_fDisableIrTranPv1;
extern BOOL       g_fDisableIrCOMM;
extern BOOL       g_fExploreOnCompletion;
extern BOOL       g_fSaveAsUPF;
extern wchar_t    g_DefaultPicturesFolder[];
extern wchar_t    g_SpecifiedPicturesFolder[];
extern BOOL       g_fAllowReceives;

extern BOOL  IrTranPFlagChanged( IN const WCHAR *pwszDisabledValueName,
                                 IN       BOOL   NotPresentValue,
                                 IN OUT   BOOL  *pfDisabled );


//---------------------------------------------------------------------
// GetUserKey()
//
//---------------------------------------------------------------------
HKEY GetUserKey()
    {
    return g_hUserKey;
    }

//---------------------------------------------------------------------
// GetModule()
//
//---------------------------------------------------------------------
HINSTANCE GetModule()
    {
    return ghInstance;
    }
//---------------------------------------------------------------------
// CheckSaveAsUPF()
//
// Return TRUE iff pictures need to be saved in .UPF (as opposed to
// .JPEG) format.
//---------------------------------------------------------------------
BOOL CheckSaveAsUPF()
    {
    return g_fSaveAsUPF;
    }

//---------------------------------------------------------------------
// CheckExploreOnCompletion()
//
// Return TRUE iff we want to popup an explorer on the directory
// containing the newly transfered pictures.
//---------------------------------------------------------------------
BOOL CheckExploreOnCompletion()
    {
    return g_fExploreOnCompletion;
    }

//---------------------------------------------------------------------
// GetUserDirectory();
//
// The "main" part of irxfer.dll (in ..\irxfer) maintains the path
// for My Documents\My Pictures for the currently logged in user.
//
// The path is set when the user first logs on.
//---------------------------------------------------------------------
WCHAR*
GetUserDirectory()
{

    WCHAR *pwszPicturesFolder;

    if (g_SpecifiedPicturesFolder[0]) {

        pwszPicturesFolder = g_SpecifiedPicturesFolder;

    } else {

        if (g_DefaultPicturesFolder[0]) {

            pwszPicturesFolder = g_DefaultPicturesFolder;

        } else {

            if ( SUCCEEDED((SHGetFolderPath( NULL,
                                   CSIDL_MYPICTURES | CSIDL_FLAG_CREATE,
                                   NULL,
                                   0,
                                   g_DefaultPicturesFolder)))) {

                pwszPicturesFolder = g_DefaultPicturesFolder;

            } else {

                pwszPicturesFolder = NULL;
            }
        }
    }

    return pwszPicturesFolder;
}

//---------------------------------------------------------------------
// ReceivesAllowed()
//
// Using the IR configuration window (available from the wireless network
// icon in the control panel) you can disable communications with IR
// devices. This function returns the state of IR communications, FALSE
// is disabled, TRUE is enabled.
//---------------------------------------------------------------------
BOOL ReceivesAllowed()
    {
    return g_fAllowReceives;
    }

//---------------------------------------------------------------------
// SetupListenConnection()
//
//---------------------------------------------------------------------
DWORD SetupListenConnection( IN  CHAR  *pszService,
                             IN  BOOL   fIsIrCOMM,
                             IN  HANDLE hIoCompletionPort )
    {
    DWORD        dwStatus = NO_ERROR;
    CIOPACKET   *pIoPacket;
    CCONNECTION *pConnection;
    BOOL         fDisabled = FALSE;

    // See if the connection already exists:

    if (g_pConnectionMap == NULL) {

        return NO_ERROR;
    }

    if (g_pConnectionMap->LookupByServiceName(pszService))
        {
        return NO_ERROR;
        }

    //
    // Makeup and initialize a new connection object:
    //
    pConnection = new CCONNECTION;

    if (!pConnection) {

        return E_OUTOFMEMORY;
    }

    dwStatus = pConnection->InitializeForListen( pszService,
                                                 fIsIrCOMM,
                                                 hIoCompletionPort );
    if (dwStatus)
        {
        #ifdef DBG_ERROR
        DbgPrint("SetupForListen(): InitializeForListen(%s) failed: %d\n",
                 pszService, dwStatus );
        #endif
        delete pConnection;
        return dwStatus;
        }

    pIoPacket = new CIOPACKET;

    if (!pIoPacket) {

        #ifdef DBG_ERROR
        DbgPrint("SetupForListen(): new CIOPACKET failed.\n");
        #endif
        delete pConnection;
        return E_OUTOFMEMORY;
    }

    // Setup the IO packet:
    dwStatus = pIoPacket->Initialize( PACKET_KIND_LISTEN,
                                      pConnection->GetListenSocket(),
                                      INVALID_SOCKET,
                                      hIoCompletionPort );

    if (dwStatus != NO_ERROR) {

        delete pIoPacket;
        delete pConnection;
        return dwStatus;
    }

    // Post the listen packet on the IO completion port:
    dwStatus = pConnection->PostMoreIos(pIoPacket);

    if (dwStatus != NO_ERROR) {

        delete pIoPacket;
        delete pConnection;
        return dwStatus;
    }

    pConnection->SetSocket(pIoPacket->GetSocket());

    if (!g_pConnectionMap->Add(pConnection,pIoPacket->GetListenSocket())) {

        #ifdef DBG_ERROR
        DbgPrint("SetupForListen(): Add(pConnection) ConnectionMap Failed.\n");
        #endif
        delete pIoPacket;
        delete pConnection;
        return 1;
    }

    return dwStatus;
    }

//---------------------------------------------------------------------
// TeardownListenConnection()
//
//---------------------------------------------------------------------
DWORD TeardownListenConnection( IN char *pszService )
    {
    DWORD        dwStatus = NO_ERROR;
    CCONNECTION *pConnection;

    // Look for the connection associated with the service name:
    if (!g_pConnectionMap)
        {
        // nothing to tear down...
        return dwStatus;
        }

    pConnection = g_pConnectionMap->LookupByServiceName(pszService);

    if (pConnection)
        {
        g_pConnectionMap->RemoveConnection(pConnection);
        pConnection->CloseSocket();
        pConnection->CloseListenSocket();
        }

    return dwStatus;
    }


//---------------------------------------------------------------------
// EnableDisableIrCOMM()
//
//---------------------------------------------------------------------
DWORD
EnableDisableIrCOMM(
   IN HANDLE      HandleToIrTranp,
   IN BOOL        fDisable
   )
{
   PIRTRANP_CONTROL    Control=(PIRTRANP_CONTROL)HandleToIrTranp;

   DWORD     dwStatus;
   DWORD     dwEventStatus = 0;
   EVENT_LOG EventLog(WS_EVENT_SOURCE,&dwEventStatus);

   #ifdef DBG_ERROR
   if (dwEventStatus)
       {
       DbgPrint("IrTranP: Open EventLog failed: %d\n",dwEventStatus);
       }
   #endif

   if (Control == NULL) {

       return 0;
   }


   if (g_pIoStatus == NULL) {

       return 0;
   }


   if (fDisable)
       {
       dwStatus = TeardownListenConnection(
                      aListenPorts[INDEX_IRCOMM].pszService);
       #ifdef DBG_REGISTRY
       DbgPrint("IrTranP: TeardownListenConnection(%s): %d\n",
                aListenPorts[INDEX_IRCOMM].pszService,dwStatus);
       #endif

       if ((dwStatus == 0) && (dwEventStatus == 0))
           {
           EventLog.ReportInfo(CAT_IRTRANP,
                               MC_IRTRANP_STOPPED_IRCOMM);
           }
       }
   else
       {
       dwStatus = SetupListenConnection(
                      aListenPorts[INDEX_IRCOMM].pszService,
                      aListenPorts[INDEX_IRCOMM].fIsIrCOMM,
                      g_pIoStatus->GetIoCompletionPort() );
       #ifdef DBG_REGISTRY
       DbgPrint("IrTranP: SetupListenConnection(%s): %d\n",
                aListenPorts[INDEX_IRCOMM].pszService, dwStatus);
       #endif

       if (dwEventStatus == 0)
           {
           if (dwStatus)
               {
               EventLog.ReportError(CAT_IRTRANP,
                                    MC_IRTRANP_IRCOM_FAILED,
                                    dwStatus);
               }
           #ifdef DBG
           else
               {
               EventLog.ReportInfo(CAT_IRTRANP,
                                   MC_IRTRANP_STARTED_IRCOMM);
               }
           #endif
           }
       }

   return dwStatus;
}

//---------------------------------------------------------------------
// EnableDisableIrTranPv1()
//
//---------------------------------------------------------------------
DWORD
EnableDisableIrTranPv1(
   IN HANDLE      HandleToIrTranp,
   IN BOOL        fDisable
   )
{
   PIRTRANP_CONTROL    Control=(PIRTRANP_CONTROL)HandleToIrTranp;
   DWORD  dwStatus;

   if (Control == NULL) {

       return 0;
   }


   if (g_pIoStatus == NULL) {

       return 0;
   }



   if (fDisable)
       {
       dwStatus = TeardownListenConnection(
                      aListenPorts[INDEX_IRTRANPV1].pszService);
       #ifdef DBG_REGISTRY
       DbgPrint("IrTranP: TeardownListenConnection(%s): %d\n",
                aListenPorts[INDEX_IRCOMM].pszService,dwStatus);
       #endif
       }
   else
       {
       dwStatus = SetupListenConnection(
                      aListenPorts[INDEX_IRTRANPV1].pszService,
                      aListenPorts[INDEX_IRTRANPV1].fIsIrCOMM,
                      g_pIoStatus->GetIoCompletionPort() );
       #ifdef DBG_REGISTRY
       DbgPrint("IrTranP: SetupListenConnection(%s): %d\n",
                aListenPorts[INDEX_IRCOMM].pszService, dwStatus);
       #endif
       }

   return dwStatus;
}

//---------------------------------------------------------------------
// IrTranp()
//
// Thread function for the IrTran-P service. pvRpcBinding is the RPC
// connection to the IR user interface and is used to display the
// "transmission in progress" dialog when pictures are being received.
//---------------------------------------------------------------------
DWORD WINAPI IrTranP( IN PVOID Context )
    {
    int     i = 0;
    DWORD   dwStatus;
    DWORD   dwEventStatus;
    CCONNECTION *pConnection;

    PIRTRANP_CONTROL    Control=(PIRTRANP_CONTROL)Context;


    // Initialize Memory Management:
    dwStatus = InitializeMemory();

    if (dwStatus) {

        goto InitFailed;
    }


    // Create/initialize a object to keep track of the threading...
    g_pIoStatus = new CIOSTATUS;
    if (!g_pIoStatus) {

        #ifdef DBG_ERROR
        DbgPrint("new CIOSTATUS failed.\n");
        #endif
        dwStatus=E_OUTOFMEMORY;
        goto InitFailed;
    }


    dwStatus = g_pIoStatus->Initialize();

    if (dwStatus != NO_ERROR) {

        #ifdef DBG_ERROR
        DbgPrint("g_pIoStatus->Initialize(): Failed: %d\n",dwStatus);
        #endif
        goto InitFailed;
    }

    // Need to keep track of the open sockets and the number of
    // pending IOs on each...
    g_pConnectionMap = new CCONNECTION_MAP;
    if (!g_pConnectionMap) {

        dwStatus= E_OUTOFMEMORY;
        goto InitFailed;
    }

    if (!g_pConnectionMap->Initialize()) {

        goto InitFailed;
    }

    //
    //  just irtanpv1
    //
    i=INDEX_IRTRANPV1;
    dwStatus = SetupListenConnection( aListenPorts[i].pszService,
                                      aListenPorts[i].fIsIrCOMM,
                                      g_pIoStatus->GetIoCompletionPort() );

    if (dwStatus) {

        delete g_pConnectionMap;
        g_pConnectionMap = 0;
        return dwStatus;
        goto InitFailed;
    }

    aListenPorts[i].dwListenStatus = STATUS_RUNNING;


    //
    // IrTran-P started, log it to the system log...
    //
    #ifdef DBG
    {
        EVENT_LOG EventLog(WS_EVENT_SOURCE,&dwEventStatus);

        if (dwEventStatus == 0) {

            EventLog.ReportInfo(CAT_IRTRANP,MC_IRTRANP_STARTED);
        }
    }
    #endif

    //
    //  we made it past the initialization stage, signal the thread that started us the
    //  irtranp is now running
    //
    Control->StartupStatus=dwStatus;

    SetEvent(Control->ThreadStartedEvent);


    //
    // Wait on incomming connections and data, then process it.
    //
    dwStatus = ProcessIoPackets(g_pIoStatus);

    // Cleanup and close any open handles:
    while (pConnection=g_pConnectionMap->RemoveNext()) {

        delete pConnection;
    }

    delete g_pConnectionMap;
    g_pConnectionMap = 0;
    delete g_pIoStatus;
    g_pIoStatus = 0;

    UninitializeMemory();

    return 0;


InitFailed:

    if (g_pConnectionMap != NULL) {

        delete g_pConnectionMap;
    }

    if (g_pIoStatus != NULL) {

        delete g_pIoStatus;
    }

    UninitializeMemory();

    Control->StartupStatus=dwStatus;

    SetEvent(Control->ThreadStartedEvent);

    return 0;
}

//---------------------------------------------------------------------
// IrTranPEnableIrCOMMFailed()
//
//---------------------------------------------------------------------
void
IrTranPEnableIrCOMMFailed(
    IN HANDLE      HandleToIrTranp,
    IN DWORD       dwErrorCode
    )
{

   PIRTRANP_CONTROL    Control=(PIRTRANP_CONTROL)HandleToIrTranp;
   DWORD  dwStatus;

   if (Control == NULL) {

       return ;
   }


    // An error occured on enable, make sure the registry value
    // is set to disable (so UI will match the actual state).
    HKEY      hKey = 0;
    HKEY      hUserKey = GetUserKey();
    HINSTANCE hInstance = GetModule();
    DWORD     dwDisposition;

    if (RegCreateKeyExW(hUserKey,
                        WSZ_REG_KEY_IRTRANP,
                        0,              // reserved MBZ
                        0,              // class name
                        REG_OPTION_NON_VOLATILE,
                        KEY_SET_VALUE,
                        0,              // security attributes
                        &hKey,
                        &dwDisposition))
        {
        #ifdef DBG_ERROR
        DbgPrint("IrTranP: RegCreateKeyEx(): '%S' failed %d",
                  WSZ_REG_KEY_IRTRANP, GetLastError());
        #endif
        }

    if (  (hKey) )
               {
        DWORD  dwDisableIrCOMM = TRUE;
        dwStatus = RegSetValueExW(hKey,
                                  WSZ_REG_DISABLE_IRCOMM,
                                  0,
                                  REG_DWORD,
                                  (UCHAR*)&dwDisableIrCOMM,
                                  sizeof(dwDisableIrCOMM) );
        #ifdef DBG_ERROR
        if (dwStatus != ERROR_SUCCESS)
            {
            DbgPrint("IrTranP: Can't set DisableIrCOMM to TRUE in registry. Error: %d\n",dwStatus);
            }
        #endif

        }

    if (hKey)
        {
        RegCloseKey(hKey);
        }

    WCHAR *pwszMessage = NULL;
    WCHAR *pwszCaption = NULL;
    DWORD  dwFlags = ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                     | FORMAT_MESSAGE_IGNORE_INSERTS
                     | FORMAT_MESSAGE_FROM_HMODULE);

    dwStatus = FormatMessageW(dwFlags,
                              hInstance,
                              CAT_IRTRANP,
                              MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
                              (LPTSTR)(&pwszCaption),
                              0,     // Minimum size to allocate.
                              NULL); // va_list args...
    if (dwStatus == 0)
        {
        #ifdef DBG_ERROR
        DbgPrint("IrTranP: FormatMessage() failed: %d\n",GetLastError() );
        #endif
        return;
        }

    //
    // Hack: Make sure the caption doesn't end with newline-formfeed...
    //
    WCHAR  *pwsz = pwszCaption;

    while (*pwsz)
        {
        if (*pwsz < 0x20)   // 0x20 is always a space...
            {
            *pwsz = 0;
            break;
            }
        else
            {
            pwsz++;
            }
        }


    WCHAR   wszErrorCode[20];
    WCHAR  *pwszErrorCode = (WCHAR*)wszErrorCode;

    StringCchPrintfW(wszErrorCode,sizeof(wszErrorCode)/sizeof(wszErrorCode[0]),L"%d",dwErrorCode);

    dwFlags = ( FORMAT_MESSAGE_ALLOCATE_BUFFER
              | FORMAT_MESSAGE_ARGUMENT_ARRAY
              | FORMAT_MESSAGE_FROM_HMODULE);

    dwStatus = FormatMessageW(dwFlags,
                              hInstance,
                              MC_IRTRANP_IRCOM_FAILED,
                              MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
                              (LPTSTR)(&pwszMessage),
                              0,    // Minimum size to allocate.
                              (va_list*)&pwszErrorCode);
    if (dwStatus == 0)
        {
        #ifdef DBG_ERROR
        DbgPrint("IrTranP: FormatMessage() failed: %d\n",GetLastError() );
        #endif

        if (pwszMessage)
            {
            LocalFree(pwszMessage);
            }

        return;
        }

    dwStatus = MessageBoxW( NULL,
                            pwszMessage,
                            pwszCaption,
                            (MB_OK|MB_ICONERROR|MB_SETFOREGROUND|MB_TOPMOST) );

    if (pwszMessage)
        {
        LocalFree(pwszMessage);
        }

    if (pwszCaption)
        {
        LocalFree(pwszCaption);
        }
}



HANDLE
StartIrTranP(
    VOID
    )

{
    DWORD       ThreadId;

    GlobalIrTranpControl.ThreadStartedEvent=CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL
        );

    if (GlobalIrTranpControl.ThreadStartedEvent == NULL) {

        return NULL;
    }

    GlobalIrTranpControl.ThreadHandle=CreateThread( NULL,
                                     0,
                                     IrTranP,
                                     &GlobalIrTranpControl,
                                     0,
                                     &ThreadId
                                     );

    if (GlobalIrTranpControl.ThreadHandle == NULL) {

        CloseHandle(GlobalIrTranpControl.ThreadStartedEvent);
        GlobalIrTranpControl.ThreadStartedEvent=NULL;

        return NULL;
    }

    //
    //  wait for the thread to finish starting up
    //
    WaitForSingleObject(
        GlobalIrTranpControl.ThreadStartedEvent,
        INFINITE
        );


    //
    //  done with the thread startup event in any case
    //
    CloseHandle(GlobalIrTranpControl.ThreadStartedEvent);
    GlobalIrTranpControl.ThreadStartedEvent=NULL;


    if (GlobalIrTranpControl.StartupStatus != ERROR_SUCCESS) {
        //
        //  something went wrong
        //

        CloseHandle(GlobalIrTranpControl.ThreadHandle);
        GlobalIrTranpControl.ThreadHandle=NULL;

        return NULL;
    }



    return &GlobalIrTranpControl;
}


VOID
StopIrTranP(
    HANDLE      HandleToIrTranp
    )

{
    PIRTRANP_CONTROL    Control=(PIRTRANP_CONTROL)HandleToIrTranp;
    HANDLE hIoCP;

    if (HandleToIrTranp == NULL) {

        return;
    }

    hIoCP = g_pIoStatus->GetIoCompletionPort();

    if (hIoCP != INVALID_HANDLE_VALUE) {

        if (!PostQueuedCompletionStatus(hIoCP,0,IOKEY_SHUTDOWN,0)) {
            //
            //  could not post the quit notification, what now?
            //

        } else {

            //
            //  wait for the thread to stop
            //
            WaitForSingleObject(Control->ThreadHandle,INFINITE);

        }
    }

    CloseHandle(Control->ThreadHandle);
    Control->ThreadHandle=NULL;

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irtranp\memory.cpp ===
//--------------------------------------------------------------------
// Copyright (C)1998 Microsoft Corporation, All Rights Reserved.
//
// memory.cpp
//
// Simple memory allocation routines. We use our own private heap
// so we won't (have less chances of) interfering with any other 
// service code.
//
// Author:
//
//   Edward Reus (EdwardR)   03-04-98  Initial coding.
//
//   Edward Reus (EdwardR)   06-08-98  Convert to use private heap.
//
//--------------------------------------------------------------------

#include "precomp.h"

#pragma warning (disable:4200)

typedef struct _PDU_MEMORY
    {
    LIST_ENTRY  Link;
    DWORD       dwPduSize;
    UCHAR       Pdu[];
    } PDU_MEMORY;

#pragma warning (default:4200)

static HANDLE      g_hHeap = 0;   // Can't use INVALID_HANDLE_VALUE.

static LIST_ENTRY  g_FreePduList;
static BOOL        g_fListInitialized = FALSE;

#ifdef DBG_MEM
static LONG        g_lPduCount = 0;
#endif


//--------------------------------------------------------------------
// InitializeMemory()
//
//--------------------------------------------------------------------
DWORD InitializeMemory()
    {
    DWORD   dwStatus = NO_ERROR;
    #define INITIAL_HEAP_PAGES    64

    if (!g_hHeap)
        {
        SYSTEM_INFO  SystemInfo;

        GetSystemInfo(&SystemInfo);

        DWORD  dwFlags = 0;
        DWORD  dwInitialSize = INITIAL_HEAP_PAGES * SystemInfo.dwPageSize;
        DWORD  dwMaxSize = 0;
        g_hHeap = HeapCreate( dwFlags, dwInitialSize, dwMaxSize );
        if (!g_hHeap)
            {
            dwStatus = GetLastError();
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// AllocateMemory()
//
//--------------------------------------------------------------------
void *AllocateMemory( DWORD dwBytes )
    {
    DWORD  dwStatus;
    void  *pvMemory;

    if (!g_hHeap)
        {
        dwStatus = InitializeMemory();
        }

    if ((g_hHeap) && (dwBytes > 0))
        {
        #ifdef DBG_MEM_VALIDATE
        HeapValidate(g_hHeap,0,0);
        #endif

        pvMemory = HeapAlloc(g_hHeap,0,dwBytes);
        }
    else
        {
        pvMemory = 0;
        }

    return pvMemory;
    }


//--------------------------------------------------------------------
// FreeMemory()
//
//--------------------------------------------------------------------
DWORD FreeMemory( void *pvMemory )
    {
    DWORD  dwStatus = NO_ERROR;

    if (g_hHeap)
        {
        #ifdef DBG_MEM_VALIDATE
        HeapValidate(g_hHeap,0,0);
        #endif

        if (pvMemory)
            {
            if (!HeapFree(g_hHeap,0,pvMemory))
                {
                dwStatus = GetLastError();
                }
            }
        }
    else
        {
        #ifdef DBG_MEM
        DbgPrint("IrXfer.dll: IrTran-P: Free memory with NULL g_hHeap.\n");
        #endif
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// UninitializeMemory()
//
//--------------------------------------------------------------------
DWORD UninitializeMemory()
    {
    DWORD  dwStatus = NO_ERROR;

    #ifdef DBG_MEM_VALIDATE
    HeapValidate(g_hHeap,0,0);
    #endif

    if (g_hHeap)
        {
        if (!HeapDestroy(g_hHeap))
            {
            dwStatus = GetLastError();
            }
        }

    g_hHeap = 0;

    return dwStatus;
    }

//--------------------------------------------------------------------
// NewPdu()
//
//--------------------------------------------------------------------
SCEP_HEADER *NewPdu( DWORD dwPduSize )
    {
    SCEP_HEADER  *pPdu;
    PDU_MEMORY   *pPduMemory;
    LIST_ENTRY   *pLink;

    if (!g_fListInitialized)
        {
        InitializeListHead(&g_FreePduList);
        g_fListInitialized = TRUE;
        }

    if (dwPduSize == 0)
        {
        dwPduSize = MAX_PDU_SIZE;
        }

    if (IsListEmpty(&g_FreePduList))
        {
        pPduMemory 
            = (PDU_MEMORY*)AllocateMemory( sizeof(PDU_MEMORY)+dwPduSize );

        if (pPduMemory)
            {
            pPduMemory->Link.Flink = 0;
            pPduMemory->Link.Blink = 0;
            pPduMemory->dwPduSize = dwPduSize;
            }
        }
    else
        {
        pLink = RemoveHeadList(&g_FreePduList);
        pPduMemory = CONTAINING_RECORD(pLink,PDU_MEMORY,Link);
        }

    if (pPduMemory)
        {
        pPdu = (SCEP_HEADER*)(pPduMemory->Pdu);
        }
    else
        {
        pPdu = 0;
        }

    #ifdef DBG_MEM
    if (pPdu)
        {
        InterlockedIncrement(&g_lPduCount);
        }
    DbgPrint("NewPdu(): Count: %d Bytes: %d Addr: 0x%x\n",
             g_lPduCount, dwPduSize, pPdu );
    #endif

    return pPdu;
    }

//--------------------------------------------------------------------
// DeletePdu()
//
//--------------------------------------------------------------------
void DeletePdu( SCEP_HEADER *pPdu )
    {
    PDU_MEMORY  *pPduMemory;

    if (pPdu)
        {
        pPduMemory = CONTAINING_RECORD(pPdu,PDU_MEMORY,Pdu);
        InsertTailList(&g_FreePduList,&pPduMemory->Link);

        #ifdef DBG_MEM
        InterlockedDecrement(&g_lPduCount);
        DbgPrint("DeletePdu(): Count: %d\n",g_lPduCount);
        #endif
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irtranp\precomp.h ===
//---------------------------------------------------------------------
//  Copyright (C)1998 Microsoft Corporation, All Rights Reserved.
//
//  precomp.h
//
//  Author:
//
//    Edward Reus (edwardr)     02-26-98   Initial coding.
//
//---------------------------------------------------------------------

#define  UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <winsock2.h>
#include <mswsock.h>

#ifndef  _WIN32_WINNT
#define  _WIN32_WINNT
#endif

#include <rpc.h>
#include <af_irda.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <strsafe.h>

#if 0
#define DBG_ERROR 1
#define DBG_IO 1
#endif

#include "irtranp.h"
#include "io.h"
#include "scep.h"
#include "conn.h"

typedef struct _IRTRANP_CONTROL {

    HANDLE      ThreadStartedEvent;

    HANDLE      ThreadHandle;

    DWORD       StartupStatus;

} IRTRANP_CONTROL, *PIRTRANP_CONTROL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irtranp\scep.cpp ===
//--------------------------------------------------------------------
//  Copyright (C)1998 Microsoft Corporation, All Rights Reserved.
//
//  scep.cpp
//
//  This file holds most of the implementation of CSCEP_CONNECTION
//  objects. Each active connection to a camera is represented by
//  a separate CSCEP_CONNECTION object. The CSCEP_CONNECTION is then
//  destroyed when the connection (socket) to the camera is closed.
//
//  Author:
//
//    Edward Reus (edwardr)     02-24-98   Initial coding.
//
//--------------------------------------------------------------------

#include "precomp.h"

typedef struct _ATTRIBUTE_TOKEN
    {
      DWORD  dwTokenType;
      UCHAR *pChars;
      DWORD  dwSize;
    } ATTRIBUTE_TOKEN;

#define ATTRIBUTE_NAME_SIZE        2

#define COLON                     ':'
#define ONE                       '1'
#define SPACE                     ' '
#define TAB                       '\t'
#define CR                        0x0d
#define LF                        0x0a

#define ATTRIBUTE_NAME             0
#define ATTRIBUTE_COLON            1
#define ATTRIBUTE_VALUE            2
#define ATTRIBUTE_CRLF             3

#define ATTR_PDU_SIZE              0
#define ATTR_PRODUCT_ID            1
#define ATTR_USER_NAME             2
#define ATTR_PASSWORD              3

//--------------------------------------------------------------------
// Globals:
//--------------------------------------------------------------------

static  DWORD g_adwPduSizes[] 
              = { PDU_SIZE_1, PDU_SIZE_2, PDU_SIZE_3, PDU_SIZE_4 };

#ifdef DBG_MEM
static  LONG g_lCScepConnectionCount = 0;
#endif

//--------------------------------------------------------------------
// SkipBlanks()
//
//--------------------------------------------------------------------
void SkipBlanks( IN OUT UCHAR **ppAttributes,
                 IN OUT DWORD  *pdwAttributeSize )
    {
    while ( (*pdwAttributeSize > 0)
          && ((**ppAttributes == SPACE)||(**ppAttributes == TAB)) )
        {
        (*ppAttributes)++;
        (*pdwAttributeSize)--;
        }
    }

//--------------------------------------------------------------------
// NextToken()
//
//--------------------------------------------------------------------
ATTRIBUTE_TOKEN *NextToken( IN     DWORD   dwTokenType,
                            IN OUT UCHAR **ppAttributes,
                            IN OUT DWORD  *pdwAttributeSize )
    {
    ATTRIBUTE_TOKEN *pToken = 0;

    SkipBlanks(ppAttributes,pdwAttributeSize);

    if ((!*ppAttributes) || (*pdwAttributeSize == 0))
        {
        return 0;
        }

    pToken = (ATTRIBUTE_TOKEN*)AllocateMemory(sizeof(ATTRIBUTE_TOKEN));
    if (!pToken)
        {
        return 0;
        }

    pToken->dwTokenType = dwTokenType;

    switch (dwTokenType)
        {
        case ATTRIBUTE_NAME:
            if (*pdwAttributeSize < ATTRIBUTE_NAME_SIZE)
                {
                FreeMemory(pToken);
                pToken = 0;
                break;
                }

            pToken->pChars = *ppAttributes;
            pToken->dwSize = ATTRIBUTE_NAME_SIZE;
            *ppAttributes += ATTRIBUTE_NAME_SIZE;
            *pdwAttributeSize -= ATTRIBUTE_NAME_SIZE;
            break;

        case ATTRIBUTE_COLON:
            if (**ppAttributes == COLON)
                {
                pToken->pChars = *ppAttributes;
                pToken->dwSize = 1;
                *ppAttributes += 1;
                *pdwAttributeSize -= 1;
                }
            break;

        case ATTRIBUTE_VALUE:
            pToken->pChars = *ppAttributes;
            pToken->dwSize = 0;
            while ((**ppAttributes != CR) && (*pdwAttributeSize > 0))
                {
                (*ppAttributes)++;
                (*pdwAttributeSize)--;
                (pToken->dwSize)++;
                }
            break;

        case ATTRIBUTE_CRLF:
            pToken->pChars = *ppAttributes;
            pToken->dwSize = 2;
            *ppAttributes += 2;
            *pdwAttributeSize -= 2;
            if ((pToken->pChars[0] != CR)||(pToken->pChars[1] != LF))
                {
                FreeMemory(pToken);
                pToken = 0;
                }
            break;

        default:
            FreeMemory(pToken);
            pToken = 0;
            break;
        }

    return pToken;
    }

//--------------------------------------------------------------------
// IsAttributeName()
//
//--------------------------------------------------------------------
BOOL IsAttributeName( ATTRIBUTE_TOKEN *pToken,
                      int        *piAttribute )
    {
    BOOL fIsName = FALSE;

    if ((pToken->pChars[0] == 'f')&&(pToken->pChars[1] == 'r'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_PDU_SIZE;
        }
    else
    if ((pToken->pChars[0] == 'i')&&(pToken->pChars[1] == 'd'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_PRODUCT_ID;
        }
    else
    if ((pToken->pChars[0] == 'n')&&(pToken->pChars[1] == 'm'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_USER_NAME;
        }
    else
    if ((pToken->pChars[0] == 'p')&&(pToken->pChars[1] == 'w'))
        {
        fIsName = TRUE;
        *piAttribute = ATTR_PASSWORD;
        }

    return fIsName;
    }

//--------------------------------------------------------------------
// NewTokenString()
//
//--------------------------------------------------------------------
UCHAR *NewTokenString( IN  ATTRIBUTE_TOKEN *pToken,
                       OUT DWORD           *pdwStatus )
    {
    UCHAR *pszNewStr = (UCHAR*)AllocateMemory(1+pToken->dwSize);

    if (!pszNewStr)
        {
        *pdwStatus = ERROR_IRTRANP_OUT_OF_MEMORY;
        return 0;
        }

    memcpy(pszNewStr,pToken->pChars,pToken->dwSize);
    pszNewStr[pToken->dwSize] = 0;

    return pszNewStr;
    }
                      
//--------------------------------------------------------------------
// CSCEP_CONNECTION::CSCEP_CONNECTION()
//
//--------------------------------------------------------------------
CSCEP_CONNECTION::CSCEP_CONNECTION()
    {
    m_dwConnectionState = STATE_CLOSED;
    m_dwPduSendSize = PDU_SIZE_1;    // default is 512 bytes.
    m_dwPduReceiveSize = PDU_SIZE_4;
    m_CFlag = 0;
    m_pPrimaryMachineId = 0;
    m_pSecondaryMachineId = 0;
    m_DestPid = DEFAULT_PID;
    m_SrcPid = DEFAULT_PID;
    m_pszUserName = 0;
    m_pszPassword = 0;

    m_pAssembleBuffer = 0;
    m_dwAssembleBufferSize = 0;
    m_dwMaxAssembleBufferSize = 0;
    m_fDidByteSwap = FALSE;

    m_Fragmented = FALSE;
    m_DFlag = 0;
    m_dwSequenceNo = 0;
    m_dwRestNo = 0;
    m_dwCommandId = 0;
    m_pCommandHeader = 0;

    m_pszFileName = 0;
    m_pszLongFileName = 0;
    m_pwszFileName = 0;

    m_CreateTime.dwLowDateTime = 0;   // Picture create date/time.
    m_CreateTime.dwHighDateTime = 0;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::~CSCEP_CONNECTION()
//
//--------------------------------------------------------------------
CSCEP_CONNECTION::~CSCEP_CONNECTION()
    {
    if (m_pPrimaryMachineId)
        {
        FreeMemory(m_pPrimaryMachineId);
        }

    if (m_pSecondaryMachineId)
        {
        FreeMemory(m_pSecondaryMachineId);
        }

    if (m_pszUserName)
        {
        FreeMemory(m_pszUserName);
        }

    if (m_pszPassword)
        {
        FreeMemory(m_pszPassword);
        }

    if (m_pAssembleBuffer)
        {
        FreeMemory(m_pAssembleBuffer);
        }

    if (m_pCommandHeader)
        {
        FreeMemory(m_pCommandHeader);
        }

    if (m_pszFileName)
        {
        FreeMemory(m_pszFileName);
        }

    if (m_pszLongFileName)
        {
        FreeMemory(m_pszLongFileName);
        }

    if (m_pwszFileName)
        {
        FreeMemory(m_pwszFileName);
        }
    }

//------------------------------------------------------------------------
//  CSCEP_CONNECTION::operator new()
//
//------------------------------------------------------------------------
void *CSCEP_CONNECTION::operator new( IN size_t Size )
    {
    void *pObj = AllocateMemory(Size);

    #ifdef DBG_MEM
    if (pObj)
        {
        InterlockedIncrement(&g_lCScepConnectionCount);
        }
    #endif

    return pObj;
    }

//------------------------------------------------------------------------
//  CSCEP_CONNECTION::operator delete()
//
//------------------------------------------------------------------------
void CSCEP_CONNECTION::operator delete( IN void *pObj,
                                        IN size_t Size )
    {
    if (pObj)
        {
        DWORD dwStatus = FreeMemory(pObj);

        #ifdef DBG_MEM
        if (dwStatus)
            {
            DbgPrint("IrXfer: IrTran-P: CSCEP_CONNECTION::delete: FreeMemory() Failed: %d\n"dwStatus);
            }

        InterlockedDecrement(&g_lCScepConnectionCount);

        if (g_lCScepConnectionCount < 0)
            {
            DbgPrint("IrXfer: IrTran-P: CSCEP_CONNECTION::delete: Count: %d\n",
                     g_lCScepConnectionCount);
            }
        #endif
        }
    }


//--------------------------------------------------------------------
// CSCEP_CONNECTION::AssemblePdu()
//
// Take in bits of data as its read in. When a complete SCEP PDU has
// been read and assembled return it.
//
//   pInputData      - This is the data that just came in.
//
//   dwInputDataSize - Size in bytes of pInputData.
//
//   ppPdu           - Returns a complete SCEP PDU when this function
//                     returns NO_ERROR, otherwise set to 0.
//
//   pdwPduSize      - Size of the returned PDU.
//
// Return values:
//
//   NO_ERROR         - A new SCEP PDU is complete and ready.
//   ERROR_CONTINUE   - Data read so far is Ok, still waiting for more.
//   ERROR_SCEP_INVALID_PROTOCOL
//   ERROR_IRTRANP_OUT_OF_MEMORY
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::AssemblePdu( IN  void         *pInputData,
                                     IN  DWORD         dwInputDataSize,
                                     OUT SCEP_HEADER **ppPdu,
                                     OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = ERROR_CONTINUE;
    UCHAR *pEnd;

    if (dwInputDataSize > MAX_PDU_SIZE)
        return ERROR_SCEP_INVALID_PROTOCOL;

    *ppPdu = 0;
    *pdwPduSize = 0;

    if (dwInputDataSize > 0)
        {
        if (!m_pAssembleBuffer)
           {
           m_dwMaxAssembleBufferSize = 2*MAX_PDU_SIZE;
           m_pAssembleBuffer 
                   = (UCHAR*)AllocateMemory(m_dwMaxAssembleBufferSize);
           if (!m_pAssembleBuffer)
               {
               return ERROR_IRTRANP_OUT_OF_MEMORY;
               }

            memcpy(m_pAssembleBuffer,pInputData,dwInputDataSize);
            m_dwAssembleBufferSize = dwInputDataSize;
            #ifdef DBG_ASSEMBLE
            DbgPrint("Assemble: Start: %d\n",m_dwAssembleBufferSize);
            #endif
            }
        else
            {
            if (m_dwAssembleBufferSize+dwInputDataSize >= m_dwMaxAssembleBufferSize)
                {
                #ifdef DBG_ERROR
                DbgPrint("CSCEP_CONNECTION::AssemblePdu(): Buffer Overrun!\n");
                #endif
                return ERROR_SCEP_INVALID_PROTOCOL;
                }
            pEnd = &(m_pAssembleBuffer[m_dwAssembleBufferSize]);
            memcpy(pEnd,pInputData,dwInputDataSize);
            m_dwAssembleBufferSize += dwInputDataSize;
            #ifdef DBG_ASSEMBLE
            DbgPrint("Assemble: Add: %d NewSize: %d\n",
                     dwInputDataSize,m_dwAssembleBufferSize);
            #endif
            }
        }

    // Check to see if enough data has come in for a complete PDU.
    dwStatus = CheckPdu(ppPdu,pdwPduSize);

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckPdu()
//
// Run through the "current" PDU and see if its complete. If its
// not yet complete, return ERROR_CONTINUE. If it is complete then
// return NO_ERROR.
//
// Return values:
//
//   NO_ERROR         - The current SCEP PDU is complete and ready.
//   ERROR_CONTINUE   - Data read so far is Ok, still waiting for more.
//   ERROR_SCEP_INVALID_PROTOCOL
//   ERROR_IRTRANP_OUT_OF_MEMORY
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckPdu( OUT SCEP_HEADER **ppPdu,
                                  OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwSize;
    SCEP_NEGOTIATION *pInfNegotiation;

    if (m_dwAssembleBufferSize < 2)
        {
        return ERROR_CONTINUE;
        }

    switch ( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType )
        {
        case MSG_TYPE_CONNECT_REQ:
            dwStatus = CheckConnectPdu(ppPdu,pdwPduSize);
            break;

        case MSG_TYPE_CONNECT_RESP:
            dwStatus = CheckConnectRespPdu(ppPdu,pdwPduSize);
            break;

        case MSG_TYPE_DATA:
            dwStatus = CheckDataPdu(ppPdu,pdwPduSize);
            break;

        case MSG_TYPE_DISCONNECT:
            dwStatus = CheckDisconnectPdu(ppPdu,pdwPduSize);
            break;

        default:
            #ifdef DBG_ERROR
            DbgPrint("CheckPdu(): Invalid Msgtype: %d\n",
                     ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType );
            #endif
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            break;
        }
    
    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckConnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckConnectPdu( OUT SCEP_HEADER **ppPdu,
                                         OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwSize;
    SCEP_VERSION     *pInfVersion;
    SCEP_NEGOTIATION *pInfNegotiation;
    SCEP_EXTEND      *pInfExtend;


    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType 
            == MSG_TYPE_CONNECT_REQ);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_CONNECT)
        {
        return ERROR_CONTINUE;
        }

    if (m_dwAssembleBufferSize > MAX_PDU_SIZE_CONNECT)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pInfVersion = (SCEP_VERSION*)(((SCEP_HEADER*)m_pAssembleBuffer)->Rest);

    pInfNegotiation = (SCEP_NEGOTIATION*)( sizeof(SCEP_VERSION)
                                           + (char*)pInfVersion );

    pInfExtend = (SCEP_EXTEND*)( FIELD_OFFSET(SCEP_NEGOTIATION,InfVersion)
                                 + pInfNegotiation->Length
                                 + (char*)pInfNegotiation );

    // Check to see if we have a complete connect PDU size-wise:
    dwSize = 10 + pInfNegotiation->Length;
    if (m_dwAssembleBufferSize == dwSize)
        {
        // Have a complete PDU.
        dwStatus = NO_ERROR;
        }
    else if (m_dwAssembleBufferSize < dwSize)
        {
        // Need to wait for more data to arrive
        dwStatus = ERROR_CONTINUE;
        }
    else
        {
        // Too much data...
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (dwStatus == NO_ERROR)
        {
        // Check to make sure the contents of the PDU "look" Ok:

        if ( (pInfVersion->InfType != INF_TYPE_VERSION)
           || (pInfVersion->Version != PROTOCOL_VERSION) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }

        if ( (pInfNegotiation->InfType != INF_TYPE_NEGOTIATION)
           || (pInfNegotiation->InfVersion < INF_VERSION) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }

        if ( (pInfExtend->InfType != INF_TYPE_EXTEND)
           || (pInfExtend->Length != (sizeof(pInfExtend->Parameter1)
                                      +sizeof(pInfExtend->Parameter2)))
           || (pInfExtend->Parameter1 != 0)
           || (pInfExtend->Parameter2 != 0) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }

    if (dwStatus == NO_ERROR)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            DbgPrint("CSCEP_CONNECTION::CheckConnectPdu(): Out of memory.\n");
            #endif
            dwStatus = ERROR_IRTRANP_OUT_OF_MEMORY;
            }
        else
            {
            *pdwPduSize = m_dwAssembleBufferSize;
            memcpy(*ppPdu,m_pAssembleBuffer,m_dwAssembleBufferSize);
            m_dwAssembleBufferSize = 0;
            #ifdef DBG_ASSEMBLE
            DbgPrint("Assemble: PDU: %d Reset: %d\n",
                     *pdwPduSize, m_dwAssembleBufferSize );
            #endif
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
//  CSCEP_CONNECTION::CheckConnectRespPdu()                     CLIENT
//
//  A connect response from the IrTran-P server is either a ACK or
//  NACK PDU. If we get here then it's an ACK. We'll make sure the
//  entire PDU is here and that it is formatted correctly. There is
//  a specific message type for ACK PDUs, the NACK is just a special
//  case of MSG_TYPE_DATA and is handled elsewere (CheckDataPdu()).
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                             OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwSize;
    SCEP_HEADER      *pHeader;
    SCEP_NEGOTIATION *pInfNegotiation;


    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType 
            == MSG_TYPE_CONNECT_RESP);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_CONNECT_RESP)
        {
        return ERROR_CONTINUE;
        }

    if (m_dwAssembleBufferSize > MAX_PDU_SIZE_CONNECT_RESP)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pHeader = (SCEP_HEADER*)m_pAssembleBuffer;

    pInfNegotiation = (SCEP_NEGOTIATION*)(pHeader->Rest);

    // Check to see if we have a complete connect PDU size-wise:
    dwSize = sizeof(SCEP_HEADER)
             + FIELD_OFFSET(SCEP_NEGOTIATION,InfVersion)
             + pInfNegotiation->Length;

    if (m_dwAssembleBufferSize == dwSize)
        {
        // Have a complete PDU.
        dwStatus = NO_ERROR;
        }
    else if (m_dwAssembleBufferSize < dwSize)
        {
        // Need to wait for more data to arrive
        dwStatus = ERROR_CONTINUE;
        }
    else
        {
        // Too much data...
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (dwStatus == NO_ERROR)
        {
        // Check to make sure the contents of the PDU "look" Ok:

        if ( (pInfNegotiation->InfType != INF_TYPE_NEGOTIATION)
           || (pInfNegotiation->InfVersion < INF_VERSION) )
            {
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }

    if (dwStatus == NO_ERROR)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            DbgPrint("CSCEP_CONNECTION::CheckConnectRespPdu(): Out of memory.\n");
            #endif
            dwStatus = ERROR_IRTRANP_OUT_OF_MEMORY;
            }
        else
            {
            *pdwPduSize = m_dwAssembleBufferSize;
            memcpy(*ppPdu,m_pAssembleBuffer,m_dwAssembleBufferSize);
            m_dwAssembleBufferSize = 0;
            #ifdef DBG_ASSEMBLE
            DbgPrint("Assemble: PDU: %d Reset: %d\n",
                     *pdwPduSize, m_dwAssembleBufferSize );
            #endif
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckDisconnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckDisconnectPdu( OUT SCEP_HEADER **ppPdu,
                                            OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwSize;
    SCEP_DISCONNECT  *pDisconnect;


    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType 
            == MSG_TYPE_DISCONNECT);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_DISCONNECT)
        {
        return ERROR_CONTINUE;
        }

    pDisconnect = (SCEP_DISCONNECT*)(((SCEP_HEADER*)m_pAssembleBuffer)->Rest);

    // Check to make sure the contents of the PDU "look" Ok:

    if (pDisconnect->InfType != INF_TYPE_REASON)
        {
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (pDisconnect->Length1 != sizeof(USHORT))
        {
        dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
        }

    if (dwStatus == NO_ERROR)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            DbgPrint("CSCEP_CONNECTION::CheckDisonnectPdu(): Out of memory.\n");
            #endif
            dwStatus = ERROR_IRTRANP_OUT_OF_MEMORY;
            }
        else
            {
            *pdwPduSize = sizeof(SCEP_HEADER) + 2 + pDisconnect->Length1;
            memcpy(*ppPdu,m_pAssembleBuffer,*pdwPduSize);
            m_dwAssembleBufferSize -= *pdwPduSize;
            #ifdef DBG_ASSEMBLE
            DbgPrint("Assemble: PDU: %d Reset: %d\n",
                     *pdwPduSize, m_dwAssembleBufferSize );
            #endif
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::CheckDataPdu()
//
// The goal here is to check to see if we have a complete formatted
// PDU, if yes the return NO_ERROR, if the PDU looks ok so far, but
// isn't complete (we need to read more), then return ERROR_CONTINUE.
//
// Also if this is a little-endian machine, byteswap the header
// fields accordingly.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::CheckDataPdu( OUT SCEP_HEADER **ppPdu,
                                      OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwExpectedPduSize;
    UCHAR *pEnd;
    SCEP_REQ_HEADER_SHORT *pReqHeaderShort;
    SCEP_REQ_HEADER_LONG  *pReqHeaderLong;

    ASSERT( ((SCEP_HEADER*)m_pAssembleBuffer)->MsgType == MSG_TYPE_DATA);

    if (m_dwAssembleBufferSize < MIN_PDU_SIZE_DATA)
        {
        return ERROR_CONTINUE;
        }

    // Get the length out of the PDU and see if we have a
    // complete PDU:

    pReqHeaderShort = (SCEP_REQ_HEADER_SHORT*)
                             (((SCEP_HEADER*)m_pAssembleBuffer)->Rest);
    if (pReqHeaderShort->Length1 == USE_LENGTH2)
        {
        // We have a long PDU:

        pReqHeaderLong = (SCEP_REQ_HEADER_LONG*)(pReqHeaderShort);

        #ifdef LITTLE_ENDIAN
        if (!m_fDidByteSwap)
            {
            ByteSwapReqHeaderLong(pReqHeaderLong);
            m_fDidByteSwap = TRUE;
            }
        #endif

        dwExpectedPduSize = sizeof(SCEP_HEADER)
                            + FIELD_OFFSET(SCEP_REQ_HEADER_LONG,InfVersion)
                            + pReqHeaderLong->Length2;
        }
    else
        {
        // We have a short PDU:

        #ifdef LITTLE_ENDIAN
        if (!m_fDidByteSwap)
            {
            ByteSwapReqHeaderShort(pReqHeaderShort);
            m_fDidByteSwap = TRUE;
            }
        #endif

        dwExpectedPduSize = sizeof(SCEP_HEADER)
                            + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT,InfVersion)
                            + pReqHeaderShort->Length1;
        }

    // Ok, see if we have a complete PDU:
    if (m_dwAssembleBufferSize == dwExpectedPduSize)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            DbgPrint("CSCEP_CONNECTION::CheckDataPdu(): Out of memory.\n");
            #endif
            dwStatus = ERROR_IRTRANP_OUT_OF_MEMORY;
            }
        else
            {
            *pdwPduSize = dwExpectedPduSize;
            memcpy(*ppPdu,m_pAssembleBuffer,dwExpectedPduSize);
            m_dwAssembleBufferSize = 0;
            m_fDidByteSwap = FALSE;
            #ifdef DBG_ASSEMBLE
            DbgPrint("Assemble: PDU: %d Reset: %d\n",
                     *pdwPduSize, m_dwAssembleBufferSize );
            #endif
            dwStatus = NO_ERROR;
            }
        }
    else if (m_dwAssembleBufferSize > dwExpectedPduSize)
        {
        *ppPdu = NewPdu();
        if (!*ppPdu)
            {
            #ifdef DBG_ERROR
            DbgPrint("CSCEP_CONNECTION::CheckDataPdu(): Out of memory.\n");
            #endif
            dwStatus = ERROR_IRTRANP_OUT_OF_MEMORY;
            }
        else
            {
            *pdwPduSize = dwExpectedPduSize;
            memcpy(*ppPdu,m_pAssembleBuffer,dwExpectedPduSize);

            pEnd = dwExpectedPduSize + (UCHAR*)m_pAssembleBuffer;
            m_dwAssembleBufferSize -= dwExpectedPduSize;
            m_fDidByteSwap = FALSE;

            //
            //  move the data remaining to the front of the buffer
            //
            memmove(m_pAssembleBuffer,pEnd,m_dwAssembleBufferSize);

            #ifdef DBG_ASSEMBLE
            DbgPrint("Assemble: PDU: %d Reset: %d\n",
                     *pdwPduSize, m_dwAssembleBufferSize );
            #endif
            dwStatus = NO_ERROR;
            }
        }
    else
        {
        dwStatus = ERROR_CONTINUE;
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseConnectPdu()
//
// AssemblePDU() already did basic integrity checking of the PDU
// (via CheckConnectPdu()), so at this point we'll assume everything
// is Ok.
//
// NOTE: The Connect PDU is limited to 256 bytes in total length,
// so it will never be fragmented.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseConnectPdu( IN SCEP_HEADER *pPdu,
                                         IN DWORD        dwInputDataSize )
    {
    DWORD  dwStatus;
    DWORD  dwLength;

    if (dwInputDataSize > MAX_PDU_SIZE_CONNECT)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    SCEP_VERSION     *pInfVersion;
    SCEP_NEGOTIATION *pInfNegotiation;
    SCEP_EXTEND      *pInfExtend;

    pInfVersion = (SCEP_VERSION*)pPdu->Rest;

    pInfNegotiation = (SCEP_NEGOTIATION*)( sizeof(SCEP_VERSION)
                                           + (char*)pInfVersion );

    pInfExtend = (SCEP_EXTEND*)( FIELD_OFFSET(SCEP_NEGOTIATION,InfVersion)
                                 + pInfNegotiation->Length
                                 + (char*)pInfNegotiation );

    // 
    m_CFlag = pInfNegotiation->CFlag;
    
    m_pSecondaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pSecondaryMachineId)
        {
        return ERROR_IRTRANP_OUT_OF_MEMORY;
        }

    memcpy( m_pSecondaryMachineId,
            pInfNegotiation->SecondaryMachineId,
            MACHINE_ID_SIZE );
    
    m_pPrimaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pPrimaryMachineId)
        {
        FreeMemory(m_pSecondaryMachineId);
        return ERROR_IRTRANP_OUT_OF_MEMORY;
        }

    memcpy( m_pPrimaryMachineId,
            pInfNegotiation->PrimaryMachineId,
            MACHINE_ID_SIZE );

    // NOTE: The size of the negotiaion "text" is 18 bytes less than
    // the length in the SCEP_NEGOTIATION record:
    dwLength = pInfNegotiation->Length
             - ( sizeof(pInfNegotiation->InfVersion)
               + sizeof(pInfNegotiation->CFlag)
               + sizeof(pInfNegotiation->SecondaryMachineId)
               + sizeof(pInfNegotiation->PrimaryMachineId));

    dwStatus = ParseNegotiation( pInfNegotiation->Negotiation, dwLength );

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseConnectRespPdu()
//
// AssemblePDU() already did basic integrity checking of the PDU
// (via CheckConnectRespPdu()), so at this point we'll assume 
// everything is Ok.
//
// NOTE: The Connect Response PDU is limited to 255 bytes in total
// length, so it will never be fragmented.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseConnectRespPdu( IN SCEP_HEADER *pPdu,
                                             IN DWORD        dwPduSize )
    {
    DWORD  dwStatus;
    DWORD  dwLength;
    SCEP_NEGOTIATION *pInfNegotiation;


    if (dwPduSize > MAX_PDU_SIZE_CONNECT)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pInfNegotiation = (SCEP_NEGOTIATION*)( sizeof(SCEP_HEADER)
                                           + (char*)pPdu );

    // This is the CFlag sent by the other machine.
    m_CFlag = pInfNegotiation->CFlag;

    m_pSecondaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pSecondaryMachineId)
        {
        return ERROR_IRTRANP_OUT_OF_MEMORY;
        }

    memcpy( m_pSecondaryMachineId,
            pInfNegotiation->SecondaryMachineId,
            MACHINE_ID_SIZE );
    
    m_pPrimaryMachineId = (UCHAR*)AllocateMemory(MACHINE_ID_SIZE);
    if (!m_pPrimaryMachineId)
        {
        FreeMemory(m_pSecondaryMachineId);
        return ERROR_IRTRANP_OUT_OF_MEMORY;
        }

    memcpy( m_pPrimaryMachineId,
            pInfNegotiation->PrimaryMachineId,
            MACHINE_ID_SIZE );

    // NOTE: The size of the negotiaion "text" is 18 bytes less than
    // the length in the SCEP_NEGOTIATION record:
    dwLength = pInfNegotiation->Length
             - ( sizeof(pInfNegotiation->InfVersion)
               + sizeof(pInfNegotiation->CFlag)
               + sizeof(pInfNegotiation->SecondaryMachineId)
               + sizeof(pInfNegotiation->PrimaryMachineId));

    dwStatus = ParseNegotiation( pInfNegotiation->Negotiation, dwLength );

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseNegotiation()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseNegotiation( IN UCHAR *pNegotiation,
                                          IN DWORD  dwNegotiationSize )
    {
    DWORD  dwStatus = NO_ERROR;
    UCHAR *pNext = pNegotiation;
    DWORD  dwSize = dwNegotiationSize;

    if (dwNegotiationSize <= 1)
        {
        return NO_ERROR;
        }

    if (*(pNext++) < NEGOTIATION_VERSION)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    dwSize--;

    while (pNext=ParseAttribute(pNext,
                                &dwSize,
                                &dwStatus))
       {
       if (dwStatus != NO_ERROR)
           {
           break;
           }
       }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseAttribute()
//
// Attributes are of the form:
//  
// Attr      <- AttrName Colon AttrValue CrLf
//
// AttrName  <- Two byte attribute name.
//
// Colon     <- ':'
//
// AttrValue <- Character string (bytes > 0x1f and < 0x8f).
//
// CrLf      <- 0x0d 0x0a
//
//--------------------------------------------------------------------
UCHAR *CSCEP_CONNECTION::ParseAttribute( IN  UCHAR *pAttributes,
                                         IN  DWORD *pdwAttributeSize,
                                         OUT DWORD *pdwStatus )
    {
    int  iAttribute;
    int  iPduSize;
    ATTRIBUTE_TOKEN  *pToken1 = 0;
    ATTRIBUTE_TOKEN  *pToken2 = 0;
    ATTRIBUTE_TOKEN  *pToken3 = 0;
    ATTRIBUTE_TOKEN  *pToken4 = 0;

    *pdwStatus = NO_ERROR;

    if (  (pToken1=NextToken(ATTRIBUTE_NAME,&pAttributes,pdwAttributeSize))
       && (IsAttributeName(pToken1,&iAttribute))
       && (pToken2=NextToken(ATTRIBUTE_COLON,&pAttributes,pdwAttributeSize))
       && (pToken3=NextToken(ATTRIBUTE_VALUE,&pAttributes,pdwAttributeSize))
       && (pToken4=NextToken(ATTRIBUTE_CRLF,&pAttributes,pdwAttributeSize)) )
        {
        if (iAttribute == ATTR_PDU_SIZE)
            {
            iPduSize = pToken3->pChars[0] - ONE;
            if ((pToken3->dwSize == 1)&&(iPduSize >= 1)&&(iPduSize <= 4))
                {
                m_dwPduSendSize = g_adwPduSizes[iPduSize];
                #ifdef DBG_IO
                DbgPrint("ParseAttribute(): PduSendSize: %d\n",m_dwPduSendSize);
                #endif
                }
            }
        else
        if (iAttribute == ATTR_PRODUCT_ID)
            {
            m_pszProductId = NewTokenString(pToken3,pdwStatus);
            if (!m_pszProductId)
                {
                pAttributes = 0;
                #ifdef DBG_IO
                DbgPrint("ParseAttribute(): Product: %s\n",m_pszProductId);
                #endif
                }
            }
        else
        if (iAttribute == ATTR_USER_NAME)
            {
            m_pszUserName = NewTokenString(pToken3,pdwStatus);
            if (!m_pszUserName)
                {
                pAttributes = 0;
                }
            }
        else
        if (iAttribute == ATTR_PASSWORD)
            {
            m_pszPassword = NewTokenString(pToken3,pdwStatus);
            if (!m_pszPassword)
                {
                pAttributes = 0;
                }
            }
        }
    else
        {
        if (*pdwAttributeSize > 0)
            {
            *pdwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        pAttributes = 0;
        }

    if (pToken1) FreeMemory(pToken1);
    if (pToken2) FreeMemory(pToken2);
    if (pToken3) FreeMemory(pToken3);
    if (pToken4) FreeMemory(pToken4);

    return pAttributes;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseDataPdu()
//
// AssemblePDU() already did basic integrity checking of the PDU
// (via CheckConnectPdu()), so at this point we'll assume everything
// is Ok.
//
// NOTE: The Data PDU is limited to m_dwPduReceiveSize bytes in total
// length, if data is longer then you will get the fragmented versions
// of the Data PDU.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseDataPdu( IN  SCEP_HEADER     *pPdu,
                                      IN  DWORD            dwPduSize,
                                      OUT COMMAND_HEADER **ppCommand,
                                      OUT UCHAR          **ppUserData,
                                      OUT DWORD           *pdwUserDataSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwLengthOffset1;
    DWORD  dwLengthOffset3;

    // There are four cases of Data PDUs, single (unfragmented)
    // "short" and "long" PDUs, and fragmented "short" and
    // "long" PDUs:
    SCEP_REQ_HEADER_SHORT *pReqHeaderShort;
    SCEP_REQ_HEADER_LONG  *pReqHeaderLong;
    SCEP_REQ_HEADER_SHORT_FRAG *pReqHeaderShortFrag;
    SCEP_REQ_HEADER_LONG_FRAG  *pReqHeaderLongFrag;

    *ppCommand = 0;

    // Make sure the packet length makes sense...
    if (dwPduSize > m_dwPduReceiveSize)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    pReqHeaderShort = (SCEP_REQ_HEADER_SHORT*)(pPdu->Rest);

    if (pReqHeaderShort->InfType != INF_TYPE_USER_DATA)
        {
        return ERROR_SCEP_INVALID_PROTOCOL;
        }

    //
    // See if we have a short or long PDU:
    //
    if (pReqHeaderShort->Length1 != USE_LENGTH2)
        {
        // This is a short PDU (use Length1).

        m_DFlag = pReqHeaderShort->DFlag;

        if ( (pReqHeaderShort->DFlag == DFLAG_SINGLE_PDU)
           || (pReqHeaderShort->DFlag == DFLAG_CONNECT_REJECT))
            {
            //
            // This is a short unfragmented PDU.
            //

            // Make sure that a command header is present:
            if (pReqHeaderShort->Length1 > 4)
                {
                *ppCommand = (COMMAND_HEADER*)(pReqHeaderShort->CommandHeader);
                m_SrcPid = (*ppCommand)->SrcPid;
                m_DestPid = (*ppCommand)->DestPid;
                m_dwCommandId = (*ppCommand)->CommandId;
                }
            else
                {
                *ppCommand = 0;
                }

            *ppUserData = COMMAND_HEADER_SIZE + pReqHeaderShort->CommandHeader;
            *pdwUserDataSize = pReqHeaderShort->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = FALSE;
            m_dwSequenceNo = 0;
            m_dwRestNo = 0;

            // In this case, there are two different lengths
            // in the PDU that must add up to dwPduSize...
            //
            // Note: Not currently testing Length1 for consistency...
            //
            dwLengthOffset3 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT,CommandHeader);

            if (dwPduSize != dwLengthOffset3+pReqHeaderShort->Length3)
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if (pReqHeaderShort->DFlag == DFLAG_FIRST_FRAGMENT)
            {
            //
            // This is a short fragmented PDU, and is the first 
            // fragment, so it will contain a COMMAND_HEADER.
            //
            // In practice, this should probably never show up...

            pReqHeaderShortFrag = (SCEP_REQ_HEADER_SHORT_FRAG*)pReqHeaderShort;

            // The command header is present only on the first fragment
            // of a multi-fragment PDU:
            if (pReqHeaderShortFrag->SequenceNo == 0)
                {
                *ppCommand 
                    = (COMMAND_HEADER*)(pReqHeaderShortFrag->CommandHeader);

                m_SrcPid = (*ppCommand)->SrcPid;
                m_DestPid = (*ppCommand)->DestPid;
                m_dwCommandId = (*ppCommand)->CommandId;
                }
            else
                {
                *ppCommand = 0;
                }

            *ppUserData 
                = COMMAND_HEADER_SIZE + pReqHeaderShortFrag->CommandHeader;
            *pdwUserDataSize 
                = pReqHeaderShortFrag->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderShortFrag->SequenceNo;
            m_dwRestNo = pReqHeaderShortFrag->RestNo;

            // Check the two length fields for consistency:
            dwLengthOffset1 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,InfVersion);
            dwLengthOffset3 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,SequenceNo);

            if ( (dwPduSize != dwLengthOffset1+pReqHeaderShortFrag->Length1)
               || (dwPduSize != dwLengthOffset3+pReqHeaderShortFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if (  (pReqHeaderShort->DFlag == DFLAG_FRAGMENT)
                || (pReqHeaderShort->DFlag == DFLAG_LAST_FRAGMENT))
            {
            //
            // This is a short fragmented PDU.
            //
            // The 2nd through last fragmented PDUs don't contain a
            // COMMAND_HEADER, just data after Length3.
            pReqHeaderShortFrag = (SCEP_REQ_HEADER_SHORT_FRAG*)pReqHeaderShort;

            // The command header is present only on the first fragment
            // of a multi-fragment PDU:
            if (pReqHeaderShortFrag->SequenceNo == 0)
                {
                *ppCommand 
                    = (COMMAND_HEADER*)(pReqHeaderShortFrag->CommandHeader);

                m_SrcPid = (*ppCommand)->SrcPid;
                m_DestPid = (*ppCommand)->DestPid;
                m_dwCommandId = (*ppCommand)->CommandId;
                }
            else
                {
                *ppCommand = 0;
                }

            *ppUserData = pReqHeaderShortFrag->CommandHeader;
            *pdwUserDataSize = pReqHeaderShortFrag->Length3;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderShortFrag->SequenceNo;
            m_dwRestNo = pReqHeaderShortFrag->RestNo;

            // Check the two length fields for consistency:
            dwLengthOffset1 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,InfVersion);
            dwLengthOffset3 = sizeof(SCEP_HEADER)
                        + FIELD_OFFSET(SCEP_REQ_HEADER_SHORT_FRAG,SequenceNo);

            if ( (dwPduSize != dwLengthOffset1+pReqHeaderShortFrag->Length1)
               || (dwPduSize != dwLengthOffset3+pReqHeaderShortFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else
            {
            // Undefined DFlag, we've got a problem...
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }
    else
        {
        // We have a long PDU.

        pReqHeaderLong = (SCEP_REQ_HEADER_LONG*)pReqHeaderShort;

        m_DFlag = pReqHeaderLong->DFlag;

        if ( (pReqHeaderLong->DFlag == DFLAG_SINGLE_PDU)
           || (pReqHeaderLong->DFlag == DFLAG_CONNECT_REJECT))
            {
            //
            // This is a long unfragmented PDU.
            //
            *ppCommand = (COMMAND_HEADER*)(pReqHeaderLong->CommandHeader);
            *ppUserData = COMMAND_HEADER_SIZE + pReqHeaderLong->CommandHeader;
            *pdwUserDataSize = pReqHeaderLong->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = FALSE;
            m_dwSequenceNo = 0;
            m_dwRestNo = 0;
            m_SrcPid = (*ppCommand)->SrcPid;
            m_DestPid = (*ppCommand)->DestPid;
            m_dwCommandId = (*ppCommand)->CommandId;

            // In this case, there are two different lengths
            // in the PDU that must add up to dwPduSize...
            if ( (dwPduSize != 6UL+pReqHeaderLong->Length2)
               || (dwPduSize != 10UL+pReqHeaderLong->Length3))
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if (pReqHeaderLong->DFlag == DFLAG_FIRST_FRAGMENT)
            {
            //
            // This is the first fragment of a long fragmented PDU.
            //
            pReqHeaderLongFrag = (SCEP_REQ_HEADER_LONG_FRAG*)pReqHeaderLong;

            m_pCommandHeader = (COMMAND_HEADER*)AllocateMemory(sizeof(COMMAND_HEADER));
            if (!m_pCommandHeader)
                {
                dwStatus = ERROR_IRTRANP_OUT_OF_MEMORY;
                }
            else
                {
                memcpy(m_pCommandHeader,
                       pReqHeaderLongFrag->CommandHeader,
                       COMMAND_HEADER_SIZE );

                *ppCommand = m_pCommandHeader;
                }

            *ppUserData = COMMAND_HEADER_SIZE + pReqHeaderLongFrag->CommandHeader;
            *pdwUserDataSize = pReqHeaderLongFrag->Length3 - COMMAND_HEADER_SIZE;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderLongFrag->SequenceNo;
            m_dwRestNo = pReqHeaderLongFrag->RestNo;
            if (*ppCommand)
                {
                m_dwCommandId = (*ppCommand)->CommandId;
                }
            else
                {
                m_dwCommandId = 0;
                }

            // Check the two length fields for consistency:
            if ( (dwPduSize != (DWORD)6+pReqHeaderLongFrag->Length2)
               || (dwPduSize != (DWORD)18+pReqHeaderLongFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else if ( (pReqHeaderLong->DFlag == DFLAG_FRAGMENT)
                  || (pReqHeaderLong->DFlag == DFLAG_LAST_FRAGMENT) )
            {
            //
            // This is the second through last fragment of a long 
            // fragmented PDU.
            //
            // In this case the PDU doesn't contain a command
            // header, just more user data...
            //
            pReqHeaderLongFrag = (SCEP_REQ_HEADER_LONG_FRAG*)pReqHeaderLong;

            *ppCommand = m_pCommandHeader;
            *ppUserData = (UCHAR*)(pReqHeaderLongFrag->CommandHeader);
            *pdwUserDataSize = pReqHeaderLongFrag->Length3;

            m_Fragmented = TRUE;
            m_dwSequenceNo = pReqHeaderLongFrag->SequenceNo;
            m_dwRestNo = pReqHeaderLongFrag->RestNo;
            m_dwCommandId = (*ppCommand)->CommandId;

            // Check the two length fields for consistency:
            if ( (dwPduSize != (DWORD)6+pReqHeaderLongFrag->Length2)
               || (dwPduSize != (DWORD)18+pReqHeaderLongFrag->Length3) )
                {
                dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
                }
            }
        else
            {
            // Undefined DFlag, we've got a problem...
            dwStatus = ERROR_SCEP_INVALID_PROTOCOL;
            }
        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParseDisconnectPdu()
//
// NOTE: In practice, reason codes should always be 2 bytes for
//       SCEP version 1.0.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParseDisconnectPdu( IN  SCEP_HEADER *pPdu,
                                            IN  DWORD        dwPduSize )
    {
    DWORD  dwStatus;

    SCEP_DISCONNECT *pDisconnect = (SCEP_DISCONNECT*)(pPdu->Rest);

    if ( (pDisconnect->InfType != INF_TYPE_REASON)
       || (pDisconnect->Length1 != sizeof(USHORT))
       || (pDisconnect->ReasonCode == 0) )
        {
        dwStatus = ERROR_SCEP_UNSPECIFIED_DISCONNECT;
        }
    else if (pDisconnect->ReasonCode == 1)
        {
        dwStatus = ERROR_SCEP_USER_DISCONNECT;
        }
    else if (pDisconnect->ReasonCode == 2)
        {
        dwStatus = ERROR_SCEP_PROVIDER_DISCONNECT;
        }
    else
        {
        dwStatus = ERROR_SCEP_UNSPECIFIED_DISCONNECT;
        }
    
    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::ParsePdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::ParsePdu( IN  SCEP_HEADER *pPdu,
                                  IN  DWORD        dwPduSize,
                                  OUT COMMAND_HEADER **ppCommandHeader,
                                  OUT UCHAR          **ppUserData,
                                  OUT DWORD           *pdwUserDataSize )
    {
    DWORD  dwStatus = NO_ERROR;

    *ppCommandHeader = 0;
    *ppUserData = 0;
    *pdwUserDataSize = 0;

    switch (pPdu->MsgType)
        {
        case MSG_TYPE_CONNECT_REQ:
            dwStatus = ParseConnectPdu( pPdu, dwPduSize );
            break;

        case MSG_TYPE_CONNECT_RESP:
            dwStatus = ParseConnectRespPdu( pPdu, dwPduSize );
            break;

        case MSG_TYPE_DATA:
            dwStatus = ParseDataPdu( pPdu, 
                                     dwPduSize, 
                                     ppCommandHeader, 
                                     ppUserData,
                                     pdwUserDataSize );
            break;

        case MSG_TYPE_DISCONNECT:
            dwStatus = ParseDisconnectPdu( pPdu, dwPduSize );
            break;

        }

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildConnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildConnectPdu( OUT SCEP_HEADER **ppPdu,
                                         OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    SCEP_VERSION      *pVersion;
    SCEP_NEGOTIATION  *pNegotiation;
    SCEP_EXTEND       *pExtend;

    *ppPdu = 0;
    *pdwPduSize = 0;

    // Note that the PDU size doesn't include a trailing zero, as you 
    // would think by lookin at "sizeof(CONNECT_PDU_ATTRIBUTES)" below.
    // The extra byte is for the first byte of the Negotiation string
    // (which is the Negotiation version), so the eqn below is +1-1...
    dwPduSize = sizeof(SCEP_HEADER)
                + sizeof(SCEP_VERSION)
                + sizeof(SCEP_NEGOTIATION)
                + sizeof(CONNECT_PDU_ATTRIBUTES)
                + sizeof(SCEP_EXTEND);

    pHeader = NewPdu();  // Defaulting dwPduSize to MAX_PDU_SIZE
    if (!pHeader)
        {
        return ERROR_IRTRANP_OUT_OF_MEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);  // MAX_PDU_SIZE since dwPduSize is defauled above.

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_CONNECT_REQ;

    pVersion = (SCEP_VERSION*)(pHeader->Rest);
    pVersion->InfType = INF_TYPE_VERSION;
    pVersion->Version = PROTOCOL_VERSION;

    pNegotiation = (SCEP_NEGOTIATION*)((char*)pVersion + sizeof(SCEP_VERSION));
    pNegotiation->InfType = INF_TYPE_NEGOTIATION;
    pNegotiation->Length = 18 + sizeof(CONNECT_PDU_ATTRIBUTES);
    pNegotiation->InfVersion = INF_VERSION;
    pNegotiation->CFlag = CFLAG_ISSUE_OR_EXECUTE;
    // pNegotiation->SecondaryMachineId -- Leave set to zeros...
    // pNegotiation->PrimaryMachineId   -- Leave set to zeros...

    pNegotiation->Negotiation[0] = NEGOTIATION_VERSION;
    memcpy( &(pNegotiation->Negotiation[1]),
            CONNECT_PDU_ATTRIBUTES,
            sizeof(CONNECT_PDU_ATTRIBUTES)-1 );  // No Trailing zero...

    pExtend = (SCEP_EXTEND*)( (char*)pHeader + dwPduSize - sizeof(SCEP_EXTEND));
    pExtend->InfType = INF_TYPE_EXTEND;
    pExtend->Length = 2;
    pExtend->Parameter1 = 0;
    pExtend->Parameter2 = 0;

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildConnectRespPdu()
//
// This is the response PDU for a connection request from a camera.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                             OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    SCEP_NEGOTIATION  *pNegotiation;

    *ppPdu = 0;
    *pdwPduSize = 0;

    // Note that the PDU size doesn't include a trailing zero, as you 
    // would think by lookin at "sizeof(RESPONSE_PDU_ATTRIBUTES)" below,
    // the extra byte in for the first byte of the Negotiation string
    // which is the Negotiation version, so the eqn below is +1-1...
    dwPduSize = sizeof(SCEP_HEADER)
                + sizeof(SCEP_NEGOTIATION)
                + sizeof(RESPONSE_PDU_ATTRIBUTES);

    pHeader = NewPdu();
    if (!pHeader)
        {
        return ERROR_IRTRANP_OUT_OF_MEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);  // MAX_PDU_SIZE is default arg in NewPdu().

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_CONNECT_RESP;
    
    pNegotiation = (SCEP_NEGOTIATION*)(pHeader->Rest);
    pNegotiation->InfType = INF_TYPE_NEGOTIATION;
    pNegotiation->Length = 18 + sizeof(RESPONSE_PDU_ATTRIBUTES);
    pNegotiation->InfVersion = INF_VERSION;
    pNegotiation->CFlag = CFLAG_ISSUE_OR_EXECUTE;

    memcpy( pNegotiation->SecondaryMachineId,
            m_pPrimaryMachineId,
            MACHINE_ID_SIZE );

    memcpy( pNegotiation->PrimaryMachineId,
            m_pSecondaryMachineId,
            MACHINE_ID_SIZE );

    pNegotiation->Negotiation[0] = NEGOTIATION_VERSION;
    memcpy( &(pNegotiation->Negotiation[1]),
            RESPONSE_PDU_ATTRIBUTES,
            sizeof(RESPONSE_PDU_ATTRIBUTES)-1 );  // No Trailing zero...

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildConnectNackPdu()
//
// This is the response PDU for a connection request from a camera
// when we want to reject the connection request.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildConnectNackPdu( OUT SCEP_HEADER **ppPdu,
                                             OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER           *pHeader;
    SCEP_REQ_HEADER_SHORT *pReqHeader;

    *ppPdu = 0;
    *pdwPduSize = 0;

    // A short PDU, there is now command header, so Length3 is zero...
    dwPduSize = sizeof(SCEP_HEADER)
                + sizeof(SCEP_REQ_HEADER_SHORT)
                - sizeof(COMMAND_HEADER);

    pHeader = NewPdu();
    if (!pHeader)
        {
        return ERROR_IRTRANP_OUT_OF_MEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_CONNECT_REQ;

    pReqHeader = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pReqHeader->InfType = INF_TYPE_USER_DATA;
    pReqHeader->Length1 = sizeof(pReqHeader->InfVersion)
                        + sizeof(pReqHeader->DFlag)
                        + sizeof(pReqHeader->Length3);
    pReqHeader->InfVersion = INF_VERSION;
    pReqHeader->DFlag = DFLAG_CONNECT_REJECT;
    pReqHeader->Length3 = 0;

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildAbortPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildAbortPdu( OUT SCEP_HEADER **ppPdu,
                                       OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    COMMAND_HEADER    *pCommandHeader;
    SCEP_REQ_HEADER_SHORT *pReqHeader;

    *ppPdu = 0;
    *pdwPduSize = 0;

    dwPduSize = sizeof(SCEP_HEADER) + sizeof(SCEP_REQ_HEADER_SHORT);

    pHeader = NewPdu();
    if (!pHeader)
        {
        return ERROR_IRTRANP_OUT_OF_MEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);  // MAX_PDU_SIZE is default arg for NewPdu().

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pReqHeader = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pReqHeader->InfType = INF_TYPE_USER_DATA;
    pReqHeader->Length1 = 4 + sizeof(COMMAND_HEADER);
    pReqHeader->InfVersion = INF_VERSION;
    pReqHeader->DFlag = DFLAG_SINGLE_PDU;
    pReqHeader->Length3 = sizeof(COMMAND_HEADER);

    #ifdef LITTLE_ENDIAN
    pReqHeader->Length3 = ByteSwapShort(pReqHeader->Length3);
    #endif

    pCommandHeader = (COMMAND_HEADER*)(pReqHeader->CommandHeader);
    pCommandHeader->Marker58h = 0x58;
    pCommandHeader->PduType = PDU_TYPE_ABORT;
    pCommandHeader->Length4 = 22;
    pCommandHeader->DestPid = m_SrcPid;
    pCommandHeader->SrcPid = m_DestPid;
    pCommandHeader->CommandId = (USHORT)m_dwCommandId;

    #ifdef LITTLE_ENDIAN
    ByteSwapCommandHeader(pCommandHeader);
    #endif

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildStopPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildStopPdu( OUT SCEP_HEADER **ppPdu,
                                      OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER       *pHeader;
    SCEP_REQ_HEADER_SHORT *pReqHeader;

    *ppPdu = 0;
    *pdwPduSize = 0;

    dwPduSize = sizeof(SCEP_HEADER) 
                + sizeof(SCEP_REQ_HEADER_SHORT)
                - sizeof(COMMAND_HEADER);

    pHeader = NewPdu();
    if (!pHeader)
        {
        return ERROR_IRTRANP_OUT_OF_MEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);  // MAX_PDU_SIZE is default arg for NewPdu() above.

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DATA;

    pReqHeader = (SCEP_REQ_HEADER_SHORT*)(pHeader->Rest);
    pReqHeader->InfType = INF_TYPE_USER_DATA;
    pReqHeader->Length1 = 4;
    pReqHeader->InfVersion = INF_VERSION;
    pReqHeader->DFlag = DFLAG_INTERRUPT;
    pReqHeader->Length3 = 0;

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::BuildDisconnectPdu()
//
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::BuildDisconnectPdu( IN  USHORT        ReasonCode,
                                            OUT SCEP_HEADER **ppPdu,
                                            OUT DWORD        *pdwPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwPduSize;
    SCEP_HEADER     *pHeader;
    SCEP_DISCONNECT *pDisconnect;

    *ppPdu = 0;
    *pdwPduSize = 0;

    dwPduSize = sizeof(SCEP_HEADER) 
                + sizeof(SCEP_DISCONNECT);

    pHeader = NewPdu();
    if (!pHeader)
        {
        return ERROR_IRTRANP_OUT_OF_MEMORY;
        }

    memset(pHeader,0,MAX_PDU_SIZE);  // MAX_PDU_SIZE is default arg for NewPdu() above.

    pHeader->Null = 0;
    pHeader->MsgType = MSG_TYPE_DISCONNECT;

    pDisconnect = (SCEP_DISCONNECT*)(pHeader->Rest);
    pDisconnect->InfType = INF_TYPE_REASON;
    pDisconnect->Length1 = sizeof(pDisconnect->ReasonCode);
    pDisconnect->ReasonCode = ReasonCode;

    #ifdef LITTLE_ENDIAN
    pDisconnect->ReasonCode = ByteSwapShort(pDisconnect->ReasonCode);
    #endif

    *ppPdu = pHeader;
    *pdwPduSize = dwPduSize;

    return dwStatus;
    }

//--------------------------------------------------------------------
// CSCEP_CONNECTION::SetScepLength()
//
// Update the length fields in a PDU to reflect the total length
// of a PDU.
//
// WARNING: Currently only supports long fragmented PDUs.
//--------------------------------------------------------------------
DWORD CSCEP_CONNECTION::SetScepLength( IN SCEP_HEADER *pPdu,
                                       IN DWORD        dwTotalPduSize )
    {
    DWORD  dwStatus = NO_ERROR;
    SCEP_REQ_HEADER_LONG_FRAG *pScepHeader;

    if (dwTotalPduSize > MAX_PDU_SIZE)
        {
        dwStatus = ERROR_SCEP_PDU_TOO_LARGE;
        }
    else
        {
        pScepHeader = (SCEP_REQ_HEADER_LONG_FRAG *)(pPdu->Rest);
        pScepHeader->Length1 = USE_LENGTH2;
        pScepHeader->Length2 = (USHORT)dwTotalPduSize - 6;
        pScepHeader->Length3 = (USHORT)dwTotalPduSize - 18;

        #ifdef LITTLE_ENDIAN
        pScepHeader->Length2 = ByteSwapShort(pScepHeader->Length2);
        pScepHeader->Length3 = ByteSwapShort(pScepHeader->Length3);
        #endif
        }

    return dwStatus;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irtranp\scep.h ===
//--------------------------------------------------------------------
// Copyright (C)1998 Microsoft Corporation, All Rights Reserved.
//
// scep.h
//
// Constants and Types for the Simple Command Execution Protocol
// (SCEP). This is the transport protocol for IrTran-P V1.0.
//
// NOTE: That IrTran-P is a big-endian protocol when on the net.
//
// NOTE: That the protocol data structures below assume that the
//       compiler generates structures with natural alignment by
//       field type.
//
// Author:
//
//   Edward Reus (edwardr)     02-05-98   Initial coding.
//
//--------------------------------------------------------------------


#ifndef _SCEP_H_
#define _SCEP_H_

#ifndef _BFTP_H_
#include "bftp.h"
#endif

//--------------------------------------------------------------------
//  Constants:
//--------------------------------------------------------------------

#define  LITTLE_ENDIAN

#define  PROTOCOL_VERSION             0x01
#define  NEGOTIATION_VERSION          0x11   // SCEP_NEGOTIATION revision.
#define  INF_VERSION                  0x10   // Information Struct version.

#define  USE_LENGTH2                  0xff

// These PDU sizes are the default and negotiated sizes:
#define  PDU_SIZE_1                    512
#define  PDU_SIZE_2                   1024
#define  PDU_SIZE_3                   2048
#define  PDU_SIZE_4                   4096
#define  MAX_PDU_SIZE           PDU_SIZE_4

#define  DEFAULT_PDU_SIZE     MAX_PDU_SIZE

// These sizes are used to check if we have a complete PDU:
#define  MIN_PDU_SIZE_CONNECT           28
#define  MAX_PDU_SIZE_CONNECT          256
#define  MIN_PDU_SIZE_CONNECT_RESP      24
#define  MAX_PDU_SIZE_CONNECT_RESP     255

#define  MIN_PDU_SIZE_DATA               8

#define  MIN_PDU_SIZE_DISCONNECT         6

// These are the sizes of the SCEP headers:
#define  SCEP_HEADER_SIZE                2
#define  SCEP_REQ_HEADER_SHORT_SIZE     34
#define  COMMAND_HEADER_SIZE            28

#define  FILE_NAME_SIZE                 12  // 8.3

// These are the attribute strings that go in the negotiation part
// of connect request and response PDUs:
#define  CONNECT_PDU_ATTRIBUTES  "fr:3\r\nid:Microsoft IrTran-P v1.0\r\n"
#define  RESPONSE_PDU_ATTRIBUTES "fr:4\r\nid:Microsoft IrTran-P v1.0\r\n"

// Message Types (field: MsgType):
#define  MSG_TYPE_CONNECT_REQ         0x10  // Connection request.
#define  MSG_TYPE_CONNECT_RESP        0x11  // Connection confirmation.
#define  MSG_TYPE_DATA                0x20  // Data PDU.
#define  MSG_TYPE_DISCONNECT          0x30  // Disconnection.

// Information Types (field: InfType):
#define  INF_TYPE_VERSION             0x00  // Connection establishment.
#define  INF_TYPE_NEGOTIATION         0x01  // Connection establish or accept.
#define  INF_TYPE_USER_DATA           0x03  // Only if MsgType is MSG_TYPE_DATA.
#define  INF_TYPE_EXTEND              0x10  // Connection establishment.
#define  INF_TYPE_REASON              0x20  // Only for disconnect.

// Command Header: Pdu Types (top two bits in PduType):
#define  PDU_TYPE_REQUEST             0x00  // b:00000000
#define  PDU_TYPE_REPLY_ACK           0x40  // b:01000000
#define  PDU_TYPE_REPLY_NACK          0x80  // b:10000000
#define  PDU_TYPE_ABORT               0xc0  // b:11000000

#define  PDU_TYPE_MASK                0xc0  // b:11000000
#define  PDU_TYPE_RESERVED            0x3f  // b:00111111

// The machine ID is in the Connect PDU (SCEP_NEGOTIATION), it
// is in EUI-64 format:
#define  MACHINE_ID_SIZE                 8

// Machine PIDs: In the command header, the default source and destination
// program Ids are unsigned shorts with value 8. Some machines will have
// a PID other than this (see the first command header sent to us):
#define  DEFAULT_PID                     8

// CFlag meanings:
//
// There are two cases, one where a device/machine can only issue commands,
// the other when a device can both issue and execute commands.
//
#define  CFLAG_ISSUE_ONLY             0x00
#define  CFLAG_ISSUE_OR_EXECUTE       0x04

// DFlag Meanings:
//
// DFlag give information about the data and fragmentation (why did they
// put the reject in here?).
//
#define  DFLAG_SINGLE_PDU             0xc1
#define  DFLAG_FIRST_FRAGMENT         0x41
#define  DFLAG_FRAGMENT               0x01
#define  DFLAG_LAST_FRAGMENT          0x81
#define  DFLAG_INTERRUPT              0xc2
#define  DFLAG_CONNECT_REJECT         0xc3

// Reason Codes:
//
// Currently for V1.0 all reason codes are 2-byte numbers:
#define  REASON_CODE_UNSPECIFIED          0x0000
#define  REASON_CODE_USER_DISCONNECT      0x0001
#define  REASON_CODE_PROVIDER_DISCONNECT  0x0002

// Connection States:
#define  STATE_CLOSED                       0
#define  STATE_CONNECTING                   1
#define  STATE_CONNECTED                    2

// Put Response Protocol Error Codes (sent back to the camera):
#define  ERROR_PUT_UNDEFINED_ERROR     0x0000
#define  ERROR_PUT_ILLEGAL_DATA        0x0001
#define  ERROR_PUT_UNSUPPORTED_PID     0x0002
#define  ERROR_PUT_ILLEGAL_ATTRIBUTE   0x0010
#define  ERROR_PUT_UNSUPPORTED_CMD     0x0011
#define  ERROR_PUT_FILE_SYSTEM_FULL    0x0020
#define  ERROR_PUT_NO_FILE_OR_DIR      0x0021
#define  ERROR_PUT_LOW_BATTERY         0x0030
#define  ERROR_PUT_ABORT_EXECUTION     0x0031
#define  ERROR_PUT_NO_ERROR            0xffff

//--------------------------------------------------------------------
//  SCEP Protocol Headers:
//--------------------------------------------------------------------

// Turn off warning for zero-sized array...
#pragma warning(disable:4200)
#pragma pack(1)

typedef struct _SCEP_HEADER
   {
   UCHAR  Null;          // Always zero.
   UCHAR  MsgType;       // See MSG_TYPE_* above.
   UCHAR  Rest[];        // Dependent on the MsgType...
   } SCEP_HEADER;

typedef struct _SCEP_VERSION
   {
   UCHAR  InfType;       // Always INF_TYPE_VERSION (0x00).
   UCHAR  Version;       // Currently 0x01 (Version = 1).
   } SCEP_VERSION;

typedef struct _SCEP_NEGOTIATION
   {
   UCHAR  InfType;       // Always INF_TYPE_NEGOTATION (0x01).
   UCHAR  Length;        // Length (bytes) from InfVersion to
                         //   the end of the Negotiation information.
                         //   This will be from 0 to 228.
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  CFlag;         //
   UCHAR  SecondaryMachineId[8]; //
   UCHAR  PrimaryMachineId[8];   //
   UCHAR  Negotiation[]; //
   } SCEP_NEGOTIATION;

typedef struct _SCEP_DISCONNECT
   {
   UCHAR  InfType;       // Always INF_TYPE_REASON (0x20).
   UCHAR  Length1;       // For V1.0 this should be 2.
   USHORT ReasonCode;    // See the REASON_CODE_xxx
   } SCEP_DISCONNECT;

typedef struct _SCEP_EXTEND
   {
   UCHAR  InfType;       // Always INF_TYPE_EXTEND (0x10).
   UCHAR  Length;        // Always 2 (bytes).
   UCHAR  Parameter1;
   UCHAR  Parameter2;
   } SCEP_EXTEND;

typedef struct _COMMAND_HEADER
   {
   UCHAR  Marker58h;      // Always 0x58 (See: 3.2.2.1.3 of Protocol).
   UCHAR  PduType;        // One of: PDU_TYPE_xxxx.
   ULONG  Length4;
   UCHAR  DestMachineId[MACHINE_ID_SIZE];
   UCHAR  SrcMachineId[MACHINE_ID_SIZE];
   USHORT DestPid;
   USHORT SrcPid;
   USHORT CommandId;
   } COMMAND_HEADER;

typedef struct _SCEP_REQ_HEADER_SHORT
   {
   UCHAR  InfType;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_SHORT;

typedef struct _SCEP_REQ_HEADER_LONG
   {
   UCHAR  InfType;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   USHORT Length2;       // Only present if Length1 == 0xff.
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_LONG;

typedef struct _SCEP_REQ_HEADER_SHORT_FRAG
   {
   UCHAR  Inftype;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   DWORD  SequenceNo;    // Fragment number.
   DWORD  RestNo;        // Number of fragments left for this PDU.
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_SHORT_FRAG;

typedef struct _SCEP_REQ_HEADER_LONG_FRAG
   {
   UCHAR  InfType;       // Always INF_TYPE_USER_DATA (0x03).
   UCHAR  Length1;
   USHORT Length2;       // Only present if Length1 == 0xff.
   UCHAR  InfVersion;    // Version of InfType = INF_VERSION.
   UCHAR  DFlag;
   USHORT Length3;
   DWORD  SequenceNo;    // Fragment number.
   DWORD  RestNo;        // Number of fragments left for this PDU.
   UCHAR  CommandHeader[sizeof(COMMAND_HEADER)];
   UCHAR  UserData[];
   } SCEP_REQ_HEADER_LONG_FRAG;

#pragma pack()
#pragma warning(default:4200)

//--------------------------------------------------------------------
//  SCEP API Structures:
//--------------------------------------------------------------------

class CSCEP_CONNECTION
{
public:
    CSCEP_CONNECTION();
    ~CSCEP_CONNECTION();

    void  *operator new( IN size_t Size );

    void   operator delete( IN void  *pObj,
                            IN size_t Size );

    // Assemble the next PDU as data comes in:
    DWORD  AssemblePdu( IN  void         *pInputData,
                        IN  DWORD         dwInputDataSize,
                        OUT SCEP_HEADER **ppPdu,
                        OUT DWORD        *pdwPduSize );

    // Parse the PDU returned from AssemblePdu():
    DWORD  ParsePdu( IN  SCEP_HEADER *pPdu,
                     IN  DWORD        dwPduSize,
                     OUT COMMAND_HEADER **ppCommand,
                     OUT UCHAR          **ppUserData,
                     OUT DWORD           *pdwUserDataSize );

    DWORD  SetScepLength( IN SCEP_HEADER *pPdu,
                          IN DWORD        dwTotalPduSize );

    // Construct SCEP connection/control PDUs:
    DWORD  BuildConnectPdu( OUT SCEP_HEADER **ppPdu,
                            OUT DWORD        *pdwPduSize );

    DWORD  BuildConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                OUT DWORD        *pdwPduSize );

    DWORD  BuildConnectNackPdu( OUT SCEP_HEADER **ppPdu,
                                OUT DWORD        *pdwPduSize );

    DWORD  BuildAbortPdu( OUT SCEP_HEADER **ppPdu,
                          OUT DWORD        *pdwPduSize );

    DWORD  BuildStopPdu( OUT SCEP_HEADER **ppPdu,
                         OUT DWORD        *pdwPduSize );

    DWORD  BuildDisconnectPdu( IN  USHORT        ReasonCode,
                               OUT SCEP_HEADER **ppPdu,
                               OUT DWORD        *pdwPduSize );

    // Build bFTP request (client-side) PDUs:
    DWORD  BuildBftpWht0RinfPdu( OUT SCEP_HEADER          **ppPdu,
                                 OUT DWORD                 *pdwPduSize,
                                 OUT SCEP_REQ_HEADER_LONG **ppCommand,
                                 OUT COMMAND_HEADER       **ppCommandHeader );

    DWORD  BuildBftpPutPdu( IN  DWORD                       dwUpfFileSize,
                            IN  CHAR                       *pszUpfFile,
                            IN OUT DWORD                   *pdwFragNo,
                            OUT SCEP_HEADER               **ppPdu,
                            OUT DWORD                      *pdwPduSize,
                            OUT SCEP_REQ_HEADER_LONG_FRAG **ppCommand );

    // Build bFTP response PDUs:
    DWORD  BuildBftpRespPdu( IN  DWORD            dwPduSize,
                             OUT SCEP_HEADER    **ppPdu,
                             OUT SCEP_REQ_HEADER_SHORT **ppCommand,
                             OUT COMMAND_HEADER **ppCommandHeader );

    DWORD  BuildWht0RespPdu( IN  DWORD         dwWht0Type,
                             OUT SCEP_HEADER **ppPdu,
                             OUT DWORD        *pdwPduSize );

    DWORD  BuildPutRespPdu( IN  DWORD         dwPduAckOrNack,
                            IN  USHORT        usErrorCode,
                            OUT SCEP_HEADER **ppPdu,
                            OUT DWORD        *pdwPduSize );

    // Parse the bFTP in a SCEP command request PDU:
    DWORD  ParseBftp( IN  UCHAR  *pvBftpData,
                      IN  DWORD   dwDataSize,
                      IN  BOOL    fSaveAsUPF,
                      OUT DWORD  *pdwBftpOp,
                      OUT UCHAR **ppPutData,
                      OUT DWORD  *pdwPutDataSize );

    // Parse and save the create date/time that was specified as a 
    // bFTP option:
    DWORD  SaveBftpCreateDate( IN UCHAR *pDate,
                               IN DWORD  dwLength );

    // Parse the UPF file header to find the image JPEG file:
    DWORD  ParseUpfHeaders( IN UCHAR  *pPutData,
                            IN DWORD   dwPutDataSize,
                            OUT DWORD *pdwJpegOffset,
                            OUT DWORD *pdwJpegSize );

    // Used when a SCEP command PDU is received:
    BOOL   IsFragmented();
    DWORD  GetSequenceNo();
    DWORD  GetRestNo();
    DWORD  GetCommandId();
    WCHAR *GetFileName();
    UCHAR  GetDFlag();
    FILETIME *GetCreateTime();

protected:

    DWORD  CheckPdu( OUT SCEP_HEADER **ppPdu,
                     OUT DWORD        *pdwPduSize );

    DWORD  CheckConnectPdu( OUT SCEP_HEADER **ppPdu,
                            OUT DWORD        *pdwPduSize );

    DWORD  CheckAckPdu( OUT SCEP_HEADER **ppPdu,
                        OUT DWORD        *pdwPduSize );

    DWORD  CheckNackPdu( OUT SCEP_HEADER **ppPdu,
                         OUT DWORD        *pdwPduSize );

    DWORD  CheckConnectRespPdu( OUT SCEP_HEADER **ppPdu,
                                OUT DWORD        *pdwPduSize );

    DWORD  CheckDataPdu( OUT SCEP_HEADER **ppPdu,
                         OUT DWORD        *pdwPduSize );

    DWORD  CheckDisconnectPdu( OUT SCEP_HEADER **ppPdu,
                               OUT DWORD        *pdwPduSize );

    DWORD  ParseConnectPdu( IN SCEP_HEADER *pPdu,
                            IN DWORD        dwPduSize );

    DWORD  ParseConnectRespPdu( IN SCEP_HEADER *pPdu,
                                IN DWORD        dwPduSize );

    DWORD  ParseDataPdu( IN  SCEP_HEADER *pPdu,
                         IN  DWORD        dwPduSize,
                         OUT COMMAND_HEADER **ppCommand,
                         OUT UCHAR          **ppUserData,
                         OUT DWORD           *pdwUserDataSize );

    DWORD  ParseDisconnectPdu( IN SCEP_HEADER *pPdu,
                               IN DWORD        dwPduSize );

    DWORD  ParseNegotiation( IN UCHAR *pNegotiation,
                             IN DWORD  dwNegotiationSize );

    UCHAR *ParseAttribute( IN     UCHAR *pAttributes,
                           IN OUT DWORD *pdwAttributeSize,
                           OUT    DWORD *pdwStatus );

    DWORD  ParseSingleLongPdu( IN SCEP_HEADER *pPdu,
                               IN DWORD        dwPduSize );

    BFTP_ATTRIBUTE *ParseBftpAttributeName(
                               IN BFTP_ATTRIBUTE *pAttr,
                               IN OUT DWORD      *pdwSize,
                               OUT    DWORD      *pdwWhichAttr );

    DWORD   m_dwConnectionState;
    DWORD   m_dwPduSendSize;
    DWORD   m_dwPduReceiveSize;
    UCHAR   m_CFlag;
    UCHAR  *m_pPrimaryMachineId;
    UCHAR  *m_pSecondaryMachineId;
    USHORT  m_DestPid;        // My PID (Camera point of view).
    USHORT  m_SrcPid;         // Camera's PID (Camera point of view).
    UCHAR  *m_pszProductId;
    UCHAR  *m_pszUserName;
    UCHAR  *m_pszPassword;

    // Used during PDU assembley process.
    UCHAR  *m_pAssembleBuffer;
    DWORD   m_dwAssembleBufferSize;
    DWORD   m_dwMaxAssembleBufferSize;
    BOOL    m_fDidByteSwap;

    // Used to manage the current SCEP command PDU.
    UCHAR   m_Fragmented;
    UCHAR   m_DFlag;
    DWORD   m_dwSequenceNo;
    DWORD   m_dwRestNo;
    DWORD   m_dwCommandId;
    COMMAND_HEADER *m_pCommandHeader;

    // UPF Hear and bFTP information
    // NOTE: The CHAR version of the file name is the one that camera
    //       sent us, the WCHAR version is the one we will actually 
    //       create. Note that the WCHAR version usually has a different
    //       suffix.
    CHAR    *m_pszFileName;
    CHAR    *m_pszLongFileName;
    WCHAR   *m_pwszFileName;
    FILETIME m_CreateTime;
};

//--------------------------------------------------------------------
// Inline Functions:
//--------------------------------------------------------------------

inline BOOL CSCEP_CONNECTION::IsFragmented()
    {
    return m_Fragmented;
    }

inline DWORD CSCEP_CONNECTION::GetSequenceNo()
    {
    return m_dwSequenceNo;
    }

inline DWORD CSCEP_CONNECTION::GetRestNo()
    {
    return m_dwRestNo;
    }

inline DWORD CSCEP_CONNECTION::GetCommandId()
    {
    return m_dwCommandId;
    }

inline WCHAR *CSCEP_CONNECTION::GetFileName()
    {
    return m_pwszFileName;
    }

inline UCHAR CSCEP_CONNECTION::GetDFlag()
    {
    return m_DFlag;
    }

inline FILETIME *CSCEP_CONNECTION::GetCreateTime()
    {
    if ( (m_CreateTime.dwLowDateTime)
       || (m_CreateTime.dwHighDateTime) )
        {
        return &m_CreateTime;
        }
    else
        {
        return 0;
        }
    }

//--------------------------------------------------------------------
// Utility Functions/Macros:
//--------------------------------------------------------------------

#define ByteSwapShort(Value)              \
            (  (((Value) & 0x00FF) << 8)  \
             | (((Value) & 0xFF00) >> 8))

#define ByteSwapLong(Value) \
            (  (((Value) & 0xFF000000) >> 24) \
             | (((Value) & 0x00FF0000) >> 8)  \
             | (((Value) & 0x0000FF00) << 8)  \
             | (((Value) & 0x000000FF) << 24))

extern void ByteSwapReqHeaderShort( SCEP_REQ_HEADER_SHORT *pSingleShort );

extern void ByteSwapReqHeaderLong( SCEP_REQ_HEADER_LONG *pSingleLong );

extern void ByteSwapCommandHeader( COMMAND_HEADER *pCommandHeader );


//--------------------------------------------------------------------
// Memory management functions:
//--------------------------------------------------------------------

DWORD        InitializeMemory();

DWORD        UninitializeMemory();

void        *AllocateMemory( DWORD dwBytes );
 
DWORD        FreeMemory( void *pvMemory );

SCEP_HEADER *NewPdu( DWORD dwPduSize = MAX_PDU_SIZE );

void         DeletePdu( SCEP_HEADER *pPdu );

#if FALSE
//--------------------------------------------------------------------

    SCEP Connect PDU
    ----------------

    Connection request PDU. This is a SCEP_HEADER with Rest[] filled
    with three Inf Records, a SCEP_VERSION followed by a SCEP_NEGOTIATION
    followed by a SCEP_EXTEND. The Connect PDU must be less than or equal
    to 256 bytes in length.

      SCEP_HEADER                        2 bytes.
      Rest[]: SCEP_VERSION               2 bytes.
              SCEP_NEGOTIATION    20 - 228 bytes.
              SCEP_EXTEND                4 bytes.
                                  --------
                                  28 - 256 bytes.

    - If either the SecondaryMachineId[] or PrimariyMachineId is unused,
      then they are set to 00,00,00,00,00,00,00,00.
    - If a machine gets a Connect PDU but can't  execute commands
      (CFlag = CFLAG_ISSUE_ONLY), then it needs to respond with a
      NACK PDU.
    - The negotiation information is a simple text based command
      language.


    SCEP Connection ACK PDU
    -----------------------

    Connection acceptance PDU. This is a SCEP_HEADER with Rest[] filled
    with two Inf Records, a SCEP_VERSION followed by a SCEP_NEGOTIATION.

      SCEP_HEADER                        2 bytes.
      SCEP_VERSION                       2 bytes.
      Rest[]: SCEP_NEGOTIATION      20-251 bytes.
                                    ------
                                    24-255 bytes.

    - Note that the size of the ACK PDU is limited by the fact that
      the Length field is a single byte and that the ACK PDU can not
      be fragmented. Normally these PDUs will never be this long.


    SCEP Connection NACK PDU
    ------------------------

    Connection rejected PDU. This one can have either of two different
    formats.

      SCEP_HEADER
      Rest[]: SCEP_REQ_HEADER_SHORT

      or

      SCEP_HEADER
      Rest[]: SCEP_REQ_HEADER_LONG

    - In the first case, Length1 = 4, DFlag = DFLAG_CONNECT_REJECT,
      and Length 3 = 0.
    - In the second case, Length1 = 0xff, DFlag = DFLAG_CONNECT_REJECT,
      and Length 3 = 0.


    SCEP Disconnect PDU
    -------------------

    A disconnect can be generated by either side of the connection,
    or by one of the transports at any time.

      SCEP_HEADER
      Rest[]: SCEP_DISCONNECT

    - For V1.0, Length1 = 2, and ReasonCode is a USHORT.


    SCEP Command Request and Response PDUs (Non-fragmented)
    -------------------------------------------------------

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT    4 + 0-254 bytes
                                       ---------
                                         6 - 260 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG    4 + 0-4090 bytes (1)
                                      ----------
                                        6 - 4096 bytes

    - In either case, DFlag = DFLAG_SINGLE_PDU.
    - PduType = PDU_TYPE_REQUEST.
    - If Length1 = 0xff then the long version is used.
    - The Length1(2) field specifies the byte size from InfVersion to the
      end of the user data. If the total size will exceed the maximum PDU
      size then the request must be fragmented.
    - So the total PDU size is: 6 + Length1(2) bytes.

    (1) Assuming the maximum PDU size is 4096 (fr:4).


    SCEP Command Request and Response PDUs (Fragmented)
    ---------------------------------------------------

    For requests these PDUs are generated when the PDU size is greater
    than that of the responder that you are connected to. For responses,
    the PDUs are fragmented when the returned data is greater than the
    maximum that the requester specified during the connection establishment.

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT_FRAG    6 + 0-254 bytes
                                       ---------
                                         8 - 260 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG_FRAG    8 + 0-4088 bytes (1)
                                       ---------
                                       10 - 4096 bytes

    - For the first PDU fragment, DFlag = DFLAG_FIRST_FRAGMENT, for
      intermediate fragments, DFlag = DFLAG_FRAGMENT, and for the
      last fragment, DFlag = DFLAG_LAST_FRAGMENT.
    - PduType = PDU_TYPE_REQUEST for the request.
    - PduType = PDU_TYPE_REPLY_ACK or PDU_TYPE_REPLY_NACK in the
      response.
    - If Length1 = 0xff then the long version is used.
    - Length1(2) can not exceed the maximum PDU size - 6 bytes.
    - SequenceNo is 0 for the first PDU (NOTE: 4 bytes).
    - RestNo is the remaining number of PDUs to get. It is 1 for
      the last PDU (really, it says so in the spec!). So, a client
      should start this as the total number of PDUs in the first
      fragment (not really the number remaining). NOTE: 4 bytes.

    (1) Assuming the maximum PDU size is 4096 (fr:4).


    SCEP Abort PDU
    --------------

    Use the abort to stop execution of a command (specified by the
    DestPid and CommandId) after ALL of the request PDUs have been
    sent. An abort PDU also has two possible formats.

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT           34 bytes
                                              --
                                              36 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG            36 bytes
                                              --
                                              38 bytes

    - In either case, DFlag = DFLAG_SINGLE_PDU.
    - In either case, PduType = PDU_TYPE_ABORT.
    - For the short PDU, Length1 = 0x20 (32), and Length3 = 0x1c
      (28).
    - For the long PDU, Length1 = 0xff, Length2 = 0x20 (32),
      and Length3 = 0x1c (28).


    SCEP Stop (Interrupt) PDU
    -------------------------

    If an Abort PDU has been sent out to stop a command, and as the
    command is halted some response data has already been sent, the
    the responder will send this PDU. It appears that a Stop PDU should
    not be sent if no response has yet been sent back.

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_SHORT            6 bytes
                                              --
                                               8 bytes
      or

      SCEP_HEADER                              2 bytes
      Rest[]: SCEP_REQ_HEADER_LONG             8 bytes
                                              --
                                              10 bytes

    - In either case, DFlag = DFLAG_INTERRUPT.
    - For the short PDU, Length1 = 4, and Length3 = 0.
    - For the long PDU, Length1 = 0xff, Length2 = 4, and
      Length3 = 0.

    Negotiation Information
    -----------------------

    The negotiation information is used to convey the frame size,
    authentication data, and product information, etc.

    Its structure is a version code (currently 0x11) followed by
    text in the following syntax:

      NegInf    -> Attribute ':' Spaces Value CrLf

      Attribute -> AttribChar AttribChar

      AttribChar-> 'a-zA-Z'

      Value     -> ValueChar Value
                ->

      ValueChar -> 'ASCII string, bytes must be between 0x20 and 0x8e
                    inclusive'

      Spaces    -> ' ' Spaces
                ->

      CrLf      -> 0x0d 0x0a

      Attribute    Meaning
      ---------    -------
      fr           Frame (PDU) size. The sender requests the maximum
                   receivable PDU size, the receiver decides the
                   transmission PDU size in accordance with the senders
                   requested PDU size. The maximum PDU size of the sender
                   may be different than that of the receiver. The value
                   is one of:

                   1 -  512 bytes PDU size (default).
                   2 - 1024 bytes PDU size.
                   3 - 2048 bytes PDU size.
                   4 - 4096 bytes PDU size.

      id           Product Identification string.

      nm           User name. any byte string that doesn't include CR or
                   LF (note the conflict in by values with the syntax
                   specification above). The user name may be up to 32
                   characters long.

      pw           Password. This is a MD5 encoded password expressed
                   in a 16 byte "hex" string, no spaces are allowd.
                   It appears that this will always be 32 characters
                   long. For example: 0aff3728e4a62791337984282871a6bc

//--------------------------------------------------------------------
#endif

#endif //_SCEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irutil\decdirda.c ===
#include <irda.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <decdirda.h>

#if 1 //DBG

int vDispMode;

UINT vDecodeLayer;

const int vSlotTable[] = { 1, 6, 8, 16 };

int IasRequest;

const CHAR *vLM_PDU_DscReason[] =
{
    (""),
    ("User Request"),
    ("Unexpected IrLAP Disconnect"),
    ("Failed to establish IrLAP connection"),
    ("IrLAP reset"),
    ("Link management initiated disconnect"),
    ("data sent to disconnected LSAP"),
    ("Non responsive LM-MUX client"),
    ("No available LM-MUX client"),
    ("Unspecified")
};

/*
** Negotiation Parameter Value (PV) tables
*/
const CHAR *vBaud[] =
{
    ("2400"), ("9600"), ("19200"), ("38400"), ("57600"),
    ("115200"), ("576000"), ("1152000"), ("4000000")
};

const CHAR *vMaxTAT[] = /* Turn Around Time */
{
    ("500"), ("250"), ("100"), ("50"), ("25"), ("10"),
    ("5"), ("reserved")
};

const CHAR *vMinTAT[] =
{
    ("10"), ("5"), ("1"), ("0.5"), ("0.1"), ("0.05"),
    ("0.01"), ("0")
};

const CHAR *vDataSize[] =
{
    ("64"), ("128"), ("256"), ("512"), ("1024"),
    ("2048"), ("reserved"), ("reserved")
};

const CHAR *vWinSize[] =
{
    ("1"), ("2"), ("3"), ("4"), ("5"), ("6"),
    ("7"), ("reserved")
};

const CHAR *vNumBofs[] =
{
    ("48"), ("24"), ("12"), ("5"), ("3"), ("2"),
    ("1"), ("0")
};

const CHAR *vDiscThresh[] =
{
    ("3"), ("8"), ("12"), ("16"), ("20"), ("25"),
    ("30"), ("40")
};

/*---------------------------------------------------------------------------*/
LONG
RawDump(UCHAR *pFrameBuf, UCHAR *pEndBuf, CHAR *pOutStr, ULONG BufferSize)
{
    BOOLEAN    First = TRUE;
    UCHAR    *pBufPtr = pFrameBuf;
    ULONG      BytesWritten=0;

    if (!vDecodeLayer)
        return 0;

    if (vDispMode == DISP_ASCII || vDispMode == DISP_BOTH)
    {

        if ((BufferSize - BytesWritten) < (ULONG)(2+(pEndBuf-pFrameBuf)+1)) {
            //
            //  not big enough to hold all the characters
            //
            return -1;
        }

        while (pBufPtr <= pEndBuf)
        {
            if (First)
            {
                First = FALSE;
                *pOutStr++ = ('[');
                BytesWritten++;
            }
        
            *pOutStr++ = isprint(*pBufPtr) ? *pBufPtr : '.';
            BytesWritten++;
        
            pBufPtr++;
        }
        if (!First) {
             // meaning, close [
            *pOutStr++ = ']';
            BytesWritten++;
        }
    } 

    First = TRUE;
    pBufPtr = pFrameBuf;
    
    if (vDispMode == DISP_HEX || vDispMode == DISP_BOTH)
    {

        if ((BufferSize - BytesWritten) < (ULONG)(2+((pEndBuf-pFrameBuf)*2)+1)) {
            //
            //  not big enough to hold all the characters
            //
            return -1;
        }

        while (pBufPtr <= pEndBuf)
        {
            if (First)
            {
                First = FALSE;
                *pOutStr++ = ('[');
                BytesWritten++;
            }
        
            sprintf(pOutStr, ("%02X "), *pBufPtr);
            BytesWritten++;
        
            pBufPtr++;

        }
        if (!First) {
            //
            // meaning, close [
            //
            *pOutStr++ = ']';
            BytesWritten++;
        }
    }

    return (LONG)BytesWritten;
}
/*---------------------------------------------------------------------------*/
CHAR *
GetStatusStr(UCHAR status)
{
    switch (status)
    {
        case LM_PDU_SUCCESS:
            return (("SUCCESS"));
        case LM_PDU_FAILURE:
            return (("FAILURE"));
        case LM_PDU_UNSUPPORTED:
            return (("UNSUPPORTED"));
        default:
            return (("BAD STATUS!"));
    }
}

/*---------------------------------------------------------------------------*/
LONG
DecodeIFrm(UCHAR *pFrameBuf, UCHAR *pEndBuf, CHAR *pOutStr, ULONG BufferSize)
{
    LM_HEADER *pLMHeader = (LM_HEADER *) pFrameBuf;
    LM_CNTL_FORMAT *pCFormat =
       (LM_CNTL_FORMAT *)(pFrameBuf + sizeof(LM_HEADER));
    UCHAR *pLMParm1 = ((UCHAR *) pCFormat + sizeof(LM_CNTL_FORMAT));
    UCHAR *pLMParm2 = ((UCHAR *) pCFormat + sizeof(LM_CNTL_FORMAT) + 1);
    TTP_CONN_HEADER *pTTPConnHeader = (TTP_CONN_HEADER *) pLMParm2;
    TTP_DATA_HEADER *pTTPDataHeader = (TTP_DATA_HEADER *)
                            (pFrameBuf + sizeof(LM_HEADER));
    CHAR RCStr[] = ("    ");
    BOOLEAN IasFrame = FALSE;
    LONG    PrintfResult=0;

    LONG    OutputBufferSizeInCharacters=BufferSize;
    
    if (2 == vDecodeLayer) // LAP only
    {
        PrintfResult=RawDump(pFrameBuf, pEndBuf, pOutStr,BufferSize);

        if (PrintfResult < 0) {

            return -1;
        }

        OutputBufferSizeInCharacters-=PrintfResult;
        pOutStr +=  PrintfResult;

        return 0;
    }

    // Ensure the LMP header is there
    if (((UCHAR *)pLMHeader + sizeof(LM_HEADER) > pEndBuf+1))
    {
        return  _snprintf(pOutStr,OutputBufferSizeInCharacters, ("!-MISSING LMP HEADER-!"));
    }
    
    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters, ("sls:%02X dls:%02X "),
                         pLMHeader->SLSAP_SEL, pLMHeader->DLSAP_SEL);


    if (PrintfResult < 0) {

        return -1;
    }

    OutputBufferSizeInCharacters-=PrintfResult;
    pOutStr +=  PrintfResult;

    if (pLMHeader->SLSAP_SEL == IAS_SEL || pLMHeader->DLSAP_SEL == IAS_SEL)
    {
        IasFrame = TRUE;
        PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters, ("*IAS*"));

        if (PrintfResult < 0) {

            return -1;
        }

        OutputBufferSizeInCharacters-=PrintfResult;
        pOutStr +=  PrintfResult;

    }
    
    switch (pLMHeader->CntlBit)
    {
        case LM_PDU_CNTL_FRAME:
            strcpy(RCStr, pCFormat->ABit == LM_PDU_REQUEST ?
                   ("req") : ("conf"));

            if (((UCHAR *)pCFormat + sizeof(LM_CNTL_FORMAT)) > pEndBuf+1)
            {
                PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                                      ("!-MISSING LMP-CNTL HEADER-!"));
                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                return BufferSize-OutputBufferSizeInCharacters;
            }
            else
            {
                if (pLMParm1 > pEndBuf)
                {
                    pLMParm1 = NULL;
                    pLMParm2 = NULL;
                    pTTPConnHeader = NULL;
                }
                else
                {
                    if (pLMParm2 > pEndBuf)
                    {
                        pLMParm2 = NULL;
                        pTTPConnHeader = NULL;
                    }
                    else
                    {
                        if (((UCHAR *)pTTPConnHeader+sizeof(TTP_CONN_HEADER)) >
                        pEndBuf+1)
                        {
                            pTTPConnHeader = NULL;
                        }
                    }
                }
            }
            
            switch (pCFormat->OpCode)
            {
                case LM_PDU_CONNECT:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters, ("LM-Connect.%s "),
                                         RCStr);

                    if (PrintfResult < 0) {

                        return -1;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    if (pLMParm1 != NULL)
                    {
                        PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters, ("rsvd:%02X "),
                                              *pLMParm1);
                        if (PrintfResult < 0) {

                            return -1;
                        }

                        OutputBufferSizeInCharacters-=PrintfResult;
                        pOutStr +=  PrintfResult;

                    }
                    if (3 == vDecodeLayer) // LMP only
                    {
                        if (pLMParm2 != NULL) 
                        {
                            // This is user data
                            RawDump(pLMParm2, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

                            if (PrintfResult < 0) {

                                return -1;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;

                        }
                    }
                    else
                    {
                        // TTP
                        if (pTTPConnHeader == NULL)
                        {
                            PrintfResult= _snprintf(pOutStr,    OutputBufferSizeInCharacters,
                                     ("!-MISSING TTP CONNECT HEADER-!"));

                            if (PrintfResult < 0) {

                                return -1;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;

                        }
                        else
                        {
                            PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,
                                  ("pf:%d ic:%d "),
                                  pTTPConnHeader->ParmFlag,
                                       pTTPConnHeader->InitialCredit);

                            if (PrintfResult < 0) {

                                return -1;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;

                            // This is user data
                            PrintfResult=RawDump(((UCHAR *) pTTPConnHeader +
                                     sizeof(TTP_CONN_HEADER)), pEndBuf,
                                    pOutStr,OutputBufferSizeInCharacters);

                            if (PrintfResult < 0) {

                                return -1;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;

                        }
                    }
                    break;
                    
                case LM_PDU_DISCONNECT:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                                     ("LM-Disconnect.%s"), RCStr);

                    if (PrintfResult < 0) {

                        return -1;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    if (pLMParm1 == NULL)
                    {
                        PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                                        ("!-MISSING REASON CODE-!"));

                        if (PrintfResult < 0) {

                            return -1;
                        }

                        OutputBufferSizeInCharacters-=PrintfResult;
                        pOutStr +=  PrintfResult;

                        return BufferSize-OutputBufferSizeInCharacters;
                    }
                    else
                    {
                        if ((*pLMParm1 > LM_PDU_MAX_DSC_REASON || 
                             *pLMParm1 == 0) && *pLMParm1 != 0xFF)
                        { 
                            PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                                          (" BAD REASON CODE:%02X "),
                                                  *pLMParm1);


                            if (PrintfResult < 0) {

                                return -1;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;

                        }
                        else
                        {
                            if (*pLMParm1 == 0xFF)
                            {
                                *pLMParm1 = 0x09; // KLUDGE HERE !!
                            }
                            PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                                           ("(%02X:%s) "), *pLMParm1,
                                           vLM_PDU_DscReason[*pLMParm1]);

                            if (PrintfResult < 0) {

                                return -1;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;



                        }
                        if (pLMParm2 != NULL)
                        {
                            PrintfResult=RawDump(pLMParm2, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

                            if (PrintfResult < 0) {

                                return -1;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;

                        }
                    }

                    break;
                    
                case LM_PDU_ACCESSMODE:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters, ("LM-AccessMode.%s "),
                                          RCStr);

                    if (PrintfResult < 0) {

                        return -1;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    if (pLMParm1 == NULL || pLMParm2 == NULL)
                    {
                        PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                                              ("!-MISSING PARAMETER-!"));

                        if (PrintfResult < 0) {

                            return -1;
                        }

                        OutputBufferSizeInCharacters-=PrintfResult;
                        pOutStr +=  PrintfResult;

                    }
                    else
                    {
                        if (pCFormat->ABit == LM_PDU_REQUEST)
                        {
                            PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                                  ("rsvd:%02X "), *pLMParm1);

                            if (PrintfResult < 0) {

                                return -1;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;


                        }
                        else
                        {
                            PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                                 ("status:%s "), GetStatusStr(*pLMParm1));

                            if (PrintfResult < 0) {

                                return -1;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;

                        }
                        
                        PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,("mode:%s "),
                                          *pLMParm2 == LM_PDU_EXCLUSIVE ?
                                          ("Exclusive") :
                                              ("Multiplexed"));

                        if (PrintfResult < 0) {

                            return -1;
                        }

                        OutputBufferSizeInCharacters-=PrintfResult;
                        pOutStr +=  PrintfResult;

                    }
                    break;
                default:
                    PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,("Bad opcode: "));

                    if (PrintfResult < 0) {

                        return -1;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;


                    PrintfResult=RawDump((UCHAR *) pCFormat, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

                    if (PrintfResult < 0) {

                        return -1;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

            }
            break;
                    
        case LM_PDU_DATA_FRAME:
            if (IasFrame)
            {
                break;
            }
            if (3 == vDecodeLayer)
            {
                PrintfResult=RawDump((UCHAR *) pCFormat, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

            }
            else
            {
                // TTP
                if ((UCHAR *) (pTTPDataHeader + 1) > pEndBuf + 1)
                {
                    PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,
                                 ("!-MISSING TTP DATA HEADER-!"));

                    if (PrintfResult < 0) {

                        return -1;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                }
                else
                {
                    PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,
                               ("mb:%d nc:%d "),
                                          pTTPDataHeader->MoreBit,
                                          pTTPDataHeader->AdditionalCredit);

                    if (PrintfResult < 0) {

                        return -1;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    // This is user data
                    PrintfResult=RawDump(((UCHAR *) pTTPDataHeader +
                             sizeof(TTP_DATA_HEADER)), pEndBuf,
                            pOutStr,OutputBufferSizeInCharacters);

                    if (PrintfResult < 0) {

                        return -1;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                }
                
            }
            break;

        default:
            PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,("Bad LM-PDU type: "));

            if (PrintfResult < 0) {

                return -1;
            }

            OutputBufferSizeInCharacters-=PrintfResult;
            pOutStr +=  PrintfResult;

            PrintfResult=RawDump((UCHAR *) pLMHeader, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

            if (PrintfResult < 0) {

                return -1;
            }

            OutputBufferSizeInCharacters-=PrintfResult;
            pOutStr +=  PrintfResult;

    }

    return BufferSize-OutputBufferSizeInCharacters;

}
/*---------------------------------------------------------------------------*/
LONG
DumpPv(const CHAR *PVTable[], UCHAR **ppQosUChar, CHAR* pOutStr,ULONG BufferSize)
{
    PUCHAR      SourceBuffer=*ppQosUChar;

    int Pl = (int) *SourceBuffer++;
    int i;
    BOOLEAN First = TRUE;
    UCHAR    Mask = 1;
    UINT     BitField;

    ULONG  OutputBufferSizeInCharacters=BufferSize;
    LONG    PrintfResult=0;



    BitField = 0;

    if (Pl == 1)
    {
        BitField = (UINT) *SourceBuffer;
    }
    else
    {
        BitField = ((UINT) *(SourceBuffer+1))<<8;
        BitField |= (UINT) *(SourceBuffer);
    }

    for (i = 0; i <= 8; i++)
    {
        if (BitField & (Mask))
        {
            if (First)
            {
                PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, PVTable[i]);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                First = FALSE;
            }
            else {
                PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, (",%s"), PVTable[i]);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

            }
        }
        Mask *= 2;
    }

    if (OutputBufferSizeInCharacters > 0) {

        *pOutStr++ = '>';
        PrintfResult=1;

        OutputBufferSizeInCharacters-=PrintfResult;
        pOutStr +=  PrintfResult;


    } else {

        return -1;
    }

    *ppQosUChar=SourceBuffer + Pl;

    return BufferSize-OutputBufferSizeInCharacters;
}
/*---------------------------------------------------------------------------*/
LONG
DecodeNegParms(UCHAR *pCurPos, UCHAR *pEndBuf, CHAR *pOutStr,ULONG BufferSize)
{

    ULONG  OutputBufferSizeInCharacters=BufferSize;
    LONG    PrintfResult=0;


    while (pCurPos+2 <= pEndBuf) /* need at least 3 bytes */
                                 /* to define a parm      */
    {
        switch (*pCurPos)
        {
            case NEG_PI_BAUD:
                PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("<baud:"));

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;


                pCurPos++;
                PrintfResult=DumpPv(vBaud, &pCurPos, pOutStr,OutputBufferSizeInCharacters);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                break;

            case NEG_PI_MAX_TAT:
                PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("<max TAT:"));

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                pCurPos++;
                PrintfResult=DumpPv(vMaxTAT, &pCurPos, pOutStr,OutputBufferSizeInCharacters);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                break;

            case NEG_PI_DATA_SZ:
                PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("<data size:"));

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                pCurPos++;
                PrintfResult=DumpPv(vDataSize, &pCurPos, pOutStr,OutputBufferSizeInCharacters);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                break;
                
            case NEG_PI_WIN_SZ:
                PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("<win size:"));

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                pCurPos++;
                PrintfResult=DumpPv(vWinSize, &pCurPos, pOutStr, OutputBufferSizeInCharacters);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                break;
                
            case NEG_PI_BOFS:
                PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("<BOFs:"));

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                pCurPos++;
                PrintfResult=DumpPv(vNumBofs, &pCurPos, pOutStr,OutputBufferSizeInCharacters);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                break;
                
            case NEG_PI_MIN_TAT:
                PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("<min TAT:"));

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                pCurPos++;
                PrintfResult=DumpPv(vMinTAT, &pCurPos, pOutStr,OutputBufferSizeInCharacters);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                break;
            case NEG_PI_DISC_THRESH:
                PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("<disc thresh:"));

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                pCurPos++;
                PrintfResult=DumpPv(vDiscThresh, &pCurPos, pOutStr,OutputBufferSizeInCharacters);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                break;
                
            default:
                PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("!!BAD PARM:%02X!!"),*pCurPos);

                if (PrintfResult < 0) {

                    return -1;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

                pCurPos += 3;
        }
    }

    return BufferSize-OutputBufferSizeInCharacters;
}
 /*---------------------------------------------------------------------------*/
LONG
DecodeXID(UCHAR *FormatID, UCHAR *pEndBuf, CHAR *pOutStr,ULONG BufferSize)
{
    XID_DISCV_FORMAT *DiscvFormat=(XID_DISCV_FORMAT *)((UCHAR *)FormatID + 1);
    UCHAR *NegParms = FormatID + 1;
    UCHAR *DiscvInfo = FormatID + sizeof(XID_DISCV_FORMAT);

    ULONG  OutputBufferSizeInCharacters=BufferSize;
    LONG    PrintfResult=0;

    switch (*FormatID)
    {
      case XID_DISCV_FORMAT_ID:
        PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("dscv "));

        if (PrintfResult < 0) {

            return -1;
        }

        OutputBufferSizeInCharacters-=PrintfResult;
        pOutStr +=  PrintfResult;


        if (DiscvFormat->GenNewAddr) {
            PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("new addr "));
        }

        PrintfResult=_snprintf(pOutStr, OutputBufferSizeInCharacters,("sa:%02X%02X%02X%02X "),
                              DiscvFormat->SrcAddr[0],
                              DiscvFormat->SrcAddr[1],
                              DiscvFormat->SrcAddr[2],
                              DiscvFormat->SrcAddr[3]);

        if (PrintfResult < 0) {

            return -1;
        }

        OutputBufferSizeInCharacters-=PrintfResult;
        pOutStr +=  PrintfResult;


        PrintfResult=_snprintf(pOutStr, OutputBufferSizeInCharacters,("da:%02X%02X%02X%02X "),
                              DiscvFormat->DestAddr[0],
                              DiscvFormat->DestAddr[1],
                              DiscvFormat->DestAddr[2],
                              DiscvFormat->DestAddr[3]);
        if (PrintfResult < 0) {

            return -1;
        }

        OutputBufferSizeInCharacters-=PrintfResult;
        pOutStr +=  PrintfResult;

        PrintfResult=_snprintf(pOutStr, OutputBufferSizeInCharacters,("Slot:%02X/%X "),
                              DiscvFormat->SlotNo,
                              vSlotTable[DiscvFormat->NoOfSlots]);
        if (PrintfResult < 0) {

            return -1;
        }

        OutputBufferSizeInCharacters-=PrintfResult;
        pOutStr +=  PrintfResult;

        PrintfResult= RawDump(DiscvInfo, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

        if (PrintfResult < 0) {

            return -1;
        }

        OutputBufferSizeInCharacters-=PrintfResult;
        pOutStr +=  PrintfResult;

        break;

      case XID_NEGPARMS_FORMAT_ID:
        PrintfResult=_snprintf(pOutStr, OutputBufferSizeInCharacters,("Neg Parms "));

        if (PrintfResult < 0) {

            return -1;
        }

        OutputBufferSizeInCharacters-=PrintfResult;
        pOutStr +=  PrintfResult;


        DecodeNegParms(NegParms, pEndBuf, pOutStr,OutputBufferSizeInCharacters);
        break;
    }

    return BufferSize-OutputBufferSizeInCharacters;
}
/*---------------------------------------------------------------------------*/
LONG
BadFrame(UCHAR *pFrameBuf, UCHAR *pEndBuf, CHAR *pOutStr, ULONG BufferSize)
{

    ULONG  OutputBufferSizeInCharacters=BufferSize;
    LONG    PrintfResult=0;


    PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("Undefined Frame: "));

    if (PrintfResult < 0) {

        return -1;
    }

    OutputBufferSizeInCharacters-=PrintfResult;
    pOutStr +=  PrintfResult;

    PrintfResult=RawDump(pFrameBuf, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

    if (PrintfResult < 0) {

        return -1;
    }

    OutputBufferSizeInCharacters-=PrintfResult;
    pOutStr +=  PrintfResult;

    return BufferSize-OutputBufferSizeInCharacters;

}

/*---------------------------------------------------------------------------*/
CHAR *DecodeIRDA(int  *pFrameType,// returned frame type (-1=bad frame)
                UCHAR *pFrameBuf, // pointer to buffer containing IRLAP frame
                UINT FrameLen,   // length of buffer 
                CHAR   *OutputBuffer,  // string where decoded packet is placed
                ULONG   OutputBufferSizeInCharacters,
                UINT DecodeLayer,// 0, hdronly, 1,LAP only, 2 LAP/LMP, 3, LAP/LMP/TTP
                int fNoConnAddr,// TRUE->Don't show connection address in str
                int  DispMode 
)
{
    UINT CRBit;
    UINT PFBit;
    UCHAR *Addr = pFrameBuf;
    UCHAR *Cntl = pFrameBuf + 1;
    CHAR CRStr[] = ("   ");
    CHAR PFChar = (' ');
    SNRM_FORMAT *SNRMFormat = (SNRM_FORMAT *) ((UCHAR *) pFrameBuf + 2);
    UA_FORMAT *UAFormat = (UA_FORMAT *) ((UCHAR *) pFrameBuf + 2);
    UINT Nr = IRLAP_GET_NR(*Cntl);
    UINT Ns = IRLAP_GET_NS(*Cntl);
    UCHAR *pEndBuf = pFrameBuf + FrameLen - 1;

    LONG    CharactersWrittenToBuffer=0;
    LONG    PrintfResult=0;
    CHAR *pOutStr=OutputBuffer;
    CHAR *First = pOutStr;
    //
    //  reduce the length by one so that we can be ebsure a null is on thge end
    //
    OutputBufferSizeInCharacters--;

    //
    //  put a null at the end
    //
    pOutStr[OutputBufferSizeInCharacters]=('\0');

    vDispMode = DispMode;
    
    vDecodeLayer = DecodeLayer;

    if ( !fNoConnAddr) {

        PrintfResult=_snprintf(pOutStr,OutputBufferSizeInCharacters, ("ca:%02X "), IRLAP_GET_ADDR(*Addr));

        if (PrintfResult < 0) {

            goto BufferToSmall;
        }

        OutputBufferSizeInCharacters-=PrintfResult;
        pOutStr +=  PrintfResult;
    }
    
    CRBit = IRLAP_GET_CRBIT(*Addr);
    strcpy(CRStr, CRBit == _IRLAP_CMD ? ("cmd"):("rsp"));
    
    PFBit = IRLAP_GET_PFBIT(*Cntl);
    if (1 == PFBit)
    {
        if (CRBit == _IRLAP_CMD)
            PFChar = 'P';
        else
            PFChar ='F';
    }
    
    *pFrameType = IRLAP_FRAME_TYPE(*Cntl);

    switch (IRLAP_FRAME_TYPE(*Cntl))
    {
        case IRLAP_I_FRM:
            PrintfResult = _snprintf(pOutStr,OutputBufferSizeInCharacters, ("I %s %c ns:%01d nr:%01d "),
                               CRStr, PFChar, Ns, Nr);

            if (PrintfResult < 0) {

                goto BufferToSmall;
            }

            OutputBufferSizeInCharacters-=PrintfResult;
            pOutStr +=  PrintfResult;

            if (DecodeLayer) {
                PrintfResult=DecodeIFrm(pFrameBuf + 2, pEndBuf,pOutStr,OutputBufferSizeInCharacters);

                if (PrintfResult < 0) {

                    goto BufferToSmall;
                }

                OutputBufferSizeInCharacters-=PrintfResult;
                pOutStr +=  PrintfResult;

            }
            break;
            
        case IRLAP_S_FRM:
            *pFrameType =  IRLAP_GET_SCNTL(*Cntl);
            
            switch (IRLAP_GET_SCNTL(*Cntl))
            {
                case IRLAP_RR:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters, ("RR %s %c nr:%01d"),
                                        CRStr, PFChar, Nr);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    break;
                    
                case IRLAP_RNR:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters, ("RNR %s %c nr:%01d"),
                                        CRStr, PFChar, Nr);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;


                    break;
                    
                case IRLAP_REJ:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters, ("REJ %s %c nr:%01d"),
                                        CRStr, PFChar, Nr);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;


                    break;

                case IRLAP_SREJ:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters, ("SREJ %s %c nr:%01d"),
                                        CRStr, PFChar, Nr);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;


                    break;
                default:
                    PrintfResult=BadFrame(pFrameBuf, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

            }


            break;
            
        case IRLAP_U_FRM:
            *pFrameType =  IRLAP_GET_UCNTL(*Cntl);
            switch (IRLAP_GET_UCNTL(*Cntl))
            {
                case IRLAP_UI:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,("UI %s %c "),
                                        CRStr, PFChar);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    PrintfResult=RawDump(pFrameBuf + 2, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    break;
         
                case IRLAP_XID_CMD:
                case IRLAP_XID_RSP:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,("XID %s %c "),
                                          CRStr, PFChar);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    if (DecodeLayer) {

                        PrintfResult=DecodeXID(pFrameBuf + 2, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

                        if (PrintfResult < 0) {

                            goto BufferToSmall;
                        }

                        OutputBufferSizeInCharacters-=PrintfResult;
                        pOutStr +=  PrintfResult;
                    }

                    break;

                case IRLAP_TEST:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters, ("TEST %s %c "),
                                       CRStr, PFChar);
                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                              ("sa:%02X%02X%02X%02X da:%02X%02X%02X%02X "),
                                         UAFormat->SrcAddr[0],
                                         UAFormat->SrcAddr[1],
                                         UAFormat->SrcAddr[2],
                                         UAFormat->SrcAddr[3],
                                         UAFormat->DestAddr[0],
                                         UAFormat->DestAddr[1],
                                         UAFormat->DestAddr[2],
                                         UAFormat->DestAddr[3]);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    PrintfResult=RawDump(pFrameBuf + 1 + sizeof(UA_FORMAT), pEndBuf,
                            pOutStr,OutputBufferSizeInCharacters);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    break;
                    
                case IRLAP_SNRM:
                    if (CRBit == _IRLAP_CMD)
                    {
                        PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,("SNRM %s %c "),
                                            CRStr,PFChar);

                        if (PrintfResult < 0) {

                            goto BufferToSmall;
                        }

                        OutputBufferSizeInCharacters-=PrintfResult;
                        pOutStr +=  PrintfResult;

                        if ((UCHAR *) SNRMFormat < pEndBuf)
                        {
                            PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                                            ("sa:%02X%02X%02X%02X da:%02X%02X%02X%02X ca:%02X "),
                                            SNRMFormat->SrcAddr[0],
                                            SNRMFormat->SrcAddr[1],
                                            SNRMFormat->SrcAddr[2],
                                            SNRMFormat->SrcAddr[3],
                                            SNRMFormat->DestAddr[0],
                                            SNRMFormat->DestAddr[1],
                                            SNRMFormat->DestAddr[2],
                                            SNRMFormat->DestAddr[3],
                                            // CRBit stored in conn addr
                                            // according to spec... 
                                            (SNRMFormat->ConnAddr) >>1);

                            if (PrintfResult < 0) {

                                goto BufferToSmall;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;

                            if (DecodeLayer) {
                                PrintfResult=DecodeNegParms(&(SNRMFormat->FirstPI),
                                               pEndBuf, pOutStr,OutputBufferSizeInCharacters);

                                if (PrintfResult < 0) {

                                    goto BufferToSmall;
                                }

                                OutputBufferSizeInCharacters-=PrintfResult;
                                pOutStr +=  PrintfResult;


                            }
                        }
                    }
                    else {
                        PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,
                                            ("RNRM %s %c "),CRStr,PFChar);
                        if (PrintfResult < 0) {

                            goto BufferToSmall;
                        }

                        OutputBufferSizeInCharacters-=PrintfResult;
                        pOutStr +=  PrintfResult;

                    }
                    break;
                    
                case IRLAP_DISC:
                    if (CRBit == _IRLAP_CMD) {
                        PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,("DISC %s %c "),
                                           CRStr, PFChar);
                    } else {
                        PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,("RD %s %c "),
                                           CRStr, PFChar);
                    }

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    break;
                    
                case IRLAP_UA:
                    PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                                        ("UA %s %c "),CRStr,PFChar);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;


                    if ((UCHAR *) UAFormat < pEndBuf)
                    {
                        PrintfResult= _snprintf(pOutStr,OutputBufferSizeInCharacters,
                              ("sa:%02X%02X%02X%02X da:%02X%02X%02X%02X "),
                                         UAFormat->SrcAddr[0],
                                         UAFormat->SrcAddr[1],
                                         UAFormat->SrcAddr[2],
                                         UAFormat->SrcAddr[3],
                                         UAFormat->DestAddr[0],
                                         UAFormat->DestAddr[1],
                                         UAFormat->DestAddr[2],
                                         UAFormat->DestAddr[3]);

                        if (PrintfResult < 0) {

                            goto BufferToSmall;
                        }

                        OutputBufferSizeInCharacters-=PrintfResult;
                        pOutStr +=  PrintfResult;


                        if (DecodeLayer)  {
                            PrintfResult=DecodeNegParms(&(UAFormat->FirstPI), pEndBuf,
                                           pOutStr,OutputBufferSizeInCharacters);

                            if (PrintfResult < 0) {

                                goto BufferToSmall;
                            }

                            OutputBufferSizeInCharacters-=PrintfResult;
                            pOutStr +=  PrintfResult;


                         }
                    }
                    break;
                    
                case IRLAP_FRMR:
                    PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,("FRMR %s %c "),
                                       CRStr, PFChar);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    PrintfResult=RawDump(pFrameBuf + 2, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    break;                    
                case IRLAP_DM:
                    PrintfResult= _snprintf(pOutStr, OutputBufferSizeInCharacters,("DM %s %c "),
                                       CRStr, PFChar);
                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

                    break;                   
 
                default:

                    PrintfResult=BadFrame(pFrameBuf, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

                    if (PrintfResult < 0) {

                        goto BufferToSmall;
                    }

                    OutputBufferSizeInCharacters-=PrintfResult;
                    pOutStr +=  PrintfResult;

            }
            break;
        default:
            *pFrameType = -1;
            PrintfResult=BadFrame(pFrameBuf, pEndBuf, pOutStr,OutputBufferSizeInCharacters);

            if (PrintfResult < 0) {

                goto BufferToSmall;
            }

            OutputBufferSizeInCharacters-=PrintfResult;
            pOutStr +=  PrintfResult;

    }
    *pOutStr = 0;

    return (First);

BufferToSmall:

    *First='\0';

    return (First);


}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irutil\refcnt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refcnt.c

Abstract:

    This module exports Reference Counting support functions. By 
    including a Reference Count Control Block (REF_CNT) in a
    dynamic type, and using this API, a Reference scheme can be
    implemented for that type.

Author:

    Edward Buchwalter (v-edbuc)    14-Aug-1996

Revision History:

--*/

//
// Include Files
//

#include "irda.h"

#undef offsetof
#include "refcnt.tmh"

#define EXPAND_TAG(t)   ((CHAR *)(&Tag))[0],((CHAR *)(&Tag))[1],((CHAR *)(&Tag))[2],((CHAR *)(&Tag))[3]
VOID
ReferenceInit 
(
    IN PREF_CNT pRefCnt,
    PVOID       InstanceHandle,
    VOID        (*DeleteHandler)( PVOID )
)

/*++

Routine Description:

    ReferenceInit initializes and adds one reference to the
    supplied Reference Control Block. If provided, an instance
    handle and delete handler are saved for use by the ReferenceRemove 
    function when all references to the instance are removed.

Arguments:

    pRefCnt - pointer to uninitialized Reference Control Block
    InstanceHandle - handle to the managed instance.
    DeleteHandler - pointer to delete function, NULL is OK.

Return Value:

    The function's value is VOID.

--*/

{
    DEBUGMSG( DBG_REF,( TEXT("ReferenceInit( 0x%p, 0x%p, 0x%p )\n"),
    pRefCnt, InstanceHandle, DeleteHandler ));
    ASSERT( pRefCnt );

    // Set the reference to 1 and save the instance 
    // handle and the delete handler.

    pRefCnt->Count         = 0;
    pRefCnt->Instance      = InstanceHandle;
    pRefCnt->DeleteHandler = DeleteHandler;
    
#if DBG
    pRefCnt->Sig = REF_SIG;

    RtlZeroMemory(pRefCnt->Tags, sizeof(REF_TAG) * TAG_CNT);
    
    pRefCnt->Tags[0].Tag = 'LTOT';
    
    CTEInitLock(&pRefCnt->Lock);
    
#endif
        
}

VOID
ReferenceAdd
(
    IN  PREF_CNT pRefCnt
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    ASSERT( pRefCnt );

    InterlockedIncrement(&pRefCnt->Count);
//    DEBUGMSG( DBG_REF,( TEXT("R+%d\n"), pRefCnt->Count ));    
}

VOID
ReferenceAddCount
(
    IN  PREF_CNT    pRefCnt,
    IN  UINT        Count
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    ASSERT( pRefCnt->Count > 0 );

    CTEInterlockedExchangeAdd(&pRefCnt->Count, Count);
}

VOID
ReferenceRemove 
(
    IN PREF_CNT  pRefCnt
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    ASSERT( pRefCnt );

    // Trap remove reference on a zero count

    ASSERT( pRefCnt->Count > 0 );

    // If the decremented count is non zero return the instance handle

    if (InterlockedDecrement(&pRefCnt->Count) > 0 )
    {
//        DEBUGMSG( DBG_REF,( TEXT("R-%d\n"), pRefCnt->Count ));        
//        DEBUGMSG( DBG_REF,( TEXT("ReferenceRemove:remaining: %d\n"), pRefCnt->Count ));
        return;
    }

    // Delete this instance if a delete handler is available

    if( pRefCnt->DeleteHandler )
    {
        DEBUGMSG( DBG_REF,( TEXT("Executing DeleteHandler\n") ));

        (pRefCnt->DeleteHandler)( pRefCnt->Instance );
    }

    // Indicate no active references to this instance

    return;
}

//
// API Test Support
//

#if DBG
#if 0
VOID
ReferenceApiTest( VOID )
{
REF_CNT  RefCnt;

    DEBUGMSG( DBG_REF,( TEXT("\nReferenceApiTest\n") ));
    DEBUGMSG( DBG_REF,( TEXT("\nTest #1: NULL delete handler\n") ));

    ReferenceInit( &RefCnt, &RefCnt, NULL );

    ReferenceAdd( &RefCnt );
    ReferenceAdd( &RefCnt );
    ReferenceAdd( &RefCnt );

    while( ReferenceRemove( &RefCnt ) )
    {
        ;
    }

    DEBUGMSG( DBG_REF,( TEXT("\nTest #2: Delete Handler - TBD\n") ));
}
#endif
VOID
ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    
    ASSERT(pRefCnt->Sig == REF_SIG);
    
    DEBUGMSG(DBG_REF, (TEXT("IRREF: add %p (%c%c%c%c) %d\n"),
             pRefCnt, (char)Tag,(char)(Tag>>8),(char)(Tag>>16),(char)(Tag>>24), pRefCnt->Count));
    
    CTEGetLock(&pRefCnt->Lock, &hLock);
    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == 0 || pRefCnt->Tags[i].Tag == Tag)
        {
            pRefCnt->Tags[i].Tag = Tag;
            InterlockedIncrement(&pRefCnt->Tags[i].Count);
            break;
        }
    }
    
    ASSERT(i < TAG_CNT);
    
    InterlockedIncrement(&pRefCnt->Tags[0].Count);
    
    InterlockedIncrement(&pRefCnt->Count);
    
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);

    // sanity check
/*    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }

    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgBreakPoint();
    }        
    

*/    
    CTEFreeLock(&pRefCnt->Lock, hLock);
}

VOID
ReferenceRemoveDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;
    
    ASSERT(pRefCnt->Sig == REF_SIG);

    DEBUGMSG(DBG_REF, (TEXT("IRREF: remove %p (%c%c%c%c) %d\n"),
             pRefCnt, (char)Tag, (char)(Tag>>8), (char)(Tag>>16), (char)(Tag>>24), pRefCnt->Count));
             
    CTEGetLock(&pRefCnt->Lock, &hLock);
        
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;
            
            ASSERT(pRefCnt->Tags[i].Count > 0);
            
            InterlockedDecrement(&pRefCnt->Tags[i].Count);
            if (pRefCnt->Tags[i].Count == 0)
                pRefCnt->Tags[i].Tag = Tag; 
            break;
        }
    }

    ASSERT(FoundIt);
  
    ASSERT(pRefCnt->Tags[0].Count > 0);
        
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);
      
    InterlockedDecrement(&pRefCnt->Tags[0].Count);
    
    if (InterlockedDecrement(&pRefCnt->Count) > 0 )
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);
    } 
    else if (pRefCnt->DeleteHandler)
    {
        DEBUGMSG( DBG_REF,( TEXT("Executing DeleteHandler\n") ));
        
        CTEFreeLock(&pRefCnt->Lock, hLock);
        
        (pRefCnt->DeleteHandler)( pRefCnt->Instance );
    }
    else
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);   
    }
        
/*
    // sanity check
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }
    
    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgPrint(TEXT("Tag %X, RefCnt %p, perArray %d, total %d\n"), Tag, pRefCnt,
                  TotalPerArray, pRefCnt->Tags[0].Count);
                  
        DbgBreakPoint();
    }    
    

*/    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irutil\dbgmsg.c ===
#if DBG
#include <irda.h>
#include <dbgmsg.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

CHAR         DbgMsgs[DBG_MSG_CNT][MAX_MSG_LEN];
UINT         First, Last;
CTETimer     DbgTimer;
BOOLEAN      TimerRunning;
CTELock      DbgLock;
PIRP         pDbgIrp;
UCHAR        *IrpBuf;
ULONG        IrpBufLen;
ULONG        IrpBufWritten;

VOID DbgTimerExp(CTEEvent *Event, void *Arg);

VOID
DbgMsgInit()
{
    
    pDbgIrp = NULL;
    First = 0;
    Last = 0;
    TimerRunning = FALSE;
    
    CTEInitLock(&DbgLock);
    
    CTEInitTimer(&DbgTimer);
} 

VOID
DbgMsgUninit()
{
    CTELockHandle   LockHandle;
    KIRQL           Irql;

    CTEGetLock(&DbgLock, &LockHandle);

    if (pDbgIrp)
    {
        IoAcquireCancelSpinLock(&Irql);
             
        IoSetCancelRoutine(pDbgIrp, NULL);
    
        IoReleaseCancelSpinLock(Irql);    
        
        pDbgIrp->IoStatus.Information = 0;
        pDbgIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

DbgPrint("Complete irp!\n");
    	IoCompleteRequest(pDbgIrp, IO_NO_INCREMENT);
        
        pDbgIrp = NULL;
    }
    
    CTEFreeLock(&DbgLock, LockHandle);         
}
VOID
DbgMsg(CHAR *Format, ...)
{
    va_list         Args;
    CTELockHandle   LockHandle;
    CHAR            Temp[MAX_MSG_LEN];
    LARGE_INTEGER   Time;
    ULONG           UlongTime;

    KeQueryTickCount(&Time);

    //
    //  change it milliseconds and stuff it in a dword
    //
    UlongTime=(ULONG)((Time.QuadPart * KeQueryTimeIncrement()) / 10000);

    sprintf(Temp,"%6d.%03d - ",UlongTime/1000, UlongTime%1000);

    va_start(Args, Format);
    
    vsprintf(&Temp[strlen(Temp)], Format, Args);
        
    if (DbgOutput & DBG_OUTPUT_DEBUGGER)
    {
        DbgPrint(Temp);
    }
        
    if (DbgOutput & DBG_OUTPUT_BUFFER)
    {
        CTEGetLock(&DbgLock, &LockHandle);
    
        strcpy(DbgMsgs[Last], Temp);
        
        Last++;
    
        if (Last == DBG_MSG_CNT)
            Last = 0;
        
        if (First == Last)
        {
            First++;
            if (First == DBG_MSG_CNT)
                First = 0;
        }            
    
        if (pDbgIrp && !TimerRunning)
        {
            CTEStartTimer(&DbgTimer, DBG_TIMER_INTERVAL,
                      DbgTimerExp, NULL);
            TimerRunning = TRUE;
        }
 
        CTEFreeLock(&DbgLock, LockHandle); 
    }    
    
    va_end(Args);    
}

NTSTATUS
FillDbgIrp(UCHAR Msg[])
{
    NTSTATUS Status = STATUS_PENDING;
    UINT i;
    
    if ((IrpBufLen - IrpBufWritten) < MAX_MSG_LEN)
    {
        Status = STATUS_SUCCESS;
    }
    else
    {
        Msg[MAX_MSG_LEN - 1] = 0; // just to be sure
        
        i = 0;
    
        while (1) 
        {
            IrpBuf[IrpBufWritten++] = Msg[i];            
            
            if (Msg[i] == 0)
                break;
            i++;
        }        
    }

    return Status;
}        

VOID CancelDbgIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP pIrp)
{
//    DbgPrint("CancelDbgIrp %x\n", pIrp);
    
    pDbgIrp = NULL;
    
    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;
    
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
}

NTSTATUS
DbgMsgIrp(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp)
{
    CTELockHandle   LockHandle;
    NTSTATUS        Status = STATUS_PENDING;    

    if (pDbgIrp != NULL)
        return STATUS_DEVICE_BUSY;
        
    CTEGetLock(&DbgLock, &LockHandle);
    
    IrpBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    IrpBufWritten = 0;
    
    if (IrpBufLen < MAX_MSG_LEN)
    {
        CTEFreeLock(&DbgLock, LockHandle); 
        return STATUS_BUFFER_OVERFLOW;
    }
    
    IrpBuf = pIrp->AssociatedIrp.SystemBuffer;    
        
    while (First != Last)
    {
        Status = FillDbgIrp(DbgMsgs[First]);
        
        if (Status == STATUS_SUCCESS)
            break;

        First++;
        if (First == DBG_MSG_CNT)
            First = 0;
    }
    
    
    if (Status == STATUS_SUCCESS)
    {
        pIrp->IoStatus.Information = IrpBufWritten;
    }
    else if (Status == STATUS_PENDING)
    {
        KIRQL           Irql;
        PDRIVER_CANCEL  PrevCancel;
                
        pDbgIrp = pIrp;
     
        IoMarkIrpPending(pIrp);
     
        IoAcquireCancelSpinLock(&Irql);       
            
        PrevCancel = IoSetCancelRoutine(pIrp, CancelDbgIrp);
            
        CTEAssert(PrevCancel == NULL);
            
        IoReleaseCancelSpinLock(Irql);
        
        if (IrpBufWritten != 0)
        {
            CTEStartTimer(&DbgTimer, DBG_TIMER_INTERVAL,
                      DbgTimerExp, NULL);
                      
            TimerRunning = TRUE;          
        }              
    }

    CTEFreeLock(&DbgLock, LockHandle); 
    
    //DbgPrint("DbgIrp status %x, bw %d, irp %x\n", Status, IrpBufWritten, pIrp);    
    return Status;
}

VOID
DbgTimerExp(CTEEvent *Event, void *Arg)
{
    CTELockHandle   LockHandle;
    PIRP            pIrp;
    KIRQL           Irql;
    
//DbgPrint("Texp\n");
    
    if (pDbgIrp == NULL)
    {
        DbgPrint("DbgIrp is null\n");
        return;
    }    
        
    IoAcquireCancelSpinLock(&Irql);
             
    IoSetCancelRoutine(pDbgIrp, NULL);
    
    IoReleaseCancelSpinLock(Irql);
    
    if (pDbgIrp->Cancel)
    {
        DbgPrint("DbgIrp is being canceled\n");
        pDbgIrp = NULL;
        return;
    }    


    CTEGetLock(&DbgLock, &LockHandle);
        
    TimerRunning = FALSE;
    
    while (First != Last)
    {
        if (FillDbgIrp(DbgMsgs[First]) == STATUS_SUCCESS)
            break;

        First++;
        if (First == DBG_MSG_CNT)
            First = 0;        
    }

    pIrp = pDbgIrp;
    
    pDbgIrp = NULL;

    CTEFreeLock(&DbgLock, LockHandle); 
    
    pIrp->IoStatus.Information = IrpBufWritten;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

  //  DbgPrint("Comp bw %d, irp %x\n", IrpBufWritten, pIrp);

	IoCompleteRequest(pIrp, IO_NO_INCREMENT);    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\irxfer.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       irxfer.cxx
//
//--------------------------------------------------------------------------

/*
 *  IRXFER.C
 *
 */

#include "precomp.h"
#include <malloc.h>

#include <devlist.h>

#include <irmon.h>
#include <irmonftp.h>

#ifndef  VOLATILE
#define  VOLATILE  volatile
#endif



//
struct SAVED_IRDA_DEVICE_LIST
{
    unsigned            MaxDevices;
    OBEX_DEVICE_LIST    Devices;
};

typedef struct _IRXFER_CONTROL {

    CRITICAL_SECTION    Lock;

    PVOID               IrmonContext;
    SET_SOUND_STATUS_FN SoundStatusCallback;


    PXFER_LIST          TransferList;

    FILE_TRANSFER      *IrTransfer1;
    FILE_TRANSFER      *IrTransfer2;

}   IRXFER_CONTROL, *PIRXFER_CONTROL;

IRXFER_CONTROL    GlobalControl;


//
// Handle for irmon.dll (see ..\irmon\irmon.c).
//
extern "C" HINSTANCE    ghInstance;

//
// Entry points for IrTran-P
//
#ifdef IRTRANP_ENABLED

#include <irtranpp.h>


static HANDLE g_hIrTranPThread = NULL;

#endif

//
// registry entries
//
const wchar_t * const WSZ_REG_KEY            = L"Control Panel\\Infrared";
const wchar_t * const WSZ_REG_KEY_GLOBAL     = L"Control Panel\\Infrared\\Global";
const wchar_t * const WSZ_REG_KEY_XFER       = L"Control Panel\\Infrared\\File Transfer";

#ifdef IRTRANP_ENABLED
const wchar_t * const WSZ_REG_KEY_IRTRANP    = L"Control Panel\\Infrared\\IrTranP";
#endif

const wchar_t * const WSZ_REG_SHOW_UI       = L"PopupApp";
const wchar_t * const WSZ_REG_ALLOW_RECEIVE = L"AllowSend";
const wchar_t * const WSZ_REG_SHOW_TRAY     = L"ShowTrayIcon";
const wchar_t * const WSZ_REG_PLAY_SOUND    = L"PlaySound";
const wchar_t * const WSZ_REG_RECEIVED_FILES_FOLDER = L"RecvdFilesLocation";

#ifdef IRTRANP_ENABLED
const wchar_t * const WSZ_REG_PICTURES_FOLDER   = L"RecvdFilesLocation";
const wchar_t * const WSZ_REG_DISABLE_IRTRANPV1 = L"DisableIrTranPv1";
const wchar_t * const WSZ_REG_DISABLE_IRCOMM    = L"DisableIrCOMM";
const wchar_t * const WSZ_REG_EXPLORE           = L"ExploreOnCompletion";
const wchar_t * const WSZ_REG_SAVEASUPF         = L"SaveAsUPF";

const wchar_t * const WSZ_DEFAULT_MYPICTURES    = L"C:\\My Pictures";
#endif


SET_TRAY_STATUS_FN   g_SetTrayStatus;

HKEY    g_hUserKey;
HKEY    g_hInfraredKey;
HKEY    g_hGlobalKey  ;
HKEY    g_hFileXferKey;

#ifdef IRTRANP_ENABLED
HKEY    g_hIrTranPXferKey = 0;
BOOL    g_fIrTranPv1Disabled = FALSE;
BOOL    g_fIrCOMMDisabled = TRUE;
BOOL    g_fExploreOnCompletion = TRUE;
BOOL    g_fSaveAsUPF = FALSE;
#endif


HANDLE  g_RegistryEvent;


MUTEX * g_Mutex;

struct SAVED_IRDA_DEVICE_LIST * g_DeviceList;

wchar_t g_ReceivedFilesFolder  [ MAX_PATH ];
wchar_t g_DuplicateFileTemplate[ MAX_PATH ];
wchar_t g_DesktopFolder        [ MAX_PATH ];

wchar_t g_UnknownDeviceName    [ 100 ];

#ifdef IRTRANP_ENABLED
wchar_t g_DefaultPicturesFolder[ MAX_PATH ];
wchar_t g_SpecifiedPicturesFolder[ MAX_PATH ];
#endif



HANDLE  g_RegistryWaitHandle = 0;

void
RegistryMonitorCallback(
                      PVOID   ignore,
                      BOOLEAN unknown
                      );

BOOL Uninit_RegistryCallback();



RPC_BINDING_HANDLE rpcBinding = 0;

BOOL fListen = TRUE;

BOOL g_fAllowReceives = FALSE;
BOOL g_fShowTrayIcon  = TRUE;
BOOL g_fShutdown      = FALSE;
BOOL g_fLogoff        = FALSE;
BOOL g_fRegistryWaitComplete = FALSE;



void __stdcall
ProcessRegistryChange();

unsigned long
RegistryMonitorThread(
                      PVOID ignore
                      );

DWORD ReadUserPreferences();




extern "C"
{
BOOL
ShowSendWindow();

BOOL
ShowPropertiesPage();



} // extern "c"

VOID
RemoveFromTransferList(
    FILE_TRANSFER*   Transfer
    )
{

    RemoveTransferFromList(GlobalControl.TransferList,Transfer);
    return;
}





BOOL
InitializeIrxfer(
    PVOID               IrmonContext,
    SET_TRAY_STATUS_FN  y,
    SET_SOUND_STATUS_FN SoundStatusCallback,
    PVOID              *IrxferContext
    )

{
    BOOL b;
    DWORD status = 0;


    g_DefaultPicturesFolder[0]='\0';
    g_DesktopFolder[0]='\0';

    ZeroMemory(&GlobalControl,sizeof(GlobalControl));

    GlobalControl.IrmonContext=IrmonContext;

    GlobalControl.SoundStatusCallback=SoundStatusCallback;

    InitializeCriticalSection(&GlobalControl.Lock);

    *IrxferContext=&GlobalControl;


    g_fShutdown = FALSE;

    g_SetTrayStatus  = y;


    //
    // Event logging. This will make sure that the system event
    // logging is configured in the registry:
    //
    status = EVENT_LOG::CheckConfiguration( WS_EVENT_SOURCE,
                                            WS_CATALOG_PATH,
                                            CATEGORY_COUNT,
                                            0x7 );
    #ifdef DBG_ERROR
    if (dwEventStatus)
        {
        DbgPrint("IrMon: EVENT_LOG::CheckConfiguration() failed: %d\n",
                 status );
        }
    #endif

    if (!LoadString( ghInstance,
                     IDS_DUPLICATE_FILE_PATTERN,
                     g_DuplicateFileTemplate,
                     sizeof(g_DuplicateFileTemplate) / sizeof(WCHAR)
                     ))
        {
#if DBG
        DbgPrint("InitializeIrxfer(): LoadString(1) failed\n");
#endif
        goto abend;
    }

    if (!LoadString( ghInstance,
                     IDS_UNKNOWN_DEVICE2,
                     g_UnknownDeviceName,
                     sizeof(g_UnknownDeviceName) / sizeof(WCHAR)
                     ))
        {
#if DBG
        DbgPrint("InitializeIrxfer(): LoadString(2) failed\n");
#endif

        goto abend;
    }

    GlobalControl.TransferList=CreateXferList();

    if (GlobalControl.TransferList == NULL) {

#if DBG
        DbgPrint("InitializeIrxfer(): CreateXferList() failed\n");
#endif

        goto abend;
    }


    g_Mutex = new MUTEX(&status);
    if (!g_Mutex || status)
        {
        goto abend;
        }

    if (FAILED( SHGetFolderPath( NULL,
                                 CSIDL_DESKTOPDIRECTORY,
                                 NULL,
                                 0,
                                 g_DesktopFolder)))
        {

#if DBG
        DbgPrint("InitializeIrxfer(): SHGetFolderPath(desktop) failed\n");
#endif

        goto abend;
    }

    g_RegistryEvent = CreateEvent( NULL,    // no security
                                   FALSE,    // auto-reset
                                   FALSE,   // initially FALSE
                                   NULL     // no name
                                   );
    if (!g_RegistryEvent) {

#if DBG
        DbgPrint("InitializeIrxfer(): CreateEvent() failed\n");
#endif


        goto abend;
    }

    g_hIrTranPThread=StartIrTranP();
    if (g_hIrTranPThread == NULL)
    {
#if DBG
        DbgPrint("InitializeIrxfer(): StartIrTranP() failed\n");
#endif

        goto abend;
    }


    if (ReadUserPreferences() != 0)
    {
        // force Uninit_RegistryCallback to properly terminate registry watcher thread.
        g_fShutdown = true;
        goto abend;
    }

    return TRUE;

abend:

    DWORD     dwEventStatus = 0;
    EVENT_LOG EventLog(WS_EVENT_SOURCE,&dwEventStatus);

    if (!dwEventStatus)
        {
        EventLog.ReportError(CAT_IRXFER, MC_IRXFER_SETUP_FAILED, GetLastError());
        }

    if (GlobalControl.TransferList != NULL) {

        DeleteXferList(GlobalControl.TransferList);
    }

    delete g_Mutex;


    if (g_RegistryEvent)
        {
        Uninit_RegistryCallback();
        }
    return FALSE;
}

DWORD
ReadUserPreferences()
{

    DbgLog(SEV_INFO, "ReadUserPreferences");


    //
    // Open all our keys.  If we can't open the user's key
    // or the key to watch for changes, we bail.
    //
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      NULL,
                      0,
                      KEY_READ,
                      &g_hUserKey
                      ))
        {
        DbgLog1(SEV_WARNING, "RegOpenKey  failed %d",  GetLastError());
        return GetLastError();
        }

    DWORD Disposition;
    if (RegCreateKeyEx( g_hUserKey,
                        WSZ_REG_KEY,
                        0,                      // reserved MBZ
                        0,                      // class name
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        0,                      // security attributes
                        &g_hInfraredKey,
                        &Disposition
                        ))
        {
        DbgLog2(SEV_WARNING, "RegCreateKey '%S' failed %d", WSZ_REG_KEY, GetLastError());
        return GetLastError();
        }

    #ifdef IRTRANP_ENABLED
    RegOpenKeyEx( g_hUserKey,
                  WSZ_REG_KEY_IRTRANP,
                  0,
                  KEY_READ,
                  &g_hIrTranPXferKey );
    #endif


    //
    // Start the registry snoop.
    //
    RegistryMonitorCallback(0, 0);
    
    BOOL            bResult;
    GlobalControl.IrTransfer1=InitializeSocket( SERVICE_NAME_1);
    if (GlobalControl.IrTransfer1 != NULL) {

        bResult=AddTransferToList(GlobalControl.TransferList,GlobalControl.IrTransfer1);

        if (!bResult) {

            GlobalControl.IrTransfer1->StopListening();
            GlobalControl.IrTransfer1=NULL;
        }
    }

    GlobalControl.IrTransfer2=InitializeSocket(SERVICE_NAME_2);
    if (GlobalControl.IrTransfer2 != NULL) {

        bResult=AddTransferToList(GlobalControl.TransferList,GlobalControl.IrTransfer2);

        if (!bResult) {

            GlobalControl.IrTransfer2->StopListening();
            GlobalControl.IrTransfer2=NULL;
        }
    }

    if (GlobalControl.IrTransfer1 == NULL && GlobalControl.IrTransfer2 == NULL)
    {
        DbgPrint("IrMon: ReadUserPreferences::Failed to init sockets\n");
        return -1;
    }
    
    return 0;
}

void
_UserLoggedOff( handle_t rpc,
                error_status_t __RPC_FAR * pStatus
                )
{
    error_status_t status = 0;

    //
    // Allow only a single notification at a time, to avoid odd race conditions.
    //
    CLAIM_MUTEX Lock( g_Mutex );

    DbgLog(SEV_INFO, "user logged off");

    g_fLogoff = TRUE;
    g_fAllowReceives = FALSE;

    if (GlobalControl.IrTransfer1 != NULL) {

        RemoveTransferFromList(GlobalControl.TransferList,GlobalControl.IrTransfer1);

        GlobalControl.IrTransfer1->StopListening();
        GlobalControl.IrTransfer1=NULL;
    }

    if (GlobalControl.IrTransfer2 != NULL) {

        RemoveTransferFromList(GlobalControl.TransferList,GlobalControl.IrTransfer2);

        GlobalControl.IrTransfer2->StopListening();
        GlobalControl.IrTransfer2=NULL;
    }



    //
    // Close down the registry watcher.
    //
    if (g_RegistryWaitHandle)
        {
        if (FALSE == UnregisterWait( g_RegistryWaitHandle ))
            {
            while (!*((BOOL volatile *)&g_fRegistryWaitComplete))
                {
                Sleep(1000);
                }
            }

        g_RegistryWaitHandle = 0;
        }

    g_fRegistryWaitComplete = FALSE;



    //
    // Close the registry handles.
    //
    RegCloseKey( g_hUserKey );
    g_hUserKey = 0;

    RegCloseKey( g_hFileXferKey );
    g_hFileXferKey = 0;

    #ifdef IRTRANP_ENABLED
    RegCloseKey( g_hIrTranPXferKey );
    g_hIrTranPXferKey = 0;
    #endif

    RegCloseKey( g_hInfraredKey );
    g_hInfraredKey = 0;

    RegCloseKey( g_hGlobalKey );
    g_hGlobalKey   = 0;

    *pStatus = 0;

    g_fLogoff = FALSE;
}


#ifdef IRTRANP_ENABLED
//--------------------------------------------------------------------
//  RegistryCheckDwordFlag()
//
//  Check to see if the specified registry key value has changed,
//  if so, then update the value and return TRUE.
//--------------------------------------------------------------------
BOOL RegistryCheckDwordFlag( IN  HKEY         hKey,
                             IN  const WCHAR *pwszValueName,
                             IN       BOOL   NotPresentValue,
                             OUT BOOL        *pbValue )
{
    BOOL  fChanged = FALSE;
    DWORD dwStatus = 0;
    DWORD dwRegDword;
    DWORD dwSize = sizeof(dwRegDword);

    dwStatus = RegQueryValueEx( hKey,
                                pwszValueName,
                                NULL,
                                NULL,
                                (UCHAR*)&dwRegDword,
                                &dwSize );

    if (dwStatus != ERROR_SUCCESS) {
        //
        //  failed, no change
        //
        DbgLog2(SEV_INFO,"REG: Key/Value: %S: Status: %d\n",
                pwszValueName, dwStatus );

        if (NotPresentValue != *pbValue) {
            //
            //  the not present value is no the same as the current, change and report a change
            //
            *pbValue=NotPresentValue;

            return TRUE;
        }
        //
        //  No change
        //
        return FALSE;

    } else {
        //
        //  got value
        //
        if ( (dwRegDword) && (*pbValue == FALSE)) {
            //
            // Value changed from FALSE to TRUE.
            //
            fChanged = TRUE;
            *pbValue = TRUE;

        } else  if ((!dwRegDword) && (*pbValue)) {
            //
            // Value changed from TRUE to FALSE.
            //
            fChanged = TRUE;
            *pbValue = FALSE;
        }

    }

    return fChanged;
}

//--------------------------------------------------------------------
//  IrTranPFlagChanged()
//
//  Check to see if the specified registry flag changed. If the value
//  changed, return TRUE, if not then return FALSE. Return the new value
//  in *pfDisabled.
//--------------------------------------------------------------------
BOOL IrTranPFlagChanged( IN const WCHAR *pwszDisabledValueName,
                         IN       BOOL   NotPresentValue,
                         IN OUT   BOOL  *pfDisabled )
    {
    DWORD dwStatus = 0;
    DWORD dwSize;
    DWORD dwRegDword;
    BOOL  fChanged = FALSE;
    BOOL  fDisabled = *pfDisabled;

    DbgLog3(SEV_INFO, "Process IrTranP flag Change %S, def=%d, current=%d",
        pwszDisabledValueName,
        NotPresentValue,
        *pfDisabled
        );

    if (!g_hIrTranPXferKey)
        {
        // By default, the IrTranP subkey does not exist at all until
        // user brings up Wireless Link CPL and makes changes to
        // to the Image Transfer page. Without trying to reopen the subkey
        // here, we may fail to pick up the changes if this is the first
        // time IrTranP subkey gets created.
        // The other issue that might rise(although rare) is when the subkey
        // is deleted for whatever reasons. We should reset everything to
        // default when the key is deleted. An easy but slow solution is to
        // reopen the subkey everytime this function is called. This approach
        // would ensures that the HKEY to the subkey is always fresh.
        // Since the case is rare and implementation is slow, lets forget
        // about this for the time being. If the entire Infrared subkey is
        // deleted or missing then we will return TRUE (the default is
        // enabled).
        //
        RegOpenKeyEx(g_hUserKey,
                     WSZ_REG_KEY_IRTRANP,
                     0,
                     KEY_READ,
                     &g_hIrTranPXferKey );
        }

    if (!g_hIrTranPXferKey) {

        DbgLog(SEV_INFO, "IrTranP: g_hIrTranPXferKey not opened");

        if (NotPresentValue != *pfDisabled) {
            //
            //  the not present value does not match the current setting, change it
            //
            *pfDisabled=NotPresentValue;
            return TRUE;
        }

        //
        //  it must match, so no change
        //
        return FALSE;

    }

    //
    // Is IrTranP over the specified channel to be disabled?
    //
    if (RegistryCheckDwordFlag(g_hIrTranPXferKey,
                               pwszDisabledValueName,
                               NotPresentValue,
                               &fDisabled))
        {
        #ifdef DBG_REGISTRY
        DbgPrint("DisableIrCOMM: Changed: %d\n",g_fIrCOMMDisabled);
        #endif
        }

    if (*pfDisabled != fDisabled)
        {
        *pfDisabled = fDisabled;
        fChanged = TRUE;
        }

    return fChanged;
    }

//--------------------------------------------------------------------
//  ProcessIrTranPRegistryChanges()
//
//--------------------------------------------------------------------
void ProcessIrTranPRegistryChanges()
    {
    DWORD dwStatus = 0;
    DWORD dwSize;
    DWORD dwRegDword;

    DbgLog(SEV_INFO, "Process IrTranP Registry Change");

    //
    // Is IrTranP over IrCOMM to be disabled?
    //
    if (IrTranPFlagChanged(WSZ_REG_DISABLE_IRCOMM,TRUE,&g_fIrCOMMDisabled))
        {
        #ifdef DBG_REGISTRY
        DbgPrint("DisableIrCOMM: Changed: %d\n",g_fIrCOMMDisabled);
        #endif
        dwStatus = EnableDisableIrCOMM(g_hIrTranPThread,g_fIrCOMMDisabled);

        if ((g_fIrCOMMDisabled == FALSE) && (dwStatus))
            {
            #ifdef DBG_ERROR
            if (dwStatus)
                {
                DbgPrint("IrTranP: EnableDisableIrCOMM() failed: %d\n",dwStatus);
                }
            #endif

            IrTranPEnableIrCOMMFailed(g_hIrTranPThread,dwStatus);
            }
        }

    //
    // Is IrTranP over sockets (IrTranPv1) to be disabled?
    //
    if (IrTranPFlagChanged(WSZ_REG_DISABLE_IRTRANPV1,FALSE,&g_fIrTranPv1Disabled))
        {
        #ifdef DBG_REGISTRY
        DbgPrint("DisableIrTranPv1: Changed: %d\n",g_fIrTranPv1Disabled);
        #endif
        dwStatus = EnableDisableIrTranPv1(g_hIrTranPThread,g_fIrTranPv1Disabled);
        }

    //
    // Explore the new pictures automatically:
    //
    if (RegistryCheckDwordFlag(g_hIrTranPXferKey,
                               WSZ_REG_EXPLORE,
                               TRUE,
                               &g_fExploreOnCompletion))
        {
        #ifdef DBG_REGISTRY
        DbgPrint("ExploreOnCompletion: Changed: %d\n",g_fExploreOnCompletion);
        #endif
        }

    //
    // Save pictures as .UPF files instead of .JPEG files?
    //
    // NOTE: This is used for testing to create full .UPF files and
    // would not normally be set by the customer.
    //
    if (RegistryCheckDwordFlag(g_hIrTranPXferKey,
                               WSZ_REG_SAVEASUPF,
                               FALSE,
                               &g_fSaveAsUPF))
        {
        #ifdef DBG_REGISTRY
        DbgPrint("SaveAsUPF: Changed: %d\n",g_fSaveAsUPF);
        #endif
        }

    //
    // Where pictures are to be stored. If this value exists then it
    // is used instead of the default "My Documents\My Pictures\"
    // path.
    //
    dwSize = sizeof(g_SpecifiedPicturesFolder);
    dwStatus = RegQueryValueEx( g_hIrTranPXferKey,
                                WSZ_REG_PICTURES_FOLDER,
                                NULL,
                                NULL,
                                (UCHAR*)g_SpecifiedPicturesFolder,
                                &dwSize );
    if (dwStatus)
        {
        DbgLog1( SEV_INFO, "REG: Pictures Folder Status: %d\n", dwStatus );
        g_SpecifiedPicturesFolder[0] = 0;
        }
    else
        {
        DbgLog1( SEV_INFO, "REG: Pictures Folder %S\n",
                 g_SpecifiedPicturesFolder );
        #ifdef DBG_REGISTRY
        DbgPrint("RecvdFilesLocation: %S\n",g_SpecifiedPicturesFolder);
        #endif
        }
    }
#endif




//--------------------------------------------------------------------
//  ProcessRegistryChange()
//
//--------------------------------------------------------------------
void __stdcall
ProcessRegistryChange()
{
    DWORD status = 0;

    DWORD size = sizeof(unsigned char);
    unsigned char boolVal = 0;

    DbgLog(SEV_INFO, "process registry change");

    if (!g_hGlobalKey)
        {
        status = RegOpenKeyEx( g_hUserKey,
                               WSZ_REG_KEY_GLOBAL,
                               0,
                               KEY_READ,
                               & g_hGlobalKey
                               );
        if (status)
            {
            DbgLog2(SEV_WARNING, "RegOpenKeyEx '%S' failed %d", WSZ_REG_KEY_GLOBAL, status);
            }
        }

    if (!g_hFileXferKey)
        {
        status = RegOpenKeyEx( g_hUserKey,
                               WSZ_REG_KEY_XFER,
                               0,
                               KEY_READ,
                               & g_hFileXferKey
                               );
        if (status)
            {
            DbgLog2(SEV_WARNING, "RegOpenKeyEx '%S' failed %d", WSZ_REG_KEY_XFER, status);
            }
        }


    //
    // Are other people allowed to send to me?
    //
    size = sizeof(unsigned char);
    status = RegQueryValueEx( g_hFileXferKey,
                              WSZ_REG_ALLOW_RECEIVE,
                              NULL,
                              NULL,
                              &boolVal,
                              &size
                              );
    if (!g_hUserKey)
        {
        g_fAllowReceives = FALSE;
        }
    else if (status || boolVal)
        {
        DbgLog1( SEV_INFO, "reg: allow receives key, status %d\n", status);
        g_fAllowReceives = TRUE;
        }
    else
        {
        g_fAllowReceives = FALSE;
        }

    size = sizeof( g_ReceivedFilesFolder );
    status = RegQueryValueEx( g_hFileXferKey,
                              WSZ_REG_RECEIVED_FILES_FOLDER,
                              NULL,
                              NULL,
                              (unsigned char *) g_ReceivedFilesFolder,
                              &size
                              );
    if (status) {

        StringCbCopy(g_ReceivedFilesFolder,sizeof(g_ReceivedFilesFolder), g_DesktopFolder );
        DbgLog2( SEV_INFO, "reg: received files folder status %d\nfolder %S", status, g_ReceivedFilesFolder);

    } else {
        //
        // normalize the path so that we can compare it to other normalized paths
        //
        WCHAR szNormalized[MAX_PATH];
        DWORD dwLen = GetFullPathName(g_ReceivedFilesFolder, MAX_PATH, szNormalized, NULL);

        if (dwLen != 0 && dwLen < MAX_PATH) {

            StringCbCopy(g_ReceivedFilesFolder,sizeof(g_ReceivedFilesFolder), szNormalized);

        } else {

            StringCbCopy( g_ReceivedFilesFolder,sizeof(g_ReceivedFilesFolder), g_DesktopFolder );
        }

        DbgLog1( SEV_INFO, "reg: received files folder %S\n", g_ReceivedFilesFolder);
    }

    //
    // always end path with a backslash '\'
    //
    if ( bNoTrailingSlash(g_ReceivedFilesFolder) ) {

        StringCbCat(g_ReceivedFilesFolder,sizeof(g_ReceivedFilesFolder), szBACKSLASH );
    }

    size = sizeof(unsigned char);
    status = RegQueryValueEx( g_hGlobalKey,
                              WSZ_REG_SHOW_TRAY,
                              NULL,
                              NULL,
                              &boolVal,
                              &size
                              );
    if (status || boolVal)
        {
        DbgLog1( SEV_INFO, "reg: show tray key, status %d\n", status);
        g_fShowTrayIcon = TRUE;
        }
    else
        {
        g_fShowTrayIcon = FALSE;
        }

    (*g_SetTrayStatus)( GlobalControl.IrmonContext, g_fShowTrayIcon );

    size = sizeof(unsigned char);
    status = RegQueryValueEx( g_hGlobalKey,
                              WSZ_REG_PLAY_SOUND,
                              NULL,
                              NULL,
                              &boolVal,
                              &size
                              );

    if ((status != ERROR_SUCCESS)) {

        DbgLog1( SEV_INFO, "reg: play sound key, status %d\n", status);
        boolVal=TRUE;

    }

    (*GlobalControl.SoundStatusCallback)(
        GlobalControl.IrmonContext,
        boolVal
        );

    //
    // Process changes specific to IrTran-P:
    //
    #ifdef IRTRANP_ENABLED
    ProcessIrTranPRegistryChanges();
    #endif

    //
    // Look for more changes.
    //
    status = RegNotifyChangeKeyValue( g_hInfraredKey,
                                      TRUE,              // watch child keys
                                      REG_NOTIFY_CHANGE_LAST_SET,
                                      g_RegistryEvent,
                                      TRUE               // async
                                      );
    if (status)
        {
        DWORD     dwEventStatus = 0;
        EVENT_LOG EventLog(WS_EVENT_SOURCE,&dwEventStatus);

        if (!dwEventStatus)
            {
            EventLog.ReportError(CAT_IRXFER, MC_IRXFER_REGISTER_NOTIFY_FAILED, status);
            }
        }
}



void
RegistryMonitorCallback(
                      PVOID   ignore,
                      BOOLEAN unknown
                      )
{
    DbgLog(SEV_INFO, "reg callback");

    if (g_fShutdown || g_fLogoff)
        {
        DbgLog(SEV_INFO, "reg callback: terminating");

        if (g_fShutdown)
            {
            CloseHandle( g_RegistryEvent );
            }

        g_fRegistryWaitComplete = TRUE;
        return;
        }

    ProcessRegistryChange();

    if (!RegisterWaitForSingleObject( &g_RegistryWaitHandle,
                                      g_RegistryEvent,
                                      RegistryMonitorCallback,
                                      0,
                                      INFINITE,
                                      WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE
                                      ))
        {
        g_RegistryWaitHandle = 0;

        DWORD     dwEventStatus = 0;
        EVENT_LOG EventLog(WS_EVENT_SOURCE,&dwEventStatus);

        if (!dwEventStatus)
            {
            EventLog.ReportError(CAT_IRXFER, MC_IRXFER_REGISTER_NOTIFY_FAILED, GetLastError());
            }
        }
}



void
UpdateDiscoveredDevices(
    const OBEX_DEVICE_LIST *IrDevices
    )
{
    BOOL fLaunch = FALSE;
    error_status_t status;

    //
    // Update the saved device list.
    //
    SAVED_IRDA_DEVICE_LIST * list;

    g_Mutex->Enter();

    if ((g_DeviceList == NULL)
        ||
        (g_DeviceList->MaxDevices < IrDevices->DeviceCount)) {

        list = (SAVED_IRDA_DEVICE_LIST *)
               new char [ sizeof(SAVED_IRDA_DEVICE_LIST)
                          + (IrDevices->DeviceCount ) * sizeof(OBEX_DEVICE)
                          ];
        if (!list) {

            g_Mutex->Leave();
            return;
        }

        list->MaxDevices = 1+IrDevices->DeviceCount;

        if (g_DeviceList) {

            delete g_DeviceList;
        }

        g_DeviceList = list;

    } else {

        list = g_DeviceList;
    }

    //
    // Determine how many of the existing devices support our protocol.
    //
    list->Devices.DeviceCount=0;

    unsigned i;
    for (i=0; i < IrDevices->DeviceCount; i++) {

        list->Devices.DeviceList[list->Devices.DeviceCount]=IrDevices->DeviceList[i];

        list->Devices.DeviceCount++;

        fLaunch = fLaunch || list->Devices.DeviceList[i].DeviceSpecific.s.Irda.ObexSupport;

    }
    //
    // Inform the UI program of the new device list.  Don't create the process
    // unless at least one of the devices said it supports OBEX.
    //
    if (fLaunch) {

        g_Mutex->Leave();

        LaunchUi( NULL );

    } else {

        if (g_DeviceList->Devices.DeviceCount > 0) {

            _DeviceInRange( rpcBinding, &g_DeviceList->Devices, &status );

            g_Mutex->Leave();

            DbgLog1(SEV_INFO, "UpdateDiscoveredDevices: DeviceInRange returned %d", status);

        } else {

            g_Mutex->Leave();

            _NoDeviceInRange( rpcBinding, &status );
        }
    }
}


BOOL
UninitializeIrxfer(
    PVOID    IrxferContext
    )
{
    PIRXFER_CONTROL    Control=(PIRXFER_CONTROL)IrxferContext;
    error_status_t     LogoffStatus;

    g_fShutdown = TRUE;

    DbgLog1(SEV_INFO, "start shutdown: %d", GetTickCount());


    _UserLoggedOff(NULL,&LogoffStatus);

    if (Control->TransferList != NULL) {

        DeleteXferList(Control->TransferList);
    }


    _ShutdownUi( rpcBinding );

    BOOL fSuccess = TRUE;


    fSuccess &= Uninit_RegistryCallback();

    DbgLog1(SEV_INFO, "after registry: %d", GetTickCount());

    #ifdef IRTRANP_ENABLED
    StopIrTranP(g_hIrTranPThread);
    #endif


#ifdef LOGGING

    Log_Close();

#endif

    DeleteCriticalSection(&Control->Lock);

    return fSuccess;
}


BOOL
Uninit_RegistryCallback()
{
    BOOL fSuccess = TRUE;

    SetEvent( g_RegistryEvent );

    //
    // The handle will be deleted when the callback is completed.
    //
    while (WAIT_TIMEOUT == WaitForSingleObject( g_RegistryEvent, 0 ))
        {
        Sleep(1000);
        }

    return fSuccess;
}



void
_SendFiles(
    handle_t RpcHandle,
    COOKIE   ClientCookie,
    wchar_t  DirectoryName[],
    wchar_t  FileNameList[],
    long   ListLength,
    unsigned long DeviceId,
    OBEX_DEVICE_TYPE    DeviceType,
    error_status_t * pStatus,
    int * pLocation
    )
{
    FILE_TRANSFER * Transfer;

    DbgPrint("IRMON: SendFiles address=%08lx, type=%d\n",DeviceId,DeviceType);

    *pStatus = 0;
    *pLocation = (int)locStartup;

    if ( g_fShutdown )
        {
        *pStatus = ERROR_SHUTDOWN_IN_PROGRESS;
        return;
        }

    if (DirectoryName && *DirectoryName)
        {
        *pStatus = ERROR_ACCESS_DENIED;
        return;
        }

    //
    // Try NT-compatible connect.
    //
    Transfer = new FILE_TRANSFER;
    if (!Transfer || !Transfer->Xfer_Init( FileNameList, ListLength, dialNt5, DeviceType,TRUE,INVALID_SOCKET ))
        {
        delete Transfer;
        *pStatus = ERROR_NOT_ENOUGH_MEMORY;
        return;
        }

    Transfer->_rpcHandle = RpcHandle;
    Transfer->_cookie    = ClientCookie;

    Transfer->BeginSend( DeviceId, DeviceType, pStatus, (FAILURE_LOCATION*)pLocation );

    if (*pStatus == ERROR_INVALID_DATA && *pLocation == locConnect) {

        //
        // Try Win98-compatible connect.
        //
        Transfer = new FILE_TRANSFER;
        if (!Transfer || !Transfer->Xfer_Init( FileNameList, ListLength, dialWin95,DeviceType,TRUE,INVALID_SOCKET ))
            {
            delete Transfer;
            *pStatus = ERROR_NOT_ENOUGH_MEMORY;
            return;
            }

        Transfer->_rpcHandle = RpcHandle;
        Transfer->_cookie    = ClientCookie;

        Transfer->BeginSend( DeviceId, DeviceType, pStatus, (FAILURE_LOCATION*)pLocation );
    }

    if (*pStatus != ERROR_SUCCESS) {

        DWORD     dwEventStatus = 0;
        EVENT_LOG EventLog(WS_EVENT_SOURCE,&dwEventStatus);

        if (!dwEventStatus) {

            EventLog.ReportError(CAT_IRXFER, MC_IRXFER_CONNECT_FAILED, *pStatus);
        }
    } else {
        //
        //  it worked add it to the list
        //

        AddTransferToList(GlobalControl.TransferList,Transfer);

    }
}


error_status_t
_CancelSend(
    /* [in] */ handle_t      binding,
    /* [in] */ COOKIE        cookie
               )
{
    FILE_TRANSFER * transfer = TransferFromCookie(GlobalControl.TransferList,cookie);

    if (!transfer) {

        return ERROR_FILE_NOT_FOUND;
    }

    transfer->Cancel();

    return 0;
}



error_status_t
_CancelReceive(
    /* [in] */ handle_t      binding,
    /* [in] */ COOKIE        cookie
               )
{
    FILE_TRANSFER * transfer = TransferFromCookie(GlobalControl.TransferList,cookie);

    if (!transfer) {

        return ERROR_FILE_NOT_FOUND;
    }

    transfer->Cancel();

    return 0;
}

BOOL
LaunchUi(
         wchar_t * cmdline
         )
{

    //
    // Give the UI the current device list.
    //
    error_status_t status = 0;

    g_Mutex->Enter();

    if (g_DeviceList)
        {
        _DeviceInRange( rpcBinding, &g_DeviceList->Devices, &status );
        }

    DbgLog1(SEV_INFO, "LaunchUi: DeviceInRange returned %d", status);

    g_Mutex->Leave();

    return TRUE;
}


BOOL GetReceivedFilesFolder( LPWSTR szDir, DWORD dwLen )
{
    if (g_ReceivedFilesFolder[0] == L'\0') {

        ProcessRegistryChange();
    }

    StringCchCopy(szDir, dwLen, g_ReceivedFilesFolder);


    return TRUE;
}

BOOL
ShowSendWindow()
{

    _PopupUI(NULL);

    return TRUE;
}

BOOL ShowPropertiesPage()
{
    _DisplaySettings(NULL);

    return TRUE;
}

extern "C"
{
LRESULT
IrxferHandlePowerMessage(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );
}

BOOL IrxferQuerySuspend( LPARAM lParam );
void  IrxferResume();


LRESULT
IrxferHandlePowerMessage(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (message == WM_QUERYENDSESSION)
        {
        DbgLog1(SEV_INFO, "POWER: Query logoff %d", lParam);
        return IrxferQuerySuspend( 1 );
        }

    ASSERT( message == WM_POWERBROADCAST );

    switch (wParam)
        {
        case PBT_APMQUERYSUSPEND:
            {
            DbgLog1(SEV_INFO, "POWER: Query Suspend %d", lParam);
            return ( IrxferQuerySuspend( lParam ) ? TRUE : BROADCAST_QUERY_DENY );
            }
        case PBT_APMQUERYSUSPENDFAILED:
            {
            DbgLog(SEV_INFO, "POWER: Suspend Failed");
            IrxferResume();
            break;
            }
        case PBT_APMRESUMESUSPEND:
            {
            DbgLog(SEV_INFO, "POWER: Resume Suspend");
            IrxferResume();
            break;
            }
        case PBT_APMRESUMECRITICAL:
            {
            DbgLog(SEV_INFO, "POWER: Resume Critical");
            //
            // Do nothing.  The Winsock layer will send failures
            // for reads and writes on any sockets active before
            // the shutdown.
            //
            break;
            }

        default:
            DbgLog2(SEV_INFO, "POWER: w=0x%x l=0x%x", wParam, lParam);
        }

    return DefWindowProc(hwnd, message, wParam, lParam);
}

BOOL
IrxferQuerySuspend( LPARAM lParam )
{


    if (!AreThereActiveTransfers(GlobalControl.TransferList)) {

        DbgLog(SEV_INFO, "    no transfers active");
        return TRUE;
    }

    if (lParam & 1)
        {
        //
        // The app is allowed to prompt the user if necessary.
        //
        boolean answer;
        DWORD status = _ShutdownRequested( rpcBinding, &answer );
        DbgLog2(SEV_INFO, "    status %d  answer %d", status, answer);
        if (status || answer == TRUE)
            {
            g_fShutdown = 1;
            return TRUE;
            }
        else
            {
            return FALSE;
            }
        }
    else
        {
        DbgLog(SEV_INFO, "    not allowed to prompt");
        g_fShutdown = 1;
        return TRUE;
        }
}

void
IrxferResume()
{
    g_fShutdown = FALSE;

    // update device list
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irutil\irevent.c ===
#include <irda.h>
#include <irioctl.h>
#include <irlap.h>
#include <irlmp.h>
#undef offsetof
#include "irevent.tmh"

VOID
IrdaEventCallback(struct CTEEvent *Event, PVOID Arg)
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) Arg;
    PIRDA_EVENT     pIrdaEvent = (PIRDA_EVENT) Event;
    
    if (pIrdaLinkCb)
        REFADD(&pIrdaLinkCb->RefCnt, 'TNVE');
    
    pIrdaEvent->Callback(pIrdaLinkCb);

    PAGED_CODE();

    if (pIrdaLinkCb)
        REFDEL(&pIrdaLinkCb->RefCnt, 'TNVE');
}    

VOID
IrdaEventInitialize(PIRDA_EVENT pIrdaEvent,
                    VOID        (*Callback)(PVOID Context))
{
    CTEInitEvent(&pIrdaEvent->CteEvent, IrdaEventCallback);
    pIrdaEvent->Callback = Callback;
}   
    
VOID
IrdaEventSchedule(PIRDA_EVENT pIrdaEvent, PVOID Arg)
{
    PIRDA_LINK_CB pIrdaLinkCb = (PIRDA_LINK_CB) Arg;
        
    if (CTEScheduleEvent(&pIrdaEvent->CteEvent, pIrdaLinkCb) == FALSE)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("CTEScheduleEvent failed\n")));
        ASSERT(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irutil\irtimer.c ===
#include <irda.h>
#include <irioctl.h>
#include <irlap.h>
#include <irlmp.h>

#undef offsetof
#include "irtimer.tmh"

VOID
IrdaTimerExpFunc(struct CTEEvent *Event, void *Arg);

void
IrdaTimerInitialize(PIRDA_TIMER     pTimer,
                    VOID            (*ExpFunc)(PVOID Context),
                    UINT            Timeout,
                    PVOID           Context,
                    PIRDA_LINK_CB   pIrdaLinkCb)
{
    
#if DBG
    DEBUGMSG(DBG_TIMER, (TEXT("%hs timer initialized, context %p\n"),
                         pTimer->pName, pTimer));
#endif
    
    CTEInitTimer(&pTimer->CteTimer);
    CTEInitEvent(&pTimer->CteEvent, IrdaTimerExpFunc);
    
    pTimer->ExpFunc = ExpFunc;
    pTimer->Context = Context;
    pTimer->Timeout = Timeout;
    pTimer->pIrdaLinkCb = pIrdaLinkCb;
}

void
TimerFuncAtDpcLevel(CTEEvent *Event, void *Arg)
{
    PIRDA_TIMER pIrdaTimer = (PIRDA_TIMER) Arg;

#if DBG    
    DEBUGMSG(DBG_TIMER, (TEXT("%hs timer expired at DPC, context %p\n"),
                         pIrdaTimer->pName, pIrdaTimer));
#endif
    
    CTEScheduleEvent(&pIrdaTimer->CteEvent, Arg);
    
    return;
}

VOID
IrdaTimerExpFunc(struct CTEEvent *Event, void *Arg)
{
    PIRDA_TIMER     pIrdaTimer = (PIRDA_TIMER) Arg;
    PIRDA_LINK_CB   pIrdaLinkCb;

#if DBG    
    DEBUGMSG(DBG_TIMER, (TEXT("%hs timer expired, context %p\n"),
                         pIrdaTimer->pName, pIrdaTimer));
#endif

    pIrdaLinkCb = pIrdaTimer->pIrdaLinkCb;
    
    if (pIrdaLinkCb)
        LOCK_LINK(pIrdaLinkCb);
            
    if (pIrdaTimer->Late != TRUE)    
        pIrdaTimer->ExpFunc(pIrdaTimer->Context);
    else
    {
        DEBUGMSG(DBG_WARN ,
             (TEXT("IRDA TIMER LATE, ignoring\n")));
        pIrdaTimer->Late = FALSE;
    }
    
    if (pIrdaLinkCb)
    {   
        UNLOCK_LINK(pIrdaLinkCb);
    
        REFDEL(&pIrdaLinkCb->RefCnt,'RMIT');
    }    
    
    return;
}

VOID
IrdaTimerStart(PIRDA_TIMER pIrdaTimer)
{
    if (pIrdaTimer->pIrdaLinkCb)
        REFADD(&pIrdaTimer->pIrdaLinkCb->RefCnt, 'RMIT');
    
    pIrdaTimer->Late = FALSE;
    CTEStartTimer(&pIrdaTimer->CteTimer, pIrdaTimer->Timeout,
                  TimerFuncAtDpcLevel, (PVOID) pIrdaTimer);

#if DBG    
    DEBUGMSG(DBG_TIMER, (TEXT("Start timer %hs (%dms) context %p\n"),
                            pIrdaTimer->pName,
                            pIrdaTimer->Timeout,
                            pIrdaTimer));
#endif    
    return;
}

VOID
IrdaTimerStop(PIRDA_TIMER pIrdaTimer)
{
    BOOLEAN     ReleaseReference=FALSE;

    if (pIrdaTimer->pIrdaLinkCb) {

        LOCK_LINK(pIrdaTimer->pIrdaLinkCb);
    }

    if (CTEStopTimer(&pIrdaTimer->CteTimer) == 0) {

        pIrdaTimer->Late = TRUE;

    } else {
        //
        //  timer canceled
        //
        ReleaseReference=TRUE;

    }
#if DBG    
    DEBUGMSG(DBG_TIMER, (TEXT("Timer %hs stopped, late %d\n"), pIrdaTimer->pName,
                            pIrdaTimer->Late));
#endif

    if (pIrdaTimer->pIrdaLinkCb) {

        UNLOCK_LINK(pIrdaTimer->pIrdaLinkCb);

        if (ReleaseReference) {

            REFDEL(&pIrdaTimer->pIrdaLinkCb->RefCnt,'RMIT');
        }
    }
    return;
}

VOID
IrdaTimerRestart(PIRDA_TIMER pIrdaTimer)
{
    IrdaTimerStop(pIrdaTimer);
    IrdaTimerStart(pIrdaTimer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\iso8601.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       iso8601.h
//
//--------------------------------------------------------------------------


#ifndef _ISO8601_H_
#define _ISO8601_H_

#ifdef __cplusplus
extern "C" {
#endif

#define ISO_TIME_LENGTH 40

DWORD iso8601ToFileTime(char *pszisoDate, FILETIME *pftTime, BOOL fLenient, BOOL fPartial);
DWORD iso8601ToSysTime(char *pszisoDate, SYSTEMTIME *pSysTime, BOOL fLenient, BOOL fPartial);
DWORD FileTimeToiso8601(FILETIME *pftTime, char *pszBuf);
DWORD SysTimeToiso8601(SYSTEMTIME *pstTime, char *pszBuf);

#ifdef __cplusplus
}
#endif

#endif // _ISO8601_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\iso8601.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       iso8601.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "iso8601.h"

// This code implements a parser & generater for the ISO 8601 date format.

// This table defines different "types" of characters for use as the columns
// of the state table

unsigned char iso8601chartable[256] = {
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0x82, 0,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// State table
// 0x80 bit = Error
// 0x20 = Add character & advance to next field
// 0x40 = Add character & advance to next field + skip one (for day of week)
// 0x1f = Mask to determine next state #

// Columns = input character type: unknown, number, "-", "T", ":", "Z"
unsigned char iso8601StateTable[][6] =
{
        0x80, 0x01, 0x25, 0x80, 0x80, 0x80, // year
        0x80, 0x02, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x03, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x24, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x06, 0x05, 0x85, 0x85, 0x05, //0x04 month
        0x80, 0x06, 0x48, 0x80, 0x80, 0x80,
        0x80, 0x47, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x09, 0x08, 0x88, 0x88, 0x08, //0x07 day
        0x80, 0x09, 0x8b, 0x2b, 0x8b, 0x80,
        0x80, 0x2a, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x0c, 0x8b, 0x0b, 0x8b, 0x08, //0x0a hour
        0x80, 0x0c, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x2d, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x0f, 0x8e, 0x8e, 0x0e, 0x08, //0x0d min
        0x80, 0x0f, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x30, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x12, 0x91, 0x91, 0x11, 0x08, //0x10 sec
        0x80, 0x12, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x30, 0x80, 0x80, 0x80, 0x80,
};

DWORD iso8601ToFileTime(char *pszisoDate, FILETIME *pftTime, BOOL fLenient, BOOL fPartial)
{
    SYSTEMTIME  stTime;
    DWORD     hr;

    hr = iso8601ToSysTime(pszisoDate, &stTime, fLenient, fPartial);

    if (0 == hr)
        {
        if (SystemTimeToFileTime( &stTime, pftTime))
            return 0;
        else
            return GetLastError();
        }
    return hr;
}

// Convert a character string formatted as iso8601 into a SYSTEMTIME structure
// Supports both basic & extended forms of iso8601.
// isoDate: Input string. It can be null or space terminated.
// pSysTime: Output SYSTEMTIME structure
// fLenient: true for normal operation. "false" if you want to detect incorrectly
//                      formatted iso8601. Will still return the "best guess" value.
// fPartial: Set to true if you will accept partial results. Note that this just fills
//                      in zeros where data is missing, which strictly speaking can't be distinguished
//                      from real zeros in this implementation. An improvement would have a second
//                      structure to fill in with validity bits.

DWORD iso8601ToSysTime(char *pszisoDate, SYSTEMTIME *pSysTime, BOOL fLenient, BOOL fPartial)
{
        DWORD hr = 0;
        WORD *dateWords = (WORD *) pSysTime;
        WORD *endWord = dateWords + 7;  // To detect the end of the date
        int state = 0;
        int pos = 0;
    unsigned char action;

        *dateWords = 0;

        // Main state machine loop. Loop until a space or null.
        while(*pszisoDate && *pszisoDate != ' ')
        {
                char code = iso8601chartable[*pszisoDate];
                if(code & 0x80)
                        {
                        if(!fLenient)
                                hr = ERROR_INVALID_DATA;    // Illegal character only when lenient
                        code = code & 0x7f;
                        }
                action = iso8601StateTable[state][code];

                state = action&0x1f;    // Calculate the next state

                if(code == 1)   // The character code 1 is always a number which gets accumulated
                        *dateWords = *dateWords * 10 + *pszisoDate - '0';
                switch(action >> 5)
                {
                case 0x1:
                        if(!fPartial && !*dateWords)
                                hr = ERROR_INVALID_DATA; // Only partial, error
                        if(dateWords == endWord)        // Prevent an overflow
                                return 0;
                        dateWords++;
                        *dateWords = 0;
                        break;
                case 0x2:       // Finish piece & advance twice (past day of week)
                        if(!fPartial && !*dateWords)
                                hr = ERROR_INVALID_DATA; // Only partial, error

                        // We don't need to check for an overflow here since the state machine
                        // only calls this to skip "dayofweek" in the SYSTEMTIME structure.
                        // We could do dateWords+=2 instead of the following if leaving random
                        // values in dayofweek is acceptable.
                        dateWords++;
                        *dateWords = 0;
                        dateWords++;
                        *dateWords = 0;
                        break;
                }
                if((action & 0x80) && !fLenient)
                        hr = ERROR_INVALID_DATA;
                pszisoDate++;
        }

        // Zero out the rest of the SYSTEMTIME structure
        while(dateWords < endWord)
                *(++dateWords) = 0;
        return hr;
}

// The function toExtended accepts a FILETIME and converts it into the ISO8601 extended
// form, placeing it in the character buffer 'buf'. The buffer 'buf' must have room for
// a minimum of 40 characters to support the longest forms of 8601 (currently only 21 are used).
DWORD FileTimeToiso8601(FILETIME *pftTime, char *pszBuf)
{
    SYSTEMTIME  stTime;

    if (FileTimeToSystemTime( pftTime, &stTime))
        {
        return SysTimeToiso8601(&stTime, pszBuf);
        }
    else
        return GetLastError();
}


// The function toExtended accepts a SYSTEMTIME and converts it into the ISO8601 extended
// form, placeing it in the character buffer 'buf'. The buffer 'buf' must have room for
// a minimum of 40 characters to support the longest forms of 8601 (currently only 21 are used).
DWORD SysTimeToiso8601(SYSTEMTIME *pstTime, char *pszBuf)
{
        pszBuf[0] = pstTime->wYear / 1000 + '0';
        pszBuf[1] = ((pstTime->wYear / 100) % 10) + '0';
        pszBuf[2] = ((pstTime->wYear / 10) % 10) + '0';
        pszBuf[3] = ((pstTime->wYear) % 10) + '0';
        pszBuf[4] = '.';
        pszBuf[5] = pstTime->wMonth / 10 + '0';
        pszBuf[6] = (pstTime->wMonth % 10) + '0';
        pszBuf[7] = '.';
        pszBuf[8] = pstTime->wDay / 10 + '0';
        pszBuf[9] = (pstTime->wDay % 10) + '0';
        pszBuf[10] = 'T';
        pszBuf[11] = pstTime->wHour / 10 + '0';
        pszBuf[12] = (pstTime->wHour % 10) + '0';
        pszBuf[13] = ':';
        pszBuf[14] = pstTime->wMinute / 10 + '0';
        pszBuf[15] = (pstTime->wMinute % 10) + '0';
        pszBuf[16] = ':';
        pszBuf[17] = pstTime->wSecond / 10 + '0';
        pszBuf[18] = (pstTime->wSecond % 10) + '0';
        pszBuf[19] = 'Z';
        pszBuf[20] = 0;

        return 0;
}


#ifdef STANDALONETEST8601

// This code does some simple tests.
int main(int argc, char **argv)
{
        char *isoDate;
        SYSTEMTIME sysTime;
        char outBuf[256];
        DWORD hr;

        isoDate = "1997.01.01T14:23:53Z";
        hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
        if(hr != 0)
                printf("error.\n");
        iso8601::toExtended(&sysTime, outBuf);
        printf("%s\n", outBuf);

        isoDate = "19970101T142353Z";
        hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
        if(hr != 0)
                printf("error.\n");
        iso8601::toExtended(&sysTime, outBuf);
        printf("%s\n", outBuf);

        isoDate = "1997:01.01T14:23:53Z";
        hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
        if(hr != 0)
                printf("error (correct).\n");
        iso8601::toExtended(&sysTime, outBuf);
        printf("%s\n", outBuf);

        isoDate = ".01.01T14:23:53Z";
        hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
        if(hr != 0)
                printf("error.\n");
        iso8601::toExtended(&sysTime, outBuf);
        printf("%s\n", outBuf);

        isoDate = "..01T14:23:53Z";
        hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
        if(hr != 0)
                printf("error.\n");
        iso8601::toExtended(&sysTime, outBuf);
        printf("%s\n", outBuf);

        isoDate = "..T14:23:53Z";
        hr = iso8601::toSysTime(isoDate, &sysTime, FALSE);
        if(hr != 0)
                printf("error.\n");
        iso8601::toExtended(&sysTime, outBuf);
        printf("%s\n", outBuf);

        return 0;
}
#endif // STANDALONETEST8601
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\log.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       log.cxx
//
//--------------------------------------------------------------------------


#include "precomp.h"

#ifdef LOGGING

static HANDLE _hLogFile = INVALID_HANDLE_VALUE;


BOOL Log_Init( VOID )
{
#if 1
    _hLogFile = CreateFile(
        L"IrXfer.log",
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        CREATE_ALWAYS,   // overwrite any existing file
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
#endif
    if( INVALID_HANDLE_VALUE == _hLogFile )
        return FALSE;

    Log( SEV_INFO, "**\r\n**\r\n** Infrared File Transfer Log\r\n**\r\n**" );
    return TRUE;
}


VOID Log_Close( VOID )
{
    if( INVALID_HANDLE_VALUE != _hLogFile )
    {
        CloseHandle( _hLogFile );
        _hLogFile = INVALID_HANDLE_VALUE;
    }
}


VOID Log( DWORD dwSev, LPSTR lpsz )
{
    DWORD dwWritten;
    LPSTR lpszPrefix = "??";

    if ( INVALID_HANDLE_VALUE == _hLogFile ) {

        if( !Log_Init() ) {

            return;
        }
    }

    switch( dwSev )
        {
        case SEV_INFO:     lpszPrefix = "";           break;
        case SEV_FUNCTION: lpszPrefix = "Function: "; break;
        case SEV_WARNING:  lpszPrefix = "WARNING: ";  break;
        case SEV_ERROR:    lpszPrefix = "ERROR! ";    break;
        }

    char Buffer[2000];

    StringCbPrintfA(
             Buffer,
             sizeof(Buffer),
             "[%d] %d %s %s\r\n",
	         GetTickCount(),
             GetCurrentThreadId(),
             lpszPrefix,
             lpsz
             );

    WriteFile(
        _hLogFile,
        Buffer,
        lstrlenA(Buffer),
        &dwWritten,
        NULL
        );
}


LPSTR GetSocketMsgSz( INT nSockMsg )
{
    switch( nSockMsg )
    {
    case FD_WRITE:  return "FD_WRITE";
    case FD_ACCEPT: return "FD_ACCEPT";
    case FD_READ:   return "FD_READ";
    case FD_OOB:    return "FD_OOB";
    case FD_CLOSE:  return "FD_CLOSE";
    default:        return "UNKNOWN";
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDS_RPC_ANNOTATION              260
#define IDS_DUPLICATE_FILE_PATTERN      401
#define IDS_UNKNOWN_DEVICE2             261
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\precomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       precomp.h
//
//--------------------------------------------------------------------------

/*
 *  IRXFER.H
 *
 *
 *
 */

#ifndef _IRXFER_H_
#define _IRXFER_H_

#define INC_OLE2

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>
#include <winuser.h>
#include <mmsystem.h>
#include <pbt.h>
#include <winsock2.h>
#ifndef _WIN32_WINDOWS
#define  _WIN32_WINDOWS 0
#endif
#include <af_irda.h>

#include <initguid.h>
#include <shlobj.h>
#include <shellapi.h>
#include <strsafe.h>

//
// CONNECT_MAXPKT is the size of each network packet, so the actual file data sent
// in each pkt is slightly smaller.  Xfer_PutBody calls _Put in chunks of cbSOCK_BUFFER_SIZE,
// so this should be a good multiple of CONNECT_MAXPKT.
//
#if 1
#define MAX_IRDA_PDU           (2042)

#define CONNECT_MAXPKT         (BYTE2)((MAX_IRDA_PDU*16))
#define cbSOCK_BUFFER_SIZE     ( CONNECT_MAXPKT * 2 )                  // max amount of data read from/written to sockets at a time
#define cbSTORE_SIZE_RECV      ( CONNECT_MAXPKT * 2 )   // size of receive buffer - MUST FIT INTO 2 BYTES
#else
#define CONNECT_MAXPKT         (BYTE2)(10000-17)
#define cbSOCK_BUFFER_SIZE     ( 60000 )                  // max amount of data read from/written to sockets at a time
#define cbSTORE_SIZE_RECV      ( 60000 )   // size of receive buffer - MUST FIT INTO 2 BYTES

#endif


#define TEMP_FILE_PREFIX      L"infrared"

typedef BYTE   BYTE1, *LPBYTE1;        // one-byte value
typedef WORD   BYTE2, *LPBYTE2;        // two-byte value
typedef DWORD  BYTE4, *LPBYTE4;        // four-byte value

typedef struct {
    DWORD dwSize;                      // size of ab1Store, NOT entire memory block
    DWORD dwUsed;                      // bytes used
    DWORD dwOutOffset;                 // next position to get data from
    BYTE1 ab1Store[1];                 // actual data
} STORE, *LPSTORE;

typedef enum {
    xferRECV          = 0,
    xferSEND          = 1,
    xferNONE
} XFER_TYPE, *LPXFER_TYPE;

#define ExitOnErr( err )       { if( err ) goto lExit; }


extern "C"
{
#ifndef ASSERT

//
// If debugging support enabled, define an ASSERT macro that works.  Otherwise
// define the ASSERT macro to expand to an empty expression.
//

#if DBG
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

#endif // !ASSERT
}

#include "eventlog.h"
#include "log.h"
#include "irtypes.h"
#include "mutex.hxx"
#include "resource.h"
#include "util.h"
#include "store.h"
#include "xfer.h"

#include "xferlist.h"

//extern PXFER_LIST    TransferList;
VOID
RemoveFromTransferList(
    FILE_TRANSFER *  Transfer
    );

extern BOOL g_fShutdown;
//extern "C" HANDLE g_UserToken;

extern wchar_t g_UiCommandLine[];

BOOL LaunchUi( wchar_t * cmdline );

VOID ChangeByteOrder( void * pb1, UINT uAtomSize, UINT uDataSize );
VOID SetDesktopIconName( LPWSTR lpszTarget, BOOL fWaitForCompletion );
VOID SetSendToIconName( LPWSTR lpszTarget, BOOL fWaitForCompletion );


#endif // _IRXFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\sock.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sock.cxx
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include <malloc.h>
#include <mswsock.h>

#include <irmonftp.h>

#define dwENUM_REST             100    // time to rest between successive
                                       // IRLMP_ENUMDEVICES queries
#define dwCONN_REST             100    // time to rest between successive
                                       // connect() calls

#define MAX_DEVICE_COUNT        20
#define nMAX_TARGETS            8
#define nMAX_ENUM_RETRIES       100
#define nMAX_CONN_RETRIES       10

#define nSOCKET_MAXCONN         8


#define dwWRITEABLE_TIMEOUT     10000
#define SOCKET_RECEIVE_TIMEOUT  (1000 * 60 * 10)

#define SINGLE_INST_MUTEX   L"IRMutex_1A8452B5_A526_443C_8172_D29657B89F57"


FILE_TRANSFER*
InitializeSocket(
    char     ServiceName[]
    )
{
    int nSize;
    INT     nRet;
    WORD    wWinsockVersion;
    WSADATA wsadata;
    SOCKET  listenSocket=INVALID_SOCKET;
    FILE_TRANSFER*   Transfer;
    HANDLE           FileMapping;
    PVOID            FileView=NULL;



    LPWSAPROTOCOL_INFO    ProtocolInfo;

    wWinsockVersion = MAKEWORD( 2, 0 );

    nRet = WSAStartup( wWinsockVersion, &wsadata );

    if ( 0 != nRet ) {

        goto lErr;
    }


    FileMapping=OpenFileMapping(
        FILE_MAP_READ,
        FALSE,
        TEXT("Global\\Irmon-shared-memory")
        );

    if (FileMapping != NULL) {

        FileView=MapViewOfFile(
            FileMapping,
            FILE_MAP_READ,
            0,
            0,
            0
            );

        CloseHandle(FileMapping);

    } else {

        DbgPrint("irftp: could not open shared mem %d\n",GetLastError());
    }

    ProtocolInfo=(LPWSAPROTOCOL_INFO)FileView;

    if (ProtocolInfo != NULL) {

        if (lstrcmpA(ServiceName,SERVICE_NAME_2) == 0) {

            ProtocolInfo++;
        }

        listenSocket=WSASocket(FROM_PROTOCOL_INFO,FROM_PROTOCOL_INFO ,FROM_PROTOCOL_INFO ,ProtocolInfo, NULL, 0);

        UnmapViewOfFile(FileView);
    }


    if (listenSocket == INVALID_SOCKET) {
        //
        // establish listen socket
        //
        SOCKADDR_IRDA saListen;

        DbgPrint("irftp: WSASocketFailed %d\n",WSAGetLastError());

        listenSocket = socket( AF_IRDA, SOCK_STREAM, 0 );

        if( INVALID_SOCKET == listenSocket ) {

            UINT uErr = (UINT)WSAGetLastError();
            DbgLog3( SEV_ERROR, "listen on %s socket() failed with %d [0x%x]", ServiceName, uErr, uErr);
            goto lErr;
        }

        DbgLog2( SEV_INFO, "listen on %s socket ID: %ld", ServiceName, (DWORD)listenSocket );

        saListen.irdaAddressFamily     = AF_IRDA;
        *(UINT *)saListen.irdaDeviceID = 0;

        StringCbCopyA(saListen.irdaServiceName,sizeof(saListen.irdaServiceName), ServiceName );

        nRet = bind( listenSocket, (const struct sockaddr *)&saListen, sizeof(saListen) );

        if( SOCKET_ERROR == nRet ) {

            UINT uErr = (UINT)WSAGetLastError();

            DbgLog3( SEV_ERROR, "listen on %s setsockopt failed with %d [0x%x]", ServiceName, uErr, uErr);
            closesocket(listenSocket);

            goto lErr;
        }

        nRet = listen( listenSocket, nSOCKET_MAXCONN );

        if( SOCKET_ERROR == nRet ) {

            UINT uErr = (UINT)WSAGetLastError();

            DbgLog3( SEV_ERROR, "listen on %s listen() failed with %d [0x%x]", ServiceName, uErr, uErr);

            closesocket(listenSocket);
            goto lErr;
        }
    } else {


    }

    Transfer=ListenForTransfer(listenSocket,TYPE_IRDA);

    if (Transfer == NULL) {

        closesocket(listenSocket);
    }


    return Transfer;

lErr:

    return NULL;
}


DWORD
FILE_TRANSFER::Sock_EstablishConnection(
                                         DWORD dwDeviceID,
                                         OBEX_DEVICE_TYPE    DeviceType
                                         )
{
    FILE_TRANSFER * transfer;

    _state = CONNECTING;

    if (DeviceType == TYPE_IRDA) {

        SOCKADDR_IRDA saRemote;

        saRemote.irdaAddressFamily     = AF_IRDA;
        *(UINT *)saRemote.irdaDeviceID = dwDeviceID;

        StringCbCopyA(saRemote.irdaServiceName,sizeof(saRemote.irdaServiceName), SERVICE_NAME_1 );

        if ( 0 == connect( _socket, (const struct sockaddr *) &saRemote, sizeof(saRemote))) {

            return 0;
        }

        StringCbCopyA(saRemote.irdaServiceName,sizeof(saRemote.irdaServiceName), SERVICE_NAME_2 );

        if ( 0 == connect( _socket, (const struct sockaddr *) &saRemote, sizeof(saRemote))) {

            return 0;
        }

    } else {

        sockaddr_in Address;

        ZeroMemory(&Address,sizeof(Address));

        Address.sin_family=AF_INET;
        Address.sin_port=650;
        Address.sin_addr.S_un.S_addr=dwDeviceID;

        if ( 0 == connect( _socket, (const struct sockaddr *) &Address, sizeof(Address))) {

            return 0;
        }

    }

    return WSAGetLastError();
}

DWORD
FILE_TRANSFER::SyncAccept(
    VOID
    )
{
    DWORD           status = 0;
    DWORD           bytes = 0;

    DWORD           dwEventStatus = 0;
    EVENT_LOG       EventLog(WS_EVENT_SOURCE,&dwEventStatus);
    int             size;
    SOCKADDR_IRDA   s;
    sockaddr_in     Address;
    BOOL            bResult;


    status = 0;

    while (!m_StopListening) {

        _state = ACCEPTING;
        _dataXferRecv.dwFileSent = 0;

        if (m_DeviceType == TYPE_IRDA) {

            size = sizeof(SOCKADDR_IRDA);

            _socket = accept( m_ListenSocket, (sockaddr *) &s, &size );

        } else {

            size=sizeof(Address);

            _socket = accept( m_ListenSocket, (sockaddr *) &Address, &size );
        }

        if ( INVALID_SOCKET == _socket ) {

            if (!m_StopListening) {
                //
                //  the thread has been request to stop listening for incoming connection
                //
                if (!dwEventStatus) {

                    EventLog.ReportError(CAT_IRXFER, MC_IRXFER_LISTEN_FAILED, WSAGetLastError());
                }

                Sleep(1 * 1000);
            }

            continue;
        }

        //
        //  we are handling an incoming connection, don't suspend on timeout during the transfer
        //
        SetThreadExecutionState( ES_SYSTEM_REQUIRED | ES_CONTINUOUS );

        _state = READING;

        //
        // Record the machine name for later use.
        //
        RecordDeviceName( &s );

        _fCancelled=FALSE;

        do {

            if (_fCancelled) {
#if DBG
                DbgPrint("irmon: receive canceled\n");
#endif
                status = ERROR_CANCELLED;
                break;
            }

            DWORD    BytesToRead=Store_GetSize(_dataRecv.lpStore)-Store_GetDataUsed(_dataRecv.lpStore);

            bytes = recv( _socket, (char *) _buffer, BytesToRead, 0 );

            if (SOCKET_ERROR == bytes) {

                if (_dataRecv.state == osCONN) {
                    //
                    //  workaround for nokia cell phones that drop the irda connection after sending
                    //  the file. If we are not in the middle of a file transfer then just left it close
                    //  normally
                    //
                    status = 0;
                    break;

                } else {

                    if (!dwEventStatus) {

                        EventLog.ReportError(CAT_IRXFER, MC_IRXFER_RECV_FAILED, WSAGetLastError());
                    }
                }

                status = GetLastError();
                break;
            }

            if (0 == bytes) {

                status = 0;
                break;
            }

            HANDLE   MutexHandle;

            MutexHandle=OpenMutex(SYNCHRONIZE,FALSE,SINGLE_INST_MUTEX);

            if (MutexHandle == NULL) {
                //
                //  start the ui app, so we have something to rpc to.
                //
                LaunchUi( NULL);

            } else {
                //
                //  The app is already running
                //
                CloseHandle(MutexHandle);
            }

            DbgLog1(SEV_FUNCTION,"SyncAccept(): Recv: %d bytes", bytes);

            ASSERT( _guard == GUARD_MAGIC );

            _dataXferRecv.dwFileSent += bytes;

            Obex_ReceiveData( xferRECV, _buffer, bytes );

            while (Obex_ConsumePackets( xferRECV, &status )) {

                if (status != ERROR_SUCCESS) {

                    break;
                }
            }

            if (status == 0xffffffff) {

                status = 0;
            }

        } while (status == STATUS_SUCCESS);


        DbgLog1( status ? SEV_ERROR : SEV_INFO, "Obex_Consume returned %d", status);

        //
        // Clean up OBEX data.
        //

        HandleClosure( status );

        status = 0;

        if (_socket != INVALID_SOCKET) {

            closesocket(_socket);
            _socket=INVALID_SOCKET;
        }

        //
        //  done with this connection, allow idle suspend
        //
        SetThreadExecutionState( ES_CONTINUOUS );
    }
#if DBG
    DbgPrint("IRMON: accept thread exiting\n");
#endif
    DecrementRefCount();

    return 0;
}

error_status_t
FILE_TRANSFER::Sock_CheckForReply(
    long timeout
    )
{
    int bytes;
    long seconds;
    long msec;
    fd_set FdSet;
    timeval BerkeleyTimeout;

    FD_ZERO( &FdSet );
    FD_SET( _socket, &FdSet );

    if (timeout == TIMEOUT_INFINITE) {

        int     Result=0;

        while (Result == 0) {

            msec    = 0;
            seconds = 5;

            BerkeleyTimeout.tv_sec  = seconds;
            BerkeleyTimeout.tv_usec = msec * 1000;

            Result=select(0, &FdSet, NULL, NULL, &BerkeleyTimeout);

//            if (0 == Result) {
//
//                return ERROR_TIMEOUT;
//            }

            if (_fCancelled) {

                return ERROR_OPERATION_ABORTED;
            }
        }

    } else {

        msec    = timeout % 1000;
        seconds = timeout / 1000;

        BerkeleyTimeout.tv_sec  = seconds;
        BerkeleyTimeout.tv_usec = msec * 1000;

        DbgLog1(SEV_INFO, "sock_checkForReply: timeout %ld", timeout);

        if (0 == select(0, &FdSet, NULL, NULL, &BerkeleyTimeout)) {

            return ERROR_TIMEOUT;
        }
    }

    bytes = recv( _socket, (char *) _buffer, cbSOCK_BUFFER_SIZE, 0 );

    if (bytes == SOCKET_ERROR) {

        return GetLastError();

    } else if (bytes == 0) {

        return WSAECONNRESET;

    } else {

        DbgLog1(SEV_FUNCTION,"Sock_CheckForReply(): Recv: %d bytes", bytes);
        Obex_ReceiveData( xferSEND, _buffer, bytes );
        return 0;
    }

    return 0;
}

DWORD
AcceptThreadStartRoutine(
    PVOID    Context
    )

{
    FILE_TRANSFER * transfer=(FILE_TRANSFER *)Context;

    return transfer->SyncAccept();

}


FILE_TRANSFER *
ListenForTransfer(
    SOCKET              ListenSocket,
    OBEX_DEVICE_TYPE    DeviceType
    )

{
    FILE_TRANSFER * transfer;
    BOOL            bResult;
    ULONG           ThreadId;
    HANDLE          ThreadHandle;

    transfer = new FILE_TRANSFER;

    if (transfer == NULL) {

        return NULL;
    }


    bResult=transfer->Xfer_Init(0, 0, dialWin95,DeviceType,FALSE,ListenSocket);

    if (!bResult) {

        delete transfer;
        return NULL;

    }

    ThreadHandle=CreateThread(
        NULL,
        80000,
        AcceptThreadStartRoutine,
        (PVOID) transfer,
        STACK_SIZE_PARAM_IS_A_RESERVATION,
        &ThreadId
        );

    if (ThreadHandle == NULL) {

        delete transfer;
        return NULL;
    }

    CloseHandle(ThreadHandle);

    return transfer;

}


void
FILE_TRANSFER::HandleClosure(
                              DWORD error
                              )
{
    if (!error)
        {
        _state = CLOSING;
        }

    if (_state == ACCEPTING ||
        _state == READING )
        {
        SendReplyWin32( 0, error );
        }

    if (_fInUiReceiveList)
        {
        _fInUiReceiveList = FALSE;
        _ReceiveFinished( rpcBinding, _cookie, error );
        }

    if (error)
        {
        Xfer_FileAbort();         // just in case a file is being received
        }

    Obex_Reset();             // reset the state machine
}


error_status_t
FILE_TRANSFER::Sock_Request( LPVOID lpvData, DWORD dwDataSize )
{
    if (send( _socket, (char *) lpvData, dwDataSize, 0) != (int) dwDataSize)
        {
        return GetLastError();
        }

    DbgLog1(SEV_FUNCTION,"Sock_Request(): Send: %d bytes", dwDataSize);

    return 0;
}


error_status_t
FILE_TRANSFER::Sock_Respond(
    LPVOID lpvData,
    DWORD dwDataSize
    )
{
    if (send( _socket, (char *) lpvData, dwDataSize, 0) != (int) dwDataSize)
        {
        return GetLastError();
        }

    DbgLog1(SEV_FUNCTION,"Sock_Respond(): Send: %d bytes", dwDataSize);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\log.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       log.h
//
//--------------------------------------------------------------------------

#ifndef _LOG_H_
#define _LOG_H_

#include <stdio.h>

#define SEV_INFO     0x00000001
#define SEV_FUNCTION 0x00000002
#define SEV_WARNING  0x00000004
#define SEV_ERROR    0x00000008

#ifdef DBG
#define LOGGING
#endif

#ifdef LOGGING

BOOL Log_Init( VOID );

VOID Log( DWORD dwSev, LPSTR lpsz );
VOID Log_Close( VOID );

LPSTR GetSocketMsgSz( INT nSockMsg );
LPSTR GetPacketSz( DWORD dwPkt );

#define DbgLog(sev,a)          Log(sev,a)
#define DbgLog1(sev, szFormat, p1)            \
    {                                         \
        CHAR _sz[MAX_PATH];                   \
        StringCbPrintfA(_sz,sizeof(_sz), szFormat, p1);          \
        DbgLog(sev, _sz);                     \
    }
#define DbgLog2(sev, szFormat, p1, p2)        \
    {                                         \
        CHAR _sz[MAX_PATH];                   \
        StringCbPrintfA(_sz,sizeof(_sz), szFormat, p1, p2);      \
        DbgLog(sev, _sz);                     \
    }
#define DbgLog3(sev, szFormat, p1, p2, p3)    \
    {                                         \
        CHAR _sz[MAX_PATH];                   \
        StringCbPrintfA(_sz,sizeof(_sz), szFormat, p1, p2, p3);  \
        DbgLog(sev, _sz);                     \
    }
#define DbgLog4(sev, szFormat, p1, p2, p3, p4) \
    {                                         \
        CHAR _sz[MAX_PATH];                   \
        StringCbPrintfA(_sz,sizeof(_sz), szFormat, p1, p2, p3, p4);  \
        DbgLog(sev, _sz);                     \
    }
#define DbgMsgBox(a,b)         MessageBox( NULL, a, b, MB_OK | MB_ICONEXCLAMATION )
#define DbgMsgBox1(szFormat, szTitle, p1) \
    {                                     \
        CHAR _sz[MAX_PATH];               \
        StringCbPrintfA(_sz,sizeof(_sz), szFormat, p1);      \
        DbgMsgBox(_sz, szTitle);          \
    }
#define DbgMsgBox2(szFormat, szTitle, p1, p2) \
    {                                     \
        CHAR _sz[2*MAX_PATH];             \
        StringCbPrintfA(_sz,sizeof(_sz), szFormat, p1, p2);  \
        DbgMsgBox(_sz, szTitle);          \
    }
#define DbgMsgBox3(szFormat, szTitle, p1, p2, p3) \
    {                                     \
        CHAR _sz[3*MAX_PATH];             \
        StringCbPrintfA(_sz,sizeof(_sz), szFormat, p1, p2, p3);  \
        DbgMsgBox(_sz, szTitle);          \
    }
#define DbgMsgBox4(szFormat, szTitle, p1, p2, p3, p4) \
    {                                     \
        CHAR _sz[4*MAX_PATH];             \
        StringCbPrintfA(_sz,sizeof(_sz), szFormat, p1, p2, p3, p4);  \
        DbgMsgBox(_sz, szTitle);          \
    }

#else  // not DBG

#define Log_Init()                   TRUE
#define Log( dwSev, lpsz )
#define Log_Close()
#define GetSocketMsgSz( nSockMsg )   szNIL
#define GetPacketSz( dwPkt )         szNIL

#define DbgLog(sev,a)
#define DbgLog1(sev,a,b)
#define DbgLog2(sev,a,b,c)
#define DbgLog3(sev,a,b,c,d)
#define DbgLog4(sev,a,b,c,d, e)
#define DbgMsgBox(a,b)
#define DbgMsgBox1(a,b,c)
#define DbgMsgBox2(a,b,c,d)
#define DbgMsgBox3(a,b,c,d,e)
#define DbgMsgBox4(a,b,c,d,e,f)

#endif  // not DBG


#endif  // _LOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\obex.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       obex.cxx
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include "iso8601.h"
#include <irmonftp.h>

#define OBEX_VERSION                  0x10

#define OBEX_OPCODE_FINALBIT          0x80
#define OBEX_OPCODE_CONNECT           ( 0x00 | OBEX_OPCODE_FINALBIT )
#define OBEX_OPCODE_DISCONNECT        ( 0x01 | OBEX_OPCODE_FINALBIT )
#define OBEX_OPCODE_PUT               0x02
#define OBEX_OPCODE_PUT_FINAL         ( 0x02 | OBEX_OPCODE_FINALBIT )
#define OBEX_OPCODE_SETPATH           ( 0x05 | OBEX_OPCODE_FINALBIT )
#define OBEX_OPCODE_ABORT             0xFF
#define OBEX_OPCODE_LEN               1
#define OBEX_OPCODE_VALID             1
#define OBEX_OPCODE_NOTIMP            0
#define OBEX_OPCODE_INVALID           -1

#define OBEX_REPLY_CONTINUE           ( 0x10 | OBEX_OPCODE_FINALBIT )
#define OBEX_REPLY_SUCCESS            ( 0x20 | OBEX_OPCODE_FINALBIT )
#define OBEX_REPLY_FAIL_BADREQUEST    ( 0x40 | OBEX_OPCODE_FINALBIT )
#define OBEX_REPLY_FAIL_FORBIDDEN     ( 0x43 | OBEX_OPCODE_FINALBIT )
#define OBEX_REPLY_FAIL_NOTFOUND      ( 0x44 | OBEX_OPCODE_FINALBIT )
#define OBEX_REPLY_FAIL_TOOBIG        ( 0x4D | OBEX_OPCODE_FINALBIT )
#define OBEX_REPLY_FAIL_NOTIMP        ( 0x61 | OBEX_OPCODE_FINALBIT )
#define OBEX_REPLY_FAIL_UNAVAILABLE   ( 0x63 | OBEX_OPCODE_FINALBIT )

#define CONNECT_PKTLEN                0x0007
#define CONNECT_FLAGS                 0x00

#define DISCONNECT_PKTLEN             0x0003

#define ABORT_PKTLEN                  0x0008

#define SETPATH_FLAGS                 0x00
#define SETPATH_CONSTANTS             0x00
#define SETPATH_UPALEVEL              0x01

#define REPLY_PKTLEN                  0x0003

#define REPLY_TIMEOUT               TIMEOUT_INFINITE
#define CONNECT_TIMEOUT             60000
#define SETPATH_TIMEOUT             60000
#define DISCONN_TIMEOUT             15000
#define MAX_UPDATE_DELAY            5000


#define dwBUFFER_INC                  512L
#define MIN_PACKET_SIZE               3        // 1 (opcode/status) + 2 (packet len)


//#ifdef DBG
#if 1
LPSTR _szState[] = { "IDLE", "CONNECTED", "FILE" };
#endif

UUID DIALECT_ID_NT5 = /* b9c7fd98-e5f8-11d1-bfce-0000f8753890 */
{
    0xb9c7fd98,
    0xe5f8,
    0x11d1,
    {0xbf, 0xce, 0x00, 0x00, 0xf8, 0x75, 0x38, 0x90}
};



BOOL FILE_TRANSFER::Obex_Init( VOID )
{
    //
    // initialize connection data structures
    //
    FillMemory( &_dataRecv, sizeof(_dataRecv), 0 );

    _SetState( &_dataRecv, osIDLE );

    _dataRecv.lpStore = Store_New( cbSTORE_SIZE_RECV );
    if( !_dataRecv.lpStore )
        goto lErr;

    return TRUE;

lErr:

    if( _dataRecv.lpStore )
        Store_Delete( &_dataRecv.lpStore );

    return FALSE;
}


VOID FILE_TRANSFER::Obex_Reset( VOID )
{
    _SetState( &_dataRecv, osIDLE );

    Store_Empty( _dataRecv.lpStore );
}


BOOL FILE_TRANSFER::Obex_ReceiveData( XFER_TYPE xferType, LPVOID lpvData, DWORD dwDataSize )
{
    return Store_AddData( _dataRecv.lpStore, lpvData, dwDataSize );
}


error_status_t
FILE_TRANSFER::Obex_Connect( __int64 dwTotalSize )
{
    error_status_t status = ERROR_NOT_ENOUGH_MEMORY;

    LPSTORE lpStore = Store_New( CONNECT_PKTLEN+30 );

    DbgLog2( SEV_FUNCTION, "Obex_Connect(0x%x): dwTotalSize: %d",
             OBEX_OPCODE_CONNECT, (ULONG) dwTotalSize );

    ExitOnFalse( _dataRecv.state == osIDLE );

    ExitOnNull( lpStore );

    if (_dialect == dialNt5)
        {
        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_OPCODE_CONNECT) );
        ExitOnFalse( Store_AddData2Byte(lpStore, CONNECT_PKTLEN+5) );
        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_VERSION) );
        ExitOnFalse( Store_AddData1Byte(lpStore, CONNECT_FLAGS) );
        ExitOnFalse( Store_AddData2Byte(lpStore, CONNECT_MAXPKT) );
        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_PARAM_LENGTH) );
        ExitOnFalse( Store_AddData4Byte(lpStore, (ULONG) dwTotalSize) );

        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_PARAM_WHO) );
        ExitOnFalse( Store_AddData2Byte(lpStore, sizeof(UUID)+3) );
        ExitOnFalse( Store_AddDataUuid(lpStore, &DIALECT_ID_NT5) );
        ExitOnFalse( _PokePacketSizeIntoStore(lpStore) );

        DbgLog1( SEV_INFO, "Connect (NT5) Packet Size: %d",
                 Store_GetDataUsed( lpStore ) );

        status = _Request( lpStore, OBEX_REPLY_SUCCESS );
        ExitOnErr( status );

        status = _WaitForReply( CONNECT_TIMEOUT, OBEX_REPLY_SUCCESS );
        }
    else
        {
        DbgLog( SEV_INFO, "trying with Win9x Connect" );

        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_OPCODE_CONNECT) );
        ExitOnFalse( Store_AddData2Byte(lpStore, CONNECT_PKTLEN+5) );
        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_VERSION) );
        ExitOnFalse( Store_AddData1Byte(lpStore, CONNECT_FLAGS) );
        ExitOnFalse( Store_AddData2Byte(lpStore, CONNECT_MAXPKT) );
        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_PARAM_LENGTH) );
        ExitOnFalse( Store_AddData4Byte(lpStore, (ULONG) dwTotalSize) );

        status = _Request( lpStore, OBEX_REPLY_SUCCESS );
        ExitOnErr( status );

        status = _WaitForReply( CONNECT_TIMEOUT, OBEX_REPLY_SUCCESS );
        }

    DbgLog1(SEV_INFO, "wait result was %d", status);

    if (ERROR_TIMEOUT == status)
        {
        DbgLog( SEV_FUNCTION, "Obex_Connect: no connect reply; assuming Win95 [%d]" );

        // Win95 doesn't reply;
        // manually fill in the values we would
        // have gotten in a connect response
        _dataRecv.b1Version   = 0x10;  // assume the lowest version, Obex 1.0
        _dataRecv.b1Flags     = 0;
        _dataRecv.b2MaxPacket = 2000;
        status = 0;

        _dialect = dialWin95;
        }

    ExitOnErr( status );

    _SetState( &_dataRecv, osCONN );

    //
    // See Obex_PutBody for reasoning on the -16...
    // Make sure Acked <= Total; this is just an estimate, anyway.
    //

    _blockSize = _dataRecv.b2MaxPacket - 16;

lExit:

    Store_Delete( &lpStore );

    DbgLog1( SEV_FUNCTION, "Obex_Connect leave [%d]", status );

    return status;
}


error_status_t
FILE_TRANSFER::Obex_Disconnect(
                               error_status_t error
                               )
{
    error_status_t status = ERROR_NOT_ENOUGH_MEMORY;
    LPSTORE lpStore = Store_New( DISCONNECT_PKTLEN );

    DbgLog( SEV_FUNCTION, "Obex_Disconnect" );

    // if we are in the middle of sending a file, abort it before disconnecting.
    // this will set the state to osCONN.
    if( _dataRecv.state == osFILE )
        Obex_Abort(error);

    ExitOnFalse( _dataRecv.state == osCONN );

    ExitOnNull( lpStore );

    ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_OPCODE_DISCONNECT) );
    ExitOnFalse( Store_AddData2Byte(lpStore, DISCONNECT_PKTLEN) );

    status = _Request( lpStore, OBEX_REPLY_SUCCESS );
    ExitOnErr( status );

    status = _WaitForReply( DISCONN_TIMEOUT, OBEX_REPLY_SUCCESS );

lExit:

    _SetState( &_dataRecv, osIDLE );

    Store_Delete( &lpStore );

    DbgLog1( SEV_FUNCTION, "Obex_Disconnect leave [%d]", status );

    return status;
}


error_status_t
FILE_TRANSFER::Obex_Abort(
                          error_status_t error
                          )
{
    error_status_t status = ERROR_NOT_ENOUGH_MEMORY;
    LPSTORE lpStore = Store_New( ABORT_PKTLEN );

    DbgLog( SEV_FUNCTION, "Obex_Abort" );

    ExitOnFalse( _dataRecv.state == osFILE );

    ExitOnNull( lpStore );

    ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_OPCODE_ABORT) );
    ExitOnFalse( Store_AddData2Byte(lpStore, ABORT_PKTLEN) );

    if (status && _dialect != dialWin95)
        {
        ExitOnFalse( Store_AddData1Byte(lpStore, PRIVATE_PARAM_WIN32_ERROR) );
        ExitOnFalse( Store_AddData4Byte(lpStore, error) );
        }

    status = _Request( lpStore, OBEX_REPLY_SUCCESS );
    ExitOnErr( status );

lExit:

    _SetState( &_dataRecv, osCONN );

    Store_Delete( &lpStore );

    DbgLog1( SEV_FUNCTION, "Obex_Abort leave [%d]", status );

    return status;
}


error_status_t
FILE_TRANSFER::_Put(
    LPWSTR wszObj,
    __int64 dwObjSize,
    FILETIME * pFileTime,
    LPBYTE1 pb1Data,
    BYTE2 b2DataSize,
    BOOL fFinal
    )
{
    DWORD msg;

    error_status_t status = ERROR_NOT_ENOUGH_MEMORY;
    BYTE1   b1Opcode = ( fFinal ? OBEX_OPCODE_PUT_FINAL : OBEX_OPCODE_PUT );
    BYTE1 b1BodyParam = ( fFinal ? OBEX_PARAM_BODY_END : OBEX_PARAM_BODY );

    LPSTORE lpStore  = Store_New( _dataRecv.b2MaxPacket );

    DbgLog1( SEV_FUNCTION, "_Put, fFinal = %s", SzBool(fFinal) );

    msg = MC_IRXFER_SEND_FAILED;

    ExitOnFalse( _dataRecv.state == osCONN || _dataRecv.state == osFILE );

    ExitOnNull( lpStore );

    ExitOnFalse( Store_AddData1Byte(lpStore, b1Opcode) );

    // add buffer space for the packet length
    ExitOnFalse( Store_AddData2Byte(lpStore, 0) );

    if( wszObj )
        {
        WCHAR wszNameOnly[MAX_PATH];

        //
        // strip the path from the full file name
        //
        StripPath(wszObj, wszNameOnly,sizeof(wszNameOnly)/sizeof(WCHAR) );

        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_PARAM_NAME) );
        ExitOnFalse( Store_AddData2Byte(lpStore, 3+CbWsz(wszNameOnly)) );
        ExitOnFalse( Store_AddDataWsz(lpStore, wszNameOnly) );
        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_PARAM_LENGTH) );
        ExitOnFalse( Store_AddData4Byte(lpStore, (ULONG) dwObjSize) );

        if (_dialect == dialWin95)
            {
            DWORD UnixTime;

            if( FileTimeToUnixTime(pFileTime, &UnixTime) )
                {
                ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_PARAM_UNIX_TIME) );
                ExitOnFalse( Store_AddData4Byte(lpStore, UnixTime) );
                }
            }
        else
            {
            char  IsoTimeA[1+ISO_TIME_LENGTH];
            WCHAR IsoTimeW[1+ISO_TIME_LENGTH];

            status = FileTimeToiso8601(pFileTime, IsoTimeA);
            if (status)
                {
                goto lExit;
                }

            if (0 == MultiByteToWideChar(CP_ACP, 0L, IsoTimeA, -1, IsoTimeW, 1+ISO_TIME_LENGTH))
                {
                status = GetLastError();
                goto lExit;
                }

            DbgLog2(SEV_INFO, "    ISO time: len %d '%S'", 3+CbWsz(IsoTimeW), IsoTimeW);

            ExitOnFalse( Store_AddData1Byte( lpStore, OBEX_PARAM_ISO_TIME ));
            ExitOnFalse( Store_AddData2Byte( lpStore, 3+CbWsz(IsoTimeW) ));
            ExitOnFalse( Store_AddDataWsz  ( lpStore, IsoTimeW ));
            }
        }

    ExitOnFalse( Store_AddData1Byte(lpStore, b1BodyParam) );
    ExitOnFalse( Store_AddData2Byte(lpStore, b2DataSize+3) );
    ExitOnFalse( Store_AddData(lpStore, pb1Data, b2DataSize ) );

    DbgLog1(SEV_INFO, "    data size %d", b2DataSize);

    ExitOnFalse( _PokePacketSizeIntoStore(lpStore) );

    status = _Request( lpStore, 0 );
    ExitOnErr( status );

    ++_blocksSent;

    msg = MC_IRXFER_SEND_WAIT_FAILED;

    if (fFinal) {
        //
        //  final put
        //
        do {

            status = _WaitForReply( REPLY_TIMEOUT, OBEX_REPLY_SUCCESS );

            if (status != ERROR_TIMEOUT) {

                ++_blocksAcked;
            }

            DbgLog3(SEV_INFO, "    blocks %d   acks %d   status %x",
                    _blocksSent, _blocksAcked, status );

         } while ( !status && _blocksAcked < _blocksSent );

    } else {
        //
        //  non-final put
        //
#if 0
        if (GetTickCount() - _lastAckTime > MAX_UPDATE_DELAY) {
#endif
            //
            //  it has been more than 5 seconds since last ack
            //
            status = _WaitForReply( REPLY_TIMEOUT, OBEX_REPLY_SUCCESS );
            if (status != ERROR_TIMEOUT)
                {
                ++_blocksAcked;
                }

            DbgLog3(SEV_INFO, "    blocks %d   acks %d   status %x",
                    _blocksSent, _blocksAcked, status );
#if 0
        } else {
            //
            //  less than 5 seconds since last ack
            //
            status = _WaitForReply( 0, OBEX_REPLY_CONTINUE );
            if (status == ERROR_TIMEOUT)
                {
                status = 0;
                }
            else
                {
                ++_blocksAcked;
                }

            DbgLog3(SEV_INFO, "    blocks %d   acks %d   status %x",
                    _blocksSent, _blocksAcked, status );
        }
#endif
    }
    ExitOnErr( status );

    _SetState( &_dataRecv, (fFinal ? osCONN : osFILE) );

lExit:

    if (status)
        {
        ASSERT( msg );

        DWORD     dwEventStatus = 0;
        EVENT_LOG EventLog(WS_EVENT_SOURCE,&dwEventStatus);

        if (!dwEventStatus)
            {
            ReportFileError( msg, _dataFileRecv.szFileName, status );
            }
        }

    Store_Delete( &lpStore );

    DbgLog1( SEV_FUNCTION, "_Put leave [%d]", status );

    return status;
}


error_status_t
FILE_TRANSFER::_WaitForReply(
    DWORD dwTimeout,
    BYTE1 b1NeededReply
    )
{
    BOOL fProcessed;
    long StartTime = GetTickCount();
    long EndTime = StartTime + dwTimeout;

    error_status_t status = 0;
    error_status_t ExpectedStatus = 0;

    DbgLog1( SEV_FUNCTION, "_WaitForReply( %d )", dwTimeout );

    ASSERT( b1NeededReply == OBEX_REPLY_SUCCESS  ||
            b1NeededReply == OBEX_REPLY_CONTINUE );

    if (b1NeededReply == OBEX_REPLY_CONTINUE)
        {
        ExpectedStatus = ERROR_CONTINUE;
        }

    if (TRUE == Obex_ConsumePackets( xferSEND, &status ))
        {
        return status;
        }

    if (dwTimeout == TIMEOUT_INFINITE)
        {
        BOOL fProcessedPacket = FALSE;

        do
            {
            status = Sock_CheckForReply( TIMEOUT_INFINITE );
            if (status == WSAETIMEDOUT)
                {
                DbgLog(SEV_WARNING, "    infinite wait returned WSAETIMEDOUT");
                status = 0;
                }

            if (!status)
                {
                fProcessedPacket = Obex_ConsumePackets( xferSEND, &status );
                }
            }
        while ( !fProcessedPacket && !status );
        }
    else
        {
        BOOL fProcessedPacket = FALSE;

        DbgLog1(SEV_INFO, "    end time = %d", EndTime);

        do
            {
            status = Sock_CheckForReply( EndTime - GetTickCount() );
            if (status == WSAETIMEDOUT)
                {
                status = ERROR_TIMEOUT;
                }

            if (!status)
                {
                fProcessedPacket = Obex_ConsumePackets( xferSEND, &status );
                }
            }
        while ( !fProcessedPacket && !status && (EndTime - (long) GetTickCount() > 0) );

        if (!fProcessedPacket && !status)
            {
            status = ERROR_TIMEOUT;
            }
        }

    if ( status == ExpectedStatus )
        {
        status = 0;
        }

    DbgLog1( SEV_FUNCTION, "_WaitForReply leave [%d]", status );

    return status;
}


BOOL
FILE_TRANSFER::Obex_ConsumePackets(
    XFER_TYPE xferType,
    error_status_t * pStatus
    )
{
    BOOL    fRet     = FALSE;
    DWORD   dwUsed;
    BYTE1   b1Opcode;
    BYTE2   b2Length;
    LPSTORE lpStore  = _dataRecv.lpStore ;

    dwUsed = Store_GetDataUsed( lpStore );

    DbgLog1( SEV_FUNCTION, "Obex_ConsumePackets: dwUsed: %ld", dwUsed );

    // Must have at least MIN_PACKET_SIZE bytes to do anything
    if( dwUsed < MIN_PACKET_SIZE )
        {
        DbgLog( SEV_INFO, "not enough bytes");
        goto lExit;
        }

    // Get status/opcode
    if( !Store_GetData1Byte(lpStore, &b1Opcode) )
        {
        DbgLog( SEV_INFO, "    can't get opcode");
        goto lExit;
        }

    // Get total packet length
    if( !Store_GetData2Byte(lpStore, &b2Length) )
        {
        DbgLog( SEV_INFO, "    can't get packet length");
        goto lExit;
        }

    // We must have all of the packet to continue
    if (dwUsed < b2Length)
        {
        DbgLog2( SEV_INFO, "    have: %d of %d",
                 dwUsed, b2Length );

        // Put back the 3 bytes we just read
        Store_SkipData( lpStore, -3 );
        goto lExit;
        }

    DbgLog2( SEV_INFO, "    b1Opcode: 0x%x  b2Length: %d",
             b1Opcode, b2Length );

    // if we're waiting, this must be a response packet
    if( xferType == xferSEND )
        {
        *pStatus = _HandleResponse( b1Opcode, b2Length-3 );
        }
    else
        {
        *pStatus = _HandleRequest( b1Opcode, b2Length-3 ) ;
        }

    Store_RemoveData( lpStore, b2Length );

    _lastAckTime = GetTickCount();

    fRet = TRUE;

lExit:

    DbgLog2( SEV_FUNCTION, "Obex_ConsumePackets leave [%s, %d]", SzBool(fRet), *pStatus );

    return fRet;
}


INT FILE_TRANSFER::_ValidOpcode( OBEXSTATE state, BYTE1 b1Opcode )
{
    switch( b1Opcode )
    {
    case OBEX_OPCODE_CONNECT:
        if( state == osIDLE ) return OBEX_OPCODE_VALID;
        break;

    case OBEX_OPCODE_DISCONNECT:
        if( state == osCONN || state == osFILE ) return OBEX_OPCODE_VALID;
        break;

    case OBEX_OPCODE_PUT:
    case OBEX_OPCODE_PUT_FINAL:
        if( state == osCONN || state == osFILE ) return OBEX_OPCODE_VALID;
        break;

    case OBEX_OPCODE_SETPATH:
        if( state == osCONN ) return OBEX_OPCODE_VALID;
        break;

    case OBEX_OPCODE_ABORT:
        if( state == osFILE ) return OBEX_OPCODE_VALID;
        break;

    default:
        return OBEX_OPCODE_NOTIMP;
    }

    DbgLog1( SEV_FUNCTION, "_ValidOpcode: Invalid opcode: 0x%2.2x", b1Opcode);

    return OBEX_OPCODE_INVALID;
}


error_status_t
FILE_TRANSFER::_HandleResponse(
    BYTE1 b1Opcode,
    BYTE2 b2Length
    )
{
    error_status_t status = ERROR_NOT_ENOUGH_MEMORY;

    DbgLog1( SEV_FUNCTION, "_HandleResponse b2Length[0x%x]", b2Length );

    if( _dataRecv.state == osIDLE )
        {
        BYTE2 RemoteMaxPacket;

        // this should be a connect response.  get the conn data
        //
        ExitOnFalse( Store_GetData1Byte(_dataRecv.lpStore, &_dataRecv.b1Version)   );
        DbgLog1( SEV_INFO, "_HandleResponse, b1Version[0x%x]", _dataRecv.b1Version );

        ExitOnFalse( Store_GetData1Byte(_dataRecv.lpStore, &_dataRecv.b1Flags)     );
        DbgLog1( SEV_INFO, "_HandleResponse, b1Flags[0x%x]", _dataRecv.b1Flags );

        ExitOnFalse( Store_GetData2Byte(_dataRecv.lpStore, &RemoteMaxPacket) );
        DbgLog1( SEV_INFO, "_HandleResponse, b2MaxPacket[0x%x]", RemoteMaxPacket );

        _dataRecv.b2MaxPacket = min(RemoteMaxPacket, cbSTORE_SIZE_RECV);

        b2Length -= 4;

        status = _ParseParams( b1Opcode, b2Length );
        }
    else
        {
        status = _ParseParams( b1Opcode, b2Length );
        if (!status &&
            _dataRecv.state == osFILE &&
            (b1Opcode == OBEX_REPLY_SUCCESS || b1Opcode == OBEX_REPLY_CONTINUE))
            {
            if (_blocksAcked > 1)
                {
                __int64 currentFileBytesAcked = (_blocksAcked-1) * _blockSize;
                if (currentFileBytesAcked > _dataXferRecv.dwFileSize)
                    {
                    currentFileBytesAcked = _dataXferRecv.dwFileSize;
                    }

                _UpdateSendProgress( rpcBinding,
                                    _cookie,
                                    _dataFileRecv.szFileName,
                                    _dataXferRecv.dwTotalSize,
                                    _completedFilesSize + currentFileBytesAcked,
                                    &status
                                    );
                if (status)
                    {
                    DbgLog1( SEV_WARNING, "_HandleResponse: UpdateSendProgress returned %d", status );
                    }
                }
            }
        }

    if (!status && b1Opcode != OBEX_REPLY_SUCCESS && b1Opcode != OBEX_REPLY_CONTINUE)
        {
        status = ObexStatusToWin32( b1Opcode );
        DbgLog2( SEV_WARNING, "_HandleResponse: mapped OBEX 0x%x to Win32 %d", b1Opcode, status );
        }

lExit:

    return status;
}

#ifdef DBG

struct
{
    BYTE1   opcode;
    char *  name;
}
OpcodeNames[] =
{
    { OBEX_OPCODE_CONNECT, "connect" },
    { OBEX_OPCODE_DISCONNECT, "disconnect" },
    { OBEX_OPCODE_PUT, "put" },
    { OBEX_OPCODE_ABORT, "abort" },
    { OBEX_OPCODE_SETPATH, "setpath" },
    { OBEX_OPCODE_PUT_FINAL, "putfinal" }
};

void
LogOpcode(
           char * prefix,
           BYTE1 opcode,
           BYTE2 length
           )
{
    unsigned i;

    for (i=0; i < sizeof(OpcodeNames)/sizeof(OpcodeNames[0]); ++i)
        {
        if (opcode == OpcodeNames[i].opcode)
            {
            DbgLog3( SEV_INFO, "%s: %s length %d", prefix, OpcodeNames[i].name, length );
            return;
            }
        }

    DbgLog3( SEV_ERROR, "%s: unknown opcode 0x%x, length %d", prefix, opcode, length );
}

#else

inline void
LogOpcode(
           char * prefix,
           BYTE1 opcode,
           BYTE2 length
           )
{
}

#endif


error_status_t
FILE_TRANSFER::_HandleRequest(
    BYTE1 b1Opcode,
    BYTE2 b2Length
    )
{
    INT  nValid;
    BOOL fRet;

    LogOpcode( "_HandleRequest", b1Opcode, b2Length );

    // only accept valid opcodes, otherwise discard the packet and move on
    nValid = _ValidOpcode( _dataRecv.state, b1Opcode );

    if( nValid == OBEX_OPCODE_INVALID )
        {
        _HandleBadRequest( b1Opcode );
        return ERROR_INVALID_PARAMETER;
        }
    else if( nValid == OBEX_OPCODE_NOTIMP )
        {
        _HandleNotImplemented( b1Opcode );
        return ERROR_INVALID_PARAMETER;
        }

    // opcode is valid

    switch ( b1Opcode )
        {
        case OBEX_OPCODE_CONNECT:
            _HandleConnect( b1Opcode, b2Length );
            return 0;

        case OBEX_OPCODE_DISCONNECT:
            _HandleDisconnect( b1Opcode, b2Length );
            return 0xffffffff;

        case OBEX_OPCODE_PUT:
            return _HandlePut( b1Opcode, b2Length, FALSE );

        case OBEX_OPCODE_PUT_FINAL:
            return _HandlePut( b1Opcode, b2Length, TRUE );

        case OBEX_OPCODE_SETPATH:
            return _HandleSetPath( b1Opcode, b2Length );

        case OBEX_OPCODE_ABORT:
            _HandleAbort( b1Opcode, b2Length );
            return ERROR_CANCELLED;

        default:
            ASSERT( 0 && "IRMON: bad OBEX opcode" );
            return ERROR_INVALID_PARAMETER;
        }

    return 0;
}


BOOL FILE_TRANSFER::_HandleConnect( BYTE1 b1Opcode, BYTE2 b2Length )
{
    BYTE1   ReplyCode;
    BYTE2   RemoteMaxPacket;

    error_status_t status = ERROR_NOT_ENOUGH_MEMORY;
    LPSTORE lpStore = 0;

    DbgLog( SEV_FUNCTION, "_HandleConnect" );

    ExitOnFalse( Store_GetData1Byte(_dataRecv.lpStore, &_dataRecv.b1Version) );
    b2Length -= 1;

    ExitOnFalse( Store_GetData1Byte(_dataRecv.lpStore, &_dataRecv.b1Flags) );
    b2Length -= 1;

    ExitOnFalse( Store_GetData2Byte(_dataRecv.lpStore, &RemoteMaxPacket) );
    b2Length -= 2;

    _dataRecv.b2MaxPacket = min(RemoteMaxPacket, cbSTORE_SIZE_RECV);

    lpStore = Store_New( CONNECT_PKTLEN + 30);
    ExitOnNull( lpStore );

    status = Xfer_ConnStart();
    if (!status)
        {
        Xfer_FileInit();
        }

    //
    // Parse parms before checking login status so we can send richer error codes
    // to an NT client.
    //
    if (!status)
        {
        status = _ParseParams( b1Opcode, b2Length );
        }

    if (!status)
        {
        if (!g_fAllowReceives || g_fShutdown)
            {
            // We'd like to return ERROR_NOT_LOGGED_ON but the NT5 client can't handle this error.
            //
            status = ERROR_ACCESS_DENIED;
            }
        }

    DbgLog1(SEV_INFO, "status = %d", status);

    ReplyCode = StatusToReplyCode(b1Opcode, status);

    if (_dialect == dialNt5)
        {
        DbgLog(SEV_INFO, "using NT5 dialect");
        }

    ExitOnFalse( Store_AddData1Byte(lpStore, ReplyCode) );
    ExitOnFalse( Store_AddData2Byte(lpStore, 0) );          // placeholder for length
    ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_VERSION) );
    ExitOnFalse( Store_AddData1Byte(lpStore, CONNECT_FLAGS) );
    ExitOnFalse( Store_AddData2Byte(lpStore, CONNECT_MAXPKT) );

    if (status && _dialect == dialNt5)
        {
        ExitOnFalse( Store_AddData1Byte(lpStore, PRIVATE_PARAM_WIN32_ERROR) );
        ExitOnFalse( Store_AddData4Byte(lpStore, status) );
        }
    else if (_dialect == dialNt5)
        {
        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_PARAM_WHO) );
        ExitOnFalse( Store_AddData2Byte(lpStore, sizeof(UUID)+3) );
        ExitOnFalse( Store_AddDataUuid(lpStore, &DIALECT_ID_NT5) );
        }

    ExitOnFalse( _PokePacketSizeIntoStore(lpStore) );

    if (status)
        {
        _Respond( lpStore );
        }
    else
        {
        status = _Respond( lpStore );
        }

    ExitOnErr( status );

    _SetState( &_dataRecv, osCONN );

    status = _ReceiveInProgress(rpcBinding, _DeviceName, &_cookie, FALSE);

    DbgLog3( status ? SEV_ERROR : SEV_INFO, "ReceiveInProgress [%S] returned %d, cookie %p", _DeviceName, status, (void *) _cookie );

    ExitOnErr( status );

    _fInUiReceiveList = TRUE;

lExit:

    if( status )
        Xfer_ConnEnd();

    if (lpStore)
        {
        Store_Delete( &lpStore );
        }

    DbgLog2( SEV_FUNCTION, "_HandleConnect leave [%s] %d", SzBool(_dataRecv.state == osCONN), status );

    return ( _dataRecv.state == osCONN );
}

#if 1

error_status_t
FILE_TRANSFER::ObexStatusToWin32(
    BYTE1 ObexStatus
    )
{
    switch (ObexStatus)
        {
        case OBEX_REPLY_SUCCESS:
            return 0;

        case OBEX_REPLY_CONTINUE:
            return ERROR_CONTINUE;

        case OBEX_REPLY_FAIL_FORBIDDEN:
            return ERROR_ACCESS_DENIED;

        case OBEX_REPLY_FAIL_TOOBIG:
            return ERROR_DISK_FULL;

        case OBEX_REPLY_FAIL_UNAVAILABLE:
            return ERROR_NOT_ENOUGH_MEMORY;

        case OBEX_REPLY_FAIL_BADREQUEST:
        default:
            DbgLog1(SEV_ERROR, "obex error 0x%x", ObexStatus);
            return ERROR_INVALID_DATA;
        }
}

#endif


BYTE1
FILE_TRANSFER::StatusToReplyCode(
    BYTE1 b1Opcode,
    DWORD status
    )
{
    if (status)
        {
        DbgLog1(SEV_ERROR, "win32 error 0x%x", status);
        }

    switch (status)
        {
        case 0:

            if (b1Opcode == OBEX_OPCODE_PUT) {

                return OBEX_REPLY_CONTINUE;
            }

            return OBEX_REPLY_SUCCESS;

        case ERROR_NOT_LOGGED_ON:
        case ERROR_ACCESS_DENIED:
        case ERROR_CANCELLED:

            return OBEX_REPLY_FAIL_FORBIDDEN;

        case ERROR_DISK_FULL:
            return OBEX_REPLY_FAIL_TOOBIG;

        case ERROR_INVALID_DATA:
            return OBEX_REPLY_FAIL_BADREQUEST;

        case ERROR_NOT_ENOUGH_MEMORY:
            return OBEX_REPLY_FAIL_UNAVAILABLE;

        default:
            DbgLog(SEV_WARNING, "error not mapped");
            return OBEX_REPLY_FAIL_UNAVAILABLE;
        }
}


BOOL
FILE_TRANSFER::SendReplyWin32(
    BYTE1 b1Opcode,
    DWORD status
    )
{
    LPSTORE lpStore;

    if (status)
        {
        DbgLog1( SEV_WARNING, "sending Win32 error [%d]", status );
        }

    lpStore = Store_New( REPLY_PKTLEN+5 );
    ExitOnNull( lpStore );

    ExitOnFalse( Store_AddData1Byte(lpStore, StatusToReplyCode(b1Opcode, status)) );
    ExitOnFalse( Store_AddData2Byte(lpStore, REPLY_PKTLEN) );

    if (status && _dialect != dialWin95)
        {
        DbgLog(SEV_INFO, "(including WIN32_ERROR parameter)");
        ExitOnFalse( Store_AddData1Byte(lpStore, PRIVATE_PARAM_WIN32_ERROR) );
        ExitOnFalse( Store_AddData4Byte(lpStore, status) );
        }

    status = _Respond( lpStore );

lExit:

    Store_Delete( &lpStore );

    if (status)
        {
        Xfer_ConnEnd();

        _SetState( &_dataRecv, osIDLE );

        DbgLog1( SEV_FUNCTION, "SendReplyWin32 failed [%d]", status);
        return FALSE;
        }

    return TRUE;
}


BOOL
FILE_TRANSFER::SendReplyObex(
    BYTE1 ObexCode
    )
{
    error_status_t status = ERROR_NOT_ENOUGH_MEMORY;
    LPSTORE lpStore = NULL;

    if (ObexCode != OBEX_REPLY_SUCCESS)
        {
        DbgLog1( SEV_WARNING, "sending OBEX error [0x%x]", ObexCode );
        }

    lpStore = Store_New( REPLY_PKTLEN );
    ExitOnNull( lpStore );

    ExitOnFalse( Store_AddData1Byte(lpStore, ObexCode) );
    ExitOnFalse( Store_AddData2Byte(lpStore, REPLY_PKTLEN) );

    status = _Respond( lpStore );

lExit:

    Store_Delete( &lpStore );

    if (status)
        {
        Xfer_ConnEnd();

        _SetState( &_dataRecv, osIDLE );

        DbgLog1( SEV_FUNCTION, "SendReplyObex failed [%d]", status);
        return FALSE;
        }

    return TRUE;
}


BOOL FILE_TRANSFER::_HandleDisconnect( BYTE1 b1Opcode, BYTE2 b2Length )
{
    DbgLog( SEV_FUNCTION, "_HandleDisconnect" );

    SendReplyObex( OBEX_REPLY_SUCCESS );

    Xfer_ConnEnd();

    _SetState( &_dataRecv, osIDLE );

    HandleClosure( 0 );

    DbgLog( SEV_FUNCTION, "_HandleDisconnect leave [TRUE]" );

    return TRUE;
}


error_status_t
FILE_TRANSFER::_HandlePut(
    BYTE1 b1Opcode,
    BYTE2 b2Length,
    BOOL fFinal
    )
{
    error_status_t status = 0;

    DbgLog1( SEV_FUNCTION, "_HandlePut%s", fFinal ? " (final)" : "" );

    status = _ParseParams( b1Opcode, b2Length );

    // if final put packet, write 0-length data packet to ensure the
    // file is closed (for 0-length files).
    // don't watch the error code - if the file is already closed, it
    // would return FALSE.
    if( fFinal )
        {
        if (!status)
            {
            status = Xfer_FileWriteBody( NULL, 0, TRUE );
            }
        else
            {
            Xfer_FileWriteBody( NULL, 0, TRUE );
            }
        }

    if (!SendReplyWin32(b1Opcode, status))
        {
        DbgLog1(SEV_WARNING, "_HandlePut leave [%d]", status);
        return status;
        }

    _SetState( &_dataRecv, (fFinal ? osCONN : osFILE) );

    DbgLog1( SEV_FUNCTION, "_HandlePut leave [%d]", status );

//    return ( _dataRecv.state == osCONN );

    return status;
}


error_status_t
FILE_TRANSFER::_HandleSetPath(
    BYTE1 b1Opcode,
    BYTE2 b2Length
    )
{
    error_status_t status = ERROR_NOT_ENOUGH_MEMORY;

    DbgLog( SEV_FUNCTION, "_HandleSetPath" );

    // get the flags and constants
    ExitOnFalse( Store_GetData1Byte(_dataRecv.lpStore, &_dataPath.b1Flags) );
    b2Length -= 1;

    ExitOnFalse( Store_GetData1Byte(_dataRecv.lpStore, &_dataPath.b1Constants) );
    b2Length -= 1;

    status = 0;

    // pop up a level
    if( _dataPath.b1Flags & SETPATH_UPALEVEL )
        {
        status = Xfer_SetPath( szPREVDIR );
        }

    if (!status)
        {
        status = _ParseParams( b1Opcode, b2Length );
        }

    SendReplyWin32(b1Opcode, status);

lExit:

    DbgLog1( SEV_FUNCTION, "_HandleSetPath leave [%d]", status);

    return status;
}


BOOL
FILE_TRANSFER::_HandleAbort(
    BYTE1 b1Opcode,
    BYTE2 b2Length )
{
    BOOL    fRet    = FALSE;
    LPSTORE lpStore = NULL;

    DbgLog( SEV_FUNCTION, "_HandleAbort" );

    Xfer_FileAbort();

    if (!SendReplyWin32(b1Opcode, 0))
        {
        return FALSE;
        }

    _SetState( &_dataRecv, osCONN );

    DbgLog( SEV_FUNCTION, "_HandleAbort leave" );

    return TRUE;
}


VOID FILE_TRANSFER::_SetState( LPDATA_CONN lpDataConn, OBEXSTATE os )
{
    lpDataConn->state = os;

    DbgLog2( SEV_INFO, "_SetState[%s], %s", (lpDataConn == &_dataRecv ? "SEND":"RECV"), _szState[os] );
}


error_status_t
FILE_TRANSFER::_ParseParams(
    BYTE1 b1Opcode,
    BYTE2 b2Length
    )
{
    error_status_t     status = 0;

    BOOL   fHaveName = FALSE;
    BYTE1  b1Param;
    BYTE2  b2ParamLen;
    LPVOID lpvData;
    PSZ    EndOfData = PSZ(Store_GetDataPtr( _dataRecv.lpStore )) + b2Length;

    DbgLog1( SEV_FUNCTION, "_ParseParams [0x%x]", b1Opcode );

    // get the data out of the buffer
    while( PSZ(Store_GetDataPtr( _dataRecv.lpStore )) < EndOfData )
        {
        if ( !Store_GetData1Byte(_dataRecv.lpStore, &b1Param))
            {
            status = ERROR_INVALID_DATA;
            goto lExit;
            }

#ifdef DBG
        Store_DumpParameter( _dataRecv.lpStore, b1Param );
#endif

        switch( b1Param )
            {
            case OBEX_PARAM_NAME:
                {
                WCHAR wszName[MAX_PATH];

                if ( !Store_GetData2Byte(_dataRecv.lpStore, &b2ParamLen) )
                    {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    goto lExit;
                    }

                if (b2ParamLen >= MAX_PATH)
                    {
                    status = ERROR_INVALID_DATA;
                    goto lExit;
                    }

                if ( !Store_GetDataWsz(_dataRecv.lpStore, wszName, sizeof(wszName)) )
                    {
                    status = ERROR_INVALID_DATA;
                    goto lExit;
                    }

                if( CchWsz(wszName) > 0 )
                    {
                    fHaveName = TRUE;

                    if( b1Opcode == OBEX_OPCODE_SETPATH )
                        status = Xfer_SetPath( wszName );
                    if( b1Opcode == OBEX_OPCODE_PUT || b1Opcode == OBEX_OPCODE_PUT_FINAL )
                        status = Xfer_FileSetName( wszName );

                    if (status)
                        {
                        goto lExit;
                        }
                    }
                }
                break;

            case OBEX_PARAM_LENGTH:
                {
                BYTE4 b4Size;

                if ( !Store_GetData4Byte(_dataRecv.lpStore, &b4Size) )
                    {
                    status = ERROR_INVALID_DATA;
                    goto lExit;
                    }

                if( b1Opcode == OBEX_OPCODE_CONNECT )
                    {
                    Xfer_SetSize( b4Size );
                    }
                else if( b1Opcode == OBEX_OPCODE_PUT || b1Opcode == OBEX_OPCODE_PUT_FINAL )
                    {
                    if( !Xfer_FileSetSize(b4Size) )
                        {
                        DWORD     dwEventStatus = 0;
                        EVENT_LOG EventLog(WS_EVENT_SOURCE,&dwEventStatus);

                        if (!dwEventStatus)
                            {
                            EventLog.ReportError(CAT_IRXFER, MC_IRXFER_DISK_FULL);
                            }

                        status = ERROR_DISK_FULL;
                        goto lExit;
                        }
                    }
                break;
                }

            case OBEX_PARAM_UNIX_TIME:
                {
                DWORD UnixTime;

                if ( !Store_GetData4Byte(_dataRecv.lpStore, &UnixTime) )
                    {
                    status = ERROR_INVALID_DATA;
                    goto lExit;
                    }

                if( b1Opcode == OBEX_OPCODE_PUT || b1Opcode == OBEX_OPCODE_PUT_FINAL )
                    {
                    if (!UnixTimeToFileTime( UnixTime, &_dataFileRecv.filetime))
                        {
                        DbgLog1(SEV_ERROR, "UnixTimeToFileTime() failed on 0x%x", UnixTime);
                        status = ERROR_INVALID_DATA;
                        goto lExit;
                        }
                    }

                break;
                }

            case OBEX_PARAM_ISO_TIME:
                {
                char  IsoTimeA[1+ISO_TIME_LENGTH];
                WCHAR IsoTimeW[1+ISO_TIME_LENGTH];

                if ( !Store_GetData2Byte(_dataRecv.lpStore, &b2ParamLen) )
                    {
                    status = ERROR_INVALID_DATA;
                    goto lExit;
                    }

                if (b2ParamLen > 3+(1+ISO_TIME_LENGTH)*sizeof(WCHAR))
                    {
                    DbgLog2(SEV_ERROR, "ISO time length is %d, string is '%S'", b2ParamLen, Store_GetDataPtr( _dataRecv.lpStore ));
                    status = ERROR_INVALID_DATA;
                    goto lExit;
                    }

                ExitOnFalse( Store_GetDataWsz( _dataRecv.lpStore, IsoTimeW, sizeof(IsoTimeW)));

                if( b1Opcode == OBEX_OPCODE_PUT || b1Opcode == OBEX_OPCODE_PUT_FINAL )
                    {
                    if (0 == WideCharToMultiByte(CP_ACP, 0L, IsoTimeW, -1, IsoTimeA, 1+ISO_TIME_LENGTH, NULL, NULL))
                        {
                        DbgLog2(SEV_ERROR, "WideCharToMultiByte failed %d on '%S'", GetLastError(), IsoTimeW);
                        status = ERROR_INVALID_DATA;
                        goto lExit;
                        }

                    if (0 != iso8601ToFileTime( IsoTimeA, &_dataFileRecv.filetime, TRUE, TRUE))
                        {
                        DbgLog1(SEV_ERROR, "iso8601ToFileTime() failed on '%s'", IsoTimeA);
                        status = ERROR_INVALID_DATA;
                        goto lExit;
                        }
                    }

                break;
                }

            case OBEX_PARAM_BODY:
            case OBEX_PARAM_BODY_END:
                {
                if ( !Store_GetData2Byte(_dataRecv.lpStore, &b2ParamLen) )
                    {
                    status = ERROR_INVALID_DATA;
                    goto lExit;
                    }

                lpvData = Store_GetDataPtr( _dataRecv.lpStore );

                if( b1Opcode == OBEX_OPCODE_PUT || b1Opcode == OBEX_OPCODE_PUT_FINAL )
                    {
                    status = Xfer_FileWriteBody(lpvData, b2ParamLen-3, FALSE);
                    if (status)
                        {
                        goto lExit;
                        }
                    }

                Store_SkipData( _dataRecv.lpStore, b2ParamLen-3 );  // -3 for HI and HI len
                break;
                }

            case OBEX_PARAM_WHO:
                {
                BYTE2 Left;

                if ( !Store_GetData2Byte(_dataRecv.lpStore, &b2ParamLen) )
                    {
                    status = ERROR_INVALID_DATA;
                    goto lExit;
                    }

                Left = b2ParamLen;

                Left -= 3;  // -3 for HI and HI len

                while (Left >= sizeof(UUID))
                    {
                    UUID dialect;

                    if ( !Store_GetDataUuid(_dataRecv.lpStore, &dialect) )
                        {
                        status = ERROR_INVALID_DATA;
                        goto lExit;
                        }

                    Left -= sizeof(UUID);

                    if (0 == memcmp(&dialect, &DIALECT_ID_NT5, sizeof(UUID)))
                        {
                        _dialect = dialNt5;
                        break;
                        }
                    }

                //
                // Skip over uninterpreted parameter data.
                //
                Store_SkipData( _dataRecv.lpStore, Left );
                break;
                }

            case PRIVATE_PARAM_WIN32_ERROR:
                {
                if ( !Store_GetData4Byte( _dataRecv.lpStore, &status ))
                    {
                    status = ERROR_INVALID_DATA;
                    goto lExit;
                    }

                if (status)
                    {
                    goto lExit;
                    }

                break;
                }

            default:
                _SkipHeader( b1Param, _dataRecv.lpStore );
                break;
            }
        }

    if( b1Opcode == OBEX_OPCODE_SETPATH )
        {
        if( !(_dataPath.b1Flags & SETPATH_UPALEVEL) && !fHaveName )
            {
            // go back to receive folder root
            status = Xfer_SetPath( NULL );
            }
        }

lExit:

    DbgLog1( SEV_FUNCTION, "_ParseParams leave [%d]", status );

    return status;
}


BYTE2 FILE_TRANSFER::_SkipHeader( BYTE1 b1Param, LPSTORE lpStore )
{
    BYTE2 b2Ret = 0;

    // if it's 1 or 4 byte value, read it in and ignore, otherwise
    // read the length and skip ahead the appropriate number of bytes

    // NOTE: Win95 and Win98 have a bug in this routine.  Their test looks like
    //
    // if( b1Param & OBEX_PARAM_1BYTE )
    //    {
    //    treat as 1-byte;
    //    }
    // else if( b1Param & OBEX_PARAM_4BYTE )
    //    {
    //    treat as 4-byte;
    //    }
    // else
    //    {
    //    treat as 2-byte length-prefixed header;
    //    }
    //
    // which, if I read it correctly, treats 1- and 4-byte headers as 1-byte,
    // byte-stream headers as 4-byte, and Unicode headers as Unicode.

    if( (b1Param & OBEX_PARAM_TYPE_MASK) == OBEX_PARAM_1BYTE )
    {
        BYTE1 b1;
        ExitOnFalse( Store_GetData1Byte(lpStore, &b1) );
        b2Ret = 2;
    }
    else if( (b1Param & OBEX_PARAM_TYPE_MASK) == OBEX_PARAM_4BYTE )
    {
        BYTE4 b4;
        ExitOnFalse( Store_GetData4Byte(lpStore, &b4) );
        b2Ret = 5;
    }
    else
    {
        ExitOnFalse( Store_GetData2Byte(lpStore, &b2Ret) );
        Store_SkipData( lpStore, b2Ret-3 );  // -3 for HI and HI len
    }

lExit:

    return b2Ret;
}


BOOL FILE_TRANSFER::_PokePacketSizeIntoStore( LPSTORE lpStore )
{
    // NOTE: cast assumes store sizes to fit into 2 bytes
    BYTE2 b2PktSize = (BYTE2)Store_GetDataUsed( lpStore );

    // packet size is always the 2nd and 3rd bytes in the buffer
    return Store_PokeData( lpStore, 1, &b2PktSize, sizeof(b2PktSize) );
}


error_status_t
FILE_TRANSFER::_Request(
    LPSTORE lpStore,
    BYTE1 b1NeededReply
    )
{
    error_status_t status = 0;
    LPBYTE1 pb1Data  = (LPBYTE1) Store_GetDataPtr(lpStore);
    DWORD   dwUsed   = Store_GetDataUsed(lpStore);
    DWORD   dwOffset = 0;

    DbgLog( SEV_FUNCTION, "_Request" );

    status = Sock_Request( pb1Data + dwOffset, dwUsed - dwOffset );
    ExitOnErr( status );

#if 0
    status = _WaitForReply( REPLY_TIMEOUT, b1NeededReply );
    if (status == ERROR_TIMEOUT)
        {
        status = 0;
        }

    ExitOnErr( status );
#endif

lExit:

    DbgLog1( SEV_FUNCTION, "_Request leave [%d]", status );

    return status;
}


error_status_t
FILE_TRANSFER::_Respond(
    LPSTORE lpStore
    )
{
    error_status_t status = 0;
    LPBYTE1 pb1Data  = (LPBYTE1) Store_GetDataPtr(lpStore);
    DWORD   dwUsed   = Store_GetDataUsed(lpStore);
    DWORD   dwOffset = 0;

    DbgLog( SEV_FUNCTION, "_Respond" );

    status = Sock_Respond( pb1Data + dwOffset, dwUsed - dwOffset );
    ExitOnErr( status );

lExit:

    DbgLog1( SEV_FUNCTION, "_Respond leave [%d]", status );

    return status;
}


error_status_t
FILE_TRANSFER::Obex_PutBegin(
    LPWSTR wszObj,
    __int64 dwObjSize,
    FILETIME * pFileTime
    )
{
    _blocksSent     = 0;
    _blocksAcked    = 0;
    _lastAckTime = GetTickCount();

    return _Put( wszObj, dwObjSize, pFileTime, NULL, 0, dwObjSize == 0 );
}


error_status_t
FILE_TRANSFER::Obex_PutBody(
    wchar_t FileName[],
    LPBYTE1 pb1Data,
    BYTE2 b2DataSize,
    BOOL fFinal
    )
{
    error_status_t status = 0;
    BYTE2 b2Sent        = 0;
    BYTE2 b2MaxBodySize = _dataRecv.b2MaxPacket - 16; // 16 = 3 (opcode+pktlen) + 3 (param+len param) + 10 (for good measure)

    // send in packets no larger than what the receiving side requested
    while( b2Sent < b2DataSize )
        {
        BYTE2 b2SendSize  = min( b2DataSize - b2Sent, b2MaxBodySize );
        BOOL  fLastPacket = fFinal && (b2Sent + b2SendSize == b2DataSize);

        DbgLog4(SEV_INFO, "    b2DataSize %d, b2Sent %d, b2MaxBodySize %d, b2MaxPacket %d",
                _dataRecv.b2MaxPacket, b2DataSize, b2Sent, b2MaxBodySize );

        if( _fCancelled )
            {
            Obex_Abort(ERROR_CANCELLED);
            return ERROR_CANCELLED;
            }

        status = _Put( NULL, 0, 0, pb1Data + b2Sent, b2SendSize, fLastPacket );

        if( status )
            break;

        status = 0;
        b2Sent += b2SendSize;
        }

    return status;
}


error_status_t
FILE_TRANSFER::Obex_SetPath(
    LPWSTR wszPath
    )
{
    error_status_t status = ERROR_NOT_ENOUGH_MEMORY;
    BOOL    fUpALevel = ( !wszPath || CchWsz(wszPath) == 0 );
    BYTE1   b1Flags   = SETPATH_FLAGS;
    WCHAR   wsz[MAX_PATH];
    LPSTORE lpStore   = Store_New( MAX_PATH+10 );

    DbgLog1( SEV_FUNCTION, "Obex_SetPath '%S'", wszPath );

    if( !fUpALevel ) {

        WCHAR   TempPath[MAX_PATH];

        StringCbCopy(TempPath, sizeof(TempPath), wszPath);

        //
        // strip off all but the last directory
        //
        if ( TempPath[CchWsz(TempPath)-1] == cBACKSLASH ) {

            TempPath[CchWsz(TempPath)-1] = (WCHAR)cNIL;
        }

        StripPath( TempPath, wsz, sizeof(wsz)/sizeof(WCHAR) );
    }

    if ( _dataRecv.state != osCONN )
        {
        status = ERROR_NOT_CONNECTED;
        goto lExit;
        }

    ExitOnNull( lpStore );

    ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_OPCODE_SETPATH) );

    // add buffer space for the packet length
    ExitOnFalse( Store_AddData2Byte(lpStore, 0) );

    if( fUpALevel )
        b1Flags |= SETPATH_UPALEVEL;

    ExitOnFalse( Store_AddData1Byte(lpStore, b1Flags) );
    ExitOnFalse( Store_AddData1Byte(lpStore, SETPATH_CONSTANTS) );

    if( !fUpALevel )
    {
        ExitOnFalse( Store_AddData1Byte(lpStore, OBEX_PARAM_NAME) );
        ExitOnFalse( Store_AddData2Byte(lpStore, 3+CbWsz(wsz)) );
        ExitOnFalse( Store_AddDataWsz(lpStore, wsz) );
    }

    ExitOnFalse( _PokePacketSizeIntoStore(lpStore) );

    status = _Request( lpStore, OBEX_REPLY_SUCCESS );
    ExitOnErr( status );

    status = _WaitForReply( SETPATH_TIMEOUT, OBEX_REPLY_SUCCESS );

    ExitOnErr( status );

    status = 0;

lExit:

    Store_Delete( &lpStore );

    DbgLog1( SEV_FUNCTION, "Obex_SetPath leave [%d]", status );

    return status;
}

BOOL FILE_TRANSFER::_HandleNotImplemented( BYTE1 b1Opcode )
{
    return SendReplyObex( OBEX_REPLY_FAIL_NOTIMP );
}

BOOL FILE_TRANSFER::_HandleBadRequest( BYTE1 b1Opcode )
{
    return SendReplyObex( OBEX_REPLY_FAIL_BADREQUEST );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\store.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       store.cxx
//
//--------------------------------------------------------------------------

#include "precomp.h"


#define cbSTORE_OVERHEAD    ( 3*sizeof(DWORD) )


LPSTORE Store_New( DWORD dwStoreSize )
{
    LPSTORE lpStore;

    lpStore = (LPSTORE) MemAlloc( cbSTORE_OVERHEAD + dwStoreSize );

    if( lpStore )
    {
        lpStore->dwSize = dwStoreSize;
        Store_Empty( lpStore );
    }

    return lpStore;
}


BOOL Store_Empty( LPSTORE lpStore )
{
    if( !lpStore )
        {
        return FALSE;
        }

    DbgLog1( SEV_FUNCTION, "Store_Empty: Remove: %ld bytes", lpStore->dwUsed );

    lpStore->dwUsed      = 0;
    lpStore->dwOutOffset = 0;

    return TRUE;
}


BOOL Store_AddData( LPSTORE lpStore, LPVOID lpvData, DWORD dwDataSize )
{
    // have enough room for new data?
    if( lpStore->dwUsed + dwDataSize > lpStore->dwSize )
        {
        DbgLog3( SEV_ERROR,
                 "Store_AddData: not enough room, used %d new %d size %d",
                 lpStore->dwUsed, dwDataSize, lpStore->dwSize );
        return FALSE;
        }

    CopyMemory( (LPVOID)( &(lpStore->ab1Store[lpStore->dwUsed]) ),
                lpvData,
                dwDataSize );

    lpStore->dwUsed += dwDataSize;

    DbgLog1( SEV_INFO, "Store_AddData: dwUsed: %ld bytes", lpStore->dwUsed );

    return TRUE;
}


DWORD Store_GetDataUsed( LPSTORE lpStore )
{
    return lpStore->dwUsed;
}

DWORD
Store_GetSize(
    LPSTORE lpStore
    )
{
    return lpStore->dwSize;
}



VOID Store_RemoveData( LPSTORE lpStore, DWORD dwLen )
{
    DbgLog1( SEV_FUNCTION, "Store_RemoveData: Remove: %ld bytes", dwLen );

    if( dwLen > lpStore->dwUsed )
        {
        Store_Empty( lpStore );
        return;
        }

    lpStore->dwUsed -= dwLen;
    lpStore->dwOutOffset  = 0L;

    if (lpStore->dwUsed)
        {
        CopyMemory( (LPVOID)( lpStore->ab1Store ),
                    (LPVOID)( &(lpStore->ab1Store[dwLen]) ),
                    lpStore->dwUsed );
        }

    DbgLog1( SEV_FUNCTION, "Store_RemoveData: dwUsed: %d", lpStore->dwUsed );
}

BOOL Store_GetData1Byte( LPSTORE lpStore, LPBYTE1 pb1 )
{
    if( !pb1 )
        return FALSE;

    if( lpStore->dwOutOffset + sizeof(*pb1) > lpStore->dwUsed )
        {
        DbgLog2( SEV_ERROR,
                 "Store_GetData: get 1 failed, used %d, offset %d",
                 lpStore->dwUsed, lpStore->dwOutOffset );
        return FALSE;
        }

    *pb1 = *( (LPBYTE1)(lpStore->ab1Store + lpStore->dwOutOffset) );

    lpStore->dwOutOffset += sizeof( *pb1 );

    return TRUE;
}


BOOL Store_GetData2Byte( LPSTORE lpStore, LPBYTE2 pb2 )
{
    if( !pb2 )
        return FALSE;

    if( lpStore->dwOutOffset + sizeof(*pb2) > lpStore->dwUsed )
        {
        DbgLog2( SEV_ERROR,
                 "Store_GetData: get 2 failed, used %d, offset %d",
                 lpStore->dwUsed, lpStore->dwOutOffset );
        return FALSE;
        }

    CopyMemory(pb2,lpStore->ab1Store + lpStore->dwOutOffset, sizeof(*pb2));

//    *pb2 = *( (LPBYTE2)(lpStore->ab1Store + lpStore->dwOutOffset) );

    ChangeByteOrder( (LPBYTE1)pb2, sizeof(*pb2), sizeof(*pb2) );

    lpStore->dwOutOffset += sizeof( *pb2 );

    return TRUE;
}


BOOL Store_GetData4Byte( LPSTORE lpStore, LPBYTE4 pb4 )
{
    if( !pb4 )
        return FALSE;

    if( lpStore->dwOutOffset + sizeof(*pb4) > lpStore->dwUsed )
        {
        DbgLog2( SEV_ERROR,
                 "Store_GetData: get 4 failed, used %d, offset %d",
                 lpStore->dwUsed, lpStore->dwOutOffset );
        return FALSE;
        }

    CopyMemory(pb4,lpStore->ab1Store + lpStore->dwOutOffset, sizeof(*pb4));

//    *pb4 = *( (LPBYTE4)(lpStore->ab1Store + lpStore->dwOutOffset) );

    ChangeByteOrder( (LPBYTE1)pb4, sizeof(*pb4), sizeof(*pb4) );

    lpStore->dwOutOffset += sizeof( *pb4 );

    return TRUE;
}

BOOL Store_GetDataUuid( LPSTORE lpStore, UUID * pb )
{
    if( !pb )
        return FALSE;

    if( lpStore->dwOutOffset + sizeof(*pb) > lpStore->dwUsed )
        {
        DbgLog2( SEV_ERROR,
                 "Store_GetData: get UUID failed, used %d, offset %d",
                 lpStore->dwUsed, lpStore->dwOutOffset );
        return FALSE;
        }

    CopyMemory(pb,lpStore->ab1Store + lpStore->dwOutOffset, sizeof(*pb));
//    *pb = *( (UUID *)(lpStore->ab1Store + lpStore->dwOutOffset) );

    ChangeByteOrder( &pb->Data1, sizeof(pb->Data1), sizeof(pb->Data1) );
    ChangeByteOrder( &pb->Data2, sizeof(pb->Data2), sizeof(pb->Data2) );
    ChangeByteOrder( &pb->Data3, sizeof(pb->Data3), sizeof(pb->Data3) );

    lpStore->dwOutOffset += sizeof( UUID );

    return TRUE;
}


BOOL Store_GetDataWsz( LPSTORE lpStore, LPWSTR wsz, DWORD BufferLength )
{
    LPWSTR lpwsz = (LPWSTR)(lpStore->ab1Store + lpStore->dwOutOffset);
    INT    nLen  = CbWsz(lpwsz);

    if( !wsz || BufferLength < (DWORD) nLen)
        return FALSE;

    if( lpStore->dwOutOffset + nLen > lpStore->dwUsed )
        {
        DbgLog2( SEV_ERROR,
                 "Store_GetData: get Unicode string failed, used %d, offset %d",
                 lpStore->dwUsed, lpStore->dwOutOffset );
        return FALSE;
        }

    wcsncpy( wsz, lpwsz, BufferLength / sizeof(WCHAR) );

    lpStore->dwOutOffset += nLen;

    ChangeByteOrder( (LPBYTE1)wsz, sizeof(WCHAR), nLen );

    return TRUE;
}


LPVOID Store_GetDataPtr( LPSTORE lpStore )
{
    return (lpStore->ab1Store + lpStore->dwOutOffset);
}


VOID Store_SkipData( LPSTORE lpStore, INT nSize )
{
    lpStore->dwOutOffset += nSize;
}


BOOL Store_PokeData( LPSTORE lpStore, DWORD dwOffset, LPVOID lpvData, DWORD dwDataSize )
{
    if( dwOffset + dwDataSize > lpStore->dwUsed )
        return FALSE;

    // NOTE: data must be atomic
    ChangeByteOrder( (unsigned char *) lpvData, dwDataSize, dwDataSize );

    CopyMemory(
        lpStore->ab1Store + dwOffset,
        lpvData,
        dwDataSize
    );

    return TRUE;
}


BOOL Store_AddData1Byte( LPSTORE lpStore, BYTE1 b1 )
{
    return Store_AddData( lpStore, &b1, sizeof(b1) );
}


BOOL Store_AddData2Byte( LPSTORE lpStore, BYTE2 b2 )
{
    ChangeByteOrder( (LPBYTE1)&b2, sizeof(b2), sizeof(b2) );

    return Store_AddData( lpStore, &b2, sizeof(b2) );
}


BOOL Store_AddData4Byte( LPSTORE lpStore, BYTE4 b4 )
{
    ChangeByteOrder( (LPBYTE1)&b4, sizeof(b4), sizeof(b4) );

    return Store_AddData( lpStore, (LPBYTE1)&b4, sizeof(b4) );
}

BOOL Store_AddDataUuid( LPSTORE lpStore, UUID * puuid )
{
    UUID uuid = *puuid;

    ChangeByteOrder( &uuid.Data1, sizeof(uuid.Data1), sizeof(uuid.Data1) );
    ChangeByteOrder( &uuid.Data2, sizeof(uuid.Data2), sizeof(uuid.Data2) );
    ChangeByteOrder( &uuid.Data3, sizeof(uuid.Data3), sizeof(uuid.Data3) );

    return Store_AddData( lpStore, &uuid, sizeof(UUID) );
}


BOOL Store_AddDataWsz( LPSTORE lpStore, LPWSTR wsz )
{
    INT   nLen = CbWsz( wsz );
    WCHAR wszCopy[MAX_PATH];

    SzCpyW( wszCopy, wsz );

    ChangeByteOrder( (LPBYTE1)wszCopy, sizeof(WCHAR), nLen );

    return Store_AddData( lpStore, wszCopy, nLen );
}


VOID Store_Delete( LPSTORE *lplpStore )
{
    if( lplpStore && *lplpStore )
        {
        MemFree( *lplpStore );
        *lplpStore = 0;
        }
}


VOID ChangeByteOrder( void * pb1, UINT uAtomSize, UINT uDataSize )
{
    LPBYTE1 pb1Src;
    LPBYTE1 pb1Dst;
    BYTE1   b1Temp;
    UINT    uSwaps;

    // 1 byte atoms don't change order
    if( uAtomSize == 1 )
        return;

    // go atom-by-atom, reversing the order of each byte in each atom
    for(
        pb1Src = LPBYTE1(pb1), pb1Dst = LPBYTE1(pb1) + uAtomSize-1;
        pb1Src < LPBYTE1(pb1) + uDataSize;
        pb1Src += uAtomSize-uSwaps, pb1Dst += uAtomSize+uSwaps
    )
    {
        uSwaps = 0;

        while( pb1Src < pb1Dst )
        {
            b1Temp    = *pb1Src;
            *pb1Src++ = *pb1Dst;
            *pb1Dst-- = b1Temp;

            uSwaps++;
        }
    }
}

void
Store_DumpParameter(
    LPSTORE lpStore,
    BYTE1 parm
    )
{
    unsigned Length;
    unsigned Offset = 0;
    char * name;

    switch (parm)
        {
        case OBEX_PARAM_COUNT:      name = "OBEX_PARAM_COUNT";        break;
        case OBEX_PARAM_NAME:       name = "OBEX_PARAM_NAME";         break;
        case OBEX_PARAM_LENGTH:     name = "OBEX_PARAM_LENGTH";       break;
        case OBEX_PARAM_UNIX_TIME:  name = "OBEX_PARAM_UNIX_TIME";    break;
        case OBEX_PARAM_ISO_TIME:   name = "OBEX_PARAM_ISO_TIME";     break;
        case OBEX_PARAM_BODY:       name = "OBEX_PARAM_BODY";         break;
        case OBEX_PARAM_BODY_END:   name = "OBEX_PARAM_BODY_END";     break;
        case OBEX_PARAM_WHO:        name = "OBEX_PARAM_WHO";          break;
        case PRIVATE_PARAM_WIN32_ERROR: name = "private WIN32_ERROR"; break;
        default:                    name = "unknown";                 break;
        }

    DbgLog2(SEV_INFO, "parameter 0x%x (%s):", parm, name);

    switch (parm & OBEX_PARAM_TYPE_MASK)
        {
        case OBEX_PARAM_UNICODE:
        case OBEX_PARAM_STREAM:
            {
            if (lpStore->dwSize - lpStore->dwOutOffset < 2)
                {
                Length = lpStore->dwSize - lpStore->dwOutOffset;
                }
            else
                {
                DbgLog2(SEV_INFO, "length = %x:%x",  lpStore->ab1Store[lpStore->dwOutOffset], lpStore->ab1Store[lpStore->dwOutOffset+1]);

                Length = (lpStore->ab1Store[lpStore->dwOutOffset] << 8) + lpStore->ab1Store[lpStore->dwOutOffset+1];

                Length -= 3; // on-wire length includes opcode and length field themselves
                Offset = 2;
                }
            break;
            }
        case OBEX_PARAM_1BYTE:
            {
            Length = 1;
            break;
            }
        case OBEX_PARAM_4BYTE:
            {
            Length = 4;
            break;
            }
        default:
            {
            DbgLog( SEV_ERROR, "Store_DumpParameter is broken\n");
            return;
            }
        }

    if ((Length+Offset) > lpStore->dwSize - lpStore->dwOutOffset)
        {
        Length = lpStore->dwSize - lpStore->dwOutOffset - Offset;
        }

    const BYTES_PER_LINE = 16;

    unsigned char *p = (unsigned char *) lpStore->ab1Store + lpStore->dwOutOffset + Offset;

    //
    // 3 chars per byte for hex display, plus an extra space every 4 bytes,
    // plus a byte for the printable representation, plus the \0.
    //
    char Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+BYTES_PER_LINE+1];
    Outbuf[0] = 0;
    Outbuf[sizeof(Outbuf)-1] = 0;
    char * HexDigits = "0123456789abcdef";

    if (Length < 32) {

        unsigned Index;
        for (Offset=0; Offset < Length; Offset++) {

            Index = Offset % BYTES_PER_LINE;

            if (Index == 0) {

                DbgLog1(SEV_INFO, "   %s", Outbuf);
                memset(Outbuf, ' ', sizeof(Outbuf)-1);
            }

            Outbuf[Index*3+Index/4  ] = HexDigits[p[Offset] / 16];
            Outbuf[Index*3+Index/4+1] = HexDigits[p[Offset] % 16];
            Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+Index] = iscntrl(p[Offset]) ? '.' : p[Offset];
        }

        DbgLog1(SEV_INFO, "   %s", Outbuf);
        DbgLog(SEV_INFO, "");

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\store.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       store.h
//
//--------------------------------------------------------------------------

#ifndef _STORE_H_
#define _STORE_H_


BOOL Store_AddData( LPSTORE lpStore, LPVOID lpvData, DWORD dwDataSize );
BOOL Store_AddData1Byte( LPSTORE lpStore, BYTE1 b1 );
BOOL Store_AddData2Byte( LPSTORE lpStore, BYTE2 b2 );
BOOL Store_AddData4Byte( LPSTORE lpStore, BYTE4 b4 );
BOOL Store_AddDataWsz( LPSTORE lpStore, LPWSTR wsz );
BOOL Store_AddDataUuid( LPSTORE lpStore, UUID * puuid );
BOOL Store_Empty( LPSTORE lpStore );
BOOL Store_GetData1Byte( LPSTORE lpStore, LPBYTE1 pb1 );
BOOL Store_GetData2Byte( LPSTORE lpStore, LPBYTE2 pb2 );
BOOL Store_GetData4Byte( LPSTORE lpStore, LPBYTE4 pb4 );
BOOL Store_GetDataWsz( LPSTORE lpStore, LPWSTR wsz, DWORD BufferLength );
BOOL Store_GetDataUuid( LPSTORE lpStore, UUID * pb );
BOOL Store_PokeData( LPSTORE lpStore, DWORD dwOffset, LPVOID lpvData, DWORD dwDataSize );

VOID Store_Delete( LPSTORE *lplpStore );
VOID Store_RemoveData( LPSTORE lpStore, DWORD dwLen );
VOID Store_SkipData( LPSTORE lpStore, INT nSize );

DWORD Store_GetDataUsed( LPSTORE lpStore );

DWORD
Store_GetSize(
    LPSTORE lpStore
    );


LPVOID Store_GetDataPtr( LPSTORE lpStore );

LPSTORE Store_New( DWORD dwStoreSize );

void Store_DumpParameter( LPSTORE lpStore, BYTE1 parm );

#endif // _STORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       util.h
//
//--------------------------------------------------------------------------

#ifndef _UTIL_H_
#define _UTIL_H_

#define fTRUE                 TRUE
#define fFALSE                FALSE

#define pNIL                  ( NULL )
#define lpNIL                 ( NULL )
#define hNIL                  ( (HANDLE)NULL )
#define hwndNIL               ( (HWND)NULL )
#define hkeyNIL               ( (HKEY)NULL )
#define dwNIL                 ( (DWORD)NULL )
#define uNIL                  ( (UINT)NULL )
#define nNIL                  ( -1 )
#define cNIL                  ( '\0' )
#define szNIL                 ( L"" )

#define cBACKSLASH            '\\'
#define cPERIOD               '.'
#define cSLASH                '/'
#define cMINUS                '-'
#define cPLUS                 '+'
#define cSPACE                ' '
#define cDBLQUOTE             '\"'
#define cTILDE                L'~'
#define cLOWER_A              'a'
#define cLOWER_Z              'z'
#define cUPPER_A              'A'
#define cUPPER_H              'H'
#define cUPPER_Q              'Q'
#define cUPPER_R              'R'
#define cUPPER_S              'S'
#define cUPPER_V              'V'
#define cUPPER_Z              'Z'
#define cZERO                 '0'
#define cNINE                 '9'

#define szBACKSLASH           L"\\"
#define szSPACE               " "
#define szCRLF                "\r\n"
#define szPERIOD              L"."
#define szDOTDOT              ".."
#define szPREVDIR             L".."

#define bMSG_HANDLED          0
#define bMSG_NOTHANDLED       1

#define bDLG_MSG_HANDLED      1
#define bDLG_MSG_NOTHANDLED   0

#define cbSMALL_SZ            64
#define cbLARGE_SZ            128
#define cbMAX_SZ              256

#define nREALLOC_INC          512

#define CchSz( sz )           lstrlen(sz)
#define CbSz( sz )            ( lstrlen(sz) + 1 )
#define CchWsz( sz )          SzLenW(sz)
#define CbWsz( sz )           ( (SzLenW(sz)+1)*sizeof(WCHAR) )

#define MemAlloc( dw )        LocalAlloc( LPTR, dw )
#define MemReAlloc( lp, dw )  LocalReAlloc( lp, dw, (UINT)0 )
#define MemFree( lpv )        { LocalFree( lpv ); lpv = 0; }

#define ExitOnTrue( f )       if( f ) goto lExit;
#define ExitOnFalse( f )      if( !(f) ) goto lExit;
#define ExitOnNull( x )       if( (x) == NULL ) goto lExit;
#define ExitOnFail( hr )      if( FAILED(hr) ) goto lExit;

#define FailOnTrue( f )       if( f ) goto lErr;
#define FailOnFalse( f )      if( !(f) ) goto lErr;
#define FailOnNull( x )       if( (x) == NULL ) goto lErr;
#define FailOnFail( hr )      if( FAILED(hr) ) goto lErr;

#define GotoErrSet( cmd )     { cmd; goto lErr; }

#define SzBool( f )           ( (f) ? "TRUE" : "FALSE" )

#define Validate_Number( n, nMin, nMax )  \
    n = min( nMax, max( nMin, n ) )

INT  StrTblMsgBox( HWND hwnd, UINT uTextID, UINT uTitleID, DWORD dwFlags );

BOOL CenterWindow( HWND hwnd, HWND hwndRef );
BOOL DirectoryExists( LPWSTR szDir );
BOOL GetReceivedFilesFolder( LPWSTR szDir, DWORD dwLen );
BOOL GetUniqueName( LPWSTR szPath, ULONG PathSize, LPWSTR szBase, BOOL fFile );
BOOL FileExists( LPWSTR szFile );
BOOL IsChecked( HWND hwnd );
BOOL IsCharInStr( CHAR c, LPWSTR sz );
BOOL IsRoomForFile( __int64 dwFileSize, LPWSTR szPath );
BOOL bNoTrailingSlash( LPWSTR szPath );
#define bHasTrailingSlash(_a) (!(bNoTrailingSlash(_a)))

VOID StripPath( LPWSTR szFullPath, LPWSTR szReturnPath, ULONG PathSize );
VOID StripFile( LPWSTR szFullPath );
VOID StripExt( LPWSTR szFullPath );
LPWSTR GetFileName( LPWSTR szFullPath );
LPWSTR GetFileNameW( LPWSTR wszFullPath );

typedef enum {
    LTB_NULL_TERM  = 0,
    LTB_SPACE_SEP  = 1,
} LIST_TYPE;
LPWSTR DropListToBuffer( HDROP hDrop, LIST_TYPE listType );
LPWSTR OpenFileListToBuffer( LPWSTR pszFileList, LIST_TYPE listType );

VOID ShowReceivedFilesFolder( void );

DWORD GetDirectorySize( LPWSTR szFolder );

VOID BringWndToTop( HWND hwnd );
VOID Rest( DWORD dwMilliseconds );
WPARAM DoMsgLoop( BOOL fForever );

BOOL ProcessMessageIfAvailable();
BOOL ProcessMessage();

LPWSTR  SzSz( LPCSTR pszStr, LPCSTR pszFind );
LPWSTR  SzSzI( LPCSTR szStr, LPCSTR szFind );
INT    SzCmpN( LPCSTR lpsz1, LPCSTR lpsz2, INT nLen );

LPSTR  WszToSz( LPCWSTR lpwsz );
LPWSTR SzToWsz( LPCSTR lpsz );
INT    SzLenW( LPCWSTR lpwsz );
LPWSTR SzCpyW( LPWSTR lpsz1, LPCWSTR lpsz2 );

HRESULT ResolveShortCut( LPWSTR pszShortcut, LPWSTR lpszResolved );

HANDLE WaitForMutex( LPWSTR pszMutexName, DWORD dwRetryTime, DWORD dwTimeout );

BOOL FileTimeToUnixTime( LPFILETIME lpFileTime, LPDWORD pdwUnixTime );
BOOL UnixTimeToFileTime( DWORD dwUnixTime, LPFILETIME lpFileTime );

#endif  // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\util.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       util.cxx
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include "shlguid.h"

// FileExists function
#define _dwGFAFail              0xFFFFFFFF
#define _nMaxLines              1000

// Reg functions
#define nMAX_REGROOT            7
#define nREGROOT_SZ             24


BOOL DirectoryExists( LPWSTR szDir )
{
    DWORD dwAttr = GetFileAttributes( szDir );

    if( _dwGFAFail == dwAttr )
        return FALSE;

    return (BOOL)( dwAttr & FILE_ATTRIBUTE_DIRECTORY );
}


BOOL FileExists( LPWSTR szFile )
{
    DWORD dwAttr = GetFileAttributes( szFile );

    if( _dwGFAFail == dwAttr )
        return FALSE;

    return (BOOL)( !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) );
}

VOID StripPath( LPWSTR szFullPath, LPWSTR szReturnPath, ULONG PathSize )
{
    LPWSTR lpc = GetFileName( szFullPath );

    if( !lpc )
        return;

    StringCchCopy(szReturnPath,PathSize,lpc);

}


VOID StripFile( LPWSTR szFullPath )
{
    LPWSTR lpc = GetFileName( szFullPath );

    if( !lpc )
        return;

    *lpc = cNIL;
}

LPWSTR GetFileName( LPWSTR lpszFullPath )
{
    LPWSTR lpszFileName;

    if( !lpszFullPath)
        return lpNIL;

    for (lpszFileName = lpszFullPath; *lpszFullPath; lpszFullPath++)
        {
        if (*lpszFullPath == cBACKSLASH)
            lpszFileName = lpszFullPath + 1;
        }

    return lpszFileName;

}


LPWSTR GetFileNameW( LPWSTR wszFullPath )
{
    LPWSTR lpwc;

    if( !wszFullPath || wszFullPath[0] == 0)
        return lpNIL;

    lpwc = wszFullPath + CchWsz(wszFullPath) - 1;

    while( *lpwc != (WCHAR)cBACKSLASH && lpwc != wszFullPath )
        lpwc--;

    if( lpwc == wszFullPath )
        return wszFullPath;

    return ++lpwc;
}

BOOL bNoTrailingSlash( LPWSTR szPath )
{
    LPWSTR lpc;
    WCHAR  cLast=L'\0';

    for( lpc = szPath; *lpc; cLast = *lpc, lpc++ )
        ;

    return ( cLast != cBACKSLASH );
}

BOOL GetUniqueName( LPWSTR szPath, ULONG PathSize, LPWSTR szBase, BOOL fFile )
{
    INT     nTry;
    LPWSTR  lpFileName;
    WCHAR   szFormat[cbMAX_SZ];
    ULONG   NewPathLength;

    if( bNoTrailingSlash(szPath) ) {

        StringCchCat(szPath, PathSize,szBACKSLASH );
    }

    NewPathLength = lstrlen(szPath);

    lpFileName = szPath + NewPathLength;

    StringCchCat(szPath, PathSize, szBase);

    StringCbCopy(szFormat, sizeof(szFormat), g_DuplicateFileTemplate );

    nTry = 0;

    while( 0xffffffff != GetFileAttributes(szPath) ) {

        StringCchPrintf(lpFileName, PathSize-NewPathLength, szFormat, ++nTry, szBase );
    }

    return TRUE;
}


DWORD GetDirectorySize( LPWSTR szFolder )
{
    BOOL   bRet;
    HANDLE hFind;
    DWORD  dwSize = 0L;
    WCHAR   szBaseDir[MAX_PATH];
    WCHAR   szSpec[MAX_PATH*2];
    WIN32_FIND_DATA findData;

    //
    // get base directory ending with backslash
    //
    StringCbCopy(szBaseDir,sizeof(szBaseDir), szFolder );

    if ( bNoTrailingSlash(szBaseDir) ) {

        StringCbCat(szBaseDir, sizeof(szBaseDir), szBACKSLASH );
    }

    //
    // form search string
    //

    StringCbCopy(szSpec, sizeof(szSpec), szBaseDir );

    StringCbCat(szSpec, sizeof(szSpec), L"*.*" );

    hFind = FindFirstFile(
        szSpec,
        &findData
        );

    bRet = ( hFind != INVALID_HANDLE_VALUE );

    while( bRet )
    {
        WCHAR szObj[MAX_PATH*2];

        StringCbCopy(szObj, sizeof(szObj), szBaseDir );

        StringCbCat(szObj, sizeof(szObj), findData.cFileName );

        if( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            // weed out "." and ".."
            if (0 != lstrcmp(findData.cFileName, szPERIOD) && 0 != lstrcmp(findData.cFileName, szPREVDIR))
                dwSize += GetDirectorySize( szObj );
        }
        else
        {
            HANDLE hFile = CreateFile(
                szObj,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );
            if( INVALID_HANDLE_VALUE != hFile )
            {
                //REVIEW: won't work for REALLY large files
                dwSize += GetFileSize( hFile, NULL );

                CloseHandle( hFile );
            }
        }

        bRet = FindNextFile( hFind, &findData );
    }

    if (hFind != INVALID_HANDLE_VALUE)
        {
        FindClose(hFind);
        }

    return dwSize;
}

LPWSTR SzToWsz( LPCSTR lpsz )
{
    INT    nSzLen = lstrlenA(lpsz);
    LPWSTR lpwsz  = (LPWSTR) MemAlloc((nSzLen+1)*sizeof(WCHAR));

    if (lpwsz){
        MultiByteToWideChar(
            CP_ACP,
            0L,
            lpsz,
            nSzLen,
            lpwsz,
            nSzLen+1
        );
    }

    return lpwsz;
}


LPSTR WszToSz( LPCWSTR lpwsz )
{
    int err;
    int Length;
    LPSTR lpsz;

    Length = WideCharToMultiByte(CP_ACP,
                                 0L,
                                 lpwsz,
                                 -1,
                                 0,
                                 0,
                                 NULL,
                                 NULL
                                 );

    lpsz = (LPSTR) MemAlloc(1+Length);
    if (!lpsz)
        {
        return 0;
        }

    if ( !WideCharToMultiByte(CP_ACP,
                              0L,
                              lpwsz,
                              Length,
                              lpsz,
                              1+Length,
                              NULL,
                              NULL
                              ))
        {
        MemFree( lpsz );
        return 0;
        }

    return lpsz;
}


INT SzLenW( LPCWSTR lpwsz )
{
    WCHAR *pwc = (WCHAR *)lpwsz;

    if( !lpwsz )
        return 0;

    while( *pwc++ != 0 )
        ;

    return (INT)(--pwc - lpwsz);
}


LPWSTR SzCpyW( LPWSTR lpsz1, LPCWSTR lpsz2 )
{
    LPWSTR lpwsz = lpsz1;

    while( *lpsz2 )
        *lpsz1++ = *lpsz2++;

    *lpsz1 = 0;

    return lpwsz;
}


INT SzCmpN( LPCSTR lpsz1, LPCSTR lpsz2, INT nLen )
{
    while( *lpsz1 && *lpsz2 && *lpsz1 == *lpsz2 && --nLen > 0 )
    {
        lpsz1++;
        lpsz2++;
    }

    return ( *lpsz1 - *lpsz2 );
}

BOOL IsRoomForFile( __int64 dwFileSize, LPWSTR szPath )
{
    BOOL  fRet;
    ULARGE_INTEGER MyDiskFreeBytes;
    ULARGE_INTEGER DiskFreeBytes;
    ULARGE_INTEGER DiskTotalBytes;

    fRet = GetDiskFreeSpaceEx(
        szPath,
        &MyDiskFreeBytes,
        &DiskTotalBytes,
        &DiskFreeBytes
        );

    if( fRet )
        {
        fRet = ( MyDiskFreeBytes.QuadPart >= (ULONGLONG) dwFileSize );
        }

    return fRet;
}

__int64 _Get100nsIntervalsFrom1601To1970( VOID )
{
    __int64 ilrg100nsPerSec  = 10000000;  // 100-ns intervals per second (10^7)
    __int64 ilrg100nsPerMin  = 60*ilrg100nsPerSec;
    __int64 ilrgDays         = 369*365 + 89; // 369 years (89 are leap years).
    __int64 ilrgMin          = ilrgDays*24*60;
    __int64 ilrgRet;

    ilrgRet = ilrgMin * ilrg100nsPerMin;

    return ilrgRet;
}


BOOL FileTimeToUnixTime( IN  LPFILETIME lpFileTime,
                         OUT LPDWORD    pdwUnixTime )
{
    LARGE_INTEGER  lrgTime
                   = { lpFileTime->dwLowDateTime, lpFileTime->dwHighDateTime };
    __int64  ilrgFileTime = *((__int64*)lpFileTime);
    __int64  ilrgIntervalsTil1970 = _Get100nsIntervalsFrom1601To1970();
    __int64  ilrgIntsSince1970;
    __int64  ilrgSecSince1970;
    __int64  ilrg100nsPerSec = 10000000;
    __int64  ilrgRem;

    // Get the intervals since 1970
    ilrgIntsSince1970 = ilrgFileTime - ilrgIntervalsTil1970;

    // Convert to seconds since 1970
    ilrgSecSince1970 = ilrgIntsSince1970/ilrg100nsPerSec;

    if (ilrgSecSince1970 >= 0xffffffff)
        {
        return FALSE;
        }

    *pdwUnixTime = (DWORD)ilrgSecSince1970;
    return TRUE;
}


BOOL UnixTimeToFileTime( DWORD dwUnixTime, LPFILETIME lpFileTime )
{
    __int64  ilrg100nsPerSec = 10000000; // 100-ns intervals/second (10^7)
    __int64  ilrgIntervalsSince1601;
    __int64  ilrgIntervalsSince1970;
    __int64  ilrgIntervalsTil1970 = _Get100nsIntervalsFrom1601To1970();

    // Get the intervals since 1970
    ilrgIntervalsSince1970 = dwUnixTime * ilrg100nsPerSec;

    // Get the intervals since 1601
    ilrgIntervalsSince1601 = ilrgIntervalsTil1970 + ilrgIntervalsSince1970;

    *lpFileTime = *((FILETIME*)&ilrgIntervalsSince1601);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\xferlist.h ===
#ifndef __XFERLIST__
#define __XFERLIST__

#define MAX_TRANSFERS    (8)

typedef struct _XFER_LIST {

    CRITICAL_SECTION    Lock;
    HANDLE              CloseEvent;
    BOOL                Closing;
    LONG                Transfers;

    FILE_TRANSFER*      List[MAX_TRANSFERS];

} XFER_LIST, *PXFER_LIST;

PXFER_LIST
CreateXferList(
    VOID
    );


VOID
DeleteXferList(
    PXFER_LIST     XferList
    );

BOOL
AddTransferToList(
    PXFER_LIST     XferList,
    FILE_TRANSFER* FileTransfer
    );

BOOL
RemoveTransferFromList(
    PXFER_LIST     XferList,
    FILE_TRANSFER* FileTransfer
    );

BOOL
AreThereActiveTransfers(
    PXFER_LIST     XferList
    );

FILE_TRANSFER*
TransferFromCookie(
    PXFER_LIST     XferList,
    __int64        Cookie
    );



#endif //__XFERLIST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\xfer.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       xfer.cxx
//
//--------------------------------------------------------------------------

#include "precomp.h"

#include <irmonftp.h>

error_status_t
MapWinsockErrorToWin32(
    error_status_t status
    );

DWORD
MdWork(
       WCHAR *arg
       );


DWORD
ReportFileError( DWORD mc,
                 WCHAR * file,
                 DWORD error
                 )
{
    DWORD     dwEventStatus = 0;
    EVENT_LOG EventLog(WS_EVENT_SOURCE,&dwEventStatus);

    if (!dwEventStatus)
        {
        TCHAR ErrorDescription[ERROR_DESCRIPTION_LENGTH];

        if (!FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                            FORMAT_MESSAGE_FROM_SYSTEM,
                            0,          // ignored
                            error,
                            0,       // try default language ids
                            ErrorDescription,
                            ERROR_DESCRIPTION_LENGTH,
                            0        // ignored
                            ))
        {
            //
            //  could not format the message just use the error value
            //
            StringCbPrintf(ErrorDescription, sizeof(ErrorDescription), L"0x%x", error);
        }

        WCHAR * Strings[2];

        Strings[0] = file;
        Strings[1] = ErrorDescription;

        dwEventStatus = EventLog.ReportError(CAT_IRXFER, mc, 2, Strings);
        }

    return dwEventStatus;
}


FILE_TRANSFER::FILE_TRANSFER(  )
{
    _refs  = 1;
    _event = 0;
    _socket = INVALID_SOCKET;
    _cookie = 0;

    m_StopListening=FALSE;

    // for sock.c

    _fWriteable       = FALSE;

    // for xfer.c

    _dataFileRecv.hFile = INVALID_HANDLE_VALUE;

    // for progress.c

    _fCancelled       = FALSE;
    _fInUiReceiveList = FALSE;

    _CurrentPercentage = 0;

    _files = 0;

    _dataXferRecv.dwFileSent = 0;

    DbgLog2(SEV_INFO, "[0] %p: refs = %d\n", this, _refs);
}


FILE_TRANSFER::~FILE_TRANSFER()
{
    if (_socket != INVALID_SOCKET) {

        //
        // Drain any remaining receive data to ensure our sent data is sent across the link.
        //
        closesocket( _socket );
        _socket = INVALID_SOCKET;
    }

    if (_event) {

        CloseHandle( _event );
        _event = 0;
    }

    if (_fInUiReceiveList) {

        _ReceiveFinished( rpcBinding, _cookie, 0 );
    }

    delete [] _files;
    
    DeleteCriticalSection(&m_Lock);
}

unsigned long __stdcall
SendFilesWrapper( PVOID arg )
{
    PFILE_TRANSFER(arg)->Send();
    return 0;

}



void
FILE_TRANSFER::BeginSend(
                         DWORD DeviceId,
                         OBEX_DEVICE_TYPE    DeviceType,
                         error_status_t * pStatus,
                         FAILURE_LOCATION * pLocation
                         )
{
    DWORD  status;
    DWORD  dwFiles        = 0L;
    DWORD  dwFolders      = 0L;
    __int64  dwTotalSize  = 0L;

    status = _GetObjListStats( _files, &dwFiles, &dwFolders, &dwTotalSize );

    if (status) {

        *pLocation = locFileOpen;
        goto lExit;
    }

    if (( 0 == dwFiles) && (0 == dwFolders )) {

        goto lExit;   // nothing to send
    }

    status = Sock_EstablishConnection( DeviceId,DeviceType );

    if ( status ) {

        *pLocation = locConnect;
        goto lExit;
    }


    _dataXferRecv.dwTotalSize = (DWORD) dwTotalSize;

    DWORD ThreadId;
    HANDLE ThreadHandle;

    ThreadHandle = CreateThread( 0,
                                 0,
                                 SendFilesWrapper,
                                 this,
                                 0,
                                 &ThreadId
                                 );
    if (!ThreadHandle) {

        *pLocation = locStartup;
        status = GetLastError();
        goto lExit;
    }

    CloseHandle( ThreadHandle );

lExit:

    if (status) {

        DecrementRefCount();
    }

    *pStatus = status;
}


void
FILE_TRANSFER::Send()
{
    error_status_t status = 0;

    wchar_t * szObj=L"";
    ULONG64 dwTotalSize=_dataXferRecv.dwTotalSize;

    //
    // Avoid idle-time shutdowns.  If the call fails, we want to continue anyway.
    //
    SetThreadExecutionState( ES_SYSTEM_REQUIRED | ES_CONTINUOUS );

    status = Obex_Connect( dwTotalSize );

    if (status == ERROR_SUCCESS) {

        _Send_StartXfer( dwTotalSize, 0 );

        //
        // send the files one at a time
        //
        for( szObj = _files; *szObj != 0; szObj += lstrlen(szObj)+1 ) {

            DbgLog1( SEV_INFO, "Sending %S", szObj );

            _UpdateSendProgress( rpcBinding,
                                _cookie,
                                szObj,
                                _dataXferRecv.dwTotalSize,
                                _completedFilesSize,
                                &status
                                );

            if ( DirectoryExists(szObj) ) {

                status = _SendFolder( szObj );

            } else {

                status = _SendFile( szObj );
            }

            if ((status !=ERROR_SUCCESS) || g_fShutdown) {

                break;
            }
        }
    }


    //
    // Re-enable idle-time shutdowns.
    //
    SetThreadExecutionState( ES_CONTINUOUS );

    //
    // Make sure we show 100% for a completed transfer.
    //
    if (!status) {

        _UpdateSendProgress( rpcBinding,
                            _cookie,
                            _dataFileRecv.szFileName,
                            _dataXferRecv.dwTotalSize,
                            _dataXferRecv.dwTotalSize,
                            &status
                            );
    }

    if (status != ERROR_CANCELLED) {
        //
        // don't overwrite the error unless there isn't one
        //
        error_status_t errTemp;

        _Send_EndXfer();

        errTemp = Obex_Disconnect( status );

        if ( !status ) {

            status = errTemp;
        }
    }


    if ( status != ERROR_SUCCESS ) {

//        status = MapWinsockErrorToWin32( status );
        _OneSendFileFailed( rpcBinding, _cookie, szObj, status, locFileSend, &status );
    }

    _SendComplete( rpcBinding, _cookie, _dataXferRecv.dwTotalSent, &status );

    RemoveFromTransferList(this);

    DecrementRefCount();
}

error_status_t
MapWinsockErrorToWin32(
    error_status_t status
    )
{
    if (status)
        {
        DbgLog2(SEV_ERROR, "mapping error 0x%x (%d)", status, status);
        }

    if (status < WSABASEERR || status > WSABASEERR + 1000)
        {
        return status;
        }

    switch (status)
        {
        case WSAECONNREFUSED:
            return ERROR_CONNECTION_REFUSED;

        default:
            return ERROR_REQUEST_ABORTED;
        }
}


error_status_t
_GetObjListStats(
                  LPWSTR lpszObjList,
                  LPDWORD lpdwFiles,
                  LPDWORD lpdwFolders,
                  __int64 * lpdwTotalSize
                  )
{
    error_status_t status = 0;
    LPWSTR  szObj;
    HANDLE hFile;


    // get (a) number of files, (b) total file size
    //
    for( szObj = lpszObjList; *szObj != 0; szObj += lstrlen(szObj)+1 ) {

        hFile = CreateFile(
            szObj,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

        if( INVALID_HANDLE_VALUE == hFile ) {

            // if it's a directory, get the total size of its files
            if( DirectoryExists(szObj) ) {

                *lpdwTotalSize += GetDirectorySize( szObj );
                (*lpdwFolders)++;
                continue;

            } else {

                DbgLog2(SEV_ERROR, "open file \'%S\' failed %d", szObj, GetLastError());

                ReportFileError( MC_IRXFER_OPEN_FAILED, szObj, GetLastError() );
                return GetLastError();
            }
        }

        *lpdwTotalSize += GetFileSize( hFile, NULL );

        (*lpdwFiles)++;
        CloseHandle( hFile );
    }

    return 0;
}


BOOL
FILE_TRANSFER::Xfer_Init(
                         wchar_t * files,
                         unsigned length,
                         OBEX_DIALECT dialect,
                         OBEX_DEVICE_TYPE    DeviceType,
                         BOOL                CreateSocket,
                         SOCKET              ListenSocket
                         )
{
    unsigned Timeout = 500;
    DWORD status = 0;

    m_ListenSocket=ListenSocket;
    _dialect = dialect;

    InitializeCriticalSection(&m_Lock);

    if (length)
        {
        _xferType = xferSEND;

        _files = new wchar_t[ length ];
        if (!_files)
            {
            goto cleanup;
            }

        memcpy(_files, files, sizeof(wchar_t) * length );
        }
    else
        {
        _xferType = xferRECV;

        _files = 0;
        }

    _dataXferRecv.fXferInProgress = FALSE;

    m_DeviceType=DeviceType;

    if (CreateSocket) {

        if (DeviceType == TYPE_IRDA) {

            _socket = socket( AF_IRDA, SOCK_STREAM, 0);

        } else {

            _socket = socket( AF_INET, SOCK_STREAM, 0);

        }

        if (!_socket) {

            goto cleanup;
        }

        setsockopt( _socket, SOL_SOCKET, SO_RCVTIMEO, (char *) &Timeout, sizeof(Timeout));

    } else {

        _socket = INVALID_SOCKET;
    }



    _event = CreateEvent( NULL,          // no security
                          TRUE,          // manual-reset
                          FALSE,         // initially not set
                          NULL           // no name
                          );
    if (!_event)
        {
        goto cleanup;
        }

    _state = BLANK;
    _guard = GUARD_MAGIC;

    if ( !Obex_Init())
        {
        goto cleanup;
        }
    return TRUE;

cleanup:

    if (_files != NULL) {

        delete _files;
        _files=NULL;
    }

    if (_socket != INVALID_SOCKET ) {

        closesocket( _socket );
        _socket=INVALID_SOCKET;
    }

    if (_event != NULL) {

        CloseHandle( _event );
        _event=NULL;
    }

    return FALSE;
}


error_status_t
FILE_TRANSFER::Xfer_ConnStart()
{
    _uObjsReceived = 0;

    _dataXferRecv.fXferInProgress = TRUE;
    _dataXferRecv.dwTotalSize     = 0;
    _dataXferRecv.dwTotalSent     = 0;

    return _SetReceiveFolder( NULL );
}


VOID FILE_TRANSFER::Xfer_ConnEnd( VOID )
{
    _dataXferRecv.fXferInProgress = FALSE;
}


error_status_t
FILE_TRANSFER::Xfer_SetPath(
    LPWSTR szPath
    )
{
    error_status_t status = 0;

    if( !szPath || lstrlen(szPath) == 0 )
        {
        // set default receive folder
        return _SetReceiveFolder( NULL );
        }

    if( lstrcmp(szPath, szPREVDIR) == 0 )
        {
        // pop up a level
        WCHAR sz[MAX_PATH];

        StringCbCopy(sz, sizeof(sz), _szRecvFolder );

        // remove trailing backslash
        if(bHasTrailingSlash(sz))
            sz[lstrlen(sz)-1] = cNIL;

        // strip last folder off path
        StripFile( sz );

        return _SetReceiveFolder( sz );
        }

    // format szPath and append it to the current receive folder

    WCHAR  szRFF[MAX_PATH];
    LPWSTR lpsz;

    // remove preceding backslashes
    while( *szPath == cBACKSLASH )
        szPath++;

    // remove anything after a backslash
    lpsz = szPath;
    while( *lpsz != cNIL && *lpsz != cBACKSLASH )
        lpsz++;
    *lpsz = cNIL;

    StringCbCopy(szRFF, sizeof(szRFF), _szRecvFolder );

    GetUniqueName( szRFF, sizeof(szRFF)/sizeof(WCHAR), szPath, FALSE );

    _uObjsReceived++;
    return _SetReceiveFolder( szRFF );
}


VOID FILE_TRANSFER::Xfer_FileInit( VOID )
{
    _dataXferRecv.dwFileSize = 0;
    _dataXferRecv.dwFileSent = 0;

    FillMemory( &_dataFileRecv.filetime, sizeof(_dataFileRecv.filetime), (BYTE)-1 );

    _dataFileRecv.szFileName[0]= TEXT('\0');
    _dataFileRecv.szFileSave[0]= TEXT('\0');
    _dataFileRecv.szFileTemp[0]= TEXT('\0');

}


error_status_t
FILE_TRANSFER::Xfer_FileSetName( LPWSTR szName )
{
    StringCbCopy(_dataFileRecv.szFileName, sizeof(_dataFileRecv.szFileName), szName );

    return _FileStart();
}


BOOL FILE_TRANSFER::Xfer_FileSetSize( BYTE4 b4Size )
{
    _dataXferRecv.dwFileSize = b4Size;

    return ( IsRoomForFile(_dataXferRecv.dwFileSize, _szRecvFolder) );
}


error_status_t
FILE_TRANSFER::Xfer_FileWriteBody(
    LPVOID lpvData,
    BYTE2 b2Size,
    BOOL fFinal
    )
{
    error_status_t status = 0;
    DWORD dwSize         = b2Size;
    DWORD dwBytesWritten;

    DbgLog1( SEV_FUNCTION, "Xfer_WriteBody: %ld bytes", dwSize );

    // has this file been opened yet?
    if( INVALID_HANDLE_VALUE == _dataFileRecv.hFile )
        {
        ASSERT( 0 );
        return ERROR_CANTOPEN;
        }

    // write the data to the file
    while( dwSize > 0 )
        {
        BOOL fRet;

        fRet = WriteFile( _dataFileRecv.hFile,
                          lpvData,
                          dwSize,
                          &dwBytesWritten,
                          NULL
                          );
        if( !fRet )
            {
            status = GetLastError();
            break;
            }

        lpvData = (LPVOID)( (DWORD_PTR)lpvData + dwBytesWritten );
        dwSize -= dwBytesWritten;

        _dataXferRecv.dwTotalSent += dwBytesWritten;
        _dataXferRecv.dwFileSent  += dwBytesWritten;
        }

    if( fFinal )
        {
        if (!status)
            {
            status = _FileEnd( TRUE );
            }
        else
            {
            _FileEnd( TRUE );
            }
        }

    return status;
}


VOID FILE_TRANSFER::Xfer_FileAbort( VOID )
{
    _FileEnd( FALSE );
}


error_status_t
FILE_TRANSFER::_FileStart()
{
    WCHAR szFullPath[MAX_PATH];
    WCHAR szBaseFile[MAX_PATH];

    //
    // get path of file
    //
    StringCbCopy(szFullPath,sizeof(szFullPath), _szRecvFolder );

    //
    // strip path to get the base filename
    //
    StripPath(_dataFileRecv.szFileName ,szBaseFile, sizeof(szBaseFile)/sizeof(WCHAR) );

    GetUniqueName( szFullPath, sizeof(szFullPath)/sizeof(WCHAR), szBaseFile, TRUE );

    StringCbCopy(_dataFileRecv.szFileSave,sizeof(_dataFileRecv.szFileSave), szFullPath );

    DbgLog1( SEV_INFO, "Save file: [%S]", szFullPath );

    GetTempPath( sizeof(szBaseFile)/sizeof(WCHAR), szBaseFile );
    GetTempFileName( szBaseFile, TEMP_FILE_PREFIX, 0, szFullPath );

    StringCbCopy(_dataFileRecv.szFileTemp,sizeof(_dataFileRecv.szFileTemp), szFullPath );
    DbgLog1( SEV_INFO, "Temp file: [%S]", szFullPath );

    {
        wchar_t RFF[1+MAX_PATH];

        GetReceivedFilesFolder(RFF, MAX_PATH);

        wchar_t * PromptPath = _dataFileRecv.szFileSave + lstrlen(RFF);

        DbgLog2( SEV_INFO, "need to ask permission: \n new file = [%S]\n prompt file = [%S]",
                 _dataFileRecv.szFileSave,
                 PromptPath );

        error_status_t status = _GetPermission( rpcBinding, _cookie, PromptPath, FALSE );
        if (status)
            {
            DbgLog2( SEV_ERROR, "permission check failed, cookie %p error %d", (void *) _cookie, status );
            return status;
            }
    }

    //
    // Create the temporary file.
    //
    _dataFileRecv.hFile = CreateFile(
        szFullPath,
        GENERIC_WRITE,
        0L,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );


    if ( INVALID_HANDLE_VALUE == _dataFileRecv.hFile )
        {
        ReportFileError( MC_IRXFER_OPEN_FAILED, szFullPath, GetLastError() );

        return GetLastError();
        }

    return 0;
}


error_status_t
FILE_TRANSFER::_FileEnd( BOOL fSave )
{
    error_status_t status = 0;

    // set the date stamp
    if( _dataFileRecv.filetime.dwLowDateTime != (DWORD)-1
        || _dataFileRecv.filetime.dwHighDateTime != (DWORD)-1 )
        {
        if( INVALID_HANDLE_VALUE != _dataFileRecv.hFile )
            SetFileTime( _dataFileRecv.hFile, NULL, NULL, &_dataFileRecv.filetime );
        }

    if( INVALID_HANDLE_VALUE != _dataFileRecv.hFile )
        {
        CloseHandle( _dataFileRecv.hFile );
        _dataFileRecv.hFile = INVALID_HANDLE_VALUE;
        }

    if( fSave )
        {
        _uObjsReceived++;


        if (!MoveFile( _dataFileRecv.szFileTemp, _dataFileRecv.szFileSave ))
            {
            status = GetLastError();
            ReportFileError( MC_IRXFER_MOVE_FAILED, _dataFileRecv.szFileSave, status );
            DbgLog3(SEV_ERROR, "%d moving %S -> %S", status, _dataFileRecv.szFileTemp, _dataFileRecv.szFileSave);
            }
        else
            {
            DbgLog2(SEV_INFO, "moved %S -> %S", _dataFileRecv.szFileTemp, _dataFileRecv.szFileSave);
            }

        }
    else
        {
        DeleteFile( _dataFileRecv.szFileTemp );
        }

    Xfer_FileInit();

    return status;
}


error_status_t
FILE_TRANSFER::_SetReceiveFolder(
    LPWSTR szFolder
    )
{
    error_status_t status = 0;

    WCHAR sz[MAX_PATH];
    WCHAR szFullPath[MAX_PATH] = { 0 };
    WCHAR* pszFilePart;

    DbgLog1( SEV_FUNCTION, "_SetReceiveFolder: [%S]", (szFolder?szFolder : L"NULL") );


    GetReceivedFilesFolder( sz, sizeof(sz) );

    //
    // Make sure the requested folder is within the root RFF, for security reasons.
    //
    if ( szFolder && lstrlen(szFolder) > 0 ) {

        DWORD dwLen = GetFullPathName(szFolder, MAX_PATH, szFullPath, &pszFilePart);
        //
        // normalize the path name first, so that the comparison can be meaningful
        //
        if (dwLen != 0 && dwLen < MAX_PATH) {

            if ( 0 == wcsncmp(sz, szFullPath, lstrlen(sz)) ) {

                StringCbCopy(_szRecvFolder,sizeof(_szRecvFolder), szFullPath );

            } else {
                //
                // can't go outside the RFF tree; use the root RFF.
                //
                StringCbCopy(_szRecvFolder,sizeof(_szRecvFolder),sz );
            }

        } else {

            StringCbCopy(_szRecvFolder,sizeof(_szRecvFolder),sz );
        }

    } else {

        StringCbCopy(_szRecvFolder,sizeof(_szRecvFolder),sz );
    }

    //
    // always end path with a backslash '\'
    //
    if( bNoTrailingSlash(_szRecvFolder) ) {

        StringCbCat(_szRecvFolder, sizeof(_szRecvFolder),szBACKSLASH );
    }

    //
    // Get permission to create this directory, unless we have not yet called ReceiveInProgress.
    // This latter will be true only during the connect.  This seems harmless: a malicious
    // client can only create a couple of empty directories in my desktop w/o authorization.
    //
    if (_fInUiReceiveList)
        {
        wchar_t * PromptPath = _szRecvFolder + lstrlen(sz);

        DbgLog2( SEV_INFO, "need to ask permission: \n new dir = [%S]\n prompt dir = [%S]",
                 _szRecvFolder,
                 PromptPath );

        status = _GetPermission( rpcBinding, _cookie, PromptPath, TRUE );
        if (status)
            {
            DbgLog1( SEV_ERROR, "permission check failed %d", status );
            return status;
            }
        }

    DbgLog1( SEV_INFO, "Setting Receive Folder: [%S]", _szRecvFolder );

    if( !DirectoryExists( _szRecvFolder ) )
        {
        status = MdWork( _szRecvFolder );
        if (status)
            {
            ReportFileError( MC_IRXFER_CREATE_DIR_FAILED, _szRecvFolder, status );
            }
        }

    DbgLog1( SEV_FUNCTION, "_SetReceiveFolder leave %d", status);

    return status;
}


VOID
FILE_TRANSFER::_Send_StartXfer( __int64 dwTotalSize,
                                LPWSTR szDst
                                )
{
    _dataXferRecv.fXferInProgress = TRUE;
    _dataXferRecv.dwTotalSize     = dwTotalSize;
    _dataXferRecv.dwTotalSent     = 0;

    _completedFilesSize = 0;
}


VOID FILE_TRANSFER::_Send_EndXfer( VOID )
{
    _dataXferRecv.fXferInProgress = FALSE;
}


error_status_t
FILE_TRANSFER::_SendFile(
    LPWSTR wszFile
    )
{
    error_status_t status = 0;
    DWORD    dwFileTime  = (DWORD)-1;
    HANDLE   hFile=INVALID_HANDLE_VALUE;
    FILETIME filetime;

    DbgLog1(SEV_FUNCTION, "_SendFile( %S )", wszFile);

    StringCbCopy(_dataFileRecv.szFileName,sizeof(_dataFileRecv.szFileName), wszFile );

    hFile = CreateFileW(
        wszFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if ( INVALID_HANDLE_VALUE == hFile ) {

        status=GetLastError();
        goto lExit;
    }

    if( !GetFileTime(hFile, NULL, NULL, &filetime) ) {

        status=GetLastError();
        goto lExit;
    }

    _dataXferRecv.dwFileSize = GetFileSize( hFile, NULL );
    _dataXferRecv.dwFileSent = 0;

    status = Obex_PutBegin( wszFile, _dataXferRecv.dwFileSize, &filetime );
    ExitOnErr( status );

    status = _PutFileBody( hFile, wszFile );
    ExitOnErr( status );

    _completedFilesSize += _dataXferRecv.dwFileSize;

lExit:

    DbgLog1( SEV_FUNCTION, "_SendFile leave [%d]", status );

    if ( INVALID_HANDLE_VALUE != hFile ) {

        CloseHandle( hFile );
    }

    return status;
}


error_status_t
FILE_TRANSFER::_SendFolder(
    LPWSTR wszFolder
    )
{
    error_status_t status = 0;
    BOOL   bContinue;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WCHAR   wszDir[MAX_PATH];
    WCHAR   wszSpec[MAX_PATH*2];
    WIN32_FIND_DATAW findData;

    // send this directory so it's created
    status = Obex_SetPath( wszFolder );
    ExitOnErr( status );

    //
    // get base directory ending with backslash
    //
    StringCbCopy(wszDir, sizeof(wszDir), wszFolder );

    if ( bNoTrailingSlash(wszDir) ) {

        StringCbCat(wszDir,sizeof(wszDir), szBACKSLASH );
    }

    //
    // form search string
    //
    StringCbCopyW(wszSpec,sizeof(wszSpec), wszDir );
    StringCbCatW(wszSpec,sizeof(wszSpec), L"*.*" );

    hFind = FindFirstFileW( wszSpec, &findData );

    bContinue = ( hFind != INVALID_HANDLE_VALUE );

    while( bContinue ) {

        WCHAR wszObj[MAX_PATH*2];

        StringCbCopy(wszObj, sizeof(wszObj), wszDir );
        StringCbCat(wszObj, sizeof(wszObj), findData.cFileName );

        if( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

            // weed out "." and ".."
            if (0 != lstrcmp(findData.cFileName, szPERIOD) && 0 != lstrcmp(findData.cFileName, szPREVDIR))
                {
                status = _SendFolder( wszObj );
                }

        } else {

            status = _SendFile( wszObj );
        }

        if ( status ) {

            break;
        }

        bContinue = FindNextFileW( hFind, &findData );
    }

    // pop out of this directory
    {
    error_status_t errTemp = Obex_SetPath( NULL );

    // only set the error if there isn't one already
    if( !status )
        status = errTemp;
    }
    ExitOnErr( status );

lExit:

    if ( hFind != INVALID_HANDLE_VALUE )
       {
       FindClose( hFind );
       }

    return status;
}


// if we have a file size of 0, we still want to write a
// blank body once, hence fPutOnce
error_status_t
FILE_TRANSFER::_PutFileBody( HANDLE hFile, wchar_t FileName[] )
{
    error_status_t status = 0;
    BOOL  fPutOnce  = FALSE;
    DWORD dwRead;
    BYTE1 b1Send[cbSOCK_BUFFER_SIZE];

    DWORD Extra = sizeof(b1Send) % (_dataRecv.b2MaxPacket-16);

    DbgLog( SEV_FUNCTION, "_PutFileBody" );

    while( !status && !g_fShutdown)
        {
        BOOL fRet = ReadFile(
            hFile,
            b1Send,
            sizeof(b1Send) - Extra,
            &dwRead,
            NULL
            );

        if( !fRet )
            return GetLastError();

        if( dwRead == 0 && fPutOnce )
            break;

        _dataXferRecv.dwTotalSent += dwRead;
        _dataXferRecv.dwFileSent  += dwRead;

        // NOTE: casting dwRead from 4 bytes to 2 bytes requires
        // cbSOCK_BUFFER_SIZE to fit into 2 bytes
        status = Obex_PutBody(  FileName,
                                b1Send,
                                (BYTE2)dwRead,
                                _dataXferRecv.dwFileSent == _dataXferRecv.dwFileSize
                                );
        fPutOnce = TRUE;
        }

    DbgLog1( SEV_FUNCTION, "_PutFileBody leave [%d]", status );

    return status;
}


VOID FILE_TRANSFER::Xfer_SetSize( BYTE4 b4Size )
{
    _dataXferRecv.dwTotalSize = b4Size;
}


void
FILE_TRANSFER::RecordDeviceName(
    SOCKADDR_IRDA * s
    )
{
    char buffer[sizeof(DEVICELIST) + 8*sizeof(IRDA_DEVICE_INFO)];
    DEVICELIST * list = (DEVICELIST *) buffer;
    int size = sizeof(buffer);

    if (SOCKET_ERROR == getsockopt( _socket, SOL_IRLMP, IRLMP_ENUMDEVICES, buffer, &size)) {

        StringCbCopy(_DeviceName,sizeof(_DeviceName), g_UnknownDeviceName );
        return;
    }

    for (unsigned i=0; i < list->numDevice; ++i) {

        if (0 == memcmp(list->Device[i].irdaDeviceID, s->irdaDeviceID, sizeof(s->irdaDeviceID))) {

            UCHAR  TempBuffer[sizeof(list->Device[i].irdaDeviceName)+3];

            unsigned MaxCharCount;

            //
            //  zero out the whole buffer and then copy the string from the device to make sure it
            //  is null terminated
            //
            ZeroMemory(&TempBuffer[0],sizeof(TempBuffer));

            CopyMemory(&TempBuffer[0],list->Device[i].irdaDeviceName,sizeof(list->Device[i].irdaDeviceName));

            //
            //  get the character count of unicode destination buffer
            //
            MaxCharCount = sizeof(_DeviceName)/sizeof(wchar_t);

            if (list->Device[i].irdaCharSet != LmCharSetUNICODE) {

                MultiByteToWideChar(CP_ACP, 0,
                                    (LPCSTR)&TempBuffer[0],
                                    -1,  // NULL terminated string
                                    _DeviceName,
                                    MaxCharCount
                                    );
            } else {
                //
                //  the name is in unicode
                //
                StringCbCopy( _DeviceName,
                         sizeof(_DeviceName),
                         (wchar_t *)&TempBuffer[0]
                         );


            }
            return;
        }
    }

    StringCbCopy(_DeviceName,sizeof(_DeviceName), g_UnknownDeviceName );
}



//
// Code that I took from CMD.EXE
//
#define COLON  ':'
#define NULLC  '\0'
#define BSLASH '\\'

BOOL IsValidDrv(TCHAR drv);

/**************** START OF SPECIFICATIONS ***********************/
/*                                                              */
/* SUBROUTINE NAME: MdWork                                      */
/*                                                              */
/* DESCRIPTIVE NAME: Make a directory                           */
/*                                                              */
/* FUNCTION: MdWork creates a new directory.                    */
/*                                                              */
/* INPUT: arg - a pointer to a NULL terminated string of the    */
/*              new directory to create.                        */
/*                                                              */
/* EXIT-NORMAL: returns zero if the directory is made           */
/*              successfully                                    */
/*                                                              */
/* EXIT-ERROR:      returns an error code otherwise             */
/*                                                              */
/* EFFECTS: None.                                               */
/*                                                              */
/**************** END OF SPECIFICATIONS *************************/

DWORD
MdWork(
       WCHAR *arg
       )
{
    ULONG Status;
    WCHAR *lpw;
    WCHAR TempBuffer[MAX_PATH];

    /*  Check if drive is valid because Dosmkdir does not
        return invalid drive   @@5 */

    if ((arg[1] == COLON) && !IsValidDrv(*arg))
        {
        return ERROR_INVALID_DRIVE;
        }

    if (!GetFullPathName(arg, MAX_PATH, TempBuffer, &lpw))
        {
        return GetLastError();
        }

    if (CreateDirectory( arg, NULL ))
        {
        return 0;
        }

    Status = GetLastError();

    if (Status == ERROR_ALREADY_EXISTS)
        {
        return 0;
        }
    else if (Status != ERROR_PATH_NOT_FOUND)
        {
        return Status;
        }

    //
    //  loop over input path and create any needed intermediary directories.
    //
    //  Find the point in the string to begin the creation.  Note, for UNC
    //  names, we must skip the machine and the share
    //

    if (TempBuffer[1] == COLON) {

        //
        //  Skip D:\
        //

        lpw = TempBuffer+3;
    } else if (TempBuffer[0] == BSLASH && TempBuffer[1] == BSLASH) {

        //
        //  Skip \\server\share\
        //

        lpw = TempBuffer+2;
        while (*lpw && *lpw != BSLASH) {
            lpw++;
        }
        if (*lpw) {
            lpw++;
        }

        while (*lpw && *lpw != BSLASH) {
            lpw++;
        }
        if (*lpw) {
            lpw++;
        }
    } else {
        //
        //  For some reason, GetFullPath has given us something we can't understand
        //

        return ERROR_CANNOT_MAKE;
    }

    //
    //  Walk through the components creating them
    //


    while (*lpw) {

        //
        //  Move forward until the next path separator
        //

        while (*lpw && *lpw != BSLASH) {
            lpw++;
        }

        //
        //  If we've encountered a path character, then attempt to
        //  make the given path.
        //

        if (*lpw == BSLASH) {
            *lpw = NULLC;
            if (!CreateDirectory( TempBuffer, NULL )) {
                Status = GetLastError();
                if (Status != ERROR_ALREADY_EXISTS) {
                    return ERROR_CANNOT_MAKE;
                }
            }
            *lpw++ = BSLASH;
        }
    }

    if (!CreateDirectory( TempBuffer, NULL )) {
        Status = GetLastError( );
        if (Status != ERROR_ALREADY_EXISTS) {
            return Status;
        }
    }

    return 0;
}

/***    IsValidDrv - Check drive validity
 *
 *  Purpose:
 *      Check validity of passed drive letter.
 *
 *  int IsValidDrv(WCHAR drv)
 *
 *  Args:
 *      drv - The letter of the drive to check
 *
 *  Returns:
 *      TRUE if drive is valid
 *      FALSE if not
 *
 *  Notes:
 *
 */

BOOL
IsValidDrv(WCHAR drv)
{
    WCHAR    temp[4];

    temp[ 0 ] = drv;
    temp[ 1 ] = COLON;
    temp[ 2 ] = BSLASH;
    temp[ 3 ] = NULLC;

    //
    // return of 0 or 1 mean can't determine or root
    // does not exists.
    //
    if (GetDriveType(temp) <= 1)
        return( FALSE );
    else {
        return( TRUE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\xferlist.cpp ===
#include "precomp.h"

PXFER_LIST
CreateXferList(
    VOID
    )

{
    PXFER_LIST     XferList;

    XferList=(PXFER_LIST)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(*XferList));

    if (XferList == NULL) {

        return NULL;
    }

    ZeroMemory(XferList,sizeof(XferList));

    XferList->CloseEvent=CreateEvent(NULL,TRUE,FALSE,NULL);

    if (XferList->CloseEvent == NULL) {

        HeapFree(GetProcessHeap(),0,XferList);

        return NULL;
    }

    _try {

        InitializeCriticalSection(
            &XferList->Lock
            );

    } _except(EXCEPTION_EXECUTE_HANDLER) {

        CloseHandle(XferList->CloseEvent);

        HeapFree(GetProcessHeap(),0,XferList);

        return NULL;
    }

    return XferList;

}

VOID
DeleteXferList(
    PXFER_LIST     XferList
    )

{

    ULONG     i;

    EnterCriticalSection(&XferList->Lock);

    XferList->Closing=TRUE;

    for (i=0; i<MAX_TRANSFERS; i++) {

        if (XferList->List[i] != NULL) {

            XferList->List[i]->StopListening();
        }
    }

    if (XferList->Transfers == 0 ) {

        SetEvent(XferList->CloseEvent);
    }

    LeaveCriticalSection(&XferList->Lock);

    WaitForSingleObject(XferList->CloseEvent,INFINITE);

    CloseHandle(XferList->CloseEvent);

    DeleteCriticalSection(
        &XferList->Lock
        );

    HeapFree(GetProcessHeap(),0,XferList);

    return;

}

BOOL
AddTransferToList(
    PXFER_LIST     XferList,
    FILE_TRANSFER* FileTransfer
    )

{

    ULONG     i;
    BOOL      bReturn=FALSE;

    EnterCriticalSection(&XferList->Lock);

    if (!XferList->Closing) {

        for (i=0; i<MAX_TRANSFERS; i++) {

            if (XferList->List[i] == NULL) {

                XferList->List[i]=FileTransfer;
                InterlockedIncrement(&XferList->Transfers);
                bReturn=TRUE;
                break;
            }
        }
    }

    LeaveCriticalSection(&XferList->Lock);

    return bReturn;
}

BOOL
RemoveTransferFromList(
    PXFER_LIST     XferList,
    FILE_TRANSFER* FileTransfer
    )

{
    ULONG     i;
    BOOL      bReturn=FALSE;
    LONG      Count;

    EnterCriticalSection(&XferList->Lock);

    for (i=0; i<MAX_TRANSFERS; i++) {

        if (XferList->List[i] == FileTransfer) {

            XferList->List[i]=NULL;
            Count=InterlockedDecrement(&XferList->Transfers);
            bReturn=TRUE;
            break;
        }
    }

    if (bReturn) {
        //
        //  found the transfer in the list
        //
        if ((Count == 0) && (XferList->Closing)) {

            SetEvent(XferList->CloseEvent);
        }

    } else {
        //
        //  where did the transfer go?
        //
        ASSERT(0);
    }

    LeaveCriticalSection(&XferList->Lock);

    return TRUE;

}


BOOL
AreThereActiveTransfers(
    PXFER_LIST     XferList
    )

{
    ULONG     i;
    BOOL      bReturn=FALSE;

    EnterCriticalSection(&XferList->Lock);

    for (i=0; i<MAX_TRANSFERS; i++) {

        if (XferList->List[i] != NULL) {

            if (XferList->List[i]->IsActive()) {

                bReturn=TRUE;
                break;
            }
        }
    }

    LeaveCriticalSection(&XferList->Lock);

    return bReturn;
}


FILE_TRANSFER*
TransferFromCookie(
    PXFER_LIST     XferList,
    __int64        Cookie
    )

{
    ULONG             i;
    BOOL              bReturn=FALSE;
    FILE_TRANSFER*    Transfer=NULL;

    EnterCriticalSection(&XferList->Lock);

    for (i=0; i<MAX_TRANSFERS; i++) {

        if (XferList->List[i] != NULL) {

            if (XferList->List[i]->GetCookie() == Cookie) {

                Transfer=XferList->List[i];
                break;
            }
        }
    }
#if DBG
    if (Transfer == NULL) {

        DbgPrint("IRMON: TransferFromCookie: could not find cookie\n");
    }

#endif
    LeaveCriticalSection(&XferList->Lock);

    return Transfer;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\irxfer\xfer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       xfer.h
//
//--------------------------------------------------------------------------

#ifndef _XFER_H_
#define _XFER_H_

#include <stdio.h>

#define SERVICE_NAME_1         "OBEX:IrXfer"
#define SERVICE_NAME_2         "OBEX"


#define GUARD_MAGIC             0x45454545

#define TIMEOUT_INFINITE            (~0UL)
#define ERROR_DESCRIPTION_LENGTH    1000
#define IRDA_DEVICE_NAME_LENGTH     22

//
// OBEX parameter codes
//

#define OBEX_PARAM_UNICODE            0x00
#define OBEX_PARAM_STREAM             0x40
#define OBEX_PARAM_1BYTE              0x80
#define OBEX_PARAM_4BYTE              0xC0

#define OBEX_PARAM_TYPE_MASK          0xC0

#define OBEX_PARAM_COUNT              ( 0x00 | OBEX_PARAM_4BYTE   )
#define OBEX_PARAM_NAME               ( 0x01 | OBEX_PARAM_UNICODE )
#define OBEX_PARAM_LENGTH             ( 0x03 | OBEX_PARAM_4BYTE   )
#define OBEX_PARAM_UNIX_TIME          ( 0x04 | OBEX_PARAM_4BYTE   )
#define OBEX_PARAM_ISO_TIME           ( 0x04 | OBEX_PARAM_STREAM  )
#define OBEX_PARAM_BODY               ( 0x08 | OBEX_PARAM_STREAM  )
#define OBEX_PARAM_BODY_END           ( 0x09 | OBEX_PARAM_STREAM  )
#define OBEX_PARAM_WHO                ( 0x0A | OBEX_PARAM_STREAM  )
// #define OBEX_PARAM_LEN                1

#define PRIVATE_PARAM_WIN32_ERROR     ( 0x30 | OBEX_PARAM_4BYTE )

// for xfer.c

typedef struct {
    BOOL   fXferInProgress;         // transfer in progress
    __int64  dwTotalSize;             // total size of transfer
    __int64  dwTotalSent;             // number of bytes sent in this transfer
    __int64  dwFileSize;              // total size of current file
    __int64  dwFileSent;              // number of bytes sent of the current file
} DATA_XFER, *LPDATA_XFER;

typedef struct {
    FILETIME filetime;              // file time
    WCHAR     szFileName[MAX_PATH];  // name of file
    WCHAR     szFileSave[MAX_PATH];  // path+name of final file
    WCHAR     szFileTemp[MAX_PATH];  // path+name of temp file used
    HANDLE   hFile;                 // file handle (of szFileTemp)
} DATA_FILE, *LPDATA_FILE;

// for obex.c

typedef struct {
    BYTE1  b1Flags;                 // setpath flags
    BYTE1  b1Constants;             // setpath constants
} DATA_PATH, *LPDATA_PATH;

typedef struct {
    BOOL   fWaiting;                // indicates if waiting for a reply
    BYTE1  b1Status;                // response status (error/success)
} DATA_REPLY, *LPDATA_REPLY;

typedef enum {
    osIDLE       = 0,
    osCONN       = 1,
    osFILE       = 2
} OBEXSTATE;

typedef struct {
    LPSTORE   lpStore;
    OBEXSTATE state;
    BYTE1     b1Version;               // peer's version of obex
    BYTE1     b1Flags;                 // connection flags
    BYTE2     b2MaxPacket;             // peer's maximum packet size
} DATA_CONN, *LPDATA_CONN;

// for status.c

typedef struct {
    DWORD dwDeviceID;
    BOOL  fClear;
} TARGET_ITEM, *LPTARGET_ITEM;




//-------------------------------------


enum TRANSFER_STATE
{
    BLANK,
    CONNECTING,
    ACCEPTING,
    READING,
    WRITING,
    CLOSING
};

enum OBEX_DIALECT
{
    dialUnknown = 0,
    dialWin95,
    dialNt5
};

typedef class FILE_TRANSFER * PFILE_TRANSFER;


class FILE_TRANSFER
{
public:

     FILE_TRANSFER(  );
    ~FILE_TRANSFER();


    BOOL
    Xfer_Init(
        wchar_t * files,
        unsigned length,
        OBEX_DIALECT dialect ,
        OBEX_DEVICE_TYPE    DeviceType,
        BOOL                CreateSocket,
        SOCKET              ListenSocket
        );

    BOOL
    SendReplyObex(
        BYTE1 ObexCode
        );

    BOOL
    SendReplyWin32(
        BYTE1 b1Opcode,
        DWORD status
        );


    void
    BeginSend(
              DWORD DeviceId,
              OBEX_DEVICE_TYPE    DeviceType,
              error_status_t * pStatus,
              FAILURE_LOCATION * pLocation
              );

    void Deactivate();


    DWORD
    SyncAccept(
        VOID
        );


    handle_t        _rpcHandle;
    COOKIE          _cookie;

    inline long
    DecrementRefCount()
    {

        EnterCriticalSection(&m_Lock);

        long count = --_refs;

        DbgLog3(SEV_INFO, "[%x] %p: refs = %d\n", (DWORD) _cookie, this, count);

        if (0 == count) {
#if DBG
            DbgPrint("irmon: freeing transfer\n");
#endif
            LeaveCriticalSection(&m_Lock);
            delete this;
            return count;

        } else {

            LeaveCriticalSection(&m_Lock);
        }

        return count;
    }

    inline BOOL
    IsActive(
        VOID
        )

    {

        return (_state != ACCEPTING);
    }

    inline long
    IncrementRefCount()
    {

        EnterCriticalSection(&m_Lock);

        long count = ++_refs;

        DbgLog3(SEV_INFO, "[%x] %p: refs = %d\n", (DWORD) _cookie, this, count);

        LeaveCriticalSection(&m_Lock);

        return count;
    }


    void Cancel()
    {
        _fCancelled = TRUE;
    }

    COOKIE
    GetCookie(
        VOID
        )
    {
        return _cookie;
    }

    void Send();

    void RecordDeviceName( SOCKADDR_IRDA * s );

    VOID
    StopListening(
        VOID
        )
    {

        IncrementRefCount();
        EnterCriticalSection(&m_Lock);

        m_StopListening=TRUE;
        if (m_ListenSocket != INVALID_SOCKET) {

            closesocket(m_ListenSocket);
            m_ListenSocket=INVALID_SOCKET;

        }

        LeaveCriticalSection(&m_Lock);
        DecrementRefCount();
        return;
    }


private:

    CRITICAL_SECTION  m_Lock;
    BOOL              m_StopListening;

    SOCKET            m_ListenSocket;
    OBEX_DEVICE_TYPE  m_DeviceType;



    BOOL            _fCancelled;
    BOOL            _fInUiReceiveList;
    XFER_TYPE       _xferType;
    TRANSFER_STATE  _state;
    SOCKET          _socket;


    wchar_t *       _files;
    long            _refs;
    HANDLE          _event;
    BOOL            _fWriteable;

    OBEX_DIALECT    _dialect;

    wchar_t         _DeviceName[MAX_PATH];

    HANDLE          _waitHandle;
    BYTE            _buffer[ cbSOCK_BUFFER_SIZE + 16 + sizeof(SOCKADDR_IRDA) + 16 + sizeof(SOCKADDR_IRDA) ];
    DWORD           _guard;

    void
    HandleClosure(
                   DWORD error
                   );

    // for sock.c


    error_status_t   Sock_Request( LPVOID lpvData, DWORD dwDataSize );
    error_status_t   Sock_Respond( LPVOID lpvData, DWORD dwDataSize );

    error_status_t Sock_EstablishConnection( DWORD dwDeviceID ,OBEX_DEVICE_TYPE DeviceType);

    VOID  Sock_BreakConnection( SOCKET * pSock );

    error_status_t _SendDataOnSocket( SOCKET sock, LPVOID lpvData, DWORD dwDataSize );

    VOID _BreakConnection( SOCKET sock );
    VOID _ReadConnection( SOCKET sock );

    error_status_t Sock_CheckForReply( long Timeout );

    // for xfer.c

    UINT       _uObjsReceived;
    WCHAR       _szRecvFolder[MAX_PATH];
    DATA_FILE  _dataFileRecv;
    DATA_XFER  _dataXferRecv;

    BOOL Xfer_FileSetSize( BYTE4 b4Size );
    error_status_t Xfer_FileWriteBody( LPVOID lpvData, BYTE2 b2Size, BOOL fFinal );

    VOID Xfer_ConnEnd( VOID );
    error_status_t Xfer_ConnStart( VOID );
    VOID Xfer_FileAbort( VOID );
    VOID Xfer_FileInit( VOID );
    error_status_t Xfer_FileSetName( LPWSTR szName );
    VOID Xfer_FileSetTime( FILETIME * FileTime );
    error_status_t Xfer_SetPath( LPWSTR szPath );
    VOID Xfer_SetSize( BYTE4 b4Size );


    error_status_t _PutFileBody( HANDLE hFile, wchar_t FileName[] );
    error_status_t _SendFile( LPWSTR szFile );
    error_status_t _SendFolder( LPWSTR szFolder );
    error_status_t _FileStart( VOID );
    error_status_t _FileEnd( BOOL fSave );
    VOID _Send_StartXfer( __int64 dwTotalSize, LPWSTR szDst );
    VOID _Send_EndXfer( VOID );
    error_status_t _SetReceiveFolder( LPWSTR szFolder );

    // for progress.c

    DWORD _dwTimeStart;
    DWORD _dwSecondsLeft;
    int   _CurrentPercentage;

    VOID _FormatTime( LPWSTR sz, DWORD dwSeconds );

    // for obex.c

    DATA_CONN  _dataRecv;
    DATA_PATH  _dataPath;
    DATA_REPLY _dataReply;

    ULONG   _blocksSent;
    ULONG   _blocksAcked;
    ULONG   _blockSize;

    __int64 _completedFilesSize;
    __int64 _currentFileSize;
    __int64 _currentFileAcked;

    DWORD   _lastAckTime;

    error_status_t Obex_Abort( error_status_t status );
    error_status_t Obex_Connect( __int64 dwTotalSize );
    error_status_t Obex_Disconnect( error_status_t status );
    error_status_t Obex_PutBegin( LPWSTR wszObj, __int64 dwObjSize, FILETIME * pFileTime );
    error_status_t Obex_PutBody( wchar_t FileName[], LPBYTE1 pb1Data, BYTE2 b2DataSize, BOOL fFinal );
    error_status_t Obex_SetPath( LPWSTR wszPath );

    BOOL Obex_ConsumePackets( XFER_TYPE xferType, error_status_t * pStatus );
    BOOL Obex_Init( VOID );
    BOOL Obex_ReceiveData( XFER_TYPE xferType, LPVOID lpvData, DWORD dwDataSize );
    VOID Obex_Reset( VOID );

    error_status_t _WaitForReply( DWORD dwTimeout, BYTE1 b1NeededReply );
    error_status_t _Put( LPWSTR wszObj, __int64 dwObjSize, FILETIME * Time, LPBYTE1 pb1Data, BYTE2 b2DataSize, BOOL fFinal );
    error_status_t _Request( LPSTORE lpStore, BYTE1 b1NeededReply );
    error_status_t _Respond( LPSTORE lpStore );
    INT _ValidOpcode( OBEXSTATE state, BYTE1 b1Opcode );
    BOOL _HandleAbort( BYTE1 b1Opcode, BYTE2 b2Length );
    BOOL _HandleBadRequest( BYTE1 b1Opcode );
    BOOL _HandleConnect( BYTE1 b1Opcode, BYTE2 b2Length );
    BOOL _HandleDisconnect( BYTE1 b1Opcode, BYTE2 b2Length );
    BOOL _HandleNotImplemented( BYTE1 b1Opcode );
    error_status_t _HandlePut( BYTE1 b1Opcode, BYTE2 b2Length, BOOL fFinal );
    error_status_t _HandleResponse( BYTE1 b1Status, BYTE2 b2Length );
    error_status_t _HandleRequest( BYTE1 b1Opcode, BYTE2 b2Length );
    error_status_t _HandleSetPath( BYTE1 b1Opcode, BYTE2 b2Length );
    error_status_t  _ParseParams( BYTE1 b1Opcode, BYTE2 b2Length );
    BOOL _PokePacketSizeIntoStore( LPSTORE lpStore );
    VOID _SetState( LPDATA_CONN lpDataConn, OBEXSTATE os );
    VOID _WaitInit( VOID );
    VOID _WriteBody( LPVOID lpvData, BYTE2 b2Size, BOOL fFinal );
    BYTE2 _SkipHeader( BYTE1 b1Param, LPSTORE lpStore );

    BYTE1
    StatusToReplyCode(
        BYTE1 b1Opcode,
        DWORD status
        );

    error_status_t
    ObexStatusToWin32(
        BYTE1 ObexStatus
        );

    BOOL Activate();

};

error_status_t
_GetObjListStats(
                  LPWSTR lpszObjList,
                  LPDWORD lpdwFiles,
                  LPDWORD lpdwFolders,
                  __int64 * pTotalSize
                  );

DWORD
ReportFileError( DWORD mc,
                 WCHAR * file,
                 DWORD error
                 );

BYTE1 WinErrorToObexError( DWORD Win32Error );

extern RPC_BINDING_HANDLE rpcBinding;
extern BOOL g_fAllowReceives;
extern wchar_t g_DuplicateFileTemplate[];
extern wchar_t g_UnknownDeviceName[];
extern MUTEX * g_Mutex;
#include <stdio.h>

extern "C" {

FILE_TRANSFER* InitializeSocket(
    char     ServiceName[]
    );


FILE_TRANSFER *
ListenForTransfer(
    SOCKET              ListenSocket,
    OBEX_DEVICE_TYPE    DeviceType
    );
}


#endif // _XFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\rasirda\rasirdap.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    rasirdap.h

Abstract:

Author:

    mbert 9-97

--*/

#include <ntddk.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <ntddtcp.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>

#include <cxport.h>
#include <dbgmsg.h>
#include <refcnt.h>
#include <af_irda.h>
#include <irdatdi.h>
#include <irtdicl.h>
#include <irmem.h>

extern LIST_ENTRY       RasIrAdapterList;
extern NDIS_SPIN_LOCK   RasIrSpinLock;

#define NDIS_MajorVersion 5
#define NDIS_MinorVersion 0

#define ADAPTER_SIG         0xAA00AA00AA
#define VC_SIG              0xCC00CC00CC
#define ENDP_SIG            0xEE00EE00EE

#define GOODADAPTER(a)      ASSERT(a->Sig == (ULONG)ADAPTER_SIG)
#define GOODVC(vc)          ASSERT(vc->Sig == (ULONG)VC_SIG)
#define GOODENDP(endp)      ASSERT(endp->Sig == (ULONG)ENDP_SIG)


#define RASIR_SERVICE_NAME_DIRECT   "IrNetv1"
#define RASIR_SERVICE_NAME_ASYNC    "IrNetAsyncv1" // async frameing for Win CE
#define RASIR_SERVICE_NAME_IRMODEM  "IrModem"

#define RASIR_MAX_LINE_NAME 64

#define RASIR_INTERNAL_SEND (PVOID) -1

#define RASIR_MAX_RATE      4000000

#define AF_FLAG_CHAR        0x7E
#define AF_ESC_CHAR         0x7D
#define AF_COMP_BIT         0x20

#define TX_BUF_POOL_SIZE    6

#define CALC_FCS(fcs, chr)  ((fcs >> 8)^FcsTable[(fcs ^ chr) & 0xFF]) 

#define STUFF_BYTE(p,b,am)   do { \
                                if (((b < 0x20) && ((1 << b) & am)) ||  \
                                    b == AF_FLAG_CHAR || b == AF_ESC_CHAR) \
                                { \
                                   *p++ = AF_ESC_CHAR; \
                                   *p++ = b ^ AF_COMP_BIT; \
                                } \
                                else \
                                { \
                                   *p++ = b;\
                                } \
                            } while (0);       


#define ASYNC_BUF_SIZE  (IRDA_MAX_DATA_SIZE*2) // worst case byte stuffing
typedef struct 
{
    LIST_ENTRY      Linkage;
    UCHAR           Buf[ASYNC_BUF_SIZE]; 
    int             BufLen;
    PNDIS_BUFFER    pNdisBuf;
} ASYNC_BUFFER, *PASYNC_BUFFER;


typedef struct
{
    LIST_ENTRY                  Linkage;
    LIST_ENTRY                  VcList;
    ULONG                       Sig;
    LIST_ENTRY                  EndpList;
    NDIS_HANDLE                 NdisSapHandle;
    NDIS_HANDLE                 NdisAfHandle;
    NDIS_HANDLE                 MiniportAdapterHandle;
    NPAGED_LOOKASIDE_LIST       WorkItemsLList;
    NPAGED_LOOKASIDE_LIST       AsyncBufLList;    
    NDIS_SPIN_LOCK              SpinLock;
    NDIS_WAN_CO_INFO            Info;
    BOOLEAN                     ModemPort;
    WCHAR                       TapiLineNameBuf[32];
    NDIS_STRING                 TapiLineName;
    ULONG                       Flags;
     #define ADF_PENDING_AF_CLOSE 0x00000001
     #define ADF_SAP_DEREGISTERED 0x00000002
} RASIR_ADAPTER, *PRASIR_ADAPTER;

typedef struct 
{
    LIST_ENTRY      Linkage;
    ULONG           Sig;
    PRASIR_ADAPTER  pAdapter;
    PVOID           IrdaEndpContext;
    ULONG           EndpType;    
     #define EPT_DIRECT         1
     #define EPT_ASYNC          2 // using async framing            
    #if DBG 
    CHAR            ServiceName[IRDA_DEV_SERVICE_LEN];
    #endif
} RASIR_IRDA_ENDPOINT, *PRASIR_IRDA_ENDPOINT;


typedef struct
{
    LIST_ENTRY                  Linkage;
    ULONG                       Sig;
    PRASIR_ADAPTER              pAdapter;
    NDIS_HANDLE                 NdisVcHandle;
    PVOID                       IrdaConnContext;
    REF_CNT                     RefCnt;
    PCHAR                       pInCallParms;
    PCO_CALL_PARAMETERS         pMakeCall;
    PCO_AF_TAPI_MAKE_CALL_PARAMETERS pTmParams;
    PCO_AF_TAPI_INCOMING_CALL_PARAMETERS pTiParams;    
    NDIS_WAN_CO_GET_LINK_INFO   LinkInfo;
    NDIS_HANDLE                 RxBufferPool;
    NDIS_HANDLE                 RxPacketPool;
    NDIS_HANDLE                 TxBufferPool;
    LONG                        OutstandingSends;
    ULONG                       Flags;
     #define  VCF_CREATED_LOCAL  0x00000001
     #define  VCF_IRDA_OPEN      0x00000002
     #define  VCF_OPEN           0x00000004
     #define  VCF_CLOSING        0x00000008
     #define  VCF_CLOSE_PEND     0x00000010
     #define  VCF_MAKE_CALL_PEND 0x00000020
    ULONG                       ConnectionSpeed;
    BOOLEAN                     AsyncFraming;
    PASYNC_BUFFER               pCurrAsyncBuf;
    LIST_ENTRY                  CompletedAsyncBufList;
    ULONG                       AsyncFramingState;
     #define RX_READY           0
     #define RX_RX              1
     #define RX_ESC             2
    BOOLEAN                     IrModemCall;
    ULONG                       ModemState;
     #define MS_OFFLINE         0
     #define MS_CONNECTING      1
     #define MS_ONLINE          2
    CHAR                        OfflineSendBuf[32];
    PNDIS_BUFFER                pOfflineNdisBuf;
} RASIR_VC, *PRASIR_VC;

typedef struct 
{
    CO_TAPI_LINE_CAPS   caps;
    WCHAR               LineName[RASIR_MAX_LINE_NAME];
} RASIR_CO_TAPI_LINE_CAPS;


PRASIR_ADAPTER
IrdaEndpointToAdapter(PVOID EndpointContext);

NDIS_STATUS
RasIrInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext);

VOID
RasIrHalt(
    IN NDIS_HANDLE MiniportAdapterContext);

NDIS_STATUS
RasIrReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext);

VOID
RasIrReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet);

NDIS_STATUS
RasIrCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters);

NDIS_STATUS
RasIrCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext);

VOID
RasIrCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets);

NDIS_STATUS
RasIrCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest);

VOID
RasIrReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet);


// Call Manager handlers
NDIS_STATUS
RasIrCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext);

NDIS_STATUS
RasIrCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext);

NDIS_STATUS
RasIrCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext);

NDIS_STATUS
RasIrCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext);

NDIS_STATUS
RasIrCmRegisterSap(
    IN NDIS_HANDLE CallMgrAfContext,
    IN PCO_SAP Sap,
    IN NDIS_HANDLE NdisSapHandle,
    OUT PNDIS_HANDLE CallMgrSapContext);

NDIS_STATUS
RasIrCmDeregisterSap(
    NDIS_HANDLE CallMgrSapContext);

NDIS_STATUS
RasIrCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext);

NDIS_STATUS
RasIrCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size);

VOID
RasIrCmIncomingCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters);

VOID
RasIrCmActivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters);

VOID
RasIrCmDeactivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext);

NDIS_STATUS
RasIrCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters);

NDIS_STATUS
RasIrCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest);

NDIS_STATUS
ScheduleWork(
    IN PRASIR_ADAPTER pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext);

VOID
AllocCallParms(
    IN PRASIR_VC pVc);

VOID
DeleteVc(
    IN PRASIR_VC pVc);

VOID
CompleteClose(
    IN PRASIR_VC pVc);

VOID    
ProcessOfflineRxBuf(
    IN PRASIR_VC pVc,
    IN PIRDA_RECVBUF pRecvBuf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\rasirda\rasirda.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    rasirda.c

Abstract:

    Miniport peice of the irda NDIS 5 miniport (WAN driver) 
    
Author:

    mbert 9-97    

--*/

#include "rasirdap.h"

// Globals
#if DBG

#include <irioctl.h>
#if 0
int DbgSettings = 
        DBG_INIT        |
        DBG_CONFIG      |
        DBG_CONNECT     |
//        DBG_SEND        |
//        DBG_RECV        |
        DBG_LIB_OBJ     |
        DBG_LIB_CONNECT |
        DBG_ERROR       |
        1;
#else
int DbgSettings = 0;
#endif
int DbgOutput = 
        DBG_OUTPUT_BUFFER | 
        DBG_OUTPUT_DEBUGGER |
        0;

PDRIVER_OBJECT  pRasIrDriverObject;
PDEVICE_OBJECT  pRasIrDeviceObject;

NTSTATUS
DbgDispatch(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp);
#endif

NDIS_SPIN_LOCK  RasIrSpinLock;
LIST_ENTRY      RasIrAdapterList;

const USHORT FcsTable[256] = {
    0x0000,0x1189,0x2312,0x329B,0x4624,0x57AD,0x6536,0x74BF,
    0x8C48,0x9DC1,0xAF5A,0xBED3,0xCA6C,0xDBE5,0xE97E,0xF8F7,
    0x1081,0x0108,0x3393,0x221A,0x56A5,0x472C,0x75B7,0x643E,
    0x9CC9,0x8D40,0xBFDB,0xAE52,0xDAED,0xCB64,0xF9FF,0xE876,
    0x2102,0x308B,0x0210,0x1399,0x6726,0x76AF,0x4434,0x55BD,
    0xAD4A,0xBCC3,0x8E58,0x9FD1,0xEB6E,0xFAE7,0xC87C,0xD9F5,
    0x3183,0x200A,0x1291,0x0318,0x77A7,0x662E,0x54B5,0x453C,
    0xBDCB,0xAC42,0x9ED9,0x8F50,0xFBEF,0xEA66,0xD8FD,0xC974,
    0x4204,0x538D,0x6116,0x709F,0x0420,0x15A9,0x2732,0x36BB,
    0xCE4C,0xDFC5,0xED5E,0xFCD7,0x8868,0x99E1,0xAB7A,0xBAF3,
    0x5285,0x430C,0x7197,0x601E,0x14A1,0x0528,0x37B3,0x263A,
    0xDECD,0xCF44,0xFDDF,0xEC56,0x98E9,0x8960,0xBBFB,0xAA72,
    0x6306,0x728F,0x4014,0x519D,0x2522,0x34AB,0x0630,0x17B9,
    0xEF4E,0xFEC7,0xCC5C,0xDDD5,0xA96A,0xB8E3,0x8A78,0x9BF1,
    0x7387,0x620E,0x5095,0x411C,0x35A3,0x242A,0x16B1,0x0738,
    0xFFCF,0xEE46,0xDCDD,0xCD54,0xB9EB,0xA862,0x9AF9,0x8B70,
    0x8408,0x9581,0xA71A,0xB693,0xC22C,0xD3A5,0xE13E,0xF0B7,
    0x0840,0x19C9,0x2B52,0x3ADB,0x4E64,0x5FED,0x6D76,0x7CFF,
    0x9489,0x8500,0xB79B,0xA612,0xD2AD,0xC324,0xF1BF,0xE036,
    0x18C1,0x0948,0x3BD3,0x2A5A,0x5EE5,0x4F6C,0x7DF7,0x6C7E,
    0xA50A,0xB483,0x8618,0x9791,0xE32E,0xF2A7,0xC03C,0xD1B5,
    0x2942,0x38CB,0x0A50,0x1BD9,0x6F66,0x7EEF,0x4C74,0x5DFD,
    0xB58B,0xA402,0x9699,0x8710,0xF3AF,0xE226,0xD0BD,0xC134,
    0x39C3,0x284A,0x1AD1,0x0B58,0x7FE7,0x6E6E,0x5CF5,0x4D7C,
    0xC60C,0xD785,0xE51E,0xF497,0x8028,0x91A1,0xA33A,0xB2B3,
    0x4A44,0x5BCD,0x6956,0x78DF,0x0C60,0x1DE9,0x2F72,0x3EFB,
    0xD68D,0xC704,0xF59F,0xE416,0x90A9,0x8120,0xB3BB,0xA232,
    0x5AC5,0x4B4C,0x79D7,0x685E,0x1CE1,0x0D68,0x3FF3,0x2E7A,
    0xE70E,0xF687,0xC41C,0xD595,0xA12A,0xB0A3,0x8238,0x93B1,
    0x6B46,0x7ACF,0x4854,0x59DD,0x2D62,0x3CEB,0x0E70,0x1FF9,
    0xF78F,0xE606,0xD49D,0xC514,0xB1AB,0xA022,0x92B9,0x8330,
    0x7BC7,0x6A4E,0x58D5,0x495C,0x3DE3,0x2C6A,0x1EF1,0x0F78
};
    
NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath);
    
NDIS_STATUS
QueryInformation(
    IN PRASIR_ADAPTER pAdapter,
    IN PRASIR_VC pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded);

NDIS_STATUS
SetInformation(
    IN PRASIR_ADAPTER pAdapter,
    IN PRASIR_VC pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded);

    
#pragma NDIS_INIT_FUNCTION(DriverEntry)

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )
{
    NDIS_STATUS                     Status;
    NDIS_MINIPORT_CHARACTERISTICS   MiniportChr;
    NDIS_HANDLE                     NdisWrapperHandle;
#if DBG
    UNICODE_STRING                  DeviceName;
    int                             i;
#endif
    
    DEBUGMSG(DBG_INIT, ("RASIR: DriverEntry\n"));

    IrdaClientInitialize();  
    
    NdisAllocateSpinLock(&RasIrSpinLock);        
    
    InitializeListHead(&RasIrAdapterList);

    NdisMInitializeWrapper(&NdisWrapperHandle, DriverObject, 
                           RegistryPath, NULL );
    NdisZeroMemory( &MiniportChr, sizeof(MiniportChr) );

    MiniportChr.MajorNdisVersion        = NDIS_MajorVersion;
    MiniportChr.MinorNdisVersion        = NDIS_MinorVersion;
    MiniportChr.Reserved                = NDIS_USE_WAN_WRAPPER;
    MiniportChr.HaltHandler             = RasIrHalt;
    MiniportChr.InitializeHandler       = RasIrInitialize;
    MiniportChr.ResetHandler            = RasIrReset;
    MiniportChr.ReturnPacketHandler     = RasIrReturnPacket;
    MiniportChr.CoActivateVcHandler     = RasIrCoActivateVc;
    MiniportChr.CoDeactivateVcHandler   = RasIrCoDeactivateVc;
    MiniportChr.CoSendPacketsHandler    = RasIrCoSendPackets;
    MiniportChr.CoRequestHandler        = RasIrCoRequest;
    
    // no CheckForHangHandler
    // no DisableInterruptHandler
    // no EnableInterruptHandler
    // no HandleInterruptHandler
    // no ISRHandler
    // no QueryInformationHandler (see CoRequestHandler)
    // no SendHandler (see CoSendPacketsHandler)
    // no WanSendHandler (see CoSendPacketsHandler)
    // no SetInformationHandler (see CoRequestHandler)
    // no TransferDataHandler
    // no WanTransferDataHandler    
    // no SendPacketsHandler (see CoSendPacketsHandler)
    // no AllocateCompleteHandler
    

    Status = NdisMRegisterMiniport(NdisWrapperHandle, &MiniportChr, sizeof(MiniportChr));

    if (Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: ->NdisMRegisterMiniport failed %x\n", Status));
        NdisTerminateWrapper(NdisWrapperHandle, NULL);
    }

#if 0

    DbgMsgInit();  
    
    RtlInitUnicodeString(&DeviceName, L"\\Device\\RASIR");

    Status = IoCreateDevice(
        DriverObject,           // DriverObject
        0,                      // DeviceExtensionSize
        &DeviceName,            // DeviceName
        FILE_DEVICE_NETWORK,    // DeviceType
        0,                      // DeviceCharacteristics
        FALSE,                  // Exclusive?
        &pRasIrDeviceObject);    // DeviceObject pointer returned
    
    if (Status != STATUS_SUCCESS)
        DbgPrint("Failed to create device\n");

    else
    {
        DriverObject->DriverUnload   = NULL;
        DriverObject->FastIoDispatch = NULL;
    
        for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
        {
            DriverObject->MajorFunction[i] = DbgDispatch;
        }
        
        pRasIrDeviceObject->Flags |= DO_DIRECT_IO;
        
    }
#endif

    return Status;
}

VOID
FreeAdapter(PRASIR_ADAPTER pAdapter)
{

    ASSERT(IsListEmpty(&pAdapter->VcList));
    
    #if DBG
    pAdapter->Sig = 0xBAD;
    #endif
    
    NdisDeleteNPagedLookasideList(&pAdapter->WorkItemsLList);
    NdisDeleteNPagedLookasideList(&pAdapter->AsyncBufLList);    

    NdisFreeMemory(pAdapter, sizeof(PRASIR_ADAPTER), 0);
}

NDIS_STATUS
RasIrInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext)
{
    UINT            i;
    PRASIR_ADAPTER                      pAdapter;
    NDIS_CALL_MANAGER_CHARACTERISTICS   CallMgrChr;
    CO_ADDRESS_FAMILY                   Family;    
    NDIS_STATUS                         Status;
    NDIS_HANDLE                         hConfig;    
    PNDIS_CONFIGURATION_PARAMETER       Value;    
    NDIS_STRING                         TapiLineNameString = NDIS_STRING_CONST("TapiLineName");
    NDIS_STRING                         ModemPortString = NDIS_STRING_CONST("ModemPort");    
    ULONG                               ModemPort;
    
    DEBUGMSG(DBG_ERROR, ("RASIR: Miniport initialize\n"));
    
    for (i = 0; i < MediumArraySize; ++i)
    {
        if (MediumArray[i] == NdisMediumCoWan)
            break;
    }

    if (i == MediumArraySize)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: No matching media\n"));
        return NDIS_STATUS_FAILURE;
    }

    *SelectedMediumIndex = i;

    NdisAllocateMemoryWithTag((PVOID *)&pAdapter, sizeof(RASIR_ADAPTER),
                              MT_RASIR_ADAPTER);

    if (pAdapter == NULL)
        return NDIS_STATUS_RESOURCES;
        
    NdisZeroMemory(pAdapter, sizeof(RASIR_ADAPTER));        
        
    InitializeListHead(&pAdapter->VcList);
    
    InitializeListHead(&pAdapter->EndpList);    

    NdisInitializeNPagedLookasideList(
        &pAdapter->WorkItemsLList,
        NULL, NULL, 0,
        sizeof(NDIS_WORK_ITEM),
        MT_RASIR_WORKITEM, // RasIr work item
        10);
        
    NdisInitializeNPagedLookasideList(
        &pAdapter->AsyncBufLList,
        NULL, NULL, 0,
        sizeof(ASYNC_BUFFER),
        MT_RASIR_ASYNCBUF, // RasIr work item
        0);        
        
    NdisAllocateSpinLock(&pAdapter->SpinLock);        
    
    NdisOpenConfiguration(&Status, &hConfig, WrapperConfigurationContext);
    
    if (Status == NDIS_STATUS_SUCCESS)
    {
        pAdapter->TapiLineNameBuf[0] = 0;
        pAdapter->TapiLineName.Buffer = pAdapter->TapiLineNameBuf;
        pAdapter->TapiLineName.Length = 0;
        pAdapter->TapiLineName.MaximumLength = sizeof(pAdapter->TapiLineNameBuf);
        
        NdisReadConfiguration(&Status,
                              &Value,
                              hConfig,
                              &TapiLineNameString,
                              NdisParameterString);
      
        if (Status == NDIS_STATUS_SUCCESS)
        {
            RtlCopyUnicodeString(&pAdapter->TapiLineName, &Value->ParameterData.StringData);
            *(PWCHAR)(pAdapter->TapiLineName.Buffer + (pAdapter->TapiLineName.MaximumLength)/sizeof(WCHAR)) = UNICODE_NULL;

        } else {
            //
            //  could not get the line name
            //
            NdisCloseConfiguration(hConfig);
            goto Done;
        }
                        
        NdisReadConfiguration(&Status,
                              &Value,
                              hConfig,
                              &ModemPortString,
                              NdisParameterInteger);
      
        if (Status == NDIS_STATUS_SUCCESS)
        {
            pAdapter->ModemPort = (BOOLEAN) Value->ParameterData.IntegerData;
        }  
        
        NdisCloseConfiguration(hConfig);

    } else {
        //
        //  could open the config info
        //
        goto Done;
    }
    
    DEBUGMSG(DBG_CONFIG, ("RASIR: ModemPort = %d\n", pAdapter->ModemPort));
    
    pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;    

    pAdapter->Info.MaxFrameSize = IRDA_MAX_DATA_SIZE;
    pAdapter->Info.MaxSendWindow = 4;
    pAdapter->Info.FramingBits = PPP_FRAMING | 
                                 PPP_COMPRESS_ADDRESS_CONTROL |
                                 PPP_COMPRESS_PROTOCOL_FIELD;
    pAdapter->Info.DesiredACCM = 0;                             
                                 
#if DBG
    pAdapter->Sig = (ULONG)ADAPTER_SIG;
#endif
        
    // Inform NDIS of the attributes of our adapter.  Set the
    // 'MiniportAdapterContext' returned to us by NDIS when it calls our
    // handlers to the address of our adapter control block.  Turn off
    // hardware oriented timeouts.
    //
   
    NdisMSetAttributesEx(
        MiniportAdapterHandle,
        (NDIS_HANDLE)pAdapter,
        (UINT)-1,
        NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT 
        | NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT,
        NdisInterfaceInternal);
    
    
    NdisZeroMemory(&Family, sizeof(Family));
    Family.MajorVersion     = NDIS_MajorVersion;
    Family.MinorVersion     = NDIS_MinorVersion;
    Family.AddressFamily    = CO_ADDRESS_FAMILY_TAPI_PROXY;

    NdisZeroMemory(&CallMgrChr, sizeof(CallMgrChr));
    CallMgrChr.MajorVersion                 = NDIS_MajorVersion;
    CallMgrChr.MinorVersion                 = NDIS_MinorVersion;
    CallMgrChr.CmCreateVcHandler            = RasIrCmCreateVc;
    CallMgrChr.CmDeleteVcHandler            = RasIrCmDeleteVc;
    CallMgrChr.CmOpenAfHandler              = RasIrCmOpenAf;
    CallMgrChr.CmCloseAfHandler             = RasIrCmCloseAf;
    CallMgrChr.CmRegisterSapHandler         = RasIrCmRegisterSap;
    CallMgrChr.CmDeregisterSapHandler       = RasIrCmDeregisterSap;
    CallMgrChr.CmMakeCallHandler            = RasIrCmMakeCall;
    CallMgrChr.CmCloseCallHandler           = RasIrCmCloseCall;
    CallMgrChr.CmIncomingCallCompleteHandler= RasIrCmIncomingCallComplete;
    CallMgrChr.CmActivateVcCompleteHandler  = RasIrCmActivateVcComplete;
    CallMgrChr.CmDeactivateVcCompleteHandler= RasIrCmDeactivateVcComplete;
    CallMgrChr.CmModifyCallQoSHandler       = RasIrCmModifyCallQoS;
    CallMgrChr.CmRequestHandler             = RasIrCmRequest;
    // no CmAddPartyHandler
    // no CmDropPartyHandler

    Status = NdisMCmRegisterAddressFamily(
                MiniportAdapterHandle, &Family, &CallMgrChr, 
                sizeof(CallMgrChr));

Done:

    if (Status != NDIS_STATUS_SUCCESS)
    {
        FreeAdapter(pAdapter);
        DEBUGMSG(DBG_ERROR, ("RASIR: NdisMCmRegisterFamily failed %X\n",
                   Status));
    }
    else
    {
        NdisInterlockedInsertTailList(&RasIrAdapterList,
                                      &pAdapter->Linkage,
                                      &RasIrSpinLock);
    }
    
    return Status;
}        

VOID
RasIrHalt(
    IN NDIS_HANDLE MiniportAdapterContext)
{
    PRASIR_ADAPTER  pAdapter = MiniportAdapterContext;
    
    GOODADAPTER(pAdapter);
    
    NdisAcquireSpinLock(&RasIrSpinLock); 

    RemoveEntryList(&pAdapter->Linkage);
    
    NdisReleaseSpinLock(&RasIrSpinLock);    
    
    DEBUGMSG(DBG_ERROR, ("RASIR: Halt!\n"));
    
    FreeAdapter(pAdapter);
    
    return;
}    

NDIS_STATUS
RasIrReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext)
{
    return NDIS_STATUS_NOT_RESETTABLE;
}        

NDIS_STATUS
RasIrCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters)
{
    return STATUS_SUCCESS;
}    


NDIS_STATUS
RasIrCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext)
{
    return STATUS_SUCCESS;
}

UINT
AddAsyncFraming(
    IN PUCHAR       pOutBuf,
    IN PNDIS_BUFFER pNdisBuf,
    IN ULONG        Accm)
{
    PUCHAR  pData;
    int     DataLen;
    USHORT  Fcs = 0xFFFF;
    PUCHAR  pBuf = pOutBuf;
    PUCHAR   pEndBuf = pOutBuf + ASYNC_BUF_SIZE;
    
    NdisQueryBufferSafe(pNdisBuf, &pData, &DataLen, NormalPagePriority);
    
    if (pData == NULL)
    {
        return 0;
    }    
    
    ASSERT(DataLen);

    *pBuf++ = AF_FLAG_CHAR;
    
    while (DataLen != 0)
    {
        int i;

        for (i = 0; i < DataLen; i++)
        {
            Fcs = CALC_FCS(Fcs, pData[i]);
            STUFF_BYTE(pBuf, pData[i], Accm); 
        }
        
        NdisGetNextBuffer(pNdisBuf, &pNdisBuf);
        
        if (pNdisBuf)
        {
            NdisQueryBufferSafe(pNdisBuf, &pData, &DataLen, NormalPagePriority);
            
            if (pData == NULL)
            {
                return 0;
            }    
        }
        else
        {
            break;
        }        
        
        if (pBuf > pEndBuf)
        {
            return 0;
        }
    }
    
    Fcs = ~(Fcs);
    
    STUFF_BYTE(pBuf, ((CHAR) (Fcs & 0xFF)), Accm);
    STUFF_BYTE(pBuf, ((CHAR) (Fcs >> 8)), Accm);
    
    *pBuf++ = AF_FLAG_CHAR;
    
    return (UINT)((UINT_PTR)pBuf - (UINT_PTR) pOutBuf);
}
    
VOID
RasIrCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets )
{
    PRASIR_VC       pVc = MiniportVcContext;
    UINT            i;
    PNDIS_BUFFER    pNdisBuf;
    UINT            PacketLen;
    NTSTATUS        Status = NDIS_STATUS_SUCCESS;
    BOOLEAN         VcDown = FALSE;
    PASYNC_BUFFER   pAsyncBuf;
    PMDL            pSendNdisBuf;
    
    GOODVC(pVc);             

    for (i = 0; i < NumberOfPackets; i++)
    {
        Status = NDIS_STATUS_SUCCESS;
        
        NdisQueryPacket(PacketArray[i], NULL, NULL, &pNdisBuf, &PacketLen);
        
        ASSERT(PacketLen <= IRDA_MAX_DATA_SIZE);
        
        *((PVOID *) &PacketArray[i]->MiniportReserved[0]) = NULL;        
        
        NdisAcquireSpinLock(&pVc->pAdapter->SpinLock);
        
        REFADD(&pVc->RefCnt, 'DNES');
        
        pVc->OutstandingSends += 1;
        
        if (!(pVc->Flags & VCF_IRDA_OPEN))
        {
            DEBUGMSG(DBG_ERROR, ("RASIR: Not sending on Vc %X, Irda is closed\n", pVc));
            Status = NDIS_STATUS_CLOSED;
        }    

        NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);
        
        if (Status == NDIS_STATUS_SUCCESS)
        {
            if (!pVc->AsyncFraming)
            {
                pSendNdisBuf = pNdisBuf;
            }
            else
            {
                pAsyncBuf = NdisAllocateFromNPagedLookasideList(
                                &pVc->pAdapter->AsyncBufLList);
                                            
                *((PVOID *) &PacketArray[i]->MiniportReserved[0]) = pAsyncBuf;
                        
                if (!pAsyncBuf)
                {
                    Status = NDIS_STATUS_RESOURCES;                
                }
                else
                {   
                    UINT FrameLen;
             
                    pAsyncBuf->pNdisBuf = NULL;

                    FrameLen = AddAsyncFraming(pAsyncBuf->Buf, pNdisBuf,
                                               pVc->LinkInfo.SendACCM);
                    if (!FrameLen)
                    {
                        DEBUGMSG(DBG_ERROR, ("RASIR: not sending, AsyncFraming failed\n"));
                        IrdaSendComplete(pVc, PacketArray[i], Status);            
                        continue;
                    }

                    NdisAllocateBuffer(&Status, &pAsyncBuf->pNdisBuf,
                                       pVc->TxBufferPool, pAsyncBuf->Buf, FrameLen);
                
                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                        pSendNdisBuf = pAsyncBuf->pNdisBuf;
                    }    
                    else
                    {
                        DEBUGMSG(DBG_ERROR, ("RASIR: NdisAllocateBuffer failed %X\n", Status));
                    }
                }
            }    
        }
        
        if (Status == NDIS_STATUS_SUCCESS)
        {
            IrdaSend(pVc->IrdaConnContext, pSendNdisBuf, PacketArray[i]);
        }  
        else
        {  
            IrdaSendComplete(pVc, PacketArray[i], Status);            
            continue;
        }
        
        DEBUGMSG(DBG_SEND, ("RASIR: IrdaSend %X len %d pending\n", 
                 PacketArray[i], PacketLen));
    }
}    

VOID
RasIrReceiveComplete(
    PRASIR_VC   pVc,
    PVOID       pRxBuf)
{
    if (pVc->AsyncFraming)
    {
        // Async frames where already completed in
        // ProcessAsyncRxPacket() so just return the
        // buffer owned by rasir to the BufList
        
        NdisFreeToNPagedLookasideList(
            &pVc->pAdapter->AsyncBufLList, 
            pRxBuf);    
    }
    else
    {
        IrdaReceiveComplete(pVc->IrdaConnContext, 
                            (PIRDA_RECVBUF) pRxBuf);    
    }
}        
    
VOID
RasIrReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET pNdisPacket)
{
    PVOID           pRxBuf;
    PRASIR_VC       pVc;
    PNDIS_BUFFER    pNdisBuf;
    
    pVc = *((PRASIR_VC *) &pNdisPacket->MiniportReserved[0]);
    pRxBuf = *((PVOID *) &pNdisPacket->MiniportReserved[sizeof(PUCHAR)]);
    
    
    GOODVC(pVc);
    
    DEBUGMSG(DBG_RECV, ("RASIR: ReturnPacket %X\n", pRxBuf));
    
    RasIrReceiveComplete(pVc, pRxBuf);
    
    NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuf);
    
    NdisFreeBuffer(pNdisBuf);

    NdisFreePacket(pNdisPacket);
    
    REFDEL(&pVc->RefCnt, 'VCER');    

    return;
}        

NDIS_STATUS
RasIrCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest)
{
    NDIS_STATUS         Status;
    PRASIR_ADAPTER      pAdapter = MiniportAdapterContext;
    PRASIR_VC           pVc = MiniportVcContext;
        
    DEBUGMSG(DBG_CONFIG, ("RASIR: RasIrCoRequest() type %X\n", 
             NdisRequest->RequestType));

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        {
            Status = QueryInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.QUERY_INFORMATION.Oid,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            Status = SetInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.SET_INFORMATION.Oid,
                NdisRequest->DATA.SET_INFORMATION.InformationBuffer,
                NdisRequest->DATA.SET_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.SET_INFORMATION.BytesRead,
                &NdisRequest->DATA.SET_INFORMATION.BytesNeeded );
            break;
        }

        default:
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
    }

    return Status;
}

NDIS_STATUS
QueryInformation(
    IN PRASIR_ADAPTER pAdapter,
    IN PRASIR_VC pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded)
{
    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;

    status = NDIS_STATUS_SUCCESS;

    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    DEBUGMSG(DBG_CONFIG, ("RASIR: QueryInformation oid:%X\n", Oid));

    switch (Oid)
    {
        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            DEBUGMSG(DBG_CONFIG, ("  OID_GET_MAXIMUM_LOOKAHEAD = %d\n",
                     IRDA_MAX_DATA_SIZE));
            ulInfo = IRDA_MAX_DATA_SIZE;
            break;
        }

        case OID_GEN_MAC_OPTIONS:
        {
            // Report a bitmask defining optional properties of the driver.
            //
            // NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA promises that our receive
            // buffer is not on a device-specific card.
            //
            // NDIS_MAC_OPTION_TRANSFERS_NOT_PEND promises we won't return
            // NDIS_STATUS_PENDING from our TransferData handler which is true
            // since we don't have one.
            //
            ulInfo = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA
                     | NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
            DEBUGMSG(DBG_CONFIG, ("  OID_GEN_MAC_OPTIONS = %d\n",ulInfo)); 
            break;
        }

        case OID_WAN_MEDIUM_SUBTYPE:
        {
            // Report the media subtype we support.  NDISWAN may use this in
            // the future (doesn't now) to provide framing differences for
            // different media.
            //
            DEBUGMSG(DBG_CONFIG, ("  OID_WAN_MEDIUM_SUBTYPE\n"));
            if (pAdapter->ModemPort)
            {
                ulInfo = NdisWanMediumSerial;
            }
            else
            {
                ulInfo = NdisWanMediumIrda;    
            }    
            break;
        }

        case OID_WAN_CO_GET_INFO:
        {
            // Report the capabilities of the adapter.
            //
            DEBUGMSG(DBG_CONFIG, ("  OID_WAN_CO_GET_INFO\n"));
            pInfo = &pAdapter->Info;
            ulInfoLen = sizeof(NDIS_WAN_CO_INFO);
            break;
        }

        case OID_WAN_CO_GET_LINK_INFO:
        {
            // Report the current state of the link.
            //
            DEBUGMSG(DBG_CONFIG, ("  OID_WAN_CO_GET_LINK_INFO\n"));

            if (!pVc)
                return NDIS_STATUS_INVALID_DATA;
                
            pInfo = &pVc->LinkInfo;

            ulInfoLen = sizeof(NDIS_WAN_CO_GET_LINK_INFO);
            break;
        }

            case OID_WAN_CO_GET_COMP_INFO:
        {
            // Report the type of compression we provide, which is none.
            //
            DEBUGMSG(DBG_CONFIG, ("  OID_WAN_CO_GET_COMP_INFO\n"));
                status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
                break;
        }

            case OID_WAN_CO_GET_STATS_INFO:
        {
            // Because L2TP doesn't do compression, NDISWAN will use it's own
            // statistics and not query ours.
            //
            ASSERT( !"OID_WAN_CO_GET_STATS_INFO?" );
                status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
                break;
        }

        case OID_PNP_QUERY_POWER:
            DEBUGMSG(DBG_CONFIG, ("  OID_PNP_QUERY_POWER\n"));
                status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;            
            break;

        case OID_PNP_CAPABILITIES:
            DEBUGMSG(DBG_CONFIG, ("  OID_PNP_CAP\n"));
                status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;

        case OID_PNP_SET_POWER:
            DEBUGMSG(DBG_CONFIG, ("  OID_PNP_SET_POWER\n"));        
                status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
            
        default:
        {
            DEBUGMSG(DBG_CONFIG, ( "  Oid $%08x?\n", Oid));
            status = NDIS_STATUS_INVALID_OID;
            ulInfoLen = 0;
            break;
        }
    }
    
    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    return status;
}    

NDIS_STATUS
SetInformation(
    IN PRASIR_ADAPTER pAdapter,
    IN PRASIR_VC pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded)
{
    NDIS_STATUS Status;
    
    DEBUGMSG(DBG_CONFIG, ("RASIR: SetInformation oid:%X\n", Oid));
    
    Status = NDIS_STATUS_SUCCESS;

    switch (Oid)
    {
        case OID_WAN_CO_SET_LINK_INFO:
        {
            // Read new link state settings.
            //
            DEBUGMSG(DBG_CONFIG, ("  OID_WAN_CO_SET_LINK_INFO\n"));

            if (InformationBufferLength < sizeof(NDIS_WAN_CO_SET_LINK_INFO))
            {
                Status = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
            }
            else
            {
                if (!pVc)
                    return NDIS_STATUS_INVALID_DATA;

                ASSERT( sizeof(pVc->LinkInfo)
                    == sizeof(NDIS_WAN_CO_SET_LINK_INFO) );

                NdisMoveMemory(&pVc->LinkInfo, InformationBuffer,
                               sizeof(pVc->LinkInfo) );
                               
                DEBUGMSG(DBG_CONFIG, ("  MaxSend %d MaxRecv %d SendAccm %X RecvAccm %X\n",
                         pVc->LinkInfo.MaxSendFrameSize,
                         pVc->LinkInfo.MaxRecvFrameSize,
                         pVc->LinkInfo.SendACCM,
                         pVc->LinkInfo.RecvACCM));
                                                        
                *BytesRead = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
            }
            *BytesNeeded = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
        }
        break;

        case OID_WAN_CO_SET_COMP_INFO:
        {
            // L2TP doesn't provide compression. Neither does IrDA
            //
            DEBUGMSG(DBG_CONFIG, ("  OID_WAN_CO_SET_COMP_INFO\n"));
                Status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;
                break;
        }
        
        case OID_PNP_QUERY_POWER:
            DEBUGMSG(DBG_CONFIG, ("  OID_PNP_QUERY_POWER\n"));
                Status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;            
            break;

        case OID_PNP_CAPABILITIES:
            DEBUGMSG(DBG_CONFIG, ("  OID_PNP_CAP\n"));
                Status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;                        
            break;

        case OID_PNP_SET_POWER:
            DEBUGMSG(DBG_CONFIG, ("  OID_PNP_SET_POWER\n"));
                Status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;                        
            break;

#if 0
        // These OIDs are mandatory according to current doc, but since
        // NDISWAN never requests them they are omitted.
        //
        case OID_GEN_CURRENT_PACKET_FILTER:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_PROTOCOL_OPTIONS:
        case OID_WAN_PROTOCOL_TYPE:
        case OID_WAN_HEADER_FORMAT:
#endif
        default:
        {
            DEBUGMSG(DBG_CONFIG, ("Oid $%08x?\n", Oid ));
            Status = NDIS_STATUS_INVALID_OID;
            *BytesRead = *BytesNeeded = 0;
            break;
        }
    }

    return Status;
}    

VOID
ProcessAsyncRxPacket(
    PRASIR_VC       pVc,
    PIRDA_RECVBUF   pIrdaRxBuf)
{
    PASYNC_BUFFER   pReturnRxBuf = NULL;
    BOOLEAN         EndOfFrame = FALSE;
    PASYNC_BUFFER   pCurrAsyncBuf;
    UINT            i;
    CHAR            Byte;

    //DbgMsgBuf(pIrdaRxBuf->Buf, pIrdaRxBuf->BufLen);
    
    for (i = 0; i < pIrdaRxBuf->BufLen; i++)
    {
        //
        // If we are not currently reasembling a frame 
        // in pCurrAsyncBuf then get a new one
        //
            
        if (pVc->pCurrAsyncBuf == NULL)
        {
            pVc->AsyncFramingState = RX_READY;
        
            if (!(pCurrAsyncBuf = NdisAllocateFromNPagedLookasideList(
                            &pVc->pAdapter->AsyncBufLList)))
            {
                DEBUGMSG(DBG_ERROR, ("RASIR: Failed to allocate AsyncBuf\n"));
                return;
            } 
                               
            pCurrAsyncBuf->BufLen = 0;        
            pVc->pCurrAsyncBuf = pCurrAsyncBuf;
        }
        else
        {
            pCurrAsyncBuf = pVc->pCurrAsyncBuf;
        }

        Byte = pIrdaRxBuf->Buf[i];

        switch (pVc->AsyncFramingState)
        {
            case RX_READY:
                
                if (Byte == AF_FLAG_CHAR)
                {
                    pVc->AsyncFramingState = RX_RX;
                }    
                break;
                
            case RX_RX:
                switch (Byte)
                { 
                    case AF_FLAG_CHAR:
                    
                        // We have a complete frame, put it on the completed
                        // list
                        
                        pVc->AsyncFramingState = RX_READY;    
                        
                        if (pCurrAsyncBuf->BufLen > 2)
                        {
                            // remove FCS, IrDA is reliable so I don't look at it
                            
                            pCurrAsyncBuf->BufLen -= 2;
                       
                            NdisInterlockedInsertTailList(
                                    &pVc->CompletedAsyncBufList,
                                    &pCurrAsyncBuf->Linkage,
                                    &pVc->pAdapter->SpinLock);
                            
                            DEBUGMSG(DBG_RECV, ("RASIR: Complete async frame %d, %d of %d\n",
                                     pVc->pCurrAsyncBuf->BufLen, i, pIrdaRxBuf->BufLen));
                                
                            pVc->pCurrAsyncBuf = NULL;
                                                        
                        }
                        else
                        {
                            // frame too small, we'll just ignore it
                            pCurrAsyncBuf->BufLen = 0;
                            
                            DEBUGMSG(DBG_ERROR, ("RASIR: Async failure 1\n"));
                        }
                        
                        break;
                    
                    case AF_ESC_CHAR:
                        pVc->AsyncFramingState = RX_ESC;
                        break;
                        
                    default:
                        if (pCurrAsyncBuf->BufLen >= ASYNC_BUF_SIZE)
                        {
                            pCurrAsyncBuf->BufLen = 0;
                            pVc->AsyncFramingState = RX_READY;
                            DEBUGMSG(DBG_ERROR, ("RASIR: Async buffer overflow\n"));

                        }
                        else
                        {
                            pCurrAsyncBuf->Buf[pCurrAsyncBuf->BufLen] = Byte;
                            pCurrAsyncBuf->BufLen += 1;    
                        }    
                }        
                        
                break;
                
            case RX_ESC:
                if (pCurrAsyncBuf->BufLen >= ASYNC_BUF_SIZE)
                {
                    pCurrAsyncBuf->BufLen = 0;
                    pVc->AsyncFramingState = RX_READY;
                    DEBUGMSG(DBG_ERROR, ("RASIR: Async failure 2\n"));                    
                }
                else
                {
                    pCurrAsyncBuf->Buf[pCurrAsyncBuf->BufLen] = (Byte ^= AF_COMP_BIT);
                    pCurrAsyncBuf->BufLen += 1;    
                    pVc->AsyncFramingState = RX_RX;
                    break;
                }    
        }
    }
}

VOID
IndicateReceive(
    PRASIR_VC       pVc,
    PIRDA_RECVBUF   pRecvBuf,
    PASYNC_BUFFER   pAsyncBuf,
    BOOLEAN         LastBuf)
{
    PNDIS_PACKET    pNdisPacket;
    PNDIS_BUFFER    pNdisBuf;
    NDIS_STATUS     Status;
    KIRQL           OldIrql;
    PVOID           pRecvOrAsyncBuf = NULL;
    int             Len;

    REFADD(&pVc->RefCnt, 'VCER');
    
    if (pVc->AsyncFraming)
    {
        ASSERT(pAsyncBuf && !pRecvBuf);
        pRecvOrAsyncBuf = pAsyncBuf;                   
        Len = pAsyncBuf->BufLen;                           
    }
    else
    {
        ASSERT(pRecvBuf && !pAsyncBuf);
        pRecvOrAsyncBuf = pRecvBuf;                   
        Len = pRecvBuf->BufLen;                           
    }    
        
    if (!(pVc->Flags & VCF_OPEN))
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: VC not open yet, dropping packet\n"));
        goto error1;
    }    
    NdisAllocatePacket(&Status, &pNdisPacket, pVc->RxPacketPool);
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: NdisAllocatePacket failed, %X\n",
                 Status));
        goto error1;
    }
    
    if (pVc->AsyncFraming)
    {
        NdisAllocateBuffer(&Status, &pNdisBuf, pVc->RxBufferPool,
                           pAsyncBuf->Buf, pAsyncBuf->BufLen);    
    }
    else
    {
        NdisAllocateBuffer(&Status, &pNdisBuf, pVc->RxBufferPool,
                           pRecvBuf->Buf, pRecvBuf->BufLen);
    }                       
                       
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: NdisAllocateBuffer failed, %X\n",
                  Status));
        goto error2;
    }
    
    NdisChainBufferAtFront(pNdisPacket, pNdisBuf);
    
    *((PRASIR_VC *) &pNdisPacket->MiniportReserved[0]) = pVc;
    *((PVOID *) &pNdisPacket->MiniportReserved[sizeof(PUCHAR)]) = pRecvOrAsyncBuf;

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    
    if (LastBuf)
    {
        NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_RESOURCES);
        
        DEBUGMSG(DBG_RECV, ("RASIR: Irtdi out of buffers\n"));
    }
    else
    {
        NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_SUCCESS);    
    }    

    Status = NDIS_GET_PACKET_STATUS(pNdisPacket);

    DEBUGMSG(DBG_RECV, ("RASIR: ->NdisMCoIndicateReceive %d\n", Len));
             
    NdisMCoIndicateReceivePacket(pVc->NdisVcHandle, &pNdisPacket, 1);

    NdisMCoReceiveComplete(pVc->pAdapter->MiniportAdapterHandle);

    KeLowerIrql(OldIrql);
    
    if (Status == NDIS_STATUS_SUCCESS) {
        //
        //  the packets will be returned later
        //
        return;
    }
    

    NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuf);
    
    NdisFreeBuffer(pNdisBuf);

error2:

    NdisFreePacket(pNdisPacket);

error1:
    
    DEBUGMSG(DBG_RECV, ("RASIR: RecvIndication completed synchronously for %X\n",
              pRecvOrAsyncBuf));
    
    RasIrReceiveComplete(pVc, pRecvOrAsyncBuf);
    
    REFDEL(&pVc->RefCnt, 'VCER');    

}    
    
VOID
IrdaReceiveIndication(
    PVOID           ConnectionContext,
    PIRDA_RECVBUF   pRecvBuf,
    BOOLEAN         LastBuf)
{
    PRASIR_VC       pVc = ConnectionContext;
    PASYNC_BUFFER   pAsyncRxBuf;

    
    DEBUGMSG(DBG_RECV, ("RASIR: IrdaReceiveIndication %X, %d bytes\n",
             pRecvBuf, pRecvBuf->BufLen));
    
    if (!pVc)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: IrdaReceiveIndication NULL vc\n"));
        ASSERT(0);
        return;
    }
                 
    GOODVC(pVc);
    
    GOODADAPTER(pVc->pAdapter);
    
    if (pVc->IrModemCall && pVc->ModemState < MS_ONLINE)
    {
        ProcessOfflineRxBuf(pVc, pRecvBuf);
        
        IrdaReceiveComplete(pVc->IrdaConnContext, pRecvBuf);
        
        return;
    }
        
    if (pVc->AsyncFraming)
    {
        ProcessAsyncRxPacket(pVc, pRecvBuf);
       
        // We are done with pRecvBuf. The async framing has 
        // been removed and the data is now contained in a buffer
        // on the CompletedAsyncBufList or if not a full frame
        // then in pCurrAsyncBuf
                    
        IrdaReceiveComplete(pVc->IrdaConnContext, pRecvBuf);                
        
        while ((pAsyncRxBuf = (PASYNC_BUFFER) NdisInterlockedRemoveHeadList(
                                    &pVc->CompletedAsyncBufList,
                                    &pVc->pAdapter->SpinLock)) != NULL)
        {
            IndicateReceive(pVc, NULL, pAsyncRxBuf, LastBuf);
        }                            
    }    
    else
    {
        IndicateReceive(pVc, pRecvBuf, NULL, LastBuf);
    }
    
    return;
}   

VOID
IrdaSendComplete(
    PVOID       ConnectContext,
    PVOID       SendContext,
    NTSTATUS    Status)
{
    PRASIR_VC       pVc = ConnectContext;
    PNDIS_PACKET    pNdisPacket = (PNDIS_PACKET) SendContext;
    
    DEBUGMSG(DBG_SEND, ("RASIR: IrdaSendComplete vc:%X, Packet %X\n", pVc, SendContext));
    
    GOODVC(pVc);

    if (SendContext == RASIR_INTERNAL_SEND)
    {
        ASSERT(pVc->pOfflineNdisBuf);
       
        NdisFreeBuffer(pVc->pOfflineNdisBuf);
        
        pVc->pOfflineNdisBuf = NULL;
        
        goto EXIT;
    }
    
    if (pVc->AsyncFraming)
    {
        PASYNC_BUFFER pAsyncBuf;
        
        pAsyncBuf = *((PASYNC_BUFFER *) &pNdisPacket->MiniportReserved[0]);         
                             
        if (pAsyncBuf)
        {            
            if (pAsyncBuf->pNdisBuf)
            {
                NdisFreeBuffer(pAsyncBuf->pNdisBuf);
            }
            
            NdisFreeToNPagedLookasideList(&pVc->pAdapter->AsyncBufLList, 
                                          pAsyncBuf);
        }    
    }
    
    NdisMCoSendComplete(Status, pVc->NdisVcHandle, pNdisPacket);

    NdisAcquireSpinLock(&pVc->pAdapter->SpinLock);
    
    pVc->OutstandingSends -= 1; // do interlockedDec dork

    NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);
    
    if ((pVc->Flags & VCF_CLOSE_PEND) && (pVc->OutstandingSends == 0))
    {
        DEBUGMSG(DBG_CONNECT, ("RASIR: Outstanding send to 0, CompleteClose\n"));    
        CompleteClose(pVc);
    }    

EXIT:
    
    REFDEL(&pVc->RefCnt, 'DNES');        
}    

NDIS_STATUS
ScheduleWork(
    IN PRASIR_ADAPTER pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext )

    // Schedules a PASSIVE IRQL callback to routine 'pProc' which will be
    // passed 'pContext'.  'PAdapter' is the adapter control block from which
    // the work item is allocated.
    //
    // Returns NDIS_STATUS_SUCCESS or an error code.
    //
{
    NDIS_STATUS status;
    NDIS_WORK_ITEM* pWork;

    pWork = NdisAllocateFromNPagedLookasideList(&pAdapter->WorkItemsLList);

    if (!pWork)
    {
        ASSERT( !"Alloc work?" );
        return NDIS_STATUS_RESOURCES;
    }

    NdisInitializeWorkItem( pWork, pProc, pContext );

    status = NdisScheduleWorkItem( pWork );
    if (status != NDIS_STATUS_SUCCESS)
    {
        ASSERT( !"SchedWork?" );
        NdisFreeToNPagedLookasideList(&pAdapter->WorkItemsLList, pWork);
    }

    return status;
}


#if DBG

NTSTATUS
DbgDispatch(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp)
{
    PIO_STACK_LOCATION  pIrpSp;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    
    if (pIrpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL)
    {
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
        return STATUS_SUCCESS;
    }    
        
    ASSERT(pIrpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL);

    switch(pIrpSp->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_IRDA_GET_DBG_MSGS:
        {
            NTSTATUS Status;
            
            if ((Status = DbgMsgIrp(pIrp, pIrpSp)) == STATUS_PENDING)
            {
                return STATUS_PENDING;
            }
            break;
        }    
        case IOCTL_IRDA_GET_DBG_SETTINGS:
        {
            UINT    *Settings = pIrp->AssociatedIrp.SystemBuffer;
            
            Settings[0] = DbgSettings;
            Settings[1] = DbgOutput;
            
            pIrp->IoStatus.Information = sizeof(UINT)*2;
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }    
        
        case IOCTL_IRDA_SET_DBG_SETTINGS:
        {
            UINT    *Settings = pIrp->AssociatedIrp.SystemBuffer;
            
            DbgSettings = Settings[0];
            DbgOutput = Settings[1];
            
            pIrp->IoStatus.Information = 0;
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }
        
        default:
            pIrp->IoStatus.Information = 0;
            pIrp->IoStatus.Status = STATUS_SUCCESS;        
    }

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return STATUS_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\blaster\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by irsock.rc
//
#define IDD_DIALOG1                     101
#define IDC_LISTEN                      1000
#define IDC_DISCOVER                    1001
#define IDC_CONNECT                     1002
#define IDC_COMBO1                      1005
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\kdext\irdakdx.c ===
#define SRVDBG 1
#define SRVKD 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windows.h>
#include <ntosp.h>
#include <wdbgexts.h>

#define NT
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>

#include <irda.h>
#include <irlmp.h>
#include <irlmpp.h>
#include <irdap.h>
#include <dbgmsg.h>
#include <irioctl.h>
#include <irlap.h>
#include <irlapp.h>

/*
#define DBG_NDIS        0x00000002 // keep in sync with test\irdakdx
#define DBG_TIMER       0x00000004
#define DBG_IRMAC       0x00000008

#define DBG_IRLAP       0x00000010
#define DBG_IRLAPLOG    0x00000020
#define DBG_RXFRAME     0x00000040
#define DBG_TXFRAME     0x00000080

#define DBG_IRLMP       0x00000100
#define DBG_IRLMP_CONN  0x00000200
#define DBG_IRLMP_CRED  0x00000400
#define DBG_IRLMP_IAS   0x00000800

#define DBG_DISCOVERY   0x00001000
#define DBG_PRINT       0x00002000
#define DBG_ADDR        0x00004000

#define DBG_REF         0x00010000

#define DBG_TDI         0x00020000
#define DBG_TDI_IRP     0x00040000

#define DBG_ALLOC       0x10000000
#define DBG_FUNCTION    0x20000000
#define DBG_WARN        0x40000000
#define DBG_ERROR       0x80000000
*/

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


typedef struct
{
    char    Name[16];
    int     Val;
} DBG_LEVEL;
#if 0
DBG_LEVEL DbgLevel[] = {
    {"RXFRAME",  DBG_RXFRAME     },
    {"TXFRAME",  DBG_TXFRAME     },
    {"NDIS",  DBG_NDIS        },
    {"IRMAC",  DBG_IRMAC       },
    {"IRLAP",  DBG_IRLAP       },
    {"IRLAPLOG",  DBG_IRLAPLOG    },
    {"IRLMP",  DBG_IRLMP       },
    {"IRLMP_CONN",  DBG_IRLMP_CONN  },
    {"IRLMP_CRED",  DBG_IRLMP_CRED  },
    {"IRLMP_IAS",  DBG_IRLMP_IAS   },
    {"DISCOVERY",  DBG_DISCOVERY   },
    {"TDI",  DBG_TDI         },
    {"TDI_IRP",  DBG_TDI_IRP     },
    {"ALLOC",  DBG_ALLOC       },
    {"TIMER ",  DBG_TIMER       },
    {"PRINT",  DBG_PRINT       },
    {"ADDRESS",  DBG_ADDR        },
    {"REFERENCE",  DBG_REF         },        
    {"FUNCTION",  DBG_FUNCTION    },
    {"WARN",  DBG_WARN        },
    {"ERROR",  DBG_ERROR       }};
#endif
char *IrlmpState[] =
    {"LINK_DOWN",
     "LINK_DISCONNECTED",
     "LINK_DISCONNECTING",
     "LINK_IN_DISCOVERY",
     "LINK_CONNECTING",
     "LINK_READY"};
     
char *LsapState[] =
    {"LSAP_CREATED",
     "LSAP_DISCONNECTED",          
     "LSAP_IRLAP_CONN_PEND", 
     "LSAP_LMCONN_CONF_PEND",
     "LSAP_CONN_RESP_PEND",  
     "LSAP_CONN_REQ_PEND",   
     "LSAP_EXCLUSIVEMODE_PEND",  
     "LSAP_MULTIPLEXEDMODE_PEND",
     "LSAP_READY",               
     "LSAP_NO_TX_CREDIT"};

char *ConnObjState[] =     
    {"IRDA_CONN_CREATED",
     "IRDA_CONN_CLOSING",
     "IRDA_CONN_OPENING", 
     "IRDA_CONN_OPEN"};
     
char *IrlapState[] = 
{  "NDM", 
   "DSCV_MEDIA_SENSE", 
   "DSCV_QUERY", 
   "DSCV_REPLY",
   "CONN_MEDIA_SENSE",
   "SNRM_SENT",
   "BACKOFF_WAIT",
   "SNRM_RECEIVED",
   "P_XMIT",
   "P_RECV",
   "P_DISCONNECT_PEND",
   "P_CLOSE",
   "S_NRM",
   "S_DISCONNECT_PEND",
   "S_ERROR",
   "S_CLOSE"};
     
     

/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
PrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory((ULONG_PTR) pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
GetData( IN LPVOID ptr, IN DWORD_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while( size > 0 ) {

    if (count >= 3000)
        count = 3000;

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN DWORD dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !GetData( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (DWORD_PTR)ListEntry.Flink == dwListHeadAddr || (DWORD_PTR)ListEntry.Flink == 0 )
            break;

        if( !GetData( &ListEntry, (DWORD_PTR)ListEntry.Flink, (ULONG)sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (DWORD_PTR)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (DWORD_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}



/*
 * Print out a single HEX character
 */
VOID
PrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
PrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        dprintf( " " );
    }
}


/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN DWORD_PTR dwAddress, IN LPSTR buf, IN ULONG MaxChars )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}

char *mystrtok ( char *string, char * control )
{
    static unsigned char *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

DECLARE_API( help )
{
    int i;

    dprintf("IrDA extenstions:\n");

    dprintf("   dbgmsgs                     dump debug message buffer\n");
    dprintf("   dbg [Level [Level] ...]     toggle debug level\n");
}

DECLARE_API( dbgmsgs )
{
    DWORD   p;
    DWORD   Last, First;
    char    DbgMsg[MAX_MSG_LEN];
    ULONG   Read;
    char    *DbgMsgs;
    
    if (!GetData(&Last,
                 GetExpression("irda!Last"),
                 sizeof(Last), "DWORD"))
    {
        dprintf("error\n");
        return;
    }                 


    if (!GetData(&First,
                 GetExpression("irda!First"),
                 sizeof(Last), "DWORD"))
    {
        dprintf("error\n");
        return;
    }                 

                 

    DbgMsgs = (char *) GetExpression("irda!dbgmsgs");

    dprintf("\n\n");
    
    while (First != Last)
    {
       if (!GetString((DWORD_PTR) (DbgMsgs + First * MAX_MSG_LEN),
                  DbgMsg, MAX_MSG_LEN))
            break;
        /*
        ReadMemory((ULONG) (DbgMsgs + First * MAX_MSG_LEN), 
                    DbgMsg, MAX_MSG_LEN, &Read); */
        dprintf("%s", DbgMsg);
        First++;
        if (First == DBG_MSG_CNT)
            First = 0;
    }
}

DECLARE_API( dbg )
{
#if 0
    int i;
    int col = 0;
    DWORD DbgSettings;
    char argbuf[ MAX_PATH ];
    char *p;
    DWORD_PTR   dwAddress;
    DWORD   Written;
    
    dwAddress = GetExpression("irda!dbgsettings");
    
    if (!GetData(&DbgSettings,
                 dwAddress,
                 sizeof(DbgSettings), "DWORD"))
    {
        dprintf("error\n");
        return;
    }
        
    if (!args || !*args)
    {    
    
        dprintf("Current settings:\n");
    
        for (i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if (DbgSettings & DbgLevel[i].Val)
            {
                dprintf("  %s", DbgLevel[i].Name);
                if (col == 4)
                {
                    col = 0;
                    dprintf("\n");
                }
                else
                {
                    col ++;
                }
            }
        }
        if (col != 0)
            dprintf("\n");
        
        col = 0;    
    
        dprintf("Available settings:\n");
        for (i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if (!(DbgSettings & DbgLevel[i].Val))
            {
                dprintf("  %s", DbgLevel[i].Name);
        
                if (col == 4)
                {
                    col = 0;
                    dprintf("\n");
                }
                else
                {
                    col++;
                }
            }    
        }
    
        if (col != 0)
            dprintf("\n");    
            
        return;
    }        
    
    strcpy( argbuf, args );
    
    for (p = mystrtok( argbuf, " \t,;" ); 
         p && *p; 
         p = mystrtok(NULL, " \t,;")) 
    {
        for (i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if (strcmp(p, DbgLevel[i].Name) == 0)
            {
                if (DbgSettings & DbgLevel[i].Val)
                {
                    DbgSettings &= ~DbgLevel[i].Val;
                }
                else
                {
                    DbgSettings |= DbgLevel[i].Val;                
                }
            }
        }       
    }
    
    WriteMemory(dwAddress, &DbgSettings, sizeof(DWORD), &Written);
#endif
}

DECLARE_API( link )
{
    LIST_ENTRY      IrdaLinkCbListEntry, *pIrdaLinkCbListEntry;
    PIRDA_LINK_CB   pIrdaLinkCb;
    IRDA_LINK_CB    IrdaLinkCb;
    LIST_ENTRY      *pListEntry, ListEntry, *pListHead;
    

    pIrdaLinkCbListEntry = (LIST_ENTRY *) GetExpression("irda!IrdaLinkCbList");

    if (!GetData(&IrdaLinkCbListEntry,
                 (DWORD_PTR) pIrdaLinkCbListEntry,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
    {
        return;
    }

    for (pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbListEntry.Flink;
         (LIST_ENTRY *) pIrdaLinkCb != pIrdaLinkCbListEntry;
         pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCb.Linkage.Flink)
    {
        if (!GetData(&IrdaLinkCb,
                     (DWORD_PTR) pIrdaLinkCb,
                     sizeof(IRDA_LINK_CB), "IRDA_LINK_CB"))
        {
            return;
        }
        
        dprintf("IrdaLinkCb:%X, Irlap:%X, Irlmp:%X NdisBindingHandle:%X\n", pIrdaLinkCb, 
                IrdaLinkCb.IrlapContext, IrdaLinkCb.IrlmpContext,
                IrdaLinkCb.NdisBindingHandle);
                
        dprintf("  MinTat:%d, WaitMinTat:%d, SendOutCnt %d\n",
                IrdaLinkCb.MinTat, IrdaLinkCb.WaitMinTat, IrdaLinkCb.SendOutCnt);            
#if DBG                
        dprintf("  DelayedRxFrameCnt %d\n", IrdaLinkCb.DelayedRxFrameCnt);
#endif                
        pListHead = (PLIST_ENTRY) ((char *) pIrdaLinkCb + 
                        FIELD_OFFSET(IRDA_LINK_CB, TxMsgFreeList));
                        
        dprintf("TxMsgFreeList:%X len %d\n", pListHead,
                IrdaLinkCb.TxMsgFreeListLen);
                
        for (pListEntry = IrdaLinkCb.TxMsgFreeList.Flink;
             pListEntry != pListHead;
             pListEntry = ListEntry.Flink)
        {
            if (!GetData(&ListEntry,
                         (DWORD_PTR) pListEntry,
                        sizeof(LIST_ENTRY),
                        "LIST_ENTRY"))
            {
                return;
            }
            
            dprintf("  %X\n", pListEntry);                
        
        }             
        
        pListHead = (PLIST_ENTRY) ((char *) pIrdaLinkCb + 
                        FIELD_OFFSET(IRDA_LINK_CB, RxMsgFreeList));
        
        dprintf("RxMsgFreeList:%X len %d\n", pListHead,
                IrdaLinkCb.RxMsgFreeListLen);
                
        for (pListEntry = IrdaLinkCb.RxMsgFreeList.Flink;
             pListEntry != pListHead;
             pListEntry = ListEntry.Flink)
        {
            if (!GetData(&ListEntry,
                         (DWORD_PTR) pListEntry,
                        sizeof(LIST_ENTRY),
                        "LIST_ENTRY"))
            {
                return;
            }
            
            dprintf("  %X\n", pListEntry);                
        
        }             

        pListHead = (PLIST_ENTRY) ((char *) pIrdaLinkCb + 
                        FIELD_OFFSET(IRDA_LINK_CB, RxMsgList));

        dprintf("RxMsgList:%Xd\n", pListHead);
                
        for (pListEntry = IrdaLinkCb.RxMsgList.Flink;
             pListEntry != pListHead;
             pListEntry = ListEntry.Flink)
        {
            if (!GetData(&ListEntry,
                         (DWORD_PTR) pListEntry,
                        sizeof(LIST_ENTRY),
                        "LIST_ENTRY"))
            {
                return;
            }
            
            dprintf("  %X\n", pListEntry);                
        
        }             
        
    }
}

DECLARE_API( irlmp )
{
    LIST_ENTRY      IrdaLinkCbListEntry, *pIrdaLinkCbListEntry;
    PIRDA_LINK_CB   pIrdaLinkCb;
    IRDA_LINK_CB    IrdaLinkCb;
    IRLMP_LINK_CB   IrlmpLinkCb;
    PIRLMP_LSAP_CB  pLsapCb;
    IRLMP_LSAP_CB   LsapCb;
    IRDA_MSG        *pMsg, IMsg;
    
    pIrdaLinkCbListEntry = (LIST_ENTRY *) GetExpression("irda!IrdaLinkCbList");

    if (!GetData(&IrdaLinkCbListEntry,
                 (DWORD_PTR) pIrdaLinkCbListEntry,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
    {
        return;
    }

    for (pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbListEntry.Flink;
         (LIST_ENTRY *) pIrdaLinkCb != pIrdaLinkCbListEntry;
         pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCb.Linkage.Flink)
    {

        if (!GetData(&IrdaLinkCb,
                     (DWORD_PTR) pIrdaLinkCb,
                     sizeof(IRDA_LINK_CB), "IRDA_LINK_CB"))
        {
            return;
        }

        if (!GetData(&IrlmpLinkCb,
                     (DWORD_PTR) IrdaLinkCb.IrlmpContext,
                     sizeof(IRLMP_LINK_CB), "IRLMP_LINK_CB"))
        {
            return;
        }        
        

        dprintf("IrlmpLinkCb %x, State:%s, MaxSlot:%d, MaxPdu:%d, WindowSize:%d\n", 
                IrdaLinkCb.IrlmpContext, 
                IrlmpState[IrlmpLinkCb.LinkState],
                IrlmpLinkCb.MaxSlot, IrlmpLinkCb.MaxPDUSize,
                IrlmpLinkCb.WindowSize);
                
        dprintf("  Exclusive LsapCb:%x\n", IrlmpLinkCb.pExclLsapCb);
        
        for (pLsapCb = (PIRLMP_LSAP_CB) IrlmpLinkCb.LsapCbList.Flink;
             pLsapCb != (PIRLMP_LSAP_CB) ((char *)IrdaLinkCb.IrlmpContext + FIELD_OFFSET(IRLMP_LINK_CB, LsapCbList));
             pLsapCb = (PIRLMP_LSAP_CB) LsapCb.Linkage.Flink)
        {     
       
            if (!GetData(&LsapCb,
                     (DWORD_PTR) pLsapCb,
                     sizeof(IRLMP_LSAP_CB), "IRLMP_LSAP_CB"))
            {
                return;
            }
            
            dprintf("  LsapCb:%x State:%s LocalLsapSel:%d RemoteLsapSel:%d\n",
                    pLsapCb, LsapState[LsapCb.State],
                    LsapCb.LocalLsapSel, LsapCb.RemoteLsapSel);
            dprintf("    TdiContext:%x AvailCredit:%d LocalCredit:%d RemoteCredit:%d, RefCnt:%d\n",
                    LsapCb.TdiContext, LsapCb.AvailableCredit,
                    LsapCb.LocalTxCredit,
                    LsapCb.RemoteTxCredit,
                    LsapCb.RefCnt.Count);
                    
            dprintf("    TxMsgList:%x\n", LsapCb.TxMsgList);
           
            for (pMsg = (IRDA_MSG *) LsapCb.TxMsgList.Flink;
                 pMsg != (IRDA_MSG *) ((char *) pLsapCb + FIELD_OFFSET(IRLMP_LSAP_CB, TxMsgList));
                 pMsg = (IRDA_MSG *) IMsg.Linkage.Flink)
            {
                if (!GetData(&IMsg,
                     (DWORD_PTR) pMsg,
                     sizeof(IRDA_MSG), "IRDA_MSG"))
                {
                    dprintf("error\n");
                }
                dprintf("      Msg:%x\n", pMsg);            
            }     
            
            dprintf("    SegTxMsgList:%x\n", LsapCb.TxMsgList);
            
            for (pMsg = (IRDA_MSG *) LsapCb.SegTxMsgList.Flink;
                 pMsg != (IRDA_MSG *) ((char *) pLsapCb + FIELD_OFFSET(IRLMP_LSAP_CB, SegTxMsgList));
                 pMsg = (IRDA_MSG *) IMsg.Linkage.Flink)
            {
                if (!GetData(&IMsg,
                     (DWORD_PTR) pMsg,
                     sizeof(IRDA_MSG), "IRDA_MSG"))
                {
                    return;
                }
                dprintf("      Msg:%x\n", pMsg);            
            }     
            
        }
    }         

}

DECLARE_API( irlap )
{
    LIST_ENTRY      IrdaLinkCbListEntry, *pIrdaLinkCbListEntry;
    IRDA_LINK_CB    IrdaLinkCb, *pIrdaLinkCb;
    IRLAP_CB        IrlapCb;
    int             i;

    pIrdaLinkCbListEntry = (LIST_ENTRY *) GetExpression("irda!IrdaLinkCbList");

    if (!GetData(&IrdaLinkCbListEntry,
                 (DWORD_PTR) pIrdaLinkCbListEntry,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
    {
        return;
    }

    for (pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbListEntry.Flink;
         (LIST_ENTRY *) pIrdaLinkCb != pIrdaLinkCbListEntry;
         pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCb.Linkage.Flink)
    {

        if (!GetData(&IrdaLinkCb,
                     (DWORD_PTR) pIrdaLinkCb,
                     sizeof(IRDA_LINK_CB), "IRDA_LINK_CB"))
        {
            return;
        }

        if (!GetData(&IrlapCb,
                     (DWORD_PTR) IrdaLinkCb.IrlapContext,
                     sizeof(IRLAP_CB), "IRLAP_CB"))
        {
            return;
        }
        
        dprintf("\nIrlapCb:%X State:%s Vs:%d Vr:%d FTimerExpCnt:%d RetranCnt:%d\n",
                IrdaLinkCb.IrlapContext, 
                IrlapState[IrlapCb.State],
                IrlapCb.Vs, IrlapCb.Vr, IrlapCb.FTimerExpCnt, IrlapCb.RetranCnt);
                
        #if DBG
        dprintf("DelayedConfirms:%d\n", IrlapCb.DelayedConf);
        #endif                
                
        dprintf("  TxMsgList:%X\n",
                *(DWORD*)&IrlapCb.TxMsgList);        
                
        dprintf("  RxWin start:%d end:%d pMsgs:\n", 
                    IrlapCb.RxWin.Start,
                    IrlapCb.RxWin.End);
                    
        for (i = 0; i < IRLAP_MOD; i++)
        {
            dprintf("    %d. %X\n", i, IrlapCb.RxWin.pMsg[i]);
        }            
        
        dprintf("TxWin start:%d end:%d pMsgs:\n", 
                    IrlapCb.TxWin.Start,
                    IrlapCb.TxWin.End);
        for (i = 0; i < IRLAP_MOD; i++)
        {
            dprintf("    %d. %X\n", i, IrlapCb.TxWin.pMsg[i]);
            
        }            
                        
    }
}


VOID
DumpIrpList(LIST_ENTRY *pIrpList)
{
    LIST_ENTRY          IrpList, *pListEntry, ListEntry;
    IRP                 *pIrp;

    if (!GetData(&IrpList,
                 (DWORD_PTR) pIrpList,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
    {
        return;
    }
    
    for (pListEntry = IrpList.Flink;
         pListEntry != pIrpList;
         pListEntry = ListEntry.Flink)
    {
    
        if (!GetData(&ListEntry,
                 (DWORD_PTR) pListEntry,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
        {
            return;
        }
        
        pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
        
        dprintf("  %x\n", pIrp);
    }     
}

DECLARE_API( tdi )
{
    PIRDA_CONN_OBJ      pConnObjList, pConnObj;
    PIRDA_ADDR_OBJ      pAddrObjList, pAddrObj;
    IRDA_ADDR_OBJ       AddrObj;
    IRDA_CONN_OBJ       ConnObj;
    int                 i;

    pAddrObjList = (PIRDA_ADDR_OBJ) GetExpression("irda!AddrObjList");

    if (!GetData(&pAddrObj,
                 (DWORD_PTR) pAddrObjList,
                 sizeof(PIRDA_ADDR_OBJ), "IRDA_ADDR_OBJ_LIST"))
    {
        return;
    }
    
    if (pAddrObj == NULL)
    {
        dprintf("No address objects\n");
        return;
    }    
    
    while (pAddrObj)
    {
        if (!GetData(&AddrObj,
                 (DWORD_PTR) pAddrObj,
                 sizeof(IRDA_ADDR_OBJ), "IRDA_ADDR_OBJ"))
        {
            return;
        }
        
        dprintf("AddrObj:%x Server:%s LocalLsapSel:%d Service:%s\n", pAddrObj, 
            AddrObj.IsServer ? "TRUE":"FALSE", AddrObj.LocalLsapSel,
            AddrObj.LocalAddr.irdaServiceName);
        

        pConnObj = AddrObj.ConnObjList;
    
        if (pConnObj == NULL)
        {
            dprintf("  No connect objects\n");
        }    

        while (pConnObj)
        {
            IRDA_RECV_BUF   *pRecvBuf, RecvBuf;
            
            if (!GetData(&ConnObj,
                     (DWORD_PTR) pConnObj,
                 sizeof(IRDA_CONN_OBJ), "IRDA_CONN_OBJ"))
            {
                return;
            }
            
            dprintf("  ConnObj:%x State:%s Irlmp:%X TtpCreditsLeft:%d RecvBusy:%s\n", 
                pConnObj, 
                ConnObjState[ConnObj.ConnState],
                ConnObj.IrlmpContext,
                ConnObj.TtpRecvCreditsLeft,
                ConnObj.RecvBusy ? "TRUE":"FALSE");
                
            dprintf("    LocalLsapSel:%d Addr:\"%s\" RemoteLsapSel:%d Addr:\"%s\"\n",
                    ConnObj.LocalLsapSel, ConnObj.LocalAddr.irdaServiceName,
                    ConnObj.RemoteLsapSel, ConnObj.RemoteAddr.irdaServiceName);    
/*
            i = 0;
            for (pRecvBuf = (PIRDA_RECV_BUF) ConnObj.RecvBufList.Flink;
                 pRecvBuf != (PIRDA_RECV_BUF) ((char *) pConnObj + FIELD_OFFSET(IRDA_CONN_OBJ, RecvBufList));
                 pRecvBuf = (PIRDA_RECV_BUF) RecvBuf.Linkage.Flink)
            {
                i++;
                if (!GetData(&RecvBuf,
                     (DWORD_PTR) pRecvBuf,
                     sizeof(IRDA_RECV_BUF)-IRDA_MAX_DATA_SIZE,
                      "IRDA_RECV_BUF"))
                {
                    break;
                }
                
                dprintf("    RecvBuf:%x Len:%d Offset:%d\n",
                        pRecvBuf, RecvBuf.Len, RecvBuf.Offset);   
                        
                if (i > 100)
                {
                    dprintf("      !!! Infinite loop ???\n");
                    break;
                }        
            } 
*/             
            dprintf("    SendIrpList:\n");
            DumpIrpList((LIST_ENTRY *) ((char *) pConnObj + FIELD_OFFSET(IRDA_CONN_OBJ, SendIrpList)));
            
            dprintf("    RecvIrpList:\n");
            DumpIrpList((LIST_ENTRY *) ((char *) pConnObj + FIELD_OFFSET(IRDA_CONN_OBJ, RecvIrpList)));            
            
            pConnObj = ConnObj.pNext;                
        }
            
        pAddrObj = AddrObj.pNext;    
    }
    
    dprintf("IasIrp %x\n", GetExpression("irda!pIasIrp"));
    dprintf("DscvIrpList:\n");
    DumpIrpList((LIST_ENTRY *) GetExpression("irda!DscvIrpList"));    
    
    dprintf("IasIrpList:\n");
    DumpIrpList((LIST_ENTRY *) GetExpression("irda!IasIrpList"));    

    dprintf("ConnIrpList:\n");
    DumpIrpList((LIST_ENTRY *) GetExpression("irda!ConnIrpList"));        
}
        
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s SMB Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\blaster\blaster.c ===
//#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shellapi.h>
#include <winsock.h>
#include <af_irda.h>
#include <resource.h>
#include <resrc1.h>

#define DEVICE_LIST_LEN     5
#define WSBUF_SIZE          128

#define RXBUF_SIZE          2045*8 // max pdu * max window + 1
#define DEF_SENDBUF_SIZE    2045*7 // max pdu * max window
#define DEF_SENDCNT         100

int             TotalRecvBytes;
HWND            vhWnd;
PDEVICELIST     pDevList;
BYTE            DevListBuff[sizeof(DEVICELIST) - sizeof(IRDA_DEVICE_INFO) +
                            (sizeof(IRDA_DEVICE_INFO) * DEVICE_LIST_LEN)];

TCHAR *
GetLastErrorText();

void
StatusMsg(TCHAR *pFormat, ...)
{
    TCHAR   Buf[128];
    
    va_list ArgList;
    
    va_start(ArgList, pFormat);

    wvsprintf(Buf, pFormat, ArgList);

    SendMessage(GetDlgItem(vhWnd, IDC_STATUS), EM_REPLACESEL, 0,
                        (LPARAM) Buf);

    va_end(ArgList);
}



void
RecvThread(PVOID Arg)
{
    SOCKADDR_IRDA   ServSockAddr  = { AF_IRDA, 0, 0, 0, 0, "Blaster" };
    SOCKADDR_IRDA   PeerSockAddr;
    SOCKET          NewSock, Sock;
    int             sizeofSockAddr = sizeof(SOCKADDR_IRDA);
    int             RecvSize;
    TCHAR           wsBuf[WSBUF_SIZE];
    char            *RecvBuf;
    int             BytesRecvd;

    
    StatusMsg(TEXT("socket(AF_IRDA)\r\n"));

    if ((Sock = socket(AF_IRDA, SOCK_STREAM, 0)) == INVALID_SOCKET)
    {
        StatusMsg(TEXT("   error: %s\r\n"), GetLastErrorText());
        return;
    }    
    else
        StatusMsg(TEXT("   socket created (%d).\r\n"), Sock);
    
    StatusMsg(TEXT("bind(%s)\r\n"), ServSockAddr.irdaServiceName);
    if (bind(Sock, (const struct sockaddr *) &ServSockAddr, 
             sizeof(SOCKADDR_IRDA)) == SOCKET_ERROR)
    {
        StatusMsg(TEXT("   error: %s\r\n"), GetLastErrorText());
        return;
    }
    StatusMsg(TEXT("   bind() succeeded\r\n"));
    
    StatusMsg(TEXT("listen()\r\n"));
    if (listen(Sock, 5) == SOCKET_ERROR)
    {
        StatusMsg(TEXT("   error: %s\r\n"), GetLastErrorText());
        return;
    }
    StatusMsg(TEXT("   listen() succeeded\r\n"));

    
    RecvBuf = LocalAlloc(0, RXBUF_SIZE);

    while(1)    
    {    
        StatusMsg(TEXT("accept() - waiting for connection...\r\n"));
    
        if ((NewSock = accept(Sock, (struct sockaddr *) &PeerSockAddr, 
               &sizeofSockAddr)) == INVALID_SOCKET)
        {
            StatusMsg(TEXT("   error: %s\r\n"), GetLastErrorText());
            return;
        }
    
        StatusMsg(TEXT("accept(), new connection\r\n"));

        TotalRecvBytes = 0;
        
        while(1)
        {
            if ((BytesRecvd = recv(NewSock, RecvBuf, RXBUF_SIZE, 0)) == 
                SOCKET_ERROR)
            {
                StatusMsg(TEXT("recv() failed\r\n"));
                return;
            }
            TotalRecvBytes += BytesRecvd;
        
            if (BytesRecvd == 0)
            {
                StatusMsg(TEXT("recv() = 0, connection closed\r\n"));
                break;
            }
        }           
        closesocket(NewSock);        
    }

    return;
}

void
SendThread(PVOID Arg)
{
    int             DevListLen = sizeof(DevListBuff);
    int             SendSize, SendCnt, i, Sent;
    TCHAR           wsBuf[WSBUF_SIZE];
    char            *pSendBuf;   
    SOCKET          Sock;    
    SOCKADDR_IRDA   DstAddrIR  = { AF_IRDA, 0, 0, 0, 0, "Blaster" };
    
    StatusMsg(TEXT("socket(AF_IRDA)\r\n"));

    if ((Sock = socket(AF_IRDA, SOCK_STREAM, 0)) == INVALID_SOCKET)
    {
        StatusMsg(TEXT("   error: %s\r\n"), GetLastErrorText());
        goto done;
    }    
    else
        StatusMsg(TEXT("   socket created (%d).\r\n"), Sock);
    

    StatusMsg(TEXT("getsockopt(IRLMP_ENUMDEVICES)\r\n"));
    
    if (getsockopt(Sock, SOL_IRLMP, IRLMP_ENUMDEVICES, 
                   (char *) pDevList, &DevListLen) == SOCKET_ERROR)
    {   
        StatusMsg(TEXT("   error: %s.\r\n"), GetLastErrorText());
        goto done;
    }
    StatusMsg(TEXT("%d device(s) found.\r\n"),
              pDevList->numDevice);
    
    if (pDevList->numDevice == 0)
    {
        StatusMsg(TEXT(" NO DEVICES FOUND\r\n"));
        goto done;
    }    

    memcpy(DstAddrIR.irdaDeviceID, 
           pDevList->Device[0].irdaDeviceID, 4);
    
#ifdef UNICODE        
            mbstowcs(wsBuf, pDevList->Device[0].irdaDeviceName, WSBUF_SIZE);
#else
            strcpy(wsBuf, pDevList->Device[0].irdaDeviceName);
#endif        
    
    StatusMsg(TEXT("connect() to %s...\r\n"), wsBuf);
    
    if (connect(Sock, (const struct sockaddr *) &DstAddrIR, 
                sizeof(SOCKADDR_IRDA)) == SOCKET_ERROR)
    {
        StatusMsg(TEXT("   connect() error: %s\r\n"), GetLastErrorText());
        goto done;
    }
    
    
    GetWindowText(GetDlgItem(vhWnd, IDC_SENDSIZE), wsBuf, WSBUF_SIZE);
    
    SendSize = atoi(wsBuf);
    
    GetWindowText(GetDlgItem(vhWnd, IDC_SENDCNT), wsBuf, WSBUF_SIZE);
    
    SendCnt = atoi(wsBuf);
    
    StatusMsg(TEXT("connected, sending %d\r\n"), SendCnt*SendSize);
        
    pSendBuf = LocalAlloc(0, SendSize);

    if (pSendBuf == NULL) {

        StatusMsg(TEXT("   Could not allocate buffer\r\n"));
        goto done;
    }

    for (i=0; i < SendSize; i++)
    {
        pSendBuf[i] = (char) i;
    }    

    for (i=0; i < SendCnt; i++)
    {
        Sent = send(Sock, pSendBuf, SendSize,0); 
            
        if (Sent == SOCKET_ERROR)
        {
            StatusMsg(TEXT("send() failed %s\r\n"), 
                        GetLastErrorText());
            break;        
        }
    }  
    
    StatusMsg(TEXT("done sending\r\n"));
    
    LocalFree(pSendBuf);
    closesocket(Sock);

done:

    EnableWindow(GetDlgItem(vhWnd, IDC_SEND), 1);
}


void
DisplayThread(PVOID Args)
{
    TCHAR PBuf[32];
    int     Last, Curr;
    int     cnt = 1;
       
    while(1)
    {
        Last = TotalRecvBytes;    
        Sleep(1000);
        Curr = TotalRecvBytes;
            
        wsprintf(PBuf, "%u", TotalRecvBytes);
        SetWindowText(GetDlgItem(vhWnd, IDC_RXCNT), PBuf);        
        
        wsprintf(PBuf, "%u", Curr-Last);
        SetWindowText(GetDlgItem(vhWnd, IDC_BYTESEC), PBuf);        
        
    }    
}

LRESULT CALLBACK
DialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    HANDLE  hThread;
    DWORD   ThreadId;
    
    switch (message)
    {
      case WM_INITDIALOG:
      {
        TCHAR pBuf[32];
          
        SetFocus(GetDlgItem(hDlg, IDC_SENDSIZE));                    
        vhWnd = hDlg;                    
    
        wsprintf(pBuf, "%d", DEF_SENDBUF_SIZE);
        SetWindowText(GetDlgItem(hDlg, IDC_SENDSIZE), pBuf);        

        wsprintf(pBuf, "%d", DEF_SENDCNT);
        SetWindowText(GetDlgItem(hDlg, IDC_SENDCNT), pBuf);        
        
        CloseHandle(CreateThread(NULL, 0,
                (LPTHREAD_START_ROUTINE) RecvThread, NULL, 0, &ThreadId));          
                                      
        CloseHandle(CreateThread(NULL, 0,
                 (LPTHREAD_START_ROUTINE) DisplayThread, NULL, 0, &ThreadId));                                    
        break;
      }  
      case WM_COMMAND:
        switch (LOWORD(wParam))
        {
          case IDC_SEND:
            EnableWindow(GetDlgItem(hDlg, IDC_SEND), 0);
            CloseHandle(CreateThread(NULL, 0,
                                     (LPTHREAD_START_ROUTINE) SendThread,
                                      NULL, 0, &ThreadId));
            break;
                          
          case IDCANCEL:
            DestroyWindow(hDlg);
            break;
        }
        break;
        
      case WM_DESTROY:
        PostQuitMessage(0);
        break;
    }
        
    return 0;
}
WinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPSTR pCmdLine,
     int nCmdShow)
{
    WSADATA     WSAData;
    WORD        WSAVerReq = MAKEWORD(1,1);
    MSG         msg;
    HWND        hWnd;
    
    if (WSAStartup(WSAVerReq, &WSAData) != 0)
    {
        return 1;
    }

    pDevList = (PDEVICELIST) DevListBuff;
    
    pDevList->numDevice = 0;
    hWnd = CreateDialog(hInstance,
                              MAKEINTRESOURCE( IDD_DIALOG1), NULL,
                              DialogProc);
    if (hWnd)
    {
        ShowWindow(hWnd, SW_SHOWNORMAL);
        UpdateWindow(hWnd);
    }
    else
    {
        return 1;
    }
    
    while( GetMessage( &msg, NULL, 0, 0) != FALSE ) 
	{
        if (hWnd == 0 || !IsDialogMessage(hWnd, &msg))
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }

    
    return 0;
}


TCHAR *
GetLastErrorText()
{
    switch (WSAGetLastError())
    {
      case WSAEINTR:
        return (TEXT("WSAEINTR"));
        break;

      case WSAEBADF:
        return(TEXT("WSAEBADF"));
        break;

      case WSAEACCES:
        return(TEXT("WSAEACCES"));
        break;

      case WSAEFAULT:
        return(TEXT("WSAEFAULT"));
        break;

      case WSAEINVAL:
        return(TEXT("WSAEINVAL"));
        break;
        
      case WSAEMFILE:
        return(TEXT("WSAEMFILE"));
        break;

      case WSAEWOULDBLOCK:
        return(TEXT("WSAEWOULDBLOCK"));
        break;

      case WSAEINPROGRESS:
        return(TEXT("WSAEINPROGRESS"));
        break;

      case WSAEALREADY:
        return(TEXT("WSAEALREADY"));
        break;

      case WSAENOTSOCK:
        return(TEXT("WSAENOTSOCK"));
        break;

      case WSAEDESTADDRREQ:
        return(TEXT("WSAEDESTADDRREQ"));
        break;

      case WSAEMSGSIZE:
        return(TEXT("WSAEMSGSIZE"));
        break;

      case WSAEPROTOTYPE:
        return(TEXT("WSAEPROTOTYPE"));
        break;

      case WSAENOPROTOOPT:
        return(TEXT("WSAENOPROTOOPT"));
        break;

      case WSAEPROTONOSUPPORT:
        return(TEXT("WSAEPROTONOSUPPORT"));
        break;

      case WSAESOCKTNOSUPPORT:
        return(TEXT("WSAESOCKTNOSUPPORT"));
        break;

      case WSAEOPNOTSUPP:
        return(TEXT("WSAEOPNOTSUPP"));
        break;

      case WSAEPFNOSUPPORT:
        return(TEXT("WSAEPFNOSUPPORT"));
        break;

      case WSAEAFNOSUPPORT:
        return(TEXT("WSAEAFNOSUPPORT"));
        break;

      case WSAEADDRINUSE:
        return(TEXT("WSAEADDRINUSE"));
        break;

      case WSAEADDRNOTAVAIL:
        return(TEXT("WSAEADDRNOTAVAIL"));
        break;

      case WSAENETDOWN:
        return(TEXT("WSAENETDOWN"));
        break;

      case WSAENETUNREACH:
        return(TEXT("WSAENETUNREACH"));
        break;

      case WSAENETRESET:
        return(TEXT("WSAENETRESET"));
        break;

      case WSAECONNABORTED:
        return(TEXT("WSAECONNABORTED"));
        break;

      case WSAECONNRESET:
        return(TEXT("WSAECONNRESET"));
        break;

      case WSAENOBUFS:
        return(TEXT("WSAENOBUFS"));
        break;

      case WSAEISCONN:
        return(TEXT("WSAEISCONN"));
        break;

      case WSAENOTCONN:
        return(TEXT("WSAENOTCONN"));
        break;

      case WSAESHUTDOWN:
        return(TEXT("WSAESHUTDOWN"));
        break;

      case WSAETOOMANYREFS:
        return(TEXT("WSAETOOMANYREFS"));
        break;

      case WSAETIMEDOUT:
        return(TEXT("WSAETIMEDOUT"));
        break;

      case WSAECONNREFUSED:
        return(TEXT("WSAECONNREFUSED"));
        break;

      case WSAELOOP:
        return(TEXT("WSAELOOP"));
        break;

      case WSAENAMETOOLONG:
        return(TEXT("WSAENAMETOOLONG"));
        break;

      case WSAEHOSTDOWN:
        return(TEXT("WSAEHOSTDOWN"));
        break;

      case WSAEHOSTUNREACH:
        return(TEXT("WSAEHOSTUNREACH"));
        break;

      case WSAENOTEMPTY:
        return(TEXT("WSAENOTEMPTY"));
        break;

      case WSAEPROCLIM:
        return(TEXT("WSAEPROCLIM"));
        break;

      case WSAEUSERS:
        return(TEXT("WSAEUSERS"));
        break;

      case WSAEDQUOT:
        return(TEXT("WSAEDQUOT"));
        break;

      case WSAESTALE:
        return(TEXT("WSAESTALE"));
        break;

      case WSAEREMOTE:
        return(TEXT("WSAEREMOTE"));
        break;

      case WSAEDISCON:
        return(TEXT("WSAEDISCON"));
        break;

      case WSASYSNOTREADY:
        return(TEXT("WSASYSNOTREADY"));
        break;

      case WSAVERNOTSUPPORTED:
        return(TEXT("WSAVERNOTSUPPORTED"));
        break;

      case WSANOTINITIALISED:
        return(TEXT("WSANOTINITIALISED"));
        break;

        /*
      case WSAHOST:
        return(TEXT("WSAHOST"));
        break;

      case WSATRY:
        return(TEXT("WSATRY"));
        break;

      case WSANO:
        return(TEXT("WSANO"));
        break;
        */

      default:
        return(TEXT("Unknown Error"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\blaster\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by blaster.rc
//
#define IDI_DSCV2                       106
#define IDI_CONX                        107
#define IDI_CON2                        108
#define IDI_CON1A                       109
#define IDI_CON1B                       110
#define IDI_CON1C                       111
#define IDI_CON2A                       112
#define IDI_CON2B                       113
#define IDI_CON2C                       114
#define IDI_IDLE                        246
#define IDI_CON1                        251
#define IDC_DEVICES                     1008
#define IDC_ENUMDEVICES                 1009
#define IDC_STATUS                      1010
#define IDC_CONNECTTO                   1011
#define IDC_LISTENON                    1012
#define IDC_EDIT1                       1013
#define IDC_RX                          1013
#define IDC_FILE                        1013
#define IDC_SEND                        1014
#define IDC_CLOSE                       1015
#define IDC_RECV                        1015
#define IDC_EDIT2                       1016
#define IDC_CLASSNAME                   1016
#define IDC_IRLPT                       1017
#define IDC_PRINT                       1018
#define IDC_ATTRIBNAME                  1019
#define IDC_GVC                         1022
#define IDC_RXCNT                       1023
#define IDC_STOPRX                      1024
#define IDC_STARTRX                     1025
#define IDC_SENDSIZE                    1026
#define IDC_SENDCNT                     1027
#define IDC_BYTESEC                     1029

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        115
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1030
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\rasirda\callmgr.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    callmgr.c

Abstract:

    Call manager peice of the irda NDIS 5 miniport (WAN driver) 
    
Author:

    mbert 9-97    
    

RasIrda is a connection oriented Ndis 5 miniport with an integrated call manager.
Proxy is the Ndis Tapi proxy (ndproxy.sys) and is the only client protocol that 
makes calls over RasIrda.
Irda is a TDI transport driver (irda.sys). RasIrda uses irtdicl.lib to
interface with irda.sys in order to abstract the complexity of the TDI client
interface.

                      *******************    
                      Standard Call Setup
                      *******************
           
            Client                          Server

Proxy       RasIrda         Irda            RasIrda           Proxy
_______________________________________________________________________________

RasIrCmCreateVc       
---------------->

RasIrCmMakeCall
---------------->

            IrdaDiscoverDevices
            IrdaOpenConnection
            -------------------->  
                  
                          IrdaIncomingConnection
                          ------------------>
            pVc->Flags =
              IRDA_OPEN                    
                  
            NdisMCmCallComplete             +RasIrCmCreateVc
            <-----------------              pvc->Flags = 
                                              CREATED_LOCAL
            pVc->Flags =                      IRDA_OPEN
              IRDA_OPEN                                       
              VC_OPEN                       NdisMCmActivateVc
                                            ------------------>
                                                                      

                                            NdisMCmDispatchIncomingCall
                                            ------------------>
                                                    
                                                              RasIrCmIncomingCallComplete
                                                              <----------------
                                                                      
                                            pVc->Flags = 
                                              CREATED_LOCAL
                                              IRDA_OPEN
                                              VC_OPEN
                                              
===============================================================================

                        *****************                                                    
                        Client Disconnect
                        *****************
            
            Client                          Server

Proxy       RasIrda         Irda            RasIrda           Proxy
_______________________________________________________________________________

            pVc->Flags =                    pVc->Flags = 
              IRDA_OPEN                       CREATED_LOCAL
               VC_OPEN                        IRDA_OPEN
                                              VC_OPEN

RasIrCmCloseCall
--------------->

            IrdaCloseConnection
            ------------------->
            pVc->Flags =               
               VC_OPEN
                
                           IrdaConnectionClose
                           ----------------->
                                            pVc->Flags = 
                                              CREATED_LOCAL
                                              VC_OPEN
                                   
                                                    
            NdisMCmCloseCallComplete     
            <------------------                 
                                            IrdaCloseConnection
                                            <------------
RasIrCmDeleteVc                                     
---------------->                           NdisMCmDispatchIncomingCloseCall
                                            ----------------->
                                                    
                                                              RasIrCmCloseCall
                                                              <---------------
                                                                      
                                            NdisMCmCloseCallComplete
                                            ------------------>
                                                    
                                            +RasIrCmDeleteVc 
                                                
===============================================================================

                     *****************                                                                     
                     Server Disconnect
                     *****************                 
                              
            Client                          Server

Proxy       RasIrda         Irda            RasIrda           Proxy
_______________________________________________________________________________

           pVc->Flags =                     pVc->Flags = 
             IRDA_OPEN                        CREATED_LOCAL
             VC_OPEN                          IRDA_OPEN
                                              VC_OPEN
                                                                      
                                                              RasIrCmCloseCall
                                                              <---------------
                                                                        
                                            IrdaCloseConnection
                                            <------------
                                            pVc->Flags = 
                                              CREATED_LOCAL
                                              VC_OPEN


                      IrdaConnectionClose   NdisMCmCloseCallComplete
                      <-----------------    ------------------>
            pVc->Flags =               
              VC_OPEN                       +RasIrCmDeleteVc               
                          
            IrdaCloseConnection                       
            --------------->
                
            NdisMCmDispathIncomingCloseConn
            <---------------------

RasIrCmCloseCall
--------------->

            NdisMCmCloseCallComplete
            <----------------------
                
RasIrCmDeleteVc
--------------->

===============================================================================

--*/

#include "rasirdap.h"

NDIS_STATUS
RasIrCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext)
{
    PRASIR_ADAPTER  pAdapter = ProtocolAfContext;
    PRASIR_VC       pVc;
    NDIS_STATUS     Status;
    
    GOODADAPTER(pAdapter);
    
    NdisAllocateMemoryWithTag((PVOID *)&pVc, sizeof(RASIR_VC), MT_RASIR_VC);

    if (pVc == NULL)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: RasIrCmCreateVc failed, resources\n"));
        return NDIS_STATUS_RESOURCES;
    }    
        
    NdisZeroMemory(pVc, sizeof(*pVc));        
    
#if DBG
    pVc->Sig = (ULONG) VC_SIG;
#endif    
       
    pVc->pAdapter = pAdapter;            
    pVc->NdisVcHandle = NdisVcHandle;
    
    pVc->LinkInfo.MaxSendFrameSize = pAdapter->Info.MaxFrameSize;
    pVc->LinkInfo.MaxRecvFrameSize = pAdapter->Info.MaxFrameSize;
    pVc->LinkInfo.SendFramingBits  = pAdapter->Info.FramingBits;
    pVc->LinkInfo.RecvFramingBits  = pAdapter->Info.FramingBits;    
    pVc->LinkInfo.SendACCM         = (ULONG) -1;
    pVc->LinkInfo.RecvACCM         = (ULONG) -1;
    
    InitializeListHead(&pVc->CompletedAsyncBufList);
    
    ReferenceInit(&pVc->RefCnt, pVc, DeleteVc);

    REFADD(&pVc->RefCnt, ' TS1');
    
    NdisInterlockedInsertTailList(&pAdapter->VcList,
                                  &pVc->Linkage,
                                  &pAdapter->SpinLock);
    
    NdisAllocatePacketPool(&Status,
                           &pVc->RxPacketPool,
                           IRTDI_RECV_BUF_CNT * 2, 0);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: NdisAllocatePacketPool failed %X\n",
                             Status));
        goto done;
    }
    
    NdisAllocateBufferPool(&Status,
                           &pVc->RxBufferPool,
                           IRTDI_RECV_BUF_CNT);
                           
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: NdisAllocateBufferPool failed %X\n",
                             Status));
        goto done;
    }
                                   
    *ProtocolVcContext = pVc;
    
done:    
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmCreateVc status %X, vc:%X\n",
             Status, pVc));
             
    if (Status != NDIS_STATUS_SUCCESS)
    {
        REFDEL(&pVc->RefCnt, ' TS1');
    }    
                
    return Status;
}        

NDIS_STATUS
RasIrCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext)
{
    PRASIR_VC       pVc = ProtocolVcContext;
    PASYNC_BUFFER   pAsyncBuf;
    
    GOODVC(pVc);
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmDeleteVc vc:%X\n", pVc));
    
    if (pVc->pCurrAsyncBuf)
    {
        NdisFreeToNPagedLookasideList(&pVc->pAdapter->AsyncBufLList, 
                                      pVc->pCurrAsyncBuf);
    }
    
    while ((pAsyncBuf = (PASYNC_BUFFER) NdisInterlockedRemoveHeadList(
                                           &pVc->CompletedAsyncBufList,
                                           &pVc->pAdapter->SpinLock)) != NULL)
    {
        NdisFreeToNPagedLookasideList(&pVc->pAdapter->AsyncBufLList, 
                                      pAsyncBuf);    
    }                            

    REFDEL(&pVc->RefCnt, ' TS1');

    return NDIS_STATUS_SUCCESS;
}        

NDIS_STATUS
RasIrCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext)
{
    PRASIR_ADAPTER  pAdapter = (PRASIR_ADAPTER) CallMgrBindingContext;
    NDIS_HANDLE hExistingAf;
 
    GOODADAPTER(pAdapter);
    

    if ((AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_TAPI_PROXY)) {

        DEBUGMSG(DBG_ERROR, ("RASIRDA: bad address family %08lx\n",AddressFamily->AddressFamily));

        return NDIS_STATUS_INVALID_ADDRESS;
    }

    
    pAdapter->Flags = 0;
          
    hExistingAf = (NDIS_HANDLE)
        InterlockedCompareExchangePointer(
            &pAdapter->NdisAfHandle, NdisAfHandle, NULL );
            
    if (hExistingAf)
    {
        // Our AF has already been opened and it doesn't make any sense to
        // accept another since there is no way to distinguish which should
        // receive incoming calls.
        //
        DEBUGMSG(DBG_ERROR, ("RASIR: OpenAddressFamily again!\n"));
        ASSERT( !"AF exists?" );
        return NDIS_STATUS_FAILURE;
    }
    
    *CallMgrAfContext = CallMgrBindingContext;

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
RasIrCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext)
{
    PRASIR_ADAPTER      pAdapter = (PRASIR_ADAPTER) CallMgrAfContext;

    GOODADAPTER(pAdapter);

    if (pAdapter->NdisSapHandle != NULL)
    {
        DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmCloseAf pending, Outstanding registered SAP\n"));
     
        pAdapter->Flags |= ADF_PENDING_AF_CLOSE;
           
        return NDIS_STATUS_PENDING;
    }
    else
    {
        DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmCloseAf\n"));    
        
        return NDIS_STATUS_SUCCESS;
    }    
}

BOOLEAN
CloseNextAdapterEndpoint(
    PRASIR_ADAPTER  pAdapter)
{
    PRASIR_IRDA_ENDPOINT    pEndp;
    
    pEndp = (PRASIR_IRDA_ENDPOINT) NdisInterlockedRemoveHeadList(
                                    &pAdapter->EndpList,
                                    &pAdapter->SpinLock);
    
    //
    // Remove the first endpoint and close it. 
    // The remaining endpoints are closed in 
    // the completetion of this endpoint close
    // (see IrdaCloseEndpointComplete)
    //
                                    
    if (pEndp != NULL)
    {
        GOODENDP(pEndp);
                                            
        DEBUGMSG(DBG_CONNECT, ("RASIR: ->IrdaCloseEndpoint endp:%X\n",
                 pEndp));
                                                     
        IrdaCloseEndpoint(pEndp->IrdaEndpContext);
        
        return TRUE; // an endpoint was closed
    }
    
    return FALSE;
}    
            
NDIS_STATUS
OpenNewIrdaEndpoint(
    PRASIR_ADAPTER  pAdapter,
    ULONG           EndpointType,
    PCHAR           ServiceName,
    ULONG           ServiceNameSize)
{
    PRASIR_IRDA_ENDPOINT    pEndp;
    TDI_ADDRESS_IRDA        ListenAddr;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;


    NdisAllocateMemoryWithTag((PVOID *) &pEndp,
                              sizeof(RASIR_IRDA_ENDPOINT),
                              MT_RASIR_ENDP);

    DEBUGMSG(DBG_CONNECT, ("RASIR: OpenNewIrdaEndpoint %X type %d on service %s\n",
             pEndp, EndpointType, ServiceName));
                                  
    if (pEndp == NULL)
    {
        Status = NDIS_STATUS_RESOURCES;
        goto EXIT;
    }
                    
    pEndp->pAdapter = pAdapter;
    pEndp->EndpType = EndpointType;
    pEndp->Sig      = (ULONG) ENDP_SIG;
    
    #if DBG
    RtlCopyMemory(pEndp->ServiceName,
                  ServiceName,
                  ServiceNameSize);
    #endif
        
    RtlCopyMemory(ListenAddr.irdaServiceName,
                  ServiceName, 
                  ServiceNameSize);
    
    Status = IrdaOpenEndpoint(pEndp,
                              &ListenAddr, 
                              &pEndp->IrdaEndpContext);
    
EXIT:

    if (Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: OpenNewIrdaEndpoint failed %X\n",
                 Status));
                 
        if (pEndp)
        {             
            NdisFreeMemory(pEndp, 0, 0);
        }    
    }   
    else
    {
        NdisInterlockedInsertTailList(
                &pAdapter->EndpList,
                &pEndp->Linkage,
                &pAdapter->SpinLock);
    }     
   
    return Status;
}       
    
VOID
RegisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext)
{
    PRASIR_ADAPTER          pAdapter = (PRASIR_ADAPTER) pContext;
    NDIS_STATUS             Status;
    NDIS_HANDLE             hOldSap;
    PRASIR_IRDA_ENDPOINT    pEndp;

    GOODADAPTER(pAdapter);
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: RegisterSapPassive\n"));
    
    NdisFreeToNPagedLookasideList(&pAdapter->WorkItemsLList, pWork);

    hOldSap = pAdapter->NdisSapHandle;
    
    if (pAdapter->ModemPort == FALSE)
    {
    
        Status = OpenNewIrdaEndpoint(pAdapter, 
                                     EPT_DIRECT,
                                     RASIR_SERVICE_NAME_DIRECT,
                                     sizeof(RASIR_SERVICE_NAME_DIRECT));
                                     
        if (Status != NDIS_STATUS_SUCCESS)                             
        {
            goto EXIT;
        }

        Status = OpenNewIrdaEndpoint(pAdapter, 
                                     EPT_ASYNC, 
                                     RASIR_SERVICE_NAME_ASYNC,
                                     sizeof(RASIR_SERVICE_NAME_ASYNC));
    }
    else
    {
        DEBUGMSG(DBG_CONNECT, ("RASIR: Ignoring SAP registration for ModemPort\n"));
        Status = NDIS_STATUS_SUCCESS; // We don't except incoming connections for modems
    }
                                 
    if (Status != NDIS_STATUS_SUCCESS)
    {
        CloseNextAdapterEndpoint(pAdapter);
        goto EXIT;
    }
    
EXIT:
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        pAdapter->NdisSapHandle = NULL;    
    }

    NdisMCmRegisterSapComplete(Status, hOldSap, (NDIS_HANDLE) pAdapter);
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: ->NdisMCmRegisterSapComplete status %X\n",
             Status));
}        

NDIS_STATUS
RasIrCmRegisterSap(
    IN NDIS_HANDLE CallMgrAfContext,
    IN PCO_SAP Sap,
    IN NDIS_HANDLE NdisSapHandle,
    OUT PNDIS_HANDLE CallMgrSapContext)
{
    PRASIR_ADAPTER      pAdapter = (PRASIR_ADAPTER) CallMgrAfContext;
    NDIS_HANDLE         hExistingSap;
    NDIS_STATUS         Status;
    
    GOODADAPTER(pAdapter);

    DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmRegisterSap\n"));
    
    hExistingSap = (NDIS_HANDLE)
        InterlockedCompareExchangePointer(
            &pAdapter->NdisSapHandle, NdisSapHandle, NULL);
            
    if (hExistingSap)
    {
        // A SAP has already been registered and it doesn't make any sense to
        // accept another since there are no SAP parameters to distinguish
        // them.
        //
        DEBUGMSG(DBG_ERROR, ("RASIR: Registering SAP again, why. WHY??\n"));
        return NDIS_STATUS_SAP_IN_USE;
    }

    *CallMgrSapContext = (NDIS_HANDLE )pAdapter;
    
    Status = ScheduleWork(pAdapter, RegisterSapPassive, pAdapter);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        InterlockedExchangePointer(&pAdapter->NdisSapHandle, NULL);
        return Status;
    }

    return NDIS_STATUS_PENDING;
}

VOID
CompleteSapDeregistration(
    PRASIR_ADAPTER  pAdapter)
{
    NDIS_HANDLE         hOldSap;
    
    GOODADAPTER(pAdapter);
    
    if ((pAdapter->Flags & ADF_SAP_DEREGISTERED) == 0)
    {
        //
        // Sap deregisteration never occured
        // (failure path for RegisterSap)
        // 
        return;
    }

    hOldSap=InterlockedExchangePointer(&pAdapter->NdisSapHandle, NULL);

    if (hOldSap)
    {

        DEBUGMSG(DBG_CONNECT, ("RASIR: ->NdisMCmDeregisterSapComp\n"));    
            
        NdisMCmDeregisterSapComplete(NDIS_STATUS_SUCCESS, hOldSap);
    }
        
    if (pAdapter->Flags & ADF_PENDING_AF_CLOSE)

    {
        pAdapter->Flags &= ~ADF_PENDING_AF_CLOSE;
        
        DEBUGMSG(DBG_CONNECT, ("RASIR: ->NdisMCmCloseAddresFamilyComplete hAf:%X\n",
                             pAdapter->NdisAfHandle));
            
        NdisMCmCloseAddressFamilyComplete(NDIS_STATUS_SUCCESS, 
                                          pAdapter->NdisAfHandle);            
    }    
}
    
VOID
IrdaCloseEndpointComplete(
    IN PVOID ClEndpContext)
{
    PRASIR_IRDA_ENDPOINT    pEndp = (PRASIR_IRDA_ENDPOINT) ClEndpContext;
    PRASIR_ADAPTER          pAdapter;
    
    GOODENDP(pEndp);
    
    pAdapter = pEndp->pAdapter;
    
    GOODADAPTER(pAdapter);    
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: IrdaCloseEndpointComplete adapter:%X, endp:%X\n",
             pAdapter, pEndp));

    pEndp->Sig = 0x66666666;
    
    NdisFreeMemory(pEndp, 0,0);
    
    if (CloseNextAdapterEndpoint(pAdapter) == FALSE)
    {
        CompleteSapDeregistration(pAdapter);
    }
}
    
VOID
DeregisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext)
{
    PRASIR_ADAPTER      pAdapter = (PRASIR_ADAPTER) pContext;

    GOODADAPTER(pAdapter);
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: DeregisterSapPassive\n"));
    
    NdisFreeToNPagedLookasideList(&pAdapter->WorkItemsLList, pWork);
    
    if (CloseNextAdapterEndpoint(pAdapter) == FALSE)
    {
        CompleteSapDeregistration(pAdapter);   
    }  
}

NDIS_STATUS
RasIrCmDeregisterSap(
    NDIS_HANDLE CallMgrSapContext)
{
    PRASIR_ADAPTER      pAdapter = (PRASIR_ADAPTER) CallMgrSapContext;
    NDIS_STATUS         Status;
    
    GOODADAPTER(pAdapter);
    
    pAdapter->Flags |= ADF_SAP_DEREGISTERED;
    
    Status = ScheduleWork(pAdapter, DeregisterSapPassive, pAdapter);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: RasIrCmDeregisterSap failed\n"));
        return Status;
    }    
    
    DEBUGMSG(DBG_ERROR, ("RASIR: RasIrCmDeregisterSap pending\n"));    
    
    return NDIS_STATUS_PENDING;
}        

VOID
CompleteMakeCall(
    PRASIR_VC   pVc,
    NDIS_STATUS Status)   
{
    ULONG           ConnectionSpeed;

    pVc->Flags &= ~VCF_MAKE_CALL_PEND;
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        goto COMPLETE_CALL;
    }
        
    AllocCallParms(pVc);
    
    if (pVc->IrModemCall)
    {
        ConnectionSpeed = pVc->ConnectionSpeed / 8;
    }
    else
    {
        ConnectionSpeed = IrdaGetConnectionSpeed(pVc->IrdaConnContext) / 8;
    }    
    
    pVc->pMakeCall->CallMgrParameters->Receive.PeakBandwidth = ConnectionSpeed;
    pVc->pMakeCall->CallMgrParameters->Transmit.PeakBandwidth = ConnectionSpeed;    
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: Connection speed %d\n", ConnectionSpeed));    
    
    Status = NdisMCmActivateVc(pVc->NdisVcHandle,
                               pVc->pMakeCall);
    
COMPLETE_CALL:

    NdisMCmMakeCallComplete(Status, pVc->NdisVcHandle, NULL, NULL, 
                            pVc->pMakeCall);
                  
    NdisAcquireSpinLock(&pVc->pAdapter->SpinLock);
                            
    if (Status == STATUS_SUCCESS)
    {
        pVc->Flags |= VCF_OPEN;
        REFADD(&pVc->RefCnt, 'NEPO');
    }
    
    NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);    

    
    DEBUGMSG(DBG_CONNECT, ("RASIR: ->NdisMCmMakeCallComplete status %X\n", Status));                            
}

NTSTATUS
MakeIrdaConnection(
    PRASIR_VC       pVc,
    PDEVICELIST     pDevList,
    CHAR *          ServiceName,
    int             ServiceNameLen)
{
    NTSTATUS            Status=STATUS_UNSUCCESSFUL;
    ULONG               i;
    TDI_ADDRESS_IRDA    IrdaAddr;    

    DEBUGMSG(DBG_CONNECT, ("RASIR: Connect to service %s\n", ServiceName));

    //
    // Attempt a connection to all devices
    // in range until one succeeds
    //
    
    RtlCopyMemory(IrdaAddr.irdaServiceName,
                  ServiceName, 
                  ServiceNameLen);    
    
    for (i = 0; i < pDevList->numDevice; i++)
    {
        RtlCopyMemory(IrdaAddr.irdaDeviceID,
                      pDevList->Device[i].irdaDeviceID, 4);              
        
        Status = IrdaOpenConnection(&IrdaAddr, pVc, &pVc->IrdaConnContext, FALSE);
    
        DEBUGMSG(DBG_CONNECT, ("RASIR: Vc %X IrdaOpenConnection() to device %X, Status %X\n", 
                 pVc, IrdaAddr.irdaDeviceID, Status));    
                 
        if (Status == STATUS_SUCCESS)
        {
            break;
        }    
    }

    return Status;
}

VOID
IrdaCloseAddresses()
{
    PRASIR_ADAPTER  pAdapter, pNextAdapter;
    
    NdisAcquireSpinLock(&RasIrSpinLock); 
    
    DEBUGMSG(DBG_ERROR, ("RASIR: Close addresses\n"));
    for (pAdapter = (PRASIR_ADAPTER) RasIrAdapterList.Flink;
         pAdapter != (PRASIR_ADAPTER) &RasIrAdapterList;
         pAdapter = pNextAdapter)
    {
        pNextAdapter = (PRASIR_ADAPTER) pAdapter->Linkage.Flink;
        
        NdisReleaseSpinLock(&RasIrSpinLock);
        
        DEBUGMSG(DBG_ERROR, ("RASIR: Close address on adapter %X\n", pAdapter));        
        
        CloseNextAdapterEndpoint(pAdapter);
        
        NdisAcquireSpinLock(&RasIrSpinLock);
    }     
    
     NdisReleaseSpinLock(&RasIrSpinLock);    
}
    
VOID
InitiateIrdaConnection(
    IN NDIS_WORK_ITEM   *pWork,
    IN VOID             *pContext)
{
    PRASIR_VC       pVc = pContext;
    PRASIR_ADAPTER  pAdapter;
    NTSTATUS        Status;
    CHAR            DevListBuf[sizeof(DEVICELIST) - sizeof(IRDA_DEVICE_INFO) +
                       (sizeof(IRDA_DEVICE_INFO) * 3)];
    PDEVICELIST     pDevList = (PDEVICELIST) DevListBuf;                       
    ULONG           DevListLen = sizeof(DevListBuf);
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: InitiateIrdaConnection\n"));
    
    GOODVC(pVc);
    
    pAdapter = pVc->pAdapter;
    
    GOODADAPTER(pAdapter);
    
    NdisFreeToNPagedLookasideList(&pAdapter->WorkItemsLList, pWork);
    
    Status = IrdaDiscoverDevices(pDevList, &DevListLen);
    
    if (Status != STATUS_SUCCESS)
    {
        goto EXIT;
    }    
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: IrdaDiscoverDevices, %d devices found\n",
                pDevList->numDevice));
     
    if (pDevList->numDevice == 0)
    {
        DEBUGMSG(DBG_CONNECT, ("RASIR: No devices found\n"));
        Status = NDIS_STATUS_TAPI_DISCONNECTMODE_UNREACHABLE;
        goto EXIT;    
    }

    // First attempt a direct connection. if it fails try a phone connection

    if (pVc->IrModemCall)
    {
        pVc->AsyncFraming = TRUE;    
        pVc->ModemState = MS_OFFLINE;        
        
        Status = MakeIrdaConnection(
                    pVc,
                    pDevList,
                    RASIR_SERVICE_NAME_IRMODEM,
                    sizeof(RASIR_SERVICE_NAME_IRMODEM));
                    
        if (Status == STATUS_SUCCESS)
        {
            NdisAllocateBufferPool(&Status,
                                   &pVc->TxBufferPool,
                                   TX_BUF_POOL_SIZE);
        }
    }                
    else
    {                
        Status = MakeIrdaConnection(
                    pVc,
                    pDevList,
                    RASIR_SERVICE_NAME_DIRECT,
                    sizeof(RASIR_SERVICE_NAME_DIRECT));
    }
    
    if (Status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: IrdaOpenConnection failed %X\n", Status));
        Status = NDIS_STATUS_TAPI_DISCONNECTMODE_REJECT;
    }
    else
    {
        pVc->Flags |= VCF_IRDA_OPEN;
        
        REFADD(&pVc->RefCnt, 'ADRI');    
    }    
    
    if (Status == NDIS_STATUS_SUCCESS && pVc->IrModemCall)
    {
        PASYNC_BUFFER   pAsyncBuf;
    
        // 
        // Start the IrDial exchange
        //
        
        pVc->ModemState = MS_CONNECTING;
                
        ASSERT(pVc->pOfflineNdisBuf == NULL);
        

        //
        // Build the phone number string, make sore the buffer is big enough for the atd+number+cr+null
        //
        if (sizeof(pVc->OfflineSendBuf) > pVc->pTmParams->DestAddress.Offset+3+1+1 ) {
            int     i;
            char    *pIn, *pOut;
            
            strcpy(pVc->OfflineSendBuf, "ATD");
            
            pOut = pVc->OfflineSendBuf+3;
            
            pIn = ((PUCHAR)&(pVc->pTmParams->DestAddress)) + pVc->pTmParams->DestAddress.Offset;
            
            // Tapi gives us a UNICODE number so fix it up
            
            for (i = 0; i < pVc->pTmParams->DestAddress.Length; i++)
            {
                if (*pIn != 0)
                {
                    *pOut++ = *pIn;
                }
                pIn++;
            }
            
            *pOut++ = '\r';
            *pOut = 0;

        } else {

            Status=STATUS_INVALID_PARAMETER;
            goto EXIT;
        }
        

        NdisAllocateBuffer(&Status, &pVc->pOfflineNdisBuf,
                           pVc->TxBufferPool, 
                           pVc->OfflineSendBuf, strlen(pVc->OfflineSendBuf));
        

        if (Status == NDIS_STATUS_SUCCESS)
        {
            REFADD(&pVc->RefCnt, 'DNES');
             
            DEBUGMSG(DBG_CONNECT, ("RASIR: Send dial string vc:%X, packet %X\n",
                     pVc, pVc->pOfflineNdisBuf));
                         
            IrdaSend(pVc->IrdaConnContext, pVc->pOfflineNdisBuf, RASIR_INTERNAL_SEND);
            
            return;         
        }    
    }
    
EXIT:    

    if (Status != NDIS_STATUS_SUCCESS && pVc->Flags & VCF_IRDA_OPEN)
    {
        IrdaCloseConnection(pVc->IrdaConnContext);
    }

    CompleteMakeCall(pVc, Status);
}    

NDIS_STATUS
RasIrCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext)
{
    PRASIR_VC               pVc = CallMgrVcContext;
    PRASIR_ADAPTER          pAdapter;
    PCO_SPECIFIC_PARAMETERS pMSpecifics;
    PCO_AF_TAPI_MAKE_CALL_PARAMETERS pTmParams;    
    NDIS_STATUS             Status = NDIS_STATUS_PENDING;
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmMakeCall\n"));
        
    GOODVC(pVc);
    
    pAdapter = pVc->pAdapter;
    
    GOODADAPTER(pAdapter);
    
    if (CallParameters->Flags & (PERMANENT_VC | BROADCAST_VC | MULTIPOINT_VC))
    {
        Status = NDIS_STATUS_NOT_SUPPORTED;
        goto EXIT;
    }
    
    if (!CallParameters->MediaParameters)
    {
        Status = NDIS_STATUS_INVALID_DATA;
        goto EXIT;
    }
    
    pMSpecifics = &CallParameters->MediaParameters->MediaSpecific;
    if (pMSpecifics->Length < sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS))
    {
        Status = NDIS_STATUS_INVALID_LENGTH;
        goto EXIT;
    }

    pTmParams = (CO_AF_TAPI_MAKE_CALL_PARAMETERS* )&pMSpecifics->Parameters;
    
    pVc->pMakeCall = CallParameters;
    pVc->pTmParams = pTmParams;    
    
    if (CallMgrPartyContext)
    {
        *CallMgrPartyContext = NULL;
    }    
    
    if (pAdapter->ModemPort)
    {
        pVc->IrModemCall = TRUE;
    }

    pVc->Flags |= VCF_MAKE_CALL_PEND;
    
    Status = ScheduleWork(pAdapter, InitiateIrdaConnection, pVc);

EXIT: 
   
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: RasIrCmMakeCall failed %X\n",
                 Status));
        
        InterlockedExchangePointer(&pAdapter->NdisSapHandle, NULL);
    
        return Status;
    }
    
    return NDIS_STATUS_PENDING;
}        

VOID
CompleteClose(PRASIR_VC pVc)
{
    DEBUGMSG(DBG_CONNECT, ("RASIR: Complete close for vc:%X\n", pVc));
    
    REFADD(&pVc->RefCnt, 'DLOH');
    
    if (pVc->Flags & VCF_MAKE_CALL_PEND)
    {
        CompleteMakeCall(pVc, NDIS_STATUS_FAILURE);
    }
    
    if (pVc->Flags & VCF_OPEN)
    {                            
        NdisMCmDeactivateVc(pVc->NdisVcHandle);
        
        DEBUGMSG(DBG_CONNECT, ("RASIR: ->NdisMCmCloseCallComplete\n"));
        
        NdisMCmCloseCallComplete(NDIS_STATUS_SUCCESS,
                             pVc->NdisVcHandle, NULL);
         
        REFDEL(&pVc->RefCnt, 'NEPO');
    }
    
    if (pVc->Flags & VCF_CREATED_LOCAL)
    {
        NDIS_STATUS Status;
        
        Status = NdisMCmDeleteVc(pVc->NdisVcHandle);
       
        DEBUGMSG(DBG_CONNECT, ("RASIR: ->NdisMCmDeleteVc returned %X\n",
                 Status));
    
        RasIrCmDeleteVc((NDIS_HANDLE) pVc);
    }        

    REFDEL(&pVc->RefCnt, 'DLOH');    
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: Close complete for vc:%X\n", pVc));    
}

VOID
InitiateCloseCall(
    IN NDIS_WORK_ITEM   *pWork,
    IN VOID             *pContext)
{
    PRASIR_VC       pVc = pContext;

    NdisFreeToNPagedLookasideList(&pVc->pAdapter->WorkItemsLList, pWork);
    
    GOODVC(pVc);    
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: InitiateCloseCall for vc:%X\n", pVc));    
    
    NdisAcquireSpinLock(&pVc->pAdapter->SpinLock);
    
    if (pVc->Flags & VCF_IRDA_OPEN)
    {
        pVc->Flags &= ~VCF_IRDA_OPEN;
            
        NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);        
        
        ASSERT(pVc->IrdaConnContext);
        
        IrdaCloseConnection(pVc->IrdaConnContext);
        
        NdisAcquireSpinLock(&pVc->pAdapter->SpinLock);        
    }    
    
    if (pVc->OutstandingSends)
    {
        pVc->Flags |= VCF_CLOSE_PEND;
        NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);            
        DEBUGMSG(DBG_ERROR, ("RASIR: Outstanding sends, pending close\n"));            
    }
    else
    {
        NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);            
        CompleteClose(pVc);
    }    
}

NDIS_STATUS
RasIrCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size)
{
    PRASIR_VC   pVc = CallMgrVcContext;
        
    DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmCloseCall vc:%X\n", pVc));    
    
    GOODVC(pVc);
    
    NdisAcquireSpinLock(&pVc->pAdapter->SpinLock);
    
    if (pVc->Flags & VCF_MAKE_CALL_PEND)
    {
        NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);
        
        DEBUGMSG(DBG_CONNECT, ("RASIR: Make call is pending, not accepting close call\n"));
        
        return NDIS_STATUS_NOT_ACCEPTED;        
    }

    pVc->Flags |= VCF_CLOSING;
        
    if (!(pVc->Flags & VCF_OPEN) && !(pVc->Flags & VCF_IRDA_OPEN))
    {
        DEBUGMSG(DBG_CONNECT, ("RASIR: IrDA and VC not open\n"));
        
        NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);                    
        
        return NDIS_STATUS_SUCCESS;
    }
    
    NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);                
    
    ScheduleWork(pVc->pAdapter, InitiateCloseCall, pVc);
    
    return NDIS_STATUS_PENDING;
}        

VOID
RasIrCmIncomingCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters)
{
    PRASIR_VC           pVc = CallMgrVcContext;
    PRASIR_ADAPTER      pAdapter;    
 //   WAN_CO_LINKPARAMS   WanCoLinkParams;


    DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmIncomingCallComplete status %X\n",
        Status));

    GOODVC(pVc);
        
    pAdapter = pVc->pAdapter;
    
    GOODADAPTER(pAdapter);        
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisMCmDeactivateVc(pVc->NdisVcHandle);    
        RasIrCmCloseCall(pVc, NULL, NULL, 0);
        return;        
    }
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: ->NdisMCmDispatchCallConnected\n"));
    
    NdisMCmDispatchCallConnected(pVc->NdisVcHandle);
    
    NdisAcquireSpinLock(&pVc->pAdapter->SpinLock);
    
    pVc->Flags |= VCF_OPEN;

    NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);    
    
    /* Don't need to do this 
    WanCoLinkParams.TransmitSpeed = 4000000;
    WanCoLinkParams.ReceiveSpeed = 4000000;        
    WanCoLinkParams.SendWindow = 10;
                
    NdisMCoIndicateStatus(
            pAdapter->MiniportAdapterHandle,
            pVc->NdisVcHandle,
            NDIS_STATUS_WAN_CO_LINKPARAMS,
            &WanCoLinkParams,
            sizeof(WanCoLinkParams));
    */
    
    REFADD(&pVc->RefCnt, 'NEPO');    
}        

VOID
RasIrCmActivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters)
{
    DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmActivateVcComplete\n"));
    
    return;
}        

VOID
RasIrCmDeactivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext)
{
    DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmDeactivateVcComplete\n"));
    
    return;
}    

NDIS_STATUS
RasIrCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters)
{
    DEBUGMSG(DBG_CONNECT, ("RASIR: RasIrCmModifyCallQos\n"));
    
    return 0;
}        

VOID
DeleteVc(
    IN PRASIR_VC pVc)
{

    GOODVC(pVc);
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: Deleting vc:%X\n", pVc));
    
    NdisAcquireSpinLock(&pVc->pAdapter->SpinLock);
    
    RemoveEntryList(&pVc->Linkage);
    
    NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);    

    NdisFreePacketPool(pVc->RxPacketPool);
    
    NdisFreeBufferPool(pVc->RxBufferPool);
    
    if (pVc->TxBufferPool)
    {
        NdisFreeBufferPool(pVc->TxBufferPool);    
    }
    
    #if DBG
    pVc->Sig = 0xBAD;
    #endif
    
    if (pVc->pInCallParms)
    {
        NdisFreeMemory(pVc->pInCallParms, 0, 0); // yikes, 0 len :)
    }
    
    NdisFreeMemory(pVc, 0, 0);
}    

NTSTATUS
IrdaIncomingConnection(
    PVOID   ClEndpContext,
    PVOID   ConnectionContext,
    PVOID   *pClConnContext)
{
    PRASIR_IRDA_ENDPOINT pEndp = (PRASIR_IRDA_ENDPOINT) ClEndpContext;
    PRASIR_ADAPTER       pAdapter;    
    PRASIR_VC            pVc;
    NDIS_STATUS          Status;
    CO_CALL_PARAMETERS*  pCp;
    ULONG                ConnectionSpeed;    
   
    GOODENDP(pEndp);
    
    pAdapter = pEndp->pAdapter;
    
    GOODADAPTER(pAdapter);
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: IrdaIncomingConnection, type %d service %s\n", 
             pEndp->EndpType, pEndp->ServiceName));
    
    Status = RasIrCmCreateVc(pAdapter,
                            NULL,
                            &pVc);
                            
    if (Status != NDIS_STATUS_SUCCESS)
    {
        goto error1;
    }
    
    NdisAcquireSpinLock(&pVc->pAdapter->SpinLock);
    
    pVc->IrdaConnContext = ConnectionContext;
    pVc->Flags |= VCF_CREATED_LOCAL;
    pVc->AsyncFraming = (pEndp->EndpType == EPT_DIRECT ? FALSE : TRUE);
    
    NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);    
    
    AllocCallParms(pVc);
    
    pCp = (CO_CALL_PARAMETERS *) pVc->pInCallParms;
    
    if (pVc->pInCallParms == NULL)
    {
        goto error2;
    }    
    
    if (pVc->AsyncFraming)
    {
        NdisAllocateBufferPool(&Status,
                               &pVc->TxBufferPool,
                               TX_BUF_POOL_SIZE);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            goto error2;
        }    
    }
    
    Status = NdisMCmCreateVc(pAdapter->MiniportAdapterHandle,
                             pAdapter->NdisAfHandle,
                             pVc,
                             &pVc->NdisVcHandle);
                                 
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: NdisMCmCreateVc failed %X\n", Status));
        goto error2;
    }

    Status = NdisMCmActivateVc(pVc->NdisVcHandle, pCp);
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("RASIR: NdisMCmActivateVc failed %X\n", Status));
        goto error3;
    }    

    ConnectionSpeed = IrdaGetConnectionSpeed(pVc->IrdaConnContext) / 8;
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: Connection speed %d\n", ConnectionSpeed));
        
    pCp->CallMgrParameters->Receive.PeakBandwidth = ConnectionSpeed;
    pCp->CallMgrParameters->Transmit.PeakBandwidth = ConnectionSpeed;    

    Status = NdisMCmDispatchIncomingCall(pAdapter->NdisSapHandle,
                                         pVc->NdisVcHandle,
                                         pCp);
                    
    if (!(pVc->Flags & VCF_CLOSING))
    {
        pVc->Flags |= VCF_IRDA_OPEN;
        
        REFADD(&pVc->RefCnt, 'ADRI');        
        
        *pClConnContext = pVc;
                    
        switch (Status)
        {
            case NDIS_STATUS_SUCCESS:
                DEBUGMSG(DBG_CONNECT, ("RASIR: ->NdisMCmDispatchIncomingCall completed synchronously\n"));        
                RasIrCmIncomingCallComplete(Status, pVc, NULL);
                return STATUS_SUCCESS;
                    
            case NDIS_STATUS_PENDING:
                DEBUGMSG(DBG_CONNECT, ("RASIR: ->NdisMCmDispatchIncomingCall returned pending\n"));        
                return STATUS_SUCCESS;
        }
    }            

    DEBUGMSG(DBG_ERROR, ("RASIR: NdisMCmDispatchIncomingCall failed %X\n",
             Status));

    NdisMCmDeactivateVc(pVc->NdisVcHandle);    
    
error3:        

    NdisMCmDeleteVc(pVc->NdisVcHandle);                
    
error2:

    RasIrCmDeleteVc(pVc);    
    
error1:
    
    return STATUS_UNSUCCESSFUL;
}

VOID
IrdaConnectionClosed(
    PVOID ConnectionContext)
{
    PRASIR_VC       pVc = ConnectionContext;
    
    GOODVC(pVc);
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: IrdaConnectionClose vc:%X\n", pVc));
        
    NdisAcquireSpinLock(&pVc->pAdapter->SpinLock);
    
    if (!(pVc->Flags & VCF_IRDA_OPEN))
    {
        DEBUGMSG(DBG_CONNECT, ("       Irda not open\n"));
        NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);
        return;
    }    

    pVc->Flags &= ~VCF_IRDA_OPEN;
    
    NdisReleaseSpinLock(&pVc->pAdapter->SpinLock);    

    IrdaCloseConnection(pVc->IrdaConnContext);

    DEBUGMSG(DBG_CONNECT, ("RASIR: ->NdisMCmDispatchIncomingCloseCall\n"));
    
    NdisMCmDispatchIncomingCloseCall(
        NDIS_STATUS_SUCCESS,
        pVc->NdisVcHandle,
        NULL, 0);        
}

VOID
IrdaCloseConnectionComplete(
    PVOID ConnectionContext)
{
    PRASIR_VC       pVc = ConnectionContext;
    
    GOODVC(pVc);
    
    DEBUGMSG(DBG_CONNECT, ("RASIR: IrdaCloseConnectionComplete vc:%X\n", pVc));
    
    REFDEL(&pVc->RefCnt, 'ADRI');        
}

VOID
AllocCallParms(
    IN PRASIR_VC pVc)
{
    CO_CALL_PARAMETERS* pCp;
    CO_CALL_MANAGER_PARAMETERS* pCmp;
    CO_MEDIA_PARAMETERS* pMp;
    ULONG   CallParmsSize;
    CO_AF_TAPI_INCOMING_CALL_PARAMETERS* pTi;
    LINE_CALL_INFO* pLci;
    
    
    ASSERT(pVc->pInCallParms == NULL);
    
    if (pVc->pInCallParms != NULL)
    {
        return;
    }    
    
    // no attempt here to hide the beauty of CoNdis.
    
    CallParmsSize = sizeof(CO_CALL_PARAMETERS) +
                   + sizeof(CO_CALL_MANAGER_PARAMETERS)
                   + sizeof(CO_MEDIA_PARAMETERS)
                   + sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)
                   + sizeof(LINE_CALL_INFO);
        
    NdisAllocateMemoryWithTag((PVOID *)&pVc->pInCallParms, 
                        CallParmsSize, MT_RASIR_CALLPARMS);
                        
    if (pVc->pInCallParms == NULL)
    {
        return; 
    }                        
    
    NdisZeroMemory(pVc->pInCallParms, CallParmsSize);
    
    pCp = (CO_CALL_PARAMETERS* )pVc->pInCallParms;
    pCmp = (PCO_CALL_MANAGER_PARAMETERS )(pCp + 1);
    pCp->CallMgrParameters = pCmp;
    pCmp->Transmit.TokenRate =
    pCmp->Transmit.PeakBandwidth =
    pCmp->Receive.TokenRate =
    pCmp->Receive.PeakBandwidth = RASIR_MAX_RATE/8;
    
    pMp = (PCO_MEDIA_PARAMETERS )(pCmp + 1);
    pCp->MediaParameters = pMp;
    pMp->ReceiveSizeHint = IRDA_MAX_DATA_SIZE;
    pMp->MediaSpecific.Length = sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)
                                    + sizeof(LINE_CALL_INFO);
    pTi = (CO_AF_TAPI_INCOMING_CALL_PARAMETERS* )
            pMp->MediaSpecific.Parameters;

    pTi->ulLineID = 0;
        
    pTi->ulAddressID = CO_TAPI_ADDRESS_ID_UNSPECIFIED;
    pTi->ulFlags = CO_TAPI_FLAG_INCOMING_CALL;
    pTi->LineCallInfo.Length = sizeof(LINE_CALL_INFO);
    pTi->LineCallInfo.MaximumLength = sizeof(LINE_CALL_INFO);
    pTi->LineCallInfo.Offset = sizeof(pTi->LineCallInfo);
    
    pLci = (LINE_CALL_INFO* )(pTi + 1);
    pLci->ulTotalSize = sizeof(LINE_CALL_INFO);
    pLci->ulNeededSize = sizeof(LINE_CALL_INFO);
    pLci->ulUsedSize = sizeof(LINE_CALL_INFO);
    pLci->ulLineDeviceID = pTi->ulLineID;
    pLci->ulBearerMode = LINEBEARERMODE_DATA;
    pLci->ulMediaMode = LINEMEDIAMODE_DIGITALDATA;
    
    pLci->ulRate = RASIR_MAX_RATE;
    
    pVc->pTiParams = pTi;
}

NDIS_STATUS
QueryCmInformation(
    IN PRASIR_ADAPTER   pAdapter,
    IN PRASIR_VC        pVc,
    IN NDIS_OID         Oid,
    IN PVOID            InformationBuffer,
    IN ULONG            InformationBufferLength,
    OUT PULONG          BytesWritten,
    OUT PULONG          BytesNeeded)

    // Handle Call Manager QueryInformation requests.  Arguments are as for
    // the standard NDIS 'MiniportQueryInformation' handler except this
    // routine does not count on being serialized with respect to other
    // requests.
    //
{
    NDIS_STATUS Status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;
    ULONG extension;
    ULONG ulPortIndex;

    Status = NDIS_STATUS_SUCCESS;

    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    switch (Oid)
    {
        case OID_CO_TAPI_CM_CAPS:
        {
            CO_TAPI_CM_CAPS caps;
            NTSTATUS statusDevice;

            DEBUGMSG(DBG_CONFIG, ("RASIR: QueryCm OID_CO_TAPI_CM_CAPS\n"));

            NdisZeroMemory( &caps, sizeof(caps) );

            // 
            // Report 2 lines, 1 for phone and 1 for DCC
            //
            caps.ulCoTapiVersion = CO_TAPI_VERSION;
            caps.ulNumLines = 1;
            caps.ulFlags = CO_TAPI_FLAG_PER_LINE_CAPS;
            pInfo = &caps;
            ulInfoLen = sizeof(caps);
            break;
        }

        case OID_CO_TAPI_LINE_CAPS:
        {
            RASIR_CO_TAPI_LINE_CAPS     RasIrLineCaps;
            CO_TAPI_LINE_CAPS*          pInCaps;
            LINE_DEV_CAPS*              pldc;
            ULONG                       ulPortForLineId;
            
            if (InformationBufferLength < sizeof(RASIR_CO_TAPI_LINE_CAPS))
            {
                Status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            ASSERT( InformationBuffer );
            
            pInCaps = (CO_TAPI_LINE_CAPS* )InformationBuffer;
            
            DEBUGMSG(DBG_CONFIG, ("RASIR: QueryCm OID_CO_TAPI_LINE_CAPS line %d\n",
                     pInCaps->ulLineID));            

            NdisZeroMemory(&RasIrLineCaps, sizeof(RasIrLineCaps));
            pldc = &RasIrLineCaps.caps.LineDevCaps;

            // get the LineId from the incoming pInCaps (CO_TAPI_LINE_CAPS)
            //
            RasIrLineCaps.caps.ulLineID = pInCaps->ulLineID;

            pldc->ulPermanentLineID     = RasIrLineCaps.caps.ulLineID;
            pldc->ulTotalSize           = pInCaps->LineDevCaps.ulTotalSize;
            pldc->ulNeededSize          = (ULONG ) ((CHAR* )(&RasIrLineCaps + 1) - (CHAR* )(&RasIrLineCaps.caps.LineDevCaps));
            pldc->ulUsedSize            = pldc->ulNeededSize;
            pldc->ulNumAddresses        = 1;
            pldc->ulBearerModes         = LINEBEARERMODE_DATA;
            pldc->ulMaxRate             = RASIR_MAX_RATE;
            pldc->ulMediaModes          = LINEMEDIAMODE_UNKNOWN | LINEMEDIAMODE_DIGITALDATA;
            pldc->ulStringFormat        = STRINGFORMAT_ASCII;
            pldc->ulLineNameOffset      = (ULONG ) ((CHAR* )RasIrLineCaps.LineName - (CHAR* )pldc);
            if (pAdapter->ModemPort)
            {
                pldc->ulMaxNumActiveCalls = 1;
            }
            else
            {
                pldc->ulMaxNumActiveCalls = 4;            
            }    
            
            RtlCopyMemory(RasIrLineCaps.LineName, pAdapter->TapiLineName.Buffer, pAdapter->TapiLineName.Length);
            pldc->ulLineNameSize = pAdapter->TapiLineName.Length;

            pInfo = &RasIrLineCaps;
            ulInfoLen = sizeof(RasIrLineCaps);
            break;
        }

        case OID_CO_TAPI_ADDRESS_CAPS:
        {
            CO_TAPI_ADDRESS_CAPS    caps;
            CO_TAPI_ADDRESS_CAPS*   pInCaps;
            LINE_ADDRESS_CAPS*      plac;

            if (InformationBufferLength < sizeof(CO_TAPI_ADDRESS_CAPS))
            {
                Status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            ASSERT( InformationBuffer );
            pInCaps = (CO_TAPI_ADDRESS_CAPS* )InformationBuffer;

            NdisZeroMemory( &caps, sizeof(caps) );

            caps.ulLineID = pInCaps->ulLineID;
            caps.ulAddressID = pInCaps->ulAddressID;
            
            plac = &caps.LineAddressCaps;
            
            if (pAdapter->ModemPort)
            {
                plac->ulAddrCapFlags = LINEADDRCAPFLAGS_DIALED;            
                DEBUGMSG(DBG_CONFIG, ("RASIR: QueryCm OID_CO_TAPI_ADDRESS_CAPS line %d address %d, DIALED\n",
                          pInCaps->ulLineID, pInCaps->ulAddressID));
            }
            else
            {
                DEBUGMSG(DBG_CONFIG, ("RASIR: QueryCm OID_CO_TAPI_ADDRESS_CAPS line %d address %d, DCC\n",
                          pInCaps->ulLineID, pInCaps->ulAddressID));            
            }
            

            plac->ulTotalSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulNeededSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulUsedSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulLineDeviceID = caps.ulLineID;
            plac->ulMaxNumActiveCalls = 64;

            pInfo = &caps;
            ulInfoLen = sizeof(caps);
            break;
        }

        case OID_CO_TAPI_GET_CALL_DIAGNOSTICS:
        {
            CO_TAPI_CALL_DIAGNOSTICS diags;

            DEBUGMSG(DBG_CONFIG, ("RASIR: QueryCm OID_CO_TAPI_GET_CALL_DIAGS\n"));

            if (!pVc)
            {
                Status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            NdisZeroMemory( &diags, sizeof(diags) );

            diags.ulOrigin = pVc->Flags & VCF_CREATED_LOCAL ? 
                                LINECALLORIGIN_EXTERNAL : LINECALLORIGIN_OUTBOUND;
                    
            diags.ulReason = LINECALLREASON_DIRECT;

            pInfo = &diags;
            ulInfoLen = sizeof(diags);
            break;
        }

        default:
        {
            DEBUGMSG(DBG_ERROR, ("RASIR: QueryCm OID not supported %X\n", Oid));
            Status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    return Status;
}

NDIS_STATUS
RasIrCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest )

    // Standard 'CmRequestHandler' routine called by NDIS in response to a
    // client's request for information from the mini-port.
    //
{
    PRASIR_ADAPTER  pAdapter = (PRASIR_ADAPTER) CallMgrAfContext;
    PRASIR_VC       pVc = (PRASIR_VC) CallMgrVcContext;
    NDIS_STATUS     Status;

    GOODADAPTER(pAdapter);

    if (pVc) 
    {
        GOODVC(pVc);
    }    

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        {
            Status = QueryCmInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.QUERY_INFORMATION.Oid,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            DEBUGMSG(DBG_ERROR, ("RASIR: RasIrCmRequest - NdisRequestSetInformation not supported\n"));
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        default:
        {
            DEBUGMSG(DBG_ERROR, ("RASIR: RasIrCmRequest - Request type %d not supported\n", 
                    NdisRequest->RequestType));        
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
    }

    return Status;
}


VOID    
ProcessOfflineRxBuf(
    IN PRASIR_VC pVc,
    IN PIRDA_RECVBUF pRecvBuf)    
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;


    DEBUGMSG(DBG_CONNECT, ("RASIR: Offline command received. buflen %d %c%c%c%c\n",
             pRecvBuf->BufLen, pRecvBuf->Buf[2], pRecvBuf->Buf[3],
             pRecvBuf->Buf[4], pRecvBuf->Buf[5]));

    if (pRecvBuf->BufLen < 3)
    {
        goto EXIT;
    }

    if (pVc->ModemState == MS_CONNECTING)
    {        
        
        if (pRecvBuf->Buf[2] == 'C') // "<CR><LF>CONNECT 9600<CR><LF>"
        {
            pVc->ModemState = MS_ONLINE;
            
            // Extract the baudrate
            
            if (pRecvBuf->BufLen > 13) 
            {
                // Replace <CR><LF> with 0
                
                pRecvBuf->Buf[pRecvBuf->BufLen-1] = 0;
                pRecvBuf->Buf[pRecvBuf->BufLen-2] = 0;
                
                pVc->ConnectionSpeed = 2400;
                
                RtlCharToInteger(&pRecvBuf->Buf[10], 10, &pVc->ConnectionSpeed);
                
                DEBUGMSG(DBG_CONNECT, ("RASIR: Modem connected at %d\n", 
                        pVc->ConnectionSpeed));
                                
            }
            
            Status = NDIS_STATUS_SUCCESS;
        }
        else if (pRecvBuf->Buf[0] == 'A') // "ATD123-4567<CR>"
        {
            DEBUGMSG(DBG_CONNECT, ("RASIR: command echo received\n"));
            return;
        }
        else
        {
            if (pRecvBuf->Buf[2] == 'N') // "<CR><LF>NO CARRIER<CR><LF>
            {
                Status = NDIS_STATUS_TAPI_DISCONNECTMODE_NOANSWER;
            }

            DEBUGMSG(DBG_CONNECT, ("RASIR: IrDial failed\n"));        
            pVc->ModemState = MS_OFFLINE;
        }    
    }
    
EXIT:
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        IrdaCloseConnection(pVc->IrdaConnContext);
    }
    
    CompleteMakeCall(pVc, Status);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\comm.c ===
/*
 ************************************************************************
 *
 *	COMM.c
 *
 * Portions Copyright (C) 1996-2001 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */

#include "nsc.h"
#include "comm.tmh"
#define MEDIA_BUSY_THRESHOLD  (16)

#define SYNC_SET_COMM_PORT(_intobj,_port,_index,_value) SyncWriteBankReg(_intobj,_port,0,_index,_value);

#define SYNC_GET_COMM_PORT(_intobj,_port,_index) SyncReadBankReg(_intobj,_port,0,_index)



/*
 *************************************************************************
 *  SetCOMInterrupts
 *************************************************************************
 */
VOID SetCOMInterrupts(IrDevice *thisDev, BOOLEAN enable)
{
	UCHAR newMask;

	if (enable){
		if (thisDev->portInfo.SirWritePending){
			if (thisDev->currentSpeed > MAX_SIR_SPEED){
				newMask = thisDev->FirIntMask;
			}
			else {
				newMask = XMIT_MODE_INTS_ENABLE;
			}
		}	
		else {
			if (thisDev->currentSpeed > MAX_SIR_SPEED){
				newMask = thisDev->FirIntMask;
			}
			else {
				newMask = RCV_MODE_INTS_ENABLE;
			}
		}
	}
	else {
		newMask = ALL_INTS_DISABLE;
	}

	SetCOMPort(thisDev->portInfo.ioBase, INT_ENABLE_REG_OFFSET, newMask);
}

VOID
SyncSetInterruptMask(
    IrDevice *thisDev,
    BOOLEAN enable
    )

{

	UCHAR newMask;

	if (enable){
		if (thisDev->portInfo.SirWritePending){
			if (thisDev->currentSpeed > MAX_SIR_SPEED){
				newMask = thisDev->FirIntMask;
			}
			else {
				newMask = XMIT_MODE_INTS_ENABLE;
			}
		}	
		else {
			if (thisDev->currentSpeed > MAX_SIR_SPEED){
				newMask = thisDev->FirIntMask;
			}
			else {
				newMask = RCV_MODE_INTS_ENABLE;
			}
		}
	}
	else {
		newMask = ALL_INTS_DISABLE;
	}

    SYNC_SET_COMM_PORT(&thisDev->interruptObj,thisDev->portInfo.ioBase, INT_ENABLE_REG_OFFSET, newMask);

}


/*
 *************************************************************************
 *  DoOpen
 *************************************************************************
 *
 *  Open COMM port
 *
 */
BOOLEAN DoOpen(IrDevice *thisDev)
{
	BOOLEAN result;

	DBGOUT(("DoOpen(%d)", thisDev->portInfo.ioBase));

	/*
	 *  This buffer gets swapped with the rcvBuffer data pointer
	 *  and must be the same size.
	 */
	thisDev->portInfo.readBuf = LIST_ENTRY_TO_RCV_BUF(NscMemAlloc(RCV_BUFFER_SIZE));  // Was FALSE -SWA
	if (!thisDev->portInfo.readBuf){
		return FALSE;
	}


	/*
	 *  The write buffer is also used as a DMA buffer.
	 */
	thisDev->portInfo.writeComBuffer = NscMemAlloc(MAX_IRDA_DATA_SIZE );
	if (!thisDev->portInfo.writeComBuffer){
		return FALSE;
	}

	/*
	 *  Initialize send/receive FSMs before OpenCOM(), which enables rcv interrupts.
	 */
	thisDev->portInfo.rcvState = STATE_INIT;
	thisDev->portInfo.SirWritePending = FALSE;
    //
    //  the sir recieve will start automatically
    //
    thisDev->TransmitIsIdle= TRUE;

    NdisInitializeEvent(&thisDev->ReceiveStopped);
    NdisResetEvent(&thisDev->ReceiveStopped);

    NdisInitializeEvent(&thisDev->SendStoppedOnHalt);
    NdisResetEvent(&thisDev->SendStoppedOnHalt);

	result = OpenCOM(thisDev);

	DBGOUT(("DoOpen %s", (CHAR *)(result ? "succeeded" : "failed")));
	return result;

}



/*
 *************************************************************************
 *  DoClose
 *************************************************************************
 *
 *  Close COMM port
 *
 */
VOID DoClose(IrDevice *thisDev)
{
	DBGOUT(("DoClose(COM%d)", thisDev->portInfo.ioBase));

	if (thisDev->portInfo.readBuf){

		NscMemFree(RCV_BUF_TO_LIST_ENTRY(thisDev->portInfo.readBuf));

		thisDev->portInfo.readBuf = NULL;
	}

	if (thisDev->portInfo.writeComBuffer){

		NscMemFree(thisDev->portInfo.writeComBuffer);
		thisDev->portInfo.writeComBuffer = NULL;
	}
#if 0
	CloseCOM(thisDev);
#endif
}

typedef struct _SYNC_SET_SPEED {

    PUCHAR     PortBase;
    UINT       BitsPerSecond;

} SYNC_SET_SPEED, *PSYNC_SET_SPEED;


VOID
SyncSetUARTSpeed(
    PVOID      Context
    )

{

    PSYNC_SET_SPEED     SyncContext=(PSYNC_SET_SPEED)Context;

    NdisRawWritePortUchar(SyncContext->PortBase+LINE_CONTROL_REG_OFFSET,0x83);
    NdisRawWritePortUchar(SyncContext->PortBase+XFER_REG_OFFSET, (UCHAR)(115200/SyncContext->BitsPerSecond));
    NdisRawWritePortUchar(SyncContext->PortBase+INT_ENABLE_REG_OFFSET, (UCHAR)((115200/SyncContext->BitsPerSecond)>>8));
    NdisRawWritePortUchar(SyncContext->PortBase+LINE_CONTROL_REG_OFFSET, 0x03);

    return;

}




/*
 *************************************************************************
 *  SetUARTSpeed
 *************************************************************************
 *
 *
 */
VOID SetUARTSpeed(IrDevice *thisDev, UINT bitsPerSec)
{

	if (bitsPerSec <= MAX_SIR_SPEED){

		/*
		 *  Set speed in the standard UART divisor latch
		 *
		 *  1.	Set up to access the divisor latch.
		 *
		 *	2.	In divisor-latch mode:
		 *			the transfer register doubles as the low divisor latch
		 *			the int-enable register doubles as the hi divisor latch
		 *
		 *		Set the divisor for the given speed.
		 *		The divisor divides the maximum Slow IR speed of 115200 bits/sec.
		 *
		 *  3.	Take the transfer register out of divisor-latch mode.
		 *
		 */

        SYNC_SET_SPEED    SyncContext;

		if (!bitsPerSec){
			bitsPerSec = 9600;
		}


        SyncContext.PortBase=thisDev->portInfo.ioBase;
        SyncContext.BitsPerSecond=bitsPerSec;

        //
        //  since we are changeing the port bank, sync with the interrupt
        //
        NdisMSynchronizeWithInterrupt(
            &thisDev->interruptObj,
            SyncSetUARTSpeed,
            &SyncContext
            );


		NdisStallExecution(5000);
	}
}


/*
 *************************************************************************
 *  SetSpeed
 *************************************************************************
 *
 *
 */
BOOLEAN SetSpeed(IrDevice *thisDev)
{
	UINT bitsPerSec = thisDev->linkSpeedInfo->bitsPerSec;
	BOOLEAN dongleSet, result = TRUE;

//    DbgPrint("nsc: setspeed %d\n",bitsPerSec);
	DBGOUT((" **** SetSpeed(%xh, %d bps) ***************************", thisDev->portInfo.ioBase, bitsPerSec));


	/*
	 *  Disable interrupts while changing speed.
	 *  (This is especially important for the ADAPTEC dongle;
	 *   we may get interrupted while setting command mode
	 *   between writing 0xff and reading 0xc3).
	 */
	SyncSetInterruptMask(thisDev, FALSE);

	/*
	 *  First, set the UART's speed to 9600 baud.
	 *  Some of the dongles need to receive their command sequences at this speed.
	 */
	SetUARTSpeed(thisDev, 9600);

	dongleSet = NSC_DEMO_SetSpeed(thisDev, thisDev->portInfo.ioBase, bitsPerSec, thisDev->portInfo.dongleContext);
	//
	// debug info.
	//
	thisDev->portInfo.PacketsReceived_DEBUG = 0;
	if (!dongleSet){
		DBGERR(("Dongle set-speed failed"));
		result = FALSE;
	}

	/*
	 *  Now set the speed for the COM port
	 */
	SetUARTSpeed(thisDev, bitsPerSec);

	thisDev->currentSpeed = bitsPerSec;

    DebugSpeed=bitsPerSec;

	SyncSetInterruptMask(thisDev, TRUE);

	return result;
}



/*
 *************************************************************************
 *  StepSendFSM
 *************************************************************************
 *
 *
 *  Step the send fsm to send a few more bytes of an IR frame.
 *  Return TRUE only after an entire frame has been sent.
 *
 */
BOOLEAN StepSendFSM(IrDevice *thisDev)
{
	UINT i, bytesAtATime, startPos = thisDev->portInfo.writeComBufferPos;
	UCHAR lineStatReg;
	BOOLEAN result;
	UINT maxLoops;

	/*
	 *  Ordinarily, we want to fill the send FIFO once per interrupt.
	 *  However, at high speeds the interrupt latency is too slow and
	 *  we need to poll inside the ISR to send the whole packet during
	 *  the first interrupt.
	 */
	if (thisDev->currentSpeed > 115200){
		maxLoops = REG_TIMEOUT_LOOPS;
	}
	else {
		maxLoops = REG_POLL_LOOPS;
	}


	/*
	 *  Write databytes as long as we have them and the UART's FIFO hasn't filled up.
	 */
	while (thisDev->portInfo.writeComBufferPos < thisDev->portInfo.writeComBufferLen){

		/*
		 *  If this COM port has a FIFO, we'll send up to the FIFO size (16 bytes).
		 *  Otherwise, we can only send one byte at a time.
		 */
		if (thisDev->portInfo.haveFIFO){
			bytesAtATime = MIN(FIFO_SIZE, (thisDev->portInfo.writeComBufferLen - thisDev->portInfo.writeComBufferPos));
		}
		else {
			bytesAtATime = 1;
		}


		/*
		 *  Wait for ready-to-send.
		 */
		i = 0;
		do {
			lineStatReg = GetCOMPort(thisDev->portInfo.ioBase, LINE_STAT_REG_OFFSET);
		} while (!(lineStatReg & LINESTAT_XMIT_HOLDING_REG_EMPTY) && (++i < maxLoops));
		if (!(lineStatReg & LINESTAT_XMIT_HOLDING_REG_EMPTY)){
			break;
		}

		/*
		 *  Send the next byte or FIFO-volume of bytes.
		 */
		for (i = 0; i < bytesAtATime; i++){
			SetCOMPort(	thisDev->portInfo.ioBase,
						XFER_REG_OFFSET,
						thisDev->portInfo.writeComBuffer[thisDev->portInfo.writeComBufferPos++]);
		}

	}

	/*
	 *  The return value will indicate whether we've sent the entire frame.
	 */
	if (thisDev->portInfo.writeComBufferPos >= thisDev->portInfo.writeComBufferLen){

		if (thisDev->setSpeedAfterCurrentSendPacket){
			/*
			 *  We'll be changing speeds after this packet,
			 *  so poll until the packet bytes have been completely sent out the FIFO.
			 *  After the 16550 says that it is empty, there may still be one remaining
			 *  byte in the FIFO, so flush it out by sending one more BOF.
			 */
			i = 0;
			do {
				lineStatReg = GetCOMPort(thisDev->portInfo.ioBase, LINE_STAT_REG_OFFSET);
			} while (!(lineStatReg & 0x20) && (++i < REG_TIMEOUT_LOOPS));

			SetCOMPort(thisDev->portInfo.ioBase, XFER_REG_OFFSET, (UCHAR)SLOW_IR_EXTRA_BOF);
			i = 0;
			do {
				lineStatReg = GetCOMPort(thisDev->portInfo.ioBase, LINE_STAT_REG_OFFSET);
			} while (!(lineStatReg & 0x20) && (++i < REG_TIMEOUT_LOOPS));
		}

		result = TRUE;
	}
	else {
		result = FALSE;
	}

	DBGOUT(("StepSendFSM wrote %d bytes (%s):", (UINT)(thisDev->portInfo.writeComBufferPos-startPos), (PUCHAR)(result ? "DONE" : "not done")));
	// DBGPRINTBUF(thisDev->portInfo.writeComBuffer+startPos, thisDev->portInfo.writeComBufferPos-startPos);

	return result;
	
}


/*
 *************************************************************************
 *  StepReceiveFSM
 *************************************************************************
 *
 *
 *  Step the receive fsm to read in a piece of an IR frame;
 *  strip the BOFs and EOF, and eliminate escape sequences.
 *  Return TRUE only after an entire frame has been read in.
 *
 */
BOOLEAN StepReceiveFSM(IrDevice *thisDev)
{
	UINT rawBufPos=0, rawBytesRead=0;
	BOOLEAN result;
	UCHAR thisch;
    PLIST_ENTRY pListEntry;

	DBGOUT(("StepReceiveFSM(%xh)", thisDev->portInfo.ioBase));

	/*
	 *  Read in and process groups of incoming bytes from the FIFO.
	 *  NOTE:  We have to loop once more after getting MAX_RCV_DATA_SIZE
	 *         bytes so that we can see the 'EOF'; hence <= and not <.
	 */
	while ((thisDev->portInfo.rcvState != STATE_SAW_EOF) && (thisDev->portInfo.readBufPos <= MAX_RCV_DATA_SIZE)){

		if (thisDev->portInfo.rcvState == STATE_CLEANUP){
			/*
			 *  We returned a complete packet last time, but we had read some
			 *  extra bytes, which we stored into the rawBuf after returning
			 *  the previous complete buffer to the user.
			 *  So instead of calling DoRcvDirect in this first execution of this loop,
			 *  we just use these previously-read bytes.
			 *  (This is typically only 1 or 2 bytes).
			 */
			rawBytesRead = thisDev->portInfo.readBufPos;
			thisDev->portInfo.rcvState = STATE_INIT;
			thisDev->portInfo.readBufPos = 0;
		}
		else {
			rawBytesRead = DoRcvDirect(thisDev->portInfo.ioBase, thisDev->portInfo.rawBuf, FIFO_SIZE);
			if (rawBytesRead == (UINT)-1){
				/*
				 *  Receive error occurred.  Go back to INIT state.
				 */
				thisDev->portInfo.rcvState = STATE_INIT;
				thisDev->portInfo.readBufPos = 0;
				continue;
			}	
			else if (rawBytesRead == 0){
				/*
				 *  No more receive bytes.  Break out.
				 */
				break;
			}
		}

		/*
		 *  Let the receive state machine process this group of characters
		 *  we got from the FIFO.
		 *
		 *  NOTE:  We have to loop once more after getting MAX_RCV_DATA_SIZE
		 *         bytes so that we can see the 'EOF'; hence <= and not <.
		 */
		for (rawBufPos = 0;
		     ((thisDev->portInfo.rcvState != STATE_SAW_EOF) &&
			  (rawBufPos < rawBytesRead) &&
			  (thisDev->portInfo.readBufPos <= MAX_RCV_DATA_SIZE));
			 rawBufPos++){

			thisch = thisDev->portInfo.rawBuf[rawBufPos];

			switch (thisDev->portInfo.rcvState){

				case STATE_INIT:
					switch (thisch){
						case SLOW_IR_BOF:
							thisDev->portInfo.rcvState = STATE_GOT_BOF;
							break;
						case SLOW_IR_EOF:
						case SLOW_IR_ESC:
						default:
							/*
							 *  This is meaningless garbage.  Scan past it.
							 */
							break;
					}
					break;

				case STATE_GOT_BOF:
					switch (thisch){
						case SLOW_IR_BOF:
							break;
						case SLOW_IR_EOF:
							/*
							 *  Garbage
							 */
							DBGERR(("EOF in absorbing-BOFs state in DoRcv"));
							thisDev->portInfo.rcvState = STATE_INIT;
							break;
						case SLOW_IR_ESC:
							/*
							 *  Start of data.
							 *  Our first data byte happens to be an ESC sequence.
							 */
							thisDev->portInfo.readBufPos = 0;
							thisDev->portInfo.rcvState = STATE_ESC_SEQUENCE;
							break;
						default:
							thisDev->portInfo.readBuf[0] = thisch;
							thisDev->portInfo.readBufPos = 1;
							thisDev->portInfo.rcvState = STATE_ACCEPTING;
							break;
					}
					break;

				case STATE_ACCEPTING:
					switch (thisch){
						case SLOW_IR_BOF:
							/*
							 *  Meaningless garbage
							 */
							DBGOUT(("WARNING: BOF during accepting state in DoRcv"));
							thisDev->portInfo.rcvState = STATE_INIT;
							thisDev->portInfo.readBufPos = 0;
							break;
						case SLOW_IR_EOF:
							if (thisDev->portInfo.readBufPos <
									IR_ADDR_SIZE+IR_CONTROL_SIZE+SLOW_IR_FCS_SIZE){
								thisDev->portInfo.rcvState = STATE_INIT;
								thisDev->portInfo.readBufPos = 0;
							}
							else {
								thisDev->portInfo.rcvState = STATE_SAW_EOF;
							}
							break;
						case SLOW_IR_ESC:
							thisDev->portInfo.rcvState = STATE_ESC_SEQUENCE;
							break;
						default:
							thisDev->portInfo.readBuf[thisDev->portInfo.readBufPos++] = thisch;
							break;
					}
					break;

				case STATE_ESC_SEQUENCE:
					switch (thisch){
						case SLOW_IR_EOF:
						case SLOW_IR_BOF:
						case SLOW_IR_ESC:
							/*
							 *  ESC + {EOF|BOF|ESC} is an abort sequence
							 */
							DBGERR(("DoRcv - abort sequence; ABORTING IR PACKET: (got following packet + ESC,%xh)", (UINT)thisch));
							DBGPRINTBUF(thisDev->portInfo.readBuf, thisDev->portInfo.readBufPos);
							thisDev->portInfo.rcvState = STATE_INIT;
							thisDev->portInfo.readBufPos = 0;
							break;

						case SLOW_IR_EOF^SLOW_IR_ESC_COMP:
						case SLOW_IR_BOF^SLOW_IR_ESC_COMP:
						case SLOW_IR_ESC^SLOW_IR_ESC_COMP:
							thisDev->portInfo.readBuf[thisDev->portInfo.readBufPos++] = thisch ^ SLOW_IR_ESC_COMP;
							thisDev->portInfo.rcvState = STATE_ACCEPTING;
							break;

						default:
							DBGERR(("Unnecessary escape sequence: (got following packet + ESC,%xh", (UINT)thisch));
							DBGPRINTBUF(thisDev->portInfo.readBuf, thisDev->portInfo.readBufPos);

							thisDev->portInfo.readBuf[thisDev->portInfo.readBufPos++] = thisch ^ SLOW_IR_ESC_COMP;
							thisDev->portInfo.rcvState = STATE_ACCEPTING;
							break;
					}
					break;

				case STATE_SAW_EOF:
				default:
					DBGERR(("Illegal state in DoRcv"));
					thisDev->portInfo.readBufPos = 0;
					thisDev->portInfo.rcvState = STATE_INIT;
					return 0;
			}
		}
	}


	/*
	 *  Set result and do any post-cleanup.
	 */
	switch (thisDev->portInfo.rcvState){

		case STATE_SAW_EOF:
			/*
			 *  We've read in the entire packet.
			 *  Queue it and return TRUE.
			 */
			DBGOUT((" *** DoRcv returning with COMPLETE packet, read %d bytes ***", thisDev->portInfo.readBufPos));

            if (!IsListEmpty(&thisDev->rcvBufBuf))
            {
                QueueReceivePacket(thisDev, thisDev->portInfo.readBuf, thisDev->portInfo.readBufPos, FALSE);

                // The protocol has our buffer.  Get a new one.
                pListEntry = RemoveHeadList(&thisDev->rcvBufBuf);
                thisDev->portInfo.readBuf = LIST_ENTRY_TO_RCV_BUF(pListEntry);
            }
            else
            {
                // No new buffers were available.  We just discard this packet.
                DBGERR(("No rcvBufBuf available, discarding packet\n"));
            }

			result = TRUE;

			if (rawBufPos < rawBytesRead){
				/*
				 *  This is ugly.
				 *  We have some more unprocessed bytes in the raw buffer.
				 *  Move these to the beginning of the raw buffer
				 *  go to the CLEANUP state, which indicates that these
				 *  bytes be used up during the next call.
				 *  (This is typically only 1 or 2 bytes).
				 *  Note:  We can't just leave these in the raw buffer because
				 *         we might be supporting connections to multiple COM ports.
				 */
				memcpy(thisDev->portInfo.rawBuf, &thisDev->portInfo.rawBuf[rawBufPos], rawBytesRead-rawBufPos);
				thisDev->portInfo.readBufPos = rawBytesRead-rawBufPos;
				thisDev->portInfo.rcvState = STATE_CLEANUP;
			}
			else {
				thisDev->portInfo.rcvState = STATE_INIT;
			}
			break;

		default:
			if (thisDev->portInfo.readBufPos > MAX_RCV_DATA_SIZE){
				DBGERR(("Overrun in DoRcv : read %d=%xh bytes:", thisDev->portInfo.readBufPos, thisDev->portInfo.readBufPos));
				DBGPRINTBUF(thisDev->portInfo.readBuf, thisDev->portInfo.readBufPos);
				thisDev->portInfo.readBufPos = 0;
				thisDev->portInfo.rcvState = STATE_INIT;
			}
			else {
				DBGOUT(("DoRcv returning with partial packet, read %d bytes", thisDev->portInfo.readBufPos));
			}
			result = FALSE;
			break;
	}

	return result;
}



/*
 *************************************************************************
 * COM_ISR
 *************************************************************************
 *
 *
 */
VOID COM_ISR(IrDevice *thisDev, BOOLEAN *claimingInterrupt, BOOLEAN *requireDeferredCallback)
{

    LONG  NewCount;
	/*
	 *  Get the interrupt status register value.
	 */
	UCHAR intId = GetCOMPort(thisDev->portInfo.ioBase, INT_ID_AND_FIFO_CNTRL_REG_OFFSET);



	if (intId & INTID_INTERRUPT_NOT_PENDING){
		/*
		 *  This is NOT our interrupt.
		 *  Set carry bit to pass the interrupt to the next driver in the chain.
		 */
		*claimingInterrupt = *requireDeferredCallback = FALSE;
	}
	else {
		/*
		 *  This is our interrupt
		 */

		/*
		 *  In some odd situations, we can get interrupt bits that don't
		 *  get cleared; we don't want to loop forever in this case, so keep a counter.
		 */
		UINT loops = 0;

		*claimingInterrupt = TRUE;
		*requireDeferredCallback = FALSE;

		while (!(intId & INTID_INTERRUPT_NOT_PENDING) && (loops++ < 0x10)){

			switch (intId & INTID_INTIDMASK){

				case INTID_MODEMSTAT_INT:
					DBGOUT(("COM INTERRUPT: modem status int"));
					GetCOMPort(thisDev->portInfo.ioBase, MODEM_STAT_REG_OFFSET);
					break;

				case INTID_XMITREG_INT:
					DBGOUT(("COM INTERRUPT: xmit reg empty"));

					if (thisDev->portInfo.SirWritePending){

						/*
						 *  Try to send a few more bytes
						 */
						if (StepSendFSM(thisDev)){

							/*
							 *  There are no more bytes to send;
							 *  reset interrupts for receive mode.
							 */
							thisDev->portInfo.SirWritePending = FALSE;
                            InterlockedExchange(&thisDev->portInfo.IsrDoneWithPacket,1);

                            //
                            //  this will unmask the receive interrupt
                            //
							SetCOMInterrupts(thisDev, TRUE);

							/*
							 *  Request a DPC so that we can try
							 *  to send other pending write packets.
							 */
							*requireDeferredCallback = TRUE;
						}
					}

					break;

				case INTID_RCVDATAREADY_INT:
					DBGOUT(("COM INTERRUPT: rcv data available!"));

					thisDev->nowReceiving = TRUE;

                    NewCount=NdisInterlockedIncrement(&thisDev->RxInterrupts);

					if (!thisDev->mediaBusy && (NewCount > MEDIA_BUSY_THRESHOLD)){

						thisDev->mediaBusy = TRUE;
						thisDev->haveIndicatedMediaBusy = FALSE;
						*requireDeferredCallback = TRUE;
					}

					if (StepReceiveFSM(thisDev)){
						/*
						 *  The receive engine has accumulated an entire frame.
						 *  Request a deferred callback so we can deliver the frame
						 *  when not in interrupt context.
						 */
						*requireDeferredCallback = TRUE;
						thisDev->nowReceiving = FALSE;
					}

					break;

				case INTID_RCVLINESTAT_INT:
					DBGOUT(("COM INTERRUPT: rcv line stat int!"));
					break;
			}

			/*
			 *  After we service each interrupt condition, we read the line status register.
			 *  This clears the current interrupt, and a new interrupt may then appear in
			 *  the interrupt-id register.
			 */
			GetCOMPort(thisDev->portInfo.ioBase, LINE_STAT_REG_OFFSET);
			intId = GetCOMPort(thisDev->portInfo.ioBase, INT_ID_AND_FIFO_CNTRL_REG_OFFSET);

		}
	}
}



/*
 *************************************************************************
 *  OpenCOM
 *************************************************************************
 *
 *  Initialize UART registers
 *
 */
BOOLEAN OpenCOM(IrDevice *thisDev)
{
	BOOLEAN dongleInit;
	UCHAR intIdReg;

	DBGOUT(("-> OpenCOM"));

    //
    //  Make sure bank zero is selected
    //
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+LCR_BSR_OFFSET, 03);

	/*
	 *  Disable all COM interrupts while setting up.
	 */
	SyncSetInterruptMask(thisDev, FALSE);

	/*
	 *  Set request-to-send and clear data-terminal-ready.
	 *  Note:  ** Bit 3 must be set to enable interrupts.
	 */
	SYNC_SET_COMM_PORT(&thisDev->interruptObj,thisDev->portInfo.ioBase, MODEM_CONTROL_REG_OFFSET, 0x0A);

	/*
	 *  Set dongle- or part-specific info to default
	 */
	thisDev->portInfo.hwCaps.supportedSpeedsMask	= ALL_SLOW_IRDA_SPEEDS;
	thisDev->portInfo.hwCaps.turnAroundTime_usec	= DEFAULT_TURNAROUND_usec;
	thisDev->portInfo.hwCaps.extraBOFsRequired		= 0;

	/*
	 *  Set the COM port speed to the default 9600 baud.
	 *  Some dongles can only receive cmd sequences at this speed.
	 */
	SetUARTSpeed(thisDev, 9600);

	dongleInit = NSC_DEMO_Init( thisDev );

	/*
	 *  Set request-to-send and clear data-terminal-ready.
	 *  Note:  ** Bit 3 must be set to enable interrupts.
	 */
	SYNC_SET_COMM_PORT(&thisDev->interruptObj,thisDev->portInfo.ioBase, MODEM_CONTROL_REG_OFFSET, 0x0A);

	if (!dongleInit){
		DBGERR(("Dongle-specific init failed in OpenCOM"));
		return FALSE;
	}

	/*
	 *  Set speed to default for the entire part.
	 *  (This is redundant in most, but not all, cases.)
	 */
	thisDev->linkSpeedInfo = &supportedBaudRateTable[BAUDRATE_9600];;
	SetSpeed(thisDev);

	/*
	 *  Clear the FIFO control register
	 */
	SYNC_SET_COMM_PORT(&thisDev->interruptObj,thisDev->portInfo.ioBase, INT_ID_AND_FIFO_CNTRL_REG_OFFSET, 0x00);

	/*
	 *  Set up the FIFO control register to use both read and write FIFOs (if 16650),
	 *  and with a receive FIFO trigger level of 1 byte.
	 */
	SYNC_SET_COMM_PORT(&thisDev->interruptObj,thisDev->portInfo.ioBase, INT_ID_AND_FIFO_CNTRL_REG_OFFSET, 0x07);
	
	/*
	 *  Check whether we're running on a 16550,which has a 16-byte write FIFO.
	 *  In this case, we'll be able to blast up to 16 bytes at a time.
	 */
	intIdReg = SYNC_GET_COMM_PORT(&thisDev->interruptObj,thisDev->portInfo.ioBase, INT_ID_AND_FIFO_CNTRL_REG_OFFSET);
	thisDev->portInfo.haveFIFO = (BOOLEAN)((intIdReg & 0xC0) == 0xC0);

	/*
	 *  Start out in receive mode.
	 *  We always want to be in receive mode unless we're transmitting a frame.
	 */
	SyncSetInterruptMask(thisDev, TRUE);

	DBGOUT(("OpenCOM succeeded"));
	return TRUE;
}
#if 1
/*
 *************************************************************************
 *  CloseCOM
 *************************************************************************
 *
 */
VOID CloseCOM(IrDevice *thisDev)
{
	/*
	 *  Do special deinit for dongles.
	 *  Some dongles can only rcv cmd sequences at 9600, so set this speed first.
	 */
	thisDev->linkSpeedInfo = &supportedBaudRateTable[BAUDRATE_9600];;
	SetSpeed(thisDev);
	NSC_DEMO_Deinit(thisDev->portInfo.ioBase, thisDev->portInfo.dongleContext);		

	SyncSetInterruptMask(thisDev, FALSE);
}
#endif

/*
 *************************************************************************
 *  DoRcvDirect
 *************************************************************************
 *
 *  Read up to maxBytes bytes from the UART's receive FIFO.
 *  Return the number of bytes read or (UINT)-1 if an error occurred.
 *
 */
UINT DoRcvDirect(PUCHAR ioBase, UCHAR *data, UINT maxBytes)
{
	USHORT bytesRead;
	UCHAR lineStatReg;
	UINT i;
	BOOLEAN goodChar;

	for (bytesRead = 0; bytesRead < maxBytes; bytesRead++){

		/*
		 *  Wait for data-ready
		 */
		i = 0;
		do {
			lineStatReg = GetCOMPort(ioBase, LINE_STAT_REG_OFFSET);

			/*
			 *  The UART reports framing and break errors as the effected
			 *  characters appear on the stack.  We drop these characters,
			 *  which will probably result in a bad frame checksum.
			 */
			if (lineStatReg & (LINESTAT_BREAK | LINESTAT_FRAMINGERROR)){

				UCHAR badch = GetCOMPort(ioBase, XFER_REG_OFFSET);	
				DBGERR(("Bad rcv %02xh, LSR=%02xh", (UINT)badch, (UINT)lineStatReg));
				return (UINT)-1;
			}
			else if (lineStatReg & LINESTAT_DATAREADY){

                if (lineStatReg & LINESTAT_OVERRUNERROR) {
                    DBGERR(("Overrun"));
                }

				goodChar = TRUE;
			}
			else {
				/*
				 *  No input char ready
				 */
				goodChar = FALSE;
			}

		} while (!goodChar && (++i < REG_POLL_LOOPS));	
		if (!goodChar){
			break;
		}

		/*
		 *  Read in the next data byte
		 */
		data[bytesRead] = GetCOMPort(ioBase, XFER_REG_OFFSET);
	}

	return bytesRead;
}

	/*
	 *************************************************************************
	 *  GetCOMPort
	 *************************************************************************
	 */
	UCHAR GetCOMPort(PUCHAR comBase, comPortRegOffset portOffset)
	{
		UCHAR val;
#if DBG
        {
            UCHAR TempVal;
            //
            //  This code assumes that bank 0 is current, we will make sure of that
            //
            NdisRawReadPortUchar(comBase+LCR_BSR_OFFSET, &TempVal);

            ASSERT((TempVal & BKSE) == 0);
        }
#endif

		NdisRawReadPortUchar(comBase+portOffset, &val);
		return val;
	}

	/*
	 *************************************************************************
	 *  SetCOMPort
	 *************************************************************************
	 */
	VOID SetCOMPort(PUCHAR comBase, comPortRegOffset portOffset, UCHAR val)
	{

#if DBG
        UCHAR TempVal;


        //
        //  This code assumes that bank 0 is current, we will make sure of that
        //
        NdisRawReadPortUchar(comBase+LCR_BSR_OFFSET, &TempVal);

        ASSERT((TempVal & BKSE) == 0);
#endif

		NdisRawWritePortUchar(comBase+portOffset, val);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\defs.h ===
#ifndef   TYPEDEFS
#define   TYPEDEFS

/* The standard typdef's */
typedef unsigned char	    BYTE;
typedef unsigned char	    UCHAR;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;
typedef unsigned long       ULONG;
typedef unsigned int	    UINT;

/* Bit retrieval mechanism */

#define GetBit(val,bit)	 (unsigned int) ((val>>bit) & 0x1)
   			/* Returns the bit */
#define SetBit(val,bit)  (unsigned int ) (val | (0x1 << bit))
			/* Sets bit to 1  */
#define ResetBit(val,bit) (unsigned int ) (val & ~(0x1 << bit))
			/* Sets bit to 0  */


void SelectBank(UINT, const cBank); 
void UpdateBanks();
void UpdateBankZero();
void UpdateBankOne();
void UpdateBankTwo();
void UpdateBankThree();
void UpdateBankFour();
void UpdateBankFive();
void UpdateBankSix();
void UpdateBankSeven();
BYTE ReadBank(UINT, const , int );
void WriteBank(UINT, const , int , UCHAR);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\convert.c ===
/*
 ************************************************************************
 *
 *	CONVERT.c
 *
 *
 * Portions Copyright (C) 1996-2001 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */



#include "nsc.h"
#include "convert.tmh"
extern const USHORT fcsTable[];

ULONG __inline EscapeSlowIrData(PUCHAR Dest, UCHAR SourceByte)
{
    switch (SourceByte){
        case SLOW_IR_BOF:
        case SLOW_IR_EOF:
        case SLOW_IR_ESC:
            Dest[0] = SLOW_IR_ESC;
            Dest[1] = SourceByte ^ SLOW_IR_ESC_COMP;
            return 2;

        default:
            Dest[0] = SourceByte;
            return 1;
    }
}

/*
 *************************************************************************
 *  NdisToIrPacket
 *************************************************************************
 *
 *
 *  Convert an NDIS Packet into an IR packet.
 *  Write the IR packet into the provided buffer and report its actual size.
 *
 *  If failing, *irPacketLen will contain the buffer size that
 *  the caller should retry with (or 0 if a corruption was detected).
 *
 */
BOOLEAN NdisToIrPacket(
						PNDIS_PACKET Packet,
						UCHAR *irPacketBuf,
						UINT irPacketBufLen,
						UINT *irPacketLen
					)
{
	PNDIS_BUFFER ndisBuf;
	UINT i, ndisPacketBytes = 0, I_fieldBytes, totalBytes = 0;
	UINT ndisPacketLen, numExtraBOFs;
	SLOW_IR_FCS_TYPE fcs;
	PNDIS_IRDA_PACKET_INFO packetInfo = GetPacketInfo(Packet);
	UCHAR nextChar;
    UCHAR *bufData;
    UINT bufLen;

    *irPacketLen=0;

	DBGOUT(("NdisToIrPacket()  ..."));

	/*
	 *  Get the packet's entire length and its first NDIS buffer
	 */
	NdisQueryPacket(Packet, NULL, NULL, &ndisBuf, &ndisPacketLen);

	/*
	 *  Make sure that the packet is big enough to be legal.
	 *  It consists of an A, C, and variable-length I field.
	 */
	if (ndisPacketLen < IR_ADDR_SIZE + IR_CONTROL_SIZE){
		DBGERR(("packet too short in NdisToIrPacket (%d bytes)", ndisPacketLen));
		return FALSE;
	}
	else {
		I_fieldBytes = ndisPacketLen - IR_ADDR_SIZE - IR_CONTROL_SIZE;
	}

	/*
	 *  Make sure that we won't overwrite our contiguous buffer.
	 *  Make sure that the passed-in buffer can accomodate this packet's
	 *  data no matter how much it grows through adding ESC-sequences, etc.
	 */
	if ((ndisPacketLen > MAX_IRDA_DATA_SIZE) ||
	    (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > irPacketBufLen)){

		/*
		 *  The packet is too large
		 *  Tell the caller to retry with a packet size large
		 *  enough to get past this stage next time.
		 */
		DBGERR(("Packet too large in NdisToIrPacket (%d=%xh bytes), MAX_IRDA_DATA_SIZE=%d, irPacketBufLen=%d.",
			    ndisPacketLen, ndisPacketLen, MAX_IRDA_DATA_SIZE, irPacketBufLen));
		*irPacketLen = ndisPacketLen;
		return FALSE;
	}
	
    if (!ndisBuf)
    {
        DBGERR(("No NDIS_BUFFER in NdisToIrPacket"));
        return FALSE;
    }
	
    NdisQueryBufferSafe(ndisBuf, (PVOID *)&bufData, &bufLen,NormalPagePriority);

    if (bufData == NULL) {

        DBGERR(("NdisQueryBufferSafeFailed"));
        return FALSE;
    }

    fcs = 0xffff;

    // Calculate FCS and write the new buffer in ONE PASS.

	/*
	 *  Now begin building the IR frame.
	 *
	 *  This is the final format:
	 *
	 *		BOF	(1)
	 *      extra BOFs ...
	 *		NdisMediumIrda packet (what we get from NDIS):
	 *			Address (1)
	 *			Control (1)
	 *		FCS	(2)
	 *      EOF (1)
	 */

    // Prepend BOFs (extra BOFs + 1 actual BOF)

	numExtraBOFs = packetInfo->ExtraBOFs;
	if (numExtraBOFs > MAX_NUM_EXTRA_BOFS){
		numExtraBOFs = MAX_NUM_EXTRA_BOFS;
	}
	for (i = totalBytes = 0; i < numExtraBOFs; i++){
		*(SLOW_IR_BOF_TYPE *)(irPacketBuf+totalBytes) = SLOW_IR_EXTRA_BOF;
		totalBytes += SLOW_IR_EXTRA_BOF_SIZE;
	}
	*(SLOW_IR_BOF_TYPE *)(irPacketBuf+totalBytes) = SLOW_IR_BOF;
	totalBytes += SLOW_IR_BOF_SIZE;

    for (i=0; i<ndisPacketLen; i++)
    {
        ASSERT(bufData);
        nextChar = *bufData++;
        fcs = (fcs >> 8) ^ fcsTable[(fcs ^ nextChar) & 0xff];

        totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], nextChar);

        if (--bufLen==0)
        {
            NdisGetNextBuffer(ndisBuf, &ndisBuf);
            if (ndisBuf)
            {
                NdisQueryBufferSafe(ndisBuf, (PVOID *)&bufData, &bufLen,NormalPagePriority);

                if (bufData == NULL) {

                    return FALSE;
                }
            }
            else
            {
                bufData = NULL;
            }
        }

    }

    if (bufData!=NULL)
    {
		/*
		 *  Packet was corrupt -- it misreported its size.
		 */
		DBGERR(("Packet corrupt in NdisToIrPacket (buffer lengths don't add up to packet length)."));
		*irPacketLen = 0;
		return FALSE;
    }

    fcs = ~fcs;

    // Now we escape the fcs onto the end.

    totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], (UCHAR)(fcs&0xff));
    totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], (UCHAR)(fcs>>8));

    // EOF

	*(SLOW_IR_EOF_TYPE *)&irPacketBuf[totalBytes] = SLOW_IR_EOF;
	totalBytes += SLOW_IR_EOF_SIZE;

	*irPacketLen = totalBytes;

	DBGOUT(("... NdisToIrPacket converted %d-byte ndis pkt to %d-byte irda pkt:", ndisPacketLen, *irPacketLen));

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\comm.h ===
/*
 ************************************************************************
 *
 *	COMM.h
 *
 *
 * Portions Copyright (C) 1996-1998 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-1998 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */


#ifndef COMM_H
	#define COMM_H

	/*
	 *  Size of the 16550 read and write FIFOs
	 */
	#define FIFO_SIZE 16

	/*
	 *  The programming interface to a UART (COM serial port)
	 *  consists of eight consecutive registers.
	 *  These are the port offsets from the UART's base I/O address.
	 */
	typedef enum comPortRegOffsets {
		XFER_REG_OFFSET						= 0,
		INT_ENABLE_REG_OFFSET				= 1,
		INT_ID_AND_FIFO_CNTRL_REG_OFFSET	= 2,
		LINE_CONTROL_REG_OFFSET				= 3,
		MODEM_CONTROL_REG_OFFSET			= 4,
		LINE_STAT_REG_OFFSET				= 5,
		MODEM_STAT_REG_OFFSET				= 6,
		SCRATCH_REG_OFFSET					= 7
	} comPortRegOffset;


	/*
	 *  Bits in the UART Interrupt-Id register.
	 */
	#define INTID_INTERRUPT_NOT_PENDING (UCHAR)(1 << 0)

	/*
	 *  Values for bits 2-1 of Interrupt-Id register:
	 *		00  Modem Stat reg interrupt
	 *		01  Transmitter holding reg interrupt
	 *		10  Receive data ready interrupt
	 *		11  Receive line status interrupt
	 *		
	 */
	#define INTID_INTIDMASK				(UCHAR)(3 << 1)
	#define INTID_MODEMSTAT_INT			(UCHAR)(0 << 1)
	#define INTID_XMITREG_INT			(UCHAR)(1 << 1)
	#define INTID_RCVDATAREADY_INT		(UCHAR)(2 << 1)
	#define INTID_RCVLINESTAT_INT		(UCHAR)(3 << 1)



	/*
	 *  Bits in the UART line-status register.
	 */
	#define LINESTAT_DATAREADY							(UCHAR)(1 << 0)
	#define LINESTAT_OVERRUNERROR						(UCHAR)(1 << 1)
	#define LINESTAT_PARITYERROR						(UCHAR)(1 << 2)
	#define LINESTAT_FRAMINGERROR						(UCHAR)(1 << 3)
	#define LINESTAT_BREAK								(UCHAR)(1 << 4)
	#define LINESTAT_XMIT_HOLDING_REG_EMPTY				(UCHAR)(1 << 5)
	#define LINESTAT_XMIT_SHIFT_AND_HOLDING_REG_EMPTY	(UCHAR)(1 << 6)


	/*
	 *  These are bits in the UART's interrupt-enable register (INT_ENABLE_REG_OFFSET).
	 */
	#define DATA_AVAIL_INT_ENABLE      (1 << 0)
	#define READY_FOR_XMIT_INT_ENABLE  (1 << 1)
	#define RCV_LINE_STAT_INT_ENABLE   (1 << 2)
	#define MODEM_STAT_INT_ENABLE      (1 << 3)

	#define RCV_MODE_INTS_ENABLE	(DATA_AVAIL_INT_ENABLE)
	#define XMIT_MODE_INTS_ENABLE	(READY_FOR_XMIT_INT_ENABLE|DATA_AVAIL_INT_ENABLE)
	#define ALL_INTS_ENABLE			(RCV_MODE_INTS_ENABLE | XMIT_MODE_INTS_ENABLE)
	#define ALL_INTS_DISABLE        0

	/*
	 *  These are fine-tuning parameters for the COM port ISR.
	 *  Number of times we poll a COM port register waiting
	 *  for a value which may/must appear.
	 */
	#define REG_POLL_LOOPS		2
	#define REG_TIMEOUT_LOOPS	1000000


	typedef enum {
						STATE_INIT = 0,
						STATE_GOT_BOF,
						STATE_ACCEPTING,
						STATE_ESC_SEQUENCE,
						STATE_SAW_EOF,
						STATE_CLEANUP
	} portRcvState;	



	/*
	 *  This is the information that we need to keep for each COMM port.
	 */
	typedef struct _comPortInfo {

		/*
		 *  HW resource settings for COM port.
		 */

		//
		// Physical address of the ConfigIoBaseAddress
		//
		ULONG ConfigIoBasePhysAddr;

		//
		// Virtual address of the ConfigIoBaseAddress
		//
		PUCHAR ConfigIoBaseAddr;

		//
		// Physical address of the UartIoBaseAddress
		//
		ULONG ioBasePhys;

		//
		// Virtual address of the UartIoBaseAddress
		//
		PUCHAR ioBase;

		//
		// Interrupt number this adapter is using.
		//
		UINT irq;

		//
		// DMA Cnannel Number.
		//
		UCHAR DMAChannel;

		/*
		 *  Is this COM port a 16550 with a 16-byte FIFO or
		 *  a 16450/8250 with no FIFO ?
		 */
		BOOLEAN haveFIFO;
		
		/*
		 *  Data for our rcv state machine.
		 */
		UCHAR rawBuf[FIFO_SIZE];
		PUCHAR readBuf;

		UINT readBufPos;
		portRcvState rcvState;
		//
		// Debug counter for packets received correctly.
		//
		UINT PacketsReceived_DEBUG;

		/*
		 *  Data for send state machine
		 */
		PUCHAR writeComBuffer;
		UINT writeComBufferPos;
		UINT writeComBufferLen;
		UINT SirWritePending;
        UINT IsrDoneWithPacket;

		/*
		 *  Dongle or part-specific information
		 */
		dongleCapabilities hwCaps;
		UINT dongleContext;

	} comPortInfo;


#endif COMM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\dma.h ===
/*
**  dma.h - Definitions for dma.c.
**
** Portions Copyright (C) 1996-1998 National Semiconductor Corp.
** All rights reserved.
** Copyright (C) 1996-1998 Microsoft Corporation. All Rights Reserved.
**
**  $Id$
**
**  $Log$
**
**
*/
#ifndef NDIS50_MINIPORT
#include <conio.h>
#include <nsctypes.h>
#else
#include "nsc.h"
#endif

//Definition for the Command status register
#define TRANSMIT_SETUP				0x06BD0000
#define RECEIVE_SETUP				0x06BD0000
#define ACTIVATE_TRANSMIT			0x00000001
#define ACTIVATE_RECEIVE			0x00000001
#define TRANSMIT_RUNNING			0x00020000
#define RECEIVE_RUNNING				0x00020000

#define RECEIVE_DONE				0x80
#define TRANSMIT_DONE				0x80

// Definition for the Command status result in a
// buufer descriptor of a Scatter Gather DMA.
#define TRANSMIT_UNDERRUN			0x01


//Definitions for all the FIR_DMA register offsets and sizes
//Transmit registers
#define DMA_TX_CMD_STATUS_OFFSET	0x00
#define DMA_TX_CMD_STATUS_SIZE		0x04

#define DMA_TX_DESC_COUNT_OFFSET	0x04
#define DMA_TX_DESC_COUNT_SIZE		0x02

#define DMA_TX_DESC_ADDR_OFFSET		0x08
#define DMA_TX_DESC_ADDR_SIZE		0x04

#define DMA_TX_BUFF_ADDR_OFFSET		0x0c
#define DMA_TX_BUFF_ADDR_SIZE		0x04

#define DMA_TX_BUFF_LEN_OFFSET		0x14
#define DMA_TX_BUFF_LEN_SIZE		0x02

#define DMA_TX_STATUS_CMD_OFFSET	0x17
#define DMA_TX_STATUS_CMD_SIZE		0x01

#define DMA_TX_TIME_COUNT_OFFSET	0x18
#define DMA_TX_TIME_COUNT_SIZE		0x04

#define DMA_TX_DEVICE_ID_OFFSET		0x1c
#define DMA_TX_DEVICE_ID_SIZE		0x01

//Reveive registers
#define DMA_RX_CMD_STATUS_OFFSET	0x20
#define DMA_RX_CMD_STATUS_SIZE		0x04

#define DMA_RX_DESC_COUNT_OFFSET	0x24
#define DMA_RX_DESC_COUNT_SIZE		0x02

#define DMA_RX_DESC_ADDR_OFFSET		0x28
#define DMA_RX_DESC_ADDR_SIZE		0x04

#define DMA_RX_BUFF_ADDR_OFFSET		0x2c
#define DMA_RX_BUFF_ADDR_SIZE		0x04

#define DMA_RX_BUFF_SIZE_OFFSET		0x30
#define DMA_RX_BUFF_SIZE_SIZE		0x02

#define DMA_RX_BUFF_LEN_OFFSET		0x34
#define DMA_RX_BUFF_LEN_SIZE		0x02

#define DMA_RX_STATUS_CMD_OFFSET	0x37
#define DMA_RX_STATUS_CMD_SIZE		0x01

#define DMA_RX_TIME_COUNT_OFFSET	0x38
#define DMA_RX_TIME_COUNT_SIZE		0x04

#define DMA_RX_DEVICE_ID_OFFSET		0x3c
#define DMA_RX_DEVICE_ID_SIZE		0x01


typedef enum
{
	RECEIVE_STILL_RUNNING,
	RECEIVE_COMPLETE_BUT_NOT_DONE,
	TRANSMIT_STILL_RUNNING,
	TRANSMIT_COMPLETE_BUT_NOT_DONE
} LoopbackError;	

//#ifndef NDIS50_MINIPORT
//Function prototypes
bool ReadReg ( uint32 Offset_addr, uint16 Size, uint32 *Value );
bool WriteReg ( uint32 Offset_addr, uint16 Size, uint32 Value );
void LoadTransmitRegs(uint32 PhysAddr, uint16 NumOfDescriptors, uint32 OffsetRegs);
void LoadReceiveRegs(uint32 PhysAddr, uint16 NumOfDescriptors, uint32 OffsetRegs);
void ActivateTransmit(uint32 OffsetRegs);
void ActivateReceive(uint32 OffsetRegs);
bool CheckLoopbackCompletion(LoopbackError *Error, uint32 OffsetRegs);
//#else
/*//Function prototypes
BOOLEAN ReadReg ( ULONG Offset_addr, UINT Size, ULONG *Value );
BOOLEAN WriteReg ( ULONG Offset_addr, UINT Size, ULONG Value );
void LoadTransmitRegs(ULONG PhysAddr, UINT NumOfDescriptors, ULONG OffsetRegs);
void LoadReceiveRegs(ULONG PhysAddr, UINT NumOfDescriptors, ULONG OffsetRegs);
void ActivateTransmit(ULONG OffsetRegs);
void ActivateReceive(ULONG OffsetRegs);
BOOLEAN CheckLoopbackCompletion(LoopbackError *Error, ULONG OffsetRegs);
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\dmautil.h ===
typedef  struct _DMA_UTIL {

    NDIS_HANDLE     NdisDmaHandle;

    PNDIS_BUFFER    Buffer;

    ULONG           Offset;

    ULONG           Length;

    BOOLEAN         Direction;

} DMA_UTIL, *PDMA_UTIL;


VOID
InitializeDmaUtil(
    PDMA_UTIL      DmaUtil,
    NDIS_HANDLE    DmaHandle
    );

NTSTATUS
StartDmaTransfer(
    PDMA_UTIL     DmaUtil,
    PNDIS_BUFFER  Buffer,
    ULONG         Offset,
    ULONG         Length,
    BOOLEAN       ToDevice
    );

NTSTATUS
CompleteDmaTransfer(
    PDMA_UTIL    DmaUtil,
    BOOLEAN      ToDevice
    );





#define StartDmaTransferToDevice(_h,_b,_o,_l)   StartDmaTransfer(_h,_b,_o,_l,TRUE)
#define StartDmaTransferFromDevice(_h,_b,_o,_l) StartDmaTransfer(_h,_b,_o,_l,FALSE)


#define CompleteDmaTransferToDevice(_h)   CompleteDmaTransfer(_h,TRUE)
#define CompleteDmaTransferFromDevice(_h)   CompleteDmaTransfer(_h,FALSE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\dmautil.c ===
#include <ndis.h>

#include "dmautil.h"

BOOLEAN
IsIrqlGreaterThanDispatch(
    VOID
    );



VOID
InitializeDmaUtil(
    PDMA_UTIL      DmaUtil,
    NDIS_HANDLE    DmaHandle
    )

{
    RtlZeroMemory(
        DmaUtil,
        sizeof(*DmaUtil)
        );

    DmaUtil->NdisDmaHandle=DmaHandle;

    return;

}



NTSTATUS
StartDmaTransfer(
    PDMA_UTIL     DmaUtil,
    PNDIS_BUFFER  Buffer,
    ULONG         Offset,
    ULONG         Length,
    BOOLEAN       ToDevice
    )

{
    NDIS_STATUS    Status;

    if (IsIrqlGreaterThanDispatch()) {

#if DBG
        DbgPrint("IR-DMAUTIL: Transfer started at raised IRQL\n");
#endif
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }


    if (DmaUtil->Buffer != NULL) {

#if DBG
        DbgPrint("IR-DMAUTIL: Transfer started when one is already in progress\n");
#endif
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }

    DmaUtil->Buffer=Buffer;
    DmaUtil->Offset=Offset;
    DmaUtil->Length=Length;
    DmaUtil->Direction=ToDevice;


    NdisMSetupDmaTransfer(
        &Status,
        DmaUtil->NdisDmaHandle,
        Buffer,
        Offset,
        Length,
        ToDevice
        );

    if (Status != STATUS_SUCCESS) {
#if DBG
        DbgPrint("IR-DMAUTIL: NdisMSetupDmaTransfer() failed %08lx\n",Status);
#endif
        DmaUtil->Buffer=NULL;
    }

    return Status;

}



NTSTATUS
CompleteDmaTransfer(
    PDMA_UTIL    DmaUtil,
    BOOLEAN      ToDevice
    )

{
    NDIS_STATUS    Status;

    if (IsIrqlGreaterThanDispatch()) {
#if DBG
        DbgPrint("IR-DMAUTIL: CompleteTransfer called at raised IRQL\n");
#endif
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }


    if (DmaUtil->Buffer == NULL) {
#if DBG
        DbgPrint("IR-DMAUTIL: CompleteTransfer called when no transfer it active\n");
#endif
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }

    if (ToDevice != DmaUtil->Direction) {
#if DBG
        DbgPrint("IR-DMAUTIL: CompleteTransfer called for the wrong direction of transfer\n");
#endif
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }

    NdisMCompleteDmaTransfer(
        &Status,
        DmaUtil->NdisDmaHandle,
        DmaUtil->Buffer,
        DmaUtil->Offset,
        DmaUtil->Length,
        DmaUtil->Direction
        );

    if (Status != STATUS_SUCCESS) {
#if DBG
        DbgPrint("IR-DMAUTIL: NdisMCompleteDmaTransfer() failed %08lx\n",Status);
#endif
    }

    DmaUtil->Buffer=NULL;

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\dongle.h ===
/*
 ************************************************************************
 *
 *	DONGLE.h
 *
 *
 * Portions Copyright (C) 1996-1998 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-1998 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */

#ifndef DONGLE_H
	#define DONGLE_H


	#define NDIS_IRDA_SPEED_2400       (UINT)(1 << 0)   // SLOW IR ...
	#define NDIS_IRDA_SPEED_9600       (UINT)(1 << 1)
	#define NDIS_IRDA_SPEED_19200      (UINT)(1 << 2)
	#define NDIS_IRDA_SPEED_38400      (UINT)(1 << 3)
	#define NDIS_IRDA_SPEED_57600      (UINT)(1 << 4)
	#define NDIS_IRDA_SPEED_115200     (UINT)(1 << 5)
	#define NDIS_IRDA_SPEED_576K       (UINT)(1 << 6)   // MEDIUM IR ...
	#define NDIS_IRDA_SPEED_1152K      (UINT)(1 << 7)
	#define NDIS_IRDA_SPEED_4M         (UINT)(1 << 8)   // FAST IR


	typedef struct dongleCapabilities {

			/*
			 *  This is a mask of NDIS_IRDA_SPEED_xxx bit values.
			 *
			 */
			UINT supportedSpeedsMask;

			/*
			 *  Time (in microseconds) that must transpire between
			 *  a transmit and the next receive.
			 */
			UINT turnAroundTime_usec;

			/*
			 *  Extra BOF (Beginning Of Frame) characters required
			 *  at the start of each received frame.
			 */
			UINT extraBOFsRequired;

	} dongleCapabilities;


#endif DONGLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\dongle.c ===
/*
 ************************************************************************
 *
 *	DONGLE.C
 *
 * Portions Copyright (C) 1996-2001 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.
 *
 *	Auto Dongle Setup
 *
 *	Author: Kishor Padmanabhan
 *
 *	This file has routines that implements Franco Iacobelli's vision
 *	of dongle interface. Recommand reading this document before going
 *	ahead.
 *
 *
 *************************************************************************
 */

#include "newdong.h"

#ifdef NDIS50_MINIPORT
#include "nsc.h"
#else
extern void  NSC_WriteBankReg(UINT ComPort, const iBank, int iRegNum, UCHAR iVal);
extern UCHAR  NSC_ReadBankReg(UINT ComPort,const iBank, int iRegNum);
#endif

//////////////////////////////////////////////////////////////////////////
//									//
// Function prototypes							//
//////////////////////////////////////////////////////////////////////////
//DongleParam *GetDongleCapabilities(UIR Com);
//int SetDongleCapabilities(UIR Com);

void delay(unsigned int period);    // a delay loop

// Called from SetDongleCapabilities
int SetReqMode(const UIR * Com,DongleParam *Dingle);

void SetHpDongle(PUCHAR UirPort,int Mode);
void SetTemicDongle(PUCHAR UirPort,int Mode);
void SetSharpDongle(PUCHAR UirPort,int Mode);
void SetDellDongle(PUCHAR UirPort,int Mode);
void SetHpMuxDongle(PUCHAR UirPort, int Mode);
void SetIbmDongle (PUCHAR UirPort, int Mode);

// Pauses for a specified number of microseconds.
void Sleep( ULONG wait );


//////////////////////////////////////////////////////////////////////////
//									//
// Function:	GetDongleCapabilities					//
//									//
// Description: 							//
//									//
//  This routine fill up the DongleParam structure interpreting the	//
//  dongle oem's code and returns a pointer the structure.              //
//									//
// Input       : UIR structure with XcvrNumber ,Com Port and IR mode	//
//		 offset 						//
// OutPut      : DongleParam Structure					//
//									//
//////////////////////////////////////////////////////////////////////////


DongleParam *GetDongleCapabilities(PSYNC_DONGLE SyncDongle)
{

    const UIR * Com=SyncDongle->Com;
    DongleParam *Dingle=SyncDongle->Dingle;

    UINT   Signature;
    char   TEMP1 ;

    // Check for validity of the Com port address
    if(Com->ComPort == 0) return(NULL);

    // Com->XcvrNum only has either 0 or 1
    // Check for validity of the Port Number address
    //if(Com->XcvrNum > 1) return(NULL);

    // Check for first time
    if(Dingle[Com->XcvrNum].WORD0.bits.DSVFLAG)
	return(&Dingle[Com->XcvrNum]);

    // Signature is a word long ID information
    // bit 15 = 1 -- Plug and Play
    // bit 0, 1, 2, 3 -- ID number for different Manufactures
    Signature = Com->Signature;
    Dingle[Com->XcvrNum].PlugPlay = 0;
    Dingle[Com->XcvrNum].WORD0.bits.GCERR = 0;
    if(GetBit(Com->Signature, 15)) //is dongle PnP ?
    {
	// Make the Pins IRSL1-2 as Inputs
	NSC_WriteBankReg(Com->ComPort, BANK7, 7, 0x00);

    NdisStallExecution(50);  //Wait 50 us

   // Check whether Disconnect
   // ID/IRSL(2-1) as Input upon READ bit 0-3 return the logic
   // level of the pins(allowing external devices to identify
   // themselves.)
   if(((Signature = NSC_ReadBankReg(Com->ComPort, BANK7, 4) & 0x0f)) == 0x0f) {
       Dingle[Com->XcvrNum].WORD0.bits.GCERR = XCVR_DISCONNECT;
       Dingle[Com->XcvrNum].WORD0.bits.DSVFLAG = 0;
       return(&Dingle[Com->XcvrNum]);
   }
   Dingle[Com->XcvrNum].PlugPlay = 1;

    }


// Dongle Identification
    switch(Signature & 0x1f) {

	case 0:
	case 1:
#ifdef DPRINT
	    DbgPrint(" Serial Adapter with diff. signaling");
#endif
	    return(NULL);
	    break;

	case 6:
#ifdef DPRINT
	    DbgPrint(" Serial Adapter with single ended signaling");
#endif
	    return(NULL);
	    break;

	case 7:
#ifdef DPRINT
	    DbgPrint(" Consumer-IR only");
#endif
	    return(NULL);
	    break;

	case 2:
	case 3:
	case 5:
	case 0xa:
#ifdef DPRINT
	    DbgPrint(" Reserved");
#endif
	    return(NULL);
	    break;

	case 4:
#ifdef DPRINT
	    DbgPrint(" Sharp RY5HD01 or RY5KD01 transceiver");
#endif
	    Dingle[Com->XcvrNum].WORD0.bits.DSVFLAG = 1;
	    Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode = SharpRY5HD01;
	    Dingle[Com->XcvrNum].WORD4.Data = SharpRecovery;
	    Dingle[Com->XcvrNum].WORD6.Data = SharpBofs;
	    Dingle[Com->XcvrNum].WORD7.bits.FIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.MIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.SIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.Sharp_IR = TRUE;
	    break;

	case 0x8:
#ifdef DPRINT
  DbgPrint(" HP HSDL-2300/3600 transceiver");
#endif
	    Dingle[Com->XcvrNum].WORD0.bits.DSVFLAG = 1;
	    Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode = Hp2300;
	    Dingle[Com->XcvrNum].WORD4.Data = HpRecovery;
	    Dingle[Com->XcvrNum].WORD6.Data = HpBofs;
	    Dingle[Com->XcvrNum].WORD7.bits.FIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.MIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.SIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.Sharp_IR = TRUE;
	    break;

	case 0x9:
#ifdef DPRINT
    DbgPrint(" Vishay TFDS6000, IBM31T1100, Siemens IRMS/T6400");
#endif
	    Dingle[Com->XcvrNum].WORD0.bits.DSVFLAG = 1;
	    Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode = Temic6000;
	    Dingle[Com->XcvrNum].WORD4.Data = TemicRecovery;
	    Dingle[Com->XcvrNum].WORD6.Data = TemicBofs;
	    Dingle[Com->XcvrNum].WORD7.bits.FIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.MIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.SIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.Sharp_IR = TRUE;
	    break;

	case 0x0B:
#ifdef DPRINT
    DbgPrint(" Vishay TFDS6500");
#endif
	    Dingle[Com->XcvrNum].WORD0.bits.DSVFLAG = 1;
	    Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode = Temic6500;
	    Dingle[Com->XcvrNum].WORD4.Data = TemicRecovery;
	    Dingle[Com->XcvrNum].WORD6.Data = TemicBofs;
	    Dingle[Com->XcvrNum].WORD7.bits.FIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.MIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.SIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.Sharp_IR = TRUE;
	    break;

	case 0xc:
	case 0xd:
#ifdef DPRINT
	    DbgPrint(" HP HSDL-1100/2100 or TI TSLM1100 or Sharp RY6FD11E/RY6FD1SE");
#endif
	    Dingle[Com->XcvrNum].WORD0.bits.DSVFLAG = 1;
	    Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode = Hp1100;
	    Dingle[Com->XcvrNum].WORD4.Data = HpRecovery;
	    Dingle[Com->XcvrNum].WORD6.Data = HpBofs;
	    Dingle[Com->XcvrNum].WORD7.bits.FIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.MIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.SIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.Sharp_IR = TRUE;
	    break;

	case 0xe:
#ifdef DPRINT
	    DbgPrint(" SIR Only");
#endif
	    Dingle[Com->XcvrNum].WORD0.bits.DSVFLAG = 1;
	    Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode = SirOnly;
	    Dingle[Com->XcvrNum].WORD4.Data = TemicRecovery;
	    Dingle[Com->XcvrNum].WORD6.Data = TemicBofs;
	    Dingle[Com->XcvrNum].WORD7.bits.SIR = TRUE;
	    break;

	case 0xf:
#ifdef DPRINT
	    DbgPrint(" No Dongle present");
#endif
	    return(NULL);
	    break;

	case 0x10:
#ifdef DPRINT
  DbgPrint("DELL Titanium with two TEMIC transceivers");
#endif
	    Dingle[Com->XcvrNum].WORD0.bits.DSVFLAG = 1;
	    Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode = Dell1997;
	    Dingle[Com->XcvrNum].WORD4.Data = TemicRecovery;
	    Dingle[Com->XcvrNum].WORD6.Data = TemicBofs;
	    Dingle[Com->XcvrNum].WORD7.bits.FIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.MIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.SIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.Sharp_IR = TRUE;
	    break;

	case 0x11:
#ifdef DPRINT
  DbgPrint("IBM SouthernCross with two IBM transceivers");
#endif
	    Dingle[Com->XcvrNum].WORD0.bits.DSVFLAG = 1;
	    Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode = Ibm20H2987;
	    Dingle[Com->XcvrNum].WORD4.Data = TemicRecovery;
	    Dingle[Com->XcvrNum].WORD6.Data = TemicBofs;
	    Dingle[Com->XcvrNum].WORD7.bits.FIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.MIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.SIR = TRUE;
	    Dingle[Com->XcvrNum].WORD7.bits.Sharp_IR = TRUE;
	    break;


       default:
	    return(NULL);
	    break;
    }
    // Everything O.K return the structure
    return(&Dingle[Com->XcvrNum]);

}


//////////////////////////////////////////////////////////////////////////
//									//
// Function:	SetDongleCapabilities					//
//									//
// Description: 							//
//									//
// Input  : UIR structure with XcvrNumber ,Com Port and IR mode offset	//
// Result : If successfull will set the dongle to the appropriate mode. //
//	    Returns TRUE for success and error codes defined in dongle.h//
//		UNSUPPORTED	2					//
//		ERROR_GETCAPAB	7					//
//									//
//////////////////////////////////////////////////////////////////////////

int SetDongleCapabilities(PSYNC_DONGLE SyncDongle)
{

    const UIR * Com=SyncDongle->Com;
    DongleParam *Dingle=SyncDongle->Dingle;

    DongleParam *Dongle;

    Dongle = GetDongleCapabilities(SyncDongle);

    // Check whether Dongle is NULL
    if(Dongle == NULL) {
#ifdef DPRINT
	DbgPrint(" Returning ERROR");
#endif
	return(ERROR_GETCAPAB);
    }

    if(Dingle[Com->XcvrNum].WORD0.bits.GCERR != 0)
	return(ERROR_GETCAPAB);

    return(SetReqMode(Com,Dingle));

}


//////////////////////////////////////////////////////////////////////////
//									//
// Function:	SetRegMode						//
//									//
// Description: 							//
//									//
// Input    : Structure Com  with ComPort, ModeReq and XcvrNum set.	//
// OutPut   : True if successfull					//
//	      UNIMPLEMENTED if so					//
//									//
//									//
//////////////////////////////////////////////////////////////////////////

int SetReqMode(const UIR * Com,DongleParam *Dingle)
{

UINT	 trcode ;

#ifdef DPRINT
    DbgPrint("ModeReq %d ",Com->ModeReq);
#endif

    trcode = Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode;
    if ((trcode == Hp1100) || (trcode == Dell1997))
	// Make the Pins IRSL1-2 as output
	NSC_WriteBankReg(Com->ComPort, BANK7, 7, 0x08);
    else
	// Make the Pins IRSL0-2 as output
      NSC_WriteBankReg(Com->ComPort, BANK7, 7, 0x28);

    NSC_WriteBankReg(Com->ComPort, BANK7, 4, 0x00); //set IRSL1,2 low

    if(Com->ModeReq > 3)
      return(UNSUPPORTED) ;

    switch(Com->ModeReq) {

	    case 0x0:	// Setup SIR mode
		if(!Dingle[Com->XcvrNum].WORD7.bits.SIR)
		    return(UNSUPPORTED);

		NSC_WriteBankReg(Com->ComPort, BANK7, 4, 0);
		Dingle[Com->XcvrNum].WORD1.bits.CurSelMode = Com->ModeReq;
		Dingle[Com->XcvrNum].WORD0.bits.MVFLAG = 1;
		if(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode == SirOnly) {
		    return(TRUE);
		}
		if(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode == Hp1100) {
		    SetHpDongle(Com->ComPort, 1);
		    return(TRUE);
		}
		if(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode == Hp2300)
		{
		    SetHpMuxDongle(Com->ComPort,0);
		    return(TRUE);
		}
		if(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode == Temic6000) {
		    SetTemicDongle(Com->ComPort, 0);
		    return(TRUE);
		}
		if(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode == Temic6500) {
		    SetTemicDongle(Com->ComPort, 0);
		    return(TRUE);
		}
		if(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode == SharpRY5HD01) {
		    return(TRUE);
		}
		if(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode == Dell1997) {
		    SetDellDongle(Com->ComPort, 0);
		    return(TRUE);
		}
		if(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode == Ibm20H2987) {
		    SetIbmDongle(Com->ComPort, 0);
		    return(TRUE);
		}
		break;

	    case   1:	/* Setup MIR mode */
		if(!Dingle[Com->XcvrNum].WORD7.bits.MIR)
		    return(UNSUPPORTED);
		// Set the current mode to the mode requested
		Dingle[Com->XcvrNum].WORD1.bits.CurSelMode = Com->ModeReq;
		Dingle[Com->XcvrNum].WORD0.bits.MVFLAG = 1;
		switch(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode) {
		    case Hp1100:
			SetHpDongle(Com->ComPort, 1);
			return(TRUE);
		    case Hp2300:
			SetHpMuxDongle(Com->ComPort,1);
			return(TRUE);
		    case Temic6000:
			SetTemicDongle(Com->ComPort, 0);
			return(TRUE);
		    case Temic6500:
			SetTemicDongle(Com->ComPort, 1);
			return(TRUE);
		    case SharpRY5HD01:
			return(TRUE);
		    case Dell1997:
			SetDellDongle(Com->ComPort, 1);
			return(TRUE);
		    case Ibm20H2987:
			SetIbmDongle(Com->ComPort, 1);
			return(TRUE);
		}
		break;

	    case   2:	// Setup FIR mode
		if(!Dingle[Com->XcvrNum].WORD7.bits.FIR)
		    return(UNSUPPORTED);

		// Set the current mode to the mode requested
		Dingle[Com->XcvrNum].WORD1.bits.CurSelMode = Com->ModeReq;
		Dingle[Com->XcvrNum].WORD0.bits.MVFLAG = 1;
		switch(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode) {
		    case Hp1100:
			SetHpDongle(Com->ComPort, 1);
			return(TRUE);
		    case Hp2300:
			SetHpMuxDongle(Com->ComPort,1);
			return(TRUE);
		    case Temic6000:
		    case Temic6500:
			SetTemicDongle(Com->ComPort, 1);
			return(TRUE);
		    case SharpRY5HD01:
			return(TRUE);
		    case Dell1997:
			SetDellDongle(Com->ComPort, 1);
			return(TRUE);
		    case Ibm20H2987:
			SetIbmDongle(Com->ComPort, 1);
			return(TRUE);
		}
		break;

	    case   3:	// Setup Sharp-IR mode
		if(!Dingle[Com->XcvrNum].WORD7.bits.Sharp_IR)
		    return(UNSUPPORTED);

		// Set the current mode to the mode requested
		Dingle[Com->XcvrNum].WORD1.bits.CurSelMode = Com->ModeReq;
		Dingle[Com->XcvrNum].WORD0.bits.MVFLAG = 1;
		switch(Dingle[Com->XcvrNum].WORD0.bits.TrcvrCode) {
		    case Hp1100:
			SetHpDongle(Com->ComPort, 0);
			return(TRUE);
		    case Hp2300:
			SetHpMuxDongle(Com->ComPort, 1);
			return(TRUE);
		    case Temic6000:
			SetTemicDongle(Com->ComPort, 0);
			return(TRUE);
		    case Temic6500:
			SetTemicDongle(Com->ComPort, 1);
			return(TRUE);
		    case SharpRY5HD01:
			return(TRUE);
		    case Dell1997:
			SetDellDongle(Com->ComPort, 1);
			return(TRUE);
		    case Ibm20H2987:
			SetIbmDongle(Com->ComPort, 1);
			return(TRUE);
		}
		break;

	    default:
		return(UNSUPPORTED);
	}

	return(UNSUPPORTED);
}

//////////////////////////////////////////////////////////////////////////
//									//
// Function:	SetHpMuxDongle						//
//									//
// Description: 							//
//									//
// Input :  Mode = 1 for FIR,MIR and SIR .				//
//	    Mode = 0 for SIR						//
//									//
//////////////////////////////////////////////////////////////////////////

void SetHpMuxDongle(PUCHAR UirPort,int Mode)
{
  if (Mode == 1)
    NSC_WriteBankReg(UirPort,BANK7,4,0x1); //select MIR or FIR
}


//////////////////////////////////////////////////////////////////////////
//									//
// Function:	SetHpDongle						//
//									//
// Description: 							//
//									//
// Input :  Mode = 1 for FIR,MIR and SIR .				//
//	    Mode = 0 for Sharp, CIR_OS					//
//									//
//////////////////////////////////////////////////////////////////////////


void SetHpDongle(PUCHAR UirPort,int Mode)
{
    UCHAR  val;

    if(Mode) {
	//  MIR , FIR and SIR Mode . And Oversampling Low speed
	// Bank 5/offset 4/Bit 4 (AUX_IRRX) = 0
	val = (UCHAR) (NSC_ReadBankReg(UirPort,BANK5,4) & 0xef);
	NSC_WriteBankReg(UirPort,BANK5,4,val);
	NSC_WriteBankReg(UirPort,BANK7,7,0x48);
    }
    else {
	//  Sharp IR , Oversampling Med and hi speed cir
	val =(UCHAR)  NSC_ReadBankReg(UirPort,BANK5,4) | 0x10;
	NSC_WriteBankReg(UirPort,BANK5,4,val);
    }

}



//////////////////////////////////////////////////////////////////////////
//									//
// Function:	Sleep							//
//									//
// Description: 							//
//									//
//  Pauses for a specified number of microseconds.			//
//									//
//////////////////////////////////////////////////////////////////////////

void Sleep( ULONG usecToWait )
{
#ifdef NDIS50_MINIPORT
    do {
	UINT usec = (usecToWait > 8000) ? 8000 : usecToWait;
	NdisStallExecution(usec);
	usecToWait -= usec;
    } while (usecToWait > 0);
#else
    clock_t goal;
    goal = usecToWait + clock();
    while( goal >= clock() ) ;
#endif
}


//////////////////////////////////////////////////////////////////////////
//									//
// Function:	Delay							//
//									//
// Description: 							//
//									//
//  Simple delay loop.							//
//									//
//////////////////////////////////////////////////////////////////////////

void delay(unsigned int usecToWait)
{
#ifdef NDIS50_MINIPORT
    do {
	UINT usec = (usecToWait > 8000) ? 8000 : usecToWait;
	NdisStallExecution(usec);
	usecToWait -= usec;
    } while (usecToWait > 0);
#else
    while(usecToWait--);
#endif
}




//////////////////////////////////////////////////////////////////////////
//									//
// Function:	SetTemicDongle						//
// Transceivers: Temic TFDS-6000/6500, IBM31T1100			//
//									//
// Description: 							//
//  Set the IBM Transceiver mode					//
//  Mode = 0 - SIR, MIR      						//
//  Mode = 1 - MIR, FIR, Sharp-IR					//
//  Mode = 2 - Low Power Mode						//
//									//
//////////////////////////////////////////////////////////////////////////

void SetTemicDongle(PUCHAR UirPort,int Mode)
{
     switch( Mode ) {
	 case  0:
	     NSC_WriteBankReg(UirPort, BANK7, 4, 0x00);
		 NdisStallExecution(10);
	     // Trigger the Bandwidth line from high to low
	     NSC_WriteBankReg(UirPort, BANK7, 4, 0x01);
	     NdisStallExecution( 20 );
	     NSC_WriteBankReg(UirPort,BANK7,4,0x00);
	     NdisStallExecution( 1000 );
	     break;
	 case  1:
	     NSC_WriteBankReg(UirPort, BANK7, 4, 0x01);
	     NdisStallExecution( 20 );

	     NSC_WriteBankReg(UirPort, BANK7, 4, 0x81);
	     NdisStallExecution(10);
	     NSC_WriteBankReg(UirPort, BANK7, 4, 0x80);

	     NdisStallExecution( 1000 );
	     break;
	 case  2:
	     NSC_WriteBankReg(UirPort, BANK7, 4, 0x1);
	     break;
	 default:
	     break;
    }
}


//////////////////////////////////////////////////////////////////////////
//									//
// Function:	SetDellDongle						//
//									//
// Description: 							//
//  Set the Dell Transceiver mode					//
//  Mode = 0 - SIR, MIR 						//
//  Mode = 1 - FIR							//
//  Mode = 2 - Low Power Mode						//
//									//
//////////////////////////////////////////////////////////////////////////

void SetDellDongle(PUCHAR UirPort,int Mode)
{
    switch( Mode ) {
	case  0:
	    NSC_WriteBankReg(UirPort,BANK7,4,0x02);
	    NdisStallExecution( 20 );
	    NSC_WriteBankReg(UirPort, BANK7, 4, 0x00);
	    NdisStallExecution( 1000 );

	    break;

	case  1:
	    NSC_WriteBankReg(UirPort, BANK7, 4, 0x2);
	    NdisStallExecution( 20 );

	    NSC_WriteBankReg(UirPort, BANK7, 4, 0x82);
	    NdisStallExecution( 10 );

	    NSC_WriteBankReg(UirPort, BANK7, 4, 0x80);

	    NdisStallExecution( 1000 );

	    break;

	case  2:
	    NSC_WriteBankReg(UirPort, BANK7, 4, 0x2);
	    break;

	default:
	    break;
    }
}

//////////////////////////////////////////////////////////////////////////
//									//
// Function:	SetIbmDongle 						//
// Transceivers: two IBM31T1100 with IRSL0 selecting the mode for both	//
//		 transceivers. IRSL1 low selects front transceiver.    	//
//		 IRSL2 low selects rear transceiver.			//
//		 Selection is thru the SouthernCross ASIC 0000020H2987	//
//									//
// Description: 							//
//  Set the Ibm Transceiver mode					//
//  Mode = 0 - SIR      						//
//  Mode = 1 - MIR, FIR, Sharp-IR					//
//  Mode = 2 - Low Power Mode						//
//									//
//////////////////////////////////////////////////////////////////////////

void SetIbmDongle (PUCHAR UirPort, int Mode)
{

    switch( Mode ) {
	case  0:
	    NSC_WriteBankReg(UirPort,BANK7,4,0x00);
	    NdisStallExecution( 10 );

	    NSC_WriteBankReg(UirPort,BANK7,4,0x01);
	    NdisStallExecution( 20 );

	    NSC_WriteBankReg(UirPort, BANK7, 4, 0x06);
	    NdisStallExecution( 1000 );

	    break;

	case  1:
	    NSC_WriteBankReg(UirPort, BANK7, 4, 0x01);
	    NdisStallExecution( 20 );

	    NSC_WriteBankReg(UirPort, BANK7, 4, 0x81);
	    NdisStallExecution( 10 );

	    NSC_WriteBankReg(UirPort, BANK7, 4, 0x86);

	    NdisStallExecution( 1000 );


	    break;

	case  2:
	    NSC_WriteBankReg(UirPort, BANK7, 4, 0x01);
	    break;

	default:
	    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\fcs.c ===
/*
 ************************************************************************
 *
 *	FCS.c
 *
 *
 * Portions Copyright (C) 1996-2001 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */

#include "nsc.h"

const USHORT fcsTable[256] =
{
        0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
        0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
        0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
        0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
        0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
        0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
        0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
        0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
        0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
        0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
        0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
        0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
        0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
        0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
        0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
        0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
        0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
        0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
        0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
        0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
        0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
        0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
        0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
        0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
        0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
        0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
        0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
        0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
        0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
        0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
        0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
        0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};


/*
 *************************************************************************
 *  ComputeFCS
 *************************************************************************
 *
 *
 *
 *
 *
 */
USHORT ComputeFCS(UCHAR *data, UINT dataLen)
{
  USHORT fcs = 0xffff;
  UINT i;
 	
  DBGOUT(("ComputeFCS() on %d-byte buffer.", dataLen));

  for (i = 0; i < dataLen; i++){
    fcs = (fcs >> 8) ^ fcsTable[(fcs ^ *data++) & 0xff];
  }

  fcs = ~fcs;

  DBGOUT(("ComputeFCS returning %d=0x%x.", (UINT)fcs, (UINT)fcs));

  return fcs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\irql.c ===
#include <wdm.h>

BOOLEAN
IsIrqlGreaterThanDispatch(
    VOID
    )

{
#if DBG
    return   (KeGetCurrentIrql() > DISPATCH_LEVEL);
#else
    return FALSE;
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\externs.h ===
/*
 ************************************************************************
 *
 *	EXTERNS.h
 *
 *
 * Portions Copyright (C) 1996-1998 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-1998 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */



#ifndef EXTERNS_H
#define EXTERNS_H

#include "nscdemo.h"

/*
 *  Externs for required miniport export functions
 */
BOOLEAN MiniportCheckForHang(IN NDIS_HANDLE MiniportAdapterContext);
VOID MiniportDisableInterrupt(IN NDIS_HANDLE MiniportAdapterContext);
VOID MiniportEnableInterrupt(IN NDIS_HANDLE MiniportAdapterContext);
VOID MiniportHalt(IN NDIS_HANDLE MiniportAdapterContext);
VOID MiniportHandleInterrupt(IN NDIS_HANDLE MiniportAdapterContext);
NDIS_STATUS MiniportInitialize(OUT PNDIS_STATUS OpenErrorStatus,
				OUT PUINT SelectedMediumIndex,
				IN PNDIS_MEDIUM MediumArray,
				IN UINT MediumArraySize,
				IN NDIS_HANDLE MiniportAdapterHandle,
				IN NDIS_HANDLE WrapperConfigurationContext);
VOID MiniportISR(OUT PBOOLEAN InterruptRecognized,
				OUT PBOOLEAN QueueMiniportHandleInterrupt,
				IN NDIS_HANDLE MiniportAdapterContext);
NDIS_STATUS MiniportQueryInformation(IN NDIS_HANDLE MiniportAdapterContext,
				IN NDIS_OID Oid,
				IN PVOID InformationBuffer,
				IN ULONG InformationBufferLength,
				OUT PULONG BytesWritten,
				OUT PULONG BytesNeeded);
NDIS_STATUS MiniportReconfigure(OUT PNDIS_STATUS OpenErrorStatus,
				IN NDIS_HANDLE MiniportAdapterContext,
				IN NDIS_HANDLE WrapperConfigurationContext);
NDIS_STATUS MiniportReset(PBOOLEAN AddressingReset,
				NDIS_HANDLE MiniportAdapterContext);
NDIS_STATUS MiniportSend(IN NDIS_HANDLE MiniportAdapterContext,
				IN PNDIS_PACKET Packet,
				IN UINT Flags);
NDIS_STATUS MiniportSetInformation(IN NDIS_HANDLE MiniportAdapterContext,
				IN NDIS_OID Oid,
				IN PVOID InformationBuffer,
				IN ULONG InformationBufferLength,
				OUT PULONG BytesRead,
				OUT PULONG BytesNeeded);
NDIS_STATUS MiniportTransferData(OUT PNDIS_PACKET Packet,
				OUT PUINT BytesTransferred,
				IN NDIS_HANDLE MiniportAdapterContext,
				IN NDIS_HANDLE MiniportReceiveContext,
				IN UINT ByteOffset,
				IN UINT BytesToTransfer);

/*
 *  Other function externs
 */
VOID InitDevice(IrDevice *thisDev);
BOOLEAN OpenDevice(IrDevice *dev);
VOID CloseDevice(IrDevice *dev);
VOID FreeAll();
UCHAR GetCOMPort(PUCHAR comBase, comPortRegOffset portOffset);
VOID SetCOMPort(PUCHAR comBase, comPortRegOffset portOffset, UCHAR val);
PNDIS_IRDA_PACKET_INFO GetPacketInfo(PNDIS_PACKET packet);

PVOID NscMemAlloc(UINT size);
VOID NscMemFree(PVOID memptr);

IrDevice *NewDevice();
VOID FreeDevice(IrDevice *dev);
USHORT ComputeFCS(UCHAR *data, UINT dataLen);
BOOLEAN NdisToIrPacket( PNDIS_PACKET Packet,
				UCHAR *irPacketBuf, UINT irPacketBufLen,
				UINT *irPacketLen);

BOOLEAN FIR_MegaSend(IrDevice *thisDev);
BOOLEAN FIR_NewMegaSend(IrDevice *thisDev);
void TurnaroundDelay(IrDevice *thisDev);
void FIR_NewMegaSendComplete(IrDevice *thisDev);
void FIR_MegaSendComplete(IrDevice *thisDev);

BOOLEAN NSC_Setup(IrDevice *thisDev);
void NSC_Shutdown(IrDevice *thisDev);
BOOLEAN NdisToFirPacket( PNDIS_PACKET Packet,
				UCHAR *irPacketBuf, UINT irPacketBufLen,
				UINT *irPacketLen);
void FIR_DeliverFrames(IrDevice *thisDev);
VOID NSC_FIR_ISR(IrDevice *thisDev, BOOLEAN *claimingInterrupt,
				BOOLEAN *requireDeferredCallback);
BOOLEAN FindLargestSpace(IN IrDevice *thisDev,
                         OUT PULONG_PTR pOffset,
                         OUT PULONG_PTR pLength);
void SetupRecv(IrDevice *thisDev);
/*
 *  Externs for global data objects
 */
struct IrDevice;
extern struct DebugCounters RegStats;


/*
 *  From COMM.C
 */
BOOLEAN DoOpen(struct IrDevice *thisDev);
VOID DoClose(IrDevice *thisDev);
BOOLEAN DoSend(IrDevice *thisDev, PNDIS_PACKET packetToSend);
BOOLEAN SetSpeed(IrDevice *thisDev);
BOOLEAN IsCommReadyForTransmit(IrDevice *thisDev);
BOOLEAN PermissionToTransmitComm(IrDevice *thisDev);
NDIS_STATUS PortReadyForWrite(struct IrDevice *thisDev, BOOLEAN firstBufIsPending);
UINT Call_Get_System_Time();
VOID COM_ISR(struct IrDevice *thisDev, BOOLEAN *claimingInterrupt,
				BOOLEAN *requireDeferredCallback);
VOID QueueReceivePacket(struct IrDevice *thisDev, PUCHAR data, UINT dataLen, BOOLEAN IsFIR);

UINT DoRcvDirect(PUCHAR ioBase, UCHAR *data, UINT maxBytes);
VOID CloseCOM(IrDevice *thisDev);
BOOLEAN OpenCOM(IrDevice *thisDev);
VOID SetCOMInterrupts(IrDevice *thisDev, BOOLEAN enable);

VOID DelayedWrite(IN PVOID SystemSpecific1,
                  IN PVOID FunctionContext,
                  IN PVOID SystemSpecific2,
                  IN PVOID SystemSpecific3);



/*
 *  From SETTINGS.C
 */
void LogEvent(char *msg, UINT val);
void DumpLog();

extern const baudRateInfo supportedBaudRateTable[NUM_BAUDRATES];

/*
 *  From INIT.C
 */
UCHAR NSC_ReadBankReg(PUCHAR comBase, UINT bankNum, UINT regNum);
void NSC_WriteBankReg(PUCHAR comBase, UINT bankNum, UINT regNum,
				UCHAR val);

#endif EXTERNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\init.c ===
/*
 ************************************************************************
 *
 *	INIT.C
 *
 *
 * Portions Copyright (C) 1996-2001 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */


    #include "nsc.h"
    #include "newdong.h"
#include "init.tmh"


    #define  SIR      0
    #define  MIR      1
    #define  FIR      2




    #define NSC_DEMO_IRDA_SPEEDS ( NDIS_IRDA_SPEED_2400    |	   \
				   NDIS_IRDA_SPEED_2400    |	   \
				   NDIS_IRDA_SPEED_9600    |	   \
				   NDIS_IRDA_SPEED_19200   |	   \
				   NDIS_IRDA_SPEED_38400   |	   \
				   NDIS_IRDA_SPEED_57600   |	   \
				   NDIS_IRDA_SPEED_115200  |	   \
				   NDIS_IRDA_SPEED_1152K   |	   \
				   NDIS_IRDA_SPEED_4M )


    //	NSC PC87108 index registers.  See the spec for more info.
    //
    enum indexRegs {
	    BAIC_REG	    = 0,
	    CSRT_REG	    = 1,
	    MCTL_REG	    = 2,
	    GPDIR_REG	    = 3,
	    GPDAT_REG	    = 4
    };

#define CS_MODE_CONFIG_OFFSET 0x8

const UCHAR bankCode[] = { 0x03, 0x08, 0xE0, 0xE4, 0xE8, 0xEC, 0xF0, 0xF4 };

//////////////////////////////////////////////////////////////////////////
//									//
// Function :	   NSC_WriteBankReg					//
//									//
// Description: 							//
//  Write a value to the specified register of the specified register	//
//  bank.								//
//									//
//////////////////////////////////////////////////////////////////////////

void NSC_WriteBankReg(PUCHAR comBase, UINT bankNum, UINT regNum, UCHAR val)
{
    NdisRawWritePortUchar(comBase+3, bankCode[bankNum]);
    NdisRawWritePortUchar(comBase+regNum, val);

    // Always switch back to reg 0
    NdisRawWritePortUchar(comBase+3, bankCode[0]);
}

//////////////////////////////////////////////////////////////////////////
//									//
// Function :	   NSC_ReadBankReg					//
//									//
// Description: 							//
//  Write the value from the specified register of the specified	//
//  register bank.							//
//									//
//////////////////////////////////////////////////////////////////////////


UCHAR NSC_ReadBankReg(PUCHAR comBase, UINT bankNum, UINT regNum)
{
    UCHAR result;

    NdisRawWritePortUchar(comBase+3, bankCode[bankNum]);
    NdisRawReadPortUchar(comBase+regNum, &result);

    // Always switch back to reg 0
    NdisRawWritePortUchar(comBase+3, bankCode[0]);
		
    return result;
}

typedef struct _SYNC_PORT_ACCESS {

    PUCHAR    PortBase;
    UINT      BankNumber;
    UINT      RegisterIndex;
    UCHAR     Value;

} SYNC_PORT_ACCESS, *PSYNC_PORT_ACCESS;


VOID
ReadBankReg(
    PVOID     Context
    )

{
    PSYNC_PORT_ACCESS       PortAccess=(PSYNC_PORT_ACCESS)Context;

    NdisRawWritePortUchar(PortAccess->PortBase+3, bankCode[PortAccess->BankNumber]);
    NdisRawReadPortUchar(PortAccess->PortBase+PortAccess->RegisterIndex, &PortAccess->Value);

    // Always switch back to reg 0
    NdisRawWritePortUchar(PortAccess->PortBase+3, bankCode[0]);

    return;

}



VOID
WriteBankReg(
    PVOID     Context
    )

{
    PSYNC_PORT_ACCESS       PortAccess=(PSYNC_PORT_ACCESS)Context;

    NdisRawWritePortUchar(PortAccess->PortBase+3, bankCode[PortAccess->BankNumber]);
    NdisRawWritePortUchar(PortAccess->PortBase+PortAccess->RegisterIndex, PortAccess->Value);

    // Always switch back to reg 0
    NdisRawWritePortUchar(PortAccess->PortBase+3, bankCode[0]);

    return;

}


VOID
SyncWriteBankReg(
    PNDIS_MINIPORT_INTERRUPT InterruptObject,
    PUCHAR                   PortBase,
    UINT                     BankNumber,
    UINT                     RegisterIndex,
    UCHAR                    Value
    )

{
    SYNC_PORT_ACCESS        PortAccess;

    ASSERT(BankNumber <= 7);
    ASSERT(RegisterIndex <= 7);

    PortAccess.PortBase     = PortBase;
    PortAccess.BankNumber   = BankNumber;
    PortAccess.RegisterIndex= RegisterIndex;

    PortAccess.Value        = Value;

    NdisMSynchronizeWithInterrupt(
        InterruptObject,
        WriteBankReg,
        &PortAccess
        );

    return;
}

UCHAR
SyncReadBankReg(
    PNDIS_MINIPORT_INTERRUPT InterruptObject,
    PUCHAR                   PortBase,
    UINT                     BankNumber,
    UINT                     RegisterIndex
    )

{
    SYNC_PORT_ACCESS        PortAccess;

    ASSERT(BankNumber <= 7);
    ASSERT(RegisterIndex <= 7);


    PortAccess.PortBase     = PortBase;
    PortAccess.BankNumber   = BankNumber;
    PortAccess.RegisterIndex= RegisterIndex;

    NdisMSynchronizeWithInterrupt(
        InterruptObject,
        ReadBankReg,
        &PortAccess
        );

    return PortAccess.Value;
}



BOOLEAN
SyncGetDongleCapabilities(
    PNDIS_MINIPORT_INTERRUPT InterruptObject,
    UIR * Com,
    DongleParam *Dingle
    )

{
    SYNC_DONGLE    Dongle;

    Dongle.Com=Com;
    Dongle.Dingle=Dingle;

    NdisMSynchronizeWithInterrupt(
        InterruptObject,
        GetDongleCapabilities,
        &Dongle
        );

    return TRUE;

}


UINT
SyncSetDongleCapabilities(
    PNDIS_MINIPORT_INTERRUPT InterruptObject,
    UIR * Com,
    DongleParam *Dingle
    )

{
    SYNC_DONGLE    Dongle;

    Dongle.Com=Com;
    Dongle.Dingle=Dingle;


    NdisMSynchronizeWithInterrupt(
        InterruptObject,
        SetDongleCapabilities,
        &Dongle
        );

    return 0;

}


typedef struct _SYNC_FIFO_STATUS {

    PUCHAR     PortBase;
    PUCHAR     Status;
    PULONG     Length;

} SYNC_FIFO_STATUS, *PSYNC_FIFO_STATUS;

VOID
GetFifoStatus(
    PVOID     Context
    )

{
    PSYNC_FIFO_STATUS   FifoStatus=Context;

    NdisRawWritePortUchar(FifoStatus->PortBase+3, bankCode[5]);

    NdisRawReadPortUchar(FifoStatus->PortBase+FRM_ST, FifoStatus->Status);

    *FifoStatus->Length=0;

    if (*FifoStatus->Status & ST_FIFO_VALID) {

        UCHAR     High;
        UCHAR     Low;

        NdisRawReadPortUchar(FifoStatus->PortBase+RFRL_L, &Low);
        NdisRawReadPortUchar(FifoStatus->PortBase+RFRL_H, &High);

        *FifoStatus->Length =  Low;
        *FifoStatus->Length |= (ULONG)High << 8;
    }

    NdisRawWritePortUchar(FifoStatus->PortBase+3, bankCode[0]);

}

BOOLEAN
SyncGetFifoStatus(
    PNDIS_MINIPORT_INTERRUPT InterruptObject,
    PUCHAR                   PortBase,
    PUCHAR                   Status,
    PULONG                   Size
    )

{

    SYNC_FIFO_STATUS   FifoStatus;

    FifoStatus.PortBase=PortBase;
    FifoStatus.Status=Status;
    FifoStatus.Length=Size;

    NdisMSynchronizeWithInterrupt(
        InterruptObject,
        GetFifoStatus,
        &FifoStatus
        );

    return (*Status & ST_FIFO_VALID);

}


//////////////////////////////////////////////////////////////////////////
//									//
// Function :	   Ir108ConfigWrite					//
//									//
// Description: 							//
//  Write the data in the indexed register of the configuration I/O.	//
//									//
//////////////////////////////////////////////////////////////////////////

void Ir108ConfigWrite(PUCHAR configIOBase, UCHAR indexReg, UCHAR data, BOOLEAN CSMode)
{
    UCHAR IndexStore;

    if (CSMode)
    {
        NdisRawWritePortUchar(configIOBase+indexReg, data);
        NdisRawWritePortUchar(configIOBase+indexReg, data);
    }
    else
    {
        NdisRawReadPortUchar(configIOBase, &IndexStore);
        NdisRawWritePortUchar(configIOBase, indexReg);
        NdisRawWritePortUchar(configIOBase+1, data);
        NdisRawWritePortUchar(configIOBase+1, data);
        NdisRawWritePortUchar(configIOBase, IndexStore);
    }
}

//////////////////////////////////////////////////////////////////////////
//									//
// Function :	   Ir108ConfigRead					//
//									//
// Description: 							//
//  Read the data in the indexed register of the configuration I/O.	//
//									//
//////////////////////////////////////////////////////////////////////////

UCHAR Ir108ConfigRead(PUCHAR  configIOBase, UCHAR indexReg, BOOLEAN CSMode)
{
    UCHAR data,IndexStore;

    if (CSMode)
    {
        NdisRawReadPortUchar(configIOBase+indexReg, &data);
    }
    else
    {
        NdisRawReadPortUchar(configIOBase, &IndexStore);
        NdisRawWritePortUchar(configIOBase, indexReg);
        NdisRawReadPortUchar(configIOBase+1, &data);
        NdisRawWritePortUchar(configIOBase, IndexStore);
    }
    return (data);
}

//////////////////////////////////////////////////////////////////////////
//									//
// Function :	   NSC_DEMO_Init					//
//									//
// Description: 							//
//  Set up configuration registers for NSC evaluation board.		//
//									//
// NOTE:								//
//  Assumes configuration registers are at I/O addr 0x398.		//
//  This function configures the demo board to make the SIR UART appear //
//  at <comBase>.							//
//									//
//  Called By:								//
//  OpenCom								//
//////////////////////////////////////////////////////////////////////////

BOOLEAN NSC_DEMO_Init(IrDevice *thisDev)
{
    UCHAR val;
    UCHAR FifoClear;
    BOOLEAN CSMode = FALSE;
    switch(thisDev->CardType){
    case PUMA108:
        CSMode = TRUE;
        thisDev->portInfo.ConfigIoBaseAddr = thisDev->portInfo.ioBase + CS_MODE_CONFIG_OFFSET;

	case PC87108:
	    // Look for id at startup.
        if (!CSMode)
        {
            NdisRawReadPortUchar(thisDev->portInfo.ConfigIoBaseAddr, &val);
            if (val != 0x5A){
                if (val == (UCHAR)0xff){
                    DBGERR(("didn't see PC87108 id (0x5A); got ffh."));
                    return FALSE;
                }
                else {
                    //	ID only appears once, so in case we're resetting,
                    //	don't fail if we don't see it.
                    DBGOUT(("WARNING: didn't see PC87108 id (0x5A); got %xh.",
                         (UINT)val));
                }
            }
        }

        if (CSMode)
        {
            // base address ignored.
            val = 0;
        }
        else
        {
            // Select the base address for the UART
            switch ((DWORD_PTR)thisDev->portInfo.ioBase){
            case 0x3E8:	    val = 0;	    break;
            case 0x2E8:	    val = 1;	    break;
            case 0x3F8:	    val = 2;	    break;
            case 0x2F8:	    val = 3;	    break;
            default:	    return FALSE;
            }
        }
	    val |= 0x04;	// enable register banks
	    val |= 0x10;	// Set the interrupt line to Totempole output.
        Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, BAIC_REG, val, CSMode);

	    //	 Select interrupt level according to base address,
	    //	 following COM port mapping.
	    //	 Also select MIR/FIR DMA channels for rcv and xmit.
	    //
	    switch (thisDev->portInfo.irq){
		case 3:     val = 1;	    break;
		case 4:     val = 2;	    break;
		case 5:     val = 3;	    break;
		case 7:     val = 4;	    break;
		case 9:     val = 5;	    break;
		case 11:    val = 6;	    break;
		case 15:    val = 7;	    break;
		default:    return FALSE;
	    }

	    switch (thisDev->portInfo.DMAChannel){
		case 0: 		    val |= 0x08;    break;
		case 1: 		    val |= 0x10;    break;
		case 3: 		    val |= 0x18;    break;
		default:
		    DBGERR(("Bad rcv dma channel in NSC_DEMO_Init"));
		    return FALSE;
	    }

	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, CSRT_REG, val, CSMode);

	    // Select device-enable and normal-operating-mode.
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, MCTL_REG, (UCHAR)3, CSMode);
	    break;

/*
	case PC87307:
	    //
	    //	Select Logical Device 5
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x7, 0x5);

	    // Disable IO check
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,0x31,0x0);

	    // Config Base address low and high.
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,
			     0x61,(UCHAR)(thisDev->portInfo.ioBase));
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,
			     0x60,(UCHAR)(thisDev->portInfo.ioBase >> 8));

	    // Set IRQ
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,
			     0x70,(UCHAR)thisDev->portInfo.irq);
			
	    // Enable Bank Select
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,0xF0,0x82);

	    // Enable UIR
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,0x30,0x1);
	    break;

*/
	case PC87308:

	    //	Select Logical Device 5
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x7, 0x5, FALSE);
			
	    // Disable IO check
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,0x31,0x0, FALSE);

	    // Config Base address low and high.
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,
			     0x61,(UCHAR)(thisDev->portInfo.ioBasePhys), FALSE);
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,
			     0x60,(UCHAR)(thisDev->portInfo.ioBasePhys >> 8), FALSE);

	    // Set IRQ
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,
			     0x70,(UCHAR)thisDev->portInfo.irq, FALSE);
			
	    // Select DMA Channel
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,
			     0x74,thisDev->portInfo.DMAChannel, FALSE);

	    // DeSelect TXDMA Channel
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,0x75,0x4, FALSE);

	    // Enable Bank Select
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,0xF0,0x82, FALSE);


	    // Enable UIR
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr,0x30,0x1, FALSE);
	    break;

	case PC87338:
	    // Select Plug and Play mode.
	    val = Ir108ConfigRead(thisDev->portInfo.ConfigIoBaseAddr, 0x1B, FALSE);
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x1B,
			     (UCHAR)(val | 0x08), FALSE);

	    // Write the new Plug and Play UART IOBASE register.
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x46,
			     (UCHAR)((thisDev->portInfo.ioBasePhys>>2) & 0xfe), FALSE);
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x47,
			     (UCHAR)((thisDev->portInfo.ioBasePhys>>8) & 0xfc), FALSE);

	    // Enable 14 Mhz clock + Clk Multiplier
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x51, 0x04, FALSE);

	    // Get Interrup line and shift it four bits;
	    //
	    val = thisDev->portInfo.irq << 4;

	    // Read the Current Plug and Play Configuration 1 register.
	    //
	    val |= Ir108ConfigRead(thisDev->portInfo.ConfigIoBaseAddr,0x1C, FALSE);
		
	    // Write the New Plug and Play Configuration 1 register.
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x1C, val, FALSE);
			
	    // Setup 338 DMA.
	    //
	    switch (thisDev->portInfo.DMAChannel){
		case 0: 		val = 0x01;	break;
		case 1: 		val = 0x02;	break;
		case 2: 		val = 0x03;	break;
		case 3:

		    // Read the Current Plug and Play Configuration 3 register.
		    //
		    val = Ir108ConfigRead(
				thisDev->portInfo.ConfigIoBaseAddr,0x50, FALSE) | 0x01;

		    // Write the new Plug and Play Configuration 3 register.
		    //
		    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x50,
				     val, FALSE);

		    // Read the Current Plug and Play Configuration 3 register.
		    //
		    val = Ir108ConfigRead(
			       thisDev->portInfo.ConfigIoBaseAddr,0x4C, FALSE) | 0x80;

		    // Write the new Plug and Play Configuration 3 register.
		    //
		    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x4C,
				     val, FALSE);
		    val = 0x04;
		    break;

		default:
		    DBGERR(("Bad rcv dma channel in NSC_DEMO_Init"));
		    return FALSE;
	    }

	    // Write the new Plug and Play Configuration 3 register.
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x4F, val, FALSE);

	    // Read the Current SuperI/O Configuration Register 2 register.
	    //
	    val = Ir108ConfigRead(thisDev->portInfo.ConfigIoBaseAddr,0x40, FALSE);

	    // Set up UIR/UART2 for Normal Power Mode and Bank select enable.
	    //
	    val |= 0xE0;

	    // Write the New SuperI/O Configuration Register 2 register.
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x40, val, FALSE);


	    // Read the Current SuperI/O Configuration Register 3 register.
	    //
	    val = Ir108ConfigRead(thisDev->portInfo.ConfigIoBaseAddr,0x50, FALSE);

	    // Set up UIR/UART2 IRX line
	    //
	    val |= 0x0C;

	    // Write the New SuperI/O Configuration Register 3 register.
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x50, val, FALSE);
		
	    // Set the SIRQ1 int to DRQ3 ??? only for EB
	    //val = Ir108ConfigRead(thisDev->portInfo.ConfigIoBaseAddr,0x4c) & 0x3f;
	    //Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x4c, val | 0x80);


	    // Read the Current Function Enable register.
	    //
	    val = Ir108ConfigRead(thisDev->portInfo.ConfigIoBaseAddr,0x00, FALSE);

	    // Enable UIR/UART2.
	    //
	    val |= 0x04;

	    // Write the New Function Enable register.
	    //
	    Ir108ConfigWrite(thisDev->portInfo.ConfigIoBaseAddr, 0x00, val, FALSE);
	    break;


    } // End of Evaluation board configuration setction.

    thisDev->UIR_ModuleId = NSC_ReadBankReg(thisDev->portInfo.ioBase, 3, 0);

    if (thisDev->UIR_ModuleId<0x20)
    {
        // Older revs of the NSC hardware seem to handle 1MB really poorly.
        thisDev->AllowedSpeedMask &= ~NDIS_IRDA_SPEED_1152K;
    }

    // The UART doesn't appear until we clear and set the FIFO control
    // register.

    NdisRawWritePortUchar(thisDev->portInfo.ioBase+2, (UCHAR)0x00);
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+2, (UCHAR)0x07);

    // Set FIR CRC to 32 bits.
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 6, 0, 0x20);

    // Switch to bank 5
    // clear the status FIFO
    //
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+3, (UCHAR)0xEC);
    FifoClear = 8;
    do {
	NdisRawReadPortUchar(thisDev->portInfo.ioBase+6, &val);
	NdisRawReadPortUchar(thisDev->portInfo.ioBase+7, &val);
	NdisRawReadPortUchar(thisDev->portInfo.ioBase+5, &val);
	FifoClear--;
    } while( (val & 0x80) && (FifoClear > 0) );

    // Test for newer silicon for support of Frame stop mode

#if 0
    if (thisDev->UIR_Mid < 0x16)
	// Change Bit 1 to Default 1
	//  0x40 -> 0x42
#endif
	NSC_WriteBankReg(thisDev->portInfo.ioBase, 5, 4, 0x40);
#if 0  // Since we're not currently using the multi-packet send, we don't use frame stop mode.
    else
	//
	// Set FIFO threshold and TX_MS Tx frame end stop mode.
	//
	// Change Bit 1 to Default 1
	//	0x68 -> 0x6a
	NSC_WriteBankReg(thisDev->portInfo.ioBase, 5, 4, 0x60);
#endif

    // Set SIR mode in IRCR1.
    // Enable SIR infrared mode in the Non-Extended mode of operation
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 4, 2, 0x0C);

    // Set max xmit frame size.
    // Need to set value slightly larger so that counter never
    // reaches 0.
    //
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 4, 4,
			 (UCHAR)(MAX_NDIS_DATA_SIZE+1));
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 4, 5,
			 (UCHAR)((MAX_NDIS_DATA_SIZE+1) >> 8));

    // Set max rcv frame size.
    // Need to set value slightly larger so that counter never
    // reaches 0.
    //
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 4, 6,
			 (UCHAR)(MAX_RCV_DATA_SIZE+FAST_IR_FCS_SIZE));
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 4, 7,
			 (UCHAR)((MAX_RCV_DATA_SIZE+FAST_IR_FCS_SIZE) >> 8));

    // Set extended mode
    //
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 2, 2, 0x03);

    // Set 32-bit FIFOs
    //
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 2, 4, 0x05);

    // Enable and reset FIFO's and set the receive FIF0
    // equal to the receive DMA threshold. See if DMA
    // is fast enough for device.
    //
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 0, 2, 0x07);

    // Restore to Non-Extended mode
    //
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 2, 2, 0x02);


    thisDev->portInfo.hwCaps.supportedSpeedsMask = NSC_DEMO_IRDA_SPEEDS;
    thisDev->portInfo.hwCaps.turnAroundTime_usec = DEFAULT_TURNAROUND_usec;
    thisDev->portInfo.hwCaps.extraBOFsRequired = 0;

    // Initialize thedongle structure before calling
    // GetDongleCapabilities and SetDongleCapabilities for dongle 1.
    //
    thisDev->currentDongle = 1;
    thisDev->IrDongleResource.Signature = thisDev->DongleTypes[thisDev->currentDongle];

    thisDev->IrDongleResource.ComPort = thisDev->portInfo.ioBase;
    thisDev->IrDongleResource.ModeReq = SIR;
    thisDev->IrDongleResource.XcvrNum = thisDev->currentDongle;

//    IrDongle = GetDongleCapabilities(thisDev->IrDongleResource);
    SyncGetDongleCapabilities(&thisDev->interruptObj,&thisDev->IrDongleResource,&thisDev->Dingle[0]);

    // Initialize thedongle structure before calling
    // GetDongleCapabilities and SetDongleCapabilities for dongle 0.
    //
    thisDev->currentDongle = 0;
    thisDev->IrDongleResource.Signature = thisDev->DongleTypes[thisDev->currentDongle];

    thisDev->IrDongleResource.ComPort = thisDev->portInfo.ioBase;
    thisDev->IrDongleResource.ModeReq = SIR;
    thisDev->IrDongleResource.XcvrNum = 0;

//    IrDongle = GetDongleCapabilities(IrDongleResource);
    SyncGetDongleCapabilities(&thisDev->interruptObj,&thisDev->IrDongleResource,&thisDev->Dingle[0]);

    SyncSetDongleCapabilities(&thisDev->interruptObj,&thisDev->IrDongleResource,&thisDev->Dingle[0]);
	
    return TRUE;
}

#if 1
//////////////////////////////////////////////////////////////////////////
//									//
// Function:	NSC_DEMO_Deinit 					//
//									//
//  DUMMY ROUTINE							//
//////////////////////////////////////////////////////////////////////////

VOID NSC_DEMO_Deinit(PUCHAR comBase, UINT context)
{
		
}
#endif
//////////////////////////////////////////////////////////////////////////
//									//
// Function:	NSC_DEMO_SetSpeed					//
//									//
// Description: 							//
//  Set up the size of FCB, the timer, FIFO, DMA and the IR mode/dongle //
//  speed based on the negotiated speed.				//
//									//
//////////////////////////////////////////////////////////////////////////

BOOLEAN NSC_DEMO_SetSpeed(
    IrDevice *thisDev,
    PUCHAR comBase,
    UINT bitsPerSec,
    UINT context)
{
    NDIS_STATUS stat;
    UINT fcsSize;

    LOG("==>NSC_DEMO_SetSpeed %d",bitsPerSec);

    if (thisDev->FirReceiveDmaActive) {

        thisDev->FirReceiveDmaActive=FALSE;
        //
        //  receive dma is running, stop it
        //
        CompleteDmaTransferFromDevice(
            &thisDev->DmaUtil
            );

    }


    // Make sure the previous packet completely sent out(Not in the TX FIFO)
    // and Txmitter is empty
    // before the bandwidth control



    while((SyncReadBankReg(&thisDev->interruptObj, comBase, 0, 5)& 0x60) != 0x60);

    //

    if (bitsPerSec > 115200){

    	fcsSize = (bitsPerSec >= MIN_FIR_SPEED) ?
    		   FAST_IR_FCS_SIZE : MEDIUM_IR_FCS_SIZE;

    	if(bitsPerSec >= MIN_FIR_SPEED)
    	    thisDev->IrDongleResource.ModeReq = FIR;
    	else
    	    thisDev->IrDongleResource.ModeReq = MIR;

    	SyncSetDongleCapabilities(&thisDev->interruptObj,&thisDev->IrDongleResource,&thisDev->Dingle[0]);


    	// Set extended mode and set DMA fairness.
    	//
    	SyncWriteBankReg(&thisDev->interruptObj, comBase, 2, 2, 0x03);

    	if (thisDev->UIR_ModuleId < 0x16){

    	    //	Set Timer registers.
    	    //
    	    SyncWriteBankReg(&thisDev->interruptObj, comBase, 4, 0, (UCHAR)0x2);
    	    SyncWriteBankReg(&thisDev->interruptObj, comBase, 4, 1, (UCHAR)0x0);
    	}
    	else {

    	    //	Set Timer registers timer has 8 times finer
    	    //	resolution.
    	    //
            SyncWriteBankReg(&thisDev->interruptObj, comBase, 4, 0, (UCHAR)(TIMER_PERIODS & 0xff));
            SyncWriteBankReg(&thisDev->interruptObj, comBase, 4, 1, (UCHAR)(TIMER_PERIODS >> 8));

    	}

    	// Set max rcv frame size.
    	// Need to set value slightly larger so that counter never reaches 0.
    	//
    	DBGERR(("Programming Max Receive Size registers with %d Bytes ",
    						 MAX_RCV_DATA_SIZE+fcsSize));
    	SyncWriteBankReg(&thisDev->interruptObj, comBase, 4, 6, (UCHAR)(MAX_RCV_DATA_SIZE+fcsSize));
    	SyncWriteBankReg(&thisDev->interruptObj, comBase, 4, 7,
    				 (UCHAR)((MAX_RCV_DATA_SIZE+fcsSize) >> 8));


    	// Reset Timer Enable bit.
    	//
    	SyncWriteBankReg(&thisDev->interruptObj, comBase, 4, 2, 0x00);

    	// Set MIR/FIR mode and DMA enable
    	//
    	SyncWriteBankReg(&thisDev->interruptObj, comBase, 0, 4,
    			 (UCHAR)((bitsPerSec >= 4000000) ? 0xA4 : 0x84));

    	DBGERR(("EXCR2= 0x%x",SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 2, 4)));

    	// Set 32-bit FIFOs
    	//
    	SyncWriteBankReg(&thisDev->interruptObj, comBase, 2, 4, 0x05);
    	DBGERR(("EXCR2= 0x%x",SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 2, 4)));

    	//
    	// We may start receiving immediately so setup the
    	// receive DMA
    	//


#if 0
    	// First, tear down any existing DMA
    	if (thisDev->FirAdapterState==ADAPTER_RX) {

            thisDev->FirAdapterState=ADAPTER_NONE;

            CompleteDmaTransferFromDevice(
                &thisDev->DmaUtil
                );
    	}

        FindLargestSpace(thisDev, &thisDev->rcvDmaOffset, &thisDev->rcvDmaSize);

    	SetupRecv(thisDev);


    	// Set the interrupt mask to interrupt on the
    	// first packet received.
    	//
    	thisDev->IntMask = 0x04;
    	DBGOUT(("RxDMA = ON"));
#endif
    }
    else {

    	// Set SIR mode in UART before setting the timing of transciever
    	//

    	// Set SIR mode
    	//
    	SyncWriteBankReg(&thisDev->interruptObj, comBase, 4, 2, 0x0C);

    	// Must set SIR Pulse Width Register to 0 (3/16) as default
    	// Bug in 338/108
    	SyncWriteBankReg(&thisDev->interruptObj, comBase, 6, 2, 0x0);

    	// Clear extended mode
    	//
    	SyncWriteBankReg(&thisDev->interruptObj, comBase, 2, 2, 0x00);


    	thisDev->IrDongleResource.ModeReq = SIR;
    	SyncSetDongleCapabilities(&thisDev->interruptObj,&thisDev->IrDongleResource,&thisDev->Dingle[0]);


    	// Clear Line and Auxiluary status registers.
    	//
    	SyncReadBankReg(&thisDev->interruptObj, comBase, 0, 5);
    	SyncReadBankReg(&thisDev->interruptObj, comBase, 0, 7);

    }
    LOG("<==NSC_DEMO_SetSpeed");
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\newdong.h ===
/*

// This header file describes the data structure for the Dongle
// Author  : Kishor Padmanabhan
// Company : National Semiconductor Corp.
// Date    : 10 Sept 1996

 * Portions Copyright (C) 1996-2001 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.

*/


#include "defs.h"


#ifndef   DONGLE
#define   DONGLE

// This is the structure which descibes  Dongle capabilities
//
// This is a 12 word structure with bit fields defined by the specs to be soon
// published by Franco Iacobelli
// There is an extra field for the OEM differentiation.
//
typedef  struct Dingle
{
    union {
	UINT	 Data;
	struct
	{
	    UINT	   DSVFLAG:1;
	    UINT	   IADP:1;
	    UINT	   MVFLAG:1;
	    UINT	   Reserved:2;
	    UINT	   GCERR:3;
	    UINT	   NumPorts:2;
	    UINT	   TrcvrCode:5;
	    UINT	   Reserved2:1;
	} bits;
    } WORD0;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  CurSelMode;
	} bits;
    } WORD1;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  Reserved;
	} bits;
    } WORD2;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  LowPower:1;
	    UINT	  TxDefPwrLevel:3;
	    UINT	  RxDefSensitivity:3;
	    UINT	  CirDemod:1;
	    UINT	  Reserved:8;
	} bits;
    } WORD3;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  SirRxRecoveryTime:6;
	    UINT	  IrRecoveryTimeUnits:2;
	    UINT	  Reserved:8;
	} bits;
    } WORD4;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  Reserved;
	} bits;
    } WORD5;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  SirRxStability:8;
	    UINT	  Reserved:8;
	} bits;
    } WORD6;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  SIR:1;
	    UINT	  MIR:1;
	    UINT	  FIR:1;
	    UINT	  Sharp_IR:1;
	    UINT	  Reserved:8;
	    UINT	  CirOvrLowSpeed:1;
	    UINT	  CirOvrMedSpeed:1;
	    UINT	  CirOvrHiSpeed:1;
	} bits;
    } WORD7;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  Reserved:2;
	    UINT	  Cir30k:1;
	    UINT	  Cir31k:1;
	    UINT	  Cir32k:1;
	    UINT	  Cir33k:1;
	    UINT	  Cir34k:1;
	    UINT	  Cir35k:1;
	    UINT	  Cir36k:1;
	    UINT	  Cir37k:1;
	    UINT	  Cir38k:1;
	    UINT	  Cir39k:1;
	    UINT	  Cir40k:1;
	    UINT	  Cir41k:1;
	    UINT	  Cir42k:1;
	    UINT	  Cir43k:1;
	} bits;
    } WORD8;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  Cir44k:1;
	    UINT	  Cir45k:1;
	    UINT	  Cir46k:1;
	    UINT	  Cir47k:1;
	    UINT	  Cir48k:1;
	    UINT	  Cir49k:1;
	    UINT	  Cir50k:1;
	    UINT	  Cir51k:1;
	    UINT	  Cir52k:1;
	    UINT	  Cir53k:1;
	    UINT	  Cir54k:1;
	    UINT	  Cir55k:1;
	    UINT	  Cir56k:1;
	    UINT	  Cir57k:1;
	    UINT	  Reserved:3;
	} bits;
    } WORD9;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  Reserved:1;
	    UINT	  Cir450k:1;
	    UINT	  Cir480k:1;
	    UINT	  Reserved2:13;
	} bits;
    } WORD10;

    union {
	UINT	 Data;
	struct
	{
	    UINT	  Reserved;
	} bits ;
    } WORD11;

    UINT   PlugPlay; // Describes whether dongle is a plug and play or not


} DongleParam;	    // Assuming two ports

enum PwMode{NORMAl,LOWPOWER};


// The structure pre-requisite for calling the Get Capabilities
//
typedef struct
{
    char *  ComPort;	// Address of the com port
    UINT    Signature;	// Two byte value
    UINT    XcvrNum;	// Defaults to 0. In case, there are more than 1 port
    UINT    ModeReq;	// IR Mode request.
    enum    PwMode  Power;
} UIR;


// Error Codes
#define      XCVR_DISCONNECT	2
#define	     UNIMPLEMENTED	3


#define	     UNSUPPORTED	4
#define      ERROR_GETCAPAB     5


// Define Adapter code

#define 	PC87108 	0x0
#define 	PC87308 	0x1
#define 	PC87338 	0x2
#define 	PNPUIR		0x3
#define 	PC87560 	0x8
#define     PUMA108     0x4

//


// Define Dongle Manufactures Code
#define	 NoDongle     0x000F //No dongle connected - Not used anymore
#define  SirOnly      0x000E //SIR only dongle
#define	 PnpDong      0x8000 //Plug-n-Play dongle
#define  Hp1100	      0x000C //HP HSDL-1100/2100, TI TSLM1100, Sharp RY6FD11E/RY6FD1SE

#define  Hp2300	      0x0008 //HP HSDL_2300/3600
#define  Temic6000    0x0009 //TEMIC TFDS-6000, IBM31T1100, Siemens IRMS/T6400
#define  Temic6500    0x000B //TEMIC TFDS-6500
#define  SharpRY5HD01 0x0004 //SHARP RY5HD01/RY5KD01

#define  Dell1997     0x0010 //DELL Titanium (dual xcvr)
#define  Ibm20H2987   0x0011 //IBM SouthernCross (dual xcvr)

//
// Valid types of dongle, this has to be correlated with INF.
//
#define VALID_DONGLETYPES \
    {                     \
        SirOnly,          \
        Hp1100,           \
        Hp2300,           \
        Temic6000,        \
        SharpRY5HD01,     \
        Hp1100,           \
        Temic6000,        \
        Temic6500,        \
        Temic6000,        \
        Hp1100,           \
        Ibm20H2987,       \
        Dell1997          \
    }

// Bank Selection patterns for the register BSR
//
#ifdef NDIS50_MINIPORT

#define  BANK0	       0x0
#define  BANK1	       0x1
#define  BANK2	       0x2
#define  BANK3	       0x3
#define  BANK4	       0x4
#define  BANK5	       0x5
#define  BANK6	       0x6
#define  BANK7	       0x7
#define  ALL	       0x8
#else

#define  BANK0	       0x03
#define  BANK1	       0x80
#define  BANK2	       0xE0
#define  BANK3	       0xE4
#define  BANK4	       0xE8
#define  BANK5	       0xEC
#define  BANK6	       0xF0
#define  BANK7	       0xF4
#define  ALL	       0xFF
#endif

// Recovery and Stabilization table
//
#define   HpRecovery        (UINT)0x05
#define   TemicRecovery     (UINT)0x05
#define   SharpRecovery     (UINT)0x05
#define   HpBofs	    (UINT)8
#define   TemicBofs	    (UINT)8
#define   SharpBofs	    (UINT)12

typedef struct _SYNC_DONGLE {

    UIR * Com;
    DongleParam *Dingle;

} SYNC_DONGLE, *PSYNC_DONGLE;


// Putting all the stuff required for the dongle stuff in one place
DongleParam *GetDongleCapabilities(PSYNC_DONGLE SyncDongle);

int SetDongleCapabilities(PSYNC_DONGLE SyncDongle);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\nsc.c ===
/*
 ************************************************************************
 *
 *	NSC.c
 *
 *
 * Portions Copyright (C) 1996-2001 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */

#include "nsc.h"
#include "nsc.tmh"
/*
 *  We keep a linked list of device objects
 */

/* This fuction sets up the device for Recv */
void SetupRecv(IrDevice *thisDev);

//
// Debug Counters
//
DebugCounters RegStats = {0,0,0,0,0,0,0,0,0};


ULONG   DebugSpeed=0;

#ifdef RECEIVE_PACKET_LOGGING

typedef struct {
    UCHAR Data[12];
} DATA_BITS;


typedef struct {
    USHORT Tag;
    USHORT Line;
    union {
        struct {
            PNDIS_PACKET    Packet;
            PVOID           DmaBuffer;
            ULONG           Length;
        } Packet;
        struct {
            PLIST_ENTRY     Head;
            PLIST_ENTRY     Entry;
        } List;
        struct {
            PVOID           Start;
            ULONG           Offset;
            ULONG           Length;
        } Dma;
        struct {
            ULONG           Length;
        } Discard;
        DATA_BITS Data;
    };
} RCV_LOG;

#define CHAIN_PACKET_TAG 'CP'
#define UNCHAIN_PACKET_TAG 'UP'
#define ADD_HEAD_LIST_TAG 'HA'
#define ADD_TAIL_LIST_TAG 'TA'
#define REMOVE_HEAD_LIST_TAG 'HR'
#define REMOVE_ENTRY_TAG 'ER'
#define DMA_TAG  'MD'
#define DATA_TAG 'AD'
#define DATA2_TAG '2D'
#define DISCARD_TAG 'XX'

#define NUM_RCV_LOG 256

ULONG   RcvLogIndex = 0;
RCV_LOG RcvLog[NUM_RCV_LOG];


BOOLEAN SyncGetRcvLogEntry(PVOID Context)
{
    *(ULONG*)Context = RcvLogIndex++;
    RcvLogIndex &= NUM_RCV_LOG-1;
    return TRUE;
}

ULONG GetRcvLogEntry(IrDevice *thisDev)
{
    ULONG Entry;

    NdisAcquireSpinLock(&thisDev->QueueLock);
    NdisMSynchronizeWithInterrupt(&thisDev->interruptObj, SyncGetRcvLogEntry, &Entry);
    NdisReleaseSpinLock(&thisDev->QueueLock);
    return Entry;
}




#define LOG_InsertHeadList(d, h, e)         \
{                                           \
    ULONG i = GetRcvLogEntry(d);            \
    RcvLog[i].Tag = ADD_HEAD_LIST_TAG;      \
    RcvLog[i].Line = __LINE__;              \
    RcvLog[i].List.Head = (h);                   \
    RcvLog[i].List.Entry = (PLIST_ENTRY)(e);                  \
}

#define LOG_InsertTailList(d, h, e)         \
{                                           \
    ULONG i = GetRcvLogEntry(d);            \
    RcvLog[i].Tag = ADD_TAIL_LIST_TAG;      \
    RcvLog[i].Line = __LINE__;              \
    RcvLog[i].List.Head = (h);              \
    RcvLog[i].List.Entry = (PLIST_ENTRY)(e);             \
}

#define LOG_RemoveHeadList(d, h, e)         \
{                                           \
    ULONG i = GetRcvLogEntry(d);            \
    RcvLog[i].Tag = REMOVE_HEAD_LIST_TAG;      \
    RcvLog[i].Line = __LINE__;              \
    RcvLog[i].List.Head = (h);              \
    RcvLog[i].List.Entry = (PLIST_ENTRY)(e);             \
}

#define LOG_RemoveEntryList(d, e)           \
{                                           \
    ULONG i = GetRcvLogEntry(d);            \
    RcvLog[i].Tag = REMOVE_ENTRY_TAG;       \
    RcvLog[i].Line = __LINE__;              \
    RcvLog[i].List.Head = NULL;             \
    RcvLog[i].List.Entry = (PLIST_ENTRY)(e);             \
}

#define LOG_PacketChain(d, p)                                   \
{                                                               \
    PNDIS_BUFFER NdisBuffer;                                    \
    PVOID Address;                                              \
    ULONG Len;                                                  \
    ULONG i = GetRcvLogEntry(d);                                \
    RcvLog[i].Tag = CHAIN_PACKET_TAG;                           \
    RcvLog[i].Line = __LINE__;                                  \
    NdisQueryPacket((p), NULL, NULL, &NdisBuffer, NULL);        \
    NdisQueryBufferSafe(NdisBuffer, &Address, &Len,NormalPagePriority);                \
    RcvLog[i].Packet.Packet = (p);                              \
    RcvLog[i].Packet.DmaBuffer = Address;                       \
    RcvLog[i].Packet.Length = Len;                              \
}

#define LOG_PacketUnchain(d, p)                                 \
{                                                               \
    PNDIS_BUFFER NdisBuffer;                                    \
    PVOID Address;                                              \
    ULONG Len;                                                  \
    ULONG i = GetRcvLogEntry(d);                                \
    RcvLog[i].Tag = UNCHAIN_PACKET_TAG;                         \
    RcvLog[i].Line = __LINE__;                                  \
    NdisQueryPacket((p), NULL, NULL, &NdisBuffer, NULL);        \
    NdisQueryBufferSafe(NdisBuffer, &Address, &Len,NormalPagePriority);                \
    RcvLog[i].Packet.Packet = (p);                              \
    RcvLog[i].Packet.DmaBuffer = Address;                       \
    RcvLog[i].Packet.Length = Len;                              \
}

#define LOG_Dma(d)                                              \
{                                                               \
    ULONG i = GetRcvLogEntry(d);                                \
    RcvLog[i].Tag = DMA_TAG;                                    \
    RcvLog[i].Line = __LINE__;                                  \
    RcvLog[i].Dma.Start = (d)->rcvDmaBuffer;                    \
    RcvLog[i].Dma.Offset = (d)->rcvDmaOffset;                   \
    RcvLog[i].Dma.Length = (d)->rcvDmaSize;                     \
}

#define LOG_Data(d,s)                                           \
{                                                               \
    ULONG i = GetRcvLogEntry(d);                                \
    RcvLog[i].Tag = DATA_TAG;                                   \
    RcvLog[i].Line = ((USHORT)(s))&0xffff;                      \
    RcvLog[i].Data = *(DATA_BITS*)(s);                          \
}

#define LOG_Data2(d,s)                                           \
{                                                               \
    ULONG i = GetRcvLogEntry(d);                                \
    RcvLog[i].Tag = DATA2_TAG;                                   \
    RcvLog[i].Line = ((USHORT)(s))&0xffff;                      \
    RcvLog[i].Data = *(DATA_BITS*)(s);                          \
}

#define LOG_Discard(d,s)                                        \
{                                                               \
    ULONG i = GetRcvLogEntry(d);                                \
    RcvLog[i].Tag = DISCARD_TAG;                                \
    RcvLog[i].Line = __LINE__;                                  \
    RcvLog[i].Discard.Length = (s);                             \
}

void DumpNdisPacket(PNDIS_PACKET Packet, UINT Line)
{
    UINT PhysBufCnt, BufCnt, TotLen, Len;
    PNDIS_BUFFER NdisBuffer;
    PVOID Address;

    DbgPrint("Badly formed NDIS packet at line %d\n", Line);

    NdisQueryPacket(Packet, &PhysBufCnt, &BufCnt, &NdisBuffer, &TotLen);
    DbgPrint("Packet:%08X  PhysBufCnt:%d BufCnt:%d TotLen:%d\n",
             Packet, PhysBufCnt, BufCnt, TotLen);
    while (NdisBuffer)
    {
        NdisQueryBufferSafe(NdisBuffer, &Address, &Len,NormalPagePriority);
        DbgPrint("   Buffer:%08X Address:%08X Length:%d\n",
                 NdisBuffer, Address, Len);
        NdisGetNextBuffer(NdisBuffer, &NdisBuffer);
    }
    ASSERT(0);
}

#define VerifyNdisPacket(p, b) \
{                                                       \
    UINT BufCnt;                                        \
                                                        \
    NdisQueryPacket((p), NULL, &BufCnt, NULL, NULL);    \
    if (BufCnt>(b))                                     \
    {                                                   \
        DumpNdisPacket((p), __LINE__);                  \
    }                                                   \
}
#else
#define VerifyNdisPacket(p,b)
#define LOG_InsertHeadList(d, h, e)
#define LOG_InsertTailList(d, h, e)
#define LOG_RemoveHeadList(d, h, e)
#define LOG_RemoveEntryList(d, e)
#define LOG_PacketChain(d, p)
#define LOG_PacketUnchain(d, p)
#define LOG_Dma(d)
#define LOG_Data(d,s)
#define LOG_Data2(d,s)
#define LOG_Discard(d,s)
#endif

BOOLEAN
VerifyHardware(
    IrDevice *thisDev
    );


/*
 *************************************************************************
 *  MiniportCheckForHang
 *************************************************************************
 *
 *  Reports the state of the network interface card.
 *
 */
BOOLEAN MiniportCheckForHang(NDIS_HANDLE MiniportAdapterContext)
{
    IrDevice *thisDev = CONTEXT_TO_DEV(MiniportAdapterContext);
//    LOG("==> MiniportCheckForHang");
    DBGOUT(("==> MiniportCheckForHang(0x%x)", MiniportAdapterContext));

    // We have seen cases where we hang sending at high speeds.  This occurs only
    // on very old revisions of the NSC hardware.
    // This is an attempt to kick us off again.

    NdisDprAcquireSpinLock(&thisDev->QueueLock);

    if (thisDev->FirTransmitPending) {

        switch (thisDev->HangChk)
        {
            case 0:
                break;

            default:
                DBGERR(("NSCIRDA: CheckForHang--we appear hung\n"));
                LOG_ERROR("CheckForHang--we appear hung\n");

                // Issue a soft reset to the transmitter & receiver.

                SyncWriteBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 0, 2, 0x06);

                //
                //  turn the timer on and let it gnerate an interrupt
                //
                thisDev->FirIntMask = 0x90;
                SyncWriteBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 4, 2, 0x01);
                SyncSetInterruptMask(thisDev, TRUE);

                break;
        }
        thisDev->HangChk++;
    }

    NdisDprReleaseSpinLock(&thisDev->QueueLock);

//    LOG("<== MiniportCheckForHang");
    DBGOUT(("<== MiniportCheckForHang(0x%x)", MiniportAdapterContext));
    return FALSE;
}


/*
 *************************************************************************
 *  MiniportHalt
 *************************************************************************
 *
 *  Halts the network interface card.
 *
 */
VOID MiniportHalt(IN NDIS_HANDLE MiniportAdapterContext)
{
    IrDevice *thisDev = CONTEXT_TO_DEV(MiniportAdapterContext);

    LOG("==> MiniportHalt");
    DBGOUT(("==> MiniportHalt(0x%x)", MiniportAdapterContext));

    thisDev->hardwareStatus = NdisHardwareStatusClosing;

    NdisAcquireSpinLock(&thisDev->QueueLock);

    thisDev->Halting=TRUE;

    if (thisDev->PacketsSentToProtocol > 0) {
        //
        //  wait for all the packets to come back from the protocol
        //
        NdisReleaseSpinLock(&thisDev->QueueLock);

        NdisWaitEvent(&thisDev->ReceiveStopped, 1*60*1000);

        NdisAcquireSpinLock(&thisDev->QueueLock);

    }

    if (!thisDev->TransmitIsIdle) {
        //
        //  wait for all the packets to be transmitted
        //
        NdisReleaseSpinLock(&thisDev->QueueLock);

        NdisWaitEvent(&thisDev->SendStoppedOnHalt,1*60*1000);

        NdisAcquireSpinLock(&thisDev->QueueLock);

    }

    if (thisDev->FirReceiveDmaActive) {

        thisDev->FirReceiveDmaActive=FALSE;
        //
        //  receive dma is running, stop it
        //
        CompleteDmaTransferFromDevice(
            &thisDev->DmaUtil
            );

    }

    //
    //  which back to SIR mode
    //
    CloseCOM(thisDev);

    SyncSetInterruptMask(thisDev, FALSE);

    NdisReleaseSpinLock(&thisDev->QueueLock);

    //
    //  release the interrupt
    //
    NdisMDeregisterInterrupt(&thisDev->interruptObj);

#if DBG
    NdisZeroMemory(&thisDev->interruptObj,sizeof(thisDev->interruptObj));
#endif

    //
    //  release fir related resources including dma channel
    //
    NSC_Shutdown(thisDev);

    //
    //  release sir related buffers
    //
    DoClose(thisDev);


    if (thisDev->portInfo.ConfigIoBasePhysAddr) {

        NdisMDeregisterIoPortRange(thisDev->ndisAdapterHandle,
                                   thisDev->portInfo.ConfigIoBasePhysAddr,
                                   2,
                                   (PVOID)thisDev->portInfo.ConfigIoBaseAddr);
    }

    NdisMDeregisterIoPortRange(thisDev->ndisAdapterHandle,
                               thisDev->portInfo.ioBasePhys,
                               ((thisDev->CardType==PUMA108)?16:8),
                               (PVOID)thisDev->portInfo.ioBase);

    //
    //  free the device block
    //
    FreeDevice(thisDev);
    LOG("<== MiniportHalt");
    DBGOUT(("<== MiniportHalt(0x%x)", MiniportAdapterContext));
}


void InterlockedInsertBufferSorted(PLIST_ENTRY Head,
                                   rcvBuffer *rcvBuf,
                                   PNDIS_SPIN_LOCK Lock)
{
    PLIST_ENTRY ListEntry;

    NdisAcquireSpinLock(Lock);
    if (IsListEmpty(Head))
    {
        InsertHeadList(Head, &rcvBuf->listEntry);
    }
    else
    {
        BOOLEAN EntryInserted = FALSE;
        for (ListEntry = Head->Flink;
             ListEntry != Head;
             ListEntry = ListEntry->Flink)
        {
            rcvBuffer *temp = CONTAINING_RECORD(ListEntry,
                                                rcvBuffer,
                                                listEntry);
            if (temp->dataBuf > rcvBuf->dataBuf)
            {
                // We found one that comes after ours.
                // We need to insert before it

                InsertTailList(ListEntry, &rcvBuf->listEntry);
                EntryInserted = TRUE;
                break;
            }
        }
        if (!EntryInserted)
        {
            // We didn't find an entry on the last who's address was later
            // than our buffer.  We go at the end.
            InsertTailList(Head, &rcvBuf->listEntry);
        }
    }
    NdisReleaseSpinLock(Lock);
}

/*
 *************************************************************************
 *  DeliverFullBuffers
 *************************************************************************
 *
 *  Deliver received packets to the protocol.
 *  Return TRUE if delivered at least one frame.
 *
 */
VOID
DeliverFullBuffers(IrDevice *thisDev)
{
    PLIST_ENTRY ListEntry;

    LOG("==> DeliverFullBuffers");
    DBGOUT(("==> DeliverFullBuffers(0x%x)", thisDev));


    /*
     *  Deliver all full rcv buffers
     */

    for (
         ListEntry = NDISSynchronizedRemoveHeadList(&thisDev->rcvBufFull,
                                                    &thisDev->interruptObj);
         ListEntry;

         ListEntry = NDISSynchronizedRemoveHeadList(&thisDev->rcvBufFull,
                                                    &thisDev->interruptObj)
        )
    {
        rcvBuffer *rcvBuf = CONTAINING_RECORD(ListEntry,
                                              rcvBuffer,
                                              listEntry);
        NDIS_STATUS stat;
        PNDIS_BUFFER packetBuf;
        SLOW_IR_FCS_TYPE fcs;

        VerifyNdisPacket(rcvBuf->packet, 0);


        if (thisDev->currentSpeed <= MAX_SIR_SPEED) {
            /*
             * The packet we have already has had BOFs,
             * EOF, and * escape-sequences removed.  It
             * contains an FCS code at the end, which we
             * need to verify and then remove before
             * delivering the frame.  We compute the FCS
             * on the packet with the packet FCS attached;
             * this should produce the constant value
             * GOOD_FCS.
             */
            fcs = ComputeFCS(rcvBuf->dataBuf,
                             rcvBuf->dataLen);

            if (fcs != GOOD_FCS) {
               /*
                *  FCS Error.  Drop this frame.
                */
                LOG("Error: Bad FCS in DeliverFullBuffers %x", fcs);
                DBGERR(("Bad FCS in DeliverFullBuffers 0x%x!=0x%x.",
                        (UINT)fcs, (UINT) GOOD_FCS));
                rcvBuf->state = STATE_FREE;

                DBGSTAT(("Dropped %d/%d pkts; BAD FCS (%xh!=%xh):",
                         ++thisDev->packetsDropped,
                         thisDev->packetsDropped +
                         thisDev->packetsRcvd, fcs,
                         GOOD_FCS));

                DBGPRINTBUF(rcvBuf->dataBuf,
                            rcvBuf->dataLen);

                if (!rcvBuf->isDmaBuf)
                {
                    NDISSynchronizedInsertTailList(&thisDev->rcvBufBuf,
                                                   RCV_BUF_TO_LIST_ENTRY(rcvBuf->dataBuf),
                                                   &thisDev->interruptObj);
                }
                rcvBuf->dataBuf = NULL;
                rcvBuf->isDmaBuf = FALSE;

                VerifyNdisPacket(rcvBuf->packet, 0);
                NDISSynchronizedInsertHeadList(&thisDev->rcvBufFree,
                                               &rcvBuf->listEntry,
                                               &thisDev->interruptObj);

                //break;
                continue;
            }

        /* Remove the FCS from the end of the packet. */
            rcvBuf->dataLen -= SLOW_IR_FCS_SIZE;
        }
#ifdef DBG_ADD_PKT_ID
        if (addPktIdOn) {

            /* Remove dbg packet id. */
            USHORT uniqueId;
            rcvBuf->dataLen -= sizeof(USHORT);
            uniqueId = *(USHORT *)(rcvBuf->dataBuf+
                                   rcvBuf->dataLen);
            DBGOUT(("ID: RCVing packet %xh **",
                    (UINT)uniqueId));
            LOG("ID: Rcv Pkt id: %xh", uniqueId);
        }
#endif

        /*
         * The packet array is set up with its NDIS_PACKET.
         * Now we need to allocate a single NDIS_BUFFER for
         * the NDIS_PACKET and set the NDIS_BUFFER to the
         * part of dataBuf that we want to deliver.
         */
        NdisAllocateBuffer(&stat, &packetBuf,
                           thisDev->bufferPoolHandle,
                           (PVOID)rcvBuf->dataBuf, rcvBuf->dataLen);

        if (stat != NDIS_STATUS_SUCCESS){
            LOG("Error: NdisAllocateBuffer failed");
            DBGERR(("NdisAllocateBuffer failed"));
            ASSERT(0);
            break;
        }

        VerifyNdisPacket(rcvBuf->packet, 0);
        NdisChainBufferAtFront(rcvBuf->packet, packetBuf);
        LOG_PacketChain(thisDev, rcvBuf->packet);
        VerifyNdisPacket(rcvBuf->packet, 1);

        /*
         *  Fix up some other packet fields.
         */
        NDIS_SET_PACKET_HEADER_SIZE(rcvBuf->packet,
                                    IR_ADDR_SIZE+IR_CONTROL_SIZE);

        DBGPKT(("Indicating rcv packet 0x%x.", rcvBuf->packet));

        /*
         * Indicate to the protocol that another packet is
         * ready.  Set the rcv buffer's state to PENDING first
         * to avoid a race condition with NDIS's call to the
         * return packet handler.
         */

        NdisAcquireSpinLock(&thisDev->QueueLock);

        if (thisDev->Halting) {
            //
            //  the adapter is being halted, stop sending packets up
            //

            NdisReleaseSpinLock(&thisDev->QueueLock);

            if (!rcvBuf->isDmaBuf) {

                NDISSynchronizedInsertTailList(&thisDev->rcvBufBuf,
                                               RCV_BUF_TO_LIST_ENTRY(rcvBuf->dataBuf),
                                               &thisDev->interruptObj);
            }
            rcvBuf->dataBuf = NULL;
            rcvBuf->isDmaBuf = FALSE;

            VerifyNdisPacket(rcvBuf->packet, 0);
            NDISSynchronizedInsertHeadList(&thisDev->rcvBufFree,
                                           &rcvBuf->listEntry,
                                           &thisDev->interruptObj);


            //
            //  free the buffer we chained to the packet
            //
            packetBuf=NULL;

            NdisUnchainBufferAtFront(rcvBuf->packet, &packetBuf);

            if (packetBuf){

                NdisFreeBuffer(packetBuf);
            }


            continue;
        }

        //
        //  increment the count of packets sent to the protocol
        //
        NdisInterlockedIncrement(&thisDev->PacketsSentToProtocol);

        NdisReleaseSpinLock(&thisDev->QueueLock);

        rcvBuf->state = STATE_PENDING;

        *(rcvBuffer **)rcvBuf->packet->MiniportReserved = rcvBuf;

        InterlockedInsertBufferSorted(
            &thisDev->rcvBufPend,
            rcvBuf,
            &thisDev->QueueLock
            );

        VerifyNdisPacket(rcvBuf->packet, 1);
        LOG_Data2(thisDev, rcvBuf->dataBuf);


        NDIS_SET_PACKET_STATUS(rcvBuf->packet,STATUS_SUCCESS);
        NdisMIndicateReceivePacket(thisDev->ndisAdapterHandle,
                                   &rcvBuf->packet, 1);

        /*
         * The packet is being delivered asynchronously.
         * Leave the rcv buffer's state as PENDING;
         * we'll get a callback when the transfer is
         */

         LOG("Indicated rcv complete (Async) bytes: %d",
             rcvBuf->dataLen);
         DBGSTAT(("Rcv Pending. Rcvd %d packets",
                     ++thisDev->packetsRcvd));

    }

    LOG("<== DeliverFullBuffers");
    DBGOUT(("<== DeliverFullBuffers"));
    return ;
}


/*
 *************************************************************************
 *  MiniportHandleInterrupt
 *************************************************************************
 *
 *
 *  This is the deferred interrupt processing routine (DPC) which is
 *  optionally called following an interrupt serviced by MiniportISR.
 *
 */
VOID MiniportHandleInterrupt(NDIS_HANDLE MiniportAdapterContext)
{
    IrDevice    *thisDev    =    CONTEXT_TO_DEV(   MiniportAdapterContext);
    PNDIS_PACKET   PacketToComplete=NULL;
    NDIS_STATUS    PacketStatus=NDIS_STATUS_SUCCESS;
    BOOLEAN        SpeedChange=FALSE;

    LOG("==> MiniportHandleInterrupt");
    DBGOUT(("==> MiniportHandleInterrupt(0x%x)", MiniportAdapterContext));



    /*
     * If we have just started receiving a packet, indicate media-busy
     * to the protocol.
     */
    if (thisDev->mediaBusy && !thisDev->haveIndicatedMediaBusy) {

        if (thisDev->currentSpeed > MAX_SIR_SPEED) {
            LOG("Error: MiniportHandleInterrupt is in wrong state %d",
                thisDev->currentSpeed);
            DBGERR(("MiniportHandleInterrupt is in wrong state: speed is 0x%x",
                    thisDev->currentSpeed));
            ASSERT(0);
        }

        NdisMIndicateStatus(thisDev->ndisAdapterHandle,
                            NDIS_STATUS_MEDIA_BUSY, NULL, 0);
        NdisMIndicateStatusComplete(thisDev->ndisAdapterHandle);

        thisDev->haveIndicatedMediaBusy = TRUE;
    }

    NdisDprAcquireSpinLock(&thisDev->QueueLock);

    if (thisDev->currentSpeed > MAX_SIR_SPEED) {
        //
        //  fir speed
        //

        //
        //  disable any other
        //
        thisDev->FirIntMask = 0x00;

        if (thisDev->FirTransmitPending) {

            ASSERT(thisDev->CurrentPacket != NULL);

            thisDev->FirTransmitPending=FALSE;

            //
            //  we seem to be transmitting now
            //

            {
                ULONG CurrentDMACount;
                UCHAR BytesInFifo;
                ULONG LoopCount=0;

                CurrentDMACount = NdisMReadDmaCounter(thisDev->DmaHandle);

                if (CurrentDMACount > 0) {

                     LOG_ERROR("FIR send: Dma Count was not zero: %d\n\n", CurrentDMACount);
#if DBG
                     DbgPrint("FIR send: Count was not zero: %d\n\n", CurrentDMACount);
#endif
                }

                //
                //  see if the fifo is empty yet
                //
                BytesInFifo=SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, BANK_2, TXFLV_OFFSET) & 0x3f;

                if (BytesInFifo > 0) {

                    LOG_ERROR("FIR send: Bytes still in fifo: %d", BytesInFifo);

                    while ((BytesInFifo > 0) && (LoopCount < 64)) {

                        BytesInFifo=SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, BANK_2, TXFLV_OFFSET) & 0x3f;
                        LoopCount++;
                    }

                    LOG_ERROR("FIR send: Bytes still in fifo after loop: %d, loops=%d", BytesInFifo,LoopCount);
                }
            }

            PacketStatus=CompleteDmaTransferToDevice(
                &thisDev->DmaUtil
                );

            if (PacketStatus != NDIS_STATUS_SUCCESS) {
                DBGERR(("NdisMCompleteDmaTransfer failed: %d\n", PacketStatus));
#if DBG
                DbgBreakPoint();
#endif
            }

            /*
             * Check for Tx underrun.
             */
            if (SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 0, ASCR_OFFSET) & ASCR_TXUR) {

                USHORT  TransmitCurrentCount;

                //
                //  for debugging purposes, see where we were in the frame when it stopped
                //
                TransmitCurrentCount =  SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, BANK_4, TFRCCL_OFFSET);
                TransmitCurrentCount |= ((USHORT)SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, BANK_4, TFRCCH_OFFSET)) << 8;

                //
                //  reset the fifo's
                //
                SyncWriteBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 0, 2, 0x07);

                //
                //  clear the tx underrun
                //
                SyncWriteBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 0, ASCR_OFFSET, ASCR_TXUR);

                RegStats.TxUnderruns++;
                PacketStatus = NDIS_STATUS_FAILURE;

                LOG_ERROR("MiniportDpc: Transmit Underrun: tx current count=%d",TransmitCurrentCount);
                DEBUGFIR(DBG_TX|DBG_ERR, ("NSC: FIR_MegaSendComplete: Transmit Underrun\n"));
            }

            PacketToComplete=thisDev->CurrentPacket;
            thisDev->CurrentPacket=NULL;

        } else {

            if (thisDev->FirReceiveDmaActive) {

                FIR_DeliverFrames(thisDev);

            } else {

                DBGERR(("MiniportHandleInterrupt: fir: not sending and not RX state"));
                LOG_ERROR("MiniportHandleInterrupt: fir: not sending and not RX state %02x",thisDev->InterruptStatus);
            }

        }

    } else {
        //
        //  in SIR mode
        //
        if (thisDev->CurrentPacket != NULL) {
            //
            //
            UINT   TransmitComplete=InterlockedExchange(&thisDev->portInfo.IsrDoneWithPacket,0);

            if (TransmitComplete) {

                PacketToComplete=thisDev->CurrentPacket;
                thisDev->CurrentPacket=NULL;
            }
        }
    }

    thisDev->setSpeedAfterCurrentSendPacket = FALSE;

    if (PacketToComplete != NULL) {

        if (thisDev->lastPacketAtOldSpeed == PacketToComplete) {

            thisDev->lastPacketAtOldSpeed=NULL;

            SpeedChange=TRUE;

            DBGERR(("defered set speed\n"));

            SetSpeed(thisDev);
        }
    }

    NdisDprReleaseSpinLock(&thisDev->QueueLock);

    if (PacketToComplete != NULL) {

        ProcessSendQueue(thisDev);
        NdisMSendComplete(thisDev->ndisAdapterHandle, PacketToComplete, PacketStatus);

    }
    //
    //  send any received packets to irda.sys
    //
    DeliverFullBuffers(thisDev);

    SyncSetInterruptMask(thisDev, TRUE);

    LOG("<== MiniportHandleInterrupt");
    DBGOUT(("<== MiniportHandleInterrupt"));

}

/*
 *************************************************************************
 *  GetPnPResources
 *************************************************************************
 *
 *
 */
BOOLEAN GetPnPResources(IrDevice *thisDev, NDIS_HANDLE WrapperConfigurationContext)
{
	NDIS_STATUS stat;
    BOOLEAN result = FALSE;

    /*
     *  We should only need 2 adapter resources (2 IO and 1 interrupt),
     *  but I've seen devices get extra resources.
     *  So give the NdisMQueryAdapterResources call room for 10 resources.
     */
    #define RESOURCE_LIST_BUF_SIZE (sizeof(NDIS_RESOURCE_LIST) + (10*sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)))

    UCHAR buf[RESOURCE_LIST_BUF_SIZE];
    PNDIS_RESOURCE_LIST resList = (PNDIS_RESOURCE_LIST)buf;
    UINT bufSize = RESOURCE_LIST_BUF_SIZE;

    NdisMQueryAdapterResources(&stat, WrapperConfigurationContext, resList, &bufSize);
    if (stat == NDIS_STATUS_SUCCESS){
        PCM_PARTIAL_RESOURCE_DESCRIPTOR resDesc;
        BOOLEAN     haveIRQ = FALSE,
                    haveIOAddr = FALSE,
                    haveDma = FALSE;
        UINT i;

        for (resDesc = resList->PartialDescriptors, i = 0;
             i < resList->Count;
             resDesc++, i++){

            switch (resDesc->Type){
                case CmResourceTypePort:
                    if (thisDev->CardType==PC87108 &&
                        (resDesc->u.Port.Start.LowPart==0xEA ||
                         resDesc->u.Port.Start.LowPart==0x398 ||
                         resDesc->u.Port.Start.LowPart==0x150))
                    {
                        // This is an eval board and this is the config io base address

                        thisDev->portInfo.ConfigIoBasePhysAddr = resDesc->u.Port.Start.LowPart;
                    }
                    else if (thisDev->CardType==PC87308 &&
                             (resDesc->u.Port.Start.LowPart==0x2E ||
                              resDesc->u.Port.Start.LowPart==0x15C))
                    {
                        // This is an eval board and this is the config io base address

                        thisDev->portInfo.ConfigIoBasePhysAddr = resDesc->u.Port.Start.LowPart;
                    }
                    else if (thisDev->CardType==PC87338 &&
                             (resDesc->u.Port.Start.LowPart==0x2E ||
                              resDesc->u.Port.Start.LowPart==0x398 ||
                              resDesc->u.Port.Start.LowPart==0x15C))
                    {
                        // This is an eval board and this is the config io base address

                        thisDev->portInfo.ConfigIoBasePhysAddr = resDesc->u.Port.Start.LowPart;
                    }
                    else
                    {
                        if (haveIOAddr){
                            /*
                             *  The *PNP0510 chip on the IBM ThinkPad 760EL
                             *  gets an extra IO range assigned to it.
                             *  So only pick up the first IO port range;
                             *  ignore this subsequent one.
                             */
                            DBGERR(("Ignoring extra PnP IO base %xh because already using %xh.",
                                      (UINT)resDesc->u.Port.Start.LowPart,
                                      (UINT)thisDev->portInfo.ioBasePhys));
                        }
                        else {
                            thisDev->portInfo.ioBasePhys = resDesc->u.Port.Start.LowPart;
                            haveIOAddr = TRUE;
                            DBGOUT(("Got UART IO addr: %xh.", thisDev->portInfo.ioBasePhys));
                        }
                    }
                    break;

                case CmResourceTypeInterrupt:
                    if (haveIRQ){
                        DBGERR(("Ignoring second PnP IRQ %xh because already using %xh.",
                                (UINT)resDesc->u.Interrupt.Level, thisDev->portInfo.irq));
                    }
                    else {
	                    thisDev->portInfo.irq = resDesc->u.Interrupt.Level;
                        haveIRQ = TRUE;
                        DBGOUT(("Got PnP IRQ: %d.", thisDev->portInfo.irq));
                    }
                    break;

                case CmResourceTypeDma:
                    if (haveDma){
                        DBGERR(("Ignoring second DMA address %d because already using %d.",
                                (UINT)resDesc->u.Dma.Channel, (UINT)thisDev->portInfo.DMAChannel));
                    }
                    else {
                        ASSERT(!(resDesc->u.Dma.Channel&0xffffff00));
                        thisDev->portInfo.DMAChannel = (UCHAR)resDesc->u.Dma.Channel;
                        haveDma = TRUE;
                        DBGOUT(("Got DMA channel: %d.", thisDev->portInfo.DMAChannel));
                    }
                    break;
            }
        }

        result = (haveIOAddr && haveIRQ && haveDma);
    }

    return result;
}


/*
 *************************************************************************
 *  Configure
 *************************************************************************
 *
 *  Read configurable parameters out of the system registry.
 *
 */
BOOLEAN Configure(
                 IrDevice *thisDev,
                 NDIS_HANDLE WrapperConfigurationContext
                 )
{
    //
    // Status of Ndis calls.
    //
    NDIS_STATUS Status;

    //
    // The handle for reading from the registry.
    //
    NDIS_HANDLE ConfigHandle;


    //
    // The value read from the registry.
    //
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;

    //
    // String names of all the parameters that will be read.
    //
    NDIS_STRING CardTypeStr         = CARDTYPE;
    NDIS_STRING Dongle_A_TypeStr	= DONGLE_A_TYPE;
    NDIS_STRING Dongle_B_TypeStr	= DONGLE_B_TYPE;
    NDIS_STRING MaxConnectRateStr   = MAXCONNECTRATE;


    UINT Valid_DongleTypes[] = VALID_DONGLETYPES;

    DBGOUT(("Configure(0x%x)", thisDev));
    NdisOpenConfiguration(&Status, &ConfigHandle, WrapperConfigurationContext);

    if (Status != NDIS_STATUS_SUCCESS){
        DBGERR(("NdisOpenConfiguration failed in Configure()"));
        return FALSE;
    }
    //
    // Read Ir108 Configuration I/O base Address
    //
    //DbgBreakPoint();
    NdisReadConfiguration(
                         &Status,
                         &ReturnedValue,
                         ConfigHandle,
                         &CardTypeStr,
                         NdisParameterHexInteger
                         );
    if (Status != NDIS_STATUS_SUCCESS){
        DBGERR(("NdisReadConfiguration failed in accessing CardType."));
        NdisCloseConfiguration(ConfigHandle);
        return FALSE;
    }
    thisDev->CardType = (UCHAR)ReturnedValue->ParameterData.IntegerData;


    if (!GetPnPResources(thisDev, WrapperConfigurationContext)){

        DBGERR(("GetPnPResources failed\n"));

        NdisCloseConfiguration(ConfigHandle);
        return FALSE;
    }





    // Read Dongle type constant Number.
    //
    NdisReadConfiguration(&Status,
			  &ReturnedValue,
			  ConfigHandle,
			  &Dongle_A_TypeStr,
			  NdisParameterInteger);

    if (Status != NDIS_STATUS_SUCCESS){
    	DBGERR(("NdisReadConfiguration failed in accessing DongleType (0x%x).",Status));
    }
    thisDev->DonglesSupported = 1;
    thisDev->DongleTypes[0] =
	(UCHAR)Valid_DongleTypes[(UCHAR)ReturnedValue->ParameterData.IntegerData];

    // Read Dongle type constant Number.
    //
    NdisReadConfiguration(&Status,
			  &ReturnedValue,
			  ConfigHandle,
			  &Dongle_B_TypeStr,
			  NdisParameterInteger);

    if (Status != NDIS_STATUS_SUCCESS){
    	 DBGERR(("NdisReadConfiguration failed in accessing DongleType (0x%x).",
		  Status));
    }
    thisDev->DongleTypes[1] = (UCHAR)Valid_DongleTypes[(UCHAR)ReturnedValue->ParameterData.IntegerData];
    thisDev->DonglesSupported++;

    // Read MaxConnectRate.
    //
    NdisReadConfiguration(&Status,
			  &ReturnedValue,
			  ConfigHandle,
			  &MaxConnectRateStr,
			  NdisParameterInteger);

    if (Status != NDIS_STATUS_SUCCESS){
    	DBGERR(("NdisReadConfiguration failed in accessing MaxConnectRate (0x%x).",Status));
        thisDev->AllowedSpeedMask = ALL_IRDA_SPEEDS;
    }
    else
    {
        thisDev->AllowedSpeedMask = 0;

        switch (ReturnedValue->ParameterData.IntegerData)
        {
            default:
            case 4000000:
                thisDev->AllowedSpeedMask |= NDIS_IRDA_SPEED_4M;
            case 1152000:
                thisDev->AllowedSpeedMask |= NDIS_IRDA_SPEED_1152K;
            case 115200:
                thisDev->AllowedSpeedMask |= NDIS_IRDA_SPEED_115200;
            case 57600:
                thisDev->AllowedSpeedMask |= NDIS_IRDA_SPEED_57600;
            case 38400:
                thisDev->AllowedSpeedMask |= NDIS_IRDA_SPEED_38400;
            case 19200:
                thisDev->AllowedSpeedMask |= NDIS_IRDA_SPEED_19200;
            case 9600:
                thisDev->AllowedSpeedMask |= NDIS_IRDA_SPEED_9600 | NDIS_IRDA_SPEED_2400;
                break;
        }

    }


    NdisCloseConfiguration(ConfigHandle);


    DBGOUT(("Configure done: ConfigIO=0x%x UartIO=0x%x irq=%d DMA=%d",
            thisDev->portInfo.ConfigIoBaseAddr,thisDev->portInfo.ioBase,
            thisDev->portInfo.irq,thisDev->portInfo.DMAChannel));

    return TRUE;
}


/*
 *************************************************************************
 *  MiniportInitialize
 *************************************************************************
 *
 *
 *  Initializes the network interface card.
 *
 *
 *
 */
NDIS_STATUS MiniportInitialize  (   PNDIS_STATUS OpenErrorStatus,
                                    PUINT SelectedMediumIndex,
                                    PNDIS_MEDIUM MediumArray,
                                    UINT MediumArraySize,
                                    NDIS_HANDLE NdisAdapterHandle,
                                    NDIS_HANDLE WrapperConfigurationContext
                                )
{
    UINT mediumIndex;
    IrDevice *thisDev = NULL;
    NDIS_STATUS retStat, result = NDIS_STATUS_SUCCESS;

    DBGOUT(("MiniportInitialize()"));

    /*
     *  Search the passed-in array of supported media for the IrDA medium.
     */
    for (mediumIndex = 0; mediumIndex < MediumArraySize; mediumIndex++){
        if (MediumArray[mediumIndex] == NdisMediumIrda){
            break;
        }
    }
    if (mediumIndex < MediumArraySize){
        *SelectedMediumIndex = mediumIndex;
    }
    else {
        /*
         *  Didn't see the IrDA medium
         */
        DBGERR(("Didn't see the IRDA medium in MiniportInitialize"));
        result = NDIS_STATUS_UNSUPPORTED_MEDIA;
        return result;
    }

    /*
     *  Allocate a new device object to represent this connection.
     */
    thisDev = NewDevice();
    if (!thisDev){
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    thisDev->hardwareStatus = NdisHardwareStatusInitializing;
    /*
     *  Allocate resources for this connection.
     */
    if (!OpenDevice(thisDev)){
        DBGERR(("OpenDevice failed"));
        result = NDIS_STATUS_FAILURE;
        goto _initDone;
    }

    /*
     *  Record the NDIS wrapper's handle for this adapter, which we use
     *  when we call up to the wrapper.
     *  (This miniport's adapter handle is just thisDev, the pointer to the device object.).
     */
    DBGOUT(("NDIS handle: %xh <-> IRMINI handle: %xh", NdisAdapterHandle, thisDev));
    thisDev->ndisAdapterHandle = NdisAdapterHandle;

    /*
     *  Read the system registry to get parameters like COM port number, etc.
     */
    if (!Configure(thisDev, WrapperConfigurationContext)){
        DBGERR(("Configure failed"));
        result = NDIS_STATUS_FAILURE;
        goto _initDone;
    }

    /*
     *  This call will associate our adapter handle with the wrapper's
     *  adapter handle.  The wrapper will then always use our handle
     *  when calling us.  We use a pointer to the device object as the context.
     */
    NdisMSetAttributesEx(NdisAdapterHandle,
                         (NDIS_HANDLE)thisDev,
                         0,
                         NDIS_ATTRIBUTE_DESERIALIZE,
                         NdisInterfaceInternal);


    /*
     *  Tell NDIS about the range of IO space that we'll be using.
     *  Puma uses Chip-select mode, so the ConfigIOBase address actually
     *  follows the regular io, so get both in one shot.
     */
    retStat = NdisMRegisterIoPortRange( (PVOID)&thisDev->portInfo.ioBase,
                                        NdisAdapterHandle,
                                        thisDev->portInfo.ioBasePhys,
                                        ((thisDev->CardType==PUMA108)?16:8));

    if (retStat != NDIS_STATUS_SUCCESS){
        DBGERR(("NdisMRegisterIoPortRange failed"));
        thisDev->portInfo.ioBase=NULL;
        result = NDIS_STATUS_FAILURE;
        goto _initDone;
    }

    if (thisDev->portInfo.ConfigIoBasePhysAddr)
    {
        /*
         *  Eval boards require a second IO range.
         *
         */
        retStat = NdisMRegisterIoPortRange( (PVOID)&thisDev->portInfo.ConfigIoBaseAddr,
                                            NdisAdapterHandle,
                                            thisDev->portInfo.ConfigIoBasePhysAddr,
                                            2);
        if (retStat != NDIS_STATUS_SUCCESS){

            DBGERR(("NdisMRegisterIoPortRange config failed"));
            thisDev->portInfo.ConfigIoBaseAddr=NULL;
            result = NDIS_STATUS_FAILURE;
            goto _initDone;
        }
    }

    NdisMSleep(20);
    //
    // Set to Non-Extended mode
    //
    NSC_WriteBankReg(thisDev->portInfo.ioBase, 2, 2, 0x02);

    //
    //  set to bank 0
    //
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+LCR_BSR_OFFSET, 03);

    //
    //  mask all ints, before attaching interrupt
    //
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+INT_ENABLE_REG_OFFSET, 0);

    /*
     *  Register an interrupt with NDIS.
     */
    retStat = NdisMRegisterInterrupt(   (PNDIS_MINIPORT_INTERRUPT)&thisDev->interruptObj,
                                        NdisAdapterHandle,
                                        thisDev->portInfo.irq,
                                        thisDev->portInfo.irq,
                                        TRUE,   // want ISR
                                        TRUE,   // MUST share interrupts
                                        NdisInterruptLatched
                                    );
    if (retStat != NDIS_STATUS_SUCCESS){
        DBGERR(("NdisMRegisterInterrupt failed"));
        result = NDIS_STATUS_FAILURE;
        goto _initDone;
    }

    thisDev->InterruptRegistered=TRUE;

    {
        LONG   VerifyTries=5;

        while (VerifyTries > 0) {

            if (VerifyHardware(thisDev)) {

                break;
            }
#if DBG
            DbgPrint("NSCIRDA: VerifiyHardware() failed, trying again, tries left=%d\n",VerifyTries);
#endif
            VerifyTries--;
        }

        if ( VerifyTries == 0) {

            result = NDIS_STATUS_FAILURE;
            goto _initDone;
        }
    }



    /*
     *  Open COMM communication channel.
     *  This will let the dongle driver update its capabilities from their default values.
     */
    if (!DoOpen(thisDev)){
        DBGERR(("DoOpen failed"));
        result = NDIS_STATUS_FAILURE;
        goto _initDone;
    }


    /*
     *  Do special NSC setup
     *  (do this after comport resources, like read buf, have been allocated).
     */
    if (!NSC_Setup(thisDev)){
        DBGERR(("NSC_Setup failed"));
        NSC_Shutdown(thisDev);
        result = NDIS_STATUS_FAILURE;
        goto _initDone;
    }


_initDone:

    if (result == NDIS_STATUS_SUCCESS){
        /*
         *  Add this device object to the beginning of our global list.
         */
        thisDev->hardwareStatus = NdisHardwareStatusReady;
        DBGOUT(("MiniportInitialize succeeded"));
        return result;


    }

    //
    //  init failed, release the resources
    //
    if (thisDev->InterruptRegistered) {

        NdisMDeregisterInterrupt(&thisDev->interruptObj);
        thisDev->InterruptRegistered=FALSE;
    }


    if (thisDev->portInfo.ioBase != NULL) {

        NdisMDeregisterIoPortRange(
            thisDev->ndisAdapterHandle,
            thisDev->portInfo.ioBasePhys,
            ((thisDev->CardType==PUMA108)?16:8),
            (PVOID)thisDev->portInfo.ioBase
            );

        thisDev->portInfo.ioBase=NULL;

    }

    if (thisDev->portInfo.ConfigIoBaseAddr != NULL) {

        NdisMDeregisterIoPortRange(
            thisDev->ndisAdapterHandle,
            thisDev->portInfo.ConfigIoBasePhysAddr,
            2,
            (PVOID)thisDev->portInfo.ConfigIoBaseAddr
            );

        thisDev->portInfo.ConfigIoBaseAddr=NULL;

    }

    if (thisDev){

        FreeDevice(thisDev);
    }

    DBGOUT(("MiniportInitialize failed"));

    return result;

}


BOOLEAN
VerifyHardware(
    IrDevice *thisDev
    )

{
    UCHAR    TempValue;
    LONG     MilliSecondsToWait=500;


    NdisMSleep(20);
    //
    //  set to bank 0
    //
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+LCR_BSR_OFFSET, 03);

    //
    //  mask all ints, before attaching interrupt
    //
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+INT_ENABLE_REG_OFFSET, 0);

    NdisRawReadPortUchar(thisDev->portInfo.ioBase+INT_ENABLE_REG_OFFSET,&TempValue);

    if (TempValue != 0) {
#if DBG
        DbgPrint("NSCIRDA: After masking interrupts IER was not zero %x, base= %x\n",TempValue,thisDev->portInfo.ioBase);
#endif
        return FALSE;
    }

    //
    //  reset the fifo's and enable the fifos
    //
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+INT_ID_AND_FIFO_CNTRL_REG_OFFSET, 0x7);

    //
    //  read the interrupt ident reg, to see if the fifo's enabled
    //
    NdisRawReadPortUchar(thisDev->portInfo.ioBase+INT_ID_AND_FIFO_CNTRL_REG_OFFSET,&TempValue);

    if ((TempValue & 0xc0) != 0xc0) {

#if DBG
        DbgPrint("NSCIRDA: Fifo's not enabled in iir  %x, base= %x\n",TempValue,thisDev->portInfo.ioBase);
#endif
        return FALSE;
    }

    //
    //  bring up DTR and RTS, turn on the out pins
    //
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+MODEM_CONTROL_REG_OFFSET, 0xf);

    thisDev->GotTestInterrupt=FALSE;
    thisDev->TestingInterrupt=TRUE;

    //
    //   unmask the transmit holding register so an interrupt will be generated
    //
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+INT_ENABLE_REG_OFFSET, 2);

    while ((thisDev->GotTestInterrupt == FALSE) && (MilliSecondsToWait > 0)) {

        NdisMSleep(1000);
        MilliSecondsToWait--;
    }

#if DBG
    if (!thisDev->GotTestInterrupt) {

        NdisRawReadPortUchar(thisDev->portInfo.ioBase+INT_ID_AND_FIFO_CNTRL_REG_OFFSET,&TempValue);

        DbgPrint("NSCIRDA: Did not get interrupt while initializing, ier-%x, base= %x\n",TempValue,thisDev->portInfo.ioBase);
    }
#endif


    //
    //  mask all ints again;
    //
    NdisRawWritePortUchar(thisDev->portInfo.ioBase+INT_ENABLE_REG_OFFSET, 0);

    thisDev->TestingInterrupt=FALSE;

    return thisDev->GotTestInterrupt;
}

/*
 *************************************************************************
 * QueueReceivePacket
 *************************************************************************
 *
 *
 *
 *
 */
VOID QueueReceivePacket(IrDevice *thisDev, PUCHAR data, UINT dataLen, BOOLEAN IsFIR)
{
    rcvBuffer *rcvBuf = NULL;
    PLIST_ENTRY ListEntry;

    /*
     * Note: We cannot use a spinlock to protect the rcv buffer structures
     * in an ISR.  This is ok, since we used a sync-with-isr function
     * the the deferred callback routine to access the rcv buffers.
     */

    LOG("==> QueueReceivePacket");
    DBGOUT(("==> QueueReceivePacket(0x%x, 0x%lx, 0x%x)",
            thisDev, data, dataLen));
    LOG("QueueReceivePacket, len: %d ", dataLen);

    if (!IsFIR)
    {
        // This function is called inside the ISR during SIR mode.
        if (IsListEmpty(&thisDev->rcvBufFree))
        {
            ListEntry = NULL;
        }
        else
        {
            ListEntry = RemoveHeadList(&thisDev->rcvBufFree);
        }
    }
    else
    {
        ListEntry = NDISSynchronizedRemoveHeadList(&thisDev->rcvBufFree,
                                                   &thisDev->interruptObj);
    }
    if (ListEntry)
    {
        rcvBuf = CONTAINING_RECORD(ListEntry,
                                   rcvBuffer,
                                   listEntry);
        if (IsFIR)
        {
            LOG_Data(thisDev, data);
        }
    }




    if (rcvBuf){
        rcvBuf->dataBuf = data;

        VerifyNdisPacket(rcvBuf->packet, 0);
        rcvBuf->state = STATE_FULL;
        rcvBuf->dataLen = dataLen;


        if (!IsFIR)
        {
            rcvBuf->isDmaBuf = FALSE;
            InsertTailList(&thisDev->rcvBufFull,
                           ListEntry);
        }
        else
        {
            rcvBuf->isDmaBuf = TRUE;
            LOG_InsertTailList(thisDev, &thisDev->rcvBufFull, rcvBuf);
            NDISSynchronizedInsertTailList(&thisDev->rcvBufFull,
                                           ListEntry,
                                           &thisDev->interruptObj);
        }
    }
    LOG("<== QueueReceivePacket");
    DBGOUT(("<== QueueReceivePacket"));
}


/*
 *************************************************************************
 * MiniportISR
 *************************************************************************
 *
 *
 *  This is the miniport's interrupt service routine (ISR).
 *
 *
 */
VOID MiniportISR(PBOOLEAN InterruptRecognized,
                 PBOOLEAN QueueMiniportHandleInterrupt,
                 NDIS_HANDLE MiniportAdapterContext)
{
    IrDevice *thisDev = CONTEXT_TO_DEV(MiniportAdapterContext);

    if (thisDev->TestingInterrupt) {
        //
        //  we are testing to make sure the interrupt works
        //
        UCHAR    TempValue;

        //
        //  Read the interrupt identification register
        //
        NdisRawReadPortUchar(thisDev->portInfo.ioBase+INT_ID_AND_FIFO_CNTRL_REG_OFFSET,&TempValue);

        //
        //  if the low bit is clear then an interrupt is pending
        //
        if ((TempValue & 1) == 0) {

            //
            //  inform the test code that we got the interrupt
            //
            thisDev->GotTestInterrupt=TRUE;
            thisDev->TestingInterrupt=FALSE;

            //
            //  mask all ints again
            //
            NdisRawWritePortUchar(thisDev->portInfo.ioBase+INT_ENABLE_REG_OFFSET, 0);

             DBGOUT(("NSCIRDA: Got test interrupt %x\n",TempValue))

            *InterruptRecognized=TRUE;
            *QueueMiniportHandleInterrupt=FALSE;

            return;
        }

        //
        //  seems that our uart did not generate this interrupt
        //
        *InterruptRecognized=FALSE;
        *QueueMiniportHandleInterrupt=FALSE;

        return;

    }


    //LOG("==> MiniportISR", ++thisDev->interruptCount);
    //DBGOUT(("==> MiniportISR(0x%x), interrupt #%d)", (UINT)thisDev,
    //					thisDev->interruptCount));

#if DBG
    {
        UCHAR TempVal;
        //
        //  This code assumes that bank 0 is current, we will make sure of that
        //
        NdisRawReadPortUchar(thisDev->portInfo.ioBase+LCR_BSR_OFFSET, &TempVal);

        ASSERT((TempVal & BKSE) == 0);
    }
#endif


    /*
     *  Service the interrupt.
     */
    if (thisDev->currentSpeed > MAX_SIR_SPEED){
        NSC_FIR_ISR(thisDev, InterruptRecognized,
                    QueueMiniportHandleInterrupt);
    }
    else {
        COM_ISR(thisDev, InterruptRecognized,
                QueueMiniportHandleInterrupt);
    }


    LOG("<== MiniportISR");
    DBGOUT(("<== MiniportISR"));
}


/*
 *************************************************************************
 * MiniportReset
 *************************************************************************
 *
 *
 *  MiniportReset issues a hardware reset to the network interface card.
 *  The miniport driver also resets its software state.
 *
 *
 */
NDIS_STATUS MiniportReset(PBOOLEAN AddressingReset, NDIS_HANDLE MiniportAdapterContext)
{
    IrDevice    *thisDev = CONTEXT_TO_DEV(MiniportAdapterContext);
    NDIS_STATUS result = NDIS_STATUS_PENDING;

    LIST_ENTRY          TempList;
    BOOLEAN             SetSpeedNow=FALSE;
    PNDIS_PACKET        Packet;

    DBGERR(("MiniportReset(0x%x)", MiniportAdapterContext));

    InitializeListHead(&TempList);

    NdisAcquireSpinLock(&thisDev->QueueLock);

    thisDev->hardwareStatus = NdisHardwareStatusReset;
    //
    //  un-queue all the send packets and put them on a temp list
    //
    while (!IsListEmpty(&thisDev->SendQueue)) {

        PLIST_ENTRY    ListEntry;

        ListEntry=RemoveHeadList(&thisDev->SendQueue);

        InsertTailList(&TempList,ListEntry);
    }

    //
    //  if there is a current send packet, then request a speed change after it completes
    //
    if (thisDev->CurrentPacket != NULL) {
        //
        //  the current packet is now the last, chage speed after it is done
        //
        thisDev->lastPacketAtOldSpeed=thisDev->CurrentPacket;

    } else {
        //
        //  no current packet, change speed now
        //
        SetSpeedNow=TRUE;

    }


    //
    //  back to 9600
    //
    thisDev->linkSpeedInfo = &supportedBaudRateTable[BAUDRATE_9600];

    if (SetSpeedNow) {
        //
        //  there are no packets being transmitted now, switch speeds now.
        //  otherwise the dpc will do it when the current send completes
        //
        SetSpeed(thisDev);
        thisDev->TransmitIsIdle=FALSE;
    }

    NdisReleaseSpinLock(&thisDev->QueueLock);

    if (SetSpeedNow) {
        //
        //  the transmit was idle, but we change this to get the receive going again
        //
        ProcessSendQueue(thisDev);
    }

    //
    //  return all of these back to the protocol
    //
    while (!IsListEmpty(&TempList)) {

        PLIST_ENTRY    ListEntry;

        ListEntry=RemoveHeadList(&TempList);

        Packet= CONTAINING_RECORD(
                                   ListEntry,
                                   NDIS_PACKET,
                                   MiniportReserved
                                   );
        NdisMSendComplete(thisDev->ndisAdapterHandle, Packet, NDIS_STATUS_RESET_IN_PROGRESS );
    }

    thisDev->hardwareStatus = NdisHardwareStatusReady;

    NdisMResetComplete(thisDev->ndisAdapterHandle,
                       NDIS_STATUS_SUCCESS,
                       TRUE);  // Addressing reset



    *AddressingReset = TRUE;

    DBGOUT(("MiniportReset done."));
    return NDIS_STATUS_PENDING;
}




/*
 *************************************************************************
 *  ReturnPacketHandler
 *************************************************************************
 *
 *  When NdisMIndicateReceivePacket returns asynchronously,
 *  the protocol returns ownership of the packet to the miniport via this function.
 *
 */
VOID ReturnPacketHandler(NDIS_HANDLE MiniportAdapterContext, PNDIS_PACKET Packet)
{
    IrDevice *thisDev = CONTEXT_TO_DEV(MiniportAdapterContext);
    rcvBuffer *rcvBuf;
    LONG       PacketsLeft;

    DBGOUT(("ReturnPacketHandler(0x%x)", MiniportAdapterContext));
    RegStats.ReturnPacketHandlerCalled++;

    //
    // MiniportReserved contains the pointer to our rcvBuffer
    //

    rcvBuf = *(rcvBuffer**) Packet->MiniportReserved;

    VerifyNdisPacket(Packet, 1);

    if (rcvBuf->state == STATE_PENDING){
        PNDIS_BUFFER ndisBuf;

        DBGPKT(("Reclaimed rcv packet 0x%x.", Packet));

        LOG_RemoveEntryList(thisDev, rcvBuf);
        NDISSynchronizedRemoveEntryList(&rcvBuf->listEntry, &thisDev->interruptObj);

        LOG_PacketUnchain(thisDev, rcvBuf->packet);
        NdisUnchainBufferAtFront(Packet, &ndisBuf);
        if (ndisBuf){
            NdisFreeBuffer(ndisBuf);
        }

        if (!rcvBuf->isDmaBuf)
        {
            NDISSynchronizedInsertTailList(&thisDev->rcvBufBuf,
                                           RCV_BUF_TO_LIST_ENTRY(rcvBuf->dataBuf),
                                           &thisDev->interruptObj);
            // ASSERT the pointer is actually outside our FIR DMA buffer
            ASSERT(rcvBuf->dataBuf < thisDev->dmaReadBuf ||
                   rcvBuf->dataBuf >= thisDev->dmaReadBuf+RCV_DMA_SIZE);
        }
        rcvBuf->dataBuf = NULL;

        rcvBuf->state = STATE_FREE;

        VerifyNdisPacket(rcvBuf->packet, 0);
        NDISSynchronizedInsertHeadList(&thisDev->rcvBufFree,
                                       &rcvBuf->listEntry,
                                       &thisDev->interruptObj);
    }
    else {
        LOG("Error: Packet in ReturnPacketHandler was not PENDING");

        DBGERR(("Packet in ReturnPacketHandler was not PENDING."));
    }

    NdisAcquireSpinLock(&thisDev->QueueLock);

    PacketsLeft=NdisInterlockedDecrement(&thisDev->PacketsSentToProtocol);

    if (thisDev->Halting && (PacketsLeft == 0)) {

        NdisSetEvent(&thisDev->ReceiveStopped);
    }

    NdisReleaseSpinLock(&thisDev->QueueLock);

    VerifyNdisPacket(rcvBuf->packet, 1);

}


VOID
GivePacketToSirISR(
    IrDevice *thisDev
    )

{

    thisDev->portInfo.writeComBufferPos = 0;
    thisDev->portInfo.SirWritePending = TRUE;
    thisDev->nowReceiving = FALSE;

    SetCOMPort(thisDev->portInfo.ioBase, INT_ENABLE_REG_OFFSET, XMIT_MODE_INTS_ENABLE);

}

VOID
SendCurrentPacket(
    IrDevice *thisDev
    )

{
    BOOLEAN         Result;
    PNDIS_PACKET    FailedPacket=NULL;


    NdisAcquireSpinLock(&thisDev->QueueLock);

    thisDev->TransmitIsIdle=FALSE;

    if (thisDev->CurrentPacket == thisDev->lastPacketAtOldSpeed){
        thisDev->setSpeedAfterCurrentSendPacket = TRUE;
    }


    if (thisDev->currentSpeed > MAX_SIR_SPEED) {
        //
        //  send via FIR
        //
        if (thisDev->FirReceiveDmaActive) {

            thisDev->FirReceiveDmaActive=FALSE;
            //
            //  receive dma is running, stop it
            //
            CompleteDmaTransferFromDevice(
                &thisDev->DmaUtil
                );

        }

        thisDev->HangChk=0;

        thisDev->FirTransmitPending = TRUE;
        //
        // Use DMA swap bit to switch to DMA to Transmit.
        //
        SyncWriteBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 2, 2, 0x0B);

        //
        // Switch on the DMA interrupt to decide when
        // transmission is complete.
        //
        thisDev->FirIntMask = 0x14;

        SyncSetInterruptMask(thisDev, TRUE);
        //
        // Kick off the first transmit.
        //

        NdisToFirPacket(
            thisDev->CurrentPacket,
            (UCHAR *) thisDev->TransmitDmaBuffer,
            MAX_IRDA_DATA_SIZE,
            &thisDev->TransmitDmaLength
            );


        LOG_FIR("Sending packet %d",thisDev->TransmitDmaLength);
        DEBUGFIR(DBG_PKT, ("NSC: Sending packet\n"));
        DBGPRINTBUF(thisDev->TransmitDmaBuffer,thisDev->TransmitDmaLength);

        {
            UCHAR   LsrValue;

            //
            //  make sure the transmitter is empty before starting to send this frame
            //
            LsrValue=SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 0, LSR_OFFSET);

            if ((LsrValue & (LSR_TXRDY | LSR_TXEMP)) != (LSR_TXRDY | LSR_TXEMP)) {

                ULONG   LoopCount=0;

                while (((LsrValue & (LSR_TXRDY | LSR_TXEMP)) != (LSR_TXRDY | LSR_TXEMP)) && (LoopCount < 16)) {

                    LsrValue=SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 0, LSR_OFFSET);
                    LoopCount++;
                }

                LOG_ERROR("SendCurrentPacket: Looped %d times waiting for tx empty",LoopCount);
            }

        }

        /* Setup Transmit DMA. */
        StartDmaTransferToDevice(
                              &thisDev->DmaUtil,
                              thisDev->xmitDmaBuffer,
                              0,
                              thisDev->TransmitDmaLength
                              );
#if 0
        {
            ULONG    CurrentDMACount;

            CurrentDMACount = NdisMReadDmaCounter(thisDev->DmaHandle);

            LOG("SendCurrentPacket: dma count after start %d",CurrentDMACount);
        }
#endif
        SyncSetInterruptMask(thisDev, TRUE);


    } else {
        //
        //  SIR mode transfer
        //
        /*
         * See if this was the last packet before we need to change
         * speed.
         */

        /*
         *  Send one packet to the COMM port.
         */
        DBGPKT(("Sending packet 0x%x (0x%x).", thisDev->packetsSent++, thisDev->CurrentPacket));

    	/*
    	 *  Convert the NDIS packet to an IRDA packet.
    	 */
    	Result = NdisToIrPacket(
                                thisDev->CurrentPacket,
    							(UCHAR *)thisDev->portInfo.writeComBuffer,
    							MAX_IRDA_DATA_SIZE,
    							&thisDev->portInfo.writeComBufferLen
                                );
    	if (Result){

            LOG_SIR("Sending packet %d",thisDev->portInfo.writeComBufferLen);

            NdisMSynchronizeWithInterrupt(
                &thisDev->interruptObj,
                GivePacketToSirISR,
                thisDev
                );

    	} else {

            ASSERT(0);
            FailedPacket=thisDev->CurrentPacket;
            thisDev->CurrentPacket=NULL;

        }
    }


    NdisReleaseSpinLock(&thisDev->QueueLock);

    if (FailedPacket != NULL) {

        NdisMSendComplete(thisDev->ndisAdapterHandle, FailedPacket, NDIS_STATUS_FAILURE );
        ProcessSendQueue(thisDev);
    }

    return;
}

VOID
DelayedWrite(
    IN PVOID SystemSpecific1,
    IN PVOID FunctionContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
{
    IrDevice *thisDev = FunctionContext;
#if DBG
    ASSERT(thisDev->WaitingForTurnAroundTimer);

    thisDev->WaitingForTurnAroundTimer=FALSE;
#endif

    LOG("Turn around timer expired");
    SendCurrentPacket(thisDev);
}



VOID
ProcessSendQueue(
    IrDevice *thisDev
    )

{

    PNDIS_PACKET    Packet=NULL;
    PLIST_ENTRY     ListEntry;

    NdisAcquireSpinLock(&thisDev->QueueLock);

    if (thisDev->CurrentPacket == NULL) {
        //
        //  not currently processing a send
        //
        if (!IsListEmpty(&thisDev->SendQueue)) {
            //
            //  we have some queue packets to process
            //
            ListEntry=RemoveHeadList(&thisDev->SendQueue);

            Packet=  CONTAINING_RECORD(
                                       ListEntry,
                                       NDIS_PACKET,
                                       MiniportReserved
                                       );

            thisDev->CurrentPacket=Packet;



            NdisReleaseSpinLock(&thisDev->QueueLock);

            {

                PNDIS_IRDA_PACKET_INFO packetInfo;

                /*
                 *  Enforce the minimum turnaround time that must transpire
                 *  after the last receive.
                 */
                packetInfo = GetPacketInfo(Packet);

                //
                //  see if this packet is requesting a turnaround time or not
                //
                if (packetInfo->MinTurnAroundTime > 0) {
                    //
                    //  Since we are using the timer to determine when the receive has ended,
                    //  we must have waited atleast the timer timeout period before we indicated
                    //  the packet to the protocol. Therefore, if that timeout was greater than
                    //  the turn around time then we don't need to wait.
                    //
                    //  this of course assumes that the protocol is not going to start sending
                    //  in the middle of a receive. If it is, then the other station is not going to
                    //  see the data anyway, so it does not matter much
                    //
                    //  this saves us from waiting the 10ms or so for the time out since the OS timer
                    //  resoltion is around 10ms.
                    //
                    //  if the transfer ended because the DMA buffer filled up, then we will force a turnaround
                    //
                    //  we don't do this SIR speeds
                    //
                    if ((packetInfo->MinTurnAroundTime > RECEIVE_TIMEOUT)
                        ||
                        thisDev->ForceTurnAroundTimeout
                        ||
                        (thisDev->currentSpeed <= MAX_SIR_SPEED) ) {

                        UINT usecToWait = packetInfo->MinTurnAroundTime;
                        UINT msecToWait;

                        msecToWait = (usecToWait<1000) ? 1 : (usecToWait+500)/1000;
#if DBG
                        thisDev->WaitingForTurnAroundTimer=TRUE;
#endif
                        NdisSetTimer(&thisDev->TurnaroundTimer, msecToWait);

                        thisDev->ForceTurnAroundTimeout=FALSE;

                        return;
                    }
                }
            }

            SendCurrentPacket(thisDev);

            NdisAcquireSpinLock(&thisDev->QueueLock);
        }
    }

    if ((thisDev->CurrentPacket == NULL) && IsListEmpty(&thisDev->SendQueue)) {
        //
        //  not currently processing a send
        //
        if (!thisDev->TransmitIsIdle) {
            //
            //  We were not idle before
            //
            thisDev->TransmitIsIdle=TRUE;

            if (thisDev->Halting) {

                NdisSetEvent(&thisDev->SendStoppedOnHalt);
            }

            //
            //  restart receive
            //
            if (thisDev->currentSpeed > MAX_SIR_SPEED) {
                //
                //  Start receive
                //
                thisDev->FirIntMask = 0x04;
                SetupRecv(thisDev);
                SyncSetInterruptMask(thisDev, TRUE);

            } else {
                //
                //  For SIR, the ISR switches back to receive for us
                //

            }
        }
    }

    NdisReleaseSpinLock(&thisDev->QueueLock);

    return;
}

/*
 *************************************************************************
 *  SendPacketsHandler
 *************************************************************************
 *
 *  Send an array of packets simultaneously.
 *
 */
VOID SendPacketsHandler(NDIS_HANDLE MiniportAdapterContext,
                        PPNDIS_PACKET PacketArray, UINT NumberofPackets)
{
    UINT i;

    IrDevice *thisDev = CONTEXT_TO_DEV(MiniportAdapterContext);

    DEBUGMSG(DBG_TRACE_TX, ("M"));
    LOG("==> SendPacketsHandler");
    DBGOUT(("==> SendPacketsHandler(0x%x)", MiniportAdapterContext));


    LOG("Number of transmit Burst %d ", NumberofPackets);

    ASSERT(!thisDev->Halting);

    //
    // NDIS gives us the PacketArray, but it is not ours to keep, so we have to take
    // the packets out and store them elsewhere.
    //
    NdisAcquireSpinLock(&thisDev->QueueLock);
    //
    //  all packets get queued
    //
    for (i = 0; i < NumberofPackets; i++) {

        if (thisDev->Halting) {
            //
            //  ndis should not send us more packets after calling the halt rountine.
            //  just make sure here
            //
            NdisReleaseSpinLock(&thisDev->QueueLock);

            NdisMSendComplete(thisDev->ndisAdapterHandle, PacketArray[i], NDIS_STATUS_FAILURE );

            NdisAcquireSpinLock(&thisDev->QueueLock);

        } else {

            InsertTailList(
                &thisDev->SendQueue,
                (PLIST_ENTRY)PacketArray[i]->MiniportReserved
                );
        }
    }

    NdisReleaseSpinLock(&thisDev->QueueLock);

    ProcessSendQueue(thisDev);

    LOG("<== SendPacketsHandler");
    DBGOUT(("<== SendPacketsHandler"));

    return ;
}

VOID
NscUloadHandler(
    PDRIVER_OBJECT  DriverObject
    )

{
    DBGOUT(("Unloading"));

    WPP_CLEANUP(DriverObject);

    return;

}


BOOLEAN AbortLoad = FALSE;
/*
 *************************************************************************
 *  DriverEntry
 *************************************************************************
 *
 *  Only include if IRMINI is a stand-alone driver.
 *
 */
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
#pragma NDIS_INIT_FUNCTION(DriverEntry)
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    NTSTATUS result = STATUS_SUCCESS, stat;
    NDIS_HANDLE wrapperHandle;
    NDIS50_MINIPORT_CHARACTERISTICS info;

    WPP_INIT_TRACING(DriverObject,RegistryPath);

    LOG("==> DriverEntry");
    DBGOUT(("==> DriverEntry"));

    //DbgBreakPoint();
    if (AbortLoad)
    {
        return STATUS_CANCELLED;
    }

    NdisZeroMemory(&info, sizeof(info));

    NdisMInitializeWrapper( (PNDIS_HANDLE)&wrapperHandle,
                            DriverObject,
                            RegistryPath,
                            NULL
                          );
    DBGOUT(("Wrapper handle is %xh", wrapperHandle));

    info.MajorNdisVersion           =   (UCHAR)NDIS_MAJOR_VERSION;
    info.MinorNdisVersion           =   (UCHAR)NDIS_MINOR_VERSION;
    //info.Flags						=	0;
    info.CheckForHangHandler        =   MiniportCheckForHang;
    info.HaltHandler                =   MiniportHalt;
    info.InitializeHandler          =   MiniportInitialize;
    info.QueryInformationHandler    =   MiniportQueryInformation;
    info.ReconfigureHandler         =   NULL;
    info.ResetHandler               =   MiniportReset;
    info.SendHandler                =   NULL; //MiniportSend;
    info.SetInformationHandler      =       MiniportSetInformation;
    info.TransferDataHandler        =   NULL;

    info.HandleInterruptHandler     =   MiniportHandleInterrupt;
    info.ISRHandler                 =   MiniportISR;
    info.DisableInterruptHandler    =   NULL;
    info.EnableInterruptHandler     =   NULL; //MiniportEnableInterrupt;


    /*
     *  New NDIS 4.0 fields
     */
    info.ReturnPacketHandler        =   ReturnPacketHandler;
    info.SendPacketsHandler         =   SendPacketsHandler;
    info.AllocateCompleteHandler    =   NULL;


    stat = NdisMRegisterMiniport(   wrapperHandle,
                                    (PNDIS_MINIPORT_CHARACTERISTICS)&info,
                                    sizeof(info));
    if (stat != NDIS_STATUS_SUCCESS){
        DBGERR(("NdisMRegisterMiniport failed in DriverEntry"));
        result = STATUS_UNSUCCESSFUL;
        goto _entryDone;
    }

    NdisMRegisterUnloadHandler(
        wrapperHandle,
        NscUloadHandler
        );


    _entryDone:
    DBGOUT(("DriverEntry %s", (PUCHAR)((result == NDIS_STATUS_SUCCESS) ? "succeeded" : "failed")));

    LOG("<== DriverEntry");
    DBGOUT(("<== DriverEntry"));
    return result;
}

PNDIS_IRDA_PACKET_INFO GetPacketInfo(PNDIS_PACKET packet)
{
    MEDIA_SPECIFIC_INFORMATION *mediaInfo;
    UINT size;
    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(packet, &mediaInfo, &size);
    return (PNDIS_IRDA_PACKET_INFO)mediaInfo->ClassInformation;
}

/* Setup for Recv */
// This function is always called at MIR & FIR speeds
void SetupRecv(IrDevice *thisDev)
{
    NDIS_STATUS stat;
    UINT FifoClear = 8;
    UCHAR    FifoStatus;

    LOG("SetupRecv - Begin Rcv Setup");

    FindLargestSpace(thisDev, &thisDev->rcvDmaOffset, &thisDev->rcvDmaSize);

    // Drain the status fifo of any pending packets
    //
    FifoStatus=SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 5, FRM_ST);

    while ((FifoStatus & 0x80) && FifoClear--) {

        ULONG Size;

        Size =  SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 5, RFRL_L);
        Size |= SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 5, RFRL_H);

        LOG_Discard(thisDev, Size);
        LOG_ERROR("SetupRecv:  fifo %02x, %d",FifoStatus,Size);

        FifoStatus=SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 5, FRM_ST);
        thisDev->DiscardNextPacketSet = TRUE;
    }

    thisDev->rcvPktOffset = thisDev->rcvDmaOffset;

    //
    // Use DMA swap bit to switch to DMA to Receive.
    //
    SyncWriteBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 2, 2, 0x03);

    LOG_Dma(thisDev);

    thisDev->FirReceiveDmaActive=TRUE;

    if (thisDev->rcvDmaSize < 8192) {
        LOG("SetupRecv small dma %d\n",(ULONG)thisDev->rcvDmaSize);
    }

    thisDev->LastReadDMACount = thisDev->rcvDmaSize;

    stat=StartDmaTransferFromDevice(
        &thisDev->DmaUtil,
        thisDev->rcvDmaBuffer,
        (ULONG)thisDev->rcvDmaOffset,
        (ULONG)thisDev->rcvDmaSize
        );

    LOG("SetupRecv - Begin Rcv Setup: offset=%d, size =%d",(ULONG)thisDev->rcvDmaOffset,(ULONG)thisDev->rcvDmaSize);

    if (stat != NDIS_STATUS_SUCCESS) {

        thisDev->FirReceiveDmaActive=FALSE;

        LOG("Error: NdisMSetupDmaTransfer failed in SetupRecv %x", stat);
        DBGERR(("NdisMSetupDmaTransfer failed (%xh) in SetupRecv", (UINT)stat));
        ASSERT(0);
    }
    LOG("SetupRecv - End Rcv Setup");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\nscdemo.h ===
/*
 ************************************************************************
 *
 *	NSCDEMO.H
 *
 *
 * Portions Copyright (C) 1996-1998 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-1998 Microsoft Corporation. All Rights Reserved.
 *
 *
 *				
 *************************************************************************
 */

#include "dongle.h"

#ifndef NSCDEMO_H
	#define NSCDEMO_H

	BOOLEAN NSC_DEMO_Init(IrDevice *thisDev);
	VOID NSC_DEMO_Deinit(PUCHAR comBase, UINT context);
	BOOLEAN NSC_DEMO_SetSpeed(IrDevice *thisDev, PUCHAR comBase, UINT bitsPerSec, UINT context);

#endif NSCDEMO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\nscfir.c ===
/*
 ************************************************************************
 *
 *	NSCFIR.C
 *
 *
 * Portions Copyright (C) 1996-2001 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */


#include "nsc.h"
#include "nscfir.tmh"
#include "nsctypes.h"

VOID NSC_FIR_ISR(IrDevice *thisDev, BOOLEAN *claimingInterrupt,
                 BOOLEAN *requireDeferredCallback)
{
    LOG_FIR("==> NSC_FIR_ISR");
    DEBUGFIR(DBG_ISR|DBG_OUT, ("NSC: ==> NSC_FIR_ISR(0x%x)\n", thisDev));

    thisDev->InterruptMask   = NSC_ReadBankReg(thisDev->portInfo.ioBase, 0, 1);

    thisDev->InterruptStatus = NSC_ReadBankReg(thisDev->portInfo.ioBase, 0, 2) & thisDev->FirIntMask;

    thisDev->AuxStatus       = NSC_ReadBankReg(thisDev->portInfo.ioBase, 0, 7);

    thisDev->LineStatus      = NSC_ReadBankReg(thisDev->portInfo.ioBase, 0, 5);


    LOG_FIR("InterruptMask: %02x, InterruptStatus: %02x", thisDev->InterruptMask,thisDev->InterruptStatus);
    LOG_FIR("AuxStatus:     %02x, LineStatus:      %02x", thisDev->AuxStatus,thisDev->LineStatus);

    DEBUGFIR(DBG_ISR|DBG_OUT, ("NSC: InterruptMask = 0x%x\n", thisDev->InterruptMask));
    DEBUGFIR(DBG_ISR|DBG_OUT, ("NSC: InterruptStatus = 0x%x\n", thisDev->InterruptStatus));
    DEBUGFIR(DBG_ISR|DBG_OUT, ("NSC: AuxStatus = 0x%x\n", thisDev->AuxStatus));
    DEBUGFIR(DBG_ISR|DBG_OUT, ("NSC: LineStatus = 0x%x\n", thisDev->LineStatus));

    if (thisDev->InterruptStatus) {
        //
        // After seeing the first packet switch the interrupt
        // to timer and use the DMA counter to decide if receptions
        // have stopped.
        //
        if (thisDev->InterruptStatus & LS_EV) {
            //
            //  Got a link status interrupt
            //
            if (thisDev->LineStatus & LSR_FR_END) {
                //
                //  The frame end status is set
                //
                if (!thisDev->FirTransmitPending) {
                    //
                    //  we weren't tansmitting
                    //
                }
            }
            if (thisDev->LineStatus & LSR_OE) {

                LOG_ERROR("NSC_FIR_ISR: rx overflow");
            }
        }

        if (thisDev->InterruptStatus & TMR_EV){
            //
            //  Disable Timer during call to DPC bit.
            //
            NSC_WriteBankReg(thisDev->portInfo.ioBase, 4, 2, 0x00);
            NSC_WriteBankReg(thisDev->portInfo.ioBase, 0, 7, 0x80);
        }

        *claimingInterrupt = TRUE;
        *requireDeferredCallback = TRUE;

        SetCOMInterrupts(thisDev, FALSE);

        if (thisDev->UIR_ModuleId >= 0x16 )
        {
    	    // This is for the Frame stop mode when the ISR is interrupted
    	    // after every Frame Tx
    	    //

            if ((thisDev->AuxStatus & 0x08)
             && (thisDev->InterruptStatus & 0x04)
             && (thisDev->FirTransmitPending == TRUE))
            {
                if (thisDev->LineStatus&0x40)
                {
                    NSC_WriteBankReg(thisDev->portInfo.ioBase, 0, 7, 0x40);
                    DBGERR(("FIR: Transmit underrun\n"));
                }
            }
        }
    }
    else {
        *claimingInterrupt = FALSE;
        *requireDeferredCallback = FALSE;
    }

    LOG_FIR("<== NSC_FIR_ISR claimingInterrupt = %x, requireDeferredCallback = %x ", *claimingInterrupt,*requireDeferredCallback);

    DEBUGFIR(DBG_ISR|DBG_OUT, ("NSC: <== NSC_FIR_ISR\n"));

}

typedef struct {
    IrDevice *thisDev;
    ULONG_PTR Offset;
    ULONG_PTR Length;
} DMASPACE;

void SkipNonDmaBuffers(PLIST_ENTRY Head, PLIST_ENTRY *Entry)
{
    while (Head!=*Entry)
    {
        rcvBuffer *rcvBuf = CONTAINING_RECORD(*Entry,
                                              rcvBuffer,
                                              listEntry);

        if (rcvBuf->isDmaBuf)
        {
            break;
        }
        else
        {
            *Entry = (*Entry)->Flink;
        }
    }
}

//
// We have two lists of buffers which occupy our DMA space.  We
// want to walk this list and find the largest space for putting
// new packets.
//
rcvBuffer *GetNextPacket(DMASPACE *Space,
                         PLIST_ENTRY *CurrFull,
                         PLIST_ENTRY *CurrPend)
{
    rcvBuffer *Result = NULL;

    SkipNonDmaBuffers(&Space->thisDev->rcvBufFull, CurrFull);
    SkipNonDmaBuffers(&Space->thisDev->rcvBufPend, CurrPend);

    if (*CurrFull==&Space->thisDev->rcvBufFull)
    {
        // Full list is finished.
        if (*CurrPend!=&Space->thisDev->rcvBufPend)
        {
            // Any entry on the pend list is valid.  Take the
            // next one and advance the pointer.

            Result = CONTAINING_RECORD(*CurrPend,
                                       rcvBuffer,
                                       listEntry);

            *CurrPend = (*CurrPend)->Flink;
        }
        else
        {
            // Both lists are finished.  We will return NULL.
        }
    }
    else
    {
        if (*CurrPend==&Space->thisDev->rcvBufPend)
        {
            // Pend list is finished.  Take anything from the
            // Full list, advance the pointer.
            Result = CONTAINING_RECORD(*CurrFull,
                                       rcvBuffer,
                                       listEntry);

            *CurrFull = (*CurrFull)->Flink;
        }
        else
        {
            // Both list have valid entries.  Compare the two and take the
            // one that appears in the buffer first.
            rcvBuffer *Full, *Pend;

            Full = CONTAINING_RECORD(*CurrFull,
                                     rcvBuffer,
                                     listEntry);
            Pend = CONTAINING_RECORD(*CurrPend,
                                     rcvBuffer,
                                     listEntry);

            if (Full->dataBuf < Pend->dataBuf)
            {
                // Full is the winner.  Take it.

                Result = Full;
                *CurrFull = (*CurrFull)->Flink;
            }
            else
            {
                // Pend is the winner.  Take it.

                Result = Pend;
                *CurrPend = (*CurrPend)->Flink;
            }
        }
    }

    if (Result)
    {
        ASSERT(Result->isDmaBuf);
    }

    return Result;
}

BOOLEAN SynchronizedFindLargestSpace(IN PVOID Context)
{
    DMASPACE *Space = Context;
    IrDevice *thisDev = Space->thisDev;
    BOOLEAN Result;
    PLIST_ENTRY Full, Pend;
    rcvBuffer *Current = NULL;

    ASSERT(sizeof(ULONG)==sizeof(PVOID));


    if (IsListEmpty(&thisDev->rcvBufFull) && IsListEmpty(&thisDev->rcvBufPend))
    {
        Space->Offset = (ULONG_PTR)thisDev->dmaReadBuf;
        Space->Length = RCV_DMA_SIZE;
    }
    else
    {
        ULONG_PTR EndOfLast;
        ULONG_PTR ThisSpace;

        Full = thisDev->rcvBufFull.Flink;
        Pend = thisDev->rcvBufPend.Flink;

        Space->Length = 0;

        EndOfLast = Space->Offset = (ULONG_PTR)thisDev->dmaReadBuf;

        Current = GetNextPacket(Space, &Full, &Pend);
        while (Current)
        {
            // It's possible to get a packet that is from SIR.  If so, skip it.

            if (Current->isDmaBuf)
            {
                ASSERT((ULONG_PTR)Current->dataBuf >= EndOfLast);

                ThisSpace = (ULONG_PTR)Current->dataBuf - EndOfLast;

                // ASSERT the pointer is actually in our DMA buffer.
                ASSERT(Current->dataBuf >= thisDev->dmaReadBuf ||
                       Current->dataBuf < thisDev->dmaReadBuf+RCV_DMA_SIZE);

                if (ThisSpace > Space->Length)
                {
                    Space->Offset = EndOfLast;
                    Space->Length = ThisSpace;
                }

                EndOfLast = (ULONG_PTR)Current->dataBuf + Current->dataLen;
            }


            Current = GetNextPacket(Space, &Full, &Pend);
        }

        // Now we do one more calculation for the space after the end of the list.

        ThisSpace = (ULONG_PTR)thisDev->dmaReadBuf + RCV_DMA_SIZE - (ULONG_PTR)EndOfLast;

        if (ThisSpace > Space->Length)
        {
            Space->Offset = EndOfLast;
            Space->Length = ThisSpace;
        }

        // Round off to start DMA on 4 byte boundary
        Space->Length -= 4 - (Space->Offset & 3);
        Space->Offset = (Space->Offset+3) & (~3);
    }

    // We want space relative to start of buffer.
    Space->Offset -= (ULONG_PTR)thisDev->dmaReadBuf;

    Result = (Space->Length >= MAX_RCV_DATA_SIZE + FAST_IR_FCS_SIZE);

    if (!Result)
    {
        DEBUGFIR(DBG_ERR, ("NSC: ERROR: Not enough space to DMA full packet %x\n", thisDev));
    }

    return Result;
}

BOOLEAN FindLargestSpace(IN IrDevice *thisDev,
                         OUT PULONG_PTR pOffset,
                         OUT PULONG_PTR pLength)
{
    DMASPACE Space;
    BOOLEAN Result;

    Space.Offset = 0;
    Space.Length = 0;
    Space.thisDev = thisDev;

    Result = NdisMSynchronizeWithInterrupt(
                                           &thisDev->interruptObj,
                                           SynchronizedFindLargestSpace,
                                           &Space
                                           );


    *pOffset = Space.Offset;
    *pLength = Space.Length;

    return Result;
}




void FIR_DeliverFrames(IrDevice *thisDev)
{
    UCHAR frameStat;
    NDIS_STATUS stat;
    ULONG rcvFrameSize;
    PUCHAR NewFrame;

    UCHAR   BytesInFifo=0;
    ULONG_PTR LastReadDMACount, EndOfData;
    BOOLEAN resetDma = FALSE, OverflowOccurred = FALSE;
    BOOLEAN Discarding = thisDev->DiscardNextPacketSet;
    const    UINT    fcsSize    =    (   thisDev->currentSpeed    >=    MIN_FIR_SPEED)    ?
                                     FAST_IR_FCS_SIZE : MEDIUM_IR_FCS_SIZE;

    LOG("==> FIR_DeliverFrames, prev dma=%d",(ULONG)thisDev->LastReadDMACount);
    DEBUGFIR(DBG_RX|DBG_OUT, ("NSC: ==> FIR_DeliverFrames(0x%x)\n", thisDev));

    LastReadDMACount = NdisMReadDmaCounter(thisDev->DmaHandle);

    // Check for data received since the last time we were here.
    // We also check for data in fifo.  If there is some, we wait, as long
    // as the DMA still has room to capture data.

    if (LastReadDMACount > 0) {
        //
        //  we have not transfered all of the data possible into the recieve area.
        //  See if we have read more since the last time we were here
        //
        if (((LastReadDMACount < thisDev->LastReadDMACount) || (BytesInFifo=SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 2, 7) & 0x3f))) {
            //
            //  we transfered something since
            //  the last interrupt or there are still bytes in the fifo, then set a timer
            //

            thisDev->LastReadDMACount = LastReadDMACount;

            //
            //  Set Timer Enable bit for another Timeout.
            //
            thisDev->FirIntMask = 0x90;
            SyncWriteBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 4, 2, 0x01);
            LOG_FIR("<== FIR_DeliverFrames- Enable timer, fifo=%02x, LastDma=%d",BytesInFifo,(ULONG)LastReadDMACount);
            DEBUGFIR(DBG_RX|DBG_OUT, ("NSC: <== FIR_DeliverFrames\n"));
            return;
        }
    } else {
        //
        //  The dma count has gone to zero so we have transfered all we possibly can,
        //  see if any thing is left in the fifo
        //
        BytesInFifo=SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 2, 7) & 0x3f;

        LOG("Receive: dma transfer complete, bytes in fifo=%d",BytesInFifo);

        //
        //  we are stopping because the dma buffer filled up, not because the
        //  receiver was idle
        //
        thisDev->ForceTurnAroundTimeout=TRUE;

    }

    RegStats.RxDPC_Window++;


    //
    //  stop the dma transfer, so the data in the buffer will be valid
    //
    stat=CompleteDmaTransferFromDevice(&thisDev->DmaUtil);

    //
    //  see how was transfer now that we have stopped the dma
    //
    LastReadDMACount = NdisMReadDmaCounter(thisDev->DmaHandle);

    if (stat != NDIS_STATUS_SUCCESS) {
        DBGERR(("NdisMCompleteDmaTransfer failed: %d\n", stat));
        ASSERT(0);
        //
        //  could not complete the DMA, make it appear that zero bytes were transfered
        //
        LastReadDMACount=thisDev->rcvDmaSize;
    }

    thisDev->FirReceiveDmaActive=FALSE;

    thisDev->DiscardNextPacketSet = FALSE;

    EndOfData = thisDev->rcvDmaOffset + (thisDev->rcvDmaSize - LastReadDMACount);

    LOG("Recieve: Total data transfered %d",(ULONG)(thisDev->rcvDmaSize - LastReadDMACount));

    SyncGetFifoStatus(
        &thisDev->interruptObj,
        thisDev->portInfo.ioBase,
        &frameStat,
        &rcvFrameSize
        );

    if (frameStat == 0) LOG_ERROR("Receive: no frames in fifo");

    LOG("frameStat: %x, size=%d ", (UINT) frameStat,rcvFrameSize);
    DEBUGFIR(DBG_RX|DBG_OUT, ("NSC: frameStat = %xh\n", (UINT) frameStat));

    while ((frameStat & 0x80) && thisDev->rcvPktOffset < EndOfData) {

        /*
         *  This status byte is valid; see what else it says...
         *  Also mask off indeterminate bit.
         */
        frameStat &= ~0xA0;

        /*
         * Whether the frame is good or bad, we must read the counter
         * FIFO to synchronize it with the frame status FIFO.
         */
        if (Discarding)
        {
            LOG_ERROR("receive error: disc stat=%02x, lost=%d\n",frameStat,rcvFrameSize);
             // Do nothing
        }
        else if (frameStat != 0) {
            /*
             *  Some rcv error occurred. Reset DMA.
             */

            LOG_ERROR("Receive error: stat=%02x, lost=%d\n",frameStat,rcvFrameSize);

            DEBUGFIR(DBG_RX|DBG_ERR, ("NSC: RCV ERR: frameStat=%xh FrameSize=%d \n",
                                      (UINT)frameStat,rcvFrameSize));

            if (frameStat & 0x40) {
                if (frameStat & 0x01) {
                    RegStats.StatusFIFOOverflows++;
                }
                if (frameStat & 0x02) {
                    RegStats.ReceiveFIFOOverflows++;
                }
                RegStats.MissedPackets += rcvFrameSize;
            }
            else{
                if (frameStat & 0x01) {
                    RegStats.StatusFIFOOverflows++;
                }
                if (frameStat & 0x02) {
                    RegStats.ReceiveFIFOOverflows++;
                }
                if (frameStat & 0x04) {
                    RegStats.ReceiveCRCErrors++;
                }
                if (frameStat & 0x08) {
                }
                if (frameStat & 0x10) {
                }
                LOG("Bytes Lost: %d",rcvFrameSize);
                ASSERT((thisDev->rcvPktOffset + rcvFrameSize)<= RCV_DMA_SIZE);

                /* Advance pointer past bad packet.  */
                thisDev->rcvPktOffset += rcvFrameSize;
            }
        }

        else if (thisDev->rcvPktOffset + rcvFrameSize > EndOfData )
        {

            LOG_ERROR("Receive: Frame extends beyond where dma control wrote: offset=%x, Frame size=%x, EndOfData=%x",(ULONG)thisDev->rcvPktOffset,(ULONG)rcvFrameSize,(ULONG)EndOfData);

            DBGERR(("Packet won't fit in received data!\n"));
            DBGERR(("rcvPktOffset:%x rcvFrameSize:%x LastReadDmaCount:%x\n",
                     thisDev->rcvPktOffset,
                     rcvFrameSize,
                     LastReadDMACount));
            DBGERR(("rcvDmaOffset:%x rcvDmaSize:%x EndOfData:%x\n",
                     thisDev->rcvDmaOffset, thisDev->rcvDmaSize, EndOfData));

            //
            //  The frame seems to have extended past the end of where we dma the data.
            //  This should only happen if the dma space just less than the size of
            //  the fifo too small. The remaining data is still sitting in the fifo
            //  Attempt to read it out so it will be empty when we got read more frames
            //
            while (BytesInFifo > 0) {

                SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, BANK_0, TXD_RXD_OFFSET);
                BytesInFifo--;
            }


            BytesInFifo=SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 2, 7) & 0x3f;

            if (BytesInFifo > 0) {
                //
                //  still bytes in the fifo after attmpting to read them out.
                //  Another frame has probably started showing up, Can trust the data collected
                //  so mark these frames to be discarded
                //
                LOG_ERROR("Receive: Still have bytes in the fifo after attempting to flush, %d bytes remaining",BytesInFifo);

                BytesInFifo=0;

                thisDev->DiscardNextPacketSet = TRUE;
            }
            //
            //  this should be the last frame to be received with out error, advance this pointer
            //  anyway.
            //
            thisDev->rcvPktOffset += rcvFrameSize;

        }

        else {

            DEBUGFIR(DBG_RX|DBG_OUT, ("NSC:  *** >>> FIR_DeliverFrames DMA offset 0x%x:\n",
                                      thisDev->rcvDmaOffset));

            //
            //  this is where the new frame starts
            //
            NewFrame = thisDev->dmaReadBuf + thisDev->rcvPktOffset;

            //
            //  the next frame will start after the end of this frame
            //
            thisDev->rcvPktOffset += rcvFrameSize;

            ASSERT(thisDev->rcvPktOffset < RCV_DMA_SIZE);

            //
            //  the FCS is included in the length of the frame, remove that from the length
            //  we send to the protocol
            //
            rcvFrameSize -= fcsSize;

            if (rcvFrameSize <= MAX_NDIS_DATA_SIZE &&
                rcvFrameSize >= IR_ADDR_SIZE + IR_CONTROL_SIZE)
            {
                //
                // Queue this rcv packet.  Move Newframe pointer
                // into RxDMA buffer.
                //
                RegStats.ReceivedPackets++;
                RegStats.RxWindow++;
                QueueReceivePacket(thisDev, NewFrame, rcvFrameSize, TRUE);
            }
            else {
                LOG("Error: invalid packet size in FIR_DeliverFrames %d", rcvFrameSize);

                DEBUGFIR(DBG_RX|DBG_ERR, ("NSC: invalid packet size in FIR_DeliverFrames; %xh > %xh\n", rcvFrameSize, MAX_RCV_DATA_SIZE));
                //
                // Discard the rest of the packets.
                //
                while (SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 5, 5)&0x80)
                {
                    SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 5, 6);
                    SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 5, 7);
                }
                thisDev->DiscardNextPacketSet = TRUE;
            }
        }

        SyncGetFifoStatus(
            &thisDev->interruptObj,
            thisDev->portInfo.ioBase,
            &frameStat,
            &rcvFrameSize
            );

        LOG("frameStat: %x, size=%d ", (UINT) frameStat,rcvFrameSize);
        DEBUGFIR(DBG_RX|DBG_OUT, ("NSC: frameStat = %xh\n", (UINT) frameStat));

        //
        // Clear the line status register, of any past events.
        //
        thisDev->LineStatus = SyncReadBankReg(&thisDev->interruptObj,thisDev->portInfo.ioBase, 0, 5);

    }

    thisDev->FirIntMask = 0x04;

    SetupRecv(thisDev);

    LOG("<== FIR_DeliverFrames");
    DEBUGFIR(DBG_RX|DBG_OUT, ("NSC: <== FIR_DeliverFrames\n"));
}

BOOLEAN NSC_Setup(IrDevice *thisDev)
{
    NDIS_DMA_DESCRIPTION DMAChannelDcr;
    NDIS_STATUS stat;

    /*
     *  Initialize rcv DMA channel
     */
    RtlZeroMemory(&DMAChannelDcr,sizeof(DMAChannelDcr));

    DMAChannelDcr.DemandMode = TRUE;
    DMAChannelDcr.AutoInitialize = FALSE;
    DMAChannelDcr.DmaChannelSpecified = FALSE;
    DMAChannelDcr.DmaWidth = Width8Bits;
    DMAChannelDcr.DmaSpeed = Compatible;
    DMAChannelDcr.DmaPort = 0;
    DMAChannelDcr.DmaChannel = thisDev->portInfo.DMAChannel; // 0;

    stat = NdisMRegisterDmaChannel(&thisDev->DmaHandle,
                                   thisDev->ndisAdapterHandle,
                                   thisDev->portInfo.DMAChannel,
                                   FALSE, &DMAChannelDcr, RCV_DMA_SIZE);

    if (stat != NDIS_STATUS_SUCCESS) {

        DEBUGFIR(DBG_ERR, ("NSC: NdisMRegisterDmaChannel failed\n"));
        return FALSE;
    }

    InitializeDmaUtil(
        &thisDev->DmaUtil,
        thisDev->DmaHandle
        );


    thisDev->rcvDmaOffset = 0;

    /*
     *  Because we enable rcv DMA while SIR receives may still be
     *  going on, we need to keep a separate receive buffer for DMA.
     *  This buffer gets swapped with the rcvBuffer data pointer
     *  and must be the same size.
     */
    thisDev->dmaReadBuf=NscAllocateDmaBuffer(
        thisDev->ndisAdapterHandle,
        RCV_DMA_SIZE,
        &thisDev->ReceiveDmaBufferInfo
        );

    if (thisDev->dmaReadBuf == NULL) {

        return FALSE;
    }

    thisDev->TransmitDmaBuffer=NscAllocateDmaBuffer(
        thisDev->ndisAdapterHandle,
        MAX_IRDA_DATA_SIZE,
        &thisDev->TransmitDmaBufferInfo
        );


    NdisAllocateBufferPool(&stat, &thisDev->dmaBufferPoolHandle, 2);

    if (stat != NDIS_STATUS_SUCCESS){
        LOG("Error: NdisAllocateBufferPool failed in NSC_Setup");
        DEBUGFIR(DBG_ERR, ("NSC: NdisAllocateBufferPool failed in NSC_Setup\n"));
        return FALSE;
    }

    NdisAllocateBuffer(&stat, &thisDev->rcvDmaBuffer,
                       thisDev->dmaBufferPoolHandle,
                       thisDev->dmaReadBuf,
                       RCV_DMA_SIZE
                       );

    if (stat != NDIS_STATUS_SUCCESS) {
        LOG("Error: NdisAllocateBuffer failed (rcv) in NSC_Setup");
        DEBUGFIR(DBG_ERR, ("NSC: NdisAllocateBuffer failed (rcv) in NSC_Setup\n"));
        return FALSE;
    }

    NdisAllocateBuffer(&stat, &thisDev->xmitDmaBuffer,
                       thisDev->dmaBufferPoolHandle,
                       thisDev->TransmitDmaBuffer,
                       MAX_IRDA_DATA_SIZE
                       );

    if (stat != NDIS_STATUS_SUCCESS) {
        LOG("NdisAllocateBuffer failed (xmit) in NSC_Setup");
        DEBUGFIR(DBG_ERR, ("NSC: NdisAllocateBuffer failed (xmit) in NSC_Setup\n"));
        return FALSE;
    }




    return TRUE;
}


void NSC_Shutdown(IrDevice *thisDev)
{

    if (thisDev->xmitDmaBuffer){
        NdisFreeBuffer(   thisDev->xmitDmaBuffer);
        thisDev->xmitDmaBuffer = NULL;
    }

    if (thisDev->rcvDmaBuffer){
        NdisFreeBuffer(thisDev->rcvDmaBuffer);
        thisDev->rcvDmaBuffer = NULL;
    }

    if (thisDev->dmaBufferPoolHandle){
        NdisFreeBufferPool(thisDev->dmaBufferPoolHandle);
        thisDev->dmaBufferPoolHandle = NULL;
    }

    if (thisDev->dmaReadBuf){

        NscFreeDmaBuffer(&thisDev->ReceiveDmaBufferInfo);
        thisDev->dmaReadBuf = NULL;
    }

    if (thisDev->TransmitDmaBuffer){

        NscFreeDmaBuffer(&thisDev->TransmitDmaBufferInfo);
        thisDev->TransmitDmaBuffer = NULL;
    }


    if (thisDev->DmaHandle){
        NdisMDeregisterDmaChannel(thisDev->DmaHandle);
        thisDev->DmaHandle = NULL;
    }

}


BOOLEAN
NdisToFirPacket(
    PNDIS_PACKET   Packet,
    UCHAR         *irPacketBuf,
    UINT           TotalDmaBufferLength,
    UINT          *ActualTransferLength
    )
{
    PNDIS_BUFFER ndisBuf;
    UINT ndisPacketBytes = 0;
    UINT ndisPacketLen;

    LOG("==> NdisToFirPacket");
    DEBUGFIR(DBG_OUT, ("NSC: ==> NdisToFirPacket\n"));

    /*
     *  Get the packet's entire length and its first NDIS buffer
     */
    NdisQueryPacket(Packet, NULL, NULL, &ndisBuf, &ndisPacketLen);

    LOG("NdisToFirPacket, number of bytes: %d", ndisPacketLen);
    DEBUGFIR(DBG_OUT, ("NSC: NdisToFirPacket, number of bytes: %d\n", ndisPacketLen));

    /*
     *  Make sure that the packet is big enough to be legal.
     *  It consists of an A, C, and variable-length I field.
     */
    if (ndisPacketLen < IR_ADDR_SIZE + IR_CONTROL_SIZE){
        LOG("Error: packet too short in %d", ndisPacketLen);
        DEBUGFIR(DBG_ERR, ("NSC: packet too short in NdisToFirPacket (%d bytes)\n", ndisPacketLen));
        return FALSE;
    }

    /*
     *  Make sure that we won't overwrite our contiguous buffer.
     */
    if (ndisPacketLen > TotalDmaBufferLength){
        /*
         *  The packet is too large
         *  Tell the caller to retry with a packet size large
         *  enough to get past this stage next time.
         */
        LOG("Error: packet too large in %d ", ndisPacketLen);
        DEBUGFIR(DBG_ERR, ("NSC: Packet too large in NdisToIrPacket (%d=%xh bytes), MAX_IRDA_DATA_SIZE=%d, TotalDmaBufferLength=%d.\n",
                           ndisPacketLen, ndisPacketLen, MAX_IRDA_DATA_SIZE, TotalDmaBufferLength));
        *ActualTransferLength = ndisPacketLen;

        return FALSE;
    }


    /*
     *  Read the NDIS packet into a contiguous buffer.
     *  We have to do this in two steps so that we can compute the
     *  FCS BEFORE applying escape-byte transparency.
     */
    while (ndisBuf) {
        UCHAR *bufData;
        UINT bufLen;

        NdisQueryBufferSafe(ndisBuf, (PVOID *)&bufData, &bufLen,NormalPagePriority);

        if (bufData==NULL || (ndisPacketBytes + bufLen > ndisPacketLen)){
            /*
             *  Packet was corrupt -- it misreported its size.
             */
            *ActualTransferLength = 0;
            ASSERT(0);
            return FALSE;
        }

        NdisMoveMemory((PVOID)(irPacketBuf+ndisPacketBytes),
                       (PVOID)bufData, (ULONG)bufLen);
        ndisPacketBytes += bufLen;

        NdisGetNextBuffer(ndisBuf, &ndisBuf);
    }

    if (WPP_LEVEL_ENABLED(DBG_LOG_INFO)) {

        UCHAR   CommandByte=*(irPacketBuf+1);
        UCHAR   Nr=CommandByte >> 5;
        UCHAR   Ns=(CommandByte >> 1) & 0x7;
        UCHAR   Pf=(CommandByte >> 4) & 0x1;

        if ((CommandByte & 1) == 0) {

            LOG("Sending - I frame, Nr=%d, Ns=%d p/f=%d",Nr,Ns,Pf);

        } else {

            if ((CommandByte & 0x3) == 0x1) {

                LOG("Sending - S frame, Nr=%d, xx=%d, p/f=%d",Nr, (CommandByte > 2) & 0x3, Pf);

            } else {

                LOG("Sending - U frame, p/f=%d",Pf);
            }
        }
    }

    /*
     *  Do a sanity check on the length of the packet.
     */
    if (ndisPacketBytes != ndisPacketLen){
        /*
         *  Packet was corrupt -- it misreported its size.
         */
        LOG("Error: Packet corrupt in NdisToIrPacket "
            "(buffer lengths don't add up to packet length)");
        DEBUGFIR(DBG_ERR, ("NSC: Packet corrupt in NdisToIrPacket (buffer lengths don't add up to packet length).\n"));
        *ActualTransferLength = 0;
        return FALSE;
    }

#ifdef DBG_ADD_PKT_ID
    if (addPktIdOn){
        static USHORT uniqueId = 0;
        DEBUGFIR(DBG_OUT, ("NSC:  *** --> SEND PKT ID: %xh\n", (UINT)uniqueId));
        LOG("ID: Send (FIR) Pkt id: %x", uniqueId);
        *(USHORT *)(irPacketBuf+ndisPacketBytes) = uniqueId++;
        ndisPacketBytes += sizeof(USHORT);
    }
#endif

    *ActualTransferLength = ndisPacketBytes;

    LOG("<== NdisToFirPacket");
    DEBUGFIR(DBG_OUT, ("NSC: <== NdisToFirPacket\n"));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\nsc.h ===
/*
 ************************************************************************
 *
 *	NSC.h
 *
 *
 * Portions Copyright (C) 1996-1998 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-1998 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */



#ifndef NSC_H

#define NSC_H

#include <ndis.h>
#include "dmautil.h"
#include <ntddndis.h>  // defines OID's

#include "settings.h"
#include "comm.h"
#include "sync.h"
#include "newdong.h"

#define NSC_MAJOR_VERSION 1
#define NSC_MINOR_VERSION 11
#define NSC_LETTER_VERSION 's'
#define NDIS_MAJOR_VERSION 5
#define NDIS_MINOR_VERSION 0

extern ULONG DebugSpeed;


#define TIMER_RESOLTION_IN_US (125)

#define TIMER_PERIODS         (10)

#define RECEIVE_TIMEOUT       (TIMER_RESOLTION_IN_US * TIMER_PERIODS)
//
// Registry Keywords.
//
#define CARDTYPE	    NDIS_STRING_CONST("BoardType")
#define DONGLE_A_TYPE	NDIS_STRING_CONST("Dongle_A_Type")
#define DONGLE_B_TYPE	NDIS_STRING_CONST("Dongle_B_Type")
#define MAXCONNECTRATE  NDIS_STRING_CONST("MaxConnectRate")


//
//  bank 0
//
#define BANK_0           (0)
#define TXD_RXD_OFFSET   (0)
#define LCR_BSR_OFFSET   (3)
#define LSR_OFFSET       (5)
#define ASCR_OFFSET      (7)

//
//  bank 2
//
#define BANK_2           (2)
#define TXFLV_OFFSET     (6)

#define BANK_4           (4)
#define TFRCCL_OFFSET    (4)
#define TFRCCH_OFFSET    (4)

#define BKSE             (1 << 7)

#define FRM_ST            (5)
#define RFRL_L            (6)
#define RFRL_H            (7)

#define ST_FIFO_LOST_FR   (1 << 6)
#define ST_FIFO_VALID     (1 << 7)


#define LSR_OE            (1 << 1)
#define LSR_TXRDY         (1 << 5)
#define LSR_TXEMP         (1 << 6)
#define LSR_FR_END        (1 << 7)

#define ASCR_TXUR         (1 << 6)


//
// Valid value ranges for the DMA Channels.
//
    #define VALID_DMACHANNELS {0xFF,0x0,0x1,0x3}

    #define FIR_INT_MASK 0x14
//#define FIR_INT_MASK 0x50

enum NSC_EXT_INTS {
    RXHDL_EV    = (1 << 0),
    TXLDL_EV    = (1 << 1),
    LS_EV       = (1 << 2),
    MS_EV       = (1 << 3),
    DMA_EV      = (1 << 4),
    TXEMP_EV    = (1 << 5),
    SFIF_EV     = (1 << 6),
    TMR_EV      = (1 << 7)
};


typedef struct DebugCounters {
    ULONG TxPacketsStarted;
    ULONG TxPacketsCompleted;
    ULONG ReceivedPackets;
    ULONG WindowSize;
    ULONG StatusFIFOOverflows;
    ULONG TxUnderruns;
    ULONG ReceiveFIFOOverflows;
    ULONG MissedPackets;
    ULONG ReceiveCRCErrors;
    ULONG ReturnPacketHandlerCalled;
    ULONG RxWindow;
    ULONG RxWindowMax;
    ULONG RxDPC_Window;
    ULONG RxDPC_WindowMax;
    ULONG RxDPC_G1_Count;
} DebugCounters;

/*
 *  A receive buffer is either FREE (not holding anything) FULL
 * (holding undelivered data) or PENDING (holding data delivered
 * asynchronously)
 */
typedef enum rcvbufferStates {
    STATE_FREE,
    STATE_FULL,
    STATE_PENDING
} rcvBufferState;

typedef struct {
    LIST_ENTRY listEntry;
    rcvBufferState state;
    PNDIS_PACKET packet;
    UINT dataLen;
    PUCHAR dataBuf;
    BOOLEAN isDmaBuf;
} rcvBuffer;


typedef struct _NSC_DMA_BUFFER_INFO {

    NDIS_HANDLE             AdapterHandle;
    ULONG                   Length;
    PVOID                   VirtualAddress;
    NDIS_PHYSICAL_ADDRESS   PhysicalAddress;
    BOOLEAN                 SharedAllocation;

} NSC_DMA_BUFFER_INFO, *PNSC_DMA_BUFFER_INFO;

typedef struct IrDevice {
    /*
     * This is the handle that the NDIS wrapper associates with a
     * connection.  The handle that the miniport driver associates with
     * the connection is just an index into the devStates array).
     */
    NDIS_HANDLE ndisAdapterHandle;

    int CardType;

    /*
     *  Current speed setting, in bits/sec.
     *  (Note: this is updated when we ACTUALLY change the speed,
     *         not when we get the request to change speed via
     *         MiniportSetInformation).
     */
    UINT currentSpeed;

    // Current dongle setting, 0 for dongle A, 1 for dongle B
    // and so on.
    //
    UCHAR DonglesSupported;
    UCHAR currentDongle;
    UCHAR DongleTypes[2];

    UIR      IrDongleResource;
    DongleParam  Dingle[2];

    UINT AllowedSpeedMask;
    /*
     *  This structure holds information about our ISR.
     *  It is used to synchronize with the ISR.
     */
    BOOLEAN                 InterruptRegistered;
    NDIS_MINIPORT_INTERRUPT interruptObj;


    /*
     *  Circular queue of pending receive buffers
     */
#define NUM_RCV_BUFS 16
//    #define NEXT_RCV_BUF_INDEX(i) (((i)==NO_BUF_INDEX) ? 0 : (((i)+1)%NUM_RCV_BUFS))
    LIST_ENTRY rcvBufBuf;       // Protected by SyncWithInterrupt
    LIST_ENTRY rcvBufFree;      // Protected by SyncWithInterrupt
    LIST_ENTRY rcvBufFull;      // Protected by SyncWithInterrupt
    LIST_ENTRY rcvBufPend;      // Protected by QueueLock



    NDIS_SPIN_LOCK QueueLock;
    LIST_ENTRY SendQueue;
    PNDIS_PACKET CurrentPacket;
    BOOLEAN      FirTransmitPending;
    BOOLEAN      FirReceiveDmaActive;
    BOOLEAN      TransmitIsIdle;
    BOOLEAN      Halting;

    BOOLEAN      TestingInterrupt;
    volatile BOOLEAN      GotTestInterrupt;

    LONG         PacketsSentToProtocol;

    NDIS_EVENT   ReceiveStopped;
    NDIS_EVENT   SendStoppedOnHalt;

    /*
     *  Handle to NDIS packet pool, from which packets are
     *  allocated.
     */
    NDIS_HANDLE packetPoolHandle;
    NDIS_HANDLE bufferPoolHandle;


    /*
     * mediaBusy is set TRUE any time that this miniport driver moves a
     * data frame.  It can be reset by the protocol via
     * MiniportSetInformation and later checked via
     * MiniportQueryInformation to detect interleaving activity.
     */
    LONG    RxInterrupts;
    BOOLEAN mediaBusy;
    BOOLEAN haveIndicatedMediaBusy;

    /*
     * nowReceiving is set while we are receiving a frame.
     * It (not mediaBusy) is returned to the protocol when the protocol
     * queries OID_MEDIA_BUSY
     */
    BOOLEAN nowReceiving;


    //
    // Interrupt Mask.
    //
    UCHAR FirIntMask;

    UCHAR LineStatus;
    UCHAR InterruptMask;
    UCHAR InterruptStatus;
    UCHAR AuxStatus;

    BOOLEAN    ForceTurnAroundTimeout;
#if DBG
    BOOLEAN    WaitingForTurnAroundTimer;

#endif

    /*
     *  Current link speed information.
     */
    const baudRateInfo *linkSpeedInfo;

    /*
     *  When speed is changed, we have to clear the send queue before
     *  setting the new speed on the hardware.
     *  These vars let us remember to do it.
     */
    PNDIS_PACKET lastPacketAtOldSpeed;
    BOOLEAN setSpeedAfterCurrentSendPacket;

    /*
     *  Information on the COM port and send/receive FSM's.
     */
    comPortInfo portInfo;

    UINT hardwareStatus;

    /*
     *  UIR Module ID.
     */
    int UIR_ModuleId;

    /*
     *  Maintain statistical debug info.
     */
    UINT packetsRcvd;
    UINT packetsDropped;
    UINT packetsSent;
    UINT interruptCount;


    /*
     *  DMA handles
     */
    NDIS_HANDLE DmaHandle;
    NDIS_HANDLE dmaBufferPoolHandle;
    PNDIS_BUFFER rcvDmaBuffer;
    PUCHAR    dmaReadBuf;
    ULONG_PTR rcvDmaOffset;
    ULONG_PTR rcvDmaSize;
    ULONG_PTR rcvPktOffset;
    ULONG_PTR LastReadDMACount;

    PNDIS_BUFFER xmitDmaBuffer;
//    PUCHAR       xmitDmaBufferVirtualAddress;

    NDIS_TIMER TurnaroundTimer;

    ULONG HangChk;

    BOOLEAN DiscardNextPacketSet;

    DMA_UTIL    DmaUtil;

    NSC_DMA_BUFFER_INFO    ReceiveDmaBufferInfo;
    NSC_DMA_BUFFER_INFO    TransmitDmaBufferInfo;
    PUCHAR                 TransmitDmaBuffer;
    ULONG                  TransmitDmaLength;


} IrDevice;

/*
 *  We use a pointer to the IrDevice structure as the miniport's device context.
 */
    #define CONTEXT_TO_DEV(__deviceContext) ((IrDevice *)(__deviceContext))
    #define DEV_TO_CONTEXT(__irdev) ((NDIS_HANDLE)(__irdev))

    #define ON  TRUE
    #define OFF FALSE

    #include "externs.h"


VOID
SyncWriteBankReg(
    PNDIS_MINIPORT_INTERRUPT InterruptObject,
    PUCHAR                   PortBase,
    UINT                     BankNumber,
    UINT                     RegisterIndex,
    UCHAR                    Value
    );

UCHAR
SyncReadBankReg(
    PNDIS_MINIPORT_INTERRUPT InterruptObject,
    PUCHAR                   PortBase,
    UINT                     BankNumber,
    UINT                     RegisterIndex
    );

VOID
SyncSetInterruptMask(
    IrDevice *thisDev,
    BOOLEAN enable
    );

BOOLEAN
SyncGetFifoStatus(
    PNDIS_MINIPORT_INTERRUPT InterruptObject,
    PUCHAR                   PortBase,
    PUCHAR                   Status,
    PULONG                   Size
    );


VOID
ProcessSendQueue(
    IrDevice *thisDev
    );

PVOID
NscAllocateDmaBuffer(
    NDIS_HANDLE     AdapterHandle,
    ULONG           Size,
    PNSC_DMA_BUFFER_INFO    DmaBufferInfo
    );

VOID
NscFreeDmaBuffer(
    PNSC_DMA_BUFFER_INFO    DmaBufferInfo
    );



#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(CtlGuid,(57AC2B71,75CD,4043,9B00,B51674B0DC71), \
       WPP_DEFINE_BIT(DBG_LOG_ERROR)               \
       WPP_DEFINE_BIT(DBG_LOG_INFO)                \
       WPP_DEFINE_BIT(DBG_LOG_FIR)                 \
       WPP_DEFINE_BIT(DBG_LOG_SIR)                 \
       )

#endif NSC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\nsctypes.h ===
/*
**  nsctypes.h      - Local Standard Data Types
**
** Portions Copyright (C) 1996-1998 National Semiconductor Corp.
** All rights reserved.
** Copyright (C) 1996-1998 Microsoft Corporation. All Rights Reserved.
**
**  $Id$
**
**  $Log$
**
**
*/
#ifndef  _nsctypes_h_
#define  _nsctypes_h_   1


#ifdef	__BORLANDC__
#define	MSDOS	1
#endif
#ifdef  sparc
#define _FAR_
#define	cdecl
#endif
#ifdef  NDIS_NT
#define _FAR_
#endif
#ifdef  NDIS50_MINIPORT
#define _FAR_
#endif
#ifdef  SCO_UNIX
#define _FAR_
#endif
#ifdef  MSDOS
#define _FAR_   __far
#endif
#ifdef	ODI32
#define	_FAR_
#endif
#ifdef  CHICAGO
#define _FAR_
#endif

#ifdef	DOS_32
#ifdef	_FAR_
#undef	_FAR_
#endif
#define	_FAR_
#endif

#ifndef  NDIS50_MINIPORT
#ifndef FALSE
#define FALSE           0
#endif
#ifndef TRUE
#define TRUE            (!FALSE)
#endif
#endif

#ifndef NULL
#define NULL            0
#endif

#ifndef min
#define min(a,b)        ((a)<(b)?(a):(b))
#endif

#ifndef max
#define max(a,b)        ((a)>(b)?(a):(b))
#endif

typedef unsigned long   uint32;
typedef unsigned short  uint16;
typedef unsigned char   uchar;

typedef long            int32;
typedef short           int16;
typedef int             bool;

typedef	uint32	_FAR_	*uint32P;
typedef	uint16	_FAR_ 	*uint16P;
typedef	uchar	_FAR_ 	*ucharP;
typedef	char	_FAR_ 	*charP;
typedef	void	_FAR_	*PVOID;

/* macro useful for converting structure field names to
** byte offsets */

#define FieldOffset(s,x)   ((int)&(((s *)0)->x))

#ifndef CHICAGO
#ifndef GUI_BUILD
#define LOBYTE(w)       ((uchar)(w))
#define HIBYTE(w)       ((uchar)((uint16)(w) >> 8))
#define LOWORD(l)       ((uint16)(uint32)(l))
#define HIWORD(l)       ((uint16)(((uint32)(l)) >> 16))
#endif  /* GUI_BUILD */
#endif /* CHICAGO */

#define MAKEUINT16( msb, lsb ) (((uint16)msb << 8) + lsb)
#define MAKEUINT32(hi, lo) ((uint32)(((uint16)(lo)) | (((uint32)((uint16)(hi))) << 16)))

#define ARRAY_SIZE(a)   (sizeof(a)/sizeof(a[0]))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nscirda.rc
//
// Portions Copyright (C) 1996-1998 National Semiconductor Corp.
// All rights reserved.
// Copyright (C) 1996-1998 Microsoft Corporation. All Rights Reserved.
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\settings.c ===
/*
 ************************************************************************
 *
 *	SETTINGS.c
 *
 *
 * Portions Copyright (C) 1996-2001 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */



#include "nsc.h"
#include "settings.tmh"



const baudRateInfo supportedBaudRateTable[NUM_BAUDRATES] = {
	{
		BAUDRATE_2400,
		2400,
		NDIS_IRDA_SPEED_2400,
	},
	{
		BAUDRATE_9600,
		9600,
		NDIS_IRDA_SPEED_9600,
	},
	{
		BAUDRATE_19200,
		19200,
		NDIS_IRDA_SPEED_19200,
	},
	{
		BAUDRATE_38400,
		38400,
		NDIS_IRDA_SPEED_38400,
	},
	{
		BAUDRATE_57600,
		57600,
		NDIS_IRDA_SPEED_57600,
	},
	{
		BAUDRATE_115200,
		115200,
		NDIS_IRDA_SPEED_115200,
	},
	{
		BAUDRATE_576000,
		576000,
		NDIS_IRDA_SPEED_576K,
	},
	{
		BAUDRATE_1152000,
		1152000,
		NDIS_IRDA_SPEED_1152K,
	},
	{
		BAUDRATE_4000000,
		4000000,
		NDIS_IRDA_SPEED_4M,
	}
};

#if DBG

//	UINT dbgOpt = DBG_LOG | DBG_FIR_MODE ;
	UINT dbgOpt = DBG_ERR; //|DBG_FIR_MODE|DBG_SIR_MODE|DBG_BUF;

#ifdef DBG_ADD_PKT_ID
	
	BOOLEAN addPktIdOn = TRUE;
#endif


VOID DBG_PrintBuf(PUCHAR bufptr, UINT buflen)
{
	UINT i, linei;

	#define ISPRINT(ch) (((ch) >= ' ') && ((ch) <= '~'))
	#define PRINTCHAR(ch) (UCHAR)(ISPRINT(ch) ? (ch) : '.')

	DbgPrint("\r\n         %d bytes @%xh:", buflen, bufptr);

	/*
	 *  Print whole lines of 8 characters with HEX and ASCII
	 */
	for (i = 0; i+8 <= (UINT)buflen; i += 8) {
		UCHAR ch0 = bufptr[i+0],
			ch1 = bufptr[i+1], ch2 = bufptr[i+2],
			ch3 = bufptr[i+3], ch4 = bufptr[i+4],
			ch5 = bufptr[i+5], ch6 = bufptr[i+6],
			ch7 = bufptr[i+7];

		DbgPrint("\r\n         %02x %02x %02x %02x %02x %02x %02x %02x"
			"   %c %c %c %c %c %c %c %c",
			ch0, ch1, ch2, ch3, ch4, ch5, ch6, ch7,
			PRINTCHAR(ch0), PRINTCHAR(ch1),
			PRINTCHAR(ch2), PRINTCHAR(ch3),
			PRINTCHAR(ch4), PRINTCHAR(ch5),
			PRINTCHAR(ch6), PRINTCHAR(ch7));
	}

	/*
	 *  Print final incomplete line
	 */
	DbgPrint("\r\n        ");
	for (linei = 0; (linei < 8) && (i < buflen); i++, linei++){
		DbgPrint(" %02x", (UINT)(bufptr[i]));
	}

	DbgPrint("  ");
	i -= linei;
	while (linei++ < 8) DbgPrint("   ");

	for (linei = 0; (linei < 8) && (i < buflen); i++, linei++){
		UCHAR ch = bufptr[i];
		DbgPrint(" %c", PRINTCHAR(ch));
	}

	DbgPrint("\t\t<>\r\n");

}

VOID DBG_NDIS_Buffer(PNDIS_BUFFER ndisBuf);

VOID DBG_NDIS_Buffer(PNDIS_BUFFER ndisBuf)
{
	UCHAR *ptr;
	UINT  bufLen;

	NdisQueryBufferSafe(ndisBuf, (PVOID *)&ptr, &bufLen,NormalPagePriority);

    if (ptr != NULL) {

	    DBG_PrintBuf(ptr, bufLen);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\request.c ===
/*
 ************************************************************************
 *
 *	REQUEST.c
 *
 *
 *		(C) Copyright 1996 National Semiconductor Corp.
 *		(C) Copyright 1996 Microsoft Corp.
 *
 *
 *		(ep)
 *
 *************************************************************************
 */

#include "nsc.h"
#include "request.tmh"
#include "newdong.h"



const  NDIS_OID NSCGlobalSupportedOids[] = {
	OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
	OID_GEN_MEDIA_SUPPORTED,
	OID_GEN_MEDIA_IN_USE,
	OID_GEN_MAXIMUM_LOOKAHEAD,
	OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_SEND_PACKETS,
	OID_GEN_MAXIMUM_TOTAL_SIZE,
	OID_GEN_MAC_OPTIONS,
	OID_GEN_PROTOCOL_OPTIONS,
	OID_GEN_LINK_SPEED,
	OID_GEN_TRANSMIT_BUFFER_SPACE,
	OID_GEN_RECEIVE_BUFFER_SPACE,
	OID_GEN_TRANSMIT_BLOCK_SIZE,
	OID_GEN_RECEIVE_BLOCK_SIZE,
	OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_DRIVER_VERSION,
	OID_GEN_DRIVER_VERSION,
	OID_GEN_CURRENT_PACKET_FILTER,
	OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_MEDIA_CONNECT_STATUS,
	OID_IRDA_RECEIVING,
	OID_IRDA_SUPPORTED_SPEEDS,
	OID_IRDA_LINK_SPEED,
	OID_IRDA_MEDIA_BUSY,
	OID_IRDA_TURNAROUND_TIME,
	OID_IRDA_MAX_RECEIVE_WINDOW_SIZE,
	OID_IRDA_EXTRA_RCV_BOFS,
    OID_IRDA_MAX_SEND_WINDOW_SIZE
    };


//////////////////////////////////////////////////////////////////////////
//									//
//  Function:	    MiniportQueryInformation				//
//									//
//  Description:							//
//  Query the capabilities and status of the miniport driver.		//
//									//
//////////////////////////////////////////////////////////////////////////

NDIS_STATUS MiniportQueryInformation (
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded)
{
    NDIS_STATUS result = NDIS_STATUS_SUCCESS;
    IrDevice *thisDev = CONTEXT_TO_DEV(MiniportAdapterContext);
    INT i, speeds, speedSupported;
    UINT *infoPtr;

    NDIS_MEDIUM Medium = NdisMediumIrda;
    ULONG GenericUlong;
    PVOID SourceBuffer = (PVOID) (&GenericUlong);
    ULONG SourceLength = sizeof(ULONG);


    ULONG BaudRateTable[NUM_BAUDRATES];


    switch (Oid){

	case OID_GEN_SUPPORTED_LIST:
	    SourceBuffer = (PVOID) (NSCGlobalSupportedOids);
	    SourceLength = sizeof(NSCGlobalSupportedOids);
	    break;

    case OID_GEN_HARDWARE_STATUS:
        GenericUlong = thisDev->hardwareStatus;
        break;

	case OID_GEN_MEDIA_SUPPORTED:
	case OID_GEN_MEDIA_IN_USE:
	    SourceBuffer = (PVOID) (&Medium);
	    SourceLength = sizeof(NDIS_MEDIUM);
	    break;

	case OID_IRDA_RECEIVING:
	    DBGOUT(("MiniportQueryInformation(OID_IRDA_RECEIVING)"));
	    GenericUlong = (ULONG)thisDev->nowReceiving;
	    break;
			
	case OID_IRDA_SUPPORTED_SPEEDS:
	    DBGOUT(("MiniportQueryInformation(OID_IRDA_SUPPORTED_SPEEDS)"));

	    speeds = thisDev->portInfo.hwCaps.supportedSpeedsMask &
                            thisDev->AllowedSpeedMask &
							ALL_IRDA_SPEEDS;

        for (i = 0, infoPtr = (PUINT)BaudRateTable, SourceLength=0;
             (i < NUM_BAUDRATES) && speeds;
             i++){

            if (supportedBaudRateTable[i].ndisCode & speeds){
                *infoPtr++ = supportedBaudRateTable[i].bitsPerSec;
                SourceLength += sizeof(UINT);
                speeds &= ~supportedBaudRateTable[i].ndisCode;
                DBGOUT((" - supporting speed %d bps", supportedBaudRateTable[i].bitsPerSec));
            }
        }

	    SourceBuffer = (PVOID) BaudRateTable;
	    break;

	case OID_GEN_LINK_SPEED:
	    // The maximum speed of NIC is 4Mbps
	    GenericUlong = 40000;  // 100bps increments
	    break;

	case OID_IRDA_LINK_SPEED:
	    DBGOUT(("MiniportQueryInformation(OID_IRDA_LINK_SPEED)"));
	    if (thisDev->linkSpeedInfo){
    		GenericUlong = (ULONG)thisDev->linkSpeedInfo->bitsPerSec;
	    }
	    else {
	    	GenericUlong = DEFAULT_BAUD_RATE;
	    }
	    break;

	case OID_IRDA_MEDIA_BUSY:
	    DBGOUT(("MiniportQueryInformation(OID_IRDA_MEDIA_BUSY)"));
	    GenericUlong = (UINT)thisDev->mediaBusy;
	    break;

	case OID_GEN_CURRENT_LOOKAHEAD:
	case OID_GEN_MAXIMUM_LOOKAHEAD:
	    DBGOUT(("MiniportQueryInformation(OID_GEN_MAXIMUM_LOOKAHEAD)"));
	    GenericUlong = MAX_I_DATA_SIZE;
	    break;

    case OID_GEN_MAXIMUM_TOTAL_SIZE:
    case OID_GEN_TRANSMIT_BLOCK_SIZE:
    case OID_GEN_RECEIVE_BLOCK_SIZE:
	case OID_GEN_MAXIMUM_FRAME_SIZE:
	    DBGOUT(("MiniportQueryInformation(OID_GEN_MAXIMUM_LOOKAHEAD)"));

        // Normally there's some difference in these values, based on the
        // MAC header, but IrDA doesn't have one.

	    GenericUlong = MAX_I_DATA_SIZE;
	    break;

	case OID_GEN_RECEIVE_BUFFER_SPACE:
	case OID_GEN_TRANSMIT_BUFFER_SPACE:
	    GenericUlong = (ULONG) (MAX_IRDA_DATA_SIZE * 8);
	    break;

	case OID_GEN_MAC_OPTIONS:
	    DBGOUT(("MiniportQueryInformation(OID_GEN_MAC_OPTIONS)"));
	    GenericUlong = 0;
	    break;

	case OID_GEN_MAXIMUM_SEND_PACKETS:
	    DBGOUT(("MiniportQueryInformation(OID_GEN_MAXIMUM_SEND_PACKETS)"));
	    GenericUlong = 16;
	    break;

	case OID_IRDA_TURNAROUND_TIME:
	    // Indicate the amount of time that the transceiver needs
	    // to recuperate after a send.
	    DBGOUT(("MiniportQueryInformation(OID_IRDA_TURNAROUND_TIME)"));
	    GenericUlong =
		      (ULONG)thisDev->portInfo.hwCaps.turnAroundTime_usec;
	    break;

	case OID_IRDA_EXTRA_RCV_BOFS:
	    // Pass back the number of _extra_ BOFs to be prepended
	    // to packets sent to this unit at 115.2 baud, the
	    // maximum Slow IR speed.  This will be scaled for other
	    // speed according to the table in the
	    // Infrared Extensions to NDIS' spec.
	    DBGOUT(("MiniportQueryInformation(OID_IRDA_EXTRA_RCV_BOFS)"));
	    GenericUlong = (ULONG)thisDev->portInfo.hwCaps.extraBOFsRequired;
	    break;

	case OID_GEN_CURRENT_PACKET_FILTER:
	    DBGOUT(("MiniportQueryInformation(OID_GEN_CURRENT_PACKET_FILTER)"));
	    GenericUlong = NDIS_PACKET_TYPE_PROMISCUOUS;
	    break;

	case OID_IRDA_MAX_RECEIVE_WINDOW_SIZE:
	    DBGOUT(("MiniportQueryInformation(OID_IRDA_MAX_RECEIVE_WINDOW_SIZE)"));
	    GenericUlong = MAX_RX_PACKETS;
	    //GenericUlong = 1;
	    break;

	case OID_GEN_VENDOR_DESCRIPTION:
	    SourceBuffer = (PVOID)"NSC Infrared Port";
	    SourceLength = 18;
	    break;

    case OID_GEN_VENDOR_DRIVER_VERSION:
        // This value is used to know whether to update driver.
        GenericUlong = (NSC_MAJOR_VERSION << 16) +
                       (NSC_MINOR_VERSION << 8) +
                       NSC_LETTER_VERSION;
        break;

	case OID_GEN_DRIVER_VERSION:
        GenericUlong = (NDIS_MAJOR_VERSION << 8) + NDIS_MINOR_VERSION;
        SourceLength = 2;
	    break;

    case OID_IRDA_MAX_SEND_WINDOW_SIZE:
        GenericUlong = 7;
        break;

    case OID_GEN_MEDIA_CONNECT_STATUS:
        GenericUlong = (ULONG) NdisMediaStateConnected;
        break;


	default:
	    DBGERR(("MiniportQueryInformation(%d=0x%x), unsupported OID", Oid, Oid));
	    result = NDIS_STATUS_NOT_SUPPORTED;
	    break;
    }

    if (result == NDIS_STATUS_SUCCESS) {

     	if (SourceLength > InformationBufferLength) {

    	    *BytesNeeded = SourceLength;
    	    result = NDIS_STATUS_INVALID_LENGTH;

    	} else {

    	    *BytesNeeded = 0;
    	    *BytesWritten = SourceLength;
    	    NdisMoveMemory(InformationBuffer, SourceBuffer, SourceLength);
            DBGOUT(("MiniportQueryInformation succeeded (info <- %d)", *(UINT *)InformationBuffer));
    	}
    }


    return result;

}


//////////////////////////////////////////////////////////////////////////
//									//
//  Function:	    MiniportSetInformation				//
//									//
//  Description:							//
//  Allow other layers of the network software (e.g., a transport	//
//  driver) to control the miniport driver by changing information that //
//  the miniport driver maintains in its OIDs, such as the packet	//
//  or multicast addresses.						//
//									//
//////////////////////////////////////////////////////////////////////////

NDIS_STATUS MiniportSetInformation (
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded)
{
    NDIS_STATUS result = NDIS_STATUS_SUCCESS;
    IrDevice *thisDev = CONTEXT_TO_DEV(MiniportAdapterContext);
    UINT i,speedSupported;
    const baudRateInfo *    CurrentLinkSpeed;

    if (InformationBufferLength >= sizeof(UINT)){

	UINT info = *(UINT *)InformationBuffer;
	*BytesRead = sizeof(UINT);
	*BytesNeeded = 0;

	switch (Oid){
	    case OID_IRDA_LINK_SPEED:
		DBGOUT(("MiniportSetInformation(OID_IRDA_LINK_SPEED, %xh)",
			 info));
		result = NDIS_STATUS_INVALID_DATA;

        CurrentLinkSpeed=thisDev->linkSpeedInfo;

		// Find the appropriate speed  and  set it
		speedSupported = NUM_BAUDRATES;
		for (i = 0; i < speedSupported; i++){
		    if (supportedBaudRateTable[i].bitsPerSec == info){
			thisDev->linkSpeedInfo = &supportedBaudRateTable[i];
			result = NDIS_STATUS_SUCCESS;
			break;
		    }
		}
		if (result == NDIS_STATUS_SUCCESS){

            if (CurrentLinkSpeed != thisDev->linkSpeedInfo) {
                //
                //  different from the current
                //
                BOOLEAN    DoItNow=TRUE;

                NdisAcquireSpinLock(&thisDev->QueueLock);

                if (!IsListEmpty(&thisDev->SendQueue)){
                    //
                    //  packets queued, change after this one
                    //
                    thisDev->lastPacketAtOldSpeed = CONTAINING_RECORD(thisDev->SendQueue.Blink,
                                                                          NDIS_PACKET,
                                                                          MiniportReserved);
            		DBGOUT(("delaying set-speed because send pkts queued"));
                    DoItNow=FALSE;


                } else {
                    //
                    //  no packets in the queue
                    //
                    if (thisDev->CurrentPacket != NULL) {
                        //
                        //  the current packet is the only one
                        //
                        thisDev->lastPacketAtOldSpeed=thisDev->CurrentPacket;
                        thisDev->setSpeedAfterCurrentSendPacket = TRUE;

                		DBGOUT(("delaying set-speed because send pkts queued"));
                        DoItNow=FALSE;

                    }

                }

                if (DoItNow) {

    		        if (!SetSpeed(thisDev)){
        	    		result = NDIS_STATUS_FAILURE;
    		        }

                    thisDev->TransmitIsIdle=FALSE;
                }

                NdisReleaseSpinLock(&thisDev->QueueLock);

                if (DoItNow) {

                    ProcessSendQueue(thisDev);
                }
            }
		}
		else {
		    *BytesRead = 0;
		    *BytesNeeded = 0;
		}
		break;

	    case OID_IRDA_MEDIA_BUSY:
		DBGOUT(("MiniportSetInformation(OID_IRDA_MEDIA_BUSY, %xh)",
			 info));

		//  The protocol can use this OID to reset the busy field
		//  in order to check it later for intervening activity.
		//
		thisDev->mediaBusy = (BOOLEAN)info;
        InterlockedExchange(&thisDev->RxInterrupts,0);
		result = NDIS_STATUS_SUCCESS;
		break;

	    case OID_GEN_CURRENT_PACKET_FILTER:
		DBGOUT(
		 ("MiniportSetInformation(OID_GEN_CURRENT_PACKET_FILTER, %xh)",
		  info));
		result = NDIS_STATUS_SUCCESS;
		break;


        case OID_GEN_CURRENT_LOOKAHEAD:
        result = (info<=MAX_I_DATA_SIZE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_INVALID_LENGTH;
        break;

	    //	 We don't support these
	    //
	    case OID_IRDA_RATE_SNIFF:
	    case OID_IRDA_UNICAST_LIST:

	     // These are query-only parameters.
	     //
	    case OID_IRDA_SUPPORTED_SPEEDS:
	    case OID_IRDA_MAX_UNICAST_LIST_SIZE:
	    case OID_IRDA_TURNAROUND_TIME:

	    default:
		DBGERR(("MiniportSetInformation(OID=%d=0x%x, value=%xh) - unsupported OID", Oid, Oid, info));
		*BytesRead = 0;
		*BytesNeeded = 0;
		result = NDIS_STATUS_NOT_SUPPORTED;
		break;
	}
    }
    else {
	*BytesRead = 0;
	*BytesNeeded = sizeof(UINT);
	result = NDIS_STATUS_INVALID_LENGTH;
    }

    DBGOUT(("MiniportSetInformation succeeded"));
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\resource.c ===
/*
 ************************************************************************
 *
 *	RESOURCE.c
 *
 *
 * Portions Copyright (C) 1996-2001 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */


#include "nsc.h"
#include "resource.tmh"


/*
 *************************************************************************
 *  MyMemAlloc
 *************************************************************************
 *
 */
PVOID NscMemAlloc(UINT size)
{
    NDIS_STATUS stat;
    PVOID memptr;

    stat = NdisAllocateMemoryWithTag(
                                &memptr,
                                size,
                                'rIsN'
                                );

    if (stat == NDIS_STATUS_SUCCESS) {

        NdisZeroMemory((PVOID)memptr, size);

    } else {

        DBGERR(("Memory allocation failed"));
        memptr = NULL;
    }

    return memptr;
}


/*
 *************************************************************************
 *  MyMemFree
 *************************************************************************
 *
 */
VOID NscMemFree(PVOID memptr)
{

    NdisFreeMemory(memptr, 0, 0);
}

PVOID
NscAllocateDmaBuffer(
    NDIS_HANDLE     AdapterHandle,
    ULONG           Size,
    PNSC_DMA_BUFFER_INFO    DmaBufferInfo
    )

{
    NDIS_STATUS     Status;

    NdisZeroMemory(DmaBufferInfo,sizeof(*DmaBufferInfo));

    DmaBufferInfo->Length=Size;
    DmaBufferInfo->AdapterHandle=AdapterHandle;

    NdisMAllocateSharedMemory(
        DmaBufferInfo->AdapterHandle,
        DmaBufferInfo->Length,
        TRUE,
        &DmaBufferInfo->VirtualAddress,
        &DmaBufferInfo->PhysicalAddress
        );

    if (DmaBufferInfo->VirtualAddress == NULL) {
        //
        // new style did not work, try old style
        //
        const NDIS_PHYSICAL_ADDRESS MaxAddress = NDIS_PHYSICAL_ADDRESS_CONST(0x00ffffff, 0);
#if DBG
        DbgPrint("NSCIRDA: NdisMAllocateSharedMemoryFailed(), calling NdisAllocateMemory() instead (ok for XP and W2K)\n");
#endif
        Status=NdisAllocateMemory(
            &DmaBufferInfo->VirtualAddress,
            DmaBufferInfo->Length,
            NDIS_MEMORY_CONTIGUOUS | NDIS_MEMORY_NONCACHED,
            MaxAddress
            );

        if (Status != STATUS_SUCCESS) {
            //
            //  old style allocation failed
            //
            NdisZeroMemory(DmaBufferInfo,sizeof(*DmaBufferInfo));

        } else {
            //
            //  old style work, not a shared allocation
            //
            DmaBufferInfo->SharedAllocation=FALSE;
        }

    } else {
        //
        //  new style worked
        //
        DmaBufferInfo->SharedAllocation=TRUE;
    }

    return DmaBufferInfo->VirtualAddress;

}

VOID
NscFreeDmaBuffer(
    PNSC_DMA_BUFFER_INFO    DmaBufferInfo
    )

{

    if ((DmaBufferInfo->AdapterHandle == NULL) || (DmaBufferInfo->VirtualAddress == NULL)) {
        //
        //  Not been allocated
        //
        ASSERT(0);

        return;
    }

    if (DmaBufferInfo->SharedAllocation) {
        //
        //  allocated with ndis shared memory functions
        //
        NdisMFreeSharedMemory(
            DmaBufferInfo->AdapterHandle,
            DmaBufferInfo->Length,
            TRUE,
            DmaBufferInfo->VirtualAddress,
            DmaBufferInfo->PhysicalAddress\
            );

    } else {
        //
        //  Allocated via old api
        //
#if DBG
        DbgPrint("NSCIRDA: Freeing DMA buffer with NdisFreeMemory() (ok for XP and W2K)\n");
#endif

        NdisFreeMemory(
            DmaBufferInfo->VirtualAddress,
            DmaBufferInfo->Length,
            NDIS_MEMORY_CONTIGUOUS | NDIS_MEMORY_NONCACHED
            );

    }

    NdisZeroMemory(DmaBufferInfo,sizeof(*DmaBufferInfo));

    return;

}


/*
 *************************************************************************
 *  NewDevice
 *************************************************************************
 *
 */
IrDevice *NewDevice()
{
    IrDevice *newdev;

    newdev = NscMemAlloc(sizeof(IrDevice));
    if (newdev){
        InitDevice(newdev);
    }
    return newdev;
}


/*
 *************************************************************************
 *  FreeDevice
 *************************************************************************
 *
 */
VOID FreeDevice(IrDevice *dev)
{
    CloseDevice(dev);
    NscMemFree((PVOID)dev);
}



/*
 *************************************************************************
 *  InitDevice
 *************************************************************************
 *
 *  Zero out the device object.
 *
 *  Allocate the device object's spinlock, which will persist while
 *  the device is opened and closed.
 *
 */
VOID InitDevice(IrDevice *thisDev)
{
    NdisZeroMemory((PVOID)thisDev, sizeof(IrDevice));
    NdisInitializeListHead(&thisDev->SendQueue);
    NdisAllocateSpinLock(&thisDev->QueueLock);
    NdisInitializeTimer(&thisDev->TurnaroundTimer,
                        DelayedWrite,
                        thisDev);
    NdisInitializeListHead(&thisDev->rcvBufBuf);
    NdisInitializeListHead(&thisDev->rcvBufFree);
    NdisInitializeListHead(&thisDev->rcvBufFull);
    NdisInitializeListHead(&thisDev->rcvBufPend);
}




/*
 *************************************************************************
 *  OpenDevice
 *************************************************************************
 *
 *  Allocate resources for a single device object.
 *
 *  This function should be called with device lock already held.
 *
 */
BOOLEAN OpenDevice(IrDevice *thisDev)
{
    BOOLEAN result = FALSE;
    NDIS_STATUS stat;
    UINT bufIndex;

    DBGOUT(("OpenDevice()"));

    if (!thisDev){
        return FALSE;
    }


    /*
     *  Allocate the NDIS packet and NDIS buffer pools
     *  for this device's RECEIVE buffer queue.
     *  Our receive packets must only contain one buffer apiece,
     *  so #buffers == #packets.
     */

    NdisAllocatePacketPool(&stat, &thisDev->packetPoolHandle, NUM_RCV_BUFS, 6 * sizeof(PVOID));
    if (stat != NDIS_STATUS_SUCCESS){
        goto _openDone;
    }

    NdisAllocateBufferPool(&stat, &thisDev->bufferPoolHandle, NUM_RCV_BUFS);
    if (stat != NDIS_STATUS_SUCCESS){
        goto _openDone;
    }


    //
    //  allocate the receive buffers used to hold receives SIR frames
    //
    for (bufIndex = 0; bufIndex < NUM_RCV_BUFS; bufIndex++){

        PVOID buf;

        buf = NscMemAlloc(RCV_BUFFER_SIZE);

        if (!buf){
            goto _openDone;
        }

        // We treat the beginning of the buffer as a LIST_ENTRY.

        // Normally we would use NDISSynchronizeInsertHeadList, but the
        // Interrupt hasn't been registered yet.
        InsertHeadList(&thisDev->rcvBufBuf, (PLIST_ENTRY)buf);

    }

    //
    //  initialize the data structures that keep track of receives buffers
    //
    for (bufIndex = 0; bufIndex < NUM_RCV_BUFS; bufIndex++){

        rcvBuffer *rcvBuf = NscMemAlloc(sizeof(rcvBuffer));

        if (!rcvBuf)
        {
            goto _openDone;
        }

        rcvBuf->state = STATE_FREE;
        rcvBuf->isDmaBuf = FALSE;

        /*
         *  Allocate a data buffer
         *
         *  This buffer gets swapped with the one on comPortInfo
         *  and must be the same size.
         */
        rcvBuf->dataBuf = NULL;

        /*
         *  Allocate the NDIS_PACKET.
         */
        NdisAllocatePacket(&stat, &rcvBuf->packet, thisDev->packetPoolHandle);
        if (stat != NDIS_STATUS_SUCCESS){

            NscMemFree(rcvBuf);
            rcvBuf=NULL;
            goto _openDone;
        }

        /*
         *  For future convenience, set the MiniportReserved portion of the packet
         *  to the index of the rcv buffer that contains it.
         *  This will be used in ReturnPacketHandler.
         */
        *(ULONG_PTR *)rcvBuf->packet->MiniportReserved = (ULONG_PTR)rcvBuf;

        rcvBuf->dataLen = 0;

        InsertHeadList(&thisDev->rcvBufFree, &rcvBuf->listEntry);

    }



    /*
     *  Set mediaBusy to TRUE initially.  That way, we won't
     *  IndicateStatus to the protocol in the ISR unless the
     *  protocol has expressed interest by clearing this flag
     *  via MiniportSetInformation(OID_IRDA_MEDIA_BUSY).
     */
    thisDev->mediaBusy = FALSE;
    thisDev->haveIndicatedMediaBusy = TRUE;

    /*
     *  Will set speed to 9600 baud initially.
     */
    thisDev->linkSpeedInfo = &supportedBaudRateTable[BAUDRATE_9600];

    thisDev->lastPacketAtOldSpeed = NULL;
    thisDev->setSpeedAfterCurrentSendPacket = FALSE;

    result = TRUE;

    _openDone:
    if (!result){
        /*
         *  If we're failing, close the device to free up any resources
         *  that were allocated for it.
         */
        CloseDevice(thisDev);
        DBGOUT(("OpenDevice() failed"));
    }
    else {
        DBGOUT(("OpenDevice() succeeded"));
    }
    return result;

}



/*
 *************************************************************************
 *  CloseDevice
 *************************************************************************
 *
 *  Free the indicated device's resources.
 *
 *
 *  Called for shutdown and reset.
 *  Don't clear ndisAdapterHandle, since we might just be resetting.
 *  This function should be called with device lock held.
 *
 *
 */
VOID CloseDevice(IrDevice *thisDev)
{
    PLIST_ENTRY ListEntry;

    DBGOUT(("CloseDevice()"));

    if (!thisDev){
        return;
    }

    /*
     *  Free all resources for the RECEIVE buffer queue.
     */

    while (!IsListEmpty(&thisDev->rcvBufFree))
    {
        rcvBuffer *rcvBuf;

        ListEntry = RemoveHeadList(&thisDev->rcvBufFree);
        rcvBuf = CONTAINING_RECORD(ListEntry,
                                   rcvBuffer,
                                   listEntry);

        if (rcvBuf->packet){
            NdisFreePacket(rcvBuf->packet);
            rcvBuf->packet = NULL;
        }

        NscMemFree(rcvBuf);
    }


    while (!IsListEmpty(&thisDev->rcvBufBuf))
    {
        ListEntry = RemoveHeadList(&thisDev->rcvBufBuf);
        NscMemFree(ListEntry);
    }
    /*
     *  Free the packet and buffer pool handles for this device.
     */
    if (thisDev->packetPoolHandle){
        NdisFreePacketPool(thisDev->packetPoolHandle);
        thisDev->packetPoolHandle = NULL;
    }

    if (thisDev->bufferPoolHandle){
        NdisFreeBufferPool(thisDev->bufferPoolHandle);
        thisDev->bufferPoolHandle = NULL;
    }

    //
    //  the send queue should be empty now
    //
    ASSERT(IsListEmpty(&thisDev->SendQueue));


    thisDev->mediaBusy = FALSE;
    thisDev->haveIndicatedMediaBusy = FALSE;

    thisDev->linkSpeedInfo = NULL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\sync.h ===
/*
 ************************************************************************
 *
 *	SYNC.H
 *
 * Copyright (C) 1997-1998 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */

typedef enum {
    SyncInsertHead,
    SyncInsertTail,
    SyncRemoveHead,
    SyncRemoveTail,
    SyncRemove
} SynchronizeCmd;

typedef struct {
    PLIST_ENTRY Head;
    PLIST_ENTRY Entry;
    SynchronizeCmd Command;
} SynchronizeList;

extern BOOLEAN SynchronizedListFunc(IN PVOID Context);

#define NDISSynchronizedInsertHeadList(head, entry, interrupt)                                      \
{                                                                                                   \
    SynchronizeList ListData;                                                                       \
                                                                                                    \
    ListData.Head = (head);                                                                         \
    ListData.Entry = (entry);                                                                       \
    ListData.Command = SyncInsertHead;                                                              \
    (void)NdisMSynchronizeWithInterrupt((interrupt), SynchronizedListFunc, &ListData);    \
}

#define NDISSynchronizedInsertTailList(head, entry, interrupt)                                       \
{                                                                                                   \
    SynchronizeList ListData;                                                                       \
                                                                                                    \
    ListData.Head = (head);                                                                         \
    ListData.Entry = (entry);                                                                       \
    ListData.Command = SyncInsertTail;                                                              \
    (void)NdisMSynchronizeWithInterrupt((interrupt), SynchronizedListFunc, &ListData);    \
}

#define NDISSynchronizedRemoveEntryList(entry, interrupt)                                           \
{                                                                                                   \
    SynchronizeList ListData;                                                                       \
                                                                                                    \
    ListData.Entry = (entry);                                                                       \
    ListData.Command = SyncRemove;                                                                  \
    (void)NdisMSynchronizeWithInterrupt((interrupt), SynchronizedListFunc, &ListData);    \
}

static PLIST_ENTRY __inline NDISSynchronizedRemoveHeadList(PLIST_ENTRY Head,
                                                           PNDIS_MINIPORT_INTERRUPT Interrupt)
{
    SynchronizeList ListData;                                                                       \

    ListData.Head = Head;
    ListData.Command = SyncRemoveHead;
    (void)NdisMSynchronizeWithInterrupt(Interrupt, SynchronizedListFunc, &ListData);

    return ListData.Entry;
}

static PLIST_ENTRY __inline NDISSynchronizedRemoveTailList(PLIST_ENTRY Head,
                                                           PNDIS_MINIPORT_INTERRUPT Interrupt)
{
    SynchronizeList ListData;                                                                       \

    ListData.Head = Head;
    ListData.Command = SyncRemoveTail;
    (void)NdisMSynchronizeWithInterrupt(Interrupt, SynchronizedListFunc, &ListData);

    return ListData.Entry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\sys\irdap.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    irda.h

Abstract:

    irda.sys

Author:

    Zed (mikezin)   09-Sep-1996
    mbert           Sept 97

--*/

#include <irdatdi.h>

extern POBJECT_TYPE *IoFileObjectType;

#define SHIFT10000 13
#define CTEConvert100nsToMilliseconds(HnsTime) \
            RtlExtendedMagicDivide((HnsTime), Magic10000, SHIFT10000)

#define FSCTL_IRDA_BASE     FILE_DEVICE_NETWORK

#define LSAPSEL_TXT         "LSAP-SEL"
#define LSAPSEL_TXTLEN      8

#define TTP_CREDIT_ADVANCE_THRESH   8
#define TTP_RECV_MAX_SDU            0 // unlimited

#define DEFAULT_LAZY_DSCV_INTERVAL  4

// How many times should we retry making a connection if
// the link is busy? (lazy discoveries you know from peer can block connection.)
#define BUSY_LINK_CONN_RETRIES      6
#define BUSY_LINK_CONN_RETRY_WAIT   200 // msec before retry attempt

#define EXPDEVID(Id)        (Id)[0], (Id)[1], (Id)[2], (Id)[3]

//
// Winsock error codes are also defined in winerror.h
// Hence the IFDEF
//
#ifndef WSABASEERR

// wmz from winsock.h
#define WSABASEERR              10000
#define WSAEINTR                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define WSAEFAULT               (WSABASEERR+14)
#define WSAEINVAL               (WSABASEERR+22)
#define WSAEMFILE               (WSABASEERR+24)
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAEINPROGRESS          (WSABASEERR+36)
#define WSAEALREADY             (WSABASEERR+37)
#define WSAENOTSOCK             (WSABASEERR+38)
#define WSAEDESTADDRREQ         (WSABASEERR+39)
#define WSAEMSGSIZE             (WSABASEERR+40)
#define WSAEPROTOTYPE           (WSABASEERR+41)
#define WSAENOPROTOOPT          (WSABASEERR+42)
#define WSAEPROTONOSUPPORT      (WSABASEERR+43)
#define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
#define WSAEOPNOTSUPP           (WSABASEERR+45)
#define WSAEPFNOSUPPORT         (WSABASEERR+46)
#define WSAEAFNOSUPPORT         (WSABASEERR+47)
#define WSAEADDRINUSE           (WSABASEERR+48)
#define WSAEADDRNOTAVAIL        (WSABASEERR+49)
#define WSAENETDOWN             (WSABASEERR+50)
#define WSAENETUNREACH          (WSABASEERR+51)
#define WSAENETRESET            (WSABASEERR+52)
#define WSAECONNABORTED         (WSABASEERR+53)
#define WSAECONNRESET           (WSABASEERR+54)
#define WSAENOBUFS              (WSABASEERR+55)
#define WSAEISCONN              (WSABASEERR+56)
#define WSAENOTCONN             (WSABASEERR+57)
#define WSAESHUTDOWN            (WSABASEERR+58)
#define WSAETOOMANYREFS         (WSABASEERR+59)
#define WSAETIMEDOUT            (WSABASEERR+60)
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAELOOP                (WSABASEERR+62)
#define WSAENAMETOOLONG         (WSABASEERR+63)
#define WSAEHOSTDOWN            (WSABASEERR+64)
#define WSAEHOSTUNREACH         (WSABASEERR+65)
#define WSAENOTEMPTY            (WSABASEERR+66)
#define WSAEPROCLIM             (WSABASEERR+67)
#define WSAEUSERS               (WSABASEERR+68)
#define WSAEDQUOT               (WSABASEERR+69)
#define WSAESTALE               (WSABASEERR+70)
#define WSAEREMOTE              (WSABASEERR+71)
#define WSAEDISCON              (WSABASEERR+101)

#endif // ifdef WSABASEERR

#define IRDA_MIN_LSAP_SEL   1
#define IRDA_MAX_LSAP_SEL   127

typedef enum 
{
    IRDA_CONN_CREATED, // don't change order
    IRDA_CONN_CLOSING,
    IRDA_CONN_OPENING, 
    IRDA_CONN_OPEN    
} IRDA_CONN_STATES;

typedef enum
{
    CONNECTION_UP,
    CONNECTION_DOWN,
    CONNECTION_INTERRUPTED
} IRDA_CONNECTION_STATUS; // Irmon taskbar status

#define ADDR_OBJ_SIG        0xAAAAAAAA
#define CONN_OBJ_SIG        0xCCCCCCCC

#define IS_VALID_ADDR(p)    (((p) != NULL) && ((p)->Sig == ADDR_OBJ_SIG))
#define IS_VALID_CONN(p)    (((p) != NULL) && ((p)->Sig == CONN_OBJ_SIG))

#define IRLPT_MODE1     1 
#define IRLPT_MODE2     2

#define UNMARK_IRP_PENDING(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->Control) &= ~SL_PENDING_RETURNED)

typedef struct _IRDA_CONN_OBJ *PIRDA_CONN_OBJ;

typedef struct _IRDA_ADDR_OBJ
{
    CTELock                 Lock;    
	struct _IRDA_ADDR_OBJ  *pNext;
    PIRDA_CONN_OBJ          ConnObjList;
    BOOLEAN                 IsServer;
    UINT                    UseIrlptMode;
    BOOLEAN                 Use9WireMode;    
    TDI_ADDRESS_IRDA        LocalAddr;
    int                     LocalLsapSel;
    PVOID                   IasAttribHandle;
    PTDI_IND_CONNECT        pEventConnect;
    PVOID                   pEventConnectContext;
    PTDI_IND_DISCONNECT     pEventDisconnect;
    PVOID                   pEventDisconnectContext;
    PTDI_IND_RECEIVE        pEventReceive;
    PVOID                   pEventReceiveContext;
#if DBG
    unsigned                Sig;
    int                     LockLine;
#endif    
} IRDA_ADDR_OBJ, *PIRDA_ADDR_OBJ;

typedef struct _IRDA_CONN_OBJ
{
    CTELock                 Lock;
	struct _IRDA_CONN_OBJ  *pNext;
    PIRDA_ADDR_OBJ          pAddr;
    PFILE_OBJECT            AddressFileObject;
    PVOID                   ClientContext;
    PVOID                   IrlmpContext;
    IRDA_CONN_STATES        ConnState;
    BOOLEAN                 IsServer;
    LIST_ENTRY              RecvIrpList;
    LIST_ENTRY              SendIrpList;
    LIST_ENTRY              SendIrpPassiveList;
#if DBG
    unsigned                Sig;
    int                     LockLine;
    int                     TotalFramesCnt;
    int                     CreditsExtended;
    int                     TotalByteCount;
#endif            
    TDI_ADDRESS_IRDA        LocalAddr;
    int                     LocalLsapSel;
    TDI_ADDRESS_IRDA        RemoteAddr;
    int                     RemoteLsapSel;
    int                     SendMaxSDU;
    int                     SendMaxPDU;
    int                     TtpRecvCreditsLeft;
    int                     RetryConnCount;    
    IRDA_TIMER              RetryConnTimer;
    REF_CNT                 RefCnt;    
    CTEEvent                SendEvent;
    LIST_ENTRY              RecvBufList;
    BOOLEAN                 RecvBusy;    
    BOOLEAN                 ConnectionUp;
} IRDA_CONN_OBJ, *PIRDA_CONN_OBJ;

typedef struct
{
    LIST_ENTRY  Linkage;
    UINT        Len;
    UINT        Offset;
    UCHAR       Data[IRDA_MAX_DATA_SIZE];
    UINT        FinalSeg;
} IRDA_RECV_BUF, *PIRDA_RECV_BUF;

typedef struct
{
    LIST_ENTRY      Linkage;
    PVOID           AttribHandle;
    PFILE_OBJECT    pFileObject;
} IRDA_IAS_ATTRIB, *PIRDA_IAS_ATTRIB;

#if DBG
#define GET_CONN_LOCK(pConn, Handle) {      \
    CTEGetLock(&(pConn)->Lock, Handle);     \
    (pConn)->LockLine = __LINE__;           \
}    

#define FREE_CONN_LOCK(pConn, Handle) {     \
    CTEAssert((pConn)->LockLine != 0)       \
    (pConn)->LockLine = 0;                  \
    CTEFreeLock(&(pConn)->Lock, Handle);    \
}    

#define GET_ADDR_LOCK(pAddr, Handle) {      \
    CTEGetLock(&(pAddr)->Lock, Handle);     \
    (pAddr)->LockLine = __LINE__;           \
}

#define FREE_ADDR_LOCK(pAddr, Handle) {     \
    CTEAssert((pAddr)->LockLine != 0);      \
    (pAddr)->LockLine = 0;                  \
    CTEFreeLock(&(pAddr)->Lock, Handle);    \
}    
#else
#define GET_CONN_LOCK(pConn,Handle)    CTEGetLock(&(pConn)->Lock, Handle)
#define FREE_CONN_LOCK(pConn,Handle)   CTEFreeLock(&(pConn)->Lock, Handle)
#define GET_ADDR_LOCK(pAddr,Handle)    CTEGetLock(&(pAddr)->Lock, Handle)
#define FREE_ADDR_LOCK(pAddr,Handle)   CTEFreeLock(&(pAddr)->Lock, Handle)
#endif
    
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT               pDriverObject,
    PUNICODE_STRING              pRegistryPath);
    
VOID
DriverUnload(
    PDRIVER_OBJECT              pDriverObject);    

NTSTATUS
IrDADispatch(
    PDEVICE_OBJECT               pDeviceObject,
    PIRP                         pIrp);

NTSTATUS
IrDACreate(
    PDEVICE_OBJECT               pDeviceObject,
    PIRP                         pIrp,
    PIO_STACK_LOCATION           pIrpSp);

FILE_FULL_EA_INFORMATION UNALIGNED *
FindEA(
    PFILE_FULL_EA_INFORMATION    pStartEA,
    CHAR                        *pTargetName,
    USHORT                       TargetNameLength);

NTSTATUS
IrDACleanup(
    PDEVICE_OBJECT               pDeviceObject,
    PIRP                         pIrp,
    PIO_STACK_LOCATION           pIrpSp);

void
IrDACloseObjectComplete(
    void                        *pContext,
    unsigned int                 Status,
    unsigned int                 UnUsed);

NTSTATUS
IrDAClose(
    PIRP                         pIrp,
    PIO_STACK_LOCATION           pIrpSp);

NTSTATUS
IrDADispatchInternalDeviceControl(
    PDEVICE_OBJECT               pDeviceObject,
    PIRP                         pIrp);

NTSTATUS
IrDADispatchDeviceControl(
    PIRP                         pIrp,
    PIO_STACK_LOCATION           pIrpSp);

NTSTATUS
TdiDispatch(
    PIRP                         pIrp,
    PIO_STACK_LOCATION           pIrpSp,
    BOOLEAN                      Pendable,
    BOOLEAN                      Cancelable);

void
TdiDispatchReqComplete(
    void                        *pContext,
    unsigned int                 Status,
    unsigned int                 ByteCount);

void
TdiCancelIrp(
    PDEVICE_OBJECT               pDeviceObject,
	PIRP                         pIrp);

NTSTATUS
TdiQueryInformation(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp);

NTSTATUS
TdiSetInformation(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp);

NTSTATUS
TdiSetEvent(
    PIRDA_ADDR_OBJ               pAddrObj,
    int                          Type,
    PVOID                        pHandler,
    PVOID                        pContext);

int
GetLsapSelServiceName(
    CHAR *ServiceName);
    
VOID
FreeConnObject(
    PIRDA_CONN_OBJ pConn);

NTSTATUS
TdiOpenAddress(
    PIRDA_ADDR_OBJ              *ppNewAddrObj,
    TRANSPORT_ADDRESS UNALIGNED *pAddrList,
    USHORT                      AddrListLen);

NTSTATUS
TdiOpenConnection(
    PIRDA_CONN_OBJ              *ppNewConnObj,
    PVOID                       pContext,
    USHORT                      ContextLen);

NTSTATUS
TdiCloseAddress(
    PIRDA_ADDR_OBJ              pAddrObj);

NTSTATUS
TdiCloseConnection(
    PIRDA_CONN_OBJ              pConnObj);

NTSTATUS
TdiAssociateAddress(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp);

NTSTATUS
TdiDisassociateAddress(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp);

NTSTATUS
TdiConnect(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp);

NTSTATUS
TdiDisconnect(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp,
    PIRDA_CONN_OBJ              pConn);

NTSTATUS
TdiSend(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp);
    
VOID
TdiSendAtPassiveCallback(
    struct CTEEvent *Event,
    PVOID Arg);

NTSTATUS
TdiSendAtPassive(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp);    

NTSTATUS
TdiReceive(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp);

VOID
PendingIasRequestCallback(
    struct CTEEvent *Event, 
    PVOID Arg);
    
VOID
IrlmpGetValueByClassConf(
    IRDA_MSG *pMsg);    

ULONG
GetMdlChainByteCount(
    PMDL                         pMdl);
        
VOID
CancelIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP pIrp);
    
VOID
CancelConnObjIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP pIrp);
    
VOID
PendIrp(
    PLIST_ENTRY     pList,
    PIRP            pIrp,
    PIRDA_CONN_OBJ  pConn,
    BOOLEAN         LockHeld);

NTSTATUS
InitiateIasQuery(
    PIRP pIrp, 
    PIO_STACK_LOCATION pIrpSp,
    PIRDA_CONN_OBJ pConn);    

int 
GetUnusedLsapSel();

VOID
SetLsapSelAddr(
    int LsapSel,
    CHAR *ServiceName);

BOOLEAN
MyStrEqual(
    CHAR *Str1, 
    CHAR *Str2, 
    int Len);

VOID
RetryConnection(
    PIRDA_CONN_OBJ pConn, 
    PIRP pIrp
    );

VOID
RetryConnTimerExp(
    PVOID Context);

VOID
LazyDscvTimerExp(PVOID Context);

#if 1
char *
IrpMJTxt(
    PIO_STACK_LOCATION  pIrpSp);

char *
IrpTdiTxt(
    PIO_STACK_LOCATION  pIrpSp);
    
char *
IrpTdiObjTypeTxt(
    PIO_STACK_LOCATION  pIrpSp);
    
char *
TdiEventTxt(
    int EventType);
    
void
DumpObjects(void);        

char *
IrDAPrimTxt(
    IRDA_SERVICE_PRIM   Prim);

char *
TdiQueryTxt(LONG Type);

#else

#define DumpObjects()   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\settings.h ===
/*
 ************************************************************************
 *
 *	SETTINGS.h
 *
 *
 * Portions Copyright (C) 1996-1998 National Semiconductor Corp.
 * All rights reserved.
 * Copyright (C) 1996-1998 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */

#ifndef SETTINGS_H
#define SETTINGS_H

#include "dongle.h"

#if DBG  /* { */

	/*
	 * The DBG_ADD_PKT_ID flag causes the miniport to add/delete a packet
	 * id to each packet.  This is only for debugging purposes; it makes
	 * the miniport INCOMPATIBLE with all others.
	 */
//#define DBG_ADD_PKT_ID


#ifdef DBG_ADD_PKT_ID
extern BOOLEAN addPktIdOn;
#endif

typedef enum {
	DBG_ERR		= (1 << 0),
	DBG_STAT	= (1 << 1),
	DBG_MSG		= (1 << 2),
	DBG_OUT		= (1 << 2),
	DBG_BUF		= (1 << 3),
	DBG_PACKET	= (1 << 4),
	DBG_PKT	    	= (1 << 4),

	// Added so we can look at an ndis buffer.
	DBG_NDIS_PACKET = (1 << 5),

	DBG_DUMPLOG	= (1 << 6),
	DBG_LOG		= (1 << 7),
	DBG_ALL		= (DBG_ERR|DBG_STAT|DBG_MSG|DBG_BUF|DBG_PACKET),
	DBG_SIR_MODE	= (1 << 8),
	DBG_FIR_MODE	= (1 << 9),
	DBG_TX          = (1 << 10),
	DBG_RX          = (1 << 11),
	DBG_DMA         = (1 << 12),
	DBG_ISR         = (1 << 13),
	DBG_TRACE_TX    = (1 << 14)
};

// extern ULONG _cdecl DbgPrint(PCHAR Format, ...);
extern UINT dbgOpt;


#define DBG_NDIS_RESULT_STR(_ndisResult)				\
	((PUCHAR) ((_ndisResult == NDIS_STATUS_SUCCESS) ?		\
	"NDIS_STATUS_SUCCESS" : (_ndisResult == NDIS_STATUS_FAILURE) ?	\
	"NDIS_STATUS_FAILURE" : (_ndisResult == NDIS_STATUS_PENDING) ?	\
	"NDIS_STATUS_PENDING" : "NDIS_STATUS_???"))

#define DBGPRINT(dbgprint_params_in_parens)				\
{									\
	DbgPrint("NSC: ");						\
	DbgPrint dbgprint_params_in_parens;				\
	DbgPrint("\r\n");						\
}

#define DEBUGMSG(flags, dbgprint_params_in_parens) \
    if (dbgOpt & (flags))                          \
    {                                              \
        DbgPrint dbgprint_params_in_parens;        \
    }

#define DEBUGFIR(flags, dbgprint_params_in_parens) \
    if (dbgOpt & DBG_FIR_MODE && dbgOpt & (flags)) \
    {                                              \
        DbgPrint dbgprint_params_in_parens;        \
    }

#define DBGOUT(dbgprint_params_in_parens)				\
	if (dbgOpt & DBG_MSG) {						\
		if ((DebugSpeed > MAX_SIR_SPEED) &&	\
					(dbgOpt & DBG_FIR_MODE)) {	\
			DBGPRINT(dbgprint_params_in_parens);		\
		}							\
		else if (dbgOpt & DBG_SIR_MODE) {			\
			DBGPRINT(dbgprint_params_in_parens);		\
		}							\
	}

#define DBGERR(dbgprint_params_in_parens)				\
	if (dbgOpt & DBG_ERR) {						\
		if ((DebugSpeed > MAX_SIR_SPEED) &&	\
					(dbgOpt & DBG_FIR_MODE)) {	\
			DBGPRINT(dbgprint_params_in_parens);		\
		}							\
		else if (dbgOpt & DBG_SIR_MODE) {			\
			DBGPRINT(dbgprint_params_in_parens);		\
		}							\
	}

#define DBGSTAT(dbgprint_params_in_parens)				\
	if (dbgOpt & DBG_STAT) {					\
		if ((DebugSpeed > MAX_SIR_SPEED) &&	\
					(dbgOpt & DBG_FIR_MODE)) {	\
			DBGPRINT(dbgprint_params_in_parens);		\
		}							\
		else if (dbgOpt & DBG_SIR_MODE) {			\
			DBGPRINT(dbgprint_params_in_parens);		\
		}							\
	}

#define DBGPKT(dbgprint_params_in_parens)				\
	if (dbgOpt & DBG_PACKET) {					\
		if ((DebugSpeed > MAX_SIR_SPEED) &&	\
					(dbgOpt & DBG_FIR_MODE)) {	\
			DBGPRINT(dbgprint_params_in_parens);		\
		}							\
		else if (dbgOpt & DBG_SIR_MODE) {			\
			DBGPRINT(dbgprint_params_in_parens);		\
		}							\
	}

#define DBG_D(i) DbgPrint("IRSIR:"#i"==%d\n", (i))
#define DBG_X(x) DbgPrint("IRSIR:"#x"==0x%0*X\n", sizeof(x)*2, ((ULONG_PTR)(x))&((1<<(sizeof(x)*8))-1) )
#define DBG_UNISTR(s) DbgPrint("IRSIR:"#s"==%wZ\n", (s))


extern 	VOID DBG_NDIS_Buffer(PNDIS_BUFFER ndisBuf);

#define DBG_NDIS_BUFFER(Ndis_buffer)					\
	if (dbgOpt & DBG_NDIS_PACKET) {					\
		if ((DebugSpeed > MAX_SIR_SPEED) &&	\
					(dbgOpt & DBG_FIR_MODE)) {	\
			DBG_NDIS_Buffer(Ndis_buffer);			\
		}							\
		else if (dbgOpt & DBG_SIR_MODE) {			\
			DBG_NDIS_Buffer(Ndis_buffer);			\
		}							\
	}

extern VOID DBG_PrintBuf(PUCHAR bufptr, UINT buflen);

#define DBGPRINTBUF(bufptr, buflen)					\
	if (dbgOpt & DBG_BUF) {						\
		if ((DebugSpeed > MAX_SIR_SPEED) &&	\
					(dbgOpt & DBG_FIR_MODE)) {	\
			DBG_PrintBuf((PUCHAR)(bufptr), (UINT)(buflen));   \
		}							\
		else if (dbgOpt & DBG_SIR_MODE) {			\
			DBG_PrintBuf((PUCHAR)(bufptr), (UINT)(buflen));	\
		}							\
	}

#else /* } { */

#define DbgBreakPoint()
#define DBGOUT(dbgprint_params_in_parens)
#define DBGERR(dbgprint_params_in_parens)
#define DBGPRINTBUF(bufptr, buflen)
#define DBGSTAT(dbgprint_params_in_parens)
#define DBGPKT(dbgprint_params_in_parens)
#define DBG_NDIS_RESULT_STR(_ndisResult)
#define DEBUGFIR(flags, dbgprint_params_in_parens)
#define DEBUGMSG(flags, dbgprint_params_in_parens)
#define DBG_D(i)
#define DBG_X(x)
#define DBG_UNISTR(s)



#endif /* } #if DBG  */

enum baudRates {

	/* Slow IR */
	BAUDRATE_2400 = 0,
	BAUDRATE_9600,
	BAUDRATE_19200,
	BAUDRATE_38400,
	BAUDRATE_57600,
	BAUDRATE_115200,

	/* Medium IR */
	BAUDRATE_576000,
	BAUDRATE_1152000,

	/* Fast IR */
	BAUDRATE_4000000,

	NUM_BAUDRATES	/* must be last */
};

#define DEFAULT_BAUDRATE BAUDRATE_115200

#define ALL_SLOW_IRDA_SPEEDS (						\
	NDIS_IRDA_SPEED_2400 | NDIS_IRDA_SPEED_9600 |			\
	NDIS_IRDA_SPEED_19200 | NDIS_IRDA_SPEED_38400 |			\
	NDIS_IRDA_SPEED_57600 | NDIS_IRDA_SPEED_115200)

#define ALL_IRDA_SPEEDS (						\
	ALL_SLOW_IRDA_SPEEDS | NDIS_IRDA_SPEED_1152K | NDIS_IRDA_SPEED_4M)


#define MAX_SIR_SPEED	 115200
#define MIN_FIR_SPEED	4000000

#define DEFAULT_BOFS_CODE  BOFS_48
#define MAX_NUM_EXTRA_BOFS 48
#define DEFAULT_NUM_EXTRA_BOFS MAX_NUM_EXTRA_BOFS


#define DEFAULT_TURNAROUND_usec 1000

typedef struct {
	enum baudRates tableIndex;
	UINT bitsPerSec;
	UINT ndisCode;	// bitmask element
} baudRateInfo;

#define DEFAULT_BAUD_RATE 9600



/*
 * This is the largest IR packet size (counting _I_ field only,
 * and not counting ESC characters) that we handle.
 *
 */
#define MAX_I_DATA_SIZE		2048
#define MAX_NDIS_DATA_SIZE (IR_ADDR_SIZE+IR_CONTROL_SIZE+MAX_I_DATA_SIZE)

#ifdef DBG_ADD_PKT_ID
#pragma message("WARNING: INCOMPATIBLE DEBUG VERSION")
#define MAX_RCV_DATA_SIZE (MAX_NDIS_DATA_SIZE+SLOW_IR_FCS_SIZE+2)
#define MAX_DMA_XMIT_DATA_SIZE (MAX_NDIS_DATA_SIZE+SLOW_IR_FCS_SIZE+2)
#else
#define MAX_RCV_DATA_SIZE  (MAX_NDIS_DATA_SIZE+SLOW_IR_FCS_SIZE)
#define MAX_DMA_XMIT_DATA_SIZE  (MAX_NDIS_DATA_SIZE+SLOW_IR_FCS_SIZE)
#endif

#define MAX_TX_PACKETS 7
#define MAX_RX_PACKETS 7
/*
 * We loop an extra time in the receive FSM in order to see EOF after the
 * last data byte; so we need some extra space in readBuf in case we then
 * get garbage instead.
 */
#define RCV_BUFFER_SIZE (MAX_RCV_DATA_SIZE +4+sizeof(LIST_ENTRY))
#define RCV_DMA_SIZE ((MAX_RX_PACKETS+5) * (MAX_RCV_DATA_SIZE + FAST_IR_FCS_SIZE+ 16))

#define RCV_BUF_TO_LIST_ENTRY(b) ((PLIST_ENTRY)((PUCHAR)(b)-sizeof(LIST_ENTRY)))
#define LIST_ENTRY_TO_RCV_BUF(e) ((PVOID)((PUCHAR)(e)+sizeof(LIST_ENTRY)))

#if (RCV_DMA_SIZE > 0x10000)
#error "RCV_DMA_SIZE can't span physical segments"
#endif


/*
 * We allocate buffers twice as large as the max rcv size to accomodate ESC
 * characters and BOFs, etc.  Recall that in the worst possible case, the
 * data contains all BOF/EOF/ESC characters, in which case we must expand
 * it to twice its original size.
 */
#define MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(dataLen) ( 		\
	(dataLen) * 2 + (MAX_NUM_EXTRA_BOFS + 1) *			\
	SLOW_IR_BOF_SIZE + IR_ADDR_SIZE + IR_CONTROL_SIZE +		\
	SLOW_IR_FCS_SIZE + SLOW_IR_EOF_SIZE)

#define MAX_IRDA_DATA_SIZE						\
	MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(MAX_I_DATA_SIZE)

/*
 *  When FCS is computed on an IR packet with FCS appended, the result
 * should be this constant.
 */
#define GOOD_FCS ((USHORT) ~0xf0b8)


/*
 *  Sizes of IrLAP frame fields:
 *	Beginning Of Frame (BOF)
 *	End Of Frame (EOF)
 *	Address
 *	Control
 */
#define IR_ADDR_SIZE			1
#define IR_CONTROL_SIZE			1

#define SLOW_IR_BOF_TYPE		UCHAR
#define SLOW_IR_BOF_SIZE		sizeof(SLOW_IR_BOF_TYPE)
#define SLOW_IR_EXTRA_BOF_TYPE  	UCHAR
#define SLOW_IR_EXTRA_BOF_SIZE		sizeof(SLOW_IR_EXTRA_BOF_TYPE)
#define SLOW_IR_EOF_TYPE		UCHAR
#define SLOW_IR_EOF_SIZE		sizeof(SLOW_IR_EOF_TYPE)
#define SLOW_IR_FCS_TYPE		USHORT
#define SLOW_IR_FCS_SIZE		sizeof(SLOW_IR_FCS_TYPE)
#define SLOW_IR_BOF			0xC0
	/* don't use 0xFF, it breaks some HP printers! */
#define SLOW_IR_EXTRA_BOF		0xC0
#define SLOW_IR_EOF			0xC1
#define SLOW_IR_ESC			0x7D
#define SLOW_IR_ESC_COMP		0x20

#define MEDIUM_IR_BOF			0x7E
#define MEDIUM_IR_EOF			0x7E
#define MEDIUM_IR_FCS_SIZE		2

#define FAST_IR_FCS_SIZE		4
#define FAST_IR_EOF_SIZE		1


#define MIN(a,b) (((a) <= (b)) ? (a) : (b))
#define MAX(a,b) (((a) >= (b)) ? (a) : (b))


#endif SETTINGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\samples\nscirda\sync.c ===
/*
 ************************************************************************
 *
 *	SYNC.C
 *
 * Copyright (C) 1996-2001 Microsoft Corporation. All Rights Reserved.
 *
 *
 *
 *************************************************************************
 */
#include <ndis.h>
#include <ntddndis.h>
#include "sync.h"

void CheckForEntryOnList(PLIST_ENTRY Head, PLIST_ENTRY Entry)
{
    PLIST_ENTRY ListEntry;

    for (ListEntry = Head->Flink;
         ListEntry != Head->Flink;
         ListEntry = ListEntry->Flink
        )
    {
        if (Entry==ListEntry)
        {
            DbgPrint("About to insert entry that is already on list!\n");
            DbgPrint("Head:%08X Entry:%08X\n", Head, Entry);
            DbgBreakPoint();
            break;
        }
    }
}

BOOLEAN SynchronizedListFunc(IN PVOID Context)
{
    SynchronizeList *ListData = Context;

    switch (ListData->Command)
    {
        case SyncInsertHead:
//            CheckForEntryOnList(ListData->Head, ListData->Entry);
            InsertHeadList(ListData->Head, ListData->Entry);
            break;
        case SyncInsertTail:
//            CheckForEntryOnList(ListData->Head, ListData->Entry);
            InsertTailList(ListData->Head, ListData->Entry);
            break;
        case SyncRemoveHead:
            if (IsListEmpty(ListData->Head))
            {
                ListData->Entry = NULL;
            }
            else
            {
                ListData->Entry = RemoveHeadList(ListData->Head);
            }
            break;
        case SyncRemoveTail:
            if (IsListEmpty(ListData->Head))
            {
                ListData->Entry = NULL;
            }
            else
            {
                ListData->Entry = RemoveTailList(ListData->Head);
            }
            break;
        case SyncRemove:
            RemoveEntryList(ListData->Entry);
            break;
        default:
            ASSERT(0);
            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\winsock\wshirda.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    WshIrDA.c

Abstract:

    This module contains necessary routines for the IrDA Windows Sockets
    Helper DLL.  This DLL provides the transport-specific support necessary
    for the Windows Sockets DLL to use IrDA as a transport.

Author:

    Zed (mikezin)               28-Aug-1996
    mbert                       Sept 97

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <tdi.h>

#include <winsock2.h>
#include <wsahelp.h>

#include <tdistat.h>
#include <tdiinfo.h>
#include <llinfo.h>


typedef unsigned long   ulong;
typedef unsigned short  ushort;
typedef unsigned int    uint;
typedef unsigned char   uchar;

#define NT  /* for tdiinfo.h */
#include <tdiinfo.h>


#include <basetyps.h>
#include <nspapi.h>
#include <nspapip.h>

#include <af_irda.h>
#include <irioctl.h>
#include <irdatdi.h>

#define MIN_SOCKADDR_LEN    8
#define MAX_SOCKADDR_LEN    sizeof(SOCKADDR_IRDA)

#ifdef _NOT_DBG
//#ifdef DBG
#define DEBUGMSG(s)   DbgPrint s
#else
#define DEBUGMSG(s)
#endif

typedef struct WshIrdaIasAttrib
{
    HANDLE                  AttribHandle;
    struct WshIrdaIasAttrib *pNext;
} WSHIRDA_IAS_ATTRIBUTE, *PWSHIRDA_IAS_ATTRIBUTE;

typedef struct _WSHIRDA_SOCKET_CONTEXT
{
    PWSHIRDA_IAS_ATTRIBUTE          pIasAttribs;
    // all fields copied from parent to child (at accept) must follow    
    // (see SetSocketInformation SO_CONTEXT)
    INT                             AddressFamily;
    INT                             SocketType;
    INT                             Protocol;
    DWORD                           Options;
    HANDLE                          LazyDscvDevHandle;
} WSHIRDA_SOCKET_CONTEXT, *PWSHIRDA_SOCKET_CONTEXT;

typedef struct
{
    DWORD Rows;
    DWORD Columns;
    struct {
        DWORD AddressFamily;
        DWORD SocketType;
        DWORD Protocol;
    } Mapping[3];
} IRDA_WINSOCK_MAPPING;

const IRDA_WINSOCK_MAPPING IrDAMapping =
  { 3, 3,
    AF_IRDA, SOCK_STREAM, IRDA_PROTO_SOCK_STREAM,
    AF_IRDA, SOCK_STREAM, 0,
    AF_IRDA, 0,           IRDA_PROTO_SOCK_STREAM };
    
WSAPROTOCOL_INFOW Winsock2Protocols[] =
    {
        {
            XP1_GUARANTEED_DELIVERY                 // dwServiceFlags1
                | XP1_GUARANTEED_ORDER
                | XP1_IFS_HANDLES,                
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                      // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }              // ChainEntries
            },
            2,                                      // iVersion
            AF_IRDA,                                // iAddressFamily
            
            // winsock doesn't seem to use min and max here,
            // it gets it from inf and is stored
            // in CCS\services\irda\parameters\winsock
            sizeof(SOCKADDR_IRDA),                  // iMaxSockAddr
            8,                                      // iMinSockAddr
            
            SOCK_STREAM,                            // iSocketType
            IRDA_PROTO_SOCK_STREAM,                 // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            0,                                      // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Irda [IrDA]"                    // szProtocol
        }
    };
        
GUID IrdaProviderGuid = { /* 3972523d-2af1-11d1-b655-00805f3642cc */
    0x3972523d,
    0x2af1,
    0x11d1,
    {0xb6, 0x55, 0x00, 0x80, 0x5f, 0x36, 0x42, 0xcc}
    };    

VOID
DeleteSocketAttribs(PWSHIRDA_SOCKET_CONTEXT pSocket);

// globals
CRITICAL_SECTION        IrdaCs;

BOOLEAN
DllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL)
{
    switch(Reason)
    {
        case DLL_PROCESS_ATTACH:
        
            // We don't need to receive thread attach and detach
            // notifications, so disable them to help application
            // performance.
            DisableThreadLibraryCalls(DllHandle);
            
            try 
            { 
                InitializeCriticalSection(&IrdaCs);
            }
            except (STATUS_NO_MEMORY == GetExceptionCode())
            {
                return FALSE;
            }        
            return TRUE;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            DeleteCriticalSection(&IrdaCs);
            break;

        case DLL_THREAD_DETACH:
            break;
    }

    return TRUE;
}

INT
IoStatusToWs(NTSTATUS Status)
{
  switch (Status)
  {
    case STATUS_SUCCESS: 
        return NO_ERROR;
        
    case STATUS_PENDING:
        return ERROR_IO_PENDING;

    case STATUS_INVALID_HANDLE:
    case STATUS_OBJECT_TYPE_MISMATCH:
        return WSAENOTSOCK;

    case STATUS_INVALID_PARAMETER:
    case STATUS_ADDRESS_CLOSED:
    case STATUS_CONNECTION_INVALID:
    case STATUS_ADDRESS_ALREADY_ASSOCIATED:
    case STATUS_ADDRESS_NOT_ASSOCIATED:
    case STATUS_CONNECTION_ACTIVE:
    case STATUS_INVALID_DEVICE_STATE:
    case STATUS_INVALID_DEVICE_REQUEST:
        return WSAEINVAL;

    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_PAGEFILE_QUOTA:
    case STATUS_COMMITMENT_LIMIT:
    case STATUS_WORKING_SET_QUOTA:
    case STATUS_NO_MEMORY:
    case STATUS_CONFLICTING_ADDRESSES:
    case STATUS_QUOTA_EXCEEDED:
    case STATUS_TOO_MANY_PAGING_FILES:
    case STATUS_REMOTE_RESOURCES:
    case STATUS_TOO_MANY_ADDRESSES:
        return WSAENOBUFS;

    case STATUS_SHARING_VIOLATION:
    case STATUS_ADDRESS_ALREADY_EXISTS:
        return WSAEADDRINUSE;

    case STATUS_LINK_TIMEOUT:
    case STATUS_IO_TIMEOUT:
    case STATUS_TIMEOUT:
        return WSAETIMEDOUT;

    case STATUS_GRACEFUL_DISCONNECT:
        return WSAEDISCON;

    case STATUS_REMOTE_DISCONNECT:
    case STATUS_CONNECTION_RESET:
    case STATUS_LINK_FAILED:
    case STATUS_CONNECTION_DISCONNECTED:
        return WSAECONNRESET;

    case STATUS_LOCAL_DISCONNECT:
    case STATUS_TRANSACTION_ABORTED:
    case STATUS_CONNECTION_ABORTED:
        return WSAECONNRESET; // WSAECONNABORTED; Make HAPI happy

    case STATUS_INVALID_NETWORK_RESPONSE:
        return WSAENETDOWN;

    case STATUS_BAD_NETWORK_PATH:
    case STATUS_NETWORK_UNREACHABLE:
    case STATUS_PROTOCOL_UNREACHABLE:
        return WSAENETUNREACH;

    case STATUS_HOST_UNREACHABLE:
        return WSAEHOSTUNREACH;

    case STATUS_CANCELLED:
    case STATUS_REQUEST_ABORTED:
        return WSAEINTR;

    case STATUS_BUFFER_OVERFLOW:
    case STATUS_INVALID_BUFFER_SIZE:
        return WSAEMSGSIZE;

    case STATUS_BUFFER_TOO_SMALL:
    case STATUS_ACCESS_VIOLATION:
        return WSAEFAULT;

    case STATUS_DEVICE_NOT_READY:
    case STATUS_REQUEST_NOT_ACCEPTED:
        return WSAEWOULDBLOCK;

    case STATUS_NETWORK_BUSY:
    case STATUS_NO_SUCH_DEVICE:
    case STATUS_NO_SUCH_FILE:
    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_UNEXPECTED_NETWORK_ERROR:
        return WSAENETDOWN;

    case STATUS_INVALID_CONNECTION:
        return WSAENOTCONN;

    case STATUS_REMOTE_NOT_LISTENING:
    case STATUS_CONNECTION_REFUSED:
        return WSAECONNREFUSED;

    case STATUS_PIPE_DISCONNECTED:
        return WSAESHUTDOWN;

    case STATUS_INVALID_ADDRESS:
    case STATUS_INVALID_ADDRESS_COMPONENT:
        return WSAEADDRNOTAVAIL;

    case STATUS_NOT_SUPPORTED:
    case STATUS_NOT_IMPLEMENTED:
        return WSAEOPNOTSUPP;

    case STATUS_PORT_UNREACHABLE:
        return WSAEREMOTE;

    case STATUS_UNSUCCESSFUL:
        return WSAEINVAL;

    case STATUS_ACCESS_DENIED:
        return WSAEACCES;
        
    default:
        DEBUGMSG(("Didn't map NT status %X, returning WSAEINVAL\n", Status));
        return WSAEINVAL;
  }
}        

INT
WSHGetSockaddrType(
    IN  PSOCKADDR       Sockaddr,
    IN  DWORD           SockaddrLength,
    OUT PSOCKADDR_INFO  SockaddrInfo)
{
    UNALIGNED SOCKADDR *pSockaddr = (PSOCKADDR) Sockaddr;

    if (SockaddrLength < sizeof(SOCKADDR_IRDA))
    {
        DEBUGMSG(("WSHGetSockaddrType(irda): SockaddrLength(%d) < sizeof(SOCKADDR_IRDA)%d ret WSAEFAULT\n",
                    SockaddrLength, sizeof(SOCKADDR_IRDA)));
        return WSAEFAULT;
    }    

    if (pSockaddr->sa_family != AF_IRDA)
    {
        DEBUGMSG(("WSHGetSockaddrType(irda): pSockaddr->sa_family != AF_IRDA ret WSAEAFNOSUPPORT\n"));        
        return WSAEAFNOSUPPORT;
    }    

    if (((SOCKADDR_IRDA *) pSockaddr)->irdaServiceName[0] == 0)
    {
        SockaddrInfo->AddressInfo  = SockaddrAddressInfoWildcard;
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    }
    else
    {
        SockaddrInfo->AddressInfo  = SockaddrAddressInfoNormal;
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;
    }

    DEBUGMSG(("WSHGetSockaddrType(irda): returning no error\n"));
    return NO_ERROR;
}

INT
ControlIoctl(
    ULONG       IoctlCode,
    OUT PCHAR   OptionValue,
    OUT PINT    OptionLength,
    OUT HANDLE  *pDevHandle)
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjAttr;
    UNICODE_STRING      DeviceName;
    HANDLE              DeviceHandle;
    IO_STATUS_BLOCK     IoStatusBlock;
      
    RtlInitUnicodeString(&DeviceName, IRDA_DEVICE_NAME);

    if (pDevHandle)
    {    
        *pDevHandle = INVALID_HANDLE_VALUE;
    }    
      
    InitializeObjectAttributes(
        &ObjAttr,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);
        
    Status = NtCreateFile(
                &DeviceHandle,                  // PHANDLE FileHandle
                SYNCHRONIZE | GENERIC_EXECUTE,  // ACCESS_MASK DesiredAccess
                &ObjAttr,                       // POBJECT_ATTRIBUTES ObjAttr
                &IoStatusBlock,                 // PIO_STATUS_BLOCK IoStatusBlock
                NULL,                           // PLARGE_INTEGER AllocationSize
                FILE_ATTRIBUTE_NORMAL,          // ULONG FileAttributes
                FILE_SHARE_READ |
                FILE_SHARE_WRITE,               // ULONG ShareAccess
                FILE_OPEN_IF,                   // ULONG CreateDisposition
                FILE_SYNCHRONOUS_IO_NONALERT,   // ULONG CreateOptions
                NULL,                           // PVOID EaBuffer
                0);                             // ULONG EaLength

    if (!NT_SUCCESS(Status))
    {
        return WSAEINVAL;
    }

    Status = NtDeviceIoControlFile(
                DeviceHandle,    // HANDLE FileHandle
                NULL,            // HANDLE Event OPTIONAL
                NULL,            // PIO_APC_ROUTINE ApcRoutine
                NULL,            // PVOID ApcContext
                &IoStatusBlock,  // PIO_STATUS_BLOCK IoStatusBlock
                IoctlCode,       // ULONG IoControlCode
                OptionValue,     // PVOID InputBuffer
                *OptionLength,   // ULONG InputBufferLength
                OptionValue,     // PVOID OutputBuffer
                *OptionLength);  // ULONG OutputBufferLength

    DEBUGMSG(("IoControlFile returned %x\n", Status));
    
    if (Status == STATUS_SUCCESS)
    {
        *OptionLength = (INT) IoStatusBlock.Information;    
    }
    
    if (pDevHandle && Status == STATUS_SUCCESS)
    {
        *pDevHandle = DeviceHandle;
    }
    else
    {    
        NtClose(DeviceHandle);
    }    
    
    return IoStatusToWs(Status);
}

INT
WSHGetSocketInformation(
    IN  PVOID   HelperDllSocketContext,
    IN  SOCKET  SocketHandle,
    IN  HANDLE  TdiAddressObjectHandle,
    IN  HANDLE  TdiConnectionObjectHandle,
    IN  INT     Level,
    IN  INT     OptionName,
    OUT PCHAR   OptionValue,
    OUT PINT    OptionLength)
{
    PWSHIRDA_SOCKET_CONTEXT pContext = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    DEBUGMSG(("WSHGetSocketInformation\n"));
    
    if (Level == SOL_INTERNAL && OptionName == SO_CONTEXT)
    {
        if (OptionValue != NULL)
        {
            if (*OptionLength < sizeof(WSHIRDA_SOCKET_CONTEXT))
            {
                return WSAEFAULT;
            }
            
            RtlCopyMemory(OptionValue, pContext,
                          sizeof(WSHIRDA_SOCKET_CONTEXT));
        }

        *OptionLength = sizeof(WSHIRDA_SOCKET_CONTEXT);

        return NO_ERROR;
    }
    
    if (Level == SOL_IRLMP)
    {
        switch (OptionName)
        {
            case IRLMP_ENUMDEVICES:
                // need remove for at least 1 device
                if (*OptionLength < (sizeof(DWORD) + 
                        sizeof(IRDA_DEVICE_INFO)))
                {
                    return WSAEFAULT;
                }
                return ControlIoctl(IOCTL_IRDA_GET_INFO_ENUM_DEV,
                                    OptionValue, OptionLength, NULL);
                
            case IRLMP_IAS_QUERY:
                if (*OptionLength < sizeof(IAS_QUERY))
                {
                    return WSAEFAULT;
                }
                return ControlIoctl(IOCTL_IRDA_QUERY_IAS,
                                    OptionValue, OptionLength, NULL);
                
            case IRLMP_SEND_PDU_LEN:
            {
                NTSTATUS            Status;
                IO_STATUS_BLOCK     IoStatusBlock;
                
                Status = NtDeviceIoControlFile(
                    TdiConnectionObjectHandle,
                    NULL,                      // HANDLE Event OPTIONAL
                    NULL,                      // PIO_APC_ROUTINE ApcRoutine
                    NULL,                      // PVOID ApcContext
                    &IoStatusBlock,            // PIO_STATUS_BLOCK IoStatusBlock
                    IOCTL_IRDA_GET_SEND_PDU_LEN,// ULONG IoControlCode
                    NULL,                      // PVOID InputBuffer
                    0,                         // ULONG InputBufferLength
                    OptionValue,               // PVOID OutputBuffer
                    sizeof(DWORD));            // ULONG OutputBufferLength
        
                return IoStatusToWs(Status);        
            }
        }        
    }

    return WSAEINVAL;
}

INT
WSHSetSocketInformation(
    IN PVOID    HelperDllSocketContext,
    IN SOCKET   SocketHandle,
    IN HANDLE   TdiAddressObjectHandle,
    IN HANDLE   TdiConnectionObjectHandle,
    IN INT      Level,
    IN INT      OptionName,
    IN PCHAR    OptionValue,
    IN INT      OptionLength)
{
    PWSHIRDA_SOCKET_CONTEXT pSocketContext = 
        (PWSHIRDA_SOCKET_CONTEXT) HelperDllSocketContext;

    DEBUGMSG(("WSHSetSocketInformation\n"));

    if (Level == SOL_INTERNAL && OptionName == SO_CONTEXT)
    {
        int CopyOffset;
        
        if (OptionLength < sizeof(WSHIRDA_SOCKET_CONTEXT))
            return WSAEINVAL;
        
        if (HelperDllSocketContext == NULL)
        {
            // Socket was inherited or duped, create a new context.
            if ((pSocketContext =
                 RtlAllocateHeap(RtlProcessHeap(), 0,
                                 sizeof(WSHIRDA_SOCKET_CONTEXT)))
                == NULL)
            {
                return WSAENOBUFS;
            }   

            // Copy the parent's context into the child's context.
            RtlCopyMemory(pSocketContext, OptionValue,
                          sizeof(WSHIRDA_SOCKET_CONTEXT));

            pSocketContext->pIasAttribs = NULL;
    
            // Return the address of the new context in pOptionVal.
            *(PWSHIRDA_SOCKET_CONTEXT *) OptionValue = pSocketContext;

            return NO_ERROR;
        }
        
        // The socket was accept()'ed and it needs to have the same 
        // properties as it's parent.  The OptionValue buffer
        // contains the context information of this socket's parent.
        CopyOffset = FIELD_OFFSET(WSHIRDA_SOCKET_CONTEXT, AddressFamily);
        RtlCopyMemory((char *) pSocketContext + CopyOffset,
                      OptionValue + CopyOffset,
                      sizeof(WSHIRDA_SOCKET_CONTEXT) - CopyOffset);

        return NO_ERROR;
    }
    
    if (Level == SOL_IRLMP)
    {
        switch (OptionName)
        {
            case IRLMP_IRLPT_MODE:
                DEBUGMSG(("Set options for %x\n", pSocketContext)); 
                pSocketContext->Options |= OPT_IRLPT_MODE;
                return NO_ERROR;
                
            case IRLMP_9WIRE_MODE:
                pSocketContext->Options |= OPT_9WIRE_MODE;
                return NO_ERROR;
          
            case IRLMP_IAS_SET:
            {
                INT                     rc;
                PWSHIRDA_IAS_ATTRIBUTE  pIasAttrib;
                INT                     OptLen;
                PWSHIRDA_SOCKET_CONTEXT SockContext = (PWSHIRDA_SOCKET_CONTEXT) HelperDllSocketContext;
                HANDLE                  AttribHandle;
	            
                rc = ControlIoctl(IOCTL_IRDA_SET_IAS,
                                  OptionValue, &OptionLength, &AttribHandle);
                
                if (rc == NO_ERROR)
                {
                    pIasAttrib = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(*pIasAttrib));

                    if (pIasAttrib  == NULL)
                    {
                        rc = WSAENOBUFS;
                    }
                    else
                    {
                        pIasAttrib->AttribHandle = AttribHandle;
                                        
                        EnterCriticalSection(&IrdaCs);
                    
                        DEBUGMSG(("Added attrib %x to socket %x\n",
                                AttribHandle, SockContext));
                                
                        pIasAttrib->pNext = SockContext->pIasAttribs;
                        SockContext->pIasAttribs = pIasAttrib;

                        LeaveCriticalSection(&IrdaCs);
                    }    
                }   
                
                if (rc != NO_ERROR && AttribHandle != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(AttribHandle);
                }    
                
                return rc;
            }
        }
    }

    return WSAEINVAL;
}

INT
WSHGetWildcardSockaddr(
    IN  PVOID       HelperDllSocketContext,
    OUT PSOCKADDR   Sockaddr,
    OUT PINT        SockaddrLength)
{
    
    DEBUGMSG(("WSHGetWildcarSockaddr\n"));

    if (*SockaddrLength < sizeof(SOCKADDR_IRDA))
    {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_IRDA);

    RtlZeroMemory(Sockaddr, sizeof(SOCKADDR_IRDA));

    Sockaddr->sa_family = AF_IRDA;

    return NO_ERROR;
}

DWORD
WSHGetWinsockMapping(
    OUT PWINSOCK_MAPPING    Mapping,
    IN  DWORD               MappingLength)
{

    DEBUGMSG(("WSHGetWinsockMapping\n"));
    
    if (MappingLength >= sizeof(IrDAMapping))
        RtlMoveMemory(Mapping, &IrDAMapping, sizeof(IRDA_WINSOCK_MAPPING));

    return(sizeof(IRDA_WINSOCK_MAPPING));
}

//****************************************************************************
//
//
INT
WSHOpenSocket(
    IN OUT  PINT            AddressFamily,
    IN OUT  PINT            SocketType,
    IN OUT  PINT            Protocol,
    OUT     PUNICODE_STRING TransportDeviceName,
    OUT     PVOID          *HelperDllSocketContext,
    OUT     PDWORD          NotificationEvents)
{
    PWSHIRDA_SOCKET_CONTEXT pSocket;
    
    if (*AddressFamily != (int) IrDAMapping.Mapping[0].AddressFamily)
        return WSAEINVAL;

    ASSERT(IrDAMapping.Rows == 3);

    if (! ((*SocketType == (int) IrDAMapping.Mapping[0].SocketType  &&
            *Protocol   == (int) IrDAMapping.Mapping[0].Protocol)   ||
           (*SocketType == (int) IrDAMapping.Mapping[1].SocketType  &&
            *Protocol   == (int) IrDAMapping.Mapping[1].Protocol)   ||   
           (*SocketType == (int) IrDAMapping.Mapping[2].SocketType  &&
            *Protocol   == (int) IrDAMapping.Mapping[2].Protocol)))
    {
        DEBUGMSG(("WSHOpenSocket failed! WSAEINVAL\n"));    
        return WSAEINVAL;
    }

    RtlInitUnicodeString(TransportDeviceName, IRDA_DEVICE_NAME);

    if ((pSocket = RtlAllocateHeap(RtlProcessHeap(), 
            0, sizeof(WSHIRDA_SOCKET_CONTEXT))) == NULL)
    {
        DEBUGMSG(("WSHOpenSocket failed! WSAENOBUFS\n"));
        return WSAENOBUFS;
    }
    
    *HelperDllSocketContext = pSocket;
    
    pSocket->AddressFamily = AF_IRDA;
    pSocket->SocketType = SOCK_STREAM;
    pSocket->Protocol = IRDA_PROTO_SOCK_STREAM;
    pSocket->Options = 0;
    pSocket->pIasAttribs = NULL;
    pSocket->LazyDscvDevHandle = NULL;
    
    *NotificationEvents = WSH_NOTIFY_CLOSE | WSH_NOTIFY_BIND;

    DEBUGMSG(("WSHOpenSocket %X\n", pSocket));

    return NO_ERROR;
}    

VOID
DeleteSocketAttribs(PWSHIRDA_SOCKET_CONTEXT pSocket)
{
    PWSHIRDA_IAS_ATTRIBUTE pIasAttrib;

    // Assumes IrdaCs is held
    
    DEBUGMSG(("Delete attribs for socket %X\n", pSocket));
    
    while (pSocket->pIasAttribs)
    {
        pIasAttrib = pSocket->pIasAttribs;
                
        pSocket->pIasAttribs = pIasAttrib->pNext;
                
        DEBUGMSG(("Delete attrib %x socket %x\n", 
                pIasAttrib->AttribHandle, pSocket));
                
        CloseHandle(pIasAttrib->AttribHandle);                

        RtlFreeHeap(RtlProcessHeap(), 0, pIasAttrib);
    }
}

INT
WSHNotify(
    IN PVOID    HelperDllSocketContext,
    IN SOCKET   SocketHandle,
    IN HANDLE   TdiAddressObjectHandle,
    IN HANDLE   TdiConnectionObjectHandle,
    IN DWORD    NotifyEvent)
{
    PWSHIRDA_SOCKET_CONTEXT pSocket = HelperDllSocketContext;
    
    DEBUGMSG(("WSHNotify\n"));

    switch (NotifyEvent)
    {
        case WSH_NOTIFY_CLOSE:
            DEBUGMSG(("WSH_NOTIFY_CLOSE %x\n", pSocket));
            
            EnterCriticalSection(&IrdaCs);
            
            DeleteSocketAttribs(pSocket);
         
            LeaveCriticalSection(&IrdaCs);
            
            if (pSocket->LazyDscvDevHandle != NULL)
            {
                NtClose(pSocket->LazyDscvDevHandle);
            }    
            
            RtlFreeHeap(RtlProcessHeap(), 0, pSocket);
            
            break;

        case WSH_NOTIFY_CONNECT:
            DEBUGMSG(("WSH_NOTIFY_CONNECT\n"));
            break;            
 
        case WSH_NOTIFY_BIND:
            DEBUGMSG(("WSH_NOTIFY_BIND AddrObj:%x, ConnObj:%x Context %x Options %d\n",
                        TdiAddressObjectHandle, TdiConnectionObjectHandle,
                        pSocket, pSocket->Options));
                        
            if (pSocket->Options != 0)
            {
                NTSTATUS            Status;
                IO_STATUS_BLOCK     IoStatusBlock;
                
                Status = NtDeviceIoControlFile(
                            TdiAddressObjectHandle,
                            NULL,                      // HANDLE Event OPTIONAL
                            NULL,                      // PIO_APC_ROUTINE ApcRoutine
                            NULL,                      // PVOID ApcContext
                            &IoStatusBlock,            // PIO_STATUS_BLOCK IoStatusBlock
                            IOCTL_IRDA_SET_OPTIONS,    // ULONG IoControlCode
                            (char *) &pSocket->Options, // PVOID InputBuffer
                            sizeof(DWORD),             // ULONG InputBufferLength
                            NULL,                      // PVOID OutputBuffer
                            0);                        // ULONG OutputBufferLength
                            
                DEBUGMSG(("IOCTL_IRDA_SET_OPTIONS rc %x\n", Status));                            
                
            }                
            break;            
            
        case WSH_NOTIFY_LISTEN:
            DEBUGMSG(("WSH_NOTIFY_LISTEN\n"));
            break;            
            
        case WSH_NOTIFY_ACCEPT:
            DEBUGMSG(("WSH_NOTIFY_ACCEPT\n"));
            break;            
            
        default:
            DEBUGMSG(("WSHNotify unknown event %d\n", NotifyEvent));
            
    }        
            
    return NO_ERROR;

}



INT
WSHEnumProtocols(
    IN      LPINT   lpiProtocols,
    IN      LPWSTR  lpTransportKeyName,
    IN OUT  LPVOID  lpProtocolBuffer,
    IN OUT  LPDWORD lpdwBufferLength)
{
    BOOL            UseIrDA = FALSE;        
    PPROTOCOL_INFO  pIrDAProtocolInfo;    
    DWORD           BytesRequired;
    DWORD           i;

    lpTransportKeyName; // Avoid compiler warnings.

    DEBUGMSG(("WSHEnumProtocols\n"));

    if (ARGUMENT_PRESENT(lpiProtocols))
    {
        for (i = 0; lpiProtocols[i] != 0; i++) 
        {
            if (lpiProtocols[i] == IRDA_PROTO_SOCK_STREAM) 
            {
                UseIrDA = TRUE;
            }
        }
    }
    else 
    {
        UseIrDA = TRUE;
    }    

    if (! UseIrDA)
    {
        *lpdwBufferLength = 0;
        return 0;
    }

    BytesRequired = sizeof(PROTOCOL_INFO) +
        ((wcslen(IRDA_NAME) + 1) * sizeof(WCHAR));

    if (BytesRequired > *lpdwBufferLength)
    {
        *lpdwBufferLength = BytesRequired;
        return -1;
    }

    pIrDAProtocolInfo = lpProtocolBuffer;

    pIrDAProtocolInfo->dwServiceFlags   =
        XP_GUARANTEED_DELIVERY |
        XP_GUARANTEED_ORDER;
    pIrDAProtocolInfo->iAddressFamily   = AF_IRDA;
    pIrDAProtocolInfo->iMaxSockAddr     = MIN_SOCKADDR_LEN;
    pIrDAProtocolInfo->iMinSockAddr     = MAX_SOCKADDR_LEN;
    pIrDAProtocolInfo->iSocketType      = SOCK_STREAM;
    pIrDAProtocolInfo->iProtocol        = IRDA_PROTO_SOCK_STREAM;
    pIrDAProtocolInfo->dwMessageSize    = 0;
    pIrDAProtocolInfo->lpProtocol       = (LPWSTR)
        ((PBYTE) lpProtocolBuffer + *lpdwBufferLength -
         ((wcslen(IRDA_NAME) + 1) * sizeof(WCHAR)));   

    wcscpy(pIrDAProtocolInfo->lpProtocol, IRDA_NAME );

    *lpdwBufferLength = BytesRequired;

    return (1);
}

INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    )

/*++

Routine Description:

    Retrieves a pointer to the WSAPROTOCOL_INFOW structure(s) describing
    the protocol(s) supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProtocolInfo - Receives a pointer to the WSAPROTOCOL_INFOW array.

    ProtocolInfoEntries - Receives the number of entries in the array.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    DEBUGMSG(("WSHGetWSAProtocolInfo\n"));

    if( ProviderName == NULL ||
        ProtocolInfo == NULL ||
        ProtocolInfoEntries == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"IrDA" ) == 0 ) {

        *ProtocolInfo = Winsock2Protocols;
        *ProtocolInfoEntries = 1;

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetWSAProtocolInfo

INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"irda" ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &IrdaProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid

VOID
WINAPI
IoctlCompletionRoutine (
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    )
{
    LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine;
    LPWSAOVERLAPPED     lpOverlapped;
    DWORD               dwErrorCode = 0;
    DWORD               dwNumberOfBytesTransfered;
    DWORD               dwFlags = 0;

    DEBUGMSG(("IoctlCompletionRoutine\n"));
    
    if (NT_ERROR(IoStatusBlock->Status))
    {
        if (IoStatusBlock->Status != STATUS_CANCELLED) 
        {
            dwErrorCode = IoStatusToWs(IoStatusBlock->Status);
        } 
        else
        {
            dwErrorCode = WSA_OPERATION_ABORTED;
        }

        dwNumberOfBytesTransfered = 0;
    } 
    else 
    {
        dwErrorCode = 0;
        dwNumberOfBytesTransfered = (ULONG) IoStatusBlock->Information;
    }    

    CompletionRoutine = (LPWSAOVERLAPPED_COMPLETION_ROUTINE)ApcContext;
    lpOverlapped = (LPWSAOVERLAPPED)CONTAINING_RECORD(IoStatusBlock,WSAOVERLAPPED,Internal);
    
    (CompletionRoutine)(
        dwErrorCode,
        dwNumberOfBytesTransfered,
        lpOverlapped,
        dwFlags);
}

INT
WSHIoctl(
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CallerCompletionRoutine,
    OUT LPBOOL NeedsCompletion)
{
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       ObjAttr;
    UNICODE_STRING          DeviceName;
    HANDLE                  DeviceHandle;
    IO_STATUS_BLOCK         IoStatusBlock;
    BOOL                    Result;   
    PWSHIRDA_SOCKET_CONTEXT pSocket = HelperDllSocketContext;
    PIO_APC_ROUTINE apcRoutine;
    
    DEBUGMSG(("WSHIoctl: Sock %d, AddrObj %X, ConnObj %X\n", SocketHandle,
             TdiAddressObjectHandle, TdiConnectionObjectHandle));
             
    if (HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        NumberOfBytesReturned == NULL ||
        NeedsCompletion == NULL ||
        IoControlCode != SIO_LAZY_DISCOVERY ||
        (CallerCompletionRoutine != NULL && Overlapped == NULL) ||
            // I am using the Overlapped for the IoStatusBlock
            // for the completion routine so if a CallerCompletionRoutine
            // is specified, an Overlapped must be passed in as well
        OutputBufferLength < (sizeof(DWORD) + sizeof(IRDA_DEVICE_INFO))) 
    {
        return WSAEINVAL;

    }
    
    *NeedsCompletion = FALSE;
    
    *NumberOfBytesReturned = OutputBufferLength;

    if (pSocket->LazyDscvDevHandle == NULL)
    {
        RtlInitUnicodeString(&DeviceName, IRDA_DEVICE_NAME);
      
        InitializeObjectAttributes(
            &ObjAttr,
            &DeviceName,
            OBJ_INHERIT | OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);


        Status = NtCreateFile(
                &pSocket->LazyDscvDevHandle,    // PHANDLE FileHandle
                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,//SYNCHRONIZE | GENERIC_EXECUTE,  // ACCESS_MASK DesiredAccess
                &ObjAttr,                       // POBJECT_ATTRIBUTES ObjAttr
                &IoStatusBlock,                 // PIO_STATUS_BLOCK IoStatusBlock
                NULL,                           // PLARGE_INTEGER AllocationSize
                0,                              // ULONG FileAttributes
                FILE_SHARE_READ |
                FILE_SHARE_WRITE,               // ULONG ShareAccess
                FILE_OPEN_IF,                   // ULONG CreateDisposition
                0,                              // ULONG CreateOptions
                NULL,                           // PVOID EaBuffer
                0);                             // ULONG EaLength

        if (!NT_SUCCESS(Status))
        {
            return WSAEINVAL;
        }
    }    

    Status = STATUS_SUCCESS;
    
    if (CallerCompletionRoutine == NULL)
    {
        // let Win32 do the dirty work
        
        DEBUGMSG(("No CallerCompletionRoutine, using DeviceIoControl()\n"));
        Result = DeviceIoControl(pSocket->LazyDscvDevHandle,
                             IOCTL_IRDA_LAZY_DISCOVERY,
                             NULL, 0, OutputBuffer, OutputBufferLength,
                             NumberOfBytesReturned, Overlapped);

        if (Result == FALSE)
        {
            Status = GetLastError();
        
            if (Status == ERROR_IO_PENDING)
            {
                Status = STATUS_PENDING;
            }
        }
    }                             
    else
    {
        DEBUGMSG(("Using NtDeviceIoControlFile\n"));    
        
        Status = NtDeviceIoControlFile(
                    pSocket->LazyDscvDevHandle,
                    NULL,
                    IoctlCompletionRoutine,
                    CallerCompletionRoutine,
                    (PIO_STATUS_BLOCK)&Overlapped->Internal,
                    IOCTL_IRDA_LAZY_DISCOVERY,
                    NULL,
                    0,
                    OutputBuffer,
                    OutputBufferLength);
                    
        if (Status == STATUS_SUCCESS)
        {
            *NumberOfBytesReturned = (DWORD) IoStatusBlock.Information;
        }
    }
    
    DEBUGMSG(("IoControlFile returned %x\n", Status));
    
    return IoStatusToWs(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\inc\jet500.h ===
#if !defined(_JET_INCLUDED)
#define _JET_INCLUDED

#ifdef	__cplusplus
extern "C" {
#endif

#if defined(_M_ALPHA)
#pragma pack(8)
#else
#pragma pack(4)
#endif

#define JET_API     __stdcall
#define JET_NODSAPI __stdcall

typedef long JET_ERR;

typedef unsigned long JET_INSTANCE;	/* Instance Identifier */
typedef ULONG_PTR JET_SESID;        /* Session Identifier */
typedef ULONG_PTR JET_TABLEID;  	/* Table Identifier */
typedef unsigned long JET_COLUMNID;	/* Column Identifier */

typedef ULONG_PTR JET_DBID;        	/* Database Identifier */
typedef unsigned long JET_OBJTYP;	/* Object Type */
typedef unsigned long JET_COLTYP;	/* Column Type */
typedef unsigned long JET_GRBIT;  	/* Group of Bits */
typedef unsigned long JET_ACM;		/* Access Mask */
typedef unsigned long JET_RNT;		/* Repair Notification Type */

typedef unsigned long JET_SNP;		/* Status Notification Process */
typedef unsigned long JET_SNT;		/* Status Notification Type */
typedef unsigned long JET_SNC;		/* Status Notification Code */
typedef double JET_DATESERIAL;		/* JET_coltypDateTime format */
typedef unsigned long JET_HANDLE;	/* backup file handle */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void *pv);

typedef struct tagCONVERT
	{
	char			*szOldDll;
	char			*szOldSysDb;
	unsigned long	fDbAttached;		// Return value indicating if Db was attached
	} JET_CONVERT;


typedef enum
	{
	opDBUTILConsistency,
	opDBUTILDumpData,
	opDBUTILDumpMetaData,
	opDBUTILDumpSpace,
	opDBUTILSetHeaderState,
	opDBUTILDumpHeader,
	opDBUTILDumpLogfile,
	opDBUTILDumpCheckpoint
	} DBUTIL_OP;

typedef struct tagDBUTIL
	{
	unsigned long	cbStruct;
	char			*szDatabase;
	char			*szTable;
	char			*szIndex;
	DBUTIL_OP		op;
	JET_GRBIT		grbitOptions;
	} JET_DBUTIL;	

#define JET_bitDBUtilOptionAllNodes				0x00000001
#define JET_bitDBUtilOptionKeyStats				0x00000002
#define JET_bitDBUtilOptionPageDump				0x00000004
#define JET_bitDBUtilOptionDumpVerbose			0x10000000	// DEBUG only
#define JET_bitDBUtilOptionCheckBTree			0x20000000	// DEBUG only


	/*	Session information bits */

#define JET_bitCIMCommitted					 	0x00000001
#define JET_bitCIMDirty	 					 	0x00000002
#define JET_bitAggregateTransaction		  		0x00000008

	/* JetGetLastErrorInfo structure */

typedef struct
	{
	unsigned long	cbStruct;		/* Size of this structure */
	JET_ERR 	   	err;			/* Extended error code (if any) */
	unsigned long	ul1;			/* First general purpose integer */
	unsigned long	ul2;			/* Second general purpose integer */
	unsigned long	ul3;			/* Third general purpose integer */
	} JET_EXTERR;

	/* Status Notification Structures */

typedef struct				/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cunitDone;	/* Number of units of work completed */
	unsigned long	cunitTotal;	/* Total number of units of work */
	} JET_SNPROG;

	/* ErrCount Notification Structures */

typedef struct						/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cRecUniqueKeyViolation;
	unsigned long	cRecTypeConversionFail;
	unsigned long	cRecRecordLocked;
	unsigned long	cRecTotal;	/* Total number of units of work */
	} JET_SNERRCNT;


typedef struct				/* Status Notification Message */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_SNC  		snc;	  	/* Status Notification Code */
	unsigned long	ul;			/* Numeric identifier */
	char	 		sz[256];  	/* Identifier */
	} JET_SNMSG;


typedef struct
	{
	unsigned long		cbStruct;
	JET_OBJTYP			objtyp;
	JET_DATESERIAL		dtCreate;
	JET_DATESERIAL		dtUpdate;
	JET_GRBIT			grbit;
	unsigned long		flags;
	unsigned long		cRecord;
	unsigned long		cPage;
	} JET_OBJECTINFO;


/*	required for Exchange to make RSTMAP RPC capable
/**/
#ifdef	MIDL_PASS
#define	xRPC_STRING [string]
#else
#define	xRPC_STRING
typedef unsigned short WCHAR;
#endif

typedef struct
	{
	xRPC_STRING char		*szDatabaseName;
	xRPC_STRING char		*szNewDatabaseName;
	} JET_RSTMAP;			/* restore map */

/*	required for Exchange unicode support
/**/
#define	UNICODE_RSTMAP

typedef struct tagJET_RSTMAPW {
	xRPC_STRING WCHAR *wszDatabaseName;
	
	xRPC_STRING WCHAR *wszNewDatabaseName;
	} JET_RSTMAPW, *PJET_RSTMAPW;

	/* The following flags appear in the grbit field above */

#define JET_bitTableInfoUpdatable	0x00000001
#define JET_bitTableInfoBookmark	0x00000002
#define JET_bitTableInfoRollback	0x00000004
#define JET_bitTableInfoRestartable	0x00000008
#define JET_bitTableInfoNoInserts	0x00000010

	/* The following flags occur in the flags field above */

#define JET_bitSaveUIDnPWD		0x20000000	/* this bit is only 		 */
											/* appropriate for rmt links */
#define JET_bitObjectExclusive	0x40000000	/* Open link exclusively */
#define JET_bitObjectSystem		0x80000000


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidcontainername;
	JET_COLUMNID	columnidobjectname;
	JET_COLUMNID	columnidobjtyp;
	JET_COLUMNID	columniddtCreate;
	JET_COLUMNID	columniddtUpdate;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidflags;
	JET_COLUMNID	columnidcRecord;	/* Level 2 info */
	JET_COLUMNID	columnidcPage;		/* Level 2 info */
	} JET_OBJECTLIST;

#define cObjectInfoCols 9

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidSid;
	JET_COLUMNID	columnidACM;
	JET_COLUMNID	columnidgrbit; /* grbit from JetSetAccess */
	} JET_OBJECTACMLIST;

#define cObjectAcmCols 3


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidPresentationOrder;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidcbMax;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidDefault;
	JET_COLUMNID	columnidBaseTableName;
	JET_COLUMNID	columnidBaseColumnName;
	JET_COLUMNID	columnidDefinitionName;
	} JET_COLUMNLIST;

#define cColumnInfoCols 14

typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wCollate;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	} JET_COLUMNDEF;


typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wFiller;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	char			szBaseTableName[256];
	char			szBaseColumnName[256];
	} JET_COLUMNBASE;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidindexname;
	JET_COLUMNID	columnidgrbitIndex;
	JET_COLUMNID	columnidcKey;
	JET_COLUMNID	columnidcEntry;
	JET_COLUMNID	columnidcPage;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidgrbitColumn;
	JET_COLUMNID	columnidcolumnname;
	} JET_INDEXLIST;



typedef struct tag_JET_COLUMNCREATE
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szColumnName;			// column name
	JET_COLTYP		coltyp;					// column type
	unsigned long	cbMax;					// the maximum length of this column (only relevant for binary and text columns)
	JET_GRBIT		grbit;					// column options
	void			*pvDefault;				// default value (NULL if none)
	unsigned long	cbDefault;				// length of default value
	unsigned long	cp;						// code page (for text columns only)
	JET_COLUMNID	columnid;				// returned column id
	JET_ERR			err;					// returned error code
	} JET_COLUMNCREATE;


typedef struct tagJET_INDEXCREATE
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szIndexName;			// index name
	char			*szKey;					// index key
	unsigned long	cbKey;					// length of key
	JET_GRBIT		grbit;					// index options
	unsigned long	ulDensity;				// index density
	JET_ERR			err;					// returned error code
	} JET_INDEXCREATE;


typedef struct tagJET_TABLECREATE
	{
	unsigned long		cbStruct;				// size of this structure (for future expansion)
	char				*szTableName;			// name of table to create.
	unsigned long		ulPages;				// initial pages to allocate for table.
	unsigned long		ulDensity;				// table density.
	JET_COLUMNCREATE	*rgcolumncreate;		// array of column creation info
	unsigned long		cColumns;				// number of columns to create
	JET_INDEXCREATE		*rgindexcreate;			// array of index creation info
	unsigned long		cIndexes;				// number of indexes to create
	JET_GRBIT			grbit;					// Abort column/index creation on error?
	JET_TABLEID			tableid;				// returned tableid.
	unsigned long		cCreated;				// count of objects created (columns+table+indexes).
	} JET_TABLECREATE;


#define cIndexInfoCols 15

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidReferenceName;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidReferencingTableName;
	JET_COLUMNID	columnidReferencingColumnName;
	JET_COLUMNID	columnidReferencedTableName;
	JET_COLUMNID	columnidReferencedColumnName;
	} JET_RELATIONSHIPLIST;

/* for backward compatibility */
typedef JET_RELATIONSHIPLIST JET_REFERENCELIST;

#define cReferenceInfoCols 8

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	JET_COLUMNID	columnidNextTagged;
	} JET_RETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	} JET_SETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	centriesLT;
	unsigned long	centriesInRange;
	unsigned long	centriesTotal;
	} JET_RECPOS;

typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	unsigned long	cpgCompactFreed;
	} JET_OLCSTAT;

typedef struct
	{
	unsigned long	ctableid;
	JET_TABLEID		rgtableid[1];
	} JET_MGBLIST;

/*** Property Manager Structure ***/
typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID 	tableid;
	JET_COLUMNID 	columnidColumnName;
	JET_COLUMNID 	columnidPropertyName;
	JET_COLUMNID	columnidGrbit;
	JET_COLUMNID	columnidPropertyValue;
	JET_COLUMNID	columnidColtyp;
	} JET_PROPERTYLIST;


/************************************************************************/
/*************************     JET CONSTANTS	 ************************/
/************************************************************************/

#define JET_tableidNil			((JET_TABLEID) 	0xFFFFFFFF)

#define	JET_sesidNil			((JET_SESID) 	0xFFFFFFFF)

	/* Max size of a bookmark */

#define JET_cbBookmarkMost		4

	/* Max length of a object/column/index/property name */

#define JET_cbNameMost			64

	/* Max length of a "name.name.name..." construct */

#define JET_cbFullNameMost		255

	/* Max size of long-value column chunk */

#define JET_cbColumnLVChunkMost		4035

	/* Max size of non-long-value column data */

#define JET_cbColumnMost		255

	/* Max size of a sort/index key */

#define JET_cbKeyMost			255

	/* Max number of components in a sort/index key */

#define JET_ccolKeyMost			12

	/* Max number of columns in a table/query */

#define JET_ccolTableMost		255

	/* Max Length of a property in the property manager */
#define JET_cbPropertyMost 2048

	/* Largest initial substring of a long value used in an expression */

#define JET_cbExprLVMost		0x8000L	/*** 32 K ***/

	/* Max size of returned (from SQLDriverConnect) conn string */

#define JET_cbConnectMost		255

	/* Max number of levels in an MGB */

#define JET_wGroupLevelMax		12

	/* Size restrictions for Pins */
#define JET_cchPINMax			20
#define JET_cchPINMin			4

	/* System parameter codes for JetSetSystemParameter */

/* not supported */
#define JET_paramPfnStatus				2	/* Status callback function */
#define JET_paramPfnError				3	/* Error callback function */
#define JET_paramHwndODBC				4	/* Window handle for ODBC use */
#define JET_paramIniPath				5	/* Path to the ini file */
#define JET_paramPageTimeout			6	/* Red ISAM page timeout value */
#define JET_paramODBCQueryTimeout		7	/* ODBC async query timeout value */
#define JET_paramODBCLoginTimeout		25	/* ODBC connection attempt timeout value */
#define JET_paramExprObject				26  /* Expression Evaluation callback */
#define JET_paramGetTypeComp			27	/* Expression Evaluation callback */
#define JET_paramHostVersion			28	/* Host Version callback */
#define JET_paramSQLTraceMode			29	/* Enable/disable SQL tracing */
#define JET_paramEventId				46	/* NT event id */
#define JET_paramEventCategory			47	/* NT event category */
#define JET_paramRmtXactIsolation		39	/* Do not share connections with other sessions */
#define JET_paramJetInternal			35	/* Whether internal to JET; if set, allows ISAM to do things which are prevented in general */
#define JET_paramFullQJet				38	/* Allow full QJet functionality */

#define JET_paramLogFlushThreshold		18	/* log buffer flush threshold in 512 bytes [10] */
#define JET_paramLogFlushPeriod			22	/* log flush period in miliseconds [45] */

#define JET_paramOnLineCompact			37	/*	Options for compact pages on-line */
#define JET_paramRecovery				30	/* Switch for log on/off */

/* debug only not supported */
#define JET_paramTransactionLevel		32	/* Transaction level of session */
#define JET_paramAssertAction			44	/*	debug only determines action on assert */
#define	JET_paramPrintFunction			49	/* debug only. synched print function */
#define JET_paramRFS2IOsPermitted		54  /* # IOs permitted to succeed (-1 = all) */
#define JET_paramRFS2AllocsPermitted	55  /* # allocs permitted to success (-1 = all) */

/*	fully supported parameters */
/*	Note that one page = 4kBytes.
/**/
#define JET_paramSysDbPath				0	/* path to the system database (defunct) ["<base name>.<base ext>"] */
#define JET_paramSystemPath				0	/* path to check point file ["."] */
#define JET_paramTempPath				1	/* path to the temporary database ["."] */
#define JET_paramMaxBuffers				8	/* maximum page cache size in pages [512] */
#define JET_paramMaxSessions			9	/* maximum number of sessions [128] */
#define JET_paramMaxOpenTables			10	/* maximum number of open tables [300] */
#define JET_paramPreferredMaxOpenTables 	59	/* prefered maximum number of open tables [300] */
#define JET_paramMaxVerPages			11	/* maximum version store size in 16KB buckets [64] */
#define JET_paramMaxCursors				12	/* maximum number of open cursors [1024] */
#define JET_paramLogFilePath			13	/* path to the log file directory ["."] */
#define JET_paramMaxOpenTableIndexes 	14	/* maximum open table indexes [300] */
#define JET_paramMaxTemporaryTables		15	/* maximum concurrent JetCreateIndex [20] */
#define JET_paramLogBuffers				16	/* maximum log buffers in 512 bytes [21] */
#define JET_paramLogFileSize			17	/* maximum log file size in kBytes [5120] */
#define JET_paramBfThrshldLowPrcnt		19	/* low percentage clean buffer flush start [20] */
#define JET_paramBfThrshldHighPrcnt		20	/* high percentage clean buffer flush stop [80] */
#define JET_paramWaitLogFlush			21	/* log flush wait time in milliseconds [15] */
#define JET_paramLogCheckpointPeriod	23	/* checkpoint period in 512 bytes [1024] */
#define JET_paramLogWaitingUserMax		24	/* maximum sessions waiting log flush [3] */
#define JET_paramSessionInfo			33	/* per session information [0] */
#define JET_paramPageFragment			34	/* maximum disk extent considered fragment in pages [8] */
#define JET_paramMaxOpenDatabases		36	/* maximum number of open databases [100] */
#define JET_paramBufBatchIOMax			41	/* maximum batch IO in pages [64] */
#define JET_paramPageReadAheadMax		42	/* maximum read-ahead IO in pages [20] */
#define JET_paramAsynchIOMax			43	/* maximum asynchronous IO in pages [64] */
#define JET_paramEventSource			45	/* language independant process descriptor string [""] */
#define JET_paramDbExtensionSize		48	/* database extension size in pages [16] */
#define JET_paramCommitDefault			50	/* default grbit for JetCommitTransaction [0] */
#define	JET_paramBufLogGenAgeThreshold	51	/* age threshold in log files [2] */
#define	JET_paramCircularLog			52	/* boolean flag for circular logging [0] */
#define JET_paramPageTempDBMin			53  /* minimum size temporary database in pages [0] */
#define JET_paramBaseName				56  /* base name for all DBMS object names ["edb"] */
#define JET_paramBaseExtension	  		57  /* base extension for all DBMS object names ["edb"] */
#define JET_paramTableClassName			58  /* table stats class name (class #, string) */

	/* Flags for JetTerm2 */

#define JET_bitTermComplete				0x00000001
#define JET_bitTermAbrupt				0x00000002

	/* Flags for JetIdle */

#define JET_bitIdleRemoveReadLocks		0x00000001
#define JET_bitIdleFlushBuffers			0x00000002
#define JET_bitIdleCompact				0x00000004
#define JET_bitIdleStatus				0x80000000

	/* Flags for JetEndSession */
								   	
#define JET_bitForceSessionClosed		0x00000001

	/* Flags for JetOpenDatabase */

#define JET_bitDbReadOnly				0x00000001
#define JET_bitDbExclusive				0x00000002 /* multiple opens allowed */
#define JET_bitDbRemoteSilent			0x00000004
#define JET_bitDbSingleExclusive		0x00000008 /* opened exactly once */

	/* Flags for JetCloseDatabase */
										
#define JET_bitDbForceClose				0x00000001
							   	
	/* Flags for JetCreateDatabase */

#define JET_bitDbVersion10				0x00000002 /* INTERNAL USE ONLY */
#define JET_bitDbVersion1x				0x00000004
#define JET_bitDbRecoveryOff 			0x00000008 /* disable logging/recovery for this database */
#define JET_bitDbNoLogging	 			JET_bitDbRecoveryOff
#define JET_bitDbCompleteConnstr		0x00000020
#define JET_bitDbVersioningOff			0x00000040

	/* Flags for JetBackup */

#define JET_bitBackupIncremental		0x00000001
#define JET_bitKeepOldLogs				0x00000002
#define JET_bitBackupAtomic				0x00000004

	/* Database types */

#define JET_dbidNil			((JET_DBID) 0xFFFFFFFF)
#define JET_dbidNoValid		((JET_DBID) 0xFFFFFFFE) /* used as a flag to indicate that there is no valid dbid */

	/* Flags for JetCreateLink */

/* Can use JET_bitObjectExclusive to cause linked to database to be opened */
/* exclusively.															   */



	/* Flags for JetCreateTableColumnIndex */
#define JET_bitTableCreateCheckColumnNames	0x00000001	/* Ensures that each column
														/* specified in the JET_COLUMNCREATE
														/* array has a unique name
														/* (for performance reasons,
														/* the default is to NOT perform
														/* this check and rely on the
														/* function caller to ensure
														/* column name uniqueness).
														/**/
#define JET_bitTableCreateCompaction		0x40000000	/* Internal grbit used when
														/* creating a table during
														/* off-line compact.
														/**/
#define JET_bitTableCreateSystemTable		0x80000000	/* Internal grbit used when
														/* creating system tables.
														/**/


	/* Flags for JetAddColumn, JetGetColumnInfo, JetOpenTempTable */

#define JET_bitColumnFixed				0x00000001
#define JET_bitColumnTagged				0x00000002
#define JET_bitColumnNotNULL			0x00000004
#define JET_bitColumnVersion			0x00000008
#define JET_bitColumnAutoincrement		0x00000010
#define JET_bitColumnUpdatable			0x00000020 /* JetGetColumnInfo only */
#define JET_bitColumnTTKey				0x00000040 /* JetOpenTempTable only */
#define JET_bitColumnTTDescending		0x00000080 /* JetOpenTempTable only */
#define JET_bitColumnNotLast			0x00000100 /* Installable ISAM option */
#define JET_bitColumnRmtGraphic			0x00000200 /* JetGetColumnInfo */
#define JET_bitColumnMultiValued		0x00000400
#define JET_bitColumnColumnGUID			0x00000800
#define JET_bitColumnMostMany			0x00001000
#define JET_bitColumnPreventDelete		0x00002000

	/* Flags for JetSetCurrentIndex */

#define JET_bitMoveFirst				0x00000000
#define JET_bitMoveBeforeFirst 			0x00000001
#define JET_bitNoMove					0x00000002

	/* Flags for JetMakeKey */

#define JET_bitNewKey					0x00000001
#define JET_bitStrLimit 				0x00000002
#define JET_bitSubStrLimit				0x00000004
#define JET_bitNormalizedKey 			0x00000008
#define JET_bitKeyDataZeroLength		0x00000010

#ifdef DBCS /* johnta: LIKE "ABC" not converted to ="ABC" for Japanese */
#define JET_bitLikeExtra1				0x00000020
#endif /* DBCS */

	/* Flags for ErrDispSetIndexRange */

#define JET_bitRangeInclusive			0x00000001
#define JET_bitRangeUpperLimit			0x00000002
#define JET_bitRangeInstantDuration		0x00000004
#define JET_bitRangeRemove				0x00000008

	/* Constants for JetMove */

#define JET_MoveFirst					(0x80000000)
#define JET_MovePrevious				(-1)
#define JET_MoveNext					(+1)
#define JET_MoveLast					(0x7fffffff)

	/* Flags for JetMove */

#define JET_bitMoveKeyNE				0x00000001
#define JET_bitMoveCheckTS				0x00000002
#define JET_bitMoveInPage				0x00000004

	/* Flags for JetSeek */

#define JET_bitSeekEQ					0x00000001
#define JET_bitSeekLT					0x00000002
#define JET_bitSeekLE					0x00000004
#define JET_bitSeekGE					0x00000008
#define JET_bitSeekGT		 			0x00000010
#define JET_bitSetIndexRange			0x00000020

	/* Flags for JetFastFind */

#define JET_bitFFindBackwards			0x00000001
#define JET_bitFFindFromCursor			0x00000004

	/* Flags for JetCreateIndex */

#define JET_bitIndexUnique				0x00000001
#define JET_bitIndexPrimary				0x00000002
#define JET_bitIndexDisallowNull		0x00000004
#define JET_bitIndexIgnoreNull			0x00000008
#define JET_bitIndexClustered			0x00000010
#define JET_bitIndexIgnoreAnyNull		0x00000020
#define JET_bitIndexIgnoreFirstNull		0x00000040
#define JET_bitIndexLazyFlush			0x00000080
#define JET_bitIndexEmptyTable			0x40000000	// Internal use only
#define JET_bitIndexReference			0x80000000    /* IndexInfo only */

	/* Flags for index key definition */

#define JET_bitKeyAscending				0x00000000
#define JET_bitKeyDescending			0x00000001


	/* Flags for JetCreateRelationship */

#define JET_bitRelationUnique			0x00000001
#define JET_bitRelationDontEnforce		0x00000002
#define JET_bitRelationInherited		0x00000004
#define JET_bitRelationTestLegal		0x00000008	/* don't create relationship */

#define JET_bitRelationshipMatchMask	0x000000F0
#define JET_bitRelationMatchDefault		0x00000000
#define JET_bitRelationMatchFull		0x00000010

#define JET_bitRelationUpdateActionMask	0x00000F00
#define JET_bitRelationUpdateDisallow	0x00000000
#define JET_bitRelationUpdateCascade	0x00000100
#define JET_bitRelationUpdateSetNull	0x00000200
#define JET_bitRelationUpdateSetDefault	0x00000300

#define JET_bitRelationDeleteActionMask	0x0000F000
#define JET_bitRelationDeleteDisallow	0x00000000
#define JET_bitRelationDeleteCascade	0x00001000
#define JET_bitRelationDeleteSetNull	0x00002000
#define JET_bitRelationDeleteSetDefault	0x00003000

#define JET_bitRelationUserMask			0xFF000000	/* non-enforced values */
#define JET_bitRelationJoinMask			0x03000000
#define JET_bitRelationInner			0x00000000
#define JET_bitRelationLeft				0x01000000
#define JET_bitRelationRight			0x02000000


	/* Flags for JetCreateReference/JetCreateRelationship */
	/* NOTE: use the bitRelationship flags instead! */

#define JET_ReferenceUnique				JET_bitRelationUnique
#define JET_ReferenceDontEnforce		JET_bitRelationDontEnforce
#define JET_ReferenceMatchTypeMask		JET_bitRelationMatchMask
#define JET_ReferenceMatchDefault		JET_bitRelationMatchDefault
#define JET_ReferenceMatchFull			JET_bitRelationMatchFull
#define JET_ReferenceUpdateActionMask	JET_bitRelationUpdateActionMask
#define JET_ReferenceUpdateDisallow		JET_bitRelationUpdateDisallow
#define JET_ReferenceUpdateCascade		JET_bitRelationUpdateCascade
#define JET_ReferenceUpdateSetNull		JET_bitRelationUpdateSetNull
#define JET_ReferenceUpdateSetDefault	JET_bitRelationUpdateSetDefault
#define JET_ReferenceDeleteActionMask	JET_bitRelationDeleteActionMask
#define JET_ReferenceDeleteDisallow		JET_bitRelationDeleteDisallow
#define JET_ReferenceDeleteCascade		JET_bitRelationDeleteCascade
#define JET_ReferenceDeleteSetNull		JET_bitRelationDeleteSetNull
#define JET_ReferenceDeleteSetDefault	JET_bitRelationDeleteSetDefault


	/* Flags for JetOpenTable */

#define JET_bitTableDenyWrite		0x00000001
#define JET_bitTableDenyRead		0x00000002
#define JET_bitTableReadOnly		0x00000004
#define JET_bitTableAppendOnly		0x00000008
#define JET_bitTableUpdatable		0x00000010
#define JET_bitTableScrollable		0x00000020
#define JET_bitTableFixedSet		0x00000040	/* Fixed working set */
#define JET_bitTableInconsistent	0x00000080
#define JET_bitTableBulk			0x00000100
#define JET_bitTableUsePrimaryIndex	0x00000200	/* Use with FixedSet */
#define JET_bitTableSampleData		0x00000400
#define JET_bitTableQuickBrowse		0x00000800	/* Bias optimizer toward index usage */
#define JET_bitTableDDL				0x00001000	/* similar to JET_bitTableBulk, for DDL */
#define JET_bitTablePassThrough		0x00002000  /* Remote DBs Only */
#define JET_bitTableRowReturning	0x00004000
#define JET_bitTableSequential		0x00008000	/* Intend to access table sequentially */

#define JET_bitTableClassMask		0x000F0000	/*  table stats class mask  */
#define JET_bitTableClassNone		0x00000000  /*  table belongs to no stats class (default)  */
#define JET_bitTableClass1			0x00010000  /*  table belongs to stats class 1  */
#define JET_bitTableClass2			0x00020000  /*  table belongs to stats class 2  */
#define JET_bitTableClass3			0x00030000  /*  table belongs to stats class 3  */
#define JET_bitTableClass4			0x00040000  /*  table belongs to stats class 4  */
#define JET_bitTableClass5			0x00050000  /*  table belongs to stats class 5  */
#define JET_bitTableClass6			0x00060000  /*  table belongs to stats class 6  */
#define JET_bitTableClass7			0x00070000  /*  table belongs to stats class 7  */
#define JET_bitTableClass8			0x00080000  /*  table belongs to stats class 8  */
#define JET_bitTableClass9			0x00090000  /*  table belongs to stats class 9  */
#define JET_bitTableClass10			0x000A0000  /*  table belongs to stats class 10  */
#define JET_bitTableClass11			0x000B0000  /*  table belongs to stats class 11  */
#define JET_bitTableClass12			0x000C0000  /*  table belongs to stats class 12  */
#define JET_bitTableClass13			0x000D0000  /*  table belongs to stats class 13  */
#define JET_bitTableClass14			0x000E0000  /*  table belongs to stats class 14  */
#define JET_bitTableClass15			0x000F0000  /*  table belongs to stats class 15  */

	/* Flags for JetSetQoSql/JetRetrieveQoSql */
#define JET_bitSqlPassThrough		0x00000001	/* Pass through Query returning records */
#define JET_bitSqlSPTBulkOp			0x00000002  /* SPT query returning no table */
	
	/* Flags for JetOpenVtQbe */

#define JET_bitQBEAddBrackets		0x00000001
#define JET_bitQBERemoveEquals		0x00000002

	/* Flags for JetOpenTempTable and ErrIsamOpenTempTable */

#define JET_bitTTIndexed		0x00000001	/* Allow seek */
#define JET_bitTTUnique 		0x00000002	/* Remove duplicates */
#define JET_bitTTUpdatable		0x00000004	/* Allow updates */
#define JET_bitTTScrollable		0x00000008	/* Allow backwards scrolling */

	/* Flags for JetSetColumn */

#define JET_bitSetAppendLV			0x00000001
#define JET_bitSetValidate			0x00000002
#define JET_bitSetOverwriteLV		0x00000004 /* overwrite JET_coltypLong* byte range */
#define JET_bitSetSizeLV			0x00000008 /* set JET_coltypLong* size */
#define JET_bitSetValidateColumn	0x00000010
#define JET_bitSetZeroLength		0x00000020
#define JET_bitSetSeparateLV 		0x00000040 /* force LV separation */
#define JET_bitSetNoVersion 		0x00000080 /* INTERNAL USE ONLY */

	/*	Set column parameter structure for JetSetColumns */

typedef struct {
	JET_COLUMNID			columnid;
	const void 				*pvData;
	unsigned long 			cbData;
	JET_GRBIT				grbit;
	unsigned long			ibLongValue;
	unsigned long			itagSequence;
	JET_ERR					err;
} JET_SETCOLUMN;

	/* Options for JetPrepareUpdate */

#define JET_prepInsert					0
#define JET_prepInsertBeforeCurrent		1
#define JET_prepReplace 				2
#define JET_prepCancel					3
#define JET_prepReplaceNoLock			4
#define JET_prepInsertCopy				5

	/* Flags for JetRetrieveColumn */

#define JET_bitRetrieveCopy				0x00000001
#define JET_bitRetrieveFromIndex		0x00000002
#define JET_bitRetrieveCase				0x00000004
#define JET_bitRetrieveTag				0x00000008
#define JET_bitRetrieveNull				0x00000010	/*	for columnid 0 only */
#define JET_bitRetrieveIgnoreDefault	0x00000020	/*	for columnid 0 only */
#define JET_bitRetrieveLongId			0x00000040
#define JET_bitRetrieveRecord			0x80000000
#define JET_bitRetrieveFDB				0x40000000
#define JET_bitRetrieveBookmarks		0x20000000

	/* Retrieve column parameter structure for JetRetrieveColumns */

typedef struct {
	JET_COLUMNID		columnid;
	void 			*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;

	/* Flags for JetFillFatCursor */

#define JET_bitFCFillRange			0x00000001
#define JET_bitFCRefreshRange		0x00000002
#define JET_bitFCFillMemos			0x00000004

	/* Flags for JetCommitTransaction */

#define JET_bitCommitFlush			0x00000001	/* commit and flush page buffers. */
#define	JET_bitCommitLazyFlush		0x00000004	/* lazy flush log buffers. */
#define JET_bitWaitLastLevel0Commit	0x00000010	/* wait for last level 0 commit record flushed */

	/* Flags for JetRollback */

#define JET_bitRollbackAll			0x00000001

	/* Flags for JetSetAccess and JetGetAccess */

#define JET_bitACEInheritable		0x00000001

	/* Flags for JetCreateSystemDatabase */

#define JET_bitSysDbOverwrite		0x00000001

	/* Flags for Jet Property Management */
#define JET_bitPropDDL				0x00000001		/* also used for setting */
#define JET_bitPropInherited		0x00000002		/* not used for setting */

	/* JPM Flags that are only used for setting properties */
#define JET_bitPropReplaceOnly		0x00000010
#define JET_bitPropInsertOnly		0x00000020
#define JET_bitPropDeleteOnly		0x00000040
	
	/* InfoLevels for Jet Property Management */
#define JET_PropertyValue				0
#define JET_PropertyCount				1
#define JET_PropertySingleCollection 	2
#define JET_PropertyAllCollections		3

	/* Collate values for JetGetColumnInfo and JetGetIndexInfo */

#define JET_sortBinary			0x0000
#define JET_sortEFGPI			0x0100
#define JET_sortSNIFD			0x0101
#define JET_sortSpanish 		0x0102
#define JET_sortDutch			0x0103
#define JET_sortSweFin			0x0104
#define JET_sortNorDan			0x0105
#define JET_sortIcelandic		0x0106
#define JET_sortCyrillic		0x0107
#define JET_sortCzech			0x0108
#define JET_sortHungarian		0x0109
#define JET_sortPolish			0x010A
#define JET_sortArabic			0x010B
#define JET_sortHebrew			0x010C
#define JET_sortMax				0x010C		/* Max for nonDBCS sort orders */

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
#define JET_sortJapanese		0x010D
#endif /* DBCS */

#define JET_sortUnknown 		0xFFFF

	/* Paradox ISAM specific collate values */

#define JET_sortPdxIntl 		0x1000
#define JET_sortPdxSwedFin		0x1001
#define JET_sortPdxNorDan		0x1002

	/* Info parameter for JetGetDatabaseInfo */

#define JET_DbInfoFilename			0
#define JET_DbInfoConnect			1
#define JET_DbInfoCountry			2
#define JET_DbInfoLangid			3
#define JET_DbInfoCp				4
#define JET_DbInfoCollate			5
#define JET_DbInfoOptions			6
#define JET_DbInfoTransactions		7
#define JET_DbInfoVersion			8
#define JET_DbInfoIsam				9
#define JET_DbInfoFilesize			10
#define JET_DbInfoSpaceOwned		11
#define JET_DbInfoSpaceAvailable	12

	/* Database versions returned by JetGetDatabaseInfo */

#define JET_DbVersion10			0x00010000
#define JET_DbVersion11			0x00010001
#define JET_DbVersion20			0x00020000


	/* Isam specific info returned by JetGetDatabaseInfo */

#define JET_IsamInvalid			0
#define JET_IsamBuiltinRed		1
#define JET_IsamBuiltinBlue		2

#define	JET_IsamInstRed			21
#define JET_IsamInstBlue		22
#define	JET_IsamInstFox			23
#define JET_IsamInstParadox		24
#define JET_IsamInstDbase		25
#define	JET_IsamInstBtrieve		26

#define JET_IsamBuilinMost		JET_BuiltinBlue
#define JET_IsamInstMin			JET_IsamInstRed
#define	JET_IsamInstMost		JET_IsamInstBtrieve

	/* Link specific info for link identification */
#define JET_bitLinkInvalid		0x00000000
#define JET_bitLinkRemote		0x00100000
#define JET_bitLinkBuiltinRed	0x00200000
#define JET_bitLinkBuiltinBlue	0x00300000
#define JET_bitLinkInstRed		0x00400000
#define JET_bitLinkInstBlue		0x00500000
#define JET_bitLinkInstFox		0x00600000
#define JET_bitLinkInstParadox	0x00700000
#define JET_bitLinkInstDbase	0x00800000
#define JET_bitLinkInstBtrieve	0x00900000

#define JET_bitFourByteBookmark		0x00000001
#define	JET_bitContiguousBookmarks	0x00000002

	/* Column data types */

#define JET_coltypNil				0
#define JET_coltypBit				1      /* True or False, Never NULL */
#define JET_coltypUnsignedByte		2      /* 1-byte integer, unsigned */
#define JET_coltypShort 			3      /* 2-byte integer, signed */
#define JET_coltypLong				4      /* 4-byte integer, signed */
#define JET_coltypCurrency			5      /* 8 byte integer, signed */
#define JET_coltypIEEESingle		6      /* 4-byte IEEE single precision */
#define JET_coltypIEEEDouble		7      /* 8-byte IEEE double precision */
#define JET_coltypDateTime			8      /* Integral date, fractional time */
#define JET_coltypBinary			9      /* Binary data, < 255 bytes */
#define JET_coltypText				10     /* ANSI text, case insensitive, < 255 bytes */
#define JET_coltypLongBinary		11     /* Binary data, long value */
#define JET_coltypLongText			12     /* ANSI text, long value */
#define JET_coltypDatabase			13		/* Database name parameter */
#define JET_coltypTableid			14		/* Tableid parameter */
#define JET_coltypOLE				15		/* OLE blob */
#define JET_coltypGUID				15
#define JET_coltypMax				16		/* the number of column types  */
											/* used for validity tests and */
											/* array declarations.		   */

	/* Info levels for JetGetObjectInfo */

#define JET_ObjInfo					0U
#define JET_ObjInfoListNoStats		1U
#define JET_ObjInfoList 			2U
#define JET_ObjInfoSysTabCursor 	3U
#define JET_ObjInfoListACM			4U /* Blocked by JetGetObjectInfo */
#define JET_ObjInfoNoStats			5U
#define JET_ObjInfoSysTabReadOnly	6U
#define JET_ObjInfoRulesLoaded		7U
#define JET_ObjInfoMax				8U

	/* Info levels for JetGetTableInfo */

#define JET_TblInfo				0U
#define JET_TblInfoName			1U
#define JET_TblInfoDbid			2U
#define JET_TblInfoMostMany  	3U
#define JET_TblInfoRvt			4U
#define JET_TblInfoOLC			5U
#define JET_TblInfoResetOLC 	6U
#define JET_TblInfoSpaceUsage	7U
#define JET_TblInfoDumpTable	8U
#define JET_TblInfoSpaceAlloc	9U
#define JET_TblInfoSpaceOwned	10U				// OwnExt
#define JET_TblInfoSpaceAvailable	11U			// AvailExt

	/* Info levels for JetGetIndexInfo and JetGetTableIndexInfo */

#define JET_IdxInfo					0U
#define JET_IdxInfoList 			1U
#define JET_IdxInfoSysTabCursor 	2U
#define JET_IdxInfoOLC				3U
#define JET_IdxInfoResetOLC			4U
#define JET_IdxInfoSpaceAlloc		5U
#define JET_IdxInfoLangid			6U
#define JET_IdxInfoCount			7U

	/* Info levels for JetGetReferenceInfo and JetGetTableReferenceInfo */

#define JET_ReferenceInfo				0U
#define JET_ReferenceInfoReferencing	1U
#define JET_ReferenceInfoReferenced		2U
#define JET_ReferenceInfoAll			3U
#define JET_ReferenceInfoCursor 		4U

	/* Info levels for JetGetColumnInfo and JetGetTableColumnInfo */

#define JET_ColInfo					0U
#define JET_ColInfoList 			1U
	/* CONSIDER: Info level 2 is valid */
#define JET_ColInfoSysTabCursor 	3U
#define JET_ColInfoBase 			4U
#define JET_ColInfoListCompact 		5U


	/* Attribute types for query definitions */

#define JET_qoaBeginDef 		0
#define JET_qoaOperation		1
#define JET_qoaParameter		2
#define JET_qoaOptions			3
#define JET_qoaDatabase 		4
#define JET_qoaInputTable		5
#define JET_qoaOutput			6
#define JET_qoaJoin				7
#define JET_qoaRestriction		8
#define JET_qoaGroup			9
#define JET_qoaGroupRstr		10
#define JET_qoaOrdering 		11
#define JET_qoaEndDef			255
#define JET_qoaValidLeast		JET_qoaOperation
#define JET_qoaValidMost		JET_qoaOrdering


	/* Query object options */

#define JET_bitFqoOutputAllCols 	0x0001
#define JET_bitFqoRemoveDups		0x0002
#define JET_bitFqoOwnerAccess		0x0004
#define JET_bitFqoDistinctRow		0x0008
#define JET_bitFqoTop				0x0010
#define JET_bitFqoPercent			0x0020
#define JET_bitFqoCorresponding		0x0040 /* JET_qopSetOperation */

	/* Query object join type */

#define JET_fjoinInner			1
#define JET_fjoinLeftOuter		2
#define JET_fjoinRightOuter		3

	/* Query object operations */

#define JET_qopSelect			1
#define JET_qopSelectInto		2
#define JET_qopInsertSelection	3
#define JET_qopUpdate			4
#define JET_qopDelete			5
#define JET_qopTransform		6
#define JET_qopDDL				7
#define JET_qopSqlPassThrough	8
#define JET_qopSetOperation		9
#define JET_qopSPTBulk			10

#define JET_bitqopSelect			0x0000
#define JET_bitqopTransform			0x0010
#define JET_bitqopDelete			0x0020
#define JET_bitqopUpdate			0x0030
#define JET_bitqopInsertSelection	0x0040
#define JET_bitqopSelectInto		0x0050
#define JET_bitqopDDL				0x0060
#define JET_bitqopSqlPassThrough	0x0070
#define JET_bitqopSetOperation		0x0080
#define JET_bitqopSPTBulk			0x0090

	/* Engine Object Types */

#define JET_objtypNil				0
#define JET_objtypTable 			1
#define JET_objtypDb				2
#define JET_objtypContainer			3
#define JET_objtypSQLLink			4
#define JET_objtypQuery 			5
#define JET_objtypLink				6
#define JET_objtypTemplate			7
#define JET_objtypRelationship		8

	/* All types less than JET_objtypClientMin are reserved by JET */

#define JET_objtypClientMin			0x8000

	/* Security Constant Values */

#define JET_cchUserNameMax		20
#define JET_cchPasswordMax		14

	/* Security Access Masks */

#define JET_acmNoAccess 		0x00000000L
#define JET_acmFullAccess		0x000FFFFFL

#define JET_acmSpecificMask		0x0000FFFFL
#define JET_acmSpecific_1		0x00000001L
#define JET_acmSpecific_2		0x00000002L
#define JET_acmSpecific_3		0x00000004L
#define JET_acmSpecific_4		0x00000008L
#define JET_acmSpecific_5		0x00000010L
#define JET_acmSpecific_6		0x00000020L
#define JET_acmSpecific_7		0x00000040L
#define JET_acmSpecific_8		0x00000080L
#define JET_acmSpecific_9		0x00000100L
#define JET_acmSpecific_10		0x00000200L
#define JET_acmSpecific_11		0x00000400L
#define JET_acmSpecific_12		0x00000800L
#define JET_acmSpecific_13		0x00001000L
#define JET_acmSpecific_14		0x00002000L
#define JET_acmSpecific_15		0x00004000L
#define JET_acmSpecific_16		0x00008000L

#define JET_acmStandardMask		0x00FF0000L
#define JET_acmDelete			0x00010000L
#define JET_acmReadControl		0x00020000L
#define JET_acmWriteDac 		0x00040000L
#define JET_acmWriteOwner		0x00080000L

#define JET_acmTblCreate			(JET_acmSpecific_1)
#define JET_acmTblAccessRcols		(JET_acmSpecific_2)
#define JET_acmTblReadDef			(JET_acmSpecific_3)
#define JET_acmTblWriteDef			(JET_acmSpecific_4)
#define JET_acmTblRetrieveData		(JET_acmSpecific_5)
#define JET_acmTblInsertData		(JET_acmSpecific_6)
#define JET_acmTblReplaceData		(JET_acmSpecific_7)
#define JET_acmTblDeleteData		(JET_acmSpecific_8)

#define JET_acmDbCreate 			(JET_acmSpecific_1)
#define JET_acmDbOpen				(JET_acmSpecific_2)

	/* Compact Options */

#define JET_bitCompactDontCopyLocale	0x00000004	/* Don't copy locale from source to dest */
#define JET_bitCompactVersion10			0x00000008	/* Destination is version 1.0 format */
#define JET_bitCompactVersion1x			0x00000010	/* Destination is version 1.x format */
#define JET_bitCompactStats				0x00000020	/* Dump off-line compaction stats (only when progress meter also specified) */

	/* On-line Compact Options */

#define JET_bitCompactOn	 			0x00000001	/* enable on-line compaction */

	/* Repair Notification Types */

#define JET_rntSelfContained		0
#define JET_rntDeletedIndex			1
#define JET_rntDeletedRec			2
#define JET_rntDeletedLv			3
#define JET_rntTruncated			4

	/* Status Notification Processes */

#define JET_snpIndex				0
#define JET_snpQuery				1
#define JET_snpRepair				2
#define JET_snpImex					3
#define JET_snpCompact				4
#define JET_snpFastFind 			5
#define JET_snpODBCNotReady			6
#define JET_snpQuerySort	   		7
#define JET_snpRestore				8
#define JET_snpBackup				9
#define JET_snpUpgrade				10

	/* Status Notification Types */

#define JET_sntProgress 		0	/* callback for progress */
#define JET_sntMessage			1
#define JET_sntBulkRecords		2	/* callback for # rec for bulk op */
#define JET_sntFail				3	/* callback for failure during progress */
#define JET_sntErrCount 		4	/* callback for err count */
#define JET_sntBegin			5	/* callback for beginning of operation */
#define JET_sntComplete 		6	/* callback for completion of operation */
#define JET_sntCantRollback		7	/* callback for no rollback */
#define JET_sntRestoreMap		8	/* callback for restore map */

	/* Message codes for JET_snpCompact */

#define JET_sncCopyObject		0	/* Starting to copy object */
#define JET_sncCopyFailed		1	/* Copy of this object failed */
#define JET_sncYield			2	/* Client can yield/check for user interrupt */
#define JET_sncTransactionFull	3	/* Client can yield/check for user interrupt */
#define JET_sncAboutToWrap		4	/* Find find is about to wrap */

	/* Message codes for JET_snpODBCNotReady */

#define JET_sncODBCNotReady		0	/* Waiting for results from ODBC */


	/* Constants for the [ODBC] section of JET.INI */

#define JET_SQLTraceCanonical	0x0001	/* Output ODBC Generic SQL */

	/* Constants for the [Debug] section of JET.INI */

	/* APITrace */

#define JET_APITraceEnter		0x0001
#define JET_APITraceExit		0x0002
#define JET_APITraceExitError	0x0004
#define JET_APIBreakOnError		0x0008
#define JET_APITraceCount		0x0010
#define JET_APITraceNoIdle		0x0020
#define JET_APITraceParameters	0x0040

	/* IdleTrace */

#define JET_IdleTraceCursor		0x0001
#define JET_IdleTraceBuffer		0x0002
#define JET_IdleTraceFlush		0x0004

	/* AssertAction */

#define JET_AssertExit			0x0000		/* Exit the application */
#define JET_AssertBreak 		0x0001		/* Break to debugger */
#define JET_AssertMsgBox		0x0002		/* Display message box */
#define JET_AssertStop			0x0004		/* Alert and stop */

	/* IOTrace */

#define JET_IOTraceAlloc		0x0001		/* DB Page Allocation */
#define JET_IOTraceFree 		0x0002		/* DB Page Free */
#define JET_IOTraceRead 		0x0004		/* DB Page Read */
#define JET_IOTraceWrite		0x0008		/* DB Page Write */
#define JET_IOTraceError		0x0010		/* DB Page I/O Error */

	/* MemTrace */

#define JET_MemTraceAlloc		0x0001		/* Memory allocation */
#define JET_MemTraceRealloc		0x0002		/* Memory reallocation */
#define JET_MemTraceFree		0x0004		/* Memory free */

	/* RmtTrace */

#define JET_RmtTraceError		0x0001	/* Remote server error message */
#define JET_RmtTraceSql			0x0002	/* Remote SQL Prepares & Exec's */
#define JET_RmtTraceAPI			0x0004	/* Remote ODBC API calls */
#define JET_RmtTraceODBC		0x0008
#define JET_RmtSyncODBC			0x0010	/* Turn on ODBC Sync mode */
	
/**********************************************************************/
/***********************     ERROR CODES     **************************/
/**********************************************************************/

/* SUCCESS */

#define JET_errSuccess						 0    /* Successful Operation */

/* ERRORS */

#define JET_wrnNyi							-1    /* Function Not Yet Implemented */

/*	SYSTEM errors
/**/
#define JET_errRfsFailure			   		-100  /* JET_errRfsFailure */
#define JET_errRfsNotArmed					-101  /* JET_errRfsFailure */
#define JET_errFileClose					-102  /* Could not close DOS file */
#define JET_errOutOfThreads					-103  /* Could not start thread */
#define JET_errTooManyIO		  			-105  /* System busy due to too many IOs */
#define JET_errDatabase200Format			-106  /* 200 format database */
#define JET_errDatabase400Format			-107  /* 400 format database */

/*	BUFFER MANAGER errors
/**/
#define wrnBFNotSynchronous					200	  /* Buffer page evicted */
#define wrnBFPageNotFound		  			201	  /* Page not found */
#define errBFInUse				  			-202  /* Cannot abandon buffer */
#define wrnBFNewIO							203	  /* Buffer access caused a new IO (cache miss) */
#define wrnBFCacheMiss						204	  /* Buffer access was a cache miss but didn't cause a new IO */
#define	wrnBFNoBufAvailable					205	  /* Need to allocate new buffer for read (used in Async IO ) */

/*	DIRECTORY MANAGER errors
/**/
#define errPMOutOfPageSpace					-300  /* Out of page space */
#define errPMItagTooBig 		  			-301  /* Itag too big */
#define errPMRecDeleted 		  			-302  /* Record deleted */
#define errPMTagsUsedUp 		  			-303  /* Tags used up */
#define wrnBMConflict			  			304   /* conflict in BM Clean up */
#define errDIRNoShortCircuit	  			-305  /* No Short Circuit Avail */
#define errDIRCannotSplit		  			-306  /* Cannot horizontally split FDP */
#define errDIRTop				  			-307  /* Cannot go up */
#define errDIRFDP							308	  /* On an FDP Node */
#define errDIRNotSynchronous				-309  /* May have left critical section */
#define wrnDIREmptyPage						310	  /* Moved through empty page */
#define errSPConflict						-311  /* Device extent being extended */
#define wrnNDFoundLess						312	  /* Found Less */
#define wrnNDFoundGreater					313	  /* Found Greater */
#define errNDOutSonRange					-314  /* Son out of range */
#define errNDOutItemRange					-315  /* Item out of range */
#define errNDGreaterThanAllItems 			-316  /* Greater than all items */
#define errNDLastItemNode					-317  /* Last node of item list */
#define errNDFirstItemNode					-318  /* First node of item list */
#define wrnNDDuplicateItem					319	  /* Duplicated Item */
#define errNDNoItem							-320  /* Item not there */
#define JET_wrnRemainingVersions 			321	  /* Some versions couldn't be cleaned */
#define JET_wrnPreviousVersion				322	  /* Version already existed */
#define JET_errPageBoundary					-323  /* Reached Page Boundary */
#define JET_errKeyBoundary		  			-324  /* Reached Key Boundary */
#define errDIRInPageFather  				-325  /* sridFather in page to free */
#define	errBMMaxKeyInPage					-326  /* used by OLC to avoid cleanup of parent pages */
#define	JET_errBadPageLink					-327  /* next/previous page link page does not point back to source */
#define	JET_errBadBookmark					-328  /* bookmark has no corresponding address in database */
#define wrnBMCleanNullOp					329	  /* BMClean returns this on encountering a page
												  /* deleted MaxKeyInPage [but there was no conflict]
												
/*	RECORD MANAGER errors
/**/
#define wrnFLDKeyTooBig 					400	  /* Key too big (truncated it) */
#define errFLDTooManySegments				-401  /* Too many key segments */
#define wrnFLDNullKey						402	  /* Key is entirely NULL */
#define wrnFLDOutOfKeys 					403	  /* No more keys to extract */
#define wrnFLDNullSeg						404	  /* Null segment in key */
#define wrnRECLongField 					405	  /* Separated long value */
#define JET_wrnSeparateLongValue			406	  /* Separated long value */
#define JET_wrnRecordFoundGreater			JET_wrnSeekNotEqual
#define JET_wrnRecordFoundLess    			JET_wrnSeekNotEqual
#define JET_errColumnIllegalNull  			JET_errNullInvalid
#define wrnFLDNullFirstSeg		   			407	  /* Null first segment in key */
#define JET_errKeyTooBig					-408  /* Key with column truncation still truncated */

/*	LOGGING/RECOVERY errors
/**/
#define JET_errInvalidLoggedOperation		-500  /* Logged operation cannot be redone */
#define JET_errLogFileCorrupt		  		-501  /* Log file is corrupt */
#define errLGNoMoreRecords					-502  /* Last log record read */
#define JET_errNoBackupDirectory 			-503  /* No backup directory given */
#define JET_errBackupDirectoryNotEmpty 		-504  /* The backup directory is not emtpy */
#define JET_errBackupInProgress 			-505  /* Backup is active already */
#define JET_errMissingPreviousLogFile		-509  /* Missing the log file for check point */
#define JET_errLogWriteFail					-510  /* Fail when writing to log file */
#define JET_errBadLogVersion  	  			-514  /* Version of log file is not compatible with Jet version */
#define JET_errInvalidLogSequence  			-515  /* Timestamp in next log does not match expected */
#define JET_errLoggingDisabled 				-516  /* Log is not active */
#define JET_errLogBufferTooSmall			-517  /* Log buffer is too small for recovery */
#define errLGNotSynchronous					-518  /* retry to LGLogRec */
#define JET_errLogSequenceEnd				-519  /* Exceed maximum log file number */
#define JET_errNoBackup						-520  /* No backup in progress */
#define	JET_errInvalidBackupSequence		-521  /* Backup call out of sequence */
#define JET_errBackupNotAllowedYet			-523  /* Can not do backup now */
#define JET_errDeleteBackupFileFail	   		-524  /* Could not delete backup file */
#define JET_errMakeBackupDirectoryFail 		-525  /* Could not make backup temp directory */
#define JET_errInvalidBackup		 		-526  /* Cannot incremental backup when circular logging enabled */
#define JET_errRecoveredWithErrors			-527  /* For repair, restored with errors */
#define JET_errMissingLogFile				-528  /* current log file missing */
#define JET_errLogDiskFull					-529  /* log disk full */
#define JET_errBadLogSignature				-530  /* bad signature for a log file */
#define JET_errBadDbSignature				-531  /* bad signature for a db file */
#define JET_errBadCheckpointSignature		-532  /* bad signature for a checkpoint file */
#define	JET_errCheckpointCorrupt			-533  /* checkpoint file not found or corrupt */
#define	JET_errMissingPatchPage				-534  /* patch file page not found during recovery */


#define JET_errDatabaseInconsistent			-550  /* database is in inconsistent state */
#define JET_errConsistentTimeMismatch		-551  /* database last consistent time unmatched */
#define JET_errDatabasePatchFileMismatch	-552  /* patch file is not generated from this backup */
#define JET_errEndingRestoreLogTooLow		-553  /* the starting log number too low for the restore */
#define JET_errStartingRestoreLogTooHigh	-554  /* the starting log number too high for the restore */
#define JET_errGivenLogFileHasBadSignature	-555  /* Restore log file has bad signature */
#define JET_errGivenLogFileIsNotContiguous	-556  /* Restore log file is not contiguous */
#define JET_errMissingRestoreLogFiles		-557  /* Some restore log files are missing */
#define JET_wrnExistingLogFileHasBadSignature	558  /* Existing log file has bad signature */
#define JET_wrnExistingLogFileIsNotContiguous	559  /* Existing log file is not contiguous */
#define JET_errMissingFullBackup			-560  /* The database miss a previous full backup befor incremental backup */
#define JET_errBadBackupDatabaseSize		-561  /* The backup database size is not in 4k */
#define JET_errDatabaseAlreadyUpgraded		-562  /* Attempted to upgrade a database that is already current */

#define JET_errTermInProgress		  		-1000 /* Termination in progress */
#define JET_errFeatureNotAvailable			-1001 /* API not supported */
#define JET_errInvalidName					-1002 /* Invalid name */
#define JET_errInvalidParameter 			-1003 /* Invalid API parameter */
#define JET_wrnColumnNull					 1004 /* Column is NULL-valued */
#define JET_wrnBufferTruncated				 1006 /* Buffer too small for data */
#define JET_wrnDatabaseAttached 			 1007 /* Database is already attached */
#define JET_errDatabaseFileReadOnly			-1008 /* Attach a readonly database file for read/write operations */
#define JET_wrnSortOverflow					 1009 /* Sort does not fit in memory */
#define JET_errInvalidDatabaseId			-1010 /* Invalid database id */
#define JET_errOutOfMemory					-1011 /* Out of Memory */
#define JET_errOutOfDatabaseSpace 			-1012 /* Maximum database size reached */
#define JET_errOutOfCursors					-1013 /* Out of table cursors */
#define JET_errOutOfBuffers					-1014 /* Out of database page buffers */
#define JET_errTooManyIndexes				-1015 /* Too many indexes */
#define JET_errTooManyKeys					-1016 /* Too many columns in an index */
#define JET_errRecordDeleted				-1017 /* Record has been deleted */
#define JET_errReadVerifyFailure			-1018 /* Read verification error */
#define JET_errOutOfFileHandles	 			-1020 /* Out of file handles */
#define JET_errDiskIO						-1022 /* Disk IO error */
#define JET_errInvalidPath					-1023 /* Invalid file path */
#define JET_errRecordTooBig					-1026 /* Record larger than maximum size */
#define JET_errTooManyOpenDatabases			-1027 /* Too many open databases */
#define JET_errInvalidDatabase				-1028 /* Not a database file */
#define JET_errNotInitialized				-1029 /* JetInit not yet called */
#define JET_errAlreadyInitialized			-1030 /* JetInit already called */
#define JET_errFileAccessDenied 			-1032 /* Cannot access file */
#define JET_errQueryNotSupported			-1034 /* Query support unavailable */
#define JET_errSQLLinkNotSupported			-1035 /* SQL Link support unavailable */
#define JET_errBufferTooSmall				-1038 /* Buffer is too small */
#define JET_wrnSeekNotEqual					 1039 /* SeekLE or SeekGE didn't find exact match */
#define JET_errTooManyColumns				-1040 /* Too many columns defined */
#define JET_errContainerNotEmpty			-1043 /* Container is not empty */
#define JET_errInvalidFilename				-1044 /* Filename is invalid */
#define JET_errInvalidBookmark				-1045 /* Invalid bookmark */
#define JET_errColumnInUse					-1046 /* Column used in an index */
#define JET_errInvalidBufferSize			-1047 /* Data buffer doesn't match column size */
#define JET_errColumnNotUpdatable			-1048 /* Cannot set column value */
#define JET_errIndexInUse					-1051 /* Index is in use */
#define JET_errLinkNotSupported 			-1052 /* Link support unavailable */
#define JET_errNullKeyDisallowed			-1053 /* Null keys are disallowed on index */
#define JET_errNotInTransaction 			-1054 /* Operation must be within a transaction */
#define JET_wrnNoErrorInfo					1055  /* No extended error information */
#define JET_wrnNoIdleActivity		 		1058  /* No idle activity occured */
#define JET_errTooManyActiveUsers			-1059 /* Too many active database users */
#define JET_errInvalidAppend				-1060 /* Cannot append long value */
#define JET_errInvalidCountry				-1061 /* Invalid or unknown country code */
#define JET_errInvalidLanguageId			-1062 /* Invalid or unknown language id */
#define JET_errInvalidCodePage				-1063 /* Invalid or unknown code page */
#define JET_wrnNoWriteLock					1067  /* No write lock at transaction level 0 */
#define JET_wrnColumnSetNull		   		 1068 /* Column set to NULL-value */
#define JET_errVersionStoreOutOfMemory		-1069 /* lMaxVerPages exceeded (XJET only) */
#define JET_errCurrencyStackOutOfMemory		-1070 /* lCSRPerfFUCB * lMaxCursors exceeded (XJET only) */
#define JET_errOutOfSessions  				-1101 /* Out of sessions */
#define JET_errWriteConflict				-1102 /* Write lock failed due to outstanding write lock */
#define JET_errTransTooDeep					-1103 /* Xactions nested too deeply */
#define JET_errInvalidSesid					-1104 /* Invalid session handle */
#define JET_errSessionWriteConflict			-1107 /* Another session has private version of page */
#define JET_errInTransaction				-1108 /* Operation not allowed within a transaction */
#define JET_errDatabaseDuplicate			-1201 /* Database already exists */
#define JET_errDatabaseInUse				-1202 /* Database in use */
#define JET_errDatabaseNotFound 			-1203 /* No such database */
#define JET_errDatabaseInvalidName			-1204 /* Invalid database name */
#define JET_errDatabaseInvalidPages			-1205 /* Invalid number of pages */
#define JET_errDatabaseCorrupted			-1206 /* non-db file or corrupted db */
#define JET_errDatabaseLocked				-1207 /* Database exclusively locked */
#define	JET_errCannotDisableVersioning		-1208 /* Cannot disable versioning for this database */
#define JET_wrnTableEmpty			 		1301  /* Open an empty table */
#define JET_errTableLocked					-1302 /* Table is exclusively locked */
#define JET_errTableDuplicate				-1303 /* Table already exists */
#define JET_errTableInUse					-1304 /* Table is in use, cannot lock */
#define JET_errObjectNotFound				-1305 /* No such table or object */
#define JET_errDensityInvalid				-1307 /* Bad file/index density */
#define JET_errTableNotEmpty				-1308 /* Cannot define clustered index */
#define JET_errInvalidTableId				-1310 /* Invalid table id */
#define JET_errTooManyOpenTables			-1311 /* Cannot open any more tables */
#define JET_errIllegalOperation 			-1312 /* Oper. not supported on table */
#define JET_errObjectDuplicate				-1314 /* Table or object name in use */
#define JET_errInvalidObject				-1316 /* object is invalid for operation */
#define JET_errIndexCantBuild				-1401 /* Cannot build clustered index */
#define JET_errIndexHasPrimary				-1402 /* Primary index already defined */
#define JET_errIndexDuplicate				-1403 /* Index is already defined */
#define JET_errIndexNotFound				-1404 /* No such index */
#define JET_errIndexMustStay				-1405 /* Cannot delete clustered index */
#define JET_errIndexInvalidDef				-1406 /* Illegal index definition */
#define JET_errIndexHasClustered			-1408 /* Clustered index already defined */
#define JET_errInvalidCreateIndex	 		-1409 /* Invali create index description */
#define JET_errTooManyOpenIndexes			-1410 /* Out of index description blocks */
#define JET_errColumnLong					-1501 /* Column value is long */
#define JET_errColumnNoChunk				-1502 /* no such chunk in long value */
#define JET_errColumnDoesNotFit 			-1503 /* Field will not fit in record */
#define JET_errNullInvalid					-1504 /* Null not valid */
#define JET_errColumnIndexed				-1505 /* Column indexed, cannot delete */
#define JET_errColumnTooBig					-1506 /* Field length is > maximum */
#define JET_errColumnNotFound				-1507 /* No such column */
#define JET_errColumnDuplicate				-1508 /* Field is already defined */
#define JET_errColumn2ndSysMaint			-1510 /* Second autoinc or version column */
#define JET_errInvalidColumnType			-1511 /* Invalid column data type */
#define JET_wrnColumnMaxTruncated	 		1512  /* Max length too big, truncated */
#define JET_errColumnCannotIndex			-1513 /* Cannot index Bit,LongText,LongBinary */
#define JET_errTaggedNotNULL				-1514 /* No non-NULL tagged columns */
#define JET_errNoCurrentIndex				-1515 /* Invalid w/o a current index */
#define JET_errKeyIsMade					-1516 /* The key is completely made */
#define JET_errBadColumnId					-1517 /* Column Id Incorrect */
#define JET_errBadItagSequence				-1518 /* Bad itagSequence for tagged column */
#define JET_errColumnInRelationship			-1519 /* Cannot delete, column participates in relationship */
#define JET_wrnCopyLongValue				1520  /* Single instance column bursted */
#define JET_errCannotBeTagged				-1521 /* AutoIncrement and Version cannot be tagged */
#define JET_errRecordNotFound				-1601 /* The key was not found */
#define JET_errRecordNoCopy					-1602 /* No working buffer */
#define JET_errNoCurrentRecord				-1603 /* Currency not on a record */
#define JET_errRecordClusteredChanged		-1604 /* Clustered key may not change */
#define JET_errKeyDuplicate					-1605 /* Illegal duplicate key */
#define JET_errAlreadyPrepared				-1607 /* Already copy/clear current */
#define JET_errKeyNotMade					-1608 /* No call to JetMakeKey */
#define JET_errUpdateNotPrepared			-1609 /* No call to JetPrepareUpdate */
#define JET_wrnDataHasChanged		 		1610  /* Data has changed */
#define JET_errDataHasChanged				-1611 /* Data has changed, operation aborted */
#define JET_wrnKeyChanged			 		1618  /* Moved to new key */
#define JET_errTooManySorts					-1701 /* Too many sort processes */
#define JET_errInvalidOnSort				-1702 /* Invalid operation on Sort */
#define JET_errTempFileOpenError			-1803 /* Temp file could not be opened */
#define JET_errTooManyAttachedDatabases 	-1805 /* Too many open databases */
#define JET_errDiskFull 					-1808 /* No space left on disk */
#define JET_errPermissionDenied 			-1809 /* Permission denied */
#define JET_errFileNotFound					-1811 /* File not found */
#define JET_wrnFileOpenReadOnly				1813  /* Database file is read only */
#define JET_errAfterInitialization			-1850 /* Cannot Restore after init. */
#define JET_errLogCorrupted					-1852 /* Logs could not be interpreted */
#define JET_errInvalidOperation 			-1906 /* invalid operation */
#define JET_errAccessDenied					-1907 /* access denied */
#define JET_wrnIdleFull						 1908 /* ilde registry full */


/**********************************************************************/
/***********************     PROTOTYPES      **************************/
/**********************************************************************/

#if !defined(_JET_NOPROTOTYPES)

JET_ERR JET_API JetInit(JET_INSTANCE *pinstance);

JET_ERR JET_API JetTerm(JET_INSTANCE instance);

JET_ERR JET_API JetTerm2( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR JET_API JetSetSystemParameter(JET_INSTANCE *pinstance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char *sz);

JET_ERR JET_API JetGetSystemParameter(JET_INSTANCE instance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR *plParam, char *sz, unsigned long cbMax);

#define ctAccessPage			1
#define ctLatchConflict			2
#define ctSplitRetry			3
#define ctNeighborPageScanned	4
#define ctSplits				5
JET_ERR JET_API JetResetCounter( JET_SESID sesid, long CounterType );
JET_ERR JET_API JetGetCounter( JET_SESID sesid, long CounterType, long *plValue );

JET_ERR JET_API JetBeginSession(JET_INSTANCE instance, JET_SESID *psesid,
	const char *szUserName, const char *szPassword);

JET_ERR JET_API JetDupSession(JET_SESID sesid, JET_SESID *psesid);

JET_ERR JET_API JetEndSession(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetVersion(JET_SESID sesid, unsigned long *pwVersion);

JET_ERR JET_API JetIdle(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetCreateDatabase(JET_SESID sesid,
	const char *szFilename, const char *szConnect,
	JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetAttachDatabase(JET_SESID sesid, const char *szFilename, JET_GRBIT grbit );

JET_ERR JET_API JetDetachDatabase(JET_SESID sesid, const char *szFilename);

JET_ERR JET_API JetCreateTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, unsigned long lPages, unsigned long lDensity,
	JET_TABLEID *ptableid);

JET_ERR JET_API JetCreateTableColumnIndex( JET_SESID sesid, JET_DBID dbid,
	JET_TABLECREATE *ptablecreate );

JET_ERR JET_API JetDeleteTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName);

JET_ERR JET_API JetGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumnName, void *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const char *szColumnName,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumn, const JET_COLUMNDEF *pcolumndef,
	const void *pvDefault, unsigned long cbDefault,
	JET_COLUMNID *pcolumnid);

JET_ERR JET_API JetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumn);

JET_ERR JET_API JetGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, void *pvResult, unsigned long cbResult,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const char *szIndexName,
	void *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, JET_GRBIT grbit,
	const char *szKey, unsigned long cbKey, unsigned long lDensity);

JET_ERR JET_API JetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName);

JET_ERR JET_API JetGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp, const char *szContainerName,
	const char *szObjectName, void *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetBeginTransaction(JET_SESID sesid);

JET_ERR JET_API JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetRollback(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetCloseDatabase(JET_SESID sesid, JET_DBID dbid,
	JET_GRBIT grbit);

JET_ERR JET_API JetCloseTable(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenDatabase(JET_SESID sesid, const char *szFilename,
	const char *szConnect, JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetOpenTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const void *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID *ptableid);

JET_ERR JET_API JetDelete(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbBookmark,
	unsigned long *pcbActual);

JET_ERR JET_API JetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void *pvData, unsigned long cbData,
	unsigned long *pcbActual, JET_GRBIT grbit, JET_RETINFO *pretinfo);

JET_ERR JET_API JetRetrieveColumns( JET_SESID sesid, JET_TABLEID tableid,
	JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn );

JET_ERR JET_API JetSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void *pvData, unsigned long cbData,
	JET_GRBIT grbit, JET_SETINFO *psetinfo);

JET_ERR JET_API JetSetColumns(JET_SESID sesid, JET_TABLEID tableid,
	JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn );

JET_ERR JET_API JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep);

JET_ERR JET_API JetGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos, unsigned long cbRecpos);

JET_ERR JET_API JetGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos );

JET_ERR JET_API JetGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char *szIndexName, unsigned long cchIndexName);

JET_ERR JET_API JetSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName);

JET_ERR JET_API JetSetCurrentIndex2(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, JET_GRBIT grbit );

JET_ERR JET_API JetMove(JET_SESID sesid, JET_TABLEID tableid,
	long cRow, JET_GRBIT grbit);

JET_ERR JET_API JetMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void *pvData, unsigned long cbData, JET_GRBIT grbit);

JET_ERR JET_API JetSeek(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit);

JET_ERR JET_API JetGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbMax,
	unsigned long *pcbActual);
	
JET_ERR JET_API JetCompact(JET_SESID sesid, const char *szDatabaseSrc,
	const char *szDatabaseDest, JET_PFNSTATUS pfnStatus, JET_CONVERT *pconvert,
	JET_GRBIT grbit);

JET_ERR JET_API JetDBUtilities( JET_DBUTIL *pdbutil );	

JET_ERR JET_API JetGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbBookmark);

JET_ERR JET_API JetComputeStats(JET_SESID sesid, JET_TABLEID tableid);

typedef ULONG_PTR JET_VSESID;          /* Received from dispatcher */

struct tagVDBFNDEF;

typedef ULONG_PTR JET_VDBID;           /* Received from dispatcher */

struct tagVTFNDEF;

typedef ULONG_PTR JET_VTID;            /* Received from dispatcher */

JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid);

JET_ERR JET_API JetOpenTempTable2( JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef,
	unsigned long ccolumn,
	unsigned long langid,
	JET_GRBIT grbit,
	JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid );

JET_ERR JET_API JetBackup( const char *szBackupPath, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus );

JET_ERR JET_API JetRestore(const char *sz, JET_PFNSTATUS pfn );
JET_ERR JET_API JetRestore2(const char *sz, const char *szDest, JET_PFNSTATUS pfn );

JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit);

JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long *pcrec, unsigned long crecMax );

JET_ERR JET_API JetRetrieveKey(JET_SESID sesid,
	JET_TABLEID tableid, void *pvData, unsigned long cbMax,
	unsigned long *pcbActual, JET_GRBIT grbit );

JET_ERR JET_API JetBeginExternalBackup( JET_GRBIT grbit );

JET_ERR JET_API JetGetAttachInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );

JET_ERR JET_API JetOpenFile( const char *szFileName,
	JET_HANDLE	*phfFile,
	unsigned long *pulFileSizeLow,
	unsigned long *pulFileSizeHigh );

JET_ERR JET_API JetReadFile( JET_HANDLE hfFile,
	void *pv,
	unsigned long cb,
	unsigned long *pcb );

JET_ERR JET_API JetCloseFile( JET_HANDLE hfFile );

JET_ERR JET_API JetGetLogInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );

JET_ERR JET_API JetTruncateLog( void );

JET_ERR JET_API JetEndExternalBackup( void );

JET_ERR JET_API JetExternalRestore( char *szCheckpointFilePath, char *szLogPath, JET_RSTMAP *rgstmap, long crstfilemap, char *szBackupLogPath, long genLow, long genHigh, JET_PFNSTATUS pfn );

#endif	/* _JET_NOPROTOTYPES */

#pragma pack()

#ifdef	__cplusplus
}
#endif

#endif	/* _JET_INCLUDED */




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\irda\sys\irda.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    irda.c

Abstract:

    TDI interface portion of irda.sys
    
Author:

    mbert 9-97    

--*/

#define UNICODE

#include <irda.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <irioctl.h>
#include <irlap.h>
#include <irlmp.h>
#include <irdap.h>

#undef offsetof
#include "irda.tmh"

static LARGE_INTEGER Magic10000 = {0xe219652c, 0xd1b71758};

#if 0
#if DBG
int DbgSettings = 
    DBG_TDI         |    
//    DBG_NDIS        |
//    DBG_TDI_IRP     |
    DBG_IRLMP       | 
//    DBG_IRLMP_CONN  |
//    DBG_IRLMP_IAS   |
//    DBG_IRLMP_CRED  |
//    DBG_IRLAPLOG    |   
    DBG_IRLAP       |
//    DBG_TXFRAME     |
//    DBG_RXFRAME     |
//    DBG_DISCOVERY   |
    DBG_ERROR       | 
    DBG_WARN        | 
    1; 
    
int DbgOutput = /*DBG_OUTPUT_DEBUGGER  |*/ DBG_OUTPUT_BUFFER;
    
#endif
#endif

PDRIVER_OBJECT  pIrDADriverObject;
PDEVICE_OBJECT  pIrDADeviceObject;
PVOID           IrdaMsgPool;
PVOID           RecvBufPool;

PIRDA_ADDR_OBJ  AddrObjList;
LIST_ENTRY      DscvIrpList;
LIST_ENTRY      IasIrpList;
LIST_ENTRY      ConnIrpList;
LIST_ENTRY      StatusIrpList;
LIST_ENTRY      IasAttribList;

CTEEvent        PendingIasEvent;

IRLINK_STATUS   LinkStatus;
BOOLEAN         LinkStatusUpdated;
LONG            ConnectionCount;
BOOLEAN         ConnectionInterrupted;

CTELock         IrdaLock;

char            IasBuf[sizeof(IAS_QUERY) + IAS_MAX_OCTET_STRING];
IAS_QUERY       *pvIasQuery = (IAS_QUERY *) IasBuf;
PIRP            pIasIrp;

LIST_ENTRY      LazyDscvIrpList;
IRDA_TIMER      LazyDscvTimer;
BOOLEAN         LazyDscvTimerRunning;
UINT            LazyDscvInterval;
UINT            LazyDscvMacAddrs;
UINT            RandSeed;
int             gNextLsapSel;

VOID (*CloseRasIrdaAddresses)();

NTSTATUS
DriverEntry(
    PDRIVER_OBJECT  pDriverObject,
    PUNICODE_STRING pRegistryPath);
    
#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)

#endif    


PIRP
GetIrpOnConnIrpList(PIRDA_CONN_OBJ pConn);


NTSTATUS
DriverEntry(
    PDRIVER_OBJECT  pDriverObject,
    PUNICODE_STRING pRegistryPath)
{
    NTSTATUS            Status;
    UNICODE_STRING      DeviceName;
    UNICODE_STRING      ProtocolName;
    int                 i;
    LARGE_INTEGER       li;

    WPP_INIT_TRACING(pDriverObject,pRegistryPath);
#if 0
    DbgMsgInit();
#endif
    DEBUGMSG(DBG_TDI, ("IRDA: DriverEntry(), %ws.\n",
        pRegistryPath->Buffer));

    pIrDADriverObject = pDriverObject;

    RtlInitUnicodeString(&DeviceName,   IRDA_DEVICE_NAME);
    RtlInitUnicodeString(&ProtocolName, IRDA_NAME);

    Status = IoCreateDevice(
        pDriverObject,          // DriverObject
        0,                      // DeviceExtensionSize
        &DeviceName,            // DeviceName
        FILE_DEVICE_NETWORK,    // DeviceType
        FILE_DEVICE_SECURE_OPEN,// DeviceCharacteristics
        FALSE,                  // Exclusive?
        &pIrDADeviceObject);    // DeviceObject pointer returned

    if (! NT_SUCCESS(Status))
    {
        /* wmz
        CTELogEvent(
            pDriverObject,
            EVENT_IRDA_CREATE_DEVICE_FAILED,
            1,
            1,
            &DeviceName.Buffer,
            0,
            NULL);
        */

        DEBUGMSG(DBG_ERROR, ("IRDA: IoCreateDevice() failed, 0x%1x.\n",
            Status));

        return Status;
    }

    // Initialize the driver object.
    pDriverObject->DriverUnload   = DriverUnload;
    pDriverObject->FastIoDispatch = NULL;
    
    for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        pDriverObject->MajorFunction[i] = IrDADispatch;
    }

    // Internal Device Controls are hot paths for kernel-mode clients.
    pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
        IrDADispatchInternalDeviceControl;

    // Intialize the device objects.
    pIrDADeviceObject->Flags |= DO_DIRECT_IO;

    CTEInitLock(&IrdaLock);
    CTEInitEvent(&PendingIasEvent, PendingIasRequestCallback);    
                            
	InitializeListHead(&DscvIrpList);
	InitializeListHead(&IasIrpList);    
	InitializeListHead(&ConnIrpList);
	InitializeListHead(&LazyDscvIrpList);
	InitializeListHead(&StatusIrpList);    
	InitializeListHead(&IasAttribList);    
     
    pIasIrp = NULL;
    
    gNextLsapSel = IRDA_MIN_LSAP_SEL;
    
    if ((IrdaMsgPool = CreateIrdaBufPool(IRDA_MSG_DATA_SIZE_INTERNAL,
                                         MT_IMSG_POOL)) == NULL)
    {
        IoDeleteDevice(pIrDADeviceObject);        
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ((RecvBufPool = CreateIrdaBufPool(sizeof(IRDA_RECV_BUF),
                                         MT_RXBUF_POOL)) == NULL)
    {
        DeleteIrdaBufPool(IrdaMsgPool);    
        IoDeleteDevice(pIrDADeviceObject);        
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ((Status = IrdaInitialize(&ProtocolName, pRegistryPath, 
                                 &LazyDscvInterval)) != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("IRDA: IrdaInitialize() failed.\n"));
        
        IoDeleteDevice(pIrDADeviceObject);
        
        DeleteIrdaBufPool(IrdaMsgPool);
        DeleteIrdaBufPool(RecvBufPool);

        return Status;
    }
    
    if (LazyDscvInterval == 0)
        LazyDscvInterval = DEFAULT_LAZY_DSCV_INTERVAL;
        
#if DBG
    LazyDscvTimer.pName = "LazyDscv";
#endif
    IrdaTimerInitialize(&LazyDscvTimer,
                        LazyDscvTimerExp,
                        LazyDscvInterval*1000,
                        NULL, NULL);
    
    KeQuerySystemTime(&li);
    
    RandSeed = li.LowPart;
    
    return STATUS_SUCCESS;
}

VOID
DriverUnload(
    PDRIVER_OBJECT  pDriverObject)
{
    DEBUGMSG(DBG_TDI, ("IRDA: DriverUnload\n")); 
    
    IrdaTimerStop(&LazyDscvTimer);
        
    IrdaShutdown();
    
    DeleteIrdaBufPool(IrdaMsgPool);
    DeleteIrdaBufPool(RecvBufPool);    
    
    IoDeleteDevice(pIrDADeviceObject);

    WPP_CLEANUP(pDriverObject);
}    

NTSTATUS
IrDADispatch(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp)
{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  pIrpSp;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    /*
    DEBUGMSG(DBG_TDI_IRP, ("IRDA: IrDADispatch(), Irp:%X %s.\n",
                        pIrp,
                        IrpMJTxt(pIrpSp)));
    */
    
    CTEAssert(pIrpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL);

    switch (pIrpSp->MajorFunction)
    {
        case IRP_MJ_CREATE:
            Status = IrDACreate(pDeviceObject, pIrp, pIrpSp);
            break;

        case IRP_MJ_CLEANUP:
            Status = IrDACleanup(pDeviceObject, pIrp, pIrpSp);
            break;

        case IRP_MJ_CLOSE:
            Status = IrDAClose(pIrp, pIrpSp);
        	break;

        case IRP_MJ_DEVICE_CONTROL:
        
            Status = TdiMapUserRequest(pDeviceObject, pIrp, pIrpSp);
            
            if (Status == STATUS_SUCCESS)
            {
                /*
                
                IrDA will not support TdiMapUserRequest as it is not safe.
                
                return IrDADispatchInternalDeviceControl(pDeviceObject, pIrp);
                
                */    
                Status = STATUS_INVALID_DEVICE_REQUEST;
                ASSERT(0);
            }
            else
            {
            	return IrDADispatchDeviceControl(pIrp, IoGetCurrentIrpStackLocation(pIrp));
            }        

        case IRP_MJ_QUERY_SECURITY:
        case IRP_MJ_WRITE:
        case IRP_MJ_READ:
        default:
            DEBUGMSG(DBG_ERROR, ("IRDA: Irp:0x%p, Unsupported %s.\n",
                pIrp,
                IrpMJTxt(pIrpSp)));
            
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }
    
    CTEAssert(Status != TDI_PENDING);

    DEBUGMSG(DBG_TDI_IRP,
        ("IRDA: Completing Irp:%p, Status %x.\n",
        pIrp,
        Status));

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return Status;
}

NTSTATUS
IrDACreate(
    PDEVICE_OBJECT      pDeviceObject,
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp)
{
    NTSTATUS                             Status;
    FILE_FULL_EA_INFORMATION            *pEAs;
    FILE_FULL_EA_INFORMATION UNALIGNED  *pEA;

    pEAs = (PFILE_FULL_EA_INFORMATION) pIrp->AssociatedIrp.SystemBuffer;
    
    // Open a control channel
    if (pEAs == NULL)
    {
        pIrpSp->FileObject->FsContext = (PVOID) 1; // no context here
		pIrpSp->FileObject->FsContext2 = (PVOID) TDI_CONTROL_CHANNEL_FILE;

        DEBUGMSG(DBG_TDI, ("IRDA: IrdaCreate() new control channel (fo:%p)\n",
                 pIrpSp->FileObject));

        return STATUS_SUCCESS;
    }

    // Address Object open?
    pEA = FindEA(pEAs,TdiTransportAddress,TDI_TRANSPORT_ADDRESS_LENGTH);
    
    if (pEA != NULL)
    {
        PIRDA_ADDR_OBJ  pAddr;
        
        Status = TdiOpenAddress(&pAddr, (TRANSPORT_ADDRESS UNALIGNED *)
                                &(pEA->EaName[pEA->EaNameLength + 1]),
                                pEA->EaValueLength);

        CTEAssert(Status != TDI_PENDING);

        if (NT_SUCCESS(Status))
        {
            pIrpSp->FileObject->FsContext = pAddr;
			pIrpSp->FileObject->FsContext2 = (PVOID) TDI_TRANSPORT_ADDRESS_FILE;

            DEBUGMSG(DBG_TDI,
                ("IRDA: IrdaCreate() new AddrObj:%p (fo:%p)\n",
                pAddr, pIrpSp->FileObject));
        }
        else
        {
            DEBUGMSG(DBG_ERROR,
                ("IRDA: TdiOpenAddress() failed, 0x%1x.\n", Status));

            if (Status == STATUS_ADDRESS_ALREADY_EXISTS)
            {
                Status = STATUS_SHARING_VIOLATION;
			}
        }

        return Status;
    }

    // Connection Object open?
    pEA = FindEA(
        pEAs,
        TdiConnectionContext,
        TDI_CONNECTION_CONTEXT_LENGTH);

    if (pEA != NULL)
    {
        PIRDA_CONN_OBJ  pConn;
        
        Status = TdiOpenConnection(&pConn,
            *((CONNECTION_CONTEXT UNALIGNED *)
              &(pEA->EaName[pEA->EaNameLength + 1])),
              pEA->EaValueLength);

        CTEAssert(Status != TDI_PENDING);
	
        if (NT_SUCCESS(Status))
        {
            pIrpSp->FileObject->FsContext  = pConn;
            pIrpSp->FileObject->FsContext2 = (PVOID) TDI_CONNECTION_FILE;

            DEBUGMSG(DBG_TDI,
                ("IRDA: IrdaCreate() new ConnObj:%p (fo:%p)\n",
                pConn, pIrpSp->FileObject));
        }
        else
        {
            DEBUGMSG(DBG_ERROR,
                ("IRDA: TdiOpenConnection() failed, 0x%1x.\n", Status));
        }
        
        return Status;
    }
    
    DEBUGMSG(DBG_ERROR, ("IRDA: Unsupported EA.\n"));

    Status = STATUS_INVALID_EA_NAME;
    
    return Status;
}

FILE_FULL_EA_INFORMATION UNALIGNED *
FindEA(
    PFILE_FULL_EA_INFORMATION    pStartEA,
    CHAR                        *pTargetName,
    USHORT                       TargetNameLength)
{
    FILE_FULL_EA_INFORMATION UNALIGNED *pCurrentEA;

    BOOLEAN Found;
    USHORT  i;

    do
    {
        Found = TRUE;

        pCurrentEA = pStartEA;
        (PCHAR) pStartEA  += pCurrentEA->NextEntryOffset;

        if (pCurrentEA->EaNameLength != TargetNameLength)
        {
            continue;
        }

        for (i=0; i < pCurrentEA->EaNameLength; i++)
        {
            if (pCurrentEA->EaName[i] == pTargetName[i])
            {
                continue;
            }
            
            Found = FALSE;
            break;
        }

        if (Found)
        {
            return pCurrentEA;
        }

    } while (pCurrentEA->NextEntryOffset != 0);

    return NULL;
}

VOID
CancelCtrlChannelIrpsOnList(
    PLIST_ENTRY     pIrpList, 
    PFILE_OBJECT    pFileObject)
{
    PIRP                pIrp;
    PLIST_ENTRY         pListEntry, pListEntryNext;    
    PIO_STACK_LOCATION  pIrpSp;
    
    for (pListEntry = LazyDscvIrpList.Flink;
         pListEntry != &LazyDscvIrpList;
         pListEntry = pListEntryNext)
    {
        pListEntryNext = pListEntry->Flink;
        
        pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        
        if (pIrpSp->FileObject == pFileObject)
        {
            RemoveEntryList(pListEntry);
            
            if (IoSetCancelRoutine(pIrp, NULL) == NULL)
            {
                // Cancel routine is going to run. Indicate to the
                // cancel routine that the Irp has already been removed
                // from the list by setting Flink to NULL
                pIrp->Tail.Overlay.ListEntry.Flink = NULL;            
            }
            else
            {
                DEBUGMSG(DBG_TDI_IRP, ("IRDA: cancelled irp %p\n", pIrp));
                
                pIrp->IoStatus.Status = STATUS_CANCELLED;
                pIrp->IoStatus.Information = 0;
                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            }
        }
    }
}

NTSTATUS
IrDACleanup(
    PDEVICE_OBJECT      pDeviceObject,
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp)
{
    NTSTATUS        Status;
    KIRQL           OldIrql;

	switch((UINT_PTR)pIrpSp->FileObject->FsContext2)
    {
        case TDI_TRANSPORT_ADDRESS_FILE:
            DEBUGMSG(DBG_TDI_IRP, ("IRDA: Cleanup AddrObj:%p\n",
                pIrpSp->FileObject->FsContext));
            break;
            
        case TDI_CONNECTION_FILE:
            DEBUGMSG(DBG_TDI_IRP, ("IRDA: Cleanup ConnObj:%p\n",
                pIrpSp->FileObject->FsContext));
            break;
            
        case TDI_CONTROL_CHANNEL_FILE:
        {

            CTELockHandle       hLock;

            DEBUGMSG(DBG_TDI_IRP, ("IRDA: Cleanup control channel (fo:%p)\n",
                                pIrpSp->FileObject));
            
            CTEGetLock(&IrdaLock, &hLock);

            // Cleanup any Irps that may have been placed on
            // a list by this control channel
            
            CancelCtrlChannelIrpsOnList(&LazyDscvIrpList, pIrpSp->FileObject);
            CancelCtrlChannelIrpsOnList(&DscvIrpList, pIrpSp->FileObject);
            CancelCtrlChannelIrpsOnList(&StatusIrpList, pIrpSp->FileObject);            
            
            CTEFreeLock(&IrdaLock, hLock);     
                                
            break;
        }    
    }        



    // Search for IAS entries that have been added on this
    // control channel and delete them


    {
        PIRDA_IAS_ATTRIB    pIasAttrib, pIasAttribNext;
        CTELockHandle       hLock;
        IRDA_MSG            IMsg;

        CTEGetLock(&IrdaLock, &hLock);

        for (pIasAttrib = (PIRDA_IAS_ATTRIB) IasAttribList.Flink;
             pIasAttrib != (PIRDA_IAS_ATTRIB) &IasAttribList;
             pIasAttrib = pIasAttribNext)
        {
            pIasAttribNext = (PIRDA_IAS_ATTRIB) pIasAttrib->Linkage.Flink;

            DEBUGMSG(DBG_TDI_IRP, ("IRDA IAS cleanup compare fs-%p fs-%p\n",
                     pIasAttrib->pFileObject, pIrpSp->FileObject));

            if (pIasAttrib->pFileObject == pIrpSp->FileObject)
            {
                IMsg.Prim = IRLMP_DELATTRIBUTE_REQ;
                IMsg.IRDA_MSG_AttribHandle = pIasAttrib->AttribHandle;

                RemoveEntryList(&pIasAttrib->Linkage);

                CTEFreeLock(&IrdaLock, hLock);

                IrlmpDown(NULL, &IMsg);

                CTEGetLock(&IrdaLock, &hLock);

                IRDA_FREE_MEM(pIasAttrib);
            }
        }

        CTEFreeLock(&IrdaLock, hLock);
    }

    return STATUS_SUCCESS;
}
NTSTATUS
IrDAClose(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp)
{
    NTSTATUS        Status;
    KIRQL           OldIrql;

	switch((UINT_PTR) pIrpSp->FileObject->FsContext2)
    {
        case TDI_TRANSPORT_ADDRESS_FILE:
            TdiCloseAddress((PIRDA_ADDR_OBJ) pIrpSp->FileObject->FsContext);
            break;
            
        case TDI_CONNECTION_FILE:
            TdiCloseConnection((PIRDA_CONN_OBJ) pIrpSp->FileObject->FsContext);
            break;
            
        case TDI_CONTROL_CHANNEL_FILE:
            DEBUGMSG(DBG_TDI, ("IRDA: Close control channel (fo:%p)\n",
                                    pIrpSp->FileObject));
            break;
    }        
    
	return STATUS_SUCCESS;
}

NTSTATUS
IrDADispatchInternalDeviceControl(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp)
{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  pIrpSp;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    DEBUGMSG(DBG_TDI_IRP,
        ("IRDA: IrDADispatch(), Irp:0x%p %s %s FileObj:0x%p %s:0x%p.\n",
        pIrp,
        IrpMJTxt(pIrpSp),
        IrpTdiTxt(pIrpSp),
        pIrpSp->FileObject,          
        IrpTdiObjTypeTxt(pIrpSp),
        pIrpSp->FileObject->FsContext));
    
    if (((UINT_PTR) pIrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE)
    {
        switch (pIrpSp->MinorFunction)
        {
            case TDI_ASSOCIATE_ADDRESS:
                return TdiAssociateAddress(pIrp, pIrpSp);
                
            case TDI_DISASSOCIATE_ADDRESS:
                return TdiDisassociateAddress(pIrp, pIrpSp);
                
            case TDI_CONNECT:
                return TdiConnect(pIrp, pIrpSp);
                
            case TDI_DISCONNECT:
                return TdiDisconnect(pIrp, pIrpSp, NULL);

            case TDI_SEND:
                return TdiSend(pIrp, pIrpSp);
                
            case TDI_RECEIVE:
                return TdiReceive(pIrp, pIrpSp);
                
            case TDI_QUERY_INFORMATION:
            case TDI_SET_INFORMATION:
                break;    

            default: 
                DEBUGMSG(DBG_ERROR, ("IRDA: minor function %X not supportedon\n",
                         pIrpSp->MinorFunction));
            
                CTEAssert(FALSE);
                
                Status = STATUS_NOT_IMPLEMENTED;
                
                pIrp->IoStatus.Status        = Status;
                pIrp->IoStatus.Information   = 0;

                IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

                return Status;
        }
    }
    else if (((UINT_PTR) pIrpSp->FileObject->FsContext2) ==
             TDI_TRANSPORT_ADDRESS_FILE)
    {
        if (pIrpSp->MinorFunction ==  TDI_SET_EVENT_HANDLER)
        {
            PTDI_REQUEST_KERNEL_SET_EVENT   pTdiParmsSetEvent;

            pTdiParmsSetEvent = (PTDI_REQUEST_KERNEL_SET_EVENT)
                &(pIrpSp->Parameters);            
            
            Status = TdiSetEvent(
                (PIRDA_ADDR_OBJ) pIrpSp->FileObject->FsContext,
                pTdiParmsSetEvent->EventType,
                pTdiParmsSetEvent->EventHandler,
                pTdiParmsSetEvent->EventContext);

            CTEAssert(Status != TDI_PENDING);

            DEBUGMSG(DBG_TDI_IRP,
                ("IRDA: Completing Irp:0x%p %s %s FileObj:0x%p %s:0x%p, Status 0x%lx.\n",
                pIrp,
                IrpMJTxt(pIrpSp),
                IrpTdiTxt(pIrpSp),
                pIrpSp->FileObject,          
                IrpTdiObjTypeTxt(pIrpSp),
                pIrpSp->FileObject->FsContext,
                Status));
            
            pIrp->IoStatus.Status = Status;
            pIrp->IoStatus.Information = 0;
            IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

            return Status;
        }
    }

    CTEAssert(
        (((UINT_PTR)pIrpSp->FileObject->FsContext2)
         == TDI_TRANSPORT_ADDRESS_FILE)             ||
        (((UINT_PTR)pIrpSp->FileObject->FsContext2)
         == TDI_CONNECTION_FILE)                    ||
        (((UINT_PTR)pIrpSp->FileObject->FsContext2)
         == TDI_CONTROL_CHANNEL_FILE));

    switch(pIrpSp->MinorFunction)
    {
        case TDI_QUERY_INFORMATION:
            return TdiQueryInformation(pIrp, pIrpSp);
            
        case TDI_SET_INFORMATION:
            return TdiSetInformation(pIrp, pIrpSp);
            
        case TDI_ACTION:
            Status = STATUS_NOT_IMPLEMENTED;
            break;

        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    CTEAssert(Status != TDI_PENDING);

    DEBUGMSG(DBG_TDI_IRP,
        ("IRDA: Completing Irp:0x%p %s %s FileObj:0x%p %s:0x%p, Status 0x%lx.\n",
        pIrp,
        IrpMJTxt(pIrpSp),
        IrpTdiTxt(pIrpSp),
        pIrpSp->FileObject,          
        IrpTdiObjTypeTxt(pIrpSp),
        pIrpSp->FileObject->FsContext,
        Status));

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return Status;
}

BOOLEAN
ValidConnectObject( 
    PIRDA_CONN_OBJ  pConnCheck)
{
    CTELockHandle       hLock;                    
    PIRDA_ADDR_OBJ      pAddr;
    PIRDA_CONN_OBJ      pConn;    
    BOOLEAN             Valid = FALSE;

    CTEGetLock(&IrdaLock, &hLock);

    for (pAddr = AddrObjList; pAddr != NULL; pAddr = pAddr->pNext)
    {
        for (pConn = pAddr->ConnObjList; pConn != NULL; pConn = pConn->pNext)
        {
            if (pConn == pConnCheck)
            {
                Valid = TRUE;
                break;
            }    
        }    
    }
    
    CTEFreeLock(&IrdaLock, hLock);     

    return Valid;
}    

BOOLEAN
ValidAddrObject( 
    PIRDA_ADDR_OBJ  pAddrCheck)
{
    CTELockHandle       hLock;                    
    PIRDA_ADDR_OBJ      pAddr;
    BOOLEAN             Valid = FALSE;

    CTEGetLock(&IrdaLock, &hLock);

    for (pAddr = AddrObjList; pAddr != NULL; pAddr = pAddr->pNext)
    {
        if (pAddr == pAddrCheck)
        {
            Valid = TRUE;
            break;
        }    
    }
    
    CTEFreeLock(&IrdaLock, hLock);     
    
    return Valid;
}    


NTSTATUS
IrDADispatchDeviceControl(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp)
{
    NTSTATUS        Status;
  	CTELockHandle   hLock;    

#if DBG
    if (pIrpSp->Parameters.DeviceIoControl.IoControlCode != IOCTL_IRDA_GET_DBG_MSGS)
        DEBUGMSG(DBG_TDI_IRP,
        ("IRDA: IrDADispatchDeviceControl(), Irp:%p %s FileObj:%p %s:%p IoControlCode %X.\n",
        pIrp,
        IrpTdiTxt(pIrpSp),
        pIrpSp->FileObject,          
        IrpTdiObjTypeTxt(pIrpSp),
        pIrpSp->FileObject->FsContext,
        pIrpSp->Parameters.DeviceIoControl.IoControlCode));
#endif

	pIrp->IoStatus.Information = 0;

    switch(pIrpSp->Parameters.DeviceIoControl.IoControlCode)
    {
        IRDA_MSG IMsg;
        
        case IOCTL_IRDA_GET_INFO_ENUM_DEV:

            PendIrp(
                &DscvIrpList,
                pIrp,
                NULL,
                FALSE
                );

            Status=STATUS_PENDING;
#if DBG
            pIrp=NULL;
#endif
            IMsg.Prim = IRLMP_DISCOVERY_REQ;
            IMsg.IRDA_MSG_SenseMedia = TRUE;
            IrlmpDown(NULL, &IMsg);
            
            break;
        
        case IOCTL_IRDA_LAZY_DISCOVERY:
        {
            CTEGetLock(&IrdaLock, &hLock);    
            
            PendIrp(
                &LazyDscvIrpList,
                pIrp,
                NULL,
                TRUE
                );

            Status=STATUS_PENDING;
#if DBG
            pIrp=NULL;
#endif


            if (LazyDscvTimerRunning == FALSE) {

                LazyDscvTimerRunning = TRUE;                
                IrdaTimerStart(&LazyDscvTimer);                
            }
            
            CTEFreeLock(&IrdaLock, hLock);                                    
            break;
        }
        
        case IOCTL_IRDA_FLUSH_DISCOVERY_CACHE:
        {
            
            IMsg.Prim = IRLMP_FLUSHDSCV_REQ;
            
            IrlmpDown(NULL, &IMsg);
            
            LazyDscvMacAddrs = 0;
            
            Status = STATUS_SUCCESS;
            
            // also reset LinkStatusUpated flag so that irmon will get
            // latest status if it was restarted
            LinkStatusUpdated = TRUE;
            break;
        }
        case IOCTL_IRDA_SET_OPTIONS:
        {   
            PIRDA_ADDR_OBJ  pAddr = pIrpSp->FileObject->FsContext;
            int             *pOptions;
            
            DEBUGMSG(DBG_TDI, ("IRDA: IOCTL_IRDA_SET_OPTIONS\n"));
            
            if (!ValidAddrObject(pAddr))
            {
                Status = STATUS_INVALID_HANDLE;
                break;
            }                
            
            CTEAssert(IS_VALID_ADDR(pAddr));

            if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(int))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
                
            pOptions = pIrp->AssociatedIrp.SystemBuffer;
            
            if (*pOptions & OPT_IRLPT_MODE)
            {
                DEBUGMSG(DBG_TDI, ("IRDA: AddrObj:%p use IrLPT mode\n", pAddr));
                pAddr->UseIrlptMode = IRLPT_MODE1;
            }    
               
            if (*pOptions & OPT_9WIRE_MODE)
            {
                DEBUGMSG(DBG_TDI, ("IRDA: AddrObj:%p use 9-wire mode\n", pAddr));
                pAddr->Use9WireMode = TRUE;
            }    
               
            Status = STATUS_SUCCESS;
            
            break;
        }
        
        case IOCTL_IRDA_GET_SEND_PDU_LEN:
        {
            PIRDA_CONN_OBJ  pConn = pIrpSp->FileObject->FsContext;

            // protect ourselves from malicious hackers by verifying
            // this is a valid connObject
            
            if (!ValidConnectObject(pConn))
            {
                Status = STATUS_INVALID_HANDLE;
                break;
            }
                
            CTEAssert(IS_VALID_CONN(pConn));
            
            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(UINT))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;                
            }
                        
            *(UINT *) pIrp->AssociatedIrp.SystemBuffer = pConn->SendMaxPDU;
                
            DEBUGMSG(DBG_TDI, ("IRDA: GET_SEND_PDU_LEN Conn:%p, Len %d\n",
                     pConn, *(UINT *) pIrp->AssociatedIrp.SystemBuffer));
            
            pIrp->IoStatus.Information = sizeof(UINT);            
            
            Status = STATUS_SUCCESS;
            break;                
        }
            
        case IOCTL_IRDA_QUERY_IAS:
            Status = InitiateIasQuery(pIrp, pIrpSp, NULL);
            
            if (Status == STATUS_PENDING)
            {
                return STATUS_PENDING;
            }
            break;  
            
        case IOCTL_IRDA_SET_IAS:
        {
            PVOID               AttribHandle;
            PIRDA_IAS_ATTRIB    pIasAttrib;
            
            if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(IAS_SET) ||
                pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PVOID))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
            
            IMsg.Prim = IRLMP_ADDATTRIBUTE_REQ;
            IMsg.IRDA_MSG_pIasSet = (IAS_SET *) pIrp->AssociatedIrp.SystemBuffer;
            IMsg.IRDA_MSG_pAttribHandle = &AttribHandle;
            
            IrlmpDown(NULL, &IMsg);
            
            Status = STATUS_INSUFFICIENT_RESOURCES;
            
            if (AttribHandle)
            {
                IRDA_ALLOC_MEM(pIasAttrib, sizeof(IRDA_IAS_ATTRIB), MT_TDI_IAS);
                
                if (!pIasAttrib)
                {
                    IMsg.Prim = IRLMP_DELATTRIBUTE_REQ;
                    IMsg.IRDA_MSG_AttribHandle = AttribHandle;
                    IrlmpDown(NULL, &IMsg);
                }
                else
                {
                    
                    pIasAttrib->pFileObject = pIrpSp->FileObject;
                    pIasAttrib->AttribHandle = AttribHandle;
            
                    CTEGetLock(&IrdaLock, &hLock);    

                    InsertTailList(&IasAttribList, &pIasAttrib->Linkage);

                    CTEFreeLock(&IrdaLock, hLock);

                    pIrp->IoStatus.Information = sizeof(PVOID);                    
                    *(PVOID *) pIrp->AssociatedIrp.SystemBuffer = AttribHandle;                    
                    Status = STATUS_SUCCESS;
                    
                    DEBUGMSG(DBG_TDI, ("IRDA: IAS entry added, fo:%p ah:%p\n",
                             pIrpSp->FileObject, AttribHandle));
                }    
            }
            break;
        }                
        
        case IOCTL_IRDA_DEL_IAS_ATTRIB:
        {
            PVOID       *pAttribHandle = (PVOID *) pIrp->AssociatedIrp.SystemBuffer;
            
            if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PVOID))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }            
            
            IMsg.Prim = IRLMP_DELATTRIBUTE_REQ;
            IMsg.IRDA_MSG_AttribHandle = *pAttribHandle;
            IrlmpDown(NULL, &IMsg);
            
            pIrp->IoStatus.Information = 0;
            Status = STATUS_SUCCESS;
            break;
        }
        

        case IOCTL_IRDA_LINK_STATUS_NB:
        {
            PIRLINK_STATUS pLinkStatus = (PIRLINK_STATUS) pIrp->AssociatedIrp.SystemBuffer;
            
            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(IRLINK_STATUS))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;                
            }
            
            CTEGetLock(&IrdaLock, &hLock);    
            
            CTEMemCopy(pLinkStatus, &LinkStatus, sizeof(IRLINK_STATUS));            
            
            CTEFreeLock(&IrdaLock, hLock);                        
            
            pIrp->IoStatus.Information = sizeof(IRLINK_STATUS);
        
            Status = STATUS_SUCCESS;
            break;
        } 
        
        case IOCTL_IRDA_LINK_STATUS:        
        {
            PIRLINK_STATUS  pLinkStatus = (PIRLINK_STATUS) pIrp->AssociatedIrp.SystemBuffer;

            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(IRLINK_STATUS))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;                
            }            
            
            CTEGetLock(&IrdaLock, &hLock);    
            
            if (LinkStatusUpdated)
            {
                LinkStatusUpdated = FALSE;
                    
                CTEMemCopy(pLinkStatus, &LinkStatus, sizeof(IRLINK_STATUS));
                    
                pIrp->IoStatus.Information = sizeof(IRLINK_STATUS);
                
                Status = STATUS_SUCCESS;
            }
            else
            {
                PendIrp(&StatusIrpList, pIrp, NULL, TRUE);
                Status = STATUS_PENDING;
            }    

            CTEFreeLock(&IrdaLock, hLock);            
            
            break;
        }         
          
        #if 0 //DBG
        case IOCTL_IRDA_GET_DBG_MSGS:
            Status = DbgMsgIrp(pIrp, pIrpSp);
            break;
            
        case IOCTL_IRDA_GET_DBG_SETTINGS:
        {
            UINT    *Settings = pIrp->AssociatedIrp.SystemBuffer;
            
            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(UINT)*2)
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;                            
            }
            
            Settings[0] = DbgSettings;
            Settings[1] = DbgOutput;
            
            pIrp->IoStatus.Information = sizeof(UINT)*2;
            Status = STATUS_SUCCESS;
            break;
        }    
        
        case IOCTL_IRDA_SET_DBG_SETTINGS:
        {
            UINT    *Settings = pIrp->AssociatedIrp.SystemBuffer;
            
            if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UINT)*2)
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;                            
            }            
            
            DbgSettings = Settings[0];
            DbgOutput = Settings[1];
            
            pIrp->IoStatus.Information = 0;
            Status = STATUS_SUCCESS;
            break;
        }
        #endif    
            
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            break;
    }
    
    if (Status != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }    

    return Status;
}

NTSTATUS
TdiQueryInformation(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp)
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PIRDA_CONN_OBJ  pConn;
    PIRDA_ADDR_OBJ  pAddr;
    CTELockHandle   hLock;
    int             InfoSize = 0;
    int             BytesCopied;
    int             DataLen = GetMdlChainByteCount(pIrp->MdlAddress);    
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION   pTdiParmsQueryInfo;

    //
    // This is large enough for TDI_QUERY_ADDRESS_INFO because
    // of the inclusion of TDI_PROVIDER_STATISTICS.
    //
	union
    {
		TDI_CONNECTION_INFO		ConnInfo;
		TDI_ADDRESS_INFO		AddrInfo;
		TDI_PROVIDER_INFO		ProviderInfo;
		TDI_PROVIDER_STATISTICS	ProviderStats;
	} InfoBuf;
    
    pTdiParmsQueryInfo  = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION) 
                            &(pIrpSp->Parameters);
                            
    switch(pTdiParmsQueryInfo->QueryType)
    {            
        case TDI_QUERY_PROVIDER_INFO:
            InfoSize = sizeof(TDI_PROVIDER_INFO);
            InfoBuf.ProviderInfo.Version 				= 0x0100;
            InfoBuf.ProviderInfo.MaxSendSize			= 2048;//IRDA_MAX_DATA_SIZE;
            InfoBuf.ProviderInfo.MaxConnectionUserData	= 0;
            InfoBuf.ProviderInfo.MaxDatagramSize		= 0;
            InfoBuf.ProviderInfo.ServiceFlags			=
                TDI_SERVICE_CONNECTION_MODE |
                TDI_SERVICE_FORCE_ACCESS_CHECK/* | 
                TDI_SERVICE_ORDERLY_RELEASE*/;
            InfoBuf.ProviderInfo.MinimumLookaheadData	= 0;
            InfoBuf.ProviderInfo.MaximumLookaheadData	= 0;
            InfoBuf.ProviderInfo.NumberOfResources		= 0;
            InfoBuf.ProviderInfo.StartTime.LowPart		=
                CTESystemUpTime();
            InfoBuf.ProviderInfo.StartTime.HighPart	    = 0;            
			break;
            
		case TDI_QUERY_ADDRESS_INFO:
            //
            // typedef struct _TA_ADDRESS
            // {
            //     USHORT               AddressLength;
            //     USHORT               AddressType;
            //     UCHAR                Address[1];
            // } TA_ADDRESS, *PTA_ADDRESS;
            //
            // typedef struct _TRANSPORT_ADDRESS
            // {
            //     LONG                 TAAddressCount;
            //     TA_ADDRESS           Address[1];
            // } TRANSPORT_ADDRESS, *PTRANSPORT_ADDRESS;
            //
            // typedef struct _TDI_ADDRESS_IRDA
            // {
            //     UCHAR                irdaDeviceID[4];
            //     CHAR                 irdaServiceName[26];
            // } TDI_ADDRESS_IRDA, *PTDI_ADDRESS_IRDA;
            // 
            // IrDA assumes one TA_ADDRESS containing a TDI_ADDRESS_IRDA.
            //
            // typedef struct _TDI_ADDRESS_INFO
            // {
            //     ULONG                ActivityCount;
            //     TRANSPORT_ADDRESS    Address;
            // } TDI_ADDRESS_INFO, *PTDI_ADDRESS_INFO;
            
            InfoSize = 
                offsetof(TDI_ADDRESS_INFO, Address.Address[0].Address[0]) +
                sizeof(TDI_ADDRESS_IRDA);

            InfoBuf.AddrInfo.ActivityCount          = 1; // What is this?
            InfoBuf.AddrInfo.Address.TAAddressCount = 1;
                
            InfoBuf.AddrInfo.Address.Address[0].AddressLength =
                sizeof(TDI_ADDRESS_IRDA);

            InfoBuf.AddrInfo.Address.Address[0].AddressType =
                TDI_ADDRESS_TYPE_IRDA;
            
            if ((UINT_PTR) pIrpSp->FileObject->FsContext2 == TDI_CONNECTION_FILE)
            { 
                // Extract the local address from the Connection
                pConn = (PIRDA_CONN_OBJ) pIrpSp->FileObject->FsContext;
                CTEAssert(IS_VALID_CONN(pConn));

                GET_CONN_LOCK(pConn, &hLock);

                CTEMemCopy(
                    &InfoBuf.AddrInfo.Address.Address[0].Address[0],
                    &pConn->LocalAddr,
                    sizeof(TDI_ADDRESS_IRDA));

                FREE_CONN_LOCK(pConn, hLock);

                DEBUGMSG(DBG_TDI,
                    ("IRDA: TdiQueryInformation(), From ConnObj:%p, %d %02X%02X%02X%02X \"%s\".\n",
                     pConn,
                     InfoBuf.AddrInfo.Address.Address[0].AddressType,
                     InfoBuf.AddrInfo.Address.Address[0].Address[0],
                     InfoBuf.AddrInfo.Address.Address[0].Address[1],
                     InfoBuf.AddrInfo.Address.Address[0].Address[2],
                     InfoBuf.AddrInfo.Address.Address[0].Address[3],
                     (char *) &InfoBuf.AddrInfo.Address.Address[0].Address[4]));
            }
            else        // Extract the local address from the Address Object
            {
                pAddr = (PIRDA_ADDR_OBJ) pIrpSp->FileObject->FsContext;
                CTEAssert(IS_VALID_ADDR(pAddr));

                GET_ADDR_LOCK(pAddr, &hLock);                

                CTEMemCopy(
                    &InfoBuf.AddrInfo.Address.Address[0].Address[0],
                    &pAddr->LocalAddr,
                    sizeof(TDI_ADDRESS_IRDA));

                FREE_ADDR_LOCK(pAddr, hLock);

                DEBUGMSG(DBG_TDI,
                    ("IRDA: TdiQueryInformation(), From AddrObj:%p, %d %02X%02X%02X%02X \"%s\".\n",
                     pAddr,
                     InfoBuf.AddrInfo.Address.Address[0].AddressType,
                     InfoBuf.AddrInfo.Address.Address[0].Address[0],
                     InfoBuf.AddrInfo.Address.Address[0].Address[1],
                     InfoBuf.AddrInfo.Address.Address[0].Address[2],
                     InfoBuf.AddrInfo.Address.Address[0].Address[3],
                     (char *) &InfoBuf.AddrInfo.Address.Address[0].Address[4]));
            }
            break;
            
		case TDI_QUERY_CONNECTION_INFO:
            CTEAssert(FALSE);
			break;

		case TDI_QUERY_PROVIDER_STATISTICS:
            CTEAssert(FALSE);
            /*
              InfoSize = sizeof(TDI_PROVIDER_STATISTICS);
			CTEMemSet(&InfoBuf.ProviderStats, 0, sizeof(TDI_PROVIDER_STATISTICS));
			InfoBuf.ProviderStats.Version = 0x100;
            */
			break;
            
        case TDI_QUERY_BROADCAST_ADDRESS:            
		default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
			break;
        
    }

    BytesCopied=0;

    if (Status == STATUS_SUCCESS)
    {
        if (DataLen < InfoSize)
        {
            DEBUGMSG(DBG_ERROR, ("IRDA: Buffer overflow in TdiQueryInformation\n"));
            Status = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
            //
            //  could fail to get the system address for the mdl
            //
            Status=TdiCopyBufferToMdl(&InfoBuf, 0, InfoSize, pIrp->MdlAddress, 0, &BytesCopied);

        }
    }
        
	pIrp->IoStatus.Status       = Status;
    pIrp->IoStatus.Information  = BytesCopied;

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return Status;  
}

NTSTATUS
TdiSetInformation(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp)
{
    DEBUGMSG(DBG_TDI, ("IRDA: TdiSetInformation()\n"));

    //(PVOID) CloseRasIrdaAddresses = pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    
	pIrp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return STATUS_NOT_IMPLEMENTED;  
}
    
NTSTATUS
TdiSetEvent(
    PIRDA_ADDR_OBJ  pAddr,
    int             Type,
    PVOID           pHandler,
    PVOID           pContext)
{
    TDI_STATUS      Status;
	CTELockHandle   hLock;

    DEBUGMSG(DBG_TDI, ("IRDA: TdiSetEvent(), %s for AddrObj:%p, Handler:%p, Context:%p \n",
            TdiEventTxt(Type), pAddr, pHandler, pContext));

    CTEAssert(IS_VALID_ADDR(pAddr));

    Status = STATUS_SUCCESS;
    
    GET_ADDR_LOCK(pAddr, &hLock);
    
    switch (Type)
    {
        case TDI_EVENT_CONNECT:
            pAddr->pEventConnect = pHandler;
            pAddr->pEventConnectContext = pContext;
            break;

        case TDI_EVENT_DISCONNECT:
            pAddr->pEventDisconnect = pHandler;
            pAddr->pEventDisconnectContext = pContext;
            break;

        case TDI_EVENT_RECEIVE:
            pAddr->pEventReceive = pHandler;
            pAddr->pEventReceiveContext = pContext;
            break;

        case TDI_EVENT_ERROR:
            break;
            
        case TDI_EVENT_RECEIVE_DATAGRAM:
        case TDI_EVENT_RECEIVE_EXPEDITED:
      default:
          Status = STATUS_INVALID_PARAMETER;//TDI_BAD_EVENT_TYPE;
          break;
    }

    FREE_ADDR_LOCK(pAddr, hLock);

    return Status;
}

int
GetLsapSelServiceName(CHAR *ServiceName)
{
    int     LsapSel = 0;
    int     i;
    CHAR    *Digits;
    
    // Is the service name of the form "LSAP-SELxxx"?
    // If yes then return xxx if it is a number else -1.
    // If not "LSAP-SELxxx" return 0.
    
    if (RtlCompareMemory(LSAPSEL_TXT, ServiceName, LSAPSEL_TXTLEN)
        == LSAPSEL_TXTLEN)
    {
        Digits = ServiceName + LSAPSEL_TXTLEN;
        
        for (i = 0; i< 3; i++)
        {
            if (Digits[i] == 0)
                break;
            
            if (Digits[i] < '0' || Digits[i] > '9')
            {
                LsapSel = -1;
                break;
            }    
                    
            LsapSel = (LsapSel*10) + (Digits[i] - '0');
        }
        
        if (Digits[i] != 0) // LSAP-SELxxx should be null terminated
        {
            LsapSel = -1;
        }
    }    

    if (LsapSel > 127) {
        //
        //  lsapsel's are only 7 bits
        //
        LsapSel=-1;
    }

    return LsapSel;
}

NTSTATUS
TdiOpenAddress(
    PIRDA_ADDR_OBJ                  *ppNewAddrObj,
    TRANSPORT_ADDRESS UNALIGNED     *pAddrList,
    USHORT                          AddrListLen)
{
    TDI_STATUS          Status = TDI_SUCCESS;
    PIRDA_ADDR_OBJ      pAddr;
	CTELockHandle       hLock;
    int                 NewLsapSel;
    int                 i;
    PTDI_ADDRESS_IRDA   pIrdaAddr = (PTDI_ADDRESS_IRDA) pAddrList->Address[0].Address;
    BOOLEAN             AddIasServiceName = TRUE;

    //
    // typedef struct _TA_ADDRESS
    // {
    //     USHORT               AddressLength;
    //     USHORT               AddressType;
    //     UCHAR                Address[1];
    // } TA_ADDRESS, *PTA_ADDRESS;
    //
    // typedef struct _TRANSPORT_ADDRESS
    // {
    //     LONG                 TAAddressCount;
    //     TA_ADDRESS           Address[1];
    // } TRANSPORT_ADDRESS, *PTRANSPORT_ADDRESS;
    //
    // typedef struct _TDI_ADDRESS_IRDA
    // {
    //     UCHAR                irdaDeviceID[4];
    //     CHAR                 irdaServiceName[26];
    // } TDI_ADDRESS_IRDA, *PTDI_ADDRESS_IRDA;
    // 
    // IrDA assumes one TA_ADDRESS containing a TDI_ADDRESS_IRDA.
    //
    // typedef struct _TDI_ADDRESS_INFO
    // {
    //     ULONG                ActivityCount;
    //     TRANSPORT_ADDRESS    Address;
    // } TDI_ADDRESS_INFO, *PTDI_ADDRESS_INFO;
    //
    
    if (AddrListLen < sizeof(TRANSPORT_ADDRESS) + sizeof(TDI_ADDRESS_IRDA) - 1)
    {
        return STATUS_EA_LIST_INCONSISTENT;    
    }
    
    DEBUGMSG(DBG_TDI,
        ("IRDA: TdiOpenAddress(), Type:%d Addr:%02X%02X%02X%02X \"%s\".\n",
        pAddrList->Address[0].AddressType,
        pAddrList->Address[0].Address[0],
        pAddrList->Address[0].Address[1],
        pAddrList->Address[0].Address[2],
        pAddrList->Address[0].Address[3],
        (char *) &pAddrList->Address[0].Address[4]));

    if (pAddrList->TAAddressCount != 1 ||
        pAddrList->Address[0].AddressLength != sizeof(TDI_ADDRESS_IRDA) ||
        pAddrList->Address[0].AddressType != TDI_ADDRESS_TYPE_IRDA)
    {

        DEBUGMSG(DBG_ERROR, ("IRDA: TdiOpenAddress(), Bad Address. Count=%d, AddrLen:%d!=%d Type:%d!=%d\n",
                 pAddrList->TAAddressCount, pAddrList->Address[0].AddressLength,
                 sizeof(TDI_ADDRESS_IRDA), pAddrList->Address[0].AddressType,
                 TDI_ADDRESS_TYPE_IRDA)); 
        return STATUS_INVALID_ADDRESS_COMPONENT; //TDI_BAD_ADDR;
    }

    CTEGetLock(&IrdaLock, &hLock);
    
    // Service name supplied. Ensure that an address object with the same
    // name does not exist
    if (pIrdaAddr->irdaServiceName[0] != 0)
    {
        for (pAddr = AddrObjList; pAddr != NULL; pAddr = pAddr->pNext)
        {
            if (MyStrEqual(pIrdaAddr->irdaServiceName,
                           pAddr->LocalAddr.irdaServiceName,
                           sizeof(pIrdaAddr->irdaServiceName)))
            {
                DEBUGMSG(DBG_ERROR, ("IRDA: TdiOpenAddress(), Duplicate irdaServiceName.\n"));
                Status = STATUS_ADDRESS_ALREADY_EXISTS;//TDI_ADDR_IN_USE;
                
                CTEFreeLock(&IrdaLock, hLock);                
                
                goto done;
            }              
        }
    }

    NewLsapSel = GetLsapSelServiceName(pIrdaAddr->irdaServiceName);
    
    if (NewLsapSel == -1)
    {
        // Service name was of the form "LSAP-SELxxx" but xxx was invalid
        Status = STATUS_INVALID_ADDRESS_COMPONENT;

        CTEFreeLock(&IrdaLock, hLock);        
        
        goto done;

    }
    
    if (NewLsapSel)
    {
        // Service name was of the form "LSAP-SELxxx" 
        // NewLsapSel = xxx
        
        AddIasServiceName = FALSE;         
    }
    else if ((NewLsapSel = GetUnusedLsapSel()) == -1)
    {        
        DEBUGMSG(DBG_ERROR, ("IRDA: TdiOpenAddress(), No LSAP-SELs.\n"));
        
        Status = STATUS_TOO_MANY_ADDRESSES;//TDI_NO_FREE_ADDR;

        CTEFreeLock(&IrdaLock, hLock);        
        
        goto done;
    }

    IRDA_ALLOC_MEM(pAddr, sizeof(IRDA_ADDR_OBJ), MT_TDI_ADDROBJ);
    
    if (pAddr == NULL)
    {
        DEBUGMSG(DBG_ERROR, ("IRDA: AllocMem(IRDA_ADDR_OBJ) failed.\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;//TDI_NO_RESOURCES;
        
        CTEFreeLock(&IrdaLock, hLock);        
        
        goto done;
    }
    
    CTEMemSet(pAddr, 0, sizeof(IRDA_ADDR_OBJ));

    CTEInitLock(&pAddr->Lock);
    
    pAddr->ConnObjList                = NULL;
    pAddr->pEventConnect              = NULL;
    pAddr->pEventConnectContext       = NULL;
    pAddr->pEventDisconnect           = NULL;
    pAddr->pEventDisconnectContext    = NULL;
    pAddr->pEventReceive              = NULL;
    pAddr->pEventReceiveContext       = NULL;
    pAddr->LocalLsapSel               = NewLsapSel;
    pAddr->UseIrlptMode               = 0;    
    pAddr->Use9WireMode               = FALSE;
    pAddr->pNext                      = AddrObjList;
    AddrObjList                       = pAddr;
#if DBG
    pAddr->Sig                        = ADDR_OBJ_SIG;
#endif  

    CTEFreeLock(&IrdaLock, hLock);  
    
    // A server
    if (pIrdaAddr->irdaServiceName[0] != 0)
    {
        IRDA_MSG        IMsg;    
        IAS_SET         IasSet;
    
        RtlCopyMemory(&pAddr->LocalAddr, 
                      pIrdaAddr, sizeof(TDI_ADDRESS_IRDA));
        pAddr->IsServer = TRUE;
        
        // register LSAP-SEL
        IMsg.Prim                   = IRLMP_REGISTERLSAP_REQ;
        IMsg.IRDA_MSG_LocalLsapSel  = NewLsapSel;
        IMsg.IRDA_MSG_UseTtp        = TRUE;
        IrlmpDown(NULL, &IMsg);

        // and IAS LsapSel attribute
        
        if (AddIasServiceName)
        {
            i = 0;
            while (pAddr->LocalAddr.irdaServiceName[i] && i < 60)
            {
                IasSet.irdaClassName[i] = pAddr->LocalAddr.irdaServiceName[i];
                i++;
            }
            IasSet.irdaClassName[i] = 0;

            i = 0;
            while (IasAttribName_TTPLsapSel[i])
            {
                IasSet.irdaAttribName[i] = IasAttribName_TTPLsapSel[i];
                i++;
            }
            IasSet.irdaAttribName[i] = 0;

            IasSet.irdaAttribType               = IAS_ATTRIB_INT;
            IasSet.irdaAttribute.irdaAttribInt  = NewLsapSel;

            IMsg.Prim = IRLMP_ADDATTRIBUTE_REQ;
            IMsg.IRDA_MSG_pIasSet = &IasSet;
            IMsg.IRDA_MSG_pAttribHandle = &pAddr->IasAttribHandle;
        
            IrlmpDown(NULL, &IMsg);
        }
    }
    // A client
    else
    {
        pAddr->IsServer = FALSE;
        SetLsapSelAddr(NewLsapSel, pAddr->LocalAddr.irdaServiceName);
    }

    
	*ppNewAddrObj = pAddr;

    DEBUGMSG(DBG_TDI,
        ("IRDA: TdiOpenAddress(), Assigned local LSAP-SEL %d, Service:\"%s\".\n",
        pAddr->LocalLsapSel, pAddr->LocalAddr.irdaServiceName));

done:
    
	return Status;
}

NTSTATUS
TdiOpenConnection(
    PIRDA_CONN_OBJ  *ppNewConnObj,
    PVOID           pContext,
    USHORT          ContextLen)
{
    PIRDA_CONN_OBJ  pNewConnObj;

    *ppNewConnObj=NULL;

    if (ContextLen < sizeof(CONNECTION_CONTEXT))
    {
        return STATUS_EA_LIST_INCONSISTENT;
    }
        
    IRDA_ALLOC_MEM(pNewConnObj, sizeof(IRDA_CONN_OBJ), MT_TDI_CONNOBJ);

    if (pNewConnObj == NULL)
    {
        DEBUGMSG(DBG_ERROR, ("IRDA: AllocMem(IRDA_CONN_OBJ) failed.\n"));
        return STATUS_INSUFFICIENT_RESOURCES;//TDI_NO_RESOURCES;
    }

    CTEMemSet(pNewConnObj, 0, sizeof(IRDA_CONN_OBJ));

    CTEInitLock(&pNewConnObj->Lock);

    pNewConnObj->ClientContext = pContext;
    pNewConnObj->ConnState = IRDA_CONN_CREATED;
    
	InitializeListHead(&pNewConnObj->RecvBufList);
    InitializeListHead(&pNewConnObj->RecvIrpList);
    InitializeListHead(&pNewConnObj->SendIrpList);
    InitializeListHead(&pNewConnObj->SendIrpPassiveList);
        
    IrdaTimerInitialize(&pNewConnObj->RetryConnTimer,
                        RetryConnTimerExp,
                        BUSY_LINK_CONN_RETRY_WAIT,
                        pNewConnObj, NULL);

    ReferenceInit(&pNewConnObj->RefCnt, pNewConnObj, FreeConnObject);
    REFADD(&pNewConnObj->RefCnt, ' TS1');
    
    CTEInitEvent(&pNewConnObj->SendEvent, TdiSendAtPassiveCallback);
    
#if DBG
    pNewConnObj->Sig = CONN_OBJ_SIG;
    pNewConnObj->RetryConnTimer.pName = "RetryConn";
#endif        

    *ppNewConnObj = pNewConnObj;

    return STATUS_SUCCESS;
}

NTSTATUS
TdiCloseAddress(PIRDA_ADDR_OBJ pAddr)
{
    PIRDA_ADDR_OBJ  pPrevAddrObj;
	CTELockHandle   hLock;

    DEBUGMSG(DBG_TDI, ("IRDA: TdiCloseAddress() AddrObj:%p\n",
        pAddr));

    CTEAssert(IS_VALID_ADDR(pAddr));

    CTEAssert(pAddr->ConnObjList == NULL);

    CTEGetLock(&IrdaLock, &hLock);

    // if pAddr is first in the list, remove it from the list
    if (AddrObjList == pAddr)
        AddrObjList = pAddr->pNext;
    else
    {
        // find the previous IRDA_ADDR_OBJ
        pPrevAddrObj = AddrObjList;
        while (pPrevAddrObj->pNext != pAddr)
            pPrevAddrObj = pPrevAddrObj->pNext;
        // remove pAddr from the list
        pPrevAddrObj->pNext = pAddr->pNext;
    }

    CTEFreeLock(&IrdaLock, hLock);
    
    if (pAddr->IsServer)
    {
        IRDA_MSG    IMsg;
        
        IMsg.Prim = IRLMP_DEREGISTERLSAP_REQ;
        IMsg.IRDA_MSG_LocalLsapSel = pAddr->LocalLsapSel;
        IrlmpDown(NULL, &IMsg);        
        
        IMsg.Prim = IRLMP_DELATTRIBUTE_REQ;
        IMsg.IRDA_MSG_AttribHandle = pAddr->IasAttribHandle;
        IrlmpDown(NULL, &IMsg);
    }

#if DBG
    pAddr->Sig = ' DAB';
#endif
    
    IRDA_FREE_MEM(pAddr);

    return STATUS_SUCCESS;
}

VOID
ConnectionStatusChange(
    PIRDA_CONN_OBJ          pConn,
    IRDA_CONNECTION_STATUS  ConnStatus)
{
    PLIST_ENTRY         pListEntry;
    PIRP                pIrp;
    CTELockHandle       hLock;

    if (ConnStatus == CONNECTION_UP)
    {
        IRDA_MSG    IMsg;
        
        if (!ConnectionCount)
        {
            return;
        }
            
        ConnectionInterrupted = FALSE;        
        
        if (pConn)
        {
            // Query Irlap for the connected speed and
            // the MAC address of the peer so Irmon
            // can display the name of the connected device        
            IMsg.Prim = IRLAP_STATUS_REQ;
            IMsg.IRDA_MSG_pLinkStatus = &LinkStatus;
        
            IrlmpDown(pConn->IrlmpContext, &IMsg);
        }
    }
    
    CTEGetLock(&IrdaLock, &hLock);
    
    LinkStatusUpdated = TRUE;
    
    switch (ConnStatus)
    {
        case CONNECTION_UP:
            LinkStatus.Flags = LF_CONNECTED;
            break;
            
        case CONNECTION_DOWN:
            LinkStatus.Flags = 0;
            break;
            
        case CONNECTION_INTERRUPTED:
            if (ConnectionInterrupted || !ConnectionCount)
            {
                CTEFreeLock(&IrdaLock, hLock);
                return;
            }
            LinkStatus.Flags = LF_INTERRUPTED;
            ConnectionInterrupted = TRUE;
            break;
    }                

    while (!IsListEmpty(&StatusIrpList)) {

        pListEntry = RemoveHeadList(&StatusIrpList);
                
        pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
        
        if (IoSetCancelRoutine(pIrp, NULL) == NULL) {

            // Cancel routine is going to run. Mark Irp so cancel
            // routine won't attempt to remove it from the list
            pIrp->Tail.Overlay.ListEntry.Flink = NULL;

        } else {

            CTEMemCopy(pIrp->AssociatedIrp.SystemBuffer, 
                       &LinkStatus, sizeof(IRLINK_STATUS));
                                   
            CTEFreeLock(&IrdaLock, hLock);                                   
                     
            pIrp->IoStatus.Information = sizeof(IRLINK_STATUS);
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

            CTEGetLock(&IrdaLock, &hLock);

            LinkStatusUpdated = FALSE;
        }    
    }

    CTEFreeLock(&IrdaLock, hLock);

    return;
}

VOID
ConnectionUp(
    PIRDA_CONN_OBJ  pConn,
    BOOLEAN         ConnectionUp)
{
    if (ConnectionUp)
    {
        if (pConn->ConnectionUp)
        {
            return;
        }
        
        pConn->ConnectionUp = TRUE;
        
        CTEInterlockedIncrementLong(&ConnectionCount);
        
        if (ConnectionCount == 1)
        {
            ConnectionStatusChange(pConn, CONNECTION_UP);
        }
    }
    else
    {
        if (!pConn->ConnectionUp)
        {
            return;
        }
        
        pConn->ConnectionUp = FALSE;
            
        ASSERT(ConnectionCount);
        CTEInterlockedDecrementLong(&ConnectionCount);
                
        if (ConnectionCount == 0)
        {
            ConnectionStatusChange(pConn, CONNECTION_DOWN);
        }
    }
}

VOID
IrdaDisconnectIrlmp(PIRDA_CONN_OBJ  pConn)
{
    IRDA_MSG IMsg;    

    if (pConn->IrlmpContext)
    {
        IMsg.Prim = IRLMP_DISCONNECT_REQ;
        IMsg.IRDA_MSG_pDiscData = NULL;
        IMsg.IRDA_MSG_DiscDataLen = 0;
        IMsg.IRDA_MSG_pDiscContext = pConn;
            
            
        IrlmpDown(pConn->IrlmpContext, &IMsg);
    
        DEBUGMSG(DBG_TDI, ("IRDA: IrdaDisconnectIrlmp co:%p\n", pConn));
        
    }
    else
    {
        DEBUGMSG(DBG_TDI, ("IRDA: IrdaDisconnectIrlmp co %p, IrlmpContext == NULL\n",
                 pConn));
    }    
}

VOID
FreeConnObject(PIRDA_CONN_OBJ pConn)
{
    IRDA_FREE_MEM(pConn);    
}
    
NTSTATUS
TdiCloseConnection(PIRDA_CONN_OBJ pConn)
{

    PIRDA_ADDR_OBJ  pAddr=NULL;
    CTELockHandle   hLock;

    DEBUGMSG(DBG_TDI, ("IRDA: TdiCloseConnecion() ConnObj:%p\n",
        pConn));

    CTEAssert(IS_VALID_CONN(pConn));

    if (pConn->ConnState != IRDA_CONN_CREATED)
    {
        TdiDisconnect(NULL, NULL, pConn);
    }    


    GET_CONN_LOCK(pConn, &hLock);

    pAddr=pConn->pAddr;
    pConn->pAddr=NULL;

    if (pAddr != NULL) {

        PIRDA_CONN_OBJ  pPrevConnObj;

        CTELockHandle   hAddrLock;

        GET_ADDR_LOCK(pAddr, &hAddrLock);

        //
        // if pConn is first in the list, remove it from the list
        //
        if (pAddr->ConnObjList == pConn) {

            pAddr->ConnObjList = pConn->pNext;

        } else {
            //
            // find the previous IRDA_CONN_OBJ
            //

            pPrevConnObj = pAddr->ConnObjList;

            while ((pPrevConnObj != NULL) && (pPrevConnObj->pNext != pConn)) {

                pPrevConnObj = pPrevConnObj->pNext;
            }

            //
            //  since the connection has a pointer to the address object,
            //  the connection should really be in the address objects connection list.
            //
            ASSERT(pPrevConnObj != NULL);

            //
            // remove pConn from the list
            //
            if (pPrevConnObj != NULL) {

                pPrevConnObj->pNext = pConn->pNext;
            }
        }

        DumpObjects();

        FREE_ADDR_LOCK(pAddr, hAddrLock);

        //
        //  done with this address object
        //
        ObDereferenceObject(pConn->AddressFileObject);

    }

    FREE_CONN_LOCK(pConn, hLock);


    if (pConn->IrlmpContext) 
    {
        IRDA_MSG IMsg;    
    
        IMsg.Prim = IRLMP_CLOSELSAP_REQ;
        
        IrlmpDown(pConn->IrlmpContext, &IMsg);
    }
    
#if DBG
    pConn->Sig = ' DAB';
#endif
        
    CTEAssert(IsListEmpty(&pConn->RecvBufList));
    CTEAssert(IsListEmpty(&pConn->SendIrpList));    

    REFDEL(&pConn->RefCnt, ' TS1');

    return STATUS_SUCCESS;
}

NTSTATUS
TdiAssociateAddress(
    PIRP    pIrp,
    PIO_STACK_LOCATION  pIrpSp)
{
    NTSTATUS                        Status;
    PTDI_REQUEST_KERNEL_ASSOCIATE   pTdiParmsAssoc;
    PFILE_OBJECT                    AddressFileObject;
  
    CTEAssert(((UINT_PTR) pIrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);
  
    pTdiParmsAssoc = (PTDI_REQUEST_KERNEL_ASSOCIATE) &(pIrpSp->Parameters);
    
    Status = ObReferenceObjectByHandle(
                pTdiParmsAssoc->AddressHandle,
                0,
                *IoFileObjectType,
                pIrp->RequestorMode,
                &AddressFileObject,
                NULL);
    
    if (!NT_SUCCESS(Status))
    {
        DEBUGMSG(DBG_ERROR,
            ("IRDA: TdiAssociateAddress(), ObReferenceObjectByHandle() for %p failed, %X.\n",
            pTdiParmsAssoc->AddressHandle,
            Status));
    }
    else if (AddressFileObject->DeviceObject != pIrDADeviceObject ||
             ((UINT_PTR) AddressFileObject->FsContext2) != TDI_TRANSPORT_ADDRESS_FILE)
    {
        DEBUGMSG(DBG_ERROR,("IRDA: TdiAssociateAddress(), Bad handle %p.\n",
            pTdiParmsAssoc->AddressHandle));

            ObDereferenceObject(AddressFileObject);

            Status = STATUS_INVALID_HANDLE;
    }
    else
    {
        PIRDA_CONN_OBJ  pConn;
        PIRDA_ADDR_OBJ  pAddr;
	    CTELockHandle   hAddrLock;
        CTELockHandle   hLock;
        
        pConn = (PIRDA_CONN_OBJ) pIrpSp->FileObject->FsContext;
        CTEAssert(IS_VALID_CONN(pConn));
    
        pAddr = (PIRDA_ADDR_OBJ) AddressFileObject->FsContext;
        CTEAssert(IS_VALID_ADDR(pAddr));                

        DEBUGMSG(DBG_TDI, ("IRDA: TdiAssociateAddress AddrObj:%p ConnObj:%p\n",
            pAddr, pConn));

        GET_CONN_LOCK(pConn, &hLock);

        GET_ADDR_LOCK(pAddr, &hAddrLock);
        
        if (pConn->pAddr != NULL) {


            ObDereferenceObject(AddressFileObject);
            Status = STATUS_ADDRESS_ALREADY_ASSOCIATED;
            ASSERT(0);

        } else {

            //
            //  don't want the address file object going away while we have a connection object pointing to it
            //
            pConn->AddressFileObject=AddressFileObject;

            // Link IRDA_CONN_OBJ to IRDA_ADDR_OBJ.
            pConn->pAddr  = pAddr;
            
            // Add IRDA_CONN_OBJ to ConnObjList anchored on IRDA_ADDR_OBJ.
            pConn->pNext = pAddr->ConnObjList;
            pAddr->ConnObjList = pConn;

            CTEMemCopy(&pConn->LocalAddr,&pAddr->LocalAddr, sizeof(TDI_ADDRESS_IRDA));

            pConn->IsServer = pAddr->IsServer;
            pConn->LocalLsapSel = pAddr->LocalLsapSel;

            DumpObjects();
            
            Status = STATUS_SUCCESS;
        }        
        
        FREE_ADDR_LOCK(pAddr, hAddrLock);    
        FREE_CONN_LOCK(pConn, hLock);


    }
    
	pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return Status;  
}    

NTSTATUS
TdiDisassociateAddress(PIRP pIrp, PIO_STACK_LOCATION pIrpSp)
{
    PIRDA_CONN_OBJ  pConn, pPrevConnObj;
    PIRDA_ADDR_OBJ  pAddr;
    CTELockHandle   hLock;
    CTELockHandle   hAddrLock;
    NTSTATUS        Status = STATUS_SUCCESS;

    pConn = (PIRDA_CONN_OBJ) pIrpSp->FileObject->FsContext;
    CTEAssert(IS_VALID_CONN(pConn));

    if (pConn->pAddr == NULL)
    {
        CTEAssert(pConn->pAddr != NULL);
        Status = STATUS_INVALID_ADDRESS_COMPONENT; //TDI_BAD_ADDR;        
        goto done;
    }    
    
    // normally when the peer disconnects I indicate the
    // disconnect to AFD and go to IRDA_CONN_CLOSING state.
    // AFD then calls TdiDisconnect and I go into IRDA_CONN_CREATED.
    // AFD then disassociates the address. In some cases however,
    // AFD does not call TdiDisconnect before it disassociates so
    // I'll do it. 
    
    if (pConn->ConnState != IRDA_CONN_CREATED)
    {
        TdiDisconnect(NULL, NULL, pConn);
    }    
    
    CTEAssert(pConn->ConnState == IRDA_CONN_CREATED);

    GET_CONN_LOCK(pConn, &hLock);

    pAddr = pConn->pAddr;
    CTEAssert(IS_VALID_ADDR(pAddr));

    DEBUGMSG(DBG_TDI, ("IRDA: TdiDisassociateAddress() AddrObj:%p ConnObj:%p\n",
            pAddr, pConn));
    
    GET_ADDR_LOCK(pAddr, &hAddrLock);
    
    // if pConn is first in the list, remove it from the list
    if (pAddr->ConnObjList == pConn)
        pAddr->ConnObjList = pConn->pNext;
    else
    {
        // find the previous IRDA_CONN_OBJ
        
        pPrevConnObj = pAddr->ConnObjList;
        while (pPrevConnObj && pPrevConnObj->pNext != pConn)
        {
            pPrevConnObj = pPrevConnObj->pNext;
        }    
        
        // remove pConn from the list
        if (pPrevConnObj)
        {
            pPrevConnObj->pNext = pConn->pNext;
        }    
    }

    DumpObjects();

    pConn->pAddr=NULL;

    //
    //  done with this address object
    //
    ObDereferenceObject(pConn->AddressFileObject);

    FREE_ADDR_LOCK(pAddr, hAddrLock);    
    FREE_CONN_LOCK(pConn, hLock);

done:

	pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return Status;  
}

NTSTATUS
ConnectRcToNtStatus(UINT IrlmpRc)
{
    switch (IrlmpRc)
    {
        case IRLMP_LSAP_SEL_IN_USE:
        case IRLMP_IN_EXCLUSIVE_MODE:
            return STATUS_ADDRESS_ALREADY_EXISTS;
            
        case IRLMP_LINK_IN_USE:
            return STATUS_ACCESS_DENIED;
            
        case IRLMP_IAS_QUERY_IN_PROGRESS: 
            // I've serialized IAS requests, should never happen
            CTEAssert(0);
            return STATUS_CONNECTION_RESET; //STATUS_CONNECTION_ABORTED;

        case IRLMP_BAD_DEV_ADDR:
            return STATUS_INVALID_ADDRESS_COMPONENT;
    }
    
    return STATUS_CONNECTION_RESET; //STATUS_CONNECTION_ABORTED;
}

NTSTATUS
InitiateConnection(PIRDA_CONN_OBJ pConn, PIRP pIrp)
{
    IRDA_MSG    IMsg;
    UINT        rc;
    
    DEBUGMSG(DBG_TDI, ("IRDA: Initiate connection to Dev:%02X%02X%02X%02X\n",
            pConn->RemoteAddr.irdaDeviceID[0],
            pConn->RemoteAddr.irdaDeviceID[1],
            pConn->RemoteAddr.irdaDeviceID[2],
            pConn->RemoteAddr.irdaDeviceID[3]
            ));
    DEBUGMSG(DBG_TDI, ("      LocalLsapSel:%d, RemoteLsapSel:%d\n",
                        pConn->LocalLsapSel, pConn->RemoteLsapSel));        
    
    IMsg.Prim = IRLMP_CONNECT_REQ;
    
    RtlCopyMemory(IMsg.IRDA_MSG_RemoteDevAddr,
                  pConn->RemoteAddr.irdaDeviceID,
                  IRDA_DEV_ADDR_LEN);
                  
    IMsg.IRDA_MSG_RemoteLsapSel = pConn->RemoteLsapSel;
    IMsg.IRDA_MSG_pQos          = NULL;
    IMsg.IRDA_MSG_pConnData     = NULL;       
    IMsg.IRDA_MSG_ConnDataLen   = 0;
    IMsg.IRDA_MSG_LocalLsapSel  = pConn->LocalLsapSel;
    IMsg.IRDA_MSG_pContext      = pConn;
    IMsg.IRDA_MSG_UseTtp        = pConn->pAddr->UseIrlptMode ? FALSE:TRUE;
    IMsg.IRDA_MSG_TtpCredits    = TTP_RECV_CREDITS;
    IMsg.IRDA_MSG_MaxSDUSize    = TTP_RECV_MAX_SDU;
    
    #if DBG
    pConn->CreditsExtended += TTP_RECV_CREDITS;
    #endif

    pConn->TtpRecvCreditsLeft = TTP_RECV_CREDITS;


#if DBG
    pIrp->IoStatus.Information=1;
#endif
    //
    //  pend the irp, now incase the confermation happened quickly
    //
    PendIrp(&ConnIrpList, pIrp, NULL, FALSE);

    rc = IrlmpDown(NULL, &IMsg);

    pIrp=NULL;

    switch (rc)
    {
        case SUCCESS:
            //
            // TDI needed the IrlmpContext immediately so it is
            // now returned in the request message
            pConn->IrlmpContext = IMsg.IRDA_MSG_pContext;

            break;
        
        case IRLAP_REMOTE_DISCOVERY_IN_PROGRESS_ERR:

            //
            //  failed, get the irp back off the queue if possible
            //
            pIrp=GetIrpOnConnIrpList(pConn);

            if (pIrp != NULL) {
                //
                //  we got it back, attempt to retry the connection
                //
                RetryConnection(pConn, pIrp);
            }

            break;
        
        default:
            DEBUGMSG(DBG_ERROR, ("IRDA: IRLMP_CONNECT_REQ failed %d\n", rc));

            //
            //  failed, get the irp back off the queue if possible
            //
            pIrp=GetIrpOnConnIrpList(pConn);

            if (pIrp != NULL) {

                pIrp->IoStatus.Status=ConnectRcToNtStatus(rc);
                IoCompleteRequest(pIrp,IO_NO_INCREMENT);
            }

            break;

    }

    return STATUS_PENDING;
}

UINT
SendIasQuery(PIRP pIrp, PIO_STACK_LOCATION pIrpSp)
{
    IRDA_MSG            IMsg;
        
    if ((UINT_PTR) pIrpSp->FileObject->FsContext2 == TDI_CONNECTION_FILE)
    {
        // connection object querying remote IAS for LsapSel
        PTDI_CONNECTION_INFORMATION     pReqConnInfo;
        PTDI_REQUEST_KERNEL_CONNECT     pTdiParmsConn;
        PTRANSPORT_ADDRESS              pTranAddr;
        PTDI_ADDRESS_IRDA               pIrdaAddr;
        PIRDA_CONN_OBJ                  pConn = pIrpSp->FileObject->FsContext;
     
        if (!ValidConnectObject(pConn))
        {
            return 1;
        }   
        
        CTEAssert(IS_VALID_CONN(pConn));

        pTdiParmsConn = (PTDI_REQUEST_KERNEL_CONNECT) &(pIrpSp->Parameters);
        pReqConnInfo = pTdiParmsConn->RequestConnectionInformation;
        pTranAddr = (PTRANSPORT_ADDRESS) pReqConnInfo->RemoteAddress;
        pIrdaAddr = (PTDI_ADDRESS_IRDA) pTranAddr->Address[0].Address;

        RtlCopyMemory(pvIasQuery->irdaDeviceID, 
                      pIrdaAddr->irdaDeviceID,
                      IRDA_DEV_ADDR_LEN);

        strcpy(pvIasQuery->irdaClassName, pIrdaAddr->irdaServiceName);

        if (pConn->pAddr->UseIrlptMode)
        {
            // I can't beleive this crap
            if (pConn->pAddr->UseIrlptMode == IRLPT_MODE1)
            {
                strcpy(pvIasQuery->irdaAttribName, IasAttribName_IrLMPLsapSel);
                pConn->pAddr->UseIrlptMode = IRLPT_MODE2;
            }
            else
            {
                strcpy(pvIasQuery->irdaAttribName, IasAttribName_IrLMPLsapSel2);            
                pConn->pAddr->UseIrlptMode = IRLPT_MODE1;                
            }
        }        
        else
        {    
            strcpy(pvIasQuery->irdaAttribName, IasAttribName_TTPLsapSel);
        }
        
        pvIasQuery->irdaAttribType = 0; // development purposes only
    }
    else
    {   
        // A getsockopt(IRLMP_IAS_QUERY)
        
        IAS_QUERY   *pIasQuery = pIrp->AssociatedIrp.SystemBuffer;
         
		CTEAssert(pIrpSp->FileObject->FsContext2 == (PVOID) TDI_CONTROL_CHANNEL_FILE);
        
        if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(IAS_QUERY))
        {
            return 1;
        }    
        
        RtlCopyMemory(pvIasQuery->irdaDeviceID,
                      pIasQuery->irdaDeviceID,
                      IRDA_DEV_ADDR_LEN);
                      
        strncpy(pvIasQuery->irdaClassName, pIasQuery->irdaClassName, IAS_MAX_CLASSNAME);
        
        strncpy(pvIasQuery->irdaAttribName, pIasQuery->irdaAttribName, IAS_MAX_ATTRIBNAME);              
    }
    
    IMsg.Prim = IRLMP_GETVALUEBYCLASS_REQ;
    IMsg.IRDA_MSG_pIasQuery = pvIasQuery;
    IMsg.IRDA_MSG_AttribLen = sizeof(IasBuf) - sizeof(IAS_QUERY);
    
    return IrlmpDown(NULL, &IMsg);    
}    

VOID
PendingIasRequestCallback(
    struct CTEEvent *Event, 
    PVOID Arg)
{
    CTELockHandle   hLock;                    

    UINT            rc;

    CTEGetLock(&IrdaLock, &hLock);
    
    if (pIasIrp != NULL) // Is there an Ias query in progress?
    {
        CTEFreeLock(&IrdaLock, hLock);    
        return;
    }

    while (!IsListEmpty(&IasIrpList)) {

        LIST_ENTRY      *pListEntry;
        PIRP             Irp;

        PVOID            OldCancelRoutine;

        pListEntry = RemoveHeadList(&IasIrpList);
        Irp=CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);

        Irp->Tail.Overlay.ListEntry.Blink=NULL;

        OldCancelRoutine=IoSetCancelRoutine(Irp,NULL);

        if (OldCancelRoutine == NULL) {
            //
            //  the irp is in the process of being canceled
            //
            Irp=NULL;
            continue;
        }

        pIasIrp = Irp;
        break;
    }


    if (pIasIrp == NULL) {

        CTEFreeLock(&IrdaLock, hLock);    
        return;
    }
    
    
    CTEFreeLock(&IrdaLock, hLock);    
    
    rc = SendIasQuery(pIasIrp, IoGetCurrentIrpStackLocation(pIasIrp));    
    
    if (rc != SUCCESS)
    {
        IRDA_MSG    IMsg;
        
        // Make a fake GetValueByClass confirm
        
        IMsg.Prim = IRLMP_GETVALUEBYCLASS_CONF;
        IMsg.IRDA_MSG_IASStatus = IRLMP_IAS_FAILED;
        IrlmpGetValueByClassConf(&IMsg);
    }    
}

NTSTATUS
InitiateIasQuery(
    PIRP                pIrp, 
    PIO_STACK_LOCATION  pIrpSp,
    PIRDA_CONN_OBJ      pConn)
{
    NTSTATUS        Status;
	CTELockHandle   hLock;
    UINT            rc;
    
    DEBUGMSG(DBG_TDI, ("IRDA: InitiateIasQuery() \n"));

    CTEGetLock(&IrdaLock, &hLock);
    
    // only can send 1 IAS query at a time
    
    if (pIasIrp != NULL) {

        PendIrp(&IasIrpList, pIrp, NULL, TRUE);
        
        CTEFreeLock(&IrdaLock, hLock);            
        
    } else {

        //
        //  now a current IAS irp
        //
        pIasIrp = pIrp;
        IoMarkIrpPending(pIrp);

        CTEFreeLock(&IrdaLock, hLock);

        rc = SendIasQuery(pIrp, pIrpSp);

        if (rc != SUCCESS) {
            //
            //  failed,
            //
            Status = ConnectRcToNtStatus(rc);

            DEBUGMSG(DBG_ERROR,
                     ("IRDA: IRLMP_GETVALUEBYCLASS_REQ failed, rc %d\n",
                      rc));

            CTEGetLock(&IrdaLock, &hLock);

            if ((pIasIrp != NULL) && (pIasIrp == pIrp)) {

                pIasIrp = NULL;

                // Retry the the connection if this query is for a
                // connection setup and the query failed because
                // the peer was discovering us

                if (!pConn) {
                    //
                    //  not a connection attempt
                    //
                    CTEFreeLock(&IrdaLock, hLock);

                    pIrp->IoStatus.Status=Status;
                    IoCompleteRequest(pIrp,IO_NO_INCREMENT);
#if DBG
                    pIrp=NULL;
#endif
                    CTEGetLock(&IrdaLock, &hLock);

                } else {

                    if (rc == IRLAP_REMOTE_DISCOVERY_IN_PROGRESS_ERR) {
                        //
                        //  retry, the irp will either be put on a queue for later processing or
                        //  complete if the retry count has been exceeded
                        //
                        CTEFreeLock(&IrdaLock, hLock);

                        RetryConnection(pConn, pIrp);

                    }  else {
                        //
                        //  failed for some other reason, just complete
                        //
                        CTEFreeLock(&IrdaLock, hLock);

                        pIrp->IoStatus.Status=Status;
                        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
#if DBG
                        pIrp=NULL;
#endif
                        CTEGetLock(&IrdaLock, &hLock);

                    }

                }
            } else {

                ASSERT(0);
            }

            if (!IsListEmpty(&IasIrpList))
            {
                if (CTEScheduleEvent(&PendingIasEvent, NULL) == FALSE)
                {
                    CTEAssert(0);
                }
            }

            CTEFreeLock(&IrdaLock, hLock);
        }

    }       
    
    return STATUS_PENDING;
}

VOID
IndicateDisconnect(
    PIRDA_CONN_OBJ      pConn,
    ULONG               DisconnectFlags)
{


    if (pConn->pAddr->pEventDisconnect != NULL) {

        if (pConn->pAddr->pEventDisconnect(
                pConn->pAddr->pEventDisconnectContext,
                pConn->ClientContext, 0, NULL, 0, NULL,
                DisconnectFlags) != STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("  EventDisconnect() failed\r\n"));
            ASSERT(0);
        }
    }
    
    if (DisconnectFlags == TDI_DISCONNECT_ABORT)
    {
        DEBUGMSG(DBG_TDI, ("IRDA: pConn:%p, indicated abortive disconnect to client %p\n",
                 pConn, pConn->ClientContext));
                 
        TdiDisconnect(NULL, NULL, pConn);
    }    
    else
    {
        DEBUGMSG(DBG_TDI, ("IRDA: pConn:%p, indicated graceful disconnect to client %p\n",
                 pConn, pConn->ClientContext));
    }
}
    
NTSTATUS
TdiConnect(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp)
{
    PTDI_CONNECTION_INFORMATION     pReqConnInfo, pRetConnInfo;
    PTDI_REQUEST_KERNEL_CONNECT     pTdiParmsConn;
    PIRDA_CONN_OBJ                  pConn = pIrpSp->FileObject->FsContext;
    PTRANSPORT_ADDRESS              pTranAddr;
    PTDI_ADDRESS_IRDA               pIrdaAddr;
    NTSTATUS                        Status;
    int                             RemLsapSel;

    CTEAssert((UINT_PTR) pIrpSp->FileObject->FsContext2 == TDI_CONNECTION_FILE);
    CTEAssert(IS_VALID_CONN(pConn));
    
    CTEAssert(pConn->ConnState == IRDA_CONN_CREATED ||
              pConn->ConnState == IRDA_CONN_OPENING);
    
    pTdiParmsConn = (PTDI_REQUEST_KERNEL_CONNECT) &(pIrpSp->Parameters);
    pReqConnInfo = pTdiParmsConn->RequestConnectionInformation;
    pTranAddr = (PTRANSPORT_ADDRESS) pReqConnInfo->RemoteAddress;
    pIrdaAddr = (PTDI_ADDRESS_IRDA) pTranAddr->Address[0].Address;
    
    CTEAssert(pTranAddr->TAAddressCount == 1);
        
    // Will either complete the Irp now with one of the following errors:
    // (see InitiateConnection/InitiateIasQuery)
    //
    // LsapSel already in use or link in exclusive mode:
    //  WSAEADDRINUSE - STATUS_ADDRESS_ALREADY_EXISTS
    // Link in use:
    //  WSAEACCESS - STATUS_ACCESS_DENIED
    // Unspecified error:
    //  WSAECONNABORTED - STATUS_CONNECTION_ABORTED
    // Request to device that is not in Irlmp's discovery list
    //  WSAEADDRNOTAVAIL - STATUS_INVALID_ADDRESS_COMPONENT    
    // Blank service name:
    //  WASEAFAULT - STATUS_ACCESS_VIOLATION
    //
    // or pend the irp and complete with (see CompleteConnection):
    //
    // Connect request to disconnected LSAP:
    //  WSAECONNREFUSED - STATUS_CONNECTION_REFUSED
    // Mac media busy or remote discovery in progress &
    // Remote Lsap respsonse timeout:
    //  WSAETIMEDOUT
    // Unspecified error:
    //  WSAECONNABORTED - STATUS_CONNECTION_ABORTED
    
    
    DEBUGMSG(DBG_TDI, ("IRDA: TdiConnect(retry:%d) ConnObj:%p to Dev:%02X%02X%02X%02X Service:%s\n",
             pConn->RetryConnCount, pConn, 
             pIrdaAddr->irdaDeviceID[0],
             pIrdaAddr->irdaDeviceID[1],
             pIrdaAddr->irdaDeviceID[2],
             pIrdaAddr->irdaDeviceID[3],
             pIrdaAddr->irdaServiceName));
    
    // Two ways to connect to remote:
    // 1. Directly to remote LsapSel - remote address is of the form
    //    "LSAP-SELx" where x is the remote LsapSel. Initiate an
    //    IrLMP connection and pend the Irp on the ConnIrpList
    // 2. To a remote service. Query the remote IAS database for the
    //    LsapSel of the given service. Pend the Irp on the IasIrpList.
    //    When the Ias query completes, initiate an IrLMP connection and
    //    pend the Irp on the ConnIrpList.
    
    pConn->RetryConnCount += 1;
    
    RtlCopyMemory(pConn->RemoteAddr.irdaDeviceID,
                   pIrdaAddr->irdaDeviceID, IRDA_DEV_ADDR_LEN);
    strcpy(pConn->RemoteAddr.irdaServiceName,
           pIrdaAddr->irdaServiceName);
           
    pConn->ConnState = IRDA_CONN_OPENING;
    
    if (pIrdaAddr->irdaServiceName[0] == 0)
    {
        Status = STATUS_ACCESS_VIOLATION;
    }    
    else if (pConn->IsServer)
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }    
    else if ((RemLsapSel = 
                GetLsapSelServiceName(pIrdaAddr->irdaServiceName)) != 0)
    {
        if (RemLsapSel == -1)
        {
            DEBUGMSG(DBG_TDI, ("IRDA: TdiConnect() failed, bad LsapSel in service name\n"));
            Status = STATUS_INVALID_ADDRESS_COMPONENT;
        }
        else
        {
            pConn->RemoteLsapSel = RemLsapSel;
            Status = InitiateConnection(pConn, pIrp);
        }        
    }
    else
    {
        Status = InitiateIasQuery(pIrp, pIrpSp, pConn);
    }
    
    if (Status != STATUS_PENDING)
    {
        pConn->ConnState = IRDA_CONN_CREATED;    
        
        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);        
    }
    
    return Status;
}

//*************************************************************************
//
//  Irda's disconnect handler. If passed a connection object, then this is
//  a disconnect generated internally by the stack. Otherwise called by
//  client to disconnect peer.
//  This isolates the cleanup code.
NTSTATUS
TdiDisconnect(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp,
    PIRDA_CONN_OBJ      pConn)
{
    CTELockHandle                   hLock;
    PTDI_REQUEST_KERNEL_DISCONNECT  pReqDisc = NULL;

    if (!pConn)
    {
        // AFD initated, connection object in the Irp
        CTEAssert(pIrp);
        pConn = pIrpSp->FileObject->FsContext;
        pReqDisc = (PTDI_REQUEST_KERNEL_DISCONNECT) &pIrpSp->Parameters;
    }

    DEBUGMSG(DBG_TDI, ("IRDA: TdiDisconnect(%s) ConnObj:%p State %d Irlmp:%p\n",
        pIrp ? "external":"internal", pConn, pConn->ConnState, pConn->IrlmpContext));
    
    CTEAssert(IS_VALID_CONN(pConn));
        
    GET_CONN_LOCK(pConn, &hLock);
    
    ConnectionUp(pConn, FALSE);

    while (!IsListEmpty(&pConn->RecvBufList))
    {
        LIST_ENTRY      *pListEntry;
        PIRDA_RECV_BUF  pRecvBuf;
            
        pListEntry = RemoveHeadList(&pConn->RecvBufList);
        
        ASSERT(pListEntry);

        pRecvBuf = CONTAINING_RECORD(pListEntry, IRDA_RECV_BUF, Linkage);
        FreeIrdaBuf(RecvBufPool, pRecvBuf);
    }

    pConn->ConnState = IRDA_CONN_CREATED;
    
    FREE_CONN_LOCK(pConn, hLock);
                    
    IrdaDisconnectIrlmp(pConn);
                
    if (pIrp)
    {
        // Indicate the disconnect back to the client
        // This is because we don't support half close.
        // so AFD may hang the app if the app has done
        // a shutdown(SD_SEND). Really, AFD should handle
        // this correctly because I don't support 
        // TDI_SERVICE_ORDERLY_RELEASE. Vadim admits that
        // AFD should handle this but he doesn't want to 
        // break legacy transports.

        if (pConn->pAddr->pEventDisconnect != NULL) {

            pConn->pAddr->pEventDisconnect(
                pConn->pAddr->pEventDisconnectContext,
                pConn->ClientContext, 0, NULL, 0, NULL,
                TDI_DISCONNECT_ABORT);
        }
        
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = STATUS_SUCCESS;    
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }    

    return STATUS_SUCCESS;
}

NTSTATUS
TdiSend(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp) 
{
    PIRDA_CONN_OBJ  pConn = pIrpSp->FileObject->FsContext;
    CTELockHandle   hLock;    
    NTSTATUS        Status;

    CTEAssert(((UINT_PTR) pIrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);
    CTEAssert(IS_VALID_CONN(pConn));

    // IrLMP likes passive level only
    
    if (KeGetCurrentIrql() >= DISPATCH_LEVEL)
    {
        DEBUGMSG(DBG_TDI, ("IRDA: TdiSend() at DISPATCH_LEVEL\n"));
    
        GET_CONN_LOCK(pConn, &hLock);
    
        PendIrp(&pConn->SendIrpPassiveList, pIrp, pConn, TRUE);

#if DBG
        pIrp=NULL;
#endif

        Status=STATUS_PENDING;

        if (CTEScheduleEvent(&pConn->SendEvent, pConn) == FALSE) {

            LIST_ENTRY          *pListEntry;

            pListEntry = RemoveHeadList(&pConn->SendIrpPassiveList);
            pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);

            if (IoSetCancelRoutine(pIrp, NULL) == NULL) {
                //
                // Cancel routine is going to run. Mark Irp so cancel
                // routine won't attempt to remove it from the list
                //
                pIrp->Tail.Overlay.ListEntry.Flink = NULL;

            } else {

                pIrp->IoStatus.Status=STATUS_UNEXPECTED_NETWORK_ERROR;
                FREE_CONN_LOCK(pConn, hLock);
                IoCompleteRequest(pIrp,IO_NO_INCREMENT);
#if DBG
                pIrp=NULL;
#endif
                GET_CONN_LOCK(pConn, &hLock);
            }
            ASSERT(0);
        }
        
        FREE_CONN_LOCK(pConn, hLock);
        
        if (Status != STATUS_PENDING)
        {
            pIrp->IoStatus.Information = 0;
            pIrp->IoStatus.Status = Status;    
            IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
        }   
        
        return Status;
    }
    else
    {
        return TdiSendAtPassive(pIrp, pIrpSp);
    }    
}

VOID
TdiSendAtPassiveCallback(struct CTEEvent *Event, PVOID Arg)
{
    PIRDA_CONN_OBJ      pConn = Arg;
    CTELockHandle       hLock;      
    LIST_ENTRY          *pListEntry;
    PIRP                pIrp;
      
    CTEAssert(IS_VALID_CONN(pConn));
    
    GET_CONN_LOCK(pConn, &hLock);    
    
    while (!IsListEmpty(&pConn->SendIrpPassiveList))
    {    
        pListEntry = RemoveHeadList(&pConn->SendIrpPassiveList);
        
        ASSERT(pListEntry);        
                
        pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
                
        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            // Cancel routine is going to run. Mark Irp so cancel
            // routine won't attempt to remove it from the list
            pIrp->Tail.Overlay.ListEntry.Flink = NULL;
            CTEFreeLock(&IrdaLock, hLock);
            continue;
        }    

        FREE_CONN_LOCK(pConn, hLock);        
        
        TdiSendAtPassive(pIrp, IoGetCurrentIrpStackLocation(pIrp));
        
        GET_CONN_LOCK(pConn, &hLock);
    }
    
    FREE_CONN_LOCK(pConn, hLock);    
}    


NTSTATUS
TdiSendAtPassive(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp)
{
    PTDI_REQUEST_KERNEL_SEND    pSendParms = (PTDI_REQUEST_KERNEL_SEND) &pIrpSp->Parameters;
    PIRDA_CONN_OBJ              pConn = pIrpSp->FileObject->FsContext;
    NTSTATUS                    Status;
    IRDA_MSG                    *pMsg;    

    CTEAssert(((UINT_PTR) pIrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);
    CTEAssert(IS_VALID_CONN(pConn));

    if (pConn->pAddr->UseIrlptMode &&
        pSendParms->SendLength > (ULONG)pConn->SendMaxSDU)
    {
        DEBUGMSG(DBG_ERROR, ("IRDA: TdiSend() error buffer overflow, max %d\n",
                    pConn->SendMaxSDU));
        Status = STATUS_BUFFER_OVERFLOW;
    }
    else if (!pSendParms->SendLength)
    {
        DEBUGMSG(DBG_ERROR, ("IRDA: TdiSend() length of 0\n"));
        Status = STATUS_SUCCESS;
    }
    else if (pConn->ConnState != IRDA_CONN_OPEN)
    {
        DEBUGMSG(DBG_TDI, ("IRDA: TdiSend() ConnObj:%p error conn reset\n",
                  pConn));
        Status = STATUS_CONNECTION_RESET; //STATUS_CONNECTION_ABORTED;
        
        if (pConn->ConnState == IRDA_CONN_CLOSING)
        {
            DEBUGMSG(DBG_ERROR, ("IRDA: Send after indicated disconnect, indicate abortive disconnect\n"));

            // We've indicated a graceful disconnect to AFD, but AFD
            // was in the middle of sending. Because Irda doesn't support
            // graceful closes, we have to now indicate an abortive
            // disconnect to AFD.            
            IndicateDisconnect(pConn, TDI_DISCONNECT_ABORT);
        }
    }
    else if ((pMsg = AllocIrdaBuf(IrdaMsgPool)) == NULL)
    {
        DEBUGMSG(DBG_TDI, ("IRDA: TdiSend() ConnObj:%p  returning STATUS_INSUFFICIENT_RESOURCES\n",
                    pConn));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        UINT            rc;
        CTELockHandle   hLock;
        
        // We can't allow the cancelling of send IRPs because
        // the stack may have passed ownership of the MDL contained
        // in this IRP to the NDIS driver. 
        
        GET_CONN_LOCK(pConn, &hLock);
        
        InsertTailList(&pConn->SendIrpList, &pIrp->Tail.Overlay.ListEntry);

        IoMarkIrpPending(pIrp);
        
        FREE_CONN_LOCK(pConn, hLock);
        
        Status = STATUS_PENDING;
        

        pIrp->IoStatus.Information = pSendParms->SendLength;
        
        DEBUGMSG(DBG_TDI, ("IRDA: TdiSend() ConnObj:%p %d bytes, pend Irp:%p\n",
                 pConn, pSendParms->SendLength, pIrp));    

        pMsg->Prim = IRLMP_DATA_REQ;
        pMsg->DataContext = pIrp->MdlAddress;
        pMsg->IRDA_MSG_pTdiSendCompCnxt = pIrp;
        pMsg->IRDA_MSG_IrCOMM_9Wire = pConn->pAddr->Use9WireMode;
        
        if ((rc = IrlmpDown(pConn->IrlmpContext, pMsg)) != SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("IRDA: IRLMP_DATA_REQ failed %d\n", rc));

            pIrp->IoStatus.Information = 0;
            pIrp->IoStatus.Status = STATUS_CONNECTION_RESET;

            GET_CONN_LOCK(pConn, &hLock);
                        
            RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

            FREE_CONN_LOCK(pConn, hLock);            
            //
            //  complete it now
            //
            IoCompleteRequest(pIrp,IO_NO_INCREMENT);
            pIrp=NULL;

            FreeIrdaBuf(IrdaMsgPool, pMsg);
        }

        return STATUS_PENDING;
    }

                      
    pIrp->IoStatus.Information = 0;                        
    pIrp->IoStatus.Status = Status;    
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
    return Status;
}

//*************************************************************************
//
// Irda's receive handler. Called to resume receiving of data after AFD
// or client has stopped taking indicated data (see IrlmpDataInd).
// Data will have been buffered on the connection's RecvBufList.
//
NTSTATUS
TdiReceive(
    PIRP                        pIrp,
    PIO_STACK_LOCATION          pIrpSp)
{
    PTDI_REQUEST_KERNEL_RECEIVE pRecvReq;
    PIRDA_CONN_OBJ              pConn = pIrpSp->FileObject->FsContext;
    ULONG                       BytesTaken = 0;
	CTELockHandle               hLock;
    PIRDA_RECV_BUF              pRecvBuf;
    LIST_ENTRY                  *pListEntry, *pListEntryNext;
    NTSTATUS                    Status= STATUS_SUCCESS;
    PIRDA_ADDR_OBJ              pAddr;
        
    DEBUGMSG(DBG_TDI, ("IRDA: TdiReceive() ConnObj:%p. credits=%d\n", pConn, pConn->TtpRecvCreditsLeft));

    CTEAssert(IS_VALID_CONN(pConn));
    
    pAddr = pConn->pAddr;
    
    CTEAssert(IS_VALID_ADDR(pAddr));
    
    GET_CONN_LOCK(pConn, &hLock);
        
    pRecvReq = (PTDI_REQUEST_KERNEL_RECEIVE) &(pIrpSp->Parameters);    

    if (!IsListEmpty(&pConn->RecvBufList)) {
        //
        //  the list is not empty
        //
        pListEntry = RemoveHeadList(&pConn->RecvBufList);

        pRecvBuf = CONTAINING_RECORD(pListEntry, IRDA_RECV_BUF, Linkage);

        //
        //  copy what we can
        //
        Status=TdiCopyBufferToMdl(&pRecvBuf->Data[0],
                               pRecvBuf->Offset,
                               pRecvBuf->Len, 
                               pIrp->MdlAddress, 
                               0, 
                               &BytesTaken
                               );

        if (Status != STATUS_SUCCESS) {
            //
            //  some sort of problem
            //
            if (Status == STATUS_BUFFER_OVERFLOW) {
                //
                //  the irp could no hold all the data, need to adjust the recvbuf
                //  values to indace what is left
                //
                pRecvBuf->Len    -= BytesTaken;
                pRecvBuf->Offset += BytesTaken;

                //
                //  need to put it back on the list
                //
                InsertHeadList(&pConn->RecvBufList, pListEntry);

                DEBUGMSG(DBG_TDI, ("  RecvBuf copied only %d of %d\n",
                      BytesTaken, pRecvBuf->Len));


            } else {
                //
                //  could not get a system address for the mdl, just return the status
                //
                InsertHeadList(&pConn->RecvBufList, pListEntry);

                BytesTaken=0;

                DEBUGMSG(DBG_TDI, ("  RecvBuf could not map MDL\n"));

            }
        } else {
            //
            //  copied it all
            //
            DEBUGMSG(DBG_TDI, ("  RecvBuf %p copied all %d\n", pRecvBuf, BytesTaken));

        }

        FREE_CONN_LOCK(pConn, hLock);

        pIrp->IoStatus.Information = BytesTaken;
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
        pIrp=NULL;

        GET_CONN_LOCK(pConn, &hLock);    
    }
    else
    {
        DEBUGMSG(DBG_ERROR, ("IRDA: Pending TDI_RECEIVE Irp %p\n", pIrp));

        PendIrp(&pConn->RecvIrpList, pIrp, pConn, TRUE);
        pIrp=NULL;
        Status=STATUS_PENDING;
        
        FREE_CONN_LOCK(pConn, hLock);

        return Status; 
    }
    
    // Still more buffered data, indicate to client through EventReceive handler

    while (!(IsListEmpty(&pConn->RecvBufList)) && Status != STATUS_DATA_NOT_ACCEPTED)
    {
        pListEntry = RemoveHeadList(&pConn->RecvBufList);
        
        FREE_CONN_LOCK(pConn, hLock);
                
        pRecvBuf = CONTAINING_RECORD(pListEntry, IRDA_RECV_BUF, Linkage);
        
        Status = pAddr->pEventReceive(
                    pAddr->pEventReceiveContext,
                    pConn->ClientContext,
                    TDI_RECEIVE_NORMAL | \
                    (pRecvBuf->FinalSeg ? TDI_RECEIVE_ENTIRE_MESSAGE : 0),                    
                    pRecvBuf->Len,
                    pRecvBuf->Len,
                    &BytesTaken,
                    &pRecvBuf->Data[pRecvBuf->Offset],
                    &pIrp);     
     
        DEBUGMSG(DBG_TDI, ("  Next RecvBuf %p, indicated %d\n",
                    pRecvBuf, pRecvBuf->Len));


        switch (Status)
        {
          case STATUS_MORE_PROCESSING_REQUIRED:
        
            CTEAssert(BytesTaken == 0);
            CTEAssert(pIrp);
    
            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    
            pRecvReq = (PTDI_REQUEST_KERNEL_RECEIVE) &pIrpSp->Parameters;
        
            CTEAssert(pRecvReq->ReceiveLength >= pRecvBuf->Len);
    
            TdiCopyBufferToMdl(
                    &pRecvBuf->Data[pRecvBuf->Offset], 
                    0, 
                    pRecvBuf->Len, 
                    pIrp->MdlAddress, 
                    0, 
                    &BytesTaken);
                      
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = BytesTaken;
            IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);  
            
            // fall through
          case STATUS_SUCCESS:
            CTEAssert(BytesTaken == pRecvBuf->Len);

            FreeIrdaBuf(RecvBufPool, pRecvBuf);
            DEBUGMSG(DBG_TDI, ("  RecvBuf copied %d\n", BytesTaken));
            break;
        
          case STATUS_DATA_NOT_ACCEPTED:
            CTEAssert(BytesTaken == 0);
            DEBUGMSG(DBG_TDI, ("  No bytes taken\n"));

            GET_CONN_LOCK(pConn, &hLock);            

            InsertHeadList(&pConn->RecvBufList, pListEntry);
            
            FREE_CONN_LOCK(pConn, hLock);
            
            break;
            
          default:
            CTEAssert(0);    
        }    

        GET_CONN_LOCK(pConn, &hLock);            
    }

    // Has the client taken all buffered data?
    
    if (IsListEmpty(&pConn->RecvBufList))
    {
        CTEAssert(pConn->RecvBusy)
        
        pConn->RecvBusy = FALSE;

        if (pConn->ConnState == IRDA_CONN_OPEN)
        {
            // Start up peer again
            if (pConn->TtpRecvCreditsLeft <= TTP_CREDIT_ADVANCE_THRESH)
            {
                IRDA_MSG IMsg;
                int      CreditsLeft;
                
                CreditsLeft = pConn->TtpRecvCreditsLeft;
                pConn->TtpRecvCreditsLeft = TTP_RECV_CREDITS;            
                            
                FREE_CONN_LOCK(pConn, hLock);
    
                IMsg.Prim = IRLMP_MORECREDIT_REQ;
                IMsg.IRDA_MSG_TtpCredits = TTP_RECV_CREDITS - CreditsLeft;
                
                #if DBG
                pConn->CreditsExtended += (TTP_RECV_CREDITS - CreditsLeft);        
                #endif
                
                IrlmpDown(pConn->IrlmpContext, &IMsg);

                return STATUS_SUCCESS;
            }
        }
        else if (pConn->ConnState == IRDA_CONN_CLOSING)
        {
            ULONG DiscFlags = TDI_DISCONNECT_RELEASE;
            
            if (!IsListEmpty(&pConn->SendIrpList))
            {
                DEBUGMSG(DBG_TDI, ("  SendIrpList not empty, indicate abortive disconnect\n"));            
                DiscFlags = TDI_DISCONNECT_ABORT;
            }
                
            FREE_CONN_LOCK(pConn, hLock);
            
            // all buffer data has been delivered for the connection
            // that has was previously disconnected by the peer. Notify client
            // of the disconnect
            
            IndicateDisconnect(pConn, DiscFlags);
            
            return STATUS_SUCCESS;
        }
    }
    
    FREE_CONN_LOCK(pConn, hLock);

    return STATUS_SUCCESS;
}    

ULONG
GetMdlChainByteCount(
    PMDL    pMdl)
{
	ULONG   Count = 0;

	while (pMdl != NULL)
    {
		Count += MmGetMdlByteCount(pMdl);
		pMdl = pMdl->Next;
	}

	return(Count);
}

//*************************************************************************
// 
//  Copy discovered device information from internal buffer to
//  user buffer in Winsock format (extracting hints and characters
//  set)
//

VOID
CopyDevToDevInfo(PIRDA_DEVICE_INFO pDevInfo, IRDA_DEVICE *pDevice)
{                  
    BOOLEAN GotHint1 = FALSE;
    BOOLEAN GotHint2 = FALSE;
    BOOLEAN GotChar  = FALSE;
    BOOLEAN MoreHints = FALSE;
    int     i, j;
                         
    RtlCopyMemory(pDevInfo->irdaDeviceID,pDevice->DevAddr, IRDA_DEV_ADDR_LEN);
         
    CTEMemSet(pDevInfo->irdaDeviceName, 0, sizeof(pDevInfo->irdaDeviceName));                                     
    pDevInfo->irdaDeviceHints1 = 0;
    pDevInfo->irdaDeviceHints2 = 0;
    pDevInfo->irdaCharSet = 0;
                        
    j = 0;
                                     
    for (i = 0; i < pDevice->DscvInfoLen; i++)
    {
        if (GotHint1 == FALSE)
        {
            GotHint1 = TRUE;
            pDevInfo->irdaDeviceHints1 = pDevice->DscvInfo[i];
                                
            if ((pDevInfo->irdaDeviceHints1) & 0x80)
                MoreHints = TRUE;
                                    
            continue;
        }    
                            
        if (GotHint2 == FALSE && MoreHints)
        {
            GotHint2 = TRUE;
                                
            pDevInfo->irdaDeviceHints2 = pDevice->DscvInfo[i];
                                
            if ((pDevInfo->irdaDeviceHints2) & 0x80)
                MoreHints = TRUE;
            else
                MoreHints = FALSE;    
                                    
            continue;
        }
                            
        if (MoreHints)
        {
            if ((pDevice->DscvInfo[i]) & 0x80)
                MoreHints = TRUE;
            else
                MoreHints = FALSE;
                                    
            continue;    
        }            
                                
        if (GotChar == FALSE)
        {
            GotChar = TRUE;
                                
            pDevInfo->irdaCharSet = pDevice->DscvInfo[i];
                             
            continue;   
        }  
                            
        pDevInfo->irdaDeviceName[j++] = pDevice->DscvInfo[i];  
                            
        if (j > sizeof(pDevInfo->irdaDeviceName))
            break;
    }
}    
//*************************************************************************
//
// Run through the ConnIrpList and find the Irp associated with the 
// given connection object
//
PIRP
GetIrpOnConnIrpList(PIRDA_CONN_OBJ pConn)
{
    PIRDA_CONN_OBJ      pConnOnList;
  	CTELockHandle       hLock;    
    PIO_STACK_LOCATION  pIrpSp;   
    LIST_ENTRY          *pListEntry;     
    PIRP                pIrp = NULL;
    
    CTEGetLock(&IrdaLock, &hLock);

    // Remove the connect irp from the ConnIrpList
        
    for (pListEntry = ConnIrpList.Flink;
         pListEntry != &ConnIrpList;
         pListEntry = pListEntry->Flink)
    {
        pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        
        pConnOnList = (PIRDA_CONN_OBJ) pIrpSp->FileObject->FsContext;

        if (pConnOnList == pConn) {

            break;
        }
                               
        pIrp = NULL;
    }

    if (pIrp != NULL) {
        //
        //  we got a irp
        //

#if DBG
        pIrp->IoStatus.Information=0;
#endif
    
        if (IoSetCancelRoutine(pIrp, NULL) == NULL) {

            // It was already cancelled or is in the process

            DEBUGMSG(DBG_TDI, ("IRDA: Connect Irp not on list, must have been cancelled\n"));
            pIrp=NULL;

        } else {

            RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
        }
    }

    CTEFreeLock(&IrdaLock, hLock);        
    
    return pIrp;
}
//*************************************************************************
//
//  TimerExpiration routine to retry a connection attempt do to
//  remote discovery in progress
//
VOID
RetryConnTimerExp(PVOID Context)
{
    PIRDA_CONN_OBJ      pConn = Context;   
    PIRP                pIrp;
    
    DEBUGMSG(DBG_TDI, ("IRDA: RetryConnect timer expired\n"));

    if (pIrp = GetIrpOnConnIrpList(pConn))
    {
        TdiConnect(pIrp, IoGetCurrentIrpStackLocation(pIrp));        
    }        
    
    REFDEL(&pConn->RefCnt, 'RMIT');
}

//************************************************************************
//
//  RetryConnection if remote discovery in progress.
//  Returns:
//    STATUS_PENDING - a retry will be attempted. The Irp is placed on the
//    ConnIrpList.
//    STATUS_CANCELLED - the Irp could not be pended because it was cancelled
//    STATUS_IO_TIMEOUT - no more retries left.
//
VOID
RetryConnection(PIRDA_CONN_OBJ pConn, PIRP pIrp)
{
    CTELockHandle   hLock;
    NTSTATUS        Status = STATUS_IO_TIMEOUT;

    IoMarkIrpPending(pIrp);
    if (pConn->RetryConnCount <= BUSY_LINK_CONN_RETRIES)
    {
        DEBUGMSG(DBG_TDI, ("IRDA: Media busy or remote dscv in progress, retry(%d) connection\n",
                 pConn->RetryConnCount));

        IrdaDisconnectIrlmp(pConn);

#if DBG
        pIrp->IoStatus.Information=2;
#endif
        PendIrp(&ConnIrpList, pIrp, NULL, FALSE);
        Status=STATUS_PENDING;
        
        pConn->RetryConnTimer.Context = pConn;

        REFADD(&pConn->RefCnt, 'RMIT');

        IrdaTimerStart(&pConn->RetryConnTimer);

    } else {

        pIrp->IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    }
    
    return;
}
    
//*************************************************************************
//
// Asyncronous completetion of a client connection request.
// This routine also completes a failed connection.
//
VOID
CompleteConnection(PIRDA_CONN_OBJ pConn, IRDA_MSG *pMsg)
{
    PIRP                pIrp;
    BOOLEAN             RetryConn = FALSE;
        
    if ((pIrp = GetIrpOnConnIrpList(pConn)) == NULL)
    {
        DbgPrint("IRDA: CompleteConnection: could not find irp\n");
        ASSERT(pIrp);
    }
    else    
    {         
        if (pMsg->Prim == IRLMP_DISCONNECT_IND)
        {
            pConn->ConnState = IRDA_CONN_CREATED;
            
            switch (pMsg->IRDA_MSG_DiscReason)
            {
                case IRLMP_DISC_LSAP:
                    // WSAECONNREFUSED                
                    pIrp->IoStatus.Status = STATUS_CONNECTION_REFUSED;
                    break;
                    
                case IRLMP_IRLAP_REMOTE_DISCOVERY_IN_PROGRESS:
                case IRLMP_MAC_MEDIA_BUSY:    
                    RetryConn = TRUE;
                
                case IRLMP_IRLAP_CONN_FAILED:   
                case IRLMP_NO_RESPONSE_LSAP:
                    // WASETIMEDOUT
                    pIrp->IoStatus.Status = STATUS_IO_TIMEOUT;
                    break;
                    
                default:
                    // WSECONNABORTED
                    pIrp->IoStatus.Status = STATUS_CONNECTION_RESET; //STATUS_CONNECTION_ABORTED;
            }

            if (RetryConn) {
                //
                //  the irp will be queued or complete, by this function
                //
                RetryConnection(pConn, pIrp);

                return;
            }

        }
        else // IRLMP_CONNECT_CONF
        {
            pConn->SendMaxSDU = pMsg->IRDA_MSG_MaxSDUSize;
            pConn->SendMaxPDU = pMsg->IRDA_MSG_MaxPDUSize;
        
            pConn->ConnState = IRDA_CONN_OPEN;        
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            
            DEBUGMSG(DBG_TDI, ("IRDA: Completing TdiConnect co:%p\n", pConn));
            
            ConnectionUp(pConn, TRUE);
        }

        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);       
    }
}

//*************************************************************************
//
//
//
VOID
CompleteDscvIrpList(LIST_ENTRY *pIrpList, IRDA_MSG *pMsg)
{
    PIO_STACK_LOCATION  pIrpSp;
    PDEVICELIST         pDevList;
    PIRP                pIrp;
    LIST_ENTRY          *pListEntry;
    ULONG               BytesWritten;
    ULONG               BufLen;
    IRDA_DEVICE         *pDevice;
    ULONG               DevCnt;
    NTSTATUS            Status;
	CTELockHandle       hLock;

    CTEGetLock(&IrdaLock, &hLock);

    while (!IsListEmpty(pIrpList)) {
        
        pListEntry = RemoveHeadList(pIrpList);

        pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
                
        if (IoSetCancelRoutine(pIrp, NULL) == NULL) {

            //
            // Cancel routine is going to run. Mark Irp so cancel
            // routine won't attempt to remove it from the list
            //
            pIrp->Tail.Overlay.ListEntry.Flink = NULL;

        } else {
            //
            //  not canceled
            //
            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

            pDevList = pIrp->AssociatedIrp.SystemBuffer;

            BufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

            if (BufLen < sizeof(IRDA_DEVICE_INFO))
            {
                DEBUGMSG(DBG_DISCOVERY, ("IRDA: IRLMP_DISCOVERY_REQ failed, buf too small\n"));
                BytesWritten = 0;
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            else if (pMsg->IRDA_MSG_DscvStatus != IRLAP_DISCOVERY_COMPLETED)
            {
                DEBUGMSG(DBG_DISCOVERY, ("IRDA: IRLMP_DISCOVERY_REQ failed\n"));
                BytesWritten = 0;
                Status = STATUS_UNEXPECTED_NETWORK_ERROR;
            }
            else
            {
                //
                //  start with the device count at the begining of the list
                //
                BytesWritten = sizeof(pDevList->numDevice);

                DevCnt = 0;

                if (pMsg->IRDA_MSG_pDevList != NULL)
                {
                    for (pDevice = (IRDA_DEVICE * ) pMsg->IRDA_MSG_pDevList->Flink;
                         (LIST_ENTRY *) pDevice != pMsg->IRDA_MSG_pDevList;
                        pDevice = (IRDA_DEVICE *) pDevice->Linkage.Flink)
                    {
                        if (BufLen <  (BytesWritten + sizeof(IRDA_DEVICE_INFO)))
                        {
                            DEBUGMSG(DBG_ERROR, ("IRDA: Found more devices, but user buffer too small.\n"));
                            break;
                        }

                        CopyDevToDevInfo(&pDevList->Device[DevCnt], pDevice);

                        BytesWritten += sizeof(IRDA_DEVICE_INFO);

                        DevCnt++;
                    }
                }

                pDevList->numDevice = DevCnt;

                Status = STATUS_SUCCESS;
            }

            CTEFreeLock(&IrdaLock, hLock);

            pIrp->IoStatus.Status = Status;
            pIrp->IoStatus.Information = BytesWritten;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);

            CTEGetLock(&IrdaLock, &hLock);
        }
    }

    CTEFreeLock(&IrdaLock, hLock);
}
//*************************************************************************
//
// Process IRMLP_DISCOVERY_CONFIRM - Completes client discovery
// request Irp stored on DscvIrpList
//
VOID
IrlmpDiscoveryConf(IRDA_MSG *pMsg)
{
    CTELockHandle   hLock;

    DEBUGMSG(DBG_DISCOVERY, ("IRDA: IRLMP_DISCOVERY_CONF\n"));
    
    // Complete regular discovery Irp list
    CompleteDscvIrpList(&DscvIrpList, pMsg);

    CTEGetLock(&IrdaLock, &hLock);

    // Complete lazy discoveries if device list has changed
    if (!IsListEmpty(&LazyDscvIrpList))
    {
        IRDA_DEVICE *pDevice;    
        UINT        CurrLazyDscvMacAddrs = 0;
        
        // Lazy discovery Irps are completed if the newly discovered
        // device list has changed since the last discovery.
        // We determine that the device list has changed by storing
        // the value of the Mac addresses added together from the
        // last discovery
        
        if (pMsg->IRDA_MSG_DscvStatus == IRLAP_DISCOVERY_COMPLETED)
        {
            for (pDevice = (IRDA_DEVICE * ) pMsg->IRDA_MSG_pDevList->Flink;
                 (LIST_ENTRY *) pDevice != pMsg->IRDA_MSG_pDevList;
                 pDevice = (IRDA_DEVICE *) pDevice->Linkage.Flink)
            {
                CurrLazyDscvMacAddrs += *(UINT*)pDevice->DevAddr;
            }
        
            if (CurrLazyDscvMacAddrs == LazyDscvMacAddrs)
            {
                CTEFreeLock(&IrdaLock, hLock);

                return;
            }    
            LazyDscvMacAddrs = CurrLazyDscvMacAddrs;
        }    
 


        LazyDscvTimerRunning = FALSE;
        
        CTEFreeLock(&IrdaLock, hLock);                                    
                        
        IrdaTimerStop(&LazyDscvTimer);
        
        CompleteDscvIrpList(&LazyDscvIrpList, pMsg);

        CTEGetLock(&IrdaLock, &hLock);
    }

    CTEFreeLock(&IrdaLock, hLock);
}

//*************************************************************************
// 
// Process IRLMP_CONNECT_IND. Call client connect handler if we find
// matching address object
//
VOID
IrlmpConnectInd(IRDA_MSG *pMsg)
{
    PIRDA_ADDR_OBJ  pAddr;
    CTELockHandle   hLock;
    IRDA_MSG        IMsg;
    PIRDA_CONN_OBJ  pConn;
    BOOLEAN         AcceptConnection = FALSE;            
    PIRP            pAcceptIrp = NULL;
            
    DEBUGMSG(DBG_TDI, ("IRDA: IRLMP_CONNECT_IND\n"));

    // Get the LinkStatus immediately so we'll have the link speed
    // when we indicate the incoming connection to RasIrda which
    // immediately requests link speed through an ioctl.
                
    IMsg.Prim = IRLAP_STATUS_REQ;
    IMsg.IRDA_MSG_pLinkStatus = &LinkStatus;
    IrlmpDown(pMsg->IRDA_MSG_pContext, &IMsg);
            
    CTEGetLock(&IrdaLock, &hLock);
            
    // Find the address object with LocalLsapSel that matches
    // the one in the CONNECT_IND
    for (pAddr = AddrObjList; pAddr != NULL; pAddr = pAddr->pNext)
    {
        if (pAddr->LocalLsapSel == pMsg->IRDA_MSG_LocalLsapSel)
            break;
    }        
                        
    CTEFreeLock(&IrdaLock, hLock);                        
    
    if (pAddr && pAddr->pEventConnect)
    {
        UCHAR               RemAddrBuf[sizeof(TRANSPORT_ADDRESS) + sizeof(TDI_ADDRESS_IRDA)-1];
        PTRANSPORT_ADDRESS  pRemAddr = (PTRANSPORT_ADDRESS) RemAddrBuf;
        PTDI_ADDRESS_IRDA   pIrdaAddr = (PTDI_ADDRESS_IRDA) pRemAddr->Address[0].Address;
        NTSTATUS            Status;
        CONNECTION_CONTEXT  ClientContext;

        pRemAddr->TAAddressCount = 1;
        pRemAddr->Address[0].AddressLength = sizeof(SOCKADDR_IRDA) - 2;
        pRemAddr->Address[0].AddressType = AF_IRDA;
                
        RtlCopyMemory(pIrdaAddr->irdaDeviceID,
                      pMsg->IRDA_MSG_RemoteDevAddr,
                      IRDA_DEV_ADDR_LEN);
                              
        SetLsapSelAddr(pMsg->IRDA_MSG_RemoteLsapSel,
                       pIrdaAddr->irdaServiceName);              
                               

                               
        Status = pAddr->pEventConnect(
                        pAddr->pEventConnectContext,
                        sizeof(RemAddrBuf),
                        pRemAddr,
                        0, NULL, 0, NULL,
                        &ClientContext,
                        &pAcceptIrp);
            
        if (Status != STATUS_MORE_PROCESSING_REQUIRED)
        {
            DEBUGMSG(DBG_ERROR, ("IRDA: EventConnect failed %X\n", Status));
        }
        else    
        {
            ASSERT(pAcceptIrp);
            
            CTEGetLock(&IrdaLock, &hLock);
            
            for (pConn = pAddr->ConnObjList; 
                 pConn != NULL; 
                 pConn = pConn->pNext)
            {
                if (pConn->ClientContext == ClientContext)
                    break;
            }
                    
            if (!pConn)
            {
                CTEAssert(0);
                pAcceptIrp->IoStatus.Status = STATUS_INVALID_ADDRESS_COMPONENT;                
                
                CTEFreeLock(&IrdaLock, hLock);                                        
                
                IoCompleteRequest (pAcceptIrp, IO_NETWORK_INCREMENT);
            }
            else    
            {
                ASSERT(pConn->ConnState == IRDA_CONN_CREATED);
        
                pConn->ConnState             = IRDA_CONN_OPEN;
                pConn->RemoteLsapSel         = pMsg->IRDA_MSG_RemoteLsapSel;
                pConn->SendMaxSDU            = pMsg->IRDA_MSG_MaxSDUSize;
                pConn->SendMaxPDU            = pMsg->IRDA_MSG_MaxPDUSize;
                pConn->IrlmpContext          = pMsg->IRDA_MSG_pContext;
                pConn->TtpRecvCreditsLeft    = TTP_RECV_CREDITS;
                /* IRDA_MSG_pQOS ignored */

                RtlCopyMemory(&pConn->RemoteAddr, 
                              pIrdaAddr, sizeof(TDI_ADDRESS_IRDA));

                pAcceptIrp->IoStatus.Status = STATUS_SUCCESS;
                
                CTEFreeLock(&IrdaLock, hLock);                                        
                
                IoCompleteRequest (pAcceptIrp, IO_NETWORK_INCREMENT);
                                        
                DEBUGMSG(DBG_TDI, ("  ConnObj:%p connected, Loc:%s,%d Rem:%s,%d\n",
                         pConn, 
                         pConn->LocalAddr.irdaServiceName,
                         pConn->LocalLsapSel,
                         pConn->RemoteAddr.irdaServiceName,
                         pConn->RemoteLsapSel));
                        
                AcceptConnection = TRUE;
            }    
        }
    }
            
    if (AcceptConnection)
    {
        IMsg.Prim                 = IRLMP_CONNECT_RESP;
        IMsg.IRDA_MSG_pConnData   = NULL;      
        IMsg.IRDA_MSG_ConnDataLen = 0;      
        IMsg.IRDA_MSG_pContext    = pConn;      
        IMsg.IRDA_MSG_MaxSDUSize  = TTP_RECV_MAX_SDU;
        IMsg.IRDA_MSG_TtpCredits  = TTP_RECV_CREDITS;
        
        #if DBG
        pConn->CreditsExtended += TTP_RECV_CREDITS;        
        #endif
        
        ConnectionUp(pConn, TRUE);            
    }
    else
    {
        DEBUGMSG(DBG_TDI, ("  declining connection\n"));
        IMsg.Prim                   = IRLMP_DISCONNECT_REQ;
        IMsg.IRDA_MSG_pDiscData     = NULL;
        IMsg.IRDA_MSG_DiscDataLen   = 0;
    }
    
    IrlmpDown(pMsg->IRDA_MSG_pContext, &IMsg);                        
}            

VOID
IrlmpDisconnectInd(PIRDA_CONN_OBJ pConn, IRDA_MSG *pMsg)
{
	CTELockHandle       hLock;

    DEBUGMSG(DBG_TDI, ("IRDA: IRLMP_DISCONNECT_IND ConnObj:%p (Irlmp:%p)\n", pConn,
             pConn->IrlmpContext));
             
    switch (pConn->ConnState)
    {
        case IRDA_CONN_CLOSING:    
        case IRDA_CONN_CREATED:
            break;
        
        case IRDA_CONN_OPENING:
        {
            CompleteConnection(pConn, pMsg);
            break;
        }
        case IRDA_CONN_OPEN:
        {
            ULONG       DiscFlags;

            if (pMsg->IRDA_MSG_DiscReason == IRLMP_USER_REQUEST)
            {
                DEBUGMSG(DBG_TDI, ("  ConnObj:%p graceful disconnect\n",
                                pConn));
                DiscFlags = TDI_DISCONNECT_RELEASE;
            }
            else
            {
                DEBUGMSG(DBG_TDI, ("  ConnObj:%p abortive disconnect\n",
                            pConn));            
                DiscFlags = TDI_DISCONNECT_ABORT;
            }

            GET_CONN_LOCK(pConn, &hLock);
            
            pConn->ConnState = IRDA_CONN_CLOSING;                        

            if (IsListEmpty(&pConn->RecvBufList) || 
                DiscFlags == TDI_DISCONNECT_ABORT)
            {
                if (!IsListEmpty(&pConn->SendIrpList))
                {
                    DEBUGMSG(DBG_TDI, ("  SendIrpList not empty, indicate abortive disconnect\n"));
                    DiscFlags = TDI_DISCONNECT_ABORT;
                }    
                    
                FREE_CONN_LOCK(pConn, hLock);

                IndicateDisconnect(pConn, DiscFlags);
            }
            else
            {
                DEBUGMSG(DBG_TDI, ("  receive data has been buffered, not indicating disconnect to client\n"));
                FREE_CONN_LOCK(pConn, hLock);
            }    
            break;
        }
        default:
            CTEAssert(0);
    }
}

VOID
IrlmpConnectConf(PIRDA_CONN_OBJ pConn, IRDA_MSG *pMsg)
{
    DEBUGMSG(DBG_TDI, ("IRDA: IRLMP_CONNECT_CONF ConnObj:%p\n",
                        pConn));
    switch (pConn->ConnState)
    {
        case IRDA_CONN_CLOSING:    
        case IRDA_CONN_CREATED:
        case IRDA_CONN_OPEN:
            CTEAssert(0);
            break;
            
        case IRDA_CONN_OPENING:
            CompleteConnection(pConn, pMsg);
            break;
    }        
}

VOID
IrlmpGetValueByClassConf(IRDA_MSG *pMsg)
{
	CTELockHandle   hLock;
    LIST_ENTRY      *pListEntry;
    UINT            rc;    
    BOOLEAN         RetryConn = FALSE;
    
    DEBUGMSG(DBG_TDI, ("IRDA: IRLMP_GETVALUEBYCLASS_CONF\n"));

    CTEGetLock(&IrdaLock, &hLock);

    if (pIasIrp != NULL) {

        PIRP                pIrp;
        PIO_STACK_LOCATION  pIrpSp;
        NTSTATUS            Status = STATUS_CONNECTION_REFUSED;
    
        pIrp = pIasIrp;
        
        pIasIrp = NULL;
        
        CTEFreeLock(&IrdaLock, hLock);

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);        
        
        // getsockopt IAS query on connection object??
        // I think not, helper will open a control channel.
        // i.e. I am making the assumption that this IAS response is
        // from a LsapSel value query and a connection will now
        // be initiated
        if ((UINT_PTR)pIrpSp->FileObject->FsContext2 == TDI_CONNECTION_FILE) {

            PIRDA_CONN_OBJ pConn = pIrpSp->FileObject->FsContext;        
            
            CTEAssert(IS_VALID_CONN(pConn));
            
            if (pConn->ConnState != IRDA_CONN_OPENING) {

                Status = STATUS_CONNECTION_ABORTED;

            } else {

                if (pMsg->IRDA_MSG_IASStatus != IRLMP_IAS_SUCCESS &&
                    pMsg->IRDA_MSG_IASStatus != IRLMP_IAS_SUCCESS_LISTLEN_GREATER_THAN_ONE) {

                    DEBUGMSG(DBG_TDI, ("IRDA: IAS Query failed %d\n",
                             pMsg->IRDA_MSG_IASStatus));

                    if (pMsg->IRDA_MSG_IASStatus < IRLMP_IAS_NO_SUCH_OBJECT) {

                        Status = STATUS_IO_TIMEOUT;
                    }

                    if (pMsg->IRDA_MSG_IASStatus == IRLMP_MAC_MEDIA_BUSY ||
                        pMsg->IRDA_MSG_IASStatus == IRLMP_IRLAP_REMOTE_DISCOVERY_IN_PROGRESS) {

                        RetryConn = TRUE;

                    } else {

                        if (pConn->pAddr->UseIrlptMode == IRLPT_MODE2) {
                            //
                            // I just can't beleive this crap
                            // Try querying for "LSAPSel" rather than "LsapSel"
                            //
                            Status = InitiateIasQuery(pIrp, pIrpSp, pConn);

                        }
                    }

                } else {
                    //
                    //  it worked
                    //
                    if (pMsg->IRDA_MSG_pIasQuery->irdaAttribType != IAS_ATTRIB_VAL_INTEGER) {

                        CTEAssert(0);

                    } else {
                        //
                        //  we got the lsap, proceed with the connection
                        //
                        pConn->RemoteLsapSel = pMsg->IRDA_MSG_pIasQuery->irdaAttribute.irdaAttribInt;

                        Status = InitiateConnection(pConn, pIrp);
                    }
                }
           
                if (Status != STATUS_PENDING) {

                    // failing the connection
                    pConn->ConnState = IRDA_CONN_CREATED;

                    if (RetryConn) {
                        //
                        //  the irp will queue or completed, by this function
                        //
                        RetryConnection(pConn, pIrp);
                        pIrp=NULL;

                    } else {
                        //
                        //  the request failed
                        //
                        pIrp->IoStatus.Status = Status;
                        pIrp->IoStatus.Information = 0;
                        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
                    }
                }
            }

        } else {
            //
            //  control file object
            //

            IAS_QUERY   *pIasQuery = pIrp->AssociatedIrp.SystemBuffer;
            ULONG       ResultLen = sizeof(IAS_QUERY);

            Status = STATUS_SUCCESS;

            if (pMsg->IRDA_MSG_IASStatus != IRLMP_IAS_SUCCESS &&
                pMsg->IRDA_MSG_IASStatus != IRLMP_IAS_SUCCESS_LISTLEN_GREATER_THAN_ONE) {

                DEBUGMSG(DBG_TDI, ("IRDA: IAS Query failed %d\n",
                         pMsg->IRDA_MSG_IASStatus));

                if (pMsg->IRDA_MSG_IASStatus < IRLMP_IAS_NO_SUCH_OBJECT) {

                    Status = STATUS_IO_TIMEOUT;

                } else {

                    Status = STATUS_CONNECTION_REFUSED;
                }

                ResultLen = 0;

            } else {

                RtlCopyMemory(pIasQuery, pvIasQuery, sizeof(IAS_QUERY));
            }

            pIrp->IoStatus.Status = Status;
            pIrp->IoStatus.Information = ResultLen;
            IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
        }

    } else {

        ASSERT(pIasIrp != NULL);
        CTEFreeLock(&IrdaLock, hLock);
    }


    CTEGetLock(&IrdaLock, &hLock);
    
    // Start the next Ias query if one is on the list and
    // there is not one in progress

    if (!IsListEmpty(&IasIrpList) && pIasIrp == NULL)
    {
        if (CTEScheduleEvent(&PendingIasEvent, NULL) == FALSE)
        {
            CTEAssert(0);
        }    
    }
    
    CTEFreeLock(&IrdaLock, hLock);
}

VOID
IrlmpDataConf(PIRDA_CONN_OBJ pConn, IRDA_MSG *pMsg)
{
    CTELockHandle   hLock;
    LIST_ENTRY      *pListEntry;
    PIRP            pIrp = NULL;
    
    CTEAssert(IS_VALID_CONN(pConn));
    
    // find the irp
    GET_CONN_LOCK(pConn, &hLock);
    
    // the desired irp should always be at the head of the list
    // so this search will be short
    for (pListEntry = pConn->SendIrpList.Flink;
         pListEntry != &pConn->SendIrpList;
         pListEntry = pListEntry->Flink)
    {
        pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
        
        if (pIrp == (PIRP) pMsg->IRDA_MSG_pTdiSendCompCnxt)
        {
            RemoveEntryList(pListEntry);
            break;
        }
        pIrp = NULL;    
    }

    
    FREE_CONN_LOCK(pConn, hLock);

    if (pIrp)
    {
        NTSTATUS Status;
        
        if (pMsg->IRDA_MSG_DataStatus == IRLMP_DATA_REQUEST_COMPLETED)
        {
            Status = STATUS_SUCCESS;
        }    
        else
        {
            Status = STATUS_GRACEFUL_DISCONNECT;
        }    
        
        DEBUGMSG(DBG_TDI, ("IRDA: IRLMP_DATA_CONF %s ConnObj:%p %d bytes, Irp:%p\n",
                 Status == STATUS_SUCCESS ? "Success":"Failed",        
                 pConn, (ULONG)pIrp->IoStatus.Information, pIrp));
        
        pIrp->IoStatus.Status = Status;    
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
                            
        
    }
    else
    {
        DEBUGMSG(DBG_TDI, ("IRDA: IRLMP_DATA_CONF ConnObj:%p, Irp:%p NOT FOUND! pMsg=%p\n",
                    pConn, pMsg->IRDA_MSG_pTdiSendCompCnxt, pMsg));        
                    
        ASSERT(0);            
    }    
    
    FreeIrdaBuf(IrdaMsgPool, pMsg);
}

VOID
BufferRecv(
    PIRDA_CONN_OBJ  pConn, 
    UCHAR           *pData,
    ULONG           BytesAvailable,
    UINT            FinalSeg)
{
    PIRDA_RECV_BUF      pRecvBuf;

    // Assumes conn lock is held
    
    pRecvBuf = AllocIrdaBuf(RecvBufPool);

    CTEAssert(pRecvBuf);
    
    if (pRecvBuf)
    {
        InsertTailList(&pConn->RecvBufList, &pRecvBuf->Linkage);
        
        pRecvBuf->Offset = 0;
        pRecvBuf->Len = BytesAvailable;
        pRecvBuf->FinalSeg = FinalSeg;
            
        RtlCopyMemory(pRecvBuf->Data, pData,
                      pRecvBuf->Len);
        
    }
    DEBUGMSG(DBG_TDI, ("  ConnObj:%p, %d bytes buffered at %p\n",
             pConn, pRecvBuf->Len, pRecvBuf));
}

VOID
IrlmpDataInd(PIRDA_CONN_OBJ pConn, IRDA_MSG *pMsg)
{
    NTSTATUS        Status;
    PIRDA_ADDR_OBJ  pAddr = pConn->pAddr;    
    ULONG           BytesAvailable, BytesTakenTotal, BytesTaken, BytesToCopy;
    PIRP            pIrp = NULL;
	CTELockHandle   hLock;
    LIST_ENTRY      *pListEntry;
    UCHAR           *pData;
    UINT            FinalSeg;
    
    CTEAssert(IS_VALID_ADDR(pAddr));

    // remove IrCOMM header byte
    
    if (pAddr->Use9WireMode)
    {
        if (*pMsg->IRDA_MSG_pRead != 0)
        {
            DEBUGMSG(DBG_ERROR, ("IRDA: 9 wire first byte not zero!! Tossing packet\n"));
            return;
        }
        
        pMsg->IRDA_MSG_pRead += 1;    
    }

#if DBG_CHECKSUM
    // print first and last 4 bytes of frame to help isolate 
    // data corruption problem. Should be used with sledge
    if ((pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead) > 20)
        DEBUGMSG(1, ("R(%X): %c%c%c%c, %c%c%c%c (%X)\n",
            pMsg->IRDA_MSG_pRead,
            *(pMsg->IRDA_MSG_pRead),    
            *(pMsg->IRDA_MSG_pRead+1),    
            *(pMsg->IRDA_MSG_pRead+2),    
            *(pMsg->IRDA_MSG_pRead+3),
            *(pMsg->IRDA_MSG_pWrite-4),    
            *(pMsg->IRDA_MSG_pWrite-3),    
            *(pMsg->IRDA_MSG_pWrite-2),    
            *(pMsg->IRDA_MSG_pWrite-1),
            pConn));
#endif            

    BytesAvailable = (ULONG) (pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead);
    BytesTakenTotal = 0;
    pData = pMsg->IRDA_MSG_pRead;
    FinalSeg = pMsg->IRDA_MSG_SegFlags & SEG_FINAL ? 1 : 0;
    
    #if DBG
    pConn->TotalFramesCnt += 1;
    pConn->TotalByteCount += BytesAvailable;
    #endif
    
    GET_CONN_LOCK(pConn, &hLock);
        
    pConn->TtpRecvCreditsLeft--;
        
    CTEAssert(pConn->TtpRecvCreditsLeft >= 0);
    
    if (pConn->ConnState != IRDA_CONN_OPEN)
    {
        DEBUGMSG(DBG_TDI, ("  connection not open (state %d), ignoring\n",
                 pConn->ConnState));
        FREE_CONN_LOCK(pConn, hLock);
        return;
    }    

    if (pConn->RecvBusy)
    {
        DEBUGMSG(DBG_TDI, ("IRDA: IRLMP_DATA_IND pConnObj:%p busy\n", pConn));
        BufferRecv(pConn, pData, BytesAvailable, FinalSeg);
        FREE_CONN_LOCK(pConn, hLock);
        return;
    }
    
    FREE_CONN_LOCK(pConn, hLock);    
    
    do
    {
        PIO_STACK_LOCATION          pIrpSp;
        PTDI_REQUEST_KERNEL_RECEIVE pRecvReq;
    
        pIrp = NULL;
        
        GET_CONN_LOCK(pConn, &hLock);    
        
        if (!IsListEmpty(&pConn->RecvIrpList))
        {
            pListEntry = RemoveHeadList(&pConn->RecvIrpList);
        
            pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
            
            if (IoSetCancelRoutine(pIrp, NULL) == NULL)
            {
                // Cancel routine is going to run. Indicate to the
                // cancel routine that the Irp has already been removed
                // from the list by setting Flink to NULL
                
                pIrp->Tail.Overlay.ListEntry.Flink = NULL;            
                
                pIrp = NULL;
            }
            else
            {
                BytesTaken = 0;
        
                Status = STATUS_MORE_PROCESSING_REQUIRED;
            
                DEBUGMSG(DBG_ERROR, ("IRDA: IRLMP_DATA_IND, complete pending receive irp:%p\n",
                     pIrp));
                     
            }                     
            

        }    

        FREE_CONN_LOCK(pConn, hLock);
        
        if (pIrp == NULL) {

            DEBUGMSG(DBG_TDI, ("IRDA: IRLMP_DATA_IND pConnObj:%p, indicate %d bytes\n",
                                pConn, BytesAvailable));        

            if (pAddr->pEventReceive) {

                Status = pAddr->pEventReceive(
                            pAddr->pEventReceiveContext,
                            pConn->ClientContext,
                            TDI_RECEIVE_NORMAL | \
                            (FinalSeg ? TDI_RECEIVE_ENTIRE_MESSAGE : 0),
                            BytesAvailable,
                            BytesAvailable,
                            &BytesTaken,
                            pData,
                            &pIrp
                            );
            } else {

                BytesTaken= BytesAvailable;
                Status=STATUS_SUCCESS;
            }

            BytesTakenTotal += BytesTaken;
            BytesAvailable -= BytesTaken;
            pData += BytesTaken;

        }


        switch (Status)
        {
          case STATUS_MORE_PROCESSING_REQUIRED:
        
            CTEAssert(pIrp);
    
            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    
            pRecvReq = (PTDI_REQUEST_KERNEL_RECEIVE) &pIrpSp->Parameters;
        
            BytesToCopy = BytesAvailable <= pRecvReq->ReceiveLength ?
                            BytesAvailable : pRecvReq->ReceiveLength;
                      
            TdiCopyBufferToMdl(pData,           // Source 
                               0,               // Source offset
                               BytesToCopy,     // Number of bytes to copy
                               pIrp->MdlAddress,// Destination
                               0,               // Destination offset
                               &BytesTaken);    // actual bytes copied
                      
            CTEAssert(BytesTaken == BytesToCopy);
                      
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = BytesTaken;
            IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
            
            BytesTakenTotal += BytesTaken;
            BytesAvailable -= BytesTaken;
            pData += BytesTaken;
            
            // fall through
          case STATUS_SUCCESS:

            #if DBG
                if (Status == STATUS_SUCCESS)
                {
                    DEBUGMSG(DBG_TDI, ("  client took indicated data, BytesLeft %d, BytesTaken %d\n", 
                         BytesAvailable, BytesTaken));
                }
                else
                {
                    DEBUGMSG(DBG_TDI, ("  Completed Irp %p, BytesLeft %d, BytesTaken %d\n",
                        pIrp, BytesAvailable, BytesTaken));
                }
            #endif
            
            GET_CONN_LOCK(pConn, &hLock);
            
            // Advance credit to peer

            DEBUGMSG(DBG_TDI, ("   TtpRecvCreditsLeft = %d\n",pConn->TtpRecvCreditsLeft));

            if (pConn->TtpRecvCreditsLeft <= TTP_CREDIT_ADVANCE_THRESH)
            {
                int         CreditsLeft;
                IRDA_MSG    IMsg;
                
                CreditsLeft = pConn->TtpRecvCreditsLeft;
                pConn->TtpRecvCreditsLeft = TTP_RECV_CREDITS;

                FREE_CONN_LOCK(pConn, hLock);
    
                IMsg.Prim = IRLMP_MORECREDIT_REQ;
                IMsg.IRDA_MSG_TtpCredits = TTP_RECV_CREDITS - CreditsLeft;
            
                #if DBG
                pConn->CreditsExtended += (TTP_RECV_CREDITS - CreditsLeft);
                #endif

                IrlmpDown(pConn->IrlmpContext, &IMsg);
            }
            else
            {
                FREE_CONN_LOCK(pConn, hLock);
            }
        
            break;    
        
          case STATUS_DATA_NOT_ACCEPTED:
            GET_CONN_LOCK(pConn, &hLock);
            
            if (!IsListEmpty(&pConn->RecvIrpList))
            {
                FREE_CONN_LOCK(pConn, hLock);
                continue;
            }            
            
            pConn->RecvBusy = TRUE;
            
            BufferRecv(pConn, pData, BytesAvailable, FinalSeg);
                       
            FREE_CONN_LOCK(pConn, hLock);
            break;
        }
    
    } while (Status != STATUS_DATA_NOT_ACCEPTED &&
             BytesAvailable);
}

UINT
TdiUp(void *pContext, IRDA_MSG *pMsg)
{
    PIRDA_CONN_OBJ      pConn = pContext;    
    
    CTEAssert(pConn ? IS_VALID_CONN(pConn) : 1);
    
    switch (pMsg->Prim)
    {
        case IRLMP_DISCOVERY_CONF:
            IrlmpDiscoveryConf(pMsg);
            break;
            
        case IRLMP_DISCOVERY_IND:
            break;

        case IRLMP_CONNECT_IND:
            IrlmpConnectInd(pMsg);
            break;
                        
        case IRLMP_DISCONNECT_IND:
            IrlmpDisconnectInd(pConn, pMsg);
            break;
        
        case IRLMP_CONNECT_CONF:
            IrlmpConnectConf(pConn, pMsg);
            break;
            
        case IRLMP_GETVALUEBYCLASS_CONF:
            IrlmpGetValueByClassConf(pMsg);
            break;
            
        case IRLMP_DATA_CONF:
            IrlmpDataConf(pConn, pMsg);
            break;
            
        case IRLMP_DATA_IND:
            IrlmpDataInd(pConn, pMsg);
            break;
            
        case IRLAP_STATUS_IND:
        {

            CTELockHandle   hLock;
            PIRLINK_STATUS  pLinkStatus = (PIRLINK_STATUS) pMsg->IRDA_MSG_pLinkStatus;
            
            if (CTEMemCmp(pLinkStatus->ConnectedDeviceId,
                          LinkStatus.ConnectedDeviceId,
                          IRDA_DEV_ADDR_LEN) == 0)
            {
                if (pLinkStatus->Flags == LF_INTERRUPTED)
                {
                    ConnectionStatusChange(NULL, CONNECTION_INTERRUPTED);
                }
                else if ((pLinkStatus->Flags & LF_CONNECTED) && ConnectionInterrupted)
                {
                    ConnectionStatusChange(NULL, CONNECTION_UP);
                }
            }              

            /*            
            CTEGetLock(&IrdaLock, &hLock);

            // we update the status only when it changes
            
            // No longer interested in send and receives status
            ((PIRLINK_STATUS) (pMsg->IRDA_MSG_pLinkStatus))->Flags &= ~(LF_TX | LF_RX);
            
            if (CTEMemCmp(&LinkStatus, pLinkStatus, sizeof(IRLINK_STATUS)) != 0)
            {
                CTEMemCopy(&LinkStatus, pLinkStatus, sizeof(IRLINK_STATUS));
                           
                LinkStatusUpdated = TRUE;
            }    

            if (LinkStatusUpdated)
            {
                PLIST_ENTRY         pListEntry;
                PIRP                pIrp;
                
                pListEntry = RemoveHeadList(&StatusIrpList);
                
                if (pListEntry != &StatusIrpList)
                {
                    pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
                 
                    if (IoSetCancelRoutine(pIrp, NULL) == NULL)
                    {
                        // Cancel routine is going to run. Mark Irp so cancel
                        // routine won't attempt to remove it from the list
                        pIrp->Tail.Overlay.ListEntry.Flink = NULL;
                        CTEFreeLock(&IrdaLock, hLock);                                        
                    }
                    else
                    {
                        CTEMemCopy(pIrp->AssociatedIrp.SystemBuffer, 
                                   &LinkStatus, sizeof(IRLINK_STATUS));
                                   
                        CTEFreeLock(&IrdaLock, hLock);                                   
                     
                        pIrp->IoStatus.Information = sizeof(IRLINK_STATUS);
                        pIrp->IoStatus.Status = STATUS_SUCCESS;
                        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
                        LinkStatusUpdated = FALSE;
                    }    
                }
                else
                {
                    CTEFreeLock(&IrdaLock, hLock);
                }                                
            }
            else
            {                
                CTEFreeLock(&IrdaLock, hLock);
            }    
            */
            break;
        }                

        case IRLMP_ACCESSMODE_CONF:
        default:
          DEBUGMSG(DBG_ERROR,
              ("IRDA: TdiUp(), Bad prim %s.\n", IrDAPrimTxt(pMsg->Prim)));
          break;
    }

    return SUCCESS;
}

VOID
LazyDscvTimerExp(PVOID Context)
{
    IRDA_MSG        IMsg;
  	CTELockHandle   hLock;    
  
    DEBUGMSG(DBG_DISCOVERY, ("IRDA: Lazy discovery timer expired\n"));

    CTEGetLock(&IrdaLock, &hLock);
    
    if (!IsListEmpty(&LazyDscvIrpList))
    {
        UINT            OriginalTimeout;
        UINT            RandInc;
        
        CTEFreeLock(&IrdaLock, hLock);
        
        // Randomize lazy discovery time +1, +0, or -1
        
        RandSeed = RandSeed * 0x3F57A10B + 1;
        RandInc = RandSeed % 3;
        OriginalTimeout = LazyDscvTimer.Timeout;
        
        LazyDscvTimer.Timeout += (RandInc * 1000) - 1000;
        
        IMsg.Prim = IRLMP_DISCOVERY_REQ;
        IMsg.IRDA_MSG_SenseMedia = TRUE;
        IrlmpDown(NULL, &IMsg);
    
        IrdaTimerStart(&LazyDscvTimer);
        
        LazyDscvTimer.Timeout = OriginalTimeout;
    
        return;
    }    
    else
    {
        LazyDscvTimerRunning = FALSE;    
        
        DEBUGMSG(DBG_TDI, ("IRDA: IrpList empty, ending lazy discovery\n"));
    }    
    
    CTEFreeLock(&IrdaLock, hLock);    
}

VOID CancelIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP pIrp)
{
	CTELockHandle   hLock;
    
    DEBUGMSG(DBG_TDI, ("IRDA: Cancel Irp:%p\n", pIrp));

    CTEGetLock(&IrdaLock, &hLock);

    if (pIrp->Tail.Overlay.ListEntry.Flink != NULL) {

        RemoveEntryList(&(pIrp->Tail.Overlay.ListEntry));
    }    
    
    CTEFreeLock(&IrdaLock, hLock);
    
    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;
    
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
}

VOID CancelConnObjIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP pIrp)
{
    PIRDA_CONN_OBJ      pConn;
    PIO_STACK_LOCATION  pIrpSp;
	CTELockHandle       hLock;
    
    DEBUGMSG(DBG_TDI, ("IRDA: Cancel ConnObj Irp:%p\n", pIrp));
    
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    
    pConn = pIrpSp->FileObject->FsContext;
    
    CTEAssert(IS_VALID_CONN(pConn));        

    GET_CONN_LOCK(pConn, &hLock);

    if (pIrp->Tail.Overlay.ListEntry.Flink != NULL)
    {
        RemoveEntryList(&(pIrp->Tail.Overlay.ListEntry));
    }    
    
    FREE_CONN_LOCK(pConn, hLock);

    DbgPrint("irda: irp %p canceled\n",pIrp);

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;
    
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
}


VOID
PendIrp(
    PLIST_ENTRY     pList,
    PIRP            pIrp,
    PIRDA_CONN_OBJ  pConn,
    BOOLEAN         LockHeld)
{
	CTELockHandle   hLock;
    PIRP            IrpToComplete=NULL;
    
    if (!LockHeld)
    {
        if (pConn)
        {
            GET_CONN_LOCK(pConn, &hLock);
        }
        else
        {    
            CTEGetLock(&IrdaLock, &hLock);
        }
    }        
    
    InsertTailList(pList, &pIrp->Tail.Overlay.ListEntry);
    
    IoMarkIrpPending(pIrp);
    
    if (pConn)
    {
        IoSetCancelRoutine(pIrp, CancelConnObjIrp);        
    }    
    else
    {
        IoSetCancelRoutine(pIrp, CancelIrp);    
    }    
    
    pIrp->IoStatus.Status = STATUS_PENDING;
    
    if (pIrp->Cancel)
    {

        
        if (IoSetCancelRoutine(pIrp, NULL) != NULL) 
        {
            //
            // My cancel routine was still set in the Irp so
            // the Io manager never had a chance to call it
            //

            RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);


            pIrp->IoStatus.Status = STATUS_CANCELLED;

            pIrp->IoStatus.Information = 0;

            //
            //  since we may be holding a spinlock here we don't want to complete the
            //  irp now
            //
            IrpToComplete=pIrp;
#if DBG
            pIrp=NULL;
#endif

        }
    }
    
    if (!LockHeld)
    {
        if (pConn)
        {
            FREE_CONN_LOCK(pConn, hLock);
        }
        else
        {    
            CTEFreeLock(&IrdaLock, hLock);
        }
    }        

    if (IrpToComplete != NULL) {

        IoCompleteRequest(IrpToComplete, 0);
    }

    return ;
}

int
GetUnusedLsapSel()
{
    PIRDA_ADDR_OBJ  pAddr;
    int             LastLsapSel;
    int             LsapSel = gNextLsapSel;

    // Assumes AddrObjList lock is held
        
    LastLsapSel = LsapSel - 1;
    
    if (LastLsapSel < IRDA_MIN_LSAP_SEL)
    {
        LastLsapSel = IRDA_MAX_LSAP_SEL;
    }
    
    while (LsapSel != LastLsapSel)
    {
        for (pAddr = AddrObjList; pAddr != NULL; pAddr = pAddr->pNext)
        {
            if (pAddr->LocalLsapSel == LsapSel)
                break;
                
        }
        
        if (pAddr == NULL || pAddr->LocalLsapSel != LsapSel)
        {        
            gNextLsapSel = LsapSel + 1;

            if (gNextLsapSel > IRDA_MAX_LSAP_SEL)
            {
                gNextLsapSel = IRDA_MIN_LSAP_SEL;   
            }    
            return LsapSel;
        }
        
        LsapSel += 1;
        
        if (LsapSel > IRDA_MAX_LSAP_SEL)
        {
            LsapSel = IRDA_MIN_LSAP_SEL;
        }        
    }
    return -1;
}    

VOID
SetLsapSelAddr(
    int LsapSel,
    CHAR *ServiceName)
{
    int     Digit, i;
    int     StrLen = 0;
    CHAR    Str[4];
        
    while (LsapSel > 0 && StrLen < 3)
    {
        Digit = LsapSel % 10;
        LsapSel = LsapSel / 10;
        Str[StrLen] = Digit + '0';
        StrLen++;
    }

    RtlCopyMemory(ServiceName, LSAPSEL_TXT, LSAPSEL_TXTLEN);
            
    for (i = 0; i < StrLen; i++)
        ServiceName[i + LSAPSEL_TXTLEN] = Str[StrLen - 1 - i];

    ServiceName[StrLen + LSAPSEL_TXTLEN] = 0;
}    

BOOLEAN
MyStrEqual(
    CHAR *Str1, 
    CHAR *Str2, 
    int Len)
{
    while (*Str1 == *Str2 && Len--)
    {
        if (*Str1 == 0)
            return TRUE;
        
        Str1++; Str2++;
    }
    return FALSE;
}

#if 1
char *
IrpMJTxt(
    PIO_STACK_LOCATION  pIrpSp)
{
    static char *MJTxt[] =
    {
        "IRP_MJ_CREATE",
        "IRP_MJ_CREATE_NAMED_PIPE",
        "IRP_MJ_CLOSE",
        "IRP_MJ_READ",
        "IRP_MP_MJ_WRITE",
        "IRP_MJ_QUERY_INFO",
        "IRP_MJ_SET_INFO",
        "IRP_MJ_QUERY_EA",
        "IRP_MJ_SET_EA",
        "IRP_MJ_FLUSH_BUFFERS",
        "IRP_MJ_QUERY_VOLUME_INFO",
        "IRP_MJ_SET_VOLUME_INFO",
        "IRP_MJ_DIRECTORY_CTRL",
        "IRP_MJ_FILE_SYSTEM_CTRL",
        "IRP_MJ_DEV_CONTROL",
        "IRP_MJ_INTERNAL_DEV_CTRL",
        "IRP_MJ_SHUTDOWN",
        "IRP_MJ_LOCK_CTRL",
        "IRP_MJ_CLEANUP",
        "IRP_MJ_CREATE_MAILSLOT",
        "IRP_MJ_QUERY_SECURITY",
        "IRP_MJ_SET_SECURITY",
        "IRP_MJ_QUERY_POWER",
        "IRP_MJ_SET_POWER",
        "IRP_MJ_DEV_CHANGE",
        "IRP_MJ_QUERY_QUOTA",
        "IRP_MJ_SET_QUOTA",
        "IRP_MJ_PNP_POWER",
    };

    if (pIrpSp->MajorFunction < sizeof(MJTxt) / sizeof(char *))
    {
        return(MJTxt[pIrpSp->MajorFunction]);
    }

    return "UNKNOWN IRP_MJ_";
}

char *
IrpTdiTxt(
    PIO_STACK_LOCATION  pIrpSp)
{
    static char *TdiTxt[] =
    {
        "UNKNOWN TDI_",
        "TDI_ASSOC_ADDR", 
        "TDI_DISASSOC_ADDR",
        "TDI_CONNECT",
        "TDI_LISTEN",
        "TDI_ACCEPT",
        "TDI_DISC",
        "TDI_SEND",
        "TDI_RECV",
        "TDI_SEND_DATAGRAM",
        "TDI_RECV_DATAGRAM",
        "TDI_SET_HANDLER",
        "TDI_QUERY_INFO",
        "TDI_SET_INFO",
        "TDI_ACTION"
    };
    
    if (pIrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL)
    {
        if (pIrpSp->MinorFunction < sizeof(TdiTxt) / sizeof(char *))
        {
            return(TdiTxt[pIrpSp->MinorFunction]);
        }
        else
            return "UNKNOWN TDI_";
    }

    return "";
}

char *
IrpTdiObjTypeTxt(
    PIO_STACK_LOCATION  pIrpSp)
{
    switch((UINT_PTR) pIrpSp->FileObject->FsContext2)
    {
        case TDI_TRANSPORT_ADDRESS_FILE:    return "AddrObj";
        case TDI_CONNECTION_FILE:           return "ConnObj";
        case TDI_CONTROL_CHANNEL_FILE:      return "CtrlObj";
    }
    return "UNKNOWN";
}

char *
TdiEventTxt(
    int EventType)
{
    switch(EventType)
    {
        case TDI_EVENT_CONNECT:                 return "TDI_EVENT_CONN";
        case TDI_EVENT_DISCONNECT:              return "TDI_EVENT_DISC";
        case TDI_EVENT_RECEIVE:                 return "TDI_EVENT_RECV";
        case TDI_EVENT_ERROR:                   return "TDI_EVENT_ERR";
        case TDI_EVENT_RECEIVE_DATAGRAM:        return "TDI_EVENT_RECV_DATAGRAM";
        case TDI_EVENT_RECEIVE_EXPEDITED:       return "TDI_EVENT_RECV_EXPEDITED";
    }
    return "UNKNOWN TDI_EVENT_";
}

void
DumpObjects(void)
{

    PIRDA_ADDR_OBJ  pAddr;
    PIRDA_CONN_OBJ  pConn;
    
    pAddr = AddrObjList;
/*    
    while (pAddr != NULL)
    {
        DEBUGMSG(DBG_TDI,
            ("  AddrObj:%X Loc:\"%s\",%d ConnObjList:%X pNext:%X\n",
            pAddr,
            pAddr->LocalAddr.irdaServiceName,
            pAddr->LocalLsapSel,
            pAddr->ConnObjList,
            pAddr->pNext));
        
        pConn = pAddr->ConnObjList;
        while (pConn != NULL)
        {
            DEBUGMSG(DBG_TDI,
                ("    ConnObj:%X Loc:\"%s\",%d Rem:\"%s\",%d State:%d AddrObj:%X pNext:%X\n",
                pConn,
                pConn->LocalAddr.irdaServiceName,
                pConn->LocalLsapSel,
                pConn->RemoteAddr.irdaServiceName,
                pConn->RemoteLsapSel,
                pConn->ConnState,
                pConn->pAddr,
                pConn->pNext)); 

            pConn = pConn->pNext;
        }

        pAddr = pAddr->pNext;
    }    
*/    
}

char *
IrDAPrimTxt(
    IRDA_SERVICE_PRIM   Prim)
{
    static char *IrDAPrimTxt[] =
    {
        "MAC_DATA_REQ",
        "MAC_DATA_IND",
        "MAC_DATA_RESP",
        "MAC_DATA_CONF",
        "MAC_CONTROL_REQ",
        "MAC_CONTROL_CONF",
        "IRLAP_DISCOVERY_REQ",
        "IRLAP_DISCOVERY_IND",
        "IRLAP_DISCOVERY_CONF",
        "IRLAP_CONNECT_REQ",
        "IRLAP_CONNECT_IND",
        "IRLAP_CONNECT_RESP",
        "IRLAP_CONNECT_CONF",
        "IRLAP_DISCONNECT_REQ",
        "IRLAP_DISCONNECT_IND",
        "IRLAP_DATA_REQ",
        "IRLAP_DATA_IND",
        "IRLAP_DATA_CONF",
        "IRLAP_UDATA_REQ",
        "IRLAP_UDATA_IND",
        "IRLAP_UDATA_CONF",
        "IRLAP_STATUS_IND",
        "IRLAP_FLOWON_REQ",
        "IRLMP_DISCOVERY_REQ",
        "IRLMP_DISCOVERY_IND",
        "IRLMP_DISCOVERY_CONF",
        "IRLMP_CONNECT_REQ",
        "IRLMP_CONNECT_IND",
        "IRLMP_CONNECT_RESP",
        "IRLMP_CONNECT_CONF",
        "IRLMP_DISCONNECT_REQ",
        "IRLMP_DISCONNECT_IND",
        "IRLMP_DATA_REQ",
        "IRLMP_DATA_IND",
        "IRLMP_DATA_CONF",
        "IRLMP_UDATA_REQ",
        "IRLMP_UDATA_IND",
        "IRLMP_UDATA_CONF",
        "IRLMP_ACCESSMODE_REQ",
        "IRLMP_ACCESSMODE_IND",
        "IRLMP_ACCESSMODE_CONF",
        "IRLMP_MORECREDIT_REQ",
        "IRLMP_GETVALUEBYCLASS_REQ",
        "IRLMP_GETVALUEBYCLASS_CONF",
        "IRLMP_REGISTERLSAP_REQ",
        "IRLMP_ADDATTRIBUTE_REQ",
        "IRLMP_DELATTRIBUTE_REQ",
    };
    
    if (Prim < sizeof(IrDAPrimTxt) / sizeof(char *))
    {
        return(IrDAPrimTxt[Prim]);
    }

    return "UNKNOWN PRIMITIVE";
}

char *
TdiQueryTxt(LONG Type)
{
    switch(Type)
    {
        case TDI_QUERY_BROADCAST_ADDRESS:   return "TDI_QUERY_BROADCAST_ADDRESS";
        case TDI_QUERY_PROVIDER_INFO:       return "TDI_QUERY_PROVIDER_INFO";
        case TDI_QUERY_ADDRESS_INFO:        return "TDI_QUERY_ADDRES_INFO";
        case TDI_QUERY_CONNECTION_INFO:     return "TDI_QUERY_CONNECTION_INFO";
        case TDI_QUERY_PROVIDER_STATISTICS: return "TDI_QUERY_PROVIDER_STATISTICS";
        default: return "Unknown TDI_QUERY_INFO";
    }    
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\inc\jet.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1993 Microsoft Corporation.
*
* Component:
*
* File: jet.h
*
* File Comments:
*
*     Public header file with JET API definition.
*
* Revision History:
*
*    [0]  04-Jan-92  richards	Added this header
*
***********************************************************************/

//
// This __JET500 essentially creates two version of this file in this
// same file. All the jet500 stuff is in __JET500 macro
//
#if __JET500
#include "jet500.h"
//
// End of 500 series jet.h
#else
//
// Original jet.h starts here. i.e jet.h of 200 series db.
//

#if !defined(_JET_INCLUDED)
#define _JET_INCLUDED

#ifdef	__cplusplus
extern "C" {
#endif

#pragma pack(4)

#if defined(_M_ALPHA)				/* 0:32 Flat Model (Alpha AXP) */

#define _far
#define JET_API   __stdcall
#define JET_NODSAPI __stdcall

#elif	defined(M_MRX000)				/* 0:32 Flat Model (MIPS Rx000) */

#define _far
#define JET_API   __stdcall
#define JET_NODSAPI  __stdcall

#else										/*	0:32 flat model (Intel 32-bit ) */

#define _far
#define JET_API     __stdcall		/* CONSIDER: Switch to __stdcall */
#define JET_NODSAPI __stdcall		/* CONSIDER: Switch to __stdcall */

#endif

typedef long JET_ERR;

typedef unsigned long JET_INSTANCE;	/* Instance Identifier */
typedef ULONG_PTR JET_SESID;		/* Session Identifier */
typedef ULONG_PTR JET_TABLEID;	    /* Table Identifier */
typedef unsigned long JET_COLUMNID;	/* Column Identifier */

typedef ULONG_PTR JET_DBID; 		/* Database Identifier */
typedef unsigned long JET_OBJTYP;	/* Object Type */
typedef unsigned long JET_COLTYP;	/* Column Type */
typedef unsigned long JET_GRBIT;		/* Group of Bits */
typedef unsigned long JET_ACM;		/* Access Mask */
typedef unsigned long JET_RNT;		/* Repair Notification Type */

typedef unsigned long JET_SNP;		/* Status Notification Process */
typedef unsigned long JET_SNT;		/* Status Notification Type */
typedef unsigned long JET_SNC;		/* Status Notification Code */

typedef double JET_DATESERIAL;		/* JET_coltypDateTime format */

#if defined(_M_ALPHA)				/* 0:32 Flat Model (Intel 80x86) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#elif	defined(M_MRX000)				/* 0:32 Flat Model (MIPS Rx000) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#else										/*	0:32 flat model (Alpha AXP ) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#endif


	/*	Session information bits */

#define JET_bitCIMCommitted					 	0x00000001
#define JET_bitCIMDirty							 	0x00000002
#define JET_bitAggregateTransaction		  		0x00000008

	/* JetGetLastErrorInfo structure */

typedef struct
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_ERR 			err;			/* Extended error code (if any) */
	unsigned long	ul1;			/* First general purpose integer */
	unsigned long	ul2;			/* Second general purpose integer */
	unsigned long	ul3;			/* Third general purpose integer */
	} JET_EXTERR;

	/* Status Notification Structures */

typedef struct				/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cunitDone;	/* Number of units of work completed */
	unsigned long	cunitTotal;	/* Total number of units of work */
	} JET_SNPROG;

	/* ErrCount Notification Structures */

typedef struct						/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cRecUniqueKeyViolation;
	unsigned long	cRecTypeConversionFail;
	unsigned long	cRecRecordLocked;
	unsigned long	cRecTotal;	/* Total number of units of work */
	} JET_SNERRCNT;


typedef struct				/* Status Notification Message */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_SNC 	snc;					/* Status Notification Code */
	unsigned long	ul;			/* Numeric identifier */
	char		sz[256];				/* Identifier */
	} JET_SNMSG;


typedef struct
	{
	unsigned long	cbStruct;
	JET_OBJTYP	objtyp;
	JET_DATESERIAL	dtCreate;
	JET_DATESERIAL	dtUpdate;
	JET_GRBIT	grbit;
	unsigned long	flags;
	unsigned long	cRecord;
	unsigned long	cPage;
	} JET_OBJECTINFO;
	
typedef struct
	{
	unsigned	int dbid;
	char		szDatabaseName[256];
	char		szNewDatabaseName[256];
	} JET_RSTMAP;			/* restore map */

	/* The following flags appear in the grbit field above */

#define JET_bitTableInfoUpdatable	0x00000001
#define JET_bitTableInfoBookmark	0x00000002
#define JET_bitTableInfoRollback	0x00000004
#define JET_bitTableInfoRestartable	0x00000008
#define JET_bitTableInfoNoInserts	0x00000010

	/* The following flags occur in the flags field above */

#define JET_bitSaveUIDnPWD		0x20000000	/* this bit is only 		 */
											/* appropriate for rmt links */
#define JET_bitObjectExclusive	0x40000000	/* Open link exclusively */
#define JET_bitObjectSystem		0x80000000


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidcontainername;
	JET_COLUMNID	columnidobjectname;
	JET_COLUMNID	columnidobjtyp;
	JET_COLUMNID	columniddtCreate;
	JET_COLUMNID	columniddtUpdate;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidflags;
	JET_COLUMNID	columnidcRecord;	/* Level 2 info */
	JET_COLUMNID	columnidcPage;		/* Level 2 info */
	} JET_OBJECTLIST;

#define cObjectInfoCols 9	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidSid;
	JET_COLUMNID	columnidACM;
	JET_COLUMNID	columnidgrbit; /* grbit from JetSetAccess */
	} JET_OBJECTACMLIST;

#define cObjectAcmCols 3	       /* CONSIDER: Internal */


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidPresentationOrder;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidcbMax;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidDefault;
	JET_COLUMNID	columnidBaseTableName;
	JET_COLUMNID	columnidBaseColumnName;
	JET_COLUMNID	columnidDefinitionName;
	} JET_COLUMNLIST;

#define cColumnInfoCols 14	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP	coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wCollate;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT	grbit;
	} JET_COLUMNDEF;


typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP	coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wFiller;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT	grbit;
	char		szBaseTableName[256];	/* CONSIDER: Too large? */
	char		szBaseColumnName[256];	/* CONSIDER: Too large? */
	} JET_COLUMNBASE;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID	tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidindexname;
	JET_COLUMNID	columnidgrbitIndex;
	JET_COLUMNID	columnidcKey;
	JET_COLUMNID	columnidcEntry;
	JET_COLUMNID	columnidcPage;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidgrbitColumn;
	JET_COLUMNID	columnidcolumnname;
	} JET_INDEXLIST;

#define cIndexInfoCols 15	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID	tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidReferenceName;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidReferencingTableName;
	JET_COLUMNID	columnidReferencingColumnName;
	JET_COLUMNID	columnidReferencedTableName;
	JET_COLUMNID	columnidReferencedColumnName;
	} JET_RELATIONSHIPLIST;

/* for backward compatibility */
typedef JET_RELATIONSHIPLIST JET_REFERENCELIST;

#define cReferenceInfoCols 8	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	JET_COLUMNID	columnidNextTagged;
	} JET_RETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	} JET_SETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	centriesLT;
	unsigned long	centriesInRange;
	unsigned long	centriesTotal;
	} JET_RECPOS;

typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	} PERS_OLCSTAT;
	
typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	unsigned long	cpgCompactFreed;
	} JET_OLCSTAT;

typedef struct
	{
	unsigned long	ctableid;
	JET_TABLEID	rgtableid[1];
	} JET_MGBLIST;

/*** Property Manager Structure ***/
typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID 	tableid;
	JET_COLUMNID 	columnidColumnName;
	JET_COLUMNID 	columnidPropertyName;
	JET_COLUMNID	columnidGrbit;
	JET_COLUMNID	columnidPropertyValue;
	JET_COLUMNID	columnidColtyp;
	} JET_PROPERTYLIST;


/************************************************************************/
/*************************     JET CONSTANTS	 ************************/
/************************************************************************/

#define JET_tableidNil			((JET_TABLEID) 	0xFFFFFFFF)

#define	JET_sesidNil			((JET_SESID) 	0xFFFFFFFF)

	/* Max size of a bookmark */

#define JET_cbBookmarkMost		256

	/* Max length of a object/column/index/property name */

#define JET_cbNameMost			64

	/* Max length of a "name.name.name..." construct */

#define JET_cbFullNameMost		255

	/* Max size of non-long-value column data */

#define JET_cbColumnMost		255

	/* Max size of a sort/index key */

#define JET_cbKeyMost			255

	/* Max number of components in a sort/index key */

#define JET_ccolKeyMost			10

	/* Max number of columns in a table/query */

#define JET_ccolTableMost		255

	/* Max Length of a property in the property manager */
#define JET_cbPropertyMost 2048

	/* Largest initial substring of a long value used in an expression */

#define JET_cbExprLVMost		0x8000L	/*** 32 K ***/

	/* Max size of returned (from SQLDriverConnect) conn string */

#define JET_cbConnectMost		255

	/* Max number of levels in an MGB */

#define JET_wGroupLevelMax		12

	/* Size restrictions for Pins */
#define JET_cchPINMax			20
#define JET_cchPINMin			4


	/* System parameter codes for JetSetSystemParameter */

#define JET_paramSysDbPath			0	/* Path to the system database */
#define JET_paramTempPath			1	/* Path to the temporary file directory */
#define JET_paramPfnStatus			2	/* Status callback function */
#define JET_paramPfnError			3	/* Error callback function */
#define JET_paramHwndODBC			4	/* Window handle for ODBC use */
#define JET_paramIniPath			5	/* Path to the ini file */
#define JET_paramPageTimeout		6	/* Red ISAM page timeout value */
#define JET_paramODBCQueryTimeout	7	/* ODBC async query timeout value */
#define JET_paramMaxBuffers			8	/* Bytes to use for page buffers */
#define JET_paramMaxSessions		9	/* Maximum number of sessions */
#define JET_paramMaxOpenTables		10	/* Maximum number of open tables */
#define JET_paramMaxVerPages		11	/* Maximum number of modified pages */
#define JET_paramMaxCursors			12	/* Maximum number of open cursors */
#define JET_paramLogFilePath		13	/* Path to the log file directory */
#define JET_paramMaxOpenTableIndexes 14	/* Maximum open table indexes */
#define JET_paramMaxTemporaryTables	15	/* Maximum concurrent JetCreateIndex */
#define JET_paramLogBuffers			16	/* Maximum log buffers */
#define JET_paramLogFileSectors		17	/* Maximum log sectors per log file */
#define JET_paramLogFlushThreshold	18	/* Log buffer flush threshold */
#define JET_paramBfThrshldLowPrcnt	19	/* Low threshold ( % ) for buffers */
#define JET_paramBfThrshldHighPrcnt	20	/* High threshold ( % ) for buffers */
#define JET_paramWaitLogFlush		21	/* msec for waiting log flush */
#define JET_paramLogFlushPeriod		22	/* msec for waiting log flush */
#define JET_paramLogCheckpointPeriod 23	/* msec for waiting log flush */
#define JET_paramLogWaitingUserMax	24	/* Maximum # user waiting log flush */
#define JET_paramODBCLoginTimeout	25	/* ODBC connection attempt timeout value */
#define JET_paramExprObject			26  /* Expression Evaluation callback */
#define JET_paramGetTypeComp			27	/* Expression Evaluation callback */
#define JET_paramHostVersion			28	/* Host Version callback */
#define JET_paramSQLTraceMode			29	/* Enable/disable SQL tracing */
#define JET_paramRecovery				30	/* Switch for log on/off */
#define JET_paramRestorePath			31	/* Path to restoring directory */
#define JET_paramTransactionLevel	32	/* Transaction level of session */
#define JET_paramSessionInfo			33	/* Session info */
#define JET_paramPageFragment			34	/* Largest page extent considered fragment */
#define JET_paramJetInternal			35	/* Whether internal to JET; if set, allows ISAM to do things which are prevented in general */
#define JET_paramMaxOpenDatabases	36	/*	Maximum number of open databases */
#define JET_paramOnLineCompact		37 /*	Options for compact pages on-line */
#define JET_paramFullQJet		38	/* Allow full QJet functionality */
#define JET_paramRmtXactIsolation	39	/* Do not share connections with other sessions */
#define JET_paramBufLRUKCorrInterval 40
#define JET_paramBufBatchIOMax		41
#define JET_paramPageReadAheadMax	42
#define JET_paramAsynchIOMax		43

#define JET_paramAssertAction		44 /*	debug only determines action on assert */

#define JET_paramEventSource		45	/* NT event log */
#define JET_paramEventId			46	/* NT event id */
#define JET_paramEventCategory		47	/* NT event category */


	/* Flags for JetIdle */

#define JET_bitIdleRemoveReadLocks	0x00000001
#define JET_bitIdleFlushBuffers		0x00000002
#define JET_bitIdleCompact				0x00000004

	/* Flags for JetEndSession */

#define JET_bitForceSessionClosed	0x00000001

	/* Flags for JetOpenDatabase */

#define JET_bitDbReadOnly			0x00000001
#define JET_bitDbExclusive			0x00000002 /* multiple opens allowed */
#define JET_bitDbRemoteSilent		0x00000004
#define JET_bitDbSingleExclusive	0x00000008 /* opened exactly once */

	/* Flags for JetCloseDatabase */

#define JET_bitDbForceClose		0x00000001

	/* Flags for JetCreateDatabase */

#define JET_bitDbEncrypt			0x00000001
#define JET_bitDbVersion10			0x00000002
#define JET_bitDbVersion1x			0x00000004
#define JET_bitDbRecoveryOff 		0x00000008 /* disable logging/recovery */
#define JET_bitDbNoLogging	 		0x00000010 /* no logging */
#define JET_bitDbCompleteConnstr	0x00000020

	/* Flags for JetBackup */

#define JET_bitBackupIncremental		0x00000001
#define JET_bitKeepOldLogs				0x00000002
#define JET_bitOverwriteExisting		0x00000004

	/* Database types */

#define JET_dbidNil			((JET_DBID) 0xFFFFFFFF)
#define JET_dbidNoValid		((JET_DBID) 0xFFFFFFFE) /* used as a flag to indicate that there is no valid dbid */

	/* Flags for JetCreateLink */

/* Can use JET_bitObjectExclusive to cause linked to database to be opened */
/* exclusively.															   */

	/* Flags for JetAddColumn, JetGetColumnInfo, JetOpenTempTable */

#define JET_bitColumnFixed				0x00000001
#define JET_bitColumnTagged			0x00000002
#define JET_bitColumnNotNULL			0x00000004
#define JET_bitColumnVersion			0x00000008
#define JET_bitColumnAutoincrement	0x00000010
#define JET_bitColumnUpdatable		0x00000020 /* JetGetColumnInfo only */
#define JET_bitColumnTTKey				0x00000040 /* JetOpenTempTable only */
#define JET_bitColumnTTDescending	0x00000080 /* JetOpenTempTable only */
#define JET_bitColumnNotLast			0x00000100 /* Installable ISAM option */
#define JET_bitColumnRmtGraphic		0x00000200 /* JetGetColumnInfo */
#define JET_bitColumnMultiValued		0x00000400

	/* Flags for JetMakeKey */

#define JET_bitNewKey				0x00000001
#define JET_bitStrLimit 			0x00000002
#define JET_bitSubStrLimit			0x00000004
#define JET_bitNormalizedKey 		0x00000008
#define JET_bitKeyDataZeroLength	0x00000010

#ifdef DBCS /* johnta: LIKE "ABC" not converted to ="ABC" for Japanese */
#define JET_bitLikeExtra1			0x00000020
#endif /* DBCS */

	/* Flags for ErrDispSetIndexRange */

#define JET_bitRangeInclusive		0x00000001    /* CONSIDER: Internal */
#define JET_bitRangeUpperLimit		0x00000002    /* CONSIDER: Internal */

	/* Constants for JetMove */

#define JET_MoveFirst			(0x80000000)
#define JET_MovePrevious		(-1)
#define JET_MoveNext				(+1)
#define JET_MoveLast				(0x7fffffff)

	/* Flags for JetMove */

#define JET_bitMoveKeyNE		0x00000001
#define JET_bitMoveCheckTS		0x00000002
#define JET_bitMoveInPage		0x00000004

	/* Flags for JetSeek */

#define JET_bitSeekEQ			0x00000001
#define JET_bitSeekLT			0x00000002
#define JET_bitSeekLE			0x00000004
#define JET_bitSeekGE			0x00000008
#define JET_bitSeekGT		 	0x00000010
#define JET_bitSetIndexRange	0x00000020

	/* Flags for JetFastFind */

#define JET_bitFFindBackwards		0x00000001
#define JET_bitFFindFromCursor		0x00000004

	/* Flags for JetCreateIndex */

#define JET_bitIndexUnique		0x00000001
#define JET_bitIndexPrimary		0x00000002
#define JET_bitIndexDisallowNull	0x00000004
#define JET_bitIndexIgnoreNull		0x00000008
#define JET_bitIndexClustered		0x00000010
#define JET_bitIndexIgnoreAnyNull	0x00000020
#define JET_bitIndexReference		0x80000000    /* IndexInfo only */

	/* Flags for index key definition */

#define JET_bitKeyAscending		0x00000000
#define JET_bitKeyDescending		0x00000001


	/* Flags for JetCreateRelationship */

#define JET_bitRelationUnique			0x00000001
#define JET_bitRelationDontEnforce		0x00000002
#define JET_bitRelationInherited		0x00000004
#define JET_bitRelationTestLegal		0x00000008	/* don't create relationship */

#define JET_bitRelationshipMatchMask	0x000000F0
#define JET_bitRelationMatchDefault		0x00000000
#define JET_bitRelationMatchFull		0x00000010

#define JET_bitRelationUpdateActionMask	0x00000F00
#define JET_bitRelationUpdateDisallow	0x00000000
#define JET_bitRelationUpdateCascade	0x00000100
#define JET_bitRelationUpdateSetNull	0x00000200
#define JET_bitRelationUpdateSetDefault	0x00000300

#define JET_bitRelationDeleteActionMask	0x0000F000
#define JET_bitRelationDeleteDisallow	0x00000000
#define JET_bitRelationDeleteCascade	0x00001000
#define JET_bitRelationDeleteSetNull	0x00002000
#define JET_bitRelationDeleteSetDefault	0x00003000

#define JET_bitRelationUserMask			0xFF000000	/* non-enforced values */
#define JET_bitRelationJoinMask			0x03000000
#define JET_bitRelationInner			0x00000000
#define JET_bitRelationLeft				0x01000000
#define JET_bitRelationRight			0x02000000


	/* Flags for JetCreateReference/JetCreateRelationship */
	/* NOTE: use the bitRelationship flags instead! */

#define JET_ReferenceUnique				JET_bitRelationUnique
#define JET_ReferenceDontEnforce		JET_bitRelationDontEnforce
#define JET_ReferenceMatchTypeMask		JET_bitRelationMatchMask
#define JET_ReferenceMatchDefault		JET_bitRelationMatchDefault
#define JET_ReferenceMatchFull			JET_bitRelationMatchFull
#define JET_ReferenceUpdateActionMask	JET_bitRelationUpdateActionMask
#define JET_ReferenceUpdateDisallow		JET_bitRelationUpdateDisallow
#define JET_ReferenceUpdateCascade		JET_bitRelationUpdateCascade
#define JET_ReferenceUpdateSetNull		JET_bitRelationUpdateSetNull
#define JET_ReferenceUpdateSetDefault	JET_bitRelationUpdateSetDefault
#define JET_ReferenceDeleteActionMask	JET_bitRelationDeleteActionMask
#define JET_ReferenceDeleteDisallow		JET_bitRelationDeleteDisallow
#define JET_ReferenceDeleteCascade		JET_bitRelationDeleteCascade
#define JET_ReferenceDeleteSetNull		JET_bitRelationDeleteSetNull
#define JET_ReferenceDeleteSetDefault	JET_bitRelationDeleteSetDefault


	/* Flags for JetOpenTable */

#define JET_bitTableDenyWrite		0x00000001
#define JET_bitTableDenyRead		0x00000002
#define JET_bitTableReadOnly		0x00000004
#define JET_bitTableAppendOnly		0x00000008
#define JET_bitTableUpdatable		0x00000010
#define JET_bitTableScrollable		0x00000020
#define JET_bitTableFixedSet		0x00000040	/* Fixed working set */
#define JET_bitTableInconsistent	0x00000080
#define JET_bitTableBulk			0x00000100
#define JET_bitTableUsePrimaryIndex	0x00000200	/* Use with FixedSet */
#define JET_bitTableSampleData		0x00000400
#define JET_bitTableQuickBrowse		0x00000800	/* Bias optimizer toward index usage */
#define JET_bitTableDDL				0x00001000	/* similar to JET_bitTableBulk, for DDL */
#define JET_bitTablePassThrough		0x00002000  /* Remote DBs Only */
#define JET_bitTableRowReturning	0x00004000

	/* Flags for JetSetQoSql/JetRetrieveQoSql */
#define JET_bitSqlPassThrough		0x00000001	/* Pass through Query returning records */
#define JET_bitSqlSPTBulkOp			0x00000002  /* SPT query returning no table */
	
	/* Flags for JetOpenVtQbe */

#define JET_bitQBEAddBrackets		0x00000001
#define JET_bitQBERemoveEquals		0x00000002

	/* Flags for JetOpenTempTable and ErrIsamOpenTempTable */

#define JET_bitTTIndexed		0x00000001	/* Allow seek */
#define JET_bitTTUnique 		0x00000002	/* Remove duplicates */
#define JET_bitTTUpdatable		0x00000004	/* Allow updates */
#define JET_bitTTScrollable		0x00000008	/* Allow backwards scrolling */

	/* Flags for JetSetColumn */

#define JET_bitSetAppendLV			0x00000001
#define JET_bitSetValidate			0x00000002
#define JET_bitSetOverwriteLV		0x00000004
#define JET_bitSetSizeLV			0x00000008
#define JET_bitSetValidateColumn	0x00000010
#define JET_bitSetZeroLength		0x00000020

	/*	Set column parameter structure for JetSetColumns */

typedef struct {
	JET_COLUMNID			columnid;
	const void _far 		*pvData;
	unsigned long 			cbData;
	JET_GRBIT				grbit;
	unsigned long			ibLongValue;
	unsigned long			itagSequence;
	JET_ERR					err;
} JET_SETCOLUMN;

	/* Options for JetPrepareUpdate */

#define JET_prepInsert			0
#define JET_prepInsertBeforeCurrent	1
#define JET_prepReplace 		2
#define JET_prepCancel			3
#define JET_prepReplaceNoLock		4
#define JET_prepInsertCopy			5

	/* Flags for JetRetrieveColumn */

#define JET_bitRetrieveCopy			0x00000001
#define JET_bitRetrieveFromIndex		0x00000002
#define JET_bitRetrieveCase			0x00000004
#define JET_bitRetrieveTag				0x00000008
#define JET_bitRetrieveRecord			0x80000000
#define JET_bitRetrieveFDB				0x40000000
#define JET_bitRetrieveBookmarks		0x20000000

	/* Retrieve column parameter structure for JetRetrieveColumns */

typedef struct {
	JET_COLUMNID		columnid;
	void _far 			*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;

	/* Flags for JetFillFatCursor */

#define JET_bitFCFillRange		0x00000001
#define JET_bitFCRefreshRange		0x00000002
#define JET_bitFCFillMemos		0x00000004

	/* Flags for JetCommitTransaction */

#define JET_bitCommitFlush		0x00000001

	/* Flags for JetRollback */

#define JET_bitRollbackAll		0x00000001

	/* Flags for JetSetAccess and JetGetAccess */

#define JET_bitACEInheritable		0x00000001

	/* Flags for JetCreateSystemDatabase */

#define JET_bitSysDbOverwrite	0x00000001

	/* Flags for Jet Property Management */
#define JET_bitPropDDL				0x00000001		/* also used for setting */
#define JET_bitPropInherited		0x00000002		/* not used for setting */

	/* JPM Flags that are only used for setting properties */
#define JET_bitPropReplaceOnly		0x00000010
#define JET_bitPropInsertOnly		0x00000020
#define JET_bitPropDeleteOnly		0x00000040
	
	/* InfoLevels for Jet Property Management */
#define JET_PropertyValue				0
#define JET_PropertyCount				1
#define JET_PropertySingleCollection 	2
#define JET_PropertyAllCollections		3

	/* Collate values for JetGetColumnInfo and JetGetIndexInfo */

#define JET_sortBinary			0x0000
#define JET_sortEFGPI			0x0100
#define JET_sortSNIFD			0x0101
#define JET_sortSpanish 		0x0102
#define JET_sortDutch			0x0103
#define JET_sortSweFin			0x0104
#define JET_sortNorDan			0x0105
#define JET_sortIcelandic		0x0106
#define JET_sortCyrillic		0x0107
#define JET_sortCzech			0x0108
#define JET_sortHungarian		0x0109
#define JET_sortPolish			0x010A
#define JET_sortArabic			0x010B
#define JET_sortHebrew			0x010C
#define JET_sortMax				0x010C		/* Max for nonDBCS sort orders */

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
#define JET_sortJapanese		0x010D
#endif /* DBCS */

#define JET_sortUnknown 		0xFFFF

	/* Paradox ISAM specific collate values */

#define JET_sortPdxIntl 		0x1000
#define JET_sortPdxSwedFin		0x1001
#define JET_sortPdxNorDan		0x1002

	/* Info parameter for JetGetDatabaseInfo */

#define JET_DbInfoFilename		0
#define JET_DbInfoConnect		1
#define JET_DbInfoCountry		2
#define JET_DbInfoLangid		3
#define JET_DbInfoCp			4
#define JET_DbInfoCollate		5
#define JET_DbInfoOptions		6
#define JET_DbInfoTransactions	7
#define JET_DbInfoVersion		8
#define JET_DbInfoIsam			9

	/* Database versions returned by JetGetDatabaseInfo */

#define JET_DbVersion10			0x00010000
#define JET_DbVersion11			0x00010001
#define JET_DbVersion20			0x00020000


	/* Isam specific info returned by JetGetDatabaseInfo */

#define JET_IsamInvalid			0
#define JET_IsamBuiltinRed		1
#define JET_IsamBuiltinBlue		2

#define	JET_IsamInstRed			21
#define JET_IsamInstBlue		22
#define	JET_IsamInstFox			23
#define JET_IsamInstParadox		24
#define JET_IsamInstDbase		25
#define	JET_IsamInstBtrieve		26

#define JET_IsamBuilinMost		JET_BuiltinBlue
#define JET_IsamInstMin			JET_IsamInstRed
#define	JET_IsamInstMost		JET_IsamInstBtrieve

	/* Link specific info for link identification */
#define JET_bitLinkInvalid		0x00000000
#define JET_bitLinkRemote		0x00100000
#define JET_bitLinkBuiltinRed	0x00200000
#define JET_bitLinkBuiltinBlue	0x00300000
#define JET_bitLinkInstRed		0x00400000
#define JET_bitLinkInstBlue		0x00500000
#define JET_bitLinkInstFox		0x00600000
#define JET_bitLinkInstParadox	0x00700000
#define JET_bitLinkInstDbase	0x00800000
#define JET_bitLinkInstBtrieve	0x00900000

#define JET_bitFourByteBookmark		0x00000001
#define	JET_bitContiguousBookmarks	0x00000002

	/* Column data types */

	/* the column types are represented with 4 bits */
	/* make sure the choices below fit!				*/
	/* NOTE:  all comb of the 4 bits are now used! */
	/* CONSIDER:  to allow more datatypes, either 				 */
	/* CONSIDER:  JET_coltypDatabase and JET_coltypTableid	must */
	/* CONSIDER:  change or the 4 bit dependancy must be removed */

#define JET_coltypNil				0
#define JET_coltypBit				1      /* True or False, Never NULL */
#define JET_coltypUnsignedByte		2      /* 1-byte integer, unsigned */
#define JET_coltypShort 			3      /* 2-byte integer, signed */
#define JET_coltypLong				4      /* 4-byte integer, signed */
#define JET_coltypCurrency			5      /* 8 byte integer, signed */
#define JET_coltypIEEESingle		6      /* 4-byte IEEE single precision */
#define JET_coltypIEEEDouble		7      /* 8-byte IEEE double precision */
#define JET_coltypDateTime			8      /* Integral date, fractional time */
#define JET_coltypBinary			9      /* Binary data, < 255 bytes */
#define JET_coltypText				10     /* ANSI text, case insensitive, < 255 bytes */
#define JET_coltypLongBinary		11     /* Binary data, long value */
#define JET_coltypLongText			12     /* ANSI text, long value */

	/* The following are additional types used for query parameters */
	/* NOTE:  Code depends on these being contiguous with the normal coltyps */
	/* CONSIDER:  Remove the above dependency on contiguous coltyps in QJET */

#define JET_coltypDatabase			13		/* Database name parameter */
#define JET_coltypTableid			14		/* Tableid parameter */

#define JET_coltypOLE				15		/* OLE blob */

#define JET_coltypMax				16		/* the number of column types  */
											/* used for validity tests and */
											/* array declarations.		   */

	/* Info levels for JetGetObjectInfo */

#define JET_ObjInfo					0U
#define JET_ObjInfoListNoStats		1U
#define JET_ObjInfoList 			2U
#define JET_ObjInfoSysTabCursor 	3U
#define JET_ObjInfoListACM			4U /* Blocked by JetGetObjectInfo */
#define JET_ObjInfoNoStats			5U
#define JET_ObjInfoSysTabReadOnly	6U
#define JET_ObjInfoRulesLoaded		7U
#define JET_ObjInfoMax				8U

	/* Info levels for JetGetTableInfo */

#define JET_TblInfo				0U
#define JET_TblInfoName			1U
#define JET_TblInfoDbid			2U
#define JET_TblInfoMostMany  	3U
#define JET_TblInfoRvt			4U
#define JET_TblInfoOLC			5U
#define JET_TblInfoResetOLC 	6U
#define JET_TblInfoSpaceUsage	7U
#define JET_TblInfoDumpTable	8U

	/* Info levels for JetGetIndexInfo and JetGetTableIndexInfo */

#define JET_IdxInfo					0U
#define JET_IdxInfoList 			1U
#define JET_IdxInfoSysTabCursor 	2U
#define JET_IdxInfoOLC				3U
#define JET_IdxInfoResetOLC			4U

	/* Info levels for JetGetReferenceInfo and JetGetTableReferenceInfo */

#define JET_ReferenceInfo		0U
#define JET_ReferenceInfoReferencing	1U
#define JET_ReferenceInfoReferenced	2U
#define JET_ReferenceInfoAll		3U
#define JET_ReferenceInfoCursor 	4U

	/* Info levels for JetGetColumnInfo and JetGetTableColumnInfo */

#define JET_ColInfo			0U
#define JET_ColInfoList 		1U

	/* CONSIDER: Info level 2 is valid */

#define JET_ColInfoSysTabCursor 	3U
#define JET_ColInfoBase 		4U


	/* Attribute types for query definitions */

#define JET_qoaBeginDef 		0
#define JET_qoaOperation		1
#define JET_qoaParameter		2
#define JET_qoaOptions			3
#define JET_qoaDatabase 		4
#define JET_qoaInputTable		5
#define JET_qoaOutput			6
#define JET_qoaJoin			7
#define JET_qoaRestriction		8
#define JET_qoaGroup			9
#define JET_qoaGroupRstr		10
#define JET_qoaOrdering 		11
#define JET_qoaEndDef			255
#define JET_qoaValidLeast		JET_qoaOperation
#define JET_qoaValidMost		JET_qoaOrdering


	/* Query object options */

#define JET_bitFqoOutputAllCols 	0x0001
#define JET_bitFqoRemoveDups		0x0002
#define JET_bitFqoOwnerAccess		0x0004
#define JET_bitFqoDistinctRow		0x0008
#define JET_bitFqoTop				0x0010
#define JET_bitFqoPercent			0x0020
#define JET_bitFqoCorresponding		0x0040 /* JET_qopSetOperation */

	/* Query object join type */

#define JET_fjoinInner			1
#define JET_fjoinLeftOuter		2
#define JET_fjoinRightOuter		3

	/* Query object operations */

#define JET_qopSelect			1
#define JET_qopSelectInto		2
#define JET_qopInsertSelection	3
#define JET_qopUpdate			4
#define JET_qopDelete			5
#define JET_qopTransform		6
#define JET_qopDDL				7
#define JET_qopSqlPassThrough	8
#define JET_qopSetOperation		9
#define JET_qopSPTBulk			10

#define JET_bitqopSelect			0x0000
#define JET_bitqopTransform			0x0010
#define JET_bitqopDelete			0x0020
#define JET_bitqopUpdate			0x0030
#define JET_bitqopInsertSelection	0x0040
#define JET_bitqopSelectInto		0x0050
#define JET_bitqopDDL				0x0060
#define JET_bitqopSqlPassThrough	0x0070
#define JET_bitqopSetOperation		0x0080
#define JET_bitqopSPTBulk			0x0090

	/* Engine Object Types */

#define JET_objtypNil			0
#define JET_objtypTable 		1
#define JET_objtypDb			2
#define JET_objtypContainer		3
#define JET_objtypSQLLink		4
#define JET_objtypQuery 		5
#define JET_objtypLink			6
#define JET_objtypTemplate		7
#define JET_objtypRelationship		8

	/* All types less than JET_objtypClientMin are reserved by JET */

#define JET_objtypClientMin		0x8000

	/* Security Constant Values */

#define JET_cchUserNameMax		20
#define JET_cchPasswordMax		14

	/* Security Access Masks */

#define JET_acmNoAccess 		0x00000000L
#define JET_acmFullAccess		0x000FFFFFL

#define JET_acmSpecificMask		0x0000FFFFL
#define JET_acmSpecific_1		0x00000001L
#define JET_acmSpecific_2		0x00000002L
#define JET_acmSpecific_3		0x00000004L
#define JET_acmSpecific_4		0x00000008L
#define JET_acmSpecific_5		0x00000010L
#define JET_acmSpecific_6		0x00000020L
#define JET_acmSpecific_7		0x00000040L
#define JET_acmSpecific_8		0x00000080L
#define JET_acmSpecific_9		0x00000100L
#define JET_acmSpecific_10		0x00000200L
#define JET_acmSpecific_11		0x00000400L
#define JET_acmSpecific_12		0x00000800L
#define JET_acmSpecific_13		0x00001000L
#define JET_acmSpecific_14		0x00002000L
#define JET_acmSpecific_15		0x00004000L
#define JET_acmSpecific_16		0x00008000L

#define JET_acmStandardMask		0x00FF0000L
#define JET_acmDelete			0x00010000L
#define JET_acmReadControl		0x00020000L
#define JET_acmWriteDac 		0x00040000L
#define JET_acmWriteOwner		0x00080000L

#define JET_acmTblCreate		(JET_acmSpecific_1)
#define JET_acmTblAccessRcols		(JET_acmSpecific_2)
#define JET_acmTblReadDef		(JET_acmSpecific_3)
#define JET_acmTblWriteDef		(JET_acmSpecific_4)
#define JET_acmTblRetrieveData		(JET_acmSpecific_5)
#define JET_acmTblInsertData		(JET_acmSpecific_6)
#define JET_acmTblReplaceData		(JET_acmSpecific_7)
#define JET_acmTblDeleteData		(JET_acmSpecific_8)

#define JET_acmDbCreate 		(JET_acmSpecific_1)
#define JET_acmDbOpen			(JET_acmSpecific_2)

	/* Compact Options */

#define JET_bitCompactEncrypt		0x00000001	/* Dest is encrypted */
#define JET_bitCompactDecrypt		0x00000002	/* Dest is not encrypted */
#define JET_bitCompactDontCopyLocale	0x00000004	/* Don't copy locale from source to dest */
#define JET_bitCompactVersion10		0x00000008	/* Destination is version 1.0 format */
#define JET_bitCompactVersion1x		0x00000010	/* Destination is version 1.x format */

	/* On-line Compact Options */

#define JET_bitCompactOn	 		0x00000001	/* enable on-line compaction */

	/* Repair Notification Types */

#define JET_rntSelfContained		0	/* CONSIDER: These are SNCs */
#define JET_rntDeletedIndex		1
#define JET_rntDeletedRec		2
#define JET_rntDeletedLv		3
#define JET_rntTruncated		4

	/* Status Notification Processes */

#define JET_snpIndex			0
#define JET_snpQuery			1
#define JET_snpRepair			2
#define JET_snpImex				3
#define JET_snpCompact			4
#define JET_snpFastFind 		5
#define JET_snpODBCNotReady		6
#define JET_snpQuerySort		7
#define JET_snpRestore			8

	/* Status Notification Types */

#define JET_sntProgress 		0	/* callback for progress */
#define JET_sntMessage			1
#define JET_sntBulkRecords		2	/* callback for # rec for bulk op */
#define JET_sntFail				3	/* callback for failure during progress */
#define JET_sntErrCount 		4	/* callback for err count */
#define JET_sntBegin			5	/* callback for beginning of operation */
#define JET_sntComplete 		6	/* callback for completion of operation */
#define JET_sntCantRollback		7	/* callback for no rollback */
#define JET_sntRestoreMap		8	/* callback for restore map */

	/* Message codes for JET_snpCompact */

#define JET_sncCopyObject		0	/* Starting to copy object */
#define JET_sncCopyFailed		1	/* Copy of this object failed */
#define JET_sncYield			2	/* Client can yield/check for user interrupt */
#define JET_sncTransactionFull		3	/* Client can yield/check for user interrupt */
#define JET_sncAboutToWrap		4	/* Find find is about to wrap */

	/* Message codes for JET_snpODBCNotReady */
#define JET_sncODBCNotReady		0	/* Waiting for results from ODBC */


	/* Constants for the [ODBC] section of JET.INI */

#define JET_SQLTraceCanonical	0x0001	/* Output ODBC Generic SQL */

	/* Constants for the [Debug] section of JET.INI */

	/* APITrace */

#define JET_APITraceEnter	0x0001
#define JET_APITraceExit	0x0002
#define JET_APITraceExitError	0x0004
#define JET_APIBreakOnError	0x0008
#define JET_APITraceCount	0x0010
#define JET_APITraceNoIdle	0x0020
#define JET_APITraceParameters	0x0040

	/* IdleTrace */

#define JET_IdleTraceCursor	0x0001
#define JET_IdleTraceBuffer	0x0002
#define JET_IdleTraceFlush	0x0004

	/* AssertAction */

#define JET_AssertExit		0x0000		/* Exit the application */
#define JET_AssertBreak 	0x0001		/* Break to debugger */
#define JET_AssertMsgBox	0x0002		/* Display message box */
#define JET_AssertStop		0x0004		/* Alert and stop */

	/* IOTrace */

#define JET_IOTraceAlloc	0x0001		/* DB Page Allocation */
#define JET_IOTraceFree 	0x0002		/* DB Page Free */
#define JET_IOTraceRead 	0x0004		/* DB Page Read */
#define JET_IOTraceWrite	0x0008		/* DB Page Write */
#define JET_IOTraceError	0x0010		/* DB Page I/O Error */

	/* MemTrace */

#define JET_MemTraceAlloc	0x0001		/* Memory allocation */
#define JET_MemTraceRealloc	0x0002		/* Memory reallocation */
#define JET_MemTraceFree	0x0004		/* Memory free */

	/* RmtTrace */

#define JET_RmtTraceError	0x0001	/* Remote server error message */
#define JET_RmtTraceSql		0x0002	/* Remote SQL Prepares & Exec's */
#define JET_RmtTraceAPI		0x0004	/* Remote ODBC API calls */
#define JET_RmtTraceODBC	0x0008
#define JET_RmtSyncODBC		0x0010	/* Turn on ODBC Sync mode */

/**********************************************************************/
/***********************     ERROR CODES     **************************/
/**********************************************************************/

/* SUCCESS */

#define JET_errSuccess			 0    /* Successful Operation */

/* ERRORS */

#define JET_wrnNyi							-1    /* Function Not Yet Implemented */

/*	SYSTEM errors
/**/
#define JET_errRfsFailure			   		-100	/* JET_errRfsFailure */
#define JET_errRfsNotArmed					-101	/* JET_errRfsFailure */
#define JET_errFileClose					-102	/* Could not close DOS file */
#define JET_errNoMoreThreads				-103	/* Could not start thread */
#define JET_errNoComputerName	  			-104	/* fail to get computername */
#define JET_errTooManyIO		  			-105	/* System busy due to too many IOs */

/*	BUFFER MANAGER errors
/**/
#define wrnBFNotSynchronous					200			/* Buffer page evicted */
#define wrnBFPageNotFound		  			201			/* Page not found */
#define errBFInUse				  			-202		/* Cannot abandon buffer */

/*	DIRECTORY MANAGER errors
/**/
#define errPMOutOfPageSpace					-300		/* Out of page space */
#define errPMItagTooBig 		  			-301		/* Itag too big */
#define errPMRecDeleted 		  			-302		/* Record deleted */
#define errPMTagsUsedUp 		  			-303		/* Tags used up */
#define wrnBMConflict			  			304     	/* conflict in BM Clean up */
#define errDIRNoShortCircuit	  			-305		/* No Short Circuit Avail */
#define errDIRCannotSplit		  			-306		/* Cannot horizontally split FDP */
#define errDIRTop				  			-307		/* Cannot go up */
#define errDIRFDP							308			/* On an FDP Node */
#define errDIRNotSynchronous				-309		/* May have left critical section */
#define wrnDIREmptyPage						310			/* Moved through empty page */
#define errSPConflict						-311		/* Device extent being extended */
#define wrnNDFoundLess						312			/* Found Less */
#define wrnNDFoundGreater					313			/* Found Greater */
#define errNDOutSonRange					-314		/* Son out of range */
#define errNDOutItemRange					-315		/* Item out of range */
#define errNDGreaterThanAllItems 			-316		/* Greater than all items */
#define errNDLastItemNode					-317		/* Last node of item list */
#define errNDFirstItemNode					-318		/* First node of item list */
#define wrnNDDuplicateItem					319			/* Duplicated Item */
#define errNDNoItem							-320		/* Item not there */
#define JET_wrnRemainingVersions 			321			/* Some versions couldn't be cleaned */
#define JET_wrnPreviousVersion				322			/* Version already existed */
#define JET_errPageBoundary					-323		/* Reached Page Boundary */
#define JET_errKeyBoundary		  			-324		/* Reached Key Boundary */
#define errDIRInPageFather  				-325		/* sridFather in page to free

/*	RECORD MANAGER errors
/**/
#define wrnFLDKeyTooBig 					400			/* Key too big (truncated it) */
#define errFLDTooManySegments				-401		/* Too many key segments */
#define wrnFLDNullKey						402			/* Key is entirely NULL */
#define wrnFLDOutOfKeys 					403			/* No more keys to extract */
#define wrnFLDNullSeg						404			/* Null segment in key */
#define wrnRECLongField 					405			/* Separated long field */
#define JET_wrnRecordFoundGreater			JET_wrnSeekNotEqual
#define JET_wrnRecordFoundLess    			JET_wrnSeekNotEqual
#define JET_errColumnIllegalNull  			JET_errNullInvalid

/*	LOGGING/RECOVERY errors
/**/
#define JET_errRestoreFailed   				-500		/* Restore failed */
#define JET_errLogFileCorrupt		  		-501		/* Log file is corrupt */
#define errLGNoMoreRecords					-502		/* Last log record read */
#define JET_errNoBackupDirectory 			-503		/* No backup directory given */
#define JET_errBackupDirectoryNotEmpty 		-504		/* The backup directory is not emtpy */
#define JET_errBackupInProgress 			-505		/* Backup is active already */
#define JET_errFailRestoreDatabase 			-506		/* Fail to restore (copy) database */
#define JET_errNoDatabasesForRestore 		-507		/* No databases for restor found */
#define JET_errMissingLogFile	   			-508		/* jet.log for restore is missing */
#define JET_errMissingPreviousLogFile		-509		/* Missing the log file for check point */
#define JET_errLogWriteFail					-510		/* Fail when writing to log file */
#define JET_errLogNotContigous	 			-511		/* Fail to incremental backup for non-contiguous generation number */
#define JET_errFailToMakeTempDirectory		-512		/* Fail to make a temp directory */
#define JET_errFailToCleanTempDirectory		-513		/* Fail to clean up temp directory */
#define JET_errBadLogVersion  	  			-514		/* Version of log file is not compatible with Jet version */
#define JET_errBadNextLogVersion   			-515		/* Version of next log file is not compatible with current one */
#define JET_errLoggingDisabled 				-516		/* Log is not active */
#define JET_errLogBufferTooSmall			-517		/* Log buffer is too small for recovery */
#define errLGNotSynchronous					-518		/* retry to LGLogRec */

#define JET_errFeatureNotAvailable	-1001 /* API not supported */
#define JET_errInvalidName		-1002 /* Invalid name */
#define JET_errInvalidParameter 	-1003 /* Invalid API parameter */
#define JET_wrnColumnNull		 1004 /* Column is NULL-valued */
#define JET_errReferenceNotFound	-1005 /* No such reference */
#define JET_wrnBufferTruncated		 1006 /* Buf too short, data truncated */
#define JET_wrnDatabaseAttached 	 1007 /* Database is already attached */
#define JET_wrnOnEndPoint		 1008 /* On end point */
#define JET_wrnSortOverflow		 1009 /* Sort does not fit in memory */
#define JET_errInvalidDatabaseId	-1010 /* Invalid database id */
#define JET_errOutOfMemory		-1011 /* Out of Memory */
#define JET_errCantAllocatePage 	-1012 /* Couldn't allocate a page */
#define JET_errNoMoreCursors		-1013 /* Max # of cursors allocated */
#define JET_errOutOfBuffers		-1014 /* JET_errOutOfBuffers */
#define JET_errTooManyIndexes		-1015 /* Too many indexes */
#define JET_errTooManyKeys		-1016 /* Too many columns in an index */
#define JET_errRecordDeleted		-1017 /* Record has been deleted */
#define JET_errReadVerifyFailure	-1018 /* Read verification error */
#define JET_errFilesysVersion		-1019 /* Obsolete database format */
#define JET_errNoMoreFiles		-1020 /* No more file handles */
#define JET_errDiskNotReady		-1021 /* Disk not ready */
#define JET_errDiskIO			-1022 /* JET_errDiskIO */
#define JET_errInvalidPath		-1023 /* JET_errInvalidPath */
#define JET_errFileShareViolation	-1024 /* JET_errFileShareViolation */
#define JET_errFileLockViolation	-1025 /* JET_errFileLockViolation */
#define JET_errRecordTooBig		-1026 /* JET_errRecordTooBig */
#define JET_errTooManyOpenDatabases	-1027 /* Database limit reached */
#define JET_errInvalidDatabase		-1028 /* This isn't a database */
#define JET_errNotInitialized		-1029 /* JetInit not yet called */
#define JET_errAlreadyInitialized	-1030 /* JetInit already called */
#define JET_errFileLockingUnavailable	-1031 /* JET_errFileLockingUnavailable */
#define JET_errFileAccessDenied 	-1032 /* JET_errFileAccessDenied */
#define JET_errSharingBufferExceeded	-1033 /* OS sharing buffer exceeded */
#define JET_errQueryNotSupported	-1034 /* Query support unavailable */
#define JET_errSQLLinkNotSupported	-1035 /* SQL Link support unavailable */
#define JET_errTaskLimitExceeded	-1036 /* Too many client tasks */
#define JET_errUnsupportedOSVersion	-1037 /* Unsupported OS version */
#define JET_errBufferTooSmall		-1038 /* Buffer is too small */
#define JET_wrnSeekNotEqual		 1039 /* SeekLE or SeekGE didn't find exact match */
#define JET_errTooManyColumns		-1040 /* Too many columns defined */
#define JET_errTooManyFixedColumns	-1041 /* Too many fixed columns defined */
#define JET_errTooManyVariableColumns	-1042 /* Too many variable columns defined */
#define JET_errContainerNotEmpty	-1043 /* Container is not empty */
#define JET_errInvalidFilename		-1044 /* Filename is invalid */
#define JET_errInvalidBookmark		-1045 /* Invalid bookmark */
#define JET_errColumnInUse		-1046 /* Column used in an index */
#define JET_errInvalidBufferSize	-1047 /* Data buffer doesn't match column size */
#define JET_errColumnNotUpdatable	-1048 /* Can't set column value */
#define JET_wrnCommitNotFlushed 	 1049 /* Commit did not flush to disk */
#define JET_errAbortSalvage		-1050 /* Forced Salvager abort */
#define JET_errIndexInUse		-1051 /* Index is in use */
#define JET_errLinkNotSupported 	-1052 /* Link support unavailable */
#define JET_errNullKeyDisallowed	-1053 /* Null keys are disallowed on index */
#define JET_errNotInTransaction 	-1054 /* JET_errNotInTransaction */
#define JET_wrnNoErrorInfo		 1055 /* No extended error information */
#define JET_errInstallableIsamNotFound	-1056 /* Installable ISAM not found */
#define JET_errOperationCancelled	-1057 /* Operation canceled by client */
#define JET_wrnNoIdleActivity		 1058 /* No idle activity occured */
#define JET_errTooManyActiveUsers	-1059 /* Too many active database users */
#define JET_errInvalidAppend		-1060 /* Cannot append long value */
#define JET_errInvalidCountry		-1061 /* Invalid or unknown country code */
#define JET_errInvalidLanguageId	-1062 /* Invalid or unknown language id */
#define JET_errInvalidCodePage		-1063 /* Invalid or unknown code page */
#define JET_errCantBuildKey		-1064 /* Can't build key for this sort order. */
#define JET_errIllegalReentrancy	-1065 /* Re-entrancy on same cursor family */
#define JET_errIllegalRelationship	-1066 /* Can't create relationship */
#define JET_wrnNoWriteLock					1067	/* No write lock at transaction level 0 */
#define JET_errDBVerFeatureNotAvailable	-1067 /* API not supported using old database format*/

#define JET_errCantBegin		-1101 /* Cannot BeginSession */
#define JET_errWriteConflict		-1102 /* Write lock failed due to outstanding write lock */
#define JET_errTransTooDeep		-1103 /* Xactions nested too deeply */
#define JET_errInvalidSesid		-1104 /* Invalid session handle */
#define JET_errReadConflict		-1105 /* Commit lock failed due to outstanding read lock */
#define JET_errCommitConflict		-1106 /* Read lock failed due to outstanding commit lock */
#define JET_errSessionWriteConflict	-1107 /* Another session has private version of page */
#define JET_errInTransaction		-1108 /* Operation not allowed within a transaction */

#define JET_errDatabaseDuplicate	-1201 /* Database already exists */
#define JET_errDatabaseInUse		-1202 /* Database in use */
#define JET_errDatabaseNotFound 	-1203 /* No such database */
#define JET_errDatabaseInvalidName	-1204 /* Invalid database name */
#define JET_errDatabaseInvalidPages	-1205 /* Invalid number of pages */
#define JET_errDatabaseCorrupted	-1206 /* non-db file or corrupted db */
#define JET_errDatabaseLocked		-1207 /* Database exclusively locked */
#define JET_wrnDatabaseEncrypted	 1208 /* Database is encrypted */

#define JET_wrnTableEmpty			 1301 /* Open an empty table */
#define JET_errTableLocked			-1302 /* Table is exclusively locked */
#define JET_errTableDuplicate		-1303 /* Table already exists */
#define JET_errTableInUse			-1304 /* Table is in use, cannot lock */
#define JET_errObjectNotFound		-1305 /* No such table or object */
#define JET_errCannotRename			-1306 /* Cannot rename temporary file */
#define JET_errDensityInvalid		-1307 /* Bad file/index density */
#define JET_errTableNotEmpty		-1308 /* Cannot define clustered index */
#define JET_errTableNotLocked		-1309 /* No DDLs w/o exclusive lock */
#define JET_errInvalidTableId		-1310 /* Invalid table id */
#define JET_errTooManyOpenTables	-1311 /* Cannot open any more tables */
#define JET_errIllegalOperation 	-1312 /* Oper. not supported on table */
#define JET_wrnExecSegReleased		 1313 /* Query Execution segment is released */
#define JET_errObjectDuplicate		-1314 /* Table or object name in use */
#define JET_errRulesLoaded			-1315 /* Rules loaded, can't define more */
#define JET_errInvalidObject		-1316 /* object is invalid for operation */

#define JET_errIndexCantBuild		-1401 /* Cannot build clustered index */
#define JET_errIndexHasPrimary		-1402 /* Primary index already defined */
#define JET_errIndexDuplicate		-1403 /* Index is already defined */
#define JET_errIndexNotFound		-1404 /* No such index */
#define JET_errIndexMustStay		-1405 /* Cannot delete clustered index */
#define JET_errIndexInvalidDef		-1406 /* Illegal index definition */
#define JET_errSelfReference		-1407 /* Referencing/Referenced index is the same */
#define JET_errIndexHasClustered	-1408 /* Clustered index already defined */

#define JET_errColumnLong			-1501 /* column value is long */
#define JET_errColumnNoChunk		-1502 /* no such chunk in field */
#define JET_errColumnDoesNotFit 	-1503 /* Field will not fit in record */
#define JET_errNullInvalid			-1504 /* Null not valid */
#define JET_errColumnIndexed		-1505 /* Column indexed, cannot delete */
#define JET_errColumnTooBig			-1506 /* Field length is > maximum */
#define JET_errColumnNotFound		-1507 /* No such column */
#define JET_errColumnDuplicate		-1508 /* Field is already defined */
#define JET_errTaggedDefault		-1509 /* No defaults on tagged fields */
#define JET_errColumn2ndSysMaint	-1510 /* Second autoinc or version column */
#define JET_errInvalidColumnType	-1511 /* Invalid column data type */
#define JET_wrnColumnMaxTruncated	 1512 /* Max length too big, truncated */
#define JET_errColumnCannotIndex	-1513 /* Cannot index Bit,LongText,LongBinary */
#define JET_errTaggedNotNULL		-1514 /* No non-NULL tagged fields */
#define JET_errNoCurrentIndex		-1515 /* Invalid w/o a current index */
#define JET_errKeyIsMade			-1516 /* The key is completely made */
#define JET_errBadColumnId			-1517 /* Column Id Incorrect */
#define JET_errBadItagSequence		-1518 /* Bad itagSequence for tagged column */
#define JET_errColumnInRelationship	-1519 /* Cannot delete, column participates in relationship */
#define JET_wrnCopyLongValue		1520	/*	Single instance column bursted */
#define JET_errCannotBeTagged		-1521 /* AutoIncrement and Version cannot be tagged */

#define JET_errRecordNotFound		-1601 /* The key was not found */
#define JET_errRecordNoCopy			-1602 /* No working buffer */
#define JET_errNoCurrentRecord		-1603 /* Currency not on a record */
#define JET_errRecordClusteredChanged	-1604 /* Primary key may not change */
#define JET_errKeyDuplicate			-1605 /* Illegal duplicate key */
#define JET_errCannotInsertBefore	-1606 /* Cannot insert before current */
#define JET_errAlreadyPrepared		-1607 /* Already copy/clear current */
#define JET_errKeyNotMade			-1608 /* No call to JetMakeKey */
#define JET_errUpdateNotPrepared	-1609 /* No call to JetPrepareUpdate */
#define JET_wrnDataHasChanged		 1610 /* Data has changed */
#define JET_errDataHasChanged		-1611 /* Data has changed; operation aborted */
#define JET_errIntegrityViolationMaster -1612 /* References to key exist */
#define JET_errIntegrityViolationSlave	-1613 /* No referenced key exists */
#define JET_wrnMuchDataChanged		 1614 /* Repaint whole datasheet */
#define JET_errIncorrectJoinKey		-1615 /* Master key does not match lookup key */
#define JET_wrnKeyChanged			 1618 /* Moved to new key */
#define JET_wrnSyncedToDelRec		 1699 /* CONSIDER: QJET INTERNAL */
#define JET_errRedoPrepUpdate		 1698 /* CONSIDER: QJET INTERNAL(jpbulk.c)*/

#define JET_errTooManySorts			-1701 /* Too many sort processes */
#define JET_errInvalidOnSort		-1702 /* Invalid operation on Sort */

#define JET_errConfigOpenError		-1801 /* Config. file can't be opened */
#define JET_errSysDatabaseOpenError	-1802 /* System db could not be opened */
#define JET_errTempFileOpenError	-1803 /* Temp file could not be opened */
#define JET_errDatabaseOpenError	-1804 /* Database file can't be opened */
#define JET_errTooManyAttachedDatabases -1805 /* Too many open databases */
#define JET_errDatabaseCloseError	-1806 /* Db file could not be closed */
#define JET_errTooManyOpenFiles 	-1807 /* Too many files open */
#define JET_errDiskFull 			-1808 /* No space left on disk */
#define JET_errPermissionDenied 	-1809 /* Permission denied */
#define JET_errSortFileOpenError	-1810 /* Could not open sort file */
#define JET_errFileNotFound			-1811 /* File not found */
#define JET_errTempDiskFull			-1812 /* No space left on disk */
#define JET_wrnFileOpenReadOnly		1813 /* Database file is read only */

#define JET_errAfterInitialization	-1850 /* Cannot Restore after init. */
#define JET_errSeriesTooLong		-1851 /* New log generation id too big */
#define JET_errLogCorrupted			-1852 /* Logs could not be interpreted */

#define JET_errCannotOpenSystemDb	-1901 /* failed sysdb on beginsession */
#define JET_errInvalidLogon			-1902 /* invalid logon at beginsession */
#define JET_errInvalidAccountName	-1903 /* invalid account name */
#define JET_errInvalidSid			-1904 /* invalid SID */
#define JET_errInvalidPassword		-1905 /* invalid password */
#define JET_errInvalidOperation 	-1906 /* invalid operation */
#define JET_errAccessDenied			-1907 /* access denied */
#define JET_errNoMSysAccounts		-1908 /* Can't open MSysAccounts */
#define JET_errNoMSysGroups			-1909 /* Can't open MSysGroups */
#define JET_errInvalidPin			-1910	/* invalid pin */

#define JET_errRmtSqlError			-2001 /* RMT: ODBC call failed */
#define JET_errRmtMissingOdbcDll	-2006 /* RMT: Can't load ODBC DLL */
#define JET_errRmtInsertFailed		-2007 /* RMT: Insert statement failed */
#define JET_errRmtDeleteFailed		-2008 /* RMT: Delete statement failed */
#define JET_errRmtUpdateFailed		-2009 /* RMT: Update statement failed */
#define JET_errRmtColDataTruncated	-2010 /* RMT: data truncated */
#define JET_errRmtTypeIncompat		-2011 /* RMT: Can't create JET type on server */
#define JET_errRmtCreateTableFailed	-2012 /* RMT: Create table stmt failed */
#define JET_errRmtNotSupported		-2014 /* RMT: Function not legal for rdb */
#define JET_errRmtValueOutOfRange	-2020 /* RMT: Data value out of range */
#define JET_errRmtStillExec		-2021 /* RMT INTERNAL: SQL_STILL_EXECUTING */
#define JET_errRmtQueryTimeout		-2022 /* RMT: Server Not Responding */
#define JET_wrnRmtNeedLvData		 2023 /* RMT: Internal only - need Lv data */
#define JET_wrnFatCursorUseless		 2024 /* Fat cursor has no effect ***/
#define JET_errRmtWrongSPVer		-2025 /* RMT: INTERNAL: wrong SProc ver ***/
#define JET_errRmtLinkOutOfSync		-2026 /* RMT: the def for the rmt tbl has changed */
#define JET_errRmtDenyWriteIsInvalid	-2027 /* RMT: Can't open DenyWrite */
#define JET_errRmtDriverCantConv	-2029 /* RMT: INTERNAL: driver cannot convert */
#define JET_errRmtTableAmbiguous	-2030 /* RMT: Table ambiguous: must specifier owner */
#define JET_errRmtBogusConnStr		-2031 /* RMT: SPT: Bad connect string */

#define JET_errQueryInvalidAttribute	-3001 /* Invalid query attribute */
#define JET_errQueryOnlyOneRow		-3002 /* Only 1 such row allowed */
#define JET_errQueryIncompleteRow	-3003 /* Missing value in row */
#define JET_errQueryInvalidFlag 	-3004 /* Invalid value in Flag field */
#define JET_errQueryCycle		-3005 /* Cycle in query definition */
#define JET_errQueryInvalidJoinTable	-3006 /* Invalid table in join */
#define JET_errQueryAmbigRef		-3007 /* Ambiguous column reference */
#define JET_errQueryUnboundRef		-3008 /* Cannot bind name */
#define JET_errQueryParmRedef		-3009 /* Parm redefined with different type */
#define JET_errQueryMissingParms	-3010 /* Too few parameters supplied */
#define JET_errQueryInvalidOutput	-3011 /* Invalid query output */
#define JET_errQueryInvalidHaving	-3012 /* HAVING clause without aggregation */
#define JET_errQueryDuplicateAlias	-3013 /* Duplicate output alias */
#define JET_errQueryInvalidMGBInput	-3014 /* Cannot input from MGB */
#define JET_errQueryInvalidOrder	-3015 /* Invalid ORDER BY expression */
#define JET_errQueryTooManyLevels	-3016 /* Too many levels on MGB */
#define JET_errQueryMissingLevel	-3017 /* Missing intermediate MGB level */
#define JET_errQueryIllegalAggregate	-3018 /* Aggregates not allowed */
#define JET_errQueryDuplicateOutput	-3019 /* Duplicate destination output */
#define JET_errQueryIsBulkOp		-3020 /* Grbit should be set for Bulk Operation */
#define JET_errQueryIsNotBulkOp 	-3021 /* Query is not a Bulk Operation */
#define JET_errQueryIllegalOuterJoin	-3022 /* No inconsistent updates on outer joins */
#define JET_errQueryNullRequired	-3023 /* Column must be NULL */
#define JET_errQueryNoOutputs		-3024 /* Query must have an output */
#define JET_errQueryNoInputTables	-3025 /* Query must have an input */
#define JET_wrnQueryNonUpdatableRvt	 3026 /* Query is not updatable (but IS RVT) */
#define JET_errQueryInvalidAlias	-3027 /* Bogus character in alias name */
#define JET_errQueryInvalidBulkInput	-3028 /* Cannot input from bulk operation */
#define JET_errQueryNotDirectChild	-3029 /* T.* must use direct child */
#define JET_errQueryExprEvaluation	-3030 /* Expression evaluation error */
#define JET_errQueryIsNotRowReturning	-3031 /* Query does not return rows */
#define JET_wrnQueryNonRvt		 3032 /* Can't create RVT, query is static */
#define JET_errQueryParmTypeMismatch	-3033 /* Wrong parameter type given */
#define JET_errQueryChanging		-3034 /* Query Objects are being updated */
#define JET_errQueryNotUpdatable	-3035 /* Operation must use an updatable query */
#define JET_errQueryMissingColumnName	-3036 /* Missing destination column */
#define JET_errQueryTableDuplicate	-3037 /* Repeated table name in FROM list */
#define JET_errQueryIsMGB		-3038 /* Query is an MGB */
#define JET_errQueryInsIntoBulkMGB	-3039 /* Cannot insert into Bulk/MGB */
#define JET_errQueryDistinctNotAllowed	-3040 /* DISTINCT not allowed for MGB */
#define JET_errQueryDistinctRowNotAllow -3041 /* DISTINCTROW not allowed for MGB */
#define JET_errQueryNoDbForParmDestTbl	-3045 /* Dest DB for VT parm not allowed */
#define JET_errQueryDuplicatedFixedSet	-3047 /* Duplicated Fixed Value */
#define JET_errQueryNoDeleteTables	-3048 /* Must specify tables to delete from */
#define JET_errQueryCannotDelete	-3049 /* Cannot delete from specified tables */
#define JET_errQueryTooManyGroupExprs	-3050 /* Too many GROUP BY expressions */
#define JET_errQueryTooManyOrderExprs	-3051 /* Too many ORDER BY expressions */
#define JET_errQueryTooManyDistExprs	-3052 /* Too many DISTINCT output expressions */
#define JET_errQueryBadValueList	-3053 /* Malformed value list in Transform */
#define JET_errConnStrTooLong		-3054 /* Connect string too long */
#define JET_errQueryInvalidParm		-3055 /* Invalid Parmeter Name (>64 char) */
#define JET_errQueryContainsDbParm	-3056 /* Can't get parameters with Db Parm */
#define JET_errQueryBadUpwardRefed	-3057 /* Illegally Upward ref'ed */
#define JET_errQueryAmbiguousJoins	-3058 /* Joins in a QO are ambiguous */
#define JET_errQueryIsNotDDL		-3059 /* Not a DDL Operation */
#define JET_errNoDbInConnStr		-3060 /* No database in connect string */
#define JET_wrnQueryIsNotRowReturning	 3061 /* Not row returning */
#define JET_errTooManyFindSessions	-3062 /* RVT already has a find session open  */
#define JET_errSingleValueExpected	-3063 /* At most one record with one column can be returned from a scalar subquery */
#define JET_errColumnCountMismatch	-3064 /* Union Query: number of columns in children dont match */
#define JET_errQueryTopNotAllowed	-3065 /* Top not allowed for MGB */
#define JET_errQueryIsDDL			-3066 /* Must set JET_bitTableDDL */
#define JET_errQueryIsCorrupt		-3067 /* Query is Corrupt */
#define JET_errQuerySPTBulkSucceeded -3068 /* INTERNAL only */
#define JET_errSPTReturnedNoRecords -3069 /* SPT marked as RowReturning did not return a table */

#define JET_errExprSyntax		-3100 /* Syntax error in expression */
#define JET_errExprIllegalType		-3101 /* Illegal type in expression */
#define JET_errExprUnknownFunction	-3102 /* Unknown function in expression */

#define JET_errSQLSyntax		-3500 /* Bogus SQL statement type */
#define JET_errSQLParameterSyntax	-3501 /* Parameter clause syntax error */
#define JET_errSQLInsertSyntax		-3502 /* INSERT clause syntax error */
#define JET_errSQLUpdateSyntax		-3503 /* UPDATE clause syntax error */
#define JET_errSQLSelectSyntax		-3504 /* SELECT clause syntax error */
#define JET_errSQLDeleteSyntax		-3505 /* Expected 'FROM' after 'DELETE' */
#define JET_errSQLFromSyntax		-3506 /* FROM clause syntax error */
#define JET_errSQLGroupBySyntax 	-3507 /* GROUP BY clause syntax error */
#define JET_errSQLOrderBySyntax 	-3508 /* ORDER BY clause syntax error */
#define JET_errSQLLevelSyntax		-3509 /* LEVEL syntax error */
#define JET_errSQLJoinSyntax		-3510 /* JOIN syntax error */
#define JET_errSQLTransformSyntax	-3511 /* TRANSFORM syntax error */
#define JET_errSQLHavingSyntax		-3512 /* HAVING clause syntax error */
#define JET_errSQLWhereSyntax		-3513 /* WHERE clause syntax error */
#define JET_errSQLProcedureSyntax	-3514 /* Expected query name after 'PROCEDURE' */
#define JET_errSQLNotEnoughBuf		-3515 /* Buffer too small for SQL string */
#define JET_errSQLMissingSemicolon	-3516 /* Missing ; at end of SQL statement */
#define JET_errSQLTooManyTokens 	-3517 /* Characters after end of SQL statement */
#define JET_errSQLOwnerAccessSyntax -3518 /* OWNERACCESS OPTION syntax error */

#define	JET_errV11NotSupported		-3519 /* not supported in V11 */
#define JET_errV10Format			-3520 /* can be present in V10 format only */
#define JET_errSQLUnionSyntax		-3521 /* UNION query syntax error */
#define JET_errSqlPassThrough		-3523 /* Pass Through query Disallowed */
#define JET_wrnSqlPassThrough		 3524 /* Pass Through query involved */

#define JET_errDDLConstraintSyntax	-3550 /* constraint syntax error */
#define JET_errDDLCreateTableSyntax	-3551 /* create table syntax error */
#define JET_errDDLCreateIndexSyntax	-3552 /* create index syntax error */
#define JET_errDDLColumnDefSyntax	-3553 /* column def syntax error */
#define JET_errDDLAlterTableSyntax	-3554 /* alter table syntax error */
#define JET_errDDLDropIndexSyntax	-3555 /* drop index syntax error */
#define JET_errDDLDropSyntax		-3556 /* drop view/procedure syntax error */
#define JET_errDDLCreateViewSyntax	-3557 /* create view syntax error */

#define JET_errNoSuchProperty	-3600 /* Property was not found */
#define JET_errPropertyTooLarge -3601 /* Small Property larger than 2K */
#define JET_errJPMInvalidForV1x -3602 /* No JPM for V1.x databases */
#define JET_errPropertyExists	-3603 /* Property already exists */
#define JET_errInvalidDelete	-3604 /* DeleteOnly called with non-zero cbData */

#define JET_wrnFindWrapped		 3700 /* Cursor wrapped during fast find */

#define JET_errTLVNativeUserTablesOnly -3700 /* TLVs can only be placed on native user tables/columns */
#define JET_errTLVNoNull		  	   -3701 /* This field cannot be null */
#define JET_errTLVNoBlank			   -3702 /* This column cannot be blank */
#define	JET_errTLVRuleViolation 	   -3703 /* This validation rule must be met */
#define	JET_errTLVInvalidColumn	   	   -3704 /* This TLV property cannot be placed on this column */
#define JET_errTLVExprEvaluation	   -3705 /* Expression evaluation error */
#define JET_errTLVExprUnknownFunc	   -3706 /* Unknown function in TLV expression */
#define JET_errTLVExprSyntax		   -3707 /* Syntax error in TLV expression */

	/* CONSIDER: Remove the following error. */

#define JET_errGeneral			-5001 /* I-ISAM: assert failure */
#define JET_errRecordLocked		-5002 /* I-ISAM: record locked */
#define JET_wrnColumnDataTruncated	 5003 /* I-ISAM: data truncated */
#define JET_errTableNotOpen		-5004 /* I-ISAM: table is not open */
#define JET_errDecryptFail		-5005 /* I-ISAM: incorrect password */
#define JET_wrnCurrencyLost		 5007 /* I-ISAM: currency lost - must first/last */
#define JET_errDateOutOfRange		-5008 /* I-ISAM: invalid date */
#define JET_wrnOptionsIgnored		 5011 /* I-ISAM: options were ignored */
#define JET_errTableNotComplete		-5012 /* I-ISAM: incomplete table definition */
#define JET_errIllegalNetworkOption	-5013 /* I-ISAM: illegal network option */
#define JET_errIllegalTimeoutOption	-5014 /* I-ISAM: illegal timeout option */
#define JET_errNotExternalFormat	-5015 /* I-ISAM: invalid file format */
#define JET_errUnexpectedEngineReturn	-5016 /* I-ISAM: unexpected engine error code */
#define JET_errNumericFieldOverflow     -5017 /* I-ISAM: can't convert to native type */

#define JET_errIndexHasNoPrimary	-5020 /* Paradox: no primary index */
#define JET_errTableSortOrderMismatch	-5021 /* Paradox: sort order mismatch */
#define JET_errNoConfigParameters	-5023 /* Paradox: net path or user name missing */
#define JET_errCantAccessParadoxNetDir	-5024 /* Paradox: bad Paradox net path */
#define JET_errObsoleteLockFile 	-5025 /* Paradox: obsolete lock file */
#define JET_errIllegalCollatingSequence -5026 /* Paradox: invalid sort sequence */
#define JET_errWrongCollatingSequence	-5027 /* Paradox: wrong sort sequence */
#define JET_errCantUseUnkeyedTable	-5028 /* Paradox: can't open unkeyed table */

#define JET_errINFFileError		-5101 /* dBase: invalid .INF file */
#define JET_errCantMakeINFFile		-5102 /* dBase: can't open .INF file */
#define JET_wrnCantMaintainIndex	 5103 /* dBase: unmaintainable index */
#define JET_errMissingMemoFile		-5104 /* dBase: missing memo file */
#define JET_errIllegalCenturyOption	-5105 /* dBase: Illegal century option */
#define JET_errIllegalDeletedOption	-5106 /* dBase: Illegal deleted option */
#define JET_errIllegalStatsOption	-5107 /* dBase: Illegal statistics option */
#define JET_errIllegalDateOption	-5108 /* dBase: Illegal date option */
#define JET_errIllegalMarkOption	-5109 /* dBase: Illegal mark option */
#define JET_wrnDuplicateIndexes		 5110 /* dBase: duplicate indexes in INF file */
#define JET_errINFIndexNotFound		-5111 /* dBase: missing index in INF file */
#define JET_errWrongMemoFileType	-5112 /* dBase: wrong memo file type */
#define JET_errIllegalExactOption       -5113 /* dBase: Illegal exact option */

#define JET_errTooManyLongFields	-5200 /* Btrieve: more than one memo field */
#define JET_errCantStartBtrieve 	-5201 /* Btrieve: wbtrcall.dll missing */
#define JET_errBadConfigParameters	-5202 /* Btrieve: win.ini [btrieve] options wrong */
#define JET_errIndexesChanged		-5203 /* Btrieve: need to GetIndexInfo */
#define JET_errNonModifiableKey 	-5204 /* Btrieve: can't modify record column */
#define JET_errOutOfBVResources 	-5205 /* Btrieve: out of resources */
#define JET_errBtrieveDeadlock		-5206 /* Btrieve: locking deadlock */
#define JET_errBtrieveFailure		-5207 /* Btrieve: Btrieve DLL failure */
#define JET_errBtrieveDDCorrupted	-5208 /* Btrieve: data dictionary corrupted */
#define JET_errBtrieveTooManyTasks	-5209 /* Btrieve: too many tasks */
#define JET_errIllegalIndexDDFOption    -5210 /* Btrieve: Illegal IndexDDF option */
#define JET_errIllegalDataCodePage      -5211 /* Btrieve: Illeagl DataCodePage option */
#define JET_errXtrieveEnvironmentError  -5212 /* Btrieve: Xtrieve INI options bad */
#define JET_errMissingDDFFile           -5213 /* Btrieve: Missing field.ddf */
#define JET_errIlleaglIndexNumberOption -5214 /* Btrieve: Illeagl IndexRenumber option */

	/* Extended error codes must be in the following range. */
	/* Major error codes may not be in this range. */

#define JET_errMinorLeast		-8000
#define JET_errMinorMost		-8999

#define JET_errFindExprSyntax		-8001 /* Syntax error in FastFind expression */
#define JET_errQbeExprSyntax		-8002 /* Syntax error in QBE expression */
#define JET_errInputTableNotFound	-8003 /* Non-existant object in FROM list */
#define JET_errQueryExprSyntax		-8004 /* Syntax error in some query expression */
#define JET_errQodefExprSyntax		-8005 /* Syntax error in expression column */
#define JET_errExpAliasAfterAS		-8006 /* Expected alias after 'AS' in FROM list */
#define JET_errExpBYAfterGROUP		-8007 /* Expected 'BY' after 'GROUP' */
#define JET_errExpBYAfterORDER		-8008 /* Expected 'BY' after 'ORDER' */
#define JET_errExpClsParenAfterColList	-8009 /* Expected ')' after column list */
#define JET_errExpColNameAfterPIVOT	-8010 /* Expected column name after 'PIVOT' */
#define JET_errExpDatabaseAfterIN	-8011 /* Expected database name after 'IN' */
#define JET_errExpDatatypeAfterParmName -8012 /* Expected datatype after parameter name */
#define JET_errExpEqualAfterUpdColName	-8013 /* Expected '=' after update column name */
#define JET_errExpExprAfterON		-8014 /* Expected join expression after 'ON' */
#define JET_errExpExprAfterTRANSFORM	-8015 /* Expected expression after 'TRANSFORM' */
#define JET_errExpExprAfterWHERE	-8016 /* Expected expression after 'WHERE' */
#define JET_errExpGroupClauseInXform	-8017 /* Transform expects GROUP BY clause */
#define JET_errExpGroupingExpr		-8018 /* Expected grouping expression */
#define JET_errExpHavingExpr		-8019 /* Expected HAVING expression */
#define JET_errExpINTOAfterINSERT	-8020 /* Expected 'INTO' after 'INSERT' */
#define JET_errExpJOINAfterJoinType	-8021 /* Expected 'JOIN' after INNER/LEFT/RIGHT */
#define JET_errExpLEVELAfterSelectList	-8022 /* Expected LEVEL after select list */
#define JET_errExpNumberAfterLEVEL	-8023 /* Expected number after 'LEVEL' */
#define JET_errExpONAfterRightTable	-8024 /* Expected 'ON' after right join table */
#define JET_errExpOrderExpr		-8025 /* Expected ordering expression */
#define JET_errExpOutputAliasAfterAS	-8026 /* Expected output alias after 'AS' */
#define JET_errExpOutputExpr		-8027 /* Expected output expression */
#define JET_errExpPIVOTAfterSelectStmt	-8028 /* Expected 'PIVOT' after SELECT statement */
#define JET_errExpRightJoinTable	-8029 /* Expected right join table after 'JOIN' */
#define JET_errExpSELECTAfterInsClause	-8030 /* Expected 'SELECT' after INSERT clause */
#define JET_errExpSELECTAfterXformExpr	-8031 /* Expected 'SELECT' after Transform fact */
#define JET_errExpSETAfterTableName	-8032 /* Expected 'SET' after table name */
#define JET_errExpSemiAfterLevelNumber	-8033 /* Expected ';' after level number */
#define JET_errExpSemiAfterParmList	-8034 /* Expected ';' after parmeter list */
#define JET_errExpSemiAfterPivotClause	-8035 /* Expected ';' after PIVOT clause */
#define JET_errExpSemiAtEndOfSQL	-8036 /* Expected ';' at end of SQL statement */
#define JET_errExpTableName		-8037 /* Expected table name */
#define JET_errExpTableNameAfterINTO	-8038 /* Expected table name after 'INTO' */
#define JET_errExpUpdExprAfterEqual	-8039 /* Expected update expression after '=' */
#define JET_errExpUpdateColName 	-8040 /* Expected update column name */
#define JET_errInvTokenAfterFromList	-8041 /* Bogus token after FROM list */
#define JET_errInvTokenAfterGroupList	-8042 /* Bogus token after GROUP BY list */
#define JET_errInvTokenAfterHavingCls	-8043 /* Bogus token after HAVING clause */
#define JET_errInvTokenAfterOrderClause -8044 /* Bogus token after ORDER BY clause */
#define JET_errInvTokenAfterSelectCls	-8045 /* Bogus token after SELECT clause */
#define JET_errInvTokenAfterWhereClause -8046 /* Bogus token after WHERE clause */
#define JET_errLevelNumberTooBig	-8047 /* Number after 'LEVEL' too big */
#define JET_errLevelOnNonMGB		-8048 /* LEVEL allowed only in MGB */
#define JET_errIllegalDetailReference	-8049 /* Not group key or agg, but not MGB detail */
#define JET_errAggOverMixedLevels	-8050 /* Agg. arg. uses outputs from > 1 level */
#define JET_errAggregatingHigherLevel	-8051 /* Agg. over output of same/higher level */
#define JET_errNullInJoinKey		-8052 /* Cannot set column in join key to NULL */
#define JET_errValueBreaksJoin		-8053 /* Join is broken by column value(s) */
#define JET_errInsertIntoUnknownColumn	-8054 /* INSERT INTO unknown column name */
#define JET_errNoSelectIntoColumnName	-8055 /* No dest. col. name in SELECT INTO stmt */
#define JET_errNoInsertColumnName	-8056 /* No dest. col. name in INSERT stmt */
#define JET_errColumnNotInJoinTable	-8057 /* Join expr refers to non-join table */
#define JET_errAggregateInJoin		-8058 /* Aggregate in JOIN clause */
#define JET_errAggregateInWhere 	-8059 /* Aggregate in WHERE clause */
#define JET_errAggregateInOrderBy	-8060 /* Aggregate in ORDER BY clause */
#define JET_errAggregateInGroupBy	-8061 /* Aggregate in GROUP BY clause */
#define JET_errAggregateInArgument	-8062 /* Aggregate in argument expression */
#define JET_errHavingOnTransform	-8063 /* HAVING clause on TRANSFORM query */
#define JET_errHavingWithoutGrouping	-8064 /* HAVING clause w/o grouping/aggregation */
#define JET_errHavingOnMGB		-8065 /* HAVING clause on MGB query */
#define JET_errOutputAliasCycle 	-8066 /* Cycle in SELECT list (via aliases) */
#define JET_errDotStarWithGrouping	-8067 /* 'T.*' with grouping, but not MGB level 0 */
#define JET_errStarWithGrouping 	-8068 /* '*' with grouping, but not MGB detail */
#define JET_errQueryTreeCycle		-8069 /* Cycle in tree of query objects */
#define JET_errTableRepeatInFromList	-8072 /* Table appears twice in FROM list */
#define JET_errTooManyXformLevels	-8073 /* Level > 2 in TRANSFORM query */
#define JET_errTooManyMGBLevels 	-8074 /* Too many levels in MGB */
#define JET_errNoUpdateColumnName	-8075 /* No dest. column name in UPDATE stmt */
#define JET_errJoinTableNotInput	-8076 /* Join table not in FROM list */
#define JET_errUnaliasedSelfJoin	-8077 /* Join tables have same name */
#define JET_errOutputLevelTooBig	-8078 /* Output w/ level > 1+max group level */
#define JET_errOrderVsGroup		-8079 /* ORDER BY conflicts with GROUP BY */
#define JET_errOrderVsDistinct		-8080 /* ORDER BY conflicts with DISTINCT */
#define JET_errExpLeftParenthesis	-8082 /* Expected '(' */
#define JET_errExpRightParenthesis	-8083 /* Expected ')' */
#define JET_errEvalEBESErr		-8084 /* EB/ES error evaluating expression */
#define JET_errQueryExpCloseQuote	-8085 /* Unmatched quote for database name */
#define JET_errQueryParmNotDatabase	-8086 /* Parameter type should be database */
#define JET_errQueryParmNotTableid	-8087 /* Parameter type should be tableid */
#define JET_errExpIdentifierM		-8088 /* Expected identifier */
#define JET_errExpQueryName		-8089 /* Expected query name after PROCEDURE */
#define JET_errExprUnknownFunctionM	-8090 /* Unknown function in expression */
#define JET_errQueryAmbigRefM		-8091 /* Ambiguous column reference */
#define JET_errQueryBadBracketing	-8092 /* Bad bracketing of identifier */
#define JET_errQueryBadQodefName	-8093 /* Invalid name in QODEF row */
#define JET_errQueryBulkColNotUpd	-8094 /* Column not updatable (bulk op) */
#define JET_errQueryDistinctNotAllowedM	-8095 /* DISTINCT not allowed for MGB */
#define JET_errQueryDuplicateAliasM	-8096 /* Duplicate output alias */
#define JET_errQueryDuplicateOutputM	-8097 /* Duplicate destination output */
#define JET_errQueryDuplicatedFixedSetM	-8098 /* Duplicated Fixed Value */
#define JET_errQueryIllegalOuterJoinM	-8099 /* No inconsistent updates on outer joins */
#define JET_errQueryIncompleteRowM	-8100 /* Missing value in row */
#define JET_errQueryInvalidAttributeM	-8101 /* Invalid query attribute */
#define JET_errQueryInvalidBulkInputM	-8102 /* Cannot input from bulk operation */
#define JET_errQueryInvalidFlagM	-8103 /* Invalid value in Flag field */
#define JET_errQueryInvalidMGBInputM	-8104 /* Cannot input from MGB */
#define JET_errQueryLVInAggregate	-8105 /* Illegal long value in aggregate */
#define JET_errQueryLVInDistinct	-8106 /* Illegal long value in DISTINCT */
#define JET_errQueryLVInGroupBy		-8107 /* Illegal long value in GROUP BY */
#define JET_errQueryLVInHaving		-8108 /* Illegal long value in HAVING */
#define JET_errQueryLVInJoin		-8109 /* Illegal long value in JOIN */
#define JET_errQueryLVInOrderBy		-8110 /* Illegal long value in ORDER BY */
#define JET_errQueryMissingLevelM	-8111 /* Missing intermediate MGB level */
#define JET_errQueryMissingParmsM	-8112 /* Too few parameters supplied */
#define JET_errQueryNoDbForParmDestTblM	-8113 /* Dest DB for VT parm not allowed */
#define JET_errQueryNoDeletePerm	-8114 /* No delete permission on table/query */
#define JET_errQueryNoInputTablesM	-8115 /* Query must have an input */
#define JET_errQueryNoInsertPerm	-8116 /* No insert permission on table/query */
#define JET_errQueryNoOutputsM		-8117 /* Query must have an output */
#define JET_errQueryNoReadDefPerm	-8118 /* No permission to read query definition */
#define JET_errQueryNoReadPerm		-8119 /* No read permission on table/query */
#define JET_errQueryNoReplacePerm	-8120 /* No replace permission on table/query */
#define JET_errQueryNoTblCrtPerm	-8121 /* No CreateTable permission (bulk op) */
#define JET_errQueryNotDirectChildM	-8122 /* T.* must use direct child */
#define JET_errQueryNullRequiredM	-8123 /* Column must be NULL */
#define JET_errQueryOnlyOneRowM		-8124 /* Only 1 such row allowed */
#define JET_errQueryOutputColNotUpd	-8125 /* Query output column not updatable */
#define JET_errQueryParmRedefM		-8126 /* Parm redefined with different type */
#define JET_errQueryParmTypeMismatchM	-8127 /* Wrong parameter type given */
#define JET_errQueryUnboundRefM		-8128 /* Cannot bind name */
#define JET_errRmtConnectFailedM	-8129 /* RMT: Connection attempt failed */
#define JET_errRmtDeleteFailedM		-8130 /* RMT: Delete statement failed */
#define JET_errRmtInsertFailedM		-8131 /* RMT: Insert statement failed */
#define JET_errRmtMissingOdbcDllM	-8132 /* RMT: Can't load ODBC DLL */
#define JET_errRmtSqlErrorM		-8133 /* RMT: ODBC call failed */
#define JET_errRmtUpdateFailedM		-8134 /* RMT: Update statement failed */
#define JET_errSQLDeleteSyntaxM		-8135 /* Expected 'FROM' after 'DELETE' */
#define JET_errSQLSyntaxM		-8136 /* Bogus SQL statement type */
#define JET_errSQLTooManyTokensM	-8137 /* Characters after end of SQL statement */
#define JET_errStarNotAtLevel0		-8138 /* '*' illegal above level 0 */
#define JET_errQueryParmTypeNotAllowed	-8139 /* Parameter type not allowed for expression */
#define JET_errQueryTooManyDestColumn	-8142 /* Too many destination column sepcified */
#define JET_errSQLNoInsertColumnName	-8143 /* No dest. col. name in INSERT stmt */
#define JET_errRmtLinkNotFound		-8144 /* RMT: link not found */
#define JET_errRmtTooManyColumns	-8145 /* RMT: Too many columns on Select Into */
#define JET_errWriteConflictM		-8146 /* Write lock failed due to outstanding write lock */
#define JET_errReadConflictM		-8147 /* Commit lock failed due to outstanding read lock */
#define JET_errCommitConflictM		-8148 /* Read lock failed due to outstanding commit lock */
#define JET_errTableLockedM		-8149 /* Table is exclusively locked */
#define JET_errTableInUseM		-8150 /* Table is in use, cannot lock */
#define JET_errQueryTooManyXvtColumn	-8151 /* Too many cross table column headers */
#define JET_errOutputTableNotFound	-8152 /* Non-existent table in Insert Into */
#define JET_errTableLockedQM		-8153 /* Table is exclusively locked */
#define JET_errTableInUseQM		-8154 /* Table is in use, cannot lock */
#define JET_errTableLockedMUQM		-8155 /* Table is exclusively locked */
#define JET_errTableInUseMUQM		-8156 /* Table is in use, cannot lock */
#define JET_errQueryInvalidParmM	-8157 /* Invalid Parmeter Name (>64 char) */
#define JET_errFileNotFoundM		-8158 /* File not found */
#define JET_errFileShareViolationM	-8159 /* File sharing violation */
#define JET_errFileAccessDeniedM	-8160 /* Access denied */
#define JET_errInvalidPathM		-8161 /* Invalid Path */
#define JET_errTableDuplicateM		-8162 /* Table already exists */
#define JET_errQueryBadUpwardRefedM	-8163 /* Illegally Upward ref'ed */
#define JET_errIntegrityViolMasterM	-8164 /* References to key exist */
#define JET_errIntegrityViolSlaveM	-8165 /* No referenced key exists */
#define JET_errSQLUnexpectedWithM	-8166 /* Unexpected 'with' in this place */
#define JET_errSQLOwnerAccessM		-8167 /* Owner Access Option is defined Twice */
#define	JET_errSQLOwnerAccessSyntaxM 	-8168 /* Owner Access Option Syntax Error */
#define	JET_errSQLOwnerAccessDef 	-8169 /* Owner Access Option is defined more than once */
#define JET_errAccessDeniedM     	-8170 /* Generic Access Denied */
#define JET_errUnexpectedEngineReturnM	-8171 /* I-ISAM: unexpected engine error code */
#define JET_errQueryTopNotAllowedM	-8172 /* Top not allowed for MGB */
#define JET_errInvTokenAfterTableCls -8173 /* Bogus token after table clause */
#define JET_errInvTokenAfterRParen  -8174 /* Unexpected tokens after a closing paren */
#define JET_errQueryBadValueListM	-8175 /* Malformed value list in Transform */
#define JET_errQueryIsCorruptM		-8176 /* Query is Corrupt */
#define	JET_errInvalidTopArgumentM	-8177 /* Select Top argument is invalid */
#define JET_errQueryIsSnapshot		-8178 /* Query is a snapshot */
#define JET_errQueryExprOutput		-8179 /* Output is a calculated column */
#define JET_errQueryTableRO		-8180 /* Column comes from read-only table */
#define JET_errQueryRowDeleted		-8181 /* Column comes from deleted row */
#define JET_errQueryRowLocked		-8182 /* Column comes from locked row */
#define JET_errQueryFixupChanged	-8183 /* Would row-fixup away from pending changes */
#define JET_errQueryCantFillIn		-8184 /* Fill-in-the-blank only on most-many */
#define JET_errQueryWouldOrphan		-8185 /* Would orphan joined records */
#define JET_errIncorrectJoinKeyM	-8186 /* Must match join key in lookup table */
#define JET_errQueryLVInSubqueryM	-8187 /* Illegal long value in subquery */
#define JET_errInvalidDatabaseM		-8188 /* Unrecognized database format */
#define JET_errOrderVsUnion 		-8189 /* You can only order by an outputted column in a union */
#define JET_errTLVCouldNotBindRef 	-8190 /* Unknown token in TLV expression */
#define JET_errCouldNotBindRef		-8191 /* Unknown token in FastFind expression */
#define JET_errQueryPKeyNotOutput	-8192 /* Primary key not output */
#define JET_errQueryJKeyNotOutput	-8193 /* Join key not output */
#define JET_errExclusiveDBConflict	-8194 /* Conflict with exclusive user */
#define JET_errQueryNoJoinedRecord	-8195 /* No F.I.T.B. insert if no joined record */
#define JET_errQueryLVInSetOp		-8196 /* Illegal long value in set operation */
#define JET_errTLVExprUnknownFunctionM	-8197 /* Unknown function in TLV expression */
#define JET_errInvalidNameM		-8198 /* Invalid name */

#define JET_errDDLExpColName		-8200 /* expect column name */
#define JET_errDDLExpLP			-8201 /* expect '(' */
#define JET_errDDLExpRP			-8202 /* expect ')' */
#define JET_errDDLExpIndex		-8203 /* expect INDEX */
#define JET_errDDLExpIndexName		-8204 /* expect index name */
#define JET_errDDLExpOn			-8205 /* expect ON */
#define JET_errDDLExpKey		-8206 /* expect KEY */
#define JET_errDDLExpReferences		-8207 /* expect REFERENCES */
#define JET_errDDLExpTableName		-8208 /* expect table name */
#define JET_errDDLExpFullOrPartial	-8209 /* expect FULL or PARTIAL */
#define JET_errDDLExpCascadeOrSet	-8210 /* expect CASCADE or SET */
#define JET_errDDLExpNull		-8211 /* expect NULL */
#define JET_errDDLExpUpdateOrDelete	-8212 /* expect UPDATE or DELETE */
#define JET_errDDLExpConstraintName	-8213 /* expect constraint name */
#define JET_errDDLExpForeign		-8214 /* expect FOREIGN */
#define JET_errDDLExpDatatype		-8215 /* expect data type */
#define JET_errDDLExpIndexOpt		-8216 /* expect index options */
#define JET_errDDLExpWith		-8217 /* expect WITH */
#define JET_errDDLExpTable		-8218 /* expect TABLE */
#define JET_errDDLExpEos		-8219 /* expect End Of String */
#define JET_errDDLExpAddOrDrop		-8220 /* expect ADD or Drop */
#define JET_errDDLCreateView		-8221 /* Create view not supported */
#define JET_errDDLCreateProc		-8222 /* Create proc not supported */
#define JET_errDDLExpObjectName		-8223 /* expect object name */
#define JET_errDDLExpColumn		-8224 /* expect COLUMN */

#define	JET_errV11TableNameNotInScope 	-8250 /* referenced table not in join clause */
#define JET_errV11OnlyTwoTables		-8251 /* exactly two tables should be referenced in join */
#define JET_errV11OneSided		-8252 /* all tables come from one side of input */
#define JET_errV11Ambiguous		-8253 /* Join clause is ambiguous when stored in V1 format */

#define JET_errTLVExprSyntaxM		-8260 /* Syntax error in TLV expression */
#define JET_errTLVNoNullM			-8261 /* This field cannot be null */
#define JET_errTLVNoBlankM			-8262 /* This column cannot be blank */
#define	JET_errTLVRuleViolationM 	-8263 /* This validation rule must be met */
#define JET_errDDLCreateViewSyntaxM	-8264 /* create view syntax error */

/***********************
 The following error code ranges are reserved for external use.
 As is true for Jet error codes, these ranges cover the negative
 as well as positive form of the numbers in the range.

 30000 through 30999 for use by Vt Object as defined in jeteb.h
 32000 through 32767 for use by Import/Export as defined in jetutil.h

 ***********************/



/**********************************************************************/
/***********************     PROTOTYPES      **************************/
/**********************************************************************/

#if !defined(_JET_NOPROTOTYPES)

/****************************************************************************

	ISAM API

*****************************************************************************/

JET_ERR JET_API JetInit(JET_INSTANCE _far *pinstance);

JET_ERR JET_API JetTerm(JET_INSTANCE instance);

JET_ERR JET_API JetSetSystemParameter(JET_INSTANCE _far *pinstance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char _far *sz);

JET_ERR JET_API JetGetSystemParameter(JET_INSTANCE instance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR _far *plParam, char _far *sz, unsigned long cbMax);

JET_ERR JET_API JetGetLastErrorInfo(JET_SESID sesid,
	JET_EXTERR _far *pexterr, unsigned long cbexterrMax,
	char _far *sz1, unsigned long cch1Max,
	char _far *sz2, unsigned long cch2Max,
	char _far *sz3, unsigned long cch3Max,
	unsigned long _far *pcch3Actual);

JET_ERR JET_API JetBeginSession(JET_INSTANCE instance, JET_SESID _far *psesid,
	const char _far *szUserName, const char _far *szPassword);

JET_ERR JET_API JetDupSession(JET_SESID sesid, JET_SESID _far *psesid);

JET_ERR JET_API JetEndSession(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetVersion(JET_SESID sesid, unsigned long _far *pwVersion);

JET_ERR JET_API JetIdle(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetCapability(JET_SESID sesid, JET_DBID dbid,
	unsigned long lArea, unsigned long lFunction, JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetCreateDatabase(JET_SESID sesid,
	const char _far *szFilename, const char _far *szConnect,
	JET_DBID _far *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetAttachDatabase(JET_SESID sesid, const char _far *szFilename, JET_GRBIT grbit );

JET_ERR JET_API JetDetachDatabase(JET_SESID sesid, const char _far *szFilename);

JET_ERR JET_API JetCreateTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, unsigned long lPages, unsigned long lDensity,
	JET_TABLEID _far *ptableid);

JET_ERR JET_API JetRenameTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szTableNew);

JET_ERR JET_API JetDeleteTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName);

JET_ERR JET_API JetGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumnName, void _far *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szColumnName,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn, const JET_COLUMNDEF _far *pcolumndef,
	const void _far *pvDefault, unsigned long cbDefault,
	JET_COLUMNID _far *pcolumnid);

JET_ERR JET_API JetRenameColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn, const char _far *szColumnNew);

JET_ERR JET_API JetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn);

JET_ERR JET_API JetGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName, void _far *pvResult, unsigned long cbResult,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetTableReferenceInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName, void _far *pvResult,
	unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szIndexName,
	void _far *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetGetReferenceInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szReference,
	void _far *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName, JET_GRBIT grbit,
	const char _far *szKey, unsigned long cbKey, unsigned long lDensity);

JET_ERR JET_API JetRenameIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndex, const char _far *szIndexNew);

JET_ERR JET_API JetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName);

JET_ERR JET_API JetCreateReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName, const char _far *szColumns,
	const char _far *szReferencedTable,
	const char _far *szReferencedColumns, JET_GRBIT grbit);

JET_ERR JET_API JetRenameReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReference, const char _far *szReferenceNew);

JET_ERR JET_API JetDeleteReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName);

JET_ERR JET_API JetGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp, const char _far *szContainerName,
	const char _far *szObjectName, void _far *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetCreateObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	JET_OBJTYP objtyp);

JET_ERR JET_API JetDeleteObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName);

JET_ERR JET_API JetRenameObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szObjectNew);

JET_ERR JET_API JetBeginTransaction(JET_SESID sesid);

JET_ERR JET_API JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetRollback(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetUpdateUserFunctions(JET_SESID sesid);

JET_ERR JET_API JetGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetCloseDatabase(JET_SESID sesid, JET_DBID dbid,
	JET_GRBIT grbit);

JET_ERR JET_API JetCloseTable(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenDatabase(JET_SESID sesid, const char _far *szFilename,
	const char _far *szConnect, JET_DBID _far *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetOpenTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const void _far *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetDelete(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void _far *pvData, unsigned long cbData,
	unsigned long _far *pcbActual, JET_GRBIT grbit, JET_RETINFO _far *pretinfo);

JET_ERR JET_API JetRetrieveColumns( JET_SESID sesid, JET_TABLEID tableid,
	JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn );

JET_ERR JET_API JetSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void _far *pvData, unsigned long cbData,
	JET_GRBIT grbit, JET_SETINFO _far *psetinfo);

JET_ERR JET_API JetSetColumns(JET_SESID sesid, JET_TABLEID tableid,
	JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn );

JET_ERR JET_API JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep);

JET_ERR JET_API JetGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS _far *precpos, unsigned long cbRecpos);

JET_ERR JET_API JetGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos );

JET_ERR JET_API JetGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID _far *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char _far *szIndexName, unsigned long cchIndexName);

JET_ERR JET_API JetSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName);

JET_ERR JET_API JetMove(JET_SESID sesid, JET_TABLEID tableid,
	long cRow, JET_GRBIT grbit);

JET_ERR JET_API JetMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void _far *pvData, unsigned long cbData, JET_GRBIT grbit);

JET_ERR JET_API JetSeek(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit);

JET_ERR JET_API JetFastFind(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szExpr, JET_GRBIT grbit,
	signed long _far *pcrow);

JET_ERR JET_API JetFastFindBegin(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szExpr, JET_GRBIT grbit);

JET_ERR JET_API JetFastFindEnd(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbMax,
	unsigned long _far *pcbActual);
	
JET_ERR JET_API JetRefreshLink(JET_SESID sesid, JET_DBID dbid,
	const char _far *szLinkName, const char _far *szConnect,
	const char _far *szDatabase);

#ifdef	_MSC_VER		       /* CONSIDER: CSL doesn't like this */

JET_ERR JET_API JetRepairDatabase(JET_SESID sesid, const char _far *lszDbFile,
	JET_PFNSTATUS pfnstatus);

#endif	/* _MSC_VER */

JET_ERR JET_API JetCompact(JET_SESID sesid, const char _far *szDatabaseSrc,
	const char _far *szConnectSrc, const char _far *szDatabaseDest,
	const char _far *szConnectDest, JET_PFNSTATUS pfnStatus,
	JET_GRBIT grbit);

JET_ERR JET_API JetGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark);

JET_ERR JET_API JetComputeStats(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetCreateRelationship(JET_SESID sesid,JET_DBID dbidIn,
	const char _far *szRelationshipName, const char _far *szObjectName,
	const char _far *szColumns, const char _far *szReferencedObject,
	const char _far *szReferncedColumns, char _far *szLongName,
	unsigned long cbMax, unsigned long _far *pcbActual, JET_GRBIT grbit);

JET_ERR JET_API JetDeleteRelationship(JET_SESID sesid, JET_DBID dbidIn,
	const char _far *szName);

JET_ERR JET_API JetGetRelationshipInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szRelationship,
	void _far *pvResult, unsigned long cbResult);

/*****************************************************************************

	SEC API

*****************************************************************************/

JET_ERR JET_API JetGetSidFromName(JET_SESID sesid, const char _far *szName,
	void _far *pvSid, unsigned long cbMax, unsigned long _far *pcbActual,
	long _far *pfGroup);

JET_ERR JET_API JetGetNameFromSid(JET_SESID sesid,
	const void _far *pvSid, unsigned long cbSid,
	char _far *szName, unsigned long cchName, long _far *pfGroup);

JET_ERR JET_API JetCreateUser(JET_SESID sesid, const char _far *szUser,
	const char _far *szPassword, const char _far *szPin);

JET_ERR JET_API JetChangeUserPassword(JET_SESID sesid,
	const char _far *szUser, const char _far *szOldPassword,
	const char _far *szNewPassword);

JET_ERR JET_API JetDeleteUser(JET_SESID sesid, const char _far *szUser);

JET_ERR JET_API JetCreateGroup(JET_SESID sesid, const char _far *szGroup,
	const char _far *szPin);

JET_ERR JET_API JetAddMember(JET_SESID sesid,
	const char _far *szGroup, const char _far *szUser);

JET_ERR JET_API JetRemoveMember(JET_SESID sesid,
	const char _far *szGroup, const char _far *szUser);

JET_ERR JET_API JetDeleteGroup(JET_SESID sesid, const char _far *szGroup);

JET_ERR JET_API JetSetAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName, JET_ACM acm, JET_GRBIT grbit);

JET_ERR JET_API JetGetAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName, long fIndividual,
	JET_ACM _far *pacm, JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetValidateAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	JET_ACM acmRequired);

JET_ERR JET_API JetSetOwner(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName);

JET_ERR JET_API JetGetOwner(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	char _far *szName, unsigned long cchMax);

/*****************************************************************************

	Property Management API

*****************************************************************************/
JET_ERR JET_API JetSetProperty(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, JET_COLTYP coltyp,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveProperty(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, unsigned long _far *pcbActual,
	JET_COLTYP _far *pcoltyp, JET_GRBIT grbit, unsigned long InfoLevel);

JET_ERR JET_API JetSetTableProperty(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, JET_COLTYP coltyp,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveTableProperty(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, unsigned long _far *pcbActual,
	JET_COLTYP _far *pcoltyp, JET_GRBIT grbit, unsigned long InfoLevel);

/*****************************************************************************

	LINK API

*****************************************************************************/

JET_ERR JET_API JetCreateLink(JET_SESID sesid, JET_DBID dbid,
	const char _far *szLink, JET_DBID dbidFrom, const char _far *szFrom,
	JET_GRBIT grbit);

JET_ERR JET_API JetExecuteSql(JET_SESID sesid, JET_DBID dbid,
	const char _far *szSql);

/***************************************************************************

	Query API

*****************************************************************************/

JET_ERR JET_API JetOpenVtQbe(JET_SESID sesid, const char _far *szExpn,
	long _far *plCols, JET_TABLEID _far *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetCreateQuery(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetOpenQueryDef(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, JET_TABLEID _far *ptableid);

/* CONSIDER: Is rgchSql a zero-terminated string?  Maybe it should be for
 *		   consistency.
 */

JET_ERR JET_API JetSetQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char _far *rgchSql, unsigned long cchSql, const char _far *szConnect,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char _far *rgchSql, unsigned long cchMax,
	unsigned long _far *pcchActual, void _far *pvConnect,
	unsigned long cbConnectMax, unsigned long _far *pcbConnectActual,
	JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetCopyQuery(JET_SESID sesid, JET_TABLEID tableidSrc,
	JET_DBID dbidDest, const char _far *szQueryDest,
	JET_TABLEID _far *ptableidDest);

JET_ERR JET_API JetOpenSVT(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, const void _far *pvParameters,
	unsigned long cbParameters, unsigned long crowSample, JET_GRBIT grbit,
	void _far *pmgblist, unsigned long cbMax, unsigned long _far *pcbActual);

JET_ERR JET_API JetGetQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, void _far *pvResult, unsigned long cbMax,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetRestartQuery(JET_SESID sesid, JET_TABLEID tableid,
	const void _far *pvParameters, unsigned long cbParameters);

JET_ERR JET_API JetSetFatCursor(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark, unsigned long crowSize);

JET_ERR JET_API JetFillFatCursor(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark, unsigned long crow,
	unsigned long _far *pcrow, JET_GRBIT grbit);

JET_ERR JET_API JetExecuteTempQuery(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const void _far *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetExecuteTempSVT(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const void _far *pvParameters,
	unsigned long cbParameters, unsigned long crowSample, JET_GRBIT grbit,
	void _far *pmgblist, unsigned long cbMax, unsigned long _far *pcbActual);

JET_ERR JET_API JetGetTempQueryColumnInfo(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szColumnName,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetTempQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, void _far *pvResult, unsigned long cbMax,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetValidateData(JET_SESID sesid, JET_TABLEID tableidBase,
		JET_TABLEID _far *ptableid );

/***************************************************************************

	API for Installable ISAMs

****************************************************************************/

typedef ULONG_PTR JET_VSESID;         /* Received from dispatcher */

struct tagVDBFNDEF;

typedef ULONG_PTR JET_VDBID;          /* Received from dispatcher */

JET_ERR JET_API JetAllocateDbid(JET_SESID sesid, JET_DBID _far *pdbid, JET_VDBID vdbid, const struct tagVDBFNDEF _far *pvdbfndef, JET_VSESID vsesid);

JET_ERR JET_API JetUpdateDbid(JET_SESID sesid, JET_DBID dbid, JET_VDBID vdbid, const struct tagVDBFNDEF _far *pvdbfndef);

JET_ERR JET_API JetReleaseDbid(JET_SESID sesid, JET_DBID dbid);

struct tagVTFNDEF;

typedef ULONG_PTR JET_VTID;            /* Received from dispatcher */

JET_ERR JET_API JetAllocateTableid(JET_SESID sesid, JET_TABLEID _far *ptableid, JET_VTID vtid, const struct tagVTFNDEF _far *pvtfndef, JET_VSESID vsesid);

JET_ERR JET_API JetUpdateTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID vtid, const struct tagVTFNDEF _far *pvtfndef);

JET_ERR JET_API JetReleaseTableid(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
	const JET_COLUMNDEF _far *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID _far *ptableid,
	JET_COLUMNID _far *prgcolumnid);


/***************************************************************************

	MISC JET API

****************************************************************************/

JET_ERR JET_API JetStringCompare(char _far *pb1, unsigned long cb1,
	char _far *pb2, unsigned long cb2, unsigned long sort,
	long _far *plResult);

/***************************************************************************

	ADDITIONAL JET BLUE API

****************************************************************************/
JET_ERR JET_API JetBackup( const char _far *szBackupPath, JET_GRBIT grbit );
JET_ERR JET_API JetRestore(const char _far *sz, int crstmap, JET_RSTMAP *rgrstmap, JET_PFNSTATUS pfn );
JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit);
JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long _far *pcrec, unsigned long crecMax );
JET_ERR JET_API JetRetrieveKey(JET_SESID sesid,
	JET_TABLEID tableid, void _far *pvData, unsigned long cbMax,
	unsigned long _far *pcbActual, JET_GRBIT grbit );

#ifdef JETSER
JET_ERR JET_API JetGetChecksum( JET_SESID sesid,
	JET_TABLEID tableid, unsigned long _far *pulChecksum );
JET_ERR JET_API JetGetObjidFromName(JET_SESID sesid,
	JET_DBID dbid, const char _far *szContainerName,
	const char _far *szObjectName,
	unsigned long _far *pulObjectId );
#endif

#endif	/* _JET_NOPROTOTYPES */

#undef	_far

#pragma pack()

#ifdef	__cplusplus
}
#endif


#endif	/* _JET_INCLUDED */

#endif  __JET500
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\daedebug.h ===
#ifndef DEBUG

#define PrintF()

#endif	/* !DEBUG */

#ifdef	DEBUG

VOID MEMPrintStat( VOID );


typedef struct _statis
	{
	long	l;
	char	*sz;
	} STATIS;
extern STATIS rgstatis[];

#define BFEvictBG		0
#define BFEvictFG		1
#define BFEvictClean	2
#define BFEvictDirty	3
#define istatisMac		4

#define STATS(c)	rgstatis[c].l++

#else	/* !DEBUG */

#define STATS(c)

#endif	/* !DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\b71iseng.h ===
// ***********************************************************************
// Microsoft Jet
// 
// Microsoft Confidential.  Copyright 1989-1991 Microsoft Corporation.
// 
// Component: ISAM
// 
// File:
// 
// File Comments:
// <comments>
// 
// Revision History:
// 
//     [0]  19-Sep-90  RichardS	Created from BC 7.x ISAM
// 
// ***********************************************************************

//.xlist
//include config.inc
//include cmacros.inc
//.list

// USHORT cchDouble = ; define this appropriately if DBCS is defined

BYTE rgchDouble[] = { 0 };						// Never accessed
BYTE rgchSingle[] = { 186, 186, 142, 154 };	// 2 sets of single to dbl

#define BFirstByteOfDouble(ib)		(*(rgchDouble + (ib)*3))
#define BSecondByteOfDouble(ib)		(*(rgchDouble + (ib)*3 + 1))
#define BThirdByteOfDouble(ib)		(*(rgchDouble + (ib)*3 + 2))

#define BFirstByteForSingle(ib)		rgchSingle[(255 - (ib)) *2]
#define BSecondByteForSingle(ib)		rgchSingle[(255 - (ib)) *2 + 1]


#define BGetTranslation(ib)		(rgbTranslation[ib])
#define BGetAccent(ib)				(rgbAccentMap[ib])

BYTE rgbTranslation[] = 
					{
					0,			// 0
					1,			// 1
					2,			// 2
					3,			// 3
					4,			// 4
					5,			// 5
					6,			// 6
					7,			// 7
					8,			// 8
					9,			// 9
					10,			// 10
					11,			// 11
					12,			// 12
					13,			// 13
					14,			// 14
					15,			// 15
					16,			// 16
					17,			// 17
					18,			// 18
					19,			// 19
					20,			// 20
					21,			// 21
					22,			// 22
					23,			// 23
					24,			// 24
					25,			// 25
					26,			// 26
					27,			// 27
					28,			// 28
					29,			// 29
					30,			// 30
					31,			// 31
					32,			// 32
					33,			// 33
					34,			// 34
					35,			// 35
					36,			// 36
					37,			// 37
					38,			// 38
					39,			// 39
					40,			// 40
					41,			// 41
					42,			// 42
					43,			// 43
					44,			// 44
					45,			// 45
					46,			// 46
					47,			// 47
					48,			// 48
					49,			// 49
					50,			// 50
					51,			// 51
					52,			// 52
					53,			// 53
					54,			// 54
					55,			// 55
					56,			// 56
					57,			// 57
					58,			// 58
					59,			// 59
					60,			// 60
					61,			// 61
					62,			// 62
					63,			// 63
					64,			// 64
					142,			// 65
					144,			// 66
					146,			// 67
					150,			// 68
					154,			// 69
					156,			// 70
					158,			// 71
					160,			// 72
					162,			// 73
					164,			// 74
					166,			// 75
					168,			// 76
					172,			// 77
					174,			// 78
					178,			// 79
					180,			// 80
					182,			// 81
					184,			// 82
					186,			// 83
					188,			// 84
					190,			// 85
					194,			// 86
					196,			// 87
					198,			// 88
					200,			// 89
					202,			// 90
					65,			// 91
					66,			// 92
					67,			// 93
					68,			// 94
					69,			// 95
					70,			// 96
					142,			// 97
					144,			// 98
					146,			// 99
					150,			// 100
					154,			// 101
					156,			// 102
					158,			// 103
					160,			// 104
					162,			// 105
					164,			// 106
					166,			// 107
					168,			// 108
					172,			// 109
					174,			// 110
					178,			// 111
					180,			// 112
					182,			// 113
					184,			// 114
					186,			// 115
					188,			// 116
					190,			// 117
					194,			// 118
					196,			// 119
					198,			// 120
					200,			// 121
					202,			// 122
					71,			// 123
					72,			// 124
					73,			// 125
					74,			// 126
					75,			// 127
					76,			// 128
					77,			// 129
					78,			// 130
					79,			// 131
					80,			// 132
					81,			// 133
					82,			// 134
					83,			// 135
					84,			// 136
					85,			// 137
					86,			// 138
					87,			// 139
					88,			// 140
					89,			// 141
					90,			// 142
					91,			// 143
					92,			// 144
					93,			// 145
					94,			// 146
					95,			// 147
					96,			// 148
					97,			// 149
					98,			// 150
					99,			// 151
					100,			// 152
					101,			// 153
					102,			// 154
					103,			// 155
					104,			// 156
					105,			// 157
					106,			// 158
					107,			// 159
					108,			// 160
					109,			// 161
					110,			// 162
					111,			// 163
					112,			// 164
					113,			// 165
					114,			// 166
					115,			// 167
					116,			// 168
					117,			// 169
					118,			// 170
					119,			// 171
					120,			// 172
					121,			// 173
					122,			// 174
					123,			// 175
					124,			// 176
					125,			// 177
					126,			// 178
					127,			// 179
					128,			// 180
					129,			// 181
					130,			// 182
					131,			// 183
					132,			// 184
					133,			// 185
					134,			// 186
					135,			// 187
					136,			// 188
					137,			// 189
					138,			// 190
					139,			// 191
					142,			// 192
					142,			// 193
					142,			// 194
					142,			// 195
					142,			// 196
					142,			// 197
					254,			// 198
					146,			// 199
					154,			// 200
					154,			// 201
					154,			// 202
					154,			// 203
					162,			// 204
					162,			// 205
					162,			// 206
					162,			// 207
					152,			// 208
					174,			// 209
					178,			// 210
					178,			// 211
					178,			// 212
					178,			// 213
					178,			// 214
					140,			// 215
					208,			// 216
					190,			// 217
					190,			// 218
					190,			// 219
					190,			// 220
					200,			// 221
					204,			// 222
					255,			// 223
					142,			// 224
					142,			// 225
					142,			// 226
					142,			// 227
					142,			// 228
					142,			// 229
					254,			// 230
					146,			// 231
					154,			// 232
					154,			// 233
					154,			// 234
					154,			// 235
					162,			// 236
					162,			// 237
					162,			// 238
					162,			// 239
					152,			// 240
					174,			// 241
					178,			// 242
					178,			// 243
					178,			// 244
					178,			// 245
					178,			// 246
					141,			// 247
					208,			// 248
					190,			// 249
					190,			// 250
					190,			// 251
					190,			// 252
					200,			// 253
					204,			// 254
					200				// 255
					};


BYTE rgbAccentMap[] = 
					{
					1,			// 0
					1,			// 1
					1,			// 2
					1,			// 3
					1,			// 4
					1,			// 5
					1,			// 6
					1,			// 7
					1,			// 8
					1,			// 9
					1,			// 10
					1,			// 11
					1,			// 12
					1,			// 13
					1,			// 14
					1,			// 15
					1,			// 16
					1,			// 17
					1,			// 18
					1,			// 19
					1,			// 20
					1,			// 21
					1,			// 22
					1,			// 23
					1,			// 24
					1,			// 25
					1,			// 26
					1,			// 27
					1,			// 28
					1,			// 29
					1,			// 30
					1,			// 31
					1,			// 32
					1,			// 33
					1,			// 34
					1,			// 35
					1,			// 36
					1,			// 37
					1,			// 38
					1,			// 39
					1,			// 40
					1,			// 41
					1,			// 42
					1,			// 43
					1,			// 44
					1,			// 45
					1,			// 46
					1,			// 47
					1,			// 48
					1,			// 49
					1,			// 50
					1,			// 51
					1,			// 52
					1,			// 53
					1,			// 54
					1,			// 55
					1,			// 56
					1,			// 57
					1,			// 58
					1,			// 59
					1,			// 60
					1,			// 61
					1,			// 62
					1,			// 63
					1,			// 64
					1,			// 65
					1,			// 66
					1,			// 67
					1,			// 68
					1,			// 69
					1,			// 70
					1,			// 71
					1,			// 72
					1,			// 73
					1,			// 74
					1,			// 75
					1,			// 76
					1,			// 77
					1,			// 78
					1,			// 79
					1,			// 80
					1,			// 81
					1,			// 82
					1,			// 83
					1,			// 84
					1,			// 85
					1,			// 86
					1,			// 87
					1,			// 88
					1,			// 89
					1,			// 90
					1,			// 91
					1,			// 92
					1,			// 93
					1,			// 94
					1,			// 95
					1,			// 96
					1,			// 97
					1,			// 98
					1,			// 99
					1,			// 100
					1,			// 101
					1,			// 102
					1,			// 103
					1,			// 104
					1,			// 105
					1,			// 106
					1,			// 107
					1,			// 108
					1,			// 109
					1,			// 110
					1,			// 111
					1,			// 112
					1,			// 113
					1,			// 114
					1,			// 115
					1,			// 116
					1,			// 117
					1,			// 118
					1,			// 119
					1,			// 120
					1,			// 121
					1,			// 122
					1,			// 123
					1,			// 124
					1,			// 125
					1,			// 126
					1,			// 127
					1,			// 128
					1,			// 129
					1,			// 130
					1,			// 131
					1,			// 132
					1,			// 133
					1,			// 134
					1,			// 135
					1,			// 136
					1,			// 137
					1,			// 138
					1,			// 139
					1,			// 140
					1,			// 141
					1,			// 142
					1,			// 143
					1,			// 144
					1,			// 145
					1,			// 146
					1,			// 147
					1,			// 148
					1,			// 149
					1,			// 150
					1,			// 151
					1,			// 152
					1,			// 153
					1,			// 154
					1,			// 155
					1,			// 156
					1,			// 157
					1,			// 158
					1,			// 159
					1,			// 160
					1,			// 161
					1,			// 162
					1,			// 163
					1,			// 164
					1,			// 165
					1,			// 166
					1,			// 167
					1,			// 168
					1,			// 169
					1,			// 170
					1,			// 171
					1,			// 172
					1,			// 173
					1,			// 174
					1,			// 175
					1,			// 176
					1,			// 177
					1,			// 178
					1,			// 179
					1,			// 180
					1,			// 181
					1,			// 182
					1,			// 183
					1,			// 184
					1,			// 185
					1,			// 186
					1,			// 187
					1,			// 188
					1,			// 189
					1,			// 190
					1,			// 191
					3,			// 192
					2,			// 193
					4,			// 194
					6,			// 195
					5,			// 196
					7,			// 197
					1,			// 198
					8,			// 199
					3,			// 200
					2,			// 201
					4,			// 202
					5,			// 203
					3,			// 204
					2,			// 205
					4,			// 206
					5,			// 207
					1,			// 208
					6,			// 209
					3,			// 210
					2,			// 211
					4,			// 212
					6,			// 213
					5,			// 214
					1,			// 215
					1,			// 216
					3,			// 217
					2,			// 218
					4,			// 219
					5,			// 220
					2,			// 221
					1,			// 222
					1,			// 223
					3,			// 224
					2,			// 225
					4,			// 226
					6,			// 227
					5,			// 228
					7,			// 229
					1,			// 230
					8,			// 231
					3,			// 232
					2,			// 233
					4,			// 234
					5,			// 235
					3,			// 236
					2,			// 237
					4,			// 238
					5,			// 239
					1,			// 240
					6,			// 241
					3,			// 242
					2,			// 243
					4,			// 244
					6,			// 245
					5,			// 246
					1,			// 247
					1,			// 248
					3,			// 249
					2,			// 250
					4,			// 251
					5,			// 252
					2,			// 253
					1,			// 254
					5			// 255
					};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\bm.h ===
/* structure used by BMExpungelink to fix indexes
/**/
typedef struct _bmfix {
	PIB			*ppib;				/* bm cleanup thread */
	FUCB		*pfucb;				/* cursor to node */
	FUCB		*pfucbSrc;			/* cursor to backlink */
	
	BF			**rgpbf;			/* wait latched buffers required for bmfix */
	INT		  	cpbf;
	INT	  		cpbfMax;

	SRID		sridOld;
	SRID		sridNew;
	} BMFIX;


/*	register pages for bookmark cleanup.  To register a page, the pn
/*	of the page, pgno of domain FDP and srid of visible father are
/*	needed.
/**/

ERR ErrMPLInit( VOID );
VOID MPLTerm( VOID );
VOID MPLRegister( FCB *pfcb, SSIB *pssib, PN pn, SRID sridFather );
VOID MPLPurge(DBID dbid);
VOID MPLPurgeFDP( DBID dbid, PGNO pgnoFDP );
VOID MPLPurgePgno( DBID dbid, PGNO pgnoFirst, PGNO pgnoLast );

extern PIB	*ppibBMClean;

ERR ErrBMInit( VOID );
ERR ErrBMTerm( VOID );
ERR ErrBMDoEmptyPage(
	FUCB	*pfucb,
	RMPAGE	*prmpage,
	BOOL	fAllocBuf,
	BOOL	*pfRmParent,
	BOOL	fSkipDelete);
ERR ErrBMDoMerge( FUCB *pfucb, FUCB *pfucbRight, SPLIT *psplit );
ERR ErrBMAddToLatchedBFList( RMPAGE	*prmpage, BF *pbfLatched );
ERR ErrBMClean( PIB *ppib );

#ifdef DEBUG
VOID AssertNotInMPL( DBID dbid, PGNO pgnoFirst, PGNO pgnoLast );
VOID AssertMPLPurgeFDP( DBID dbid, PGNO pgnoFDP );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\daedef.h ===
/************ DAE: OS/2 Database Access Engine *************/
/************ daedef.h: DAE Global Definitions *************/


/***********************************************************/
/******************* fundamental types *********************/
/***********************************************************/

#include "os.h"

/***********************************************************/
/****************** global configuration macros ************/
/***********************************************************/

#ifndef	WIN16					/* for OS/2 or Win32 */
#define ASYNC_IO_PROC		/* asynchronous IO */
#define ASYNC_LOG_FLUSH		/* asynchronous LOG FLUSH */

#define ASYNC_BF_CLEANUP	/* asynchorouse Buffer clean up */
#define ASYNC_VER_CLEANUP	/* asynchronous Bucket clean up */
#define ASYNC_BM_CLEANUP	/* asynchorouse Bookmark clean up */
#endif

#define CHECKSUM	 		/* check sum for read/write page validation */
//#define PERFCNT	 		/* enable performance counter */
//#define NOLOG				/* Log disabled? */
#define REUSEDBID	 		/* Reuse DBID */
//#define RFS2
//#define MEM_CHECK			/*	Check for resource and memory leakage */
//#define KEYCHANGED
#define BULK_INSERT_ITEM
#define MOVEABLEDATANODE

/***********************************************************/
/******************* declaration macros ********************/
/***********************************************************/

#ifdef JETINTERNAL			/* Start of definitions copied from vtapi.h */

#ifndef NJETNT
#ifdef	WIN32				     /* 0:32 Flat Model (Intel 80x86) */
	#define VTAPI __cdecl
#elif	defined(M_MRX000)	     /* 0:32 Flat Model (MIPS Rx000) */
	#define VTAPI
#else	/* WIN16 */			     /* 16:16 Segmented Model */
	#define VTAPI __far __pascal
#endif
#endif

#endif						/* End of definitions copied from vtapi.h */


#include "daedebug.h"

#define LOCAL static
#ifdef DEBUG
#define INLINE
#else
#define INLINE __inline
#endif

/***********************************************************/
/************ global types and associated macros ***********/
/***********************************************************/

typedef struct _res			/* resource, defined in sysinit.c and daeutil.h */
	{
	const INT 	cbSize;
	INT			cblockAlloc;
	BYTE			*pbAlloc;
	INT			cblockAvail;
	BYTE			*pbAvail;
	INT			iblockCommit;
	INT			iblockFail;
	} RES;

typedef struct _pib		PIB;
typedef struct _ssib		SSIB;
typedef struct _fucb		FUCB;
typedef struct _csr		CSR;
typedef struct _fcb		FCB;
typedef struct _fdb		FDB;
typedef struct _idb		IDB;
typedef struct _dib		DIB;
typedef struct _scb		SCB;
typedef struct _rcehead	RCEHEAD;
typedef struct _rce		RCE;
typedef struct _bucket	BUCKET;
typedef struct _dab		DAB;
typedef struct _rmpage	RMPAGE;
typedef struct _bmfix	BMFIX;

typedef unsigned short LANGID;
typedef ULONG			LRID;
#if WIN32
typedef ULONG			PROCID;
#else
typedef TID				PROCID;
#endif

#define pNil			((void *)0)
#define pbNil			((BYTE *)0)
#define plineNil		((LINE *)0)
#define pkeyNil 		((KEY *)0)
#define ppibNil 		((PIB *)0)
#define pwaitNil		((WAIT *)0)
#define pssibNil		((SSIB *)0)
#define pfucbNil		((FUCB *)0)
#define pcsrNil 		((CSR *)0)
#define pfcbNil 		((FCB *)0)
#define pfdbNil 		((FDB *)0)
#define pfieldNil		((FIELD *)0)
#define pidbNil 		((IDB *)0)
#define pscbNil 		((SCB *)0)
#define procidNil		((PROCID) 0xffff)
#define pbucketNil		((BUCKET *)0)
#define prceheadNil		((RCEHEAD *)0)
#define prceNil			((RCE *)0)
#define pdabNil			((DAB *)0)
#define	prmpageNil		((RMPAGE *) 0)

typedef unsigned long	PGNO;
typedef unsigned long	PGDISCONT;
typedef unsigned long	PN;
#define pnNull			((PN) 0)
#define pgnoNull		((PGNO) 0)

/* UNDONE: should be in storage.h */
#define FVersionPage(pbf)  (pbf->ppage->pghdr.cVersion)

#define CPG					LONG					/* count of pages */

typedef BYTE				LEVEL;		 		/* transaction levels */
#define levelNil			((LEVEL)0xff)		/*	flag for inactive PIB */

typedef WORD				DBID;
typedef WORD				FID;
typedef SHORT				IDXSEG;

/* Standard Record IDs */
typedef ULONG SRID;								/* standard record id */
typedef ULONG LINK;
#define PgnoOfSrid(srid) ((srid)>>8)
#define ItagOfSrid(srid) ((BYTE)((srid) & 0x000000FF))
#define SridOfPgnoItag(pgno, itag) ((pgno)<<8 | (LONG)(itag))
#define itagNil ((INT)0x0fff)
#define sridNull SridOfPgnoItag(pgnoNull, ((BYTE)itagNil))
#define sridNullLink	0


/*	position within current series
 *	note order of field is of the essence as log position used by
 *	storage as timestamp, must in ib, isec, usGen order so that we can
 *  use long value compare.
 */
typedef struct
	{
	USHORT ib;					/* must be the last so that lgpos can */
	USHORT isec;				/* index of disksec starting logsec	 */
	USHORT usGeneration;		/* generation of logsec */
	} LGPOS;					/* be casted to TIME. */
extern LGPOS lgposMax;
extern LGPOS lgposMin;
extern INT fRecovering;		/* to turn off logging during Redo */

	
/***********************************************************/
/*********************** DAE macros ************************/
/***********************************************************/

/*  per database operation counter, ulDBTime is logged, used to compare
 *  with the ulDBTime of a page to decide if a redo of the logged operation
 *  is necessary.
 */
#define ulDBTimeMin	(0x00000000)
#define ulDBTimeMax	(0xffffffff)

/*  Transaction counter, used to keep track of the oldest transaction.
 */
typedef ULONG		TRX;
#define trxMin		0
#define trxMax		(0xffffffff)


typedef struct
	{
	ULONG cb;
	BYTE *pb;
	} LINE;

#define FLineNull(pline) \
	((pline) == NULL || (pline)->cb == 0 || (pline)->pb == NULL)

#define LineCopy(plineTo, plineFrom)								\
	{																\
	(plineTo)->cb = (plineFrom)->cb;								\
	memcpy((plineTo)->pb, (plineFrom)->pb, (plineFrom)->cb);		\
	}
#define CbLine(pline) ((pline) ? (pline)->cb : 0)

typedef LINE KEY;				// Directory Key
#define FKeyNull(pkey) FLineNull(pkey)
#define KeyCopy(pkeyTo, pkeyFrom) LineCopy(pkeyTo, pkeyFrom)
#define CbKey(pkey) CbLine(pkey)

typedef struct
	{
	ULONG cbMax;				// size of buffer
	ULONG cbActual; 			// true size of return value
	ULONG cbReturned;			// length of value returned
	BYTE *pb;					// pointer to buffer for return value
	} OUTLINE;

typedef struct _threebytes { BYTE b[3]; } THREEBYTES;
#define ThreeBytesFromL(tb, l)							\
	{																\
	ULONG DAE_ul = l;											\
	BYTE *DAE_ptb = (BYTE *)&(tb);						\
	*DAE_ptb	= (BYTE)DAE_ul; 								\
	*++DAE_ptb = (BYTE)( DAE_ul >>= 8 );				\
	*++DAE_ptb = (BYTE)( DAE_ul >>= 8 );				\
	}

#define LFromThreeBytes(l, tb)							\
	{																\
	ULONG DAE_ul;												\
	BYTE *DAE_ptb = (BYTE *)&(tb) + 2;					\
	DAE_ul = (ULONG) *DAE_ptb;								\
	DAE_ul <<= 8;												\
	DAE_ul |= *--DAE_ptb;									\
	DAE_ul <<=8;												\
	DAE_ul |= *--DAE_ptb;									\
	l = DAE_ul;													\
	}

#define TbKeyFromPgno(tbLast, pgno)						 	\
	{																	\
	ULONG DAE_ul = pgno;							  				\
	BYTE * DAE_ptb = ((BYTE *)&(tbLast)) + 2;				\
	*DAE_ptb = (BYTE) (DAE_ul);								\
	*--DAE_ptb = (BYTE) (DAE_ul >>= 8);						\
	*--DAE_ptb = (BYTE) (DAE_ul >>= 8);						\
	}

#define PgnoFromTbKey(pgno, tbKey)							\
	{																	\
	ULONG DAE_ul;													\
	BYTE * DAE_ptb = (BYTE *) & (tbKey);					\
	DAE_ul = (ULONG) *DAE_ptb;									\
	DAE_ul <<= 8;													\
	DAE_ul |= *++DAE_ptb;										\
	DAE_ul <<= 8;													\
	DAE_ul |= *++DAE_ptb;										\
	pgno = DAE_ul;													\
	}

#define	Pb4ByteAlign( pb )		( ((LONG)pb + 3) & 0xfffffffc )
#define	Pb4ByteTruncate( pb ) 	( (LONG)pb & 0xfffffffc )
	
/***********************************************************/
/******************** general C macros *********************/
/***********************************************************/

#define forever					for(;;)

#ifdef	DEBUG

#ifdef	RFS2

/*  RFS/JET call logging
/*
/*	RFS allocator:  returns 0 if allocation is disallowed.  Also handles RFS logging.
/*	cRFSAlloc is the global allocation counter.  A value of -1 disables RFS in debug mode.
/**/

#define RFSAlloc(type) (UtilRFSAlloc(#type))

	/*  RFS disable/enable macros  */

#define RFSDisable()	(fDisableRFS = 1)
#define RFSEnable()		(fDisableRFS = 0)

/*  JET call logging (log on failure)
/**/

#define LogJETCall(func,err) (UtilRFSLogJETCall(#func,err,szAssertFilename,__LINE__))

/*  JET call macros
/**/
	
#define Call(func)			{LogJETCall(func,err = (func)); if (err < 0) {goto HandleError;}}
#define CallR(func)			{LogJETCall(func,err = (func)); if (err < 0) {return err;}}
#define CallJ(func,label)	{LogJETCall(func,err = (func)); if (err < 0) {goto label;}}
#define CallS(func)			{ERR errT; LogJETCall(func,errT = (func)); Assert(errT == JET_errSuccess);}

/*  JET inline error logging (logging controlled by JET call flags)
/**/

#define LogJETErr(err,label) (UtilRFSLogJETErr(err,#label,szAssertFilename,__LINE__))

/*  JET inline error macros
/**/

#define Error(errT,label)	{LogJETErr(errT,label); err = (errT); goto label;}

#else

#define RFSAlloc(type)				(1)
#define RFSDisable()				(1)
#define RFSEnable()					(0)
#define Call(func)					{if ((err = (func)) < 0) {goto HandleError;}}
#define CallR(func)					{if ((err = (func)) < 0) {return err;}}
#define CallJ( func, label )		{if ((err = (func)) < 0) goto label;}
#define Error( errToReturn, label )	{err = errToReturn; goto label;}
#define CallS(func)					{ ERR errT; Assert( (errT = (func)) == JET_errSuccess ); }

#endif

#else

#define RFSAlloc(type)		(1)
#define RFSDisable()		(1)
#define RFSEnable()			(0)
#define Call(func)			{if ((err = (func)) < 0) {goto HandleError;}}
#define CallR(func)			{if ((err = (func)) < 0) {return err;}}
#define CallJ(func,label)	{if ((err = (func)) < 0) {goto label;}}
#define CallS(func)			{ERR errT; errT = (func);}
#define Error(errT,label)	{err = (errT); goto label;}

#endif

#define NotUsed(p)	(p)


/***********************************************************/
/***** include Jet Project prototypes and constants ********/
/***********************************************************/
	
#include "jet.h"
#include "_jet.h"
#include "_jetstr.h"
#include "jetdef.h"
#include "sesmgr.h"
#include "isamapi.h"
#include "vdbapi.h"
#include "vtapi.h"
#include "disp.h"
#include "taskmgr.h"

#include "vdbmgr.h"
extern CODECONST(VDBFNDEF) vdbfndefIsam;

#include "vtmgr.h"
extern CODECONST(VTFNDEF) vtfndefIsam;
extern CODECONST(VTFNDEF) vtfndefIsamInfo;
extern CODECONST(VTFNDEF) vtfndefTTSortIns;
extern CODECONST(VTFNDEF) vtfndefTTSortRet;
extern CODECONST(VTFNDEF) vtfndefTTBase;

JET_TABLEID TableidOfVtid( FUCB *pfucb );

ERR VTAPI ErrDispPrepareUpdate( JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit );
ERR VTAPI ErrDispSetColumn( JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void *pb, unsigned long cb, JET_GRBIT grbit,
	JET_SETINFO *psetinfo );
ERR VTAPI ErrDispCloseTable( JET_SESID sesid, JET_TABLEID tableid );
ERR VTAPI ErrDispUpdate( JET_SESID sesid, JET_TABLEID tableid, void *pb,
	unsigned long cbMax, unsigned long *pcbActual );
ERR VTAPI ErrDispMove( JET_SESID sesid, JET_TABLEID tableid, long crows, JET_GRBIT grbit );

/***********************************************************/
/******************* mutual exclusion **********************/
/***********************************************************/

typedef void * SEM;
typedef void * SIG;
typedef void * CRIT;

/*	enable multiple MUTEX resource
/**/
#ifdef WIN16

#define	SemDefine( s )	
#define	ErrSemCreate( s, sz )					JET_errSuccess
#define	SemRequest( s )							0
#define	SemRelease( s )							0
#define	SemAssert( s )							0
#define	ErrSignalCreate( s, sz ) 	  			JET_errSuccess
#define	ErrSignalCreateAutoReset( s, sz )		JET_errSuccess
#define	SignalReset( s )						0
#define	SignalSend( s )							0
#define	SignalWait( s, t )						0
#define	SignalWaitEx( s, t )					0
#define	MultipleSignalWait( i, rg, f, t )		0
#define	SignalClose( s )						0
#define	ErrInitializeCriticalSection( s )	   	JET_errSuccess
#define	EnterCriticalSection( s ) 				0
#define	LeaveCriticalSection( s ) 				0
#define	EnterNestableCriticalSection( s ) 		0
#define	LeaveNestableCriticalSection( s ) 		0
#define	AssertCriticalSection( s )				0
#define	DeleteCriticalSection( s )				0

#define	SgSemDefine( s )	
#define	SgErrSemCreate( s, sz )					JET_errSuccess
#define	SgSemRequest( s )						0	
#define	SgSemRelease( s )	  					0	
#define	SgSemAssert( s )	  					0	

#define	LgSemDefine( s )	
#define	LgErrSemCreate( s, sz )	  				JET_errSuccess
#define	LgSemRequest( s )		  				0
#define	LgSemRelease( s )		  				0
#define	LgSemAssert( s )		  				0
#define	LgErrInitializeCriticalSection( s, c )	JET_errSuccess
#define	LgEnterCriticalSection( s )		 		0	
#define	LgLeaveCriticalSection( s )		 		0	
#define	LgEnterNestableCriticalSection( s )	  	0	
#define	LgLeaveNestableCriticalSection( s )	  	0	
#define	LgAssertCriticalSection( s )			0
#define	LgDeleteCriticalSection( s )			0

#else /* !WIN16 */

#ifdef SGSEM					/* small grain */

#define	SemDefine( s )							__near SEM s
#define	ErrSemCreate( s, sz ) 					UtilSemCreate( s )
#define	SemRequest( s )							UtilSemRequest( s )
#define	SemRelease( s )							UtilSemRelease( s )
#define	SemAssert( s )							UtilAssertSEM( s )
#define	ErrSignalCreate( s, sz ) 				ErrUtilSignalCreate( s, sz )
#define	ErrSignalCreateAutoReset( s, sz ) 		ErrUtilSignalCreateAutoReset( s, sz )
#define	SignalReset( s )						UtilSignalReset( s )
#define	SignalSend( s )							UtilSignalSend( s )
#define	SignalWait( s, t ) 						UtilSignalWait( s, t )
#define	SignalWaitEx( s, t, f ) 				UtilSignalWaitEx( s, t, f )
#define	MultipleSignalWait( i, rg, f, t )		UtilMultipleSignalWait( i, rg, f, t )
#define	SignalClose( s )				   		UtilCloseSignal( s )
#define	ErrInitializeCriticalSection( s )  		ErrUtilInitializeCriticalSection( s )
#define	EnterCriticalSection( s ) 				UtilEnterCriticalSection( s )
#define	LeaveCriticalSection( s ) 				UtilLeaveCriticalSection( s )
#define	EnterNestableCriticalSection( s ) 		UtilEnterNestableCriticalSection( s )
#define	LeaveNestableCriticalSection( s )		UtilLeaveNestableCriticalSection( s )
#define	AssertCriticalSection( s )				UtilAssertCrit( s )
#define HoldCriticalSection( s )	\
	{								\
	UtilAssertCrit( s );			\
	UtilHoldCriticalSection( s );	\
	}
#define ReleaseCriticalSection( s )	
	{								\
	UtilAssertCrit( s );			\
	UtilReleaseCriticalSection( s );\
	}
#define	DeleteCriticalSection( s )				UtilDeleteCriticalSection( s )

#define	SgSemDefine( s )		 				__near SEM s
#define	SgErrSemCreate( s, sz )					UtilSemCreate( s, sz )
#define	SgSemRequest( s )  						UtilSemRequest( s )
#define	SgSemRelease( s )  						UtilSemRelease( s )
#define	SgSemAssert( s )	 					UtilAssertSEM( s )

#define	LgSemDefine( s )							
#define	LgErrSemCreate( s, sz )  			  	0
#define	LgSemRequest( s )	  					0
#define	LgSemRelease( s )	  					0
#define	LgSemAssert( s )					  	0
#define	LgErrInitializeCriticalSection( s )		JET_errSuccess
#define	LgEnterCriticalSection( s )		  		0
#define	LgLeaveCriticalSection( s )		  		0
#define	LgEnterNestableCriticalSection( s )	  	0
#define	LgLeaveNestableCriticalSection( s )	  	0
#define	LgAssertCriticalSection( s )			0
#define	LgDeleteCriticalSection( s )			0

#else /* !SGSEM */

#define	SemDefine( s )		 					__near SEM s
#define	SemErrCreate( s, sz )  					UtilSemCreate( s, sz )
#define	SemRequest( s )							UtilSemRequest( s )
#define	SemRelease( s )							UtilSemRelease( s )
#define	SemAssert( s )						   	UtilAssertSEM( s )
#define	ErrSignalCreate( s, sz ) 			   	ErrUtilSignalCreate( s, sz )
#define	ErrSignalCreateAutoReset( s, sz )		ErrUtilSignalCreateAutoReset( s, sz )
#define	SignalReset( s )					   	UtilSignalReset( s )
#define	SignalSend( s )							UtilSignalSend( s )
#define	SignalWait( s, t ) 						UtilSignalWait( s, t )
#define	SignalWaitEx( s, t, f ) 				UtilSignalWaitEx( s, t, f )
#define	MultipleSignalWait( i, rg, f, t )		UtilMultipleSignalWait( i, rg, f, t )
#define	SignalClose( s )						UtilCloseSignal( s )
#define	ErrInitializeCriticalSection( s )		ErrUtilInitializeCriticalSection( s )
#define	EnterCriticalSection( s )				UtilEnterCriticalSection( s )
#define	LeaveCriticalSection( s )				UtilLeaveCriticalSection( s )
#define	EnterNestableCriticalSection( s ) 		UtilEnterNestableCriticalSection( s )
#define	LeaveNestableCriticalSection( s ) 		UtilLeaveNestableCriticalSection( s )
#define	AssertCriticalSection( s )				UtilAssertCrit( s )
#define HoldCriticalSection( s )	\
	{								\
	UtilAssertCrit( s );			\
	UtilHoldCriticalSection( s );	\
	}
#define ReleaseCriticalSection( s )	\
	{								\
	UtilAssertCrit( s );			\
	UtilReleaseCriticalSection( s );\
	}
#define	DeleteCriticalSection( s )				UtilDeleteCriticalSection( s )

#define	SgSemDefine( s )		 					
#define	SgErrSemCreate( s, sz )					0
#define	SgSemRequest( s )						UtilAssertCrit( critJet )
#define	SgSemRelease( s )						UtilAssertCrit( critJet )
#define	SgSemAssert( s ) 						UtilAssertCrit( critJet )

#define	LgSemDefine( s )						__near SEM s;
#define	LgErrSemCreate( s, sz )					SemCreate( s, sz )
#define	LgSemRequest( s )						SemRequest( s )
#define	LgSemRelease( s )				  		SemRelease( s )
#define	LgSemAssert( s ) 						UtilAssertCrit( s )
#define	LgErrInitializeCriticalSection( s )		ErrUtilInitializeCriticalSection( s )
#define	LgEnterCriticalSection( s )				UtilEnterCriticalSection( s )
#define	LgLeaveCriticalSection( s )				UtilLeaveCriticalSection( s )
#define	LgEnterNestableCriticalSection( s )		UtilEnterNestableCriticalSection( s )
#define	LgLeaveNestableCriticalSection( s )		UtilLeaveNestableCriticalSection( s )
#define	LgAssertCriticalSection( s )			UtilAssertCrit( s )
#define	LgDeleteCriticalSection( s )			UtilDeleteCriticalSection( s )

#endif /* !SGSEM */

#endif /* !WIN16 */

/*	include other global DAE headers
/**/
#include	"sys.h"
#include	"err.h"
#include	"daeconst.h"

#define	fSTInitNotDone		0
#define fSTInitInProgress 	1
#define	fSTInitDone			2
extern BOOL __near fSTInit;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\daeconst.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============  daeconst.h: Global System Constants	===================

#define	cpgDatabaseMin			16
#define	cpgDatabaseMax			(1UL << 19)

#define pgnoSystemRoot			((PGNO) 1)
#define itagSystemRoot			0

#define szSystemDatabase		"system.mdb"
#define szTempDBFileName 		"temp.mdb"
#define szTempFile				"temp.tmp"

/* number of pages of system root FDP primary extent */
#define cpgSystemPrimary		((CPG) 1)		

/* initial temporary file allocation */
#define cpgTempFile			 	((CPG) 1)	  

/* discontinuity measurement unit
/**/
#define cpgDiscont				16

/*	default density
/**/
#define ulDefaultDensity		80					// 80% density
#define ulFILEDensityLeast		20					// 20% density
#define ulFILEDensityMost		100				// 100% density

#define dbidTemp					((DBID) 0)
#define dbidSystemDatabase		((DBID) 1)
#define dbidUserMin				((DBID) 1)
#define dbidMin					((DBID) 0)
#define dbidUserMax				((DBID) 67)
#define dbidMax					dbidUserMax

/*	number of buffer hash table entries
/*	should be prime
/**/
#define ipbfMax					8191

/*	vertical split threshold
/**/
#define cbVSplitThreshold 		400

/*	Engine OBJIDs:
/*
/*	0..0x10000000 reserved for engine use, divided as follows:
/*
/*	0x00000000..0x0000FFFF	reserved for TBLIDs under RED
/*	0x00000000..0x0EFFFFFF	reserved for TBLIDs under BLUE
/*	0x0F000000..0x0FFFFFFF	reserved for container IDs
/*	0x10000000				reserved for ObjectId of DbObject
/*
/*	Client OBJIDs begin at 0x10000001 and go up from there.
/**/

#define objidNil					((OBJID) 0x00000000)
#define objidRoot					((OBJID) 0x0F000000)
#define objidTblContainer 			((OBJID) 0x0F000001)
#define objidDbContainer			((OBJID) 0x0F000002)
#define objidRcContainer			((OBJID) 0x0F000003)
#define objidDbObject				((OBJID) 0x10000000)

/*	Magic number used in database root node for integrity checking
/**/
#define ulDAEMagic					0x89abcdef
#define ulDAEVersion				0x00000001
#define ulDAEPrevVersion			0x00000000

#define szVerbose					"BLUEVERBOSE"

#define szNull						""

/*	transaction level limits.
/**/
#define levelMax					((LEVEL)10)		// all level < 10
#define levelMost					((LEVEL)9)		// max for engine
#define levelUserMost				((LEVEL)7)		// max for user
#define levelMin					((LEVEL)0)

/* Start and max waiting period for WaitTillOldest
/**/
#define ulStartTimeOutPeriod				20
#define ulMaxTimeOutPeriod					60000

/*	default resource allocation
/**/
#define	cDBOpenDefault			 			100
#define	cbucketLowerThreshold				8
#define	cbufThresholdLowDefault				20
#define	cbufThresholdHighDefault			80
#define	cpibDefault				 			10
#define	cbgcbDefault			 			4
#define	cfucbDefault			 			300
#define	cfcbDefault				 			300
#define	cscbDefault				 			20
#define	cidbDefault				 			cfcbDefault
#define	cbufDefault				 			500
#define	clgsecBufDefault		 			21			
#define	clgsecGenDefault		 			250
#define	clgsecFTHDefault		 			10
#define	cbucketDefault			 			64
#define	lWaitLogFlushDefault	 			15
#define	lLogFlushPeriodDefault				45
#define	lLGCheckpointPeriodDefault			10
//#define	lLGCheckpointPeriodDefault		100
#define	lLGWaitingUserMaxDefault			3
#define	lPageFragmentDefault	 			8	
#define	cdabDefault				 			100
#define lBufLRUKCorrelationIntervalDefault	0
#define lBufBatchIOMaxDefault				64
#define lPageReadAheadMaxDefault  			4
#define lAsynchIOMaxDefault					64

/*	resource relationships for derived resources
/**/
#define	lCSRPerFUCB							2

/*	system resource requirements
/**/
#define	cpibSystem							3
#define	cbucketSystem						2

/*	vertical split minimum in non-FDP page.
/**/
#define	cbVSplitMin							100

/*	code page constants.
/**/
#define	usUniCodePage						1200		/* code page for Unicode strings */
#define	usEnglishCodePage					1252		/* code page for English */

/*	length of modified page list
/**/
#define		cmpeMax							8192

/*	idle processing constants
/**/
#define icallIdleBMCleanMax 				cmpeMax

/*	wait time for latch/crit conflicts
/**/
#define cmsecWaitGeneric					100
#define cmsecWaitWriteLatch					10
#define cmsecWaitLogFlush				   	1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\dbapi.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============		  dbapi.h: Database API			===================

ERR ErrDBOpenDatabase( PIB *ppib, CHAR *szDatabaseName, DBID *pdbid, ULONG grbit );
ERR ErrDBCloseDatabase( PIB *ppib, DBID dbid, ULONG grbit );
ERR ErrDBOpenDatabaseByDbid( PIB *ppib, DBID dbid );
ERR ErrDBCloseDatabaseByDbid( PIB *ppib, DBID dbid );
BOOL FDatabaseInUse( DBID dbid );
ERR ErrDBCreateDatabase( PIB *ppib, CHAR *szDatabaseName, CHAR *szConnect, DBID *pdbid, ULONG grbit );

ERR ErrDABCloseAllDBs( PIB *ppib );

#define SetOpenDatabaseFlag( ppib, dbid )							\
	{													   			\
	((ppib)->rgcdbOpen[dbid]++);						   			\
	Assert( ((ppib)->rgcdbOpen[dbid] > 0 ) );						\
	}

#define ResetOpenDatabaseFlag( ppib, dbid )							\
	{																\
	Assert( ((ppib)->rgcdbOpen[dbid] > 0 ) );						\
	((ppib)->rgcdbOpen[dbid]--);									\
	}

#define FUserOpenedDatabase( ppib, dbid )							\
	((ppib)->rgcdbOpen[dbid] > 0)

#define FLastOpen( ppib, dbid )										\
	((ppib)->rgcdbOpen[dbid] == 1)

#define	FUserDbid( dbid )											\
	(dbid > dbidSystemDatabase && dbid < dbidUserMax)

#define	FSysTabDatabase( dbid ) 									\
	(dbid >= dbidSystemDatabase && dbid < dbidUserMax)

#define CheckDBID( ppib, dbid )										\
	Assert( FUserOpenedDatabase( ppib, dbid ) )

/* Database Attribute Block
/**/
typedef struct _dab
	{
	PIB			*ppib;		 		/* thread that opens this DAB */
	DAB 		*pdabNext;			/* next DAB opened by the same ppib */
	JET_GRBIT	grbit;			 	/* database open mode */
	DBID		dbid;			 	/* database id	*/
	} DAB;

#pragma pack(1)
/* database root node data -- in-disk
/**/
typedef struct _dbroot
	{
	ULONG	ulMagic;
	ULONG	ulVersion;
	ULONG	ulDBTime;
	USHORT	usFlags;
	} DBROOT;
#pragma pack()

/* Database is loggable
/**/
#define dbrootfLoggable			(1 << 0)

ERR ErrDBAccessDatabaseRoot( DBID dbid, SSIB *pssib, DBROOT **ppdbroot );
ERR ErrDBUpdateDatabaseRoot( DBID dbid);
ERR ErrDBStoreDBPath( CHAR *szDBName, CHAR **pszDBPath );

/*	bogus dbid uniqifying code
/**/
#define vdbidNil NULL
typedef DAB * VDBID;

#ifdef DISPATCHING
#define VdbidMEMAlloc() 			  			(VDBID)PbMEMAlloc(iresDAB)
#ifdef DEBUG /*  Debug check for illegal reuse of freed vdbid  */
#define ReleaseVDbid( vdbid )					{ MEMRelease( iresDAB, (BYTE *) vdbid ); vdbid = vdbidNil; }
#else
#define ReleaseVDbid( vdbid )					{ MEMRelease( iresDAB, (BYTE *) vdbid ); }
#endif
#define DbidOfVDbid( vdbid )					( ( (VDBID) vdbid )->dbid )
#define	GrbitOfVDbid( vdbid )					( ( (VDBID) vdbid )->grbit )
#define FVDbidReadOnly( vdbid )	 				( ( (VDBID) vdbid )->grbit & JET_bitDbReadOnly )
#define VDbidCheckUpdatable( vdbid ) 	\
	( FVDbidReadOnly( vdbid ) ? JET_errPermissionDenied : JET_errSuccess )																			\

#else

#define DbidOfVDbid( vdbid )				 	(vdbid)
#define VdbidMEMAlloc() 		
#define ReleaseVDbid( vdbid )			
#define	GrbitOfVDbid( vdbid )	
#define FVDbidReadOnly( vdbid )	 	
#define VDbidCheckUpdatable( vdbid ) 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\fileapi.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	  fileapi.h: File Manager API		===================

ERR VTAPI ErrIsamCreateTable(
	PIB		*ppib,
	ULONG_PTR vdbid,
	char	*szName,
	ULONG	ulPages,
	ULONG	ulDensity,
	FUCB	**ppfucb );
ERR VTAPI ErrIsamDeleteTable( PIB *ppib, ULONG_PTR vdbid, CHAR *szName );
ERR VTAPI ErrIsamRenameTable( PIB *ppib, ULONG_PTR uldbid, CHAR *szName, CHAR *szNameNew );
ERR VTAPI ErrIsamRenameColumn( PIB *ppib, FUCB *pfucb, CHAR *szName, CHAR *szNameNew );
ERR VTAPI ErrIsamRenameIndex( PIB *ppib, FUCB *pfucb, CHAR *szName, CHAR *szNameNew );
ERR VTAPI ErrIsamAddColumn(
	PIB				*ppib,
	FUCB			*pfucb,
	CHAR	  		*szName,
	JET_COLUMNDEF	*pcolumndef,
	BYTE	  		*pbDefault,
	ULONG	  		cbDefault,
	JET_COLUMNID	*pcolumnid );
ERR VTAPI ErrIsamCreateIndex(
	PIB			*ppib,
	FUCB		*pfucb,
	CHAR		*szName,
	ULONG		ulFlags,
	CHAR		*szKey,
	ULONG		cchKey,
	ULONG		ulDensity );
ERR ErrFILEBuildIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex );
ERR VTAPI ErrIsamDeleteColumn( PIB *ppib, FUCB *pfucb, CHAR *szName);
ERR VTAPI ErrIsamDeleteIndex( PIB *ppib, FUCB *pfucb, CHAR *szName );
ERR VTAPI ErrIsamGetBookmark( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cbMax, ULONG *pcbActual );

// Open/Close
ERR VTAPI ErrIsamOpenTable( PIB *ppib,
	ULONG uldbid,
	FUCB **ppfucb,
	CHAR *szPath,
	ULONG grbit );
ERR VTAPI ErrIsamCloseTable( PIB *ppib, FUCB *pfucb );

// Sessions
ERR ErrBeginSession( PIB ** );

// Miscellaneous
ERR VTAPI ErrIsamCapability(PIB*, ULONG, ULONG, ULONG, ULONG*);
ERR VTAPI ErrIsamVersion(PIB*, int*, int*, CHAR*, ULONG);

// Internal Calls for Create, Open and Close Table
ERR ErrFILECreateTable( PIB *ppib, DBID dbid, const CHAR *szName,
	ULONG ulPages, ULONG ulDensity, FUCB **ppfucb );
ERR ErrFILEOpenTable( PIB *ppib, DBID dbid,
	FUCB **ppfucb, const CHAR *szName, ULONG grbit );
ERR ErrFILECloseTable( PIB *ppib, FUCB *pfucb );

ERR ISAMAPI ErrIsamTerm( VOID );
ERR ISAMAPI ErrIsamInit( INT itib );

//	Debug
ERR	ErrFILEDumpTable( PIB *ppib, DBID dbid, CHAR *szTable );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\fileint.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	fileint.h: File Manager Internals	===================

// the pragma is bad for efficiency, but we need it here so that the
// THREEBYTES will not be aligned on 4-byte boundary
#pragma pack(1)

// Data kept at the "fields" node of a file
typedef struct
	{
	FID fidFixedLast;
	FID fidVarLast;
	FID fidTaggedLast;
	} FIELDDATA;

// Data kept at each son of "fields" (a field definition)
typedef struct
	{
	FID			fid;
	LANGID		langid;							// language of field
	WORD			wCountry;						// country of language
	USHORT		cp;								// code page of language
	BYTE			bFlags;
	BYTE			bColtyp;
	ULONG			ulLength;
	CHAR			szFieldName[JET_cbNameMost + 1];
	WORD			cbDefault;
	BYTE			rgbDefault[1];					// must be last field in structure
	} FIELDDEFDATA;

// Data kept at each son of "indexes" for a file (an index definition)
typedef struct
	{
	LANGID		langid;							// language of index
#ifdef DATABASE_FORMAT_CHANGE
#else
//	UNDONE:	index should not have country code
//	UNDONE:	index should not have cp
	WORD			wCountry;						// country of language
	USHORT		cp;								// code page of language
#endif
	BYTE 			bFlags;
	BYTE 			bDensity;
	CHAR			szIndexName[JET_cbNameMost + 1];
	BYTE			iidxsegMac;
	IDXSEG		rgidxseg[JET_ccolKeyMost];  // must be last field in structure
	} INDEXDEFDATA;

#define PbIndexName( pfucb ) ( pfucb->lineData.pb + offsetof( INDEXDEFDATA, szIndexName ) )
#define CbIndexName( pfucb ) ( strlen( PbIndexName( pfucb ) ) )
#define FIndexNameNull( pfucb ) ( CbIndexName( pfucb ) == 0 )

#pragma pack()

ERR ErrFILESeek( FUCB *pfucb, CHAR *szTable );
#define fBumpIndexCount		(1<<0)
#define fDropIndexCount		(1<<1)
#define fDDLStamp				(1<<2)
ERR ErrFILEIUpdateFDPData( FUCB *pfucb, ULONG grbit );

/*	field and index definition
/**/
ERR ErrRECNewIDB( IDB **ppidb );
ERR ErrRECAddFieldDef( FDB *pfdb, FID fid, FIELD *pfieldNew );
ERR ErrRECAddKeyDef( FDB *pfdb, IDB *pidb, BYTE iidxsegMac, IDXSEG *rgidxseg, BYTE bFlags, LANGID langid );
#define RECFreeIDB(pidb) { MEMReleasePidb(pidb); }

ERR ErrRECNewFDB( FDB **ppfdb, FID fidFixedLast, FID fidVarLast, FID fidTaggedLast );
VOID FDBSet( FCB *pfcb, FDB *pfdb );
ERR ErrFDBConstruct( FUCB *pfucb, FCB *pfcb, BOOL fBuildDefault );
VOID FDBDestruct( FDB *pfdb );

VOID FILEIDeallocateFileFCB( FCB *pfcb );
ERR ErrFILEIGenerateFCB( FUCB *pfucb, FCB **ppfcb );
ERR ErrFILEIFillInFCB( FUCB *pfucb, FCB *pfcb );
ERR ErrFILEIBuildIndexDefs( FUCB *pfucb, FCB *pfcb );
ERR ErrFILEIFillIn2ndIdxFCB( FUCB *pfucb, FDB *pfdb, FCB *pfcb );
VOID FILEIDeallocateFileFCB( FCB *pfcb );
VOID FILESetAllIndexMask( FCB *pfcbTable );
ERR ErrFILEDeleteTable( PIB *ppib, DBID dbid, CHAR *szName );

FIELD *PfieldFCBFromColumnName( FCB *pfcb, CHAR *szColumnName );
FCB *PfcbFCBFromIndexName( FCB *pfcbTable, CHAR *szName );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\dirapi.h ===
#ifndef __DIRAPI_H__
#define __DIRAPI_H__
#pragma once

/**********************************************************
/************** DIR STRUCTURES and CONSTANTS **************
/**********************************************************
/**/

#include "node.h"

/************** DIR API defines and types ******************
/***********************************************************
/**/
typedef struct {
	ULONG		ulLT;
	ULONG		ulTotal;
	} FRAC;

typedef INT POS;
#define posFirst	  			0
#define posLast					1
#define posDown					2
#define posFrac					3

#define fDIRNull	   			0
#define fDIRPurgeParent			(1<<0)
#define fDIRBackToFather		(1<<1)
#define fDIRNeighborKey			(1<<2)
#define fDIRPotentialNode 		(1<<3)
#define fDIRAllNode				(1<<4)
#define fDIRAllPage				(1<<5)
#define fDIRReplace				(1<<6)
#define fDIRReplaceDuplicate	(1<<7)
#define fDIRDuplicate 			(1<<8)
#define fDIRSpace	   			(1<<9)
#define fDIRVersion				(1<<10)
#ifdef INPAGE
#define fDIRInPage				(1<<11)
#endif
#define fDIRAppendItem			(1<<12)
#define	fDIRDeleteItem			(1<<13)
#define fDIRNoVersion			0
/*	item list nodes not versioned
/**/
#define fDIRItemList		   	fDIRAllNode

struct _dib {
	POS		pos;
	KEY		*pkey;
	INT		fFlags;
	};

#define	itagOWNEXT		1
#define	itagAVAILEXT 	2
#define	itagLONG		3
#define	itagFIELDS		9

#define PgnoFDPOfPfucb(pfucb) ((pfucb)->u.pfcb->pgnoFDP)
#define PgnoRootOfPfucb(pfucb) ((pfucb)->u.pfcb->pgnoRoot)
#define ItagRootOfPfucb(pfucb) ((pfucb)->u.pfcb->itagRoot)

#define	ErrDIRGetBookmark( pfucb, psrid )								\
	( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||			\
		PcsrCurrent( pfucb )->csrstat == csrstatDeferGotoBookmark ?	\
		( *psrid = PcsrCurrent( pfucb )->bm, JET_errSuccess ) :		\
		JET_errNoCurrentRecord )

#define	DIRGetBookmark( pfucb, psrid )									\
	( *((SRID *)psrid) = PcsrCurrent( pfucb )->bm )

#define DIRGotoBookmark	DIRDeferGotoBookmark

#define DIRDeferGotoBookmark( pfucb, bmT )								\
	{																					\
	PcsrCurrent( pfucb )->csrstat = csrstatDeferGotoBookmark;		\
	PcsrCurrent( pfucb )->bm = bmT;											\
	( pfucb )->sridFather = sridNull;							\
	DIRSetRefresh( pfucb );														\
	}																					

#define DIRGotoBookmarkItem( pfucb, bmT, itemT )  						\
	{																					\
	PcsrCurrent( pfucb )->csrstat = csrstatDeferGotoBookmark;		\
	PcsrCurrent( pfucb )->bm = bmT;											\
	PcsrCurrent( pfucb )->item = itemT;										\
	( pfucb )->sridFather = sridNull;									\
	DIRSetRefresh( pfucb );														\
	}																					

#define DIRGotoPgnoItag( pfucb, pgnoT, itagT )   						\
	{																					\
	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;					\
	PcsrCurrent( pfucb )->bm = SridOfPgnoItag( (pgnoT), (itagT) );	\
	PcsrCurrent( pfucb )->pgno = (pgnoT);	 								\
	PcsrCurrent( pfucb )->itag = (itagT);	 								\
	( pfucb )->sridFather = sridNull;									\
	DIRSetRefresh( pfucb );														\
	}

#define DIRGotoFDPRoot( pfucb )									  		\
	{															  	 	\
	PcsrCurrent( pfucb )->csrstat = csrstatOnFDPNode;					\
	PcsrCurrent( pfucb )->bm =									  		\
		SridOfPgnoItag( PgnoFDPOfPfucb( pfucb ), itagFOP );				\
	PcsrCurrent( pfucb )->pgno = PgnoFDPOfPfucb( pfucb ); 				\
	PcsrCurrent( pfucb )->itag = itagFOP;								\
	PcsrCurrent( pfucb )->itagFather = itagFOP;							\
	( pfucb )->sridFather = sridNull;						\
	if ( !FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )		\
		{															   	\
		if ( ErrSTReadAccessPage( pfucb,							   	\
			PcsrCurrent( pfucb )->pgno ) < 0 )							\
			{														   	\
			DIRSetRefresh( pfucb );									   	\
			}															\
		else														   	\
			{														   	\
			NDGet( pfucb, PcsrCurrent( pfucb )->itag );					\
			DIRSetFresh( pfucb );										\
			}															\
		}																\
	}

#define DIRGotoOWNEXT( pfucb, pgnoT )									\
	{																	\
	DIRGotoPgnoItag( pfucb, pgnoT, itagOWNEXT );  						\
	Assert( ( pfucb )->sridFather == sridNull );						\
	PcsrCurrent( pfucb )->itagFather = itagFOP;							\
	}

#define DIRGotoAVAILEXT( pfucb, pgnoT )		 							\
	{																	\
	DIRGotoPgnoItag( pfucb, pgnoT, itagAVAILEXT );  					\
	PcsrCurrent( pfucb )->itagFather = itagFOP;							\
	}

#define DIRGotoLongRoot( pfucb )										\
	{																	\
	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;					\
	PcsrCurrent( pfucb )->bm =											\
		SridOfPgnoItag( PgnoFDPOfPfucb( pfucb ), itagLONG );			\
	PcsrCurrent( pfucb )->pgno = PgnoFDPOfPfucb( pfucb ); 				\
	PcsrCurrent( pfucb )->itag = itagLONG;								\
	PcsrCurrent( pfucb )->itagFather = itagNull;						\
	( pfucb )->sridFather = sridNull;									\
	if ( !FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )		\
		{																\
		if ( ErrSTReadAccessPage( pfucb,								\
			PcsrCurrent( pfucb )->pgno ) < 0 )							\
			{															\
			DIRSetRefresh( pfucb );										\
			}															\
		else															\
			{															\
			NDGet( pfucb, PcsrCurrent( pfucb )->itag );					\
			DIRSetFresh( pfucb );										\
			}															\
		}																\
	}

#define DIRGotoDataRoot( pfucbX )	  							\
	{															\
	PcsrCurrent( pfucbX )->csrstat = csrstatOnDataRoot;			\
	PcsrCurrent( pfucbX )->bm = ( pfucbX )->u.pfcb->bmRoot;		\
	PcsrCurrent( pfucbX )->pgno = PgnoRootOfPfucb( pfucbX );	\
	PcsrCurrent( pfucbX )->itagFather = itagNull;				\
	( pfucbX )->sridFather = sridNull;				\
	DIRSetRefresh( pfucbX );									\
	}

#define FDIRDataRootRoot( pfucb, pcsr )							\
	(	(pcsr)->pgno == PgnoRootOfPfucb( pfucb ) &&				\
		(pcsr)->itag == ItagRootOfPfucb( pfucb ) )

#define DIRDeferMoveFirst( pfucb )								\
	{															\
	PcsrCurrent( pfucb )->csrstat = csrstatDeferMoveFirst;		\
	DIRSetRefresh( pfucb );										\
	}

#define DIRSetIndexRange		FUCBSetIndexRange
#define DIRResetIndexRange		FUCBResetIndexRange

ERR ErrDIROpen( PIB *ppib, FCB *pfcb, DBID dbid, FUCB **ppfucb );
VOID DIRClose( FUCB *pfucb );
ERR ErrDIRSeekPath( FUCB *pfucb, INT ckeyPath, KEY *rgkeyPath, INT fFlags );
ERR ErrDIRDown( FUCB *pfucb, DIB *pdib );
ERR ErrDIRDownFromDATA( FUCB *pfucb, KEY *pkey );
VOID DIRUp( FUCB *pfucb, INT ccsr );
ERR ErrDIRNext( FUCB *pfucb, DIB *pdib );
ERR ErrDIRPrev( FUCB *pfucb, DIB *pdib );
ERR ErrDIRGet( FUCB *pfucb );
ERR ErrDIRCheckIndexRange( FUCB *pfucb );

ERR ErrDIRGetWriteLock( FUCB *pfucb );

ERR ErrDIRInsert( FUCB *pfucb, LINE *pline, KEY *pkey, INT fFlags );
ERR ErrDIRInitAppendItem( FUCB *pfucb );
ERR ErrDIRAppendItem( FUCB *pfucb, LINE *pline, KEY *pkey );
ERR ErrDIRTermAppendItem( FUCB *pfucb );
ERR ErrDIRInsertFDP( FUCB *pfucb, LINE *pline, KEY *pkey, INT fFlags, CPG cpg );
ERR ErrDIRDelete( FUCB *pfucb, INT fFlags );
ERR ErrDIRReplace( FUCB *pfucb, LINE *pline, INT fFlags );
ERR ErrDIRReplaceKey( FUCB *pfucb, KEY *pkeyTo, INT fFlags );

ERR ErrDIRDownKeyBookmark( FUCB *pfucb, KEY *pkey, SRID srid );
ERR ErrDIRGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal );
ERR ErrDIRGotoPosition( FUCB *pfucb, ULONG ulLT, ULONG ulTotal );
ERR ErrDIRIndexRecordCount( FUCB *pfucb, ULONG *pulCount, ULONG ulCountMost, BOOL fNext );
ERR ErrDIRComputeStats( FUCB *pfucb, INT *pcitem, INT *pckey, INT *pcpage );

ERR ErrDIRDelta( FUCB *pfucb, INT iDelta, INT fFlags );

ERR ErrDIRBeginTransaction( PIB *ppib );
ERR ErrDIRCommitTransaction( PIB *ppib );
VOID DIRPurge( PIB *ppib );
ERR ErrDIRRollback( PIB *ppib );

#define DIRBeforeFirst( pfucb )		( PcsrCurrent(pfucb)->csrstat = csrstatBeforeFirst )
#define DIRAfterLast( pfucb )		( PcsrCurrent(pfucb)->csrstat = csrstatAfterLast )
#define FDIRMostRecent				FBTMostRecent
#define FDIRDelta					FVERDelta

ERR ErrDIRDump( FUCB *pfucb, INT cchIndent );

/**********************************************************
/******************* DIR Internal *************************
/**********************************************************
/**/
#define	itagFOP				0
#define	cbSonMax				256
#define	ulDBTimeNull		0xffffffff
#define itagDIRDVSplitL		1
#define itagDIRDVSplitR		2

/*	maximum node data size for nodes which ErrNDDelta can be used on.
/*	Specifically this minimally supports long value root nodes.
/**/
#define	cbMaxCounterNode	8

/*  Offset of data field to counter. for long field reference counter.
 **/
#define ibCounter			0

/*	non-clustered index cursors already have item stored.
/**/
#ifdef DEBUG

#define CheckCSR( pfucb )       Assert( fRecovering ||					\
	(PcsrCurrent(pfucb) == pcsrNil ||											\
	PcsrCurrent(pfucb)->pcsrPath == pcsrNil ||								\
	PcsrCurrent(pfucb)->pgno != PcsrCurrent(pfucb)->pcsrPath->pgno ||	\
	PcsrCurrent(pfucb)->itag != PcsrCurrent(pfucb)->pcsrPath->itag ) );

#define DIRSetFresh( pfucb )											   	\
	{																	   	\
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||			\
		PcsrCurrent( pfucb )->csrstat == csrstatBeforeCurNode ||		   	\
		PcsrCurrent( pfucb )->csrstat == csrstatAfterCurNode || 		   	\
		PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode );			   	\
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 					   	\
	PcsrCurrent( pfucb )->ulDBTime = UlSTDBTimePssib( &(pfucb)->ssib ); 	\
	}

#define DIRSetRefresh( pfucb )											   	\
	{																	   	\
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||			\
		PcsrCurrent( pfucb )->csrstat == csrstatBeforeCurNode ||		   	\
		PcsrCurrent( pfucb )->csrstat == csrstatAfterCurNode || 		   	\
		PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode ||			   	\
		PcsrCurrent( pfucb )->csrstat == csrstatDeferGotoBookmark ||		\
		PcsrCurrent( pfucb )->csrstat == csrstatDeferMoveFirst ||			\
		PcsrCurrent( pfucb )->csrstat == csrstatOnDataRoot );			   	\
	PcsrCurrent( pfucb )->ulDBTime = ulDBTimeNull;						   	\
	}

#else

#define CheckCSR( pfucb )

#define DIRSetFresh( pfucb )		 									   	\
	{																	   	\
	PcsrCurrent( pfucb )->ulDBTime = UlSTDBTimePssib( &(pfucb)->ssib ); 	\
	}

#define DIRSetRefresh( pfucb )  										   	\
	{																	   	\
	PcsrCurrent( pfucb )->ulDBTime = ulDBTimeNull; 						   	\
	}

#endif


/**********************************************************
/********************* BTREE API **************************
/**********************************************************
/**/
#define sridMin         0
#define sridMax         0xffffffff

/*	must be on node, i.e. on current node, before node or after node.
/*	Node must be in line cache.
/**/

#define DIRISetBookmark( pfucb, pcsr )									   	\
	{																	   	\
	Assert( FReadAccessPage( (pfucb), (pcsr)->pgno ) );						\
																			\
	if ( FNDBackLink( *( (pfucb)->ssib.line.pb ) ) )						\
		(pcsr)->bm = *(SRID UNALIGNED *)PbNDBackLink( (pfucb)->ssib.line.pb );		\
	else																	\
		(pcsr)->bm = SridOfPgnoItag( (pcsr)->pgno, (pcsr)->itag );			\
	}

BOOL FBTMostRecent( FUCB *pfucb );

#define ErrBTNext( pfucb, pdib ) \
	( ErrBTNextPrev( pfucb, PcsrCurrent(pfucb), fTrue, pdib ) )
#define ErrBTPrev( pfucb, pdib ) \
	( ErrBTNextPrev( pfucb, PcsrCurrent(pfucb), fFalse, pdib ) )
#define	BTUp( pfucb )	FUCBFreeCSR( pfucb )

ERR ErrBTGet( FUCB *pfucb, CSR *pcsr );
ERR ErrBTGetNode( FUCB *pfucb, CSR *pcsr );
#ifdef DEBUG
VOID AssertBTGetNode( FUCB *pfucb, CSR *pcsr );
#else
#define	AssertBTGetNode
#endif
ERR ErrBTSetNodeHeader( FUCB *pfucb, BYTE bHeader );
ERR ErrBTReplaceKey( FUCB *pfucb, KEY *pkey, INT fFlags );
ERR ErrBTDown( FUCB *pfucb, DIB *pdib );
ERR ErrBTDownFromDATA( FUCB *pfucb, KEY *pkey );
ERR ErrBTNextPrev( FUCB *pfucb, CSR *pcsr, INT fNext, DIB *pdib );
ERR ErrBTSeekForUpdate( FUCB *pfucb, KEY *pkey, PGNO pgno, INT itag, INT fDIRFlags );
ERR ErrBTInsert( FUCB *pfucb, INT fHeader, KEY *pkey, LINE *pline, INT fDIRFlags );
ERR ErrBTReplace( FUCB *pfucb, LINE *pline, INT fFlags );
ERR ErrBTDelete( FUCB *pfucb, INT fFlags );
ERR ErrBTMakeRoom( FUCB *pfucb, CSR *pcsrRoot, INT cbReq );
ERR ErrBTGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal );
ERR ErrBTGotoBookmark( FUCB *pfucb, SRID srid );
ERR ErrBTGetInvisiblePagePtr( FUCB *pfucb, SRID sridFather );
#ifdef DEBUG
ERR ErrBTCheckInvisiblePagePtr( FUCB *pfucb, SRID sridFather );
#endif


/**********************************************************
/*********************** BT Split *************************
/**********************************************************
/**/
typedef enum {
	splittNull,
	splittVertical,
	splittDoubleVertical,
	splittLeft,
	splittRight,
	splittAppend
	} SPLITT;
	
typedef enum {
	opReplace,
	opInsert
	} OPERATION;

typedef struct {
	PN		pn;
	ULONG	ulDBTime;
} LFINFO;						/* leaf split info */

#define BTIInitLeafSplitKey(plfinfo) memset((plfinfo), 0, sizeof(LFINFO));


typedef struct
	{
	SRID	sridNew;
	SRID	sridBackLink;
	} BKLNK;


typedef struct _split {
	PIB			*ppib;
	PGNO		pgnoSplit;
	PGNO		pgnoNew;
	PGNO		pgnoNew2;
	PGNO		pgnoNew3;
	PGNO		pgnoSibling;
	
	BF			*pbfSplit;			/* BF of page being split */
	BF			*pbfNew;			/* BF of new page of this split */
	BF			*pbfNew2;			/* BF of new page of this split */
	BF			*pbfNew3;			/* BF of new page of this split */
	BF			*pbfSibling;		/* BF of sibling page of this H split */
	BF			*pbfPagePtr;

	BOOL		fNoRedoNew;			/* no need to redo new page */
	BOOL		fNoRedoNew2;		/* no need to redo new page 2 */
	BOOL		fNoRedoNew3;		/* no need to redo new page 3 */
	
	BF			**rgpbf;			/* BF of backlink page. */
	INT	  		cpbf;
	INT	  		cpbfMax;

	BKLNK		*rgbklnk;			/* SRID of backlinks. */
	INT	  		cbklnk;
	INT	  		cbklnkMax;
	
	ULONG		ulDBTimeRedo;		/* redo timestamp */
	
	INT			itagSplit;
	INT			ibSon;
	KEY	  		key;
	KEY	  		keyMac;
	
	SPLITT  	splitt;
	BOOL		fLeaf;
	OPERATION	op;
	BOOL		fFDP;
	DBID		dbid;
	INT			itagNew;
	INT			itagPagePointer;
	
	BYTE		rgbSonSplit[cbSonMax];
	BYTE		rgbSonNew[cbSonMax];

	BYTE		rgbkeyMac[JET_cbKeyMost];
	BYTE		rgbKey[JET_cbKeyMost];
	LFINFO		lfinfo;			/* leaf split key. HSplit only */

	/*	mapping from old to new tags for use in MCM
	/**/
	BYTE		mpitag[ctagMax];
	INT			ipcsrMac;				/* preallocated resource for csr */
#define ipcsrSplitMax 4
	CSR			*rgpcsr[ipcsrSplitMax];
} SPLIT;


typedef struct _rmpage {
	PIB			*ppib;
	
	ULONG		ulDBTimeRedo;			/* redo timestamp */
	
	BF			*pbfLeft;
	BF			*pbfRight;
	BF			*pbfFather;

	BKLNK		**rgbklnk;				/* latched buffers required for rmpage */
	INT			cbklnk;
	INT	  		cbklnkMax;

	BF			**rgpbf;				/* latched buffers required for rmpage */
	INT			cpbf;
	INT	  		cpbfMax;

	PGNO		pgnoRemoved;
	PGNO		pgnoLeft;
	PGNO		pgnoRight;
	PGNO		pgnoFather;
	INT			itagPgptr;
	INT			itagFather;
	INT			ibSon;
	DBID		dbid;
	} RMPAGE;
	
#define CbFreeDensity(pfucb) \
	( (pfucb)->u.pfcb != pfcbNil ? (pfucb)->u.pfcb->cbDensityFree : 0 )

/*	protypes for split used by recovery of split operations.
/**/
ERR ErrBTStoreBackLinkBuffer( SPLIT *psplit, BF *pbf, BOOL *pfAlreadyLatched );
ERR ErrBTSplit( FUCB *pfucb, INT cbNode, INT cbReq, KEY *pkey, INT fFlags );
ERR ErrBTSplitPage( FUCB *pfucb, CSR *pcsr,	CSR *pcsrRoot,
	KEY keySplit, INT cbNode, INT cbReq, BOOL fReplace, BOOL fAppendPage, LFINFO *plfinfo );
BOOL FBTSplit( SSIB *pssib, INT cbReq, INT citagReq );
BOOL FBTAppendPage( FUCB *pfucb, CSR *pcsr, INT cbReq, INT cbPageAdjust, INT cbFreeDensity );
INT CbBTFree( FUCB *pfucb, INT cbFreeDensity );

#define fAllocBufOnly		fTrue
#define fDoMove				fFalse

ERR ErrBTSplitVMoveNodes(
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	SPLIT	*psplit,
	CSR 	*pcsr,
	BYTE	*rgb,
	BOOL	fNoMove);
ERR ErrBTSplitDoubleVMoveNodes(
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	FUCB	*pfucbNew2,
	FUCB	*pfucbNew3,
	SPLIT	*psplit,
	CSR		*pcsr,
	BYTE	*rgb,
	BOOL	fNoMove);
ERR ErrBTSplitHMoveNodes(
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	SPLIT	*psplit,
	BYTE	*rgb,
	BOOL	fNoMove);
ERR ErrBTInsertPagePointer( FUCB *pfucb, CSR *pcsrPagePointer, SPLIT *psplit, BYTE *rgb );
ERR ErrBTCorrectLinks(
	SPLIT *psplit,
	FUCB *pfucb,
	SSIB *pssib,
	SSIB *pssibNew);
VOID BTReleaseSplitBfs ( BOOL fRedo, SPLIT *psplit, ERR err );
VOID BTReleaseRmpageBfs( BOOL fRedo, RMPAGE *prmpage );

ERR ErrBTMoveSons( SPLIT *psplit,
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	INT	itagSonTable,
	BYTE	*rgbSon,
	BOOL	fVisibleSons,
	BOOL	fNoMove );
	
ERR ErrBTSetUpSplitPages( FUCB *pfucb, FUCB *pfucbNew,
	FUCB *pfucbNew2, FUCB *pfucbNew3, SPLIT *psplit,
	PGTYP pgtyp, BOOL fAppend, BOOL fSkipMoves );

/**********************************************************
/********** MCM STRUCTURES, CONSTANTS and API *************
/**********************************************************
/**/
#define	opInsertItem						0
#define	opDeleteItem						1
#define	opSplitItemList					2

#define	opInsertSon							0
#define	opReplaceSon		 				1
#define	opDeleteSon							2

#define	opHorizontalRightSplitPage		0
#define	opHorizontalLeftSplitPage		1

#define opVerticalSplitPage				0

VOID MCMRightHorizontalPageSplit( FUCB *pfucb,
	PGNO pgnoSplit, PGNO pgnoRight, INT ibSonSplit, BYTE *mpitag );
VOID MCMLeftHorizontalPageSplit( FUCB *pfucb,
	PGNO pgnoSplit, PGNO pgnoNew, INT ibSonSplit, BYTE *mpitag );
VOID MCMVerticalPageSplit(
	FUCB *pfucb,
	BYTE *mpitag,
	PGNO pgnoSplit,
	INT itagSplit,
	PGNO pgnoNew,
	SPLIT *psplit );
VOID MCMDoubleVerticalPageSplit(
	FUCB	*pfucb,
	BYTE	*mpitag,
	PGNO	pgnoSplit,
	INT	itagSplit,
	INT	ibSonDivision,
	PGNO	pgnoNew,
	PGNO	pgnoNew2,
	PGNO	pgnoNew3,
	SPLIT	*psplit );
VOID MCMInsertPagePointer( FUCB *pfucb, PGNO pgnoFather, INT itagFather );
VOID MCMBurstIntrinsic( FUCB *pfucb, PGNO pgnoFather, INT itagFather, PGNO pgnoNew, INT itagNew );

#define FFUCBRecordCursor( pfucb ) (						\
		( pfucb )->u.pfcb != pfcbNil ?						\
		( pfucb )->u.pfcb->wFlags & fFCBClusteredIndex : fFalse )

#ifdef		NOLOG		/* logging disabled	*/

#define ErrLGSplitL( ppib, pcsrPagePointer, psplit, pgtyp )	0
#define ErrLGSplitR( ppib, pcsrPagePointer, psplit, pgtyp )	0
#define ErrLGSplitV( ppib, psplit, pgtyp )	0
#define ErrLGAddendR( pfucb, pcsrPagePointer, psplit, newpagetype ) 0

#else

ERR ErrLGSplitL(
	FUCB *pfucb,
	CSR *pcsrPagePointer,
	SPLIT *psplit,
	PGTYP newpagetype );

ERR ErrLGSplitR(
	FUCB *pfucb,
	CSR *pcsrPagePointer,
	SPLIT *psplit,
	PGTYP newpagetype );

ERR ErrLGSplitV(
	FUCB *pfucb,
	SPLIT *psplit,
	PGTYP newpagetype );

ERR ErrLGAddendR(
	FUCB *pfucb,
	CSR *pcsrPagePointer,
	SPLIT *psplit,
	PGTYP newpagetype );

#endif

#endif  // __DIRAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\fcb.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	   fcb.h: File Control Block		===================

#ifdef	FCB_INCLUDED
#error fcb.h already included
#endif	/* FCB_INCLUDED */
#define FCB_INCLUDED

// Database Key
typedef ULONG DBK;

// Flags for FCB
#define fFCBTemporaryTable		(1<<0)  	// This is a temporary file
#define fFCBClusteredIndex		(1<<1)  	// This FCB is for data records.
#define fFCBDenyRead			(1<<2)  	// no other session can read domain
// #define fFCBDenyWrite  		(1<<3)  	// no other session can write domain
#define fFCBSentinel			(1<<4)  	// FCB is only flag holder
// #define fFCBDenyDDL	  		(1<<5)		// no other transaction can update/delete/replace domain
#define fFCBWait				(1<<6)		// wait flag
#define fFCBOLCStatsAvail		(1<<7)		// are OLC Stats available?
#define fFCBOLCStatsChange		(1<<8)		// have OLC Stats changed since last open?
#define fFCBDeletePending		(1<<9)		// is a delete pending on this table/index?
#define fFCBDomainOperation		(1<<10)		// is used to synchronize bm cleanup
											// index creation, index deletion and table deletion

#define FFCBDomainOperation( pfcb )			( (pfcb)->wFlags & fFCBDomainOperation )
#define FCBSetDomainOperation( pfcb )	   	( (pfcb)->wFlags |= fFCBDomainOperation )
#define FCBResetDomainOperation( pfcb )		( (pfcb)->wFlags &= ~(fFCBDomainOperation) )

#define FFCBDeletePending( pfcb )		  	( (pfcb)->wFlags & fFCBDeletePending )
#define FCBSetDeletePending( pfcb )	 	  	( (pfcb)->wFlags |= fFCBDeletePending )
#define FCBResetDeletePending( pfcb )	  	( (pfcb)->wFlags &= ~(fFCBDeletePending) )

#define FFCBOLCStatsAvail( pfcb )		  	( (pfcb)->wFlags & fFCBOLCStatsAvail )
#define FCBSetOLCStatsAvail( pfcb )	 	  	( (pfcb)->wFlags |= fFCBOLCStatsAvail )
#define FCBResetOLCStatsAvail( pfcb )	  	( (pfcb)->wFlags &= ~(fFCBOLCStatsAvail) )

#define FFCBOLCStatsChange( pfcb )		  	( (pfcb)->wFlags & fFCBOLCStatsChange )
#define FCBSetOLCStatsChange( pfcb )	  	( (pfcb)->wFlags |= fFCBOLCStatsChange )
#define FCBResetOLCStatsChange( pfcb )	  	( (pfcb)->wFlags &= ~(fFCBOLCStatsChange) )

#define FFCBTemporaryTable( pfcb )		  	( (pfcb)->wFlags & fFCBTemporaryTable )
#define FCBSetTemporaryTable( pfcb )	  	( (pfcb)->wFlags |= fFCBTemporaryTable )
#define FCBResetTemporaryTable( pfcb )	  	( (pfcb)->wFlags &= ~(fFCBTemporaryTable) )

#define FFCBClusteredIndex( pfcb )		  	( (pfcb)->wFlags & fFCBClusteredIndex )
#define FCBSetClusteredIndex( pfcb )	  	( (pfcb)->wFlags |= fFCBClusteredIndex )
#define FCBResetClusteredIndex( pfcb )	  	( (pfcb)->wFlags &= ~(fFCBClusteredIndex) )

#define FFCBDenyWrite( pfcb )			  	( (pfcb)->crefDenyWrite > 0 )
#define FCBSetDenyWrite( pfcb )			  	( (pfcb)->crefDenyWrite++ )

#define FCBResetDenyWrite( pfcb )		  	\
	{									  	\
	Assert( (pfcb)->crefDenyWrite > 0 );  	\
	--(pfcb)->crefDenyWrite;			  	\
	}

#define FFCBDenyRead( pfcb, ppib )			( (pfcb)->wFlags & fFCBDenyRead && (ppib) != (pfcb)->ppibDenyRead )

#define FCBSetDenyRead( pfcb, ppib )		 		\
	{										 		\
	if ( (pfcb)->crefDenyRead++ == 0 )		 		\
		{									 		\
		Assert( (pfcb)->ppibDenyRead == ppibNil );	\
		(pfcb)->ppibDenyRead = (ppib);		 		\
		(pfcb)->wFlags |= fFCBDenyRead;		 		\
		}									 		\
	}

#define FCBResetDenyRead( pfcb )			 		\
	{										 		\
	Assert( (pfcb)->crefDenyRead > 0 );		 		\
	Assert( (pfcb)->ppibDenyRead != ppibNil );		\
	if ( --(pfcb)->crefDenyRead == 0 )		 		\
		{									 		\
		(pfcb)->wFlags &= ~(fFCBDenyRead);	 		\
		(pfcb)->ppibDenyRead = ppibNil;	   			\
		}								   			\
	}

#define FFCBDenyReadByUs( pfcb, ppib )	 	( (pfcb)->wFlags & fFCBDenyRead && (ppib) == (pfcb)->ppibDenyRead )

#define FFCBSentinel( pfcb )			   	( (pfcb)->wFlags & fFCBSentinel )
#define FCBSetSentinel( pfcb )				( (pfcb)->wFlags |= fFCBSentinel )
#define FCBResetSentinel( pfcb )		   	( (pfcb)->wFlags &= ~(fFCBSentinel) )

#define FFCBDenyDDL( pfcb, ppib )			( (pfcb)->crefDenyDDL > 0 && (ppib) != (pfcb)->ppibDDL )
#define FFCBDenyDDLByUs( pfcb, ppib )		( (pfcb)->crefDenyDDL > 0 && (ppib) == (pfcb)->ppibDDL )

#define FCBSetDenyDDL( pfcb, ppib )					\
	{												\
	if ( (pfcb)->crefDenyDDL++ == 0 )				\
		{											\
		Assert( (pfcb)->ppibDDL == ppibNil );		\
		(pfcb)->ppibDDL = (ppib);					\
		}											\
	}

#define FCBResetDenyDDL( pfcb )		  				\
	{												\
	Assert( (pfcb)->crefDenyDDL > 0 );	 			\
	Assert( (pfcb)->ppibDDL != ppibNil ); 			\
	if ( --(pfcb)->crefDenyDDL == 0 )	  			\
		{											\
		(pfcb)->ppibDDL = ppibNil;			  		\
		}											\
	}

#define FFCBWait( pfcb )							( (pfcb)->wFlags & fFCBWait )

#define FCBSetWait( pfcb )							\
	{												\
	Assert( !FFCBWait( pfcb ) );					\
	(pfcb)->wFlags |= fFCBWait;						\
	}

#define FCBResetWait( pfcb )						\
	{										   		\
	Assert( FFCBWait( pfcb ) );						\
	(pfcb)->wFlags &= ~(fFCBWait);					\
	}

#define FCBVersionIncrement( pfcb )			(pfcb)->cVersion++;
#define FCBVersionDecrement( pfcb )					\
	{												\
	Assert( (pfcb)->cVersion > 0 );					\
	(pfcb)->cVersion--;								\
	}
#define CVersionFCB( pfcb )					(pfcb)->cVersion

/* hash table for FCB's -- only FCB's for tables and db's are hashed
/**/
#define	cFCBBuckets	256
FCB*	pfcbHash[cFCBBuckets];

#define FCBHashInit()  								\
	{ 												\
	Assert( pfcbNil == (FCB *) 0 ); 				\
	memset( pfcbHash, '\0', sizeof( pfcbHash ) );	\
	}


#define	FFCBAvail( pfcb, ppib )							\
	(	pfcb->wRefCnt == 0 && 							\
		pfcb->pgnoFDP != 1 &&							\
		!FFCBSentinel( pfcb ) &&						\
		!FFCBDenyRead( pfcb, ppib ) &&					\
		!FFCBWait( pfcb ) &&							\
		( pfcb->dbid == dbidTemp || FFCBINoVersion( pfcb ) ) )


// File Control Block
//
struct _fcb
	{
	//--------------------USED BY DATA & INDEX FCB---------------------
	struct _fcb 	*pfcbNextIndex;  	// chain of indexes for this file
	struct _fcb		*pfcbNextInHashBucket;
	struct _fdb 	volatile *pfdb; 	// field descriptors
	struct _idb 	*pidb;			  	// index info (NULL if "seq." file)
	FUCB			*pfucb;				// chain of FUCBs open on this file
	PIB  			*ppibDDL;			// ppib of process updating index/adding column
	PIB  			*ppibDenyRead;		// ppib of process holding exclusive lock
	CRIT			critSplit;			//	per domain split MUTEX
	PGNO			pgnoFDP;			// FDP of this file/index
	PGNO			pgnoRoot;			// pgno of the root of the domain
	SRID			bmRoot;				// bm of root of the domain
										// -- useful if Root is movable, e.g, DATA
	
	DBID			dbid;				// which database
	INT				itagRoot;			// itag of the root of the domain
	INT				cbDensityFree;		// loading density parameter:
										// # of bytes free w/o using new page
	INT				wFlags;			 	// flags for this FCB
	INT				wRefCnt;			// # of FUCBs for this file/index
	INT				volatile cVersion;	// # of RCEs for this file/index
	INT				crefDenyRead;	 	// # of FUCBs with deny read flag
	INT				crefDenyWrite;	 	// # of FUCBs with deny write flag
	INT				crefDenyDDL;	 	// # of FUCBs with deny DDL flag

	ULONG		   	cpgCompactFreed;
	PERS_OLCSTAT	olcStat;
		
	//--------------------USED ONLY BY FCB OF DATA---------------------
	CHAR		   	*szFileName;			// name of file (for GetTableInfo)
	struct _fcb		*pfcbNext;		 		// Next data FCB in global list
	DBK	  			dbkMost;				// Greatest DBK in use
											// (if "sequential" file)
	ULONG		   	ulLongIdMax;			// max long field id
	BYTE		   	rgbitAllIndex[32];		//	used for clustered index FCB only
	BOOL		   	fAllIndexTagged;		//	used for clustered index FCB only
	};

#define FCBInit( pfcb )							\
	{											\
	memset( pfcb, '\0', sizeof( FCB ) );		\
	}

#define PfcbMEMAlloc()			(FCB*)PbMEMAlloc(iresFCB)

#ifdef DEBUG /*  Debug check for illegal use of freed fcb  */ 
#define MEMReleasePfcb(pfcb)										\
	{																\
	Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) != pfcb );		\
	MEMRelease( iresFCB, (BYTE*)(pfcb) );							\
	pfcb = pfcbNil;													\
	}
#else
#define MEMReleasePfcb(pfcb)										\
	{																\
	Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) != pfcb );		\
	MEMRelease( iresFCB, (BYTE*)(pfcb) );							\
	}
#endif

/*	if opening domain for read, write or read write, and not with
/*	deny read or deny write, and domain does not have deny read or
/*	deny write set, then return JET_errSuccess, else call
/*	ErrFCBISetMode to determine if lock is by other session or to
/*	put lock on domain.			 
/**/
#define	ErrFCBSetMode( ppib, pfcb, grbit )													\
( ( ( ( grbit & ( JET_bitTableDenyRead | JET_bitTableDenyWrite ) ) == 0 ) &&		\
	( ( FFCBDenyDDL( pfcb, ppib ) || FFCBDenyRead( pfcb, ppib ) || FFCBDenyWrite( pfcb ) ) == fFalse ) ) ?				\
	JET_errSuccess : ErrFCBISetMode( ppib, pfcb, grbit ) )

/*	reset DDL is same as reset Delete.  Both use deny read flags
/*	or sentinel.
/**/
#define	FCBResetRenameTable	FCBResetDeleteTable

extern BYTE * __near rgfcb;
extern FCB * __near pfcbGlobalList;
extern SEM __near semGlobalFCBList;
extern SEM __near semLinkUnlink;

VOID FCBLink( FUCB *pfucb, FCB *pfcb );
VOID FCBRegister( FCB *pfcb );
VOID FCBDiscard( FCB *pfcb );
VOID FCBUnlink( FUCB *pfucb );
FCB *PfcbFCBGet( DBID dbid, PGNO pgnoFDP );
ERR ErrFCBAlloc( PIB *ppib, FCB **ppfcb );
VOID FCBPurgeDatabase( DBID dbid );
VOID FCBPurgeTable( DBID dbid, PGNO pgnoFDP );
ERR ErrFCBNew( PIB *ppib, DBID dbid, PGNO pgno, FCB **ppfcb );
ERR ErrFCBISetMode( PIB *ppib, FCB *pfcb, JET_GRBIT grbit );
VOID FCBResetMode( PIB *ppib, FCB *pfcb, JET_GRBIT grbit );
ERR ErrFCBSetDeleteTable( PIB *ppib, DBID dbid, PGNO pgnoFDP );
VOID FCBResetDeleteTable( DBID dbid, PGNO pgnoFDP );
ERR ErrFCBSetRenameTable( PIB *ppib, DBID dbid, PGNO pgno );
FCB *FCBResetAfterRedo( void );
BOOL FFCBTableOpen ( DBID dbid, PGNO pgno );

VOID FCBLinkIndex( FCB *pfcbTable, FCB *pfcbIndex );
VOID FCBUnlinkIndex( FCB *pfcbTable, FCB *pfcbIndex );
BOOL FFCBUnlinkIndexIfFound( FCB *pfcbTable, FCB *pfcbIndex );
FCB *PfcbFCBUnlinkIndexByName( FCB *pfcb, CHAR *szIndex );
ERR ErrFCBSetDeleteIndex( PIB *ppib, FCB *pfcbTable, CHAR *szIndex );
VOID FCBResetDeleteIndex( FCB *pfcbIndex );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\fdb.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	 fdb.h: Field Descriptor Block		===================

// Flags for field descriptor
#define ffieldNotNull		(1<<0)		// NULL values not allowed
#define ffieldDeleted		(1<<1)		// Fixed field has been deleted
#define ffieldVersion		(1<<2)		// Version field
#define ffieldAutoInc		(1<<3)		// Auto increment field
#define ffieldMultivalue	(1<<4)		// Multi-valued column

#ifdef ANGEL
#pragma pack(4)
#endif

// Entry in field descriptor tables found in an FDB.
typedef struct _field
	{
	JET_COLTYP 	coltyp;							// column data type
	LANGID		langid;							// language of field
	WORD			wCountry;						// country of language
	USHORT		cp;								// code page of language
	ULONG			cbMaxLen;						// maximum length
	BYTE			ffield;							// various flags
	CHAR			szFieldName[JET_cbNameMost + 1];	// name of field
	} FIELD;

// Field Descriptor Block: information about all fields of a file.
struct _fdb
	{
	FID		fidVersion;					// fid of version field
	FID		fidAutoInc;					// fid of auto increment field
	FID		fidFixedLast;				// Highest fixed field id in use
	FID		fidVarLast;					// Highest variable field id in use
	FID		fidTaggedLast;				// Highest tagged field id in use
	LINE		lineDefaultRecord;		// default record
	struct	_field *pfieldFixed;		// if FCB of data: pointers to
	struct	_field *pfieldVar;		// beginnings fixed, variable, and
	struct	_field *pfieldTagged;	// tagged field tables
	WORD		*pibFixedOffsets;			// pointer to beginning of table
												// of fixed field offsets
	struct	_field rgfield[];			// FIELD structures hang off the end
//	WORD		rgibFixedOffsets[]; 		// followed by the offset table
	};

#ifdef ANGEL
#pragma pack()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\fucb.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	 fucb.h: File Use Control Block		===================


/*	describes exact placement of CSR and meaning of CSR's pgno:itag
/**/
typedef INT CSRSTAT;
#define csrstatOnCurNode				0		// pgno:itag == node CSR is ON
#define csrstatBeforeCurNode			1		// pgno:itag == node CSR is BEFORE
#define csrstatAfterCurNode				2		// pgno:itag == node CSR is AFTER,
#define csrstatDeferGotoBookmark		3		// valid bm
#define csrstatAfterLast				4		// no pgno:itag
#define csrstatBeforeFirst				5		// no pgno:itag
#define csrstatOnFDPNode				6		// pgno:itag == FDP root
#define csrstatDeferMoveFirst			7		// on first node
#define csrstatOnDataRoot				8		// on FCB data root node

/*	Currency Stack Register
/**/
struct _csr
	{
	ULONG  		ulDBTime;	 	// page time stamp
	struct _csr	*pcsrPath;		// parent currency
	PGNO   		pgno;	   		// pgno of node page
	SRID   		bm;				// bookmark of node
	SRID   		item;	   		// item, set to sridInvisibleCSR if invisible CSR
	CSRSTAT		csrstat;   		// status of csr relative to node
	INT			itag;	   		// node itag
	INT			isrid;		  	// index of item in item list
	INT			itagFather;	  	// itag of father
	INT			ibSon;		  	// index of son in father son table
	};

/*	allow invisible CSRs to be identified
/**/
#define	sridInvisibleCSR				((SRID)(-1))
#define	CSRSetInvisible( pcsr )			( (pcsr)->item = sridInvisibleCSR )
#define	CSRResetInvisible( pcsr )		( (pcsr)->item = sridNull )
#define	FCSRInvisible( pcsr )			( (pcsr)->item == sridInvisibleCSR )

#define	PcsrMEMAlloc()			(CSR*)PbMEMAlloc(iresCSR)

#ifdef DEBUG /*  Debug check for illegal use of freed csr  */
#define	MEMReleasePcsr(pcsr)	{ MEMRelease(iresCSR, (BYTE*)(pcsr)); pcsr = pcsrNil; }
#else
#define	MEMReleasePcsr(pcsr)	{ MEMRelease(iresCSR, (BYTE*)(pcsr)); }
#endif

/*	CSR constants
/**/
#define itagNull					(-1)
#define isridNull					(-1)
#define ibSonNull					(-1)

/*	flags for FUCB
/*
/*	fFUCBTaggedSet is set by column set, and reset by prepare replace
/*	and prepare insert.
/*
/*	fFUCBDeferClose is set by cursor DIRClose and reset by ErrDIROpen.
/*
/*	fFUCBDeferGotoBookmark is set by non-clustered index navigation and
/*	reset by record status, ErrIsamMove( 0 ), and column retrieval.
/*
/*	fFUCBGetBookmark is set by get bookmark and is reset by ErrFUCBOpen.
/**/
#define fFUCBIndex							(1<<0)	// FUCB is for index
#define fFUCBNonClustered					(1<<1)	// FUCB for nonclustered index
#define fFUCBSort							(1<<2)	// FUCB is for sort
#define fFUCBSystemTable					(1<<3)	// System table cursor
#define fFUCBWrite							(1<<4)	//	cursor can write
#define fFUCBDenyRead						(1<<5)	//	deny read flag
#define fFUCBDenyWrite						(1<<6)	//	deny write flag
#define fFUCBTaggedSet						(1<<7)	// tagged column

#define fFUCBDeferClose						(1<<9)	//	FUCB is awaiting close
#define fFUCBDeferGotoBookmark				(1<<10)	//	clustered cursor position
#define fFUCBGetBookmark					(1<<11)	//	cursor got bookmark
#define fFUCBLimstat	  					(1<<12)	//	range limit
#define fFUCBInclusive					 	(1<<13)	//	inclusive range
#define fFUCBUpper							(1<<14)	//	upper range limit
#define fFUCBFull							(1<<15)	//	all CSRs including invisible CSRs
#define fFUCBUpdateSeparateLV	  			(1<<16)	//	long value updated

/*	the following flags need to be prevent reuse of cursor
/*	after deferred closed.  This is done to correctly release
/*	domain flags when commit/rollback to transaction level 0.
/**/
#define fFUCBNotReuse						( fFUCBDenyRead | fFUCBDenyWrite )

#define FFUCBNotReuse( pfucb )				( (pfucb)->wFlags & fFUCBNotReuse )

#define FFUCBIndex( pfucb )					( (pfucb)->wFlags & fFUCBIndex )
#define FUCBSetIndex( pfucb )				( (pfucb)->wFlags |= fFUCBIndex )
#define FUCBResetIndex( pfucb )				( (pfucb)->wFlags &= ~(fFUCBIndex) )

#define FFUCBNonClustered( pfucb )	  		( (pfucb)->wFlags & fFUCBNonClustered )
#define FUCBSetNonClustered( pfucb )  		( (pfucb)->wFlags |= fFUCBNonClustered )
#define FUCBResetNonClustered( pfucb )		( (pfucb)->wFlags &= ~(fFUCBNonClustered) )
													
#define FFUCBSort( pfucb )	 		 		( (pfucb)->wFlags & fFUCBSort )
#define FUCBSetSort( pfucb )  				( (pfucb)->wFlags |= fFUCBSort )
#define FUCBResetSort( pfucb )				( (pfucb)->wFlags &= ~(fFUCBSort) )

#define FFUCBSystemTable( pfucb )	 		( (pfucb)->wFlags & fFUCBSystemTable )
#define FUCBSetSystemTable( pfucb )  		( (pfucb)->wFlags |= fFUCBSystemTable )
#define FUCBResetSystemTable( pfucb )		( (pfucb)->wFlags &= ~(fFUCBSystemTable) )

#define FFUCBUpdatable( pfucb )				( (pfucb)->wFlags & fFUCBWrite )
#define FUCBSetUpdatable( pfucb )			( (pfucb)->wFlags |= fFUCBWrite )
#define FUCBResetUpdatable( pfucb )			( (pfucb)->wFlags &= ~(fFUCBWrite) )

#define FFUCBDenyWrite( pfucb )				( (pfucb)->wFlags & fFUCBDenyWrite )
#define FUCBSetDenyWrite( pfucb )			( (pfucb)->wFlags |= fFUCBDenyWrite )
#define FUCBResetDenyWrite( pfucb )			( (pfucb)->wFlags &= ~(fFUCBDenyWrite) )

#define FFUCBDenyRead( pfucb )				( (pfucb)->wFlags & fFUCBDenyRead )
#define FUCBSetDenyRead( pfucb )			( (pfucb)->wFlags |= fFUCBDenyRead )
#define FUCBResetDenyRead( pfucb )			( (pfucb)->wFlags &= ~(fFUCBDenyRead) )

#define FFUCBTaggedSet( pfucb )	 			( (pfucb)->wFlags & fFUCBTaggedSet )
#define FUCBSetTaggedSet( pfucb )  			( (pfucb)->wFlags |= fFUCBTaggedSet )
#define FUCBResetTaggedSet( pfucb )			( (pfucb)->wFlags &= ~(fFUCBTaggedSet) )

#define FFUCBUpdateSeparateLV( pfucb )		( (pfucb)->wFlags & fFUCBUpdateSeparateLV )
#define FUCBSetUpdateSeparateLV( pfucb )	( (pfucb)->wFlags |= fFUCBUpdateSeparateLV )
#define FUCBResetUpdateSeparateLV( pfucb ) 	( (pfucb)->wFlags &= ~(fFUCBUpdateSeparateLV) )

#define FFUCBDeferClosed( pfucb )			( (pfucb)->wFlags & fFUCBDeferClose )
#define FUCBSetDeferClose( pfucb )			( (pfucb)->wFlags |= fFUCBDeferClose )
#define FUCBResetDeferClose( pfucb ) 		( (pfucb)->wFlags &= ~(fFUCBDeferClose) )

#define	FFUCBDeferGotoBookmark( pfucb )					\
	( (pfucb)->wFlags & fFUCBDeferGotoBookmark )
#define	FUCBSetDeferGotoBookmark( pfucb )				\
	( (pfucb)->wFlags |= fFUCBDeferGotoBookmark )
#define	FUCBResetDeferGotoBookmark( pfucb )				\
	( (pfucb)->wFlags &= ~(fFUCBDeferGotoBookmark) )

#define	FFUCBGetBookmark( pfucb )						\
	( (pfucb)->wFlags & fFUCBGetBookmark )
#define	FUCBSetGetBookmark( pfucb )						\
	( (pfucb)->wFlags |= fFUCBGetBookmark )
#define	FUCBResetGetBookmark( pfucb )					\
	( (pfucb)->wFlags &= ~(fFUCBGetBookmark) )

#define FFUCBLimstat( pfucb )				( (pfucb)->wFlags & fFUCBLimstat )
#define FUCBSetLimstat( pfucb )				( (pfucb)->wFlags |= fFUCBLimstat )
#define FUCBResetLimstat( pfucb ) 			( (pfucb)->wFlags &= ~(fFUCBLimstat) )

#define FFUCBInclusive( pfucb )	 			( (pfucb)->wFlags & fFUCBInclusive )
#define FUCBSetInclusive( pfucb )			( (pfucb)->wFlags |= fFUCBInclusive )
#define FUCBResetInclusive( pfucb ) 		( (pfucb)->wFlags &= ~(fFUCBInclusive) )

#define FFUCBUpper( pfucb )					( (pfucb)->wFlags & fFUCBUpper )
#define FUCBSetUpper( pfucb )				( (pfucb)->wFlags |= fFUCBUpper )
#define FUCBResetUpper( pfucb ) 			( (pfucb)->wFlags &= ~(fFUCBUpper) )

#define FFUCBFull( pfucb )					( (pfucb)->wFlags & fFUCBFull )
#define FUCBSetFull( pfucb )				( (pfucb)->wFlags |= fFUCBFull )
#define FUCBResetFull( pfucb ) 				( (pfucb)->wFlags &= ~(fFUCBFull) )

#define FFUCBVersioned( pfucb )				( (pfucb)->fVersioned )
#define FUCBSetVersioned( pfucb )			( (pfucb)->fVersioned = fTrue )
#define FUCBResetVersioned( pfucb )			( (pfucb)->fVersioned = fFalse )

/*	record modification copy buffer status
/**/
typedef	INT						CBSTAT;

#define	fCBSTATNull				0
#define	fCBSTATInsert			(1<<0)
#define	fCBSTATReplace			(1<<1)
#define	fCBSTATSet				(1<<2)
#define	fCBSTATLock				(1<<3)
#define	fCBSTATAppendItem		(1<<4)

#define StoreChecksum( pfucb )								\
	( (pfucb)->ulChecksum = 								\
		UlChecksum( (pfucb)->lineData.pb, (pfucb)->lineData.cb ) )
#define	PrepareInsert( pfucb )								\
	( (pfucb)->cbstat = fCBSTATInsert,						\
	  (pfucb)->levelPrep = (pfucb)->ppib->level )
#define	PrepareReplaceNoLock( pfucb )		  				\
	( (pfucb)->cbstat = fCBSTATReplace,						\
	  (pfucb)->levelPrep = (pfucb)->ppib->level )
#define	PrepareReplace( pfucb )		  						\
	( (pfucb)->cbstat = fCBSTATReplace | fCBSTATLock, 		\
	  (pfucb)->levelPrep = (pfucb)->ppib->level )
#define	PrepareSet( pfucb )									\
	( (pfucb)->cbstat = fCBSTATSet,							\
	  (pfucb)->levelPrep = (pfucb)->ppib->level )
#define	PrepareAppendItem( pfucb )							\
	( (pfucb)->cbstat = fCBSTATAppendItem )

typedef struct {
	INT		isrid;
	SRID	rgsrid[(cbPage - sizeof(INT))/sizeof(SRID)];
	} APPENDITEM;

#define	csridAppendItemMax	((cbPage - sizeof(INT))/sizeof(SRID))

#define	IsridAppendItemOfPfucb( pfucb )		(((APPENDITEM *)(pfucb)->lineWorkBuf.pb)->isrid)
#define	RgsridAppendItemOfPfucb( pfucb )	(((APPENDITEM *)(pfucb)->lineWorkBuf.pb)->rgsrid)

#define FChecksum( pfucb )											\
	( (pfucb)->ulChecksum == UlChecksum( (pfucb)->lineData.pb,		\
	(pfucb)->lineData.cb ) )

#define FFUCBReplacePrepared( pfucb )								\
	( (pfucb)->cbstat & fCBSTATReplace )
#define FFUCBReplaceNoLockPrepared( pfucb )							\
	( !( (pfucb)->cbstat & fCBSTATLock ) &&							\
	FFUCBReplacePrepared( pfucb ) )
#define FFUCBInsertPrepared( pfucb )								\
	( (pfucb)->cbstat & fCBSTATInsert )
#define FFUCBSetPrepared( pfucb )									\
	( (pfucb)->cbstat != fCBSTATNull &&								\
	(pfucb)->levelPrep == (pfucb)->ppib->level )
#define FFUCBRetPrepared( pfucb )									\
	( (pfucb)->cbstat != fCBSTATNull )
#define FFUCBUpdatePrepared( pfucb )	((pfucb)->cbstat != fCBSTATNull )
#define	FUCBResetCbstat( pfucb )  		( (pfucb)->cbstat = fCBSTATNull )

typedef INT		KS;

#define ksNull						0
#define ksPrepared					(1<<0)
#define ksTooBig					(1<<1)

#define	KSReset( pfucb )			( (pfucb)->ks = ksNull )
#define	KSSetPrepare( pfucb )		( (pfucb)->ks |= ksPrepared )
#define KSSetTooBig( pfucb ) 		( (pfucb)->ks |= ksTooBig )
#define	FKSPrepared( pfucb ) 		( (pfucb)->ks & ksPrepared )
#define	FKSTooBig( pfucb )	  		( (pfucb)->ks & ksTooBig )

/*	set bit arrary marcos
/**/
#define	FUCBResetColumnSet( pfucb )				  					\
	( memset( (pfucb)->rgbitSet, 0x00, 32 ) )
#define	FUCBSetFixedColumnSet( pfucb, fid )							\
	( (pfucb)->rgbitSet[(fid - fidFixedLeast)/8] |= 1 <<			\
		(fid-fidFixedLeast) % 8 )
#define	FUCBSetVarColumnSet( pfucb, fid )							\
	( (pfucb)->rgbitSet[16 + (fid - fidVarLeast)/8] |= 1 <<			\
		(fid-fidVarLeast) % 8 )
#define	FFUCBColumnSet( pfucb, ibitCol )							\
	( (pfucb)->rgbitSet[(ibitCol)/8] & ( 1 << ( (ibitCol) % 8 ) ) )

#define FUCBStore( pfucb )												\
	{																	\
	(pfucb)->csrstatStore = PcsrCurrent( pfucb )->csrstat;				\
	(pfucb)->bmStore = PcsrCurrent( pfucb )->bm;			 			\
	(pfucb)->itemStore = PcsrCurrent( pfucb )->item; 		 			\
	}

#define FUCBResetStore( pfucb )										\
	{																\
	(pfucb)->bmStore = 0;										 	\
	}

#define FUCBRestore( pfucb )										\
	{																\
	if ( (pfucb)->bmStore != isridNull && (pfucb)->bmStore != sridNull )	\
		{															\
		PcsrCurrent( pfucb )->csrstat = (pfucb)->csrstatStore;		\
		Assert( (pfucb)->csrstatStore == csrstatOnDataRoot ||		\
				(pfucb)->csrstatStore == csrstatDeferMoveFirst ||	\
				(pfucb)->csrstatStore == csrstatBeforeFirst ||		\
				(pfucb)->csrstatStore == csrstatAfterLast ||		\
				(pfucb)->bmStore != sridNull );						\
		PcsrCurrent( pfucb )->bm = (pfucb)->bmStore;				\
		PcsrCurrent( pfucb )->item = (pfucb)->itemStore;	  		\
		PcsrCurrent( pfucb )->ulDBTime = ulDBTimeNull; 			 	\
		}															\
	}

/* file use control block
/**/
struct _fucb
	{
	// ===== chaining fields =====
	struct _pib		*ppib;				// user that opened this FUCB
	struct _fucb 	*pfucbNext;			// Next FUCB of this user
	union
		{
		struct _fcb *pfcb;				// if wFlags & fFUCBIndex
		struct _scb *pscb;				// if wFlags & fFUCBSort
		} u;
	struct _fucb *pfucbNextInstance;	// Next Instance of this file

	// ===== currency =====
	struct _csr	*pcsr;

	// ===== stored currency =====
	SRID			bmStore;  			 	//	stored bookmark
	SRID			itemStore;		 	 	//	stored item
	SRID			bmRefresh;				//	stored bookmark for next/prev retry
	SRID 			sridFather;			 	// SRID of visible father
	
	BYTE			**ppbCurrent;		 	// (SORT) current record
	ULONG			ulChecksum;			 	// checksum of record -- used only for optimistic locking
	KEY  			keyNode;	 		 	// Key of current node
	LINE			lineData;			 	// Current data pointed in pcsr
	CSRSTAT	  		csrstatStore;  		 	//	stored CSR status
	LEVEL			levelOpen;

	// ===== interface to Storage System =====
	SSIB			ssib;					// SSIB associated with this FUCB
	struct _bf		*pbfEmpty;		 		// write latched empty page
	UINT			cpn;					//	next read-ahead pn

	// ===== maintained by rec man =====
	struct _fucb 	*pfucbCurIndex; 	// current secondary index
	struct _bf		*pbfWorkBuf;	 	// working buffer for Insert/Replace
	LINE			lineWorkBuf;	 	// working buffer for Insert/Replace
	ULONG			cbRecord;			//	size of original record
	ULONG			dbkUpdate;		 	// dbk of record to Replace
	BYTE			rgbitSet[32];
	CBSTAT			cbstat;			 	// copy buffer status
	LEVEL			levelPrep;		 	// level copy buffer prepared

		// ====== versioning work area =======
	struct _rce	*prceLast;				// last RCE allocated (used only for Replace)

	// ====== space manager work area =======
	PGNO			pgnoLast;			// last page of extent
	CPG 			cpgExtent;			// initial extent size
	CPG 			cpgAvail;			// number of remaining pages
	INT				fExtent;			// work area flag

	// ===== misc fields =====
	INT				wFlags;				// temporary flags

	// ===== maintained by dir man =====
	BYTE			*pbKey;			   	// search key buffer
	DBID			dbid;				// database id
	KS 				ks;					// search key buffer status
	UINT  			cbKey;				// key size
	BOOL			fVtid : 1;		 	// persistant flag cursor has vtid
	BOOL			fVersioned : 1;  	// persistant falg cursor made version
	BOOL			fCmprsLg:1;
	INT	  			clineDiff;
#define ilineDiffMax 3
	LINE			rglineDiff[ilineDiffMax];
	};


#define PfucbMEMAlloc()				(FUCB*)PbMEMAlloc(iresFUCB)

#ifdef DEBUG /*  Debug check for illegal use of freed fucb  */
#define MEMReleasePfucb(pfucb)		{ MEMRelease(iresFUCB, (BYTE*)(pfucb)); pfucb = pfucbNil; }
#else
#define MEMReleasePfucb(pfucb)		{ MEMRelease(iresFUCB, (BYTE*)(pfucb)); }
#endif

#ifdef	DEBUG
#define	CheckTable( ppibT, pfucb )		   					\
	{														\
	Assert( pfucb->ppib == ppibT );		   					\
	Assert( fRecovering || FFUCBIndex( pfucb ) );	 		\
	Assert( !( FFUCBSort( pfucb ) ) );						\
	Assert( pfucb->u.pfcb != NULL );						\
	}
#define	CheckSort( ppibT, pfucb )		   					\
	{									   					\
	Assert( pfucb->ppib == ppibT );		   					\
	Assert( FFUCBSort( pfucb ) );							\
	Assert( !( FFUCBIndex( pfucb ) ) );						\
	Assert( pfucb->u.pscb != NULL );						\
	}
#define	CheckFUCB( ppibT, pfucb )		   					\
	{														\
	Assert( pfucb->ppib == ppibT );		   					\
	Assert( pfucb->u.pfcb != NULL );						\
	}

#define CheckNonClustered( pfucb )							\
	{											   			\
	Assert( (pfucb)->pfucbCurIndex == pfucbNil ||			\
		FFUCBNonClustered( (pfucb)->pfucbCurIndex ) );		\
	}

#else	/* !DEBUG */
#define	CheckSort( ppib, pfucb )
#define	CheckTable( ppib, pfucb )
#define	CheckFUCB( ppib, pfucb )
#define	CheckNonClustered( pfucb )
#endif	/* !DEBUG */

#define PcsrCurrent( pfucb )		( (pfucb)->pcsr )
#define BmOfPfucb( pfucb )			( (pfucb)->pcsr->bm )
#define FUCBCheckUpdatable( pfucb )		\
	( FFUCBUpdatable( pfucb ) ? JET_errSuccess : JET_errPermissionDenied )
	
ERR ErrFUCBAllocCSR( CSR **ppcsr );
ERR ErrFUCBNewCSR( FUCB *pfucb );
VOID FUCBFreeCSR( FUCB *pfucb );
VOID FUCBFreePath( CSR **ppcsr, CSR *pcsrMark );
ERR ErrFUCBOpen( PIB *ppib, DBID dbid, FUCB **ppfucb );
VOID FUCBClose( FUCB *pfucb );
VOID FUCBRemoveInvisible(CSR **ppcsr);

VOID FUCBSetIndexRange( FUCB *pfucb, JET_GRBIT grbit );
VOID FUCBResetIndexRange( FUCB *pfucb );
ERR ErrFUCBCheckIndexRange( FUCB *pfucb );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\fmp.h ===
/*	critical section guards szDatabaseName and fWait,
/*	fWait gaurds hf open and close
/* fLoggable is fFALSE if logging is currently OFF for database
/* fDBLoggable FALSE if logging is always OFF for database
/* logged modifications counter for database
/**/
typedef struct _fmp			 		/* FILE MAP for database.					*/
	{
	HANDLE 		hf;			 		/* File handle for read/write the file		*/
	BYTE		*szDatabaseName;	/* This database file name					*/
	BYTE		*szRestorePath;		/* Database restored to. 					*/
	INT 		ffmp;				/* Flags for FMP							*/
	CRIT		critExtendDB;
	PIB			*ppib;				/* Exclusive open session					*/
	INT			cdbidExclusive;		/* Exclusive open count						*/
	BOOL		fLogOn;				/* Logging is on/off? used in createdb		*/
	BOOL		fDBLoggable;		/* Cache of pbRoot->loggable				*/
	ULONG		ulDBTime;			/* Timestamp from DB operations.			*/
	ULONG		ulDBTimeCurrent;	/* Timestamp from DB redo operations.		*/

	CHAR		*szFirst;			/* first db name shown in log redo.			*/
	BOOL		fLogOnFirst;		/* the status of first attached db			*/
	INT 		cDetach;	  		/* detach operation counters. for Redo		*/
										
	HANDLE 		hfPatch;	  		/* File handle for patch file				*/
	INT 		cpage;				/* patch page count.						*/
	PGNO		pgnoCopied;			/* during backup, last copied page's #		*/
							  		/* 0 - no back up is going on.				*/
#ifdef DEBUG
	LONG		lBFFlushPattern;	/* in-complete flush to simulate soft crash */
	BOOL		fPrevVersion;  		/* previous release version database		*/
#endif
	} FMP;

extern FMP * __near rgfmp;

/*	flags for dbid
/**/
#define	ffmpWait			 		(1<<0)
#define	ffmpExclusive		 		(1<<1)
#define	ffmpReadOnly		 		(1<<2)
#define	ffmpAttached		 		(1<<3)
#define ffmpExtendingDB		 		(1<<4)
#ifdef DEBUG
#define	ffmpFlush			 		(1<<5)
#endif

#define FDBIDWait( dbid )	 		( rgfmp[dbid].ffmp & ffmpWait )
#define DBIDSetWait( dbid )	  		( rgfmp[dbid].ffmp |= ffmpWait )
#define DBIDResetWait( dbid ) 		( rgfmp[dbid].ffmp &= ~(ffmpWait) )

#define FDBIDExclusive( dbid ) 		( rgfmp[dbid].ffmp & ffmpExclusive )
#define FDBIDExclusiveByAnotherSession( dbid, ppib )		\
				( (	FDBIDExclusive( dbid ) )				\
				&&	( rgfmp[dbid].ppib != ppib ) )
#define FDBIDExclusiveBySession( dbid, ppib )				\
				( (	FDBIDExclusive( dbid ) )				\
				&&	( rgfmp[dbid].ppib == ppib ) )
#define DBIDSetExclusive( dbid, ppib )						\
				rgfmp[dbid].ffmp |= ffmpExclusive;			\
				rgfmp[dbid].ppib = ppib; 
#define DBIDResetExclusive( dbid )	( rgfmp[dbid].ffmp &= ~(ffmpExclusive) )

#define FDBIDReadOnly( dbid )		( rgfmp[dbid].ffmp & ffmpReadOnly )
#define DBIDSetReadOnly( dbid )		( rgfmp[dbid].ffmp |= ffmpReadOnly )
#define DBIDResetReadOnly( dbid )	( rgfmp[dbid].ffmp &= ~(ffmpReadOnly) )

#define FDBIDAttached( dbid )		( rgfmp[dbid].ffmp & ffmpAttached )
#define DBIDSetAttached( dbid )		( rgfmp[dbid].ffmp |= ffmpAttached )
#define DBIDResetAttached( dbid )	( rgfmp[dbid].ffmp &= ~(ffmpAttached) )

#define FDBIDExtendingDB( dbid )	( rgfmp[dbid].ffmp & ffmpExtendingDB )
#define DBIDSetExtendingDB( dbid )	( rgfmp[dbid].ffmp |= ffmpExtendingDB )
#define DBIDResetExtendingDB( dbid) ( rgfmp[dbid].ffmp &= ~(ffmpExtendingDB) )

#define FDBIDFlush( dbid )			( rgfmp[dbid].ffmp & ffmpFlush )
#define DBIDSetFlush( dbid )		( rgfmp[dbid].ffmp |= ffmpFlush )
#define DBIDResetFlush( dbid )		( rgfmp[dbid].ffmp &= ~(ffmpFlush) )


#ifdef MULTI_PROCESS
	
HANDLE Hf(DBID dbid);
extern HANDLE	*rghfUser;
extern HANDLE	__near hfLog;

#else	/* !MULTI_PROCESS */

#define Hf(dbid) (rgfmp[dbid].hf)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\idb.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	 idb.h: Index Descriptor Block		===================

// Flags for IDB
#define fidbUnique								(1<<0)		// Duplicate keys not allowed
#define fidbHasTagged							(1<<1)		// Has a tagged segment
#define fidbAllowAllNulls						(1<<2)		// Make entries for NULL keys (all segments are null)
#define fidbAllowSomeNulls						(1<<3)		// Make entries for keys with some null segments
#define fidbNoNullSeg							(1<<4)		// Don't allow a NULL key segment
#define fidbPrimary								(1<<5)		// Index is the primary index
#define fidbLangid								(1<<6)		// Index langid
#define fidbHasMultivalue						(1<<7)		// Has a multivalued segment

#define IDBSetUnique( pidb )					( (pidb)->fidb |= fidbUnique )
#define IDBResetUnique( pidb )				( (pidb)->fidb &= ~fidbUnique )
#define FIDBUnique( pidb )						( (pidb)->fidb & fidbUnique )

#define IDBSetHasTagged( pidb )				( (pidb)->fidb |= fidbHasTagged )
#define IDBResetHasTagged( pidb )			( (pidb)->fidb &= ~fidbHasTagged )
#define FIDBHasTagged( pidb )					( (pidb)->fidb & fidbHasTagged )

#define IDBSetAllowAllNulls( pidb )	 		( (pidb)->fidb |= fidbAllowAllNulls )
#define IDBResetAllowAllNulls( pidb )		( (pidb)->fidb &= ~fidbAllowAllNulls )
#define FIDBAllowAllNulls( pidb )			( (pidb)->fidb & fidbAllowAllNulls )

#define IDBSetAllowSomeNulls( pidb )	 	( (pidb)->fidb |= fidbAllowSomeNulls )
#define IDBResetAllowSomeNulls( pidb ) 	( (pidb)->fidb &= ~fidbAllowSomeNulls )
#define FIDBAllowSomeNulls( pidb )			( (pidb)->fidb & fidbAllowSomeNulls )

#define IDBSetNoNullSeg( pidb )				( (pidb)->fidb |= fidbNoNullSeg )
#define IDBResetNoNullSeg( pidb )			( (pidb)->fidb &= ~fidbNoNullSeg )
#define FIDBNoNullSeg( pidb )					( (pidb)->fidb & fidbNoNullSeg )

#define IDBSetPrimary( pidb )					( (pidb)->fidb |= fidbPrimary )
#define IDBResetPrimary( pidb )				( (pidb)->fidb &= ~fidbPrimary )
#define FIDBPrimary( pidb )					( (pidb)->fidb & fidbPrimary )

#define IDBSetLangid( pidb )					( (pidb)->fidb |= fidbLangid )
#define IDBResetLangid( pidb )				( (pidb)->fidb &= ~fidbLangid )
#define FIDBLangid( pidb )						( (pidb)->fidb & fidbLangid )

#define IDBSetMultivalued( pidb )		  	( (pidb)->fidb |= fidbMultivalued )
#define IDBResetMultivalued( pidb )		  	( (pidb)->fidb &= ~fidbMultivalued )
#define FIDBMultivalued( pidb )			  	( (pidb)->fidb & fidbMultivalued )

// Index Descriptor Block: information about index key
struct _idb
	{
	IDXSEG		rgidxseg[JET_ccolKeyMost];
	BYTE			rgbitIdx[32];
	LANGID		langid;							// language of index
	CHAR			szName[JET_cbNameMost + 1];
	BYTE			iidxsegMac;
	BYTE			fidb;
	BYTE			rgbFiller[2];
	};

#define PidbMEMAlloc()			(IDB*)PbMEMAlloc(iresIDB)

#ifdef DEBUG /*  Debug check for illegal use of freed idb  */
#define MEMReleasePidb(pidb)	{ MEMRelease(iresIDB, (BYTE*)(pidb)); pidb = pidbNil; }
#else
#define MEMReleasePidb(pidb)	{ MEMRelease(iresIDB, (BYTE*)(pidb)); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\logver.h ===
/*	fixed log version for Daytona shippment.
/*	Must be changed whenever log format changed.
/**/
#define rmj		202
#define rmm		1
#define rup		0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\node.h ===
#ifndef NODE_INCLUDED
#define NODE_INCLUDED

typedef SRID ITEM;

//	UNDONE:	tune these constants and remove cbFudge
#define	cbFudge					10
#define	citemMax		   		300
#define	citagSonMax				ctagMax
#define	cbFOPNoSon				( sizeof(TAG) + 1 + 1 )		// 6
#define	cbFOPOneSon				( cbFOPNoSon + 1 + 1 )		// 8
#define	cbPageAvailMost	 		( cbPage - sizeof(PGHDR) - sizeof(PGTRLR) )
								// 4096 - 28 - 4 = 4064
#define	cbAvailMost				( cbPageAvailMost - cbFOPNoSon - sizeof(SRID) )
								// 4064 - 6 - 4 = 4054
#define	cbNodeMost				( cbAvailMost - ( cbFOPOneSon - cbFOPNoSon ) - sizeof(TAG) - sizeof(SRID) )
								// 4054 - 2 - 4 - 4 = 4044
#define	cbNullKeyData			( cbFOPOneSon - cbFOPNoSon + sizeof(TAG) + 1 + 1 )
								//  8 - 6 + 4 + 1 + 1 = 8
#define	cbNullKeyDataMost 	 	( cbNodeMost - ( 1 + 1 ) - cbFudge )
								// 4044 - 2 - 10 = 4032
#define	cbChunkMost 			( cbNullKeyDataMost - sizeof(LONG) )
								// 4032 - 4 = 4028
#define	cbItemNodeMost			( 1 + 1 + JET_cbKeyMost + 0 + 0 + sizeof(SRID) + (citemMax * sizeof(SRID)) )
								// 261 + 300 * 4 = 1461
#define	cbHalfItemNodeMost 		( 1 + 1 + JET_cbKeyMost + 0 + 0 + sizeof(SRID) + ((((citemMax + 1) / 2) + 1 ) * sizeof(SRID)) )
								//  261 + 151 * 4 = 865

//	node header bits
#define fNDVersion		  		0x80
#define fNDDeleted		  		0x40
#define fNDBackLink		  		0x20
#define fNDFDPPtr				0x10
#define fNDSon					0x08
#define fNDVisibleSon	  		0x04
#define fNDFirstItem  	  		0x02
#define fNDLastItem	  	  		0x01

#define	FNDDeleted(b)	 		( (b) & fNDDeleted )
#define	FNDVersion(b)	 		( (b) & fNDVersion )
#define	FNDVerDel(b)			( (b) & (fNDDeleted | fNDVersion) )

#define	FNDBackLink(b)	 		( (b) & fNDBackLink )
#define	FNDNullSon(b)	 		( !( (b) & fNDSon ) )
#define	FNDSon(b)	 			( (b) & fNDSon )

#define	FNDFDPPtr(b) 			( (b) & fNDFDPPtr )
#define	FNDVisibleSons(b)		( (b) & fNDVisibleSon )
#define	FNDInvisibleSons(b) 	( !( (b) & fNDVisibleSon ) )

#define	FNDFirstItem(b)		   	( (b) & fNDFirstItem )
#define	FNDLastItem(b)		   	( (b) & fNDLastItem )

//	node flag toggle macros

#define	NDSetDeleted(b) 	   	( (b) |= fNDDeleted )
#define	NDResetDeleted(b)	   	( (b) &= ~fNDDeleted )

#define	NDSetVersion(b) 	   	( (b) |= fNDVersion )
#define	NDResetVersion(b)	   	( (b) &= ~fNDVersion )

#define	NDSetSon(b)			   	( (b) |= fNDSon )
#define	NDResetSon(b)		   	( (b) &= ~fNDSon )

#define	NDSetKeyLength(pb, cb) 	( *(pb) = cb )

#define	NDSetVisibleSons(b)	   	( (b) |= fNDVisibleSon )
#define	NDSetInvisibleSons(b)  	( (b) &= ~fNDVisibleSon )

#define	NDSetBackLink(b)   	   	( (b) |= fNDBackLink )
#define	NDResetBackLink(b) 	   	( (b) &= ~fNDBackLink )

#define	NDSetFDPPtr(b)		   	( (b) |= fNDFDPPtr )
#define	NDResetFDPPtr(b)	   	( (b) &= ~fNDFDPPtr )

#define	NDSetFirstItem(b)	   	( (b) |= fNDFirstItem )
#define	NDResetFirstItem(b)	   	( (b) &= ~fNDFirstItem )

#define	NDSetLastItem(b)	   	( (b) |= fNDLastItem )
#define	NDResetLastItem(b)	   	( (b) &= ~fNDLastItem )

//	macros
#define StNDKey(pb)					( (pb) + 1 )
#define PbNDKeyCb(pb)		  		( (pb) + 1 )
#define PbNDKey(pb)					( (pb) + 2 )
#define CbNDKey(pb)					( *( (pb) + 1 ) )
#define PbNDSonTable(pb)	  		( (pb) + 1 + 1 + *(pb + 1) )
#define PbNDSon(pb)			  		( (BYTE *)PbNDSonTable(pb) + 1 )
#define CbNDSonTable(pbSonTable)  	( *(BYTE *)(pbSonTable) )
#define CbNDSon(pbNode) \
	( FNDNullSon(*(pbNode)) ? 0 : *PbNDSonTable(pbNode) )

#define PgnoNDOfPbSon(pb) 		 	( *(PGNO UNALIGNED *)PbNDSon(pb) )

#define FNDNonIntrinsicSons(pbNode)	( !FNDNullSon(*pbNode) && ( FNDVisibleSons(*pbNode) || CbNDSon(pbNode) > 1 ) )
#define FNDIntrinsicSons(pbNode)	( !FNDNullSon(*pbNode) && ( !FNDVisibleSons(*pbNode) || CbNDSon(pbNode) == 1 ) )
#define PbNDBackLink(pb)											\
	( PbNDSonTable(pb) + ( FNDNullSon( *(pb) ) ? 0 :				\
	( ( ( *PbNDSonTable(pb) == 1 ) && FNDInvisibleSons( *(pb) ) ) ?	\
	sizeof(PGNO) + 1 : *PbNDSonTable(pb) + 1 ) ) )
#define PbNDData(pb) \
	( PbNDBackLink(pb) + ( FNDBackLink( *(pb) ) ? sizeof(SRID) : 0 ) )
#define CbNDData( pbNode, cbNode )	( (cbNode) - (DWORD)( PbNDData(pbNode) - (pbNode) ) )
#define ItagSonOfPbND(pb,ib)		( PbNDSonTable(pb)[ib] )
#define ItagSonOfPbSonTable(pb,ib) 	( pb[ib+1] )
#define ItagSonOfPbSon(pb,ib)		( pb[ib] )

#define NDGet( pfucb, itagT )		PMGet( &(pfucb)->ssib, itagT )

#ifdef DEBUG

#define AssertNDIntrinsicSon( pbNode, cbNode )							\
		{																\
		Assert( ( PbNDData( (pbNode) )) - (pbNode) <=					\
			(INT)(cbNode) ); 											\
		Assert( ( PgnoNDOfPbSon( pbNode ) & 0xff000000 ) == 0 );		\
		}																				

#define AssertNDGet( pfucb, itagT )										\
		{																\
		AssertPMGet( &(pfucb)->ssib, itagT ); 							\
		}

VOID AssertNDGetKey( FUCB *pfucb, INT itag );

VOID AssertNDGetNode( FUCB *pfucb, INT itag );

#else

#define AssertNDIntrinsicSon( pbNode, cbNode )
#define AssertNDGet( pfucb, itag )
#define AssertNDGetKey( pfucb, itag )
#define AssertNDGetNode( pfucb, itag )

#endif

#define NDIGetBookmarkFromCSR( pfucb, pcsr, psrid )												\
	{																							\
	if ( FNDBackLink( *((pfucb)->ssib.line.pb) ) )								\
		{																						\
		*(SRID *)(psrid) = *(SRID UNALIGNED *)PbNDBackLink((pfucb)->ssib.line.pb);	\
		Assert( PgnoOfPn(*(SRID *)psrid) != pgnoNull );							\
		}																						\
	else																						\
		{																						\
		*(psrid) = SridOfPgnoItag( (pcsr)->pgno, (pcsr)->itag );		 										\
		}																						\
	}

#define NDIGetBookmark( pfucb, psrid ) 		NDIGetBookmarkFromCSR( pfucb, \
													PcsrCurrent( pfucb ), \
													psrid )

#define NDGetBookmark( pfucb, psrid ) 		NDGetBookmarkFromCSR( pfucb,	\
													PcsrCurrent( pfucb ),	\
													psrid )

/*	item bits and macros.
/**/
#define fNDItemDelete					0x40000000
#define fNDItemVersion					0x80000000

#define FNDItemVersion( item )		( (item) & fNDItemVersion )
#define ITEMSetVersion( item )		( (item) |= fNDItemVersion )
#define ITEMResetVersion( item )		( (item) &= ~(fNDItemVersion) )

#define FNDItemDelete( item ) 		( (item) & fNDItemDelete )
#define ITEMSetDelete( item )			( (item) |= fNDItemDelete )
#define ITEMResetDelete( item )		( (item) &= ~(fNDItemDelete) )

#define BmNDOfItem( item )				((item) & ~( fNDItemVersion | fNDItemDelete ) )

#define	CitemND(pb, cb) \
	( ( cb - (UINT)( PbNDData(pb) - pb ) ) / sizeof(ITEM) )

#define	CitemNDData(pb, cb, pbData)	\
	( ( cb - (UINT)( (pbData) - pb ) ) / sizeof(ITEM) )

#define FNDSingleItem( pfucb )											\
	( ( (pfucb)->ssib.line.cb -		 									\
	(UINT)( PbNDData( (pfucb)->ssib.line.pb ) - (pfucb)->ssib.line.pb ) )  	\
	/ sizeof(ITEM) == 1	)

//	LSridCmp
//	========================================================================
//	LONG LSridCmp( SRID *psrid1, SRID *psrid2 )
//
//	Compare the srids.
//
//	PARAMETERS	psrid1		   pointer to a item;
//					psrid2		   pointer to a item;
//
//	RETURNS		< 0, then the first srid is less than the second.
//					= 0, then the first srid is equal to the the second.
//					> 0, then the first srid is greater than the second.
//-
#define LSridCmp( srid1, srid2 )										\
	((LONG) ((SRID) BmNDOfItem( srid1 ) - (SRID) BmNDOfItem( srid2 )))

#ifdef DEBUG
	VOID NDCheckPage( FUCB *pfucb );
#else
	#define NDCheckPage( pfucb );
#endif

#define NDGetKey( pfucb )												\
	{																	\
	AssertNDGet( pfucb, PcsrCurrent(pfucb)->itag );	   					\
	(pfucb)->keyNode.cb = (INT)*((BYTE *)(pfucb)->ssib.line.pb + 1);	\
	(pfucb)->keyNode.pb = ( (BYTE *)(pfucb)->ssib.line.pb + 2 );		\
	}

//	node prototypes
ERR ErrNDNewPage( FUCB *pfucb, PGNO pgno, PGNO pgnoFDP, PGTYP pgtyp, BOOL fVisibleSons );
ERR ErrNDSetNodeHeader( FUCB *pfucb, BYTE bHeader );
VOID NDSeekSon( FUCB *pfucb, CSR *pcsr, KEY const *pkey, INT fFlags );
VOID NDMoveFirstSon( FUCB *pfucb, CSR *pcsr );
VOID NDMoveLastSon( FUCB *pfucb, CSR *pcsr );
ERR ErrNDMoveSon( FUCB *pfucb, CSR *pcsr );
VOID NDGetNode( FUCB *pfucb );
VOID NDGetBookmarkFromCSR( FUCB *pfucb, CSR *pcsr, SRID *psrid );

ERR ErrNDInsertNode( FUCB *pfucb, KEY const *pkey,
	LINE *plineData, INT fFlags );
ERR ErrNDDeleteNode( FUCB *pfucb );
ERR ErrNDReplaceWithLink( FUCB *pfucb, SRID sridLink );
VOID NDDeleteInvisibleSon(
	FUCB  	*pfucb,
	RMPAGE	*prmpage,
	BOOL  	fCheckRemoveParentOnly,
	BOOL  	*pfRmParent );
ERR ErrNDFlagDeleteNode( FUCB *pfucb, INT fFlags );
ERR ErrNDReplaceNodeData( FUCB *pfucb, LINE *pline, INT fFlags );
VOID NDResetNodeVersion( FUCB *pfucb );
VOID NDResetNodeDeleted( FUCB *pfucb );

ERR ErrNDGetItem( FUCB *pfucb );
ERR ErrNDFirstItem( FUCB *pfucb );
ERR ErrNDLastItem( FUCB *pfucb );
ERR ErrNDNextItem( FUCB *pfucb );
ERR ErrNDPrevItem( FUCB *pfucb );
ERR ErrNDSeekItem( FUCB *pfucb, SRID srid );
INT CitemNDThere( FUCB *pfucb );

ERR ErrNDInsertItemList( FUCB *pfucb, KEY *pkey, SRID srid, INT fFlags );
ERR ErrNDInsertItem( FUCB *pfucb, ITEM item, INT fFlags );
ERR ErrNDInsertItems( FUCB *pfucb, ITEM *rgitem, INT citem );
ERR ErrNDFlagInsertItem( FUCB *pfucb );											
ERR ErrNDDeleteItem( FUCB *pfucb );
ERR ErrNDFlagDeleteItem( FUCB *pfucb );
VOID NDSetItemDelete( FUCB *pfucb );
VOID NDResetItemVersion( FUCB *pfucb );
VOID NDResetItemDelete( FUCB *pfucb );
ERR ErrNDSplitItemListNode( FUCB *pfucb, INT fFlags );
ERR ErrNDDelta( FUCB *pfucb, LONG lDelta, INT fFlags );
ERR	ErrNDLockRecord( FUCB *pfucb );

ERR ErrNDInsertWithBackLink( FUCB *pfucb, BYTE bFlags, KEY const *pkey,
	LINE *plineSonTable, SRID sridBackLink, LINE *plineData );
VOID NDGetBackLink( FUCB *pfucb, PGNO *ppgno, INT *pitag );
ERR ErrNDExpungeBackLink( FUCB *pfucb );
ERR ErrNDExpungeLinkCommit( FUCB *pfucb, FUCB *pfucbSrc );
VOID NDGetItagFatherIbSon( INT *pitagFather, INT *pibSon, PAGE *ppage, INT itag );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\logapi.h ===
#include <stdlib.h>						/* for _MAX_PATH */
#include <dirapi.h>

//------------------------ system parameters ---------------------------

extern long lMaxSessions;
extern long lMaxOpenTables;
extern long lMaxVerPages;
extern long lMaxCursors;
extern long lMaxBuffers;
extern long lLogBuffers;
extern long lLogFileSectors;
extern long lLogFlushThreshold;
extern long lLGCheckPointPeriod;
extern long lWaitLogFlush;
extern long lLogFlushPeriod;
extern long lLGWaitingUserMax;
	
//------ log.c --------------------------------------------------------------

/*	flags controlling logging behavior
/**/
extern BOOL fLogDisabled;			/* to turn off logging by environment variable */
extern BOOL fFreezeCheckpoint;		/* freeze checkpoint when backup occurs. */
extern BOOL fFreezeNewGeneration;	/* freeze log gen when backup occurs. */
extern BOOL	fNewLogRecordAdded;
extern BOOL fBackupActive;
extern BOOL fLGNoMoreLogWrite;

extern INT cLGUsers;
extern PIB *ppibLGFlushQHead;
extern PIB *ppibLGFlushQTail;

extern INT csecLGThreshold;
extern INT csecLGCheckpointCount;
extern INT csecLGCheckpointPeriod;
extern INT cmsLGFlushPeriod;
extern INT cmsLGFlushStep;
extern BYTE szComputerName[];

/*	flags controlling recovery behavior
/**/
extern BOOL fHardRestore;

#ifdef DEBUG
extern BOOL	fDBGTraceLog;
extern BOOL	fDBGTraceLogWrite;
extern BOOL	fDBGFreezeCheckpoint;
extern BOOL	fDBGTraceRedo;
#endif

extern LONG cXactPerFlush;

#ifdef PERFCNT
extern BOOL  fPERFEnabled;
extern ULONG rgcCommitByUser[10];
extern ULONG rgcCommitByLG[10];
#endif

#pragma pack(1)

typedef struct
	{	
	BYTE			szSysDbPath[_MAX_PATH + 1];
	BYTE			szLogFilePath[_MAX_PATH + 1];
	
	ULONG			ulMaxSessions;
	ULONG			ulMaxOpenTables;
	ULONG			ulMaxVerPages;
	ULONG			ulMaxCursors;
	ULONG			ulLogBuffers;
	ULONG			ulMaxBuffers;		/* not used, for ref only */
	} DBENV;

VOID LGStoreDBEnv( DBENV *pdbenv );
VOID LGSetDBEnv( DBENV *pdbenv );
VOID LGLogFailEvent( BYTE *szLine );

/*
 * NOTE: Whenever a new log record type is added or changed, the following
 * NOTE: should be udpated too: mplrtypsz in logapi.c, new print function for
 * NOTE: the new lrtyp in logapi.c, and mplrtypcb and CbLGSizeOfRec in
 * NOTE: redut.c.
 */
typedef BYTE LRTYP;

#define lrtypNOP				((LRTYP)  0 )	/* NOP null operation */
#define lrtypStart				((LRTYP)  1 )
#define lrtypQuit				((LRTYP)  2 )
#define lrtypMS					((LRTYP)  3 )	/* mutilsec flush */
#define lrtypFill				((LRTYP)  4 )	/* no op */

#define lrtypBegin				((LRTYP)  5 )
#define lrtypCommit				((LRTYP)  6 )
#define lrtypAbort				((LRTYP)  7 )

#define lrtypCreateDB			((LRTYP)  8 )
#define lrtypAttachDB			((LRTYP)  9 )
#define lrtypDetachDB			((LRTYP) 10 )

#define lrtypInitFDPPage		((LRTYP) 11 )

#define lrtypSplit				((LRTYP) 12 )
#define lrtypEmptyPage			((LRTYP) 13 )
#define lrtypMerge				((LRTYP) 14 )

#define lrtypInsertNode			((LRTYP) 15 )
#define lrtypInsertItemList		((LRTYP) 16 )
#define lrtypReplace			((LRTYP) 17 )
#define lrtypReplaceC			((LRTYP) 18 )
#define lrtypFlagDelete			((LRTYP) 19 )
#define lrtypLockRec			((LRTYP) 20 )

#define lrtypUpdateHeader		((LRTYP) 21 )
#define lrtypInsertItem			((LRTYP) 22 )
#define lrtypInsertItems		((LRTYP) 23 )
#define lrtypFlagDeleteItem		((LRTYP) 24 )
#define lrtypFlagInsertItem		((LRTYP) 25 )
#define lrtypDeleteItem			((LRTYP) 26 )
#define lrtypSplitItemListNode	((LRTYP) 27 )

#define lrtypDelta				((LRTYP) 28 )

#define lrtypDelete				((LRTYP) 29 )
#define lrtypELC				((LRTYP) 30 )

#define lrtypFreeSpace			((LRTYP) 31 )
#define lrtypUndo				((LRTYP) 32 )
					
#define lrtypRecoveryUndo1		((LRTYP) 33 )
#define lrtypRecoveryQuit1		((LRTYP) 34 )

#define lrtypRecoveryUndo2		((LRTYP) 35 )
#define lrtypRecoveryQuit2		((LRTYP) 36 )

#define lrtypFullBackup			((LRTYP) 37 )
#define lrtypIncBackup			((LRTYP) 38 )

/*	debug only
/**/
#define lrtypCheckPage			((LRTYP) 39 )

#define lrtypMax				((LRTYP) 40 )


/* log record structure ( fixed size portion of log entry )
/**/

typedef struct
	{
	LRTYP	lrtyp;
	} LR;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of DB operations */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;				/* dbid + pgno */

	BYTE	itagSon;		/* itag of node, used only for verification */
//	UNDONE:	review with Cheen Liao
//	SHORT	itagFather;	 	/* itag of father node */
	BYTE	itagFather;	 	/* itag of father node */
	BYTE	ibSon;	 		/* position to insert in father son table */
	BYTE	bHeader;		/* node header */
	ULONG	fDIRFlags;		/* fDIRVersion for insert item list */
//	UNDONE:	review with Cheen Liao
//	USHORT 	cbKey;			/* key size */
	BYTE 	cbKey;			/* key size */
	USHORT	cbData;			/* data size */
	CHAR	szKey[0];		/* key and data follow */
	} LRINSERTNODE;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;

	BYTE	itag;			/* wherereplace occurs */
	SRID	bm;				/* bookmark of this replace node */
	ULONG	fDIRFlags;		/* flags used in original DIR call */
	USHORT	cb;	 			/* data size/diff info */
	BYTE	fOld:1;			/* fTrue if before image is in szData */
	USHORT	cbOldData:15; 	/* before image data size, may be 0 */
	USHORT	cbNewData;		/* after image data size, == cb if not replaceC */
	CHAR	szData[0];		/* made line data for new (and old) record follow */
	} LRREPLACE;

typedef	struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	PROCID	procid;			/* user id of this log record */
	PN		pn;

	BYTE	itag;
	SRID	bm;
	USHORT	cbOldData;
	CHAR	szData[0];		/* for before image */
	} LRLOCKREC;
	
typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;

	BYTE	itag;
	SRID	bm;				/* bookmark of this delete node */
	ULONG	fDIRFlags;		/* flags used in original DIR call */
	} LRFLAGDELETE;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;

	BYTE	itag;
	} LRDELETE;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	
	PROCID	procid; 		/* user id of this log record */
	DBID	dbid;
	SRID	bm;
	BYTE	level;
	SHORT	cbDelta;
	SRID	bmTarget;		/* page being updated during undo operation */
	} LRFREESPACE;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	
	PROCID	procid; 		/* user id of this log record */
	DBID	dbid;
	SRID	bm;
	BYTE	level;
	UINT	oper;
	SRID	item;
	SRID	bmTarget;		/* the page being updated during undo operation */
	} LRUNDO;

/*	expunge link commit log record
/**/
typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;

	BYTE	itag;
	SRID	sridSrc;
	} LRELC;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;

	BYTE	itag;
	SRID	bm;				/* bookmark of this udpated node */
	BYTE	bHeader;
	} LRUPDATEHEADER;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of DB operations */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;				/* dbid + pgno */

#if ISRID
	WORD	isrid;			/* in case do version only */
#endif
	BYTE	itag;			/* of item list node */
	SRID	srid;			/* item to insert */
	SRID	sridItemList;	/* bookmark of first item list node */
	ULONG	fDIRFlags;		/* so far only one bit is used - fDIRVersion */
	} LRINSERTITEM;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of DB operations */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;				/* dbid + pgno */

	BYTE	itag;			/* item list */
	WORD	citem;			/* number of items to append */
	SRID	rgitem[0];
	} LRINSERTITEMS;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;

	BYTE	itag;			/* of item list node */
#if ISRID
	SHORT	isrid;
#else
	SRID	srid;			/* item to insert */
#endif
	SRID	sridItemList;	/* bookmark of first item list node */
	} LRFLAGITEM;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of DB operations */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;				/* dbid + pgno */

	WORD	cItem;
	BYTE	itagToSplit;	/* used only for verification!	*/
//	UNDONE:	review with Cheen Liao
//	SHORT	itagFather;	 	/* father's identity */
	BYTE	itagFather;	 	/* itag of father */
	BYTE	ibSon;	 		/* Position to insert in father's son table	*/
	ULONG	fFlags;			/* flag to indicate if it is append item */
	} LRSPLITITEMLISTNODE;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of DB operations */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;				/* dbid + pgno */

#if ISRID
	SHORT	isrid;
#else
	SRID	srid;			/* item to insert */
#endif
	BYTE	itag;			/* item list */
	SRID	sridItemList;	/* bookmark of first item list node */
	} LRDELETEITEM;
	
typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;

	BYTE	itag;			/* wherereplace occurs */
	SRID	bm;				/* bookmark of this replace node */
	LONG	lDelta;
	ULONG	fDIRFlags;		/* flags used in original DIR call */
	} LRDELTA;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* current flush counter of page */
	PROCID	procid; 		/* user id of this log record */
	PN		pn;

	SHORT	cbFreeTotal;
	SHORT	itagNext;
	} LRCHECKPAGE;
	
typedef struct
	{
	LRTYP	lrtyp;
	
	PROCID	procid;			/* user id of this log record */
	LEVEL	levelStart;		/* starting transaction levels */
	LEVEL	level;			/* transaction levels */
	} LRBEGIN;

typedef struct
	{
	LRTYP	lrtyp;
	
	PROCID	procid; 		/* user id of this log record */
	LEVEL	level;			/* transaction levels */
	} LRCOMMIT;

typedef struct
	{
	LRTYP	lrtyp;
	
	PROCID	procid; 		/* user id of this log record */
	LEVEL	levelAborted; 	/* transaction level */
	} LRABORT;

typedef struct
	{
	LRTYP	lrtyp;

	PROCID	procid;			/* user id of this log record, unused in V15 */
	DBID	dbid;
	BOOL	fLogOn;
	JET_GRBIT grbit;
	USHORT	cb;				/* data size */
	CHAR	szPath[0];		/* path name follows */
	} LRCREATEDB;

typedef struct
	{
	LRTYP	lrtyp;

	PROCID	procid;			/* user id of this log record, unused in V15 */
	DBID	dbid;
	BYTE	fLogOn;
	USHORT	cb;				/* data size */
	CHAR	szPath[0];		/* path name follows */
	} LRATTACHDB;

typedef struct
	{
	LRTYP	lrtyp;
	
	PROCID	procid;			/* user id of this log record, unused in V15 */
	DBID	dbid;
	BOOL	fLogOn;
	USHORT	cb;
	CHAR	szPath[0];		/* path name follows */
	} LRDETACHDB;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* flush counter of page being split */

	PROCID	procid;			/* user id of this log record */
	BYTE	splitt;			/* split type */
	BYTE	fLeaf;			/* split on leaf node */
	PN		pn;				/* page (focus) being split, includes dbid */
	PGNO	pgnoNew;		/* newly-allocated page no */
	PGNO	pgnoNew2;		/* newly-allocated page no */
	PGNO	pgnoNew3;		/* newly-allocated page no */
	PGNO	pgnoSibling;	/* newly-allocated page no */
	BYTE	itagSplit;		/* node at which page is being split */
	SHORT	ibSonSplit;		/* ibSon at which node is being split */
	BYTE	pgtyp;			/* page type of new page */

	PGNO	pgnoFather;		/* pgno of father node */
	SHORT	itagFather;		/* itag of father node, could be itagNil (3 bytes) */
	SHORT	itagGrandFather;/* itag of Grand father node, could be itagNil (3 bytes) */
	BYTE	ibSonFather;
	BYTE	cbklnk;			/* number of back links */
//	UNDONE:	review with Cheen Liao
//	SHORT	cbKey;
//	SHORT	cbKeyMac;
	BYTE	cbKey;
	BYTE	cbKeyMac;
	BYTE	rgb[0];
	} LRSPLIT;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* flush counter of page being split */
	PROCID	procid;			/* user id of this log record */
	PN		pn;				/* page pointer of empty page */

	PGNO	pgnoFather;
	SHORT	itag;			/* itag of page pointer */
//	UNDONE:	review with Cheen Liao
//	SHORT	itagFather;		/* father of page pointer */
	BYTE	itagFather;		/* itag of father of page pointer */
	SHORT	ibSon;
	
	PGNO	pgnoLeft;
	PGNO	pgnoRight;
	} LREMPTYPAGE;

typedef struct
	{
	LRTYP	lrtyp;

	PROCID	procid;

	PN		pn;				/* page pointer of merged page */
	PGNO	pgnoRight;		/* page appended to */

	ULONG	ulDBTime;
	
	BYTE	cbklnk;
	BYTE	rgb[0];
	} LRMERGE;

typedef struct
	{
	LRTYP	lrtyp;
	ULONG	ulDBTime;		/* flush counter of father FDP page */
	PROCID	procid;			/* user id of this log record */
	PN		pn;				/* FDP page */

	PGNO	pgnoFDPParent;	/* parent FDP */
	USHORT	cpgGot;			/* returned number of pages */
	USHORT	cpgWish;		/* request pages */
	} LRINITFDPPAGE;
	
typedef struct
	{
	LRTYP	lrtyp;
	
	USHORT ibForwardLink;
	USHORT isecForwardLink;
	
	USHORT ibBackLink;
	USHORT isecBackLink;
	
 	ULONG  ulCheckSum;
	} LRMS;

typedef struct
	{
	LRTYP	lrtyp;
	DBENV	dbenv;
	} LRSTART;
	
typedef struct
	{
	LRTYP	lrtyp;
	LGPOS	lgpos;				/* point back to last beginning of undo */
	LGPOS	lgposRedoFrom;
	BYTE	fHard;
	} LRQUITREC;
	
typedef struct
	{
	LRTYP	lrtyp;
	USHORT	cbPath;				/* backup path/restore path */
	BYTE	szData[0];
	} LRLOGRESTORE;
	

#ifdef HILEVEL_LOGGING
		
typedef struct
	{
	PROCID	procid;			/* user id of this log record */
	PGNO	pn;				/* Parent FDP, includes dbid */
	ULONG	flags;			/* flags for index */
	ULONG 	density;		/* initial load density for index */
	ULONG	timepage;		/* flush counter of father FDP page */
	USHORT	cbname;			/* index name length */
	USHORT	cbkey;			/* index info length */
							/* Index name and index info follow */
	} LRCREATEIDX;

//typedef struct
//	{
//	PROCID		procid;		/* user id of this log record */
//	PGNO		pgno;		/* first page of new extent	*/
//	ULONG		cpages;		/* number of pages in the extent */
//	PGNO		pgnoFDP;	/* FDP being extended */
//	PN			pnparent;	/* Parent FDP controlling the space, includes dbid */
//	ULONG		timepage;	/* flush counter of FDP page */
//	} EXTENDFDP;

//typedef struct
//	{									
//	PROCID		procid;		/* user id of this log record */
//	PGNO		pgno;	   	/* first page of freed extent */
//	ULONG		cpages;		/* number of pages in the extent */
//	PGNO		pgnoFDP; 	/* FDP being shrunk	*/
//	ULONG		timepage;	/* flush counter of parent FDP page */
//	PN			pnparent;	/* Parent FDP regaining the space, includes dbid*/
//	} LRSHRINKFDP;

#endif

#pragma pack()
	

#ifdef NOLOG

#define LGDepend( pbf, lgpos )

#define ErrLGInsert( pfucb, fHeader, pkey, plineData )	0
#define ErrLGInsertItemList( pfucb, fHeader, pkey, plineData )	0
#define ErrLGReplace( pfucb, pline, fFlags, cbData ) 0
#define ErrLGFlagDelete( pfucb, fFlags )	0
#deinfe ErrLGUpdateHeader( pfucb, bHeader ) 0
#define ErrLGInsertItem( pfucb, fDIRFlags )	0
#define ErrLGInsertItems( pfucb, rgitem, citem )	0
#define ErrLGFlagDeleteItem( pfucb )	0
#define ErrLGSplitItemListNode(	pfucb, cItem, itagFather, ibSon, itagToSplit, fFlags) 0
#define ErrLGDeleteItem( pfucb ) 		0
#define ErrLGDelta( pfucb, lDelta, fDIRFlags ) 0
#define ErrLGLockRecord( pfucb, cbData ) 0

#define ErrLGBeginTransaction( ppib, levelBeginFrom ) 0
#define ErrLGCommitTransaction( ppib, levelCommitTo ) 0
#define ErrLGAbort( ppib,levelsAborted ) 0
#define ErrLGUndo( prce ) 0
#define ErrLGFreeSpace( prce, cbDelta ) 0

#define ErrLGCreateDB( ppib, dbid, fLogOn, grbit, sz, cch ) 0
#define ErrLGAttachDB( ppib, dbid, fLogOn, sz, cch ) 0
#define ErrLGDetachDB( ppib, dbid, fLogOn, sz, cch ) 0

#define	ErrLGMerge( pfucb, psplit ) 0
#define ErrLGSplit( splitt, pfucb, pcsrPagePointer, psplit, pgtypNew ) 0
#define	ErrLGEmptyPage(	pfucbFather, prmpage ) 0
#define ErrLGInitFDPPage( pfucb, pgnoFDPParent, pnFDP, cpgGot, cpgWish) 0
#define ErrLGFlagInsertItem(pfucb) 0

#define ErrLGStart() 0
#define ErrLGQuit( plgposRecoveryUndo )	0
#define ErrLGRecoveryQuit1( plgposRecoveryUndo ) 0
#define ErrLGRecoveryUndo1( szRestorePath ) 0
#define ErrLGRecoveryQuit2( plgposRecoveryUndo ) 0
#define ErrLGRecoveryUndo2( szRestorePath ) 0
#define ErrLGFullBackup(szRestorePath ) 0
#define ErrLGIncBackup(szRestorePath ) 0

#define ErrLGCheckPage( pfucb, cbFreeTotal, itagNext ) 0

#else	/* !NOLOG */

#define ErrLGInsert( pfucb, fHeader, pkey, plineData)		\
	ErrLGInsertNode( lrtypInsertNode, pfucb, fHeader, pkey, plineData, 0)
#define ErrLGInsertItemList( pfucb, fHeader, pkey, plineData, fFlags)		\
	ErrLGInsertNode( lrtypInsertItemList, pfucb, fHeader, pkey, plineData, fFlags)
ERR ErrLGInsertNode( LRTYP lrtyp,
 	FUCB *pfucb, INT fHeader, KEY *pkey, LINE *plineData, INT fFlags);
ERR ErrLGReplace( FUCB *pfucb, LINE *pline, int fl, int cbData );
ERR ErrLGFlagDelete( FUCB *pfucb, INT fFlags);
ERR ErrLGUpdateHeader( FUCB *pfucb, INT bHeader );
ERR ErrLGInsertItem( FUCB *pfucb, INT fDIRFlags );
ERR ErrLGInsertItems( FUCB *pfucb, SRID *rgitem, INT citem );
ERR ErrLGFlagDeleteItem( FUCB *pfucb );
ERR ErrLGSplitItemListNode( FUCB *pfucb, INT cItem, INT itagFather,
 	INT ibSon, INT itagToSplit, INT fFlags );
ERR ErrLGDelta( FUCB *pfucb, LONG lDelta, INT fDIRFlags );
ERR ErrLGLockRecord( FUCB *pfucb, INT cbData );


ERR ErrLGBeginTransaction( PIB *ppib, INT levelBeginFrom );
ERR ErrLGCommitTransaction( PIB *ppib, INT levelCommitTo );
ERR ErrLGAbort( PIB *ppib, INT levelsAborted );
ERR ErrLGUndo( RCE *prce );
ERR ErrLGFreeSpace( RCE *prce, INT cbDelta );

ERR ErrLGCreateDB( PIB *ppib, DBID dbid, BOOL fLogOn, JET_GRBIT grbit, CHAR *sz, INT cch );
ERR ErrLGAttachDB( PIB *ppib, DBID dbid, BOOL fLogOn, CHAR *sz, INT cch );
ERR ErrLGDetachDB( PIB *ppib, DBID dbid, BOOL fLogOn, CHAR *sz, INT cch );

ERR ErrLGMerge( FUCB *pfucb, struct _split *psplit );
ERR ErrLGSplit( SPLITT splitt, FUCB *pfucb, CSR *pcsrPagePointer,
 	struct _split *psplit, PGTYP pgtypNew );

ERR ErrLGEmptyPage( FUCB *pfucbFather, RMPAGE *prmpage );
ERR ErrLGInitFDPPage( FUCB *pfucb, PGNO pgnoFDPParent,
 	PN pnFDP, INT cpgGot, INT cpgWish);

#define ErrLGFlagDeleteItem(pfucb) ErrLGFlagItem(pfucb, lrtypFlagDeleteItem)
#define ErrLGFlagInsertItem(pfucb) ErrLGFlagItem(pfucb, lrtypFlagInsertItem)
ERR ErrLGFlagItem(FUCB *pfucb, LRTYP lrtyp);
ERR	ErrLGDeleteItem( FUCB *pfucb );

ERR ErrLGDelete( FUCB *pfucb );
ERR ErrLGExpungeLinkCommit( FUCB *pfucb, SSIB *pssibSrc, SRID sridSrc );

ERR ErrLGStart();
#define ErrLGRecoveryQuit1( plgposRecoveryUndo, plgposRedoFrom, fHard )		\
 	ErrLGQuitRec( lrtypRecoveryQuit1, plgposRecoveryUndo,			\
						  plgposRedoFrom, fHard )
#define ErrLGRecoveryQuit2( plgposRecoveryUndo, plgposRedoFrom, fHard )		\
 	ErrLGQuitRec( lrtypRecoveryQuit2, plgposRecoveryUndo,			\
						  plgposRedoFrom, fHard )
#define ErrLGQuit( plgposStart )						\
 	ErrLGQuitRec( lrtypQuit, plgposStart, pNil, 0 )
ERR ErrLGQuitRec( LRTYP lrtyp, LGPOS *plgposQuit, LGPOS *plgposRedoFrom, BOOL fHard);

#define ErrLGRecoveryUndo1(szRestorePath)			\
 	ErrLGLogRestore(lrtypRecoveryUndo1, szRestorePath )
#define ErrLGRecoveryUndo2(szRestorePath)			\
 	ErrLGLogRestore(lrtypRecoveryUndo2, szRestorePath )
#define ErrLGFullBackup(szRestorePath)				\
 	ErrLGLogRestore(lrtypFullBackup, szRestorePath )
#define ErrLGIncBackup(szRestorePath)				\
 	ErrLGLogRestore(lrtypIncBackup, szRestorePath )
ERR ErrLGLogRestore( LRTYP lrtyp, CHAR * szLogRestorePath );

ERR ErrLGCheckPage( FUCB *pfucb, SHORT cbFreeTotal, SHORT itagNext );

#endif			/* logging enabled	*/

ERR ISAMAPI ErrIsamRestore( CHAR *szRestoreFromPath,
	INT crstmap, JET_RSTMAP *rgrstmap, JET_PFNSTATUS pfn );

ERR ErrLGSoftStart( BOOL fAllowNoJetLog );

ERR ErrLGInit( VOID );
ERR ErrLGTerm( VOID );
ERR ErrLGLogRec( LINE *rgline, INT cline, PIB *ppib );
ERR ErrLGEndAllSessions( BOOL fSysDbOnly, BOOL fEndOfLog, LGPOS *plgposRedoFrom );
ERR ErrLGInitLogBuffers( LONG lIntendLogBuffers );
INT CmpLgpos(LGPOS *plgpos1, LGPOS *plgpos2);
ULONG UlLGMSCheckSum( CHAR *pbLrmsNew );

#define FLGOn()		(!fLogDisabled)
#define FLGOff()	(fLogDisabled)

BOOL FIsNullLgpos( LGPOS *plgpos );
VOID LGMakeLogName( CHAR *szLogName, CHAR *szFName );



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\nver.h ===
/*	node status returned from VERAccess
/**/
typedef enum
	{
	nsVersion,
	nsVerInDB,
	nsDatabase,
	nsInvalid
	} NS;

/*	version status
/*	returned from VERCheck
/**/
typedef enum
	{
	vsCommitted,
	vsUncommittedByCaller,
	vsUncommittedByOther
	} VS;

// ===========================================================================
// RCE (RC Entry)

/*	operation type
/**/
typedef UINT OPER;

#define	operReplace				0
#define	operInsert				1
#define	operFlagDelete			2
#define	operNull				3	// to nullify an RCE

#define	operExpungeLink			4
#define	operExpungeBackLink		5
#define	operWriteLock			6
#define	operAllocExt 			7
#define	operDeferFreeExt 		8
#define	operDelete				9	// a real delete

#define	operDelta				0x00000010

#define	operMaskItem			0x00000100
#define	operInsertItem			0x00000100
#define	operFlagInsertItem		0x00000300
#define	operFlagDeleteItem		0x00000500

#define	operMaskDDL				0x00001000
#define	operCreateTable	 		0x00001000
#define	operDeleteTable			0x00003000
#define	operRenameTable			0x00005000
#define	operAddColumn			0x00007000
#define	operDeleteColumn		0x00009000
#define	operRenameColumn		0x0000b000
#define	operCreateIndex	 		0x0000d000
#define	operDeleteIndex	 		0x0000f000
#define	operRenameIndex			0x00011000

/*	create table:	table pgnoFDP
/*	rename table:	before image table name
/*	add column:		before image pfdb, NULL if not first DDL at level
/*	delete column:	before image pfdb, NULL if not first DDL at level
/*	rename column:	before image column name
/*	create index:	index pgnoFDP
/*	delete index:	index pfcb
/*	rename index:	before image index name
/**/

#define FOperDDL( oper )	 	( (oper) & operMaskDDL )
#define FOperItem( oper )	 	( (oper) & operMaskItem )

typedef struct _rce
	{
	struct _rce		*prceHeadNext;			// next rce ListHead in hash over flow list
	struct _rce		*prcePrev;				// previous versions, lower trx
	USHORT			ibUserLinkBackward;		// link back to older RCE in bucket 
	DBID			dbid;  					// database id of node
	SRID			bm;						// bookmark of node
	TRX				trxPrev;				// time when previous RCE is committed
	TRX				trxCommitted; 			// time when this RCE is committed
	OPER			oper;					// operation that causes creation of RCE
	LEVEL			level;					// current level of RCE, can change
	WORD			cbData;					// length of data portion of node
	FUCB			*pfucb;					// for undo
	FCB				*pfcb;					// for clean up
	
	SRID			bmTarget;			 	// for recovery
	ULONG			ulDBTime;
	
	BYTE			rgbData[0];			 	// storing the data portion of a node
	} RCE;

/* first 2 SHORTs of rgbData are used to remember cbMax and cbAdjust for
 * each replace operation.
 */
#define cbReplaceRCEOverhead    (2 * sizeof(SHORT))


//============================================================================
// bucket

#define cbBucketHeader \
		( 2 * sizeof(struct _bucket *) + sizeof( USHORT ) )

#define cbBucket				16384	// number of bytes in a bucket
//#define cbBucket					8192	// number of bytes in a bucket

typedef struct _bucket
	{
	struct _bucket	*pbucketPrev;		// prev bucket for same user
	struct _bucket	*pbucketNext;		// next bucket for same user
 	USHORT			ibNewestRCE;		// newest RCE within bucket
	BYTE				rgb[ cbBucket - cbBucketHeader ];
	// space for storing RCEs
	} BUCKET;

#define PbucketMEMAlloc()					((BUCKET *)PbMEMAlloc(iresVersionBucket) )

#ifdef DEBUG /*  Debug check for illegal use of freed pbucket  */
#define MEMReleasePbucket(pbucket)		{ MEMRelease( iresVersionBucket, (BYTE*)(pbucket) ); pbucket = pbucketNil; }
#else
#define MEMReleasePbucket(pbucket)		{ MEMRelease( iresVersionBucket, (BYTE*)(pbucket) ); }
#endif

/*	free extent parameter block
/**/
typedef struct {
	PGNO	pgnoFDP;
	PGNO	pgnoChildFDP;
	PGNO	pgnoFirst;
	CPG	cpgSize;
	} VEREXT;

/*	rename rollback parameter block
/**/
typedef struct {
	CHAR	szName[ JET_cbNameMost + 1 ];
	CHAR	szNameNew[ JET_cbNameMost + 1 ];
	} VERRENAME;

/*	ErrRCECleanPIB flags
/**/
#define	fRCECleanAll	(1<<0)

ERR ErrVERInit( VOID );
VOID VERTerm( VOID );
VS VsVERCheck( FUCB *pfucb, SRID bm );
NS NsVERAccessNode( FUCB *pfucb, SRID bm );
NS NsVERAccessItem( FUCB *pfucb, SRID bm );
ERR FVERUncommittedVersion( FUCB *pfucb, SRID bm );
ERR FVERDelta( FUCB *pfucb, SRID bm );
ERR ErrVERCreate( FUCB *pfucb, SRID bm, OPER oper, RCE **pprce );
ERR ErrVERModify( FUCB *pfucb, SRID bm, OPER oper, RCE **pprce);
BOOL FVERNoVersion( DBID dbid, SRID bm );
ERR ErrRCECleanPIB( PIB *ppibAccess, PIB *ppib, INT fRCEClean );
ERR ErrRCECleanAllPIB( VOID );
ERR ErrVERBeginTransaction( PIB *ppib );
VOID VERPrecommitTransaction( PIB *ppib );
VOID VERCommitTransaction( PIB *ppib );
ERR ErrVERRollback(PIB *ppib);
RCE *PrceRCEGet( DBID dbid, SRID bm );
#define fDoNotUpdatePage	fTrue
#define fDoUpdatePage		fFalse
VOID VERSetCbAdjust(FUCB *pfucb, RCE *prce, INT cbDataNew, INT cbData, BOOL fNotUpdatePage );
INT CbVERGetCbReserved( RCE *prce );
INT CbVERGetNodeMax( FUCB *pfucb, SRID bm );
INT CbVERGetNodeReserve( FUCB *pfucb, SRID bm );

#define ErrVERReplace( pfucb, srid, pprce ) 	ErrVERModify( pfucb, srid, operReplace, pprce )
#define ErrVERInsert( pfucb, srid )				ErrVERCreate( pfucb, srid, operInsert, pNil )
#define ErrVERFlagDelete( pfucb, srid ) 	 	ErrVERModify( pfucb, srid, operFlagDelete, pNil )
#define ErrVERInsertItem( pfucb, srid ) 		ErrVERCreate( pfucb, srid, operInsertItem, pNil )
#define ErrVERFlagInsertItem( pfucb, srid ) 	ErrVERModify( pfucb, srid, operFlagInsertItem, pNil )
#define ErrVERFlagDeleteItem( pfucb, srid ) 	ErrVERModify( pfucb, srid, operFlagDeleteItem, pNil )
#define ErrVERDelta( pfucb, srid )			 	ErrVERModify( pfucb, srid, operDelta, pNil )

#define ErrVERDeferFreeFDP( pfucb, pgno ) 		ErrVERFlag( pfucb, operDeferFreeFDP, &pgno, siozeof(pgno) )

#define	FVERPotThere( vs, fDelete )						  		\
	( ( (vs) != vsUncommittedByOther && !(fDelete) ) ||	  		\
		(vs) == vsUncommittedByOther )

ERR ErrVERFlag( FUCB *pfucb, OPER oper, VOID *pv, INT cb );
VOID VERDeleteRce( RCE *prce );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\os.h ===
/*************************	OS Types *************************
/**/
typedef unsigned long	TID;
#define handleNil			((HANDLE)(-1))

/*	operating system dependent
/**/
#ifdef WIN32
typedef void *				HANDLE;
#else
typedef unsigned int		HANDLE;
#endif

#define OffsetOf(p)		((ULONG_PTR) p)
#define IndexOf(p)		(OffsetOf((ULONG_PTR) p)/sizeof(*(p)))

#define VOID				void
#ifndef CHAR
typedef char				CHAR;
#endif
typedef unsigned char	UCHAR;
typedef unsigned char	BYTE;
#ifndef SHORT
typedef short				SHORT;
#endif
typedef unsigned short	USHORT;
typedef unsigned short	WORD;
#ifndef INT
typedef int					INT;
#endif
typedef unsigned int		UINT;

#if defined(_ALPHA_) || defined(_AXP64_) || defined(_IA64_) || defined(_AMD64_)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif

/*************************	SysSetThreadPriority *************************
/**/
#define lThreadPriorityNormal			0
#define lThreadPriorityEnhanced		1
#define lThreadPriorityCritical		2

/****************************	SYSTEM PROVIDED ***************************
/**/
#ifndef _WINDOWS_

#ifdef WIN32

#ifndef LONG
typedef int					LONG;
#endif
typedef unsigned			ULONG;
typedef unsigned long	DWORD;

#else

#ifndef LONG
typedef long				LONG;
#endif
typedef unsigned long	ULONG;
typedef unsigned long	DWORD;

#endif

#undef  FILE_BEGIN
#undef  FILE_CURRENT
#undef  FILE_END
#define FILE_BEGIN				0x0000
#define FILE_CURRENT				0x0001
#define FILE_END					0x0002

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\info.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	   info.h: DAE Info Commands		===================

ERR ErrFILEGetColumnId( PIB *ppib, FUCB *pfucb, const CHAR *szColumn, JET_COLUMNID *pcolumnid );

// ===================== EXPOSED CLIENT API ======================
ERR VDBAPI ErrIsamGetObjectInfo(
	JET_VSESID		vsesid,
	JET_DBID 		dbid,
	JET_OBJTYP 		objtyp,
	const char 		*szContainerName,
	const char 		*szObjectName,
	OLD_OUTDATA		*poutdata,
	unsigned long	lInfoLevel );

ERR VTAPI ErrIsamGetTableInfo( 
	JET_VSESID		vsesid,
	JET_VTID			vtid,
	void				*pbOut, 
	unsigned long	cbOutMax, 
	unsigned long	lInfoLevel );

ERR VDBAPI ErrIsamGetColumnInfo( 
	JET_VSESID		vsesid,
	JET_DBID			vdbid,
	const char		*szTable,
	const char		*szColumnName,
	OLD_OUTDATA		*poutdata,
	unsigned long	lInfoLevel );

ERR VTAPI ErrIsamGetTableColumnInfo( 
	JET_VSESID		vsesid,
	JET_VTID    	vtid,
	const char		*szColumn,
	void 				*pb, 
	unsigned long	cbMax, 
	unsigned long	lInfoLevel );

ERR VDBAPI ErrIsamGetIndexInfo( 
	JET_VSESID		vsesid,
	JET_DBID			vdbid,
	const char 		*szTable,
	const char		*szIndexName,
	OLD_OUTDATA		*poutdata,
	unsigned long 	lInfoLevel );

ERR VTAPI ErrIsamGetTableIndexInfo( 
	JET_VSESID		vsesid,
	JET_VTID			vtid,
	const char		*szIndex,
	void 				*pb, 
	unsigned long	cbMax, 
	unsigned long	lInfoLevel );

ERR VDBAPI ErrIsamGetDatabaseInfo( 
	JET_VSESID		vsesid, 
	JET_DBID			vdbid, 
	void 				*pv, 
	unsigned long	cbMax, 
	unsigned long	ulInfoLevel );

ERR VTAPI ErrIsamGetSysTableColumnInfo( 
	PIB				*ppib, 
	FUCB				*pfucb, 
	char				*szColumnName, 
	OUTLINE			*pout, 
	long				lInfoLevel );

ERR VTAPI ErrIsamInfoRetrieveColumn(
	PIB				*ppib,
	FUCB				*pfucb,
	JET_COLUMNID	columnid, 
	void				*pb, 
	unsigned long	cbMax, 
	unsigned long	*pcbActual, 
	JET_GRBIT		grbit, 
	JET_RETINFO		*pretinfo );

ERR VTAPI ErrIsamInfoSetColumn(	
	PIB				*ppib,
	FUCB				*pfucb,
	JET_COLUMNID	columnid, 
	const void		*pbData,
	unsigned long	cbData,
	JET_GRBIT		grbit,
	JET_SETINFO		*psetinfo );

ERR VTAPI ErrIsamInfoUpdate( 
	JET_VSESID		vsesid, 
	JET_VTID			vtid, 
	void 				*pb, 
	unsigned long 	cbMax,
	unsigned long 	*pcbActual );

ERR VTAPI ErrIsamGetCursorInfo( 
	JET_VSESID		vsesid, 
	JET_VTID			vtid, 
	void 				*pvResult, 
	unsigned long 	cbMax, 
	unsigned long 	InfoLevel );

ERR VTAPI ErrIsamGetRecordPosition(	
	JET_VSESID		vsesid, 
	JET_VTID			vtid,
	JET_RECPOS 		*precpos, 
	unsigned long	cbRecpos );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\log.h ===
#include <stdlib.h>						/* for _MAX_PATH */
#include <time.h>

#pragma pack(1)

//#define OVERLAPPED_LOGGING			/* which Logging to use? */
#define CHECK_LG_VERSION
extern	BOOL	fLGIgnoreVersion;

extern	CHAR	szDrive[];
extern	CHAR	szDir[];
extern	CHAR	szExt[];
extern	CHAR	szFName[];
extern	CHAR	szLogName[];

extern	CHAR	*szLogCurrent;
extern	CHAR	szLogFilePath[];
extern	CHAR	szRestorePath[];
extern	CHAR	szRecovery[];
	
extern	OLP		rgolpLog[];
extern	SIG		rgsig[];

extern	CODECONST(char)	szJet[];
extern	CODECONST(char)	szJetTmp[];
extern	CODECONST(char)	szLogExt[];


#define cbMaxLogFileName	(8 + 1 + 3 + 1) /* null at the end */

#define PbSecAligned(pb)	((((pb)-pbLGBufMin) / cbSec) * cbSec + pbLGBufMin)


//------ types ----------------------------------------------------------

#define MAX_COMPUTERNAME_LENGTH 15

typedef struct
	{
	BYTE		bSeconds;				// 0 - 60
	BYTE		bMinutes;				// 0 - 60
	BYTE		bHours;					// 0 - 24
	BYTE		bDay;					// 1 - 31
	BYTE		bMonth;					// 0 - 11
	BYTE		bYear;					// Current year - 1900
	} LOGTIME;

#define FSameTime( ptm1, ptm2 ) (memcmp((ptm1), (ptm2), sizeof(LOGTIME)) == 0)
VOID LGGetDateTime( LOGTIME *plogtm );

/* log file header */
typedef struct
	{
	ULONG			ulChecksum;			// Must be the first 4 bytes

	LGPOS			lgposFirst;			// 1st log record starts.
	LGPOS			lgposLastMS;		// last recorded multi-sec flush LogRec
	LGPOS			lgposFirstMS;		// 1st recorded multi-sec flush LogRec
	LGPOS			lgposCheckpoint;	// check point
	BOOL			fEndWithMS;			// normal end of a generation.
	
	LOGTIME			tmCreate;			// date time log file creation
	LOGTIME			tmPrevGen;			// date time prev log file creation

	ULONG			ulRup;				// typically 2000
	ULONG			ulVersion;			// of format: 125.1
	BYTE			szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DBENV			dbenv;

	LGPOS			lgposFullBackup;
	LOGTIME			logtimeFullBackup;

	LGPOS			lgposIncBackup;
	LOGTIME			logtimeIncBackup;

	} FHDRUSED;

typedef struct
	{
	FHDRUSED;
	BYTE			rgb[ cbSec - sizeof( FHDRUSED ) ];
	} LGFILEHDR;

	
//------ variables ----------------------------------------------------------

/****** globals declared in log.c, shared by logapi.c redo.c *******/
	
/*** log file infor ***/
extern HANDLE		hfLog;			/* logfile handle */
extern INT			csecLGFile;
extern LGFILEHDR	*plgfilehdrGlobal;		/* cached current log file header */

/*** in memory log buffer ***/
extern INT	csecLGBuf;		/* available buffer, exclude the shadow sec */
extern CHAR	*pbLGBufMin;
extern CHAR	*pbLGBufMax;
extern CHAR	*pbLastMSFlush;	/* to LGBuf where last multi-sec flush LogRec sit*/
extern LGPOS lgposLastMSFlush;

extern BYTE			*pbEntry;
extern BYTE			*pbWrite;
extern INT			isecWrite;		/* next disk to write. */

extern BYTE			*pbNext;
extern BYTE			*pbRead;
extern INT			isecRead;		/* next disk to Read. */
extern LGPOS		lgposLastRec;	/* setinal for last log record for redo */

/*** log record position ***/
extern LGPOS lgposLogRec;	/* last log record entry, updated by ErrLGLogRec */
extern LGPOS lgposToFlush;	/* next point starting the flush. Right after */
							/* lgposLogRec. */

extern LGPOS	lgposFullBackup;
extern LOGTIME	logtimeFullBackup;

extern LGPOS	lgposIncBackup;
extern LOGTIME	logtimeIncBackup;

extern LGPOS lgposStart;	/* last log start position */

// logging MUTEX
extern CRIT __near critLGFlush;
extern CRIT __near critLGBuf;
extern CRIT __near critLGWaitQ;
extern SIG	__near sigLogFlush;

// logging EVENT
extern SIG __near sigLGFlush;


//------ log.c --------------------------------------------------------------

ERR ErrLGWrite(	int isecOffset,	BYTE *pbData, int csecData );
ERR ErrLGRead( HANDLE hfLog, int ibOffset, BYTE *pbData, int csec );
ERR ErrLGReadFileHdr( HANDLE hfLog, LGFILEHDR *plgfilehdr );

VOID LGSzFromLogId( CHAR *rgbLogFileName, int usGeneration );

extern BOOL fJetLogGeneratedDuringSoftStart;
#define fOldLogExists		1
#define fOldLogNotExists	2
#define fOldLogInBackup		4
ERR ErrLGNewLogFile( int usGeneration, BOOL fOldLog );

VOID 	LGFlushLog( VOID );
#ifdef PERFCNT
ERR ErrLGFlushLog( int tidCaller );
#else
ERR ErrLGFlushLog( VOID );
#endif

//------ redo.c -------------------------------------------------------------

/*	corresponding pointer to process information block
/**/
typedef struct
	{
	PROCID	procid;
	PIB		*ppib;
	FUCB	*rgpfucbOpen[dbidUserMax];		
	} CPPIB;
extern CPPIB *rgcppib;		/* array of pibs-procids during Redo */

//------ macros -----------------------------------------------------

/*	redo operations are valid on the system database on the first
/*	pass.  Redo operations are valid on any database for which the
/*	flag is 0 or greater.  This is to handle the case where
/*		1)	plain log records are found		( 0 )
/*		2)	create for the first time		( 1 )
/*		3)	detach and attach/create		( 0 )
/**/
#define	FValidDatabase( dbid )										\
		( dbid == dbidSystemDatabase || rgfDatabase[dbid] > 0 || fHardRestore )

//------ debug code --------------------------------------------------------

#ifdef	DEBUG
#define FlagUsed( pb, cb )	memset( pb, 'x', cb )
#else	/* !DEBUG */
#define FlagUsed( pb, cb )
#endif	/* !DEBUG */

//------ function headers ---------------------------------------------------
ERR ErrLGRedoable( PIB *ppib, PN pn, ULONG ulDBTime, BF **ppbf, BOOL *pfRedoable );
ERR ErrLGRedo1( LGPOS *plgposRedoFrom );
ERR ErrLGRedo2( LGPOS *plgposRedoFrom );
ERR ErrLGRedoOperations( LGPOS *plgposRedoFrom, BOOL fSysDb );
INT CbLGSizeOfRec( LR * );
ERR ErrLGCheckReadLastLogRecord(	LGPOS *plgposLastMS, BOOL *pfCloseNormally );
ERR ErrLGLocateFirstRedoLogRec( LGPOS *plgposLastMS, LGPOS *plgposFirst, BYTE **ppbLR );
ERR ErrLGGetNextRec( BYTE ** );
VOID LGLastGeneration( char *szSearchPath, int *piGeneration );

VOID AddLogRec(	BYTE *pb, INT cb, BYTE **ppbET);
VOID LGUpdateCheckpoint( VOID );
VOID GetLgposOfPbEntry( LGPOS *plgpos );
VOID GetLgposOfPbNext(LGPOS *plgpos);

#define fNoProperLogFile	1
#define fRedoLogFile		2
#define fNormalClose		3
ERR ErrOpenRedoLogFile( LGPOS *plgposRedoFrom, int *pfStatus );
ERR ErrLGWriteFileHdr(LGFILEHDR *plgfilehdr);
ERR ErrLGMiniOpenSystemDB();
ULONG UlLGHdrChecksum( LGFILEHDR *plgfilehdr );

#ifdef	DEBUG
VOID ShowData( BYTE *pbData, WORD cbData );
VOID PrintLgposReadLR(VOID);
VOID ShowLR( LR	*plr );
#else
#define ShowLR(	plr )			0
#endif	/* !DEBUG */


#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\pib.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	pib.h: Process Information Block	===================

/*	JET API flags
/**/
#define	FPIBVersion( ppib )	 					(!((ppib)->grbit & (JET_bitCIMCommitted | JET_bitCIMDirty)))
#define	FPIBCommitted( ppib ) 					((ppib)->grbit & JET_bitCIMCommitted)
#define	FPIBDirty( ppib ) 						((ppib)->grbit & JET_bitCIMDirty)
#define	FPIBAggregateTransaction( ppib )	 	((ppib)->grbit & JET_bitAggregateTransaction)

//
// Process Information Block
//
struct _pib
	{
	/*	most used field has offset 0
	/**/
	TRX					trx;					// trx id

	BOOL				fUserSession;			// user session

	/*	JET API fields
	/**/
	JET_SESID			sesid;					// JET session id
	JET_GRBIT			grbit;					// session flags
	
	struct _pib			*ppibNext;				// PIB list
	LEVEL			 	level;				 	// transaction level of this session
	struct _dab			*pdabList;				// list of open DAB's of this thread
	USHORT				rgcdbOpen[dbidUserMax];	// counter for open databases
	struct _fucb		*pfucb;	 				// list of active fucb of this thread

	/*	logging/recovery fields
	/**/
	PROCID  		 	procid;				 	// thread id
	LGPOS			 	lgposStart;				// log time
	LEVEL			 	levelStart;				// transaction level when first begin transaction operation
	INT				 	clgOpenT;				// count of deferred open transactions
	SIG				 	sigWaitLogFlush;
	LONG				lWaitLogFlush;
	struct _pib			*ppibNextWaitFlush;
	struct _pib			*ppibPrevWaitFlush;
	LGPOS				*plgposCommit;

	/*	PIB flags
	/**/
	BOOL			 	fAfterFirstBT:1;  		// for redo only
	BOOL			 	fLogDisabled:1; 		// temporary turn off the logging
	BOOL			 	fLGWaiting:1;	 		// waiting for log to flush
	BOOL				fDeferFreeNodeSpace:1;	// session has deferred node free space

	/*	version store fields
	/**/
	struct _bucket		volatile *pbucket;
	struct _rc			*prcLast; 				// last node of this proc's RC list
	INT					ibOldestRCE;

#ifdef	WIN16
	struct _pha 		*phaUser; 	 			// pointer to User Handle Array
#endif	/* WIN16 */
	};

#define PpibMEMAlloc()			(PIB*)PbMEMAlloc(iresPIB)

#ifdef DEBUG /*  Debug check for illegal use of freed pib  */
#define MEMReleasePpib(ppib)	{ MEMRelease(iresPIB, (BYTE*)(ppib)); ppib = ppibNil; }
#else
#define MEMReleasePpib(ppib)	{ MEMRelease(iresPIB, (BYTE*)(ppib)); }
#endif

/*	CheckPIB macro.
/**/
#ifdef	WIN16

#define CheckPIB(ppib)												\
		{															\
		Assert( fRecovering || OffsetOf(ppib) == ppib->procid );	\
		rghfUser = ppib->phaUser->rghfDatabase; 					\
		hfLog    = ppib->phaUser->hfLog;							\
		}

#else	/* !WIN16 */

#define CheckPIB(ppib)												\
	Assert( ( fRecovering || OffsetOf(ppib) == ppib->procid ) &&	\
		(ppib)->level < levelMax )

#endif	/* !WIN16 */

#define	FPIBDeferFreeNodeSpace( ppib )			( (ppib)->fDeferFreeNodeSpace )
#define	PIBSetDeferFreeNodeSpace( ppib )		( (ppib)->fDeferFreeNodeSpace = fTrue )
#define	PIBResetDeferFreeNodeSpace( ppib )		( (ppib)->fDeferFreeNodeSpace = fFalse )

#define FPIBActive( ppib )						( (ppib)->level != levelNil )

#define	SesidOfPib( ppib )						( (ppib)->sesid )

/*	prototypes
/**/
ERR ErrPIBBeginSession( PIB **pppib );
VOID PIBEndSession( PIB *ppib );
#ifdef DEBUG
VOID PIBPurge( VOID );
#else
#define PIBPurge()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\recint.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============   recint.h: Record Manager Internals	===================

#define cbLVIntrinsicMost		1024
#define cbRECRecordMost			cbNodeMost - cbNullKeyData - JET_cbKeyMost
								// 4044 - 8 - 255 = 3781

#define fidFixedLeast			1
#define fidVarLeast				128
#define fidTaggedLeast			256
#define fidTaggedMost			(0x7fff)
#define fidFixedMost  			(fidVarLeast-1)
#define fidVarMost				(fidTaggedLeast-1)

#define FFixedFid(fid)			((fid)<=fidFixedMost && (fid)>=fidFixedLeast)
#define FVarFid(fid)			((fid)<=fidVarMost && (fid)>=fidVarLeast)
#define FTaggedFid(fid)			((fid)<=fidTaggedMost && (fid)>=fidTaggedLeast)

//	Used to get offset from 2-byte VarOffset which includes null-bit
#define ibVarOffset(ibVarOffs)	( (ibVarOffs) & 0x0fff)
#define FVarNullBit(ibVarOffs)	( (ibVarOffs) & 0x8000)
#define SetNullBit(ibVarOffs)  	( (ibVarOffs) |= 0x8000)
#define ResetNullBit(ibVarOffs)	( (ibVarOffs) &= 0x7fff)

// Used to flip highest bit of signed fields when transforming.
#define maskByteHighBit			(1 << (sizeof(BYTE)*8-1))
#define maskWordHighBit			(1 << (sizeof(WORD)*8-1))
#define maskDWordHighBit		(1L << (sizeof(ULONG)*8-1))
#define bFlipHighBit(b)			((BYTE)((b) ^ maskByteHighBit))
#define wFlipHighBit(w)			((WORD)((w) ^ maskWordHighBit))
#define ulFlipHighBit(ul)		((ULONG)((ul) ^ maskDWordHighBit))


/* The following are disk structures -- so pack 'em
/**/
#pragma pack(1)

/*	long column id is big-endian long
/**/
typedef LONG	LID;

/*	long value column in record format
/**/
typedef struct
	{
	BYTE	fSeparated;
	union
		{
		LID		lid;
		BYTE	rgb[];
		};
	} LV;

/*	long value root data format
/**/
typedef struct
	{
	ULONG		ulReference;
	ULONG		ulSize;
	} LVROOT;

#pragma pack()

#define	fIntrinsic				(BYTE)0
#define	fSeparate				(BYTE)1
#define	FFieldIsSLong( pb )		( ((LV *)(pb))->fSeparated )
#define	LidOfLV( pb ) 			( ((LV *)(pb))->lid )
#define	FlagIntrinsic( pb )		( ((LV *)(pb))->fSeparated = fIntrinsic )
#define	FlagSeparate( pb )		( ((LV *)(pb))->fSeparated = fSeparate )

#define	fLVReference			0
#define	fLVDereference			1
#define ErrRECResetSLongValue( pfucb, plid )							\
	ErrRECAffectSeparateLV( pfucb, plid, fLVDereference )
#define ErrRECReferenceLongValue( pfucb, plid )						\
	ErrRECAffectSeparateLV( pfucb, plid, fLVReference )
#define ErrRECDereferenceLongValue( pfucb, plid )					\
	ErrRECAffectSeparateLV( pfucb, plid, fLVDereference )

/* The following are disk structures -- so pack 'em
/**/
#pragma pack(1)

// Record header (beginning of every data record)
typedef struct _rechdr
	{
	BYTE	fidFixedLastInRec;	// highest fixed fid represented in record
	BYTE	fidVarLastInRec;	// highest var fid represented in record
	} RECHDR;

// Structure imposed upon a tagged field occurance in a record
typedef struct _tagfld
	{
	FID  	fid;				// field id of occurance
	WORD	cb;					// length of following data
	BYTE	rgb[];				// data (extends off the end of the structure)
	} TAGFLD;

#pragma pack()

ULONG UlChecksum( BYTE *pb, ULONG cb );
ERR ErrRECChangeIndex( FUCB *pfucb, CHAR *szIndex );
BOOL FRECIIllegalNulls( FDB *pfdb, LINE *plineRec );
ERR ErrRECIRetrieve( FUCB *pfucb, FID *pfid, ULONG itagSequence, LINE *plineField, ULONG grbit );
BOOL FOnCopyBuffer( FUCB *pfucb );
ERR ErrRECIModifyField( FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField );

ERR ErrRECSetLongField(
	FUCB 		*pfucb,
	FID 		fid,
	ULONG		itagSequence,
	LINE		*plineField,
	JET_GRBIT	grbit,
	LONG		ibOffset,
	ULONG		ulMax );
ERR ErrRECRetrieveSLongField(
	FUCB		*pfucb,
	LID			lid,
	ULONG		ibGraphic,
	BYTE		*pb,
	ULONG		cbMax,
	ULONG		*pcbActual );
ERR ErrRECDeleteLongFields( FUCB *pfucb, LINE *plineRecord );
ERR ErrRECAffectLongFields( FUCB *pfucb, LINE *plineRecord, INT fAll );

#define	fSeparateAll				(INT)0
#define	fReference					(INT)1
#define	fDereference				(INT)2
#define	fDereferenceRemoved	 		(INT)3
#define	fDereferenceAdded	 		(INT)4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\page.h ===
//
//------ Page Structure ---------------------------------------------------
//
										  	
#define cbPage				4096			// database logical page size

#define cbSec				4096 			// minimum disk Read/Write unit. It
											// should be 512, but MIPS NT cache
											// bug force it be 1024.

#define ctagMax		 	256 			// default limit on number of tags
										 	
#define fNoTagLimit	 	(1<<0) 		// ignore limit on number of tags
#define fUseNewTag	 	(1<<1)	 	// don't reuse tags

typedef BYTE	PGTYP;

// the pragma is bad for efficiency, but we need it here so that the
// THREEBYTES will not be aligned on 4-byte boundary
#pragma pack(1)

typedef struct _pghdr
	{
	ULONG			ulChecksum;				// checksum of page, always 1st byte
	ULONG			ulDBTime;				// dbCounter when page was dirtied
	PGNO			pgnoFDP;					//	pgno of FDP which owns this page
	SHORT			cbFreeTotal;			// total free bytes
	SHORT			ibLastUsed;				// lower bound on used bytes
	SHORT			ctagMac; 				// upper bound on used tags
	SHORT			itagFree;				// start of tag free tags
	SHORT			cVersion;				// count of nodes with fVersion flag set
	THREEBYTES	pgnoPrev;				//	pgno of previous page
	THREEBYTES	pgnoNext;				//	pgno of next page
	} PGHDR;

typedef struct _pgtrlr
	{
	PGTYP			pgtyp;
	THREEBYTES		pgnoThisPage;
	} PGTRLR;

typedef struct _tag
	{
	SHORT		cb;
	SHORT		ib;
	} TAG;

/* tag status
/**/
typedef enum { tsLine, tsVacant, tsLink } TS;

typedef struct _page
	{
	PGHDR			pghdr;
	TAG  			rgtag[1];
	BYTE			rgbFiller[ cbPage -
					   sizeof(PGHDR) -			// pghdr
					   sizeof(TAG) -				// rgtag[1]
					   sizeof(BYTE) -				// rgbData[1]
					   sizeof(PGTYP) -			// pgtyp
						sizeof(THREEBYTES) ];	// pgnoThisPage
	BYTE			rgbData[1];
	PGTYP			pgtyp;
	THREEBYTES	pgnoThisPage;
	} PAGE;

#pragma pack()

#define bitModified			(1<<7)
#define bitLink				(1L<<31)

#define pgtypFDP				((PGTYP) 0)
#define pgtypRecord			((PGTYP) 1)
//	#define pgtypLong			((PGTYP) 2)
// #define pgtypNonrecord	((PGTYP) 3)
#define pgtypSort				((PGTYP) 4)

#define PMSetPageType( ppage, pgtypT )	( (ppage)->pgtyp = pgtypT )
#define PgtypPMPageTypeOfPage( ppage )	((PGTYP)((ppage)->pgtyp & ~(bitModified)))

#ifdef DEBUG
VOID PMSetModified( SSIB *ssib );
VOID PMResetModified( SSIB *pssib );
VOID CheckPgno( PAGE *ppage, PN pn );
#else
#define CheckPgno( ppage, pn )
#define PMSetModified( pssib )			( (pssib)->pbf->ppage->pgtyp |= bitModified )
#define PMResetModified( pssib ) 		( (pssib)->pbf->ppage->pgtyp &= ~(bitModified) )
#endif

#define PgtypPMSetModified( ppage )		( (ppage)->pgtyp | bitModified )
#define FPMModified( ppage )		  		( (ppage)->pgtyp & bitModified )

#define PMSetPgnoFDP( ppage, pgnoT )	( (ppage)->pghdr.pgnoFDP = pgnoT )
#define PgnoPMPgnoFDPOfPage( ppage )  	( (ppage)->pghdr.pgnoFDP )

#define PMIncVersion( ppage )				( (ppage)->pghdr.cVersion++ )
#if 0
#define PMDecVersion( ppage )						\
	{														\
	Assert( (ppage)->pghdr.cVersion > 0 );		\
	(ppage)->pghdr.cVersion--;						\
	}
#else
#define PMDecVersion( ppage )						\
	{														\
	if ( (ppage)->pghdr.cVersion > 0 )			\
		--(ppage)->pghdr.cVersion;					\
	}
#endif

#define SetPgno( ppage, pgno )				\
			ThreeBytesFromL( (ppage)->pgnoThisPage, (pgno) )
#define SetPgnoNext( ppage, pgno )			\
			ThreeBytesFromL( (ppage)->pghdr.pgnoNext, (pgno) )
#define SetPgnoPrev( ppage, pgno )			\
			ThreeBytesFromL( (ppage)->pghdr.pgnoPrev, (pgno) )

#define PgnoFromPage( ppage, ppgno )		\
			LFromThreeBytes( *(ppgno), (ppage)->pgnoThisPage )
	
#ifdef DEBUG	
#define PgnoNextFromPage( pssib, ppgno )	\
			{ CheckSSIB( pssib ); LFromThreeBytes( *(ppgno), (pssib)->pbf->ppage->pghdr.pgnoNext ); }
#define PgnoPrevFromPage( pssib, ppgno )	\
			{ CheckSSIB( (pssib) ); LFromThreeBytes( *(ppgno), (pssib)->pbf->ppage->pghdr.pgnoPrev ) }
#else
#define PgnoNextFromPage( pssib, ppgno )	\
			LFromThreeBytes( *(ppgno), (pssib)->pbf->ppage->pghdr.pgnoNext )
#define PgnoPrevFromPage( pssib, ppgno )	\
			LFromThreeBytes( *(ppgno), (pssib)->pbf->ppage->pghdr.pgnoPrev )
#endif

#define absdiff( x, y )	( (x) > (y)  ? (x)-(y) : (y)-(x) )
#define pgdiscont( pgno1, pgno2 ) \
	( ( (pgno1) == 0 ) || ( (pgno2) == 0 ) ? 0 \
	: absdiff( (pgno1), (pgno2) ) /  cpgDiscont )

#define ibPgnoPrevPage	( (INT) (ULONG_PTR)&((PAGE *)0)->pghdr.pgnoPrev )
#define ibPgnoNextPage	( (INT) (ULONG_PTR)&((PAGE *)0)->pghdr.pgnoNext )
#define ibCbFreeTotal	( (INT) (ULONG_PTR)&((PAGE *)0)->pghdr.cbFreeTotal )
#define ibCtagMac		( (INT) (ULONG_PTR)&((PAGE *)0)->pghdr.ctagMac )
#define ibPgtyp			( (INT) (ULONG_PTR)&((PAGE *)0)->pgtyp )

#define CbLastFreeSpace(ppage)										\
	((ppage)->pghdr.ibLastUsed											\
		- sizeof(PGHDR)													\
		- sizeof(TAG) * (ppage)->pghdr.ctagMac)

#define IbCbFromPtag( ibP, cbP, ptagP )							\
			{	TAG *_ptagT = ptagP;										\
				(ibP) = _ptagT->ib;										\
				(cbP) = _ptagT->cb;										\
			}

#define PtagFromIbCb( ptagP, ibP, cbP )	  						\
			{	TAG *_ptagT = ptagP;							\
				_ptagT->ib = (SHORT)(ibP);						\
				_ptagT->cb = (SHORT)(cbP);						\
			}

#ifdef DEBUG
#define	PMGet( pssib, itagT )	CallS( ErrPMGet( pssib, itagT ) )
#else
#define PMGet( pssib, itagT ) 										\
	{																			\
	PAGE *ppageT_ = (pssib)->pbf->ppage;							\
	TAG *ptagT_ = &(ppageT_->rgtag[itagT]);						\
	Assert( itagT >= 0 ); 												\
	Assert( itagT < (pssib)->pbf->ppage->pghdr.ctagMac ); 	\
	(pssib)->line.pb = (BYTE *)ppageT_ + ptagT_->ib;			\
	(pssib)->line.cb = ptagT_->cb;									\
	}
#endif

#define	ItagPMMost( ppage )	((ppage)->pghdr.ctagMac - 1)

BOOL FPMFreeTag( SSIB *pssib, INT citagReq );

#ifdef DEBUG
#define CbPMFreeSpace( pssib )	( CheckSSIB(pssib),							\
	((INT)(pssib)->pbf->ppage->pghdr.cbFreeTotal) )
#else
#define CbPMFreeSpace( pssib )	( (INT)(pssib)->pbf->ppage->pghdr.cbFreeTotal )
#endif

#define	ErrPMCheckFreeSpace( pssib, cbT )								   	\
		( ((INT)(pssib)->pbf->ppage->pghdr.cbFreeTotal) < cbT ?				\
			errPMOutOfPageSpace : JET_errSuccess )

#define	PMAllocFreeSpace( pssib, cb ) 					 						\
	{																							\
	Assert( (INT)(pssib)->pbf->ppage->pghdr.cbFreeTotal >= cb );			\
	(pssib)->pbf->ppage->pghdr.cbFreeTotal -= cb;								\
	}

#define	PMFreeFreeSpace( pssib, cb ) 						 						\
	{																							\
	Assert( (INT)(pssib)->pbf->ppage->pghdr.cbFreeTotal >= 0 );				\
	(pssib)->pbf->ppage->pghdr.cbFreeTotal += (SHORT)cb; 				\
	Assert( (INT)(pssib)->pbf->ppage->pghdr.cbFreeTotal < cbPage );		\
	}

#ifdef DEBUG
#define AssertBTFOP(pssib)																\
	Assert( PgtypPMPageTypeOfPage((pssib)->pbf->ppage) == pgtypSort ||	\
		PgtypPMPageTypeOfPage((pssib)->pbf->ppage) == pgtypFDP ||			\
		(pssib)->itag != 0 ||															\
		( CbNDKey( (pssib)->line.pb ) == 0 &&										\
		!FNDBackLink( *(pssib)->line.pb ) )											\
		)
#else
#define AssertBTFOP( pssib )
#endif

#define PbPMGetChunk(pssib, ib)	 &(((BYTE *)((pssib)->pbf->ppage))[ib])	

INT CbPMLinkSpace( SSIB *pssib );
TS TsPMTagstatus( PAGE *ppage, INT itag );
VOID PMNewPage( PAGE *ppage, PGNO pgno, PGTYP pgtyp, PGNO pgnoFDP );
INT ItagPMQueryNextItag( SSIB *pssib );
ERR ErrPMInsert( SSIB *pssib, LINE *rgline, INT cline );
VOID PMDelete( SSIB *ssib );
ERR ErrPMReplace( SSIB *pssib, LINE *rgline, INT cline );
ERR ErrPMGet( SSIB *pssib, INT itag );
VOID PMGetLink( SSIB *pssib, INT itag, LINK *plink );
VOID PMExpungeLink( SSIB *pssib );
VOID PMReplaceWithLink( SSIB *pssib, SRID srid );
VOID PMReplaceLink( SSIB *pssib, SRID srid );
INT CPMIFreeTag( PAGE *ppage );
BOOL FPMEmptyPage( SSIB *pssib );
BOOL FPMLastNodeToDelete( SSIB *pssib );

VOID PMDirty( SSIB *pssib );
VOID PMReadAsync( PIB *ppib, PN pn );
ERR  ErrPMAccessPage( FUCB *pfucb, PGNO pgno );

#ifdef DEBUG
VOID PageConsistent( PAGE *ppage );
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\spaceapi.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	 spaceapi.h: Space Manager API		===================

ERR ErrSPInitFDPWithoutExt( FUCB *pfucb, PGNO pgnoFDP );
ERR ErrSPInitFDPWithExt( FUCB *pfucb, PGNO pgnoFDPFrom, PGNO pgnoFirst, INT cpgReqRet, INT cpgReqWish );
ERR ErrSPGetExt( FUCB *pfucb,	PGNO pgnoFDP, CPG *pcpgReq,
	CPG cpgMin, PGNO *ppgnoFirst, BOOL fNewFDP );
ERR ErrSPGetPage( FUCB *pfucb, PGNO *ppgnoLast, BOOL fContig );
ERR ErrSPFreeExt( FUCB *pfucb, PGNO pgnoFDP, PGNO pgnoFirst,
	CPG cpgSize );
ERR ErrSPFreeFDP( FUCB *pfucb, PGNO pgnoFDP );
ERR ErrSPGetInfo( FUCB *pfucb, BYTE *pbResult, INT cbMax );
#define	ErrSPDeferFreeFDP	ErrVERDeferFreeFDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\scb.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============		SCB: Sort Control Block			===================

#ifndef	FCB_INCLUDED
#error scb.h requires fcb.h
#endif	/* FCB_INCLUDED */

#ifdef	SCB_INCLUDED
#error scb.h already included
#endif	/* SCB_INCLUDED */
#define SCB_INCLUDED

typedef ULONG RID, *PRID;

typedef struct
	{
	PN			pn;
	UINT		cbfRun;
	} RUN, *PRUN;

/*	choose crunMost so that crunMost % crunMergeMost = crunMergeMost - 1
/**/

#define crunMergeMost	16				// max number of runs to be merged
#define crunMost			31				// size of run directory

#define	fSCBInsert	 	(1<<0)
#define	fSCBIndex	 	(1<<1)
#define	fSCBUnique	 	(1<<2)

#define	SCBSetInsert( pscb )		((pscb)->fFlags |= fSCBInsert )
#define	SCBResetInsert( pscb )	((pscb)->fFlags &= ~fSCBInsert )
#define	FSCBInsert( pscb )		((pscb)->fFlags & fSCBInsert )

#define	SCBSetIndex( pscb )		((pscb)->fFlags |= fSCBIndex )
#define	SCBResetIndex( pscb )	((pscb)->fFlags &= ~fSCBIndex )
#define	FSCBIndex( pscb )			((pscb)->fFlags & fSCBIndex )

#define	SCBSetUnique( pscb )		((pscb)->fFlags |= fSCBUnique )
#define	SCBResetUnique( pscb )	((pscb)->fFlags &= ~fSCBUnique )
#define	FSCBUnique( pscb )		((pscb)->fFlags & fSCBUnique )

struct _scb
	{
	struct _fcb		fcb;					// MUST BE FIRST FIELD IN STRUCTURE
	JET_GRBIT		grbit;		 		// sort grbit
	INT				fFlags;				//	sort flags
	
	// in-memory related
	LONG			cbSort;					// size of sort buffer
#ifdef	WIN16					  	
	HANDLE	 	hrgbSort;		 		// handle for sort buffer
#endif	/* WIN16 */
	BYTE			*rgbSort;				// sort buffer
	BYTE			*pbEnd;					// end of last inserted record
	BYTE			**rgpb;					// beginning of array of pointers
	BYTE			**ppbMax;				// end of array of pointers
	LONG			wRecords;				// count of records in sort buffer

	// disk related
	BYTE		 	*rgpbMerge[crunMost];
	struct _bf	*rgpbf[crunMergeMost];
	struct _bf	*pbfOut;				// output buffer
	BYTE		 	*pbOut;				// current pos in output buffer
	BYTE		 	*pbMax;				// end of output buffer (could be computed)
	RUN		  	rgrun[crunMost];	// run directory
	INT		 	crun;
	INT		 	bf;					// input buffers
	INT		 	cpbMerge;			// merge tree
	
#ifdef DEBUG
	LONG			cbfPin;
	LONG			lInput;
	LONG			lOutput;
#endif
	};

#ifdef DEBUG
#define	SCBPin( pscb )			( (pscb)->cbfPin++ )
#define	SCBUnpin( pscb )		{ Assert( (pscb)->cbfPin > 0 ); (pscb)->cbfPin--; }
#else
#define	SCBPin( pscb )
#define	SCBUnpin( pscb )
#endif

#define PscbMEMAlloc()			(SCB*)PbMEMAlloc(iresSCB)

#ifdef DEBUG /*  Debug check for illegal use of freed scb  */
#define MEMReleasePscb(pscb)	{ MEMRelease(iresSCB, (BYTE*)(pscb)); pscb = pscbNil; }
#else
#define MEMReleasePscb(pscb)	{ MEMRelease(iresSCB, (BYTE*)(pscb)); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\spaceint.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============   spaceint.h: Space Manager Internals	===================

/* miscellaneous constants
*/
#define fFreeToPool		fTrue

/* Space Manager constants
*/
#define cSecFrac			4	 		// divider of primary extent to get secondary
											// extent size, =cpgPrimary/cpgSecondary
#define cpgSESysMin		16			// minimum secondary extent size
#define pgnoSysMax 		(1<<22)  // maximum page number allowed in database

#define NA					0
#define fDIBNull			0

/* FUCB work area flags
*/
#define fNone				0
#define fSecondary		1
#define fFreed				2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\recapi.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	recapi.h: Record Management API		===================

/*	hooks for efficient functioning of comapct
/**/
ERR ErrRECExtrinsicLong( JET_VTID tableid,
	ULONG	itagSequence,
	BOOL	*pfSeparated, 
	LONG	*plid,
	ULONG	*plrefcnt,
	ULONG	grbit );

ERR ErrREClinkLid( JET_VTID tableid, JET_COLUMNID ulFieldId, 
	long lid, unsigned long lSeqNum );	

ERR ErrRECForceSeparatedLV( JET_VTID tableid, ULONG itagSequence );						

/*	key extraction/normalization
/**/
ERR ErrRECNormExtKey(
	FUCB			*pfucb,
	FDB			*pfdb,
	IDB			*pidb,
	LINE			*plineRec,
	LINE			*plineValues,
	KEY			*pkey,
	ULONG			itagSequence );
	
ERR ErrRECExtractKey( 
	FUCB			*pfucb,
	FDB			*pfdb,
	IDB			*pidb, 
	LINE			*plineRec,
	KEY			*pkey,
	ULONG			itagSequence );
	
ERR ErrRECDenormalizeKey( FDB *pfdb, IDB *pidb, KEY *pkey, LINE *plineValues );

/*	field extraction
/**/
ERR ErrRECExtractField(
	FDB		*pfdb,
	LINE		*plineRec,
	FID		*pfid,
	ULONG		*pitagSequence,
	ULONG		itagSequence,
	LINE		*plineField );

// ===================== EXPOSED CLIENT API ======================

// Record positioning
ERR VTAPI ErrIsamMove( PIB *ppib, FUCB *pfucb, LONG crow, JET_GRBIT grbit );
ERR VTAPI ErrIsamSeek( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit );

// Record modification
ERR VTAPI ErrIsamUpdate( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cb, ULONG *cbActual );
ERR VTAPI ErrIsamDelete( PIB *ppib, FUCB *pfucb );

// Field retrieval and modification
ERR VTAPI ErrIsamSetColumn(
	PIB		 		*ppib,
	FUCB				*pfucb,
	JET_COLUMNID	columnid,
	BYTE				*pbData,
	ULONG				cbData,
	ULONG				grbit,
	JET_SETINFO		*psetinfo );

ERR VTAPI ErrIsamRetrieveColumn(
	PIB				*ppib,
	FUCB				*pfucb,
	JET_COLUMNID	columnid,
	BYTE				*pbData,
	ULONG				cbDataMax,
	ULONG				*pcbDataActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo );

ERR VTAPI ErrIsamRetrieveColumns(
	PIB					 	*ppib,
	FUCB						*pfucb,
	JET_RETRIEVECOLUMN	*pretcols,
	ULONG						cretcols );

ERR VTAPI ErrIsamPrepareUpdate( PIB *ppib, FUCB *pfucb, ULONG grbit );
ERR VTAPI ErrIsamDupCursor( PIB*, FUCB*, FUCB **, ULONG );
ERR VTAPI ErrIsamGotoBookmark( PIB *ppib, FUCB *pfucb, BYTE *pbBookmark, ULONG cbBookmark );
ERR VTAPI ErrIsamGotoPosition( PIB *ppib, FUCB *pfucb, JET_RECPOS *precpos );

// Misc
ERR VTAPI ErrIsamGetCurrentIndex( PIB *ppib, FUCB *pfucb, CHAR *szCurIdx, ULONG cbMax );
ERR VTAPI ErrIsamSetCurrentIndex( PIB *ppib, FUCB *pfucb, const CHAR *szName );
ERR VTAPI ErrIsamMakeKey( PIB *ppib, FUCB *pfucb, BYTE *pbKeySeg,
	ULONG cbKeySeg, JET_GRBIT grbit );
ERR VTAPI ErrIsamRetrieveKey( PIB *ppib, FUCB *pfucb, BYTE *pbKey,
	ULONG cbMax, ULONG *pcbKeyActual, JET_GRBIT grbit );
ERR VTAPI ErrIsamRetrieveBookmarks( PIB *ppib, FUCB *pfucb,
	void *pvBookmarks, unsigned long cbMax, unsigned long *pcbActual );
ERR VTAPI ErrIsamSetIndexRange( PIB *ppib, FUCB *pfucb, JET_GRBIT grbit );

BOOL FIndexedFixVarChanged( BYTE *rgbitIdx, BYTE *rgbitSet,
	FID fidFixedLast, FID fidVarLast );

#ifdef JETSER
	ERR VTAPI
ErrIsamRetrieveFDB( PIB *ppib, FUCB *pfucb, void *pvFDB, unsigned long cbMax, unsigned long *pcbActual, unsigned long ibFDB );
	ERR VTAPI
ErrIsamRetrieveRecords( PIB *ppib, FUCB *pfucb, void *pvRecord, unsigned long cbMax, unsigned long *pcbActual, unsigned long ulRecords );
	ERR VTAPI
ErrIsamRetrieveBookmarks( PIB *ppib, FUCB *pfucb, void *pvBookmarks, unsigned long cbMax, unsigned long *pcbActual );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\sortapi.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	   sortapi.h:  Sort System API		===================

ERR ErrSORTInsert( FUCB *pfucb, LINE rglineKeyRec[] );
ERR ErrSORTEndRead( FUCB *pfucb );
ERR ErrSORTFirst( FUCB *pfucb );
ERR ErrSORTNext( FUCB *pfucb );
ERR ErrSORTPrev( FUCB *pfucb );
ERR ErrSORTSeek( FUCB *pfucb, KEY *pkey, BOOL fGT );
ERR ErrSORTReopen( FUCB *pfucb );
ERR ErrSORTOpen( PIB *ppib, FUCB **ppfucb, INT fFlags );
ERR ErrSORTClose( FUCB *pfucb );
VOID SORTClosePscb( SCB *pscb );
ERR ErrSORTCheckIndexRange( FUCB *pfucb );

// ===================== EXPOSED CLIENT API ======================

ERR VTAPI ErrIsamSortOpen( PIB *ppib, JET_COLUMNDEF *rgcolumndef, ULONG ccolumndef, JET_GRBIT grbit, FUCB **ppfucb, JET_COLUMNID *rgcolumnid );

ERR VTAPI ErrIsamSortMove(
	PIB				*ppib,
	FUCB				*pfucb,
	long				crow,
	JET_GRBIT		grbit );

ERR VTAPI ErrIsamSortSetIndexRange( 
	PIB				*ppib,
	FUCB				*pfucb,
	JET_GRBIT	grbit );

ERR VTAPI ErrIsamSortInsert( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cbMax,
	ULONG *pcbActual );

ERR VTAPI ErrIsamSortSeek( 
	PIB				*ppib,
	FUCB				*pfucb,
	JET_GRBIT	grbit );

ERR VTAPI ErrIsamSortDupCursor( 
	PIB				*ppib,
	FUCB				*pfucb,
	JET_TABLEID *tableid,
	JET_GRBIT	ulFlags);

ERR VTAPI ErrIsamSortClose( PIB *ppib, FUCB *pfucb );

ERR VTAPI ErrIsamSortGotoBookmark( 
	PIB				*ppib,
	FUCB				*pfucb,
	void 				*pv,
	unsigned long	cbBookmark );

ERR VTAPI ErrIsamSortGetTableInfo(
	PIB				*ppib,
	FUCB				*pfucb,
	void				*pv,
	unsigned long	cbOutMax,
	unsigned long	lInfoLevel );

ERR VTAPI ErrIsamCopyBookmarks( 
	PIB				*ppib,
	FUCB				*pfucbSrc,
	FUCB				*pfucbDest,
	JET_COLUMNID	columnidDest, 
	unsigned long	crecMax,
	unsigned long	*pcrowCopied,
	unsigned long	*precidLast );

ERR VTAPI ErrIsamSortRetrieveKey( 
	PIB				*ppib,
	FUCB				*pfucb,
	void				*pb, 
	unsigned long	cbMax, 
	unsigned long	*pcbActual, 
	JET_GRBIT 		grbit );

ERR VTAPI ErrIsamSortGetBookmark( 
	PIB				*ppib,
	FUCB				*pfucb,
	void				*pb, 
	unsigned long	cbMax, 
	unsigned long	*pcbActual );

typedef struct _vl
	{
	short	vlt;
	union
		{
		BYTE rgb[8];
		int	 i2;
		unsigned long sd;
		};
	} VL;


ERR VTAPI ErrIsamGetVL(	PIB *ppib, JET_TABLEID tableid, JET_COLUMNID columnid, VL *pvl );
ERR VTAPI ErrIsamSetVL( PIB *ppib, JET_TABLEID tableid, JET_COLUMNID columnid, VL *pvl );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\ssib.h ===
//===========		DAE: OS/2 Database Access Engine		=================
//===========	  ssib.h: Storage System Interface Block	=================

//
// Storage System Interface Block
//

struct _ssib
	{
	struct _pib		*ppib;			// process using this SSIB
	struct _bf		*pbf;				// ptr to page that cusr on, or pbcbNil
	LINE				line;				// cb/pb of current record
	INT				itag;				// current line
	BOOL				fDisableAssert;
	};


#define SetupSSIB( pssibT, ppibUser )  			\
	{								  							\
	(pssibT)->pbf = pbfNil; 					  		\
	(pssibT)->ppib = ppibUser;		   				\
	(pssibT)->fDisableAssert = fFalse;				\
	}

#define SSIBSetDbid( pssib, dbid )
#define SSIBSetPgno( pssib, pgno )

#ifdef DEBUG
#define	CheckSSIB( pssib )							\
		Assert( pssib->pbf != pbfNil )
#else
#define CheckSSIB( pssib )	((VOID) 0)
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\stats.h ===
#pragma pack(1)
typedef struct
	{
	ULONG				cItems;
	ULONG				cKeys;
	ULONG				cPages;
	JET_DATESERIAL	dtWhenRun;
	} SR;
#pragma pack()

ERR ErrSTATComputeIndexStats( PIB *ppib, FCB *pfcbIdx );

ERR ErrSTATSRetrieveTableStats( 
	PIB		*ppib,				
	DBID		dbid, 			 	
	char		*szTable,
	long		*pcRecord,
	long		*pcKey,
	long		*pcPage );

ERR ErrSTATSRetrieveIndexStats(
	FUCB		*pfucbTable,
	char		*szIndex,
	long		*pcItem,
	long		*pcKey,
	long		*pcPage );

ERR VTAPI ErrIsamComputeStats( PIB *ppib, FUCB *pfucb );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\spinlock.h ===
/* SPINLOCK.H -- This file is the include file for spinlocks
**
**  Created 04/20/93 by LaleD
**
*/

#ifdef DEBUG
void	free_spinlock(long *);
#else
#define	free_spinlock(a)    *(a) = 0 ;
#endif

/*
** When /Ogb1 or /Ogb2 flag is used in the compiler, this function will
** be expanded in line
*/
__inline    int     get_spinlock(long VOLATILE *plock, int b)
{
# ifdef _X86_
	_asm	// Use bit test and set instruction
	{
	    mov eax, plock
	    lock bts [eax], 0x0
	    jc	bsy	// If already set go to busy, otherwise return TRUE
	} ;

#else
	if (InterlockedExchange(plock, 1) == 0)
#endif
	{
		return(TRUE);
	}
bsy:
		return(get_spinlockfn(plock, b, c));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\stint.h ===
//==============	DAE: OS/2 Database Access Engine	=====================
//==============	stint.h: Storage System Internals	=====================

#define cbStack 		4096			// stack size for each thread

//---- PIB (pib.c) ----------------------------------------------------------

VOID InsProc( PIB *ppib );
VOID DelProc( PIB *ppib );

//---- BUF (buf.c) ----------------------------------------------------------

#define IpbfHashPgno(pn)		(INT)( (pn + (pn>>18)) % ipbfMax )

#define PbfFromPPbfNext( ppbf )	\
	((BF *)((BYTE *)(ppbf) - (UINT)(ULONG_PTR)&((BF *)0)->pbfNext))

ERR ErrBFInit( VOID );
VOID BFTermProc( VOID );
VOID BFReleaseBF( VOID );
ERR ErrBFWrite( BF *pbf, BOOL fSync );
ERR ErrBFIFindPage( PIB *ppib, PN pn, BF **ppbf );
VOID BFCheckRefCnt( VOID );
VOID DumpBufferGroup( BOOL fDumpFree, BOOL fDumpPage, BOOL fDumpLines );
VOID DumpBF( BF *pbf );
VOID DumpBufHashTable( VOID );
VOID DumpDatabaseBuffers( DBID dbid );
BF * PbfBFISrchHashTable( PN pn );
VOID BFIInsertHashTable( BF *pbf );
VOID BFIDeleteHashTable( BF *pbf );

//------ IO (io.c) ----------------------------------------------------------

ERR ErrIOInit( void );
ERR ErrIOTerm( void );

VOID IOAsync( IOQE *pioqe );
VOID IOWait( IOQE *pioqe );
VOID IOExecute( IOQE *pioqe );

extern PIB * __near ppibAnchor;
extern unsigned int __near rgPageWeight[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\sysqry.c ===
#define cbExpressionMax 128
#define cbNameMax 64
#define cbOrderMax 4

typedef struct qryrow {
	unsigned char	Attribute;
	char			szExpression[cbExpressionMax];
	short			Flag;
	char			szName1[cbNameMax];
	char			szName2[cbNameMax];
	unsigned long	ObjectId;
	char			szOrder[cbOrderMax];
	} QRYROW;

#define cqryMax 4

static CODECONST(char) szMSysUserList[] = "MSysUserList";
static CODECONST(char) szMSysGroupList[] = "MSysGroupList";
static CODECONST(char) szMSysUserMemberships[] = "MSysUserMemberships";
static CODECONST(char) szMSysGroupMembers[] = "MSysGroupMembers";

static CODECONST(CODECONST(char) *) rgszSysQry[cqryMax] =
	{szMSysUserList, szMSysGroupList, szMSysUserMemberships, szMSysGroupMembers};

#define cqryrowMax (sizeof(rgqryrow) / sizeof (QRYROW))


/* MSysQueries rows for the following system queries: */
/* 
sql(s,d,"
	procedure MSysUserList;
	select MSysAccounts.Name
	from MSysAccounts
	where MSysAccounts.FGroup = 0
	order by MSysAccounts.Name
	;")

sql(s,d,"
	procedure MSysGroupList;
	select MSysAccounts.Name
	from MSysAccounts
	where MSysAccounts.FGroup <> 0
	order by MSysAccounts.Name
	;")

sql(s,d,"
	procedure MSysUserMemberships UserName text;
	select B.Name
	from MSysGroups, MSysAccounts as A, MSysAccounts as B
	where A.Name = UserName and A.FGroup = 0 and
			A.Sid = MSysGroups.UserSID and B.Sid = MSysGroups.GroupSid
	order by B.Name
	;")

sql(s,d,"
	procedure MSysGroupMembers GroupName text;
	select distinct MSysAccounts_1.Name
	from MSysAccounts, MSysGroups, MSysAccounts as MSysAccounts_1,
	MSysAccounts inner join MSysGroups on MSysAccounts.SID = MSysGroups.GroupSID,
	MSysGroups inner join MSysAccounts_1 on MSysGroups.UserSID = MSysAccounts_1.SID
	where (MSysAccounts.Name = [GroupName] and MSysAccounts.FGroup <> 0 and MSysAccounts_1.FGroup = 0)
	;")
*/

/* CONSIDER: the following array should be generated directly from */
/* CONSIDER: a cli extension. */

static CODECONST(QRYROW) rgqryrow[] = {

/* MSysUserList query */

	{0, "", 2, "", "", 268435457, '\0', '\0', '\0', '\1'},

	{255, "", 0, "", "", 268435457, '\0', '\0', '\0', '\1'},

	{3, "", 4, "", "", 268435457, '\0', '\0', '\0', '\1'},

	{6, "MSysAccounts.Name", 0, "", "", 268435457, '\0', '\0', '\0', '\1'},

	{5, "", -1, "MSysAccounts", "", 268435457, '\0','\0','\0','\1'},

	{8, "MSysAccounts.FGroup = 0", -1, "", "", 268435457, '\0','\0','\0','\1'},

	{11, "MSysAccounts.Name", -1, "", "", 268435457, '\0','\0','\0','\1'},

/* MSysGroupList query */	

	{0, "", 2, "", "", 268435458, '\0','\0','\0','\1'},

	{255, "", 0, "", "", 268435458, '\0','\0','\0','\1'},

	{3, "", 4, "", "", 268435458, '\0','\0','\0','\1'},
	
	{6, "MSysAccounts.Name", 0, "", "", 268435458, '\0','\0','\0','\1'},

	{5, "", -1, "MSysAccounts", "", 268435458, '\0','\0','\0','\1'},
	
	{8, "MSysAccounts.FGroup <> 0", -1, "", "", 268435458, '\0','\0','\0','\1'},

	{11, "MSysAccounts.Name", -1, "", "", 268435458, '\0','\0','\0','\1'},

/* MSysUserMemberships query */

/*	{0, "", 2, "", "", 268435459, '\0','\0','\0','\1'},

	{255, "", 0, "", "", 268435459, '\0','\0','\0','\1'},

	{3, "", 4, "", "", 268435459, '\0','\0','\0','\1'},

	{2, "", 10, "UserName", "", 268435459, '\0','\0','\0','\1'},
	
	{6, "B.Name", 0, "", "", 268435459, '\0','\0','\0','\1'},

	{5, "", -1, "MSysGroups", "", 268435459, '\0','\0','\0','\1'},
	
	{5, "", -1, "MSysAccounts", "A", 268435459, '\0','\0','\0','\2'},

	{5, "", -1, "MSysAccounts", "B", 268435459, '\0','\0','\0','\3'},

	{8, "A.Name = UserName and A.FGroup = 0 and A.Sid = MSysGroups.UserSID and B.Sid = MSysGroups.GroupSid", -1, "", "", 268435459, '\0','\0','\0','\1'},

	{11, "B.Name", -1, "", "", 268435459, '\0','\0','\0','\1'}
*/

	{0, "", 2, "", "", 268435459, '\0','\0','\0','\1'},

	{255, "", 0, "", "", 268435459, '\0','\0','\0','\1'},

	{3, "", 2, "", "", 268435459, '\0','\0','\0','\1'},

	{2, "", 10, "UserName", "", 268435459, '\0','\0','\0','\1'},
	
	{6, "MSysAccounts_1.Name", 0, "", "", 268435459, '\0','\0','\0','\1'},

	{5, "", -1, "MSysGroups", "", 268435459, '\0','\0','\0','\1'},
	
	{5, "", -1, "MSysAccounts", "", 268435459, '\0','\0','\0','\2'},

	{5, "", -1, "MSysAccounts", "MSysAccounts_1", 268435459, '\0','\0','\0','\3'},

	{7, "MSysAccounts.SID = MSysGroups.UserSID", 1, "MSysAccounts", "MSysGroups", 268435459, '\0','\0','\0','\1'},

	{7, "MSysGroups.GroupSID = MSysAccounts_1.SID", 1, "MSysGroups", "MSysAccounts_1", 268435459, '\0','\0','\0','\2'},

	{8, "MSysAccounts.Name = [UserName] and MSysAccounts.FGroup = 0 and MSysAccounts_1.FGroup <> 0", -1, "", "", 268435459, '\0','\0','\0','\1'},

/* MSysGroupMembers query */

	{0, "", 2, "", "", 268435460, '\0','\0','\0','\1'},

	{255, "", 0, "", "", 268435460, '\0','\0','\0','\1'},

	{3, "", 2, "", "", 268435460, '\0','\0','\0','\1'},

	{2, "", 10, "GroupName", "", 268435460, '\0','\0','\0','\1'},
	
	{6, "MSysAccounts_1.Name", 0, "", "", 268435460, '\0','\0','\0','\1'},

	{5, "", -1, "MSysGroups", "", 268435460, '\0','\0','\0','\1'},
	
	{5, "", -1, "MSysAccounts", "", 268435460, '\0','\0','\0','\2'},

	{5, "", -1, "MSysAccounts", "MSysAccounts_1", 268435460, '\0','\0','\0','\3'},

	{7, "MSysAccounts.SID = MSysGroups.GroupSID", 1, "MSysAccounts", "MSysGroups", 268435460, '\0', '\0', '\0', '\1'},

	{7, "MSysGroups.UserSID = MSysAccounts_1.SID", 1, "MSysGroups", "MSysAccounts_1", 268435460, '\0', '\0', '\0', '\2'},

	{8, "MSysAccounts.Name = GroupName and MSysAccounts.FGroup <> 0 and MSysAccounts_1.FGroup = 0", -1, "", "", 268435460, '\0','\0','\0','\1'}
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\sys.h ===
#ifndef DEBUG
#include <malloc.h>
#endif

ERR ErrSysOpenFile( CHAR *szFileName, HANDLE *phf, ULONG ulFileSize, BOOL fReadOnly, BOOL fOverlapped );
ERR ErrSysOpenReadFile( CHAR *szFileName, HANDLE *phf );
ERR ErrSysCloseHandle( HANDLE hf );
#define ErrSysCloseFile( hf ) ErrSysCloseHandle( hf )
#ifdef ANGEL
ERR ErrSysDeleteFile( CHAR *szFileName );
#else
ERR ErrSysDeleteFile( const CHAR *szFileName );
#endif
ERR ErrSysNewSize( HANDLE hf, ULONG ulFileSize, ULONG ulFileSizeHigh, BOOL fOverlapped );
ERR ErrSysMove( CHAR *szFrom, CHAR *szTo );
ERR ErrSysCopy( CHAR *szFrom, CHAR *szTo, BOOL fFailIfExists );
ERR ErrSysReadBlock( HANDLE hf, VOID *pvBuf, UINT cbBuf, UINT *pcbRead );
ERR ErrSysWriteBlock( HANDLE hf, VOID *pvBuf, UINT cbBuf, UINT *pcbWritten );
VOID SysTerm( VOID );
VOID SysDebugBreak( VOID );

/*	text normalization
/**/
ERR ErrSysCheckLangid( LANGID langid );
VOID SysNormText( CHAR *rgchText, INT cchText, BYTE *rgchNorm, INT cbNorm, INT *pbNorm );
INT SysCmpText( const CHAR *sz1, const CHAR *sz2 );
ERR ErrSysNormText(
	const BYTE *pbField,
	INT cbField,
	INT cbKeyBufLeft,
	BYTE *pbSeg,
	INT *pcbSeg );
VOID SysStringCompare( char __far *pb1, unsigned long cb1,
	char __far *pb2, unsigned long cb2, unsigned long sort,
	long __far *plResult );

typedef struct _olp
	{
	ULONG	ulInternal;
	ULONG	ulInternalHigh;
	ULONG	ulOffset;
	ULONG	ulOffsetHigh;
	SIG		sigIO;
	} OLP;

ERR ErrSysReadBlockOverlapped( HANDLE hf, VOID *pvBuf, UINT cbBuf,
		DWORD *pcbRead,	OLP *polp );
ERR ErrSysWriteBlockOverlapped( HANDLE hf, VOID *pvBuf, UINT cbBuf,
		DWORD *pcbWrite, OLP *polp );
ERR ErrSysGetOverlappedResult( HANDLE hf, OLP *polp, UINT *pcb,
		BOOL fWait );
ERR ErrSysWriteBlockEx(	HANDLE hf, VOID *pvBuf, UINT cbBuf, OLP *polp, VOID *pfnCompletion);
ERR ErrSysReadBlockEx(	HANDLE hf, VOID *pvBuf, UINT cbBuf, OLP *polp, VOID *pfnCompletion);

VOID SysChgFilePtr( HANDLE hf, LONG lRel, LONG *plRelHigh, ULONG ulRef, ULONG *pul );
VOID SysGetDateTime( JET_DATESERIAL *pdt );
VOID SysSleep( ULONG	ulTime );
VOID SysSleepEx( ULONG	ulTime, BOOL fAlert );
ERR ErrSysCreateThread( ULONG (*pulfn)(), ULONG cbStack, LONG lThreadPriority, HANDLE *phandle );
VOID SysExitThread( ULONG ulExitCode );
BOOL FSysExitThread( HANDLE handle );
ULONG UlSysThreadId( VOID );
ERR ErrSysGetComputerName( CHAR	*sz,  INT *pcb);

/* Unicode Support 
/**/
ERR ErrSysMapString(LANGID	langid, BYTE *pbField, INT cbField, BYTE *rgbSeg,
	int cbBufLeft, int *cbSeg);

VOID SysCheckWriteBuffer( BYTE *pvBuf, INT cbBuf );

/*	Memory allocation
/**/
#define	cbMemoryPage	4096

VOID *PvSysAlloc( ULONG dwSize );
VOID *PvSysCommit( VOID *pv, ULONG dwSize );
VOID *PvSysAllocAndCommit( ULONG dwSize );
VOID SysFree( VOID *pv );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\stapi.h ===
//==============	DAE: OS/2 Database Access Engine	=====================
//==============	   stapi.h: Storage System API	 =====================

//---- externs -------------------------------------------------------------

extern SEM	__near semST;
extern RES	__near rgres[];
extern TRX __near trxOldest;
extern TRX __near trxNewest;

extern SIG __near sigBFCleanProc;

//---- IO (io.c) ----------------------------------------------------------

#define	LOffsetOfPgnoLow( pgno )	( ((pgno) - 1) << 12 )
#define	LOffsetOfPgnoHigh( pgno )	( ((pgno) - 1) >> 20 )

#define fioqeOpenFile	1		/* for Opening File */
#define fioqeCloseFile	2		/* for Closing File */
#define fioqeDeleteFile	3		/* for deleting file */
#define fioqeNewSize	4			/* for resize file */

typedef struct _ioqe				/* IO queue element */
	{
	struct _ioqe *pioqePrev;	/* double linked IO queue list */
	struct _ioqe *pioqeNext;
	SIG sigIO;						/* signal to wait for IO completion */
	ERR err;							/* error code for err occurs during the IO */
	INT fioqe;						/* use up to 16 bits only */
	} IOQE;

#define fioqefileReadOnly	fTrue
#define fioqefileReadWrite	fFalse
typedef struct _ioqefile
	{
	IOQE;
	struct {
		BOOL fioqefile;		/* open file for read only or not */
		HANDLE hf;				/* file handle */
		char *sz;				/* fioqe = fioqeOpenFile, CloseFile, ExtFile */
		struct {
			ULONG cb;			/* how long the file is */
			ULONG cbHigh;
			};
		};
	} IOQEFILE;

VOID IOInitFMP();
ERR ErrInitFileMap( PIB *ppib );
BOOL FFileExists( CHAR *szFileName );
ERR ErrIOOpenFile( HANDLE *phf, CHAR *szDatabaseName, ULONG cb, BOOL fioqefile );
VOID IOCloseFile( HANDLE hf );
ERR ErrIONewSize( DBID dbid, CPG cpg );

BOOL FIOFileExists( CHAR *szFileName );
ERR ErrIOLockDbidByNameSz( CHAR *szFileName, DBID *pdbid );
ERR ErrIOLockDbidByDbid( DBID dbid );
ERR ErrIOLockNewDbid( DBID *pdbid, CHAR *szDatabaseName );
ERR ErrIOSetDbid( DBID dbid, CHAR *szDatabaseName );
VOID IOFreeDbid( DBID dbid );
void BFOldestLgpos( LGPOS *plgposCheckPoint );
VOID BFPurge( DBID dbid, PGNO pgnoFDP );

#define FIODatabaseOpen( dbid )	( rgfmp[dbid].hf != handleNil )
ERR ErrIOOpenDatabase( DBID dbid, CHAR *szDatabaseName, CPG cpg );
VOID IOCloseDatabase( DBID dbid );
VOID IODeleteDatabase( DBID dbid );
BOOL FIODatabaseInUse( DBID dbid );
BOOL FIODatabaseAvailable( DBID dbid );

#define FDatabaseLocked( dbid ) (rgfmp[dbid].fXOpen)

#define IOUnlockDbid( dbid )											\
	{																			\
	SgSemRequest( semST );												\
	Assert( FDBIDWait( dbid ) );			 							\
	DBIDResetWait( dbid );					  							\
	SgSemRelease( semST );												\
	}

#ifdef	DEBUG
#define IOSetDatabaseVersion( dbid, ulVersion )	 				\
	{																			\
	Assert( ulVersion == ulDAEPrevVersion ||						\
		ulVersion == ulDAEVersion );									\
	rgfmp[dbid].fPrevVersion = ( ulVersion == ulDAEPrevVersion );\
	}
#else	/* !DEBUG */
#define IOSetDatabaseVersion( dbid, ulVersion )
#endif	/* !DEBUG */

#define FIOExclusiveByAnotherSession( dbid, ppib )											\
	( Assert( FDBIDWait( dbid ) ), FDBIDExclusiveByAnotherSession( dbid, ppib ) )

#define IOSetExclusive( dbid, ppib )	  							\
	{																			\
	Assert( FDBIDWait( dbid ) );										\
	Assert( !( FDBIDExclusive( dbid ) ) );  						\
	DBIDSetExclusive( dbid, ppib );									\
	}

#define IOResetExclusive( dbid )										\
	{																			\
	Assert( FDBIDWait( dbid ) );										\
	DBIDResetExclusive( dbid );										\
	}

#define FIOReadOnly( dbid )											\
	( Assert( FDBIDWait( dbid ) ), FDBIDReadOnly( dbid ) )

#define IOSetReadOnly( dbid )											\
	{																			\
	Assert( FDBIDWait( dbid ) );										\
	DBIDSetReadOnly( dbid );											\
	}

#define IOResetReadOnly( dbid )										\
	{																			\
	Assert( FDBIDWait( dbid ) );										\
	DBIDResetReadOnly( dbid );											\
	}

#define FIOAttached( dbid )									 		\
	( Assert( FDBIDWait( dbid ) ), FDBIDAttached( dbid ) )

#define IOSetAttached( dbid )			 	 							\
	{																			\
	Assert( FDBIDWait( dbid ) );										\
	Assert( !( FDBIDAttached( dbid ) ) );		 					\
	DBIDSetAttached( dbid );											\
	}

#define IOResetAttached( dbid )		 	  							\
	{																			\
	Assert( FDBIDWait( dbid ) );										\
	Assert( FDBIDAttached( dbid ) );									\
	DBIDResetAttached( dbid );											\
	}

//---- PAGE (page.c) --------------------------------------------------------

// Max # of lines to update at once with ErrSTReplace
#define clineMax 6

#define	UlSTDBTimePssib( pssib )	( (pssib)->pbf->ppage->pghdr.ulDBTime )
#define	PMSetUlDBTime( pssib, ul )					  							\
	( Assert( (ul) <= rgfmp[DbidOfPn((pssib)->pbf->pn)].ulDBTime ),	\
	(pssib)->pbf->ppage->pghdr.ulDBTime = (ul) )								\

#define BFSetUlDBTime( pbf, ul )					  							\
	( Assert( (ul) <= rgfmp[DbidOfPn((pbf)->pn)].ulDBTime ),	\
	(pbf)->ppage->pghdr.ulDBTime = (ul) )								\

#ifdef DEBUG
VOID AssertPMGet( SSIB *pssib, INT itag );
#else
#define AssertPMGet( pssib, itag )
#endif


//---- BUF (buf.c) ----------------------------------------------------------

#define LRU_K	1

CRIT __near critLRU;

typedef struct _lru
	{
	INT	cbfAvail;				// clean available buffers in LRU list
	struct	_bf *pbfLRU;				// Least Recently Used buffer
	struct	_bf *pbfMRU;				// Most Recently Used buffer
	} LRULIST;
	
typedef struct _bgcb					// Buffer Group Control Block
	{
	struct	_bgcb *pbgcbNext;		// pointer to the next BCGB
	struct	_bf *rgbf;				// buffer control blocks for group
	struct	_page *rgpage;			// buffer control blocks for group
	INT	cbfGroup;				// number of bfs in this group
	INT	cbfThresholdLow; 		// threshold to start cleaning buffers
	INT	cbfThresholdHigh;		// threshold to stop cleaning buffers

	LRULIST lrulist;
	} BGCB;

#define pbgcbNil ((BGCB*)0)

#define PbgcbMEMAlloc() 			(BGCB*)PbMEMAlloc(iresBGCB)

#ifdef DEBUG /*  Debug check for illegal use of freed bgcb  */
#define MEMReleasePbgcb(pbgcb)	{ MEMRelease(iresBGCB, (BYTE*)(pbgcb)); pbgcb = pbgcbNil; }
#else
#define MEMReleasePbgcb(pbgcb)	{ MEMRelease(iresBGCB, (BYTE*)(pbgcb)); }
#endif

typedef struct _bf
	{
	struct	_page	*ppage; 	// pointer to page buffer
	struct	_bf  	*pbfNext;	// hash table overflow
	struct	_bf  	*pbfLRU;	// pointer to Less Recently Used Buffer
	struct	_bf  	*pbfMRU;	// pointer to More Recently Used Buffer

	PIB		*ppibWriteLatch; 	/* thread with Wait Latch */
	PIB		*ppibWaitLatch;  	/* thread with Wait Latch */
	CRIT  	critBF;				/* for setting fPreread/fRead/fWrite/fHold */
	
	OLP		olp;				/* for ssync IO, to wait for IO completion */
	HANDLE	hf;					/* for assync IO */
	
	struct	_bf	*pbfNextBatchIO;  /* next BF in BatchIO list */
	INT		ipageBatchIOFirst;
	
	ERR		err;	   			/* error code for err occurs during the IO */
	
	PN	   	pn;				  	// physical pn of cached page
	UINT   	cPin;			  	// if cPin > 0 then buf cannot be overlayed
	UINT   	cReadLatch; 	 	// if cReadLatch > 0, page cannot be updated
	UINT   	cWriteLatch; 	 	// if cWriteLatch > 0, page cannot be updated by other
	UINT   	cWaitLatch;
	UINT   	fDirty:1;	  		// indicates page needs to be flushed
										
					   			// the following flags are mutual exclusive:
	UINT   	fPreread:1;			// indicates page is being prefetched
	UINT   	fRead:1;   			// indicates page is being read/written
	UINT   	fWrite:1;			// 
	UINT   	fHold:1;   			// indicates buf is in transient state.
	
	UINT   	fIOError:1;			// indicates read/write error
	UINT   	fInHash:1;			// BF is currently in hash table

	ULONG  	ulBFTime1;
	ULONG  	ulBFTime2;
	INT		ipbfHeap;			// index in heap
	
	UINT  	 	cDepend; 		// count of prior BF's to be flushed
	struct	_bf	*pbfDepend;		// BF to be flushed after this one
	LGPOS  		lgposRC;		// log ptr to BeginT of oldest modifying xact 
	LGPOS		lgposModify;	// log ptr of entry for last page Modify
#ifdef	WIN16
	HANDLE	hpage;				// handle to the page buffer
#endif
	
//	UINT		fWaiting:1;	  	// someone is waiting to reference page
//	INT 		wNumberPages; 	// number of contiguous pages to read
	} BF;
#define pbfNil	((BF *) 0)


ERR ErrBFAccessPage( PIB *ppib, BF **ppbf, PN pn );
BF* PbfBFMostUsed( void );
VOID BFAbandon( PIB *ppib, BF *pbf );
ERR ErrBFAllocPageBuffer( PIB *ppib, BF **ppbf, PN pn, LGPOS lgposRC, BYTE pgtyp );
ERR ErrBFAllocTempBuffer( BF **ppbf );
VOID BFFree( BF *pbf );
VOID BFReadAsync( PN pn, INT cpage );
BF * PbfBFdMostUsed( void );
VOID BFRemoveDependence( PIB *ppib, BF *pbf );

/*	buffer flush prototype and flags
/**/
#define	fBFFlushSome 0
#define	fBFFlushAll	1
ERR ErrBFFlushBuffers( DBID dbid, INT fBFFlush );

#define BFSFree( pbf )						\
	{												\
	SgSemRequest( semST );					\
	BFFree( pbf );								\
	SgSemRelease( semST );					\
	}

#define	FBFDirty( pbf )	((pbf)->fDirty)

/* the following small functions are called too often, */
/* make it as a macros */
#ifdef DEBUG
VOID	BFSetDirtyBit( BF *pbf );
#else
#define BFSetDirtyBit( pbf )	(pbf)->fDirty = fTrue
#endif

VOID BFDirty( BF *pbf );

/*  check if a page is dirty. If it is allocated for temp buffer, whose
 *  pn must be Null, then no need to check if it is dirty since it will
 *  not be written out.
 */
#define AssertBFDirty( pbf )							\
	Assert( (pbf)->pn == pnNull	|| 				   		\
		(pbf) != pbfNil && (pbf)->fDirty == fTrue )

#define AssertBFPin( pbf )		Assert( (pbf)->cPin > 0 )

#define AssertBFWaitLatched( pbf, ppib )				\
	Assert( (pbf)->cWaitLatch > 0 						\
			&& (pbf)->cPin > 0 							\
			&& (pbf)->ppibWaitLatch == (ppib) );
	
#define BFPin( pbf )									\
	{													\
	EnterCriticalSection( (pbf)->critBF );				\
	Assert( (pbf) != pbfNil );							\
	Assert( !(pbf)->fWrite );							\
	Assert( !(pbf)->fRead );							\
	(pbf)->cPin++;										\
	LeaveCriticalSection( (pbf)->critBF );				\
	}

#define BFUnpin( pbf )									\
	{													\
	EnterCriticalSection( (pbf)->critBF );				\
	Assert( (pbf) != pbfNil );							\
	Assert( !(pbf)->fWrite );							\
	Assert( !(pbf)->fRead );							\
	Assert( (pbf)->cPin > 0 );							\
	(pbf)->cPin--;										\
	LeaveCriticalSection( (pbf)->critBF );				\
	}

#define BFSetReadLatch( pbf, ppibT )  	  				\
	{													\
	Assert( (pbf)->cPin > 0 );							\
	Assert( (pbf)->cWriteLatch == 0 ||		   			\
		(pbf)->ppibWriteLatch == (ppibT) );	   			\
	(pbf)->cReadLatch++;	  							\
	}

#define BFResetReadLatch( pbf, ppibT )					\
	{									  				\
	Assert( (pbf)->cPin > 0 );		  					\
	Assert( (pbf)->cReadLatch > 0 );					\
	Assert( (pbf)->cWriteLatch == 0 ||		   			\
		(pbf)->ppibWriteLatch == (ppibT) );	   			\
	(pbf)->cReadLatch--;				  				\
	}

#define FBFReadLatchConflict( ppibT, pbf )	 			\
	( (pbf)->cWriteLatch > 0 &&							\
		(pbf)->ppibWriteLatch != (ppibT) )				

#define BFSetWriteLatch( pbf, ppibT ) 	  				\
	{													\
	Assert( (pbf)->cPin > 0 );							\
	Assert( (pbf)->cReadLatch == 0 );					\
	Assert( (pbf)->cWriteLatch == 0 ||		   			\
		(pbf)->ppibWriteLatch == (ppibT) );	   			\
	(pbf)->cWriteLatch++;	  							\
	(pbf)->ppibWriteLatch = (ppibT);					\
	}

#define BFResetWriteLatch( pbf, ppibT )	 				\
	{									  				\
	Assert( (pbf)->cPin > 0 );		  					\
	Assert( (pbf)->cReadLatch == 0 );					\
	Assert( (pbf)->cWriteLatch > 0 );					\
	Assert( (pbf)->ppibWriteLatch == (ppibT) );			\
	if ( --(pbf)->cWriteLatch == 0 )					\
		{												\
		(pbf)->ppibWriteLatch = ppibNil;  				\
		Assert( (pbf)->cWaitLatch == 0 );				\
		}												\
	}

#define FBFWriteLatch( ppibT, pbf )						\
	((pbf)->cPin > 0 &&									\
		(pbf)->cWriteLatch > 0 &&	   					\
		(pbf)->ppibWriteLatch == (ppibT))

#define FBFWriteLatchConflict( ppibT, pbf )	 			\
	( (pbf)->cReadLatch > 0 ||							\
		( (pbf)->cWriteLatch > 0 &&						\
		(pbf)->ppibWriteLatch != (ppibT) ) )				

#define BFSetWaitLatch( pbf, ppib )				   		\
	{											   		\
	Assert( ( pbf )->cPin > 0 );						\
	Assert( ( pbf )->cWriteLatch > 0 );					\
	Assert( (pbf)->ppibWriteLatch == (ppib) );			\
	if ( pbf->cWaitLatch++ > 0 )				   		\
		Assert( (pbf)->ppibWaitLatch == (ppib) );		\
	(pbf)->ppibWaitLatch = ppib;						\
	}

#define BFResetWaitLatch( pbf, ppibT )					\
	{													\
	Assert( (pbf)->cPin > 0 );							\
	Assert( ( pbf )->cWriteLatch > 0 );					\
	Assert( (pbf)->cWaitLatch > 0 );					\
	Assert( (pbf)->ppibWaitLatch == (ppibT) );			\
	if ( --(pbf)->cWaitLatch == 0 )						\
		{												\
		(pbf)->ppibWaitLatch = ppibNil;					\
		SignalSend( (pbf)->olp.sigIO ); 				\
		}												\
	}

ERR ErrBFDepend( BF *pbf, BF *pbfD );

#define BFUndepend( pbf )								\
		{												\
		if ( (pbf)->pbfDepend != pbfNil )				  	\
			{											\
			BF *pbfD = (pbf)->pbfDepend;					\
			Assert( pbfD->cDepend > 0 );				\
			EnterCriticalSection( pbfD->critBF );		\
			pbfD->cDepend--;							\
			(pbf)->pbfDepend = pbfNil;					\
			LeaveCriticalSection( pbfD->critBF );		\
			}											\
		}

//---- STORAGE (storage.c) -------------------------------------------------

ERR ErrFMPSetDatabases( PIB *ppib );
ERR ErrFMPInit( VOID );
VOID FMPTerm( );

ERR ErrSTSetIntrinsicConstants( VOID );
ERR ErrSTInit( VOID );
ERR ErrSTTerm( VOID );

// Transaction support
ERR ErrSTBeginTransaction( PIB *ppib );
ERR ErrSTRollback( PIB *ppib );
ERR ErrSTCommitTransaction( PIB *ppib );
ERR ErrSTInitOpenSysDB();

ERR ErrBFNewPage( FUCB *pfucb, PGNO pgno, PGTYP pgtyp, PGNO pgnoFDP );
VOID BFSleep( unsigned long ulMSecs );

// Modes for Storage System
#define modeRead		0
#define modeWrite		1
#define modeRIW 		2

#define PnOfDbidPgno( dbid, pgno )		( ( (LONG) (dbid) )<<24 | (pgno) )
#define DbidOfPn( pn )						( (DBID)( (pn)>>24 ) )
#define PgnoOfPn( pn )						( (pn) & 0x00ffffff )

#define ErrSTReadAccessPage 			ErrSTAccessPage
#define ErrSTWriteAccessPage			ErrSTAccessPage
#define FReadAccessPage					FAccessPage
#define FWriteAccessPage 				FAccessPage

BOOL FBFAccessPage( FUCB *pfucb, PGNO pgno );
#define FAccessPage( pfucb, pgno ) FBFAccessPage( pfucb, pgno )

//	UNDONE:	this should be in SgSemRequest( semST )
#define	ErrSTAccessPage( pfucb, pgnoT )			\
	( ErrBFAccessPage( pfucb->ppib, &(pfucb)->ssib.pbf, PnOfDbidPgno( (pfucb)->dbid, pgnoT ) ) )

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\systab.h ===
#ifdef	SYSTABLES

typedef struct _cdesc			/* Column Description	*/
	{
	char			*szColName;		/* Column Name			*/
	JET_COLTYP	coltyp; 			/* Column Type			*/
	JET_GRBIT	grbit;			/* Flag bits			*/
	ULONG			ulMaxLen;		/* Max Length of Column */
	} CDESC;


typedef struct _idesc			/* Index Description	*/
	{
	char			*szIdxName;	  	/* Index Name			*/
	char			*szIdxKeys;	  	/* Key String			*/
	JET_GRBIT	grbit;			/* Flag bits			*/
	} IDESC;


typedef struct {
	const char				*szName;
	CODECONST(CDESC)		*pcdesc;
	CODECONST(IDESC)		*pidesc;
	BYTE						ccolumn;
	BYTE						cindex;
	CPG						cpg;
	JET_COLUMNID		  	*rgcolumnid;
	} SYSTABLEDEF;


#define itableSo			0		       /* MSysObjects */
#define itableSc			1		       /* MSysColumns */
#define itableSi			2		       /* MSysIndexes */
#define itableSa			3		       /* MSysACEs */
#define itableSq			4		       /* MSysQueries */
#define itableSr			5		       /* MSysRelationShips */

#define iMSO_Id 						0
#define iMSO_ParentId				1
#define iMSO_Name						2
#define iMSO_Type 					3
#define iMSO_DateCreate 			4
#define iMSO_DateUpdate 			5
#define iMSO_Rgb 						6
#define iMSO_Lv 						7
#define iMSO_Owner					8
#define iMSO_Database				9
#define iMSO_Connect					10
#define iMSO_ForeignName			11
#define iMSO_RmtInfoShort			12
#define iMSO_RmtInfoLong 			13
#define iMSO_Flags					14
#define iMSO_LvExtra					15
#define iMSO_Description			16
#define iMSO_LvModule				17
#define iMSO_LvProp					18
#define iMSO_Pages					19
#define iMSO_Density					20

#define iMSC_ObjectId				0
#define iMSC_Name						1
#define iMSC_ColumnId				2
#define iMSC_Coltyp					3
#define iMSC_FAutoincrement		4
#define iMSC_FDisallowNull			5
#define iMSC_FVersion				6
#define iMSC_CodePage				7
#define iMSC_LanguageId 			8
#define iMSC_Country					9
#define iMSC_FRestricted			10
#define iMSC_RmtInfoShort			11
#define iMSC_RmtInfoLong 			12
#define iMSC_Description			13
#define iMSC_LvExtra					14
#define iMSC_POrder					15

#define iMSI_ObjectId				0
#define iMSI_Name						1
#define iMSI_FUnique					2
#define iMSI_FPrimary				3
#define iMSI_FDisallowNull			4
#define iMSI_FExcludeAllNull 		5
#define iMSI_FClustered 			6
#define iMSI_MatchType				7
#define iMSI_UpdateAction			8
#define iMSI_DeleteAction			9
#define iMSI_ObjectIdReference	10
#define iMSI_IdxidReference		11
#define iMSI_RgkeydReference		12
#define iMSI_RglocaleReference	13
#define iMSI_FDontEnforce			14
#define iMSI_RmtInfoShort			15
#define iMSI_RmtInfoLong			16
#define iMSI_LvExtra 				17
#define iMSI_Description 			18
#define iMSI_Density					19
// UNDONE: include later
// #define iMSI_LanguageId 			20
// #define iMSI_Country					21


/* max number of columns
/**/
#define ilineSxMax					21

#define CheckTableObject( szTable )					\
	{															\
	ERR			err;										\
	OBJID		objid;										\
	JET_OBJTYP	objtyp; 									\
																\
	err = ErrFindObjidFromIdName( ppib,				\
		dbid,													\
		objidTblContainer,								\
		szTable,												\
		&objid, 												\
		&objtyp );											\
	if ( err >= JET_errSuccess )				  		\
		{														\
		if ( objtyp == JET_objtypQuery )				\
			return JET_errQueryNotSupported;			\
		if ( objtyp == JET_objtypLink ) 				\
			return JET_errLinkNotSupported; 			\
		if ( objtyp == JET_objtypSQLLink )			\
			return JET_errSQLLinkNotSupported;		\
		}														\
	else														\
		return err;											\
	}

/*	prototypes
/**/
ERR ErrSysTabCreate( PIB *ppib, DBID dbid );
ERR ErrSysTabInsert( PIB *ppib, DBID dbid, INT itable, LINE rgline[], OBJID objid );
ERR ErrSysTabDelete( PIB *ppib, DBID dbid, INT itable, CHAR *szName, OBJID objid );
ERR ErrSysTabRename(
	PIB				*ppib,
	DBID				dbid,
	CHAR				*szNew,
	CHAR				*szName,
	OBJID				objid,
	INT				itable );
ERR ErrSysTabTimestamp( PIB *ppib, DBID	dbid, OBJID objid );
ERR ErrFindObjidFromIdName(
	PIB			*ppib,
	DBID			dbid,
	OBJID			objidParentId,
	const CHAR	*lszName,
	OBJID			*pobjid,
	JET_OBJTYP	*pobjtyp );
ERR ErrFindNameFromObjid( PIB *ppib, DBID dbid, OBJID objid, OUTLINE *poutName );
ERR VTAPI ErrIsamGetObjidFromName( JET_SESID sesid, JET_DBID vdbid, const char *lszCtrName, const char *lszObjName, OBJID *pobjid );
ERR VTAPI ErrIsamCreateObject( JET_SESID sesid, JET_DBID vdbid, OBJID objidParentId, const char *szName, JET_OBJTYP objtyp );
ERR VTAPI ErrIsamDeleteObject( JET_SESID sesid, JET_DBID vdbid, OBJID objid );

#endif	/* SYSTABLES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\bt.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "dirapi.h"
#include "nver.h"
#include "util.h"

DeclAssertFile;					/* Declare file name for assert macros */

LOCAL BOOL FBTThere( FUCB *pfucb );
LOCAL INT IbsonBTFrac( FUCB *pfucb, CSR *pcsr, DIB *pdib );


/*	returns fTrue if node is potentially there and fFalse if
/*	node is not potentially there.  A node is potentially there
/*	if it can be there as a result of a transaction committ or
/*	a transaction rollback.
/**/
LOCAL BOOL FBTPotThere( FUCB *pfucb )
	{
	SSIB	*pssib = &pfucb->ssib;
	BOOL	fDelete = FNDDeleted( *pssib->line.pb );
	VS		vs;
	SRID	srid;
	BOOL	fPotThere;

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	if session cursor isolation model is not dirty and node
	/*	has version, then call version store for appropriate version.
	/**/
	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		NDGetBookmark( pfucb, &srid );
		vs = VsVERCheck( pfucb, srid );
		fPotThere = FVERPotThere( vs, fDelete );
		
		return fPotThere;
		}

	return !fDelete;
	}

		
LOCAL BOOL FBTThere( FUCB *pfucb )
	{
	SSIB	*pssib = &pfucb->ssib;

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	if session cursor isolation model is not dirty and node
	/*	has version, then call version store for appropriate version.
	/**/
	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS		ns;
		SRID	srid;

		NDGetBookmark( pfucb, &srid );
		ns = NsVERAccessNode( pfucb, srid );
		return ( ns == nsVersion || ns == nsVerInDB || ns == nsDatabase && !FNDDeleted( *pssib->line.pb ) );
		}

	return !FNDDeleted( *pssib->line.pb );
	}


/*	return fTrue this session can modify current node with out write conflict.
/**/
BOOL FBTMostRecent( FUCB *pfucb )
	{
	SSIB	*pssib = &pfucb->ssib;

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	if ( FNDVersion( *pssib->line.pb ) )
		{
		VS		vs;
		SRID	srid;

		NDGetBookmark( pfucb, &srid );
		vs = VsVERCheck( pfucb, srid );
		return ( vs != vsUncommittedByOther );
		}
	Assert( !FNDDeleted( *pssib->line.pb ) );
	return fTrue;
	}


/*	ErrBTGet returns an error is the current node
/*	is not there for the caller, and caches the line.
/**/
ERR ErrBTGet( FUCB *pfucb, CSR *pcsr )
	{
	ERR		err;
	SSIB		*pssib = &pfucb->ssib;

	if ( !FReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallR( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
		Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
		}
	NDGet( pfucb, pcsr->itag );

	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS		ns;
		SRID	srid;

		NDGetBookmark( pfucb, &srid );
		ns = NsVERAccessNode( pfucb, srid );
		if ( ns == nsDatabase )
			{
			if ( FNDDeleted( *(pfucb->ssib.line.pb) ) )
				return JET_errRecordDeleted;
			}
		else if ( ns == nsInvalid )
			{
			return JET_errRecordDeleted;
			}
		else
			return JET_errSuccess;
		}

	if ( FNDDeleted( *(pfucb->ssib.line.pb) ) )
		return JET_errRecordDeleted;
	return JET_errSuccess;
	}


/*	ErrBTGetNode returns an error if the current node is not there for
/*	the caller, and otherwise caches the line, data and key for the
/*	verion of the node for the caller.
/**/
ERR ErrBTGetNode( FUCB *pfucb, CSR *pcsr )
	{
	ERR		err;
	SSIB  	*pssib = &pfucb->ssib;

	Assert( pcsr->csrstat == csrstatOnCurNode ||
		pcsr->csrstat == csrstatOnFDPNode ||
		pcsr->csrstat == csrstatOnDataRoot ||
		pcsr->csrstat == csrstatBeforeCurNode ||
		pcsr->csrstat == csrstatAfterCurNode );

	if ( !FReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallR( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
		Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
		}
	NDGet( pfucb, pcsr->itag );

	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS		ns;
		SRID	srid;

		NDGetBookmark( pfucb, &srid );
		ns = NsVERAccessNode( pfucb, srid );
		if ( ns == nsVersion )
			{
			/*	got data but must now get key.
			/**/
			NDGetKey( pfucb );
			}
		else if ( ns == nsDatabase )
			{
			if ( FNDDeleted( *(pfucb->ssib.line.pb) ) )
				return JET_errRecordDeleted;
			NDGetNode( pfucb );
			}
		else if ( ns == nsInvalid )
			{
			return JET_errRecordDeleted;
			}
		else
			{
			Assert( ns == nsVerInDB );
			NDGetNode( pfucb );
			}
		}
	else
		{
		if ( FNDDeleted( *pssib->line.pb ) )
			return JET_errRecordDeleted;
		NDGetNode( pfucb );
		}

	return JET_errSuccess;
	}


#ifdef DEBUG
VOID AssertBTGetNode( FUCB *pfucb, CSR *pcsr )
	{
	SSIB		*pssib = &pfucb->ssib;
	NS			ns;
	SRID		srid;

	Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
	AssertNDGet( pfucb, pcsr->itag );

	Assert( CbNDKey( pssib->line.pb ) == pfucb->keyNode.cb );
	Assert( CbNDKey( pssib->line.pb ) == 0 ||
		PbNDKey( pssib->line.pb ) == pfucb->keyNode.pb );

	Assert( FNDVerDel( *pssib->line.pb ) ||
		CbNDData( pssib->line.pb, pssib->line.cb ) == pfucb->lineData.cb );
	Assert( FNDVerDel( *pssib->line.pb ) ||
		pfucb->lineData.cb == 0 ||
		PbNDData( pssib->line.pb ) == pfucb->lineData.pb );

	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		LINE	lineData;

		lineData.pb = pfucb->lineData.pb;
		lineData.cb = pfucb->lineData.cb;

		NDGetBookmark( pfucb, &srid );
		Assert( pcsr->bm == srid );

		ns = NsVERAccessNode( pfucb, srid );
		Assert( ns != nsDatabase || !FNDDeleted( *(pfucb->ssib.line.pb) ) );
		Assert( ns != nsInvalid );
		if ( ns == nsDatabase )
			NDGetNode( pfucb );

//		Assert( lineData.pb == pfucb->lineData.pb );
  		Assert( lineData.cb == pfucb->lineData.cb );
		}
	else
		{
		Assert( !FNDDeleted( *(pfucb->ssib.line.pb) ) );
		}

	return;
	}
#endif


LOCAL INLINE ERR ErrBTIMoveToFather( FUCB *pfucb )
	{
	ERR		err;

	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	/*	allocate new CSR
	/**/
	CallR( ErrFUCBNewCSR( pfucb ) );
	PcsrCurrent( pfucb )->pgno = PcsrCurrent( pfucb )->pcsrPath->pgno;
	PcsrCurrent( pfucb )->itagFather = PcsrCurrent( pfucb )->pcsrPath->itag;
	NDGet( pfucb, PcsrCurrent( pfucb )->itagFather );
	return err;
	}


/*	if a seek land on the first node of a page with a key larger
/*	than the search key or on the last node of a page with the key
/*	smaller than the search key, then we must move to previous or
/*	next pages, respectively, to look for the search key node.
/*	If found equal or less or greater respectively, then done.
/**/
LOCAL INLINE ERR ErrBTIMoveToSeek( FUCB *pfucb, DIB *pdib, BOOL fNext )
	{
	ERR		err;
	INT		s = fNext ? -1 : 1;
	INT		sLimit = fNext ? 1 : -1;

	forever
		{
		err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fNext, pdib );
		if ( err < 0 )
			{
			if ( err == JET_errNoCurrentRecord )
				{
				Call( ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), !fNext, pdib ) );
				break;
				}
			goto HandleError;
			}
		s = CmpStKey( StNDKey( pfucb->ssib.line.pb ), pdib->pkey );
		if ( s == 0 )
			{
			err = JET_errSuccess;
			goto HandleError;
			}
		/*	if s is same sign as limit then break
		/**/
		if ( s * sLimit > 0 )
			{
			Assert( s < 0 && sLimit == -1 || s > 0 && sLimit == 1 );
			break;
			}
		}

	Assert( s != 0 );
	err = ( s > 0 ) ? wrnNDFoundGreater : wrnNDFoundLess;

HandleError:
	return err;
	}


LOCAL INLINE ERR ErrBTIMoveToReplace( FUCB *pfucb, KEY *pkey, PGNO pgno, INT itag )
	{
	ERR		err;
	INT		s;
	SSIB	*pssib = &pfucb->ssib;
	CSR		*pcsr = PcsrCurrent( pfucb );
	DIB		dibT = { 0, NULL, fDIRAllNode };

	Assert( itag >= 0 && itag < ctagMax );
	Assert( pgno != pgnoNull );

	/*	determine if we seeked high of key, low of key or in key range.
	/**/
	s = CmpStKey( StNDKey( pssib->line.pb ), pkey );

	/*	if not found greater then move forward in key range looking
	/*	for node to replace.  Stop searching forward if keys greater
	/*	than seek key.
	/**/
	if ( s <= 0 )
		{
		do
			{
			err = ErrBTNextPrev( pfucb, pcsr, fTrue, &dibT );
			if ( err < 0 )
				{
				if ( err != JET_errNoCurrentRecord )
					goto HandleError;
				break;
				}
			if ( pcsr->pgno == pgno && pcsr->itag == itag )
				{
				return JET_errSuccess;
				}
			s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
			}
		while ( s <= 0 );
		}

	/*	found greater or ran out of nodes.  Now move previous until
	/*	node to replace found.  Since node was not found greater, it
	/*	must be found on move previous.
	/**/
	do
		{
		Call( ErrBTNextPrev( pfucb, pcsr, fFalse, &dibT ) );
		Assert( CmpStKey( StNDKey( pssib->line.pb ), pkey ) >= 0 );
		}
	while ( pcsr->pgno != pgno || pcsr->itag != itag );

	err = JET_errSuccess;
HandleError:
	return err;
	}


/*	moves to next/prev node which is equal to or greater/less than the
/*	given key.  The only flag read is fDIRReplaceDuplicate which
/*	causes currency to held on a duplicate key if found.
/**/
LOCAL INLINE ERR ErrBTIMoveToInsert( FUCB *pfucb, KEY *pkey, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	INT		s;
	PGNO	pgno;
	DIB		dib;
	BOOL	fDuplicate;

	/*	if tree is empty then pcsr->itag will be itagNil, and correct
	/*	insert position has been found.
	/**/
	if ( pcsr->itag == itagNil )
		{
		return JET_errSuccess;
		}

	AssertNDGet( pfucb, pcsr->itag );
	s = CmpStKey( StNDKey( pssib->line.pb ), pkey );

	/*	The common case for insert, is inserting a new largest node.  This
	/*	case is shown by a seek to the last node, of the last page, where
	/*	the key found is less than the insert key.  Since this case is the
	/*	most common, it must be handled the most efficiently.
	/**/
	if ( s < 0 )
		{
		PgnoNextFromPage( pssib, &pgno );
		if ( pgno == pgnoNull )
			{
			NDGet( pfucb, pcsr->itagFather );
			if ( pcsr->ibSon == CbNDSon( pssib->line.pb ) - 1 )
				{
				/*	node found has key less than insert key, so move
				/*	to next virtual greater node for insert.
				/**/
				pcsr->ibSon++;
				err = wrnNDFoundGreater;
				return err;
				}
			}
		}

#if 0
	/*	the next most common case is that we landed in the middle of
	/*	a page in a correct position.  We found greater and are not
	/*	on the last son or first son.
	/**/
	if ( s > 0 && pcsr->ibSon > 0 )
		{
		NDGet( pfucb, itagFOP );
		if ( pcsr->ibSon < CbNDSon( pssib->line.pb ) )
			{
			err = wrnNDFoundGreater;
			return err;
			}
		}
#endif

	/*	set DIB for movement over potential nodes.
	/**/
	dib.fFlags = fDIRPotentialNode;

	/*	if found greater or equal, then move previous until found equal
	/*	or less. This must be done to check for any nodes with insert key.
	/*	Only potential nodes need be considered.
	/*
	/*	Note that even if we land via seek on a duplicate, the node
	/*	is not necessarily there.
	/**/
	if ( s >= 0 )
		{
		do
			{
			err = ErrBTNextPrev( pfucb, pcsr, fFalse, &dib );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					{
					s = -1;
					break;
					}
				goto HandleError;
				}
			s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
			}
		while ( s > 0 );
		}

	/*	initialize fDuplicate
	/**/
	fDuplicate = ( s == 0 );

	/*	set DIB for movement over all nodes
	/**/
	dib.fFlags = fDIRAllNode;

	/*	move next until find greater
	/**/
	do
		{
		err = ErrBTNextPrev( pfucb, pcsr, fTrue, &dib );
		if ( err < 0 )
			{
			if ( err == JET_errNoCurrentRecord )
				{
				/*	may have moved to empty page.
				/**/
				s = 1;
				break;
				}
			goto HandleError;
			}
		s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
		if ( s == 0 && FBTPotThere( pfucb ) )
			{
			fDuplicate = fTrue;
			}
		}
	while ( s <= 0 );
	Assert( s > 0 );

	/*	Need to move previous to duplicate if fDIRReplaceDuplicate
	/*	flag set.
	/**/
	if ( ( fDuplicate && ( fFlags & fDIRReplaceDuplicate ) ) )
		{
		/*	set DIB for movement over potential nodes.
		/**/
		dib.fFlags = fDIRPotentialNode;
		CallS( ErrBTNextPrev( pfucb, pcsr, fFalse, &dib ) );
		Assert( CmpStKey( StNDKey( pssib->line.pb ), pkey ) == 0 );
		s = 0;
		}
	else if ( err == wrnDIREmptyPage && pcsr->ibSon == 0 )
		{
		dib.fFlags = fDIRAllNode | fDIRAllPage;
		err = ErrBTNextPrev( pfucb, pcsr, fFalse, &dib );
		Assert( err == JET_errSuccess || err == wrnDIREmptyPage );
		/*	node may have been inserted.  If found then check for
		/*	duplicate.
		/**/
		if ( err == JET_errSuccess )
			{
			s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
			if ( s == 0 && FBTPotThere( pfucb ) )
				{
				fDuplicate = fTrue;
				}
			}
		else
			{
			s = 1;
			}
		}

	Assert( s >= 0 );
	Assert( ( fFlags & fDIRReplaceDuplicate ) || s > 0 );
	if ( s == 0 )
		err = JET_errSuccess;
	else
		err = wrnNDFoundGreater;

	/*	check for illegal duplicate key.
	/**/
	if ( fDuplicate && !( fFlags & fDIRDuplicate ) )
		err = JET_errKeyDuplicate;
HandleError:
	return err;
	}


ERR ErrBTDown( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	ERR		errPos;
	CSR		*pcsr;
	SSIB	*pssib = &pfucb->ssib;
	INT		s;
	INT		ctagSon = 0;
	BOOL	fMoveToSeek = fFalse;

	/*	search down the tree from father
	/**/
	CallR( ErrBTIMoveToFather( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	tree may be empty
	/**/
	if ( FNDNullSon( *pssib->line.pb ) )
		{
		err = JET_errRecordNotFound;
		goto HandleError;
		}

	/*	search down the tree from father.
	/*	set pssib->itag for invisible son traversal.
	/**/
	if ( !FNDVisibleSons( *pssib->line.pb ) )
		{
		/*	seek through invisible sons.
		/**/
		do
			{
			/*	get child page from intrisic page pointer
			/*	if son count is 1 or from page pointer node
			/**/
			if ( pcsr->itagFather != itagFOP && CbNDSon( pssib->line.pb ) == 1 )
				{
				/*	if non-FDP page, SonTable of Intrinsic son FOP must be four bytes
				/**/
				AssertNDIntrinsicSon( pssib->line.pb, pssib->line.cb );
				pcsr->pgno = PgnoNDOfPbSon( pssib->line.pb );
				}
			else
				{
				switch ( pdib->pos )
					{
					case posDown:
						Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
						NDSeekSon( pfucb, pcsr, pdib->pkey, fDIRReplace );
						break;
					case posFirst:
						NDMoveFirstSon( pfucb, pcsr );
						break;
					case posLast:
						NDMoveLastSon( pfucb, pcsr );
						break;
					default:
						{
						Assert( pdib->pos ==  posFrac );
						pcsr->ibSon = IbsonBTFrac( pfucb, pcsr, pdib );
						CallS( ErrNDMoveSon( pfucb, pcsr ) );
						}
					}
				pcsr->pgno = *(PGNO UNALIGNED *)PbNDData( pssib->line.pb );
				}

			/*	get child page father node
			/**/
			Call( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
			Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
			NDGet( pfucb, itagFOP );
			pcsr->itagFather = itagFOP;
			}
		while ( !FNDVisibleSons( *pssib->line.pb ) );
		}

	/*	down to visible son
	/**/
	if ( FNDSon( *pssib->line.pb ) )
		{
		ctagSon = CbNDSon( pssib->line.pb );

		switch ( pdib->pos )
			{
			case posDown:
				Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
				NDSeekSon( pfucb, pcsr, pdib->pkey, fDIRReplace );
				break;
			case posFirst:
				NDMoveFirstSon( pfucb, pcsr );
				break;
			case posLast:
				NDMoveLastSon( pfucb, pcsr );
				break;
			default:
				{
				Assert( pdib->pos ==  posFrac );
				pcsr->ibSon = IbsonBTFrac( pfucb, pcsr, pdib );
				CallS( ErrNDMoveSon( pfucb, pcsr ) );
				}
			}
		}
	else
		{
		/*	must move to seek
		/**/
		fMoveToSeek = fTrue;

		/*	if we land on an empty page and there are no next previous
		/*	nodes.  What if the tree is empty.  We must first reverse
		/*	direction and if no node is found then return an empty tree
		/*	error code.  The empty tree error code should be the same
		/*	regardless of the size of the tree.
		/**/
		err = ErrBTNextPrev( pfucb, pcsr, pdib->pos != posLast, pdib );
		if ( err == JET_errNoCurrentRecord )
			Call( ErrBTNextPrev( pfucb, pcsr, pdib->pos == posLast, pdib ) );
		NDGet( pfucb, itagFOP );
		/* get right ctagSon */
		ctagSon = CbNDSon( pssib->line.pb );
		/* adjust pssib line back to the landed node */
		NDGet( pfucb, PcsrCurrent( pfucb )->itag );
		}

	/*	we have landed on a visible node
	/**/
	if ( pdib->pos == posDown )
		{
		s = CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey );
		if ( s == 0 )
			errPos = JET_errSuccess;
		else
			{
			if ( s < 0 )
				errPos = wrnNDFoundLess;
			else
				errPos = wrnNDFoundGreater;

			/*	if on last node in page and found less, or if landed on
			/*	first node in page and found greater, move next or previous
			/*	to look for node with search key.  These anomalies can
			/*	occur during update seek normally, and during read seek
			/*	when partial split pages are encountered.
			/**/
			Assert( pcsr->ibSon >= 0 && pcsr->ibSon < ctagSon );
			Assert( errPos == wrnNDFoundGreater &&
				pcsr->ibSon == 0 || pcsr->ibSon <= ( ctagSon - 1 ) );
			if ( fMoveToSeek ||
				( errPos == wrnNDFoundLess && pcsr->ibSon == ( ctagSon - 1 ) ) ||
				( errPos == wrnNDFoundGreater && pcsr->ibSon == 0 ) )
				{
				Call( ErrBTIMoveToSeek( pfucb, pdib, errPos == wrnNDFoundLess ) );
				errPos = err;
				}
			}
		}
	else
		{
		errPos = JET_errSuccess;
		}

	if ( !FBTThere( pfucb ) )
		{
		if ( pdib->pos == posDown )
			{
			/*	if current node is not there for us then move to next node.
			/*	if no next node then move to previous node.
			/*	if no previous node then return error.
			/**/
			err = ErrBTNextPrev( pfucb, pcsr, fTrue, pdib );
			if ( err < 0 && err != JET_errNoCurrentRecord )
				goto HandleError;
			if ( err == JET_errNoCurrentRecord )
				{
				Call( ErrBTNextPrev( pfucb, pcsr, fFalse, pdib ) );
				}

			/*	preferentially land on lesser key value node
			/**/
			if ( CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey ) > 0 )
				{
				err = ErrBTNextPrev( pfucb, pcsr, fFalse, pdib );
				if ( err == JET_errNoCurrentRecord )
					{
					CallS( ErrBTNextPrev( pfucb, pcsr, fTrue, pdib ) );
					err = JET_errSuccess;
					}
				}

			/*	reset errPos for new node location
			/**/
			if ( FKeyNull( pdib->pkey ) )
				{
				errPos = JET_errSuccess;
				}
			else
				{
				s = CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey );
				if ( s > 0 )
					errPos = wrnNDFoundGreater;
				else if ( s < 0 )
					errPos = wrnNDFoundLess;
				else
					errPos = JET_errSuccess;
				Assert( s != 0 || errPos == JET_errSuccess );
				}

			Assert( err != JET_errKeyBoundary && err != JET_errPageBoundary );
			if ( err == JET_errNoCurrentRecord )
				{
				/*	move previous
				/**/
				Call( ErrBTNextPrev( pfucb, pcsr, fFalse, pdib ) );
				errPos = wrnNDFoundLess;
				}
			else if ( err < 0 )
				goto HandleError;
			}
		else
			{
			err = ErrBTNextPrev( pfucb, pcsr, pdib->pos != posLast, pdib );
			if ( err == JET_errNoCurrentRecord )
				{
				/*	if fractional positioning, then try to
				/*	move previous to valid node.
				/**/
				if ( pdib->pos == posFrac )
					{
					err = ErrBTNextPrev( pfucb, pcsr, fFalse, pdib );
					}
				else
					err = JET_errRecordNotFound;
				}
			if ( err < 0 )
				goto HandleError;
			}
		}

	Assert( errPos >= 0 );
	FUCBResetStore( pfucb );
	return errPos;

HandleError:
	BTUp( pfucb );
	if ( err == JET_errNoCurrentRecord )
		err = JET_errRecordNotFound;
	return err;
	}


ERR ErrBTDownFromDATA( FUCB *pfucb, KEY *pkey )
	{
	ERR		err;
	ERR		errPos;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB 	*pssib = &pfucb->ssib;
	INT		s;
	INT		ctagSon = 0;
	BOOL 	fMoveToSeek = fFalse;

	/*	cache initial currency in case seek fails.
	/**/
	FUCBStore( pfucb );

	/*	set father currency to DATA root
	/**/
	pcsr->csrstat = csrstatOnCurNode;

	/*	read access page and check for valid time stamp
	/**/
	pcsr->pgno = PgnoRootOfPfucb( pfucb );
	while ( !FReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallR( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
		Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
		pcsr->pgno = PgnoRootOfPfucb( pfucb );
		}
	pcsr->itagFather = ItagRootOfPfucb( pfucb );

	NDGet( pfucb, pcsr->itagFather );

	/* save current node as visible father
	/**/
	if ( FNDBackLink( *((pfucb)->ssib.line.pb) ) )
		{
		pfucb->sridFather = *(SRID UNALIGNED *)PbNDBackLink((pfucb)->ssib.line.pb);
		}
	else																						
		{
		pfucb->sridFather = SridOfPgnoItag( pcsr->pgno, pcsr->itagFather );
		}
	Assert( pfucb->sridFather != sridNull );
	Assert( pfucb->sridFather != sridNullLink );

	/*	tree may be empty
	/**/
	if ( FNDNullSon( *pssib->line.pb ) )
		{
		err = JET_errRecordNotFound;
		return err;
		}

	/*	search down the tree from father.
	/*	set pssib->itag for invisible son traversal.
	/**/
	if ( !FNDVisibleSons( *pssib->line.pb ) )
		{
		/*	seek through invisible sons.
		/**/
		do
			{
			/*	get child page from intrisic page pointer
			/*	if son count is 1 or from page pointer node
			/**/
			if (  pcsr->itagFather != itagFOP && CbNDSon( pssib->line.pb ) == 1 )
				{
				/*	If non-FDP page, SonTable of Intrinsic son FOP must be four bytes
				/**/
				AssertNDIntrinsicSon( pssib->line.pb, pssib->line.cb );
				pcsr->pgno = PgnoNDOfPbSon( pssib->line.pb );
				}
			else
				{
				Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
				NDSeekSon( pfucb, pcsr, pkey, fDIRReplace );
				pcsr->pgno = *(PGNO UNALIGNED *)PbNDData( pssib->line.pb );
				}

			/*	get child page father node
			/**/
			Call( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
			Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
			NDGet( pfucb, itagFOP );
			pcsr->itagFather = itagFOP;
			}
		while ( !FNDVisibleSons( *pssib->line.pb ) );
		}

	/*	down to visible son
	/**/
	if ( FNDSon( *pssib->line.pb ) )
		{
		ctagSon = CbNDSon( pssib->line.pb );
		Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
		NDSeekSon( pfucb, pcsr, pkey, fDIRReplace );
		}
	else
		{
		DIB	dibT;

		/*	must move to seek
		/**/
		fMoveToSeek = fTrue;

		/*	If we land on an empty page and there are no next previous
		/*	nodes.  What if the tree is empty.  We must first reverse
		/*	direction and if no node is found then return an empty tree
		/*	error code.  The empty tree error code should be the same
		/*	regardless of the size of the tree.
		/**/
		dibT.fFlags = fDIRNull;
		err = ErrBTNextPrev( pfucb, pcsr, fTrue, &dibT );
		if ( err == JET_errNoCurrentRecord )
			Call( ErrBTNextPrev( pfucb, pcsr, fFalse, &dibT ) );

		/*	determine number of sons in FOP for this page
		/**/
		NDGet( pfucb, itagFOP );
		ctagSon = CbNDSon( pssib->line.pb );

		/*	recache son node.
		/**/
		NDGet( pfucb, pcsr->itag );
		}

	/*	we have landed on a visible node
	/**/
	s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
	if ( s == 0 )
		errPos = JET_errSuccess;
	else
		{
		if ( s < 0 )
			errPos = wrnNDFoundLess;
		else
			errPos = wrnNDFoundGreater;

		/*	if on last node in page and found less, or if landed on
		/*	first node in page and found greater, move next or previous
		/*	to look for node with search key.  These anomalies can
		/*	occur during update seek normally, and during read seek
		/*	when partial split pages are encountered.
		/**/
		Assert( ( ctagSon == 0 && pcsr->ibSon == 0 ) ||
			pcsr->ibSon < ctagSon );
		Assert( errPos == wrnNDFoundGreater &&
			pcsr->ibSon == 0 ||
			ctagSon == 0 ||
			pcsr->ibSon <= ( ctagSon - 1 ) );
		if ( fMoveToSeek ||
			( errPos == wrnNDFoundLess && pcsr->ibSon == ( ctagSon - 1 ) ) ||
			( errPos == wrnNDFoundGreater && pcsr->ibSon == 0 ) )
			{
			DIB	dibT;

			dibT.fFlags = fDIRNull;
			dibT.pkey = pkey;

			Call( ErrBTIMoveToSeek( pfucb, &dibT, errPos == wrnNDFoundLess ) );
			errPos = err;
			}
		}

	if ( !FBTThere( pfucb ) )
		{
		DIB		dibT;

		dibT.fFlags = fDIRNull;

		/*	if current node is not there for us then move to next node.
		/*	if no next node then move to previous node.
		/*	if no previous node then return error.
		/**/
		err = ErrBTNextPrev( pfucb, pcsr, fTrue, &dibT );
		if ( err < 0 && err != JET_errNoCurrentRecord )
			goto HandleError;
		if ( err == JET_errNoCurrentRecord )
			{
			Call( ErrBTNextPrev( pfucb, pcsr, fFalse, &dibT ) );
			}

		/*	preferentially land on lesser key value node
		/**/
		if ( CmpStKey( StNDKey( pssib->line.pb ), pkey ) > 0 )
			{
			err = ErrBTNextPrev( pfucb, pcsr, fFalse, &dibT );
			if ( err == JET_errNoCurrentRecord )
				{
				/*	cannot assume will find node since all nodes
				/*	may not be there for this session.
				/**/
				Call( ErrBTNextPrev( pfucb, pcsr, fTrue, &dibT ) );
				}
			}

		/*	reset errPos for new node location
		/**/
		s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
		if ( s > 0 )
			errPos = wrnNDFoundGreater;
		else if ( s < 0 )
			errPos = wrnNDFoundLess;
		Assert( s != 0 || errPos == JET_errSuccess );

		Assert( err != JET_errKeyBoundary && err != JET_errPageBoundary );
		if ( err == JET_errNoCurrentRecord )
			{
			DIB	dibT;
			dibT.fFlags = fDIRNull;

			/*	move previous
			/**/
			Call( ErrBTNextPrev( pfucb, pcsr, fFalse, &dibT ) );
			errPos = wrnNDFoundLess;
			}
		else if ( err < 0 )
			goto HandleError;
		}

	Assert( errPos >= 0 );
	return errPos;

HandleError:
	FUCBRestore( pfucb );
	if ( err == JET_errNoCurrentRecord )
		err = JET_errRecordNotFound;
	return err;
	}


//+private------------------------------------------------------------------------
//	ErrBTNextPrev
// ===========================================================================
//	ERR ErrBTNextPrev( FUCB *pfucb, CSR *pcsr INT fNext, const DIB *pdib )
//
//	Given pcsr may be to any CSR in FUCB stack.  We may be moving on
//	non-current CSR when updating CSR stack for split.
//
// RETURNS		JET_errSuccess
//				JET_errNoCurrentRecord
//				JET_errPageBoundary
//				JET_errKeyBoundary
//				error from called routine
//----------------------------------------------------------------------------
extern LONG lPageReadAheadMax;
ERR ErrBTNextPrev( FUCB *pfucb, CSR *pcsr, INT fNext, DIB *pdib )
	{
	ERR 	err;
	PN		pnNext;
	SSIB	*pssib = &pfucb->ssib;
	PGNO	pgnoSource;
	PGNO	pgnoT;
	ERR		wrn = 0;
	ULONG	ulPageReadAheadMax;

	/*	make current page accessible
	/**/
	if ( !FReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallR( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
		Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
		}

	/*	get father node
	/**/
Start:
	NDGet( pfucb, pcsr->itagFather );

	pcsr->ibSon += ( fNext ? 1 : -1 );
	err = ErrNDMoveSon( pfucb, pcsr );
	if ( err < 0 )
		{
		Assert( err == errNDOutSonRange );

		/*	if tree interior to page, then there is no page to move
		/*	to and return end code.
		/**/
		if ( pcsr->itagFather != itagFOP )
			{
			pcsr->csrstat = fNext ? csrstatAfterCurNode : csrstatBeforeCurNode;
			return JET_errNoCurrentRecord;
			}

#ifdef INPAGE
		/*	do not move to next page if fDIRInPage set
		/**/
		if ( pdib->fFlags & fDIRInPage )
			{
			pcsr->ibSon -= ( fNext ? 1 : -1 );
			pcsr->csrstat = fNext ? csrstatAfterCurNode : csrstatBeforeCurNode;
			return JET_errPageBoundary;
			}
#endif

		pgnoSource = pcsr->pgno;

		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itagFather );
		if ( FNDSon( *pssib->line.pb ) )
			{
			/*	store bookmark for current node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetBookmarkFromCSR( pfucb, pcsr, &pfucb->bmRefresh );
			}
		else
			{
			/*	store currency for refresh, when cursor
			/*	is on page with no sons.
			/**/
			pfucb->bmRefresh = SridOfPgnoItag( pcsr->pgno, itagFOP );
			}

		/*	move to next or previous page until node found
		/**/
		forever
			{
			PGNO pgnoBeforeMoveNext = pcsr->pgno;

			/*	there may not be a next page
			/**/
			LFromThreeBytes( pgnoT, *(THREEBYTES *)PbPMGetChunk( pssib, fNext ? ibPgnoNextPage : ibPgnoPrevPage ) );
			if ( pgnoT == pgnoNull )
				{
				pcsr->csrstat = fNext ? csrstatAfterLast : csrstatBeforeFirst;
				return JET_errNoCurrentRecord;
				}

			/*	if parent CSR points to invisible node, then correct to next page.
			/*	Check all node flag, since it is always set on movement for
			/*	update, and when moving not for update, parent CSR may not be CSR
			/*	of parent invisible node.
			/**/
			if ( FFUCBFull( pfucb ) )
				{
				CSR	*pcsrT = pcsr->pcsrPath;
				DIB	dibT = { 0, NULL, fDIRAllNode };

				Assert( pcsrT != pcsrNil );

				/*	go to parent node, and
				/*	if sons are invisible, then increment son count
				/*	by cpageTraversed.
				/**/
				CallR( ErrSTReadAccessPage( pfucb, pcsrT->pgno ) );
				Assert( FReadAccessPage( pfucb, pcsrT->pgno ) );
				NDGet( pfucb, pcsrT->itagFather );
				if ( FNDInvisibleSons( *pssib->line.pb ) )
					{
					err = ErrBTNextPrev( pfucb, pcsrT, fNext, &dibT );
					Assert( err != JET_errNoCurrentRecord );
					CallR( err );
					}
				}

			/*	access new page
			/**/
			pcsr->pgno = pgnoT;
			CallR( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
			Assert( FReadAccessPage( pfucb, pcsr->pgno ) );

			/*	if destination page was split, such that data may have
			/*	been erroneously skipped, goto bookmark of last valid
			/*	postion and move again.
			/**/
			if ( fNext )
				{
				PgnoPrevFromPage( pssib, &pgnoT );
				}
			else
				{
				PgnoNextFromPage( pssib, &pgnoT );
				}

			if ( pgnoBeforeMoveNext != pgnoT )
				{
				BFSleep( cmsecWaitGeneric );

			  	Call( ErrBTGotoBookmark( pfucb, pfucb->bmRefresh ) );
				continue;
				}

		Assert( FReadAccessPage( pfucb, pcsr->pgno ) );

  		/*	read ahead
		/**/
//		ulPageReadAheadMax = (ULONG) lPageReadAheadMax;
		ulPageReadAheadMax = 1;
		if ( fNext )
				{
				Assert( pfucb->cpn <= ulPageReadAheadMax );
				if ( pfucb->cpn == 0 || --pfucb->cpn < ulPageReadAheadMax / 2 )
					{
					PgnoNextFromPage( pssib, &pnNext );
					if ( pnNext != pnNull )
						{
						INT	ipn = 0;

						pnNext |= ((LONG)pfucb->dbid)<<24;
						pnNext += pfucb->cpn;
						pfucb->cpn = ulPageReadAheadMax;

						/*	lock the contents to make sure the pfucb->lineData
						/*	are effective after ReadAsyn.
						/**/
		 				BFPin( pfucb->ssib.pbf );
//		 				BFSetReadLatch( pfucb->ssib.pbf, pfucb->ppib );

		 				BFReadAsync( pnNext, ulPageReadAheadMax );

//						BFResetReadLatch( pfucb->ssib.pbf, pfucb->ppib );
						Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
						BFUnpin( pfucb->ssib.pbf );
						}
					else
						{
						/*	reset read-ahead counter when reach end of index.
						/**/
						pfucb->cpn = 0;
						}
					}
				}
			else
				{
				Assert( pfucb->cpn <= ulPageReadAheadMax );
				if ( pfucb->cpn == 0 || --pfucb->cpn < ulPageReadAheadMax / 2 )
					{
					PgnoPrevFromPage( pssib, &pnNext );
					if ( pnNext != pnNull )
						{
						/*	cannot read-ahead off begining of database.
						/**/
						if ( pnNext > pfucb->cpn )
							{
							pnNext |= ((LONG)pfucb->dbid)<<24;
							pnNext -= pfucb->cpn;
							pfucb->cpn = ulPageReadAheadMax;

							/* lock the contents to make sure the
							/*	pfucb->lineData are effective after ReadAsyn.
							/**/
							BFPin( pfucb->ssib.pbf );
//							BFSetReadLatch( pfucb->ssib.pbf, pfucb->ppib );

		 					BFReadAsync( pnNext - ( ulPageReadAheadMax - 1 ), ulPageReadAheadMax );

//							BFResetReadLatch( pfucb->ssib.pbf, pfucb->ppib );
							Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
							BFUnpin( pfucb->ssib.pbf );
							}
						}
					else
						{
						/*	reset read-ahead counter when reach end of index.
						/**/
						pfucb->cpn = 0;
						}
					}
				}

			/*	check read access again since buffer may
			/*	be wait latched.  Note that it has been found
			/*	wait latched as a result of loss of critJet.
			/**/
			if ( !FReadAccessPage( pfucb, pcsr->pgno ) )
				{
				CallR( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
				Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
				}

			/*	get father node
			/**/
			Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
			pcsr->itagFather = itagFOP;
			NDGet( pfucb, pcsr->itagFather );

			/*	if moving to next/prev son, then stop if found node.
			/**/
			if ( FNDSon( *pssib->line.pb ) )
				{
				if ( fNext )
					NDMoveFirstSon( pfucb, pcsr );
				else
					NDMoveLastSon( pfucb, pcsr );
				break;
				}
			else
				{
				/*	set ibSon for insertion
				/**/
				pcsr->ibSon = 0;

				/*	if  page is write latched by this cursor via
				/*	split then return wrnDIREmptyPage as insertion point
				/**/
				if ( pfucb->ssib.pbf->cWriteLatch > 0 &&
					pfucb->ssib.pbf->ppibWriteLatch == pfucb->ppib )
					wrn = wrnDIREmptyPage;

				if ( pdib->fFlags & fDIRAllPage )
					{
					err = JET_errSuccess;
					goto HandleError;
					}
				}

			/*	update pgnoSource to new source page.
			/**/
			pgnoSource = pcsr->pgno;
			}
		}

	/*	get current node
	/**/
	NDGet( pfucb, pcsr->itag );

	/*	move again if fDIRNeighborKey set and next node has same key
	/**/
	if ( pdib->fFlags & fDIRNeighborKey )
		{
		if ( CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey ) == 0 )
			goto Start;
		}

	if ( !( pdib->fFlags & fDIRAllNode ) )
		{
		if  ( !FBTThere( pfucb ) )
			{
			if ( ( pdib->fFlags & fDIRPotentialNode ) != 0 )
				{
				VS		vs;
				BOOL	fDelete = FNDDeleted( *pssib->line.pb );
				SRID	srid;

				NDGetBookmark( pfucb, &srid );
				vs = VsVERCheck( pfucb, srid );
				if ( !( FVERPotThere( vs, fDelete ) ) )
					{
					goto Start;
					}
				}
			else
 				goto Start;
			}
		}

	pcsr->csrstat = csrstatOnCurNode;
	err = JET_errSuccess;

HandleError:
	/*	return empty page warning.
	/**/
	if ( err == JET_errSuccess )
		err = wrn;
	return err;
	}


ERR ErrBTSeekForUpdate( FUCB *pfucb, KEY *pkey, PGNO pgno, INT itag, INT fFlags )
	{
	ERR		err;
	CSR		**ppcsr = &PcsrCurrent( pfucb );
	CSR		*pcsrRoot = *ppcsr;
	SSIB 	*pssib = &pfucb->ssib;
	ERR		errPos = JET_errSuccess;

	Assert( ( fFlags & fDIRReplace ) || pgno == pgnoNull );

	/* search down the tree from the father
	/**/
	Call( ErrBTIMoveToFather( pfucb ) );

	if ( FNDNullSon( *pssib->line.pb ) )
		{
		(*ppcsr)->ibSon = 0;
		errPos = wrnNDFoundGreater;
		goto Done;
		}

	while ( !FNDVisibleSons(*pssib->line.pb) )
		{
		PGNO	pgno;

		if (  (*ppcsr)->itagFather != itagFOP && CbNDSon( pssib->line.pb ) == 1 )
			{
			/* if non-FDP page, SonTable of Intrinsic son FOP must be four bytes
			/**/
			(*ppcsr)->ibSon = 0;
			(*ppcsr)->itag = itagNil;
			(*ppcsr)->csrstat = csrstatOnCurNode;
			AssertNDIntrinsicSon( pssib->line.pb, pssib->line.cb );
			pgno = PgnoNDOfPbSon( pssib->line.pb );
			Assert( (pgno & 0xff000000) == 0 );
			}
		else
			{
			Assert( FReadAccessPage( pfucb, (*ppcsr)->pgno ) );
			NDSeekSon( pfucb, *ppcsr, pkey, fFlags );
			(*ppcsr)->csrstat = csrstatOnCurNode;
			pgno = *(PGNO UNALIGNED *)PbNDData( pssib->line.pb );
			Assert( (pgno & 0xff000000) == 0 );
			}

		/*	only preserve invisible CSR stack for splits
		/**/
		if ( FFUCBFull( pfucb ) )
			{
			CSRSetInvisible( *ppcsr );
			Call( ErrFUCBNewCSR( pfucb ) );
			}

		(*ppcsr)->pgno = pgno;
		Call( ErrSTReadAccessPage( pfucb, (*ppcsr)->pgno ) );
		Assert( FReadAccessPage( pfucb, (*ppcsr)->pgno ) );
		(*ppcsr)->itagFather = itagFOP;
		NDGet( pfucb, (*ppcsr)->itagFather );
		}

	/*	seek to son or move to next son if no nodes on this page.
	/**/
	if ( FNDSon( *pssib->line.pb ) )
		{
		Assert( FReadAccessPage( pfucb, (*ppcsr)->pgno ) );
		NDSeekSon( pfucb, *ppcsr, pkey, fFlags );
		(*ppcsr)->csrstat = csrstatOnCurNode;

		/*	no current record indicates no sons so must ensure
		/*	not this error value here.
		/**/
		Assert( err != JET_errNoCurrentRecord );
		}
	else
		{
		DIB	dib;
		dib.fFlags = fDIRAllNode;
		err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib );
		if ( err == JET_errNoCurrentRecord )
			{
			err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fFalse, &dib );
			Assert( err >= JET_errSuccess || PcsrCurrent( pfucb )->ibSon == 0 );
			}
		}

	/*	if no leaf sons then ibSon must be 0
	/**/
	Assert( err != JET_errNoCurrentRecord || PcsrCurrent( pfucb )->ibSon == 0 );

	/*	now we must be on a node, but it may not be the node to replace
	/*	or the correct location to insert.  If we are replacing a node
	/*	and we are not on the correct pgno:itag, then move to node to
	/*	replace.  If we are inserting, then move to correct insert location.
	/**/
	if ( err != JET_errNoCurrentRecord )
		{
		if ( fFlags & fDIRReplace )
			{
			if ( ( (*ppcsr)->pgno != pgno || (*ppcsr)->itag != itag ) )
				{
				Call( ErrBTIMoveToReplace( pfucb, pkey, pgno, itag ) );
				Assert( (*ppcsr)->itag == itag && (*ppcsr)->pgno == pgno );
				}
			errPos = JET_errSuccess;
			(*ppcsr)->csrstat = csrstatOnCurNode;
			}
		else
			{
			Call( ErrBTIMoveToInsert( pfucb, pkey, fFlags ) );
			errPos = err;
			(*ppcsr)->csrstat = csrstatBeforeCurNode;
			}
		}
	else
		{
		/*	if we are attempting a replace, cursor must get current record
		/**/
		Assert( !( fFlags & fDIRReplace ) );
		}

Done:
	FUCBResetStore( pfucb );
	return errPos;

HandleError:
	FUCBFreePath( ppcsr, pcsrRoot );
	FUCBRestore( pfucb );
	return err;
	}


/*	Caller seeks to insert location, prior to calling ErrBTInsert.
/*	If sufficient page space is available for insertion
/*	then insert takes place.  Otherwise, split page and return error
/*	code.  Caller may reseek in order to avoid duplicate keys, merge
/*	into existing item, etc..
/**/
ERR ErrBTInsert( FUCB *pfucb, INT fHeader, KEY *pkey, LINE *pline, INT fFlags )
	{
	ERR		err;
	SSIB	*pssib = &pfucb->ssib;
	CSR	  	**ppcsr = &PcsrCurrent( pfucb );
	INT	  	cbReq;
	BOOL	fAppendNextPage;

	/* insert a new son into the page and insert the son entry
	/* to the father node located by the currency
	/**/
	cbReq = cbNullKeyData + CbKey( pkey ) + CbLine( pline );
	if ( ( fAppendNextPage = FBTAppendPage( pfucb, *ppcsr, cbReq, 0, CbFreeDensity( pfucb ) ) ) || FBTSplit( pssib, cbReq, 1 ) )
		{
		Call( ErrBTSplit( pfucb, 0, cbReq, pkey, fFlags ) );
		err = errDIRNotSynchronous;
		goto HandleError;
		}

	/*	must not give up critical section during insert, since
	/*	other thread could also insert node with same key.
	/**/
	Assert( FWriteAccessPage( pfucb, (*ppcsr)->pgno ) );

	/*	add visible son flag to node header
	/**/
	NDSetVisibleSons( fHeader );
	if ( fFlags & fDIRVersion )
		NDSetVersion( fHeader);
	Call( ErrNDInsertNode( pfucb, pkey, pline, fHeader ) );
	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
HandleError:
	return err;
	}


ERR ErrBTReplace( FUCB *pfucb, LINE *pline, INT fFlags )
	{
	ERR		err;
	SSIB	*pssib;
	INT		cbNode;
	INT		cbReq;

	/*	replace data
	/**/
	Assert( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	err = ErrNDReplaceNodeData( pfucb, pline, fFlags );

	/*	new data could not fit on page so split page
	/**/
	if ( err == errPMOutOfPageSpace )
		{
		INT	cbReserved;

		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
		pssib = &pfucb->ssib;

		if ( FNDVersion( *pfucb->ssib.line.pb ) )
			{
			//	UNDONE:	change CbVERGetNodeReserved to take itag from CSR
			pssib->itag = PcsrCurrent( pfucb )->itag;
			cbReserved = CbVERGetNodeReserve( pfucb, PcsrCurrent( pfucb )->bm );
			if ( cbReserved < 0 )
				cbReserved = 0;
			}
		else
			{
			cbReserved = 0;
			}

		cbNode = pfucb->ssib.line.cb;
		cbReq = pline->cb - CbNDData( pssib->line.pb, pssib->line.cb );
		Assert( cbReserved >= 0 && cbReq - cbReserved > 0 );
		cbReq -= cbReserved;
		Assert( cbReq > 0 );
		Assert( pfucb->pbfEmpty == pbfNil );
		Call( ErrBTSplit( pfucb, cbNode, cbReq, NULL, fFlags | fDIRDuplicate | fDIRReplace ) );
		Assert( pfucb->pbfEmpty == pbfNil );
		err = errDIRNotSynchronous;
		}

HandleError:
	return err;
	}


ERR ErrBTDelete( FUCB *pfucb, INT fFlags )
	{
	ERR		err;

	/*	write access current node
	/**/
	if ( !( FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) ) )
		{
		Call( ErrSTWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		}

	Call( ErrNDFlagDeleteNode( pfucb, fFlags ) );

	Assert( err == JET_errSuccess );
HandleError:
	return err;
	}


/* Gets the invisible csrPath to this page
/* using BTSeekForUpdate from sridFather
/**/
ERR ErrBTGetInvisiblePagePtr( FUCB *pfucb, SRID sridFather )
	{
	ERR		err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	CSR  	**ppcsr = &PcsrCurrent( pfucb );
	/*	store currency for split path construction
	/**/
	BYTE	rgb[JET_cbKeyMost];
	KEY		key;
	PGNO	pgno;
	INT		itag;

	/*	cache pgno, itag and key of current node
	/*	for subsequent seek for update
	/**/
	pgno = (*ppcsr)->pgno;
	itag = (*ppcsr)->itag;
	key.pb = rgb;
	NDGet( pfucb, (*ppcsr)->itag );
	key.cb = CbNDKey( pssib->line.pb );
	Assert( sizeof(rgb) >= key.cb );
	memcpy( rgb, PbNDKey( pssib->line.pb ), key.cb );

	/*	move to visible father and seek for update.
	/**/
	FUCBStore( pfucb );
	Call( ErrBTGotoBookmark( pfucb, sridFather ) );
	if ( !FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
		{
		CallR( ErrSTReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		}
	/*	if sridFather is of node in same page to free then
	/*	return error.
	/**/
	if ( PcsrCurrent( pfucb )->pgno == pgno )
		return errDIRInPageFather;
	FUCBSetFull( pfucb );
	err = ErrBTSeekForUpdate( pfucb, &key, pgno, itag, fDIRReplace );
	FUCBResetFull( pfucb );
	Call( err );
	Assert( err == JET_errSuccess );

	Assert( (*ppcsr)->pgno == pgno && (*ppcsr)->itag == itag );
	Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );
	FUCBResetStore( pfucb );
	return err;

HandleError:
	FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrNil );
	FUCBRestore( pfucb ) ;
	return err;
	}


#ifdef DEBUG
/*	checks the invisible csrPath to this page
/*	using BTSeekForUpdate from sridFather
/**/
ERR ErrBTCheckInvisiblePagePtr( FUCB *pfucb, SRID sridFather )
	{
	ERR		err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	CSR  	**ppcsr = &PcsrCurrent( pfucb );
	/*	store currency for split path construction
	/**/
	BYTE	rgb[JET_cbKeyMost];
	KEY		key;
	PGNO	pgno;
	INT		itag;

	/*	cache pgno, itag and key of current node
	/*	for subsequent seek for update
	/**/
	pgno = (*ppcsr)->pgno;
	itag = (*ppcsr)->itag;
	key.pb = rgb;
	NDGet( pfucb, (*ppcsr)->itag );
	key.cb = CbNDKey( pssib->line.pb );
	Assert( sizeof(rgb) >= key.cb );
	memcpy( rgb, PbNDKey( pssib->line.pb ), key.cb );

	/*	move to visible father and seek for update.
	/**/
	FUCBStore( pfucb );
	Call( ErrBTGotoBookmark( pfucb, sridFather ) );

	if ( !FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
		{
		CallR( ErrSTReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		}
	
	err = ErrBTSeekForUpdate( pfucb, &key, pgno, itag, fDIRReplace );
	Call( err );
	Assert( err == JET_errSuccess );

	Assert( (*ppcsr)->pgno == pgno && (*ppcsr)->itag == itag );
	Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );
	FUCBResetStore( pfucb );
	return err;

HandleError:
	FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrNil );
	FUCBRestore( pfucb ) ;
	return err;
	}
#endif


ERR ErrBTGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal )
	{
	ERR 	 	err;
	CSR			*pcsrRoot = PcsrCurrent( pfucb );
	CSR			*pcsrT;
	SSIB	 	*pssib = &pfucb->ssib;
	BYTE	 	rgb[JET_cbKeyMost];
	KEY			key;
	ULONG	 	ulTotal;
	ULONG	 	ulLT;
	PGNO	 	pgno = PcsrCurrent( pfucb )->pgno;
	INT			itag = PcsrCurrent( pfucb )->itag;

	/*	ErrBTGetPosition returns the position of the current leaf node
	/*	with respect to its siblings in the current tree.  The position
	/*	is returned in the form of an estimated total tree leaf nodes,
	/*	at the leaf level, and an estimated number
	/*	of nodes at the same level, occurring previous in key order to
	/*	the current node.
	/*
	/*	create full path from parent to node.  Calculate estimates
	/*	from path page information.  Free invisable path.
	/**/

	/*	this function only supports index leaf nodes
	/**/
	Assert( FFUCBIndex( pfucb ) );

	/*	cache key of current node
	/**/
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	key.cb = CbNDKey( pssib->line.pb );
	memcpy( rgb, PbNDKey( pssib->line.pb ), key.cb );
	key.pb = rgb;

	CallR( ErrFUCBNewCSR( pfucb ) );

	/*	goto data root
	/**/
	PcsrCurrent( pfucb )->bm = pfucb->u.pfcb->bmRoot;
	PcsrCurrent( pfucb )->itagFather = itagNull;
	PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
	while( !FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
		{
		CallR( ErrSTReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
		}
	PcsrCurrent( pfucb )->itag = ItagRootOfPfucb( pfucb );

	/*	invisible path is NOT MUTEX guarded, and may be invalid.  However,
	/*	since it is only being read for position calculation and discarded
	/*	immediately after, it need not be valid.
	/**/
	FUCBSetFull( pfucb );
	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	Call( ErrBTSeekForUpdate( pfucb, &key, pgno, itag, fDIRDuplicate | fDIRReplace ) );
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode );
	Assert( PcsrCurrent( pfucb )->pgno == pgno &&
		PcsrCurrent( pfucb )->itag == itag );

	/*	now follow path from root down to current node, to estimate
	/*	total and number nodes less than current node.
	/**/
	ulTotal = 1;
	ulLT = 0;
	for ( pcsrT = PcsrCurrent( pfucb ); pcsrT->pcsrPath != pcsrRoot; pcsrT = pcsrT->pcsrPath )
		{
		Call( ErrSTReadAccessPage( pfucb, pcsrT->pgno ) );
		Assert( FReadAccessPage( pfucb, pcsrT->pgno ) );
		NDGet( pfucb, pcsrT->itagFather );

		/*	calculate fractional position in B-tree
		/**/
		ulLT += pcsrT->ibSon * ulTotal;
		ulTotal *= CbNDSon( pssib->line.pb );
		}

	/*	return results
	/**/
	*pulLT = ulLT;
	*pulTotal = ulTotal;

HandleError:
	FUCBFreePath( &pfucb->pcsr, pcsrRoot );
	FUCBResetFull( pfucb );
	return err;
	}


LOCAL INT IbsonBTFrac( FUCB *pfucb, CSR *pcsr, DIB *pdib )
	{
	SSIB	*pssib = &pfucb->ssib;
	INT		ibSon;
	INT		cbSon;
	FRAC	*pfrac = (FRAC *)pdib->pkey;
	ULONG	ulT;

	Assert( pdib->pos == posFrac );

	NDGet( pfucb, pcsr->itagFather );
	cbSon = CbNDSon( pssib->line.pb );
	/*	effect fractional in page positioning such that overflow and
	/*	underflow are avoided.
	/**/
	if ( pfrac->ulTotal / cbSonMax ==  0 )
		{
		ibSon = ( ( pfrac->ulLT * cbSon ) / pfrac->ulTotal );
		}
	else
		{
		ibSon = ( cbSon * ( pfrac->ulLT / ( pfrac->ulTotal / cbSonMax ) ) ) / cbSonMax;
		}
	if ( ibSon >= cbSon )
		ibSon = cbSon - 1;

	/*	preseve fractional information by avoiding underflow
	/**/
	if ( pfrac->ulTotal / cbSon == 0 )
		{
		pfrac->ulTotal *= cbSonMax;
		pfrac->ulLT *= cbSonMax;
		}

	/*	prepare fraction for next lower B-tree level
	/**/
	pfrac->ulTotal /= cbSon;
	Assert( pfrac->ulTotal > 0 );
	ulT = ibSon * pfrac->ulTotal;
	if ( ulT > pfrac->ulLT )
		pfrac->ulLT = 0;
	else
		pfrac->ulLT -= ulT;
	return ibSon;
	}


ERR ErrBTGotoBookmark( FUCB *pfucb, SRID srid )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	SRID	sridT;
	PGNO	pgno;
	INT		itag = itagFOP;
	INT		ibSon;
	ULONG	crepeat = 0;
Start:
	crepeat++;
	Assert( crepeat < 10 );

	sridT = srid;
	Assert( sridT != sridNull );
	pcsr->pgno = PgnoOfSrid( sridT );
	pcsr->itag = ItagOfSrid( sridT );
	Assert( pcsr->pgno != pgnoNull );
	Assert( pcsr->itag >= 0 && pcsr->itag < ctagMax );

	if ( !FReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallR( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
		Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
		}
	if ( TsPMTagstatus( pfucb->ssib.pbf->ppage, pcsr->itag ) == tsVacant )
		{
		/*	node has probably moved from under us -- retry
		/**/
		BFSleep( cmsecWaitGeneric );
		goto Start;
		}
	else if ( TsPMTagstatus( pfucb->ssib.pbf->ppage, pcsr->itag ) == tsLink )
		{
		PMGetLink( &pfucb->ssib, pcsr->itag, &sridT );
		pgno = PgnoOfSrid( sridT );
		Assert( pgno != pgnoNull );
		pcsr->pgno = pgno;
		pcsr->itag = ItagOfSrid( sridT );
		Assert( pcsr->itag > 0 && pcsr->itag < ctagMax );
		CallR( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
		Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
		if ( TsPMTagstatus( pfucb->ssib.pbf->ppage, pcsr->itag ) != tsLine )
			{
			/* might have been merged into adjacent page
			/* go back to link and check
			/**/
			BFSleep( cmsecWaitGeneric );
			goto Start;
			}

		/*	get line and check if backlink is what we expected
		/**/
		NDGet( pfucb, PcsrCurrent( pfucb )->itag );
		sridT = *(SRID UNALIGNED *)PbNDBackLink( pfucb->ssib.line.pb );
		if ( sridT != srid && pcsr->itag != 0 )
			{
			BFSleep( cmsecWaitGeneric );
			goto Start;
			}
		}

	/*	search all node son tables for tag of node.
	/**/
	Assert( pcsr == PcsrCurrent( pfucb ) );
	if ( pcsr->itag == 0 )
		{
		/*	this is for case where cursor is on FDP root or page with no
		/*	sons and stores page currency.
		/**/
		ibSon = 0;
		}
	else
		{
		NDGetItagFatherIbSon(
					&itag,
					&ibSon,
					pssib->pbf->ppage,
					pcsr->itag );
		}

	/*	set itagFather and ibSon
	/**/
	pcsr->itagFather = itag;
	pcsr->ibSon = ibSon;

	/* get line -- UNDONE: optimize -- line may have already been got
	/**/
	NDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	bookmark must be on node for this table
	/**/
//	UNDONE:	cannot assert this since space manager cursors
//		 	traverse domains, as do database cursors
//	Assert( pfucb->u.pfcb->pgnoFDP == PgnoPMPgnoFDPOfPage( pfucb->ssib.pbf->ppage ) );

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\daeutil.c ===
#include "config.h"

#include <ctype.h>
#include <io.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include "daedef.h"
#include "fmp.h"
#include "util.h"

DeclAssertFile;					/* Declare file name for assert macros */


#define StringKey( sz ) {sizeof( sz )-1, sz}


#ifdef DATABASE_FORMAT_CHANGE
const KEY rgkeySTATIC[] = {
	StringKey( "" ),				// 0
	StringKey( "T" ),				// 1	TABLES
	StringKey( "I" ),				// 2	INDEXES
	StringKey( "C" ),				// 3	COLUMNS
	StringKey( "O" ),				// 4	OWNED SPACE
	StringKey( "A" ),				// 5	AVAILABLE SPACE
	StringKey( "R" ),				// 6	ROOT
	StringKey( "D" ),				// 7	DATABASES
	StringKey( "S" ),				// 8	STATISTICS
	StringKey( "L" ),				// 9	LONG DATA
	StringKey( "U" ),				// 10	UNIQUE AUTO INCREMENT ID
	StringKey( "F" )				// 11	FREE SPACE COMPACTION STATISTICS
	};
#else
const KEY rgkeySTATIC[] = {
	StringKey( "" ),				// 0
	StringKey( "TABLES" ),			// 1
	StringKey( "INDEXES" ),			// 2
	StringKey( "FIELDS" ),			// 3
	StringKey( "OWNEXT" ),			// 4
	StringKey( "AVAILEXT" ),		// 5
	StringKey( "DATA" ),			// 6
	StringKey( "DATABASES" ),		// 7
	StringKey( "STATS" ),			// 8
	StringKey( "LONG" ),			// 9
	StringKey( "AUTOINC" ),			// 10
	StringKey( "OLCSTATS" )			// 11
	};
#endif


ERR ErrCheckName( CHAR *szNewName, const CHAR *szName, INT cchName )
	{
	unsigned	cch;

	cch = CchValidateName( szNewName, szName, cchName );

	if ( cch == 0 )
		return JET_errInvalidName;
	else
		szNewName[cch] = '\0';

	return JET_errSuccess;
	}


INT CmpStKey( BYTE *stKey, const KEY *pkey )
	{
	INT		s;
	INT		sDiff;

	sDiff = *stKey - pkey->cb;
	s = memcmp( stKey + 1, pkey->pb, sDiff < 0 ? (INT)*stKey : pkey->cb );
	return s ? s : sDiff;
	}


INT CmpPartialKeyKey( KEY *pkey1, KEY *pkey2 )
	{
	INT		cmp;

	if ( FKeyNull( pkey1 ) || FKeyNull( pkey2 ) )
		{
		if ( FKeyNull( pkey1 ) && !FKeyNull( pkey2 ) )
			cmp = -1;
		else if ( !FKeyNull( pkey1 ) && FKeyNull( pkey2 ) )
			cmp = 1;
		else
			cmp = 0;
		}
	else
		{
		cmp = memcmp( pkey1->pb, pkey2->pb, pkey1->cb < pkey2->cb ? pkey1->cb : pkey2->cb );
		}

	return cmp;
	}


#ifdef DEBUG


CHAR *GetEnv2( CHAR *szEnvVar )
	{
	return getenv( szEnvVar );
	}


BOOL fDBGPrintToStdOut = fFalse;


void VARARG PrintF2(const CHAR * fmt, ...)
	{
#ifndef	WIN16
	va_list arg_ptr;
	va_start( arg_ptr, fmt );
	vprintf( fmt, arg_ptr );
	fflush( stdout );
	va_end( arg_ptr );
#endif	/* !WIN16 */
	}


void VARARG FPrintF2(const CHAR * fmt, ...)
	{
#ifndef	WIN16
	FILE *f;

	va_list arg_ptr;
	va_start( arg_ptr, fmt );
	
	if ( fDBGPrintToStdOut )
		{
		vprintf( fmt, arg_ptr );
		fflush( stdout );
		}
	else
		{
		f =	fopen( "jet.txt","a+");
		vfprintf( f, fmt, arg_ptr );
		fflush( f );
		fclose( f );
		}
		
	va_end( arg_ptr );
#endif	/* !WIN16 */
	}


#endif	/* DEBUG */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\inc\util.h ===
//==============	DAE: OS/2 Database Access Engine	===================
//==============	   util.h: DAE Misc Utilities		===================

#ifndef	UTIL_H					/* Allow this file to be included at will */
#define UTIL_H

#ifndef _FILE_DEFINED
#include <stdio.h>		       /* Needed for FPrintF2 prototype */
#endif	/* !_FILE_DEFINED */

/*	system node keys
/**/
extern const KEY rgkeySTATIC[13];
#define pkeyNull				(KEY *)(rgkeySTATIC+0)
#define pkeyTables				(KEY *)(rgkeySTATIC+1)
#define pkeyIndexes				(KEY *)(rgkeySTATIC+2)
#define pkeyFields				(KEY *)(rgkeySTATIC+3)
#define pkeyOwnExt				(KEY *)(rgkeySTATIC+4)
#define pkeyAvailExt			(KEY *)(rgkeySTATIC+5)
#define pkeyData				(KEY *)(rgkeySTATIC+6)
#define pkeyDatabases			(KEY *)(rgkeySTATIC+7)
#define pkeyStats				(KEY *)(rgkeySTATIC+8)
#define pkeyLong				(KEY *)(rgkeySTATIC+9)
#define pkeyAutoInc				(KEY *)(rgkeySTATIC+10)
#define pkeyOLCStats			(KEY *)(rgkeySTATIC+11)


/* NOTE: whenever this is changed, also update the rgres[] in sysinit.c */

#define iresBGCB					0
#define iresCSR						1
#define iresFCB						2
#define iresFUCB 					3
#define iresIDB						4
#define iresPIB						5
#define iresSCB						6
#define iresVersionBucket	   		7
#define iresDAB						8
#define iresLinkedMax		   		9		// the last linked ires + 1

#define iresBF 						9
#define iresMax						10		// max all category

/**************** function prototypes *********************
/**********************************************************
/**/
ERR ErrMEMInit( VOID );
BYTE *PbMEMAlloc( int ires);
VOID MEMRelease( int ires, BYTE *pb );
VOID MEMTerm( VOID );

#ifdef MEM_CHECK
VOID MEMCheck( VOID );
#else
#define MEMCheck()
#endif 

#ifdef	DEBUG
void VARARG PrintF2(const char * fmt, ...);
void VARARG FPrintF2(const char * fmt, ...);
VOID MEMPrintStat( VOID );
#define PrintF	PrintF2
#else
#define PrintF()
#endif

CHAR *GetEnv2( CHAR *szEnvVar );
ERR ErrCheckName( char *szNewName, const char *szName, int cchName );
CHAR *StrTok2( CHAR *szLine, CHAR *szDelimiters );

INT CmpStKey( BYTE *stKey, const KEY *pkey );
INT CmpPartialKeyKey( KEY *pkey1, KEY *pkey2 );

ERR ErrCheckName( char *szNewName, const char *szName, int cchName );

#endif	/* !UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\bm.c ===
#include "config.h"

#include "daedef.h"
#include "pib.h"
#include "fmp.h"
#include "ssib.h"
#include "page.h"
#include "fucb.h"
#include "fcb.h"
#include "fdb.h"
#include "idb.h"
#include "recapi.h"
#include "recint.h"
#include "util.h"
#include "node.h"
#include "stapi.h"
#include "spaceapi.h"
#include "dirapi.h"
#include "stint.h"
#include "dbapi.h"
#include "nver.h"
#include "logapi.h"
#include "bm.h"
#define FLAG_DISCARD 1

DeclAssertFile;					/* Declare file name for assert macros */

/*	Large Grain critical section order:
/*	critBMRCEClean -> critSplit -> critMPL -> critJet
/**/
extern CRIT __near critBMRCEClean;
extern CRIT __near critSplit;

CRIT	critMPL;
SIG		sigDoneFCB = NULL;
SIG		sigBMCleanProcess = NULL;
PIB		*ppibBMClean = ppibNil;

extern BOOL fOLCompact;
BOOL fDBGDisableBMClean;

#ifdef	ASYNC_BM_CLEANUP
/*	thread control variables.
/**/
HANDLE	handleBMClean = 0;
BOOL  	fBMCleanTerm;
#endif

LOCAL ULONG BMCleanProcess( VOID );
ERR ErrBMClean( PIB *ppib );

/**********************************************************
/*****	MESSY PAGE LIST
/**********************************************************
/**/
#define		pmpeNil	NULL

struct _mpe
	{
	PGNO		pgnoFDP;	  			/*	for finding FCB */
	PN	 		pn;						/*	of page to be cleaned */
	SRID		sridFather;				/*	visible father for page free */
	struct _mpe	*pmpeNextPN;			/*	next mpe that has same hash for pn */
	struct _mpe	*pmpeNextPgnoFDP;		/*	same for pgnoFDP */
	struct _mpe	*pmpeNextSridFather;	/*	same for sridFather */
#ifdef FLAG_DISCARD
	BOOL		fFlagDiscard;			/*	set to fTrue to flag discard */
#endif
	};

typedef struct _mpe MPE;

typedef MPE *PMPE;

typedef struct
	{
	MPE	*pmpeHead;
	MPE	*pmpeTail;
	MPE	rgmpe[cmpeMax];
	} MPL;

static MPL mpl;
SgSemDefine( semMPL );

PMPE	mplHashOnPN[cmpeMax - 1];	   		/* for hashing on pn of mpe */
PMPE	mplHashOnSridFather[cmpeMax - 1]; 	/* for hashing on sridFather of mpe */
PMPE 	mplHashOnPgnoFDP[cmpeMax - 1];		/* for hashing on pgnoFDP */

LOCAL BOOL FMPLEmpty( VOID );
LOCAL BOOL FMPLFull( VOID );
LOCAL MPE *PmpeMPLGet( VOID );
LOCAL VOID FMPLDefer( VOID );
LOCAL VOID MPLDiscard( VOID );
LOCAL VOID MPLFlagDiscard( MPE *pmpe );
LOCAL MPE *PmpeMPLNextFromHead( VOID );
LOCAL MPE *PmpeMPLNextFromTail( VOID );
LOCAL VOID MPLIRegister( PN pn, PGNO pgnoFDP, SRID sridFather );

#ifdef DEBUG
VOID AssertBMNoConflict( PIB *ppib, DBID dbid, SRID bm );
#else
#define AssertBMNoConflict( ppib, dbid, bm )
#endif


ERR ErrMPLInit( VOID )
	{
	ERR		err = JET_errSuccess;

	Call( SgErrSemCreate( &semMPL, "MPL mutex semaphore" ) );
	mpl.pmpeHead = mpl.pmpeTail = mpl.rgmpe;

	Call( ErrSignalCreate( &sigDoneFCB, NULL ) );
#ifdef	ASYNC_BM_CLEANUP
	Call( ErrSignalCreate( &sigBMCleanProcess, "bookmark clean signal" ) );
#endif

HandleError:
	return err;
	}


VOID MPLTerm( VOID )
	{
	while ( !FMPLEmpty() )
		{
		MPLDiscard();
		}
    if ( sigDoneFCB ) {
    	SignalClose( sigDoneFCB );
        sigDoneFCB = NULL;
    }
    
#ifdef	ASYNC_BM_CLEANUP
    if( sigBMCleanProcess ) {
    	SignalClose( sigBMCleanProcess );
        sigBMCleanProcess = NULL;
    }
#endif
	}


LOCAL BOOL FMPLEmpty( VOID )
	{
	return ( mpl.pmpeHead == mpl.pmpeTail );
	}


LOCAL BOOL FMPLFull( VOID )
	{
	return ( PmpeMPLNextFromTail() == mpl.pmpeHead );
	}


LOCAL MPE *PmpeMPLGet( VOID )
	{
	SgSemRequest( semMPL );
	if ( !FMPLEmpty() )
		{
		SgSemRelease( semMPL );
		return mpl.pmpeHead;
		}
	else
		{
		SgSemRelease( semMPL );
		return NULL;
		}
	}


LOCAL MPE *PmpeMPLNextFromTail( VOID )
	{
	if ( mpl.pmpeTail != mpl.rgmpe + cmpeMax - 1 )
		return mpl.pmpeTail + 1;
	else
		return mpl.rgmpe;
	}


LOCAL MPE *PmpeMPLNextFromHead( VOID )
	{
	if ( mpl.pmpeHead != mpl.rgmpe + cmpeMax - 1 )
		return mpl.pmpeHead + 1;
	else
		return mpl.rgmpe;
	}


LOCAL MPE *PmpeMPLNext( MPE *pmpe )
	{
	if ( pmpe == mpl.pmpeTail )
		return NULL;
	if ( pmpe == mpl.rgmpe + cmpeMax - 1 )
		return mpl.rgmpe;
	return pmpe + 1;
	}


LOCAL UINT UiHashOnPN( PN pn )
	{
	return ( pn % ( cmpeMax - 1 ) );
	}


LOCAL UINT UiHashOnPgnoFDP( PGNO pgnoFDP )
	{
	return ( pgnoFDP % ( cmpeMax - 1 ) );
	}


LOCAL UINT UiHashOnSridFather( SRID srid )
	{
	return ( srid % (cmpeMax-1) );
	}


LOCAL MPE* PmpeMPLLookupPN( PN pn )
	{
	MPE	*pmpehash;

	for	( pmpehash = mplHashOnPN[ UiHashOnPN( pn ) ];
		pmpehash != NULL;
		pmpehash = pmpehash->pmpeNextPN )
		{
		if ( pmpehash->pn == pn )
			return( pmpehash );
		}

	return NULL;
	}


LOCAL MPE* PmpeMPLLookupPgnoFDP( PGNO pgnoFDP, DBID dbid )
	{
	MPE	*pmpehash;

	for	( pmpehash = mplHashOnPgnoFDP[ UiHashOnPgnoFDP( pgnoFDP ) ];
		pmpehash != NULL;
		pmpehash = pmpehash->pmpeNextPgnoFDP )
		{
		if ( pmpehash->pgnoFDP == pgnoFDP && DbidOfPn( pmpehash->pn ) == dbid )
			return( pmpehash );
		}

	return NULL;
	}


LOCAL MPE* PmpeMPLLookupSridFather( SRID srid, DBID dbid )
	{
	MPE	*pmpehash;

	for	( pmpehash = mplHashOnSridFather[ UiHashOnSridFather( srid ) ];
		pmpehash != NULL;
		pmpehash = pmpehash->pmpeNextSridFather )
		{
		if ( pmpehash->sridFather == srid && DbidOfPn( pmpehash->pn ) == dbid )
			return( pmpehash );
		}

	return NULL;
	}


LOCAL VOID MPLRegisterPN( MPE *pmpe )
	{
	UINT 	iHashIndex = UiHashOnPN( pmpe->pn );

	Assert( PmpeMPLLookupPN( pmpe->pn ) == NULL );
	pmpe->pmpeNextPN = ( mplHashOnPN[ iHashIndex ] );
	mplHashOnPN[iHashIndex] = pmpe;
	return;
	}


LOCAL VOID MPLRegisterPgnoFDP( MPE *pmpe )
	{
	UINT	iHashIndex = UiHashOnPgnoFDP( pmpe->pgnoFDP );

	pmpe->pmpeNextPgnoFDP = ( mplHashOnPgnoFDP[ iHashIndex ] );
	mplHashOnPgnoFDP[iHashIndex] = pmpe;
	return;
	}


LOCAL VOID MPLRegisterSridFather( MPE *pmpe )
	{
	UINT 	iHashIndex = UiHashOnSridFather( pmpe->sridFather );

	pmpe->pmpeNextSridFather = ( mplHashOnSridFather[ iHashIndex ] );
	mplHashOnSridFather[iHashIndex] = pmpe;
	return;
	}


LOCAL VOID MPLDiscardPN( MPE *pmpe )
	{
	UINT  	iHashIndex = UiHashOnPN( pmpe->pn );
	MPE	  	*pmpehash;
	MPE	  	**ppmpePrev;

	Assert( PmpeMPLLookupPN( pmpe->pn ) != NULL );
	pmpehash = mplHashOnPN[iHashIndex];
	ppmpePrev = &mplHashOnPN[iHashIndex];
	for ( ; pmpehash != NULL;
		ppmpePrev = &pmpehash->pmpeNextPN, pmpehash = *ppmpePrev )
		{
		if ( pmpehash == pmpe )
			{
			*ppmpePrev = pmpe->pmpeNextPN;
			return;
			}
		}
	Assert( fFalse );
	}


LOCAL VOID MPLDiscardPgnoFDP( MPE *pmpe)
	{
	UINT 	iHashIndex = UiHashOnPgnoFDP( pmpe->pgnoFDP );
	MPE		*pmpehash;
	MPE	   	**ppmpePrev;

	Assert( PmpeMPLLookupPgnoFDP( pmpe->pgnoFDP, DbidOfPn( pmpe->pn ) ) != NULL );
	pmpehash = mplHashOnPgnoFDP[iHashIndex];
	ppmpePrev = &mplHashOnPgnoFDP[iHashIndex];
	for ( ; pmpehash != NULL;
			ppmpePrev = &pmpehash->pmpeNextPgnoFDP, pmpehash = *ppmpePrev )
		{
		if ( pmpehash == pmpe )
			{
			*ppmpePrev = pmpe->pmpeNextPgnoFDP;
			return;
			}
		}
	Assert( fFalse );
	}


LOCAL VOID MPLDiscardSridFather( MPE *pmpe)
	{
	UINT	iHashIndex = UiHashOnSridFather( pmpe->sridFather );
	MPE	   	*pmpehash;
	MPE	   	**ppmpePrev;

	Assert( PmpeMPLLookupSridFather( pmpe->sridFather, DbidOfPn( pmpe->pn ) ) != NULL );
	pmpehash = mplHashOnSridFather[iHashIndex];
	ppmpePrev = &mplHashOnSridFather[iHashIndex];
	for ( ; pmpehash != NULL;
			ppmpePrev = &pmpehash->pmpeNextSridFather, pmpehash = *ppmpePrev )
		{
		if ( pmpehash == pmpe )
			{
			*ppmpePrev = pmpe->pmpeNextSridFather;
			return;
			}
		}
	Assert( fFalse );
	}


LOCAL VOID MPLDiscard( VOID )
	{
	SgSemRequest( semMPL );
	Assert( !FMPLEmpty() );
	MPLDiscardPN( mpl.pmpeHead );
	MPLDiscardSridFather( mpl.pmpeHead );
	MPLDiscardPgnoFDP( mpl.pmpeHead );
	mpl.pmpeHead = PmpeMPLNextFromHead();
	SgSemRelease( semMPL );
	return;
	}


#ifdef FLAG_DISCARD
LOCAL VOID MPLFlagDiscard( MPE *pmpe )
	{
	SgSemRequest( semMPL );
	Assert( !FMPLEmpty() );
	/*	note that MPE may already been set to flag discard
	/**/
	pmpe->fFlagDiscard = fTrue;
	SgSemRelease( semMPL );
	return;
	}
#endif


VOID MPLIRegister( PN pn, PGNO pgnoFDP, SRID sridFather )
	{
	MPE	*pmpe = PmpeMPLLookupPN( pn );

//	Assert( !FMPLFull() );
	if ( pmpe == NULL && !FMPLFull() )
		{
		mpl.pmpeTail->pn = pn;
		mpl.pmpeTail->pgnoFDP = pgnoFDP;
		mpl.pmpeTail->sridFather = sridFather;
#ifdef FLAG_DISCARD
		mpl.pmpeTail->fFlagDiscard = fFalse;
#endif
		MPLRegisterPN( mpl.pmpeTail );
		MPLRegisterSridFather( mpl.pmpeTail );
		MPLRegisterPgnoFDP( mpl.pmpeTail );
		mpl.pmpeTail = PmpeMPLNextFromTail();
		}
	else if ( pmpe != NULL 
		&& sridFather != pmpe->sridFather
#ifdef FLAG_DISCARD
		&& !pmpe->fFlagDiscard
#endif
		)
		{
		if ( ( pmpe->sridFather == sridNull || pmpe->sridFather == sridNullLink ) &&
				 sridFather != sridNull && sridFather != sridNullLink ) 
			{
			/* update if we have better info on sridFather
			/**/
			Assert( PgnoOfSrid( sridFather ) != PgnoOfPn( pn ) );
			Assert( pmpe->pgnoFDP == pgnoFDP );
			Assert( pmpe->pn == pn );
			MPLDiscardSridFather( pmpe );
			pmpe->sridFather = sridFather;
			MPLRegisterSridFather( pmpe );
			}
		}
	}


VOID MPLRegister( FCB *pfcb, SSIB *pssib, PN pn, SRID sridFather )
	{
	if ( DbidOfPn( pn ) == dbidTemp || FDBIDWait( DbidOfPn( pn ) ) )
		return;

	/*	database must be writable
	/**/
	Assert( !FDBIDReadOnly( DbidOfPn( pn ) ) );
	Assert( pssib->pbf->pn == pn );
	Assert( !FFCBSentinel( pfcb ) );

	/*	do not register when domain is pending delete
	/**/
	if ( FFCBDeletePending( pfcb ) )
		return;

	SgSemRequest( semMPL );
	if ( !FPMModified( pssib->pbf->ppage ) )
		{
		PMSetModified( pssib );
		pfcb->olcStat.cUnfixedMessyPage++;
		FCBSetOLCStatsChange( pfcb );
		}

#ifdef DEBUG
	/*	check if sridFather registered is correct
	/**/
	if ( sridFather != sridNull && sridFather != sridNullLink )
		{
		ERR		err;
		FUCB	*pfucb;
		SSIB	*pssibT;

		CallJ( ErrDIROpen( pssib->ppib, pfcb, 0, &pfucb ), SkipCheck );
		
		pssibT = &pfucb->ssib;
		CallJ( ErrBTGotoBookmark( pfucb, sridFather ), CloseDir );
		if ( PgnoOfPn( pn ) == PcsrCurrent( pfucb )->pgno )
			{
			Assert( !FNDNullSon( *pssibT->line.pb ) );
			//	UNDONE: check for visible descendants in same page
			}
		else
			{
			/*	access register page
			/**/
			PcsrCurrent( pfucb )->pgno = PgnoOfPn( pn );
			Assert( !FAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
			err = ErrSTWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
			if ( err >= JET_errSuccess )
				{
				PcsrCurrent( pfucb )->itagFather = itagFOP;
				NDGet( pfucb, PcsrCurrent( pfucb )->itagFather );
				Assert( !FNDNullSon( *pssibT->line.pb ) );
				NDMoveFirstSon( pfucb, PcsrCurrent( pfucb ) );
				CallS( ErrBTCheckInvisiblePagePtr( pfucb, sridFather ) );
				}
			}
CloseDir:
		DIRClose( pfucb );
SkipCheck:
		;
		}
#endif

	/* if sridFather is in same page -- it is not useful for page recovery
	/**/
	if ( PgnoOfSrid( sridFather ) == PgnoOfPn( pn ) )
		sridFather = sridNull;
		
	MPLIRegister( pn, pssib->pbf->ppage->pghdr.pgnoFDP, sridFather );
	SgSemRelease( semMPL );

#ifdef ASYNC_BM_CLEANUP
	//	UNDONE:	hysteresis of clean up
	/*	wake up BM thread
	/**/
	SignalSend( sigBMCleanProcess );
#endif	/* ASYNC_BM_CLEANUP */

	return;
	}


LOCAL VOID MPLDefer( VOID )
	{
	MPE *pmpe = mpl.pmpeHead;

	SgSemRequest( semMPL );
	Assert( !FMPLEmpty() );
	// UNDONE: to optimize
	MPLDiscard( );
	MPLIRegister( pmpe->pn, pmpe->pgnoFDP, pmpe->sridFather );

//	*mpl.pmpeTail = *mpl.pmpeHead;
//	mpl.pmpeTail = PmpeMPLNextFromTail();
//	mpl.pmpeHead = PmpeMPLNextFromHead();
	SgSemRelease( semMPL );
	return;
	}


VOID MPLPurgePgno( DBID dbid, PGNO pgnoFirst, PGNO pgnoLast )
	{
	MPE		*pmpe;
#ifndef FLAG_DISCARD
	MPE		*pmpeEnd;
#endif

	Assert( pgnoFirst <= pgnoLast );

	/*	synchronize with bookmark clean up
	/**/
	LgLeaveCriticalSection(critJet);
	LgEnterNestableCriticalSection(critMPL);
	LgEnterCriticalSection(critJet);
	SgSemRequest( semMPL );

#ifdef FLAG_DISCARD
	/*	go through MPL discarding offending entries
	/**/
	if ( !FMPLEmpty() )
		{
		for ( pmpe = mpl.pmpeHead; pmpe != NULL; pmpe = PmpeMPLNext( pmpe ) )
			{
			if ( ( pmpe->pn >= PnOfDbidPgno ( dbid, pgnoFirst ) &&
					pmpe->pn <= PnOfDbidPgno( dbid, pgnoLast ) ) ||
				( DbidOfPn( pmpe->pn ) == dbid &&
					( ( PgnoOfSrid( pmpe->sridFather ) >= pgnoFirst &&
					PgnoOfSrid( pmpe->sridFather ) <= pgnoLast ) ||
					( pmpe->pgnoFDP >= pgnoFirst &&
					pmpe->pgnoFDP <= pgnoLast ) ) ) )
				{
				MPLFlagDiscard( pmpe );
				}
			}
		}
#else
	/*	go through MPL discarding offending entries
	/**/
	if ( !FMPLEmpty() )
		{
		pmpe = mpl.pmpeHead;
		pmpeEnd = mpl.pmpeTail;
		for ( ; pmpe != pmpeEnd; pmpe = mpl.pmpeHead )
			{
			if ( ( pmpe->pn >= PnOfDbidPgno ( dbid, pgnoFirst ) &&
					pmpe->pn <= PnOfDbidPgno( dbid, pgnoLast ) ) ||
				( DbidOfPn( pmpe->pn ) == dbid &&
					( ( PgnoOfSrid( pmpe->sridFather ) >= pgnoFirst &&
					PgnoOfSrid( pmpe->sridFather ) <= pgnoLast ) ||
					( pmpe->pgnoFDP >= pgnoFirst &&
					pmpe->pgnoFDP <= pgnoLast ) ) ) )
				{
				MPLDiscard( );
				}
			else
				{
				MPLDefer( );
				}
			}
		}
#endif

	SgSemRelease( semMPL );
	LgLeaveNestableCriticalSection( critMPL );
	return;
	}


VOID MPLPurgeFDP( DBID dbid, PGNO pgnoFDP )
	{
	MPE	*pmpe;
#ifndef FLAG_DISCARD
	MPE	*pmpeEnd;
#endif

	/*	synchronize with bookmark clean up
	/**/
	LgLeaveCriticalSection(critJet);
	LgEnterNestableCriticalSection(critMPL);
	LgEnterCriticalSection(critJet);

	SgSemRequest( semMPL );

#ifdef FLAG_DISCARD
	// CONSIDER: using the pgnoFDP hash
	if ( !FMPLEmpty() )
		{
		for ( pmpe = mpl.pmpeHead; pmpe != NULL; pmpe = PmpeMPLNext( pmpe ) )
			{
			if ( DbidOfPn( pmpe->pn ) == dbid && pmpe->pgnoFDP == pgnoFDP )
				{
				MPLFlagDiscard( pmpe );
				}
			}
		}
#else
	// CONSIDER: using the pgnoFDP hash
	if ( !FMPLEmpty() )
		{
		pmpe = mpl.pmpeHead;
		pmpeEnd = mpl.pmpeTail;
		for ( ; pmpe != pmpeEnd; pmpe = mpl.pmpeHead )
			{
			if ( DbidOfPn( pmpe->pn ) == dbid && pmpe->pgnoFDP == pgnoFDP )
				{
				MPLDiscard( );
				}
			else
				{
				MPLDefer( );
				}
			}
		}
#endif

	SgSemRelease( semMPL );

	LgLeaveNestableCriticalSection(critMPL);
	return;
	}


/* purge mpl entries of dbid
/**/
VOID MPLPurge( DBID dbid )
	{
	MPE *pmpe;
#ifndef FLAG_DISCARD
	MPE *pmpeEnd;
#endif

	/*	synchronize with bookmark clean up
	/**/
	LgLeaveCriticalSection(critJet);
	LgEnterNestableCriticalSection(critBMRCEClean);
	LgEnterNestableCriticalSection(critMPL);
	LgEnterCriticalSection(critJet);

	SgSemRequest( semMPL );

#ifdef FLAG_DISCARD
	if ( !FMPLEmpty() )
		{
		for ( pmpe = mpl.pmpeHead; pmpe != NULL; pmpe = PmpeMPLNext( pmpe ) )
			{
			if ( DbidOfPn( pmpe->pn ) == dbid )
				{
				MPLFlagDiscard( pmpe );
				}
			}
		}
#else
	if ( !FMPLEmpty() )
		{
		pmpe = mpl.pmpeHead;
		pmpeEnd = mpl.pmpeTail;
		for ( ; pmpe != pmpeEnd; pmpe = mpl.pmpeHead )
			{
			if ( DbidOfPn( pmpe->pn ) == dbid )
				{
				MPLDiscard( );
				}
			else
				{
				MPLDefer( );
				}
			}
		}
#endif

	SgSemRelease( semMPL );

	LgLeaveNestableCriticalSection(critMPL);
	LgLeaveNestableCriticalSection(critBMRCEClean);
	return;
	}


/**********************************************************
/***** BOOKMARK CLEAN UP
/**********************************************************
/**/

ERR  ErrBMInit( VOID )
	{
	ERR		err;

#ifdef DEBUG
	CHAR	*sz;
	BOOL	fBMDISABLEDSet = fFalse;

	if ( ( sz = GetEnv2 ( "BMDISABLED" ) ) != NULL )
		{
		fBMDISABLEDSet = fTrue;
		fDBGDisableBMClean = fTrue;
		}
	else
		fDBGDisableBMClean = fFalse;

	if ( ( sz = GetEnv2( "OLCENABLED" ) ) != NULL )
		fOLCompact = JET_bitCompactOn;

#endif

	/*	override grbit with environment variable
	/**/
#ifdef DEBUG
	if ( !fBMDISABLEDSet )
		{
#endif
	Assert( fOLCompact == 0 || fOLCompact == JET_bitCompactOn );
	if ( fOLCompact == JET_bitCompactOn )
		fDBGDisableBMClean = fFalse;
	else
		fDBGDisableBMClean = fTrue;
#ifdef DEBUG
		}
#endif

#ifdef MUTEX
	CallR( ErrInitializeCriticalSection( &critMPL ) );
#endif

	/*	begin sesion for page cleanning.
	/**/
	AssertCriticalSection(critJet);
	Assert( ppibBMClean == ppibNil );
	CallR( ErrPIBBeginSession( &ppibBMClean ) );
	
#ifdef	ASYNC_BM_CLEANUP
	fBMCleanTerm = fFalse;
	err = ErrSysCreateThread( BMCleanProcess, cbStack, lThreadPriorityCritical, &handleBMClean );
	if ( err < 0 )
		PIBEndSession( ppibBMClean );
	Call( err );
#endif

HandleError:
	return err;
	}


ERR  ErrBMTerm( VOID )
	{
	ERR		err = JET_errSuccess;

#ifdef	ASYNC_BM_CLEANUP
	/*	terminate BMCleanProcess.
	/**/
	Assert( handleBMClean != 0 );
	fBMCleanTerm = fTrue;
	do
		{
		SignalSend( sigBMCleanProcess );
		BFSleep( cmsecWaitGeneric );
		}
	while ( !FSysExitThread( handleBMClean ) );
	CallS( ErrSysCloseHandle( handleBMClean ) );
	handleBMClean = handleNil;
	DeleteCriticalSection( critMPL );
    if( sigBMCleanProcess ) {
    	SignalClose( sigBMCleanProcess );
        sigBMCleanProcess = NULL;
    }
#endif

	Assert( ppibBMClean != ppibNil && ppibBMClean->level == 0 );
	PIBEndSession( ppibBMClean );
	ppibBMClean = ppibNil;

    if ( sigDoneFCB ) {
	    SignalClose(sigDoneFCB);
        sigDoneFCB = NULL;
    }


	return err;
	}


LOCAL ERR ErrBMAddToWaitLatchedBFList( BMFIX *pbmfix, BF *pbfLatched )
	{
#define cpbfBlock	10

	ULONG	cpbf = pbmfix->cpbf++;

	if ( FBFWriteLatchConflict( pbmfix->ppib, pbfLatched ) )
		{
		return JET_errWriteConflict; 
		}
	
	if ( pbmfix->cpbfMax <= pbmfix->cpbf )
		{
		BF		**ppbf;

		/* run out of space, get more buffers
		/**/
		pbmfix->cpbfMax += cpbfBlock;
		ppbf = SAlloc( sizeof(BF*) * (pbmfix->cpbfMax) );
		if ( ppbf == NULL )
			return( JET_errOutOfMemory );
		memcpy( ppbf, pbmfix->rgpbf, sizeof(BF*) * cpbf);
		if ( pbmfix->rgpbf )
			SFree(pbmfix->rgpbf);
		pbmfix->rgpbf = ppbf;
		}
	*(pbmfix->rgpbf + cpbf) = pbfLatched;
	BFPin( pbfLatched );
	BFSetWriteLatch( pbfLatched, pbmfix->ppib );
	BFSetWaitLatch( pbfLatched, pbmfix->ppib );

	return JET_errSuccess;
	}


LOCAL VOID BMReleaseBmfixBfs( BMFIX *pbmfix )
	{
	/* release latches
	/**/
	while ( pbmfix->cpbf > 0 )
		{
		pbmfix->cpbf--;
		BFResetWaitLatch( *( pbmfix->rgpbf + pbmfix->cpbf ), pbmfix->ppib );
		BFResetWriteLatch( *( pbmfix->rgpbf + pbmfix->cpbf ), pbmfix->ppib );
		BFUnpin( *( pbmfix->rgpbf + pbmfix->cpbf ) );
		}

	if ( pbmfix->rgpbf )
		SFree( pbmfix->rgpbf );

	Assert( pbmfix->cpbf == 0 );
	return;
	}


LOCAL ERR ErrBMFixIndexes(
	BMFIX	*pbmfix,
	LINE	*plineRecord,
	BOOL	fAllocBuf )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucbIdx = pfucbNil;
	FCB		*pfcbIdx;
	BYTE	rgbKey[ JET_cbKeyMost ];
	KEY		key;
	LINE	lineSRID;
	ULONG	itagSequence;

	/*	key buffer.
	/**/
	key.pb = rgbKey;
	lineSRID.pb = (BYTE *)&pbmfix->sridNew;
	lineSRID.cb = sizeof(SRID);

	/*	for each non-clustered index
	/**/
	for ( pfcbIdx = pbmfix->pfucb->u.pfcb->pfcbNextIndex;
		pfcbIdx != pfcbNil;
		pfcbIdx = pfcbIdx->pfcbNextIndex )
		{
		BOOL	fHasMultivalue;
		BOOL	fNullKey = fFalse;

		/*	table open
		/**/
		Call( ErrDIROpen( pbmfix->ppib, pfcbIdx, 0, &pfucbIdx ) );
		FUCBSetIndex( pfucbIdx );
		FUCBSetNonClustered( pfucbIdx );

		fHasMultivalue = pfcbIdx->pidb->fidb & fidbHasMultivalue;

		/*	for each key extracted from record
		/**/
		for ( itagSequence = 1; ; itagSequence++ )
			{
			Call( ErrRECExtractKey(
				pbmfix->pfucb,
				(FDB *)pfcbIdx->pfdb,
				pfcbIdx->pidb,
				plineRecord,
				&key,
				itagSequence ) );
			Assert( err == wrnFLDNullKey ||
				err == wrnFLDOutOfKeys ||
				err == wrnFLDNullSeg ||
				err == JET_errSuccess );

			/*	if Null key and null keys not allowed, break as
			/*	key entry not in index, else updated index and break,
			/*	as no additional keys can exist.
			/**/
			if ( err == wrnFLDNullKey )
				{
				if ( ( pfcbIdx->pidb->fidb & fidbAllowAllNulls ) == 0 )
					break;
				else
					fNullKey = fTrue;
				}
			else if ( err == wrnFLDNullSeg && !( pfcbIdx->pidb->fidb & fidbAllowSomeNulls ) )
				break;

			/*	break if out of keys.
			/**/
			if ( itagSequence > 1 && err == wrnFLDOutOfKeys )
				break;

			DIRGotoDataRoot( pfucbIdx );
			Call( ErrDIRDownKeyBookmark( pfucbIdx, &key, pbmfix->sridOld ) );
			Assert( FAccessPage( pfucbIdx, PcsrCurrent( pfucbIdx )->pgno ) );

			if ( fAllocBuf )
				{
				/*	latchWait buffer for index page
				/**/
				Call( ErrBMAddToWaitLatchedBFList( pbmfix, pfucbIdx->ssib.pbf ) );
				}
			else
				{
//				AssertBFWaitLatched( pfucbIdx->ssib.pbf, pbmfix->ppib );

				/*	delete reference to record in old page
				/**/
				Call( ErrDIRDelete( pfucbIdx, fDIRVersion ) );

				/*	add reference to record in new page
				/*	allow duplicates here, since any illegal
				/*	duplicates were rejected during Insert or Replace
				/**/
				DIRGotoDataRoot( pfucbIdx );
				Call( ErrDIRInsert( pfucbIdx,
					&lineSRID,
					&key,
					fDIRVersion | fDIRDuplicate | fDIRPurgeParent ) );
				}

			if ( !fHasMultivalue || fNullKey )
				break;
			}

		DIRClose( pfucbIdx );
		pfucbIdx = pfucbNil;
		}

	err = JET_errSuccess;

HandleError:
	Assert( err != JET_errRecordDeleted );
	Assert( err != JET_errKeyDuplicate );
	Assert( err != wrnNDFoundLess );

	/*	free fucb if allocated
	/**/
	if ( pfucbIdx != pfucbNil )
		DIRClose( pfucbIdx );
	return err;
	}


LOCAL ERR ErrBMCheckConflict(
	PIB		*ppib,
	FCB 	*pfcb,
	DBID	dbid,
	SRID	bm,
	PGTYP	pgtyp,
	BOOL 	*pfConflict )
	{
	ERR	   	err = JET_errSuccess;
	BOOL   	fConflict = fFalse;
	FUCB   	*pfucb;
	FCB	   	*pfcbT = pfcb;
	CSR	   	*pcsr;
	BOOL   	fRecordPage	= ( pgtyp == pgtypRecord || pgtyp == pgtypFDP );

	Assert( ppib == ppibBMClean );

	/*  go through all cursors for this table
	/**/
	for ( pfucb = pfcbT->pfucb;
		pfucb != pfucbNil;
		pfucb = pfucb->pfucbNextInstance )
		{
		if ( ( fRecordPage && FFUCBGetBookmark( pfucb ) ) ||
			pfucb->bmStore == bm ||
			pfucb-> itemStore == bm )
			{
			fConflict = fTrue;
			goto Done;
			}
		if ( pfucb->bmRefresh == bm )
			{
			fConflict = fTrue;
			goto Done;
			}
		for ( pcsr = PcsrCurrent( pfucb );
			pcsr != pcsrNil;
			pcsr = pcsr->pcsrPath )
			{
			if ( pfucb->ppib != ppib &&
				( pcsr->bm == bm ||
				SridOfPgnoItag( pcsr->pgno, pcsr->itag ) == bm ) ||
				pcsr->item == bm )
				{
				fConflict = fTrue;
				goto Done;
				}
			}
		}

	/*	go through all index cursors for this table
	/**/
	for ( pfcbT = pfcbT->pfcbNextIndex;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		for ( pfucb = pfcbT->pfucb;
			pfucb != pfucbNil;
			pfucb = pfucb->pfucbNextInstance )
			{
			Assert( !FFUCBGetBookmark( pfucb ) );
			if ( pfucb->bmStore == bm ||
				pfucb->itemStore == bm )
				{
				fConflict = fTrue;
				goto Done;
				}
			for ( pcsr = PcsrCurrent( pfucb );
				pcsr != pcsrNil;
				pcsr = pcsr->pcsrPath )
				{
				if ( ( pcsr->bm == bm || pcsr->item == bm ||
					SridOfPgnoItag( pcsr->pgno, pcsr->itag ) == bm ) &&
					pfucb->ppib != ppib )
					{
					fConflict = fTrue;
					goto Done;
					}
				}
			}
		}

	/*	go through all cursors for the database
	/**/
	pfcbT = PfcbFCBGet( dbid, pgnoSystemRoot );
	Assert( pfcbT != pfcbNil );
	for ( pfucb = pfcbT->pfucb;
		pfucb != pfucbNil ;
		pfucb = pfucb->pfucbNextInstance )
		{
		if ( pfucb->bmStore == bm || pfucb-> itemStore == bm )
			{
			fConflict = fTrue;
			goto Done;
			}

		for ( pcsr = PcsrCurrent( pfucb );
			pcsr != pcsrNil;
			pcsr = pcsr->pcsrPath )
			{
			if ( pfucb->ppib != ppib &&
				( pcsr->bm == bm ||
				SridOfPgnoItag( pcsr->pgno, pcsr->itag ) == bm ) ||
				pcsr->item == bm )
				{
				fConflict = fTrue;
				goto Done;
				}
			}
		}

	Assert( pfcbT->pfcbNextIndex == pfcbNil );

Done:
	*pfConflict = fConflict;

	/* switch on for debugging purposes only
	/**/
//	if ( !fConflict )
//		AssertBMNoConflict( ppib, dbid, bm );

	return err;
	}


/*	Checks if any other cursor is on page
/**/
LOCAL BOOL FBMCheckPageConflict( FUCB *pfucbIn, PGNO pgno )
	{
	FCB 	*pfcbT = pfucbIn->u.pfcb;
	FUCB	*pfucb;
	BOOL 	fConflict = fFalse;

	/*	go through all cursors for this table
	/**/
	for ( pfucb = pfcbT->pfucb;	pfucb != pfucbNil;
		pfucb = pfucb->pfucbNextInstance )
		{
		CSR		*pcsr = PcsrCurrent( pfucb );

		if ( pcsr != pcsrNil && pcsr->pgno == pgno && pfucb != pfucbIn )
			{
			fConflict = fTrue;
			goto Done;
			}
#ifdef DEBUG
			{
			/* the stack can not this page [due to wait latches on children]
			/**/
			for ( ; pcsr != pcsrNil; pcsr = pcsr->pcsrPath )
				{
				Assert( pcsr->pgno != pgno || pfucb == pfucbIn );
				}
			}
#endif
		}

	/*	go through all index cursors for this table
	/**/
	for ( pfcbT = pfcbT->pfcbNextIndex;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		for ( pfucb = pfcbT->pfucb;
			pfucb != pfucbNil;
			pfucb = pfucb->pfucbNextInstance )
			{
			CSR		*pcsr = PcsrCurrent( pfucb );

			if ( pcsr != pcsrNil && pcsr->pgno == pgno && pfucb != pfucbIn )
				{
				fConflict = fTrue;
				goto Done;
				}
#ifdef DEBUG
				{
				/* the stack can not this page [due to wait latches on children]
				/**/
				for ( ; pcsr != pcsrNil; pcsr = pcsr->pcsrPath )
					{
					Assert( pcsr->pgno != pgno || pfucb == pfucbIn );
					}
				}
#endif
			}
		}

	/*	go through all cursors for the database
	/**/
	pfcbT = PfcbFCBGet( pfucbIn->dbid, pgnoSystemRoot );
	Assert( pfcbT != pfcbNil );
	for ( pfucb = pfcbT->pfucb;
		pfucb != pfucbNil ;
		pfucb = pfucb->pfucbNextInstance )
		{
		CSR		*pcsr = PcsrCurrent( pfucb );

		if ( pcsr != pcsrNil && pcsr->pgno == pgno && pfucb != pfucbIn )
			{
			fConflict = fTrue;
			goto Done;
			}
#ifdef DEBUG
			{
			/* the stack can not this page [due to wait latches on children]
			/**/
			for ( ; pcsr != pcsrNil; pcsr = pcsr->pcsrPath )
				{
				Assert( pcsr->pgno != pgno || pfucb == pfucbIn );
				}
			}
#endif
		}

Done:
	return 	fConflict;
	}


LOCAL ERR ErrBMIExpungeBacklink( BMFIX *pbmfix, BOOL fAlloc )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib = pbmfix->ppib;
	FUCB	*pfucb = pbmfix->pfucb;
	FUCB	*pfucbSrc = pbmfix->pfucbSrc;

	Assert( PgtypPMPageTypeOfPage( pfucb->ssib.pbf->ppage ) == pgtypRecord );
	Assert( ppib == pfucb->ppib );

	/*	set pfucbSrc to link
	/**/
	Assert( PcsrCurrent( pfucbSrc )->pgno == PgnoOfSrid( pbmfix->sridOld ) );
	PcsrCurrent( pfucbSrc )->itag = ItagOfSrid( pbmfix->sridOld );

	/*	check if the node is deleted already. If it is, then all its index
	/*	should have been marked as deleted. So simply delete the backlink node.
	/**/
	if ( !FNDDeleted( *pfucb->ssib.line.pb ) )
		{
		/*	clean non-clustered indexes.
		/*	Latch current buffers in memory.
		/**/
		LINE	lineRecord;

		Assert( PgtypPMPageTypeOfPage( pfucb->ssib.pbf->ppage ) == pgtypRecord );
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
		Assert( pbmfix->sridNew == SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
			PcsrCurrent( pfucb )->itag ) );

		lineRecord.pb = PbNDData( pfucb->ssib.line.pb );
		lineRecord.cb = CbNDData( pfucb->ssib.line.pb, pfucb->ssib.line.cb );

		/*	fix indexes
		/**/
		Call( ErrBMFixIndexes( pbmfix, &lineRecord, fAlloc ) );
		}

HandleError:
	return err;
	}


LOCAL ERR ErrBMExpungeBacklink( FUCB *pfucb, BOOL fTableClosed, SRID sridFather )
	{
	ERR		err = JET_errSuccess;
	PGNO	pgnoSrc;
	INT		itagSrc;
	FUCB	*pfucbSrc;
	CSR		*pcsr = PcsrCurrent( pfucb );

	Assert( pfucb->ppib->level == 0 );

	/*	access source page of moved node
	/**/
	AssertNDGet( pfucb, pcsr->itag );
	NDGetBackLink( pfucb, &pgnoSrc, &itagSrc );

	CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbSrc ) );

	/*	latch both buffers in memory for index update, hold the key
	/**/
	BFPin( pfucb->ssib.pbf );
	while( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		}
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	PcsrCurrent( pfucbSrc )->pgno = pgnoSrc;
	Call( ErrSTWriteAccessPage( pfucbSrc, PcsrCurrent( pfucbSrc )->pgno ) );
	BFPin( pfucbSrc->ssib.pbf );

#ifdef DEBUG
	{
	PGTYP	pgtyp = PgtypPMPageTypeOfPage( pfucb->ssib.pbf->ppage );

	Assert( pgtyp == pgtypRecord || pgtyp == pgtypFDP || pgtyp == pgtypSort );
	}
#endif

	//	UNDONE:	fix this patch
	if( PgtypPMPageTypeOfPage( pfucb->ssib.pbf->ppage ) == pgtypRecord )
		{
		BOOL	fConflict = !fTableClosed;
		BMFIX	bmfix;

		memset( &bmfix, 0, sizeof( BMFIX ) );
		bmfix.pfucb = pfucb;
		bmfix.pfucbSrc = pfucbSrc;
		bmfix.ppib = pfucb->ppib;
		bmfix.sridOld = SridOfPgnoItag( pgnoSrc, itagSrc );
		bmfix.sridNew = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
	  		PcsrCurrent( pfucb )->itag );
		Assert( bmfix.sridOld != pfucb->u.pfcb->bmRoot );

		/*	allocate buffers and wait latch buffers
		/**/
		err = ErrBMIExpungeBacklink( &bmfix, fAllocBufOnly );
		if ( err == JET_errWriteConflict )
			{
			err = wrnBMConflict;
			goto ReleaseBufs;
			}

		/*	check if any cursors are on bm/item
		/**/
		if ( !fTableClosed )
			{
			CallJ( ErrBMCheckConflict(
				bmfix.ppib,
				bmfix.pfucbSrc->u.pfcb,
				bmfix.pfucbSrc->dbid,
				bmfix.sridOld,
				PgtypPMPageTypeOfPage( bmfix.pfucbSrc->ssib.pbf->ppage ),
				&fConflict ),
				ReleaseBufs );
			}
		else
			{
#ifdef DEBUG
			CallJ( ErrBMCheckConflict(
				bmfix.ppib,
				bmfix.pfucbSrc->u.pfcb,
				bmfix.pfucbSrc->dbid,
				bmfix.sridOld,
				PgtypPMPageTypeOfPage( bmfix.pfucbSrc->ssib.pbf->ppage ),
				&fConflict ),
				ReleaseBufs );
			Assert( !fConflict );
#endif
			}

		/* fix indexes atomically
		/**/
		if ( !fConflict )
			{
			PIB 	*ppib = pfucb->ppib;

			/*	begin transaction to rollback changes on failure.
			/**/
			Assert( ppib->level == 0 );
			CallJ( ErrDIRBeginTransaction( ppib ), ReleaseBufs );

			CallJ( ErrBMIExpungeBacklink( &bmfix, fDoMove ), Rollback );

			/*	expunge backlink and redirector. If it is done successfully, then
			/*	write a special ELC log record right away. ELC implies a commit.
			/*	Call DIRPurge to close deferred closed cursors not closed since
			/*	VERCommitTransaction was called instead of ErrDIRCommitTransaction.
			/**/
			Assert( PmpeMPLLookupSridFather( bmfix.sridOld, pfucb->dbid ) == NULL );
			CallJ( ErrNDExpungeLinkCommit( pfucb, pfucbSrc ), Rollback );
			VERCommitTransaction( ppib );
			Assert( ppib->level == 0 );

			/*	force ErrRCECleanPIB to clean all versions so that
			/*	bookmark aliasing does not occur in indexes.
			/**/
			CallS( ErrRCECleanPIB( ppib, ppib, fRCECleanAll ) );
			DIRPurge( ppib );

			goto ReleaseBufs;

Rollback:
			CallS( ErrDIRRollback( ppib ) );
			Assert( ppib->level == 0 );
			goto ReleaseBufs;
			}
		else
			{
			Assert( fConflict );
			err = wrnBMConflict;
			}
ReleaseBufs:
		BMReleaseBmfixBfs( &bmfix );
		}

	/*	unlatch buffers
	/**/
	BFUnpin( pfucbSrc->ssib.pbf );

HandleError:
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );
	Assert( pfucbSrc != pfucbNil );
	DIRClose( pfucbSrc );
	Assert( !fTableClosed || err != wrnBMConflict );
	Assert( pfucb->ppib->level == 0 );
	return err;
	}


ERR ErrBMDoEmptyPage(
	FUCB	*pfucb,
	RMPAGE	*prmpage,
	BOOL	fAllocBuf,
	BOOL	*pfRmParent,
	BOOL	fSkipDelete )
	{
	ERR		err = JET_errSuccess;

	if ( !fSkipDelete )
		{
		/*	access page from which page pointer is deleted
		/**/
		CallR( ErrSTWriteAccessPage( pfucb, prmpage->pgnoFather ) );
		Assert( pfucb->ssib.pbf == prmpage->pbfFather );
		AssertBFPin( pfucb->ssib.pbf );

		/* 	delete invisble parent pointer node and mark parent dirty
		/**/
		NDDeleteInvisibleSon( pfucb, prmpage, fAllocBuf, pfRmParent );
		if ( fAllocBuf )
			{
			return err;
			}
		}

	/*	adjust sibling pointers and mark sibling dirty
	/**/
	if ( prmpage->pbfLeft != pbfNil )
		{
		/*	use BFDirty instead of PMDirty since PM Dirty is set
		/*	in ErrNDDeleteNode already
		/**/
		BFDirty( prmpage->pbfLeft );
		SetPgnoNext( prmpage->pbfLeft->ppage, prmpage->pgnoRight );
		}

	if ( prmpage->pbfRight != pbfNil )
		{
		/*	use BFDirty instead of PMDirty since PM Dirty is set
		/*	in ErrNDDeleteNode already
		/**/
		BFDirty( prmpage->pbfRight );
		SetPgnoPrev( prmpage->pbfRight->ppage, prmpage->pgnoLeft );
		}

	return err;
	}


/* checks if page can be merged with following page
/* without violating density constraints
/**/
LOCAL VOID BMMergeablePage( FUCB *pfucb, FUCB *pfucbRight, BOOL *pfMergeable )
	{
	SSIB	*pssib = &pfucb->ssib;
	SSIB	*pssibRight = &pfucbRight->ssib;
	INT		cUsedTags = ctagMax - CPMIFreeTag( pssib->pbf->ppage );
	/* current space + space for backlinks
	/**/
	ULONG	cbReq = cbAvailMost - CbPMFreeSpace( pssib ) -
				CbPMLinkSpace( pssib ) + cUsedTags * sizeof(SRID);
	ULONG	cbFree = CbBTFree( pfucbRight, CbFreeDensity( pfucbRight ) );
	INT		cFreeTagsRight = CPMIFreeTag( pssibRight->pbf->ppage );

	/* look for available space without violating density constraint,
	/* in next page
	/* also check if tag space available in right page is sufficient
	/**/
	// UNDONE: this is a conservative estimate -- we can merge if the space
	// is enough for all descendants of FOP [which may be less than cUsedTags]
	if ( cbFree >= cbReq && cFreeTagsRight >= cUsedTags )
		{
		*pfMergeable = fTrue;
		}
	else
		{
		*pfMergeable = fFalse;
		}

	return;
	}


ERR ErrBMDoMerge( FUCB *pfucb, FUCB *pfucbRight, SPLIT *psplit )
	{
	ERR 		err;
	BF			*pbf = pbfNil;
	BYTE		*rgb;
	SSIB		*pssib = &pfucb->ssib;
	SSIB		*pssibRight = &pfucbRight->ssib;
	BOOL		fVisibleSons;
	LINE		rgline[3];
	INT 		cline;
	BYTE		cbSonMerged;
	BYTE		cbSonRight;
	BYTE		*pbNode;
	ULONG		cbNode;
	BYTE		*pbSonRight;
	ULONG		ibSonMerged;

	/* if buffer dependencies cause a cycle/violation,
	/* mask error to warning -- handled at caller
	/**/
	err = ErrBFDepend( psplit->pbfSibling, psplit->pbfSplit );
	if ( err == errDIRNotSynchronous )
		{
		err = wrnBMConflict;
		goto HandleError;
		}	
	Call( err );
	
	/*	allocate temporary page buffer
	/**/
	Call( ErrBFAllocTempBuffer( &pbf ) );
	rgb = (BYTE *)pbf->ppage;

	/*	check if sons of split page are visible
	/*	move sons
	/*	update sibling FOP
	/*	update merged FOP
	/**/

	/*	check if sons of split page are visible
	/*	cache split page son table
	/**/
	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );

	fVisibleSons = FNDVisibleSons( *pssib->line.pb );

	BFDirty( pssib->pbf );

	/* allocate buffers only, do not move nodes
	/**/
	err = ErrBTMoveSons( psplit,
		pfucb,
		pfucbRight,
		itagFOP,
		psplit->rgbSonNew,
		fVisibleSons,
		fAllocBufOnly );
	Assert( err != errDIRNotSynchronous );
	Call( err );

	/*	flag right page dirty
	/**/
	BFDirty( pssibRight->pbf );

	/* move nodes atomically
	/**/
	pssib->itag = itagFOP;
	Assert( psplit->ibSon == 0 );
	Assert( psplit->splitt == splittRight );
	Assert( pssib->itag == itagFOP );
	HoldCriticalSection( critJet );
	CallS( ErrBTMoveSons( psplit,
		pfucb,
		pfucbRight,
		itagFOP,
		psplit->rgbSonNew,
		fVisibleSons,
		fDoMove ) );
	ReleaseCriticalSection( critJet );

	/*	update new FOP
	/*	prepend son table
	/**/
	pssibRight->itag = itagFOP;
	PMGet( pssibRight, pssibRight->itag );
	cline = 0;
	rgb[0] = *pssibRight->line.pb;
	Assert( *(pssibRight->line.pb + 1) == 0 );
	rgb[1] = 0;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = 2;
	/* left page might have no sons of FOP, but only tags
	/* and hence not an empty page.
	/**/
	cbSonMerged = psplit->rgbSonNew[0];

	/* prepend new son table to already existing son table
	/**/
	pbNode = pssibRight->line.pb;
	cbNode = pssibRight->line.cb;
	pbSonRight = PbNDSon( pbNode );
	ibSonMerged = cbSonMerged;

	cbSonRight = CbNDSon( pbNode );
	if ( cbSonMerged )
	 	NDSetSon( rgb[0] );
 	psplit->rgbSonNew[0] += cbSonRight;
	rgline[cline].pb = psplit->rgbSonNew;
	rgline[cline++].cb = psplit->rgbSonNew[0] + 1;
	for ( ; ibSonMerged < psplit->rgbSonNew[0];  )
		{
		psplit->rgbSonNew[++ibSonMerged] = *pbSonRight++;
		Assert( ibSonMerged <= cbSonMax );
		}

	if ( fVisibleSons )
		NDSetVisibleSons( rgb[0] );
	Assert( pssibRight->itag == itagFOP );
	Assert( cline == 2 );
	Assert( PgnoOfPn( pssibRight->pbf->pn ) == psplit->pgnoSibling );
	CallS( ErrPMReplace( pssibRight, rgline, cline ) );
	AssertBTFOP( pssibRight );

	/*	update split FOP -- leave one deleted node in page
	/*	so BMCleanup can later retrieve page
	/**/
	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );
	AssertBTFOP( pssib );
	pbNode = pssib->line.pb;
	Assert( CbNDSon( pbNode ) == cbSonMerged );
	rgb[0] = *pbNode;
	rgb[1] = 0;

	NDResetSon( rgb[0] );
	Assert( FNDVisibleSons( rgb[0] ) );
	rgline[0].pb = rgb;
	Assert( psplit->ibSon == 0 );
	rgline[0].cb = 2 + psplit->ibSon;
	Assert( PgnoOfPn(pssib->pbf->pn) == psplit->pgnoSplit );
	CallS( ErrPMReplace( pssib, rgline, 1 ) );

	Call( ErrLGMerge( pfucb, psplit ) );

#ifdef DEBUG
	CallS( ErrPMGet( pssib, itagFOP ) );
	Assert( FNDNullSon( *pssib->line.pb ) );
#endif

HandleError:
	if ( pbf != pbfNil )
		BFSFree( pbf );
	return err;
	}


/* merge current page with the following page
/**/
LOCAL ERR ErrBMMergePage( FUCB *pfucb, FUCB *pfucbRight, KEY *pkeyMin, SRID sridFather )
	{
	ERR		err = JET_errSuccess;
	SPLIT	*psplit = NULL;
	SSIB	*pssibRight = &pfucbRight->ssib;
	SSIB	*pssib = &pfucb->ssib;
	LINE	lineNull = { 0, NULL };

	AssertCriticalSection( critSplit );
	Assert( pkeyMin->cb != 0 );
	Assert( pfucbRight != pfucbNil );

	/* current and right page must already be latched
	/**/
	CallR( ErrSTWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	/*	initialize local variables and allocate split resources
	/*  pin the buffers even though they are already pinned --
	/*  BTReleaseSplitBufs unpins them.
	/**/
	psplit = SAlloc( sizeof(SPLIT) );
	if ( psplit == NULL )
		{
		err = JET_errOutOfMemory;
		goto HandleError;
		}
	memset( (BYTE *)psplit, 0, sizeof(SPLIT) );
	psplit->ppib = pfucb->ppib;
	psplit->pgnoSplit = PcsrCurrent( pfucb )->pgno;
	psplit->pbfSplit = pfucb->ssib.pbf;
	AssertBFPin( psplit->pbfSplit );
	AssertBFWaitLatched( psplit->pbfSplit, pfucb->ppib );
	BFPin( psplit->pbfSplit );
	BFSetWriteLatch( psplit->pbfSplit, pfucb->ppib  );

	psplit->pgnoSibling = pfucbRight->pcsr->pgno;
	psplit->pbfSibling = pssibRight->pbf;
	AssertBFPin( psplit->pbfSibling );
	AssertBFWaitLatched( psplit->pbfSibling, pfucbRight->ppib );
	BFPin( psplit->pbfSibling );
	BFSetWriteLatch( psplit->pbfSibling, pfucb->ppib );
	psplit->ibSon = 0;
	psplit->splitt = splittRight;
	
	Call( ErrBMDoMerge( pfucb, pfucbRight, psplit ) );

	/* if already exisitng buffer dependencies cause cycle/violation,
	/* abort
	/**/
	Assert( err == JET_errSuccess || err == wrnBMConflict );
	if ( err == wrnBMConflict )
		{
		goto HandleError;
		}

	/* insert delete-flagged node in page
	/* so that BMCleanPage has a node to search for
	/* when it gets to remove the empty page
	/**/
	CallS( ErrDIRBeginTransaction( pfucb->ppib ) );
	Assert( PcsrCurrent( pfucb )->pgno == psplit->pgnoSplit );
	PcsrCurrent( pfucb )->itagFather = itagFOP;
	err = ErrNDInsertNode( pfucb, pkeyMin, &lineNull, fNDVersion | fNDDeleted );
	//	UNDONE:	handle error case
	Assert( err >= JET_errSuccess );
	if ( err >= JET_errSuccess )
		err = ErrDIRCommitTransaction( pfucb->ppib );
	if ( err < 0 )
		CallS( ErrDIRRollback( pfucb->ppib ) );
	Call( err );

	/* register page in MPL
	/**/
	Assert( sridFather != sridNull && sridFather != sridNullLink );
	MPLRegister( pfucb->u.pfcb,
		pssib,
		PnOfDbidPgno( pfucb->dbid, PcsrCurrent( pfucb )->pgno ),
		sridFather );
#ifdef DEBUG
	/*	source page should have at least one son
	/**/
	NDGet( pfucb, itagFOP );
	Assert( !FNDNullSon( *pssib->line.pb ) );
#endif

	//	UNDONE:	review conditional registry by B. Sriram
	//	UNDONE:	avoid case of fully depopulated page
	/*	a case exists where a page is fully depopulated as a result
	/*	of regular clean up finding a conflict after all nodes have
	/*	been deleted but before the min key can be inserted.  Handle
	/*	this case by not registering empty page.
	/**/
	Assert( FAccessPage( pfucbRight, PcsrCurrent( pfucbRight )->pgno ) );
	NDGet( pfucbRight, itagFOP );
	if ( !FNDNullSon( *pssibRight->line.pb ) )
		{
		MPLRegister( pfucbRight->u.pfcb,
			pssibRight,
			PnOfDbidPgno( pfucb->dbid, psplit->pgnoSibling ),
			sridFather );
		}

HandleError:
	/* release allocated buffers and memory
	/**/
	if ( psplit != NULL )
		{
		BTReleaseSplitBfs( fFalse, psplit, err );
		SFree( psplit );
		}

	return err;
	}


/*	latches buffer and adds it to list of latched buffers in rmpage
/**/
ERR ErrBMAddToLatchedBFList( RMPAGE	*prmpage, BF *pbfLatched )
	{
#define cpbfBlock	10
	ULONG	cpbf = prmpage->cpbf;

	if ( FBFWriteLatchConflict( prmpage->ppib, pbfLatched ) )
		{
		return JET_errWriteConflict; 
		}
		
	if ( prmpage->cpbfMax <= prmpage->cpbf + 1 )
		{
		BF		**ppbf;

		/* run out of space, get more buffers
		/**/
		prmpage->cpbfMax += cpbfBlock;
		ppbf = SAlloc( sizeof(BF*) * (prmpage->cpbfMax) );
		if ( ppbf == NULL )
			return( JET_errOutOfMemory );
		memcpy( ppbf, prmpage->rgpbf, sizeof(BF*) * cpbf);
		if ( prmpage->rgpbf )
			SFree(prmpage->rgpbf);
		prmpage->rgpbf = ppbf;
		}
	
	prmpage->cpbf++;
	*(prmpage->rgpbf + cpbf) = pbfLatched;
	BFPin( pbfLatched );
	BFSetWriteLatch( pbfLatched, prmpage->ppib );
	BFSetWaitLatch( pbfLatched, prmpage->ppib );

	return JET_errSuccess;
	}


//	UNDONE:	handle error from log write fail in ErrBMRemoveEmptyPage
//			when actually removing pages.  We should be able to ignore
//			error since buffers will not be flushed as a result of
//			WAL.  Thus OLC will not be done.  We may discontinue OLC
//			when log fails to mitigate all buffers dirty.
/* removes a page and adjusts pointers at parent and sibling pages
/* called only at do-time
/**/
LOCAL ERR ErrBMRemoveEmptyPage(
	FUCB		*pfucb,
	CSR			*pcsr,
	RMPAGE		*prmpage,
	BOOL 		fAllocBuf )
	{
	ERR  		err;
	PIB  		*ppib = pfucb->ppib;
	SSIB		*pssib = &pfucb->ssib;
	PGDISCONT	pgdiscontOrig;
	PGDISCONT	pgdiscontFinal;
	BOOL		fRmParent = fFalse;

	Assert( pfucb->ppib->level == 0 );
	AssertCriticalSection( critSplit );
	Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );
	Assert( prmpage->pgnoFather != pgnoNull );

	/* seek removed page, get left and right pgno
	/**/
	Call( ErrSTWriteAccessPage( pfucb, prmpage->pgnoRemoved ) );
	AssertBFWaitLatched( pssib->pbf, pfucb->ppib );

	if ( fAllocBuf && FBMCheckPageConflict( pfucb, prmpage->pgnoRemoved ) )
		{
		err = wrnBMConflict;
		goto HandleError;
		}

#ifdef DEBUG
	NDGet( pfucb, itagFOP );
	Assert( fAllocBuf || FPMEmptyPage( pssib ) || FPMLastNodeToDelete( pssib ) );
#endif
	PgnoPrevFromPage( pssib, &prmpage->pgnoLeft );
	PgnoNextFromPage( pssib, &prmpage->pgnoRight );

	/* seek and latch parent and sibling pages iff fAllocBuf
	/**/
	Call( ErrSTWriteAccessPage( pfucb, prmpage->pgnoFather ) );
	prmpage->pbfFather = pfucb->ssib.pbf;
	if ( fAllocBuf )
		{
		Call( ErrBMAddToLatchedBFList( prmpage, prmpage->pbfFather ) );
		}
	else
		{
		AssertBFWaitLatched( prmpage->pbfFather, pfucb->ppib );
		}

	if ( prmpage->pgnoLeft != pgnoNull )
		{
		Call( ErrSTWriteAccessPage( pfucb, prmpage->pgnoLeft ) );
		prmpage->pbfLeft = pfucb->ssib.pbf;
		if ( fAllocBuf )
			{
			Call( ErrBMAddToLatchedBFList( prmpage, prmpage->pbfLeft ) );
			}
		else
			{
			AssertBFWaitLatched( prmpage->pbfLeft, pfucb->ppib );
			}
		}

	if ( prmpage->pgnoRight != pgnoNull )
		{
		Call( ErrSTWriteAccessPage( pfucb, prmpage->pgnoRight ) );
		prmpage->pbfRight = pfucb->ssib.pbf;
		if ( fAllocBuf )
			{
			Call( ErrBMAddToLatchedBFList( prmpage, prmpage->pbfRight ) );
			}
		else
			{
			AssertBFWaitLatched( prmpage->pbfRight, pfucb->ppib );
			}
		}

	/* no rollback on empty page, in worst case, we lose some pages
	/**/
	Call( ErrDIRBeginTransaction( pfucb->ppib ) );

	CallJ( ErrBMDoEmptyPage( pfucb, prmpage, fAllocBuf, &fRmParent, fFalse ), Commit );

	if ( !fAllocBuf )
		{
#undef BUG_FIX
#ifdef BUG_FIX
		err = ErrLGEmptyPage( pfucb, prmpage );
		Assert( err >= JET_errSuccess || fLogDisabled );
		err = JET_errSuccess;
#else
		CallJ( ErrLGEmptyPage( pfucb, prmpage ), Commit );
#endif

		/* adjust the OLCstat info for fcb
		/**/
		pfucb->u.pfcb->cpgCompactFreed++;
		pgdiscontOrig = pgdiscont( prmpage->pgnoLeft, prmpage->pgnoRemoved )
	  		+ pgdiscont( prmpage->pgnoRight, prmpage->pgnoRemoved );
		pgdiscontFinal = pgdiscont( prmpage->pgnoLeft, prmpage->pgnoRight );
		pfucb->u.pfcb->olcStat.cDiscont += pgdiscontFinal - pgdiscontOrig;
		FCBSetOLCStatsChange( pfucb->u.pfcb );
		}

Commit:
#ifdef BUG_FIX
	err = ErrDIRCommitTransaction( pfucb->ppib );
	Assert( err >= JET_errSuccess || fLogDisabled );
	err = JET_errSuccess;
#else
	err = ErrDIRCommitTransaction( pfucb->ppib );
	if ( err < 0 )
		{
		CallS( ErrDIRRollback( pfucb->ppib ) );
		}
	Call( err );
#endif

	/* call next level of remove page if required
	/**/
	if ( fRmParent )
		{
		/* cache rmpage info
		/**/
		PGNO	pgnoFather = prmpage->pgnoFather;
		PGNO	pgnoRemoved = prmpage->pgnoRemoved;
		INT		itagPgptr = prmpage->itagPgptr;
		INT		itagFather = prmpage->itagFather;
		INT		ibSon = prmpage->ibSon;
		CSR		*pcsrFather = pcsr->pcsrPath;

		Assert( pcsrFather != pcsrNil );

		/* set up prmpage for the next level
		/**/
		prmpage->pgnoFather = pcsrFather->pgno;
		prmpage->pgnoRemoved = pcsr->pgno;
		prmpage->itagPgptr = pcsrFather->itag;
		prmpage->itagFather = pcsrFather->itagFather;
		prmpage->ibSon = pcsrFather->ibSon;

		/* tail recursion
		/**/
		err = ErrBMRemoveEmptyPage( pfucb, pcsr->pcsrPath, prmpage, fAllocBuf );

		/* reset rmpage to cached values
		/**/
		prmpage->pgnoFather = pgnoFather;
		prmpage->pgnoRemoved = pgnoRemoved;
		prmpage->itagPgptr = itagPgptr;
		prmpage->itagFather = itagFather;
		prmpage->ibSon = ibSon;

		Call( err );
		}

	if ( !fAllocBuf )
		{
		/* release page to parentFDP
		/**/
		CallS( ErrDIRBeginTransaction( pfucb->ppib ) );
		err = ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, prmpage->pgnoRemoved, 1 );
#ifdef BUG_FIX
		/*	ignore error from ErrSPFreeExt
		/**/
		err = ErrDIRCommitTransaction( pfucb->ppib );
		Assert( err >= JET_errSuccess || fLogDisabled );
		err = JET_errSuccess;
#else
		if ( err >= JET_errSuccess )
			{
			err = ErrDIRCommitTransaction( pfucb->ppib );
			}
		if ( err < 0 )
			{
			CallS( ErrDIRRollback( pfucb->ppib ) );
			goto HandleError;
			}
#endif
		}

	Assert( err >= JET_errSuccess );
	return err;

HandleError:
	BTReleaseRmpageBfs( fFalse, prmpage );
	Assert( pfucb->ppib->level == 0 );
	return err;
	}


LOCAL ERR ErrBMCleanPage(
	PIB 		*ppib,
	PN   		pn,
	SRID 		sridFather,
	FCB 		*pfcb,
	BOOL		fTableClosed,
	BOOL		*pfRmPage )
	{
	ERR  		err = JET_errSuccess;
	ERR  		wrn1 = JET_errSuccess;
	ERR			wrn2 = JET_errSuccess;
	FUCB		*pfucb;
	BF   		*pbfLatched;
	SSIB		*pssib;
	INT  		itag;
	INT  		itagMost;
	BOOL		fDeleteParents;
	BOOL		fNodeDeleted;
	BOOL		fMerge;
	BOOL		fLastNodeToDelete = fFalse;
	RMPAGE		*prmpage = prmpageNil;
	BYTE		rgbKey[ JET_cbKeyMost ];
	KEY			keyMin;
	BOOL		fKeyAvail = fFalse;

	AssertCriticalSection( critSplit );
	Assert( !FFCBDeletePending( pfcb ) );

	*pfRmPage = fFalse;

	/*	open FUCB and access page to be cleaned.
	/**/
	CallR( ErrDIROpen( ppib, pfcb, 0, &pfucb ) );
	pssib = &pfucb->ssib;
	PcsrCurrent( pfucb )->pgno = PgnoOfPn( pn );

	/*	access page to free and remove buffer dependencies
	/**/
	forever
		{
		CallJ( ErrSTWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ), FUCBClose );
//		Assert( FPMModified( pssib->pbf->ppage ) );
		Assert( pfcb->pgnoFDP == pssib->pbf->ppage->pghdr.pgnoFDP );

		pbfLatched = pssib->pbf;
		if ( FBFWriteLatchConflict( ppib, pbfLatched ) )
			{
			Assert( !*pfRmPage );
			wrn1 = wrnBMConflict;
			goto FUCBClose;
			}

		/*	if no dependencies, then break
		/**/
		if ( pbfLatched->cDepend == 0 )
			{
			break;
			}

		/*	remove dependencies on buffer of page to be removed, to
		/*	prevent buffer anomalies after buffer is reused.
		/**/
		BFRemoveDependence( pfucb->ppib, pssib->pbf );
		}
	Assert( pbfLatched->cDepend == 0 );

	/*	wait latch the page, so no one else can look at it
	/**/
	BFPin( pbfLatched );
	BFSetWriteLatch( pbfLatched, ppib );
	BFSetWaitLatch( pbfLatched, ppib );
	//	UNDONE:	fix this patch
	BFSetDirtyBit( pbfLatched );

	//	UNDONE:	find better way to do this
	/* get minimum key in this page to use later for dummy node insertion.
	/**/
	keyMin.pb = rgbKey;
	PcsrCurrent( pfucb )->itagFather = itagFOP;
	NDGet( pfucb, itagFOP );
	if ( !FNDNullSon( *pssib->line.pb ) )
		{
		NDMoveFirstSon( pfucb, PcsrCurrent( pfucb ) );
		keyMin.cb = CbNDKey( pssib->line.pb );
		Assert( keyMin.cb <= JET_cbKeyMost );
		memcpy( keyMin.pb, PbNDKey( pssib->line.pb ), keyMin.cb );
		fKeyAvail = fTrue;
		}
	else
		{
		keyMin.cb = 0;
		fKeyAvail = fFalse;
		}

	//	UNDONE:	should code below be reinstated???
	/*	if page has already been cleaned, then end cleanning and
	/*	return success.
	/*
	/*	if ( !( FPMModified( pssib->pbf->ppage ) ) )
	/*		{
	/*		Assert( err >= JET_errSuccess );
	/*		goto HandleError;
	/*		}
	/**/

	/*	set itagMost to last tag on page for tag loops
	/**/
	itagMost = ItagPMMost( pssib->pbf->ppage );

	/*	delete node trees from bottom up.  Loop once for each level
	/*	in deleted tree of nodes.
	/**/
	do
		{
		BOOL	fUndeletableNodeSeen = fFalse;

		fNodeDeleted = fFalse;
		fDeleteParents = fFalse;

		/*	for each tag in page check for deleted node.
		/**/
		for ( itag = 0; itag <= itagMost ; itag++ )
			{
			BOOL	fConflict = !fTableClosed;

			PcsrCurrent( pfucb )->itag = itag;
			err = ErrPMGet( pssib, PcsrCurrent( pfucb )->itag );
			Assert( err == JET_errSuccess || err == errPMRecDeleted );
			if ( err != JET_errSuccess )
				continue;

			/* check if there is any cursor open on this node
			/**/
			if ( !fTableClosed )
				{
				Call( ErrBMCheckConflict(
					ppib,
					pfcb,
					pfucb->dbid,
					SridOfPgnoItag( PcsrCurrent( pfucb )->pgno, itag ),
					PgtypPMPageTypeOfPage( pfucb->ssib.pbf->ppage ),
					&fConflict) );
				if ( fConflict )
					{
					/* some other user on this bm -- can't clean
					/* move on to next itag
					/**/
					// fUndeletableNodeSeen = fTrue;
					Assert( !*pfRmPage );
					wrn1 = wrnBMConflict;
					continue;
					}
				}

			Assert( !fConflict );
			NDIGetBookmark( pfucb, &PcsrCurrent( pfucb)->bm );

			/*	first check if version bit is set, but no version remains
			/*	for node.
			/**/
			if ( FNDVersion( *pssib->line.pb ) ||
				FNDFirstItem( *pssib->line.pb ) )
				{
				if ( FVERNoVersion( pfucb->dbid, PcsrCurrent( pfucb )->bm ) )
					{
					/*	although this implmentation could be more efficient
					/*	by using lower level reset bit call, it occurs so
					/*	rarely, that this is not necessary.
					/**/
					NDResetNodeVersion( pfucb );
					}
				else
					{
					/*	versioned nodes cannot be cleaned.  Move to next itag.
					/**/
					fUndeletableNodeSeen = fTrue;
					Assert( !*pfRmPage );
					wrn1 = wrnBMConflict;
					continue;
					}
				}

			Assert( !FNDVersion( *pssib->line.pb ) );

			/*	if node has back link
			/*	and back link is not in sridFather list of PME's,
			/*	then fix indexes if necessary,
			/*	remove redirector and remove back link.
			/**/
			if ( FNDBackLink( *pssib->line.pb ) )
				{
				Assert( PgnoOfSrid( PcsrCurrent( pfucb )->bm ) != pgnoNull );

				if ( PmpeMPLLookupSridFather( PcsrCurrent( pfucb )->bm,
					pfucb->dbid ) == NULL )
					{
					Call( ErrBMExpungeBacklink( pfucb, fTableClosed, sridFather ) );
					wrn1 = err == wrnBMConflict ? err : wrn1;
					Assert( err != wrnBMConflict || !*pfRmPage );
					}
#ifdef BMSTAT
				else
					{
					BMCannotExpunge( srid );
					}
#endif
				}

			Assert( PcsrCurrent( pfucb )->pgno == PgnoOfPn( pn ) );
			AssertNDGet( pfucb, itag );
			
			/*	back links may not have been removable.  If no backlink
			/*	and node flagged deleted, then remove node.
			/**/
			if( !FNDBackLink( *pssib->line.pb ) )
				{
				/*	expunge deleted nodes.
				/**/
				if ( FNDDeleted( *pssib->line.pb ) )
					{
					if ( FNDSon( *pssib->line.pb ) )
						{
						/*	if it has visible sons, then the sons must
						/*	have been marked as deleted. Otherwise do
						/*	nothing, let on-line compact to free the pointed
						/*	page, and then clean up the node.
						/**/
						if ( FNDVisibleSons( *pssib->line.pb ) )
							fDeleteParents = fTrue;
						continue;
						}

					/*	goto bookmark and call ErrDIRGet to set correct ibSon
					/*	in CSR for node deletion.
					/**/
					DIRGotoBookmark( pfucb,
						SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
						PcsrCurrent( pfucb )->itag ) );
					err = ErrDIRGet( pfucb );
					if ( err != JET_errRecordDeleted )
						{
						Assert( err < 0 );
						goto HandleError;
						}

					Assert( !FNDVersion( *pssib->line.pb ) );

					/*	call low level delete to bypass version store and
					/*	expunge deleted node from page.
					/*	If last node to be deleted from page, remove page.
					/**/
					Call( ErrDIRBeginTransaction( pfucb->ppib ) );

					if ( fOLCompact && !fUndeletableNodeSeen )
						{
						fLastNodeToDelete = FPMLastNodeToDelete( &pfucb->ssib );
						}

					if( fLastNodeToDelete &&
						sridFather != sridNull &&
						sridFather != sridNullLink )
						{
						/* cache invisible page pointer
						/**/
						Assert( fOLCompact );
						AssertCriticalSection( critSplit );
						Assert( PcsrCurrent( pfucb )->pgno == PgnoOfPn( pn ) );
						AssertNDGet( pfucb, itag );
						CallJ( ErrBTGetInvisiblePagePtr( pfucb, sridFather ), Rollback );
						Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );
						}

					//	UNDONE:	improve performance by deleting whole subtree

					/*	if node is page pointer, then discontinue
					/*	clean up on page until this node is deleted
					/*	when the page it points to is deleted.
					/**/
					if ( PcsrCurrent( pfucb )->itagFather != itagFOP )
						{
						NDGet( pfucb, PcsrCurrent( pfucb )->itagFather );
						if ( FNDSon( *pfucb->ssib.line.pb ) &&
							FNDInvisibleSons( *pfucb->ssib.line.pb ) )
							{
							wrn1 = wrnBMConflict;
							goto Rollback;
							}
						NDGet( pfucb, PcsrCurrent( pfucb )->itag );
						NDIGetBookmark( pfucb, &PcsrCurrent( pfucb)->bm );
 						Assert( PgnoOfSrid( PcsrCurrent( pfucb )->bm ) != pgnoNull );
						}

					Assert( !fConflict );
					if ( !fLastNodeToDelete )
					 	{
					 	Assert( PmpeMPLLookupSridFather( SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
					 		PcsrCurrent( pfucb )->itag ), pfucb->dbid ) == NULL );
						CallJ( ErrNDDeleteNode( pfucb ), Rollback );
						fNodeDeleted = fTrue;
						}

					CallJ( ErrDIRCommitTransaction( pfucb->ppib ), Rollback );
					continue;

Rollback:
					CallS( ErrDIRRollback( ppib ) );
					goto HandleError;
					}
				}
			}
		}
	while ( fNodeDeleted && fDeleteParents && !fLastNodeToDelete );

	if ( !fNodeDeleted && err != errPMRecDeleted )
		{
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
		}
	
	/* reset err [assumes successfully exit the loop]
	/**/
	Assert( err == JET_errSuccess ||
		err == errPMRecDeleted ||
		err == wrnBMConflict );
	err = JET_errSuccess;

	if ( fOLCompact &&
		sridFather != sridNull &&
		sridFather != sridNullLink )
		{
		if ( fLastNodeToDelete )
			{
			/* allocate and initialize rmpage struct
			/**/
			Assert( fOLCompact );
			Assert( FPMLastNodeToDelete( pssib ) );
			Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );
			prmpage = (RMPAGE *) SAlloc( sizeof(RMPAGE) );
			if ( prmpage == prmpageNil )
				{
				Error( JET_errOutOfMemory, HandleError );
				}
			memset( (BYTE *)prmpage, 0, sizeof(RMPAGE) );
			prmpage->ppib = pfucb->ppib;
			prmpage->pgnoRemoved = PcsrCurrent(pfucb)->pgno;
			prmpage->dbid = pfucb->dbid;
			prmpage->pgnoFather = PcsrCurrent( pfucb )->pcsrPath->pgno;
			prmpage->itagPgptr = PcsrCurrent( pfucb )->pcsrPath->itag;
			prmpage->itagFather = PcsrCurrent( pfucb )->pcsrPath->itagFather;
			prmpage->ibSon = PcsrCurrent( pfucb )->pcsrPath->ibSon;

			/* allocate rmpage resources
			/**/
			Call( ErrBMRemoveEmptyPage(
				pfucb,
				PcsrCurrent( pfucb )->pcsrPath,
				prmpage,
				fAllocBufOnly ) );
			Assert ( err == JET_errSuccess || err == wrnBMConflict );
			if ( err == wrnBMConflict )
				{
				Assert( !*pfRmPage );
				wrn2 = err;
				goto HandleError;
				}
			/*	check for conflict again after all buffers latched
			/**/
			if ( FBMCheckPageConflict( pfucb, prmpage->pgnoRemoved ) )
				{
				Assert( !*pfRmPage );
				wrn2 = wrnBMConflict;
				goto HandleError;
				}
				
			Assert( prmpage->dbid == pfucb->dbid );
			Assert( prmpage->pgnoFather == PcsrCurrent( pfucb )->pcsrPath->pgno );
			Assert( prmpage->itagFather == PcsrCurrent( pfucb )->pcsrPath->itagFather );
			Assert( prmpage->itagPgptr == PcsrCurrent( pfucb )->pcsrPath->itag );
			Assert( prmpage->ibSon == PcsrCurrent( pfucb )->pcsrPath->ibSon );

			Call( ErrBMRemoveEmptyPage(
				pfucb,
				PcsrCurrent( pfucb )->pcsrPath,
				prmpage,
				fDoMove ) );
			Assert( wrn2 != wrnBMConflict );
			*pfRmPage = fTrue;
			}
		else if ( fKeyAvail )
			{
			FUCB 	*pfucbRight = pfucbNil;
			PGNO 	pgnoRight;

			/* get page next to current page
			/* if last page, no merge
			/**/
			PgnoNextFromPage( pssib, &pgnoRight );

			if ( pgnoRight != pgnoNull )
				{
				/* access right page, latch and perform merge, if possible
				/**/
				Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbRight ) );
				PcsrCurrent( pfucbRight )->pgno = pgnoRight;
				CallJ( ErrSTWriteAccessPage( pfucbRight, PcsrCurrent( pfucbRight )->pgno ), CloseFUCB );
				if ( FBFWriteLatchConflict( pfucbRight->ppib, pfucbRight->ssib.pbf ) )
					{
					Assert( !*pfRmPage );
					wrn2 = wrnBMConflict;
					goto CloseFUCB;
					}
				BFPin( pfucbRight->ssib.pbf );
				BFSetWriteLatch( pfucbRight->ssib.pbf, pfucbRight->ppib );
				BFSetWaitLatch( pfucbRight->ssib.pbf, pfucbRight->ppib );

				BMMergeablePage( pfucb, pfucbRight, &fMerge );
				if ( fMerge )
					{
					CallJ( ErrBMMergePage( pfucb, pfucbRight, &keyMin, sridFather ), UnlatchPage );
					wrn2 = err == wrnBMConflict ? err : wrn2;
					Assert( err != wrnBMConflict || !*pfRmPage );
					}
UnlatchPage:
				Assert( pfucbRight != pfucbNil );
				AssertBFWaitLatched( pfucbRight->ssib.pbf, pfucbRight->ppib );
				Assert( PgnoOfPn( pfucbRight->ssib.pbf->pn ) == pgnoRight );
				BFResetWaitLatch( pfucbRight->ssib.pbf, pfucbRight->ppib );
				BFResetWriteLatch( pfucbRight->ssib.pbf, pfucbRight->ppib );
				BFUnpin( pfucbRight->ssib.pbf );
CloseFUCB:
				Assert( pfucbRight != pfucbNil );
				DIRClose( pfucbRight );
				Call( err );
				}
			}
		}

//	UNDONE: move free page to latching function
	/*	after the page has been freed, we can make no assumptions
	/*	about the state of the page buffer.  Further the page
	/*	should be freed only when the page buffer has been returned
	/*	to an inactive state with no page latches.
	/**/
//	AssertBFDirty( pbfLatched );

	if ( wrn1 != wrnBMConflict && wrn2 != wrnBMConflict )
		{
		FCBSetOLCStatsChange( pfucb->u.pfcb );
		pfucb->u.pfcb->olcStat.cUnfixedMessyPage--;
		PMResetModified( &pfucb->ssib );
		}

HandleError:
	if ( prmpage != prmpageNil )
		{
		BTReleaseRmpageBfs( fFalse, prmpage );
		SFree( prmpage );
		}
	BFResetWaitLatch( pbfLatched, ppib );
	BFResetWriteLatch( pbfLatched, ppib );
	BFUnpin( pbfLatched );

FUCBClose:
	DIRClose( pfucb );
	Assert( !*pfRmPage || wrn2 != wrnBMConflict );
	if ( err == JET_errSuccess && !*pfRmPage )
		err = wrn1 == wrnBMConflict ? wrn1 : wrn2;
	Assert( !( *pfRmPage && err == wrnBMConflict ) );
	
	return err;
	}


ERR ErrBMClean( PIB *ppib )
	{
	ERR		err = JET_errSuccess;
	MPE		*pmpe;
	FCB		*pfcb;
	PN		pn;
	DBID	dbid;
	INT		cmpeClean = 0;

	/*  if ppibBMClean == ppibNIL, we ran out of memory  */

	if (ppibBMClean == ppibNil)
		return JET_errOutOfMemory;

	/*	enter critBMRCEClean
	/**/
	LgLeaveCriticalSection( critJet );
	LgEnterNestableCriticalSection( critBMRCEClean );
	EnterNestableCriticalSection( critSplit );
	LgEnterNestableCriticalSection( critMPL );
	LgEnterCriticalSection(critJet);
	Assert( ppibBMClean->level == 0 );

	SgSemRequest( semMPL );
	pmpe = PmpeMPLGet();
	SgSemRelease( semMPL );

	/*	if no more MPL entries, then return no idle activity.
	/**/
	if ( pmpe == pmpeNil )
		{
		err = JET_wrnNoIdleActivity;
		goto HandleError;
		}

#ifdef FLAG_DISCARD
	/*	if MPE has been flagged for discard, then discard MPE now
	/**/
	if ( pmpe->fFlagDiscard )
		{
		MPLDiscard();
		goto HandleError;
		}
#endif 

	pn = pmpe->pn;
	dbid = DbidOfPn( pmpe->pn );

	/*	open database for session.  If database has been detached then
	/*	open will fail.
	/**/
	err = ErrDBOpenDatabaseByDbid( ppib, dbid );
	if ( err < 0 )
		{
		cmpeClean++;
		MPLDiscard();
		goto HandleError;
		}

	SgSemRequest( semGlobalFCBList );
	pfcb = PfcbFCBGet( DbidOfPn( pmpe->pn ), pmpe->pgnoFDP );
	Assert( pfcb == pfcbNil || pfcb->pgnoFDP == pmpe->pgnoFDP );

	/*	find FCB for table.  If FCB not found then discard MPE.  If FCB
	/*	reference count is 0, or if no bookmarks have been retrieved,
	/*	then process MPE.  Also discard if database can no longer be
	/*	written, which may happen through detach and attach since
	/*	MPL is not flushed on Detach.
	/**/
	if ( pfcb == pfcbNil || FDBIDReadOnly( DbidOfPn( pmpe->pn ) ) )
		{
		cmpeClean++;
		MPLDiscard();
		SgSemRelease( semGlobalFCBList );
		}
	else if ( pfcb->wRefCnt > 0 && !fOLCompact || FFCBDomainOperation( pfcb ) )
		{
		MPLDefer();
		SgSemRelease( semGlobalFCBList );
		}
	else if ( FFCBDenyDDL( pfcb, ppib ) )
		{
		/*	if uncommitted create index, we must defer clean up
		/*	on table, since case of write conflict on index entry
		/*	only, is not handled.
		/**/
		MPLDefer();
		SgSemRelease( semGlobalFCBList );
		}
	else if ( FFCBDeletePending( pfcb ) )
		{
		/*	Also, discard if table is being deleted.
		/**/
		cmpeClean++;
		MPLDiscard();
		SgSemRelease( semGlobalFCBList );
		}
	else
		{
		/* if there are no cursors on this FDP, then we can do compaction
		/* And we need to block out all openTables till we are done
		/**/
		BOOL fTableClosed = ( pfcb->wRefCnt <= 0 );
		BOOL fPageRemoved;

		if ( fTableClosed )
			{
			SignalReset( sigDoneFCB );
			FCBSetWait( pfcb );
			}
		Assert( pfcb == PfcbFCBGet( DbidOfPn( pmpe->pn ), pmpe->pgnoFDP ) );
		Assert( pfcb != pfcbNil );
		Assert( !fTableClosed || FFCBWait( pfcb ) );
		SgSemRelease( semGlobalFCBList );

		Assert( !fTableClosed || FFCBWait( pfcb ) );
		Assert( !FFCBDomainOperation( pfcb ) );

		/* block index creation that might mess up expunge backlinks
		/**/
		FCBSetDomainOperation( pfcb );
		
		err = ErrBMCleanPage( ppib,
			pmpe->pn,
			pmpe->sridFather,
			pfcb,
			fTableClosed,
			&fPageRemoved );

		Assert( !fTableClosed || FFCBWait( pfcb ) );
		Assert( !( fPageRemoved && err == wrnBMConflict ) );

		FCBResetDomainOperation( pfcb );

		if ( !fPageRemoved )
			{
			if ( err == wrnBMConflict )
				MPLDefer();
			else
				{
				Assert( pmpe == PmpeMPLGet( ) && pmpe->pn == pn);
				Assert( pfcb == PfcbFCBGet( DbidOfPn( pmpe->pn ), pmpe->pgnoFDP ) );
				cmpeClean++;
				MPLDiscard();
				}
			}

		Assert( pfcb != pfcbNil );
		if ( fTableClosed )
			{
			FCBResetWait( pfcb );
			SignalSend( sigDoneFCB );
			}
		}

	CallS( ErrDBCloseDatabaseByDbid( ppib, dbid ) );

	/*	set success code
	/**/
	if ( cmpeClean == 0 )
		err = JET_wrnNoIdleActivity;
	else
		err = JET_errSuccess;

HandleError:
	LgLeaveNestableCriticalSection( critMPL );
	LeaveNestableCriticalSection( critSplit );
	LgLeaveNestableCriticalSection( critBMRCEClean );
	return err;
	}


/*	number of MPE to attempt to process per synchronous call of
/*	BMCleanProcess.
/**/
#define cmpeClean	100


LOCAL ULONG BMCleanProcess( VOID )
	{
	INT	cmpe;
#ifdef ASYNC_BM_CLEANUP
	ERR	err;
#endif

#ifdef	ASYNC_BM_CLEANUP
	forever
		{
		SignalReset( sigBMCleanProcess );
		SignalWait( sigBMCleanProcess, -1 );

#ifdef DEBUG
		if ( !fDBGDisableBMClean )
#endif
			{
			LgEnterCriticalSection(critJet);
			for ( cmpe = 0; cmpe < cmpeClean; cmpe++ )
				{
				if ( fBMCleanTerm )
					{
					break;
					}
				err = ErrBMClean( ppibBMClean );
				if ( err == JET_wrnNoIdleActivity )
					break;
				}
			LgLeaveCriticalSection(critJet);
			}

		if ( fBMCleanTerm )
			break;
		}
#else	/* !ASYNC_BM_CLEANUP */
	for ( cmpe = 0; cmpe < cmpeClean; cmpe++ )
		{
		if ( fBMCleanTerm )
			{
			break;
			}
		(VOID) ErrBMClean( ppibBMClean );
		}
#endif	/* !ASYNC_BM_CLEANUP */

//	/*	exit thread on system termination.
//	/**/
//	SysExitThread( 0 );

	return 0;
	}


#ifdef DEBUG
VOID AssertBMNoConflict( PIB *ppib, DBID dbid, SRID bm )
	{
	PIB		*ppibT;

	for ( ppibT = ppibAnchor; ppibT != ppibNil; ppibT = ppibT->ppibNext )
		{
		FUCB	*pfucb = ppibT->pfucb;

		for ( ; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
			{
			CSR *pcsr = PcsrCurrent( pfucb );

			Assert( pfucb->ppib == ppibT );
			if ( pfucb->dbid != dbid )
				continue;

			if ( ppibT == ppib )
				{
				Assert( ppib == ppibBMClean );
				continue;
				}

			Assert( pfucb->bmStore != bm );
			Assert( pfucb->itemStore != bm );
			for ( ; pcsr != pcsrNil; pcsr = pcsr->pcsrPath )
				{
				Assert( pcsr->bm != bm );
				Assert( pcsr->item != bm );
				Assert( SridOfPgnoItag( pcsr->pgno, pcsr->itag ) != bm );
				}
			}
		}
	}


VOID AssertNotInMPL( DBID dbid, PGNO pgnoFirst, PGNO pgnoLast )
	{
	PN		pn = PnOfDbidPgno( dbid, pgnoFirst );
#ifdef FLAG_DISCARD
	MPE		*pmpe;
#endif

	for( ; pn <= PnOfDbidPgno( dbid, pgnoLast ); pn++ )
		{
		ULONG	itag;
		for ( itag = 0; itag < cbSonMax; itag++ )
			{
#ifdef FLAG_DISCARD
			pmpe = PmpeMPLLookupSridFather( SridOfPgnoItag( PgnoOfPn( pn ), itag ), dbid );
			Assert( pmpe == NULL || pmpe->fFlagDiscard == fTrue );
#else
			Assert( PmpeMPLLookupSridFather( SridOfPgnoItag( PgnoOfPn( pn ), itag ), dbid ) == NULL );
#endif
			}
#ifdef FLAG_DISCARD
		pmpe = PmpeMPLLookupPN( pn );
		Assert( pmpe == NULL || pmpe->fFlagDiscard == fTrue );
		pmpe = PmpeMPLLookupPgnoFDP( PgnoOfPn( pn ), dbid );
		Assert( pmpe == NULL || pmpe->fFlagDiscard == fTrue );
#else
		Assert( PmpeMPLLookupPN( pn ) == NULL );
		Assert( PmpeMPLLookupPgnoFDP( PgnoOfPn( pn ), dbid ) == NULL );
#endif
		}
	}


VOID AssertMPLPurgeFDP( DBID dbid, PGNO pgnoFDP )
	{
#ifdef FLAG_DISCARD
	MPE		*pmpe;
	pmpe = PmpeMPLLookupPgnoFDP( pgnoFDP, dbid );
	Assert( pmpe == NULL || pmpe->fFlagDiscard == fTrue );
#else
	Assert( PmpeMPLLookupPgnoFDP( pgnoFDP, dbid ) == NULL );
#endif
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\btsplit.c ===
#include "config.h"

#include <ctype.h>
#include <io.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "page.h"
#include "ssib.h"
#include "fcb.h"
#include "fucb.h"
#include "stapi.h"
#include "dirapi.h"
#include "nver.h"
#include "spaceapi.h"
#include "util.h"
#include "fmp.h"
#include "logapi.h"
#include "log.h"
#include "bm.h"

#define memcpy memmove

DeclAssertFile;					/* Declare file name for assert macros */

#ifdef DEBUG
//#define	DEBUGGING		1
#endif

void * __near critSplit;
static	INT		itagVSplit;
static	INT		cbVSplit;
static	INT		clineVSplit;
static	INT		clineVSplitTotal;

/*	split trace enable flag
/**/
//#define SPLIT_TRACE

/*	size of space extent =
/*	4 for tag
/*	1 for son in father's son table
/*	1 for node header
/*	1 for key length
/*	3 for key
/*	3 for data
/*	17 for luck ( fudge factor for future node expansion )
/**/
#define cbSPExt	30

#ifdef DEBUG
static INT iSplit = 0;
static INT cbfEmpty = 0;
#endif

#define	cbFirstPagePointer	sizeof(PGNO)

/*	split global comments
/*
/*	split physically logs split and new pages.  Operations on split
/*	and new pages must be below storeage API, as logging is performed
/*	at storage API.  Operations on non-split non-new pages must be at
/*	or above storage API to ensure logging occurs.
/**/
LOCAL ERR ErrBTSelectSplit( FUCB *pfucb, CSR *pcsr, SSIB *pssib, KEY key, INT cbNode, INT cbReq, BOOL fAppendPage, BOOL fDIRFlags, SPLIT *psplit, BOOL *pfAppend );
LOCAL ERR ErrBTMoveNode( SPLIT *psplit, FUCB *pfucb, FUCB *pfucbNew, INT itagNode, BYTE *rgbSonNew, BOOL fVisibleNode, BOOL fNoMove );
LOCAL ULONG UsBTWeight( FUCB *pfucb, INT itag );
LOCAL BOOL FBTVSplit( FUCB *pfucb, INT itag, INT cbReq, BOOL fMobile );
LOCAL VOID BTIVSplit( FUCB *pfucb, INT itag, INT cbReq, BOOL fMobile, BOOL *pfMobile, INT *pcb, INT *pclineTotal );
LOCAL VOID BTDoubleVSplit( FUCB *pfucb, INT itagSplit, INT cbReq, INT cbTotal, INT *pibSon, KEY *pkey );
LOCAL VOID BTHSplit( FUCB *pfucb, INT cbReq, BOOL fAppendPage, BOOL fReplace, BOOL fDIRFlags, INT *pibSon, KEY *pkeyMac, KEY *pkeySplit, BOOL *pfRight, BOOL *pfAppend, SPLIT *psplit);
LOCAL BOOL FBTTableData( FUCB *pfucb, PGNO pgno, INT itag );
LOCAL ERR ErrBTSetIntermediatePage( FUCB *pfucb, SPLIT *psplit, BYTE *rgb );

#if 0
LOCAL VOID BTCheckPage( BF *pbf )
	{
	SSIB	ssib;
	INT		itag;
	INT		cbSon = 0;
	INT		ctag = 0;

	ssib.pbf = pbf;

	for ( itag = 0; itag <= ItagPMMost( pbf->ppage ); itag++ )
		{
		if ( TsPMTagstatus( pbf->ppage, itag ) == tsLine )
			{
			ctag++;
			PMGet( &ssib, itag );
			if ( ( itag == itagFOP && FNDSon( *(ssib.line.pb) ) ) ||
				FNDNonIntrinsicSons( ssib.line.pb ) )
				{
				cbSon += *(BYTE *)(PbNDSonTable( ssib.line.pb ));
				}
			}
		}

	/*	one tag has no parent, FOP, so number of sons + 1 == number
	/*	of tags.
	/**/
	Assert( cbSon + 1 == ctag );

	return;
	}
#endif


#ifdef DEBUGGING
/*	pcsr must hold pgno of page to be checked
/**/
LOCAL VOID BTCheckSplit( FUCB *pfucb, CSR *pcsr )
	{
	PGNO	pgnoSav = PgnoOfPn( pfucb->ssib.pbf->pn );
	SSIB	*pssib = &pfucb->ssib;
	/*	pgno cannot change since this routine is only called within
	/*	split MUTEX.
	/**/
	PGNO	pgno = pcsr->pgno;
	PGNO	pgnoCurrent;
	KEY		key;
	BYTE	rgb[JET_cbKeyMost];
	PGNO	pgnoPrev;
	KEY		keyPrev;
	BYTE	rgbPrev[JET_cbKeyMost];
	BYTE	rgitag[cbSonMax];
	INT		ibSonMax;
	INT		ibSon;
	char	*pb;

	/*	check parent page
	/**/
	CallS( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
	NDCheckPage( pfucb );

	/*	initialize variables
	/**/
	key.pb = rgb;
	key.cb = 0;
	pgnoPrev = pgnoNull;
	keyPrev.pb = rgbPrev;
	keyPrev.cb = 0;

	/*	if father is intrinsic page pointer
	/*	then return.
	/**/
	if ( pcsr->itagFather == itagNull )
		goto Done;

	/*	get son table of parent node
	/**/
	CallS( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
	pssib->itag = pcsr->itagFather;
	PMGet( pssib, pssib->itag );
	Assert( !FNDNullSon( *pssib->line.pb ) );
	/*	may be multiple level visible tree, and not valid for check
	/**/
	if ( FNDVisibleSons( *pssib->line.pb ) )
		goto Done;

	/*	copy all son itags to rgitag
	/**/
	ibSonMax = CbNDSon( pssib->line.pb );
	pb = PbNDSon( pssib->line.pb );
	memcpy( rgitag, pb, ibSonMax );

	NDCheckPage( pfucb );

	for ( ibSon = 0; ibSon < ibSonMax - 1; ibSon++ )
		{
		/*	for each invisable son, cache key and go to page pointed
		/*	to and assert that greatest key in page pointed to is
		/*	less than page pointer node key.
		/**/
		pssib->itag = rgitag[ibSon];
		PMGet( pssib, pssib->itag );
		key.cb = CbNDKey( pssib->line.pb );
		memcpy( key.pb, PbNDKey( pssib->line.pb ), key.cb );
		pgnoCurrent = *(PGNO *)PbNDData( pssib->line.pb );
		/*	assert data is page
		/**/
		Assert( CbNDData( pssib->line.pb, pssib->line.cb ) == sizeof(PGNO) );

		/*	check previous page link
		/**/
		if ( pgnoPrev != pgnoNull )
			{
			PGNO	pgnoT;

			CallS( ErrSTReadAccessPage( pfucb, pgnoCurrent ) );
			LFromThreeBytes( pgnoT, pssib->pbf->ppage->pghdr.pgnoPrev );
			Assert( pgnoPrev == pgnoT );
			CallS( ErrSTReadAccessPage( pfucb, pgnoPrev ) );
			LFromThreeBytes( pgnoT, pssib->pbf->ppage->pghdr.pgnoNext );
			Assert( pgnoCurrent == pgnoT );
			}
		pgnoPrev = pgnoCurrent;

		/*	access current page
		/**/
		CallS( ErrSTReadAccessPage( pfucb, pgnoCurrent ) );

		pssib->itag = 0;
		PMGet( pssib, pssib->itag );
		if ( FNDSon( *pssib->line.pb ) )
			{
			NDCheckPage( pfucb );

			/*	assert keyPrev less than or equal to least key on page
			/**/
			pssib->itag = 0;
			PMGet( pssib, pssib->itag );
			pssib->itag = *( PbNDSon( pssib->line.pb ) );
			PMGet( pssib, pssib->itag );
			Assert( CmpStKey( StNDKey( pssib->line.pb ), &keyPrev ) >= 0 );

			/*	assert key greater tahn or equal to greatest key on page.
			/**/
			pssib->itag = 0;
			PMGet( pssib, pssib->itag );
			pssib->itag = *( PbNDSon( pssib->line.pb ) + CbNDSon( pssib->line.pb ) - 1 );
			PMGet( pssib, pssib->itag );
			Assert( CmpStKey( StNDKey( pssib->line.pb ), &key ) <= 0 );

			/*	make key into keyPrev for next iteration
			/**/
			keyPrev.cb = key.cb;
			memcpy( keyPrev.pb, key.pb, keyPrev.cb );
			}

		/*	prepare for next page pointer check
		/**/
		CallS( ErrSTReadAccessPage( pfucb, pgno ) );
		}

Done:
	/*	restore page currency
	/**/
	CallS( ErrSTReadAccessPage( pfucb, pgnoSav ) );
	return;
	}
#else /* !DEBUGGING */
	#define	BTCheckSplit( pfucb, pcsr )
#endif /* DEBUGGING */


LOCAL INLINE VOID BTIStoreLeafSplitKey( SPLIT *psplit, SSIB *pssib )
	{
	LFINFO *plfinfo = &psplit->lfinfo;

	plfinfo->pn = pssib->pbf->pn;
	plfinfo->ulDBTime = pssib->pbf->ppage->pghdr.ulDBTime;
	}


ERR ErrBTRefresh( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );

	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatBeforeCurNode:
		case csrstatAfterCurNode:
		case csrstatOnFDPNode:
		  	Call( ErrBTGotoBookmark( pfucb, PcsrCurrent( pfucb )->bm ) );
			break;
		default:
			{
			Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnDataRoot );
			Assert( PcsrCurrent( pfucb )->itagFather == itagNull );
			PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
			while( !FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
				{
				Call( ErrSTReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
				PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
				}
			PcsrCurrent( pfucb )->itag = ItagRootOfPfucb( pfucb );
			NDGet( pfucb, PcsrCurrent( pfucb )->itag );
			}
		}

HandleError:
	return err;
	}

	
/*	split is used to make more space available for insert or replace
/*	enlargment operations.  Parent currency must be visible father.
/**/
ERR ErrBTSplit( FUCB *pfucb, INT cbNode, INT cbReq, KEY *pkey, INT fDIRFlags )
	{
	ERR		err = JET_errSuccess;
	SSIB   	*pssib = &pfucb->ssib;
	CSR		*pcsrT;
	CSR   	**ppcsr = &PcsrCurrent( pfucb );
	CSR		*pcsrRoot = pcsrNil;
	CSR		*pcsrLongId;
	INT		citag;
	INT		cbSon;

	/*	store currency for split path construction
	/**/
	BYTE  	rgb[JET_cbKeyMost];
	KEY		key;
	SRID  	bm;
	PGNO  	pgno;
	INT		itag;
	SRID  	item;
	ULONG 	ulDBTime;
	LFINFO 	lfinfo;

	BOOL  	fAppend;
	BOOL  	fInPageParent = fFalse;
	BOOL  	fOutPageParent = fFalse;
	BOOL  	fTwoLevelSplit = fFalse;
#ifdef DEBUG
	PGNO  	pgnoT;
	INT		itagT;
	INT		csplit = 0;
#define csplitMax		10
#endif	/* DEBUG */

	#ifdef MUTEX
		/*	store currency, and request split MUTEX, and refresh currency
		/*	in case split occurred on same page will jet MUTEX
		/*	was given up.  We must request split MUTEX to maintain
		/*	validity of invisible CSR stack.  Also, we must store and
		/*	refresh so that the pgno itag retrieved from currency will
		/*	exist when seek looks for them.
		/**/
		if ( fDIRFlags & fDIRReplace )
			{
			NDGetBookmark( pfucb, &pfucb->bmRefresh );
			}

		LgLeaveCriticalSection( critJet );
		EnterNestableCriticalSection( critSplit );
		LgEnterCriticalSection( critJet );

		if ( fDIRFlags & fDIRReplace )
			{
			Call( ErrBTGotoBookmark( pfucb, pfucb->bmRefresh ) );
			}
	#endif

	Assert( pfucb->pbfEmpty == pbfNil );

	/*	We would expect to set citag to 0 if replace and to 1 if insert,
	/*	however, citag is set to 1 to cover case of item list split
	/*	which is called as fDIRReplace
	/**/
	citag = 1;

	if ( PcsrCurrent( pfucb )->csrstat != csrstatOnFDPNode )
		{
		/*	get key, pgno and itag for subsequent seek for update
		/**/
		bm = (*ppcsr)->bm;
		item = (*ppcsr)->item;
		ulDBTime = (*ppcsr)->ulDBTime;

		if ( fDIRFlags & fDIRReplace )
			{
			/*	in the case of replace item list, the current node has
			/*	not been cached.
			/**/
			pgno = (*ppcsr)->pgno;
			itag = (*ppcsr)->itag;
			key.pb = rgb;
			NDGet( pfucb, (*ppcsr)->itag );
			key.cb = CbNDKey( pssib->line.pb );
			Assert( sizeof(rgb) >= key.cb );
			memcpy( rgb, PbNDKey( pssib->line.pb ), key.cb );
			pkey = &key;
			}
		else
			{
			pgno = pgnoNull;
			itag = itagNil;
			key = *pkey;
			}

		/*	move to parent and remember parent CSR as root.
		/*	cache pgno, itag for subsequent seek for update.
		/**/
#ifdef DEBUG
		pgnoT = pfucb->pcsr->pgno;
		itagT = pfucb->pcsr->itag;
#endif

		/*	if leaf page is NOT FDP and visible parent in same page,
		/*	then handle as two level.  This allows split to H-Split any
		/*	page.  FDP page is excluded both because it cannot be H-Split
		/*	and because it typically has multiple visible levels.  This
		/*	code only handles two visible levels below the FOP.
		/**/
		Assert( PcsrCurrent( pfucb ) != pcsrNil );
		pcsrT = PcsrCurrent( pfucb )->pcsrPath;
		fInPageParent = fFalse;
		NDGet( pfucb, itagFOP );
		cbSon = CbNDSon( pfucb->ssib.line.pb );
		if ( cbSon > 1 )
			{
			if ( pcsrT != pcsrNil && PcsrCurrent( pfucb )->pgno != PgnoFDPOfPfucb( pfucb ) )
				{
				while ( pcsrT->pgno == PcsrCurrent( pfucb )->pgno )
					{
					if ( !FCSRInvisible( pcsrT ) )
						{
						fInPageParent = fTrue;
						/*	we currently only support a two level, and not an n-level in
						/*	page tree.
						/**/
						Assert( pcsrT->itagFather == itagFOP ||
							pcsrT->itagFather == itagNull );
						break;
						}
					}

				if ( fInPageParent )
					{
					/*	go to CSR above page
					/**/
					while ( pcsrT != pcsrNil &&
						pcsrT->pgno == PcsrCurrent( pfucb )->pgno )
						{
						pcsrT = pcsrT->pcsrPath;
						}

					/*	now look for visible parent above the page
					/**/
					while ( pcsrT != pcsrNil )
						{
						if ( !FCSRInvisible( pcsrT ) )
							{
							fOutPageParent = fTrue;
							Assert( pcsrT->itagFather == itagFOP ||
								pcsrT->itagFather == itagNull );
							break;
							}
						}

					fTwoLevelSplit = fInPageParent && fOutPageParent;
					}
				}
			}

		if ( fTwoLevelSplit )
			{
			ULONG	ulLongId;
			KEY		keyLongId;
			SRID	bmLong;
			PGNO	pgnoLong;
			INT		itagLong;
			SRID	itemLong;
			ULONG	ulDBTimeLong;

			/*  go to LongID
			/**/
			FUCBStore( pfucb );
			BTUp( pfucb );
			Assert ( PcsrCurrent( pfucb )->itag != itagNil);
			Call( ErrBTRefresh( pfucb ) );
			Call( ErrBTGet( pfucb, pfucb->pcsr ) );
			Assert( CbNDKey( pfucb->ssib.line.pb ) == sizeof(ULONG) );

			ulLongId = *(ULONG UNALIGNED *)PbNDKey(pfucb->ssib.line.pb);

			/*  go to LONG
			/**/
			bmLong = PcsrCurrent( pfucb )->bm;
			pgnoLong = PcsrCurrent( pfucb )->pgno;
			itagLong = PcsrCurrent( pfucb )->itag;
			itemLong = PcsrCurrent( pfucb )->item;
			ulDBTimeLong = PcsrCurrent( pfucb )->ulDBTime;

			BTUp( pfucb );
			pcsrRoot = PcsrCurrent( pfucb );
			Call( ErrBTRefresh( pfucb ) );
			Assert( PcsrCurrent( pfucb ) == pcsrRoot );
			Assert( PcsrCurrent( pfucb )->itag != itagNil );

			/*	seek to LongID
			/**/
			keyLongId.pb = (BYTE *)&ulLongId;
			keyLongId.cb = sizeof( ULONG );

			/*	must be replace so as to seek exact
			/**/
			if ( !FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
				{
				Call( ErrSTReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
				}

			FUCBSetFull( pfucb );
			err = ErrBTSeekForUpdate( pfucb, &keyLongId, pgnoLong, itagLong, fDIRFlags | fDIRDuplicate | fDIRReplace ) ;
			Assert ( err >= 0 );
			pcsrLongId = PcsrCurrent( pfucb );

			/*	preserve currency of Long.
			/**/
			PcsrCurrent( pfucb )->bm = bmLong;
			Assert( PcsrCurrent( pfucb )->pgno == pgnoLong );
			Assert( PcsrCurrent( pfucb )->itag == itagLong );
			PcsrCurrent( pfucb )->item = itemLong;
			PcsrCurrent( pfucb )->ulDBTime = ulDBTimeLong;
			}
		else
			{
			FUCBStore( pfucb );
			BTUp( pfucb );
			pcsrRoot = PcsrCurrent( pfucb );
			if ( PcsrCurrent( pfucb ) != pcsrNil )
				{
				Call( ErrBTRefresh( pfucb ) );
				Assert( PcsrCurrent( pfucb ) == pcsrRoot );
				}
			}

		/*	inserting cursors, are already located on the root node.  Replace
		/*	cursors must be moved to their visible fathers prior to split.
		/*	Note that visible father is father of node in keep.
		/**/
		if ( PcsrCurrent( pfucb ) == pcsrNil )
			{
			Assert( FFUCBIndex( pfucb ) );
			Assert( fDIRFlags & fDIRReplace );
			Call( ErrFUCBNewCSR( pfucb ) );

			/*	goto DATA root
			/**/
			PcsrCurrent( pfucb )->csrstat = csrstatOnDataRoot;
			PcsrCurrent( pfucb )->bm = pfucb->u.pfcb->bmRoot;
			PcsrCurrent( pfucb )->itagFather = itagNull;
			PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
			if ( !FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
				{
				Call( ErrSTReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
				}
			Assert( PcsrCurrent( pfucb )->pgno == PgnoRootOfPfucb( pfucb ) );
			PcsrCurrent( pfucb )->itag = ItagRootOfPfucb( pfucb );
			}

		/*	currency must be on visible father before calling seek for update.
		/**/
		if ( !FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
			{
			Call( ErrSTReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
			}
		FUCBSetFull( pfucb );
		Call( ErrBTSeekForUpdate( pfucb, pkey, pgno, itag, fDIRFlags | fDIRDuplicate ) );

		/*	preserve currency.
		/**/
		(*ppcsr)->bm = bm;
		(*ppcsr)->item = item;
		(*ppcsr)->ulDBTime = ulDBTime;

		Assert( !(fDIRFlags & fDIRReplace) || (*ppcsr)->csrstat == csrstatOnCurNode );
		Assert( !(fDIRFlags & fDIRReplace) || (*ppcsr)->pgno == pgno && (*ppcsr)->itag == itag );
		}

	/*	split page as necessary to make requested space available.  Note that
	/*	page may already have been split by another user inserting/enlarging
	/*	on same page.
	/**/
	BTIInitLeafSplitKey(&lfinfo);

	while ( ( fAppend = (fDIRFlags & fDIRReplace) ? 0 : FBTAppendPage( pfucb, *ppcsr, cbReq, 0, CbFreeDensity( pfucb ) ) ) ||
		FBTSplit( pssib, cbReq, citag ) )
		{
		CallJ( ErrBTSplitPage(
			pfucb,
			*ppcsr,
			pcsrRoot,
			key,
			cbNode,
			cbReq,
			fDIRFlags,
			fAppend,
			&lfinfo ), RestoreCurrency );

		/*	must access current page so that while macros can
		/*	check page for available space.
		/**/
		if ( !FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
			{
			CallJ( ErrSTReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ), RestoreCurrency );
			}
		Assert( ++csplit < csplitMax );
		}

RestoreCurrency:
	if ( PcsrCurrent( pfucb )->csrstat != csrstatOnFDPNode )
		{
		/*	if error occurred then refresh currency to that at function
		/*	start, else remove invisible CSR stack and former current
		/*	CSR, leaving new currency as current.
		/**/
		if ( fTwoLevelSplit )
			{
			FUCBFreePath( &(*ppcsr)->pcsrPath, pcsrLongId );
			FUCBFreePath( &pcsrLongId->pcsrPath, pcsrRoot );
			}
		else
			{
			FUCBFreePath( &(*ppcsr)->pcsrPath, pcsrRoot );
			}

		FUCBRemoveInvisible( ppcsr );
		}

HandleError:
	/*	reset full flag
	/**/
	FUCBResetFull( pfucb );

	Assert( PcsrCurrent( pfucb ) != pcsrNil );

	#ifdef MUTEX
		LeaveNestableCriticalSection( critSplit );
	#endif

	//	UNDONE:	find a better way to MUTEX.  Can per domain
	//			MUTEX solve this deadlock problem when waiters
	//			hold critJet and are waiting for write latch
	//			holders waiting for critSplit.  If we
	//			critJet on domain basis then this problem
	//			should be avoided.
	/*	not sychronous to JET_errSuccess.  May have contended
	/*	on page lock so yeild to other waiter to avoid
	/*	future contension.
	/**/
	if ( err == errDIRNotSynchronous )
		{
		err = JET_errSuccess;
		BFSleep( cmsecWaitWriteLatch );
		}
	return err;
	}


ERR ErrBTSetUpSplitPages( FUCB *pfucb, FUCB *pfucbNew, FUCB *pfucbNew2, FUCB *pfucbNew3, SPLIT *psplit, PGTYP pgtyp, BOOL fAppend, BOOL fSkipMove )
	{
	ERR		err;
	BOOL 	fDoubleVertical = ( psplit->splitt == splittDoubleVertical );
	SSIB 	*pssib  = &pfucb->ssib;
	SSIB 	*pssibNew  = &pfucbNew->ssib;
	SSIB 	*pssibNew2;
	SSIB 	*pssibNew3;

	if ( fDoubleVertical )
		{
		pssibNew2  = &pfucbNew2->ssib;
		pssibNew3  = &pfucbNew3->ssib;
		}

	PcsrCurrent( pfucbNew )->pgno = psplit->pgnoNew;
	Assert( PcsrCurrent( pfucbNew )->pgno != pgnoNull );
	PcsrCurrent( pfucbNew )->itag = itagFOP;

	/*	in redo, we may redo the appended page, but we have to set
	/*	right bit if it is for leaf node when initialize FOP node.
	/*	for regular case, fLeaf is not set until MoveNodes are called.
	/**/
	Assert( !( fAppend && psplit->fLeaf ) || fRecovering );

	if ( fRecovering )
		{
		BF		*pbf;
		BOOL	fRedoNeeded;

		/* if need to redo or not
		/**/
		psplit->fNoRedoNew = ErrLGRedoable(
			pfucb->ppib,
			PnOfDbidPgno( pfucb->dbid, psplit->pgnoNew ),
			psplit->ulDBTimeRedo,
			&pbf,
			&fRedoNeeded ) == JET_errSuccess &&
			fRedoNeeded == fFalse;
		}
		
	CallR( ErrNDNewPage( pfucbNew,
		PcsrCurrent( pfucbNew )->pgno,
		pfucbNew->u.pfcb->pgnoFDP,
		pgtyp, fAppend && psplit->fLeaf ) )

 	/* lock it till split log rec is generated
	/**/
	if ( FBFWriteLatchConflict( pssibNew->ppib, pssibNew->pbf ) )
		{
		/*	yeild after release split resources
		/**/
		return errDIRNotSynchronous;
		}
 	BFPin( pssibNew->pbf );
	BFSetWriteLatch( pssibNew->pbf, pssibNew->ppib );
	Assert( psplit->pbfNew == pbfNil );
 	psplit->pbfNew = pssibNew->pbf;

	if ( fDoubleVertical )
		{
		PcsrCurrent( pfucbNew2 )->pgno = psplit->pgnoNew2;
		Assert( PcsrCurrent( pfucbNew2 )->pgno != pgnoNull );
		PcsrCurrent( pfucbNew2 )->itag = 0;
		
		if ( fRecovering )
			{
			BF		*pbf;
			BOOL	fRedoNeeded;

			/* if need to redo or not
			/**/
			psplit->fNoRedoNew2 = ErrLGRedoable(
				pfucb->ppib,
				PnOfDbidPgno( pfucb->dbid, psplit->pgnoNew2 ),
				psplit->ulDBTimeRedo,
				&pbf, &fRedoNeeded ) == JET_errSuccess &&
				fRedoNeeded == fFalse;
			}
		
		CallR( ErrNDNewPage( pfucbNew2, PcsrCurrent( pfucbNew2 )->pgno, pfucbNew2->u.pfcb->pgnoFDP, pgtyp, fFalse ) );
		if ( FBFWriteLatchConflict( pssibNew2->ppib, pssibNew2->pbf ) )
			{
			/*	yeild after release split resources
			/**/
			return errDIRNotSynchronous;
			}
 		BFPin( pssibNew2->pbf );
		BFSetWriteLatch( pssibNew2->pbf, pssibNew2->ppib );
		Assert( psplit->pbfNew2 == pbfNil );
 		psplit->pbfNew2 = pssibNew2->pbf;

		PcsrCurrent( pfucbNew3 )->pgno = psplit->pgnoNew3;
		Assert( PcsrCurrent( pfucbNew3 )->pgno != pgnoNull );
		PcsrCurrent( pfucbNew3 )->itag = 0;

		if ( fRecovering )
			{
			BF		*pbf;
			BOOL	fRedoNeeded;

			/* if need to redo or not
			/**/
			psplit->fNoRedoNew3 = ErrLGRedoable(
				pfucb->ppib,
				PnOfDbidPgno( pfucb->dbid, psplit->pgnoNew3 ),
				psplit->ulDBTimeRedo,
				&pbf,
				&fRedoNeeded ) == JET_errSuccess &&
				fRedoNeeded == fFalse;
			}
		
		CallR( ErrNDNewPage( pfucbNew3, PcsrCurrent( pfucbNew3 )->pgno, pfucbNew3->u.pfcb->pgnoFDP, pgtyp, fFalse ) );
		if ( FBFWriteLatchConflict( pssibNew3->ppib, pssibNew3->pbf ) )
			{
			/*	yeild after release split resources
			/**/
			return errDIRNotSynchronous;
			}
		BFPin( pssibNew3->pbf );
		BFSetWriteLatch( pssibNew3->pbf, pssibNew3->ppib );
		Assert( psplit->pbfNew3 == pbfNil );
		psplit->pbfNew3 = pssibNew3->pbf;
		}

	if ( fRecovering && fSkipMove )
		{
		/* if it is skip move, no need to touch the split page
		/**/
		Assert( fRecovering );
		psplit->pbfSplit = pbfNil;
		return JET_errSuccess;
		}
		
	/*	acquire write access on split page and flag page buffer as dirty
	/**/
	if ( !( FWriteAccessPage( pfucb, psplit->pgnoSplit ) ) )
		{
		CallR( ErrSTWriteAccessPage( pfucb, psplit->pgnoSplit ) );
		}

	/* lock it till split log rec is generated
	/**/
	if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
		{
		/*	yeild after release split resources
		/**/
		return errDIRNotSynchronous;
		}
	BFPin( pssib->pbf );
	BFSetWriteLatch( pssib->pbf, pssib->ppib );
	Assert( psplit->pbfSplit == pbfNil );
	psplit->pbfSplit = pssib->pbf;

	/*	make split page depend on new page
	/*	append page has no data from src page and hence there
	/*	is no dependency.
	/*	Also bookmark all visible (leaf) nodes.
	/**/
	PMGet( pssib, pssib->itag );

	/*	if split not append then set buffer dependency
	/**/
	if ( psplit->splitt != splittAppend )
		{
		CallR( ErrBFDepend( pssibNew->pbf, pssib->pbf ));

		if ( fDoubleVertical )
			{
			CallR( ErrBFDepend( pssibNew2->pbf, pssib->pbf ));
			CallR( ErrBFDepend( pssibNew3->pbf, pssib->pbf ));
			}
		}

	return JET_errSuccess;
	}

	
/*	Move Nodes for Vertical split.
/*	This function only touches the split page and new page.
/**/
ERR ErrBTSplitVMoveNodes(
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	SPLIT	*psplit,
	CSR		*pcsr,
	BYTE	*rgb,
	BOOL	fNoMove )
	{
	SSIB	*pssib  = &pfucb->ssib;
	SSIB	*pssibNew  = &pfucbNew->ssib;
	LINE	rgline[6];
	INT 	cline;
	BYTE	bTmp;
	INT 	cbSon;
	INT 	ibSon;
	BYTE	*pbSon;
	BYTE	*pbNode;
	BYTE	*pbData;
	BOOL	fVisibleSons;
	ERR 	err;
	BYTE	rgbT[1 + sizeof(PGNO)];

	/*	set new page type and pgnoFDP
	/*	cache split node son table
	/*	move sons
	/*	update split node
	/*	insert page pointer in split page to new page
	/**/

	/*	cache split node son table
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );

	fVisibleSons = FNDVisibleSons( *pssib->line.pb );
	if ( !fNoMove )
		{
		/* do not change anything before real move
		/**/
		psplit->fLeaf |= fVisibleSons;
		}

	pbSon = PbNDSon( pssib->line.pb );
	Assert( psplit->itagSplit != itagFOP );
	if ( FNDNullSon( *pssib->line.pb ) || FNDNonIntrinsicSons( pssib->line.pb ) )
		{
		cbSon = CbNDSon( pssib->line.pb );
		Assert( cbSon < cbSonMax );
		psplit->rgbSonSplit[0] = (BYTE)cbSon;
		for ( ibSon = 0; ibSon < cbSon; ibSon++ )
			{
			psplit->rgbSonSplit[ibSon + 1] = pbSon[ibSon];
			}

		/*	move sons
		/**/
		CallR( ErrBTMoveSons( psplit, pfucb, pfucbNew, pssib->itag,
			psplit->rgbSonNew, fVisibleSons, fNoMove ) );

		if ( fNoMove )
			return err;
		}
	else
		{
		/*	if split node contained intrinsic page pointer,
		/*	split page pointer to new page.  Correct page
		/*	pointer CSR to new page.  Since there may be another
		/*	full cursor, must call MCMCorrectIntrinsic to
		/*	change position.
		/**/
		Assert( pssib->itag != itagNull );

		if ( fNoMove )
			return JET_errSuccess;

		cline = 0;
		rgb[0] = 0;
		rgb[1] = 0;
		rgline[cline].pb = (BYTE *)rgb;
		rgline[cline++].cb = 2;
		rgline[cline].pb = (BYTE *)pbSon;
		rgline[cline++].cb = sizeof(PGNO);
		Assert( cline <= 6 );
		CallS( ErrPMInsert( pssibNew, rgline, cline ) );
		Assert( pssibNew->itag == 1 );

		if ( !fRecovering )
			{
			/*	correct parent CSR to split page
			/**/
			MCMBurstIntrinsic( pfucb, pcsr->pgno,
				pcsr->itagFather, psplit->pgnoNew, pssibNew->itag );
			Assert( pcsr->pgno == psplit->pgnoNew );
			Assert( pcsr->itag == pssibNew->itag );
			Assert( pcsr->itagFather == itagFOP );
			Assert( pcsr->csrstat == csrstatOnCurNode );
			}

		/*	show moved one son to itag 1
		/**/
		psplit->rgbSonNew[0] = 1;
		psplit->rgbSonNew[1] = 1;
		}

	/*	update FOP of new page
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );
	bTmp = *(pssib->line.pb);
	rgb[0] = 0;
	if ( fVisibleSons )
		{
		NDSetVisibleSons( rgb[0] );
		}
	rgb[1] = 0;
	cline = 0;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = 2;
	if ( psplit->rgbSonNew[0] != 0 )
		{
		NDSetSon( rgb[0] );
		rgline[cline].pb = psplit->rgbSonNew;
		rgline[cline++].cb = psplit->rgbSonNew[0] + 1;
		}
	else
		{
		NDResetSon( rgb[0] );
		Assert( FNDVisibleSons( rgb[0] ) );
		}
	pssibNew->itag = 0;
	Assert(cline <= 6);
	Assert( PgnoOfPn(pssibNew->pbf->pn) == psplit->pgnoNew );
	CallS( ErrPMReplace( pssibNew, rgline, cline ) );

	/*	update split node with intrinsic page pointer
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );
	memcpy( rgb, pssib->line.pb, pssib->line.cb );
	pbNode = rgb;
	Assert( bTmp == *(pbNode) );
	NDSetSon( bTmp );
	NDSetInvisibleSons( bTmp );
	cline = 0;
	rgline[cline].pb = &bTmp;
	rgline[cline++].cb = 1;
	rgline[cline].pb = StNDKey( pbNode );
	rgline[cline++].cb = CbNDKey( pbNode ) + 1;
	rgbT[0] = 1;
	*(PGNO UNALIGNED *)&rgbT[1] = psplit->pgnoNew;
	rgline[cline].pb = rgbT;
	rgline[cline++].cb = 1 + sizeof(PGNO);

	/*	copy back link
	/**/
	if ( FNDBackLink( *pbNode ) )
		{
		rgline[cline].pb = PbNDBackLink( pbNode );
		rgline[cline++].cb = sizeof(SRID);
		}
	pbData = PbNDData( pbNode );
	rgline[cline].pb = pbData;
	rgline[cline++].cb = pssib->line.cb - (ULONG) ( pbData - pbNode );
	Assert( cline <= 6 );
	Assert( PgnoOfPn(pssib->pbf->pn) == psplit->pgnoSplit );
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	return JET_errSuccess;
	}


/*  Move Nodes for Double Vertical split.
/*  This function only touches the split page and new page.
/**/
ERR ErrBTSplitDoubleVMoveNodes(
	FUCB		*pfucb,
	FUCB		*pfucbNew,
	FUCB		*pfucbNew2,
	FUCB		*pfucbNew3,
	SPLIT		*psplit,
	CSR		  	*pcsr,
	BYTE		*rgb,
	BOOL		fNoMove )
	{
	SSIB		*pssib  = &pfucb->ssib;
	SSIB		*pssibNew2  = &pfucbNew2->ssib;
	SSIB		*pssibNew3  = &pfucbNew3->ssib;
	LINE		rgline[6];
	INT	  		cline;
	BYTE		bTmp;
	INT	  		cbSon;
	INT	  		ibSon;
	BYTE		*pbSon;
	BYTE		*pbNode;
	BYTE		*pbData;
	BYTE		*pbSonNew = psplit->rgbSonNew;
	THREEBYTES	tbNew2;
	THREEBYTES	tbNew3;
	BOOL		fVisibleSons;
	ERR			err;

	/*	set new page type and pgnoFDP
	/*	cache split node son table
	/*	move sons
	/*	update split node
	/*	insert page pointer in split page to new page
	/**/

	/*	cache split node son table
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );

	fVisibleSons = FNDVisibleSons( *pssib->line.pb );
	if ( !fNoMove )
		{
		/* do not change anything before real move
		/**/
		psplit->fLeaf |= fVisibleSons;
		}

	pbSon = PbNDSon( pssib->line.pb );

	/*	we shall never Double VSplit a node with no son or with an
	/*	intrinsic son.  A normal VSplit should be performed instead.
	/**/
	Assert( FNDNullSon( *pssib->line.pb ) || FNDNonIntrinsicSons( pssib->line.pb ) );

	cbSon = CbNDSon( pssib->line.pb );
	Assert( cbSon < cbSonMax );
	psplit->rgbSonSplit[0] = (BYTE)cbSon;
	for ( ibSon = 0; ibSon < cbSon; ibSon++ )
		{
		psplit->rgbSonSplit[ibSon + 1] = pbSon[ibSon];
		}

	/*	move sons from 0th son to ibSon
	/**/
	psplit->splitt = splittLeft;
	CallR( ErrBTMoveSons( psplit,
		pfucb,
		pfucbNew2,
		pssib->itag,
		pbSonNew,
		fVisibleSons,
		fNoMove ) );

	if ( !fNoMove )
		{
		/*	update FOP of new page
		/**/
		pssib->itag = psplit->itagSplit;
		PMGet( pssib, pssib->itag );
		bTmp = *(pssib->line.pb);
		rgb[0] = 0;
		if ( FNDVisibleSons( bTmp ) )
			{
			NDSetVisibleSons( rgb[0] );
			}
		rgb[1] = 0;
		cline = 0;
		rgline[cline].pb = rgb;
		rgline[cline++].cb = 2;
		if ( *pbSonNew != 0 )
			{
			NDSetSon( rgb[0] );
			rgline[cline].pb = pbSonNew;
			rgline[cline++].cb = *pbSonNew + 1;
			}
		else
			{
			NDResetSon( rgb[0] );
			Assert( FNDVisibleSons( rgb[0] ) );
			}
		pssibNew2->itag = 0;
		Assert( cline <= 6 );
		Assert( PgnoOfPn(pssibNew2->pbf->pn) == psplit->pgnoNew2 );
		CallS( ErrPMReplace( pssibNew2, rgline, cline ) );
		}

	/*	cache split node son table
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );

	/*	adjust to point to second set of sons (their itags)
	/**/
	pbSonNew += ( *pbSonNew + 1 );
	Assert( pbSonNew == psplit->rgbSonNew + *psplit->rgbSonNew + 1 );

	/* move sons from ibSon + 1 to end
	/**/
	psplit->splitt = splittRight;
	psplit->ibSon++;
	Assert( cbSon - psplit->ibSon > 0 );
	CallR( ErrBTMoveSons( psplit,
		pfucb,
		pfucbNew3,
		pssib->itag,
		pbSonNew,
		fVisibleSons,
		fNoMove ) );

	psplit->splitt = splittDoubleVertical;
	psplit->ibSon--;

	if ( fNoMove )
		{
		return JET_errSuccess;
		}

	/*	update FOP of new page
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );
	bTmp = *(pssib->line.pb);
	rgb[0] = 0;
	if ( FNDVisibleSons( bTmp ) )
		{
		NDSetVisibleSons( rgb[0] );
		}
	rgb[1] = 0;
	cline = 0;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = 2;
	if ( *pbSonNew != 0 )
		{
		NDSetSon( rgb[0] );
		rgline[cline].pb = pbSonNew;
		rgline[cline++].cb = *pbSonNew + 1;
		}
	else
		{
		NDResetSon( rgb[0] );
		Assert( FNDVisibleSons( rgb[0] ) );
		}
	pssibNew3->itag = 0;
	Assert( cline <= 6 );
	Assert( PgnoOfPn(pssibNew3->pbf->pn) == psplit->pgnoNew3 );
	CallS( ErrPMReplace( pssibNew3, rgline, cline ) );

	/*	update split node with intrinsic page pointer
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );
	pbNode = pssib->line.pb;
	Assert( bTmp == *(pbNode) );
	NDSetSon( bTmp );
	NDSetInvisibleSons( bTmp );
	cline = 0;
	rgline[cline].pb = &bTmp;
	rgline[cline++].cb = 1;
	rgline[cline].pb = StNDKey( pbNode );
	rgline[cline++].cb = CbNDKey( pbNode ) + 1;
	rgb[0] = 1;
	*(PGNO UNALIGNED *)&rgb[1] = psplit->pgnoNew;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = 1 + sizeof(PGNO);
	/*	copy back link
	/**/
	if ( FNDBackLink( *pbNode ) )
		{
		rgline[cline].pb = PbNDBackLink( pbNode );
		rgline[cline++].cb = sizeof(SRID);
		}
	pbData = PbNDData( pbNode );
	rgline[cline].pb = pbData;
	rgline[cline++].cb = pssib->line.cb - (ULONG) ( pbData - pbNode );
	Assert( cline <= 6 );
	Assert( PgnoOfPn(pssib->pbf->pn) == psplit->pgnoSplit );
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	/*	set the links
	/**/
	ThreeBytesFromL( tbNew2, PnOfDbidPgno( pfucbNew2->dbid, pfucbNew2->pcsr->pgno ) );
	ThreeBytesFromL( tbNew3, PnOfDbidPgno( pfucbNew3->dbid, pfucbNew3->pcsr->pgno ) );
	pssibNew2->pbf->ppage->pghdr.pgnoNext = tbNew3;
	pssibNew3->pbf->ppage->pghdr.pgnoPrev = tbNew2;

	CallS( ErrBTSetIntermediatePage( pfucbNew, psplit, rgb ) );
	return JET_errSuccess;
	}


/*  Move Nodes for Horizontal split.
/*  This function only touches the split page and new page.
/**/
ERR ErrBTSplitHMoveNodes(
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	SPLIT	*psplit,
	BYTE	*rgb,
	BOOL	fNoMove)
	{
	ERR			err;
	SSIB		*pssib  = &pfucb->ssib;
	SSIB		*pssibNew  = &pfucbNew->ssib;
	LINE		rgline[2];
	INT 		cline;
	INT 		cbSon;
	INT 		ibSon;
	BYTE		*pbSon;
	BYTE		*pbNode;
	BOOL		fLeftSplit = (psplit->splitt == splittLeft);
	BOOL		fVisibleSons;

	/*	check if sons of split page are visible
	/*	move sons
	/*	update new FOP
	/*	update split FOP
	/*	correct page links
	/**/

	CallR( ErrSTWriteAccessPage( pfucb, psplit->pgnoSplit ) );

	/*	check if sons of split page are visible
	/*	cache split page son table
	/**/
	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );

	fVisibleSons = FNDVisibleSons( *pssib->line.pb );
	if ( !fNoMove )
		{
		/* do not change anything before real move
		/**/
		psplit->fLeaf |= fVisibleSons;
		}

	AssertBTFOP( pssib );
	pbSon = PbNDSon( pssib->line.pb );
	cbSon = CbNDSon( pssib->line.pb );
	Assert( cbSon < cbSonMax );
	psplit->rgbSonSplit[0] = (BYTE)cbSon;
	for ( ibSon = 0; ibSon < cbSon; ibSon++ )
		psplit->rgbSonSplit[ibSon + 1] = pbSon[ibSon];

 	AssertBFDirty( pssib->pbf );

	/*	move sons
	/**/
	CallR( ErrBTMoveSons( psplit, pfucb, pfucbNew, pssib->itag,
		psplit->rgbSonNew, fVisibleSons, fNoMove ) );

	if ( fNoMove )
		return err;

	/*	update new FOP
	/**/
	pssibNew->itag = itagFOP;
	PMGet( pssibNew, pssibNew->itag );
	cline = 0;
	rgb[0] = *pssibNew->line.pb;
	rgb[1] = 0;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = 2;
	if ( psplit->rgbSonNew[0] > 0 )
		{
		NDSetSon( rgb[0] );
		rgline[cline].pb = psplit->rgbSonNew;
		rgline[cline++].cb = psplit->rgbSonNew[0] + 1;
		}
	else
		{
		Assert( psplit->ibSon == ibSonNull ||
			psplit->ibSon == (INT)psplit->rgbSonSplit[0] );
		Assert( FNDNullSon( rgb[0] ) );
		}

	if ( fVisibleSons )
		NDSetVisibleSons( rgb[0] );
	Assert( pssibNew->itag == 0 );
	Assert(cline <= 2);
	Assert( PgnoOfPn( pssibNew->pbf->pn ) == psplit->pgnoNew );
	//	UNDONE:	remove this bogus code
	pssibNew->fDisableAssert = fTrue;
	CallS( ErrPMReplace( pssibNew, rgline, cline ) );
	//	UNDONE:	remove this bogus code
	pssibNew->fDisableAssert = fFalse;
	AssertBTFOP( pssibNew );

	/*	update split FOP
	/**/
	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );
	AssertBTFOP( pssib );
	pbNode = pssib->line.pb;
	rgb[0] = *pbNode;
	rgb[1] = 0;

	if ( psplit->ibSon != ibSonNull )
		{
		/*	if split all sons out of page, then must reset FOP to have
		/*	no sons.  Split all nodes if left and ibSon == cbSon - 1 or
		/*	if right and ibSon == 0.
		/**/
		if ( ( fLeftSplit && psplit->ibSon == (INT)psplit->rgbSonSplit[0] - 1 ) ||
			( !fLeftSplit && psplit->ibSon == 0 ) )
			{
			NDResetSon( rgb[0] );
			Assert( FNDVisibleSons( rgb[0] ) );
			}
		else
			{
			Assert( FNDSon( rgb[0] ) );
			pbSon = PbNDSon( pbNode );
			Assert( psplit->ibSon < cbSonMax );
			if ( fLeftSplit )
				{
				rgb[2] = psplit->rgbSonSplit[0] - (BYTE)psplit->ibSon - 1;
				memcpy( &rgb[3], pbSon + (BYTE)psplit->ibSon + 1, rgb[2] );
				}
			else
				{
				rgb[2] = (BYTE)psplit->ibSon;
				memcpy( &rgb[3], pbSon, psplit->ibSon );
				}
			}
		rgline[0].pb = rgb;
		if ( fLeftSplit )
			rgline[0].cb = 3 + psplit->rgbSonSplit[0] - psplit->ibSon - 1;
		else
			rgline[0].cb = 3 + psplit->ibSon;
		Assert( PgnoOfPn(pssib->pbf->pn) == psplit->pgnoSplit );
		CallS( ErrPMReplace( pssib, rgline, 1 ) );
		}

#ifdef DEBUG
	CallS( ErrPMGet( pssib, itagFOP ) );
	Assert( FNDNullSon( *pssib->line.pb ) || CbNDSon( pssib->line.pb ) != 0 );
#endif

	return JET_errSuccess;
	}


/*  Assume that pssib and pssibNew is pointing to split page and newpage
/*  respectively.
/**/
ERR ErrBTPrepareCorrectLinks( SPLIT *psplit, FUCB *pfucb, SSIB *pssib, SSIB *pssibNew )
	{
	ERR		err;
	BOOL	fLeftSplit = (psplit->splitt == splittLeft);

	Assert( pssib == &pfucb->ssib );
	if ( fLeftSplit )
		{
		PGNO   		pgnoPrev;

		LFromThreeBytes( pgnoPrev, pssib->pbf->ppage->pghdr.pgnoPrev );
		if ( pgnoPrev != pgnoNull )
			{
			CallR( ErrSTWriteAccessPage( pfucb, pgnoPrev ) );
			psplit->pgnoSibling = pgnoPrev;

			/* lock it till split log rec is generated
			/**/
			if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
				{
				/*	yeild after release split resources
				/**/
				return errDIRNotSynchronous;
				}
			BFPin( pssib->pbf );
			BFSetWriteLatch( pssib->pbf, pssib->ppib );
			Assert( psplit->pbfSibling == pbfNil );
			psplit->pbfSibling = pssib->pbf;
			}
		}
	else
		{
		PGNO   		pgnoNext;

		LFromThreeBytes( pgnoNext, pssib->pbf->ppage->pghdr.pgnoNext );
		if ( pgnoNext != pgnoNull )
			{
			CallR( ErrSTWriteAccessPage( pfucb, pgnoNext ) );
			psplit->pgnoSibling = pgnoNext;
			/* lock it till split log rec is generated
			/**/
			if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
				{
				/*	yeild after release split resources
				/**/
				return errDIRNotSynchronous;
				}
			BFPin( pssib->pbf );
			BFSetWriteLatch( pssib->pbf, pssib->ppib );
			Assert( psplit->pbfSibling == pbfNil );
			psplit->pbfSibling = pssib->pbf;
			}
		}

	return JET_errSuccess;
	}


VOID BTCorrectLinks( SPLIT *psplit, FUCB *pfucb, SSIB *pssib, SSIB *pssibNew )
	{
	BOOL		fLeftSplit = (psplit->splitt == splittLeft);
	THREEBYTES	tbNew;
	THREEBYTES	tbSplit;

	/*	correct page links
	 *		new to split next
	 *		split to new
	 *		split next to new
	 *		new to split
	 */

	Assert( pssib == &pfucb->ssib );

	ThreeBytesFromL( tbNew, PnOfDbidPgno( pfucb->dbid, psplit->pgnoNew ) );
	ThreeBytesFromL( tbSplit, PnOfDbidPgno( pfucb->dbid, psplit->pgnoSplit ) );

	if ( fLeftSplit )
		{
		PGNO   		pgnoPrev = psplit->pgnoSibling;

		pssibNew->pbf->ppage->pghdr.pgnoPrev =
			pssib->pbf->ppage->pghdr.pgnoPrev;
		pssib->pbf->ppage->pghdr.pgnoPrev = tbNew;
		pssibNew->pbf->ppage->pghdr.pgnoNext = tbSplit;

		if ( pgnoPrev != pgnoNull )
			{
			CallS( ErrSTWriteAccessPage( pfucb, pgnoPrev ) );

			pssib->pbf->ppage->pghdr.pgnoNext = tbNew;
			PMDirty( &pfucb->ssib );
			}
		}
	else
		{
		PGNO   		pgnoNext = psplit->pgnoSibling;

		pssibNew->pbf->ppage->pghdr.pgnoNext =
			pssib->pbf->ppage->pghdr.pgnoNext;
		pssib->pbf->ppage->pghdr.pgnoNext = tbNew;
		pssibNew->pbf->ppage->pghdr.pgnoPrev = tbSplit;

		if ( pgnoNext != pgnoNull )
			{
			CallS( ErrSTWriteAccessPage( pfucb, pgnoNext ) );

			pssib->pbf->ppage->pghdr.pgnoPrev = tbNew;
			PMDirty( &pfucb->ssib );
			}
		}
	}


#pragma optimize("g",off)

/*  Make sure parent page has enough space to insert page pointer.
/**/
LOCAL ERR ErrBTPrepareInsertParentPage(
	FUCB	*pfucb,
	CSR		*pcsr,
	CSR		*pcsrRoot,
	CSR		**ppcsrPagePointer,
	SPLIT	*psplit )
	{
	ERR		err;
	CSR		*pcsrPagePointer;
	INT		cbReqFather;
	BOOL  	fAppendPageFather;
	BOOL  	fSplitFather;
	SSIB  	*pssib = &pfucb->ssib;
	BOOL  	fSplitDone = fFalse;
	CSR		*pcsrRevert = pcsrNil;
	INT		ibSonRevert;

	/*	find page pointer CSR.  Note that CSR stack may span multiple nested
	/*	trees on page.  The page pointer must be the first CSR on
	/*	a different page.
	/**/
	for (	pcsrPagePointer = pcsr;
			pcsrPagePointer->pgno == psplit->pgnoNew ||
			pcsrPagePointer->pgno == psplit->pgnoSplit;
			pcsrPagePointer = pcsrPagePointer->pcsrPath );

	*ppcsrPagePointer = pcsrPagePointer;

	CallR( ErrSTReadAccessPage( pfucb, pcsrPagePointer->pgno ) );

	if ( !( psplit->splitt == splittLeft ) )
		{
		/*	prepare to undo ibSon change if errDIRNotSynchronous
		/**/
		pcsrRevert = pcsrPagePointer;
		ibSonRevert = pcsrRevert->ibSon;

		/* correct ibSon to point to the new entry so that split page
		/* will choose the right split spot.
		/**/
		if ( pcsrPagePointer->ibSon == ibSonNull )
			{
			/* father page is an intrinsic pointer, which as 1 son only
			/**/
			pcsrPagePointer->ibSon = 1;
			}
		else
			{
			pcsrPagePointer->ibSon++;
			}
		pcsrPagePointer->csrstat = csrstatBeforeCurNode;
		}

	/*	space needed is most of:
	/*
	/*	case 1 : intrinsic father node
	/*		TAG				sizeof(TAG)
	/*		header			1
	/*		cbKey 			1
	/*		key				JET_cbKeyMost
	/*		pgno			sizeof(PGNO)
	/*		son in father	1
	/*		burst TAG		sizeof(TAG)
	/*		header			1
	/*		cbKey	  		1
	/*		NULL key  		0
	/*		pgno	  		sizeof(PGNO)
	/*		son in father	1
	/**/
	cbReqFather = sizeof(TAG) + 1 + 1 + JET_cbKeyMost + sizeof(PGNO) + sizeof(PGNO ) + 1 +
		sizeof(TAG) + 1 + 1 + sizeof(PGNO) + 1;
	fAppendPageFather = FBTAppendPage( pfucb, pcsrPagePointer, cbReqFather, 0, CbFreeDensity( pfucb ) );

	while( fSplitFather = FBTSplit( pssib, cbReqFather, 2 ) )
		{
		//	UNDONE:	allow specification of a number of tags
		//			to be freed as well as a number of bytes
		//			for bursting of intrisic page pointers
		#if DEBUGGING
			PAGE *ppageT = pssib->pbf->ppage;
		#endif

		fSplitDone = fTrue;

		CallR( ErrBTSplitPage(
			pfucb,
			pcsrPagePointer,
			pcsrRoot,
			psplit->key,
			0, /* no existing node since inserting */			
			cbReqFather,
			0,
			fAppendPageFather,
			&psplit->lfinfo ) );

		#if DEBUGGING
			PageConsistent( ppageT );
		#endif
		}


	if ( !fSplitDone )
		{
		LFINFO	*plfinfo = &psplit->lfinfo;

		/* check if the leave condition is still effective */
		/* before we start the atomic split operation.
		/**/
		CallR( ErrSTWriteAccessPage( pfucb, PgnoOfPn(plfinfo->pn) ) );
		if ( pssib->pbf->ppage->pghdr.ulDBTime != plfinfo->ulDBTime )
			{
			/*	revert ibSon change
			/**/
			if ( pcsrRevert != pcsrNil )
				{
				Assert( ibSonRevert >= 0 && ibSonRevert <= cbSonMax );
				pcsrRevert->ibSon = ibSonRevert;
				}
			return errDIRNotSynchronous;
			}
		}
        return JET_errSuccess;
	}


/*	this function is used by the split. Split has checked that there must
/*  be enough space to insert this new page pointer node.
/*  This function only touches the pointer page.
/**/
ERR ErrBTInsertPagePointer( FUCB *pfucb, CSR *pcsrPagePointer, SPLIT *psplit, BYTE *rgb )
	{
	ERR		err;
	SSIB  	*pssib  = &pfucb->ssib;
	LINE  	rgline[4];
	INT		cline;
	ULONG 	cb;
	BYTE  	bTmp;
	BYTE  	*pbSon;
	BOOL  	fLeftSplit = (psplit->splitt == splittLeft);
	INT		cbSon;
	INT		itagIntrinsic = itagNull;

	/*	burst intrinsic page pointer if exists
	/*	insert new page pointer node with split key
	/*	link into father son table before split page
	/**/
	CallR( ErrSTWriteAccessPage( pfucb, pcsrPagePointer->pgno ) );

	/* lock it till split log rec is generated
	/**/
	if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
		{
		/*	yeild after release split resources
		/**/
		return errDIRNotSynchronous;
		}
	BFPin( pssib->pbf );
	BFSetWriteLatch( pssib->pbf, pssib->ppib );
	Assert( psplit->pbfPagePtr == pbfNil );
	psplit->pbfPagePtr = pssib->pbf;

	/*	burst intrisic page pointer if exists
	/**/
	pssib->itag = pcsrPagePointer->itagFather;
	PMGet( pssib, pssib->itag );
	PMDirty( pssib );

	Assert( FNDInvisibleSons( *pssib->line.pb ) );
	cbSon = CbNDSon( pssib->line.pb );
	if ( pcsrPagePointer->itagFather != itagFOP && cbSon == 1 )
		{
		/*	can not be FOP sine FOP do not have intrinsic sons
		/**/
		Assert( pcsrPagePointer->itagFather != itagFOP );

		/*	if only one son, an intrinsic pointer,
		/*	insert discrete page pointer node.
		/**/
		rgb[0] = 0;
		rgb[1] = 0;
		/* null key
		/**/
		AssertNDIntrinsicSon( pssib->line.pb, pssib->line.cb );
		*(PGNO UNALIGNED *)&rgb[2] = PgnoNDOfPbSon( pssib->line.pb );
		rgline[0].pb = rgb;
		rgline[0].cb = 2 + sizeof(PGNO);
		CallS( ErrPMInsert( pssib, rgline, 1 ) );

		/*	save itag of burst page pointer node for MCM.
		/**/
		itagIntrinsic = pssib->itag;

		/*	remember itag of bursted page pointer node
		/**/
		Assert( pcsrPagePointer->itag == itagNil );
		pcsrPagePointer->itag = pssib->itag;
		bTmp = (BYTE)pssib->itag;

		/*	update father node with son itag of discrete
		/*	page pointer node
		/**/
		pssib->itag = pcsrPagePointer->itagFather;
		PMGet( pssib, pssib->itag );
		memcpy( rgb, pssib->line.pb, pssib->line.cb );
		Assert( FNDSon( rgb[0] ) );

		pbSon = PbNDSon( rgb );
		*pbSon = bTmp;

		memcpy( pbSon + sizeof(BYTE),
			pbSon + sizeof(PGNO),
			pssib->line.cb - (ULONG) (pbSon - rgb) - sizeof(PGNO) );
		rgline[0].pb = rgb;
		rgline[0].cb = pssib->line.cb - sizeof(PGNO) + sizeof(BYTE);
		Assert( PgnoOfPn(pssib->pbf->pn) == pcsrPagePointer->pgno );
		//	UNDONE:	remove this bogus code
		pssib->fDisableAssert = fTrue;
		CallS( ErrPMReplace( pssib, rgline, 1 ) );
		//	UNDONE:	remove this bogus code
		pssib->fDisableAssert = fFalse;
		}

	/*	if there are no sons in this page, then we have been right split
	/*	into an empty page and must insert the page pointer with no key.
	/*	if there are sons and this is a right split, then we must correct
	/*	the current page pointer to have a non-NULL key and insert a new
	/*	page pointer with a NULL key.
	/*	if this is a left split, then we must just insert the new page pointer
	/*	with a key.
	/**/
	if ( cbSon == 0 )
		{
		Assert( pcsrPagePointer->itagFather == itagFOP );

		rgb[0] = 0;
		rgb[1] = 0;
		*(PGNO UNALIGNED *)&rgb[2] = psplit->pgnoNew;
		rgline[0].pb = rgb;
		rgline[0].cb = 2 + sizeof(PGNO);
 		AssertBFDirty( pssib->pbf );
		CallS( ErrPMInsert( pssib, rgline, 1 ) );

		/*	set itagPagePointer in SPLIT structure.
		/**/
		psplit->itagPagePointer = pssib->itag;

		/*	update father node with new page pointer node son
		/**/
		pssib->itag = pcsrPagePointer->itagFather;
		PMGet( pssib, pssib->itag );
		Assert( pssib->line.cb == 2 );
		memcpy( rgb, pssib->line.pb, pssib->line.cb );
		Assert( rgb[1] == 0 );
		Assert( FNDNullSon( rgb[0] ) );
		NDSetSon( rgb[0] );
		rgb[2] = 1;
		rgb[3] = (BYTE)psplit->itagPagePointer;
//		rgb[4] = 0;
//		rgb[5] = 0;
//		rgb[6] = 0;
		rgline[0].pb = rgb;
//		rgline[0].cb = 7;
		rgline[0].cb = 4;
		Assert( PgnoOfPn(pssib->pbf->pn) == pcsrPagePointer->pgno );
		CallS( ErrPMReplace( pssib, rgline, 1 ) );
		AssertBTFOP( pssib );
		}
	else
		{
		/*	insert new page pointer node with split key
		/**/
		if ( fLeftSplit )
			{
			Assert( cbSon != 0 );

			rgb[0] = 0;
			Assert( psplit->key.cb <= JET_cbKeyMost );
			rgb[1] = (BYTE)psplit->key.cb;
			memcpy( &rgb[2], psplit->key.pb, psplit->key.cb );
			*(PGNO UNALIGNED *)&rgb[2 + psplit->key.cb] = psplit->pgnoNew;
			rgline[0].pb = rgb;
			rgline[0].cb = 2 + psplit->key.cb + sizeof(PGNO);
			PMDirty( pssib );
			CallS( ErrPMInsert( pssib, rgline, 1 ) );
			}
		else
			{
			ULONG		cbNode;
			BYTE		*pbData;

			/*	if not left split, then do the followings:
			/*	copy the current page pointer
			/*	replace the current page pointer with split key
			/*	insert a new page pointer node with new key
			/*	insert son into father
			/**/
			Assert( cbSon != 0 );
			pssib->itag = pcsrPagePointer->itag;
			PMGet( pssib, pssib->itag );
			memcpy( rgb, pssib->line.pb, pssib->line.cb );
			Assert( FNDNullSon( rgb[0] ) );
			cbNode = pssib->line.cb;
			pbData = PbNDData( rgb );

			cline = 0;
			rgline[cline].pb = rgb;
			rgline[cline++].cb = 1;
			Assert( !FKeyNull( &psplit->key ) );
			bTmp = (BYTE)psplit->key.cb;
			rgline[cline].pb = &bTmp;
			rgline[cline++].cb = 1;
			rgline[cline].pb = psplit->key.pb;
			rgline[cline++].cb = psplit->key.cb;
			rgline[cline].pb = pbData;
			rgline[cline++].cb = sizeof(PGNO);
			Assert( pssib->itag == pcsrPagePointer->itag );
			Assert( PgnoOfPn(pssib->pbf->pn) == pcsrPagePointer->pgno );
			CallS( ErrPMReplace( pssib, rgline, cline ) );

			/*	replace page pointer to point to new page
			/**/
			Assert( PbNDData( rgb ) == pbData );
			*(PGNO UNALIGNED *)pbData = psplit->pgnoNew;
			cline = 0;
			rgline[cline].pb = rgb;
			rgline[cline++].cb = cbNode;
			CallS( ErrPMInsert( pssib, rgline, cline ) );
			}

		/*	set itagPagePointer in SPLIT structure.
		/**/
		psplit->itagPagePointer = pssib->itag;

		/*	update father node with new page pointer node son
		/**/
		pssib->itag = pcsrPagePointer->itagFather;
		PMGet( pssib, pssib->itag );
		memcpy( rgb, pssib->line.pb, pssib->line.cb );
		Assert( !FNDNullSon( rgb[0] ) );
		pbSon = PbNDSonTable( rgb );

		/*	increase number of sons by one for inserted son
		/**/
		(*pbSon)++;

		/*	move to son insertion point
		/**/
		pbSon += 1 + pcsrPagePointer->ibSon;

		cline = 0;
		rgline[cline].pb = rgb;
		cb = (UINT)(pbSon - rgb);
		rgline[cline++].cb = cb;
		bTmp = (BYTE)psplit->itagPagePointer;
		rgline[cline].pb = &bTmp;
		rgline[cline++].cb = 1;
		rgline[cline].pb = pbSon;
		rgline[cline++].cb = pssib->line.cb - cb;
		Assert( pssib->line.cb >= cb );
		Assert( PgnoOfPn(pssib->pbf->pn) == pcsrPagePointer->pgno );
		CallS( ErrPMReplace( pssib, rgline, cline ) );
		}

	if ( !fRecovering )
		{
		MCMInsertPagePointer( pfucb,
			pcsrPagePointer->pgno,
			pcsrPagePointer->itagFather );
		}

	return JET_errSuccess;
	}


/*	This function is used by Double Vertical split. It sets two page pointer
/*	nodes in the intermediate page.
/**/
ERR ErrBTSetIntermediatePage( FUCB *pfucb, SPLIT *psplit, BYTE *rgb )
	{
	ERR    	err;
	SSIB   	*pssib  = &pfucb->ssib;
	LINE   	rgline[4];
	INT		cline;
	BYTE   	*pbSon;
	BOOL   	fLeftSplit = ( psplit->splitt == splittLeft );
	BYTE   	bItag2;
	BYTE   	bItag3;

	/*	burst intrinsic page pointer if exists
	/*	insert new page pointer node with split key
	/*	link into father son table before split page
	/**/
	CallR( ErrSTWriteAccessPage( pfucb, psplit->pgnoNew ) );
// UNDONE: 	Check the next line pbfPagePtr what for.
// Not for VSplit but for HSplit.
//	psplit->pbfPagePtr = pssib->pbf;

	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );

	Assert( FNDNullSon( *pssib->line.pb ) );

	/*	insert new page pointer nodes with split key.
	/**/
	rgb[0] = 0;
	Assert( psplit->key.cb <= JET_cbKeyMost );
	rgb[1] = (BYTE)psplit->key.cb;
	memcpy( &rgb[2], psplit->key.pb, psplit->key.cb );
	*(PGNO UNALIGNED *)&rgb[2 + psplit->key.cb] = psplit->pgnoNew2;
	rgline[0].pb = rgb;
	rgline[0].cb = 2 + psplit->key.cb + sizeof(PGNO);
	CallS( ErrPMInsert( pssib, rgline, 1 ) );
	Assert( pssib->itag == itagDIRDVSplitL );
	bItag2 = (BYTE) pssib->itag;

	rgb[0] = 0;
	Assert( psplit->key.cb <= JET_cbKeyMost );

	/*	key is null
	/**/
	rgb[1] = 0;
	*(PGNO UNALIGNED *)&rgb[2] = psplit->pgnoNew3;
	rgline[0].pb = rgb;
	rgline[0].cb = 2 + sizeof(PGNO);
	CallS( ErrPMInsert( pssib, rgline, 1 ) );
	Assert( pssib->itag == itagDIRDVSplitR );
	bItag3 = (BYTE) pssib->itag;

	/*	update father node with new page pointer node sons
	/**/
	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );
	memcpy( rgb, pssib->line.pb, pssib->line.cb );

	pbSon = PbNDSonTable( rgb );

	/*	set number of sons to two for inserted PPNs
	/**/
	*pbSon++ = 2;
	NDSetSon( *rgb );

	cline = 0;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = (UINT)(pbSon - rgb);

	rgline[cline].pb = &bItag2;
	rgline[cline++].cb = 1;
	rgline[cline].pb = &bItag3;
	rgline[cline++].cb = 1;

	Assert( PgnoOfPn(pssib->pbf->pn) == psplit->pgnoNew );
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	return JET_errSuccess;
	}


VOID BTReleaseRmpageBfs( BOOL fRedo, RMPAGE *prmpage )
	{
	ULONG	ulDBTime =prmpage->ulDBTimeRedo;
	
	/* release latches
	/**/
	while ( prmpage->cpbf > 0 )
		{
		BF *pbf;
		
		prmpage->cpbf--;
		pbf = *( prmpage->rgpbf + prmpage->cpbf );
		if ( fRedo )
			{
			AssertBFDirty( pbf );
			Assert( pbf->ppage->pghdr.ulDBTime < ulDBTime );
			pbf->ppage->pghdr.ulDBTime = ulDBTime;
			}
		BFResetWaitLatch( pbf, prmpage->ppib );
		BFResetWriteLatch( pbf, prmpage->ppib );
		BFUnpin( pbf );
		}

	if ( prmpage->rgpbf )
		{
		SFree( prmpage->rgpbf );
		}

	Assert( prmpage->cpbf == 0 );
	return;
	}


/*	release split resources
/**/
VOID BTReleaseSplitBfs( BOOL fRedo, SPLIT *psplit, ERR err )
	{
	ULONG	ulDBTime = psplit->ulDBTimeRedo;

	if ( psplit->pbfNew )
		{
		if ( err < 0 )
			{
//			Assert( psplit->pbfNew->pbfDepend == psplit->pbfSplit );
			if ( psplit->pbfNew->pbfDepend != pbfNil )
				BFUndepend( psplit->pbfNew );
			}
			
		if ( fRedo )
			{
			AssertBFDirty( psplit->pbfNew );
			Assert( psplit->pbfNew->ppage->pghdr.ulDBTime < ulDBTime );
			psplit->pbfNew->ppage->pghdr.ulDBTime = ulDBTime;
			}

		/* in recovery, if we did not have to redo the new page because the
		 * new page is more up to date, but we still do new page and redo
		 * the split. At the end of split, we simply abandon the changes
		 * that we made on the buffer since we know that the page on disk
		 * is more up to date than the split.
		 */
		if ( psplit->fNoRedoNew )
			{
			Assert( fRedo );
			/* abandon the buffer while in critJet */
			if ( psplit->pbfNew->pbfDepend != pbfNil )
				BFUndepend( psplit->pbfNew );
			
			psplit->pbfNew->fDirty = fFalse;
			BFAbandon( psplit->ppib, psplit->pbfNew );
			}

		BFResetWriteLatch( psplit->pbfNew, psplit->ppib );
		BFUnpin( psplit->pbfNew );
		}

	if ( psplit->pbfNew2 )
		{
		Assert ( psplit->pbfNew3 );

		if ( err < 0 )
			{
//			Assert( psplit->pbfNew2->pbfDepend == psplit->pbfSplit );
			if ( psplit->pbfNew2->pbfDepend != pbfNil )
				BFUndepend( psplit->pbfNew2 );
			if ( psplit->pbfNew3->pbfDepend != pbfNil )
				BFUndepend( psplit->pbfNew3 );
			}

		if ( fRedo )
			{
			AssertBFDirty( psplit->pbfNew2 );
			AssertBFDirty( psplit->pbfNew3 );
			Assert( psplit->pbfNew2->ppage->pghdr.ulDBTime < ulDBTime );
			Assert( psplit->pbfNew3->ppage->pghdr.ulDBTime < ulDBTime );
			
			psplit->pbfNew2->ppage->pghdr.ulDBTime = ulDBTime;
			psplit->pbfNew3->ppage->pghdr.ulDBTime = ulDBTime;
			}

		if ( psplit->fNoRedoNew2 )
			{
			Assert( fRedo );
			/* abandon the buffer while in critJet
			/**/
			if ( psplit->pbfNew2->pbfDepend != pbfNil )
				BFUndepend( psplit->pbfNew2 );
			
			psplit->pbfNew2->fDirty = fFalse;
			BFAbandon( psplit->ppib, psplit->pbfNew2 );
			}
		BFResetWriteLatch( psplit->pbfNew2, psplit->ppib );
		BFUnpin( psplit->pbfNew2 );

		if ( psplit->fNoRedoNew3 )
			{
			Assert( fRedo );
			/* abandon the buffer while in critJet
			/**/
			if ( psplit->pbfNew3->pbfDepend != pbfNil )
				BFUndepend( psplit->pbfNew3 );
			
			psplit->pbfNew3->fDirty = fFalse;
			BFAbandon( psplit->ppib, psplit->pbfNew3 );
			}
		BFResetWriteLatch( psplit->pbfNew3, psplit->ppib );
		BFUnpin( psplit->pbfNew3 );
		}

	if ( psplit->pbfSibling )
		{
		if ( fRedo )
			{
			AssertBFDirty( psplit->pbfSibling );
			Assert( psplit->pbfSibling->ppage->pghdr.ulDBTime < ulDBTime );
			psplit->pbfSibling->ppage->pghdr.ulDBTime = ulDBTime;
			}

		BFResetWriteLatch( psplit->pbfSibling, psplit->ppib );
		BFUnpin( psplit->pbfSibling );
		}

	if ( psplit->pbfPagePtr )
		{
		if ( fRedo )
			{
			AssertBFDirty( psplit->pbfPagePtr );
			Assert( psplit->pbfPagePtr->ppage->pghdr.ulDBTime < ulDBTime );

			psplit->pbfPagePtr->ppage->pghdr.ulDBTime = ulDBTime;
			}
		BFResetWriteLatch( psplit->pbfPagePtr, psplit->ppib );
		BFUnpin( psplit->pbfPagePtr );
		}

	if ( psplit->cpbf )
		{
		BF	**ppbf = psplit->rgpbf;
		BF	**ppbfMax = ppbf + psplit->cpbf;

		for (; ppbf < ppbfMax; ppbf++)
			{
			if ( fRedo )
				{
				AssertBFDirty( *ppbf );
//				Assert( (*ppbf)->ppage->pghdr.ulDBTime < ulDBTime );

				(*ppbf)->ppage->pghdr.ulDBTime = ulDBTime;
				}

			BFResetWriteLatch( *ppbf, psplit->ppib );
			BFUnpin( *ppbf );
			}
		//	UNDONE:	use rgpbf
		if ( psplit->rgpbf )
			SFree( psplit->rgpbf );
		}
		
	if ( psplit->rgbklnk != NULL )
		{
		SFree( psplit->rgbklnk );
		psplit->rgbklnk = NULL;
		}

	/* when redo an append, we always redo it even ulDBTime
	/* of the split page is greater than ulDBTime of split
	/* log record. In this case, we do not want to change
	/* the ulDBTime of the page. So we can not rely on the buffer
	/* dependency to assume that when a split is redo, all the dependent
	/* buffer must have smaller ulDBTime.
	/**/
	if ( psplit->pbfSplit )
		{
		if ( fRedo )
			{
			AssertBFDirty( psplit->pbfSplit );
			/*	ulDBTime may have been set equal to ulDBTime by above
			/*	link page ulDBTime correction, during page merge.
			/**/
			Assert( psplit->pbfSplit->ppage->pghdr.ulDBTime <= ulDBTime );
			
			psplit->pbfSplit->ppage->pghdr.ulDBTime = ulDBTime;
			}

		BFResetWriteLatch( psplit->pbfSplit, psplit->ppib );
		BFUnpin( psplit->pbfSplit );
		}
	}


//+private----------------------------------------------------------------------
//
//	ErrBTSplitPage
//	============================================================================
//
//	ERR ErrBTSplitPage(
//		FUCB			*pfucb,
//		CSR				*pcsr,
//		CSR				*pcsrRoot,
//		KEY				keySplit,
//		INT				cbNode,
//		INT				cbReq,
//		INT				fDIRFlags,
//		BOOL			fAppendPage )
//
//		pfucb			cursor
//		pcsr			location of insert or replace
//		pcsrRoot		root of tree, i.e. <record data root>
//		pssib			cursor ssib
//		keySplit		key of insert or replace node
//		cbReq			required cb
//		fReplace		fDIRReplace bit set if operation is replace
//		fAppendPage		insert at end
//
//------------------------------------------------------------------------------
ERR ErrBTSplitPage(
	FUCB		*pfucb,
	CSR  		*pcsr,
	CSR  		*pcsrRoot,
	KEY  		keySplit,
	INT			cbNode,
	INT 		cbReq,
	BOOL		fDIRFlags,
	BOOL		fAppendPage,
	LFINFO		*plfinfo )
	{
	ERR	  		err = JET_errSuccess;
	SPLIT		*psplit = NULL;

	FUCB		*pfucbNew = pfucbNil;
	FUCB		*pfucbNew2 = pfucbNil;
	FUCB		*pfucbNew3 = pfucbNil;
	SSIB		*pssib = &pfucb->ssib;

	SSIB 		*pssibNew;
	SSIB 		*pssibNew2;
	SSIB 		*pssibNew3;
	BOOL		fAppend = fFalse;

//	BF			*pbf = NULL;
//	BYTE		*rgb;
//	UNDONE:	fix this
	static		BYTE rgb[cbPage];

	PGTYP		pgtyp;

	PIB			*ppib = pfucb->ppib;
	BOOL		fPIBLogDisabledSave = ppib->fLogDisabled;
	SPLITT	 	splittOrig = splittNull;

	BOOL		fSplit = fFalse;
	INT	 		ipcsrMac;
	INT	 		ipcsr;

	Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
	Assert( cbReq > 0 );
	if ( cbReq > cbNodeMost )
		return JET_errRecordTooBig;

	/*	enter split critical section
	/**/
	/*	check page key order
	/**/
	BTCheckSplit( pfucb, pcsr->pcsrPath );

	/******************************************************
	/*	initialize local variables and allocate split resources
	/**/
	psplit = SAlloc( sizeof(SPLIT) );
	if ( psplit == NULL )
		{
		err = JET_errOutOfMemory;
		return err;
		}
	memset( (BYTE *)psplit, 0, sizeof(SPLIT) );
	memcpy( &psplit->lfinfo, plfinfo, sizeof(LFINFO));
	psplit->ppib = pfucb->ppib;

	if ( fDIRFlags & fDIRReplace )
		psplit->op = opReplace;
	else
		psplit->op = opInsert;

	psplit->dbid = pfucb->dbid;
	psplit->pgnoSplit = pcsr->pgno;

	/* no logging for this particular function
	/**/
	ppib->fLogDisabled = fTrue;
	err = ErrBTSelectSplit( pfucb, pcsr, pssib, keySplit, cbNode, cbReq,
		fAppendPage, fDIRFlags, psplit, &fAppend );
	ppib->fLogDisabled = fPIBLogDisabledSave;
	Call( err );

	/* if appending then attempt to get next page in contiguous order
	/**/
	Assert( psplit->pgnoNew == pgnoNull );
	if ( fAppendPage )
		psplit->pgnoNew = pcsr->pgno;
	err = ErrSPGetPage( pfucb, &psplit->pgnoNew, fAppendPage );
	if ( err < 0 )
		{
		psplit->pgnoNew = pgnoNull;
		goto HandleError;
		}
	Assert( psplit->pgnoNew != pcsr->pgno );

	if ( psplit->splitt == splittDoubleVertical )
		{
		/*	preallocate pages for double vertical split. Release them if
		/*	it is not a double vertical split.
		/**/
		Assert( psplit->pgnoNew2 == pgnoNull );
		Call( ErrSPGetPage( pfucb, &psplit->pgnoNew2, fAppendPage ) );
		Assert( psplit->pgnoNew2 != psplit->pgnoNew &&
			psplit->pgnoNew2 != psplit->pgnoSplit );

		Assert( psplit->pgnoNew3 == pgnoNull );
		Call( ErrSPGetPage( pfucb, &psplit->pgnoNew3, fAppendPage ) );
		Assert( psplit->pgnoNew3 != psplit->pgnoNew2 &&
			psplit->pgnoNew3 != psplit->pgnoNew &&
			psplit->pgnoNew3 != psplit->pgnoSplit );
		}

	ppib->fLogDisabled = fTrue;

	/*	space management may have caused indirect recursion of
	/*	split an already split this page.  Check if split of this
	/*	page still required.  Must adjust cbReq for artificial space
	/*	savings as a result of get page deleting a space extent.  Free
	/*	extent would consume same space.
	/**/
	if ( !( FReadAccessPage( pfucb, pcsr->pgno ) ) )
		{
		Call( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
		}

	if ( !( ( ( fDIRFlags & fDIRReplace ) ? 0 :
		FBTAppendPage( pfucb, pcsr, cbReq, cbSPExt, CbFreeDensity( pfucb ) ) ) ||
		FBTSplit( pssib, cbReq + cbSPExt, 2 ) ) )
		{
		/*	release page and done
		/**/
		ppib->fLogDisabled = fPIBLogDisabledSave;

		Call( ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew, 1 ) );
		psplit->pgnoNew = pgnoNull;
		
		if ( psplit->splitt == splittDoubleVertical )
			{
			Call( ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew2, 1 ) );
			psplit->pgnoNew2 = pgnoNull;
			Call( ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew3, 1 ) );
			psplit->pgnoNew3 = pgnoNull;
			}

		ppib->fLogDisabled = fTrue;

		Assert( !( ( fDIRFlags & fDIRReplace ) ? 0 : FBTAppendPage( pfucb, pcsr, cbReq, cbSPExt, CbFreeDensity(pfucb) ) ) ||
			FBTSplit( pssib, cbReq + cbSPExt, 1 ) );
		goto HandleError;
		}

//	/*	allocate buffer for rgb
//	/**/
//	Call( ErrBFAllocTempBuffer( &pbf ) );
//	rgb = (BYTE *)pbf->ppage;

	/******************************************************
	/*	select split again. psplit may be changed by space manager.
	/**/
	splittOrig = psplit->splitt;
	Call( ErrBTSelectSplit( pfucb, pcsr, pssib, keySplit, cbNode, cbReq,
		fAppendPage, fDIRFlags, psplit, &fAppend ) );

	if ( psplit->splitt != splittOrig )
		{
		/* return to caller and retry
		/**/
		goto HandleError;
		}

	/*	store intial state of FUCB for restoration after split node
	/*	movement and before split MCM.  Note, that we can cache CSR
	/*	only because we are inside critSplit and bookmark clean up
	/*	is prevented.
	/*
	/*	Be careful to cache CSR after space management requests, since
	/*	they may cause CSR to change via MCM.
	/**/
	fSplit = fTrue;

	/*	access new page with pgtyp and pgnoFDP
	/**/
	if ( ( psplit->splitt == splittVertical ||
		psplit->splitt == splittDoubleVertical ) &&
		psplit->pgnoSplit == pfucb->u.pfcb->pgnoRoot &&
		psplit->itagSplit == pfucb->u.pfcb->itagRoot )
		{
		pgtyp = pgtypRecord;
		}
	else
		{
		pgtyp = PgtypPMPageTypeOfPage( pssib->pbf->ppage );
		}

	Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew ) );
	pssibNew = &pfucbNew->ssib;
	SetupSSIB( pssibNew, pfucb->ppib );
	SSIBSetDbid( pssibNew, pfucb->dbid );

	if ( psplit->splitt == splittDoubleVertical )
		{
		/*	allocate additional cursor
		/**/
		Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew2 ) );
		pssibNew2 = &pfucbNew2->ssib;
		SetupSSIB( pssibNew2, pfucb->ppib );
		SSIBSetDbid( pssibNew2, pfucb->dbid );

		Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew3 ) );
		pssibNew3 = &pfucbNew3->ssib;
		SetupSSIB( pssibNew3, pfucb->ppib );
		SSIBSetDbid( pssibNew3, pfucb->dbid );
		}

	/*  Access new page, and set it up. Then latch the new page.
	/*  Also set up the buffer dependency between the two pages.
	/**/
	Call( ErrBTSetUpSplitPages( pfucb, pfucbNew, pfucbNew2, pfucbNew3, psplit, pgtyp, fAppend, fFalse ) );

	//	Set split page dirty.
	//	Other page need not, as BTSetUpSplitPages -->
	//	NDInitPage would set buffer dirty.

	// use set dirty bit to preserve pbf's ulDBTime such that
	// lfinfo set in SetUpSplitPages will be preserved.
	BFSetDirtyBit( pfucb->ssib.pbf );
//	PMDirty( &pfucb->ssib );
	PMDirty( &pfucbNew->ssib );

	/* preallocate CSR resources
	/**/
	if ( psplit->splitt == splittVertical )
		ipcsrMac = 2;
	else if ( psplit->splitt == splittDoubleVertical )
		ipcsrMac = 4;
	else
		ipcsrMac = 0;

	Assert ( psplit->ipcsrMac == 0 );
	if ( ipcsrMac )
		{
		for ( ipcsr = 0; ipcsr < ipcsrMac; ipcsr++ )
			{
			Call( ErrFUCBAllocCSR( &psplit->rgpcsr[ipcsr] ) );
			psplit->ipcsrMac++;
			}
		}

	/******************************************************
	/*	perform split
	/**/

	/* set BFDirty again for those buffers that can be accessed during
	/* preparing split. This is necessary because while some pcsr is move
	/* to those pages and set ulDBTime after we PMDirty the page (e.g. we
	/* PMDirty split page then prepare insert parent page which may let
	/* other csr landing on the page and set time stamp as split time stamp.
	/* then we move the nodes and compelete split. But the node whose csr
	/* pointing to a moved node will have same ulDBTime as the split timestamp
	/* and can not detect the page is changed. So all the buffers with nodes
	/* moved in split should be increment the ulDBTime again.
	/**/

	switch ( psplit->splitt )
		{
		case splittVertical:
			{
			/*	set new page type and pgnoFDP
			/*	cache split node son table
			/*	move sons
			/*	update split node
			/*	insert page pointer in split page to new page
			/*	vertical split MCM
			/**/
			Call( ErrBTSplitVMoveNodes( pfucb, pfucbNew, psplit, pcsr, rgb, fAllocBufOnly ) );

			HoldCriticalSection( critJet );
			err = ErrBTSplitVMoveNodes( pfucb, pfucbNew, psplit, pcsr, rgb, fDoMove );
			ReleaseCriticalSection( critJet );
			Call( err );

			/*	vertical split MCM
			/**/
//			BTIRestoreItag( pfucb, &csrSav );
			MCMVerticalPageSplit( pfucb,
				(BYTE *)(psplit->mpitag),
				psplit->pgnoSplit,
				psplit->itagSplit,
				psplit->pgnoNew,
				psplit );

			ppib->fLogDisabled = fPIBLogDisabledSave;

			BFDirty( psplit->pbfSplit );

			Call( ErrLGSplit( splittVertical, pfucb, pcsrNil, psplit, pgtyp ) );
			break;
			}

		case splittDoubleVertical:
			{
			/*	set new page type and pgnoFDP
			/*	cache split node son table
			/*	move sons
			/*	update split node
			/*	insert page pointer in split page to new page
			/*	vertical split MCM
			/**/
			PMDirty( &pfucbNew2->ssib );
			PMDirty( &pfucbNew3->ssib );

			Call( ErrBTSplitDoubleVMoveNodes(
				pfucb, pfucbNew, pfucbNew2, pfucbNew3,
				psplit, pcsr, rgb, fAllocBufOnly ) );

			HoldCriticalSection( critJet );
			err = ErrBTSplitDoubleVMoveNodes(
				pfucb, pfucbNew, pfucbNew2, pfucbNew3,
				psplit, pcsr, rgb, fDoMove );
			ReleaseCriticalSection( critJet );
			Call( err );

			/*	vertical split MCM
			/**/
//			BTIRestoreItag( pfucb, &csrSav );
			MCMDoubleVerticalPageSplit( pfucb,
				(BYTE *)psplit->mpitag,
				psplit->pgnoSplit,
				psplit->itagSplit,
				psplit->ibSon,
				psplit->pgnoNew,
				psplit->pgnoNew2,
				psplit->pgnoNew3,
				psplit );

			ppib->fLogDisabled = fPIBLogDisabledSave;

			BFDirty( psplit->pbfSplit );

			Call( ErrLGSplit( splittDoubleVertical, pfucb, pcsrNil, psplit, pgtyp ) );
			break;
			}

		default:
			{
			CSR		csrPagePointerSave;
			CSR		*pcsrPagePointer;
			BOOL	fSplitLeft;

			if ( psplit->splitt == splittLeft )
				{
				fSplitLeft = fTrue;
				}
			else
				{
				Assert( psplit->splitt == splittRight ||
	  				psplit->splitt == splittAppend );
				fSplitLeft = fFalse;
				}

			/*	check if sons of split page are visible
			/*	move sons
			/*	update new FOP
			/*	update split FOP
			/*	correct page links
			/**/

			/*  allocate buffers that will be used in adjusting back links.
			/*  Do not do the realy move yet.
			/**/
			Call( ErrBTSplitHMoveNodes( pfucb, pfucbNew, psplit, rgb, fAllocBufOnly));

			Call( ErrBTPrepareCorrectLinks( psplit, pfucb, pssib, pssibNew ) );

			/*	add new page pointer node to parent page
			/*		set pcsrPagePointer to first CSR above
			/*	   	FOP CSR
			/*		split parent page is not enough space/tags
			/*		add page pointer node
			/*		add son to parent node
			/**/
			ppib->fLogDisabled = fPIBLogDisabledSave;
			Call( ErrBTPrepareInsertParentPage(
				pfucb,
				pcsr,
				pcsrRoot,
				&pcsrPagePointer,
				psplit ) );
			ppib->fLogDisabled = fTrue;

			/*  do the real move here.
			/**/
			HoldCriticalSection( critJet );
			CallS( ErrBTSplitHMoveNodes( pfucb, pfucbNew, psplit, rgb, fDoMove));
			ReleaseCriticalSection( critJet );

			Assert( pssib == &pfucb->ssib );
			Assert( pssibNew == &pfucbNew->ssib );
			BTCorrectLinks( psplit, pfucb, pssib, pssibNew );

			/*	left split MCM
			/**/
//			BTIRestoreItag( pfucb, &csrSav );
			if ( fSplitLeft )
				{
				MCMLeftHorizontalPageSplit(
					pfucb,
					psplit->pgnoSplit,
					psplit->pgnoNew,
					psplit->ibSon,
					(BYTE *)psplit->mpitag );
				}
			else
				{
				MCMRightHorizontalPageSplit(
					pfucb,
					psplit->pgnoSplit,
					psplit->pgnoNew,
					psplit->ibSon,
					(BYTE *)psplit->mpitag );
				}

			/*	at this point there is sufficient space/tags in the father
			/*	page to allow the page pointer node to be inserted since
			/*  there can be only one split occurs.
			/**/

			/*   pcsrPagePointer's itag may be bursted, save it.
			/**/
			csrPagePointerSave = *pcsrPagePointer;
			Call( ErrBTInsertPagePointer( pfucb, pcsrPagePointer, psplit, rgb));

			/*	check page key order
			/**/
			BTCheckSplit( pfucb, pcsrPagePointer );

			/*	log operation.  If append, then no need for dependency.
			/**/
			ppib->fLogDisabled = fPIBLogDisabledSave;

			BFDirty( psplit->pbfSplit );

			if ( fSplitLeft )
				{
				Call( ErrLGSplit( splittLeft, pfucb, &csrPagePointerSave, psplit, pgtyp) );
				}
			else
				{
				Assert( psplit->splitt == splittRight ||
					psplit->splitt == splittAppend );
				Call( ErrLGSplit( psplit->splitt,
					pfucb,
					&csrPagePointerSave,
					psplit,
					pgtyp ) );
				}
			break;
			}
		}

	/*	setup physical currency for output
	/**/
	if ( !( FReadAccessPage( pfucb, pcsr->pgno ) ) )
		{
		Call( ErrSTWriteAccessPage( pfucb, pcsr->pgno ) );
		}

	/*	check page key order
	/**/
	BTCheckSplit( pfucb, pcsr->pcsrPath );

	if ( fRecovering )
		{
		goto EndOfMPLRegister;
		}

	if ( psplit->fLeaf )
		{
		if ( psplit->splitt == splittDoubleVertical )
			{
			MPLRegister( pfucbNew2->u.pfcb,
				pssibNew2,
				PnOfDbidPgno( pfucbNew2->dbid, psplit->pgnoNew2 ),
				pfucbNew2->sridFather );
			MPLRegister( pfucbNew3->u.pfcb,
				pssibNew3,
				PnOfDbidPgno( pfucbNew3->dbid, psplit->pgnoNew3 ),
				pfucbNew3->sridFather );
			}
		else
			{
			if ( !fAppend )
				{
				MPLRegister( pfucbNew->u.pfcb,
					pssibNew,
					PnOfDbidPgno( pfucbNew->dbid, psplit->pgnoNew ),
					pfucbNew->sridFather );
				}
			pfucb->u.pfcb->olcStat.cDiscont +=
				pgdiscont( psplit->pgnoNew, psplit->pgnoSplit )
				+ pgdiscont( psplit->pgnoNew, psplit->pgnoSibling )
				- pgdiscont( psplit->pgnoSplit, psplit->pgnoSibling );
			}
		}

EndOfMPLRegister:

HandleError:
	#ifdef SPLIT_TRACE
		PrintF2( "Split............................... %d\n", iSplit++);
		switch ( psplit->splitt )
			{
			case splittNull:
				PrintF2( "split split type = null\n" );
				break;
			case splittVertical:
				PrintF2( "split split type = vertical\n" );
				break;
			case splittRight:
				if	( fAppend )
					PrintF2( "split split type = Append\n" );
				else
					PrintF2( "split split type = right\n" );
				break;
			case splittLeft:
				PrintF2( "split split type = left\n" );
			};
		PrintF2( "split page = %lu\n", psplit->pgnoSplit );
		PrintF2( "dbid = %u\n", psplit->dbid );
		PrintF2( "fFDP = %d\n", psplit->fFDP );
		PrintF2( "fLeaf = %d\n", psplit->fLeaf );
		PrintF2( "split itag = %d\n", psplit->itagSplit );
		PrintF2( "split ibSon = %d\n", psplit->ibSon );
		PrintF2( "new page = %lu\n", psplit->pgnoNew );
		PrintF2( "\n" );
	#endif

	/*	release split resources
	/**/
	ppib->fLogDisabled = fPIBLogDisabledSave;

	if ( splittOrig != psplit->splitt && splittOrig == splittDoubleVertical )
		{
		(VOID)ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew2, 1 );
		psplit->pgnoNew2 = pgnoNull;
		(VOID)ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew3, 1 );
		psplit->pgnoNew3 = pgnoNull;
		}

	if ( err < 0 )
		{
		if ( psplit->pgnoNew != pgnoNull )
			{
			(VOID)ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew, 1 );
			}
		
		if ( psplit->pgnoNew2 != pgnoNull )
			{
			(VOID)ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew2, 1 );
			}
		if ( psplit->pgnoNew3 != pgnoNull )
			{
			(VOID)ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew3, 1 );
			}
		}
		
	ppib->fLogDisabled = fTrue;

	//	UNDONE:	this is a hack to fix empty page
	//			unknown key space bug
	/*	if split 0 nodes to new page, i.e. empty page, then
	/*	flag FUCB as owning empty page for its next insert.
	/*	Note if FUCB is already owner of empty page then this
	/*	must not be leaf page, so do not make FUCB owner.
	/**/
	if ( err >= 0 &&
		psplit->rgbSonNew[0] == 0 &&
		psplit->fLeaf &&
		pfucb->pbfEmpty == pbfNil &&
		psplit->pbfNew != pbfNil )
		{
#ifdef DEBUG
		cbfEmpty++;
#endif
		Assert( ( fDIRFlags & fDIRReplace ) == 0 );
		pfucb->pbfEmpty = psplit->pbfNew;
		BFPin( pfucb->pbfEmpty );
		BFSetWriteLatch( pfucb->pbfEmpty, pfucb->ppib );
		}

	Assert( psplit != NULL );
	BTReleaseSplitBfs( fFalse, psplit, err );

	if ( pfucbNew != pfucbNil )
		DIRClose( pfucbNew );
	if ( pfucbNew2 != pfucbNil )
		DIRClose( pfucbNew2 );
	if ( pfucbNew3 != pfucbNil )
		DIRClose( pfucbNew3 );

	/* release the left unused CSR
	/**/
	for ( ipcsr = 0; ipcsr < psplit->ipcsrMac; ipcsr++ )
		{
		MEMReleasePcsr( psplit->rgpcsr[ipcsr] );
		}

	SFree( psplit );

	ppib->fLogDisabled = fPIBLogDisabledSave;

	Assert( err != errDIRCannotSplit );
	return err;
	}


//+private--------------------------------------------------------------------
//
//	ErrBTSelectSplit
//	==========================================================================
//
//	LOCAL ERR ErrBTSelectSplit( FUCB *pfucb, CSR *pcsr, SSIB *pssib,
//		KEY key, INT cbReq, BOOL fAppendPage, BOOL fDIRFlags, SPLIT *psplit, BOOL *pfAppend )
//
//	PARAMETERS
//
//	pfucb  		pointer to fucb of split requester, split along CSR stack
//	pcsr   		pointer to node below split location, i.e. pointer to node
//		   		being enlarged causing split.  Siblings of pcsr are moved.
//	key			key of node enlarged or inserted causing split
//	splitinfo 	split information output
//----------------------------------------------------------------------------

	LOCAL ERR
ErrBTSelectSplit(
	FUCB	*pfucb,
	CSR  	*pcsr,
	SSIB	*pssib,
	KEY  	key,
	INT  	cbNode,
	INT  	cbReq,
	BOOL	fAppendPage,
	BOOL	fDIRFlags,
	SPLIT	*psplit,
	BOOL	*pfAppend )
	{
	BOOL	fFreeTag = FPMFreeTag( pssib, 1 );
	INT  	cbFreeSpace = CbPMFreeSpace( pssib );
	BOOL	fFatherHasSons;

	Assert( psplit->op == opInsert || psplit->op == opReplace );

	/*	initialize variables
	/**/
	psplit->splitt = splittNull;
	psplit->key.pb = pbNil;
	psplit->key.cb = 0;
	psplit->itagSplit = 0;
	psplit->ibSon = 0;
	psplit->fLeaf = fFalse;

	/*	determine if split page is FDP.  Space management pfucbs
	/*	do not have pfcbs set.
	/**/
	psplit->fFDP = ( pcsr->pgno == pfucb->u.pfcb->pgnoFDP ||
		pcsr->csrstat == csrstatOnFDPNode );

	/*	get father node
	/**/
	NDGet( pfucb, pcsr->itagFather );

	fFatherHasSons = FNDSon( *(pfucb->ssib.line.pb) );

//	UNDONE:
//		this code is a patch to handle the case where the only V split
//		is of an empty tree above the insert.  However, this patch
//		will split the DATA node which is currently fixed, so it disable
//		for FDPs except where father is Ownext, Availext or DATA.  Fix this
//		patch by making DATA node movable.

//	UNDONE:	must esitmate size of parent and parent sibling nodes to infer
//			limits of H-split and V-split when H-split cannot free space
//			required by node and requirement.

	if ( pcsr->itagFather != itagFOP &&
		( fFatherHasSons || ( cbFreeSpace > cbFirstPagePointer ) ) &&
		( pcsr->pgno != pfucb->u.pfcb->pgnoFDP ||
			pcsr->pgno == pgnoSystemRoot ||
 			pcsr->itagFather == itagOWNEXT ||
			pcsr->itagFather == itagAVAILEXT ||
			pcsr->itagFather == itagLONG ||
			pcsr->itagFather == itagFIELDS ||
			pcsr->itagFather == pfucb->u.pfcb->itagRoot ||
			( pcsr->itagFather != itagFOP && ( cbNode + cbReq ) > ( cbPage / 4 ) ) ) )
		{
SplitFather:
		Assert( FNDIntrinsicSons( pfucb->ssib.line.pb ) ||
			fFatherHasSons ||
			cbFreeSpace > cbFirstPagePointer );
		psplit->itagSplit = pcsr->itagFather;
		psplit->splitt = splittVertical;

		/*	above split selection should not select ancestor of DATA.
		/**/
		Assert( ( pcsr->pgno == pfucb->u.pfcb->pgnoRoot &&
			pcsr->itagFather == pfucb->u.pfcb->itagRoot ) ||
			FBTVSplit( pfucb, pcsr->itagFather, cbReq, fTrue ) );

		/*	if space required is greater than page, then
		/*	double vertical split.  Call FBTVSplit to get weight.
		/**/
	 	(VOID) FBTVSplit( pfucb, pcsr->itagFather, cbReq, fTrue );
		if ( cbVSplit > cbAvailMost )
			{
			INT		ibSon = pcsr->ibSon;
			KEY		keyT;

			Assert( clineVSplit > 1 );

			/*	check division point
			/**/
			keyT = key;
			BTDoubleVSplit( pfucb, psplit->itagSplit, cbReq, cbVSplit, &ibSon, &keyT );

			psplit->splitt = splittDoubleVertical;
			Assert( psplit->itagSplit == pcsr->itagFather );
			psplit->ibSon = ibSon;
			psplit->key.cb = keyT.cb;
			psplit->key.pb = psplit->rgbKey;
			memcpy( psplit->rgbKey, keyT.pb, keyT.cb );
			}
		}
	else
		{
		/*	try any split in page
		/**/
		FBTVSplit( pfucb, itagFOP, cbReq, fFalse );

		/*	if pssib->itag is root or benefit of vertical split is
		/*	zero, no benefit from veritcal split.
		/*	Since FDP cannot be horizontally split, if fFDP
		/*	cannot split this page.
		/**/
		if ( itagVSplit != itagFOP && ( cbVSplit > cbVSplitMin || psplit->fFDP && cbVSplit != 0 ) )
			{
			/*	vertical split
			/**/
			if ( cbVSplit > cbAvailMost )
				{
				INT		ibSon = pcsr->ibSon;
				KEY		keyT;

				Assert( clineVSplit > 1 );

				/*	check division point
				/**/
				keyT = key;
				BTDoubleVSplit( pfucb, itagVSplit, cbReq, cbVSplit, &ibSon, &keyT );
				psplit->splitt = splittDoubleVertical;
				psplit->itagSplit = itagVSplit;
				psplit->ibSon = ibSon;
				psplit->key.cb = keyT.cb;
				psplit->key.pb = psplit->rgbKey;
				memcpy( psplit->rgbKey, keyT.pb, keyT.cb );
				}
			else
				{
				psplit->splitt = splittVertical;
				psplit->itagSplit = itagVSplit;
				Assert( itagVSplit != itagFOP );
				psplit->key.pb = pbNil;
				psplit->key.cb = 0;
				}
			}
		else
			{
			INT		ibSon;
			KEY		keyMac;
			KEY		keyT;
			BOOL	fRight;
			CSR		*pcsrT;

			/*	choose ibSon of the son of FOP
			/**/
			for ( pcsrT = pcsr; pcsrT != pcsrNil; pcsrT = pcsrT->pcsrPath )
				{
				if ( pcsrT->itagFather == itagFOP )
					{
					ibSon = pcsrT->ibSon;
					break;
					}
				}

			Assert( psplit->op == opInsert || psplit->op == opReplace );

			/*	if no part of CSR stack has itagFOP as father, then we
			/*	must split father node.
			/**/
			/*	if page is FDP or non-FDP with fixed nodes resulting
			/*	in no benneficial vertical split, return error cannot
			/*	split.
			/**/
			if ( pcsrT == pcsrNil || psplit->fFDP )
				{
				/*	if we are going to split the father, then the
				/*	father should not be the father of page.  This
				/*	is especially true if the pscrT == pcsrNil which
				/*	indicates that no CSR had an FOP father.
				/**/
				Assert( pcsr->itagFather != itagFOP );
				NDGet( pfucb, pcsr->itagFather );
				goto SplitFather;
				}

			/*	horizontal split
			/**/
			keyT = key;
			BTHSplit( pfucb, cbReq, fAppendPage, psplit->op == opReplace, fDIRFlags,
		  		&ibSon, &keyMac, &keyT, &fRight, pfAppend, psplit );

			psplit->splitt = fRight ? splittRight : splittLeft;
			psplit->itagSplit = itagFOP;
			psplit->ibSon = ibSon;

			/*	store split key, key for new page
			/**/
			psplit->key.cb = keyT.cb;
			psplit->key.pb = psplit->rgbKey;
			memcpy( psplit->rgbKey, keyT.pb, keyT.cb );

			/*	store new key for page being split
			/**/
			psplit->keyMac.cb = keyMac.cb;
			psplit->keyMac.pb = psplit->rgbkeyMac;
			memcpy( psplit->rgbkeyMac, keyMac.pb, keyMac.cb );
			}
		}

	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );

	return JET_errSuccess;
	}


//+private----------------------------------------------------------------------
//
//	FBTVSplit
//	============================================================================
//
//	LOCAL BOOL FBTVSplit( FUCB *pfucb, INT itag, INT cbReq, BOOL fMobile )
//
//	PARAMETERS
//
//	Selects a node to vertically split.  Search begins at
//	itag.  By initializing *pf to fFalse, starting
//	node candidate is disqualified.  Fixed nodes disqualify
//	parent and ancestor nodes.
//
//	Select node with largest weight of children ( not including
//	weight of node ) to vertical split, i.e. large nodes with no
//	sons have weight of 0.
//
//	itag	candidate splittable node
//	*pf == fTrue if candidate splittable.  Will be false
//		if fixed node descendant.
//	*pcb is number of bytes freed as a result of the split
//
//------------------------------------------------------------------------------
LOCAL BOOL FBTVSplit( FUCB *pfucb, INT itag, INT cbReq, BOOL fMobile )
	{
	BOOL 	fT;
	INT	 	cbT;
	INT  	clineT;
	SSIB 	*pssib = &pfucb->ssib;

	//	UNDONE:	move these into split structure
	/*	reset output variables.
	/**/
	itagVSplit = itagFOP;
	cbVSplit = 0;
	clineVSplit = 0;
	clineVSplitTotal = 0;

	/*	cache root node.
	/**/
	NDGet( pfucb, itag );

	BTIVSplit( pfucb, itag, cbReq, fMobile, &fT, &cbT, &clineT );

	cbVSplit += cbFOPNoSon;

	return fT;
	}


LOCAL VOID BTIVSplit( FUCB *pfucb, INT itag, INT cbReq, BOOL fMobile, BOOL *pfMobile, INT *pcb, INT *pclineTotal )
	{
	SSIB   	*pssib = &pfucb->ssib;
	INT	  	cbThis = 0;
	INT	  	clineTotalThis = 0;
	BOOL   	fVisibleSons;
  	INT   	cbSon = 1;
	BYTE 	*pbSon;
	BYTE 	*pbSonMax;

	/*	assert current current node cached
	/**/
	AssertNDGet( pfucb, itag );

	fVisibleSons = FNDVisibleSons( *pssib->line.pb );
	*pfMobile = fTrue;

	/*	pssib must be set to current node
	/**/
#ifdef MOVEABLEDATANODE
	/*	only split DATA node is sons of DATA node have
	/*	already been split, so that record nodes are not mixed
	/*	with non-record nodes in split, non-FDP, page, so that
	/*	bookmark clean up can use pgtyp to clean up non-clustered
	/*	indexes.
	/**/
	if ( PgnoOfPn(pssib->pbf->pn) == pfucb->u.pfcb->pgnoRoot &&
		itag == pfucb->u.pfcb->itagRoot &&
		FNDSon( *pssib->line.pb ) &&
		FNDVisibleSons( *pssib->line.pb ) )
		*pfMobile = fFalse;
#else
	if ( PgnoOfPn(pssib->pbf->pn) == pfucb->u.pfcb->pgnoRoot &&
		itag == pfucb->u.pfcb->itagRoot )
		*pfMobile = fFalse;
#endif

	Assert( itag != itagFOP || FNDNonIntrinsicSons( pssib->line.pb ) );
	if ( FNDNonIntrinsicSons( pssib->line.pb ) )
		{
		pbSon = PbNDSonTable( pssib->line.pb );
		cbSon = CbNDSonTable( pbSon );
		pbSon++;
		pbSonMax = pbSon + cbSon;
		for( ;pbSon < pbSonMax; pbSon++ )
			{
			INT		itagT = (INT)*(BYTE *)pbSon;
			BOOL 	fT = fTrue;
			INT		cbT = 0;
			INT		clineT = 0;

			NDGet( pfucb, itagT );

			/*	add the number of bytes required in the new page for son
			/*		node
			/*		tag
			/*		itag son in father son table
			/*		backlink if node is visible and does not already have one
			/**/
			cbThis += pssib->line.cb + 1 + sizeof(TAG);
			if ( fVisibleSons && !FNDBackLink( *pssib->line.pb ) )
				{
				cbThis += sizeof(SRID);
				}

			/*	adjust weight for reserved space
			/**/
			if ( FNDVersion( *pssib->line.pb ) )
				{
				SRID	srid;
				UINT	cbMax;

				NDIGetBookmark( pfucb, &srid );
				cbMax = CbVERGetNodeMax( pfucb, srid );
				if ( cbMax > 0 && cbMax > CbNDData( pssib->line.pb, pssib->line.cb ) )
					cbThis += ( cbMax - CbNDData( pssib->line.pb, pssib->line.cb ) );
				}

			clineTotalThis++;
			BTIVSplit( pfucb, itagT, cbReq, fTrue, &fT, &cbT, &clineT );

			fMobile = fMobile && fT;
			cbThis += cbT;
			clineTotalThis += clineT;
			}
		}

	/*	return information for this level of tree
	/**/
	*pcb = cbThis;
	*pclineTotal = clineTotalThis;
	*pfMobile = *pfMobile && fMobile;

	/*	choose new split iff mobile and this is the first candidate
	/*	or if this is a subsequent candidate and it is
	/*	better than the previous by cbVSplitThreshold.
	/**/
	if ( fMobile &&
		( ( cbSon > 1 ) || ( cbThis <= cbAvailMost ) ) &&
		( ( cbThis > ( cbVSplit + ( cbVSplit == 0 ? 0 : cbVSplitThreshold ) ) ) ||
		( cbThis > cbReq && cbVSplit < cbReq ) ) )
		{
		Assert( itag != itagFOP );
		itagVSplit = itag;
		cbVSplit = cbThis;
		clineVSplit = cbSon;
		clineVSplitTotal = clineTotalThis;
		Assert( clineVSplit != 1 || cbVSplit <= cbAvailMost );
		}

	return;
	}


//+private----------------------------------------------------------------------
//
//	BTHSplit
//	============================================================================
//
//	LOCAL VOID BTHSplit( FUCB *pfucb, INT cbReq, BOOL fAppendPage,
//		BOOL fReplace, BOOL fDIRFlags, INT *pibSon, KEY *pkeyMac, KEY *pkey,
//		BOOL *pf, BOOL *pfAppend )
//
//	Selects right or left horizontal split and location of split.
//
//	If required additional space greater than space currently used in
//	page, then split at key or node requiring additional space.
//	Otherwise, determine
//
//	Note, BTHSplit also supports the concept that an operation may
//	be and update ibSon - 1 and insert ibSon, as occurrs with
//	insertion of page pointer nodes.  This can be distinguished
//	when the page is not visible sons, and the selection algorithm is
//	adjusted not to split at ibSon.
//
//------------------------------------------------------------------------------
LOCAL VOID BTHSplit(
	FUCB   	*pfucb,
	INT		cbReq,
	BOOL   	fAppendPage,
	BOOL   	fReplace,
	BOOL   	fDIRFlags,
	INT		*pibSon,
	KEY		*pkeyMac,
	KEY		*pkey,
	BOOL   	*pfRight,
	BOOL   	*pfAppend,
	SPLIT  	*psplit )
	{
	SSIB   	*pssib = &pfucb->ssib;
	INT		ibSon;
	BYTE   	*pbSon;
	BYTE   	*rgitagSon;
	BYTE   	*pbSonMax;
	INT		cbSon;
	INT		cbT;
	INT		ibSonT;
	INT		cbTotal = cbAvailMost - CbPMFreeSpace( pssib ) - CbPMLinkSpace( pssib ) + cbReq;
	BOOL   	fInsertLeftPage;
	BOOL   	fVisibleSons;

	/*	set pbSon to point to first son and cbSon to number of sons.
	/**/
	NDGet( pfucb, itagFOP );
	fVisibleSons = FNDVisibleSons( *pssib->line.pb );

	Assert ( CbNDSon(pssib->line.pb) != 0 );
	pbSon = PbNDSonTable( pssib->line.pb );
	cbSon = CbNDSonTable( pbSon );
	pbSon++;
	rgitagSon = pbSon;

	/*	get greatest key in page for new key for page pointer to this page.
	/**/
	NDGet( pfucb, pbSon[cbSon - 1] );
	pkeyMac->pb = PbNDKey( pssib->line.pb );
	pkeyMac->cb = CbNDKey( pssib->line.pb );

	/*	APPEND cases, i.e. split no nodes to right
	/**/

	/*	append when updating last node in non-clustered index
	/**/
	if ( ( fDIRFlags & fDIRAppendItem ) && ( *pibSon == cbSon - 1 ) )
		{
		*pfRight = fTrue;
		*pkey = *pkeyMac;
		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		*pfAppend = fTrue;
		return;
		}

	/*	append when no next page in B-tree and inserting node at end of page
	/**/
	if ( fAppendPage && *pibSon == cbSon )
		{
		/*	inserted nodes are ALWAYS inserted on new page, but replaced
		/*	nodes may or may not be moved.  If split is for replacement
		/*	then a child split of this split, may have a parent CSR that
		/*	will not move, but it must move to support the insertion of
		/*	the new page pointer node.  Thus, split avoids MCM
		/*	inconsistencies	by forcing the page pointer for current
		/*	page to be moved to the new page.
		/**/
		if ( fVisibleSons || psplit->op == opInsert )
			{
			*pfRight = fTrue;

			if ( fVisibleSons )
				{
				/* store the leaf page split key info
				/**/
				pkey->pb = PbNDKey( pssib->line.pb );
				pkey->cb = CbNDKey( pssib->line.pb );

				BTIStoreLeafSplitKey( psplit, pssib );
				}

			*pfAppend = fTrue;
			return;
			}
		}

	/*	if replacing node and page cannot hold node due to link
	/*	overhead, split only node to next page.
	/**/
	if ( fVisibleSons &&
		fReplace &&
		cbSon == 1 &&
		cbReq > CbPMFreeSpace( pssib ) )
		{
		*pfRight = fTrue;
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		*pfAppend = fFalse;
		return;
		}

	/*	append when inserting node larger than half of total space
	/*	at end of page, same effect as append page, except it is leaf only
	/**/
	if ( fVisibleSons &&
		!fReplace &&
		cbReq >= ( cbTotal / 2 ) &&
		*pibSon == (INT)cbSon )
		{
		*pfRight = fTrue;
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		*pfAppend = fTrue;
		return;
		}

	/*	prepend when inserting node larger than half of total space
	/*	at start of page.  Get split key from key of first node
	/*	on this page.  Note that the key of the inserted node cannot
	/*	be used as a result of the BT key conflict search algorithm!
	/**/
	if ( fVisibleSons &&
		!fReplace &&
		cbReq >= ( cbTotal / 2 ) &&
		*pibSon == 0 )
		{
		*pfRight = fFalse;
		NDGet( pfucb, pbSon[0] );
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		/*	set *pibSon to ibSonNull as a flag to move no nodes
		/**/
		*pibSon = ibSonNull;
		*pfAppend = fFalse;
		return;
		}

	/*	if only one node on page, and updating then split right, else
	/*	if inserting at ibSon 0 then split left or if inserting at ibSon 1
	/*	then split right.
	/**/
	if ( cbSon == 1 )
		{
		Assert( fVisibleSons );

		NDGet( pfucb, pbSon[0] );
		*pfRight = memcmp( pkey->pb, PbNDKey( pssib->line.pb ),
			min( CbNDKey( pssib->line.pb ), pkey->cb ) ) >= 0;
		if ( !*pfRight )
			{
			Assert( !fReplace && *pibSon == 0 );
			*pibSon = ibSonNull;

			/*	if left split then get split key from key of first node
			/*	on this page.  Note that the key of the inserted node cannot
			/*	be used as a result of the BT key conflict search algorithm!
			/**/
			pkey->pb = PbNDKey( pssib->line.pb );
			pkey->cb = CbNDKey( pssib->line.pb );
			}
#ifdef DEBUG
		else
			{
			Assert( fReplace && *pibSon == 0 || !fReplace && *pibSon == 1 );
			}
#endif

		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		*pfAppend = fFalse;
		return;
		}

	/*	OTHER cases, i.e. find best place to split to have equal free
	/*	space in both pages.  Note that care must be taken to avoid
	/*	splitting data larger than page size as a result of backlinks.
	/**/
	if ( !fReplace && *pibSon == cbSon )
		{
		/* an append
		/**/
		pbSonMax = pbSon + cbSon + 1;
		}
	else
		{
		pbSonMax = pbSon + cbSon;
		}
	cbT = 0;
	fInsertLeftPage = fFalse;
	for ( ibSon = 0; pbSon < pbSonMax; ibSon++, pbSon++ )
		{
		/*	if traversing inserted/replaced node add cbReq
		/**/
		if ( ibSon == (INT)*pibSon )
			{
			cbT += cbReq;
			}

		if ( !fReplace && ibSon == cbSon )
			break;

		/* if this is the inserting spot, then split on this ibSon, and
		/* insert the new node into the left page.
		/**/
		if ( !fReplace && cbT >= ( cbTotal / 2 ) )
			{
			fInsertLeftPage = fTrue;
			break;
			}

		cbT += UsBTWeight( pfucb, (INT)*pbSon );
		if ( cbT >= ( cbTotal / 2 ) )
			break;
		}

	/*	if cannot select on size, i.e when no tags left,
	/*	then just split page into halves
	/**/
	Assert( pbSon <= pbSonMax );
	if ( pbSon == pbSonMax )
		ibSon = cbSon / 2 ;

	Assert( cbSon > 1 );

	/* regular rule for split right
	/**/
	if ( ( ibSon != 0 && *pibSon >= ibSon ) ||
		( ibSon == 0 && *pibSon > ibSon ) )
		{
		*pfRight = fTrue;
		if ( ibSon == 0 )
			ibSon++;

		/*	since we did not compute the space required in the right split,
		/*	compute the space from right most to ibSon, and shunt if greater
		/*	than available page space.
		/**/
		cbT = 0;
		for ( ibSonT = cbSon - 1; ibSonT > ibSon; ibSonT-- )
			{
			if ( ibSonT == (INT)*pibSon - 1 )
				cbT += cbReq;

			cbT += UsBTWeight( pfucb, (INT)rgitagSon[ibSonT] );
			if ( cbT > cbAvailMost )
				break;
			}
		if ( ibSonT > ibSon )
			ibSon = ibSonT;
		if ( !fVisibleSons && ibSon == *pibSon )
			{
			Assert( cbSon > 2 );
#define BUGFIX 1
#ifdef BUGFIX
			/*	adjust split point to keep current page pointer
			/*	on same page with inserted page pointer, since
			/*	both nodes must be modified and MCMed together.
			/**/
			Assert( ibSon > 1 );
			ibSon--;

#else
			ibSon++;
			Assert( ibSon < cbSon );
#endif
			}
		}
	else
		{
		/*	since splitting left is inclusive of ibSon, reduce ibSon by
		/*	one if splitting all nodes left.
		/**/
		if ( ibSon == cbSon - 1 )
			ibSon--;
		if ( !fVisibleSons && ibSon == *pibSon )
			{
			Assert( cbSon > 2 );
#ifdef BUGFIX
			/*	adjust split point to keep current page pointer
			/*	on same page with inserted page pointer, since
			/*	both nodes must be modified and MCMed together.
			/**/
			Assert( ibSon < cbSon - 2 );
			ibSon++;
#else
			ibSon--;
			Assert( ibSon > 0 );
#endif
			}
		*pfRight = fFalse;
		}

	/*	ensure that we do not split update and insert page pointer
	/*	nodes during recursive split, since both nodes must be
	/*	updated together.
	/**/
	Assert( fVisibleSons || ibSon != *pibSon );

	if ( *pfRight )
		{
		/* split empty right page for Update should never happen.
		/* so if ibSon == cbSon, an append, can not be for update.
		/**/
		Assert ( ibSon != cbSon || !fReplace);

		/*	always right split, if the inserted key should go to left side
		/*	of the split, the split key is the ibSono'th Son's key.
		/*	To detect left side of split, check if ibSon == *pibSon and
		/*	if fInsertLeftPage is set.
		/*	if ibSon == cbSon, then it must be an append.
		/**/
		Assert( ibSon <= cbSon );

		/* get the right split key
		/**/
		NDGet( pfucb, itagFOP );
		pbSon = PbNDSon( pssib->line.pb );
		Assert( ibSon >= 1 );
		NDGet( pfucb, pbSon[ ibSon - 1 ] );
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		if ( fVisibleSons )
			{
			BTIStoreLeafSplitKey( psplit, pssib );
			}
		}
	else
		{
		/*	if left split then get split key from key of first node
		/*	on this page. Note that the key of the inserted node cannot
		/*	be used as a result of the BT key conflict search algorithm
		/**/

		/*	for update on first node and first node become huge
		/*	use first node's key as split key
		/**/
		Assert ( !( *pfRight ) );
		NDGet( pfucb, itagFOP );
		pbSon = PbNDSon( pssib->line.pb );
		NDGet( pfucb, pbSon[ibSon] );
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		if ( fVisibleSons )
			{
			BTIStoreLeafSplitKey( psplit, pssib );
			}

		/* prepend, no move.
		/**/
		if ( !fReplace && ibSon == 0 && *pibSon == 0 && fInsertLeftPage )
			ibSon = ibSonNull;

		}

	*pibSon = ibSon;
	*pfAppend = fFalse;
	return;
	}


LOCAL VOID BTDoubleVSplit( FUCB *pfucb, INT itagSplit, INT cbReq, INT cbTotal, INT *pibSon, KEY *pkey )
	{
	SSIB   	*pssib = &pfucb->ssib;
	INT		ibSon;
	BYTE   	*pbSon;
	BYTE   	*pbSonSplit;
	BYTE   	*pbSonMax;
	INT		cbSon;
	INT		cb;

	/*	set pbSon to point to first son and cbSon to number of sons.
	/**/
	NDGet( pfucb, itagSplit );

	Assert( CbNDSon(pssib->line.pb) > 1 );
	pbSon = PbNDSonTable( pssib->line.pb );
	cbSon = CbNDSonTable( pbSon );
	pbSon++;
	pbSonSplit = pbSon;

	pbSonMax = pbSon + cbSon;
	cb = 0;
	for ( ibSon = 0; pbSon < pbSonMax; ibSon++, pbSon++ )
		{
		/*	if traversing inserted/replaced node add cbReq
		/**/
		if ( ibSon == (INT)*pibSon )
			cb += cbReq;
		cb += UsBTWeight( pfucb, (INT)*pbSon );
		if ( cb >= ( cbTotal / 2 ) )
			break;
		}

	if ( ibSon == cbSon - 1 )
		ibSon--;

	NDGet( pfucb, pbSonSplit[ibSon] );
	pkey->pb = PbNDKey(pssib->line.pb);
	pkey->cb = CbNDKey(pssib->line.pb);

	/*	set return split ibSon
	/**/
	*pibSon = ibSon;
	return;
	}


//+private----------------------------------------------------------------------
//
//	UsBTWeight
//	============================================================================
//
//	LOCAL ULONG UsBTWeight( FUCB *pfucb, INT itag )
//
//	Only used for horizontal split.
//	Recursively calculates weight, i.e space freed by moving node and
//	node descendants.
//
//------------------------------------------------------------------------------
LOCAL ULONG UsBTWeight( FUCB *pfucb, INT itag )
	{
	SSIB   	*pssib = &pfucb->ssib;
	BYTE   	*pbSon;
	INT		cbSon;
	INT		ibSon;
	ULONG  	cbWeight;

	/*	keep SSIB in ssync with current tag for bookmark computation
	/**/
	pssib->itag = itag;

	NDGet( pfucb, itag );

	/*	total length is data length + tag size + son entry + backlink
	/**/
	cbWeight = pssib->line.cb + sizeof(TAG) + 1;
	if ( !FNDBackLink( *pssib->line.pb ) )
		{
		cbWeight += sizeof(SRID);
		}
	Assert( itag != itagFOP || FNDNonIntrinsicSons( pssib->line.pb ) );

	/*	adjust weight for reserved space
	/**/
	if ( FNDVersion( *pssib->line.pb ) )
		{
		SRID	srid;
		UINT	cbMax;

		NDIGetBookmark( pfucb, &srid );
		cbMax = CbVERGetNodeMax( pfucb, srid );
		if ( cbMax > 0 && cbMax > CbNDData( pssib->line.pb, pssib->line.cb ) )
			cbWeight += ( cbMax - CbNDData( pssib->line.pb, pssib->line.cb ) );
		}

	if ( FNDNonIntrinsicSons( pssib->line.pb ) )
		{
		/*	add weight of sons
		/**/
		pbSon = PbNDSonTable( pssib->line.pb );
		cbSon = *pbSon++;
		for ( ibSon = 0; ibSon < cbSon; ibSon++ )
			{
			cbWeight += UsBTWeight( pfucb, (INT)pbSon[ibSon] );
			}
		}
	return cbWeight;
	}


//+private---------------------------------------------------------------------
//
//	ErrBTMoveSons
//	===========================================================================
//
//	LOCAL ERR ErrBTMoveSons( SPLIT *psplit,
//	  FUCB *pfucb, FUCB *pfucbNew, BYTE *rgbSon,
//	  BOOL fVisibleSons, BOOL fNoMove )
//
//	PARAMETERS
//
//	move a tree rooted at pssib to pssibNew
//	pssib.line.pb must point to the source root line
//
//	When fVisibleSons is set, indicate this node is a leaf node.
//	When fNoMove is set, no real update will be done, only buffers involved
//	in the backlink updates will be collected.
//
//------------------------------------------------------------------------------
ERR ErrBTMoveSons(
	SPLIT	*psplit,
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	INT 	itagSonTable,
	BYTE	*rgbSon,
	BOOL	fVisibleSons,
	BOOL	fNoMove )
	{
	ERR  	err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	SSIB	*pssibNew = &pfucbNew->ssib;
	BYTE	*pbSon;
	INT  	cbSon;
	INT  	ibSon;
	INT  	ibSonMax;

	CallR( ErrSTWriteAccessPage( pfucb, psplit->pgnoSplit ) );
	Assert( pfucb->ssib.pbf == psplit->pbfSplit );

	/*	since splitter write latched split page there can be no
	/*	conflict and no updater can change split nodes during split.
	/**/
	Assert( FBFWriteLatch( psplit->ppib, psplit->pbfSplit ) );

	NDGet( pfucb, itagSonTable );

	rgbSon[0] = 0;

	if ( FNDNullSon( *pssib->line.pb ) )
		{
		Assert( err == JET_errSuccess );
		goto HandleError;
		}

	Assert( !FNDNullSon( *pssib->line.pb ) );

	pbSon = PbNDSonTable( pssib->line.pb );
	cbSon = CbNDSonTable(pbSon);
	pbSon++;

	if ( psplit->ibSon != ibSonNull )
		{
		switch ( psplit->splitt )
			{
			case splittVertical:
				ibSon = 0;
				ibSonMax = cbSon;
				break;
			case splittLeft:
				Assert( psplit->ibSon < cbSon );
				ibSon = 0;
				ibSonMax = psplit->ibSon + 1;
				break;
			default:
				Assert( psplit->ibSon <= cbSon );
				Assert( psplit->splitt == splittRight ||
						psplit->splitt == splittAppend );
				ibSon = psplit->ibSon;
				ibSonMax = cbSon;
			}

		for ( ; ibSon < ibSonMax; ibSon++ )
			{
			Call( ErrBTMoveNode( psplit, pfucb, pfucbNew,
				(INT)pbSon[ibSon],	rgbSon, fVisibleSons, fNoMove ) );
			}
		}

	/*	if success then should have split buffer access
	/**/
	Assert( pfucb->ssib.pbf == psplit->pbfSplit );

HandleError:
	return err;
	}


/*	forward node deferred free space to new page, allocating space from
/*	new page and releasing to split page.
/**/
INLINE LOCAL VOID BTIForwardDeferFreedNodeSpace( FUCB *pfucb, PAGE *ppageOld, PAGE *ppageNew, SRID bm )
	{
	INT	cbReserved;

	Assert( FNDVersion( *pfucb->ssib.line.pb ) );
	cbReserved = CbVERGetNodeReserve( pfucb, bm );
	Assert( cbReserved >= 0 );
	if ( cbReserved > 0 )
		{
		ppageOld->pghdr.cbFreeTotal += (SHORT)cbReserved;
		ppageNew->pghdr.cbFreeTotal -= (SHORT)cbReserved;
		}

	return;
	}

	
ERR ErrBTStoreBackLinkBuffer( SPLIT *psplit, BF *pbf, BOOL *pfAlreadyStored )
	{
	INT		cpbf;
	
	/*	check if the page is back linked in previous backlink
	/**/
	if ( psplit->cpbf )
		{
		BF	**ppbf = psplit->rgpbf;
		BF	**ppbfMax = ppbf + psplit->cpbf;

		for (; ppbf < ppbfMax; ppbf++)
			{
			if ( *ppbf == pbf )
				{
				*pfAlreadyStored = fTrue;
				return JET_errSuccess;
				}
			}
		}

	*pfAlreadyStored = fFalse;

	/*	keep the backlink into the psplit backlink table rgpbf
	/**/
	cpbf = psplit->cpbf++;
	if ( psplit->cpbf > psplit->cpbfMax )
		{
		BF **ppbf;

		/*	run out of space, get more buffers
		/**/
		psplit->cpbfMax += 10;
		ppbf = SAlloc( sizeof(BF *) * psplit->cpbfMax );
		if ( ppbf == NULL )
			return JET_errOutOfMemory;
		
		memcpy( ppbf, psplit->rgpbf, sizeof(BF *) * cpbf );
		if ( psplit->rgpbf )
			{
			SFree( psplit->rgpbf );
			}
		psplit->rgpbf = ppbf;
		}

	*( psplit->rgpbf + cpbf ) = pbf;

	return JET_errSuccess;
	}

	
/* store the operations of the merge page:
/*  sridBackLink != pgnoSplit
/*      ==> a regular backlink
/*  sridBackLink == pgnoSplit && sridNew == sridNull
/*      ==> move the node from old page to new page. Deletion on old page.
/*  sridBackLink == pgnoSplit && sridNew != sridNull.
/*      ==> a new link among the old page and the new page,
/*          replace an entry with link on old page.
/**/
ERR ErrBTStoreBackLink( SPLIT *psplit, SRID sridNew, SRID sridBackLink )
	{
	BKLNK	*pbklnk;
	INT		cbklnk;
	
	Assert( sridNew == sridNull ||
		PgnoOfSrid( sridNew ) != pgnoNull );
	Assert( sridNew == sridNull ||
		(UINT) ItagOfSrid( sridNew ) > 0 &&
		(UINT) ItagOfSrid( sridNew ) < (UINT) ctagMax );
	Assert( sridBackLink != sridNull );
	Assert( PgnoOfSrid( sridBackLink ) != pgnoNull );

	/* log the back link
	/**/
	cbklnk = psplit->cbklnk++;

	/* assert cbklnk less then max.  Note that we may store
	/*	two entries per record.
	/**/
	Assert( cbklnk < ctagMax * 2 );
	
	if ( psplit->cbklnk > psplit->cbklnkMax )
		{
		/* run out of space, get more buffers
		/**/
		psplit->cbklnkMax += 10;
		pbklnk = SAlloc( sizeof(BKLNK) * (psplit->cbklnkMax) );
		if ( pbklnk == NULL )
			{
			/*	restore cbklnk
			/**/
			psplit->cbklnk--;
			return JET_errOutOfMemory;
			}
		memcpy( pbklnk, psplit->rgbklnk, sizeof(BKLNK) * cbklnk );
					
		if ( psplit->rgbklnk )
			{
			SFree( psplit->rgbklnk );
			}
		psplit->rgbklnk = pbklnk;
		}

	pbklnk = psplit->rgbklnk + cbklnk;

	pbklnk->sridNew = sridNew;
	pbklnk->sridBackLink = sridBackLink;
	
	return JET_errSuccess;
	}
	

//+private---------------------------------------------------------------------
//
//	ErrBTMoveNode
//	===========================================================================
//
//	LOCAL ERR ErrBTMoveNode( SPLIT *psplit, FUCB *pfucb, FUCB *pfucbNew,
// 	  BYTE *rgbSon, BOOL fVisibleNode, BOOL fNoMove )
//
//	PARAMETERS
//
//	moves node and any decendants of node.  Increments rgbSonNew count
//	and sets new itag in rgbSonNew array.
//  When fVisibleSons is set, indicate this node is a leaf node.
//  if fNoMove is set, no delete or insert is done, only backlinked buffers
//  are collected.
//
//-----------------------------------------------------------------------------
LOCAL ERR ErrBTMoveNode(
	SPLIT		*psplit,
	FUCB		*pfucb,
	FUCB		*pfucbNew,
	INT  		itagNode,
	BYTE		*rgbSon,
	BOOL		fVisibleNode,
	BOOL		fNoMove )
	{
	ERR			err;
	/*	used as index into tag mapping
	/**/
	INT  		itagOld = itagNode;
	SSIB		*pssib = &pfucb->ssib;
	SSIB		*pssibNew = &pfucbNew->ssib;
	INT  		cline = 1;
	LINE		rgline[3];
	BYTE		*pb;
	BYTE		*pbNode;
	ULONG		cb;
	SRID		sridNew;
	SRID		sridBackLink;
	BYTE		rgbT[citagSonMax];

	/*	get node to move.
	/**/
	pssib->itag = itagOld;
	NDGet( pfucb, itagOld );

	rgline[0] = pssib->line;
	pbNode = pb = pssib->line.pb;
	cb = pssib->line.cb;
	Assert( cb < cbPage );

	Assert( itagOld != itagFOP || FNDNonIntrinsicSons( pssib->line.pb ) );
	if ( FNDNonIntrinsicSons( pssib->line.pb ) )
		{
		INT		itagT = itagOld;
		SPLITT	splittT;
		BOOL	fVisibleSons = FNDVisibleSons( *pssib->line.pb );

		psplit->fLeaf |= fVisibleSons;

		/*	call move tree to move all its sons
		/**/
		rgbT[0] = 0;

		/*	movement of subtrees must include whole tree, hence,
		/*	move as though vertical split
		/**/
		splittT = psplit->splitt;
		psplit->splitt = splittVertical;
		CallR( ErrBTMoveSons( psplit, pfucb, pfucbNew, itagOld, rgbT, fVisibleSons, fNoMove) );
		psplit->splitt = splittT;

		/*	can be done by copying the new rgbSon into the pssib page
		/*	directly, pb should be still effective.  Must remember
		/*	to copy back link as well.
		/**/
		pb = PbNDSonTable( pb );
		rgline[0].cb = (UINT)(pb - pbNode);
		rgline[1].pb = rgbT;
		rgline[1].cb = rgbT[0] + 1;
		rgline[2].pb = pb + *pb + 1;
		rgline[2].cb = cb - rgline[0].cb - rgline[1].cb;
		cline = 3;

		/*	restore cursor state
		/**/
		pfucb->ssib.itag = itagOld;
		NDGet( pfucb, itagOld );
		}

	/*	assert current node cached
	/**/
	AssertNDGet( pfucb, itagOld );

	/*	propogate version count if version exists for node being moved
	/**/
	if ( !fNoMove && FNDVersion( *pbNode ) )
		{
		PMDecVersion( pssib->pbf->ppage );
		PMIncVersion( pssibNew->pbf->ppage );
		}

	/*	if node is linked, it must be a leaf node, adjust links
	/*	to new location else replace with new link to new location.
	/**/
	if ( !fVisibleNode )
		{
		if ( fNoMove )
			return JET_errSuccess;

		CallS( ErrPMInsert( pssibNew, rgline, cline ) );
		Assert( !FNDBackLink( *pssib->line.pb ) );
		PMDelete( pssib );
		sridNew = sridNull;
		sridBackLink = SridOfPgnoItag( psplit->pgnoSplit, itagOld );
		CallR( ErrBTStoreBackLink( psplit, sridNew, sridBackLink ) );
		}
	else
		{
		if ( FNDBackLink( *pbNode ) )
			{
			PGNO	pgno;
			INT		itag;
			BOOL	fLatched;

#ifdef DEBUG
			{
			INT itagT = PcsrCurrent(pfucb)->itag;

			PcsrCurrent(pfucb)->itag = pssib->itag;
			NDGetBackLink( pfucb, &pgno, &itag );
			PcsrCurrent(pfucb)->itag = itagT;
			}
#else
			NDGetBackLink( pfucb, &pgno, &itag );
#endif

			if ( !fNoMove )
				{
				if ( FNDVersion( *pssib->line.pb ) )
					{
					BTIForwardDeferFreedNodeSpace(
						pfucb,
						pssib->pbf->ppage,
						pssibNew->pbf->ppage,
						SridOfPgnoItag(pgno, itag) );
					}
				CallS( ErrPMInsert( pssibNew, rgline, cline ) );
				PMDelete( pssib );
				}

			CallR( ErrSTWriteAccessPage( pfucb, pgno ) );
			if ( fRecovering &&
				pssib->pbf->ppage->pghdr.ulDBTime >= psplit->ulDBTimeRedo )
				goto EndOfUpdateLinks;

			sridNew = SridOfPgnoItag( PcsrCurrent( pfucbNew )->pgno, pssibNew->itag );
			sridBackLink = SridOfPgnoItag( pgno, itag );

			if ( !fNoMove )
				{
				pssib->itag = itag;
				PMDirty( pssib );
				PMReplaceLink( pssib, sridNew );

				/*	For redo, we do not call this function with fNoMove to hold buffer.
				 *	We simply access the buffer as we go. So we have to check if buffer
				 *	need to be stored. Check if the page is back linked in previous backlink
				 **/
				if ( fRecovering )
					{
					CallR( ErrBTStoreBackLinkBuffer( psplit, pssib->pbf, &fLatched ) );
					if ( !fLatched )
						{
						BFPin( pssib->pbf );
						BFSetWriteLatch( pssib->pbf, pssib->ppib );
						}
					}
#ifdef DEBUG
				else
					{
					BF		**ppbf = psplit->rgpbf;
					BF		**ppbfMax = ppbf + psplit->cpbf;
					BOOL	fBufferFound = fFalse;

					Assert( psplit->cpbf );

					for ( ; ppbf < ppbfMax; ppbf++ )
						{
						if ( *ppbf == pssib->pbf )
							{
							fBufferFound = fTrue;
							break;
							}
						}

					Assert( fBufferFound );
					}
#endif

				Assert( sridNew != sridNull );
				Assert( sridBackLink != sridNull );
				CallR( ErrBTStoreBackLink( psplit,
					sridNew,
					sridBackLink ) );
			
				/*	store backlink such that the source node will be
				/*	deleted during recovery.
				/**/
				CallR( ErrBTStoreBackLink( psplit,
					sridNull,
					SridOfPgnoItag( psplit->pgnoSplit, itagOld ) ) );

				goto EndOfUpdateLinks;
				}

			if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
				{
				/*	yeild after release split resources
				/**/
				return errDIRNotSynchronous;
				}

			/*	check if the page is back linked in previous backlink
			/**/
			CallR( ErrBTStoreBackLinkBuffer( psplit, pssib->pbf, &fLatched ) );
			if ( !fLatched )
                {
			    BFPin( pssib->pbf );
			    BFSetWriteLatch( pssib->pbf, pssib->ppib );
                }

EndOfUpdateLinks:

			CallR( ErrSTWriteAccessPage( pfucb, psplit->pgnoSplit ) );

			if ( fNoMove )
				return JET_errSuccess;
			}
		else
			{
			BYTE	bFlags;
			KEY 	key;
			LINE	lineSonTable;
			LINE	lineData;
			SRID	srid;

			if ( fNoMove )
				return JET_errSuccess;

			srid = SridOfPgnoItag( psplit->pgnoSplit, itagNode );

			if ( FNDVersion( *pssib->line.pb ) )
				{
				BTIForwardDeferFreedNodeSpace(
					pfucb,
					pssib->pbf->ppage,
					pssibNew->pbf->ppage,
					srid );
				}

#ifndef MOVEABLEDATANODE
			Assert( psplit->pgnoSplit != pfucb->u.pfcb->pgnoRoot ||
				itagNode != pfucb->u.pfcb->itagRoot );
#endif
			//	UNDONE:	clean this up
			bFlags = *pbNode;
			key.cb = CbNDKey( pbNode );
			if ( key.cb > 0 )
				key.pb = PbNDKey( pbNode );
			if ( FNDSon( *pbNode ) )
				{
				if ( cline == 1 )
					{
					/*	must be intrinsic son
					/**/
					Assert( FNDSon( *pbNode ) && FNDInvisibleSons( *pbNode ) &&
						CbNDSon( pbNode ) == 1 );
					lineSonTable.cb = 1 + sizeof(PGNO);
					lineSonTable.pb = PbNDSonTable( pbNode );
					}
				else
					{
					Assert( cline == 3 );
					lineSonTable.cb = rgline[1].cb;
					lineSonTable.pb = rgline[1].pb;
					}
				}
			else
				{
				lineSonTable.cb = 0;
				lineSonTable.pb = NULL;
				}
			Assert( !FNDBackLink( *pbNode ) );
			lineData.pb = PbNDData( pbNode );
			lineData.cb = cb - (UINT)( lineData.pb - pbNode );
			CallS( ErrNDInsertWithBackLink( pfucbNew, bFlags, &key, &lineSonTable, srid, &lineData ) );
			Assert( PcsrCurrent( pfucbNew )->itag != itagFOP );
			srid = SridOfPgnoItag( PcsrCurrent( pfucbNew )->pgno, PcsrCurrent( pfucbNew )->itag );
			PMReplaceWithLink( pssib, srid );
			
			sridNew = srid;
			sridBackLink = SridOfPgnoItag( psplit->pgnoSplit, itagOld );
			
			CallR( ErrBTStoreBackLink( psplit, sridNew, sridBackLink ) );
			}
		}

	rgbSon[++rgbSon[0]] = (BYTE) pssibNew->itag;

	/*	record tag mapping in SPLIT.  Note that some new itags will
	/*	be duplicated during double split, however, since source itags
	/*	are unique, there is no aliasing.
	/**/
	Assert( itagOld != 0 );
	Assert( psplit->mpitag[itagOld] == 0 );
	psplit->mpitag[itagOld] = (BYTE)pssibNew->itag;

#ifdef MOVEABLEDATANODE
	/*	if moved DATA node then update FCB.
	/**/
#ifdef DEBUG
	{
	/*	Assert that correct FCB is used with split page so that
	/*	root updates are not lost.
	/**/
	PGNO	pgnoFDP;

	LFromThreeBytes( pgnoFDP, pssib->pbf->ppage->pghdr.pgnoFDP );
	Assert( pgnoFDP == pfucb->u.pfcb->pgnoFDP );

	LFromThreeBytes( pgnoFDP, pssibNew->pbf->ppage->pghdr.pgnoFDP );
	Assert( pgnoFDP == pfucb->u.pfcb->pgnoFDP );
	}
#endif

	if ( PgnoOfPn( pssib->pbf->pn ) == pfucb->u.pfcb->pgnoRoot &&
		itagNode == pfucb->u.pfcb->itagRoot )
		{
		pfucb->u.pfcb->pgnoRoot = PgnoOfPn( pssibNew->pbf->pn );
		pfucb->u.pfcb->itagRoot = pssibNew->itag;
		}
#endif

	return JET_errSuccess;
	}


//+private----------------------------------------------------------------------
//
//	FBTSplit
//	============================================================================
//
//	BOOL FBTSplit( SSIB *pssib, INT cbReq, INT citagReq )
//
//	PARAMETERS
//
//	determine whether split is required.  Split is required if less than
//	required space is free in page or if no page tags are free.  cbReq
//	must include all space required including that space for the tag.
//
//------------------------------------------------------------------------------
BOOL FBTSplit( SSIB *pssib, INT cbReq, INT citagReq )
	{
	BOOL	fSplit;

	Assert( citagReq < ctagMax );

	fSplit =	CbPMFreeSpace( pssib ) < cbReq || !FPMFreeTag( pssib, (INT) citagReq );
	return fSplit;
	}



//+private----------------------------------------------------------------------
//
//	FBTAppendPage
//	============================================================================
//
//	LOCAL BOOL FBTAppendPage( CSR *pcsr, SSIB *pssib, INT cbReq, INT cbPageAdjust, INT cbFreeDensity )
//
//	PARAMETERS
//
//	node should be inserted into appended page when node is last son of FOP, page to be inserted in
//	is last page in b-tree, not FDP page and density contraint would be
//	violated if node were inserted on current page.
//
//------------------------------------------------------------------------------
BOOL FBTAppendPage( FUCB *pfucb, CSR *pcsr, INT cbReq, INT cbPageAdjust, INT cbFreeDensity )
	{
	BOOL	fAppendPage = fFalse;
	PGNO	pgno;
	INT		cbSon;
	SSIB	*pssib = &pfucb->ssib;

	PgnoNextFromPage( pssib, &pgno );

	/*	itagFather == 0 for non-FDP page
	/*	pgno == pgnoNull for last B-tree page
	/*	cbFree - cbReq < cbFreeDensity violates density contraint
	/*	disable density contraint when required space is too large
	/*	to satisfy density
	/**/
	if ( pcsr->itagFather == itagFOP &&
		pgno == pgnoNull &&
		( cbReq < (INT)cbAvailMost - cbFreeDensity ) &&
		( CbPMFreeSpace(pssib) - cbPageAdjust - cbReq ) < cbFreeDensity )
		{
		LINE	lineSav = pfucb->ssib.line;

		/*	get number of sons of FOP to check if current node is last of FOP's sons */
		/**/
		NDGet( pfucb, itagFOP );
		cbSon = CbNDSonTable( PbNDSonTable( pssib->line.pb ) );
		fAppendPage = ( pcsr->ibSon == cbSon );

		/*	restore line
		/**/
		pfucb->ssib.line = lineSav;
		}

	return fAppendPage;
	}


#pragma optimize("g",on)


//+private----------------------------------------------------------------------
//
//	CbBTFree
//	============================================================================
//
//	Returns free space until density or page constraint met.
//
//------------------------------------------------------------------------------
INT CbBTFree( FUCB *pfucb, INT cbFreeDensity )
	{
	SSIB	*pssib = &pfucb->ssib;
	INT		cbFree =  CbPMFreeSpace( pssib ) - cbFreeDensity;

	if ( cbFree < 0 )
		return 0;
	return cbFree;
	}


//+private----------------------------------------------------------------------
//
//	FBTTableData
//	============================================================================
//
//	LOCAL BOOL FBTTableData( FUCB *pfucb, PGNO pgno, INT itag )
//
//	PARAMETERS
//
//------------------------------------------------------------------------------
BOOL FBTTableData( FUCB *pfucb, PGNO pgno, INT itag )
	{
	BOOL	f;
	f = FFUCBRecordCursor( pfucb ) &&
		pfucb->u.pfcb->pgnoRoot == pgno &&
		pfucb->u.pfcb->itagRoot == itag;
	return f;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\buf.c ===
//===========================================================================
//              DAE: Database Access Engine
//              buf.c: buffer manager
//===========================================================================

#include "config.h"

#include <stdlib.h>
#include <string.h>

#include "daedef.h"
#include "fmp.h"
#include "dbapi.h"
#include "page.h"
#include "util.h"
#include "pib.h"
#include "ssib.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "stint.h"
#include "logapi.h"
#include "log.h"

DeclAssertFile;         /* Declare file name for assert macros */

#ifdef DEBUG
#define HONOR_PAGE_TIME	1
#endif

/*******************************************************************

  The buffer manager maintains a LRU-K heap to keep track of referenced
  page, and order the page's buffer in LRU-K order. The buffer manager
  also maintains an avail lru list. When number of available buffer is
  lower than a threshold, then buffer manager will activate BFClean
  thread to take out the writable buffers from lru-k heap and put them
  into BFWrite heap. When there are enough buffers are put into BFWrite heap,
  the BFWrite thread will be activated and begin to take out the buffers
  from BFWrite heap and issue an assynchronous write.

  If two references are too close, then we said the two references are
  correlated and we treat them as one reference. LRU-K weight is the
  interval of two non-correlated references.

  BFWrite process will issue IO to a certain number (controled by a system
  parameter), and then stop issuing and sleepEx. When one write is complete
  and its completion routine is called, it will then issue another write.
  This mechanism allow us to make sure no too much writes are issued and
  not saturate disk for writes only.

  When BFWrite taking out buffers to write, it check next buffer in the
  BFWrite heap to see if it can combine the two (or more) writes as one.
  A continuous batch write buffers are used for this purpose. As long as
  batch write buffers are available we will combine the writes whenever
  page number is contiguous.

  A buffer can be in one of the following states:
	  pre/read/write - the buffer is being used for IO's.
	  held - temporarily taken out from a heap and put to another heap.
  A buffer in one of above state is said the buffer is in use.
  If a buffer is in use, the requester has to wait until it become available.
  A buffer state must be checked within critBF so that no thread will see
  the transit state of a buffer.

/*******************************************************************/


/*
 *  Buffer hash table.
 */

BF	*rgpbfHash[ipbfMax];


/*
 *  buffer group control block.
 */

BGCB    *pbgcb = NULL;


/*
 *  A buffer can be in one of the 4 groups
 *   1) LRU-K heap and temp list.
 *      regulated by critLRUK.
 *      a) in LRU-K heap. ( ipbf < ipbfLRUKHeapMac )
 *      b) temporary clean cache list. ( ipbfInLRUKList == -2 )
 *         The head of the list is lrulistLRUK.pbLRU.
 *
 *   2) BFWrite heap.
 *      regulated by critBFWrite. (ipbf > ipbfHeapMax - 1 - ipbfBFWriteHeapMac)
 *
 *   3) Available lru list
 *      regulated by critAvail. ( ipbfInAvailList == -3 )
 *      The head of the list is pbgcb->lrulist.pbfLRU.
 *
 *   4) Preread list
 *      regulated by critBFPreread. ( ipbfInPrereadList == -4 )
 *      The head of the list is lrulistPreread.pbfLRU.
 *
 *   4) dangling buffers. ( ipbfDangling == -1 ).
 *
 *  A buffer is being pre/read/written/hold, its pre/read/write/hold flag
 *  will be set. During buffer clean up, if a buffer is in LRU-K heap and
 *  is latched, it will be put into a temporay lru list, and then be put
 *  back to LRU-K heap at the end of clean_up process issuing IO (it does
 *  not wait for IOs).
 *
 *  Both LRU-K and BFWrite heaps are sharing one heap (rgpbfHeap), the LRU-K
 *  heap is growing from 0 to higher numbers, and BFWrite heap is growing from
 *  higher number (ipbfHeapMax - 1) to lower number.
 */

BF **rgpbfHeap = NULL;
INT ipbfHeapMax;

INT ipbfLRUKHeapMac;
INT ipbfBFWriteHeapMac;

LRULIST lrulistLRUK;		/* -2 */
LRULIST lrulistPreread;		/* -4 */

#define ipbfDangling		-1
#define ipbfInLRUKList		-2
#define ipbfInAvailList		-3
#define ipbfInPrereadList	-4

#define FBFInBFWriteHeap(pbf) \
	((pbf)->ipbfHeap < ipbfHeapMax && (pbf)->ipbfHeap > ipbfBFWriteHeapMac)

#define FBFInLRUKHeap(pbf) \
	((pbf)->ipbfHeap >= 0 && (pbf)->ipbfHeap < ipbfLRUKHeapMac)


/*
 *  critical section order
 *  critJet --> critLRUK --> ( critBFWrite, critPreread, critAvail ) --> critBF
 */

CRIT	__near critLRUK;		/* for accessing LRU-K heap */
CRIT	__near critBFWrite;		/* for accessing BFWrite heap */
CRIT	__near critPreread;		/* for accessing preread list */
CRIT	__near critAvail;		/* for accessing avail lru-list */


/*
 *  Batch IO buffers. Used by BFWrite to write contigous pages, or by preread
 *  to read continguous pages. Allocation of contingous batch IO buffers
 *  must be done in critBatch. If a batch IO buffer is allocated, the
 *  corresponding use flag will be set.
 */

CRIT	__near critBatchIO;
INT		ipageBatchIOMax;
PAGE	*rgpageBatchIO = NULL;
BOOL	*rgfBatchIOUsed = NULL;


/*
 *  BFClean process - take the heaviest buffer out of LRUK heap and put
 *  into BFWrite process.
 */

#ifdef  ASYNC_BF_CLEANUP
HANDLE  handleBFCleanProcess = 0;
BOOL    fBFCleanProcessTerm = 0;
SIG __near sigBFCleanProc;
LOCAL VOID BFCleanProcess( VOID );

/*
 *	number of active asynchronous IO.
 */

CRIT __near	critIOActive;
// UNDONE: cIOactive itself be the spin lock
int			cIOActive = 0;


/*
 *  BFWrite process - take the buffer out of BFWrite heap and issue IO's
 */

HANDLE  handleBFWriteProcess = 0;
BOOL    fBFWriteProcessTerm = 0;
static SIG __near sigBFWriteProc;
LOCAL VOID BFWriteProcess( VOID );

/*
 *  BFPreread process - take the buffer out of BFIO heap and issue IO's
 */

HANDLE  handleBFPrereadProcess = 0;
BOOL    fBFPrereadProcessTerm = 0;
static SIG __near sigBFPrereadProc;
LOCAL VOID BFPrereadProcess( VOID );
#endif

LOCAL ERR ErrBFIAlloc( BF **ppbf );
INLINE BOOL FBFIWritable(BF *pbf);
#define fOneBlock       fTrue
#define fAllPages       fFalse
LOCAL ERR ErrBFClean( BOOL fHowMany );
LOCAL VOID BFIRemoveDependence( PIB *ppib, BF *pbf );

LOCAL VOID __stdcall BFIOPrereadComplete( LONG err, LONG cb, OLP *polp );
LOCAL VOID __stdcall BFIOWriteComplete( LONG err, LONG cb, OLP *polp );


/*
 *  Timer for LRUK algorithm.
 */

ULONG ulBFTime = 0;
ULONG ulBFCorrelationInterval = 100;
ULONG ulBFFlush1 = 0;
ULONG ulBFFlush2 = 0;
ULONG ulBFFlush3 = 0;

		
/*
 *  system parameters
 */
extern long lBufThresholdLowPercent;
extern long lBufThresholdHighPercent;

extern long lBufLRUKCorrelationInterval;
extern long lBufBatchIOMax;
extern long lPagePrereadMax;
extern long lAsynchIOMax;


/*
 *  When ppib is not Nil and check if a page is in use by checking if it is
 *  Accessible to this PIB. Note that a page is accessible even it is overlay
 *  latched (cPin != 0). This checking accessible is mainly used by BFAccess.
 *  If ppib is nil, basically it is used for freeing a buffer. This is used
 *  by BFClean and BFIAlloc.
 */

#define FBFNotAccessible( ppib, pbf )					\
			((pbf)->fPreread ||							\
			 (pbf)->fRead ||							\
			 (pbf)->fWrite ||							\
			 (pbf)->fHold ||							\
			 (pbf)->cWaitLatch != 0 && (ppib) != (pbf)->ppibWaitLatch )

#define FBFNotAvail( pbf )								\
			((pbf)->fPreread ||							\
			 (pbf)->fRead ||							\
			 (pbf)->fWrite ||							\
			 (pbf)->fHold ||							\
			 (pbf)->cPin != 0)

#define FBFInUse(ppib, pbf)								\
			((ppib != ppibNil) ? FBFNotAccessible(ppib,pbf) : FBFNotAvail(pbf))

#define FBFInUseByOthers(ppib, pbf)											\
			((pbf)->fPreread ||												\
			 (pbf)->fRead ||												\
			 (pbf)->fWrite ||												\
			 (pbf)->fHold ||												\
			 (pbf)->cPin > 1 ||												\
			 (pbf)->cWaitLatch != 0 && (ppib) != (pbf)->ppibWaitLatch ||	\
			 (pbf)->cWriteLatch != 0 && (ppib) != (pbf)->ppibWriteLatch )

#ifdef DEBUG
//#define DEBUGGING				1
//#define FITFLUSHPATTERN       1
#ifdef  FITFLUSHPATTERN

BOOL fDBGSimulateSoftCrash = fFalse;
BOOL fDBGForceFlush = fFalse;

BOOL FFitFlushPattern( PN pn )
	{
	LONG lBFFlushPattern = rgfmp[DbidOfPn( pn )].lBFFlushPattern;

	if ( fDBGForceFlush )
		return fTrue;

	/* flush odd and page is not odd
	/**/
	if ( lBFFlushPattern == 1 && ( pn & 0x01 ) == 0 )
		return fFalse;

	/* flush even and page is not even
	/**/
	if ( lBFFlushPattern == 2 && ( pn & 0x01 ) == 1 )
		return fFalse;

	if ( lBFFlushPattern )
		fDBGSimulateSoftCrash = fTrue;

	return fTrue;
	}
#else
BOOL fDBGForceFlush = fFalse;
BOOL fDBGSimulateSoftCrash = fFalse;
#define fDBGSimulateSoftCrash   fFalse
#define fDBGForceFlush                  fFalse
#endif
#endif


/*  check if the page is accessiable. To check if the buffer in use,
/*  ppib must be passed for accessiability checking.
/**/
BOOL FBFAccessPage( FUCB *pfucb, PGNO pgno )
	{
	BOOL	f;
	BF		*pbf = pfucb->ssib.pbf;
	
	EnterCriticalSection( pbf->critBF );
	f = ( PgnoOfPn(pbf->pn) == (pgno) &&
		pfucb->dbid == DbidOfPn(pbf->pn) &&
		!FBFInUse(pfucb->ppib, pbf) );
	LeaveCriticalSection( pbf->critBF );
	if ( f )
		{
		CheckPgno( pbf->ppage, pbf->pn ) ;
		
		/* check if it is in LRUK heap
		/**/
		EnterCriticalSection( critLRUK );
		f &= ( FBFInLRUKHeap( pbf ) || pbf->ipbfHeap == ipbfInLRUKList );
		LeaveCriticalSection( critLRUK );
		}

	return f;
	}


/*  swap two elements of rgpbfHeap
/**/
VOID BFHPISwap( INT ipbf1, INT ipbf2 )
	{
	BF	*pbf1 = rgpbfHeap[ipbf1];
	BF	*pbf2 = rgpbfHeap[ipbf2];

	Assert( pbf1->ipbfHeap == ipbf1 );
	Assert( pbf2->ipbfHeap == ipbf2 );

	rgpbfHeap[ipbf2] = pbf1;
	pbf1->ipbfHeap = ipbf2;

	rgpbfHeap[ipbf1] = pbf2;
	pbf2->ipbfHeap = ipbf1;
	}


/*********************************************************
 * 
 *  Heap functions for buffer IO heap
 *
 *********************************************************/

/*
 *  make sure the smallest page number has highest priority
 */
BOOL FBFWriteGreater( BF *pbf1, BF *pbf2 )
	{
	return pbf1->pn < pbf2->pn;
	}

/*
 *  when the weight of a node (ipbf) is reduced, then we adjust the heap
 */
VOID BFWriteAdjustHeapDownward(INT ipbf)
	{
	INT dpbf;
	INT dpbfLeft;
	INT ipbfLeft;
	INT ipbfSonMax;

	AssertCriticalSection( critBFWrite );
		
NextLevel:
	Assert( ipbf == rgpbfHeap[ipbf]->ipbfHeap );

	dpbf = ipbfHeapMax - 1 - ipbf;
	dpbfLeft = dpbf * 2 + 1;
	ipbfLeft = ipbfHeapMax - 1 - dpbfLeft;

	if (ipbfLeft > ipbfBFWriteHeapMac)
		{
		/*  not reach the leaf yet, choose larger of
		 *  left and right node and put in ipbfSonMax.
		 */
		INT ipbfRight;
		
		ipbfRight = ipbfLeft - 1;
		ipbfSonMax = ipbfLeft; /* assume left is max of the two for now */
		
		/* check if right son exists, check if it is greater */
		Assert( ipbfRight <= ipbfBFWriteHeapMac ||
				rgpbfHeap[ ipbfRight ]->ipbfHeap == ipbfRight );
		Assert(	rgpbfHeap[ ipbfLeft ]->ipbfHeap == ipbfLeft );
		if ( ipbfRight > ipbfBFWriteHeapMac &&
			 FBFWriteGreater( rgpbfHeap[ ipbfRight ], rgpbfHeap[ ipbfLeft ] ) )
			ipbfSonMax = ipbfRight;

		/* swap the node with larger son.
		 */
		Assert( rgpbfHeap[ ipbfSonMax ]->ipbfHeap == ipbfSonMax );
		Assert( rgpbfHeap[ ipbf ]->ipbfHeap == ipbf );
		if ( FBFWriteGreater( rgpbfHeap[ ipbfSonMax ], rgpbfHeap[ ipbf ] ))
			{
			BFHPISwap(ipbf, ipbfSonMax);
			ipbf = ipbfSonMax;
			goto NextLevel;
			}
		}
	}

/*
 *  when the weight of a node (ipbf) is increased, then we adjust the heap
 */
VOID BFWriteAdjustHeapUpward(int ipbf)
	{
	INT dpbf;
	INT dpbfParent;
	INT ipbfParent;
	INT ipbfSonMax;

	AssertCriticalSection( critBFWrite );

NextLevel:
	Assert( ipbf == rgpbfHeap[ipbf]->ipbfHeap );

	dpbf = ipbfHeapMax - 1 - ipbf;
	dpbfParent = (dpbf + 1) / 2 - 1;
	ipbfParent = ipbfHeapMax - 1 - dpbfParent;
	
	if ( ipbfParent < ipbfHeapMax - 1 )
		{
		/* haven't reach the top of heap */
			
		Assert( rgpbfHeap[ ipbfParent ]->ipbfHeap == ipbfParent );
		Assert( rgpbfHeap[ ipbf ]->ipbfHeap == ipbf );
		if ( FBFWriteGreater( rgpbfHeap[ ipbfParent ], rgpbfHeap[ ipbf ] ))
			return;
			
		/*  choose larger of this node and its sibling
		 */
		ipbfSonMax = ipbf;

		if ( dpbf & 0x01)
			{
			/*  odd, ipbf is Left son
			 */
			INT ipbfRight = ipbf - 1;
			
			/*  check if right son exist, find the larger one
			 */
			Assert( rgpbfHeap[ ipbf ]->ipbfHeap == ipbf );
			Assert( ipbfRight <= ipbfBFWriteHeapMac ||
					rgpbfHeap[ ipbfRight ]->ipbfHeap == ipbfRight );
			if ( ipbfRight > ipbfBFWriteHeapMac &&
				 FBFWriteGreater( rgpbfHeap[ ipbfRight ], rgpbfHeap[ ipbf ] ) )
				ipbfSonMax = ipbfRight;
			}
		else
			{
			/*  even, right son, left son must exists
			 */
		    INT ipbfLeft = ipbf + 1;
			Assert( rgpbfHeap[ ipbf ]->ipbfHeap == ipbf );
			Assert( rgpbfHeap[ ipbfLeft ]->ipbfHeap == ipbfLeft );
			if ( FBFWriteGreater( rgpbfHeap[ ipbfLeft ], rgpbfHeap[ ipbf ] ) )
				ipbfSonMax = ipbfLeft;
			}

		BFHPISwap(ipbfParent, ipbfSonMax);
		ipbf = ipbfParent;
		goto NextLevel;
		}
	}

/*
 *  put the inserted buffer at the end of heap, and then adjust upward
 */
VOID BFWriteAddToHeap( BF *pbfToInsert )
	{
	AssertCriticalSection( critBFWrite );

	/* buf must be a dangling buffer */
	Assert( pbfToInsert->ipbfHeap == ipbfDangling );
	
	rgpbfHeap[ ipbfBFWriteHeapMac ] = pbfToInsert;
	pbfToInsert->ipbfHeap = ipbfBFWriteHeapMac;
	
	ipbfBFWriteHeapMac--;
	BFWriteAdjustHeapUpward( ipbfBFWriteHeapMac + 1 );
	}

/*
 *  take the last entry of the heap to replace the one taken out.
 *  adjust heap accordingly.
 */
VOID BFWriteTakeOutOfHeap( BF *pbf )
	{
	INT ipbfHeap = pbf->ipbfHeap;
	BF *pbfBFWriteHeapMac;

	AssertCriticalSection( critBFWrite );
	Assert( ipbfHeap > ipbfBFWriteHeapMac && ipbfHeap < ipbfHeapMax );

	ipbfBFWriteHeapMac++;

	if ( ipbfBFWriteHeapMac == ipbfHeap )
		{
		/* no need to adjust the heap */
		pbf->ipbfHeap = ipbfDangling;
		return;
		}

	/* move last entry to the removed element's entry */
	pbfBFWriteHeapMac = rgpbfHeap[ ipbfBFWriteHeapMac ];
	pbfBFWriteHeapMac->ipbfHeap = ipbfHeap;
	rgpbfHeap[ ipbfHeap ] = pbfBFWriteHeapMac;

	pbf->ipbfHeap = ipbfDangling;

	if ( FBFWriteGreater( pbfBFWriteHeapMac, pbf ) )
		BFWriteAdjustHeapUpward( ipbfHeap );
	else
		BFWriteAdjustHeapDownward( ipbfHeap );
	}

#define FBFWriteHeapEmpty() (ipbfBFWriteHeapMac == ipbfHeapMax - 1)


/*********************************************************
 * 
 *  Heap functions for LRU-K heap
 *
 *********************************************************/

/*
 *  LRU-K will try to prioritize the buffer according to their buffer
 *  reference intervals. The longer the higher priority to be taken out.
 */
#define SBFLRUKInterval(pbf) ((pbf)->ulBFTime1 - (pbf)->ulBFTime2 )
BOOL FBFLRUKGreater(BF *pbf1, BF *pbf2)
	{
	return (SBFLRUKInterval(pbf1) > SBFLRUKInterval(pbf2));
	}

VOID BFLRUKAdjustHeapDownward(int ipbf)
	{
	INT dpbf;
	INT dpbfLeft;
	INT ipbfLeft;
	INT ipbfSonMax;

	AssertCriticalSection( critLRUK );
		
NextLevel:
	Assert( ipbf == rgpbfHeap[ipbf]->ipbfHeap );
	
	dpbf = ipbf;
	dpbfLeft = dpbf * 2 + 1;
	ipbfLeft = dpbfLeft;

	if (ipbfLeft < ipbfLRUKHeapMac)
		{
		/*  not reach the leaf yet, choose larger of
		 *  left and right node and put in ipbfSonMax.
		 */
		INT ipbfRight;
		
		ipbfSonMax = ipbfLeft;
		ipbfRight = ipbfLeft + 1;
		
		/*  check if right exist and greater */
		Assert( ipbfRight >= ipbfLRUKHeapMac ||
				rgpbfHeap[ ipbfRight ]->ipbfHeap == ipbfRight );
		Assert( rgpbfHeap[ ipbfLeft ]->ipbfHeap == ipbfLeft );
		if ( ipbfRight < ipbfLRUKHeapMac &&
			 FBFLRUKGreater( rgpbfHeap[ ipbfRight ], rgpbfHeap[ ipbfLeft ] ) )
			ipbfSonMax = ipbfRight;

		/* swap the node with larger son.
		 */
		Assert( rgpbfHeap[ ipbf ]->ipbfHeap == ipbf );
		Assert( rgpbfHeap[ ipbfSonMax ]->ipbfHeap == ipbfSonMax );
		if ( FBFLRUKGreater( rgpbfHeap[ ipbfSonMax ], rgpbfHeap[ ipbf ] ))
			{
			BFHPISwap(ipbf, ipbfSonMax);
			ipbf = ipbfSonMax;
			goto NextLevel;
			}
		}
	}

VOID BFLRUKAdjustHeapUpward(int ipbf)
	{
	INT dpbf;
	INT dpbfParent;
	INT ipbfParent;
	INT ipbfSonMax;

	AssertCriticalSection( critLRUK );

NextLevel:
	Assert( ipbf == rgpbfHeap[ipbf]->ipbfHeap );
	
	dpbf = ipbf;
	dpbfParent = (dpbf + 1) / 2 - 1;
	ipbfParent = dpbfParent;
	
	if (ipbfParent > 0)
		{
		/* haven't reach the top of heap */
			
		Assert( rgpbfHeap[ ipbf ]->ipbfHeap == ipbf );
		Assert( rgpbfHeap[ ipbfParent ]->ipbfHeap == ipbfParent );
		if ( FBFLRUKGreater( rgpbfHeap[ ipbfParent ], rgpbfHeap[ ipbf ] ))
			return;
			
		/*  choose larger of this node and its sibling
		 */
		ipbfSonMax = ipbf;
		
		if ( dpbf & 0x01 )
			{
			/*  ipbf is odd, ipbf is Left son
			 */
			INT ipbfRight = ipbf + 1;

			/*  check if right son exist and find larger son.
			 */
			Assert( rgpbfHeap[ ipbf ]->ipbfHeap == ipbf );
			Assert( ipbfRight >= ipbfLRUKHeapMac ||
					rgpbfHeap[ ipbfRight ]->ipbfHeap == ipbfRight );
			if ( ipbfRight < ipbfLRUKHeapMac &&
				 FBFLRUKGreater( rgpbfHeap[ ipbfRight ], rgpbfHeap[ ipbf ] ) )
				ipbfSonMax = ipbfRight;
			}
		else
			{
			/*  ipbf is even, right son, left son must exists
			 */
		    INT ipbfLeft = ipbf - 1;
			
			Assert( rgpbfHeap[ ipbfLeft ]->ipbfHeap == ipbfLeft );
			Assert( rgpbfHeap[ ipbf ]->ipbfHeap == ipbf );
			if ( FBFLRUKGreater( rgpbfHeap[ ipbfLeft ], rgpbfHeap[ ipbf ] ) )
				ipbfSonMax = ipbfLeft;
			}

		BFHPISwap(ipbfParent, ipbfSonMax);
		ipbf = ipbfParent;
		goto NextLevel;
		}
	}

VOID BFLRUKAddToHeap(BF *pbfToInsert)
	{
	AssertCriticalSection( critLRUK );

	/* buf can not in heap */
	Assert( pbfToInsert->ipbfHeap == ipbfDangling );
	
	rgpbfHeap[ ipbfLRUKHeapMac ] = pbfToInsert;
	pbfToInsert->ipbfHeap = ipbfLRUKHeapMac;
	
	ipbfLRUKHeapMac++;
	BFLRUKAdjustHeapUpward( ipbfLRUKHeapMac - 1 );
	}

VOID BFLRUKTakeOutOfHeap( BF *pbf )
	{
	int ipbfHeap = pbf->ipbfHeap;
	BF *pbfLRUKHeapMac;
	
	AssertCriticalSection( critLRUK );
	Assert( ipbfHeap >= 0 && ipbfHeap < ipbfLRUKHeapMac );
	
	ipbfLRUKHeapMac--;

	if ( ipbfLRUKHeapMac == ipbfHeap )
		{
		/* no need to adjust the heap */
		pbf->ipbfHeap = ipbfDangling;
		return;
		}

	/* move last entry to the removed element's entry */
	pbfLRUKHeapMac = rgpbfHeap[ ipbfLRUKHeapMac ];
	pbfLRUKHeapMac->ipbfHeap = ipbfHeap;
	rgpbfHeap[ ipbfHeap ] = pbfLRUKHeapMac;

	pbf->ipbfHeap = ipbfDangling;

	if ( FBFLRUKGreater( pbfLRUKHeapMac, pbf ) )
		BFLRUKAdjustHeapUpward( ipbfHeap );
	else
		BFLRUKAdjustHeapDownward( ipbfHeap );
	}

#define FBFLRUKHeapEmpty() (ipbfLRUKHeapMac == 0)

/*********************************************************
 * 
 *  Functions for Avail list
 *
 *********************************************************/

//#if 0
#ifdef DEBUG

LOCAL VOID CheckLRU( LRULIST *plrulist )
	{
	BF		*pbfLRU = plrulist->pbfLRU;
	BF		*pbfMRU = plrulist->pbfMRU;
	BF		*pbfT;
	INT		cbfAvailMRU = 0;
	INT		cbfAvailLRU = 0;
			

	Assert( ( pbfMRU == pbfNil && pbfLRU == pbfNil ) ||
		( pbfMRU != pbfNil && pbfLRU != pbfNil ) );

	Assert( pbfMRU == pbfNil || pbfMRU->pbfLRU == pbfNil );
	Assert( pbfMRU == pbfNil || pbfMRU->pbfMRU == pbfNil ||
		( pbfMRU->pbfMRU->pbfLRU == pbfMRU ) );
	
	Assert( pbfLRU == pbfNil || pbfLRU->pbfMRU == pbfNil );
	Assert( pbfLRU == pbfNil || pbfLRU->pbfLRU == pbfNil ||
		( pbfLRU->pbfLRU->pbfMRU == pbfLRU ) );

	for ( pbfT = plrulist->pbfMRU; pbfT != pbfNil; pbfT = pbfT->pbfMRU )
		{
		Assert( pbfT->pbfMRU == pbfNil || pbfT->pbfMRU->pbfLRU == pbfT );
		if (plrulist == &lrulistLRUK)
			Assert( pbfT->ipbfHeap == ipbfInLRUKList );
		else if (plrulist == &lrulistPreread)
			{
			Assert( pbfT->fPreread );
			Assert( pbfT->ipbfHeap == ipbfInPrereadList );
			if ( pbfT->pbfMRU != pbfNil )
				Assert( pbfT->pn < pbfT->pbfMRU->pn );
			}
		else
			Assert( pbfT->ipbfHeap == ipbfInAvailList );
		cbfAvailMRU++;
		}
	for ( pbfT = plrulist->pbfLRU; pbfT != pbfNil; pbfT = pbfT->pbfLRU )
		{
		Assert( pbfT->pbfLRU == pbfNil || pbfT->pbfLRU->pbfMRU == pbfT );
		if (plrulist == &lrulistLRUK)
			Assert( pbfT->ipbfHeap == ipbfInLRUKList );
		else if (plrulist == &lrulistPreread)
			Assert( pbfT->ipbfHeap == ipbfInPrereadList );
		else
			Assert( pbfT->ipbfHeap == ipbfInAvailList );
		cbfAvailLRU++;
		}
	Assert( cbfAvailMRU == cbfAvailLRU );
	Assert( cbfAvailMRU == plrulist->cbfAvail );
	}
#else

#define	CheckLRU( pbgcb )

#endif


/*	Insert into LRU list at MRU End
/**/
LOCAL INLINE VOID BFAddToListAtMRUEnd( BF *pbf, LRULIST *plrulist )
	{
	BF	*pbfT;
	
#ifdef DEBUG
	Assert( pbf->ipbfHeap == ipbfDangling );
	if (plrulist == &lrulistLRUK)
		AssertCriticalSection( critLRUK );
	else if (plrulist == &lrulistPreread)
		AssertCriticalSection( critPreread );
	else
		{
		AssertCriticalSection( critAvail );
		Assert( pbf->pn != 0 );
		}
#endif
		
	Assert( pbf != pbfNil );

	CheckLRU( plrulist );

	/*	set pbfT to first buffer with smaller current weight from MRU end
	/**/
	pbfT = plrulist->pbfMRU;

	if ( pbfT != pbfNil )
		{
		/*	insert before pbfT
		/**/
		Assert(pbfT->pbfLRU == pbfNil);
		pbfT->pbfLRU = pbf;
		pbf->pbfMRU = pbfT;
		pbf->pbfLRU = pbfNil;
		plrulist->pbfMRU = pbf;
		}
	else
		{
		pbf->pbfMRU = pbfNil;
		pbf->pbfLRU = pbfNil;
		plrulist->pbfMRU = pbf;
		plrulist->pbfLRU = pbf;
		}

	if (plrulist == &lrulistLRUK)
		pbf->ipbfHeap = ipbfInLRUKList;
	else if (plrulist == &lrulistPreread)
		pbf->ipbfHeap = ipbfInPrereadList;
	else
		pbf->ipbfHeap = ipbfInAvailList;

	plrulist->cbfAvail++;

	CheckLRU( plrulist );
	}

LOCAL INLINE VOID BFAddToListAtLRUEnd( BF *pbf, LRULIST *plrulist )
	{
	BF	*pbfT;
	
#ifdef DEBUG
	Assert( pbf->ipbfHeap == ipbfDangling );
	if (plrulist == &lrulistLRUK)
		AssertCriticalSection( critLRUK );
	else if (plrulist == &lrulistPreread)
		AssertCriticalSection( critPreread );
	else
		AssertCriticalSection( critAvail );
#endif
	
	Assert( pbf != pbfNil );

	CheckLRU( plrulist );

	/*	add pbf to LRU end of LRU queue
	/**/
	pbfT = plrulist->pbfLRU;
	if ( pbfT != pbfNil )
		{
		Assert(pbfT->pbfMRU == pbfNil);
		pbfT->pbfMRU = pbf;
		pbf->pbfLRU = pbfT;
		pbf->pbfMRU = pbfNil;
		plrulist->pbfLRU = pbf;
		}
	else
		{
		pbf->pbfMRU = pbfNil;
		pbf->pbfLRU = pbfNil;
		plrulist->pbfMRU = pbf;
		plrulist->pbfLRU = pbf;
		}

	if (plrulist == &lrulistLRUK)
		pbf->ipbfHeap = ipbfInLRUKList;
	else if (plrulist == &lrulistPreread)
		pbf->ipbfHeap = ipbfInPrereadList;
	else
		pbf->ipbfHeap = ipbfInAvailList;

	plrulist->cbfAvail++;

	CheckLRU( plrulist );
	}


/*	Insert into LRU list in page number order. Preread only.
/**/
LOCAL INLINE VOID BFAddToList( BF *pbf, LRULIST *plrulist )
	{
	BF	*pbfT;
	
#ifdef DEBUG
	Assert( pbf->ipbfHeap == ipbfDangling );
	Assert( plrulist == &lrulistPreread );
	AssertCriticalSection( critPreread );

	Assert( pbf != pbfNil );
	Assert( pbf->pn != pnNull );
#endif

	CheckLRU( plrulist );

	/*	set pbfT to first buffer with smaller current weight from MRU end
	/**/
	pbfT = plrulist->pbfMRU;

	if ( pbfT == pbfNil )
		{
		pbf->pbfMRU = pbfNil;
		pbf->pbfLRU = pbfNil;
		plrulist->pbfMRU = pbf;
		plrulist->pbfLRU = pbf;
		}
	else if ( pbfT->pn > pbf->pn )
		{
		BFAddToListAtMRUEnd( pbf, plrulist );
		CheckLRU( plrulist );
		return;
		}
	else
		{
		while( pbfT->pbfMRU != pbfNil &&
			   pbfT->pbfMRU->pn < pbf->pn )
			{
			Assert( pbfT->pn < pbfT->pbfMRU->pn );
			pbfT = pbfT->pbfMRU;
			}

		if ( pbfT->pbfMRU == pbfNil )
			{
			/* add to lru end */
			BFAddToListAtLRUEnd( pbf, plrulist );
			CheckLRU( plrulist );
			return;
			}

		/* insert between pbfT and pbfT->pbfMRU */
		pbfT->pbfMRU->pbfLRU = pbf;
		pbf->pbfMRU = pbfT->pbfMRU;
		pbfT->pbfMRU = pbf;
		pbf->pbfLRU = pbfT;
		}

	pbf->ipbfHeap = ipbfInPrereadList;
	plrulist->cbfAvail++;

	CheckLRU( plrulist );
	}


LOCAL INLINE VOID BFTakeOutOfList( BF *pbf, LRULIST *plrulist )
	{
#ifdef DEBUG
	if (plrulist == &lrulistLRUK)
		{
		AssertCriticalSection( critLRUK );
		Assert( pbf->ipbfHeap == ipbfInLRUKList );
		}
	else if (plrulist == &lrulistPreread)
		{
		AssertCriticalSection( critPreread );
		Assert( pbf->ipbfHeap == ipbfInPrereadList );
		}
	else
		{
		AssertCriticalSection( critAvail );
		Assert( pbf->ipbfHeap == ipbfInAvailList );
		}
#endif
	
	Assert( pbf != pbfNil );

	CheckLRU( plrulist );
	
	if ( pbf->pbfMRU != pbfNil )
		{
		pbf->pbfMRU->pbfLRU = pbf->pbfLRU;
		if (plrulist->pbfMRU == pbf)
			plrulist->pbfMRU = pbf->pbfMRU;
		}
	else
		{
		Assert( plrulist->pbfLRU == pbf );
		plrulist->pbfLRU = pbf->pbfLRU;
		}
	
	if ( pbf->pbfLRU != pbfNil )
		{
		pbf->pbfLRU->pbfMRU = pbf->pbfMRU;
		if (plrulist->pbfLRU == pbf)
			plrulist->pbfLRU = pbf->pbfLRU;
		}
	else
		{
		Assert( plrulist->pbfMRU == pbf || pbf->pbfMRU );
		plrulist->pbfMRU = pbf->pbfMRU;
		}
	
	--plrulist->cbfAvail;

	pbf->ipbfHeap = ipbfDangling;
	
	CheckLRU( plrulist );
	}


/*
 *  If ppib is Nil, then we check if the buffer is free (cPin == 0 and
 *  no IO is going on. If ppib is not Nil, we check if the buffer is
 *  accessible. I.e. No IO is going on, but the buffer may be latched
 *  by the ppib and is accessible by this ppib.
 */
BOOL FBFHoldBuffer( PIB *ppib, BF *pbf )
	{
	/* renew BF by moving it to LRU-K heap
	/**/
	EnterCriticalSection(critBFWrite);
	if ( FBFInBFWriteHeap( pbf ) )
		{
		EnterCriticalSection( pbf->critBF );
		if ( FBFInUse( ppib, pbf ) )
			{
			LeaveCriticalSection( pbf->critBF );
			LeaveCriticalSection(critBFWrite);
			return fFalse;
			}
		else
			{
			pbf->fHold = fTrue;
			LeaveCriticalSection( pbf->critBF );
			BFWriteTakeOutOfHeap( pbf );
			LeaveCriticalSection(critBFWrite);
			return fTrue;
			}
		LeaveCriticalSection( pbf->critBF );
		}
	LeaveCriticalSection(critBFWrite);

	EnterCriticalSection( critAvail );
	if ( pbf->ipbfHeap == ipbfInAvailList )
		{
		EnterCriticalSection( pbf->critBF );
		if ( FBFInUse( ppib, pbf ) )
			{
			LeaveCriticalSection( pbf->critBF );
			LeaveCriticalSection(critAvail);
			return fFalse;
			}
		else
			{
			pbf->fHold = fTrue;
			LeaveCriticalSection( pbf->critBF );
			BFTakeOutOfList( pbf, &pbgcb->lrulist );
			LeaveCriticalSection(critAvail);
			return fTrue;
			}
		LeaveCriticalSection( pbf->critBF );
		}
	LeaveCriticalSection( critAvail );

	EnterCriticalSection( critPreread );
	if ( pbf->ipbfHeap == ipbfInPrereadList )
		{
		Assert( FBFInUse( ppib, pbf ) );
		LeaveCriticalSection(critPreread);
		
		/* someone is checking, better hurry up
		/**/
		SignalSend( sigBFPrereadProc );
	
		return fFalse;
		}
	LeaveCriticalSection( critPreread );
	
	EnterCriticalSection( critLRUK );
	if ( FBFInLRUKHeap( pbf ) || pbf->ipbfHeap == ipbfInLRUKList )
		{
		EnterCriticalSection( pbf->critBF );
		if ( FBFInUse( ppib, pbf ) )
			{
			LeaveCriticalSection( pbf->critBF );
			LeaveCriticalSection(critLRUK);
			return fFalse;
			}
		else
			{
			pbf->fHold = fTrue;
			LeaveCriticalSection( pbf->critBF );
			if ( pbf->ipbfHeap == ipbfInLRUKList )
				BFTakeOutOfList( pbf, &lrulistLRUK );
			else
				BFLRUKTakeOutOfHeap( pbf );
			LeaveCriticalSection(critLRUK);
			return fTrue;
			}
		LeaveCriticalSection( pbf->critBF );
		}
	LeaveCriticalSection( critLRUK );
	
	EnterCriticalSection( pbf->critBF );
	if ( pbf->ipbfHeap == ipbfDangling ) /* dangling */
		{
		if ( FBFInUse( ppib, pbf ) )
			{
			LeaveCriticalSection( pbf->critBF );
			return fFalse;
			}
		else
			{
			pbf->fHold = fTrue;
			LeaveCriticalSection( pbf->critBF );
			return fTrue;
			}
		}
	LeaveCriticalSection( pbf->critBF );

	return fFalse;	
	}

	
BOOL FBFHoldBufferByMe( PIB *ppib, BF *pbf )
	{
	AssertCriticalSection( critJet );
	
	/* renew BF by moving it to LRU-K heap
	/**/
	EnterCriticalSection(critBFWrite);
	if ( FBFInBFWriteHeap( pbf ) )
		{
		EnterCriticalSection( pbf->critBF );
		if ( FBFInUseByOthers( ppib, pbf ) )
			{
			LeaveCriticalSection( pbf->critBF );
			LeaveCriticalSection(critBFWrite);
			return fFalse;
			}
		else
			{
			pbf->fHold = fTrue;
			LeaveCriticalSection( pbf->critBF );
			BFWriteTakeOutOfHeap( pbf );
			LeaveCriticalSection(critBFWrite);
			return fTrue;
			}
		LeaveCriticalSection( pbf->critBF );
		}
	LeaveCriticalSection(critBFWrite);

	EnterCriticalSection( critAvail );
	if ( pbf->ipbfHeap == ipbfInAvailList )
		{
		EnterCriticalSection( pbf->critBF );
		if ( FBFInUseByOthers( ppib, pbf ) )
			{
			LeaveCriticalSection( pbf->critBF );
			LeaveCriticalSection(critAvail);
			return fFalse;
			}
		else
			{
			pbf->fHold = fTrue;
			LeaveCriticalSection( pbf->critBF );
			BFTakeOutOfList( pbf, &pbgcb->lrulist );
			LeaveCriticalSection(critAvail);
			return fTrue;
			}
		LeaveCriticalSection( pbf->critBF );
		}
	LeaveCriticalSection( critAvail );

	EnterCriticalSection( critPreread );
	if ( pbf->ipbfHeap == ipbfInPrereadList )
		{
		Assert( FBFInUse( ppib, pbf ) );
		LeaveCriticalSection(critPreread);
		
		/* someone is checking, better hurry up. */
		SignalSend( sigBFPrereadProc );
	
		return fFalse;
		}
	LeaveCriticalSection( critPreread );
	
	EnterCriticalSection( critLRUK );
	if ( FBFInLRUKHeap( pbf ) || pbf->ipbfHeap == ipbfInLRUKList )
		{
		EnterCriticalSection( pbf->critBF );
		if ( FBFInUseByOthers( ppib, pbf ) )
			{
			LeaveCriticalSection( pbf->critBF );
			LeaveCriticalSection(critLRUK);
			return fFalse;
			}
		else
			{
			pbf->fHold = fTrue;
			LeaveCriticalSection( pbf->critBF );
			if ( pbf->ipbfHeap == ipbfInLRUKList )
				BFTakeOutOfList( pbf, &lrulistLRUK );
			else
				BFLRUKTakeOutOfHeap( pbf );
			LeaveCriticalSection(critLRUK);
			return fTrue;
			}
		LeaveCriticalSection( pbf->critBF );
		}
	LeaveCriticalSection( critLRUK );
	
	EnterCriticalSection( pbf->critBF );
	if ( pbf->ipbfHeap == ipbfDangling ) /* dangling */
		{
		if ( FBFInUseByOthers( ppib, pbf ) )
			{
			LeaveCriticalSection( pbf->critBF );
			return fFalse;
			}
		else
			{
			pbf->fHold = fTrue;
			LeaveCriticalSection( pbf->critBF );
			return fTrue;
			}
		}
	LeaveCriticalSection( pbf->critBF );

	return fFalse;	
	}
	
/*
 * update the buffer's LRUK weight and check
 * if the buffer is in LRUK heap. if it is, then adjust the heap, 
 * otherwise inter it into the heap.
 */

VOID BFUpdateLRU_KWeight(BF *pbf)
	{
	ULONG ulOldInterval;
	ULONG ulCurInterval;
	
	AssertCriticalSection( critLRUK );
	Assert( pbf->fHold );
	Assert( pbf->ipbfHeap == ipbfDangling );

	ulOldInterval = pbf->ulBFTime1 - pbf->ulBFTime2;
	ulCurInterval = ulBFTime - pbf->ulBFTime1;
	
	/*  Set LRU_K Weight only the interval is longer than
	 *  correlation interval.
	 */
	if ( ulCurInterval > ulBFCorrelationInterval )
		{
		pbf->ulBFTime2 = pbf->ulBFTime1;
		pbf->ulBFTime1 = ++ulBFTime;
		}

	AssertCriticalSection( critLRUK );
	if (pbf->ipbfHeap == ipbfInLRUKList)
		/*  in LRUK temp list
		 */
		return;

	if ( pbf->ipbfHeap >= ipbfLRUKHeapMac || pbf->ipbfHeap < 0 )
		{
		/*  the buffer is not in LRUK heap.
		 */
		BFLRUKAddToHeap(pbf);
		}
	else
		{
		/*  the buffer is in LRUK heap.
		 */
		if ( ulCurInterval > ulOldInterval )
			BFLRUKAdjustHeapUpward( pbf->ipbfHeap );
		else if ( ulCurInterval < ulOldInterval )
			BFLRUKAdjustHeapDownward( pbf->ipbfHeap );
		}
	}


#ifdef DEBUG
VOID BFDiskIOEvent( BF *pbf, ERR err, char *sz, int i1, int i2 )
	{
	BYTE szMessage[256];

	sprintf( szMessage, "(dbid=%d,pn=%lu,err=%d) %s %d %d ",
				DbidOfPn( pbf->pn ), PgnoOfPn( pbf->pn ), err, sz, i1, i2 );
	UtilWriteEvent( evntypDiskIO, szMessage, pNil, 0 );
	}
#else
#define BFDiskIOEvent( pbf, err, sz, i1, i2 )		0
#endif


/* 
 *  Allocates and initializes buffer management data structures, including
 *  one buffer group (BGCB) with cbfInit pages and buffer control
 *  blocks (BF).  Currently only one BGCB is ever used by the buffer manager.
 *  RETURNS     JET_errSuccess, JET_OutOfMemory
 *
 *  COMMENTS
 *         Most of the current BUF code assumes there is EXACTLY ONE BGCB.
 *         This can be changed later if a use for multiple buffer groups is
 *         seen.
 */
ERR ErrBFInit( VOID )
	{
	ERR     err;
	BF      *rgbf = NULL;
	BF      *pbf;
	PAGE	*rgpage = NULL;
	int     ibf;
	int     cbfInit = rgres[iresBF].cblockAlloc;

	Assert( pbfNil == 0 );
	Assert( cbfInit > 0 );

	/* initialize buffer hash table
	/**/
	memset( (BYTE *)rgpbfHash, 0, sizeof(rgpbfHash));

	/* get memory for BF's
	/**/
	rgbf = LAlloc( (long) cbfInit, sizeof(BF) );
	if ( rgbf == NULL )
		goto HandleError;
	memset( rgbf, 0, cbfInit * sizeof(BF) );

	//	UNDONE: eliminate bgcb as resource, make it local
	/* get memory for pbgcb
	/**/
	pbgcb = PbgcbMEMAlloc();
	if ( pbgcb == NULL )
		goto HandleError;

	/* get memory for page buffers
	/**/
	rgpage = (PAGE *)PvSysAllocAndCommit( cbfInit * cbPage );
	if ( rgpage == NULL )
		goto HandleError;

	/* allocate a heap array
	/**/
	rgpbfHeap = LAlloc( (long) cbfInit, sizeof(BF *) );
	if ( rgpbfHeap == NULL )
		goto HandleError;
	ipbfHeapMax = cbfInit;

	/* initially both lruk and BFWrite heaps are empty
	/**/
	ipbfLRUKHeapMac = 0;
	ipbfBFWriteHeapMac = ipbfHeapMax - 1;

	/* initialize lruk temp list as empty list
	/**/
	memset( &lrulistLRUK, 0, sizeof(lrulistLRUK));

	/* initialize preread list as empty list
	/**/
	memset( &lrulistPreread, 0, sizeof(lrulistPreread) );

	/* initialize batch IO buffers
	/**/	
	ipageBatchIOMax = lBufBatchIOMax;
	rgpageBatchIO = (PAGE *) PvSysAllocAndCommit( ipageBatchIOMax * cbPage );
	if ( rgpageBatchIO == NULL )
		goto HandleError;
	
	rgfBatchIOUsed = LAlloc( (ipageBatchIOMax + 1), sizeof(BOOL) );
	if ( rgfBatchIOUsed == NULL )
		goto HandleError;
	memset( rgfBatchIOUsed, 0, ipageBatchIOMax * sizeof(BOOL) );
	rgfBatchIOUsed[ ipageBatchIOMax ] = fTrue; /* sentinal */

	Call( ErrInitializeCriticalSection( &critLRUK ) );
	Call( ErrInitializeCriticalSection( &critBFWrite ) );
	Call( ErrInitializeCriticalSection( &critPreread ) );
	Call( ErrInitializeCriticalSection( &critAvail ) );
	Call( ErrInitializeCriticalSection( &critBatchIO ) );
	Call( ErrInitializeCriticalSection( &critIOActive ) );

	/*  initialize the group buffer
	/*  lBufThresholdLowPercent and lBufThresholdHighPercent are system
	/*  parameters note AddLRU will increment cbfAvail.
	/**/
	pbgcb->cbfGroup         = cbfInit;
	pbgcb->cbfThresholdLow  = (cbfInit * lBufThresholdLowPercent) / 100;
	pbgcb->cbfThresholdHigh = (cbfInit * lBufThresholdHighPercent) / 100;
	pbgcb->rgbf             = rgbf;
	pbgcb->rgpage           = rgpage;
	pbgcb->lrulist.cbfAvail = 0;
	pbgcb->lrulist.pbfMRU   = pbfNil;
	pbgcb->lrulist.pbfLRU   = pbfNil;

	/* initialize the BF's of this group
	/**/
	pbf = rgbf;
	for ( ibf = 0; ibf < cbfInit; ibf++ )
		{
		pbf->ppage = rgpage + ibf;
		Assert( pbf->pbfNext == pbfNil );
		Assert( pbf->pbfLRU == pbfNil );
		Assert( pbf->pbfMRU == pbfNil );
		Assert( pbf->pn == pnNull );
		Assert( pbf->cPin == 0 );
		Assert( pbf->fDirty == fFalse );
		Assert( pbf->fPreread == fFalse );
		Assert( pbf->fRead == fFalse );
		Assert( pbf->fWrite == fFalse );
		Assert( pbf->fHold == fFalse );
		Assert( pbf->fIOError == fFalse );

		Assert( pbf->cDepend == 0 );
		Assert( pbf->pbfDepend == pbfNil );
		
		pbf->lgposRC = lgposMax;
		Assert( CmpLgpos(&pbf->lgposModify, &lgposMin) == 0 );

		Call( ErrSignalCreate( &pbf->olp.sigIO, NULL ) );

		Call( ErrInitializeCriticalSection( &pbf->critBF ) );

		/* make a list of available buffers
		/**/
		Assert( pbf->cPin == 0 );
		EnterCriticalSection( critAvail );
		pbf->ipbfHeap = ipbfDangling;	/* make it dangling */
		BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
		LeaveCriticalSection( critAvail );

		Assert( pbf->ipbfHeap == ipbfInAvailList );
		pbf++;
		}
	Assert( (INT) pbgcb->lrulist.cbfAvail == cbfInit );

#ifdef  ASYNC_BF_CLEANUP

	Call( ErrSignalCreate( &sigBFCleanProc, "buf proc signal" ) ); 
	Call( ErrSignalCreateAutoReset( &sigBFWriteProc, "buf write proc signal" ) );
	Call( ErrSignalCreateAutoReset( &sigBFPrereadProc, "buf preread proc signal" ) );

	//	UNDONE: temporary fix
#define cbBFCleanStackSz        8192                    

	fBFCleanProcessTerm = fFalse;
	Call( ErrSysCreateThread( (ULONG (*) ()) BFCleanProcess,
		cbBFCleanStackSz,
		lThreadPriorityCritical,
		&handleBFCleanProcess ) );

	fBFWriteProcessTerm = fFalse;
	CallJ( ErrSysCreateThread( (ULONG (*) ()) BFWriteProcess,
		cbBFCleanStackSz,
		lThreadPriorityCritical,
		&handleBFWriteProcess ), TermBFProc );

	fBFPrereadProcessTerm = fFalse;
	CallJ( ErrSysCreateThread( (ULONG (*) ()) BFPrereadProcess,
		cbBFCleanStackSz,
		lThreadPriorityCritical,
		&handleBFPrereadProcess ), TermBFProc );
	
#else   /* !ASYNC_BF_CLEANUP */
	NotUsed( err );
#endif  /* !ASYNC_BF_CLEANUP */

	return JET_errSuccess;

TermBFProc:
	BFTermProc();

HandleError:
	if ( rgfBatchIOUsed != NULL )
		{
		LFree( rgfBatchIOUsed );
		rgfBatchIOUsed = NULL;
		}
		
	if ( rgpageBatchIO != NULL )
		{
		SysFree( rgpageBatchIO );
		rgpageBatchIO = NULL;
		}
		
	if ( rgpbfHeap != NULL )
		LFree( rgpbfHeap );
	
	if ( rgpage != NULL )
		SysFree( rgpage );
	
	if ( pbgcb != NULL )
		MEMReleasePbgcb( pbgcb );
	
	if ( rgbf != NULL )
		LFree( rgbf );
	
	return JET_errOutOfMemory;
	}


VOID BFSleep( unsigned long ulMSecs )
	{
	LgLeaveCriticalSection( critJet );
	SysSleep( ulMSecs );
	LgEnterCriticalSection( critJet );
	return;
	}

/*      releases all resources allocated by buffer pool.
/**/
VOID BFTermProc( VOID )
	{
#ifdef  ASYNC_BF_CLEANUP
	/*  terminate BFCleanProcess.
	/*  Set termination flag, signal process
	/*  and busy wait for thread termination code.
	/**/
	if ( handleBFCleanProcess != 0 )
		{
		fBFCleanProcessTerm = fTrue;
		do
			{
			SignalSend( sigBFCleanProc );
			BFSleep( cmsecWaitGeneric );
			}
		while ( !FSysExitThread( handleBFCleanProcess ) );
		CallS( ErrSysCloseHandle( handleBFCleanProcess ) );
		handleBFCleanProcess = 0;
		SignalClose(sigBFCleanProc);
		}
		
	if ( handleBFWriteProcess != 0 )
		{
		fBFWriteProcessTerm = fTrue;
		do
			{
			SignalSend( sigBFWriteProc );
			BFSleep( cmsecWaitGeneric );
			}
		while ( !FSysExitThread( handleBFWriteProcess ) );
		CallS( ErrSysCloseHandle( handleBFWriteProcess ) );
		handleBFWriteProcess = 0;
		SignalClose(sigBFWriteProc);
		}
	
	if ( handleBFPrereadProcess != 0 )
		{
		fBFPrereadProcessTerm = fTrue;
		do
			{
			SignalSend( sigBFPrereadProc );
			BFSleep( cmsecWaitGeneric );
			}
		while ( !FSysExitThread( handleBFPrereadProcess ) );
		CallS( ErrSysCloseHandle( handleBFPrereadProcess ));
		handleBFPrereadProcess = 0;
		SignalClose(sigBFPrereadProc);
		}
#endif

	}


VOID BFReleaseBF( VOID )
	{
	BF  *pbf, *pbfMax;
		
	/* last chance to do checkpoint! */
	LGUpdateCheckpoint( );

	/* release memory
	/**/
	pbf = pbgcb->rgbf;
	pbfMax = pbf + pbgcb->cbfGroup;

	for ( ; pbf < pbfMax; pbf++ )
		{
		SignalClose(pbf->olp.sigIO);
		DeleteCriticalSection( pbf->critBF );
		}

	DeleteCriticalSection( critLRUK );
	DeleteCriticalSection( critBFWrite );
	DeleteCriticalSection( critPreread );
	DeleteCriticalSection( critAvail );
	DeleteCriticalSection( critBatchIO );
	DeleteCriticalSection( critIOActive );

	if ( rgpbfHeap != NULL )
		{
		LFree( rgpbfHeap );
		rgpbfHeap = NULL;
		}
		
	if ( pbgcb != NULL )
		{
		SysFree( pbgcb->rgpage );
		LFree( pbgcb->rgbf );
		MEMReleasePbgcb( pbgcb );
		pbgcb = NULL;
		}
	
	if ( rgfBatchIOUsed != NULL )
		{
		LFree( rgfBatchIOUsed );
		rgfBatchIOUsed = NULL;
		}
		
	if ( rgpageBatchIO != NULL )
		{
		SysFree( rgpageBatchIO );
		rgpageBatchIO = NULL;
		}
	}


VOID BFDirty( BF *pbf )
	{
	DBID dbid = DbidOfPn( pbf->pn );

	BFSetDirtyBit( pbf );

#ifdef HONOR_PAGE_TIME
    /*	set ulDBTime for logging and also for multiple cursor
	/*	maintenance, so that cursors can detect a change.
	/**/
	Assert( fRecovering ||
		dbid == dbidTemp ||
		pbf->ppage->pghdr.ulDBTime <= rgfmp[ dbid ].ulDBTime );
	pbf->ppage->pghdr.ulDBTime = ++( rgfmp[ dbid ].ulDBTime );
#else
	if ( pbf->ppage->pghdr.ulDBTime > rgfmp[dbid].ulDBTime )
		{
		rgfmp[dbid].ulDBTime = pbf->ppage->pghdr.ulDBTime;
		}
	pbf->ppage->pghdr.ulDBTime = ++( rgfmp[ dbid ].ulDBTime );
#endif

	return;
	}


#ifdef CHECKSUM
//+api------------------------------------------------------------------------
//
//  UlChecksumPage
//  ===========================================================================
//
//  UlChecksumPage( PAGE *ppage )
//
//  fastcall is safe, even if it is used the parameters are immediately
//  move to edi and esi
//
//----------------------------------------------------------------------------

/*  calculate checksum, exclude ulChecksum field which is on the first
 *  4 byte of a page.
 */
INLINE ULONG UlChecksumPage( PAGE *ppage )
	{
	ULONG   *pul    = (ULONG *) ( (BYTE *) ppage + sizeof(ULONG) );
	ULONG   *pulMax = (ULONG *) ( (BYTE *) ppage + cbPage );
	ULONG   ulChecksum = 0;

	for ( ; pul < pulMax; pul++ )
		ulChecksum += *pul;

	return ulChecksum;
	}
#endif


/*
 *  This function issue a read/write. The caller must have setup the buffer
 *  with fRead/fWrite flag set so that no other can access it. The buffer
 *  does not need to be a dangling one.
 **/
VOID BFIOSync( BF *pbf )
	{
	ERR     err;
	UINT    cb;

	PAGE    *ppage = pbf->ppage;
	PN      pn = pbf->pn;
	DBID    dbid = DbidOfPn( pn );
	FMP     *pfmp = &rgfmp[ dbid ];
	HANDLE  hf = pfmp->hf;

	PGNO    pgno;
	INT		cmsec;

	AssertCriticalSection( critJet );

	Assert( PgnoOfPn(pbf->pn) != pgnoNull );
	Assert( pbf->fPreread == fFalse );
	Assert( pbf->cDepend == 0 );

	/*	set 64 bit offset
	/**/
	Assert( sizeof(PAGE) == 1 << 12 );
	pgno = PgnoOfPn(pn);
	pgno--;

	pbf->olp.ulOffset = pgno << 12;
	pbf->olp.ulOffsetHigh = pgno >> (32 - 12);

	Assert( hf != handleNil );

	/* issue a synchronous read/write
	/**/

	/*  reset sigIO so that users can wait for IO to finish if
	/*  they want to wait.
	/**/
	SignalReset( pbf->olp.sigIO );

	/*  if error, ignore it, try to do the read/write again
	/**/
	pbf->fIOError = fFalse;

	/* make sure this page is not being fRead and fWrite
	/**/
	Assert( !pbf->fHold && ( pbf->fRead || pbf->fWrite ) );

	LeaveCriticalSection( critJet );

	cmsec = 1 << 4;
	
	if ( pbf->fRead )
		{
		Assert( pbf->fDirty == fFalse );

IssueReadOverlapped:
		err = ErrSysReadBlockOverlapped( hf, (BYTE *)ppage, cbPage, &cb, &pbf->olp);
		if ( err == JET_errTooManyIO )
			{
			cmsec <<= 1;
			SysSleep(cmsec - 1);
			goto IssueReadOverlapped;
			}
		if ( err < 0 )
			{
//			BFDiskIOEvent( pbf, err, "Sync overlapped ReadBlock Fails",0,0 );
			goto ReturnDiskIOErr;
			}
			
		if ( ErrSysGetOverlappedResult( hf, &pbf->olp, &cb, fTrue ) != JET_errSuccess ||
			cb != sizeof(PAGE) )
			{
//			BFDiskIOEvent( pbf, err, "Sync overlapped read GetResult Fails",0,0 );
			err = JET_errDiskIO;

ReturnDiskIOErr:
			EnterCriticalSection( critJet );

			/* make sure err is set at this point
			/**/
			Assert( err != JET_errSuccess );
			pbf->fIOError = fTrue;
			pbf->err = err;

			return;
			}

		EnterCriticalSection( critJet );

		#ifdef  CHECKSUM
		Assert ( err == JET_errSuccess );
			{
			ULONG ulChecksum = UlChecksumPage( ppage );
			ULONG ulPgno;

			LFromThreeBytes(ulPgno, ppage->pgnoThisPage);
			if ( ulChecksum != ppage->pghdr.ulChecksum ||
				ulPgno != PgnoOfPn( pbf->pn ) )
				{
				//	UNDONE:	remove assertion after IO error buf fixed
				Assert( fRecovering );
				err = JET_errReadVerifyFailure;
				}
			else
				{
//				Assert( DbidOfPn( pbf->pn ) == dbidTemp || pbf->ppage->pghdr.ulDBTime > 0 );
				}
			}
		#endif  /* CHECKSUM */

#ifdef HONOR_PAGE_TIME
		if ( err == JET_errSuccess &&
			!fRecovering &&
			dbid != dbidTemp &&
			pbf->ppage->pghdr.ulDBTime > rgfmp[ dbid ].ulDBTime )
			{
			BFDiskIOEvent( pbf, err, "Sync overlapped read UlDBTime is bad",
					pbf->ppage->pghdr.ulDBTime, rgfmp[ dbid ].ulDBTime );
			err = JET_errDiskIO;
			}
#endif
		}
	else
		{
		Assert( pbf->fDirty == fTrue );

		/* if it is first page, do an in-place update ulDBTime
		/**/
		if ( !fRecovering && dbid != dbidTemp && PgnoOfPn( pbf->pn ) == 1 )
			{
			SSIB ssib;
			ULONG *pulDBTime;

			ssib.pbf = pbf;
			ssib.itag = 0;
			CallS( ErrPMGet( &ssib, ssib.itag ) );
			pulDBTime = (ULONG *) ( ssib.line.pb + ssib.line.cb -
		  		sizeof(ULONG) - sizeof(USHORT) );
			*(UNALIGNED ULONG *) pulDBTime = rgfmp[ dbid ].ulDBTime;
			}

//		Assert( DbidOfPn( pbf->pn ) == dbidTemp || ppage->pghdr.ulDBTime > 0 );
		
		#ifdef  CHECKSUM
		ppage->pghdr.ulChecksum = UlChecksumPage( ppage );
#ifdef HONOR_PAGE_TIME
		Assert( fRecovering ||
			DbidOfPn((pbf)->pn) == dbidTemp ||
			pbf->ppage->pghdr.ulDBTime <= rgfmp[ DbidOfPn((pbf)->pn) ].ulDBTime );
#endif
		
		CheckPgno( pbf->ppage, pbf->pn ) ;
		
		#endif  /* CHECKSUM */

#ifdef DEBUG
#ifdef FITFLUSHPATTERN
		if ( !FFitFlushPattern( pn ) )
			{
			err = JET_errDiskIO;
			goto ReturnDiskIOErr;
			}
#endif
#endif

IssueWriteOverlapped1:
		err = ErrSysWriteBlockOverlapped(
				hf, (BYTE *)ppage, cbPage, &cb, &pbf->olp );
		if ( err == JET_errTooManyIO )
			{
			cmsec <<= 1;
			SysSleep(cmsec - 1);
			goto IssueWriteOverlapped1;
			}
		if ( err < 0 )
			{
			BFDiskIOEvent( pbf, err, "Sync overlapped WriteBlock Fails",0,0 );
			goto ReturnDiskIOErr;
			}

		/*  if write fail, do not clean up this buffer!
		/**/
		if ( ( err = ErrSysGetOverlappedResult(
			hf, &pbf->olp, &cb, fTrue ) ) != JET_errSuccess ||
			cb != sizeof(PAGE) )
			{
			if ( err == JET_errSuccess )
				err = JET_errDiskIO;
			BFDiskIOEvent( pbf, err, "Sync overlapped Write GetResult Fails",0,0 );
			goto ReturnDiskIOErr;
			}

		EnterCriticalSection( critJet );

		/*  some one is depending on this page and
		/*  this page has been copied to back up file, need to append
		/*  this page to patch file.
		/**/
		if ( err == JET_errSuccess && pbf->pbfDepend &&
			pfmp->pgnoCopied >= PgnoOfPn(pn) )
			{
			/*  backup is going on
			/**/
			Assert( PgnoOfPn(pn) == pgno + 1 );

			/*  need the file change in case previous SysWriteBlock may
			/*  be failed and file pointer may be messed up and not
			/*  aligned to page size.
			/**/
			pgno = pfmp->cpage++;
			pbf->olp.ulOffset = pgno << 12;
			pbf->olp.ulOffsetHigh = pgno >> (32 - 12);
			SignalReset( pbf->olp.sigIO );

			LeaveCriticalSection( critJet );

//			Assert( DbidOfPn( pbf->pn ) == dbidTemp || ppage->pghdr.ulDBTime > 0 );
			
#ifdef  CHECKSUM
			Assert( ppage->pghdr.ulChecksum == UlChecksumPage(ppage));
#ifdef HONOR_PAGE_TIME
			Assert( fRecovering ||
				DbidOfPn((pbf)->pn) == dbidTemp ||
				pbf->ppage->pghdr.ulDBTime <=
				rgfmp[ DbidOfPn((pbf)->pn) ].ulDBTime );
#endif
				
			CheckPgno( pbf->ppage, pbf->pn ) ;
#endif  /* CHECKSUM */

			cmsec = 1;

IssueWriteOverlapped2:
			err = ErrSysWriteBlockOverlapped(
				pfmp->hfPatch, (BYTE *)ppage, cbPage, &cb, &pbf->olp);
			if ( err == JET_errTooManyIO )
				{
				cmsec <<= 1;
				SysSleep(cmsec - 1);
				goto IssueWriteOverlapped2;
				}
			if ( err < 0 )
				{
				BFDiskIOEvent( pbf, err, "Sync overlapped patch file WriteBlock Fails",0,0 );
				goto ReturnDiskIOErr;
				}
			
			/* if write fail, do not clean up this buffer!
			/**/
			if ( ( err = ErrSysGetOverlappedResult(
				hf, &pbf->olp, &cb, fTrue ) ) != JET_errSuccess ||
				cb != sizeof(PAGE) )
				{
				if ( err == JET_errSuccess )
					err = JET_errDiskIO;
				BFDiskIOEvent( pbf, err, "Sync overlapped Write patch file GetResult Fails",0,0 );
				goto ReturnDiskIOErr;
				}
				
			EnterCriticalSection( critJet );
			}
		}
	
	if ( err != JET_errSuccess )
		{
		/* Some error occur, set the error code
		/**/
		pbf->fIOError = fTrue;
		pbf->err = err;
		}
	else
		{
		Assert( pbf->fIOError == fFalse );

		if ( !pbf->fRead )
			{
			pbf->fDirty = fFalse;
			pbf->lgposRC = lgposMax;
			BFUndepend( pbf );
			}
		}
	}


INLINE VOID BFIReturnBuffers( BF *pbf )
	{
	Assert( pbf->ipbfHeap == ipbfDangling );

	Assert( !( pbf->fInHash ) );
	Assert( pbf->cPin == 0 );
	Assert( pbf->fDirty == fFalse );
	Assert( pbf->fPreread == fFalse );
	Assert( pbf->fRead == fFalse );
	Assert( pbf->fWrite == fFalse );
	Assert( pbf->fIOError == fFalse );

	Assert( pbf->cDepend == 0 );
	Assert( pbf->pbfDepend == pbfNil );
	
	pbf->pn = pnNull;
	
	/* release the buffer and return the found buffer
	/**/
	EnterCriticalSection( critAvail );
	BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
	LeaveCriticalSection( critAvail );
			
	EnterCriticalSection( pbf->critBF );
	Assert( pbf->fHold == fTrue );
	pbf->fHold = fFalse;
	LeaveCriticalSection( pbf->critBF );
	}


/*  ErrBFAccessPage is used to make any physical page (pn) accessible to
/*  the caller (returns pbf).
/*  RETURNS JET_errSuccess
/*          JET_errOutOfMemory      no buffer available, request not granted
/*			                        fatal io errors
/**/
LOCAL ERR ErrBFIAccessPage( PIB *ppib, BF **ppbf, PN pn );


ERR ErrBFAccessPage( PIB *ppib, BF **ppbf, PN pn )
	{
	ERR	err;

Start:
	err = ErrBFIAccessPage( ppib, ppbf, pn );
	Assert( err < 0 || err == JET_errSuccess );
	if ( err == JET_errSuccess && (*ppbf)->pn != pn )
		{
		goto Start;
		}

	return err;
	}
	

LOCAL ERR ErrBFIAccessPage( PIB *ppib, BF **ppbf, PN pn )
	{
	ERR     err = JET_errSuccess;
	BF      *pbf;

#ifdef DEBUG
	EnterCriticalSection( critLRUK );
	LeaveCriticalSection( critLRUK );
#endif

	AssertCriticalSection( critJet );

SearchPage:
	CallR( ErrBFIFindPage( ppib, pn, &pbf ) );

	if ( pbf == pbfNil )
		{
		Assert( err == wrnBFPageNotFound );

		/* not found the page in the buffer pool, go allocate one.
		/**/
		CallR( ErrBFIAlloc ( &pbf ) );
		
#ifdef DEBUG
		EnterCriticalSection( critLRUK );
		LeaveCriticalSection( critLRUK );
#endif

		if ( err == wrnBFNotSynchronous )
			{
			/* we did not find a buffer, let's see if other user
			/* bring in this page by checking BFIFindPage again.
			/**/
			Assert( pbf == pbfNil );
			// release critJet and sleep in BFIFindPage or BFIAlloc
			goto SearchPage;
			}

		/* now we got a buffer for page pn
		/**/
		if ( PbfBFISrchHashTable( pn ) != NULL )
			{
			/* someone has add one,
			 * release the buffer and return the newly found buffer
			 */
			BFIReturnBuffers( pbf );
			goto SearchPage;
			}

		pbf->pn = pn;
		BFIInsertHashTable( pbf );

		/* release semphore, do the IO, and regain it.
		/* note that this page must be a new page.
		/* set the buffer for read.
		/**/
		Assert( pbf->fHold == fTrue );
		
		Assert( pbf->fWrite == fFalse );
		Assert( pbf->fRead == fFalse );
		Assert( pbf->ipbfHeap == ipbfDangling );

		EnterCriticalSection( pbf->critBF );
		pbf->fRead = fTrue;
		pbf->fHold = fFalse;
		LeaveCriticalSection( pbf->critBF );

		BFIOSync( pbf );

		EnterCriticalSection( pbf->critBF );
		pbf->fRead = fFalse;
		pbf->fHold = fTrue;
		LeaveCriticalSection( pbf->critBF );

		Assert( pbf->fRead == fFalse );
		Assert( pbf->cPin == 0 );

		pbf->ulBFTime2 = 0;

		if ( pbf->fIOError )
			{
			/* free the read buffer
			/**/
			BFIDeleteHashTable( pbf );
			pbf->pn = pnNull;
			pbf->fIOError = fFalse;
			err = JET_errDiskIO;

			pbf->ulBFTime1 = 0;
			EnterCriticalSection( critAvail );
			BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
			LeaveCriticalSection( critAvail );
			goto HandleError;
			}
		else
			{
			pbf->ulBFTime1 = ulBFTime;
			EnterCriticalSection( critLRUK );
			BFLRUKAddToHeap( pbf );
			LeaveCriticalSection( critLRUK );
			}

		Assert( !FDBIDFlush( DbidOfPn( pbf->pn ) ) );
		}

	/*  buffer can not be stolen
	/**/
	Assert ( pbf->pn == pn && !pbf->fRead && !pbf->fWrite && !pbf->fPreread);

	*ppbf = pbf;

#ifdef DEBUG
	{
	PGNO	pgnoThisPage;

	LFromThreeBytes( pgnoThisPage, pbf->ppage->pgnoThisPage );
	Assert( PgnoOfPn(pbf->pn) == pgnoThisPage );
	}
#endif
	
HandleError:

	EnterCriticalSection( pbf->critBF );
	Assert( pbf->fHold == fTrue );
	Assert( pbf->fRead == fFalse );
	pbf->fHold = fFalse;
	LeaveCriticalSection( pbf->critBF );

//#ifdef DEBUG
//	Assert( CmpLgpos( &pbf->lgposModify, &lgposLogRec ) <= 0 );
//#endif
	
	return err;
	}


/*
 *  Allocate a buffer and initialize it for a given (new) page.
 */
ERR ErrBFNewPage( FUCB *pfucb, PGNO pgno, PGTYP pgtyp, PGNO pgnoFDP )
	{
	ERR  err;
	PN   pn;

	SgSemRequest( semST );
	pn = PnOfDbidPgno( pfucb->dbid, pgno );
	Call( ErrBFAllocPageBuffer( pfucb->ppib, &pfucb->ssib.pbf, pn,
		pfucb->ppib->lgposStart, pgtyp ) );

	PMNewPage( pfucb->ssib.pbf->ppage, pgno, pgtyp, pgnoFDP );
	PMDirty( &pfucb->ssib );

HandleError:
	SgSemRelease( semST );
	return err;
	}


/*
 *  get largest continuous Batch IO buffers.
 */
VOID BFGetLargestBatchIOBuffers( INT *pipageFirst, INT *pcpageBatchIO )
	{
	INT ipageFirst = -1;
	INT cpageBatchIO = 0;
	
	INT ipageRun = 0;
	INT cpageRun = 0;
	INT cpageMax = min( *pcpageBatchIO, ipageBatchIOMax / 2 );

	INT ipage;

	AssertCriticalSection( critBatchIO );
	Assert( *pcpageBatchIO > 1 );

	for ( ipage = 0; ipage < ipageBatchIOMax + 1; ipage++ )
		{
		if ( rgfBatchIOUsed[ ipage ] )
			{
			if ( cpageRun != 0 )
				{
				if ( cpageRun > cpageBatchIO && cpageRun != 1 )
					{
					/*  current run is the largest continuous block.
					 */
					ipageFirst = ipageRun;
					cpageBatchIO = cpageRun;
					}

				/* start a new run */
				cpageRun = 0;
				}
			continue;
			}

		if ( cpageRun == 0 )
			/* keep track of the first page of the new run */
			ipageRun = ipage;

		cpageRun++;

		/* do not allow more than half of total be allocated */
		if ( cpageRun >= cpageMax )
			{
			/*  current run is large enough a continuous block.
			 */
			ipageFirst = ipageRun;
			cpageBatchIO = cpageRun;
			break;
			}
		}
	
	for ( ipage = ipageFirst; ipage < ipageFirst + cpageBatchIO; ipage++ )
		rgfBatchIOUsed[ ipage ] = fTrue;
	
	*pipageFirst = ipageFirst;
	*pcpageBatchIO = cpageBatchIO;

#ifdef DEBUGGING
	printf("Get   %2d - %2d,%4d\n",
		cpageBatchIO, ipageFirst, ipageFirst + cpageBatchIO - 1 );
#endif
	}


VOID BFFreeBatchIOBuffers( INT ipage, INT cpage )
	{
	INT ipageMax = ipage + cpage;

	Assert( ipage >= 0 );
	Assert( cpage > 0 );
	Assert( cpage <= ipageBatchIOMax );
	Assert( ipageMax <= ipageBatchIOMax );

	EnterCriticalSection( critBatchIO );
	while ( ipage < ipageMax )
		rgfBatchIOUsed[ ipage++ ] = fFalse;
	LeaveCriticalSection( critBatchIO );
	
#ifdef DEBUGGING
	printf("Free  %2d - %2d,%4d\n",	cpage, ipage - cpage, ipage - 1 );
#endif
	}
 

VOID FreePrereadBuffers( BF *pbf, INT *pcpbf )
	{
	INT cpbf = 0;

	for ( ; pbf != pbfNil; pbf = pbf->pbfNextBatchIO, cpbf++ )
		{
		AssertCriticalSection( critJet );
		BFIDeleteHashTable( pbf );

		pbf->pn = pnNull;
		pbf->fIOError = fFalse;
		pbf->err = 0;
		
		pbf->ulBFTime2 = 0;
		pbf->ulBFTime1 = 0;
		EnterCriticalSection( critAvail );
		BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
		LeaveCriticalSection( critAvail );

		/* free the held buffer */
		EnterCriticalSection( pbf->critBF );
		Assert( pbf->fHold == fFalse );
		pbf->fPreread = fFalse;
		LeaveCriticalSection( pbf->critBF );
		}
	*pcpbf = cpbf;
	}


/*
 *  Preread.
 */
VOID BFReadAsync( PN pnFirst, INT cpage )
	{
	ERR     err;
	PGNO    pgno;

	PN		pn;
	PN		pnMax;

	BF      *pbf;

	BF		*pbfFirst, *pbfLast;
	INT		ipageFirst;
	INT		cpagePreread = 0;
	INT		cpbf;
	INT		cpagePrereadFinal;
	PAGE	*ppageToRead;
	FMP     *pfmp;
	
	AssertCriticalSection( critJet );

	/* check parameters */
	Assert( pnFirst );
	Assert( cpage );

	pbfFirst = pbfNil;
	pn = pnFirst;
	pnMax = pnFirst + cpage;

	while (pn < pnMax)
		{
Search:
		/*  look for cached copy of source page
		/**/
		if ( PbfBFISrchHashTable( pn ) != NULL )
			{
CheckExists:
			if ( pn == pnFirst )
				{
				/* done, no need to pre-read */
				goto HandleError;
				}
			else
				/* preread up to this page */
				break; /* while */
			}

		/* not found the page in the buffer pool, go allocate one
		/**/
		CallJ( ErrBFIAlloc( &pbf ), HandleError )
		if ( err == wrnBFNotSynchronous )
			goto Search;

		Assert(pbf->fHold);
		Assert( !FDBIDFlush( DbidOfPn( pbf->pn ) ) );

		/* make sure it is not available still */
		if ( PbfBFISrchHashTable( pn ) != NULL )
			{
			/* release the buffer and return the found buffer */
			BFIReturnBuffers( pbf );
			goto CheckExists;
			}
		pbf->pn = pn;
		BFIInsertHashTable( pbf );

		if (pn == pnFirst)
			{
			pbfFirst = pbf;
			pbfLast = pbf;
			}
		else
			{
			if ( pbfFirst == pbfLast )
				{
				/*
				 *  find out how many pages we need preread
				 *  and store it in cpagePreread
				 */
				Assert ( cpage > 1 );

				EnterCriticalSection( critBatchIO );
				cpagePreread = cpage;
				BFGetLargestBatchIOBuffers( &ipageFirst, &cpagePreread );
				LeaveCriticalSection( critBatchIO );

				if ( cpagePreread == 0 )
					{
					/* no large buffer available, only preread one page */
					/* delete from hash table */
					BFIDeleteHashTable( pbf );
					pbf->pn = pnNull;
					BFIReturnBuffers( pbf );
					break;
					}
				pnMax = pnFirst + cpagePreread;
				}

			pbfLast->pbfNextBatchIO = pbf;
			pbfLast = pbf;
			}

		/* hold the buffers */
		EnterCriticalSection( pbf->critBF );
		Assert( pbf->ipbfHeap == ipbfDangling );
		Assert( pbf->fWrite == fFalse );
		pbf->fHold = fFalse;
		pbf->fPreread = fTrue;
		LeaveCriticalSection( pbf->critBF );
	
		pn = pn + 1;
		}
	pbfLast->pbfNextBatchIO = pbfNil;

	cpagePrereadFinal = pn - pnFirst;

	if ( cpagePrereadFinal > 1 )
		{
		ppageToRead = &rgpageBatchIO[ ipageFirst ];
		pbfFirst->ipageBatchIOFirst = ipageFirst;
		
		if ( cpagePreread > cpagePrereadFinal )
			{
			BFFreeBatchIOBuffers(
				ipageFirst + cpagePrereadFinal,
				cpagePreread - cpagePrereadFinal );
			}
		}
	else
		{
		ppageToRead = pbfFirst->ppage;
		pbfFirst->ipageBatchIOFirst = -1;

		if ( cpagePreread > 1 )
			BFFreeBatchIOBuffers( ipageFirst, cpagePreread );
		}

	pgno = PgnoOfPn(pnFirst);
	pgno--;
	pbfFirst->olp.ulOffset = pgno << 12;
	pbfFirst->olp.ulOffsetHigh = pgno >> (32 - 12);
	pfmp = &rgfmp[ DbidOfPn( pnFirst ) ];
	pbfFirst->hf = pfmp->hf;

	/* put into preread list */
	EnterCriticalSection( critPreread );
	BFAddToList( pbfFirst, &lrulistPreread );
	LeaveCriticalSection( critPreread );

	SignalSend( sigBFPrereadProc );
	return;
	
HandleError:
	/*  free all the allocated page buffers.
	 */
	FreePrereadBuffers( pbfFirst, &cpbf );
	if ( cpagePreread > 1 )
		BFFreeBatchIOBuffers( ipageFirst, cpagePreread );
	return;
	}


#define fSleepNotAllowed	fTrue
#define fSleepAllowed		fFalse
VOID BFIssueAsyncPreread( INT cIOMax, INT *pcIOIssued, BOOL fNoSleep )
	{
	BOOL fTooManyIOs = fFalse;
	INT cIOMac = 0;
	ERR err;

	EnterCriticalSection(critPreread);
	while ( lrulistPreread.pbfMRU &&
			!fTooManyIOs &&
			cIOMac < cIOMax )
		{
		INT	cmsec;
		PAGE *ppageToRead;
		INT cpagePreread;
		BF *pbf = lrulistPreread.pbfMRU;

		/* pbf is hold with fPreread set */
		Assert( pbf->fPreread );
		Assert( pbf->pn != pnNull );
		BFTakeOutOfList( pbf, &lrulistPreread );
		Assert( pbf->fPreread );
		Assert( pbf->pn != pnNull );
		
		Assert( pbf->fDirty == fFalse );

		cpagePreread = 1;
		if ( pbf->ipageBatchIOFirst == -1 )
			ppageToRead = pbf->ppage;
		else
			{
			BF *pbfT = pbf;
			ppageToRead = &rgpageBatchIO[ pbf->ipageBatchIOFirst ];
			while ( pbfT->pbfNextBatchIO )
				{
				pbfT = pbfT->pbfNextBatchIO;
				cpagePreread++;
				}
			Assert( cpagePreread > 1 );
			}

		// UNDONE: should have been reset
		SignalReset( pbf->olp.sigIO );
		cIOMac++;
		EnterCriticalSection( critIOActive );
		cIOActive++;
		fTooManyIOs = cIOActive > lAsynchIOMax;
		LeaveCriticalSection( critIOActive );
		cmsec = 1;
		while ( ( err = ErrSysReadBlockEx(
			pbf->hf,
			(BYTE *)ppageToRead,
			cbPage * cpagePreread,
			&pbf->olp, BFIOPrereadComplete ) ) < 0 )
			{
			if ( !fNoSleep && err == JET_errTooManyIO )
				{
				cmsec <<= 1;
				LeaveCriticalSection(critPreread);
				SysSleep( cmsec - 1 );
				EnterCriticalSection(critPreread);
				}
			else
				{
				INT cpbf;
				
				/* issue read fail, free the page buffers
				/**/
				if ( cpagePreread > 1 )
					BFFreeBatchIOBuffers(pbf->ipageBatchIOFirst, cpagePreread);
				
				LeaveCriticalSection(critPreread);
				EnterCriticalSection( critJet );
				FreePrereadBuffers( pbf, &cpbf );
				LeaveCriticalSection( critJet );
				EnterCriticalSection(critPreread);
				
				Assert( cpbf == cpagePreread );
				
				cIOMac--;
				EnterCriticalSection( critIOActive );
				cIOActive--;
				fTooManyIOs = cIOActive > lAsynchIOMax;
				LeaveCriticalSection( critIOActive );

				break;
				}
			} /* while */
		}
	LeaveCriticalSection(critPreread);

	*pcIOIssued = cIOMac;
	}


LOCAL VOID BFPrereadProcess()
	{
	forever
		{
		INT cIOIssued;
		
		SignalWaitEx( sigBFPrereadProc, -1, fTrue );
MoreIO:
		BFIssueAsyncPreread ( lAsynchIOMax, &cIOIssued, fSleepAllowed );

		if ( fBFPrereadProcessTerm )
			{
			/* check if any page is still in read write state
			/* after this point, no one should ever continue putting
			/* pages for IO
			/**/
			BF      *pbf = pbgcb->rgbf;
			BF      *pbfMax = pbf + pbgcb->cbfGroup;
			for ( ; pbf < pbfMax; pbf++ )
				{
				DBID dbid = DbidOfPn( pbf->pn );
				BOOL f;
#ifdef DEBUG                            
#ifdef FITFLUSHPATTERN
				if ( !FFitFlushPattern( pbf->pn ) )
					continue;
#endif
#endif
				EnterCriticalSection( pbf->critBF );
				f = FBFInUse( ppibNil, pbf );
				LeaveCriticalSection( pbf->critBF );
				if ( f )
					{
					/* let the on-going IO have a chance to complete */
					SysSleepEx( 10, fTrue );
					goto MoreIO;
					}

				// UNDONE: report event
				Assert( !pbf->fIOError );
				}

			break; /* forever */
			}
		}

//	/*	exit thread on system termination.
//	/**/
//	SysExitThread( 0 );
	return;
	}


LOCAL VOID __stdcall BFIOPrereadComplete( LONG err, LONG cb, OLP *polp )
	{
	BF      *pbf = (BF *) (((char *)polp) - ((char *)&((BF *)0)->olp));
	BF		*pbfNext;
	DBID    dbid = DbidOfPn(pbf->pn);
	INT		ipageFirst = pbf->ipageBatchIOFirst;
	INT		ipage = ipageFirst;
	INT		cpageTotal = 0;
	INT		cpbf;
	INT		cIOIssued;

	Assert( ipage == -1 || ipage >= 0 );
	Assert( ipage == -1 ? pbf->pbfNextBatchIO == pbfNil : pbf->pbfNextBatchIO != pbfNil );

	for ( ; pbf != pbfNil; pbf = pbf->pbfNextBatchIO, cpageTotal++ )
		{
		Assert( pbf->fPreread );
		Assert( pbf->pn );
		Assert( pbf->pbfNextBatchIO == pbfNil || pbf->pn + 1 == pbf->pbfNextBatchIO->pn );

#ifdef DEBUGGING
		printf(" (%d,%d) ", DbidOfPn(pbf->pn), PgnoOfPn(pbf->pn));
#endif
		}
#ifdef DEBUGGING
		printf(" -- %d\n", cpageTotal );
#endif

	/* recovery pbf
	/**/	
	pbf = (BF *) (((char *)polp) - ((char *)&((BF *)0)->olp));
	
	if ( err )
		goto FreeBfs;

	/*  read was done successfully
	/**/
	for ( ; pbf != pbfNil; pbf = pbfNext, ipage++ )
		{
		PAGE *ppage;

		pbfNext = pbf->pbfNextBatchIO;

		if ( ipage == -1 )
			{
			ppage = pbf->ppage;
			Assert( pbf->pbfNextBatchIO == pbfNil );
			}
		else
			ppage = &rgpageBatchIO[ipage];
		
		Assert( pbf->fPreread == fTrue );
		Assert( pbf->fRead == fFalse );
		Assert( pbf->fWrite == fFalse );
		Assert( pbf->fHold == fFalse );

		Assert( pbf->fDirty == fFalse );
		Assert( pbf->fIOError == fFalse );

		Assert( pbf->ipbfHeap == ipbfDangling );

		#ifdef  CHECKSUM
			{
			ULONG ulChecksum = UlChecksumPage( ppage );
			ULONG ulPgno;
			
			LFromThreeBytes(ulPgno, ppage->pgnoThisPage);
			if ( ulChecksum != ppage->pghdr.ulChecksum ||
				ulPgno != PgnoOfPn( pbf->pn ) )
				{
				err = JET_errReadVerifyFailure;
				goto FreeBfs;
				}
//			else
//				{
//				Assert( DbidOfPn( pbf->pn ) == dbidTemp || ppage->pghdr.ulDBTime > 0 );
//				}
			}
		#endif  /* CHECKSUM */

		//	UNDONE: remap the page to buffers or 4k copy
		if ( ipage != -1 )
			{
			Assert( pbf->fPreread );
			Assert( cbPage == sizeof(PAGE) );
			memcpy( pbf->ppage, ppage, sizeof(PAGE) );
			}

#ifdef HONOR_PAGE_TIME
		if ( !fRecovering &&
			dbid != dbidTemp &&
			ppage->pghdr.ulDBTime > rgfmp[ dbid ].ulDBTime )
			{
			BFDiskIOEvent( pbf, err, "Async preread UlDBTime is bad",
				ppage->pghdr.ulDBTime, rgfmp[ dbid ].ulDBTime );
			err = JET_errDiskIO;
			goto FreeBfs;
			}
#endif
	
		/* put into heap
		/**/
		pbf->ulBFTime2 = 0;
		pbf->ulBFTime1 = 0;
		EnterCriticalSection( critAvail );
		BFAddToListAtMRUEnd( pbf, &pbgcb->lrulist );
		LeaveCriticalSection( critAvail );

#ifdef DEBUGGING
		{
		ULONG ulNext, ulPrev, ulThisPage;
		LFromThreeBytes(ulPrev, pbf->ppage->pghdr.pgnoPrev );
		LFromThreeBytes(ulNext, pbf->ppage->pghdr.pgnoNext );
		LFromThreeBytes(ulThisPage, pbf->ppage->pgnoThisPage );
		printf("Pread %2d - %2d,%4d - %2d <%lu %lu> (%lu, %lu, %lu)\n",
			cpageTotal, DbidOfPn(pbf->pn), PgnoOfPn(pbf->pn),
			ipage,
			rgfmp[DbidOfPn(pbf->pn)].ulDBTime, pbf->ppage->pghdr.ulDBTime,
			ulPrev, ulNext, ulThisPage);
		}
#endif
		/* free the held buffer
		/**/
		EnterCriticalSection( pbf->critBF );
		Assert( pbf->fHold == fFalse );
		pbf->fPreread = fFalse;
		LeaveCriticalSection( pbf->critBF );
		}
	
	goto FreeBatchBuffers;

FreeBfs:
	EnterCriticalSection( critJet );
	FreePrereadBuffers( pbf, &cpbf );
	LeaveCriticalSection( critJet );

FreeBatchBuffers:
	if ( ipageFirst != -1 )
		BFFreeBatchIOBuffers( ipageFirst, cpageTotal );

	BFIssueAsyncPreread( 1, &cIOIssued, fSleepNotAllowed );

	if ( cIOIssued == 0 )
		{
		EnterCriticalSection( critIOActive );
		cIOActive--;
		LeaveCriticalSection( critIOActive );
		}
	}


/*  Allocate a buffer for the physical page identified by pn.
/*  No data is read in for this page.
/*
/*  PARAMETERS      ppbf    pointer to BF is returned in *ppbf
/*
/*  RETURNS         JET_errSuccess
/*                  errBFNoFreeBuffers 
/**/
ERR ErrBFAllocPageBuffer( PIB *ppib, BF **ppbf, PN pn, LGPOS lgposRC, PGTYP pgtyp )
	{
	ERR     err = JET_errSuccess;
	BF		*pbf;
	BOOL    fFound;

	Assert( pn );
	
Begin:
	do
		{
		AssertCriticalSection( critJet );
		CallR( ErrBFIFindPage( ppib, pn, &pbf ) );

		if ( fFound = ( pbf != NULL ) )
			{
			Assert( err == JET_errSuccess );
			Assert( pbf->fHold );

			/* need to remove dependency before returned for overwrite
			/**/
			BFIRemoveDependence( ppib, pbf );
			}
		else if ( err == wrnBFPageNotFound )
			{
			CallR( ErrBFIAlloc( &pbf ) );
			}
		}
	while ( err == wrnBFNotSynchronous );
	Assert( pbf->fHold );
	
	AssertCriticalSection( critJet );
	if ( fFound )
		{
		Assert( pbf->fRead == fFalse );
		Assert( pbf->fWrite == fFalse );
		/*  make sure no residue effects
		/**/
		pbf->fIOError = fFalse;
		}
	else
		{
		if ( PbfBFISrchHashTable( pn ) != NULL )
			{
			/* release the buffer and return the found buffer */
			BFIReturnBuffers( pbf );
			goto Begin;
			}
		pbf->pn = pn;                           
		BFIInsertHashTable( pbf );
		Assert( pbf->fIOError == fFalse );

		EnterCriticalSection(critLRUK);
		pbf->ulBFTime2 = 0;
		pbf->ulBFTime1 = ulBFTime;
		BFLRUKAddToHeap( pbf );
		LeaveCriticalSection(critLRUK);
		}

	Assert( !FDBIDFlush( DbidOfPn( pbf->pn ) ) );
	pbf->lgposRC = lgposRC;

	/* free the held page to caller */
	EnterCriticalSection( pbf->critBF );
	Assert( pbf->fHold );
	pbf->fHold = fFalse;
	LeaveCriticalSection( pbf->critBF );

#ifdef DEBUG
	EnterCriticalSection( critLRUK );
	LeaveCriticalSection( critLRUK );
#endif
	
	*ppbf = pbf;
	return err;
	}


/* paired with BFFree
/**/
ERR ErrBFAllocTempBuffer( BF **ppbf )
	{
	ERR     err = JET_errSuccess;
	BF      *pbf;

	AssertCriticalSection( critJet );

	while ( ( err = ErrBFIAlloc( &pbf ) ) == wrnBFNotSynchronous );
	if ( err < 0 )
		goto HandleError;
	Assert( pbf->pn == pnNull );

	/* free the held page to caller */
	EnterCriticalSection( pbf->critBF );
	pbf->fHold = fFalse;
	LeaveCriticalSection( pbf->critBF );

	*ppbf = pbf;

HandleError:

#ifdef DEBUG
	EnterCriticalSection( critLRUK );
	LeaveCriticalSection( critLRUK );
#endif
	
	AssertCriticalSection( critJet );
	return err;
	}


/*  Discard a working buffer without saving contents.  BFFree makes the buffer
/*  immediately available to be reused.
/**/
VOID BFFree( BF *pbf )
	{
	AssertCriticalSection( critJet );

	Assert( pbf );
	Assert( pbf->pn == pnNull );
	Assert( pbf->fHold == fFalse );
	Assert( pbf->fPreread == fFalse );
	Assert( pbf->fRead == fFalse );
	Assert( pbf->fWrite == fFalse );
	Assert( pbf->fIOError == fFalse );

	/* take out from list
	/**/
	forever
		{
		if ( FBFHoldBuffer( ppibNil, pbf ) )
			{
			Assert( pbf->fHold );
			break;
			}
		/* the page is being read/written, wait for the event.
		/**/
		LeaveCriticalSection( critJet );
		SignalWait( pbf->olp.sigIO, 10 );
		EnterCriticalSection( critJet );
		}
	
	Assert( pbf->ipbfHeap == ipbfDangling );
	pbf->fDirty = fFalse;

	Assert( CmpLgpos( &pbf->lgposRC, &lgposMax ) == 0 );
	Assert( pbf->cPin == 0 );

	EnterCriticalSection( critAvail );
	pbf->ulBFTime2 = 0;
	pbf->ulBFTime1 = 0;
	BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
	LeaveCriticalSection( critAvail );
	
	/* free the holding */
	EnterCriticalSection( pbf->critBF );
	Assert( pbf->fHold == fTrue );
	pbf->fHold = fFalse;
	LeaveCriticalSection( pbf->critBF );
	}


#ifdef DEBUG

VOID BFSetDirtyBit( BF *pbf )
	{
	Assert( pbf != pbfNil );
	Assert( pbf->fRead == fFalse );
	Assert( pbf->fPreread == fFalse );
	Assert( pbf->fWrite == fFalse );
	
	Assert( pbf->ipbfHeap != ipbfInAvailList );	/* can not be in avail list */
	Assert( !FBFInBFWriteHeap( pbf ) );	/* should not be accessed again */

	Assert( !( FDBIDReadOnly( DbidOfPn((pbf)->pn) ) ) );    
	Assert( !( FDBIDFlush( DbidOfPn((pbf)->pn) ) ) );
#ifdef HONOR_PAGE_TIME
	Assert( fRecovering ||
		DbidOfPn((pbf)->pn) == dbidTemp ||
		pbf->ppage->pghdr.ulDBTime <=
		rgfmp[ DbidOfPn((pbf)->pn) ].ulDBTime );
#endif

	if ( DbidOfPn((pbf)->pn) != dbidTemp )
		CheckPgno( pbf->ppage, pbf->pn ) ;

	(pbf)->fDirty = fTrue;
	}

#endif


ERR ErrBFDepend( BF *pbf, BF *pbfD )
	{
	BF		*pbfT;

	AssertCriticalSection( critJet );

	/*  already exists, this may happen after hardrestore, such
	/*  dependency is set, then when we redo soft restore, we will
	/*  see the dependcy exists.
	/**/
	if ( pbf->pbfDepend == pbfD )
		{
		Assert( pbfD->cDepend > 0 );
		return JET_errSuccess;
		}

	/*	pbfDepend will depend on us, it will not be flushed until after
	/*	pbf is flushed.
	/**/

	/*  check for dependency creating cycle.  Cycle will be created
	/*	if pbf already depends directly or indirectly on pbfD.
	/**/
	for( pbfT = pbfD; pbfT != pbfNil; pbfT = pbfT->pbfDepend )
		{
		Assert( errDIRNotSynchronous < 0 );
		Assert( pbfT->pbfDepend != pbfD );
		if ( pbfT == pbf )
			return errDIRNotSynchronous;
		}
		
	if ( pbf->pbfDepend )
		{
		/* depend on others already
		/**/
		return errDIRNotSynchronous;
		}

	/*	set dependency
	/**/
	pbf->pbfDepend = pbfD;
	EnterCriticalSection( pbfD->critBF );
	pbfD->cDepend++;
	LeaveCriticalSection( pbfD->critBF );

	return JET_errSuccess;
	}


VOID BFRemoveDependence( PIB *ppib, BF *pbf )
	{
	Assert( pbf->pn != pnNull );

	forever
		{
		if ( FBFHoldBufferByMe( ppib, pbf ) )
			{
			Assert( pbf->fHold );
			break;
			}
		/* the page is being read/written, wait for the event
		/**/
		LeaveCriticalSection( critJet );
		SignalWait( pbf->olp.sigIO, 10 );
		EnterCriticalSection( critJet );
		}

	BFIRemoveDependence( ppib, pbf );
	Assert( pbf->fHold );

	/* put into lruk heap
	/**/
	pbf->ulBFTime2 = 0;
	pbf->ulBFTime1 = ulBFTime;
	EnterCriticalSection( critLRUK );
	BFLRUKAddToHeap( pbf );
	LeaveCriticalSection( critLRUK );
	
	EnterCriticalSection( pbf->critBF );
	pbf->fHold = fFalse;
	LeaveCriticalSection( pbf->critBF );

	return;
	}

	
LOCAL VOID BFIRemoveDependence( PIB *ppib, BF *pbf )
	{
#ifdef DEBUG
	INT cLoop = 0;
#endif
	BF *pbfSave = pbf;

	Assert( pbf->fHold );

RemoveDependents:

	/*  remove dependencies from buffers which depend upon pbf
	/**/
	while ( pbf->cDepend > 0 )
		{
		BF  *pbfT;
		BF  *pbfTMax;

		Assert( ++cLoop < rgres[iresBF].cblockAlloc * rgres[iresBF].cblockAlloc / 2 );
		AssertCriticalSection( critJet );

		for ( pbfT = pbgcb->rgbf, pbfTMax = pbgcb->rgbf + pbgcb->cbfGroup;
			pbfT < pbfTMax;
			pbfT++ )
			{
			INT cmsec;
		
			if ( pbfT->pbfDepend != pbf )
				continue;
			Assert( pbfT->fDirty == fTrue );

			cmsec = 1;
GetDependedPage:
			/* make sure no one can move me after leave critLRU
			/**/
			EnterCriticalSection( pbfT->critBF );
			if ( FBFInUse( ppib, pbfT ) )
				{
				LeaveCriticalSection( pbfT->critBF);
				cmsec <<= 1;
				if ( cmsec > ulMaxTimeOutPeriod )
					cmsec = ulMaxTimeOutPeriod;
				BFSleep( cmsec - 1 );
				goto GetDependedPage;
				}
			LeaveCriticalSection( pbfT->critBF );

			if ( pbfT->pbfDepend != pbf )
				continue;
			Assert( pbfT->fDirty == fTrue );
			
			forever
				{
				if ( FBFHoldBuffer( ppibNil, pbfT ) )
					{
					Assert( pbfT->fHold );
					break;
					}
				/* the page is being read/written, wait for the event
				/**/
				LeaveCriticalSection( critJet );
				SignalWait( pbfT->olp.sigIO, 10 );
				EnterCriticalSection( critJet );
				}

			/* buffer may be clean when we hold it
			/**/
			if ( !pbfT->fDirty )
				{
				Assert( pbfT->fHold == fTrue );
				goto ReturnPbfT;
				}
			
			/*	there should be no case where buffer to flush is latched
			/**/
			Assert( pbfT->cPin == 0 );
				
			/* if this page has dependency
			/**/
			if ( pbfT->cDepend )
				{
				/* can not write it now, lets flush pbfT dependent
				/* pages first.  Assign pbfT to pbf and start the
				/* remove dependency from begining of the loop.
				/**/
				pbf = pbfT;

				EnterCriticalSection(critLRUK);
				BFLRUKAddToHeap(pbfT);
				LeaveCriticalSection(critLRUK);
				
				EnterCriticalSection( pbfT->critBF );
				pbfT->fHold = fFalse;
				LeaveCriticalSection( pbfT->critBF);

				/* remove all pbf dependents
				/**/
				goto RemoveDependents;
				}
				
			EnterCriticalSection( pbfT->critBF );
			pbfT->fHold = fFalse;
			pbfT->fWrite = fTrue;
			LeaveCriticalSection( pbfT->critBF);

			BFIOSync( pbfT );
					
			EnterCriticalSection( pbfT->critBF );
			pbfT->fWrite = fFalse;
			pbfT->fHold = fTrue;
			LeaveCriticalSection( pbfT->critBF);
			
ReturnPbfT:
			EnterCriticalSection( critAvail );
			BFAddToListAtMRUEnd(pbfT, &pbgcb->lrulist);
			LeaveCriticalSection( critAvail );

			EnterCriticalSection( pbfT->critBF );
			pbfT->fHold = fFalse;
			LeaveCriticalSection( pbfT->critBF );
			}
		}

	if ( pbf != pbfSave )
		{
		/* try again to remove all pbf dependents
		/**/
		pbf = pbfSave;
		goto RemoveDependents;
		}
		
	Assert( pbf->cDepend == 0 );
	Assert( pbf->pbfDepend == pbfNil || pbf->fDirty == fTrue );
	if ( pbf->fDirty )
		{
		/* write the page out and remove dependency.
		/* BFUndepend is called in BFIOSync.
		/**/
		EnterCriticalSection( pbf->critBF );
		Assert( pbf->fHold == fTrue );
		Assert( pbf->fRead == fFalse );
		if ( pbf->cPin != 0 )
			AssertBFWaitLatched( pbf, ppib );
		pbf->fHold = fFalse;
		pbf->fWrite = fTrue;
		LeaveCriticalSection( pbf->critBF );

		BFIOSync( pbf );

		EnterCriticalSection( pbf->critBF );
		Assert( pbf->fWrite == fTrue );
		pbf->fWrite = fFalse;
		pbf->fHold = fTrue;
		LeaveCriticalSection( pbf->critBF );

		Assert( pbf->pbfDepend == pbfNil );
		}

	return;
	}


VOID BFIAbandonBuf( BF *pbf )
	{
	AssertCriticalSection( critJet );
	BFIDeleteHashTable( pbf );
	pbf->pn = pnNull;

	Assert( pbf->cPin == 0 || pbf->cPin == 1 );
	Assert( pbf->fHold == fTrue );
	Assert( pbf->fRead == fFalse );
	Assert( pbf->fWrite == fFalse );

	Assert( pbf->ipbfHeap == ipbfDangling );
	pbf->fDirty = fFalse;

	pbf->fIOError = fFalse;

	Assert( fDBGSimulateSoftCrash || pbf->cDepend == 0 );

	BFUndepend( pbf );
	pbf->lgposRC = lgposMax;

	EnterCriticalSection( critAvail );
	Assert( pbf->ipbfHeap == ipbfDangling );
	pbf->ulBFTime2 = 0;
	pbf->ulBFTime1 = 0;
	BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
	LeaveCriticalSection( critAvail );

#ifdef DEBUG
//	BFDiskIOEvent( pbf, JET_errSuccess, "Abandon page",0,0 );
#endif
	}


/*	discard any page buffer associated with pn without saving contents.
/*	If pn is cached its buffer is made available to be reused.
/**/
VOID BFAbandon( PIB *ppib, BF *pbf )
	{
	DBID    dbid = DbidOfPn(pbf->pn);
	FMP     *pfmp = &rgfmp[ dbid ];

	Assert( pbf->pn != pnNull );

	forever
		{
		if ( FBFHoldBufferByMe( ppib, pbf ) )
			{
			Assert( pbf->fHold );
			break;
			}
		/* the page is being read/written, wait for the event.
		/**/
		LeaveCriticalSection( critJet );
		SignalWait( pbf->olp.sigIO, 10 );
		EnterCriticalSection( critJet );
		}
		
	if ( dbid != dbidTemp && pbf->fDirty )
		{
		/* remove all the dependency so that redo will have
		/* enough information.
		/**/
		BFIRemoveDependence( ppib, pbf );
		}
		
#if 0
	if ( dbid != dbidTemp && pbf->fDirty && pbf->pbfDepend )
		{
		/*  some one depends on this buffer,
		/*  can not simply abandon it. We need to write this page out
		/*  to make sure that when redo, we have enough information
		/**/
		EnterCriticalSection( pbf->critBF );
		Assert( pbf->fRead == fFalse );
		pbf->fHold = fFalse;
		Assert( pbf->cPin == 0 );
		pbf->fWrite = fTrue;
		LeaveCriticalSection( pbf->critBF );

		BFIOSync( pbf );

		EnterCriticalSection( pbf->critBF );
		Assert( pbf->fRead == fFalse );
		pbf->fWrite = fFalse;
		pbf->fHold = fTrue;
		LeaveCriticalSection( pbf->critBF );

		Assert( fDBGSimulateSoftCrash || pbf->pbfDepend == pbfNil );
		/* ignore the error code
		/**/
		}
#endif

	BFIAbandonBuf( pbf );

	EnterCriticalSection( pbf->critBF );
	pbf->fHold = fFalse;
	LeaveCriticalSection( pbf->critBF );

#ifdef DEBUG
	EnterCriticalSection( critLRUK );
	LeaveCriticalSection( critLRUK );
#endif

	return;
	}


//  This function purges buffers belonging to deleted table or deleted
//  index.  Purging these buffers is necessary to remove extraneous
//  buffer dependencies which could otherwise lead to a dependency
//  cycle.
//
//  PARAMETERS      pgnoFDP of table or index whose pages are to be purged.
//  >>>ar           If pgnoFDP is null, all pages for this dbid are purged.

VOID BFPurge( DBID dbid, PGNO pgnoFDP )
	{
	BF     *pbfT = pbgcb->rgbf;
	BF     *pbfMax = pbgcb->rgbf + pbgcb->cbfGroup;

	AssertCriticalSection( critJet );

	for ( ; pbfT < pbfMax; pbfT++ )
		{
		Assert( pbfT->pn != pnNull || pbfT->cDepend == 0 );

		if ( DbidOfPn( pbfT->pn ) == dbid &&
			 pbfT->pn != pnNull &&
			 ( pbfT->ppage->pghdr.pgnoFDP == pgnoFDP ||
			   pgnoFDP == (PGNO)0 ) )
			BFAbandon( ppibNil, pbfT );
		}

	AssertCriticalSection( critJet );
	}


/*  Find BF for pn in hash table (see PbfBFISrchHashTable).
/*  If the page is being READ/WRITE from/to disk, we can still find
/*  the BF, but we must wait until the read is complete.
/*
/*  RETURNS         NULL if BF is not found.
/**/
ERR ErrBFIFindPage( PIB *ppib, PN pn, BF **ppbf )
	{
	BF  *pbf;
	ERR	err;

	forever
		{
		DBID    dbid = DbidOfPn( pn );
		FMP     *pfmp = &rgfmp[ dbid ];

		AssertCriticalSection( critJet );
		pbf = PbfBFISrchHashTable(pn);

		*ppbf = pbf;

		if ( !pbf )
			return wrnBFPageNotFound;

		/* the page is in the hash table
		/* check if not being read/written
		/**/
		if ( FBFHoldBuffer( ppib, pbf ) )
			{
			if ( pbf->pn == pn )
				{
				Assert( pbf->fHold == fTrue );
				break;
				}
			else
				{
				/* someone steal the page, return it and try again */

				if ( pbf->pn != pnNull )
					{
					EnterCriticalSection(critLRUK);
					BFLRUKAddToHeap(pbf);
					LeaveCriticalSection(critLRUK);
					}
				else
					{
					EnterCriticalSection( critAvail );
					BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
					LeaveCriticalSection( critAvail );
					}

				EnterCriticalSection( pbf->critBF );
				Assert( pbf->fHold == fTrue );
				pbf->fHold = fFalse;
				LeaveCriticalSection( pbf->critBF );
				}
			}

		/* the page is being pre/read/written/hold, wait for the event.
		/**/
		LeaveCriticalSection( critJet );
		SignalWait( pbf->olp.sigIO, 10 );
		EnterCriticalSection( critJet );
		}

	if ( pbf->fIOError )
		{
		err = pbf->err;
		goto End;
		}
	else
		err = JET_errSuccess;

#ifdef DEBUG
	{
	PGNO	pgnoThisPage;

	LFromThreeBytes( pgnoThisPage, pbf->ppage->pgnoThisPage );
	Assert( PgnoOfPn(pbf->pn) == pgnoThisPage );
	}
#endif
	
	/*  renew BF by moving it to LRU-K heap
	/**/
	EnterCriticalSection( critLRUK );
	BFUpdateLRU_KWeight(pbf);
	Assert( !FDBIDFlush( DbidOfPn( pbf->pn ) ) );
	LeaveCriticalSection( critLRUK );

End:
	Assert( pbf->fHold );	
	return err;
	}


/*      This function returns a free buffer.
/*      Scans LRU list (leading part) for clean buffer. If none available,
/*      clean up LRU list, and return errBFNotsynchronous if some pages are
/*      cleaned and available, or return out of memory if all buffers are
/*      used up. If caller got errBFNotSychronous, it will try to alloca again.
/**/
LOCAL ERR ErrBFIAlloc( BF **ppbf )
	{
	BF		*pbf;

	AssertCriticalSection( critJet );

#ifdef  ASYNC_BF_CLEANUP
	if ( pbgcb->lrulist.cbfAvail < pbgcb->cbfThresholdLow )
		{
		SignalSend( sigBFCleanProc );
		BFSleep( 1L );
		}
#endif  /* ASYNC_BF_CLEANUP */

	/*      look for clean buffers on LRU list
	/**/
	EnterCriticalSection( critAvail );
	for ( pbf = pbgcb->lrulist.pbfLRU; pbf != pbfNil; pbf = pbf->pbfLRU )
		{
		if ( pbf->cDepend != 0 )
			continue;

		EnterCriticalSection( pbf->critBF );
		if ( !FBFInUse( ppibNil, pbf ) )
			{
			pbf->fHold = fTrue;
			
			Assert( pbf->fDirty == fFalse );
			Assert( pbf->fPreread == fFalse );
			Assert( pbf->fRead == fFalse );
			Assert( pbf->fWrite == fFalse );
			Assert( pbf->fIOError == fFalse );
			Assert( pbf->cPin == 0 );
			Assert( pbf->cDepend == 0 );
			Assert( pbf->pbfDepend == pbfNil );
			pbf->lgposRC = lgposMax;
			pbf->lgposModify = lgposMin;

			if ( pbf->pn != pnNull )
				{
				BFIDeleteHashTable( pbf );    
				pbf->pn = pnNull;
				}

			*ppbf = pbf;
			LeaveCriticalSection( pbf->critBF );
			
			BFTakeOutOfList( pbf, &pbgcb->lrulist );
			LeaveCriticalSection( critAvail );
			
			return JET_errSuccess;
			}
		LeaveCriticalSection( pbf->critBF );
		}
	LeaveCriticalSection( critAvail );

	/*  do a synchronouse buffer clean up for at least one pages.
	/**/
	return ErrBFClean( fOneBlock );
	}


/*  returns most like pbf to be accessed.  Used in cursor initialization.
/**/
BF  *PbfBFMostUsed( void )
	{
	if ( !FBFLRUKHeapEmpty() )
		return rgpbfHeap[ 0 ];

	if ( lrulistLRUK.pbfMRU )
		return lrulistLRUK.pbfMRU;

	if ( pbgcb->lrulist.pbfMRU )
		return pbgcb->lrulist.pbfMRU;

	if ( !FBFWriteHeapEmpty() )
		return rgpbfHeap[ ipbfHeapMax - 1 ];
	
	if ( lrulistPreread.pbfMRU )
		return lrulistPreread.pbfMRU;

	return pbfNil;
	}


/* conditions to Write a buffer
/**/
INLINE BOOL FBFIWritable( BF *pbf )
	{
	BOOL f;

	Assert( pbf->fHold );

	/* no one is depending on it
	/**/
	EnterCriticalSection( pbf->critBF );
	f = (
			pbf->pn != pnNull &&		/* valid page number */
			pbf->fDirty &&				/* being dirtied */

#ifndef NOLOG
			(							/* if log is on, log record of last */
			fLogDisabled ||				/* operation on the page has flushed */
			fRecovering  ||
			CmpLgpos( &pbf->lgposModify, &lgposToFlush ) < 0 ) &&
#endif
			!pbf->fPreread &&
			!pbf->fRead &&				/* not being read/written */
			!pbf->fWrite &&
			pbf->cDepend == 0
		);
	LeaveCriticalSection( pbf->critBF );

	return f;
	}


/*  Move a buffer to BFWrite heap
/**/
INLINE VOID BFIMoveToBFWriteHeap ( BF *pbf )
	{
	PGNO    pgno = PgnoOfPn( pbf->pn );
	DBID    dbid = DbidOfPn( pbf->pn );
	FMP     *pfmp = &rgfmp[ dbid ];

	/* set the buffer for Write.
	/**/
	Assert( pbf->fHold == fTrue );
	Assert( pbf->cPin == 0 );
	Assert( pbf->fRead == fFalse );
	Assert( pbf->fWrite == fFalse );

	pgno--;
	pbf->olp.ulOffset = pgno << 12;
	pbf->olp.ulOffsetHigh = pgno >> (32 - 12);
	pbf->hf = pfmp->hf;
	SignalReset( pbf->olp.sigIO ); // UNDONE: no need?

	EnterCriticalSection( critBFWrite );
	Assert( pbf->ipbfHeap == ipbfDangling );
	BFWriteAddToHeap(pbf);

	EnterCriticalSection(pbf->critBF);
	pbf->fHold = fFalse;
	LeaveCriticalSection(pbf->critBF);
	
	LeaveCriticalSection( critBFWrite );
	}


VOID BFIssueAsyncWrite( INT cIOMax, INT *pcIOIssued, BOOL fNoSleep )
	{
	ERR		err;
	BOOL	fTooManyIOs = fFalse;
	INT		cIOMac = 0;
	BF		*pbf;
	BF		*pbfFirst;
	PAGE	*ppageToWrite;
	INT		ipageFirst;
	INT		cpbfBatchWriteMac;
	INT		cpageBatchWrite;
	BF		*pbfLast;
	INT		cmsec;
	DBID	dbid;

	EnterCriticalSection( critBFWrite );
	while ( !FBFWriteHeapEmpty() &&
	   	!fTooManyIOs &&
	   	cIOMac < cIOMax )
		{
		cpbfBatchWriteMac = 0;
		cpageBatchWrite = 0;
		pbfLast = pbfNil;

		do {
			pbf = rgpbfHeap[ ipbfHeapMax - 1 ];

			Assert( !FBFInUse( ppibNil, pbf ) );
			Assert( pbf->cDepend == 0 );
		
			if ( pbfLast == pbfNil )
				{
				/* first hit in this do-while loop
				/**/
				pbfFirst = pbf;
				pbfLast = pbf;
				}
			else if ( pbfLast->pn == pbf->pn - 1 )
				{
				/*  the page on top of heap is contiguous to last page
				/*  check if we have enough batch IO buffer.
				/**/
				if ( pbfLast == pbfFirst )
					{
					/* we now need batch buffers
					/**/
					EnterCriticalSection( critBatchIO );
					cpageBatchWrite = ipageBatchIOMax;
					BFGetLargestBatchIOBuffers( &ipageFirst, &cpageBatchWrite );
					Assert( cpageBatchWrite == 0 || cpageBatchWrite > 1 );
					LeaveCriticalSection( critBatchIO );
					}
		
				if ( cpbfBatchWriteMac + 1 > cpageBatchWrite )
					{
					/*  not enough batch IO buffers
					/**/
					break;
					}
	
				/* continuous page
				/**/
				pbfLast->pbfNextBatchIO = pbf;
				pbfLast = pbf;
				}
			else
				{
				/*  page is not contiguous
				/**/
				break;
				}

			/*  hold it before taken out.
			/*  no need to set fHold in critBF since we are in critBFWrite
			/**/
			EnterCriticalSection( pbf->critBF );
			pbf->fHold = fTrue;
			LeaveCriticalSection( pbf->critBF );
	
			BFWriteTakeOutOfHeap( pbf );
			cpbfBatchWriteMac++;

			Assert( pbf->fDirty );

			EnterCriticalSection( pbf->critBF );
			Assert( pbf->cPin == 0 );
			pbf->fHold = fFalse;
			pbf->fWrite = fTrue;
			LeaveCriticalSection( pbf->critBF );

			dbid = DbidOfPn( pbf->pn );
			
			//	UNDONE:	find a better solution for the ulDBTime 
			//			checkpoint bug.  The bug is that we cannot
			//			know to update the ulDBTime in the database
			//			since the checkpoint may be after the 
			//			update operation increasing the ulDBTime.
			/* if it is first page, do an in-place update ulDBTime
			/**/
			if ( !fRecovering && dbid != dbidTemp && PgnoOfPn( pbf->pn ) == 1 )
				{
				SSIB	ssib;
				ULONG	*pulDBTime;
			
				ssib.pbf = pbf;
				ssib.itag = 0;
				CallS( ErrPMGet( &ssib, ssib.itag ) );
				pulDBTime = (ULONG *) ( ssib.line.pb + ssib.line.cb -
					sizeof(ULONG) - sizeof(USHORT) );
				*(UNALIGNED ULONG *) pulDBTime = rgfmp[ dbid ].ulDBTime;
				}

//			Assert( DbidOfPn( pbf->pn ) == dbidTemp || pbf->ppage->pghdr.ulDBTime > 0 );

#ifdef  CHECKSUM
			pbf->ppage->pghdr.ulChecksum = UlChecksumPage( pbf->ppage );
#ifdef HONOR_PAGE_TIME
			Assert( fRecovering ||
				DbidOfPn((pbf)->pn) == dbidTemp ||
				pbf->ppage->pghdr.ulDBTime <=
				rgfmp[ DbidOfPn(pbf->pn) ].ulDBTime );
#endif
		
			CheckPgno( pbf->ppage, pbf->pn ) ;
#endif  /* CHECKSUM */
			}
		while ( !FBFWriteHeapEmpty() &&
			( cpbfBatchWriteMac == 1 ||
			cpbfBatchWriteMac < cpageBatchWrite ) );

		pbfLast->pbfNextBatchIO = pbfNil;
		Assert( cpbfBatchWriteMac > 0 );

		/* free unused batch write buffer
		/**/
		if ( cpageBatchWrite > cpbfBatchWriteMac )
			{
			INT ifBatchWrite;
			INT ifBatchWriteMax = ipageFirst + cpageBatchWrite;

			if ( cpbfBatchWriteMac == 1 )
				ifBatchWrite = ipageFirst;
			else
				ifBatchWrite = ipageFirst + cpbfBatchWriteMac;
			BFFreeBatchIOBuffers( ifBatchWrite, ifBatchWriteMax - ifBatchWrite );
			}

		if ( cpbfBatchWriteMac == 1 )
			{
			ppageToWrite = pbfFirst->ppage;
			pbfFirst->ipageBatchIOFirst = -1;
			}
		else
			{
			INT ipage = ipageFirst;

			pbf = pbfFirst;
			do {
				Assert( pbf->fWrite );
				Assert( cbPage == sizeof(PAGE) );
				memcpy( &rgpageBatchIO[ipage], pbf->ppage, sizeof(PAGE) );
				pbf = pbf->pbfNextBatchIO;
				ipage++;
				}
			while ( pbf != pbfNil );
			ppageToWrite = &rgpageBatchIO[ ipageFirst ];
			pbfFirst->ipageBatchIOFirst = ipageFirst;
			}
			
		cmsec = 1;
		cIOMac++;
		EnterCriticalSection( critIOActive );
		cIOActive++;
		fTooManyIOs = cIOActive > lAsynchIOMax;
		LeaveCriticalSection( critIOActive );

		while ( ( err = ErrSysWriteBlockEx(
			pbfFirst->hf,
			(BYTE *)ppageToWrite,
			cbPage * cpbfBatchWriteMac,
			&pbfFirst->olp,
			BFIOWriteComplete ) ) < 0 )
			{
			/* issue write fail, skip this page
			/**/
			if ( !fNoSleep && err == JET_errTooManyIO )
				{
				cmsec <<= 1;
				LeaveCriticalSection( critBFWrite );
				SysSleepEx( cmsec - 1, fTrue );
				EnterCriticalSection( critBFWrite );
				}
			else
				{
				pbf = pbfFirst;

				do {
					BF *pbfNext = pbf->pbfNextBatchIO;
				   
					/*	assert that buffer is still dirty
					/**/
					Assert( pbf->fDirty == fTrue );

					/* those pages are failed to be written, put back
					/* to LRUK heap.
					/**/
					LeaveCriticalSection( critBFWrite );
					EnterCriticalSection( critLRUK );
					BFLRUKAddToHeap( pbf );
					LeaveCriticalSection( critLRUK );
					EnterCriticalSection( critBFWrite );

					/* set it as accessible
					/**/
					EnterCriticalSection( pbf->critBF );
					pbf->fWrite = fFalse;
					LeaveCriticalSection( pbf->critBF );
					
					pbf = pbfNext;
					}
				while ( pbf != pbfNil );

				if ( cpbfBatchWriteMac > 1 )
					{
					BFFreeBatchIOBuffers( ipageFirst, cpbfBatchWriteMac );
					}

				/* leave the while loop
				/**/
				cIOMac--;
				EnterCriticalSection( critIOActive );
				cIOActive--;
				fTooManyIOs = cIOActive > lAsynchIOMax;
				LeaveCriticalSection( critIOActive );
				break;
				}
			} /* while writeEx is issued successfully */
		
		} /* while there are IO to do */
	
	LeaveCriticalSection( critBFWrite );
	*pcIOIssued = cIOMac;
	
#ifdef DEBUG
	EnterCriticalSection( critBFWrite );
	LeaveCriticalSection( critBFWrite );
#endif
	}


LOCAL VOID __stdcall BFIOWriteComplete( LONG err, LONG cb, OLP *polp )
	{
	BF    *pbfFirst = (BF *) (((CHAR *)polp) - ((CHAR *)&((BF *)0)->olp));
	INT	  ipageFirst = pbfFirst->ipageBatchIOFirst;
	BF	  *pbf;
	INT	  cpbf;
	INT	  cpageTotal = 0;
	PN    pn = pbfFirst->pn;
	DBID  dbid = DbidOfPn( pn );
	FMP   *pfmp = &rgfmp[ dbid ];
	INT   cIOIssued;
	BOOL  fAppendPages = fFalse;

#ifdef DEBUG
#ifdef DEBUGGING
	INT		ipage = ipageFirst;
#endif
	{
	ULONG	ulPgno;

	LFromThreeBytes( ulPgno, pbfFirst->ppage->pgnoThisPage );
	Assert( ulPgno != 0 );
	}

	/*	check multipage buffer for non-zero pages
	/**/
	if ( ipageFirst != -1 )
		{
		INT	ipageT = ipageFirst;
		INT	cpageT = 0;
		BF	*pbfT;

		for ( pbfT = pbfFirst; pbfT != pbfNil; pbfT = pbfT->pbfNextBatchIO )
			cpageT++;

//		SysCheckWriteBuffer( (BYTE *)&rgpageBatchIO[ipageT], cpageT * cbPage );
		}

	/*	assert that bytes written is correct for number of buffers
	/**/
	{
	INT	cbfT;
	BF	*pbfT;

	for ( pbfT = pbfFirst, cbfT = 0;
		pbfT != pbfNil;
		pbfT = pbfT->pbfNextBatchIO, cbfT++ );

	Assert( cbfT * cbPage == cb );
	}
#endif

	for ( pbf = pbfFirst; pbf != pbfNil; pbf = pbf->pbfNextBatchIO, cpageTotal++ )
		{
		Assert( pbf->cDepend == 0 );
		Assert( pbf->fWrite );
		Assert( pbf->pn );
		Assert( pbf->pbfNextBatchIO == pbfNil || pbf->pn + 1 == pbf->pbfNextBatchIO->pn );
		
#ifdef DEBUGGING
		printf(" (%d,%d) ", DbidOfPn(pbf->pn), PgnoOfPn(pbf->pn));
#endif
		}
#ifdef DEBUGGING
		printf(" -- %d\n", cpageTotal );
#endif

	/* if write fail, do not clean up this buffer
	/**/
	if ( err != JET_errSuccess )
		{
		BF *pbf = pbfFirst;
		
		BFDiskIOEvent( pbf, err, "Async write fail", cpageTotal, 0 );
		
		/* fail to write, free them. set the buffers dirty but available
		/**/
		do {
			BF *pbfNext = pbf->pbfNextBatchIO;
			
			/* put back to LRUK heap
			/**/
			EnterCriticalSection( critLRUK );
			BFLRUKAddToHeap( pbf );
			LeaveCriticalSection( critLRUK );
			
			EnterCriticalSection( pbf->critBF );
			Assert( pbf->fDirty );
			Assert( pbf->fWrite == fTrue );
			Assert( pbf->fHold == fFalse );
			Assert( pbf->fRead == fFalse );
			pbf->fWrite = fFalse;
			pbf->fIOError = fTrue;
			pbf->err = JET_errDiskIO;
			LeaveCriticalSection( pbf->critBF );
			
			pbf = pbfNext;
			
			} while ( pbf != pbfNil );
			
		goto Done;
		}

	cpbf = 0;
	pbf = pbfFirst;
	do {
		Assert( pbf->fWrite );

		/* if backup is going on
		/**/
		if ( pbf->hf != pfmp->hfPatch &&
			pbf->pbfDepend &&
			pfmp->pgnoCopied >= PgnoOfPn(pbf->pn) )
			{
			/* append page to patch file
			/**/
			fAppendPages = fTrue;
			}
		cpbf++;
		pbf = pbf->pbfNextBatchIO;
		} while ( pbf != pbfNil );
			
	if ( fAppendPages )
		{
		PGNO    pgno = pfmp->cpage;

		Assert( pbfFirst->fWrite );
		pfmp->cpage += cpbf;
			
		pbfFirst->olp.ulOffset = pgno << 12;
		pbfFirst->olp.ulOffsetHigh = pgno >> (32 - 12);
		pbfFirst->hf = pfmp->hfPatch;

//		Assert( DbidOfPn( pbfFirst->pn ) == dbidTemp || pbfFirst->ppage->pghdr.ulDBTime > 0 );
		
#ifdef  CHECKSUM
		Assert( pbfFirst->ppage->pghdr.ulChecksum ==
			UlChecksumPage( pbfFirst->ppage ) );
#ifdef HONOR_PAGE_TIME
		Assert( fRecovering ||
			DbidOfPn(pbfFirst->pn) == dbidTemp ||
			pbfFirst->ppage->pghdr.ulDBTime <=
			rgfmp[ DbidOfPn(pbfFirst->pn) ].ulDBTime );
#endif
		CheckPgno( pbfFirst->ppage, pbfFirst->pn );
#endif  /* CHECKSUM */

		/* set it as ready for repeated write to patch file
		/**/
		EnterCriticalSection(pbfFirst->critBF);
		Assert( pbfFirst->fWrite == fTrue );
		LeaveCriticalSection(pbfFirst->critBF);

#ifdef DEBUG
		EnterCriticalSection(critBFWrite);
		LeaveCriticalSection(critBFWrite);
#endif
		return;
		}
		
	pbf = pbfFirst;
	do {
		BF *pbfNext = pbf->pbfNextBatchIO;

		EnterCriticalSection( critAvail );
		BFAddToListAtMRUEnd( pbf, &pbgcb->lrulist );
		LeaveCriticalSection( critAvail );

		pbf->lgposRC = lgposMax;

		EnterCriticalSection( pbf->critBF );
		pbf->fDirty = fFalse;
		Assert( pbf->fPreread == fFalse );
		Assert( pbf->fHold == fFalse );
		Assert( pbf->fRead == fFalse );
		Assert( pbf->fWrite == fTrue );
		pbf->fWrite = fFalse;
		pbf->fHold = fTrue;
		pbf->fIOError = fFalse;
		BFUndepend( pbf );

		Assert( pbf->cPin == 0 );
		
		pbf->fHold = fFalse;
		
		LeaveCriticalSection( pbf->critBF );

#ifdef DEBUGGING
		{
		ULONG ulNext, ulPrev, ulThisPage;
		LFromThreeBytes(ulPrev, pbf->ppage->pghdr.pgnoPrev );
		LFromThreeBytes(ulNext, pbf->ppage->pghdr.pgnoNext );
		LFromThreeBytes(ulThisPage, pbf->ppage->pgnoThisPage );
		printf("Write %2d - %2d,%4d - %2d <%lu %lu> (%lu, %lu, %lu)\n",
			cpbf, DbidOfPn(pbf->pn), PgnoOfPn(pbf->pn),
			ipage++,
			rgfmp[DbidOfPn(pbf->pn)].ulDBTime, pbf->ppage->pghdr.ulDBTime,
			ulPrev, ulNext, ulThisPage);

//		Assert( DbidOfPn( pbf->pn ) == dbidTemp || pbf->ppage->pghdr.ulDBTime > 0 );
		
#ifdef  CHECKSUM
		Assert(	pbf->ppage->pghdr.ulChecksum == UlChecksumPage( pbf->ppage ));
#ifdef HONOR_PAGE_TIME
		Assert( fRecovering ||
			DbidOfPn((pbf)->pn) == dbidTemp ||
			pbf->ppage->pghdr.ulDBTime <=
			rgfmp[ DbidOfPn(pbf->pn) ].ulDBTime );
#endif
		CheckPgno( pbf->ppage, pbf->pn );
#endif  /* CHECKSUM */
		}
#endif

		pbf = pbfNext;
		}
	while ( pbf != pbfNil );

Done:
	if ( ipageFirst != -1 )
		{
		BFFreeBatchIOBuffers( ipageFirst, cpageTotal );
		}

	/*	write additional buffer, for performance reasons to
	/*	maintain given number of outstanding IOs.
	/*	Note, to avoid stack overflow, do not allow SleepEx
	/*	by calling issue async write with sleep not allowed.
	/**/
	BFIssueAsyncWrite( 1, &cIOIssued, fSleepNotAllowed );
	
	if ( cIOIssued == 0 )
		{
		EnterCriticalSection( critIOActive );
		cIOActive--;
		LeaveCriticalSection( critIOActive );
		}
	}
	

//+api------------------------------------------------------------------------
//
//	ErrBFFlushBuffers
//	=======================================================================
//
//	VOID ErrBFFlushBuffers( DBID dbidToFlush, INT fBFFlush )
//
//	Write all dirty database pages to the disk.
//	Must attempt to flush buffers repetatively since dependencies
//	may prevent flushable buffers from being written on the first
//	iteration.
//----------------------------------------------------------------------------

ERR ErrBFFlushBuffers( DBID dbidToFlush, INT fBFFlush )
	{
	ERR		err = JET_errSuccess;
	BF		*pbf;
	BF		*pbfMax;
	BOOL	fReleaseCritJet;
	BOOL	fContinue;
	INT		cIOReady;
	BOOL	fIONotDone;
	BOOL	fFirstPass;

	Assert( fBFFlush == fBFFlushAll || fBFFlush == fBFFlushSome );

	/*	if flush all then flush log first since WAL
	/**/
	if ( !fLogDisabled && fBFFlush == fBFFlushAll )
		{
#ifdef ASYNC_LOG_FLUSH
		SignalSend(sigLogFlush);
#else
		CallR( ErrLGFlushLog() );
#endif
		}

	AssertCriticalSection( critJet );

#ifdef DEBUGGING
	printf("Flush Begin:\n");
#endif

	/*  update all database root
	/**/
	if ( fBFFlush == fBFFlushAll )
		{
		if ( dbidToFlush )
			{
			Assert( FIODatabaseOpen( dbidToFlush ) );
			CallR( ErrDBUpdateDatabaseRoot( dbidToFlush ) )
			}
		else
			{
			DBID dbidT;

			for ( dbidT = dbidMin; dbidT < dbidUserMax; dbidT++ )
				if ( FIODatabaseOpen( dbidT ) )
					CallR( ErrDBUpdateDatabaseRoot( dbidT ) )
			}
		}

#ifdef DEBUG
	if ( fBFFlush == fBFFlushAll )
		{
		if ( dbidToFlush != 0 )
			{
			DBIDSetFlush( dbidToFlush );
			}
		else
			{
			DBID dbidT;

			for ( dbidT = dbidMin; dbidT < dbidUserMax; dbidT++ )
				DBIDSetFlush( dbidT );
			}
		}
#endif

BeginFlush:
	err = JET_errSuccess;

	/*	flush buffers in dependency order
	/**/
	fFirstPass = fTrue;
	cIOReady = 0;
	do
		{
		fReleaseCritJet = fFalse;
		fContinue = fFalse;

		pbf = pbgcb->rgbf;
		pbfMax = pbf + pbgcb->cbfGroup;
		for ( ; pbf < pbfMax; pbf++ )
			{
			DBID dbid;
			
			dbid = DbidOfPn( pbf->pn );
#ifdef DEBUG
#ifdef FITFLUSHPATTERN
			if ( !FFitFlushPattern( pbf->pn ) )
				continue;
#endif
#endif
			if ( dbidToFlush == 0 )
				{
				/* if flush all, do not flush temp database
				/**/
				if ( dbid == dbidTemp )
					continue;
				}
			else
				{
				/* flush only the specified database's buffers
				/**/
				if ( dbidToFlush != dbid )
					continue;
				}

			/*  try to flush even those buffers which had previous
			/*  write errors.  This is one last chance for the buffers
			/*  to be flushed.  It also allows the correct error code
			/*  to be returned.
			/**/
			if ( pbf->cDepend != 0 && !fLGNoMoreLogWrite )  /*  avoids infinite flush loop on Log Down  */
				{
				fContinue = fTrue;
				continue;
				}

			/*  try to hold the buffer, if the buffer is in BFWrite heap
			/*  already, do not bother to touch it.
			/**/
			EnterCriticalSection( critBFWrite );
			if ( FBFInBFWriteHeap( pbf ) )
				{
				LeaveCriticalSection( critBFWrite );
				fContinue = fTrue;
				continue;
				}
			LeaveCriticalSection( critBFWrite );

			if ( !FBFHoldBuffer( ppibNil, pbf ) )
				{
				fContinue = fTrue;
				fReleaseCritJet = fTrue;
				continue;
				}

			if ( FBFIWritable( pbf ) )
				{
				/* if there were error during last IO, try it once again and
				/* only once.
				/**/
				if ( !fFirstPass && pbf->fIOError )
					{
					/* no need to write again
					/**/
					continue;
					}

				BFIMoveToBFWriteHeap( pbf );
				/* pbf->fHold is reset in BFIMoveToBFWriteHeap
				/**/

				if ( ++cIOReady >= lAsynchIOMax / 2 )
					{
					SignalSend( sigBFWriteProc );
					cIOReady = 0;
					}
				}
			else
				{
				/*	if flushing all buffers for dbid or all dbids,
				/*	then all buffer for dbid or all dbids should
				/*	be writable or not dirty unless it is being
				/*	written out by BFClean or waiting for log to flush.
				/**/
				BOOL f = 0;

				EnterCriticalSection( pbf->critBF );
#ifndef NOLOG
				f = ( !fLogDisabled &&
					 !fRecovering  &&
					 CmpLgpos( &pbf->lgposModify, &lgposToFlush ) >= 0 );
				if ( f && !fLGNoMoreLogWrite )  /*  avoids infinite flush loop on Log Down  */
					{
					/* flush log
					/**/
					SignalSend(sigLogFlush);
					}
#endif
				f = f || ( pbf->cDepend != 0 );
				LeaveCriticalSection( pbf->critBF );

				/* put back to lruk heap
				/**/
				EnterCriticalSection( critLRUK );
				Assert( pbf->fHold );
				BFLRUKAddToHeap( pbf );
				LeaveCriticalSection( critLRUK );
				
				EnterCriticalSection( pbf->critBF );
				pbf->fHold = fFalse;
				LeaveCriticalSection( pbf->critBF );

				if ( f && !fLGNoMoreLogWrite )  /*  avoids infinite flush loop on Log Down  */
					{
					/* need to continue loop to wait for BFClean or
					/* Log Flush thread to finish IO.
					/**/
					fContinue = fTrue;
					fReleaseCritJet = fTrue;
					}
				else
					{
					Assert( fLGNoMoreLogWrite || fBFFlush == fBFFlushSome || pbf->fWrite || !pbf->fDirty );
					}
				}
			} /* for */

		if ( cIOReady )
			{
			SignalSend( sigBFWriteProc );
			cIOReady = 0;
			}

		if ( fReleaseCritJet )
			BFSleep( cmsecWaitGeneric );
		
		fFirstPass = fFalse;
		}
#ifdef DEBUG
	while ( err == JET_errSuccess &&
		( fDBGForceFlush || !fDBGSimulateSoftCrash ) &&
		fContinue );
#else
	while ( err == JET_errSuccess &&
		fContinue );
#endif

	if ( cIOReady )
		SignalSend( sigBFWriteProc );

	/* every page should be written out successfully.
	/* except out of disk space.
	/**/
	forever
		{
		fIONotDone = fFalse;

		pbf = pbgcb->rgbf;
		Assert( pbfMax == pbf + pbgcb->cbfGroup );
		for ( ; pbf < pbfMax; pbf++ )
			{
			DBID dbid = DbidOfPn( pbf->pn );
#ifdef DEBUG
#ifdef FITFLUSHPATTERN
			if ( !FFitFlushPattern( pbf->pn ) )
				continue;
#endif
#endif
			if ( dbidToFlush == 0 )
				{
				/* if flush all, do not flush temp database
				/**/
				if ( dbid == dbidTemp )
					continue;
				}
			else
				{
				/* flush only the specified database's buffers
				/**/
				if ( dbidToFlush != dbid )
					continue;
				}

			EnterCriticalSection( critBFWrite );
			if ( FBFInBFWriteHeap( pbf ) )
				{
				LeaveCriticalSection( critBFWrite );
				fIONotDone = fTrue;
				continue;
				}
			
			EnterCriticalSection( pbf->critBF );
			if ( FBFInUse( ppibNil, pbf ) || pbf->fDirty )
			{
				if ( !fLGNoMoreLogWrite )  /*  avoids infinite flush loop on Log Down  */
					fIONotDone = fTrue;
			}
			LeaveCriticalSection( pbf->critBF );

			if ( pbf->fIOError && pbf->fDirty )
				{
				if ( err == JET_errSuccess )
					{
					/* no error code set yet, set it
					/**/
					err = pbf->err;
					}
				}

			LeaveCriticalSection( critBFWrite );
			}

		if ( fIONotDone )
			{
			BFSleep( cmsecWaitGeneric );
			goto BeginFlush;
			}
		else
			break;
		}

#ifdef DEBUG
	if ( fBFFlush == fBFFlushAll )
		{
		if ( dbidToFlush != 0 )
			DBIDResetFlush( dbidToFlush );
		else
			{
			DBID dbidT;

			for ( dbidT = dbidMin; dbidT < dbidUserMax; dbidT++ )
				DBIDResetFlush( dbidT );
			}
		}

	/*	if flush all buffers then no dirty buffers should remain
	/**/
	if ( fBFFlush == fBFFlushAll )
		{
		pbf = pbgcb->rgbf;
		pbfMax = pbf + pbgcb->cbfGroup;
		for ( ; pbf < pbfMax; pbf++ )
			{
#ifdef FITFLUSHPATTERN
			if ( !FFitFlushPattern( pbf->pn ) )
				continue;
#endif
			if ( ( dbidToFlush == 0 && DbidOfPn ( pbf->pn ) != 0 ) ||
				( dbidToFlush != 0 && DbidOfPn ( pbf->pn ) == dbidToFlush )     )
				Assert( !pbf->fDirty || fLGNoMoreLogWrite );  /*  disable assert if Log Down (will be dirty bufs)  */
			}
		}
#endif

#ifdef DEBUGGING
	printf("Flush End.\n");
#endif
	
	return err;
	}


/*	PARAMETERS      fHowMany clean up
/*
/*	RETURNS         JET_errOutOfMemory              no flushable buffers
/*					wrnBFNotSynchronous             buffer flushed
/**/
LOCAL ERR ErrBFClean( BOOL fHowMany )
	{
	ERR     err = JET_errSuccess;
	BF      *pbf;
	INT     cIOReady = 0;
	INT		cbfAvailPossible;
	INT		cmsec = 10;

	AssertCriticalSection( critJet );

Start:
	cbfAvailPossible = 0;

	EnterCriticalSection( critLRUK );
	while( !FBFLRUKHeapEmpty() && cbfAvailPossible < pbgcb->cbfThresholdHigh )
		{
		BOOL fHold;
		
		pbf = rgpbfHeap[0];
		BFLRUKTakeOutOfHeap(pbf);
		
#ifdef DEBUG
#ifdef FITFLUSHPATTERN
		if ( !FFitFlushPattern( pbf->pn ) )
			continue;
#endif
#endif

		/*  try to hold the buffer
		/*  if buffer has been latched, then continue to next buffer.
		/**/
		fHold = fFalse;

		EnterCriticalSection( pbf->critBF );
		if ( !FBFInUse( ppibNil, pbf ) )
			pbf->fHold = fHold = fTrue;
		LeaveCriticalSection( pbf->critBF );

		if ( !fHold )
			{
			/* put into a temporary list */
			BFAddToListAtMRUEnd( pbf, &lrulistLRUK );
			continue;
			}
		else if ( !pbf->fDirty )
			{
			/* put into a available list */
			EnterCriticalSection( critAvail );
			BFAddToListAtMRUEnd(pbf, &pbgcb->lrulist);
			LeaveCriticalSection( critAvail );

			EnterCriticalSection( pbf->critBF );
			pbf->fHold = fFalse;
			LeaveCriticalSection( pbf->critBF );

			cbfAvailPossible++;
			continue;
			}
		else if ( !FBFIWritable( pbf ) )
			{
			BFAddToListAtMRUEnd(pbf, &lrulistLRUK );
			EnterCriticalSection( pbf->critBF );
			pbf->fHold = fFalse;
			LeaveCriticalSection( pbf->critBF );
			}
		else
			{
			/*  since pbf is just taken from LRUK heap and we are still in
			/*  the same critical section and hold it, no one can be doing
			/*  IO on this buffer.
			/**/

			if ( fHowMany != fOneBlock )
				{
				BFIMoveToBFWriteHeap ( pbf );
				/* fHold is reset in BFIMoveToBFWriteHeap */
				cbfAvailPossible++;
				if ( ++cIOReady >= lAsynchIOMax / 2 )
					{
					SignalSend( sigBFWriteProc );
					cIOReady = 0;
					}
				}
			else
				{
				err = JET_errSuccess;
				
				/* set the buffer for write
				/**/
				Assert( pbf->fHold == fTrue );
				Assert( pbf->fRead == fFalse );
				Assert( pbf->fWrite == fFalse );
//				Assert( pbf->fIOError == fFalse );

				EnterCriticalSection( pbf->critBF );
				Assert( pbf->fRead == fFalse );
				pbf->fHold = fFalse;
				Assert( pbf->cPin == 0 );
				pbf->fWrite = fTrue;
				LeaveCriticalSection( pbf->critBF );

				LeaveCriticalSection( critLRUK );
				BFIOSync( pbf );
				EnterCriticalSection( critLRUK );

				EnterCriticalSection( pbf->critBF );
				Assert( pbf->fRead == fFalse );
				pbf->fWrite = fFalse;
				pbf->fHold = fTrue;
				LeaveCriticalSection( pbf->critBF );

				Assert( pbf->fIOError || pbf->pbfDepend == pbfNil );
				Assert( pbf->cPin == 0 );
				if ( pbf->fIOError )
					{
					BFAddToListAtMRUEnd( pbf, &lrulistLRUK );
					err = pbf->err;
					}
				else
					{
					EnterCriticalSection( critAvail );
					BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
					LeaveCriticalSection( critAvail );
					}

				EnterCriticalSection( pbf->critBF );
				pbf->fHold = fFalse;
				LeaveCriticalSection( pbf->critBF );
				
				if ( err && err != JET_errDiskFull )
					continue;

				break;
				}
			}
		}

	if ( cIOReady )
		{
		SignalSend( sigBFWriteProc );
		}

	/*  put back the temp list */
	while ( ( pbf = lrulistLRUK.pbfLRU ) != pbfNil )
		{
		BFTakeOutOfList( pbf, &lrulistLRUK );
		BFLRUKAddToHeap( pbf );
		}

	/*  set return code */
	if ( fHowMany == fOneBlock )
		{
		if ( err == JET_errSuccess )
			err = wrnBFNotSynchronous;
		}
	else
		{
		if ( pbgcb->lrulist.cbfAvail > 0 )
			err = wrnBFNotSynchronous;
		else
			{
			if (cbfAvailPossible > 0)
				{
				/* give it one more chance to see if all IO are done */
				LeaveCriticalSection( critLRUK );
				cmsec <<= 1;
				BFSleep( cmsec - 1 );
				goto Start;
				}
			err = JET_errOutOfMemory;
			}
		}

	LeaveCriticalSection( critLRUK );

	return err;
	}


#ifdef  ASYNC_BF_CLEANUP


/*      BFClean runs in its own thread moving pages to the free list.   This
/*      helps insure that user requests for free buffers are handled quickly
/*      and synchonously.  The process tries to keep at least
/*      pbgcb->cbfThresholdLow buffers on the free list.
/**/
LOCAL VOID BFCleanProcess( VOID )
	{
	forever
		{
		SignalReset( sigBFCleanProc );

		SignalWait( sigBFCleanProc, 30000 );

		EnterCriticalSection( critJet );
		pbgcb->cbfThresholdHigh = rgres[iresBF].cblockAlloc;

		/* update LRU_K interval */
		ulBFFlush3 = ulBFFlush2;
		ulBFFlush2 = ulBFFlush1;
		ulBFFlush1 = ulBFTime;
		if ( lBufLRUKCorrelationInterval )
			/* user defined correlation interval, use it */
			ulBFCorrelationInterval = (ULONG) lBufLRUKCorrelationInterval;
		else
			ulBFCorrelationInterval =
				( 3 * (ulBFFlush1 - ulBFTime) +
				  3 * (ulBFFlush2 - ulBFTime) / 2 +
				  (ulBFFlush3 - ulBFTime)
				) / 3;

		(VOID)ErrBFClean( fAllPages );

		LeaveCriticalSection( critJet );

		if ( fBFCleanProcessTerm )
			break;
		}

//	/*      exit thread on system termination.
//	/**/
//	SysExitThread( 0 );
	return;
	}


/*  BFWrite runs in its own thread writing/reading pages that are in IOReady
/*  state.
/**/
LOCAL VOID BFWriteProcess( VOID )
	{
	forever
		{
		INT cIOIssued;

		SignalWaitEx( sigBFWriteProc, -1, fTrue );
MoreIO:
		BFIssueAsyncWrite( lAsynchIOMax, &cIOIssued, fSleepAllowed );

		if ( fBFWriteProcessTerm )
			{
			/* check if any page is still in read write state
			/* after this point, no one should ever continue putting
			/* pages for IO.
			/**/
			BF	*pbf = pbgcb->rgbf;
			BF	*pbfMax = pbf + pbgcb->cbfGroup;

			for ( ; pbf < pbfMax; pbf++ )
				{
				DBID	dbid = DbidOfPn( pbf->pn );
				BOOL	f;
#ifdef DEBUG                            
#ifdef FITFLUSHPATTERN
				if ( !FFitFlushPattern( pbf->pn ) )
					continue;
#endif
#endif
				EnterCriticalSection( pbf->critBF );
				f = FBFInUse( ppibNil, pbf );
				LeaveCriticalSection( pbf->critBF );
				if ( f )
					{
					/* let the on-going IO have a chance to complete
					/**/
					SysSleepEx( 10, fTrue );
					goto MoreIO;
					}

				// UNDONE: report event
				Assert( !pbf->fIOError );
				}

			break; /* forever */
			}
		}

//	/* exit thread on system termination.
//	/**/
//	SysExitThread( 0 );
	return;
	}


#endif  /* ASYNC_BF_CLEANUP */


//+private---------------------------------------------------------------------
//
//	PbfBFISrchHashTable
//	===========================================================================
//	BF *PbfBFISrchHashTable( PN pn )
//
//	Search the buffer hash table for BF associated with PN.
//	Returns NULL if page is not found.
//
//	For efficiency, the Hash table functions might reasonably be
//	made into macros.
//
//-----------------------------------------------------------------------------

BF *PbfBFISrchHashTable( PN pn )
	{
	BF      *pbfCur;

	AssertCriticalSection( critJet );
	Assert( pn );

	pbfCur = rgpbfHash[ IpbfHashPgno( pn ) ];
	while ( pbfCur && pbfCur->pn != pn )
		pbfCur = pbfCur->pbfNext;

	return pbfCur;
	}


//+private----------------------------------------------------------------------
//	BFIInsertHashTable
//	===========================================================================
//
//	VOID BFIInsertHashTable( BF *pbf )
//
//	Add BF to hash table.
//----------------------------------------------------------------------------

VOID BFIInsertHashTable( BF *pbf )
	{
	INT     ipbf;

	AssertCriticalSection( critJet );

	Assert( pbf->pn );
	Assert( !PbfBFISrchHashTable( pbf->pn ) );
	Assert(	FBFInUse( ppibNil, pbf ) );

	ipbf = IpbfHashPgno( pbf->pn );
	pbf->pbfNext = rgpbfHash[ipbf];
	rgpbfHash[ipbf] = pbf;

#ifdef DEBUG
	Assert( !( pbf->fInHash ) );
	pbf->fInHash = fTrue;
#endif
	}


//+private----------------------------------------------------------------------
//
// BFIDeleteHashTable
// ===========================================================================
//
//      VOID BFIDeleteHashTable( BF *pbf )
//
// Delete pbf from hash table.  Currently functions searches for pbf and
// then deletes it.      Alternately a doubly-linked overflow list could be used.
//
//----------------------------------------------------------------------------

VOID BFIDeleteHashTable( BF *pbf )
	{
	BF      *pbfPrev;

#ifdef DEBUG
	Assert( pbf->fInHash );
	pbf->fInHash = fFalse;
#endif

	AssertCriticalSection( critJet );

	Assert( pbf->pn );
	Assert(	FBFInUse( ppibNil, pbf ) );

	pbfPrev = PbfFromPPbfNext( &rgpbfHash[IpbfHashPgno( pbf->pn )] );

	Assert( pbfPrev->pbfNext );
	while ( pbfPrev->pbfNext != pbf )
		{
		pbfPrev = pbfPrev->pbfNext;
		Assert( pbfPrev->pbfNext );
		}

	pbfPrev->pbfNext = pbf->pbfNext;
	}


//+api----------------------------------------------------------------------
//
// BFOldestLgpos
// ===========================================================================
//
//      LGPOS LgposBFOldest( void )
//
//      Returns time of oldest transaction creating version in buffer.
//
//----------------------------------------------------------------------------

void BFOldestLgpos( LGPOS *plgpos )
	{
	LGPOS   lgpos = lgposMax;
	BF		*pbf;
	BF		*pbfMax;

	/*	guard against logging asking for check point before
	/*	buffer manager initialized, after termination.
	/**/
	if ( fSTInit == fSTInitDone )
		{
		pbf = pbgcb->rgbf;
		pbfMax = pbf + pbgcb->cbfGroup;

		for( ; pbf < pbfMax; pbf++ )
			{
			if ( CmpLgpos( &pbf->lgposRC, &lgpos ) < 0 )
				lgpos = pbf->lgposRC;
			}
		}
	*plgpos = lgpos;
	return;
	}


#ifdef DEBUG

/* The following is for debugging purpose to flush a buffer
/**/
INT ForceBuf( PGNO pgno )
	{
	ERR             err;
	ULONG           pn;
	CHAR            filename[20];
	FILE            *pf;

	sprintf(filename, "c:\\#fb%x", pgno);
	pn = 0x2000000 + pgno;
	pf = fopen(filename, "w+b");
	if (pf == NULL)
		return -1;
	if ( rgpbfHash[( (pn + (pn>>18)) % ipbfMax )] == NULL )
		return -2;
	if ( rgpbfHash[( (pn + (pn>>18)) % ipbfMax )]->ppage == NULL )
		return -3;

	err =  (INT) fwrite((void*) rgpbfHash[( (pn + (pn>>18)) % ipbfMax )]->ppage, 1, cbPage, pf);
	fclose(pf);
	return err;
	}

#endif /* DEBUG */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\dbapi.c ===
#include "config.h"

#include <string.h>
#include <stdlib.h>
#include <stddef.h>

#include "daedef.h"
#include "util.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fmp.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "node.h"
#include "logapi.h"
#include "log.h"
#include "nver.h"
#include "dirapi.h"
#include "fileapi.h"
#include "systab.h"
#include "dbapi.h"
#include "bm.h"

DeclAssertFile;                                 /* Declare file name for Assert macros */

extern int itibGlobal;

typedef struct {
        BYTE    bDbid;
        BYTE    bLoggable;
        /*      must be last field in structure */
        CHAR    rgchDatabaseName[1];
} DBA;

extern PIB * __near ppibAnchor;
#ifdef DEBUG
extern BOOL fDBGForceFlush;
#endif

LOCAL ERR ErrDBRemoveDatabase( PIB *ppib, CHAR *szDatabaseName );
LOCAL ERR ErrDBAddDatabase( PIB *ppib, CHAR *szDatabaseName, DBID dbid );
LOCAL ERR ErrDBInitDatabase( PIB *ppib, DBID dbid, CPG cpg, BOOL fNoLogging );
LOCAL ERR ErrDBValidDatabaseFile( CHAR *szDatabaseName, ULONG *pulVersion, BOOL *pfLoggingCapable);


ERR ErrFMPSetDatabases( PIB *ppib )
        {
        ERR             err;
        FUCB    *pfucb;
        DIB             dib;
        DBID    dbid;
        INT             cchDatabaseName;

        CallR( ErrDIROpen( ppib, pfcbNil, dbidSystemDatabase, &pfucb ) );
        DIRGotoFDPRoot( pfucb );

        dib.pos = posFirst;
        dib.fFlags = fDIRNull;

        Call( ErrDIRSeekPath( pfucb, 1, pkeyDatabases, 0 ) );
        Call( ErrDIRDown( pfucb, &dib ) );

        do
                {
                Call( ErrDIRGet( pfucb ) );

                Assert( pfucb->lineData.cb > sizeof(BYTE) * 2 );
                dbid = (DBID) ((DBA *)pfucb->lineData.pb)->bDbid;
                rgfmp[dbid].fLogOn =
                rgfmp[dbid].fDBLoggable = (BOOL) ((DBA *)pfucb->lineData.pb)->bLoggable;
                cchDatabaseName = pfucb->lineData.cb - offsetof( DBA, rgchDatabaseName );
                /*      allocate bytes for database name with NULL terminator
                /**/
                if (!(rgfmp[dbid].szDatabaseName = SAlloc( cchDatabaseName + 1 )))
                        Error( JET_errOutOfMemory, HandleError );
                strncpy( rgfmp[dbid].szDatabaseName,
                        (BYTE *)&(((DBA *)pfucb->lineData.pb)->rgchDatabaseName),
                        cchDatabaseName );
                rgfmp[dbid].szDatabaseName[cchDatabaseName] = '\0';
                DBIDSetAttached( dbid );
                err = ErrDIRNext( pfucb, &dib );
                }
        while ( err >= 0 );

HandleError:
        DIRClose( pfucb );
        
        /*      polymorph end of file to JET_errSuccess
        /**/
        if ( err == JET_errRecordNotFound || err == JET_errNoCurrentRecord )
                err = JET_errSuccess;

        /*      return error code
        /**/
        return err;
        }


//+local
//      ErrDBInitDatabase
//      ========================================================================
//      ErrDBInitDatabase( PIB *ppib, DBID dbid, CPG cpgPrimary )
//
//      Initializes database structure.  Structure is customized for
//      system, temporary and user databases which are identified by
//      the dbid.  Primary extent is set to cpgPrimary but no allocation
//      is performed.  The effect of this routine can be entirely
//      represented with page operations.
//
//      PARAMETERS      ppib                    ppib of database creator
//                                      dbid                    dbid of created database
//                                      cpgPrimary      number of pages to show in primary extent
//
//      RETURNS         JET_errSuccess or error returned from called routine.
//-
LOCAL ERR ErrDBInitDatabase( PIB *ppib, DBID dbid, CPG cpgPrimary, BOOL fNoLogging )
        {
        ERR                             err;
        THREEBYTES              tbSize;
        THREEBYTES              tbLast;
        LINE                    line;
        KEY                     key;
        BYTE                    rgbT[sizeof(THREEBYTES)];
        FUCB                    *pfucb = pfucbNil;
        BYTE                    rgb[sizeof(DBROOT)];

        /*      set up the root page
        /**/
        CallR( ErrDIRBeginTransaction( ppib ) );

        /*      open cursor on database domain.
        /**/
        Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );

        rgfmp[dbid].ulDBTime = 0;

        /*      set system root node ( pgno, itag )=( 1, 0 ) as empty FDP node
        /**/
        Call( ErrNDNewPage( pfucb, pgnoSystemRoot, pgnoSystemRoot, pgtypFDP, fTrue ) );
        DIRGotoFDPRoot( pfucb );

        /*      data for root of database is magic number followed
        /*      by version number       (followed by timestamp followed by flags)
        /**/
        ((DBROOT *)rgb)->ulMagic = ulDAEMagic;
        ((DBROOT *)rgb)->ulVersion = ulDAEVersion;

        /* initialize timestamp */
        ( (DBROOT *)rgb)->ulDBTime = 0;

        /* initialize flags, set flags to "loggable" except TMP */
        ( (DBROOT *)rgb)->usFlags =
                ( FSysTabDatabase( dbid ) && !fNoLogging ) ? dbrootfLoggable : 0;

        line.cb = sizeof(DBROOT);
        line.pb = rgb;
        Call( ErrDIRReplace( pfucb, &line, fDIRNoVersion ) );

        /*      make the "ownext" node
        /**/
        ThreeBytesFromL( *( THREEBYTES *)rgbT, cpgPrimary );
        line.cb = sizeof(THREEBYTES);
        line.pb = rgbT;
        Call( ErrDIRInsert( pfucb, &line, pkeyOwnExt, fDIRNoVersion | fDIRBackToFather ) );

        /* make the "availext" node
        /**/
        ThreeBytesFromL( *( THREEBYTES *) rgbT, pgnoNull );
        Assert( line.cb == sizeof(THREEBYTES) );
        Assert( line.pb == (BYTE *)rgbT );
        Call( ErrDIRInsert( pfucb, &line, pkeyAvailExt, fDIRNoVersion | fDIRBackToFather ) );

        /* setup OwnExt tree
        /**/
        TbKeyFromPgno( tbLast, cpgPrimary );
        key.cb = sizeof(THREEBYTES);
        key.pb = (BYTE *) &tbLast;
        ThreeBytesFromL( tbSize, cpgPrimary );
        line.cb = sizeof(THREEBYTES);
        line.pb = (BYTE *) &tbSize;
        DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
        Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRBackToFather ) );

        /* setup AvailExt tree if there are any pages left
        /**/
        if ( --cpgPrimary > 0 )
                {
                DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
                ThreeBytesFromL( tbSize, cpgPrimary );
                Assert( line.cb == sizeof(THREEBYTES) );
                Assert( line.pb == (BYTE *) &tbSize );
                /* tbLast should still contain last page key
                */
                Assert( key.cb == sizeof(THREEBYTES) );
                Assert( key.pb == (BYTE *) &tbLast );
                Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRBackToFather ) );
                }

        /* goto FDP root and add pkeyTables son node.
        /**/
        DIRGotoFDPRoot( pfucb );

        line.cb = sizeof(WORD);
        line.pb = rgbT;
        *(WORD *)rgbT = 0;
        Call( ErrDIRInsert( pfucb, &line, pkeyTables, fDIRNoVersion | fDIRBackToFather ) );

        /*      system database
        /**/
        if ( dbid == dbidSystemDatabase )
                {
                /* add "databases" node
                /**/
                line.cb = 0;
                Call( ErrDIRInsert( pfucb, &line, pkeyDatabases, fDIRNoVersion | fDIRBackToFather ) );
                }

        /*      close cursor and commit operations
        /**/
        DIRClose( pfucb );
        pfucb = pfucbNil;
        Call( ErrDIRCommitTransaction( ppib ) );
        return err;

HandleError:
        if ( pfucb != pfucbNil )
                DIRClose( pfucb );
        CallS( ErrDIRRollback( ppib ) );
        return err;
        }


#ifdef NO_OVER_PREREAD
//to prevent read ahead over-preread, we may want to keep track of last
//page of the database.

ERR ErrDBSetLastPage( PIB *ppib, DBID dbid )
        {
        ERR err;
        DIB dib;
        FUCB *pfucb;

        CallR( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );
        DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
        dib.fFlags = fDIRNull;
        dib.pos = posLast;
        CallJ( ErrDIRDown( pfucb, &dib ), CloseFucb );
        Assert( pfucb->keyNode.cb == sizeof( THREEBYTES ) );
        PgnoFromTbKey( rgfmp[dbid].pgnoLast, *(THREEBYTES *) pfucb->keyNode.pb );

CloseFucb:
        DIRClose( pfucb );
        return err;
        }
#endif


#ifdef DISPATCHING

LOCAL ERR ErrDABAlloc( PIB *ppib, VDBID *pvdbid, DBID dbid, JET_GRBIT grbit )
        {
        VDBID vdbid = (VDBID)VdbidMEMAlloc();

        if ( vdbid == NULL )
                return JET_errTooManyOpenDatabases;
        vdbid->dbid = dbid;
        vdbid->ppib = ppib;

        /* set the mode of DBopen */
        /**/
        if ( FDBIDReadOnly( dbid ) )
                vdbid->grbit = JET_bitDbReadOnly;
        else
                vdbid->grbit = grbit;

        /* insert DAB/VDBID into ppib's dabList
        /**/
        vdbid->pdabNext = ppib->pdabList;
        ppib->pdabList = vdbid;

        *pvdbid = vdbid;
        return JET_errSuccess;
        }

#endif

LOCAL ERR ErrDABDealloc( PIB *ppib, VDBID vdbid)
        {
        DAB     **pdabPrev;
        DAB     *pdab;

        pdab = ppib->pdabList;
        pdabPrev = &ppib->pdabList;

        /* search thru thread's DAB list and unlink this DAB
        /**/
        for( ; pdab != pdabNil; pdabPrev = &pdab->pdabNext, pdab = pdab->pdabNext )
                {
                Assert( ppib == pdab->ppib );
                if ( pdab == vdbid )
                        {
                        *pdabPrev = pdab->pdabNext;
                        ReleaseVDbid( vdbid );
                        return( JET_errSuccess );
                        }
                }

        Assert( fFalse );
        return( JET_errSuccess );
        }

ERR ISAMAPI ErrIsamCreateDatabase(
        JET_VSESID sesid,
        const char __far*szDatabaseName,
        const char __far *szConnect,
        JET_DBID *pjdbid,
        JET_GRBIT grbit )
        {
        ERR             err;
        PIB             *ppib;
        DBID            dbid;
        VDBID           vdbid = vdbidNil;

        /* check parameters */
        Assert(sizeof(JET_VSESID) == sizeof(PIB *));
        ppib = (PIB*) sesid;

        dbid = 0;
        CallR( ErrDBCreateDatabase( ppib, (char *) szDatabaseName,
                (char *) szConnect, &dbid, grbit ) );

#ifdef  DISPATCHING
        Call( ErrDABAlloc( ppib, &vdbid, (DBID) dbid, JET_bitDbExclusive ) );
        Assert(sizeof(vdbid) == sizeof(JET_VDBID));
        Call( ErrAllocateDbid( pjdbid, (JET_VDBID) vdbid, &vdbfndefIsam ) );
#else
        *pjdbid = (JET_DBID) dbid;
#endif  /* !DISPATCHING */

        return JET_errSuccess;

HandleError:
        if ( vdbid != vdbidNil )
                CallS( ErrDABDealloc( ppib, vdbid ) );
        (VOID)ErrDBCloseDatabase( ppib, dbid, grbit );
        (VOID)ErrDBRemoveDatabase( ppib, (char *) szDatabaseName );
        return err;
        }


ERR ErrDBCreateDatabase( PIB *ppib, CHAR *szDatabaseName, CHAR *szConnect, DBID *pdbid, ULONG grbit )
        {
        ERR             err;
        DBID            dbid;
        CHAR            rgbFullName[JET_cbFullNameMost];
        CHAR            *szFullName;
        ULONG           cpgPrimary = cpgDatabaseMin;
        BOOL            fNoLoggingCapability;
        CHAR            *szFileName;

        CheckPIB( ppib );

        NotUsed(szConnect);
        Assert( *pdbid >= 0 && *pdbid < dbidUserMax );
        
        if (grbit & JET_bitDbNoLogging)
                grbit |= JET_bitDbRecoveryOff;

        if ( ppib->level > 0 )
                return JET_errInTransaction;

        if ( cpgPrimary == 0 )
                cpgPrimary = cpgDatabaseMin;

        if ( cpgPrimary > cpgDatabaseMax )
                return( JET_errDatabaseInvalidPages );

        /* if recovering and dbid is a known one, the lock the dbid first */
        if ( fRecovering && *pdbid != dbidTemp )
                {
                dbid = *pdbid;
                /* get corresponding dbid */
                CallS( ErrIOLockNewDbid( &dbid, rgfmp[dbid].szDatabaseName ) );
                }

        if ( fRecovering && *pdbid != dbidTemp && rgfmp[dbid].szRestorePath )
                {
                szFullName = rgfmp[dbid].szDatabaseName;
                szFileName = rgfmp[dbid].szRestorePath;
                }
        else
                {
                if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
                        {
                        return(JET_errDatabaseNotFound);
                        }
                szFullName = rgbFullName;
                szFileName = szFullName;
                }
        
        /* check if database file already exists
        /**/
        if ( FIOFileExists( szFileName ) )
                {
                err = JET_errDatabaseDuplicate;
                return err;
                }

        if ( !( fRecovering && *pdbid != dbidTemp ) )
                {
                err = ErrIOLockNewDbid( &dbid, szFullName );
                if ( err != JET_errSuccess )
                        {
                        if ( err == JET_wrnDatabaseAttached )
                                err = JET_errDatabaseDuplicate;
                        return err;
                        }
                }

        //      UNDONE: add support to FFileExists and remove check for file in
        //                              use here.
        if ( Hf(dbid) != handleNil )
                {
                IOUnlockDbid( dbid );
                err = JET_errDatabaseDuplicate;
                return err;
                }

        err = ErrIOOpenDatabase( dbid, szFileName, cpgPrimary );
        if ( err < 0 )
                {
                IOFreeDbid( dbid );
                return err;
                }

        /* set database non-loggable during CreateDB
        /**/
        rgfmp[dbid].fLogOn = fFalse;

        /*      not in a transaction, but still need to set lgposRC of the buffers
        /*      used by this function such that when get checkpoint, it will get
        /*      right check point.
        /**/
        if ( !( fLogDisabled || fRecovering ) )
                {
                EnterCriticalSection(critLGBuf);
                GetLgposOfPbEntry( &ppib->lgposStart );
                LeaveCriticalSection(critLGBuf);
                }

        /*      initialize the database file.  Logging of page operations is
        /*      turned off (during creation only). After creation the database
        /*      is marked "loggable" and logging is turned on.
        /**/
        SetOpenDatabaseFlag( ppib, dbid );

        fNoLoggingCapability = grbit & JET_bitDbNoLogging;
        Call( ErrDBInitDatabase(ppib, dbid, cpgPrimary, fNoLoggingCapability));

#ifdef  SYSTABLES
        if ( FSysTabDatabase( dbid ) )
                {
                Call( ErrSysTabCreate( ppib, dbid ) );  // Create system tables
                }
#endif  /* SYSTABLES */

#ifdef NO_OVER_PREREAD
        /*
         *  set the last page of the database, used to prevent over preread.
         */
        Call( ErrDBSetLastPage(ppib, dbid) );
#endif

        /*
         *  set database status to loggable
         */
        if ( grbit & JET_bitDbRecoveryOff )
                {
                rgfmp[ dbid ].fDBLoggable = fFalse;
                }
        else if ( FSysTabDatabase( dbid ) )
                {
                /* set all databases loggable except Temp if allowed
                /**/
                rgfmp[dbid].fDBLoggable = !fNoLoggingCapability;
                }

        rgfmp[dbid].fLogOn = rgfmp[dbid].fDBLoggable;

        /*      log Create Database prior to page modifications so file will
        /*      be open during redo of page modifications if soft crash occurs
        /**/
        Call( ErrLGCreateDB(
                        ppib,
                        dbid,
                        rgfmp[ dbid ].fLogOn,
                        grbit,
                        szFullName,
                        strlen(szFullName) + 1));

#ifdef DEBUG
        {
        /* must be a complete flush since the whole create db is log as one
        /* operation.
        /**/
        BOOL    fDBGForceFlushSav = fDBGForceFlush;
        fDBGForceFlush = fTrue;
#endif

        /* flush buffers if not temporary database
        /**/
        if ( dbid != dbidTemp )
                {
                Call( ErrBFFlushBuffers( dbid, fBFFlushSome ) );
                }


#ifdef DEBUG
        fDBGForceFlush = fDBGForceFlushSav;
        rgfmp[ dbid ].lBFFlushPattern = grbit >> 24;
        }
#endif

        /* if recover, the insertion is done by redoing logged insertion
         * operations. No need to do it again. Only do the database initialization.
         */
        if ( !fRecovering && FUserDbid( dbid ) )
                {
                err = ErrDBAddDatabase( ppib, szFullName, dbid );
                if (err < 0 && err != JET_errKeyDuplicate )
                        goto HandleError;
                }

        *pdbid = dbid;
        IOSetAttached( dbid );
        IOUnlockDbid( dbid );
        return JET_errSuccess;

HandleError:

        /*      functions may only use the call macro when the system state
        /*      is file exists, file open or closed, database record fWait
        /*      set, database record name valid and user logging status
        /*      valid.
        /**/
        BFPurge( dbid, 0 );                             /*  Purge bad db  */
        if ( FIODatabaseOpen(dbid) )
                IOCloseDatabase( dbid );
        IODeleteDatabase( dbid );
        ResetOpenDatabaseFlag( ppib, dbid );
        IOFreeDbid( dbid );
        return err;
        }


ERR ISAMAPI ErrIsamAttachDatabase(
        JET_VSESID sesid,
        const char __far *szDatabaseName,
        JET_GRBIT grbit )
        {
        PIB             *ppib;
        ERR             err;
        DBID    dbid;
        CHAR    rgbFullName[JET_cbFullNameMost];
        CHAR    *szFullName;
        ULONG   ulVersion;
        BOOL    fLoggingCapable;

        /* check parameters */
        Assert(sizeof(JET_VSESID) == sizeof(PIB *));
        ppib = (PIB*) sesid;

        CheckPIB( ppib );

        if ( ppib->level > 0 )
                return JET_errInTransaction;

        if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
                {
                return(JET_errDatabaseNotFound);
                }
        szFullName = rgbFullName;

        /*      depend on _fullpath to make same files same name
        /*      thereby preventing same file to be multiply attached
        /**/
        err = ErrIOLockNewDbid( &dbid, szFullName );
        if ( err != JET_errSuccess )
                {
                Assert( err == JET_wrnDatabaseAttached ||
                        err == JET_errOutOfMemory ||
                        err == JET_errTooManyAttachedDatabases );
                return err;
                }

        Call( ErrDBValidDatabaseFile( szFullName, &ulVersion, &fLoggingCapable ) );

#ifdef NO_OVER_PREREAD
        /*
         *  set the last page of the database, used to prevent over preread.
         */
        Call( ErrDBSetLastPage( ppib, dbid ) );
#endif

        /*      set database loggable flags.
        /**/
        if ( grbit & JET_bitDbRecoveryOff )
                {
                rgfmp[dbid].fDBLoggable = fFalse;
                }
        else if ( FSysTabDatabase( dbid ) )
                {
                /* set all databases loggable except Temp if allowed
                /**/
                rgfmp[dbid].fDBLoggable = fLoggingCapable;
                }

        rgfmp[dbid].fLogOn = rgfmp[dbid].fDBLoggable;

#ifdef DEBUG
        rgfmp[ dbid ].lBFFlushPattern = grbit >> 24;
#endif

        Call( ErrDBAddDatabase( ppib, szFullName, dbid ) );

        /* log Attach
        /**/
        Assert( dbid != dbidTemp );
        Call( ErrLGAttachDB(
                        ppib,
                        dbid,
                        rgfmp[ dbid ].fLogOn,
                        (char *) szFullName,
                        strlen(szFullName) + 1) );
                
        IOSetAttached( dbid );
        IOUnlockDbid( dbid );
        return JET_errSuccess;
HandleError:
        IOFreeDbid( dbid );
        return err;
        }


ERR ErrDBAccessDatabaseRoot(
        DBID dbid,
        SSIB *pssib,
        DBROOT **ppdbroot )
        {
        PN              pn;
        ERR             err;
        BOOL    fRecoveringSav;

        /* read in the FDP */
        pn = ((PN)dbid << 24) | (PGNO)1;

        /* set frecovering = fTrue to disable the Access page time stamp */
        /* check. The time stamp check access pfmp->ulDBTime which is */
        /* not initialized util this function is called. */

        fRecoveringSav = fRecovering;
        fRecovering = fTrue;

        CallR( ErrBFAccessPage( pssib->ppib, &pssib->pbf, pn ) );

        fRecovering = fRecoveringSav;

        /* root node */
        pssib->itag = 0;
        CallR( ErrPMGet( pssib, pssib->itag ) );
        *ppdbroot = (DBROOT*)PbNDData( pssib->line.pb ); /* point to root struct */

        return JET_errSuccess;
        }


/*      This is a special function always followed by BFFlush. No logging no
/*      Version for it. It is called in detach database or system shut down.
/**/
ERR ErrDBUpdateDatabaseRoot( DBID dbid )
        {
        ERR             err;
        LINE    rgline[3];
        DBROOT  *pdbroot;
        USHORT  usFlags;
        SSIB    ssibT;

        /*      if database updatable then update root
        /**/
        if( !FDBIDReadOnly( dbid ) )
                {
                /*  no operations on the database. This check is needed for recovering.
                /*  We may attach a database, without proper ulDBTime set, and then no
                /*  operation for this database. In this case, we do not want to
                /*  update its ulDBTime.
                /**/
                if ( rgfmp[ dbid ].ulDBTime == 0 )
                        return JET_errSuccess;

                CallR( ErrDBAccessDatabaseRoot(dbid, &ssibT, &pdbroot ) );

                /*      since database root node is fixed, we can wait
                /*      for write latch without refreshing currency
                /**/
                while ( FBFWriteLatchConflict( ssibT.ppib, ssibT.pbf ) )
                        {
                        BFSleep( cmsecWaitWriteLatch );
                        }

                /*      write latch page from dirty until log completion
                /**/
                BFPin( ssibT.pbf );
                BFSetWriteLatch( ssibT.pbf, ssibT.ppib );

                /* dirty here but not to increment the DBTime
                /**/
                BFSetDirtyBit ( ssibT.pbf );

                usFlags = pdbroot->usFlags;

                rgline[0].pb = ssibT.line.pb;
                rgline[0].cb = ssibT.line.cb - sizeof(ULONG) - sizeof(USHORT);

                Assert( !fRecovering ||
                        fDBGForceFlush ||
                        /* will be greater if UNDO is appended. */
                        rgfmp[ dbid ].ulDBTime >= rgfmp[ dbid ].ulDBTimeCurrent);
                Assert( rgfmp[ dbid ].ulDBTime > 0 );

                /* timestamp
                /**/
                rgline[1].pb = (char *)&(rgfmp[ dbid ].ulDBTime);
                rgline[1].cb = sizeof( ULONG );
                rgline[2].pb = (char *)&usFlags;
                rgline[2].cb = sizeof(USHORT);
                CallS( ErrPMReplace( &ssibT, rgline, 3 ) );

                BFResetWriteLatch( ssibT.pbf, ssibT.ppib );
                BFUnpin( ssibT.pbf );
                }

        return JET_errSuccess;
        }


ERR ISAMAPI ErrIsamDetachDatabase( JET_VSESID sesid, const char __far *szDatabaseName )
        {
        ERR             err;
        PIB             *ppib;
        DBID    dbid = 0;
        CHAR    rgbFullName[JET_cbFullNameMost];
        CHAR    *szFullName;
        DBID    dbidDetach;

        /* check parameters
        /**/
        Assert( sizeof(JET_VSESID) == sizeof(PIB *) );
        ppib = (PIB *)sesid;

        CheckPIB( ppib );

        if ( ppib->level > 0 )
                return JET_errInTransaction;

        if ( szDatabaseName == NULL )
                {
                dbidDetach = dbidUserMin;
                }
Start:
        if ( szDatabaseName == NULL )
                {
                for ( dbidDetach++; dbidDetach < dbidUserMax
                        && rgfmp[dbidDetach].szDatabaseName == NULL;
                        dbidDetach++ );
                Assert( dbidDetach != dbidSystemDatabase );
                if ( dbidDetach == dbidUserMax )
                        return JET_errSuccess;
                szFullName = rgfmp[dbidDetach].szDatabaseName;
                }
        else
                {
                if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
                        {
                        return(JET_errDatabaseNotFound);
                        }
                szFullName = rgbFullName;
                }

        /* purge all MPL entries for this dbid
        /**/

        MPLPurge( dbid );

        err = ErrIOLockDbidByNameSz( szFullName, &dbid );

        if ( err == JET_errSuccess && FIODatabaseInUse( dbid ) )
                {
                IOUnlockDbid( dbid );
                err = JET_errDatabaseInUse;
                }

        if ( err < 0 )
                {
                return err;
                }

        /*      clean up all version store. Actually we only need to clean up
        /*      the entries that had dbid as the dbid for the new database.
        /**/
        Call( ErrRCECleanAllPIB() );

        if ( FIODatabaseOpen(dbid) )
                {
                /*      if database is updatable then update time stamp.
                /**/
                if ( !FDBIDReadOnly( dbid ) )
                        {
                        Call( ErrDBUpdateDatabaseRoot( dbid ) );
                        }

                /*      flush all database buffers
                /**/
                err = ErrBFFlushBuffers( dbid, fBFFlushSome );
                if ( err < 0 )
                        {
                        IOUnlockDbid( dbid );
                        return err;
                        }

                /* purge all buffers for this dbid */
                BFPurge( dbid, (PGNO)0 );

                IOCloseDatabase( dbid );
                }

        Call( ErrDBRemoveDatabase( ppib, szFullName ) );

        // log Detach
        Assert( dbid != dbidTemp );
        Call( ErrLGDetachDB(
                        ppib,
                        dbid,
                        rgfmp[dbid].fLogOn,
                        (char *) szFullName,
                        strlen(szFullName) + 1) );

        /* purge all MPL entries for this dbid
        /**/
        MPLPurge( dbid );

        /*      clean up all version store again in case any versions created
        /*      by on-line compaction or update of database root.
        /**/
        Call( ErrRCECleanAllPIB() );

        /*      do not free dbid on detach to avoid problems related to
        /*      version RCE aliasing and database name conflict during
        /*      recovery.
        /**/
#ifdef REUSEDBID
        IOResetAttached( dbid );
        IOResetExclusive( dbid );
        IOUnlockDbid( dbid );
#else
        IOFreeDbid( dbid );
#endif

        /*      purge open table fcbs to avoid future confusion
        /**/
        FCBPurgeDatabase( dbid );

        if ( szDatabaseName == NULL )
                goto Start;

        return JET_errSuccess;

HandleError:
        IOUnlockDbid( dbid );
        return err;
        }


/*      DAE databases are repaired automatically on system restart
/**/
ERR ISAMAPI ErrIsamRepairDatabase(
        JET_VSESID sesid,
        const char __far *lszDbFile,
        JET_PFNSTATUS pfnstatus )
        {
        PIB *ppib;

        Assert(sizeof(JET_VSESID) == sizeof(PIB *));
        ppib = (PIB*) sesid;

        NotUsed(ppib);
        NotUsed(lszDbFile);
        NotUsed(pfnstatus);

        return JET_errFeatureNotAvailable;
        }


ERR ISAMAPI ErrIsamOpenDatabase(
        JET_VSESID sesid,
        const char __far *szDatabaseName,
        const char __far *szConnect,
        JET_DBID *pjdbid,
        JET_GRBIT grbit )
        {
        ERR             err;
        PIB             *ppib;
        DBID            dbid;
        VDBID           vdbid = vdbidNil;

        /* check parameters */
        Assert(sizeof(JET_VSESID) == sizeof(PIB *));
        ppib = (PIB*) sesid;
        NotUsed(szConnect);

        CheckPIB( ppib );

        dbid = 0;
        CallR( ErrDBOpenDatabase( ppib, (char *)szDatabaseName, &dbid, grbit ) );

#ifdef  DISPATCHING
        Call( ErrDABAlloc( ppib, &vdbid, dbid, grbit ) );
        Assert(sizeof(vdbid) == sizeof(JET_VDBID));
        Call( ErrAllocateDbid( pjdbid, (JET_VDBID) vdbid, &vdbfndefIsam ) );
#else   /* !DISPATCHING */
        *pjdbid = (JET_DBID) dbid;
#endif  /* !DISPATCHING */

        return JET_errSuccess;

HandleError:
        if ( vdbid != vdbidNil )
                CallS( ErrDABDealloc( ppib, vdbid ) );
        CallS( ErrDBCloseDatabase( ppib, dbid, grbit ) );
        return err;
        }


ERR ErrDBOpenDatabase( PIB *ppib, CHAR *szDatabaseName, DBID *pdbid, ULONG grbit )
        {
        ERR             err;
        CHAR    rgbFullName[JET_cbFullNameMost];
        CHAR    *szFullName;
        CHAR    *szFileName;
        DBID    dbid;
        ULONG   ulVersion;

        if ( fRecovering )
                {
                CallS( ErrIOLockDbidByNameSz( szDatabaseName, &dbid ) );
                }
        
        if ( fRecovering && rgfmp[dbid].szRestorePath )
                {
                szFullName = rgfmp[dbid].szDatabaseName;
                szFileName = rgfmp[dbid].szRestorePath;
                }
        else
                {
                if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
                        {
                        return(JET_errDatabaseNotFound);
                        }
                szFullName = rgbFullName;
                szFileName = szFullName;
                }

        if ( !fRecovering )
                {
                CallR( ErrIOLockDbidByNameSz( szFullName, &dbid ) );
                }

        /*  during recovering, we could open an non-detached database
        /*  to force to initialize the fmp entry.
        /*      if database has been detached, then return error.
        /**/
        if ( !fRecovering && !FIOAttached( dbid ) )
                {
                err = JET_errDatabaseNotFound;
                goto HandleError;
                }

        if ( FIOExclusiveByAnotherSession( dbid, ppib ) )
                {
                IOUnlockDbid( dbid );
                return JET_errDatabaseLocked;
                }

        if ( ( grbit & JET_bitDbExclusive ) )
                {
                if ( FIODatabaseInUse( dbid ) )
                        {
                        IOUnlockDbid( dbid );
                        return JET_errDatabaseInUse;
                        }
                IOSetExclusive( dbid, ppib );
                }

        if ( Hf(dbid) == handleNil )
                {
                /*  newly opened database
                /**/
                SSIB    ssibT;
                DBROOT  *pdbroot;
                BOOL    fLoggingCapable;

                Call( ErrDBValidDatabaseFile( szFileName, &ulVersion, &fLoggingCapable ) );
                Call( ErrIOOpenDatabase( dbid, szFileName, 0L ) );

                CallR( ErrDBAccessDatabaseRoot(dbid, &ssibT, &pdbroot ) );

                rgfmp[ dbid ].ulDBTime = pdbroot->ulDBTime;     /* copy last timestamp */

                /* loggable flag
                /**/
                Assert( pdbroot->usFlags & dbrootfLoggable ||
                        ( !rgfmp[ dbid ].fDBLoggable && !rgfmp[ dbid ].fLogOn ) );

                IOSetDatabaseVersion( dbid, ulVersion );
                }

        IOUnlockDbid( dbid );
        SetOpenDatabaseFlag( ppib, dbid );
        *pdbid = dbid;
        return JET_errSuccess;

HandleError:
        IOResetExclusive( dbid );
        IOUnlockDbid( dbid );
        return err;
        }


ERR ISAMAPI ErrIsamCloseDatabase(
        JET_VSESID      sesid,
        JET_VDBID       vdbid,
        JET_GRBIT       grbit )
        {
        ERR             err;
        PIB             *ppib;
        DBID            dbid = DbidOfVDbid( vdbid );
        ULONG           grbitOpen;                                                                              // flags for corresponding open

        /* check parameters
        /**/
        Assert( sizeof(JET_VSESID) == sizeof(PIB *) );
        ppib = (PIB *)sesid;
        NotUsed(grbit);

        CheckPIB( ppib );
        CheckDBID( ppib, dbid );
        grbitOpen = GrbitOfVDbid( vdbid );

        err = ErrDBCloseDatabase( ppib, dbid, grbitOpen );
#ifdef  DISPATCHING
        if ( err == JET_errSuccess )
                {
                ReleaseDbid( DbidOfVdbid( vdbid, &vdbfndefIsam ) );
                CallS( ErrDABDealloc( ppib, (VDBID) vdbid ) );
                }
#endif  /* DISPATCHING */
        return err;
        }


ERR ErrDBCloseDatabase( PIB *ppib, DBID dbid, ULONG     grbit )
        {
        ERR             err;
        FUCB    *pfucb;
        FUCB    *pfucbNext;

        if ( !( FUserOpenedDatabase( ppib, dbid ) ) )
                {
                return JET_errDatabaseNotFound;
                }

        CallR( ErrIOLockDbidByDbid( dbid ) );

        Assert( FIODatabaseOpen( dbid ) );

        if ( FLastOpen( ppib, dbid ) )
                {
                /*      close all open FUCBs on this database
                /**/

                /*      get first table FUCB
                /**/
                pfucb = ppib->pfucb;
                while ( pfucb != pfucbNil && ( pfucb->dbid != dbid || !FFCBClusteredIndex( pfucb->u.pfcb ) ) )
                        pfucb = pfucb->pfucbNext;

                while ( pfucb != pfucbNil )
                        {
                        /*      get next table FUCB
                        /**/
                        pfucbNext = pfucb->pfucbNext;
                        while ( pfucbNext != pfucbNil && ( pfucbNext->dbid != dbid || !FFCBClusteredIndex( pfucbNext->u.pfcb ) ) )
                                pfucbNext = pfucbNext->pfucbNext;

                        if ( !( FFUCBDeferClosed( pfucb ) ) )
                                {
                                if ( pfucb->fVtid )
                                        {
                                        CallS( ErrDispCloseTable( (JET_SESID)ppib, TableidOfVtid( pfucb ) ) );
                                        }
                                else
                                        {
                                        CallS( ErrFILECloseTable( ppib, pfucb ) );
                                        }
                                }
                        pfucb = pfucbNext;
                        }
                }

        /* if we opened it exclusively, we reset the flag
        /**/
        ResetOpenDatabaseFlag( ppib, dbid );
        if ( grbit & JET_bitDbExclusive )
                IOResetExclusive( dbid );
        IOUnlockDbid( dbid );

        /*      do not close file until file map space needed or database
        /*      detached.
        /**/

        return JET_errSuccess;
        }


/*      called by bookmark clean up to open database for bookmark
/*      clean up operation.  Returns error if database is in use for
/*      attachment/detachment.
/**/
ERR ErrDBOpenDatabaseByDbid( PIB *ppib, DBID dbid )
        {
        if ( !FIODatabaseAvailable( dbid ) )
                {
                return JET_errDatabaseNotFound;
                }

        SetOpenDatabaseFlag( ppib, dbid );
        return JET_errSuccess;
        }


/*      called by bookmark clean up to close database.
/**/
ERR ErrDBCloseDatabaseByDbid( PIB *ppib, DBID dbid )
        {
        ResetOpenDatabaseFlag( ppib, dbid );
        return JET_errSuccess;
        }


LOCAL ERR ErrDBRemoveDatabase( PIB *ppib, CHAR *szDatabaseName )
        {
        ERR             err = JET_errSuccess;
        FUCB    *pfucb;
        KEY             rgkey[2];
        BYTE    rgbKey[ JET_cbKeyMost ];
        DBID    dbidSysDb;

        /*      remove the entry added under DATABASES in the system database
        /*      for the detached database
        /**/
        CallR( ErrDIRBeginTransaction( ppib ) );

        dbidSysDb = dbidSystemDatabase;
        Call( ErrDBOpenDatabase( ppib, rgfmp[dbidSystemDatabase].szDatabaseName, &dbidSysDb, 0 ) );
        CallJ( ErrDIROpen( ppib, pfcbNil, dbidSystemDatabase, &pfucb ), DbClose );

        /*      normalize database name and set key and seek
        /**/
        rgkey[0] = *pkeyDatabases;
        SysNormText( szDatabaseName, strlen( szDatabaseName ), rgbKey, sizeof( rgbKey ), &rgkey[1].cb );
        rgkey[1].pb = rgbKey;
        err = ErrDIRSeekPath( pfucb, 2, rgkey, 0 );
        Assert( err != JET_errNoCurrentRecord );
        if ( err < 0 )
                {
                if ( err == JET_errRecordNotFound )
                        err = JET_errDatabaseNotFound;
                goto Close;
                }
        CallJ( ErrDIRDelete( pfucb, fDIRVersion ), Close );
        DIRClose( pfucb );
        Call( ErrDBCloseDatabase( ppib, dbidSysDb, 0 ) );
        Call( ErrDIRCommitTransaction( ppib ) );
        return JET_errSuccess;

Close:
        DIRClose( pfucb );
DbClose:
        CallS( ErrDBCloseDatabase( ppib, dbidSysDb, 0 ) );
HandleError:
        CallS( ErrDIRRollback( ppib ) );
        return err;
        }


LOCAL ERR ErrDBAddDatabase( PIB *ppib, CHAR *szDatabaseName, DBID dbid )
        {
        ERR             err = JET_errSuccess;
        FUCB    *pfucb;
        KEY             key;
        BYTE    rgbKey[ JET_cbKeyMost ];
        LINE    line;
        DBID    dbidSysDb;
        BYTE    rgdba[sizeof(BYTE) + sizeof(BYTE) + JET_cbNameMost];
        DBA             *pdba;

        /*      allocate space for DBA
        /**/
        pdba = (DBA *)rgdba;

        /*      add entry in DATABASES node of system database for created
        /*      database
        /**/
        CallR( ErrDIRBeginTransaction( ppib ) );
        dbidSysDb = dbidSystemDatabase;
#ifdef NJETNT
        Call( ErrDBOpenDatabase( ppib, rgtib[itibGlobal].szSysDbPath, &dbidSysDb, 0 ) );
#else
        Call( ErrDBOpenDatabase( ppib, szSysDbPath, &dbidSysDb, 0 ) );
#endif
        if ( FDBIDReadOnly( dbidSystemDatabase ) )
                {
                err = JET_errFileAccessDenied;
                goto DbClose;
                }

        CallJ( ErrDIROpen( ppib, pfcbNil, dbidSysDb, &pfucb ), DbClose );
        CallJ( ErrDIRSeekPath( pfucb, 1, pkeyDatabases, 0 ), Close );

        /*      normalize database name and set key
        /**/
        SysNormText( szDatabaseName, strlen( szDatabaseName ), rgbKey, sizeof( rgbKey ), &key.cb );
        key.pb = rgbKey;

        /*      set dba with dbid, fLogOn and database name without NULL terminator
        /**/
        pdba->bDbid = (BYTE)dbid;
        pdba->bLoggable = (BYTE)rgfmp[dbid].fLogOn;
        strncpy( (BYTE *)pdba->rgchDatabaseName, szDatabaseName, strlen( szDatabaseName ) );

        line.pb = (BYTE *)pdba;
        line.cb = (ULONG)(sizeof(BYTE) + sizeof(BYTE) + strlen(szDatabaseName));
        CallJ( ErrDIRInsert( pfucb, &line, &key, fDIRVersion ), Close )
        DIRClose( pfucb );
        Call( ErrDBCloseDatabase( ppib, dbidSysDb, 0 ) );
        Call( ErrDIRCommitTransaction( ppib ) );
        return JET_errSuccess;
Close:
        DIRClose( pfucb );
DbClose:
        CallS( ErrDBCloseDatabase( ppib, dbidSysDb, 0 ) );
HandleError:
        CallS( ErrDIRRollback( ppib ) );
        return err;
        }


ERR ErrDBValidDatabaseFile( CHAR *szDatabaseName, ULONG *pulVersion, BOOL *pfLoggingCapable )
        {
        ERR             err = JET_errSuccess;
        UINT    cb;
        HANDLE  hf;
        PAGE    *ppage;
        INT             ibTag;
        INT             cbTag;
        BYTE    *pb;

        CallR( ErrSysOpenFile( szDatabaseName, &hf, 0L, fTrue, fFalse ) );
        if ( ( ppage = ( PAGE * ) PvSysAllocAndCommit( cbPage ) ) == NULL )
                {
                err = JET_errOutOfMemory;
                goto HandleError;
                }

        SysChgFilePtr( hf, 0, NULL, FILE_BEGIN, &cb );
        Assert( cb == 0 );
        err = ErrSysReadBlock( hf, (BYTE*)ppage, cbPage, &cb );
        
        /* since file exists and we are unable to read data,
        /* it may not be a system.mdb
        /**/
        if ( err == JET_errDiskIO )
                err = JET_errDatabaseCorrupted;
        Call( err );
        
        IbCbFromPtag(ibTag, cbTag, &ppage->rgtag[0]);
        if ( ibTag < (BYTE*)&ppage->rgtag[1] - (BYTE*)ppage ||
                (BYTE*)ppage + ibTag + cbTag >= (BYTE*)(ppage + 1) )
                {
                err = JET_errDatabaseCorrupted;
                goto HandleError;
                }

        /*      at least FILES, OWNEXT, AVAILEXT
        /**/
        pb = (BYTE *)ppage + ibTag;
        if ( !FNDVisibleSons( *pb ) || CbNDKey( pb ) != 0 || FNDNullSon( *pb ) )
                {
                err = JET_errDatabaseCorrupted;
                goto HandleError;
                }

        /*      check data length
        /**/
        cb = cbTag - (UINT)( PbNDData( pb ) - pb );
        if ( cb != sizeof(DBROOT) )
                {
                err = JET_errDatabaseCorrupted;
                goto HandleError;
                }

        /*      return database version
        /**/
        *pulVersion = ((DBROOT *)PbNDData(pb))->ulVersion;
        *pfLoggingCapable = ((DBROOT *)PbNDData(pb))->usFlags & dbrootfLoggable;

HandleError:
        if ( ppage != NULL )
                SysFree( (VOID *)ppage );
        (VOID)ErrSysCloseFile( hf );
        return err;
        }


/* ErrDABCloseAllDBs: Close all databases (except system database) opened by this thread
/**/
ERR ErrDABCloseAllDBs( PIB *ppib )
        {
        ERR             err;

        while( ppib->pdabList != pdabNil )
                {
                Assert( FUserOpenedDatabase( ppib, ppib->pdabList->dbid ) );
                CallR( ErrIsamCloseDatabase( ( JET_VSESID ) ppib, (JET_VDBID) ppib->pdabList, 0 ) );
                }
        return JET_errSuccess;
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\dir.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "page.h"
#include "ssib.h"
#include "node.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "dirapi.h"
#include "spaceapi.h"
#include "recint.h"
#include "fileint.h"
#include "fileapi.h"
#include "sortapi.h"
#include "dbapi.h"
#include "nver.h"
#include "fmp.h"
#include "logapi.h"
#include "log.h"

DeclAssertFile;                                 /* Declare file name for assert macros */

extern void * __near critSplit;
extern BOOL fOLCompact;

LOCAL ERR ErrDIRIIRefresh( FUCB *pfucb );
LOCAL ERR ErrDIRICopyKey( FUCB *pfucb, KEY *pkey );
LOCAL ERR ErrDIRIDownToFDP( FUCB *pfucb, PGNO pgnoFDP );
LOCAL ERR ErrDIRIMoveToItem( FUCB *pfucb, SRID srid, BOOL fNext );
LOCAL INLINE ERR ErrDIRIInsertFDPPointer( FUCB *pfucb, PGNO pgnoFDP, KEY *pkey, INT fFlags );
LOCAL INLINE ERR ErrDIRIGotoItem( FUCB *pfucb, SRID bmItemList, ITEM item );

#undef DIRAPIReturn
#define	DIRAPIReturn( pfucbX, err )								\
	{															\
	Assert( pfucbX == pfucbNil ||								\
		((FUCB *)pfucbX)->pbfEmpty == pbfNil );				   	\
	return err;													\
	}

/****************** DIR Item Routines *********************
/**********************************************************
/**/
//	UNDONE:	if pcsr is always current then remove parameter
#define DIRIGetItemList( pfucb, pcsr )			   				\
	{											   				\
	Assert( pcsr == PcsrCurrent( pfucb ) );						\
	Assert( FFUCBNonClustered( (pfucb) ) );			  			\
	Assert( FReadAccessPage( (pfucb), (pcsr)->pgno ) );  	   	\
	AssertNDGet( pfucb, pcsr->itag ); 	 				  		\
	NDGetNode( (pfucb) );								   		\
	}


#define ErrDIRINextItem( pfucb )								\
	( pfucb->lineData.cb == sizeof(SRID) ?                      \
		errNDNoItem : ErrNDNextItem( pfucb ) )


#define ErrDIRIPrevItem( pfucb )                                \
	( PcsrCurrent(pfucb)->isrid == 0 ?                          \
		errNDNoItem : ErrNDPrevItem( pfucb ) )


/*	cache srid of first item list node for version.  Return
/*	warning JET_wrnKeyChanged if first item.
/**/
#define DIRICheckFirstSetItemListAndWarn( pfucb, wrn )			\
		{                                         				\
		if FNDFirstItem( *pfucb->ssib.line.pb )      			\
			{                                         			\
			wrn = JET_wrnKeyChanged;							\
			DIRISetItemListFromFirst( pfucb );        			\
			}                                        	 		\
		}


/*	cache srid of first item list node for version
/**/
#define DIRICheckFirstSetItemList( pfucb )         				\
		{                                            			\
		if FNDFirstItem( *pfucb->ssib.line.pb )      			\
			{                                         			\
			DIRISetItemListFromFirst( pfucb );        			\
			}                                         			\
		}


#define DIRISetItemListFromFirst( pfucb )          			   	\
		{                                    				   	\
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 	   	\
		Assert( FNDFirstItem( *pfucb->ssib.line.pb ) );     	\
		NDGetBookmark( pfucb, &PcsrCurrent( pfucb )->bm );		\
		}


#define DIRICheckLastSetItemList( pfucb )                       \
		{                                                       \
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 		\
		if FNDLastItem( *pfucb->ssib.line.pb )                  \
			{                                                   \
			DIRISetItemListFromLast( pfucb );                   \
			}    												\
		}


#define DIRICheckLastSetItemListAndWarn( pfucb, wrn )              	\
		{														   	\
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 		   	\
		if FNDLastItem( *pfucb->ssib.line.pb )					   	\
			{													   	\
			wrn = JET_wrnKeyChanged;							   	\
			DIRISetItemListFromLast( pfucb );					   	\
			}													  	\
		}


/*	remember to back up one item after move to last item via
/*	seek for sridMax, since this call will normally position
/*	after last item and we want to move onto last item.
/**/
#define DIRISetItemListFromLast( pfucb ) 							\
		{                                                           \
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 			\
		if FNDFirstItem( *pfucb->ssib.line.pb )                     \
			{                                                       \
			DIRISetItemListFromFirst( pfucb );                      \
			}                                                       \
		else                                                        \
			{                                                       \
			CallS( ErrDIRIMoveToItem( pfucb, sridMin, fFalse ) );   \
			DIRISetItemListFromFirst( pfucb );                      \
			CallS( ErrDIRIMoveToItem( pfucb, sridMax, fTrue ) );    \
			Assert( PcsrCurrent( pfucb )->isrid > 0 );				\
			PcsrCurrent( pfucb )->isrid--;							\
			}                                                       \
		}


/*********** DIR Fresh/Refresh Routines *************
/**********************************************************
/**/
#define AssertDIRFresh( pfucb )    									\
	Assert( FReadAccessPage( (pfucb),								\
		PcsrCurrent(pfucb)->pgno ) &&								\
		PcsrCurrent( pfucb )->ulDBTime ==							\
		UlSTDBTimePssib( &pfucb->ssib ) )


#define ErrDIRRefresh( pfucb )                                                                                            \
	( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) ?                                \
		ErrDIRIRefresh( pfucb ) : ErrDIRIIRefresh( pfucb ) )


#define ErrDIRIRefresh( pfucb )													\
	( !( FBFReadLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) &&							\
		PcsrCurrent(pfucb)->ulDBTime == UlSTDBTimePssib( &pfucb->ssib ) ?		\
		JET_errSuccess : ErrDIRIIRefresh( pfucb ) )


/*	this routine is called to refresh currency when time stamp is
/*	out of date or when buffer has been overlayed.  The common case
/*	is filtered out by the encapsulating macro.
/**/
LOCAL ERR ErrDIRIIRefresh( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	CSR		*pcsr;

Start:
	/*	cache pcsr for efficiency.  Must recache after start since
	/*	CSR may change as a result of some navigation operations.
	/**/
	pcsr = PcsrCurrent( pfucb );

	/*	only need to refresh currency when on node, or before, or after
	/*	node.  Before first, and after last do not need restoration.
	/*	On FDP node does not need restoration since this node is
	/*	inherently fixed.
	/**/
	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatBeforeCurNode:
		case csrstatAfterCurNode:
		case csrstatOnFDPNode:
			break;
		case csrstatDeferGotoBookmark:
			/*	goto bookmark as though operation was
			/*	not defered.  Must store currency so
			/*	that timestamp set for future operations.
			/**/
			Call( ErrBTGotoBookmark( pfucb, pcsr->bm ) );
			pcsr->csrstat = csrstatOnCurNode;
			goto AfterNodeRefresh;
			break;
		case csrstatDeferMoveFirst:
			{
			DIB		dib;
			FUCB 	*pfucbIdx;

			if ( pfucb->pfucbCurIndex )
				{
				pfucbIdx = pfucb->pfucbCurIndex;
				}
			else
				{
				pfucbIdx = pfucb;
				}

			/*	set DIB to move first
			/**/
			dib.fFlags = fDIRPurgeParent;
			dib.pos = posFirst;

			/*	go to DATA node
			/**/
			DIRGotoDataRoot( pfucbIdx );

			/*	move to first son of DATA node
			/**/
			err = ErrDIRDown( pfucbIdx, &dib );
			Assert( PcsrCurrent( pfucbIdx )->csrstat != csrstatDeferMoveFirst );
			Call( err );

			Assert( err == JET_errSuccess && PcsrCurrent( pfucbIdx )->csrstat == csrstatOnCurNode );
			if ( pfucb->pfucbCurIndex )
				{
				Assert( PcsrCurrent( pfucb ) == pcsr );
				pcsr->bm = PcsrCurrent( pfucbIdx )->item;
				Call( ErrBTGotoBookmark( pfucb, PcsrCurrent( pfucbIdx )->item ) );
				pcsr->csrstat = csrstatOnCurNode;
				}

			goto Done;
			}
		case csrstatOnDataRoot:
			{
			Assert( PcsrCurrent( pfucb ) == pcsr );
//			pcsr->bm == sridNull;
			pcsr->itagFather = itagNull;
			pcsr->pgno = PgnoRootOfPfucb( pfucb );
			while( !FReadAccessPage( pfucb, pcsr->pgno ) )
				{
				Call( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
				pcsr->pgno = PgnoRootOfPfucb( pfucb );
				}
			pcsr->itag = ItagRootOfPfucb( pfucb );
			NDGet( pfucb, pcsr->itag );

			/*	note that it is important here than the currency
			/*	is not set fresh since each time we use this CSR
			/*	we must go through the same process to navigate to the
			/*	data node.
			/**/
			goto Done;
			}
		default:
			Assert( pcsr->csrstat == csrstatAfterLast ||
				pcsr->csrstat == csrstatBeforeFirst );
			goto Done;
		}

	Assert( pcsr->csrstat == csrstatOnCurNode ||
		pcsr->csrstat == csrstatBeforeCurNode ||
		pcsr->csrstat == csrstatAfterCurNode ||
		pcsr->csrstat == csrstatOnFDPNode );

	/*	read access page and check for valid time stamp
	/**/
	if ( !FReadAccessPage( pfucb, pcsr->pgno ) )
		{
		err = ErrSTReadAccessPage( pfucb, pcsr->pgno );
		if ( err < 0 )
			return err;
		}

	/*	if timestamp unchanged then set line cache and data cache
	/*	for non-clustered cursors.  If timestamp changed then
	/*	refresh currency from bookmark.
	/**/
	if ( pcsr->ulDBTime == UlSTDBTimePssib( &pfucb->ssib ) )
		{
		NDGet( pfucb, pcsr->itag );
		if ( FFUCBNonClustered( pfucb ) )
			{
			DIRIGetItemList( pfucb, pcsr );
			}
		}
	else
		{
		/*	refresh node currency.  If node is not there for
		/*	caller then it must have been deleted so set
		/*	CSR status to before current node.
		/**/
		Assert( PcsrCurrent( pfucb ) == pcsr );
		err = ErrBTGotoBookmark( pfucb, pcsr->bm );
		if ( err < 0 )
			{
			if ( err == JET_errRecordDeleted )
				{
				err = JET_errSuccess;
				Assert( pcsr->csrstat == csrstatOnCurNode ||
					pcsr->csrstat == csrstatBeforeCurNode ||
					pcsr->csrstat == csrstatAfterCurNode );
				pcsr->csrstat = csrstatBeforeCurNode;
				}
			else
				goto HandleError;
			}

AfterNodeRefresh:
		/*	if non-clustered cursor and on item list, i.e. not on
		/*	index root, then position currency in item list.
		/**/
		if ( FFUCBNonClustered( pfucb ) && !FDIRDataRootRoot( pfucb, pcsr ) )
			{
			/*	fix item cursor for insert, delete, split.
			/**/
			DIRIGetItemList( pfucb, pcsr );
			Call( ErrDIRIMoveToItem( pfucb, pcsr->item, fTrue ) );
			}
		}

	DIRSetFresh( pfucb );
	err = JET_errSuccess;
Done:
	Assert( err >= 0 );
	if ( FBFReadLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		goto Start;
		}
	return err;

HandleError:
	Assert( err != JET_errRecordDeleted );
	return err;
	}


ERR ErrDIRGet( FUCB *pfucb )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	special case on current node if
	/* 		on current node and
	/* 		page cached and
	/* 		timestamp not changed and
	/* 		node has not been versioned or
	/* 		caller sees consistent version
	/**/
	if (  pcsr->csrstat == csrstatOnCurNode )
		{
		/*	read access page and check for valid time stamp
		/**/
		if ( !FReadAccessPage( pfucb, pcsr->pgno ) )
			{
			Call( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
			}

		if ( pcsr->ulDBTime == UlSTDBTimePssib( &pfucb->ssib ) )
			{
			NDGet( pfucb, pcsr->itag );
			if ( !FNDVerDel( *(pfucb->ssib.line.pb) ) || FPIBDirty( pfucb->ppib ) )
				{
				NDGetNode( pfucb );
				return JET_errSuccess;
				}
			}
		}

	/*	refresh currency
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent(pfucb);

	/*	check CSR status
	/**/
	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatOnFDPNode:
		case csrstatOnDataRoot:
			break;
		default:
			Assert( pcsr->csrstat == csrstatBeforeCurNode ||
				pcsr->csrstat == csrstatAfterCurNode ||
				pcsr->csrstat == csrstatAfterLast ||
				pcsr->csrstat == csrstatBeforeFirst );
			return JET_errNoCurrentRecord;
		}

	/*	make node current, and return error if node is not there.
	/**/
	Call( ErrBTGetNode( pfucb, pcsr ) );

	/*	non-clustered cursor record bookmark cannot change.  Even
	/*	if record has been deleted, return from goto bookmark
	/*	operation will provide information.
	/**/
	err = JET_errSuccess;
	return err;

HandleError:
	DIRSetRefresh( pfucb );
	return err;
	}


/***************** DAE Internal Routines ******************
/**********************************************************
/**/
#define	DIRIPurgeParent( pfucb )												\
	FUCBFreePath( &(PcsrCurrent( pfucb )->pcsrPath), pcsrNil );


/*	free CSRs from current CSR to pcsr.
/**/
#define	DIRIUpToCSR( pfucb, pcsr )												\
	{																						\
	FUCBFreePath( &PcsrCurrent( pfucb ), pcsr );								\
	if ( FReadAccessPage( pfucb, pcsr->pgno ) )								\
		{																					\
		NDGet( pfucb, pcsr->itag );	  											\
		}																					\
	}


LOCAL ERR ErrDIRICopyKey( FUCB *pfucb, KEY *pkey )
	{
	if ( pfucb->pbKey == NULL )
		{
		pfucb->pbKey = LAlloc( 1L, JET_cbKeyMost );
		if ( pfucb->pbKey == NULL )
			return JET_errOutOfMemory;
		}
	KSReset( pfucb );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	NDGetKey( pfucb );
	pkey->cb = pfucb->keyNode.cb;
	pkey->pb = pfucb->pbKey;
	memcpy( pkey->pb, pfucb->keyNode.pb, pkey->cb );
	return JET_errSuccess;
	}


LOCAL ERR ErrDIRIDownToFDP( FUCB *pfucb, PGNO pgnoFDP )
	{
	ERR	err;
	CSR	*pcsr;

	Assert( PcsrCurrent(pfucb)->csrstat == csrstatOnCurNode );

	err = ErrFUCBNewCSR( pfucb );
	if ( err < 0 )
		return err;
	pcsr = PcsrCurrent( pfucb );

	pcsr->csrstat = csrstatOnFDPNode;
	pcsr->bm = SridOfPgnoItag( pgnoFDP, 0 );
//	pcsr->item = itemNil;
	pcsr->pgno = pgnoFDP;
	pcsr->itag = 0;
	pcsr->itagFather = itagNull;
	pcsr->ibSon = 0;
	Call( ErrSTReadAccessPage( pfucb, pcsr->pgno ) );
//	pcsr->isrid = isridNull;
	NDGet( pfucb, pcsr->itag );
	NDGetNode( pfucb );
	return JET_errSuccess;

HandleError:
	BTUp( pfucb );
	return err;
	}


/*	this routine moves from first item list node to item insert
/*	position, or it moves from the last item list node to the
/*	first item list node.
/**/
LOCAL ERR ErrDIRIMoveToItem( FUCB *pfucb, SRID srid, BOOL fNext )
	{
	ERR		err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	CSR		*pcsr = PcsrCurrent( pfucb );
	DIB		dib;

	/*	item list nodes not versioned.
	/**/
	dib.fFlags = fDIRItemList;

	forever
		{
		Assert( FReadAccessPage( pfucb, pcsr->pgno ) );
		AssertNDGetNode( pfucb, pcsr->itag );

		/*	if we are moving to item insert position, then stop
		/*	when on last item list node or when insert position
		/*	found in item list node.
		/**/
		if ( fNext )
			{
			if ( srid != sridMax )
				err = ErrNDSeekItem( pfucb, srid );
			else
				{
				PcsrCurrent( pfucb )->isrid = pfucb->lineData.cb / sizeof(SRID);
				err = errNDGreaterThanAllItems;
				}
			if ( FNDLastItem( *pssib->line.pb ) || err != errNDGreaterThanAllItems )
				{
				break;
				}
			}
		else
			{
			if ( srid != sridMin )
				{
				err = ErrNDSeekItem( pfucb, srid );
				Assert( err == errNDGreaterThanAllItems ||
					err == wrnNDDuplicateItem ||
					err == JET_errSuccess );
				}
			else
				pcsr->isrid = 0;
			if ( FNDFirstItem( *pssib->line.pb ) || pcsr->isrid != 0 )
				{
				break;
				}
			}

		Call( ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fNext, &dib ) );
		DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
		}

	if ( err != wrnNDDuplicateItem )
		err = JET_errSuccess;
HandleError:
	return err;
	}


/*	return JET_errKeyDuplicate, if any potentially there item
/*	found in this item list.
/**/
LOCAL INLINE ERR ErrDIRIKeyDuplicate( FUCB *pfucb )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB 	*pssib = &pfucb->ssib;
	DIB		dib;
	SRID  	*psrid;
	SRID  	*psridMax;
	VS	  	vs;

	/*	must start on first item list node.
	/**/
	Assert( FNDFirstItem( *pssib->line.pb ) );
	AssertBTGetNode( pfucb, pcsr );

	dib.fFlags = fDIRNull;

	/*	for each node in item list, check for duplicate key.
	/**/
	forever
		{
		/*	for each SRID in item list, if item is potentially there
		/*	then return JET_errDuplicateKey.
		/**/
		psrid = (SRID *)pfucb->lineData.pb;
		psridMax = psrid + pfucb->lineData.cb / sizeof(SRID);
		for ( ; psrid < psridMax; psrid++ )
			{
			if ( FNDItemVersion( *( UNALIGNED SRID * )psrid ) )
				{
				vs = VsVERCheck( pfucb, PcsrCurrent( pfucb )->bm );
				if ( FVERPotThere( vs, FNDItemDelete( *( UNALIGNED SRID * )psrid ) ) )
					return JET_errKeyDuplicate;
				}
			else
				{
				if ( !FNDItemDelete( *( UNALIGNED SRID * )psrid )   )
					return JET_errKeyDuplicate;
				}
			}

		/*	if this node is last node in item list then break.
		/**/
		if ( FNDLastItem( *pssib->line.pb ) )
			break;

		Call( ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib ) );
		DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
		}

	err = JET_errSuccess;
HandleError:
	return err;
	}


/*	when a down does not find a valid item in the first/last item of
/*	an item list with the seek key, this routine is called to
/*	adjust the currency to a valid position.  The final position
/*	may be on a node with a key not equal to the seek key, if
/*	there was no valid item for the seek key.
/**/
LOCAL INLINE ERR ErrDIRIDownAdjust( FUCB *pfucb, DIB *pdib )
	{
	ERR		err = JET_errNoCurrentRecord;
	SSIB 	*pssib = &pfucb->ssib;
	INT		s;

	/* input currency on node.
	/**/
	AssertBTGetNode( pfucb, PcsrCurrent( pfucb ) );

	/*	item list nodes not versioned.
	/**/
	pdib->fFlags |= fDIRItemList;

	/*	if not pos last, move next to next valid item.
	/**/
	if ( pdib->pos != posLast )
		{
		while ( ( err = ErrDIRINextItem( pfucb ) ) < 0 )
			{
			Assert( err == errNDNoItem || err == errNDLastItemNode );
			/*	move to next node with DIB constraints
			/**/
			err = ErrBTNext( pfucb, pdib );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					{
					ERR	errT;
					errT = ErrBTPrev( pfucb, pdib );
					if ( errT < 0 )
						goto HandleError;
					break;
					}
				goto HandleError;
				}

			DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

			/*	if on new item list then set bookmark from
			/*	first item list node.
			/**/
			DIRICheckFirstSetItemList( pfucb );
			err = ErrNDFirstItem( pfucb );
			if ( err == JET_errSuccess )
				break;
			}
		}

	/*	if no valid item found then move previous item.
	/**/
	Assert( err == JET_errSuccess || err == JET_errNoCurrentRecord );
	if ( err < 0 )
		{
		while ( ( err = ErrDIRIPrevItem( pfucb ) ) < 0 )
			{
			Assert( err == errNDNoItem || err == errNDFirstItemNode );
			/*	move to previous node with DIB constraints
			/**/
			Call ( ErrBTPrev( pfucb, pdib ) );

			DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

			/*	if on new item list, then set bookmark from
			/*	first item list node.
			/**/
			DIRICheckLastSetItemList( pfucb );
			err = ErrNDLastItem( pfucb );
			if ( err == JET_errSuccess )
				break;
			}
		}

	/*	if posDown then set status.
	/**/
	Assert( err == JET_errSuccess );
	if ( pdib->pos == posDown )
		{
		s = CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey );
		if ( s == 0 )
			err = JET_errSuccess;
		else if ( s < 0 )
			err = wrnNDFoundLess;
		else
			err = wrnNDFoundGreater;
		}

HandleError:
	if ( err == JET_errNoCurrentRecord )
		err = JET_errRecordNotFound;
	return err;
	}


LOCAL INLINE ERR ErrDIRIInsertFDPPointer( FUCB *pfucb, PGNO pgnoFDP, KEY *pkey, INT fFlags )
	{
	ERR		err;
	LINE	line;
	CSR		*pcsrRoot = PcsrCurrent( pfucb );

	CheckFUCB( pfucb->ppib, pfucb );

	line.cb = sizeof(PGNO);
	line.pb = (BYTE *)&pgnoFDP;

	Call( ErrBTSeekForUpdate( pfucb, pkey, 0, 0, 0 ) );

	err = ErrBTInsert( pfucb, fNDFDPPtr, pkey, &line, fFlags );
	if ( err < 0 )
		{
		DIRIUpToCSR( pfucb, pcsrRoot );
		}

HandleError:
	CheckCSR( pfucb );
	return err;
	}


/*	Deletes item node that is either first or last
/*	enters critSplit, so split does not reorganize page during this time
/*	latches all buffers required, so no other user can read inconsistent data
/*	( since the changes are not versioned ).
/**/
LOCAL ERR ErrDIRIDeleteEndItemNode( FUCB *pfucb, BOOL fFirstItem, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	DIB		dib;
	BYTE 	bHeader;
	PGNO 	pgnoItem;
	BF	 	*pbfLatched;
	BF	 	*pbfSibling = pbfNil;

	/*	operations should not be versioned
	/**/
	Assert( !( fFlags & fDIRVersion ) );

	do
		{
Start:
		pbfSibling = pbfNil;
		LgLeaveCriticalSection( critJet );
		EnterNestableCriticalSection( critSplit );
		LgEnterCriticalSection( critJet );

		/*	check currency and refresh if necessary.
		/**/
		CallJ( ErrDIRRefresh( pfucb ), LeaveCritSplit );
		pgnoItem = pcsr->pgno;

		/* wait latch current page
		/**/
		Assert( FAccessPage( pfucb, pgnoItem ) );
		pbfLatched = pfucb->ssib.pbf;
		if ( FBFWriteLatchConflict( pfucb->ppib, pbfLatched ) )
			{
			LeaveNestableCriticalSection( critSplit );
			goto Start;
			}
		BFPin( pbfLatched );
		BFSetWriteLatch( pbfLatched, pfucb->ppib );
		BFSetWaitLatch( pbfLatched, pfucb->ppib );

		/*	if next/prev item node is on different page,
		/*	latch adjacent page
		/**/
		dib.fFlags = fDIRNull;
		if ( fFirstItem )
			{
			Call( ErrBTNext( pfucb, &dib ) );
			}
		else
			{
			Call( ErrBTPrev( pfucb, &dib ) );
			}

		if ( pcsr->pgno != pgnoItem )
			{
			Call( ErrSTWriteAccessPage( pfucb, pcsr->pgno ) );
			pbfSibling = pfucb->ssib.pbf;
			if ( FBFWriteLatchConflict( pfucb->ppib, pbfSibling ) )
				{
				BFResetWaitLatch( pbfLatched, pfucb->ppib );
				BFResetWriteLatch( pbfLatched, pfucb->ppib );
				BFUnpin( pbfLatched );
				LeaveNestableCriticalSection( critSplit );
				goto Start;
				}

			BFPin( pbfSibling );
			BFSetWriteLatch( pbfSibling, pfucb->ppib );
			BFSetWaitLatch( pbfSibling, pfucb->ppib );
			}

		/* go back page of deleted item and delete item node
		/**/
		Assert( dib.fFlags == fDIRNull );
		if ( fFirstItem )
			{
			CallS( ErrBTPrev( pfucb, &dib ) );
			}
		else
			{
			CallS( ErrBTNext( pfucb, &dib ) );
			}

		Call( ErrBTDelete( pfucb, fFlags ) );

		/*	make next/prev item list node new first/last item node
		/**/
		dib.fFlags = fDIRNull;
		if ( fFirstItem )
			{
			CallS( ErrBTNext( pfucb, &dib ) );
			}
		else
			{
			CallS( ErrBTPrev( pfucb, &dib ) );
			}

		CallS( ErrBTGet( pfucb, pcsr ) );
		bHeader = *pfucb->ssib.line.pb;
		if ( fFirstItem )
			NDSetFirstItem( bHeader );
		else
			NDSetLastItem( bHeader );

		//	UNDONE:	handle error from logging here
		CallS( ErrNDSetNodeHeader( pfucb, bHeader ) );

HandleError:
		if ( pbfSibling != pbfNil )
			{
			BFResetWaitLatch( pbfSibling, pfucb->ppib );
			BFResetWriteLatch( pbfSibling, pfucb->ppib );
			BFUnpin( pbfSibling );
			}
		BFResetWaitLatch( pbfLatched, pfucb->ppib );
		BFResetWriteLatch( pbfLatched, pfucb->ppib );
		BFUnpin( pbfLatched );

LeaveCritSplit:
		LeaveNestableCriticalSection(critSplit);
		}
	while ( err == errDIRNotSynchronous );

	return err;
	}


ERR ErrDIRICheckIndexRange( FUCB *pfucb )
	{
	ERR		err;

	AssertNDGetKey( pfucb, PcsrCurrent( pfucb )->itag );

	err = ErrFUCBCheckIndexRange( pfucb );
	if ( err == JET_errNoCurrentRecord )
		{
		if ( FFUCBUpper( pfucb ) )
			{
			DIRAfterLast( pfucb );
			}
		else
			{
			DIRBeforeFirst( pfucb );
			}
		}

	return err;
	}


VOID DIRISaveOLCStats( FUCB *pfucb )
	{
	ERR  	err;
	LINE	line;
	BOOL	fNonClustered = FFUCBNonClustered( pfucb );

	/*	release unneeded CSRs
	/**/
	if ( pfucb->pcsr != pcsrNil )
		{
		while ( pfucb->pcsr->pcsrPath != pcsrNil )
			{
			FUCBFreeCSR( pfucb );
			}
		}

	if ( !FFCBOLCStatsAvail( pfucb->u.pfcb ) )
		return;

	/* go to ../file/some_file/OLCStats
	/**/
	FUCBResetNonClustered( pfucb );
	DIRGotoFDPRoot( pfucb );
	err = ErrDIRSeekPath( pfucb, 1, pkeyOLCStats, 0 );
	if ( err != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
#ifndef DATABASEFORMATCHANGE
		if ( err == JET_errRecordNotFound )
			err = JET_errSuccess;
#endif
		Error( err, HandleError );
		}

	/* replace existing data with pfcb->olcstats, if it has changed
	/**/
	if ( fOLCompact && FFCBOLCStatsChange( pfucb->u.pfcb ) )
		{
		line.pb = (BYTE *) &pfucb->u.pfcb->olcStat;
		line.cb = sizeof(PERS_OLCSTAT);

		Call( ErrDIRBeginTransaction( pfucb->ppib ) );
		err = ErrDIRReplace( pfucb, &line, fDIRNoVersion );
		if ( err >= JET_errSuccess )
			err = ErrDIRCommitTransaction( pfucb->ppib );
		if ( err < 0 )
			{
			CallS( ErrDIRRollback( pfucb->ppib ) );
			}
		}

HandleError:
	if ( fNonClustered )
		FUCBSetNonClustered( pfucb );
	return;
	}


/**************** DAE Super API Routines ******************
/**********************************************************
/**/
ERR ErrDIRSeekPath( FUCB *pfucb, INT ckeyPath, KEY *rgkeyPath, INT fFlags )
	{
	ERR		err = JET_errSuccess;
	DIB		dibT;
	CSR		*pcsr = PcsrCurrent( pfucb );
	INT		ikey;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( ckeyPath > 0 );
	Assert( rgkeyPath != NULL );

	/*	disable purge path for error recovery
	/**/
	dibT.fFlags = fFlags & ~( fDIRPurgeParent );
	dibT.pos = posDown;

	for ( ikey = 0; ikey < ckeyPath; ikey++ )
		{
		dibT.pkey = (KEY *)&rgkeyPath[ikey];
		err = ErrDIRDown( pfucb, &dibT );
		if ( err != errDIRFDP && err != JET_errSuccess )
			{
			if ( err >= JET_errSuccess )
				err = JET_errRecordNotFound;
			goto HandleError;
			}
		}

	/*	purge path if requested now that success is sure
	/**/
	if ( fFlags & fDIRPurgeParent )
		DIRIPurgeParent( pfucb );

	CheckCSR( pfucb );
	return err;

HandleError:
	DIRIUpToCSR( pfucb, pcsr );
	CheckCSR( pfucb );
	return err;
	}


VOID DIRIUp( FUCB *pfucb, INT ccsr )
	{
	CheckFUCB( pfucb->ppib, pfucb );
	CheckCSR( pfucb );
	Assert( ccsr > 0 );

	while ( PcsrCurrent( pfucb ) != pcsrNil && ccsr > 0 )
		{
		/*	must release two CSRs to move up through FDP node
		/*	since path through FDP has two CSRs
		/**/
		if ( PcsrCurrent( pfucb )->csrstat != csrstatOnFDPNode )
			ccsr--;
		FUCBFreeCSR( pfucb );
		}

	/*	set currency.
	/**/
	Assert( ccsr == 0 );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	DIRSetRefresh( pfucb );

	/* set sridFather
	/**/
	{
	CSRSTAT		csrstat = PcsrCurrent( pfucb )->csrstat;
	if ( ( csrstat == csrstatOnFDPNode || csrstat == csrstatOnCurNode )
		 && PcsrCurrent( pfucb )->pcsrPath != pcsrNil )
		{
		pfucb->sridFather = PcsrCurrent( pfucb )->pcsrPath->bm;
		Assert( pfucb->sridFather != sridNull );
		Assert( pfucb->sridFather != sridNullLink );
		}
	else
		{
		pfucb->sridFather = sridNull;
		}
	}

	CheckCSR( pfucb );
	return;
	}


/******************** DIR API Routines ********************
/**********************************************************
/**/
ERR ErrDIROpen( PIB *ppib, FCB *pfcb, DBID dbid, FUCB **ppfucb )
	{
	ERR		err;
	FUCB 	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	if ( !fRecovering && fSTInit == fSTInitDone )
		CheckDBID( ppib, dbid );
#endif

	/*	canabalize deferred closed cursor
	/**/
	for ( pfucb = ppib->pfucb;
		pfucb != pfucbNil;
		pfucb = pfucb->pfucbNext )
		{
		if ( FFUCBDeferClosed(pfucb) && !FFUCBNotReuse(pfucb) )
			{
			Assert( pfucb->u.pfcb != pfcbNil );
			if ( ( pfucb->u.pfcb == pfcb ) ||
				( pfcb == pfcbNil &&
				pfucb->u.pfcb->dbid == dbid &&
				pfucb->u.pfcb->pgnoRoot == pgnoSystemRoot ) )
				{
				Assert( ppib->level > 0 );
				Assert( pfucb->levelOpen <= ppib->level );
				FUCBResetDeferClose(pfucb);
				// UNDONE: integrate this with ErrFUCBOpen
				pfucb->wFlags = 0;

				if ( FDBIDReadOnly( dbid ) )
					FUCBResetUpdatable(pfucb);
				else
					FUCBSetUpdatable(pfucb);
				goto GotoRoot;
				}
			}
		}

	err = ErrFUCBOpen( ppib, (DBID) (pfcb != pfcbNil ? pfcb->dbid : dbid), &pfucb );
	if ( err < 0 )
		{
		DIRAPIReturn( pfucbNil, err );
		}

	/*	link FCB
	/**/
	if ( pfcb == pfcbNil )
		{
		pfcb = PfcbFCBGet( dbid, pgnoSystemRoot );
		if ( pfcb == pfcbNil )
			Call( ErrFCBNew( ppib, dbid, pgnoSystemRoot, &pfcb ) );
		}
	FCBLink( pfucb, pfcb );

GotoRoot:
	/*	initialize cursor location to root of domain.
	/*	set currency.  Note, that no line can be cached
	/*	since this domain may not yet exist in page format.
	/**/
	PcsrCurrent( pfucb )->csrstat = csrstatOnFDPNode;
	PcsrCurrent( pfucb )->bm =
		SridOfPgnoItag( PgnoFDPOfPfucb( pfucb ), itagFOP );
	PcsrCurrent( pfucb )->pgno = PgnoFDPOfPfucb( pfucb );
	PcsrCurrent( pfucb )->itag = itagFOP;
	PcsrCurrent( pfucb )->itagFather = itagFOP;
	pfucb->sridFather = sridNull;
	DIRSetRefresh( pfucb );

	/*	reset rglineDiff delta logging
	/**/
	pfucb->clineDiff = 0;
	pfucb->fCmprsLg = fFalse;

	/*	set return pfucb
	/**/
	*ppfucb = pfucb;
	DIRAPIReturn( pfucb, JET_errSuccess );

HandleError:
	FUCBClose( pfucb );
	DIRAPIReturn( pfucbNil, err );
	}


VOID DIRClose( FUCB *pfucb )
	{
	/*	this cursor should not be already defer closed
	/**/
	Assert( fRecovering || !FFUCBDeferClosed(pfucb) );

	/*	release key buffer if one was allocated.
	/**/
	if ( pfucb->pbKey != NULL )
		{
		LFree( pfucb->pbKey );
		pfucb->pbKey = NULL;
		}

	/*  reset log compression */
	pfucb->clineDiff = 0;
	pfucb->fCmprsLg = fFalse;

	/*	if cursor created version then deferred close until transaction
	/*	level 0, for rollback support.
	/**/
	if ( pfucb->ppib->level > 0 && FFUCBVersioned( pfucb ) )
		{
		Assert( pfucb->u.pfcb != pfcbNil );
		DIRIPurgeParent( pfucb );
		FUCBSetDeferClose( pfucb );
		}
	else
		{
		if ( FFUCBDenyRead( pfucb ) )
			FCBResetDenyRead( pfucb->u.pfcb );
		if ( FFUCBDenyWrite( pfucb ) )
			FCBResetDenyWrite( pfucb->u.pfcb );

		/*	if last reference to fcb, save the OLCStats info
		/**/
		if ( pfucb->u.pfcb->wRefCnt == 1 )
			{
			DIRISaveOLCStats( pfucb );
			}

		FCBUnlink( pfucb );
		FUCBClose( pfucb );
		}
	}


ERR ErrDIRDown( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	CSR		**ppcsr = &PcsrCurrent( pfucb );
	SRID	sridFatherSav = pfucb->sridFather;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( *ppcsr != pcsrNil );
	Assert( pdib->pos == posFirst ||
		pdib->pos == posLast ||
		pdib->pos == posDown );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );

	switch( (*ppcsr)->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatOnFDPNode:
		case csrstatOnDataRoot:
			break;
		default:
			Assert( (*ppcsr)->csrstat == csrstatBeforeCurNode ||
				(*ppcsr)->csrstat == csrstatAfterCurNode ||
				(*ppcsr)->csrstat == csrstatBeforeFirst ||
				(*ppcsr)->csrstat == csrstatAfterLast );
			DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
		}

	/* save current node as visible father
	/**/
	pfucb->sridFather = (*ppcsr)->bm;

	/*	down to node
	/**/
	Call( ErrBTDown( pfucb, pdib ) );
	NDGetNode( pfucb );

	/*	handle key found case on non-clustered index before
	/*	status handling, since absence of valid items
	/*	may change case.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	if posLast, then move to last item.  If posFirst,
		/*	or posDown, then move to first item.
		/**/
		if ( err == JET_errSuccess )
			{
			if ( pdib->pos == posLast )
				{
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRISetItemListFromLast( pfucb );
				err = ErrNDLastItem( pfucb );
				}
			else
				{
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRISetItemListFromFirst( pfucb );
				err = ErrNDFirstItem( pfucb );
				}

			/*	if items not there, then go next previous
			/*	depending on DIB.  If no valid item found, then
			/*	discard leaf CSR and fail down operation.
			/**/
			if ( err != JET_errSuccess )
				{
				err = ErrDIRIDownAdjust( pfucb, pdib );
				if ( err < 0 )
					{
					if ( PcsrCurrent(pfucb)->pcsrPath )
						BTUp( pfucb );
					goto HandleError;
					}
				}
			}
		else
			{
			/*	set item list descriptor for subsequent ver
			/*	operations.
			/**/
			DIRISetItemListFromLast( pfucb );
			(VOID)ErrNDFirstItem( pfucb );
			}
		}
	else
		{
		/*	must store bookmark for currency.
		/**/
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	/*	set status depending on search findings.
	/**/
	switch( err )
		{
		case JET_errSuccess:

			(*ppcsr)->csrstat = csrstatOnCurNode;

			if( FNDFDPPtr( *pfucb->ssib.line.pb ) )
				{
				AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
//				Assert( !( FNDVersion( *pfucb->ssib.line.pb ) ) );
				Assert( pfucb->lineData.cb == sizeof(PGNO) );
				Call( ErrDIRIDownToFDP( pfucb, *( UNALIGNED PGNO * )pfucb->lineData.pb ) );
				AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
				err = errDIRFDP;
				}
			break;

		case wrnNDFoundLess:
			(*ppcsr)->csrstat = csrstatAfterCurNode;
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there.
				/**/
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				(VOID)ErrNDLastItem( pfucb );
				}
			break;

		default:
			Assert( err == wrnNDFoundGreater );
			(*ppcsr)->csrstat = csrstatBeforeCurNode;
			/*	isrid value could be any valid item
			/*	in node with key greater than seek key.
			/**/
			break;
		}

	if ( pdib->fFlags & fDIRPurgeParent )
		{
		DIRIPurgeParent( pfucb );
		}

	DIRSetFresh( pfucb );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );

HandleError:
	/*	reinstate sridFather
	/**/
	pfucb->sridFather = sridFatherSav;
	CheckCSR( pfucb );
	Assert( err != JET_errNoCurrentRecord );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDownFromDATA( FUCB *pfucb, KEY *pkey )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );

	/*	down to node
	/**/
	Call( ErrBTDownFromDATA( pfucb, pkey ) );
	NDGetNode( pfucb );

	/*	set to first item
	/**/
	PcsrCurrent( pfucb )->isrid = 0;

	/*	handle key found case on non-clustered index before
	/*	status handling, since absence of valid items
	/*	may change case.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	if posLast, then move to last item.  If posFirst,
		/*	or posDown, then move to first item.
		/**/
		if ( err == JET_errSuccess )
			{
			/*	set item list descriptor for subsequent ver
			/*	operations.
			/**/
			DIRISetItemListFromFirst( pfucb );
			err = ErrNDFirstItem( pfucb );

			/*	if items not there, then go next item.
			/*	If no valid item found, then set currency to
			/*	before first.
			/**/
			if ( err != JET_errSuccess )
				{
				DIB	dibT;

				dibT.fFlags = fDIRNull;
				dibT.pos = posDown;
				dibT.pkey = pkey;
				Call( ErrDIRIDownAdjust( pfucb, &dibT ) );
				}
			}
		else
			{
			/*	set item list descriptor for subsequent ver
			/*	operations.
			/**/
			DIRISetItemListFromLast( pfucb );
			(VOID)ErrNDFirstItem( pfucb );
			}
		}
	else
		{
		/*	must store bookmark for currency.
		/**/
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	/*	set status depending on search findings.
	/**/
	switch( err )
		{
		case JET_errSuccess:
			PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
			Assert( !FNDFDPPtr( *pfucb->ssib.line.pb ) );
			break;

		case wrnNDFoundLess:
			PcsrCurrent( pfucb )->csrstat = csrstatAfterCurNode;
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there.
				/**/
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				(VOID)ErrNDLastItem( pfucb );
				}
			break;

		default:
			Assert( err == wrnNDFoundGreater );
			PcsrCurrent( pfucb )->csrstat = csrstatBeforeCurNode;
			/*	isrid value could be any valid item
			/*	in node with key greater than seek key.
			/**/
			break;
		}

	Assert( PcsrCurrent( pfucb )->pcsrPath == pcsrNil );

	DIRSetFresh( pfucb );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );

HandleError:
	CheckCSR( pfucb );
	Assert( err != JET_errNoCurrentRecord );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDownKeyBookmark( FUCB *pfucb, KEY *pkey, SRID srid )
	{
	ERR		err;
	DIB		dib;
	CSR		*pcsr;
	CSR		*pcsrRoot = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;

	/*	this routine should only be called with non-clustered indexes.
	/**/
	Assert( FFUCBNonClustered( pfucb ) );

	/*	check currency and refresh if necessary.
	/**/
	Assert( pfucb->pcsr->csrstat != csrstatDeferMoveFirst );
	Call( ErrDIRRefresh( pfucb ) );

	/*	item list nodes not versioned.
	/**/
	dib.fFlags = fDIRItemList;
	dib.pos = posDown;
	dib.pkey = pkey;
	Call( ErrBTDown( pfucb, &dib ) );
	Assert( err == JET_errSuccess );

	/*	set currency to on item list and get item list in node data.
	/**/
	pcsr = PcsrCurrent( pfucb );
	pcsr->csrstat = csrstatOnCurNode;
	DIRIGetItemList( pfucb, pcsr );

	/*	set item list descriptor for subsequent ver
	/*	operations.
	/**/
	DIRISetItemListFromFirst( pfucb );

	while ( ( err = ErrNDSeekItem( pfucb, srid ) ) == errNDGreaterThanAllItems )
		{
		Assert( !FNDLastItem( *pssib->line.pb ) );
		Call( ErrBTNextPrev( pfucb, pcsr, fTrue, &dib ) );
		DIRIGetItemList( pfucb, pcsr );
		}

	Assert( err == wrnNDDuplicateItem );
	Assert( pcsr->csrstat == csrstatOnCurNode );

	/*	set item currency.
	/**/
	pcsr->item = srid;

	/*	always purge parent.
	/**/
	DIRIPurgeParent( pfucb );

	DIRSetFresh( pfucb );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, JET_errSuccess );

HandleError:
	DIRIUpToCSR( pfucb, pcsrRoot );
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


VOID DIRUp( FUCB *pfucb, INT ccsr )
	{
	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	DIRIUp( pfucb, ccsr );

	CheckCSR( pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	return;
	}


//+api
//	ERR ErrDIRNext( FUCB pfucb, DIB *pdib )
//
//	PARAMETERS
//		pfucb		 		cursor
//		pdib.pkey			key
//		pdib.fFlags
//		fDIRInPage			move to node/item of same page
//		fDIRNeighborKey		move to node/item of different key
//
//		RETURNS
//
//		err code					bottom CSR status
//		---------------------------------------------------
//		JET_errSuccess				OnCurNode
//		JET_errNoCurrentRecord		AfterLast
//		JET_errPageBoundary			AfterCurNode
//		JET_errKeyBoundary			AfterCurNode
//		errDIRFDP					OnFDPNode
//
//		COMMENTS
//
//		for negative return code, CSR status is unchanged
//-
ERR ErrDIRNext( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );
	KEY		key;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent(pfucb);

	/*	switch action based on CSR status
	/**/
	switch( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatAfterCurNode:
			/*	get next item
			/**/
			break;

		case csrstatBeforeCurNode:
			/*	if non-clustered index then get first item.  If no item
			/*	then break to go to next item in next node.
			/**/
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there.
				/**/
				DIRIGetItemList( pfucb, pcsr );

				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckFirstSetItemList( pfucb );
				err = ErrNDFirstItem( pfucb );
				if ( err != JET_errSuccess )
					break;
				}
			else
				{
				/*	get current node.  If node is deleted, then break
				/*	to move to next node.
				/**/
				err = ErrBTGetNode( pfucb, pcsr );
				if ( err < 0 )
					{
					if ( err == JET_errRecordDeleted )
						break;
					goto HandleError;
					}
				}

			/*	set currency on current
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRSetFresh( pfucb );
			DIRAPIReturn( pfucb, err );

		case csrstatAfterLast:
			DIRAPIReturn( pfucb, JET_errNoCurrentRecord );

		case csrstatOnFDPNode:
			/*	go up to previous level so that cursor can
			/*	be moved to the next node
			/**/
			BTUp( pfucb );
			pcsr = PcsrCurrent( pfucb );
			break;

		default:
			{
			DIB	dib;
			Assert( pcsr->csrstat == csrstatBeforeFirst );

			dib.fFlags = fDIRPurgeParent;
			dib.pos = posFirst;

			/*	move to root.
			/**/
			DIRGotoDataRoot( pfucb );
			err = ErrDIRDown( pfucb, &dib );
			if ( err < 0 )
				{
				/*	retore currency.
				/**/
				DIRBeforeFirst( pfucb );

				/*	polymorph error code.
				/**/
				if ( err == JET_errRecordNotFound )
					err = JET_errNoCurrentRecord;
				}
			DIRAPIReturn( pfucb, err );
			}
		}

	/*	setup dib key
	/**/
	if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
		{
		/*	get current node, which may no longer be there for us.
		/**/
		Call( ErrDIRICopyKey( pfucb, &key ) );
		pdib->pkey = &key;
		}

	/*	if non-clustered index, move to next item.  If on last item,
	/*	move to first item of next node else move to next node.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

		/*	item list nodes not versioned.
		/**/
		pdib->fFlags |= fDIRItemList;

		/*	if neighbor key set then move to first item of next neighbor key
		/*	node, else, move to next item.  If node is deleted then move to
		/*	first item of next node.
		/**/
		if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
			{
			/*	return warning that key has changed
			/**/
			wrn = JET_wrnKeyChanged;

			do
				{
				err = ErrBTNext( pfucb, pdib );
				/*	handle no next node such that DIB preserved.
				/**/
				if ( err < 0 )
					{
					pdib->fFlags |= fDIRNeighborKey;
					Call( err );
					}
				/*	must be on first item list node
				/**/
				Assert( !(pdib->fFlags & fDIRNeighborKey) || FNDFirstItem( *pfucb->ssib.line.pb ) );

				/*	must reset flag so can stop on item list nodes
				/*	in item list interior which have items while
				/*	other nodes have no items.  After stop then
				/*	reset DIB to initial state.
				/**/
				pdib->fFlags &= ~fDIRNeighborKey;
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckFirstSetItemList( pfucb );
				err = ErrNDFirstItem( pfucb );
				/*	first item was not there, check for item there
				/*	later in same item list node.
				/**/
				if ( err != JET_errSuccess )
					err = ErrDIRINextItem( pfucb );
				}
			while ( err != JET_errSuccess );
			pdib->fFlags |= fDIRNeighborKey;
			}
		else
			{
			/*	non-clustered index nodes are always there.
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRIGetItemList( pfucb, pcsr );

			/*	move to next item and next node until item found.
			/**/
			while ( ( err = ErrDIRINextItem( pfucb ) ) < 0 )
				{
				Assert( err == errNDNoItem || err == errNDLastItemNode );
				/*	move to next node with DIB constraints
				/**/
				Call( ErrBTNext( pfucb, pdib ) );
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckFirstSetItemListAndWarn( pfucb, wrn );
				err = ErrNDFirstItem( pfucb );
				if ( err == JET_errSuccess )
					{
					break;
					}
				}
			}
		}
	else
		{
		/*	return warning if key changed
		/**/
		wrn = JET_wrnKeyChanged;

		Call( ErrBTNext( pfucb, pdib ) );
		NDGetNode( pfucb );

		if ( FNDFDPPtr( *pfucb->ssib.line.pb ) )
			{
//			Assert( !( FNDVersion( *pfucb->ssib.line.pb ) ) );
			Assert( pfucb->lineData.cb == sizeof(PGNO) );
			Call( ErrDIRIDownToFDP( pfucb, *( UNALIGNED PGNO * )pfucb->lineData.pb ) );
#ifdef KEYCHANGED
			wrn = errDIRFDP;
#else
			err = errDIRFDP;
#endif
			}
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	/*	check index range
	/**/
	if ( FFUCBLimstat( pfucb ) && FFUCBUpper( pfucb ) && err == JET_errSuccess )
		{
		Call( ErrDIRICheckIndexRange( pfucb ) );
		}

	DIRSetFresh( pfucb );
	CheckCSR( pfucb );
#ifdef KEYCHANGED
	/*	return warning if key changed
	/**/
	DIRAPIReturn( pfucb, wrn );
#else
	DIRAPIReturn( pfucb, err );
#endif

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRPrev( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );
	KEY		key;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent(pfucb);

	/*	switch action based on CSR status
	/**/
	switch( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatBeforeCurNode:
			/*	get next item
			/**/
			break;

		case csrstatAfterCurNode:
			/*	if non-clustered index then get current item.  If no item
			/*	then break to go to previous item in next node.
			/**/
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there
				/**/
				DIRIGetItemList( pfucb, pcsr );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRISetItemListFromLast( pfucb );
				err = ErrNDGetItem( pfucb );
				if ( err != JET_errSuccess )
					break;
				}
			else
				{
				/*	get current node.  If node is deleted, then break
				/*	to move to next node.
				/**/
				err = ErrBTGetNode( pfucb, pcsr );
				if ( err < 0 )
					{
					if ( err == JET_errRecordDeleted )
						break;
					goto HandleError;
					}
				}

			/*	set currency on current
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRSetFresh( pfucb );
			DIRAPIReturn( pfucb, err );

		case csrstatBeforeFirst:
			DIRAPIReturn( pfucb, JET_errNoCurrentRecord );

		case csrstatOnFDPNode:
			/*	go up to previous level so that cursor can
			/*	be moved to the next node
			/**/
			BTUp( pfucb );
			pcsr = PcsrCurrent( pfucb );
			break;

		default:
			{
			DIB dib;

			Assert( pcsr->csrstat == csrstatAfterLast );

			dib.fFlags = fDIRPurgeParent;
			dib.pos = posLast;

			/*	move up preserving currency in case down fails.
			/**/
			DIRGotoDataRoot( pfucb );
			err = ErrDIRDown( pfucb, &dib );
			if ( err < 0 )
				{
				/*	restore currency.
				/**/
				DIRAfterLast( pfucb );

				/*	polymorph error code.
				/**/
				if ( err == JET_errRecordNotFound )
					err = JET_errNoCurrentRecord;
				}
			DIRAPIReturn( pfucb, err );
			}
		}

	/*	setup dib key
	/**/
	if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
		{
		/*	get current node, which may no longer be there for us.
		/**/
		Call( ErrDIRICopyKey( pfucb, &key ) );
		pdib->pkey = &key;
		}

	/*	if non-clustered index, move to previous item
	/*	if on first item, move to last item of previous node
	/*	else move to previous node
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

		/*	item list nodes not versioned.
		/**/
		pdib->fFlags |= fDIRItemList;

		/*	if neighbor key then move to last item of previous neighbor key
		/*	node, else move to previous item.  If current node deleted, then
		/*	move to previous node.
		/**/
		if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
			{
			/*	return warning that key has changed
			/**/
			wrn = JET_wrnKeyChanged;

			do
				{
				/*	handle no prev node such that DIB preserved
				/**/
				err = ErrBTPrev( pfucb, pdib );
				if ( err < 0 )
					{
					pdib->fFlags |= fDIRNeighborKey;
					Call( err );
					}

				/*	must be last item list node
				/**/
				Assert( !( pdib->fFlags & fDIRNeighborKey ) || FNDLastItem( *pfucb->ssib.line.pb ) );

				/*	must reset flag so can stop on item list nodes
				/*	in item list interior which have items while
				/*	other nodes have no items.  After stop then
				/*	reset DIB to initial state.
				/**/
				pdib->fFlags &= ~fDIRNeighborKey;

				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckLastSetItemList( pfucb );
				err = ErrNDLastItem( pfucb );
				/*	last item was not there, check for item there
				/*	earlier in same item list node.
				/**/
				if ( err != JET_errSuccess )
					err = ErrDIRIPrevItem( pfucb );
				}
			while ( err != JET_errSuccess );
			pdib->fFlags |= fDIRNeighborKey;
			}
		else
			{
			/*	non-clustered index nodes are always there.
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRIGetItemList( pfucb, pcsr );

			while ( ( err = ErrDIRIPrevItem( pfucb ) ) < 0 )
				{
				Assert( err == errNDNoItem || err == errNDFirstItemNode );
				/*	move to previous node with DIB constraints
				/**/
				Call( ErrBTPrev( pfucb, pdib ) );
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckLastSetItemListAndWarn( pfucb, wrn );
				err = ErrNDLastItem( pfucb );
				if ( err == JET_errSuccess )
					{
					break;
					}
				}
			}
		}

	else
		{
		/*	return warning if key changed
		/**/
		wrn = JET_wrnKeyChanged;
		Call( ErrBTPrev( pfucb, pdib ) );
 		NDGetNode( pfucb );

		if ( FNDFDPPtr( *pfucb->ssib.line.pb ) )
			{
//			Assert( !( FNDVersion( *pfucb->ssib.line.pb ) ) );
			Assert( pfucb->lineData.cb == sizeof(PGNO) );
			Call( ErrDIRIDownToFDP( pfucb, *(PGNO *)pfucb->lineData.pb ) );
#ifdef KEYCHANGED
			wrn = errDIRFDP;
#else
			err = errDIRFDP;
#endif
			}
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	/*	check index range.  If exceed range, then before first, disable
	/*	range and return no current record.
	/**/
	if ( FFUCBLimstat( pfucb ) && !FFUCBUpper( pfucb ) && err == JET_errSuccess )
		{
		Call( ErrDIRICheckIndexRange( pfucb ) );
		}

	DIRSetFresh( pfucb );
	CheckCSR( pfucb );
#ifdef KEYCHANGED
	/*	return warning if key changed
	/**/
	DIRAPIReturn( pfucb, wrn );
#else
	DIRAPIReturn( pfucb, err );
#endif

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRCheckIndexRange( FUCB *pfucb )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	/*	get keyNode for check index range
	/**/
	Call( ErrDIRGet( pfucb ) );
	Call( ErrDIRICheckIndexRange( pfucb ) );

	DIRSetFresh( pfucb );
HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRInsert( FUCB *pfucb, LINE *pline, KEY *pkey, INT fFlags )
	{
	ERR		err;
	CSR		*pcsrRoot;
	DIB		dib;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

Start:
	/* save current node as visible father
	/**/
	Assert( pfucb->pcsr->csrstat != csrstatDeferMoveFirst );
	pcsrRoot = PcsrCurrent( pfucb );
	pfucb->sridFather = pcsrRoot->bm;
	Assert( pfucb->sridFather != sridNull );
	Assert( pfucb->sridFather != sridNullLink );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );

	if ( FFUCBNonClustered( pfucb ) )
		{
		SRID	srid;
		INT		cbReq;
		SSIB	*pssib = &pfucb->ssib;

		/*	get given item
		/**/
		Assert( pline->cb == sizeof(SRID) );
		srid = *( UNALIGNED SRID * ) pline->pb;

		/*	seek first item list node with given key.  Allow duplicate nodes
		/*	even if non-clustered index does not allow duplicate key items
		/*	since node may contain item list with all deleted items.
		/**/
		err = ErrBTSeekForUpdate( pfucb, pkey, 0, 0, fDIRDuplicate | fDIRReplaceDuplicate | fFlags );

		switch ( err )
			{
			case JET_errSuccess:
				{
				/*	seek for update does not cache line pointers.
				/*	We need this information for item insertion.
				/**/
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

		 		/*	if versioning then get bookmark of first item list
				/*	node to hash item versions.
				/**/
				if ( fFlags & fDIRVersion )
					{
					SRID	bmItemList;

					/*	if node is not first item list node then
					/*	reseek to first item list node.  In this way,
					/*	thrashing across many duplicate index entries.
					/**/
					if ( !FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
						{
						/*	go up to root, and reseek to begining of item list node list
						/**/
						DIRIUpToCSR( pfucb, pcsrRoot );
						dib.fFlags = fDIRNull;
						dib.pos = posDown;
						dib.pkey = pkey;
						Call( ErrBTGet( pfucb, PcsrCurrent( pfucb ) ) );
						Call( ErrBTDown( pfucb, &dib ) );
						Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );
						DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
						}

					/*	set item list descriptor for subsequent ver operations
					/**/
					DIRISetItemListFromFirst( pfucb );
					bmItemList = PcsrCurrent( pfucb )->bm;

					/*	if duplicates are not allowed then check for duplicate
					/**/
					if ( !( fFlags & fDIRDuplicate ) )
						{
						Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );

						/*	check for duplicate key
						/**/
						Call( ErrDIRIKeyDuplicate( pfucb ) );
						Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
						}
					else if ( !FNDLastItem( *( pfucb->ssib.line.pb ) ) )
						{
						/*	now go back to end of item list node list and seek for
						/*	insertion point, which is more likely to be at
						/*	end of list.  Note that during this time, all items
						/*	may have been deleted and cleaned up, so if not found
						/*	success, then start over.
						/**/
						DIRIUpToCSR( pfucb, pcsrRoot );
						Call( ErrBTGet( pfucb, PcsrCurrent( pfucb ) ) );
						Call( ErrBTSeekForUpdate( pfucb, pkey, 0, 0, fDIRDuplicate | fDIRReplaceDuplicate | fFlags ) );
						if ( err != JET_errSuccess )
							goto Start;
						Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
						DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
						}

					/*	move to item insert position
					/**/
					Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
					Call( ErrDIRIMoveToItem( pfucb, srid, fFalse ) );

					/*	set bm from cached bm
					/**/
					PcsrCurrent( pfucb )->bm = bmItemList;
					}
				else
					{
					/*	set bookmark from current node
					/**/
					PcsrCurrent( pfucb )->bm = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
						PcsrCurrent( pfucb )->itag );

					/*	if duplicates are not allowed then check for duplicate
					/**/
					if ( !( fFlags & fDIRDuplicate ) )
						{
						/*	if node is not first item list node then
						/*	reseek to first item list node.  In this way,
						/*	thrashing across many duplicate index entries.
						/**/
						if ( !FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
							{
							/*	go up to root, and reseek to begining of item list node list
							/**/
							DIRIUpToCSR( pfucb, pcsrRoot );
							dib.fFlags = fDIRNull;
							dib.pos = posDown;
							dib.pkey = pkey;
							Call( ErrBTGet( pfucb, PcsrCurrent( pfucb ) ) );
							Call( ErrBTDown( pfucb, &dib ) );
							Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );
							DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
							}

						/*	check for duplicate key
						/**/
						Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );
						Call( ErrDIRIKeyDuplicate( pfucb ) );
						}

					/*	move to item insert position
					/**/
					Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
					Call( ErrDIRIMoveToItem( pfucb, srid, fFalse ) );

					/*	set bookmark from current node
					/**/
					PcsrCurrent( pfucb )->bm = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
						PcsrCurrent( pfucb )->itag );
					}

				/*	if item already there, then overwrite with insert version
				/**/
				if ( err == wrnNDDuplicateItem )
					{
					err = ErrNDFlagInsertItem( pfucb );
					if ( err == errDIRNotSynchronous )
						{
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}
					Call( err );
					}
				else
					{
					/*	split item list node if maximum number of items
					/*	has been reached
					/**/
					if ( pfucb->lineData.cb == citemMax * sizeof(SRID) )
						{
						cbReq = cbFOPOneSon + pfucb->keyNode.cb;

						if ( FBTSplit( pssib, cbReq, 1 ) )
							{
							FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrRoot );
							AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
							Call( ErrBTSplit( pfucb, pfucb->ssib.line.cb, cbReq, NULL, fDIRAppendItem | fDIRReplace ) );
							DIRIUpToCSR( pfucb, pcsrRoot );
							goto Start;
							}

						Call( ErrNDSplitItemListNode( pfucb, fFlags ) );
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}

					cbReq = sizeof(SRID);
					if ( FBTSplit( pssib, cbReq, 0 ) )
						{
						FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrRoot );
						AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
						Call( ErrBTSplit( pfucb, pfucb->ssib.line.cb, cbReq, pkey, fDIRAppendItem | fDIRReplace ) );
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}

					/*	cache page access in case lost during loss of critJet
					/**/
					if ( !FWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
						{
						Call( ErrSTWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
						}
					NDGet( pfucb, PcsrCurrent( pfucb )->itag );
					DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
					err = ErrNDInsertItem( pfucb, (SRID)srid, fFlags );
					if ( err == errDIRNotSynchronous )
						{
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}
					Call( err );
					PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
					}
				break;
				}

			case wrnNDFoundLess:
			case wrnNDFoundGreater:
				{
				cbReq = cbNullKeyData + pkey->cb + sizeof(SRID);
				if ( FBTAppendPage( pfucb, PcsrCurrent( pfucb ), cbReq, 0, CbFreeDensity( pfucb ) ) ||
					FBTSplit( pssib, cbReq, 1 ) )
					{
					FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrRoot );
					Call( ErrBTSplit( pfucb, 0, cbReq, pkey, 0 ) );
					DIRIUpToCSR( pfucb, pcsrRoot );
					goto Start;
					}

				/*	insert item list node.
				/**/
				err = ErrNDInsertItemList( pfucb, pkey, *(UNALIGNED SRID *)pline->pb, fFlags );
				if ( err == errDIRNotSynchronous )
					{
					DIRIUpToCSR( pfucb, pcsrRoot );
					goto Start;
					}
				Call( err );
				PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
				break;
				}

			default:
				goto HandleError;
			}
		}
	else
		{
		/*	clustered index
		/**/
		Call( ErrBTSeekForUpdate( pfucb, pkey, 0, 0, fFlags ) );

		err = ErrBTInsert( pfucb, 0, pkey, pline, fFlags );
		if ( err == errDIRNotSynchronous )
			{
			BTUp( pfucb );
			goto Start;
			}
		Call( err );
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	if ( fFlags & fDIRBackToFather )
		{
		DIRIUp( pfucb, 1 );
		Assert( PcsrCurrent( pfucb ) == pcsrRoot );
		}
	else
		{
		if ( fFlags & fDIRPurgeParent )
			{
			Assert( err >= 0 );
			DIRIPurgeParent( pfucb );
			}
		DIRSetFresh( pfucb );
		}

HandleError:
	/*	 if write latched empty page the release latch
	/**/
	if ( pfucb->pbfEmpty != pbfNil )
		{
		BFResetWriteLatch( pfucb->pbfEmpty, pfucb->ppib );
		BFUnpin( pfucb->pbfEmpty );
		pfucb->pbfEmpty = pbfNil;
		}

	/*	depend on ErrDIRRollback to clean up on error.  Rollback may have
	/*	already occured in which case even pcsrRoot may no longer be
	/*	present in CSR stack.
	/**/
//	if ( err < 0 )
//		{
//		DIRIUpToCSR( pfucb, pcsrRoot );
//		}

#ifdef DEBUG
	if ( err >= JET_errSuccess )
		CheckCSR( pfucb );
#endif

	DIRAPIReturn( pfucb, err );
	}


/* Does not log, this is done at a higher level
/**/
ERR ErrDIRInsertFDP( FUCB *pfucb, LINE *pline, KEY *pkey, INT fFlags, CPG cpgMin )
	{
	ERR     err;
	CPG     cpgRequest;
	PGNO    pgnoFDP;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	Assert( FReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	/*	create FDP
	/**/
	cpgRequest = cpgMin;
	Call( ErrSPGetExt( pfucb, pfucb->u.pfcb->pgnoFDP, &cpgRequest, cpgMin, &pgnoFDP, fTrue ) );

	/*	add FDP to directory tree
	/**/
	do
		{
		Call( ErrDIRRefresh( pfucb ) );

		err = ErrDIRIInsertFDPPointer( pfucb, pgnoFDP, pkey, fFlags );
		}
	while ( err == errDIRNotSynchronous );
	Call( err );

	/*	replace FDP root with correct data.  NOTE: key left as NULL.
	/*	Also NOTE, this node must be versioned as a indication of
	/*	domain status, to be used during rollback processing.
	/**/
	Call( ErrDIRIDownToFDP( pfucb, pgnoFDP ) );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
	Assert( pline->cb > 0 );

	/*	since this replace is of the FDP root do not handle split case
	/**/
	do
		{
		Call( ErrDIRRefresh( pfucb ) );

		err = ErrBTReplace( pfucb, pline, fDIRVersion );
		}
	while ( err == errDIRNotSynchronous );
	Call( err );

	if ( fFlags & fDIRBackToFather )
		{
		DIRIUp( pfucb, 1 );
		}
	else
		{
		if ( fFlags & fDIRPurgeParent )
			{
			DIRIPurgeParent( pfucb );
			}
		DIRSetFresh( pfucb );
		}

HandleError:
	/*	 if write latched empty page the release latch
	/**/
	if ( pfucb->pbfEmpty != pbfNil )
		{
		BFResetWriteLatch( pfucb->pbfEmpty, pfucb->ppib );
		BFUnpin( pfucb->pbfEmpty );
		pfucb->pbfEmpty = pbfNil;
		}

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


/*	This routine is for use in building non-clustered indexes.  It does not
/*	maintain normal CSR status and leaves currency on inserted node.  If for
/*	any reason simple insertion cannot be performed, errDIRNoShortCircuit
/*	is returned so that the insertion may be performed via DIRInsert.
/*
/*	Also, no versions are created for index items since the table
/*	must be opened exclusively.  When the index is visible to other
/*	sessions, so too will all the items.
/**/
ERR ErrDIRInitAppendItem( FUCB *pfucb )
	{
	ERR	err = JET_errSuccess;

	/*	allocate working buffer if needed
	/**/
	if ( pfucb->pbfWorkBuf == NULL )
		{
		err = ErrBFAllocTempBuffer( &pfucb->pbfWorkBuf );
		if ( err < 0 )
			{
			DIRAPIReturn( pfucb, err );
			}
		pfucb->lineWorkBuf.pb = (BYTE *)pfucb->pbfWorkBuf->ppage;
		}

	PrepareAppendItem( pfucb );
	((APPENDITEM *)pfucb->lineWorkBuf.pb)->isrid = 0;
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRAppendItem( FUCB *pfucb, LINE *pline, KEY *pkey )
	{
	ERR		err;
	CSR		*pcsr;
	SSIB 	*pssib = &pfucb->ssib;
	INT		fNodeHeader;
	UINT 	cbReq;
	UINT 	cbFree;
	INT		citem;
	LONG 	l;
#ifdef BULK_INSERT_ITEM
	INT		isrid = IsridAppendItemOfPfucb( pfucb );
	SRID 	*rgsrid = RgsridAppendItemOfPfucb( pfucb );
#endif

	Assert( pline->cb == sizeof(SRID) );
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	get current node to check for key append
	/**/
	NDGet( pfucb, pcsr->itag );
	DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
	Assert( FNDNullSon( *pssib->line.pb ) );
	citem = pfucb->lineData.cb / sizeof(SRID);

	/*	get free space to density contraint violation
	/**/
	cbFree = CbBTFree( pfucb, CbFreeDensity( pfucb ) );

	/*	if key same as current node then insert SRID, else
	/*	begin new item list node with given key
	/**/
	if ( CmpStKey( StNDKey( pssib->line.pb ), pkey ) == 0 )
		{
#ifdef BULK_INSERT_ITEM
		/*	if one more item would not require item list split
		/*	or page split, then cache current item for bulk
		/*	insertion, else if any cached items, then perform
		/*	bulk insertion.
		/*
		/*	cbReq is space required for cached item node replacement plus
		/*	space for new inserted item list node with one item.
		/**/
		cbReq = isrid * sizeof(SRID) + cbFOPOneSon + pfucb->keyNode.cb + sizeof(SRID);
		Assert( csridAppendItemMax >= citemMax );
		if ( citem + isrid == citemMax || cbReq > cbFree )
			{
			if ( isrid > 0 )
				{
				Call( ErrNDInsertItems( pfucb, ( SRID *)rgsrid, isrid ) );
				IsridAppendItemOfPfucb( pfucb ) = 0;
				}
			}
		else
			{
			Assert( !FBTSplit( pssib, cbReq, 0 ) );
			Assert( citem + isrid < citemMax );
			rgsrid[isrid] = *(UNALIGNED SRID *)pline->pb;
			IsridAppendItemOfPfucb( pfucb )++;
			DIRAPIReturn( pfucb, JET_errSuccess );
			}
#endif

		/*	if this is last item insert before split item list
		/*	cannot be satified from page space, then split item
		/*	list prematurely to ensure good item packing.
		/**/
		cbReq = cbFOPOneSon + pfucb->keyNode.cb;
		if ( cbReq <= cbFree &&  cbReq + sizeof(SRID) > cbFree )
			{
#define	citemFrag		16
			/*	if number of items in current node exceeds
			/*	fragment then split node.
			/**/
			if ( citem > citemFrag )
				{
				/*	cache current item list for item list split.
				/**/
				NDGet( pfucb, PcsrCurrent( pfucb )->itag );
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				Call( ErrNDSplitItemListNode( pfucb, fDIRNoVersion | fDIRAppendItem ) );
				DIRAPIReturn( pfucb, errDIRNoShortCircuit );
				}
			}

		/*	honor density by checking free space to density violation
		/*	and check for split case.
		/**/
		cbReq = sizeof(SRID);
		if ( cbReq > cbFree )
			{
			DIRAPIReturn( pfucb, errDIRNoShortCircuit );
			}
		Assert( !FBTSplit( pssib, cbReq, 0 ) );

		/*	get lineData
		/**/
		NDGet( pfucb, pcsr->itag );
		DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

		citem = pfucb->lineData.cb / sizeof(SRID);
		Assert( citem <= citemMax );
		if ( citem == citemMax )
			{
			DIRAPIReturn( pfucb, errDIRNoShortCircuit );
			}
		l = LSridCmp(	*(((UNALIGNED SRID *)pfucb->lineData.pb) + citem - 1),
			*(UNALIGNED SRID *)pline->pb );
		/*	SRIDs are sorted and will be returned from SORT
		/*	in ascending order.
		/**/
		Assert( l < 0 );
		pcsr->isrid = citem;
		PcsrCurrent( pfucb )->bm = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno, PcsrCurrent( pfucb )->itag );
		CallS( ErrNDInsertItem( pfucb, *(UNALIGNED SRID *)pline->pb, fDIRNoVersion ) );
		}
	else
		{
#ifdef BULK_INSERT_ITEM
		/*	append duplicate items to last node
		/**/
		if ( isrid > 0 )
			{
			Call( ErrNDInsertItems( pfucb,
				( SRID *)rgsrid,
				isrid ) );
			IsridAppendItemOfPfucb( pfucb ) = 0;
			}
#endif

		Assert( CmpStKey( StNDKey( pssib->line.pb ), pkey ) < 0 );

		/*	check density contraint against free space and check split.
		/**/
		cbReq = cbFOPOneSon + CbKey( pkey ) + CbLine( pline );
		if ( cbReq > cbFree || FBTSplit( pssib, cbReq, 1 ) )
			{
			DIRAPIReturn( pfucb, errDIRNoShortCircuit );
			}

		fNodeHeader = 0;
		NDSetFirstItem( fNodeHeader );
		NDSetLastItem( fNodeHeader );
		pcsr->ibSon++;
		while( ( err = ErrNDInsertNode( pfucb, pkey, pline, fNodeHeader ) ) == errDIRNotSynchronous );
		Call( err );
		}

	/*	set CSR status to on inserted node.
	/**/
	pcsr->csrstat = csrstatOnCurNode;
	DIRSetFresh( pfucb );

HandleError:
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRTermAppendItem( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	INT		isrid = IsridAppendItemOfPfucb( pfucb );
	CSR		*pcsr;
	SSIB	*pssib;
	UINT	cbReq;
	UINT	cbFree;
	INT		citem;

	if ( isrid > 0 )
		{
		pssib = &pfucb->ssib;

		Call( ErrDIRRefresh( pfucb ) );
		pcsr = PcsrCurrent( pfucb );

		/*	get current node to check for key append.
		/**/
		NDGet( pfucb, pcsr->itag );
		DIRIGetItemList( pfucb, pcsr );
		Assert( FNDNullSon( *pssib->line.pb ) );

		/*	get free space to density contraint violation
		/**/
		cbFree = CbBTFree( pfucb, CbFreeDensity( pfucb ) );

		/*	if key same as current node then insert SRID, else
		/*	begin new item list node with given key
		/**/
		citem = pfucb->lineData.cb / sizeof(SRID);
		cbReq = isrid * sizeof(SRID) + cbFOPOneSon + pfucb->keyNode.cb;
		Assert( isrid != csridAppendItemMax &&
			citem + isrid < citemMax &&
			cbReq <= cbFree );
		Call( ErrNDInsertItems( pfucb,
			( SRID *)RgsridAppendItemOfPfucb( pfucb ),
			isrid ) );

		/*	set CSR status to on inserted node.
		/**/
		pcsr->csrstat = csrstatOnCurNode;

		DIRSetFresh( pfucb );
		}

HandleError:
	if ( pfucb->pbfWorkBuf != pbfNil )
		{
		BFSFree( pfucb->pbfWorkBuf );
		pfucb->pbfWorkBuf = pbfNil;
		}

	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRReplaceKey( FUCB *pfucb, KEY *pkeyTo, INT fFlags )
	{
	ERR		err;
	BOOL   	fFDP;
	PGNO   	pgnoFDP;
	CSR		*pcsr;
	BYTE   	rgbData[ cbNodeMost ];
	LINE   	line;
	INT		bHeader;
	CSR		*pcsrRoot;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	if ( pcsr->csrstat != csrstatOnCurNode && pcsr->csrstat != csrstatOnFDPNode )
		{
		DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
		}
	fFDP = ( pcsr->csrstat == csrstatOnFDPNode );

	/*	if FDP, then replace key and go up to replace FDP page pointer key
	/**/
	if ( fFDP )
		{
		pgnoFDP = PcsrCurrent( pfucb )->pgno;
		Assert( pcsr->pcsrPath != pcsrNil );
		BTUp( pfucb );
		pcsr = PcsrCurrent( pfucb );
		}

	do
		{
		/*	get current node
		/**/
		Assert( pcsr->csrstat == csrstatOnCurNode );
		Call( ErrDIRRefresh( pfucb ) );
		Assert( pfucb->ssib.line.cb < cbNodeMost );

		/*	copy node header
		/**/
		bHeader = *pfucb->ssib.line.pb;
		NDResetVersion( bHeader );
		/*	can be deleted, but we can only land on this if we are
		/*	out of date, and we will fail on update since we are
		/*	out of date.
		/**/
		NDResetBackLink( bHeader );
		Assert( !FNDSon( bHeader ) );
		Assert( !FNDFirstItem( bHeader ) );
		Assert( !FNDLastItem( bHeader ) );

		/*	copy node data
		/**/
		line.cb = CbNDData( pfucb->ssib.line.pb, pfucb->ssib.line.cb );
		line.pb = rgbData;
		memcpy( line.pb, PbNDData( pfucb->ssib.line.pb ), line.cb );

		/*	delete currnet node and reinsert with new key
		/**/
		err = ErrBTDelete( pfucb, fFlags );
		}
	while ( err == errDIRNotSynchronous );
	Call( err );

	BTUp( pfucb );
	pcsrRoot = PcsrCurrent( pfucb );

	do
		{
		/*	after moving up must refresh the parent node
		/**/
		Call( ErrDIRRefresh( pfucb ) );

		/*	insert node even if not synchronous.
		/**/
		Call( ErrBTSeekForUpdate( pfucb, pkeyTo, 0, 0, fFlags ) );

		err = ErrBTInsert( pfucb, bHeader, pkeyTo, &line, fFlags );

		/* backup to where it was to start seeking again
		/**/
		if ( err < 0 )
			{
			DIRIUpToCSR( pfucb, pcsrRoot );
			}
		}
	while ( err == errDIRNotSynchronous );
	Call( err );

	/*	set line cache to honor currency semantics.
	/**/
	Assert( FAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
	NDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	if FDP, go back down to FDP node
	/**/
	if ( fFDP )
		{
		Call( ErrDIRIDownToFDP( pfucb, pgnoFDP ) );
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	DIRSetFresh( pfucb );

HandleError:
	/*	 if write latched empty page the release latch
	/**/
	if ( pfucb->pbfEmpty != pbfNil )
		{
		BFResetWriteLatch( pfucb->pbfEmpty, pfucb->ppib );
		BFUnpin( pfucb->pbfEmpty );
		pfucb->pbfEmpty = pbfNil;
		}

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRGotoPosition( FUCB *pfucb, ULONG ulLT, ULONG ulTotal )
	{
	ERR		err;
	CSR		**ppcsr = &PcsrCurrent( pfucb );
	DIB		dib;
	FRAC	frac;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );

	dib.fFlags = fDIRPurgeParent;
	dib.pos = posFrac;
	dib.pkey = (KEY *)&frac;

	frac.ulLT = ulLT;
	frac.ulTotal = ulTotal;

	/*	position fractionally on node.  Move up preserving currency
	/*	in case down fails.
	/**/
	Call( ErrBTDown( pfucb, &dib ) );
	NDGetNode( pfucb );

	/*	node cannot be FDP pointer, and must be record or index.
	/**/
	Assert( err == JET_errSuccess );
	Assert( !( FNDFDPPtr( *pfucb->ssib.line.pb ) ) );
	(*ppcsr)->csrstat = csrstatOnCurNode;

	/*	if non-clustered index, position fractionally on item.
	/*	FRAC will contain remaining fractional position, for
	/*	item list level.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		INT           citem;
		INT           iitem;

		/*	determine fractional position in item list
		/**/
		citem = CitemNDData( pfucb->ssib.line.pb,
			pfucb->ssib.line.cb,
			PbNDData( pfucb->ssib.line.pb ) );
		if ( frac.ulTotal / citemMax == 0 )
			{
			iitem = ( citem * frac.ulLT ) / frac.ulTotal;
			}
		else
			{
			iitem = ( citem * ( frac.ulLT / ( frac.ulTotal / citemMax ) ) ) / citemMax;
			}
		if ( iitem >= citem )
			iitem = citem - 1;

		/*	if cursor is on first item list node, then cache bookmark
		/*	for version operations.
		/*
		/*	else then move previous
		/*	in same item list until first item list node found.  Cache
		/*	bookmark of first item list node for version operations.
		/**/
		if ( FNDFirstItem( *pfucb->ssib.line.pb ) )
			{
			DIRISetItemListFromFirst( pfucb );
			}
		else
			{
			INT     iitemPrev;
			DIB     dibT;

			dibT.fFlags = fDIRNull;

			for ( iitemPrev = 0;; iitemPrev++)
				{
				Call( ErrDIRPrev( pfucb, &dibT ) );
				if ( FNDFirstItem( *pfucb->ssib.line.pb ) )
					break;
				}

			DIRISetItemListFromFirst( pfucb );

			for ( ; iitemPrev > 0; iitemPrev-- )
				{
				Call( ErrDIRNext( pfucb, &dibT ) );
				}
			}

		/*	position on first item.  If item is not there for this session
		/*	then increment iitem to move to correct position.
		/**/
		err = ErrNDFirstItem( pfucb );
		Assert( err == JET_errSuccess || err == errNDNoItem );
		if ( err == errNDNoItem )
			{
			iitem++;
			}

		while ( iitem-- > 0 )
			{
			DIB     dibT;

			dibT.fFlags = fDIRNull;

			Assert( iitem >= 0 );

			/*	move to next item in item list.  Note that if some items
			/*	are not there for us, we will move to the next item
			/*	list node.
			/**/
			err = ErrDIRNext( pfucb, &dibT );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					break;
				goto HandleError;
				}
			}

		/*	handle JET_errNoCurrentRecord.  We may have landed on a record
		/*	not there for us, or we may have moved past the last record
		/*	for us.  Try to move to next record, if there is no next record
		/*	then move previous to last record there for us.  If no previous
		/*	record then return JET_errNoCurrentRecord.
		/**/
		Assert( err != errNDNoItem );
		if ( err == JET_errNoCurrentRecord )
			{
			DIB     dibT;
			dibT.fFlags = fDIRNull;

			err = ErrDIRNext( pfucb, &dibT );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					Call( ErrDIRPrev( pfucb, &dibT ) );
				goto HandleError;
				}
			}
		}

	/*	always purge parent.
	/**/
	DIRIPurgeParent( pfucb );
HandleError:
	DIRAPIReturn( pfucb, err );
	}


/*********** currency neutral DIR API Routines ************
/**********************************************************
/**/
ERR ErrDIRGetWriteLock( FUCB *pfucb )
	{
	ERR     err = JET_errSuccess;

	do
		{

		Assert( pfucb->ppib->level > 0 );

		/*	check currency and refresh if necessary.
		/**/
		Call( ErrDIRRefresh( pfucb ) );

		/*	check CSR status
		/**/
		switch ( PcsrCurrent( pfucb )->csrstat )
			{
			case csrstatOnCurNode:
			case csrstatOnFDPNode:
				break;
			default:
				Assert( PcsrCurrent( pfucb )->csrstat == csrstatBeforeCurNode ||
					PcsrCurrent( pfucb )->csrstat == csrstatAfterCurNode ||
					PcsrCurrent( pfucb )->csrstat == csrstatAfterLast ||
					PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst );
				DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
			}

		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
		NDGetNode( pfucb );

		err = ErrNDLockRecord( pfucb );
		}
	while ( err == errDIRNotSynchronous );
	Call( err );
	Assert( err == JET_errSuccess );

	DIRSetFresh( pfucb );
HandleError:
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDelete( FUCB *pfucb, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( FFUCBNonClustered( pfucb ) || !( fFlags & fDIRDeleteItem ) );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
			{
			Call( ErrBTGetNode( pfucb, pcsr ) );

			if ( FFUCBNonClustered( pfucb ) )
				{
				Assert( !FNDSon( *pfucb->ssib.line.pb ) );
				if ( ! ( fFlags & fDIRDeleteItem ) )
					{
					Assert( fFlags & fDIRVersion );
					err = ErrNDFlagDeleteItem( pfucb );
					while ( err == errDIRNotSynchronous )
						{
						Call( ErrDIRRefresh( pfucb ) );
						err = ErrNDFlagDeleteItem( pfucb );
						}
					Call( err );
					}
				else
					{
					/* actually delete the item
					/* used by VER in cleanup
					/**/
					Assert( !( fFlags & fDIRVersion ) );

					/*	if only one item then delete node
					/**/
					if ( pfucb->lineData.cb == sizeof(SRID) )
						{
						BOOL    fFirstItem;
						BOOL    fLastItem;

						Assert( FNDSingleItem( pfucb ) );

						if ( FNDFirstItem( *pfucb->ssib.line.pb ) )
							fFirstItem = fTrue;
						else
							fFirstItem = fFalse;

						if ( FNDLastItem( *pfucb->ssib.line.pb ) )
							fLastItem = fTrue;
						else
							fLastItem = fFalse;

						if ( fFirstItem ^ fLastItem )
							{
							/*	adjust fist/last item info appropriately
							/**/
							Call( ErrDIRIDeleteEndItemNode( pfucb, fFirstItem, fFlags ) )
							}
						else
							{
							err = ErrBTDelete( pfucb, fFlags );
							while ( err == errDIRNotSynchronous )
								{
								Call( ErrDIRRefresh( pfucb ) );
								err = ErrBTDelete( pfucb, fFlags );
								}
							Call( err );
							}
						}
					else
						{
						/*	delete item
						/**/
						if ( !FWriteAccessPage( pfucb, pcsr->pgno ) )
							{
							Call( ErrSTWriteAccessPage( pfucb, pcsr->pgno ) );
							}
						AssertNDGet( pfucb, pcsr->itag );
						Call( ErrNDDeleteItem( pfucb ) );
						}
					}
				}
			else
				{
				/*	delete current node sons and then current node.  Even
				/*	though the node has sons, the tree may be empty of
				/*	visible sons.
				/**/
				if ( FNDSon( *pfucb->ssib.line.pb ) )
					{
					DIB	dib;

					dib.pos = posFirst;
					dib.fFlags = fDIRNull;
					err = ErrDIRDown( pfucb, &dib );
					if ( err < 0 && err != JET_errRecordNotFound )
						goto HandleError;
					if ( err != JET_errRecordNotFound )
						{
						do
							{
							err = ErrDIRDelete( pfucb, fFlags );
							if ( err < 0 )
								{
								DIRAPIReturn( pfucb, err );
								}
							err = ErrDIRNext( pfucb, &dib );
							}
						while( err == 0 || err == errDIRFDP );
						DIRUp( pfucb, 1 );
						if ( err != JET_errNoCurrentRecord )
							goto HandleError;
						/*	refresh currency after up
						/**/
						Call( ErrDIRRefresh( pfucb ) );
						}
					}
				err = ErrBTDelete( pfucb, fFlags );
				while ( err == errDIRNotSynchronous )
					{
					Call( ErrDIRRefresh( pfucb ) );
					err = ErrBTDelete( pfucb, fFlags );
					}
				Call( err );
				}
			break;
			}
		case csrstatOnFDPNode:
			{
			PGNO    pgnoFDP;

			/*	delete FDP and FDP pointer node
			/**/
			if ( PcsrCurrent( pfucb )->pcsrPath == pcsrNil )
				{
				err = errDIRTop;
				goto HandleError;
				}
			BTUp( pfucb );
			pfucb->sridFather = sridNull;

			/*	refresh currency after up
			/**/
			Call( ErrDIRRefresh( pfucb ) );
			pcsr = PcsrCurrent( pfucb );
			Call( ErrBTGetNode( pfucb, pcsr ) );
			Assert( FNDFDPPtr( *pfucb->ssib.line.pb ) );
			Assert( pfucb->lineData.cb == sizeof(PGNO) );
			pgnoFDP = *(UNALIGNED PGNO *)pfucb->lineData.pb;
			err = ErrBTDelete( pfucb, fFlags );
			while ( err == errDIRNotSynchronous )
				{
				Call( ErrDIRRefresh( pfucb ) );
				err = ErrBTDelete( pfucb, fFlags );
				}
			Call( err );

			/*	release FDP space
			/**/
			Call( ErrSPFreeFDP( pfucb, pgnoFDP ) );
			break;
			}
		default:
			err = JET_errNoCurrentRecord;
		}

	DIRSetRefresh( pfucb );

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRReplace( FUCB *pfucb, LINE *pline, INT fFlags )
	{
	ERR	err;

	do
		{
		CheckFUCB( pfucb->ppib, pfucb );
		Assert( pfucb->pbfEmpty == pbfNil );
		CheckCSR( pfucb );

		/*	check currency and refresh if necessary.
		/**/
		Call( ErrDIRRefresh( pfucb ) );

		if ( PcsrCurrent( pfucb )->csrstat != csrstatOnCurNode &&
			PcsrCurrent( pfucb )->csrstat != csrstatOnFDPNode )
			{
			DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
			}

		NDGetNode( pfucb );
		err = ErrBTReplace( pfucb, pline, fFlags );
		if ( err == JET_errSuccess )
			{
			DIRSetFresh( pfucb );
			DIRAPIReturn( pfucb, err );
			}

		Assert( pfucb->pbfEmpty == pbfNil );
		}
	while ( err == errDIRNotSynchronous );

	DIRSetRefresh( pfucb );
HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDelta( FUCB *pfucb, INT iDelta, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr;

	do
		{
		CheckFUCB( pfucb->ppib, pfucb );
		Assert( pfucb->pbfEmpty == pbfNil );
		CheckCSR( pfucb );

		/*	check currency and refresh if necessary.
		/**/
		Call( ErrDIRRefresh( pfucb ) );
		pcsr = PcsrCurrent( pfucb );

		Call( ErrBTGetNode( pfucb, pcsr ) );

		err = ErrNDDelta( pfucb, iDelta, fFlags );
		}
	while ( err == errDIRNotSynchronous );

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal )
	{
	ERR		err;
	CSR		*pcsr = NULL;
	INT		isrid;
	INT		citem = 1;
	ULONG	ulLT;
	ULONG	ulTotal;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection( critJet );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	return error if not on a record
	/**/
	if ( pcsr->csrstat != csrstatOnCurNode )
		{
		DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
		}

	/*	if on non-clustered index, then treat item list as
	/*	additional tree level.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		DIRIGetItemList( pfucb, pcsr );

		/*	refresh srid
		/**/
		isrid = pcsr->isrid;
		citem = CitemNDData( pfucb->ssib.line.pb,
			pfucb->ssib.line.cb,
			PbNDData( pfucb->ssib.line.pb ) );
		Assert( citem > 0 && citem < citemMax );
		}

	/*	get approximate position of node.
	/**/
	Call( ErrBTGetPosition( pfucb, &ulLT, &ulTotal ) );

	/*	assert that ErrBTGetPosition does not change the
	/*	current CSR.
	/**/
	Assert( pcsr == PcsrCurrent( pfucb ) );

	/*	if citem > 1 from non-clustered index with duplicates, then
	/*	adjust fractional positon by treating non-clustered index
	/*	as additional tree level.
	/**/
	if ( citem > 1 )
		{
		ulTotal *= citem;
		ulLT = ulLT * citem + pcsr->isrid;
		}

	/*	return results
	/**/
	Assert( err == JET_errSuccess );
	Assert( ulLT <= ulTotal );
	*pulLT = ulLT;
	*pulTotal = ulTotal;

HandleError:
	/*	honor currency semantics
	/**/
	if (pcsr != NULL && FReadAccessPage( pfucb, pcsr->pgno ) )
		{
		NDGet( pfucb, PcsrCurrent( pfucb )->itag );
		}

	LeaveNestableCriticalSection( critSplit );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRIndexRecordCount( FUCB *pfucb, ULONG *pulCount, ULONG ulCountMost, BOOL fNext )
	{
	ERR		err;
	CSR		*pcsr;
	DIB		dib;
	INT		citem;
	ULONG 	ulCount;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	return error if not on a record
	/**/
	if ( pcsr->csrstat != csrstatOnCurNode )
		{
		DIRAPIReturn( pfucb, JET_errNoCurrentRecord );
		}
	Call( ErrBTGetNode( pfucb, pcsr ) );

	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	item list nodes not versioned.
		/**/
		dib.fFlags = fDIRItemList;

		/*	initialize count with current position in item list
		/**/
		if ( fNext )
			{
			citem = CitemNDThere( pfucb );
			ulCount = citem - pcsr->isrid;
			}
		else
			{
			ulCount = pcsr->isrid + 1;
			}

		/*	count all items util end of file or limit
		/**/
		forever
			{
			if ( ulCount > ulCountMost )
				{
				ulCount = ulCountMost;
				break;
				}

			err = ErrBTNextPrev( pfucb, pcsr, fNext, &dib );
			if ( err < 0 )
				break;

			/*	if on new item list then set bookmark from
			/*	first item list node, of if on new last item
			/*	list node then move to first, set bookmark,
			/*	and then move back to last.
			/**/
			if ( fNext )
				{
				DIRICheckFirstSetItemList( pfucb );
				}
			else
				{
				DIRICheckLastSetItemList( pfucb );
				}

			DIRIGetItemList( pfucb, pcsr );

			/*	check index range if on new first item list node, i.e.
			/*	key has changed.
			/**/
			if ( FFUCBLimstat( pfucb ) && FNDFirstItem( *pfucb->ssib.line.pb ) )
				{
				err = ErrDIRICheckIndexRange( pfucb );
				if ( err < 0 )
					break;
				}

			citem = CitemNDThere( pfucb );
			Assert( citem < citemMax );
			ulCount += citem;
			}
		}
	else
		{
		/*	clusterred index nodes can be versioned.
		/**/
		dib.fFlags = fDIRNull;

		/*	intialize count variable
		/**/
		ulCount = 0;

		/*	count nodes from current to limit or end of table
		/**/
		forever
			{
			ulCount++;
			if ( ulCount >= ulCountMost )
				{
				ulCount = ulCountMost;
				break;
				}
			err = ErrBTNextPrev( pfucb, pcsr, fNext, &dib );
			if ( err < JET_errSuccess )
				break;

			/*	check index range
			/**/
			if ( FFUCBLimstat( pfucb ) )
				{
				NDGetKey( pfucb );
				err = ErrDIRICheckIndexRange( pfucb );
				if ( err < 0 )
					break;
				}
			}
		}

	/*	common exit loop processing
	/**/
	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto HandleError;

	err = JET_errSuccess;
	*pulCount = ulCount;
HandleError:
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRComputeStats( FUCB *pfucb, INT *pcitem, INT *pckey, INT *pcpage )
	{
	ERR		err;
	DIB		dib;
	BYTE	rgbKey[ JET_cbKeyMost ];
	KEY		key;
	PGNO	pgnoT;
	INT		citem = 0;
	INT		ckey = 0;
	INT		cpage = 0;
	INT		citemT;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( !FFUCBLimstat( pfucb ) );

	/*	go to first node
	/**/
	DIRGotoDataRoot( pfucb );
	dib.fFlags = fDIRNull;
	dib.pos = posFirst;
	err = ErrDIRDown( pfucb, &dib );
	if ( err < 0 )
		{
		/*	if index empty then set err to success
		/**/
		if ( err == JET_errRecordNotFound )
			{
			err = JET_errSuccess;
			goto Done;
			}
		goto HandleError;
		}

	/*	if there is at least one node, then there is a first page.
	/**/
	cpage = 1;

	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	item list nodes not versioned.
		/**/
		dib.fFlags = fDIRItemList;

		/*	count all items util end of file or limit
		/**/
		forever
			{
			DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

			citemT = CitemNDThere( pfucb );
			Assert( citemT < citemMax );
			citem += citemT;

			if ( FNDFirstItem( *pfucb->ssib.line.pb ) && citemT > 0 )
				ckey++;

			pgnoT = PcsrCurrent( pfucb )->pgno;
			err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib );
			if ( err < 0 )
				break;

			/*	if on new item list then set bookmark from
			/*	first item list node.
			/**/
			DIRICheckFirstSetItemList( pfucb );

			if ( PcsrCurrent( pfucb )->pgno != pgnoT )
				cpage++;
			}
		}
	else
		{
		/*	if clustered index is unique then user much faster algorithm
		/**/
		if ( pfucb->u.pfcb->pidb != NULL &&
			( pfucb->u.pfcb->pidb->fidb & fidbUnique ) )
			{
			forever
				{
				citem++;

				/*	move to next node.  If cross page boundary then
				/*	increment page count.
				/**/
				pgnoT = PcsrCurrent( pfucb )->pgno;
				err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib );
				if ( PcsrCurrent( pfucb )->pgno != pgnoT )
					cpage++;
				if ( err < JET_errSuccess )
					{
					ckey = citem;
					goto Done;
					}
				}
			}
		else
			{
			/*	clusterred index nodes can be versioned.
			/**/
			Assert( dib.fFlags == fDIRNull );
			key.pb = rgbKey;

			forever
				{
				ckey++;
				err = ErrDIRICopyKey( pfucb, &key );
				if ( err < 0 )
					{
					DIRAPIReturn( pfucb, err );
					}

				forever
					{
					citem++;

					/*	move to next node.  If cross page boundary then
					/*	increment page count.
					/**/
					pgnoT = PcsrCurrent( pfucb )->pgno;
					err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib );
					if ( PcsrCurrent( pfucb )->pgno != pgnoT )
						cpage++;
					if ( err < JET_errSuccess )
						goto Done;
					if ( CmpStKey( StNDKey( pfucb->ssib.line.pb ), &key ) != 0 )
						break;
					}
				}
			}
		}

Done:
	/*	common exit loop processing
	/**/
	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto HandleError;

	err = JET_errSuccess;
	*pcitem = citem;
	*pckey = ckey;
	*pcpage = cpage;

HandleError:
	DIRAPIReturn( pfucb, err );
	}


/************** DIR Transaction Routines ******************
/**********************************************************
/**/
ERR ErrDIRBeginTransaction( PIB *ppib )
	{
	ERR		err = JET_errSuccess;

	/*	log begin transaction.
	/**/
	err = ErrLGBeginTransaction( ppib, ppib->level );
	if ( err < 0 )
		{
		DIRAPIReturn( pfucbNil, err );
		}

	DIRAPIReturn( pfucbNil, ErrVERBeginTransaction( ppib ) );
	}


ERR ErrDIRCommitTransaction( PIB *ppib )
	{
	ERR		err;
	FUCB   	*pfucb;

	CheckPIB( ppib );
	Assert( ppib->level > 0 );

	VERPrecommitTransaction( ppib );

	/*	must write commit record and flush log prior to commiting any
	/*	version pages of transaction.  Synchronous flush performed
	/*	within log commit transaction.
	/**/
	err = ErrLGCommitTransaction( ppib, ppib->level - (BYTE)1 );
	Assert( err >= 0 || fLGNoMoreLogWrite );
	if ( err < 0 )
		{
		DIRAPIReturn( pfucbNil, err );
		}

	VERCommitTransaction( ppib );

	/*	set all open cursor transaction levels to new level
	/**/
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
		{
		if ( pfucb->levelOpen > ppib->level )
			pfucb->levelOpen = ppib->level;
		}

	/*	reset performed DDL operation flag on open cursors.  After commit to
	/*	level 0, DDL performed in transaction will not be rolled back.
	/*	Also, fully close cursors deferred closed.
	/**/
	if ( ppib->level == 0 )
		{
		DIRPurge( ppib );
		}

	DIRAPIReturn( pfucbNil, err );
	}


/*	closes deferred closed cursors not closed in commit to transaction
/*	level 0 via VERCommit.
/**/
VOID DIRPurge( PIB *ppib )
	{
	FUCB	*pfucb;
	FUCB	*pfucbNext;

	Assert( ppib->level == 0 );

	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucbNext )
		{
		pfucbNext = pfucb->pfucbNext;

		while ( FFCBDenyDDLByUs( pfucb->u.pfcb, ppib ) )
			{
			FCBResetDenyDDL( pfucb->u.pfcb );
			}
		if ( FFUCBDeferClosed( pfucb ) )
			{
			if ( FFUCBDenyRead( pfucb ) )
				FCBResetDenyRead( pfucb->u.pfcb );
			if ( FFUCBDenyWrite( pfucb ) )
				FCBResetDenyWrite( pfucb->u.pfcb );
			FCBUnlink( pfucb );
			FUCBClose( pfucb );
			}
		}

	return;
	}


ERR ErrDIRRollback( PIB *ppib )
	{
	ERR   	err;
	FUCB	*pfucb;
	INT   	levelAbortTo = (INT)ppib->level - 1;

	CheckPIB( ppib );
	/*	must be in a transaction to rollback
	/**/
	Assert( ppib->level > 0 );

	/*	clean up cursor CSR stacks
	/*	leave each cursor with at most one CSR, and reset fFUCBAll flag
	/**/
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
		{
		if ( PcsrCurrent( pfucb ) != pcsrNil )
			{
			while ( PcsrCurrent( pfucb )->pcsrPath != pcsrNil )
				{
				BTUp( pfucb );
				}
#undef BUG_FIX
#ifdef BUG_FIX
			DIRBeforeFirst( pfucb );
#endif
			}
#ifdef BUG_FIX
		/*	reset update separate LV and copy buffer status on rollback.
		/*	All long value resources will be freed as a result of
		/*	rollback and currency is reset to copy buffer status must
		/*	be reset.
		/**/
		FUCBResetUpdateSeparateLV( pfucb );
		FUCBResetCbstat( pfucb );
#endif
		}

	//	UNDONE:	rollback may fail from resource failure so
	//			we must retry in order to assure success
	/*	rollback changes made in transaction
	/**/
	CallS( ErrVERRollback( ppib ) );

	/*	log rollback. Must be called after VERRollback to record
	/*  the UNDO operations.  Do not handle error
	/**/
	err = ErrLGAbort( ppib, 1 );
	Assert( err == JET_errSuccess ||
			JET_errLogWriteFail ||			/* may be caused by disk full */
			err == JET_errDiskFull );

	if ( fRecovering )
		{
		/* we are done. No need to close fucb since they are faked and
		/* not the same behavior as regular fucb which could be deferred.
		/**/
		DIRAPIReturn( pfucbNil, JET_errSuccess );
		}

	/*	if rollback to level 0 then close deferred closed cursors
	/**/
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; )
		{
		FUCB    *pfucbT = pfucb->pfucbNext;

		if ( pfucb->levelOpen > ppib->level || ( ppib->level == 0 && FFUCBDeferClosed( pfucb ) ) )
			{
			if ( FFUCBDenyRead( pfucb ) )
				FCBResetDenyRead( pfucb->u.pfcb );
			if ( FFUCBDenyWrite( pfucb ) )
				FCBResetDenyWrite( pfucb->u.pfcb );
			FCBUnlink( pfucb );
			FUCBClose( pfucb );
			}

		pfucb = pfucbT;
		}

#ifdef BUG_FIX
#ifdef DEBUG
	/*	check all cursors in reset state
	/**/
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
		{
		if ( PcsrCurrent( pfucb ) != pcsrNil )
			{
			Assert( PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst );
			Assert( PcsrCurrent( pfucb )->pcsrPath == pcsrNil );
			}
		}
#endif
#endif

	DIRAPIReturn( pfucbNil, JET_errSuccess );
	}


#ifdef DEBUG


#define	cbKeyPrintMax		10
#define	cbDataPrintMax		10


VOID SPDump( FUCB *pfucb, INT cchIndent )
	{
	PGNO	pgno;
	CPG		cpg = 0;
	INT		ich;

	/*	print indentation
	/**/
	for ( ich = 0; ich < cchIndent; ich++ )
		{
		PrintF2( " " );
		}

	/*	print headings
	/**/
	if ( pfucb == pfucbNil )
		{
		PrintF2( "pgno      itag  bm        pgno last cpg\n");
		return;
		}

	Assert( pfucb->keyNode.cb == 3 );
	LFromThreeBytes( pgno, *pfucb->keyNode.pb );

	Assert( pfucb->lineData.cb == 3 );
	LFromThreeBytes( pgno, *pfucb->lineData.pb );

	/*	print	node	pgno:itag
	/*					bookmark
	/*					pgno last
	/*					cpg
	/**/

	/*	print fixed lenght values
	/**/
	PrintF2( "%.8x  %.2x    %.8x  %.8x  %.8x",
		PcsrCurrent( pfucb )->pgno,
		PcsrCurrent( pfucb )->itag,
		PcsrCurrent( pfucb )->bm,
		pgno,
		cpg );

	/*	terminate line
	/**/
	PrintF2( "\n" );

	return;
	}


VOID LVDump( FUCB *pfucb, INT cchIndent )
	{
	ULONG		ulId = 0;
	LVROOT		lvroot;
	INT			ich;

	/*	print indentation
	/**/
	for ( ich = 0; ich < cchIndent; ich++ )
		{
		PrintF2( " " );
		}

	/*	print headings
	/**/
	if ( pfucb == pfucbNil )
		{
		PrintF2( "****************** LONG VALUES ***********************\n" );
		PrintF2( "pgno      itag  bm        long id   lenght    reference count\n");
		return;
		}

	Assert( pfucb->keyNode.cb == sizeof(ulId) );
	//	UNDONE:	set long id from key

	Assert( pfucb->lineData.cb == sizeof(lvroot) );
	memcpy( &lvroot, pfucb->lineData.pb, sizeof(lvroot) );

	/*	print	node	pgno:itag
	/*					bookmark
	/*					long id
	/*					length
	/*					reference count
	/**/

	/*	print fixed lenght values
	/**/
	PrintF2( "%.8x  %.2x      %.8x  %.8x  %.8  %.8  ",
		PcsrCurrent( pfucb )->pgno,
		PcsrCurrent( pfucb )->itag,
		PcsrCurrent( pfucb )->bm,
		ulId,
		lvroot.ulSize,
		lvroot.ulReference );

	/*	terminate line
	/**/
	PrintF2( "\n" );

	return;
	}

BYTE mpbb[] = {	'0', '1', '2', '3', '4', '5', '6', '7',
				'8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

//BOOL fPrintFullKeys = fTrue;
BOOL fPrintFullKeys = fFalse;
BYTE rgbKeyLastGlobal[ JET_cbKeyMost + 1 ];
BYTE *pbKeyLastGlobal = rgbKeyLastGlobal;
INT cbKeyLastGlobal = 0;

VOID NDDump( FUCB *pfucb, INT cchIndent )
	{
	INT		cbT;
	INT		ibT;
	BYTE	szKey[JET_cbKeyMost * 3];
	BYTE	rgbData[cbDataPrintMax + 1];
	INT		ich;

	/*	print indentation
	/**/
	for ( ich = 0; ich < cchIndent; ich++ )
		{
		PrintF2( " " );
		}

	/*	print headings
	/**/
	if ( pfucb == pfucbNil )
		{
		PrintF2( "pgno      itag  bm        header    key         data\n");
		return;
		}

	szKey[cbKeyPrintMax] = '\0';
	memset( szKey, ' ', cbKeyPrintMax );
	cbT = pfucb->keyNode.cb;
	if ( cbT > cbKeyPrintMax )
		cbT = cbKeyPrintMax;
	memcpy( szKey, pfucb->keyNode.pb, cbT );

	for ( ibT = 0; ibT < cbKeyPrintMax && ibT < (INT)pfucb->keyNode.cb; ibT++ )
		{
		if ( !( ( szKey[ibT] >= 'a' && szKey[ibT] <= 'z' ) ||
			( szKey[ibT] >= 'A' && szKey[ibT] <= 'Z' ) ) )
			{
			szKey[ibT] = '.';
			}
		}

	if ( fPrintFullKeys )
		{
		INT cbKey = (INT) pfucb->keyNode.cb;
		BYTE *pbKey = pfucb->keyNode.pb;
		BYTE *pbKeyMax = pbKey + pfucb->keyNode.cb;
		BYTE *pbPrint = szKey;

		if ( cbKeyLastGlobal == cbKey &&
			 memcmp( pbKeyLastGlobal, pbKey, cbKeyLastGlobal ) == 0 )
			*pbPrint++ = '*';
		else
			{
			*pbPrint++ = ' ';
			cbKeyLastGlobal = cbKey;
			memcpy( pbKeyLastGlobal, pbKey, cbKeyLastGlobal );
			}

		while ( pbKey < pbKeyMax )
			{
			BYTE b = *pbKey++;
			*pbPrint++ = mpbb[b >> 4];
			*pbPrint++ = mpbb[b & 0x0f];
			*pbPrint++ = ' ';
			}
		*pbPrint='\0';
		}

	rgbData[cbKeyPrintMax] = '\0';
	memset( rgbData, ' ', cbDataPrintMax );
	cbT = pfucb->lineData.cb;
	if ( cbT > cbDataPrintMax )
		cbT = cbDataPrintMax;
	memcpy( rgbData, pfucb->lineData.pb, cbT );
	for ( ibT = 0; ibT < cbDataPrintMax && ibT < (INT)pfucb->lineData.cb; ibT++ )
		{
		if ( !( ( rgbData[ibT] >= 'a' && rgbData[ibT] <= 'z' ) ||
			( rgbData[ibT] >= 'A' && rgbData[ibT] <= 'Z' ) ) )
			{
			rgbData[ibT] = '.';
			}
		}

	/*	print	node	pgno:itag
	/*					bookmark
	/*					header
	/*					key to 10 bytes
	/*					data to 10 bytes
	/**/

	/*	print fixed lenght values
	/**/
	PrintF2( "%.8x  %.2x    %.8x  %.2x        ",
		PcsrCurrent( pfucb )->pgno,
		PcsrCurrent( pfucb )->itag,
		PcsrCurrent( pfucb )->bm,
		*pfucb->ssib.line.pb );

	/*	print variable lenght values
	/**/
	PrintF2( "%s  %s", szKey, rgbData );

	/*	terminate line
	/**/
	PrintF2( "\n" );

	return;
	}


/*	prints tree nodes, indented by depth, in depth first fashion
/**/
ERR ErrDIRDump( FUCB *pfucb, INT cchIndent )
	{
	ERR	err = JET_errSuccess;
	DIB	dib;
	BYTE *pbKeyLastCurLevel;
	INT cbKeyLastCurLevel;

#define	cchPerDepth		5

	Call( ErrDIRGet( pfucb ) );
	/*	if parent is space node, then dump space
	/*	if parent is LONG, then dump long value root
	/*	otherwise dump node
	/**/
	if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
		( ItagOfSrid( pfucb->sridFather ) == itagOWNEXT ||
		ItagOfSrid( pfucb->sridFather ) == itagAVAILEXT ) )
		{
		if ( cchIndent == 0 )
			SPDump( pfucbNil, cchIndent );
		SPDump( pfucb, cchIndent );
		}
	else if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
		ItagOfSrid( pfucb->sridFather ) == itagLONG )
		{
		if ( cchIndent == 0 )
			LVDump( pfucbNil, cchIndent );
		LVDump( pfucb, cchIndent );
		}
	else
		{
		if ( cchIndent == 0 )
			NDDump( pfucbNil, cchIndent );
		NDDump( pfucb, cchIndent );
		}

	pbKeyLastCurLevel = pbKeyLastGlobal;
	cbKeyLastCurLevel = cbKeyLastGlobal;

	dib.fFlags = 0;
	dib.pos = posFirst;
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errRecordNotFound )
		{
		if (!(pbKeyLastGlobal = SAlloc( sizeof( rgbKeyLastGlobal ) )))
			Error( JET_errOutOfMemory, HandleError );
		cbKeyLastGlobal = 0;

		if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
			( ItagOfSrid( pfucb->sridFather ) == itagOWNEXT ||
			ItagOfSrid( pfucb->sridFather ) == itagAVAILEXT ) )
			{
			SPDump( pfucbNil, cchIndent + cchPerDepth );
			}
		else if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
			ItagOfSrid( pfucb->sridFather ) == itagLONG )
			{
			LVDump( pfucbNil, cchIndent + cchPerDepth );
			}
		else
			{
			NDDump( pfucbNil, cchIndent + cchPerDepth );
			}

		SFree( pbKeyLastGlobal );
		pbKeyLastGlobal = pbKeyLastCurLevel;
		cbKeyLastGlobal = cbKeyLastCurLevel;

		forever
			{
			if (!(pbKeyLastGlobal = SAlloc( sizeof( rgbKeyLastGlobal ))))
				Error( JET_errOutOfMemory, HandleError );
			cbKeyLastGlobal = 0;

			Call( ErrDIRDump( pfucb, cchIndent + cchPerDepth ) );

			SFree( pbKeyLastGlobal );
			pbKeyLastGlobal = pbKeyLastCurLevel;
			cbKeyLastGlobal = cbKeyLastCurLevel;

			err = ErrDIRNext( pfucb, &dib );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					{
					break;
					}
				goto HandleError;
				}
			}

		if ( err == JET_errNoCurrentRecord )
			err = JET_errSuccess;

		DIRIUp( pfucb, 1 );
		}

	if ( err == JET_errRecordNotFound )
		err = JET_errSuccess;
HandleError:
	DIRAPIReturn( pfucbNil, err );
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\fileopen.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>
#include <stddef.h>

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fmp.h"
#include "fucb.h"
#include "fdb.h"
#include "fcb.h"
#include "stapi.h"
#include "idb.h"
#include "spaceapi.h"
#include "fileapi.h"
#include "fileint.h"
#include "util.h"
#include "dirapi.h"
#include "sortapi.h"
#include "systab.h"
#include "recapi.h"
#include "recint.h"
#include "dbapi.h"

DeclAssertFile;						/* Declare file name for assert macros */

extern SIG	sigDoneFCB;

//
// Internal routines
//
	ERR VTAPI
ErrIsamDupCursor( PIB *ppib, FUCB *pfucbOpen, FUCB **ppfucb, ULONG grbit )
	{
	ERR		err;
	FUCB 	*pfucb;
	CSR		*pcsr;
#ifdef	DISPATCHING
	JET_TABLEID	tableid;
#endif	/* DISPATCHING */

	CheckPIB( ppib );
	CheckTable( ppib, pfucbOpen );

	/*	silence warnings
	/**/
	grbit = grbit;

#ifdef	DISPATCHING

	/*	Allocate a dispatchable tableid
	/**/
	CallR( ErrAllocateTableid( &tableid, (JET_VTID) 0, &vtfndefIsam ) );
#endif	/* DISPATCHING */

	/*	allocate fucb
	/**/
	Call( ErrDIROpen( ppib, pfucbOpen->u.pfcb, 0, &pfucb ) );

	/*	reset copy buffer
	/**/
	pfucb->pbfWorkBuf = pbfNil;
	pfucb->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdateSeparateLV( pfucb ) );
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	/*	reset key buffer
	/**/
	pfucb->pbKey = NULL;
	KSReset( pfucb );

	/*	copy cursor flags
	/**/
	pfucb->wFlags |= fFUCBIndex;
	if ( FFUCBUpdatable( pfucbOpen ) )
		FUCBSetUpdatable( pfucb );
	else
		FUCBResetUpdatable( pfucb );

	/*	set currency before first node
	/**/
	pcsr = PcsrCurrent( pfucb );
	Assert( pcsr != pcsrNil );
	pcsr->csrstat = csrstatBeforeFirst;

	/*	move currency to the first record and ignore error if no records
	/**/
	err = ErrIsamMove( ppib, pfucb, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

#ifdef	DISPATCHING
	/* Inform dispatcher of correct JET_VTID */
	CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucb ) );
	pfucb->fVtid = fTrue;
	*(JET_TABLEID *) ppfucb = tableid;
#else	/* !DISPATCHING */
	*ppfucb = pfucb;
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
#ifdef	DISPATCHING
	ReleaseTableid(tableid );
#endif	/* DISPATCHING */
	return err;
	}




	ERR VTAPI
ErrIsamOpenTable(
	PIB	*ppib,		// IN	PIB of who is opening file
	ULONG	vdbid,		// IN	database id
	FUCB	**ppfucb,	// OUT receives a new FUCB open on the file
	CHAR	*szPath,		// IN	path name of file to open
	ULONG	grbit )		// IN	lock exclusively?
	{
	ERR	err;
	DBID	dbid = DbidOfVDbid( ULongToPtr(vdbid) );
	FUCB	*pfucb = pfucbNil;
#ifdef	DISPATCHING
	JET_TABLEID  tableid;

	/*	Allocate a dispatchable tableid
	/**/
	CallR( ErrAllocateTableid( &tableid, (JET_VTID) 0, &vtfndefIsam ) );
#endif	/* DISPATCHING */

#ifdef PERISCOPE
	printf( "IsamOpenTBL( ppib=%lp, dbid= %lu, ppfucb=%lp, TBL=%s, grbit=%lu)\n",
		ppib, uldbid, ppfucb, szPath, grbit );
#endif

	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szPath, grbit ) );

	/* if database was opened read-only, so should the cursor */
	/**/
	if ( FVDbidReadOnly( ULongToPtr(vdbid) ) )
		FUCBResetUpdatable( pfucb );
	else
		FUCBSetUpdatable( pfucb );

#ifdef	DISPATCHING
	/* Inform dispatcher of correct JET_VTID */
	CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucb ) );
	pfucb->fVtid = fTrue;
	*(JET_TABLEID *) ppfucb = tableid;
#else	/* !DISPATCHING */
	*ppfucb = pfucb;
#endif	/* !DISPATCHING */

#ifdef PERISCOPE
	puts("\tIsamOpenTBL returns JET_errSuccess" );
#endif

	return JET_errSuccess;

HandleError:
#ifdef	DISPATCHING
	ReleaseTableid( tableid );
#endif	/* DISPATCHING */

#ifdef	SYSTABLES
	if ( err == JET_errObjectNotFound )
		{
		ERR			err;
		OBJID		objid;
		JET_OBJTYP	objtyp;

		err = ErrFindObjidFromIdName( ppib, dbid, objidTblContainer, szPath, &objid, &objtyp );

		if ( err >= 0 )
			{
			if ( objtyp == JET_objtypQuery )
				return JET_errQueryNotSupported;
			if ( objtyp == JET_objtypLink )
				return JET_errLinkNotSupported;
			if ( objtyp == JET_objtypSQLLink )
				return JET_errSQLLinkNotSupported;
			}
		else
			return err;
		}

#endif	/* SYSTABLES */

	return err;
	}




//+API
// ErrFILEOpenTable
// ========================================================================
// ErrFILEOpenTable( ppib, dbid, ppfucb, szName, grbit )
//		PIB *ppib;			// IN	 PIB of who is opening file
//		DBID dbid;			// IN	 database id
//		FUCB **ppfucb;		// OUT	 receives a new FUCB open on the file
//		CHAR *szName;		// IN	 path name of file to open
//		ULONG grbit;		// IN	 lock exclusively?
// Opens a data file, returning a new
// FUCB on the file.
//
// PARAMETERS
//				ppib			PIB of who is opening file
//				dbid			database id
//				ppfucb		receives a new FUCB open on the file
//								( should NOT already be pointing to an FUCB )
//				szName		path name of file to open ( the node
//								corresponding to this path must be an FDP )
//				grbit		 	flags:
//									JET_bitTableDenyRead	open table in exclusive mode;
//									default is share mode
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess					Everything worked.
//					-TableInvalidName					The path given does not
//															specify a file.
//					-JET_errDatabaseCorrupted		The database directory tree
//															is corrupted.
//					-Various out-of-memory error codes.
//				In the event of a fatal ( negative ) error, a new FUCB
//				will not be returned.
// SIDE EFFECTS FCBs for the file and each of its secondary indexes are
//				created ( if not already in the global list ).  The file's
//				FCB is inserted into the global FCB list.  One or more
//				unused FCBs may have had to be reclaimed.
//				The currency of the new FUCB is set to "before the first item".
// SEE ALSO		CloseTable
//-
ERR ErrFILEOpenTable( PIB *ppib, DBID dbid, FUCB **ppfucb, const CHAR *szName, ULONG grbit )
	{
	ERR		err;
	CHAR  	szTable[JET_cbFullNameMost + 1];
	BYTE  	rgbTableNorm[ JET_cbKeyMost ];
	CHAR  	szFileName[JET_cbFullNameMost + 1];
	KEY		rgkey[2];
	FCB		*pfcb;
	CSR		*pcsr;
	BOOL  	fReUsing = fTrue;

	CheckPIB( ppib );
	CheckDBID( ppib, dbid );
	CallR( ErrCheckName( szTable, szName, (JET_cbNameMost + 1 ) ) );

	Assert( ppib != ppibNil );
	Assert( ppfucb != NULL );

	/*	make seek path from table name.
	/**/
	rgkey[0] = *pkeyTables;

	/*	normalize table name and set key
	/**/
	SysNormText( szTable, strlen( szTable ), rgbTableNorm, sizeof( rgbTableNorm ), &rgkey[1].cb );
	rgkey[1].pb = rgbTableNorm;

	/*	open database cursor
	/**/
	CallR( ErrDIROpen( ppib, pfcbNil, dbid, ppfucb ) );

	/*	request table open mutex
	/**/
	SgSemRequest( semGlobalFCBList );

	/*	search for table
	/**/
	err = ErrDIRSeekPath( *ppfucb, 2, rgkey, fDIRPurgeParent );
	switch ( err )
		{
		case errDIRFDP: break;
		case JET_errSuccess:	Error( JET_errInvalidName, ReleaseFUCB )
		case JET_errRecordNotFound: Error( JET_errObjectNotFound, ReleaseFUCB )
		default: goto ReleaseFUCB;
		}
	Assert( *ppfucb != pfucbNil );
	Assert( ( *ppfucb )->lineData.cb > 2*sizeof(WORD)+2*sizeof( JET_DATESERIAL));
	memcpy( szFileName, ( *ppfucb )->lineData.pb+2*sizeof(WORD)+2*sizeof(JET_DATESERIAL),
		( *ppfucb )->lineData.cb-2*sizeof(WORD)-2*sizeof(JET_DATESERIAL) );
	szFileName[( *ppfucb )->lineData.cb-2*sizeof(WORD)-2*sizeof(JET_DATESERIAL)] = '\0';

	/*	reset copy buffer
	/**/
	(*ppfucb)->pbfWorkBuf = pbfNil;
	(*ppfucb)->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdateSeparateLV( *ppfucb ) );
	Assert( !FFUCBUpdatePrepared( *ppfucb ) );

	/*	reset key buffer
	/**/
	(*ppfucb)->pbKey = NULL;
	KSReset( ( *ppfucb ) );

	/*	search global list by FDP pgno
	/**/
	Assert( ppib->level < levelMax );
	pcsr = PcsrCurrent( *ppfucb );
	Assert( pcsr != pcsrNil );
	pfcb = PfcbFCBGet( dbid, pcsr->pgno );

	/*	FCB not in global list?
	/**/
	if ( pfcb == pfcbNil )
		{
		FCB	*pfcbT;

		/*	have to build it from directory tree info
		/**/
		fReUsing = fFalse;
		SgSemRelease( semGlobalFCBList );		 // this may take a while...
		CallJ( ErrFILEIGenerateFCB( *ppfucb, &pfcb ), ReleaseFUCB )
		Assert( pfcb != pfcbNil );
		SgSemRequest( semGlobalFCBList );

		/*** Must search global list again:	 while I was out reading ***/
		/*** the tree, some other joker just might have been opening ***/
		/*** the same file and may have actually beat me to it. ***/
		pfcbT = PfcbFCBGet( dbid, pcsr->pgno );

		/*** Link into global list ( even if duplicate ) ***/
		Assert( pfcbGlobalList != pfcb );
		pfcb->pfcbNext = pfcbGlobalList;
		pfcbGlobalList = pfcb;

		/*** This is somewhat of a hack:  if the FCB was put in the ***/
		/*** list while I was building my copy, I should throw mine ***/
		/*** away.	The easiest way to do this is just to make the FCB's ***/
		/*** pgnoFDP a bogus value;	 it will sit in the global list with ***/
		/*** zero refcount, and somebody will eventually reclaim it. ***/
		if ( pfcbT != pfcbNil )
			{
			fReUsing = fTrue;
			pfcb->pgnoFDP = pgnoNull;
			pfcb->szFileName = NULL;
			pfcb = pfcbT;
			}
		else
			{
			/*	insert fcb in hash
			/**/
			Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcbNil );
			FCBRegister( pfcb );
			}
		}

	//	UNDONE: move this into fcb.c
	/*	wait on bookmark clean up if necessary
	/**/
	while ( FFCBWait( pfcb ) )
		{
		LgLeaveCriticalSection( critJet );
		SignalWait( &sigDoneFCB, -1 );
		LgEnterCriticalSection( critJet );
		}

	/*	set table usage mode.
	/**/
	CallJ( ErrFCBSetMode( ppib, pfcb, grbit ), ReleaseFUCB );

	/*	close database cursor and open table cursor
	/**/
	DIRClose( *ppfucb );
	CallJ( ErrDIROpen( ppib, pfcb, 0, ppfucb ), SimpleError );
	FUCBSetIndex( *ppfucb );

	/*	this code must coincide with call to ErrFCBSetMode above.
	/**/
	if ( grbit & JET_bitTableDenyRead )
		FUCBSetDenyRead( *ppfucb );
	if ( grbit & JET_bitTableDenyWrite )
		FUCBSetDenyWrite( *ppfucb );

	/*	reset copy buffer
	/**/
	( *ppfucb )->pbfWorkBuf = pbfNil;
	( *ppfucb )->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdateSeparateLV( *ppfucb ) );
	Assert( !FFUCBUpdatePrepared( *ppfucb ) );

	/*	reset key buffer
	/**/
	( *ppfucb )->pbKey = NULL;
	KSReset( ( *ppfucb ) );

	/*	store the file name now
	/**/
	if ( !fReUsing )
		{
		if ( ( pfcb->szFileName = SAlloc( strlen( szFileName ) + 1 ) ) == NULL )
			{
			err = JET_errOutOfMemory;
			goto ReleaseFUCB;
			}
		strcpy( pfcb->szFileName, szFileName );
		}

	/*	set currency before first node
	/**/
	pcsr = PcsrCurrent( *ppfucb );
	Assert( pcsr != pcsrNil );
	pcsr->csrstat = csrstatBeforeFirst;

	/*	move currency to the first record and ignore error if no records
	/**/
	err = ErrIsamMove( ppib, *ppfucb, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto ReleaseFUCB;
		err = JET_errSuccess;
		}

	/*	release crit section
	/**/
	SgSemRelease( semGlobalFCBList );
	return JET_errSuccess;

ReleaseFUCB:
	DIRClose( *ppfucb );
SimpleError:
	*ppfucb = pfucbNil;
	/*	release crit section
	/**/
	SgSemRelease( semGlobalFCBList );
	return err;
	}




ERR VTAPI ErrIsamCloseTable( PIB *ppib, FUCB *pfucb )
	{
	ERR		err;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );

#ifdef	DISPATCHING
	Assert( pfucb->fVtid );
#ifdef	SYSTABLES
	if ( FFUCBSystemTable( pfucb ) )
		ReleaseTableid( TableidFromVtid( (JET_VTID ) pfucb, &vtfndefIsamInfo ) );
	else
#endif	/* SYSTABLES */
		ReleaseTableid( TableidFromVtid( (JET_VTID ) pfucb, &vtfndefIsam ) );
	pfucb->fVtid = fFalse;
#endif	/* DISPATCHING */

	err = ErrFILECloseTable( ppib, pfucb );
	return( err );
	}




//+API
// ErrFILECloseTable
// ========================================================================
// ErrFILECloseTable( PIB *ppib, FUCB *pfucb )
//
// Closes the FUCB of a data file, previously opened using FILEOpen.
// Also closes the current secondary index, if any.
//
// PARAMETERS	ppib	PIB of this user
//				pfucb	FUCB of file to close
//
// RETURNS		JET_errSuccess
//				or lower level errors
//
// SEE ALSO		OpenTable
//-
ERR ErrFILECloseTable( PIB *ppib, FUCB *pfucb )
	{
	ERR		err;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	Assert( pfucb->fVtid == fFalse );

	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}
	Assert( !FFUCBUpdateSeparateLV( pfucb ) );
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	/*	release working buffer
	/**/
	if ( pfucb->pbfWorkBuf != pbfNil )
		{
		BFSFree( pfucb->pbfWorkBuf );
		pfucb->pbfWorkBuf = pbfNil;
		pfucb->lineWorkBuf.pb = NULL;
		}

	if ( pfucb->pbKey != NULL )
		{
		LFree( pfucb->pbKey );
		pfucb->pbKey = NULL;
		}

	/*	detach, close and free index FUCB, if any
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		DIRClose( pfucb->pfucbCurIndex );
		pfucb->pfucbCurIndex = pfucbNil;
		}

	/*	if closing a temporary table, free resources if
	/*	last one to close
	/**/
	if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
		{
		FCB		*pfcb = pfucb->u.pfcb;
		DBID		dbid = pfucb->dbid;
		BYTE		szFileName[JET_cbNameMost+2];

		strncpy( szFileName, ( pfucb->u.pfcb )->szFileName, JET_cbNameMost+1 );
        szFileName[JET_cbNameMost+1] = 0;
		DIRClose( pfucb );
		if ( pfcb->wRefCnt )
			return JET_errSuccess;

		err = ErrFILEDeleteTable( ppib, dbid, szFileName );
		return err;
		}

	/*	undo X lock applied at OPEN time
	/**/
//	if ( FFUCBDenyRead( pfucb ) )
//		{
//		SgSemRequest( semGlobalFCBList );
//		FCBResetDenyRead( pfucb->u.pfcb );
//		SgSemRelease( semGlobalFCBList );
//		}

	FUCBResetGetBookmark( pfucb );
	DIRClose( pfucb );
	return JET_errSuccess;
	}


//+INTERNAL
// ErrFILEIGenerateFCB
// ========================================================================
// ErrFILEIGenerateFCB( FUCB *pfucb, FCB **ppfcb )
//
// Allocates FCBs for a data file and its indexes, and fills them in
// from the database directory tree.
//
// PARAMETERS
//					pfucb		FUCB opened on the FDP to be built from
//					ppfcb		receives the built FCB for this file
//
// RETURNS		lower level errors, or one of:
//					JET_errSuccess						
//					JET_errTooManyOpenTables			could not allocate enough FCBs.
//
//	On fatal (negative) error, any FCBs which were allocated
//	are returned to the free pool.
//
// SIDE EFFECTS	Global FCB list may be reaped for unused FCBs
// SEE ALSO			OpenTable
//-
ERR ErrFILEIGenerateFCB( FUCB *pfucb, FCB **ppfcb )
	{
	ERR		err;								// error code of various utility
	INT		cFCBNeed;						// # of FCBs that have to be allocated
	FCB		*pfcbAllFCBs = pfcbNil;		// list of pre-allocated FCBs
	FCB		*pfcb;							// FCB pointer of various utility
	ULONG		ulFileDensity;					// loading density of file

	Assert( ppfcb != NULL );
	Assert( pfucb != pfucbNil );

	/*	allocate all the FCBs at once, chaining by pfcbNextIndex
	/*	first word of file node's data is number of secondary indexes
	/*	second word is file's loading density
	/**/
	Assert( pfucb->lineData.pb != NULL );
	Assert( pfucb->lineData.cb > 2*sizeof(WORD) );
	cFCBNeed = *(UNALIGNED WORD *)pfucb->lineData.pb + 1;
	ulFileDensity = ( (UNALIGNED WORD *)pfucb->lineData.pb )[1];
	while ( cFCBNeed > 0 )
		{
		CallJ( ErrFCBAlloc( pfucb->ppib, &pfcb ), ReleaseAllFCBs );
		pfcb->pfcbNextIndex = pfcbAllFCBs;
		pfcbAllFCBs = pfcb;
		cFCBNeed--;
		}

	/*	got all the FCBs:	now fill them in from the tree
	/**/
	pfcb->cbDensityFree = ( ( 100 - ulFileDensity ) * cbPage ) / 100;
	CallJ( ErrFILEIFillInFCB( pfucb, pfcbAllFCBs ), ReleaseAllFCBs )

	/*	combine index column masks into a single mask
	/*	for fast record replace.
	/**/
	FILESetAllIndexMask( pfcbAllFCBs );

	*ppfcb = pfcbAllFCBs;
	return JET_errSuccess;

	/*	error handling
	/**/
ReleaseAllFCBs:
	while ( pfcbAllFCBs != pfcbNil )
		{
		pfcb = pfcbAllFCBs;
		pfcbAllFCBs = pfcbAllFCBs->pfcbNextIndex;
		Assert( pfcb->cVersion == 0 );
		MEMReleasePfcb( pfcb );
		}
	return err;
	}


//+INTERNAL
// ErrFILEIFillInFCB
// ========================================================================
// ErrFILEIFillInFCB( pfucb, pfcb )
//		FUCB *pfucb;	// IN	   FUCB opened on the FDP to build from
//		FCB *pfcb;		// INOUT   empty FCB and index FCBs to fill in
// Walks the database directory tree, filling in the pre-allocated FCBs
// for the data file and indexes.
//
// PARAMETERS	pfucb		FUCB opened on the FDP to build from
//					pfcb		must point to an allocated FCB, with FCBs
//								chained on the pfcbNextIndex field, one
//								for each secondary index of the file.
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess					Everything worked.
//					-JET_errOutOfMemory				Could not allocate misc. memory
//					-JET_errDatabaseCorrupted		The database directory tree
//															is corrupted.
//				On fatal ( negative ) errors, any memory resources which
//				were allocated are freed.
// SEE ALSO		OpenTable
//-
ERR ErrFILEIFillInFCB( FUCB *pfucb, FCB *pfcb )
	{
	ERR err;
	DIB dib;				// needed for DIR calls

	Assert( pfcb != pfcbNil );
	Assert( pfucb != pfucbNil );
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode );
	/*** Fill in FDP page number ***/
	pfcb->pgnoFDP = PcsrCurrent( pfucb )->pgno;

	/*** Assume sequential: IDB is NULL ***/
	pfcb->pidb = pidbNil;

	/*	reference count
	/**/
	pfcb->wRefCnt = 0;
	pfcb->wFlags = fFCBClusteredIndex;
	pfcb->dbid = pfucb->dbid;	// dbid should have been set at this point

	/*** Down to \files\some_file\fields ***/
	dib.pos = posDown;
	dib.pkey = (KEY *)pkeyFields;
	dib.fFlags = fDIRNull;
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
		Error( err, SimpleError );
		}

	/*	construct field definition block
	/**/
	CallJ( ErrFDBConstruct( pfucb, pfcb, fTrue ), SimpleError )

	/*	up to \files\some_file
	/**/
	DIRUp( pfucb, 1 );

	/*	down to \files\some_file\olcstats
	/**/
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyOLCStats;
	Assert( dib.fFlags == fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	if ( err >= JET_errSuccess )
		{
		if ( err != JET_errSuccess )
			{
			FCBResetOLCStatsAvail( pfcb );
			}
		else
			{
			FCBSetOLCStatsAvail( pfcb );
			CallJ( ErrDIRGet( pfucb ), FreeFDB );
			Assert( pfucb->lineData.cb == sizeof( PERS_OLCSTAT ) );
			memcpy( (BYTE *) &pfcb->olcStat, pfucb->lineData.pb, sizeof( PERS_OLCSTAT ) );
			}
		/*	up to \files\some_file
		/**/
		DIRUp( pfucb, 1 );
		}

	/*	down to \files\some_file\indexes
	/**/
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyIndexes;
	Assert( dib.fFlags == fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
		Error( err, FreeFDB );
		}

	/*	build index definitions
	/**/
	CallJ( ErrFILEIBuildIndexDefs( pfucb, pfcb ), FreeFDB )

	/*	up to \files\some_file
	/**/
	DIRUp( pfucb, 1 );

	/*	set long field id max
	/**/
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyLong;
	Assert( dib.fFlags == fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errSuccess )
		goto FreeIndexes;

	/*  if err == JET_errSuccess  */

	dib.pos = posLast;
	dib.fFlags = fDIRNull;
	err = ErrDIRDown( pfucb, &dib );
	Assert( err != JET_errNoCurrentRecord );
	if ( err == JET_errSuccess )
		{
		BYTE *pb = pfucb->keyNode.pb;
		/*	remember to add 1 to make this then next long value
		/*	to add.
		/**/
		pfcb->ulLongIdMax =
			( pb[0] << 24 ) +
			( pb[1] << 16 ) +
			( pb[2] <<  8 ) +
			pb[3] + 1;
		DIRUp( pfucb, 1 );
		}
	else if ( err == JET_errRecordNotFound )
		pfcb->ulLongIdMax = 0;
	else
		goto FreeIndexes;

	/*	up to \files\some_file
	/**/
	DIRUp( pfucb, 1 );

	return JET_errSuccess;

	/*	error handling
	/**/
FreeIndexes:					// free all index FCB storage
	{
	FCB *pfcbT;					// FCB pointer of various utility

	for ( pfcbT = pfcb->pfcbNextIndex; pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		RECFreeIDB( pfcbT->pidb );
		}
	}

	if ( pfcb->pidb != pidbNil )
		RECFreeIDB( pfcb->pidb );
FreeFDB:						// free file FCB's FDB block
	FDBDestruct( (FDB *)pfcb->pfdb );
SimpleError:
	return err;
	}


//+INTERNAL
//	ErrFDBConstruct
//	========================================================================
//	ErrFDBConstruct( FUCB *pfucb, FCB *pfcb, BOOL fBuildDefault )
//
//	Constructs a table FDB from the field descriptions in the tree.
//	Currency must be on FIELDS node. On error, this routine will not affect pfcb.
//
//	PARAMETERS	pfucb				FUCB open on ...\<file>\fields
//	   			pfcb				FCB containing FDB to build
//	   			fBuildDefault		Build default record?
//
//	RETURNS
//				JET_errSuccess
//				negative failing error code
//-
ERR ErrFDBConstruct( FUCB *pfucb, FCB *pfcb, BOOL fConstructDefaultRecord )
	{
	ERR						err;				// error code of various utility
	UNALIGNED FIELDDATA		*pfd;				// data found at the "fields" node
	FIELDDEFDATA	 		*pfdd;				// data found at each field descriptor node
	DIB				 		dib;				// needed for DIR calls
	FDB				 		*pfdbNew;
	FDB				 		*pfdbSav;
	FDB				 		*pfdbOld;
	WORD			 		wFlagsSav;
	RECHDR			 		*prechdr;
	BYTE			 		*pb;
	FIELD			 		field;

	Assert( pfucb != pfucbNil );
	Assert( pfcb != pfcbNil );
	Assert( pfucb->lineData.pb != NULL );
	Assert( pfucb->lineData.cb == sizeof(FIELDDATA) );

	/*	allocate FDB
	/**/
	pfd = (FIELDDATA *)pfucb->lineData.pb;
	CallR( ErrRECNewFDB(
		&pfdbNew,
		pfd->fidFixedLast,
		pfd->fidVarLast,
		pfd->fidTaggedLast) );

	/*	scan all sons of fields, filling in FDB
	/**/
	dib.pos = posFirst;
	dib.fFlags = fDIRNull;

	pfdbNew->fidVersion = 0;
	pfdbNew->fidAutoInc = 0;

	err = ErrDIRDown( pfucb, &dib );
	if ( err < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( err != JET_errRecordNotFound )
			goto HandleError;
		}
	else
		{
		/*	since move first err must be JET_errSuccess
		/**/
		Assert( err == JET_errSuccess );

		forever
			{
			Assert( pfucb->lineData.pb != NULL );
			Assert( pfucb->lineData.cb >= sizeof(FIELDDEFDATA) - 1 );
			pfdd = (FIELDDEFDATA *)pfucb->lineData.pb;
			Assert( !FKeyNull( &pfucb->keyNode ) );
			Assert( pfucb->keyNode.cb <= JET_cbKeyMost );
			Assert( pfdd->bColtyp >= JET_coltypNil && pfdd->bColtyp < JET_coltypMax );
			field.coltyp = (JET_COLTYP)pfdd->bColtyp;
			if ( field.coltyp == JET_coltypText || field.coltyp == JET_coltypLongText )
				{
				field.langid = pfdd->langid;
				field.cp		 = pfdd->cp;
				field.wCountry = pfdd->wCountry;
				}
			field.cbMaxLen = pfdd->ulLength;
			field.ffield = pfdd->bFlags;
			Assert( strlen( pfdd->szFieldName ) <= JET_cbNameMost );
			strcpy( field.szFieldName, pfdd->szFieldName );

			Call( ErrRECAddFieldDef( pfdbNew, pfdd->fid, &field ) );

			/*	fixed fields which have been deleted are not usable
			/**/
			if ( field.ffield & ffieldDeleted )
				{
				pfdbNew->pfieldFixed[pfdd->fid-fidFixedLeast].coltyp = JET_coltypNil;
				}

			/*	set version and auto increment field ids
			/**/
			if ( field.ffield & ffieldVersion )
				pfdbNew->fidVersion = pfdd->fid;
			if ( field.ffield & ffieldAutoInc )
				pfdbNew->fidAutoInc = pfdd->fid;

			err = ErrDIRNext( pfucb, &dib );
			if ( err < 0 )
				{
				/* go back up to files\some_file\fields
				/**/
				DIRUp( pfucb, 1 );
				if ( err == JET_errNoCurrentRecord )
					break;
				goto HandleError;
				}
			}
		}

	/*	set FCB pfdb to new FDB, saving old for RestoreFUCB
	/**/
	pfdbOld = (FDB *)pfcb->pfdb;
	(FDB *)pfcb->pfdb = pfdbNew;

	if ( !fConstructDefaultRecord )
		return JET_errSuccess;

	/*	make default record
	/*	prepare for set
	/**/
	if ( pfucb->pbfWorkBuf == pbfNil )
		{
		Call( ErrBFAllocTempBuffer( &pfucb->pbfWorkBuf ) )
		pfucb->lineWorkBuf.pb = (BYTE *)pfucb->pbfWorkBuf->ppage;
		}
	PrepareInsert( pfucb );

	/*	fake pfucb to look like an opened file
	/**/
	wFlagsSav = (WORD)pfucb->wFlags;
	FUCBSetIndex( pfucb );
	pfdbSav = (FDB *)pfucb->u.pfcb->pfdb;
	pfucb->u.pfcb->pfdb = pfcb->pfdb;

	/* init buffer for set column
	/**/
	prechdr = (RECHDR *)pfucb->lineWorkBuf.pb;
	prechdr->fidFixedLastInRec = (BYTE)( fidFixedLeast - 1 );
	prechdr->fidVarLastInRec = (BYTE)( fidVarLeast - 1 );
	*(WORD *)( prechdr + 1 ) = pfucb->lineWorkBuf.cb = sizeof(RECHDR) + sizeof(WORD);

	/* scan all sons of fields, building default record
	/**/
	Assert( dib.pos == posFirst );
	Assert( dib.fFlags == fDIRNull );

	err = ErrDIRDown( pfucb, &dib );
	if ( err < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( err != JET_errRecordNotFound )
			goto RestoreFUCB;
		}
	else
		{
		/*	since move first err must be JET_errSuccess
		/**/
		Assert( err == JET_errSuccess );

		forever
			{
			Assert( pfucb->lineData.pb != NULL );
			Assert( pfucb->lineData.cb >= sizeof(FIELDDEFDATA) - 1 );
			pfdd = (FIELDDEFDATA *)pfucb->lineData.pb;
			if ( pfdd->cbDefault > 0 )
				{
				CallJ( ErrIsamSetColumn( pfucb->ppib, pfucb, (ULONG)pfdd->fid, pfdd->rgbDefault, (ULONG)pfdd->cbDefault, 0, NULL ), RestoreFUCB )
				}
			err = ErrDIRNext( pfucb, &dib );
			if ( err < 0 )
				{
				/* go back up to files\some_file\fields
				/**/
				DIRUp( pfucb, 1 );
				if ( err == JET_errNoCurrentRecord )
					break;
				goto RestoreFUCB;
				}
			}
		}

	/*	alloc and copy default record, release working buffer
	/**/
	pb = SAlloc( pfucb->lineWorkBuf.cb );
	if ( pb == NULL )
		{
		err = JET_errOutOfMemory;
		goto RestoreFUCB;
		}

	pfcb->pfdb->lineDefaultRecord.pb = pb;

	LineCopy( &pfcb->pfdb->lineDefaultRecord, &pfucb->lineWorkBuf );

	/*	reset copy buffer
	/**/
	BFSFree( pfucb->pbfWorkBuf );
	pfucb->pbfWorkBuf = pbfNil;
	pfucb->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdateSeparateLV( pfucb ) );
	FUCBResetCbstat( pfucb );

	/* unfake pfucb
	/**/
	pfucb->wFlags = wFlagsSav;
	FDBSet( pfucb->u.pfcb, pfdbSav );
	return JET_errSuccess;

	/*	error handling
	/**/
RestoreFUCB:
	pfucb->wFlags = wFlagsSav;
	FDBSet( pfucb->u.pfcb, pfdbSav );

	BFSFree( pfucb->pbfWorkBuf );
	pfucb->pbfWorkBuf = pbfNil;
	pfucb->lineWorkBuf.pb = NULL;

	(FDB *)pfcb->pfdb = pfdbOld;
HandleError:
	FDBDestruct( pfdbNew );
	return err;
	}


VOID FDBDestruct( FDB *pfdb )
	{
	Assert( pfdb != NULL );
	if ( pfdb->lineDefaultRecord.pb != NULL )
		SFree( pfdb->lineDefaultRecord.pb );
	SFree( pfdb );
	return;
	}


/*	set all table FCBs to given pfdb.  Used during reversion to
/*	saved FDB during DDL operation.
/**/
VOID FDBSet( FCB *pfcb, FDB *pfdb )
	{
	FCB	*pfcbT;

 	/* correct non-clusterred index FCBs to new FDB
	/**/
	for ( pfcbT = pfcb;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		pfcbT->pfdb = pfdb;
		}

	return;
	}


//+INTERNAL
// ErrFILEIBuildIndexDefs
// ========================================================================
// ErrFILEIBuildIndexDefs( pfucb, pfcb )
//		FUCB	*pfucb;		// IN	   FUCB open on ...\<file>\indexes
//		FCB	*pfcb;		// INOUT   FCB to fill in indexes for
//
// Fills in the index FCBs for a data file from the directory tree,
// including the clustered index information in the file's FCB.
//
// PARAMETERS	pfucb				FUCB open on ...\<file>\indexes
//					pfcb				must point to an allocated FCB, with FCBs
//										chained on the pfcbNextIndex field, one
//										for each secondary index of the file.
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess	 				Everything worked.
//					-JET_errOutOfMemory				Could not allocate misc. memory
//					-JET_errDatabaseCorrupted		The database directory tree
//															is corrupted.
//				On fatal ( negative ) errors, any memory resources which
//				were allocated are freed.
//
// SEE ALSO	OpenTable
//-
ERR ErrFILEIBuildIndexDefs( FUCB *pfucb, FCB *pfcb )
	{
	ERR	err;								// error code of various utility
	DIB	dib;								// needed for DIR calls
	FCB	*pfcb2ndIdx;					// pointer to secondary index FCBs
	KEY	key;

	/*** "Sequential" or "clustered" file? ***/
	if ( FLineNull( &pfucb->lineData ) )
		{
		// "sequential" file
		pfcb->pidb = pidbNil;

		/*** Down to <NULL> node ***/
		dib.pos = posDown;
		key.cb = 0;
		dib.pkey = &key;
		dib.fFlags = fDIRNull;
		if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
			{
			if ( err > 0 )
				err = JET_errDatabaseCorrupted;
			Error( err, SimpleError );
			}
		}
	else
		{
		/*	file has clustered index
		/**/
		INDEXDEFDATA	*pidd;
		KEY				key;
		CHAR				rgbIndexName[(JET_cbNameMost + 1)];
		INT				cbIndexName;

		cbIndexName = pfucb->lineData.cb;
		Assert( cbIndexName < (JET_cbNameMost + 1) );
		memcpy( rgbIndexName, pfucb->lineData.pb, cbIndexName );

		/*** Down to clustered index node ***/
		dib.pos = posDown;
		dib.pkey = &key;
		dib.pkey->cb = cbIndexName;
		dib.pkey->pb = rgbIndexName;
		dib.fFlags = fDIRNull;
		if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
			{
			if ( err > 0 )
				err = JET_errDatabaseCorrupted;
			Error( err, SimpleError );
			}

		/*** Get clustered index definition, store in IDB ***/
		Assert( pfucb->lineData.pb != NULL );
		Assert( pfucb->lineData.cb <= sizeof(INDEXDEFDATA) );
		pidd = (INDEXDEFDATA *)pfucb->lineData.pb;
		pfcb->cbDensityFree = ( (100-pidd->bDensity ) * cbPage ) / 100;
		CallJ( ErrRECNewIDB( &pfcb->pidb ), SimpleError )
		CallJ( ErrRECAddKeyDef(
			(FDB *)pfcb->pfdb,
			pfcb->pidb,
		   pidd->iidxsegMac,
			pidd->rgidxseg,
		   pidd->bFlags,
			pidd->langid ), FreeIDB )
		strcpy( pfcb->pidb->szName, pidd->szIndexName );
		}

	/*** Go down to "data" node ***/
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyData;
	Assert( dib.fFlags == fDIRNull );
	if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
		Error( err, FreeIDB );
		}

	/*	now at "DATA"; get pgno, itag of data root from CSR
	/**/
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	pfcb->pgnoRoot = PcsrCurrent( pfucb )->pgno;
	pfcb->itagRoot = PcsrCurrent( pfucb )->itag;
	pfcb->bmRoot = SridOfPgnoItag( pfcb->pgnoRoot, pfcb->itagRoot );
	
	/*** If "sequential" file, get the max DBK in use ***/
	if ( pfcb->pidb == pidbNil )
		{
		/*** Go down to the last data record ***/
		dib.pos = posLast;
		Assert( dib.fFlags == fDIRNull );

		if ( ( err = ErrDIRDown( pfucb, &dib ) ) == JET_errSuccess )
			{
			BYTE *pb = pfucb->keyNode.pb;
			pfcb->dbkMost = ( pb[0] << 24 ) + ( pb[1] << 16 ) + ( pb[2] <<  8 ) +	 pb[3];
			DIRUp( pfucb, 1 );
			}
		else if ( err == JET_errRecordNotFound )
			pfcb->dbkMost = 0;
		else
			goto FreeIDB;
		}

	/*	go back up to "indexes" node
	/**/
	DIRUp( pfucb, 2 );

	/*	build index FCB for each secondary index
	/**/
	pfcb2ndIdx = pfcb->pfcbNextIndex;
	dib.pos = posFirst;
	Assert( dib.fFlags == fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	while ( err >= 0 )
		{
		/*	ignore clustered index
		/**/
		if ( pfcb->pidb == pidbNil )
			{
			/*	sequential file
			/**/
			if ( pfucb->lineData.cb == 0 || FIndexNameNull( pfucb ) )
				goto NextIndex;
			}
		else
			{
			/*	clustered file
			/**/
			if ( CbIndexName( pfucb ) == strlen( pfcb->pidb->szName ) &&
				_strnicmp( PbIndexName( pfucb ), pfcb->pidb->szName,
				CbIndexName( pfucb ) ) == 0 )
				{
				goto NextIndex;
				}
			}

		/*	build index definition into next index FCB
		/**/
		if ( err != errDIRFDP )
			{
			/*	2nd idxs must be FDPs
			/**/
			if ( err == JET_errSuccess )
				err = JET_errDatabaseCorrupted;
			Error( err, CleanUpDoneFCBs );
			}
		if ( pfcb2ndIdx == pfcbNil )
			{
			/*	more idxs than I was told
			/**/
			Error( JET_errDatabaseCorrupted, CleanUpDoneFCBs )
			}
		CallJ( ErrFILEIFillIn2ndIdxFCB( pfucb, (FDB *)pfcb->pfdb, pfcb2ndIdx ), CleanUpDoneFCBs )

		/*	move on to the next pre-allocated index FCB
		/**/
		pfcb2ndIdx = pfcb2ndIdx->pfcbNextIndex;

NextIndex:
		/*	next index
		/**/
		err = ErrDIRNext( pfucb, &dib );
		}

	if ( pfcb2ndIdx != pfcbNil )
		{
		/*	fewer idxs than expected
		/**/
		Error( JET_errDatabaseCorrupted, CleanUpDoneFCBs )
		}
	else
		if ( err != JET_errRecordNotFound && err != JET_errNoCurrentRecord )
			goto CleanUpDoneFCBs;

	/*	go back up to "indexes" node
	/**/
	DIRUp( pfucb, 1 );

	return JET_errSuccess;

	/*** Error handling ***/
CleanUpDoneFCBs:
	// release memory for finished indexes
	{
	FCB	*pfcbT;							// FCB pointer of various utility

	for ( pfcbT = pfcb->pfcbNextIndex; pfcbT != pfcb2ndIdx; pfcbT = pfcbT->pfcbNextIndex )
		{
		Assert( pfcbT != pfcbNil );
		RECFreeIDB( pfcbT->pidb );
		}
	}
FreeIDB:						// free file clustered index IDB
	if ( pfcb->pidb != pidbNil )
		RECFreeIDB( pfcb->pidb );
SimpleError:				// nothing to clean up
	return err;
	}


//+INTERNAL
// ErrFILEIFillIn2ndIdxFCB
// ========================================================================
// ErrFILEIFillIn2ndIdxFCB( pfucb, pfdb, pfcb )
//		FUCB *pfucb;	// IN	   FUCB open on ...\<file>\indexes\<index>
//		FDB *pfdb;		// IN	   FDB of file who has this index
//		FCB *pfcb;		// INOUT   secondary index FCB to fill in
// Fills in a secondary index FCB from the directory tree.
//
// PARAMETERS	pfucb		FUCB open on ...\<file>\indexes\<index>
//				pfdb		FDB of file who has this index
//				pfcb		must point to an allocated FCB
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess					Everything worked.
//					-JET_errOutOfMemory				Could not allocate misc. memory
//					-JET_errDatabaseCorrupted		The database directory tree
//															is corrupted.
//				On fatal ( negative ) errors, any memory resources which
//				were allocated are freed.
// SEE ALSO		OpenTable
//-
ERR ErrFILEIFillIn2ndIdxFCB( FUCB *pfucb, FDB *pfdb, FCB *pfcb )
	{
	ERR												err;			// error code of various utility
	INDEXDEFDATA							*pidd; 		// data at the index node
	DIB												dib;			// needed for DIR calls

	/*** Fill in FDP page number ***/
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	pfcb->pgnoFDP = PcsrCurrent( pfucb )->pgno;

	/*	reference count
	/**/
	pfcb->wRefCnt = 0;
	pfcb->wFlags = 0;
	pfcb->dbid = pfucb->dbid;	// dbid should have been set at this point

	/*** Get index definition, store in IDB ***/
	Assert( pfucb->lineData.pb != NULL );
	Assert( pfucb->lineData.cb <= sizeof(INDEXDEFDATA) );
	pidd = (INDEXDEFDATA *)pfucb->lineData.pb;
	pfcb->cbDensityFree = ( (100-pidd->bDensity ) * cbPage ) / 100;
	CallJ( ErrRECNewIDB( &pfcb->pidb ), SimpleError )
	pfcb->pfdb = pfdb;
	CallJ( ErrRECAddKeyDef(
		(FDB *)pfcb->pfdb,
		pfcb->pidb,
	   pidd->iidxsegMac,
		pidd->rgidxseg,
	   pidd->bFlags,
		pidd->langid ), FreeIDB )
	strcpy( pfcb->pidb->szName, pidd->szIndexName );

	/*	go down to "OLCStats" node and get Stats, if any
	/**/
	dib.pos = posDown;
	dib.pkey = (KEY *)pkeyOLCStats;
	dib.fFlags = fDIRNull;
	err = ErrDIRDown( pfucb, &dib );
	if ( err >= JET_errSuccess )
		{
		if ( err != JET_errSuccess )
			{
			FCBResetOLCStatsAvail( pfcb );
			}
		else
			{
			FCBSetOLCStatsAvail( pfcb );
			CallJ( ErrDIRGet( pfucb ), FreeIDB );
			Assert( pfucb->lineData.cb == sizeof( PERS_OLCSTAT ) );
			memcpy( (BYTE *) &pfcb->olcStat, pfucb->lineData.pb, sizeof( PERS_OLCSTAT ) );
			}

		/*** Go back up to ...\indexes\<index> node ***/
		DIRUp( pfucb, 1 );
		}

	/*	go down to "data" node
	/**/
	Assert( dib.pos == posDown );
	dib.pkey = (KEY *)pkeyData;
	Assert( dib.fFlags == fDIRNull );
	if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
		{
		if ( err > 0 )
			err = JET_errDatabaseCorrupted;
		Error( err, FreeIDB )
		}

	/*	now at "data", get pgno, itag of data root from CSR
	/**/
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	pfcb->pgnoRoot = PcsrCurrent( pfucb )->pgno;
	pfcb->itagRoot = PcsrCurrent( pfucb )->itag;
	AssertNDGetNode( pfucb, pfcb->itagRoot );
	NDGetBookmark( pfucb, &pfcb->bmRoot );

	/*** Go back up to ...\indexes\<index> node ***/
	DIRUp( pfucb, 1 );

	return JET_errSuccess;

	/*** Error handling ***/
FreeIDB:						// free up secondary index IDB block
	RECFreeIDB( pfcb->pidb );
SimpleError:					// nothing to clean up
	return err;
	}


//+INTERNAL
// FILEIDeallocateFileFCB
// ========================================================================
// FILEIDeallocateFileFCB( FCB *pfcb )
//
// Frees memory allocations associated with a file FCB and all of its
// secondary index FCBs.
//
// PARAMETERS	
//		pfcb			pointer to FCB to deallocate
//
//-
VOID FILEIDeallocateFileFCB( FCB *pfcb )
	{
	FCB	*pfcbIdx;
	FCB	*pfcbT;

	Assert( pfcb != pfcbNil );
	Assert( CVersionFCB( pfcb ) == 0 );
	
	/*	release FCB resources
	/**/
	pfcbIdx = pfcb->pfcbNextIndex;
	if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
		{
		FCBDiscard( pfcb );
		}

	while ( pfcbIdx != pfcbNil )
		{
		Assert( pfcbIdx->pidb != pidbNil );
		RECFreeIDB( pfcbIdx->pidb );
		pfcbT = pfcbIdx->pfcbNextIndex;
		Assert( PfcbFCBGet( pfcbIdx->dbid, pfcbIdx->pgnoFDP ) == pfcbNil );
		Assert( pfcbIdx->cVersion == 0 );
		Assert( pfcbIdx->crefDenyDDL == 0 );
		MEMReleasePfcb( pfcbIdx );
		pfcbIdx = pfcbT;
		}

	/*	if fcb was on table was opened during the creation of
	/*	this FCB, then szFileName would not be set
	/**/
	if ( pfcb->szFileName != NULL )
		SFree( pfcb->szFileName );
	if ( pfcb->pfdb != pfdbNil )
		FDBDestruct( (FDB *)pfcb->pfdb );
	if ( pfcb->pidb != pidbNil )
		RECFreeIDB( pfcb->pidb );
	Assert( pfcb->cVersion == 0 );
	Assert( pfcb->crefDenyDDL == 0 );
	MEMReleasePfcb( pfcb );
	}


/*	combines all index column masks into a single per table
/*	index mask, used for index update check skip.
/**/
VOID FILESetAllIndexMask( FCB *pfcbTable )
	{
	FCB		*pfcbT;
	LONG		*plMax;
	LONG		*plAll;
	UNALIGNED LONG	*plIndex;

	/*	initialize variables.
	/**/
	plMax = (LONG *)pfcbTable->rgbitAllIndex +
		sizeof( pfcbTable->rgbitAllIndex ) / sizeof(LONG);

	/*	initialize mask to clustered index, or to 0s for sequential file.
	/**/
	if ( pfcbTable->pidb != pidbNil )
		{
		memcpy( pfcbTable->rgbitAllIndex,
			pfcbTable->pidb->rgbitIdx,
			sizeof( pfcbTable->pidb->rgbitIdx ) );
		pfcbTable->fAllIndexTagged = pfcbTable->pidb->fidb & fidbHasTagged;
		}
	else
		{
		memset( pfcbTable->rgbitAllIndex,
			'\0',
			sizeof( pfcbTable->rgbitAllIndex ) );
		pfcbTable->fAllIndexTagged = fFalse;
		}

	/*	for each non-clustered index, combine index mask with all index
	/*	mask.  Also, combine has tagged flag.
	/**/
	for ( pfcbT = pfcbTable->pfcbNextIndex;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		plAll = (LONG *) pfcbTable->rgbitAllIndex;
		plIndex = (LONG *) pfcbT->pidb->rgbitIdx;
		for ( ; plAll < plMax; plAll++, plIndex++ )
			{
			*plAll |= *plIndex;
			}

		/*	has tagged flag.
		/**/
		pfcbTable->fAllIndexTagged |= pfcbT->pidb->fidb & fidbHasTagged;
		}

	return;
	}


/*	calls ErrDIRSeekPath to navigate to table root.
/**/
ERR ErrFILESeek( FUCB *pfucb, CHAR *szTable )
	{
	ERR  		err;
	KEY 		rgkey[2];
	BYTE		rgbTableNorm[ JET_cbKeyMost ];

	Assert( pfucb != pfucbNil );

	/*	make seek path from table name
	/**/
	rgkey[0] = *pkeyTables;

	/*	normalize table name and set key
	/**/
	SysNormText( szTable, strlen( szTable ), rgbTableNorm, sizeof( rgbTableNorm ), &rgkey[1].cb );
	rgkey[1].pb = rgbTableNorm;

	err = ErrDIRSeekPath( pfucb, 2, rgkey, 0 );
	switch ( err )
		{
	default:
		return err;
	case JET_errRecordNotFound:
		return JET_errObjectNotFound;
	case errDIRFDP:
		break;
	case JET_errSuccess:
		return JET_errInvalidName;
		}

	return err;
	}


FIELD *PfieldFCBFromColumnName( FCB *pfcb, CHAR *szName )
	{
	FID		fid;
	FIELD		*rgfield;

	/*	find column structure in FDB and change name.  Since
	/*	column may be fixed, variable or tagged, go through
	/*	each column list.
	/**/
	rgfield = pfcb->pfdb->pfieldFixed;

	for ( fid = 0;
		fid < pfcb->pfdb->fidFixedLast; fid++ )
		{
		if ( SysCmpText( rgfield[fid].szFieldName, szName ) == 0 )
			{
			return &rgfield[fid];
			}
		}

	rgfield = pfcb->pfdb->pfieldVar;
	for ( fid = 0;
		fid < pfcb->pfdb->fidVarLast - fidVarLeast + 1; fid++ )
		{
		if ( SysCmpText( rgfield[fid].szFieldName, szName ) == 0 )
			{
			return &rgfield[fid];
			}
		}

	rgfield = pfcb->pfdb->pfieldTagged;
	for ( fid = 0;
		fid < pfcb->pfdb->fidTaggedLast - fidTaggedLeast + 1; fid++ )
		{
		if ( SysCmpText( rgfield[fid].szFieldName, szName ) == 0 )
			{
			return &rgfield[fid];
			}
		}

	/*	must have found column
	/**/
	Assert( fFalse );
	return NULL;
	}


FCB *PfcbFCBFromIndexName( FCB *pfcbTable, CHAR *szName )
	{
	FCB	*pfcb;

	/*	find index FCB and change name.
	/**/
	for ( pfcb = pfcbTable; pfcb != pfcbNil; pfcb = pfcb->pfcbNextIndex )
		{
		if ( pfcb->pidb != NULL &&
			SysCmpText( pfcb->pidb->szName, szName ) == 0 )
			{
			break;
			}
		}
//	Assert( pfcb != pfcbNil );
	return pfcb;
	}

#if 0
FIELD *PfieldFCBFromColumnid( FCB *pfcb, FID fid )
	{
	/*	find column structure in FDB and change name.  Since
	/*	column may be fixed, variable or tagged, go through
	/*	each column list.
	/**/
	if ( FFixedFid( fid ) )
		return pfcb->pfdb->pfieldFixed[fid -fidFixLeast];
	if ( FVarFid( fid ) )
		return pfcb->pfdb->pfieldVar[fid - fidVarLeast];
	if ( FTaggedFid( fid ) )
		return pfcb->pfdb->pfieldVar[fid - fidTaggedLeast];

	/*	must have found column
	/**/
	Assert( fFalse );
	return;
	}
#endif


#ifdef DEBUG
ERR	ErrFILEDumpTable( PIB *ppib, DBID dbid, CHAR *szTable )
	{
	ERR		err = JET_errSuccess;
	FUCB  	*pfucb = pfucbNil;

	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szTable, JET_bitTableDenyRead ) );

	/*	move to table root
	/**/
	DIRGotoFDPRoot( pfucb );

	/*	dump table
	/**/
	Call( ErrDIRDump( pfucb, 0 ) );

HandleError:
	if ( pfucb != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucb ) );

	return err;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\fdelete.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "fmp.h"
#include "page.h"
#include "ssib.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "fileint.h"
#include "recint.h"
#include "logapi.h"
#include "nver.h"
#include "dirapi.h"
#include "recapi.h"
#include "fileapi.h"
#include "dbapi.h"
#include "systab.h"
#include "bm.h"

DeclAssertFile;						/* Declare file name for assert macros */

#ifdef DEBUG
//#define TRACE
#endif

//+API
// ErrIsamDeleteTable
// ========================================================================
// ERR ErrIsamDeleteTable( PIB *ppib, ULONG_PTR vdbid, CHAR *szName )
//
// Calls ErrFILEIDeleteTable to
// delete a file and all indexes associated with it.
//
// RETURNS		JET_errSuccess or err from called routine.
//
// SEE ALSO		ErrIsamCreateTable
//-
ERR VTAPI ErrIsamDeleteTable( PIB *ppib, ULONG_PTR vdbid, CHAR *szName )
	{
	ERR			err;
	DBID	   	dbid = DbidOfVDbid (vdbid);
	CHAR	   	szTable[(JET_cbNameMost + 1)];
	OBJID	   	objid;
	JET_OBJTYP	objtyp;

	/* ensure that database is updatable
	/**/
	CallR( VDbidCheckUpdatable( vdbid ) );

	CheckPIB( ppib );
	CheckDBID( ppib, dbid );
	CallR( ErrCheckName( szTable, szName, (JET_cbNameMost + 1) ) );
	
#ifdef	SYSTABLES
	if ( FSysTabDatabase( dbid ) )
		{
		err = ErrFindObjidFromIdName( ppib, dbid, objidTblContainer, szTable, &objid, &objtyp );
		if ( err < 0 )
			{
			return err;
			}
		else		
			{
			if ( objtyp == JET_objtypQuery || objtyp == JET_objtypLink || objtyp == JET_objtypSQLLink )
				{
				err = ErrIsamDeleteObject( (JET_SESID)ppib, vdbid, objid );
				return err;
				}
			}
		}
#endif	/* SYSTABLES */

	err = ErrFILEDeleteTable( ppib, dbid, szName );
	return err;
	}


// ErrFILEDeleteTable
// ========================================================================
// ERR ErrFILEDeleteTable( PIB *ppib, DBID dbid, CHAR *szName )
//
// Deletes a file and all indexes associated with it.
//
// RETURNS		JET_errSuccess or err from called routine.
//
// COMMENTS		
//	Acquires an exclusive lock on the file [FCBSetDelete].
//	A transaction is wrapped around this function.	Thus,
//	any work done will be undone if a failure occurs.
//	Transaction logging is turned off for temporary files.
//
// SEE ALSO		ErrIsamCreateTable
//-
ERR ErrFILEDeleteTable( PIB *ppib, DBID dbid, CHAR *szTable )
	{
	ERR   	err;
	FUCB  	*pfucb = pfucbNil;
	PGNO  	pgnoFDP;
	BOOL  	fSetDomainOperation = fFalse;
	FCB	  	*pfcb;
	FCB	  	*pfcbT;

	CheckPIB( ppib );
	CheckDBID( ppib, dbid );

	CallR( ErrDIRBeginTransaction( ppib ) );

	/*	open cursor on database
	/**/
	Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );

	/*	seek to table without locking
	/**/
	Call( ErrFILESeek( pfucb, szTable ) );
	Assert( ppib != ppibNil );
	Assert( ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode );
	pgnoFDP = PcsrCurrent( pfucb )->pgno;

	/* abort if index is being built on file
	/**/
	if ( FFCBDenyDDL( pfucb->u.pfcb, ppib ) )
		{
		err = JET_errWriteConflict;
		goto HandleError;
		}

    /*  get table FCB or sentinel FCB
    /**/
    pfcb = PfcbFCBGet( dbid, pgnoFDP );
    /* wait for other domain operation
    /**/
    while ( pfcb != pfcbNil && FFCBDomainOperation( pfcb ) )
        {
        BFSleep( cmsecWaitGeneric );
        pfcb = PfcbFCBGet( dbid, pgnoFDP );
        }
    if ( pfcb != pfcbNil )
        {
        FCBSetDomainOperation( pfcb );
        fSetDomainOperation = fTrue;
        }

	/*	handle error for above call
	/**/
	Call( ErrFCBSetDeleteTable( ppib, dbid, pgnoFDP ) );
    if ( pfcb == pfcbNil )
        {
        pfcb = PfcbFCBGet( dbid, pgnoFDP );
        Assert( pfcb != pfcbNil );
        }

	FCBSetDenyDDL( pfucb->u.pfcb, ppib );
	err = ErrVERFlag( pfucb, operDeleteTable, &pgnoFDP, sizeof(pgnoFDP) );
	if ( err < 0 )
		{
		FCBResetDenyDDL( pfucb->u.pfcb );
		FCBResetDeleteTable( dbid, pgnoFDP );
		goto HandleError;
		}

	/*	delete table FDP pointer node.  This will recursively delete
	/*	table and free table space.  Note that table space is defer
	/*	freed until commit to transaction level 0.  This is done to
	/*	facillitate rollback.
	/**/
	Call( ErrDIRDelete( pfucb, fDIRVersion ) );

	/* remove MPL entries for this table and all indexes
	/**/
	Assert( pfcb->pgnoFDP == pgnoFDP );
	for ( pfcbT = pfcb; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		{
		Assert( dbid == pfcbT->dbid );
		MPLPurgeFDP( dbid, pfcbT->pgnoFDP );
		FCBSetDeletePending( pfcbT );
		}
	
	DIRClose( pfucb );
	pfucb = pfucbNil;

#ifdef	SYSTABLES
	/*	remove table record from MSysObjects before committing.
	/*	Also remove associated columns and indexes in MSC/MSI.
	/*	Pass 0 for tblid; MSO case in STD figures it out.
	/**/
	if ( dbid != dbidTemp )
		{
		Call( ErrSysTabDelete( ppib, dbid, itableSo, szTable, 0 ) );
		}
#endif	/* SYSTABLES */

#ifdef TRACE
	FPrintF2( "delete table at %d.%lu\n", pfcb->dbid, pfcb->pgnoFDP );
#endif
    if ( fSetDomainOperation )
        FCBResetDomainOperation( pfcb );
	Call( ErrDIRCommitTransaction( ppib ) );
	return err;

HandleError:
	if ( fSetDomainOperation )
		FCBResetDomainOperation( pfcb );
	if ( pfucb != pfucbNil )
		DIRClose( pfucb );
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}


//+API
// DeleteIndex
// ========================================================================
// ERR DeleteIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
//
// Deletes an index definition and all index entries it contains.
//
// PARAMETERS	ppib						PIB of user
// 				pfucb						Exclusively opened FUCB on file
// 				szName						name of index to delete
// RETURNS		Error code from DIRMAN or
//					JET_errSuccess		  	 Everything worked OK.
//					-TableInvalid			 There is no file corresponding
// 											 to the file name given.
//					-TableNoSuchIndex		 There is no index corresponding
// 											 to the index name given.
//					-IndexMustStay			 The clustered index of a file may
// 											 not be deleted.
// COMMENTS		
//		There must not be anyone currently using the file.
//		A transaction is wrapped around this function.	Thus,
//		any work done will be undone if a failure occurs.
//		Transaction logging is turned off for temporary files.
// SEE ALSO		DeleteTable, CreateTable, CreateIndex
//-
ERR VTAPI ErrIsamDeleteIndex( PIB *ppib, FUCB *pfucb, CHAR *szName )
	{
	ERR		err;
	CHAR	szIndex[ (JET_cbNameMost + 1) ];
	BYTE	rgbIndexNorm[ JET_cbKeyMost ];
	DIB		dib;
	KEY		key;
	FCB		*pfcb;
	FCB		*pfcbIdx;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CallR( ErrCheckName( szIndex, szName, ( JET_cbNameMost + 1 ) ) );

	/* ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb )  );

	Assert( ppib != ppibNil );
	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	pfcb = pfucb->u.pfcb;

	/* wait for other domain operation
	/**/
	while ( FFCBDomainOperation( pfcb ) )
		{
		BFSleep( cmsecWaitGeneric );
		}
	FCBSetDomainOperation( pfcb );

	/*	normalize index and set key to normalized index
	/**/
	SysNormText( szIndex, strlen( szIndex ), rgbIndexNorm, sizeof( rgbIndexNorm ), &key.cb );
	key.pb = rgbIndexNorm;

	err = ErrDIRBeginTransaction( ppib );
	if ( err < 0 )
		{
		FCBResetDomainOperation( pfcb );
		return err;
		}

	/*	move to FDP root
	/**/
	DIRGotoFDPRoot( pfucb );

	/*	down to indexes, check against clustered index name
	/**/
	dib.pos = posDown;
	dib.pkey = (KEY *)pkeyIndexes;
	dib.fFlags = fDIRNull;
	Call( ErrDIRDown( pfucb, &dib ) );
	if ( pfucb->lineData.cb != 0 &&
		pfucb->lineData.cb == key.cb &&
		memcmp( pfucb->lineData.pb, rgbIndexNorm, pfucb->lineData.cb ) == 0 )
		{
		err = JET_errIndexMustStay;
		goto HandleError;
		}

	/*	down to index node
	/**/
	Assert( dib.pos == posDown );
	dib.pkey = &key;
	Assert( dib.fFlags == fDIRNull );
	Call( ErrDIRDown( pfucb, &dib ) );
	if ( err == wrnNDFoundLess || err == wrnNDFoundGreater )
		{
		err = JET_errIndexNotFound;
		goto HandleError;
		}

	/* abort if DDL is being done on file
	/**/
	if ( FFCBDenyDDL( pfcb, ppib ) )
		{
		err = JET_errWriteConflict;
		goto HandleError;
		}
	FCBSetDenyDDL( pfcb, ppib );
	
	/*	flag delete index
	/**/
	pfcbIdx = PfcbFCBFromIndexName( pfcb, szIndex );
	if ( pfcbIdx == NULL )
		{
		// NOTE:	This case goes away when the data structures
		//			are versioned also.
		//			This case means basically, that another session
		//			has changed this index BUT has not committed to level 0
		//			BUT has changed the RAM data structures.
		FCBResetDenyDDL( pfcb );
		err = JET_errWriteConflict;
		goto HandleError;
		}

	err = ErrFCBSetDeleteIndex( ppib, pfcb, szIndex );
	if ( err < 0 )
		{
		FCBResetDenyDDL( pfcb );
		goto HandleError;
		}
	err = ErrVERFlag( pfucb, operDeleteIndex, &pfcbIdx, sizeof(pfcbIdx) );
	if ( err < 0 )
		{
		FCBResetDeleteIndex( pfcbIdx );
		FCBResetDenyDDL( pfcb );
		goto HandleError;
		}

	/*	purge MPL entries -- must be done after FCBSetDeletePending
	/**/
	MPLPurgeFDP( pfucb->dbid, pfcbIdx->pgnoFDP );
	
	/*	assert not deleting current non-clustered index
	/**/
	Assert( pfucb->pfucbCurIndex == pfucbNil ||
		SysCmpText( szIndex, pfucb->pfucbCurIndex->u.pfcb->pidb->szName ) != 0 );

	/*	delete index node
	/**/
	Call( ErrDIRDelete( pfucb, fDIRVersion ) );

	/*	back up to file node
	/**/
	DIRUp( pfucb, 2 );

	/*	update index count and DDL time stamp
	/**/
	Call( ErrFILEIUpdateFDPData( pfucb, fDropIndexCount | fDDLStamp ) );

#ifdef	SYSTABLES
	/*	remove index record from MSysIndexes before committing...
	/**/
	if ( FSysTabDatabase( pfucb->dbid ) )
		{
		Call( ErrSysTabDelete( ppib, pfucb->dbid, itableSi, szIndex, pfucb->u.pfcb->pgnoFDP ) );
		}
#endif	/* SYSTABLES */

	Call( ErrDIRCommitTransaction( ppib ) );

	/*	set currency to before first
	/**/
	DIRBeforeFirst( pfucb );
#ifdef TRACE
	FPrintF2( "delete index at %d.%lu\n", pfcbIdx->dbid, pfcbIdx->pgnoFDP );
#endif
	FCBResetDomainOperation( pfcb );
 	return JET_errSuccess;

HandleError:
	CallS( ErrDIRRollback( ppib ) );
	FCBResetDomainOperation( pfcb );
	return err;
	}


ERR VTAPI ErrIsamDeleteColumn( PIB *ppib, FUCB *pfucb, CHAR *szName )
	{
	ERR  			  		err;
	DIB  			  		dib;
	INT 			  		iidxseg;
	KEY  			  		key;
	CHAR			  		szColumn[ (JET_cbNameMost + 1) ];
	BYTE			  		rgbColumnNorm[ JET_cbKeyMost ];
	FCB			  			*pfcb;
	LINE					lineField;
	FIELDDEFDATA  			fdd;
	FCB			  			*pfcbIndex;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	CallR( ErrCheckName( szColumn, szName, (JET_cbNameMost + 1) ) );

	/* ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb ) );

	Assert( ppib != ppibNil );
	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	pfcb = pfucb->u.pfcb;
//	if ( !( FFCBDenyReadByUs( pfcb, ppib ) ) )
//		return JET_errTableNotLocked;

	/* normalize column name and set key
	/**/
	SysNormText( szColumn, strlen( szColumn ), rgbColumnNorm, sizeof( rgbColumnNorm ), &key.cb );
	key.pb = rgbColumnNorm;

	CallR( ErrDIRBeginTransaction( ppib ) );

	/* abort if DDL is being done on file
	/**/
	if ( FFCBDenyDDL( pfcb, ppib ) )
		{
		err = JET_errWriteConflict;
		goto HandleError;
		}
	FCBSetDenyDDL( pfcb, ppib );
	
	err = ErrVERFlag( pfucb, operDeleteColumn, (VOID *)&pfcb->pfdb, sizeof(pfcb->pfdb) );
	if ( err < 0 )
		{
		FCBResetDenyDDL( pfcb );
		}
	
	/*	move to FDP root and update FDP timestamp
	/**/
	DIRGotoFDPRoot( pfucb );
	Call( ErrFILEIUpdateFDPData( pfucb, fDDLStamp ) );

	/*	down to fields\rgbColumnNorm to find field id (and verify existance)
	/**/
	dib.pos = posDown;
	dib.pkey = (KEY *)pkeyFields;
	dib.fFlags = fDIRNull;
	Call( ErrDIRDown( pfucb, &dib ) );
	dib.pkey = &key;
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errSuccess )
		{
		err = JET_errColumnNotFound;
		goto HandleError;
		}
	fdd = *(FIELDDEFDATA *)pfucb->lineData.pb;

	/*	search for column in use in indexes
	/**/
	for ( pfcbIndex = pfucb->u.pfcb;
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->pfcbNextIndex )
		{
		if ( pfcbIndex->pidb != NULL )
			{
			for ( iidxseg = 0;
				iidxseg < pfcbIndex->pidb->iidxsegMac;
				iidxseg++ )
				{
				if ( pfcbIndex->pidb->rgidxseg[iidxseg] < 0 )
					{
					if ( (FID)( -pfcbIndex->pidb->rgidxseg[iidxseg] ) == fdd.fid )
						Call( JET_errColumnInUse );
					}
				else
					{
					if ( (FID)pfcbIndex->pidb->rgidxseg[iidxseg] == fdd.fid )
						Call( JET_errColumnInUse );
					}
				}
			}
		}

	Call( ErrDIRDelete( pfucb, fDIRVersion ) );

	/*	if fixed field, insert a placeholder for computing offsets
	/**/
	if ( fdd.fid <= fidFixedMost )
		{
		BYTE	bSav = *rgbColumnNorm;

		fdd.bFlags = ffieldDeleted;			//	flag deleted fixed field
		fdd.cbDefault = 0;					//	get rid of the default value
		*rgbColumnNorm = ' ';				//	clobber the key
		key.cb = 1;							//	(any value will work)
		lineField.pb = (BYTE *)&fdd;		//	point to the field definition
		lineField.cb = sizeof(fdd);

		/*	up to the FIELDS node
		/**/
		DIRUp( pfucb, 1 );
		Call( ErrDIRInsert(pfucb, &lineField, &key, fDIRVersion | fDIRDuplicate ) );
		*rgbColumnNorm = bSav;
		}

	/*	up to "FIELDS" node
	/**/
	DIRUp( pfucb, 1 );

	/*	rebuild FDB and default record value
	/**/
	Call( ErrDIRGet( pfucb ) );
	Call( ErrFDBConstruct(pfucb, pfcb, fTrue /*fBuildDefault*/ ) );

	/*	set currencies at BeforeFirst and remove unused CSR
	/**/
	DIRUp( pfucb, 1 );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		Assert( PcsrCurrent( pfucb->pfucbCurIndex ) != pcsrNil );
		PcsrCurrent( pfucb->pfucbCurIndex )->csrstat = csrstatBeforeFirst;
		}

#ifdef SYSTABLES
	/*	remove column record from MSysColumns before committing...
	/**/
	if ( FSysTabDatabase( pfucb->dbid ) )
		{
		Call( ErrSysTabDelete( ppib, pfucb->dbid, itableSc, szColumn, pfucb->u.pfcb->pgnoFDP ) );
		}
#endif	/* SYSTABLES */

	Call( ErrDIRCommitTransaction( ppib ) );

	return JET_errSuccess;

HandleError:
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\fcreate.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "ssib.h"
#include "page.h"
#include "fmp.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "logapi.h"
#include "scb.h"
#include "fdb.h"
#include "idb.h"
#include "fileapi.h"
#include "fileint.h"
#include "util.h"
#include "dbapi.h"

#include "systab.h"
#include "stats.h"
#include "nver.h"
#include "dirapi.h"
#include "recapi.h"
#include "sortapi.h"
#include "node.h"
#include "recint.h"

DeclAssertFile;                                 /* Declare file name for assert macros */

static FIELDDATA fielddataInitial = {
        fidFixedLeast-1,
        fidVarLeast-1,
        fidTaggedLeast-1
};

static PERS_OLCSTAT olcStatsInit = {
        0,
        0,
        0,
        0
};

static ULONG    autoincInit = 1;
LINE                    lineNull = { 0, NULL };

//
// WaitTillOldest( TRX trx )
// Waits till trx becomes the oldest transaction alive
//      Uses exponential back off
// BFSleep releases critical sections to avoid deadlocks
LOCAL VOID WaitTillOldest( TRX trx )
        {
        ULONG ulmsec = ulStartTimeOutPeriod;

        /*      must be in critJet when inspect trxOldest global variable.
        /*      Call BFSleep to release critJet while sleeping.
        /**/
        for ( ; trx != trxOldest; )
                {
                BFSleep( ulmsec );
                ulmsec *= 2;
                if ( ulmsec > ulMaxTimeOutPeriod )
                        ulmsec = ulMaxTimeOutPeriod;
                }
        return;
        }


ERR VTAPI ErrIsamCreateTable(
        PIB                     *ppib,
        ULONG_PTR       vdbid,
        char            *szName,
        ULONG           ulPages,
        ULONG           ulDensity,
        FUCB            **ppfucb )
        {
        ERR                     err;
        DBID            dbid;
        FUCB            *pfucb;

#ifdef  DISPATCHING
        JET_TABLEID     tableid;

        /*      Allocate a dispatchable tableid
        /**/
        CallR( ErrAllocateTableid(&tableid, (JET_VTID) 0, &vtfndefIsam ) );
#endif  /* DISPATCHING */

        /* Ensure that database is updatable
        /**/
        CallR( VDbidCheckUpdatable( vdbid ) );

        dbid = DbidOfVDbid( vdbid );

        Call( ErrFILECreateTable(
                ppib,
                dbid,
                szName,
                ulPages,
                ulDensity,
                &pfucb ) );

#ifdef  DISPATCHING
        /* Inform dispatcher of correct JET_VTID */
        CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucb ) );
        pfucb->fVtid = fTrue;
        *(JET_TABLEID *) ppfucb = tableid;
#else   /* !DISPATCHING */
        *ppfucb = pfucb;
#endif  /* !DISPATCHING */

        return err;

HandleError:
#ifdef  DISPATCHING
        ReleaseTableid( tableid );
#endif  /* DISPATCHING */
        return err;
        }


//+API
// ErrFILECreateTable
// =========================================================================
// ERR ErrFILECreateTable( PIB *ppib, DBID dbid, CHAR *szName,
//              ULONG ulPages, ULONG ulDensity, FUCB **ppfucb )
//
// Create file with pathname szName.  Created file will have no fields or
// indexes defined (and so will be a "sequential" file ).
//
// PARAMETERS
//                                      ppib                            PIB of user
//                                      dbid                            database id
//                                      szName                  path name of new file
//                                      ulPages                 initial page allocation for file
//                                      ulDensity               initial loading density
//                                      ppfucb                  Exclusively locked FUCB on new file
// RETURNS              Error codes from DIRMAN or
//                                       JET_errSuccess         Everything worked OK.
//                                      -DensityIvlaid                  Density parameter not valid
//                                      -TableDuplicate                 A file already exists with
//                                                                                              the path given.
// COMMENTS             A transaction is wrapped around this function.  Thus, any
//                                      work done will be undone if a failure occurs.
// SEE ALSO             ErrIsamAddColumn, ErrIsamCreateIndex, ErrIsamDeleteTable
//-
ERR ErrFILECreateTable( PIB *ppib, DBID dbid, const CHAR *szName, ULONG ulPages, ULONG ulDensity, FUCB **ppfucb )
        {
        ERR                             err;
        CHAR                    szTable[(JET_cbNameMost + 1 )];
        FUCB                    *pfucb;
        KEY                             key;
        BYTE                    rgbKey[JET_cbKeyMost];
#define cbMostTableRoot (2*sizeof(WORD)+2*sizeof(JET_DATESERIAL)+JET_cbNameMost)
        BYTE                    rgbData[cbMostTableRoot];
        LINE                    line;
        PGNO                    pgnoFDP;
        DBID                    dbidAdjust;
        JET_DATESERIAL  dtNow;

#ifdef  SYSTABLES
        BOOL            fDoSTI;

        /*      Set fDoSTI and fix DBID...
        */
        if (dbid >= dbidMax )
                {
                dbid -= dbidMax;
                fDoSTI = 0;
                }
        else
                fDoSTI = 1;
        dbidAdjust = (ULONG) dbid;
#endif  /* SYSTABLES */

        /*** Check parms ***/
        CheckPIB(ppib );
        CheckDBID( ppib, dbid );
        CallR( ErrCheckName( szTable, szName, (JET_cbNameMost + 1) ) );
        if ( ulDensity == 0 )
                ulDensity = ulDefaultDensity;
        if ( ulDensity < ulFILEDensityLeast || ulDensity > ulFILEDensityMost )
                return JET_errDensityInvalid;

        CallR( ErrDIRBeginTransaction( ppib ) );

        // get an fucb
        Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );

        /*      move to tables node.
        /**/
        Call( ErrDIRSeekPath( pfucb, 1, pkeyTables, 0 ) );

        /****** FILE PAGE START ****************************
        /**/

        // create terminal node; data is:
        //         number of secondary indexes (WORD)
        //         density, if sequential file (WORD)
        //         creation time stamp (JET_DATESERIAL)
        //         last DDL time stamp (JET_DATESERIAL)
        //         original form of file name (var.)

        /*      normalize table name and set key
        /**/
        SysNormText( szTable, strlen( szTable ), rgbKey, sizeof( rgbKey ), &key.cb );
        key.pb = rgbKey;

        line.pb = rgbData;
        ((WORD *)line.pb)[0] = 0;                                               // number of secondary indexes
        ((WORD *)line.pb)[1] = (WORD)ulDensity;         // sequential file density
        UtilGetDateTime( &dtNow );
        memcpy( line.pb+2*sizeof(WORD), &dtNow, sizeof(JET_DATESERIAL) );
        memcpy( line.pb+2*sizeof(WORD)+sizeof(JET_DATESERIAL), &dtNow, sizeof(JET_DATESERIAL) );
        memcpy( line.pb+2*sizeof(WORD)+2*sizeof(JET_DATESERIAL), szTable, strlen(szTable) );
        line.cb = (ULONG)(2*sizeof(WORD) + 2*sizeof(JET_DATESERIAL) + strlen(szTable));
        Assert( line.cb <= cbMostTableRoot );
        err = ErrDIRInsertFDP( pfucb, &line, &key, fDIRVersion, (CPG)ulPages );
        if ( err < 0 )
                {
                if ( err == JET_errKeyDuplicate )
                        {
                        err = JET_errTableDuplicate;
                        }
                goto HandleError;
                }

        Assert( ppib != ppibNil );
        Assert( ppib->level < levelMax );
        Assert( PcsrCurrent( pfucb ) != pcsrNil );
        Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode );
        pgnoFDP = PcsrCurrent( pfucb )->pgno;

        /*      set page density.
        /**/
        pfucb->u.pfcb->cbDensityFree = ( ( 100 - ulDensity ) * cbPage ) / 100;

        // indexes/clustered/data
        Call( ErrDIRInsert( pfucb, &lineNull, pkeyIndexes, fDIRNoVersion ) );
        Call( ErrDIRInsert( pfucb, &lineNull, pkeyNull, fDIRNoVersion ) );
        Call( ErrDIRInsert( pfucb, &lineNull, pkeyData, fDIRNoVersion | fDIRBackToFather ) );
        DIRUp( pfucb, 2 );

        // fields
        line.cb = sizeof(FIELDDATA);
        line.pb = (BYTE *)&fielddataInitial;
        Call( ErrDIRInsert( pfucb, &line, pkeyFields, fDIRNoVersion | fDIRBackToFather ) );

//      // long data
//      Call( ErrDIRInsert( pfucb, &lineNull, pkeyLong, fDIRNoVersion | fDIRBackToFather ) );

        // AutoInc Node
        line.pb = (BYTE *) &autoincInit;
        line.cb = sizeof(autoincInit);
        Call( ErrDIRInsert( pfucb, &line, pkeyAutoInc, fDIRNoVersion | fDIRBackToFather ) );

        // OLCStats node
        line.pb = (BYTE *) &olcStatsInit;
        line.cb = sizeof( olcStatsInit );
        Call( ErrDIRInsert( pfucb, &line, pkeyOLCStats, fDIRNoVersion | fDIRBackToFather ) );

        DIRClose( pfucb );

#ifdef SYSTABLES
        /*      insert record in MSO...
        /**/
        if ( dbid != dbidTemp && fDoSTI )
                {
                JET_TABLEID             objidTable              = pgnoFDP;
                LINE                            rgline[ilineSxMax];
                OBJTYP                  objtyp                  = (OBJTYP)JET_objtypTable;
                JET_TABLEID             objidParentId   = objidTblContainer;
                long                            flags                           = 0;

                rgline[iMSO_Id].pb                              = (BYTE *)&objidTable;
                rgline[iMSO_Id].cb                              = sizeof(objidTable);
                rgline[iMSO_ParentId].pb                = (BYTE *)&objidParentId;
                rgline[iMSO_ParentId].cb                = sizeof(objidParentId);
                rgline[iMSO_Name].pb                            = (BYTE *)szTable;
                rgline[iMSO_Name].cb                            = strlen(szTable);
                rgline[iMSO_Type].pb                            = (BYTE *)&objtyp;
                rgline[iMSO_Type].cb                            = sizeof(objtyp);
                rgline[iMSO_DateCreate].pb              = (BYTE *)&dtNow;
                rgline[iMSO_DateCreate].cb              = sizeof(JET_DATESERIAL);
                rgline[iMSO_DateUpdate].pb              = (BYTE *)&dtNow;
                rgline[iMSO_DateUpdate].cb              = sizeof(JET_DATESERIAL);
                rgline[iMSO_Rgb].cb                             = 0;
                rgline[iMSO_Lv].cb                              = 0;
                rgline[iMSO_Owner].cb                   = 0;
                rgline[iMSO_Database].cb                = 0;
                rgline[iMSO_Connect].cb                 = 0;
                rgline[iMSO_ForeignName].cb     = 0;
                rgline[iMSO_RmtInfoShort].cb    = 0;
                rgline[iMSO_RmtInfoLong].cb     = 0;
                rgline[iMSO_Flags].pb                   = (BYTE *) &flags;
                rgline[iMSO_Flags].cb                   = sizeof(ULONG);
                rgline[iMSO_LvExtra].cb                 = 0;
                rgline[iMSO_Description].cb     = 0;
                rgline[iMSO_LvModule].cb                = 0;
                rgline[iMSO_LvProp].cb                  = 0;
                rgline[iMSO_Pages].pb                   = (BYTE *) &ulPages;
                rgline[iMSO_Pages].cb                   = sizeof(ulPages);
                rgline[iMSO_Density].pb                 = (BYTE *) &ulDensity;
                rgline[iMSO_Density].cb                 = sizeof(ulDensity);
                Call( ErrSysTabInsert( ppib, dbid, itableSo, rgline, objidTable ) );
                }
#endif  /* SYSTABLES */

        /*      open table in exclusive mode, for output parameter
        /**/
        Call( ErrFILEOpenTable( ppib, dbidAdjust, ppfucb, szName, JET_bitTableDenyRead ) );

        FCBSetDenyDDL( (*ppfucb)->u.pfcb, ppib );
        err = ErrVERFlag( *ppfucb, operCreateTable, NULL, 0 );
        if ( err < 0 )
                {
                FCBResetDenyDDL( (*ppfucb)->u.pfcb );
                goto HandleError;
                }
        FUCBSetVersioned( *ppfucb );

//      /* build empty STATS node for clustered index
//      /**/
//      Call( ErrIsamComputeStats( ppib, *ppfucb ) );

        Call( ErrDIRCommitTransaction( ppib ) );

        return JET_errSuccess;

HandleError:
        /*      close performed by rollback
        /**/
        CallS( ErrDIRRollback( ppib ) );
        return err;
        }


//+API
// ErrIsamAddColumn
// ========================================================================
// ERR ErrIsamAddColumn(
//              PIB                             *ppib;                  // IN PIB of user
//              FUCB                            *pfucb;                 // IN Exclusively opened FUCB on file
//              CHAR                            *szName;                        // IN name of new field
//              JET_COLUMNDEF   *pcolumndef             // IN definition of column added
//              BYTE                            *pbDefault              //      IN Default value of column
//              ULONG                           cbDefault               // IN length of Default value
//              JET_COLUMNID    *pcolumnid )    // OUT columnid of added column
//
// Creates a new field definition for a file.
//
// PARAMETERS
//                              pcolumndef->coltyp                      data type of new field, see jet.h
//                              pcolumndef->grbit                               field describing flags:
//                                      VALUE                           MEANING
//                                      ========================================
//                                      JET_bitColumnNotNULL                            Indicates that the field may
//                                                                                                                      not take on NULL values.
//                                      JET_bitColumnTagged                             The field is a "tagged" field.
//                                      JET_bitColumnVersion                            The field is a version field
//                                      JET_bitColumnAutoIncrement              The field is a autoinc field
//
// RETURNS              JET_errSuccess                  Everything worked OK.
//                                      -TaggedDefault                  A default value was specified
//                                                                                              for a tagged field.
//                                      -ColumnDuplicate                There is already a field
//                                                                                              defined for the name given.
// COMMENTS
//              There must not be anyone currently using the file, unless
//              the ErrIsamAddColumn is at level 0 [when non-exclusive ErrIsamAddColumn works].
//              A transaction is wrapped around this function.  Thus, any
//              work done will be undone if a failure occurs.
//              Transaction logging is turned off for temporary files.
//
// SEE ALSO             ErrIsamCreateTable, ErrIsamCreateIndex
//-
ERR VTAPI ErrIsamAddColumn(
        PIB                             *ppib,
        FUCB                    *pfucb,
        CHAR                    *szName,
        JET_COLUMNDEF   *pcolumndef,
        BYTE                    *pbDefault,
        ULONG                   cbDefault,
        JET_COLUMNID    *pcolumnid )
        {
        CHAR                    szColumn[(JET_cbNameMost + 1)];
        FIELDDATA               fielddata;
        FIELDDEFDATA    *pfdd = NULL;
        KEY                             key;
        LINE                    line;
        ERR                             err;
        BYTE                    rgbColumnNorm[ JET_cbKeyMost ];
        FCB                             *pfcb;
//      FDB                             *pfdbSav;
        LINE                    lineDefault;
        LINE                    *plineDefault;
        JET_COLTYP              coltyp;
        ULONG                   ulLength;
        USHORT                  cp = pcolumndef->cp;
        LANGID                  langid = (LANGID)pcolumndef->langid;
        WORD                    wCountry = (WORD)pcolumndef->wCountry;
//      BOOL                    fFDBConstruct = fFalse;
        BOOL                    fMaxTruncated = fFalse;

#ifdef  SYSTABLES
        BOOL                            fDoSTI;
#endif  /* SYSTABLES */

        /* check paramaters
        /**/
        CheckPIB( ppib );
        CheckTable( ppib, pfucb );
        CallR( ErrCheckName( szColumn, szName, (JET_cbNameMost + 1) ) );

        /* ensure that table is updatable */
        /**/
        CallR( FUCBCheckUpdatable( pfucb )  );

#ifdef  SYSTABLES
        /*      set fDoSTI and fix DBID...
        /**/
        if ( pfucb->dbid >= dbidMax )
                {
                pfucb->dbid -= dbidMax;
                fDoSTI = 0;
                }
        else
                fDoSTI = 1;

        if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
                fDoSTI = 0;
#endif  /* SYSTABLES */

        if ( pcolumndef->cbStruct < sizeof(JET_COLUMNDEF) )
                return JET_errInvalidParameter;
        coltyp = pcolumndef->coltyp;

        /*      if column type is text then check code page and language id
        /**/
        if ( ( coltyp == JET_coltypText || coltyp == JET_coltypLongText ) )
                {
                /*      check code page
                /**/
                if ( cp != usEnglishCodePage && cp != usUniCodePage )
                        {
                        return JET_errInvalidParameter;
                        }

                /*      check language id
                /**/
                CallR( ErrSysCheckLangid( langid ) );
                }

        ulLength = pcolumndef->cbMax;

        if ( cbDefault > 0 )
                {
                lineDefault.cb = cbDefault;
                lineDefault.pb = (void *)pbDefault;
                plineDefault = &lineDefault;
                }
        else
                {
                plineDefault = NULL;
                }

        if ( pcolumndef->grbit & JET_bitColumnTagged )
                {
                if ( CbLine( plineDefault ) > 0 )
                        return JET_errTaggedDefault;
                if ( pcolumndef->grbit & JET_bitColumnNotNULL )
                        return JET_errTaggedNotNULL;
                }

        Assert( ppib != ppibNil );
        Assert( pfucb != pfucbNil );
        CheckTable( ppib, pfucb );
        Assert( pfucb->u.pfcb != pfcbNil );
        pfcb = pfucb->u.pfcb;

        /*      normalize column name
        /**/
        SysNormText( szColumn, strlen( szColumn ), rgbColumnNorm, sizeof( rgbColumnNorm ), &key.cb );
        key.pb = rgbColumnNorm;

        CallR( ErrDIRBeginTransaction( ppib ) );

        if ( FFCBDenyDDL( pfcb, ppib ) )
                {
                /* abort if DDL modification in progress
                /**/
                err = JET_errWriteConflict;
                goto HandleError;
                }
        FCBSetDenyDDL( pfcb, ppib );

        err = ErrVERFlag( pfucb, operAddColumn, (VOID *)&pfcb->pfdb, sizeof(pfcb->pfdb) );
        if ( err < 0 )
                {
                FCBResetDenyDDL( pfcb );
                goto HandleError;
                }

        /*      move to FDP root and update FDP timestamp
        /**/
        Assert( pfucb->ppib->level < levelMax );
        DIRGotoFDPRoot( pfucb );
        Call( ErrFILEIUpdateFDPData( pfucb, fDDLStamp ) );

        /*      down to "FIELDS" node.  Cache node data in fielddata.
        /**/
        Call( ErrDIRSeekPath( pfucb, 1, pkeyFields, 0 ) );
        Call( ErrDIRGet( pfucb ) );
        fielddata = *(UNALIGNED FIELDDATA *)pfucb->lineData.pb;

        /*      field should not already exist
        /**/
        err = ErrDIRSeekPath( pfucb, 1, &key, 0 );
        Assert( err != JET_errNoCurrentRecord );
        if (err >= 0)
                {
                err = JET_errColumnDuplicate;
                goto HandleError;
                }
        if (err != JET_errRecordNotFound)
                goto HandleError;

        if ( ( pfdd = SAlloc( sizeof(FIELDDEFDATA) + CbLine( plineDefault ) - 1 ) ) == NULL )
                {
                err = JET_errOutOfMemory;
                goto HandleError;
                }

        if ( coltyp == 0 || coltyp > JET_coltypLongText )
                {
                err = JET_errInvalidColumnType;
                goto HandleError;
                }

        /*      set field parameters
        /**/
        pfdd->bFlags = 0;

        if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement )
                && ( pcolumndef->grbit & JET_bitColumnVersion ) )
                {
                /* mutual exclusive
                /**/
                err = JET_errInvalidParameter;
                goto HandleError;
                }

        /*      if column attribute is JET_bitVersion
        /*      return error if previous column attribute has been defined
        /*      return error if column type is not long
        /*      set column flag
        /**/
        if ( ( pcolumndef->grbit & JET_bitColumnVersion ) != 0 )
                {
                if ( pfcb->pfdb->fidVersion != 0 )
                        {
                        err = JET_errColumn2ndSysMaint;
                        goto HandleError;
                        }
                if ( coltyp != JET_coltypLong )
                        {
                        err = JET_errInvalidParameter;
                        goto HandleError;
                        }
                /*      autoincrement cannot be tagged
                /**/
                if ( pcolumndef->grbit & JET_bitColumnTagged )
                        {
                        err = JET_errCannotBeTagged;
                        goto HandleError;
                        }
                pfdd->bFlags |= ffieldVersion;
                }


        /*      if column attribute is JET_bitAutoincrement
        /*      return error if previous column attribute has been defined
        /*      return error if column type is not long
        /*      set column flag
        /**/
        if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement ) != 0 )
                {
                /*      it is an autoinc column that we want to add
                /**/
                if ( pfcb->pfdb->fidAutoInc != 0 )
                        {
                        /*      there is already an autoinc column for the table.
                        /*      and we don't allow two autoinc columns for one table.
                        /**/
                        err = JET_errColumn2ndSysMaint;
                        goto HandleError;
                        }
                if ( coltyp != JET_coltypLong )
                        {
                        err = JET_errInvalidParameter;
                        goto HandleError;
                        }
                /*      autoincrement cannot be tagged
                /**/
                if ( pcolumndef->grbit & JET_bitColumnTagged )
                        {
                        err = JET_errCannotBeTagged;
                        goto HandleError;
                        }
                pfdd->bFlags |= ffieldAutoInc;
                }

        pfdd->bColtyp = (BYTE) coltyp;
        if ( coltyp == JET_coltypText || coltyp == JET_coltypLongText )
                {
                pfdd->cp                  =  cp;
                pfdd->langid  =  langid;
                pfdd->wCountry = wCountry;
                }

        if ( pcolumndef->grbit & JET_bitColumnNotNULL )
                pfdd->bFlags |= ffieldNotNull;

        if ( pcolumndef->grbit & JET_bitColumnMultiValued )
                pfdd->bFlags |= ffieldMultivalue;

        // ====================================================
        // Determine maximum field length as follows:
        // switch (field type)
        //         case numeric:
        //                 max = <exact length of specified type>;
        //         case "short" textual (Text || CaseText || Binary ):
        //                 if (specified max == 0 ) max = JET_cbColumnMost
        //                 else max = MIN( JET_cbColumnMost, specified max )
        //         case "long" textual (Memo || Graphic ):
        //                 max = specified max (if 0, unlimited )
        //====================================================
        switch ( coltyp )
                {
                case JET_coltypBit:
                case JET_coltypUnsignedByte:
                        pfdd->ulLength = 1;
                        break;
                case JET_coltypShort:
                        pfdd->ulLength = 2;
                        break;
                case JET_coltypLong:
                case JET_coltypIEEESingle:
                        pfdd->ulLength = 4;
                        break;
                case JET_coltypCurrency:
                case JET_coltypIEEEDouble:
                case JET_coltypDateTime:
                        pfdd->ulLength = 8;
                        break;
                case JET_coltypBinary:
                case JET_coltypText:
                        if ( ulLength == 0 )
                                pfdd->ulLength = JET_cbColumnMost;
                        else if ((pfdd->ulLength = ulLength ) > JET_cbColumnMost )
                                {
                                pfdd->ulLength = JET_cbColumnMost;
                                fMaxTruncated = fTrue;
                                }
                        break;
                case JET_coltypLongBinary:
                case JET_coltypLongText:
                        pfdd->ulLength = ulLength;
                        break;
                }

        if ( ( pfdd->cbDefault = CbLine( plineDefault ) ) > 0 )
                memcpy( pfdd->rgbDefault, plineDefault->pb, plineDefault->cb );
        strcpy( pfdd->szFieldName, szColumn );

        //====================================================
        // Determine field "mode" as follows:
        // if ("long" textual || JET_bitColumnTagged given ) ==> TAGGED
        // else if (numeric type || JET_bitColumnFixed given ) ==> FIXED
        // else ==> VARIABLE
        //====================================================
        if ( coltyp == JET_coltypLongBinary ||
                coltyp == JET_coltypLongText ||
                ( pcolumndef->grbit & JET_bitColumnTagged ) )
                {
                pfdd->fid = ++fielddata.fidTaggedLast;
                if ( pfdd->fid > fidTaggedMost )
                        Call( JET_errTooManyColumns );
                }
        else if ( ( pcolumndef->grbit & JET_bitColumnFixed ) ||
                         coltyp == JET_coltypBit ||
                         coltyp == JET_coltypUnsignedByte ||
                         coltyp == JET_coltypShort ||
                         coltyp == JET_coltypLong ||
                         coltyp == JET_coltypCurrency ||
                         coltyp == JET_coltypIEEESingle ||
                         coltyp == JET_coltypIEEEDouble ||
                         coltyp == JET_coltypDateTime )
                {
                pfdd->fid = ++fielddata.fidFixedLast;
                if ( pfdd->fid > fidFixedMost )
                        Call( JET_errTooManyFixedColumns );
                }
        else
                {
                pfdd->fid = ++fielddata.fidVarLast;
                if ( pfdd->fid > fidVarMost )
                        Call( JET_errTooManyVariableColumns );
                }

        /*      replace "FIELDS" node data with updated version
        /**/
        line.cb = sizeof(FIELDDATA);
        line.pb = (BYTE *)&fielddata;
        Call( ErrDIRReplace( pfucb, &line, fDIRVersion ) );

        /*      add field descriptor node, go back to "FIELDS" node
        /*      "key" still points to the case-folded field name
        /**/
        line.pb = (BYTE *)  pfdd;
        line.cb = sizeof( *pfdd ) + pfdd->cbDefault - 1;
        Call( ErrDIRInsert( pfucb, &line, &key, fDIRVersion ) );
        DIRUp( pfucb, 1 );

        if ( pcolumnid != NULL )
                *pcolumnid = (JET_COLUMNID)pfdd->fid;

        /*      rebuild FDB and default record value
        /**/
//      pfdbSav = pfcb->pfdb;
        Call( ErrDIRGet( pfucb ) );
        Call( ErrFDBConstruct( pfucb, pfcb, fTrue/*fBuildDefault*/ ) );
//      fFDBConstruct = fTrue;

        /*      set currencies at BeforeFirst
        /**/
        DIRUp( pfucb, 1 );
        DIRBeforeFirst( pfucb );
        if ( pfucb->pfucbCurIndex != pfucbNil )
                {
                DIRBeforeFirst( pfucb->pfucbCurIndex );
                }

#ifdef  SYSTABLES
        /*      insert column record into MSC before committing...
        /**/
        if ( fDoSTI )
                {
                LINE                            rgline[ilineSxMax];
                JET_TABLEID             objidTable                      =       pfucb->u.pfcb->pgnoFDP;
                BYTE                            coltypTemp                      =       (BYTE) coltyp;
                JET_COLUMNID    columnid                                =       (JET_COLUMNID)pfdd->fid;
                BYTE                            fAutoincrement          =       (BYTE) ( ( pcolumndef->grbit & JET_bitColumnAutoincrement ) ? 0xff : 0x00 );
                BYTE                            fRestricted                     =       0;
                BYTE                            fDisallowNull           =       0;
                BYTE                            fVersion                                =       (BYTE)( pcolumndef->grbit & JET_bitColumnVersion );
                LONG                            lPOrder;

                /*      set presentation order from number of existing columns
                /**/
#ifdef CHRONOLOGICAL_PRESENTATION_ORDER
                lPOrder = ( fielddata.fidFixedLast == fidFixedLeast - 1 ?
                        0 : fielddata.fidFixedLast - fidFixedLeast + 1 ) +
                        ( fielddata.fidVarLast == fidVarLeast - 1 ?
                        0 : fielddata.fidVarLast - fidVarLeast + 1 ) +
                        ( fielddata.fidTaggedLast == fidTaggedLeast - 1 ?
                        0 : fielddata.fidTaggedLast - fidTaggedLeast + 1 );
#else
                lPOrder = 0;
#endif

                rgline[iMSC_ObjectId].pb                                = (BYTE *)&objidTable;
                rgline[iMSC_ObjectId].cb                                = sizeof(objidTable);
                rgline[iMSC_Name].pb                                            = szColumn;
                rgline[iMSC_Name].cb                                            = strlen(szColumn);
                rgline[iMSC_ColumnId].pb                                = (BYTE *)&columnid;
                rgline[iMSC_ColumnId].cb                                = sizeof(columnid);
                rgline[iMSC_Coltyp].pb                                  = &coltypTemp;
                rgline[iMSC_Coltyp].cb                                  = sizeof(coltypTemp);
                rgline[iMSC_FAutoincrement].pb          = &fAutoincrement;
                rgline[iMSC_FAutoincrement].cb          = sizeof(BYTE);
                rgline[iMSC_FDisallowNull].pb                   = &fDisallowNull;
                rgline[iMSC_FDisallowNull].cb                   = sizeof(BYTE);
                rgline[iMSC_FVersion].pb                                = &fVersion;
                rgline[iMSC_FVersion].cb                                = sizeof(BYTE);
                rgline[iMSC_CodePage].pb                                = (BYTE *)&cp;
                rgline[iMSC_CodePage].cb                                = sizeof(cp);
                rgline[iMSC_LanguageId].pb                              = (BYTE *)&langid;
                rgline[iMSC_LanguageId].cb                              = sizeof(langid);
                rgline[iMSC_Country].pb                                 = (BYTE *)&wCountry;
                rgline[iMSC_Country].cb                                 = sizeof(wCountry);
                rgline[iMSC_FRestricted].pb                     = &fRestricted;
                rgline[iMSC_FRestricted].cb                     = sizeof(BYTE);
                rgline[iMSC_RmtInfoShort].cb                    = 0;
                rgline[iMSC_RmtInfoLong].cb                     = 0;
                rgline[iMSC_Description].cb                     = 0;
                rgline[iMSC_LvExtra].cb                                 = 0;
                rgline[iMSC_POrder].pb                                  = (BYTE *)&lPOrder;
                rgline[iMSC_POrder].cb                                  = sizeof(lPOrder);

                Call( ErrSysTabInsert( ppib, pfucb->dbid, itableSc, rgline, objidTable ) );
                }
#endif  /* SYSTABLES */

        if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement ) != 0 )
                {
                DIB dib;

                dib.pos = posDown;
                dib.fFlags = fDIRNull;
                dib.pkey = &key;

                /*      it is an autoinc column that we want to add
                /*      make sure there are no data records
                /*      down to sequential node, down to Data node
                /**/
                DIRGotoFDPRoot( pfucb );
                Call( ErrDIRSeekPath( pfucb, 1, pkeyIndexes, 0 ) );
                Call( ErrDIRGet(pfucb) );

                /*      go down to the NULL node (for system-assigned clustering index )
                /*      or go down to the <clustering-index name> node (for user-defined
                /*      clustering index )
                /**/
                if ( FLineNull( &pfucb->lineData ) )
                        {
                        /* "sequential" file
                        /**/
                        pfcb->pidb = pidbNil;

                        /*      down to <NULL> node
                        /**/
                        Assert( dib.pos == posDown );
                        Assert( dib.fFlags == fDIRNull );
                        Assert( dib.pkey == &key );
                        key.cb = 0;
                        if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
                                {
                                if ( err > 0 )
                                        err = JET_errDatabaseCorrupted;
                                Error( err, HandleError );
                                }
                        }
                else
                        {
                        /*      file has clustering index
                        /**/
                        CHAR    rgbIndexName[(JET_cbNameMost + 1)];
                        ULONG   cbIndexName;

                        cbIndexName = pfucb->lineData.cb;
                        Assert( cbIndexName < ( JET_cbNameMost + 1 ) );
                        memcpy( rgbIndexName, pfucb->lineData.pb, cbIndexName );

                        /*      down to clustered index root
                        /**/
                        Assert( dib.pos == posDown );
                        Assert( dib.fFlags == fDIRNull );
                        Assert( dib.pkey == &key );
                        dib.pkey->cb = cbIndexName;
                        dib.pkey->pb = rgbIndexName;
                        if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errSuccess )
                                {
                                if ( err > 0 )
                                        err = JET_errDatabaseCorrupted;
                                Error( err, HandleError );
                                }
                        }

                /*      see if table is empty
                /**/
                Call( ErrDIRSeekPath( pfucb, 1, pkeyData, 0 ) );
                dib.pos = posFirst;
                err = ErrDIRDown( pfucb, &dib );
                if ( err < 0 && err != JET_errRecordNotFound )
                        {
                        goto HandleError;
                        }
                if ( err != JET_errRecordNotFound )
                        {
                        ULONG           ul = 1;
                        LINE            lineAutoInc;
                        FID             fidAutoIncTmp = pfucb->u.pfcb->pfdb->fidAutoInc;

                        do
                                {
                                Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepReplace ) );
                                PrepareInsert( pfucb );
                                Call( ErrIsamSetColumn( ppib, pfucb, (ULONG) fidAutoIncTmp, (BYTE *) &ul, sizeof(ul), 0, NULL ) );
                                PrepareReplace( pfucb );
                                Call( ErrIsamUpdate( ppib, pfucb, 0, 0, 0 ) );
                                ul++;
                                err = ErrIsamMove( ppib, pfucb, JET_MoveNext, 0 );
                                if ( err < 0 && err != JET_errNoCurrentRecord )
                                        goto HandleError;
                                }
                        while ( err != JET_errNoCurrentRecord );

                        /*      now ul has the correct value for the next autoinc field.
                        /*      replace the value in the autoinc node in FDP
                        /**/
                        // UNDONE: should be able to delete the loop
                        Assert( PcsrCurrent( pfucb ) != NULL );
                        while ( PcsrCurrent( pfucb )->pcsrPath != NULL )
                                {
                                DIRUp( pfucb, 1 );
                                }

                        /*      go down to AutoInc node
                        /**/
                        DIRGotoFDPRoot( pfucb );
                        err = ErrDIRSeekPath( pfucb, 1, pkeyAutoInc, 0 );
                        if ( err != JET_errSuccess )
                                {
                                if ( err > 0 )
                                        err = JET_errDatabaseCorrupted;
                                Error( err, HandleError );
                                }
                        lineAutoInc.pb = (BYTE *) &ul;
                        lineAutoInc.cb = sizeof(ul);
                        CallS( ErrDIRReplace( pfucb, &lineAutoInc, fDIRNoVersion ) );
                        }

                /*      leave currency as it was
                /**/
                Assert( PcsrCurrent( pfucb ) != NULL );
                while ( PcsrCurrent( pfucb )->pcsrPath != NULL )
                        {
                        DIRUp( pfucb, 1 );
                        }

                DIRBeforeFirst( pfucb );
                }

        Call( ErrDIRCommitTransaction( ppib ) );

        SFree( pfdd );
        pfdd = NULL;

        /*      update all index mask.
        /**/
        FILESetAllIndexMask( pfcb );

        return fMaxTruncated ? JET_wrnColumnMaxTruncated : JET_errSuccess;

HandleError:
        if ( pfdd != NULL )
                {
                SFree( pfdd );
                }

        CallS( ErrDIRRollback( ppib ) );

        return err;
        }


ERR ErrFILEIUpdateFDPData( FUCB *pfucb, ULONG grbit )
        {
#define cbFDPDataMax    256
        ERR             err;
        BYTE            rgbData[ cbFDPDataMax ];
        LINE            line;

        Call( ErrDIRGet( pfucb ) );

        Assert( pfucb->lineData.cb <= sizeof rgbData );
        Assert( pfucb->lineData.cb > 2 * sizeof(WORD) + 2 * sizeof(JET_DATESERIAL) );
        line.pb = rgbData;
        LineCopy( &line, &pfucb->lineData );

        if ( grbit & fBumpIndexCount )
                *(WORD *)rgbData += 1;
        if ( grbit & fDropIndexCount )
                *(WORD *)rgbData -= 1;
        if ( grbit & fDDLStamp )
                {
                JET_DATESERIAL dtNow;
                UtilGetDateTime( &dtNow );
                memcpy( rgbData + 2 * sizeof(WORD) + sizeof(JET_DATESERIAL), &dtNow, sizeof(JET_DATESERIAL) );
                }
        err = ErrDIRReplace( pfucb, &line, fDIRVersion );

HandleError:
        return err;
        }



//+API
// ErrIsamCreateIndex
// ========================================================================
// ERR ErrIsamCreateIndex(
//              PIB             *ppib;                  // IN   PIB of user
//              FUCB    *pfucb;                 // IN   Exclusively opened FUCB of file
//              CHAR    *szName;                // IN   name of index to define
//              ULONG   ulFlags;                // IN   index describing flags
//              CHAR    *szKey;                 // IN   index key string
//              ULONG   cchKey;
//              ULONG   ulDensity );    // IN   loading density of index
//
//      Defines an index on a file.
//
// PARAMETERS
//              ppib            PIB of user
//              pfucb           Exclusively opened FUCB of file
//              szName          name of index to define
//              ulFlags         index describing flags
//                      VALUE                           MEANING
//                      ========================================
//                      JET_bitIndexPrimary             This index is to be the primary
//                                                                      index on the data file.  The file
//                                                                      must be empty, and there must not
//                                                                      already be a primary index.
//                      JET_bitIndexUnique              Duplicate entries are not allowed.
//                      JET_bitIndexIgnoreNull  Null keys are not to be indexed.
//                      ulDensity                               load density of index
//
// RETURNS      Error code from DIRMAN or
//                      JET_errSuccess                  Everything worked OK.
//                      -JET_errColumnNotFound  The index key specified
//                                                                      contains an undefined field.
//                      -IndexHasPrimary                The primary index for this
//                                                                      Insertfile is already defined.
//                      -IndexDuplicate                 An index on this file is
//                                                                      already defined with the
//                                                                      given name.
//                      -IndexInvalidDef                There are too many segments
//                                                                      in the key.
//                      -TableNotEmpty                  A primary index may not be
//                                                                      defined because there is at
//                                                                      least one record already in
//                                                                      the file.
// COMMENTS
//              If transaction level > 0, there must not be anyone currently
//              using the file.
//              A transaction is wrapped around this function.  Thus, any
//              work done will be undone if a failure occurs.
//
// SEE ALSO             ErrIsamAddColumn, ErrIsamCreateTable
//-
ERR VTAPI ErrIsamCreateIndex(
        PIB                                     *ppib,
        FUCB                            *pfucb,
        CHAR                            *szName,
        ULONG                           grbit,
        CHAR                            *szKey,
        ULONG                           cchKey,
        ULONG                           ulDensity )
        {
        CHAR                            szIndex[ (JET_cbNameMost + 1) ];
        FCB                                     *pfcbIdx = pfcbNil;
        INT                                     cFields;
        char                            *rgsz[JET_ccolKeyMost];
        const BYTE                      *pb;
        BYTE                            rgfbDescending[JET_ccolKeyMost];
        INDEXDEFDATA            idd;
        INT                                     iidxseg;
        FID                                     fid;
        BOOL                            fClustered = ((grbit & JET_bitIndexClustered) != 0);
        KEY                                     keyIndex;
        KEY                                     line;
        ERR                                     err;
        PGNO                            pgnoIdxRoot;
        INT                                     itagIdxRoot;
        BYTE                            rgbIndexNorm[ JET_cbKeyMost ];
        FCB                                     *pfcb;
        BOOL                            fVersion;
        //      UNDONE: get language information from database
        LANGID                          langid = 0x409;
        BOOL                            fLangid = fFalse;

#ifdef  SYSTABLES
        BOOL                            fDoSTI;

        /* do not allow clustered indexes with any Ignore bits on
        /**/
        if ( fClustered && ( grbit & JET_bitIndexIgnoreAnyNull || grbit & JET_bitIndexIgnoreNull ) )
                return JET_errInvalidParameter;

        /*      set fDoSTI and fix DBID...
        /**/
        if ( pfucb->dbid >= dbidMax )
                {
                pfucb->dbid -= dbidMax;
                fDoSTI = 0;
                }
        else
                fDoSTI = 1;

        if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
                fDoSTI = 0;
#endif  /* SYSTABLES */

        /* ensure that table is updatable
        /**/
        CallR( FUCBCheckUpdatable( pfucb )  );

        Assert ( !FFUCBNonClustered( pfucb ) );

        /*      check parms
        /**/
        CheckPIB( ppib );
        CheckTable( ppib, pfucb );

        /*      check index name
        /**/
        CallR( ErrCheckName( szIndex, szName, (JET_cbNameMost + 1) ) );

        /*      check index description for required format.
        /**/
        if ( cchKey == 0 )
                return JET_errInvalidParameter;
        if ( ( szKey[0] != '+' && szKey[0] != '-' ) ||
                szKey[cchKey - 1] != '\0' ||
                szKey[cchKey - 2] != '\0' )
                {
                return JET_errIndexInvalidDef;
                }
        Assert( szKey[cchKey - 1] == '\0' );
        Assert( szKey[cchKey - 2] == '\0' );

        Assert( pfucb->u.pfcb != pfcbNil );
        pfcb = pfucb->u.pfcb;
        if ( ulDensity == 0 )
                ulDensity = ulDefaultDensity;
        if ( ulDensity < ulFILEDensityLeast || ulDensity > ulFILEDensityMost )
                return JET_errDensityInvalid;

        cFields = 0;
        pb = szKey;
        while ( *pb != '\0' )
                {
                if ( cFields >= JET_ccolKeyMost )
                        return JET_errIndexInvalidDef;
                if ( *pb == '-' )
                        {
                        rgfbDescending[cFields] = 1;
                        pb++;
                        }
                else
                        {
                        rgfbDescending[cFields] = 0;
                        if ( *pb == '+' )
                                pb++;
                        }
                rgsz[cFields++] = (char *) pb;
                pb += strlen( pb ) + 1;
                }
        if ( cFields < 1 )
                return JET_errIndexInvalidDef;

        /*      get locale from end of szKey if present
        /**/
        pb++;
        Assert( pb > szKey );
        if ( (unsigned)( pb - szKey ) < cchKey )
                {
                if ( pb - szKey + sizeof(LANGID) + 2 * sizeof(BYTE) == cchKey )
                        {
                        langid = *((UNALIGNED LANGID *)(pb));
                        CallR( ErrSysCheckLangid( langid ) );
                        fLangid = fTrue;
                        }
                else
                        return JET_errIndexInvalidDef;
                }

        /* return an error if this is a second primary index definition
        /**/
        if ( grbit & JET_bitIndexPrimary )
                {
                FCB *pfcbNext = pfcb;

                while ( pfcbNext != pfcbNil )
                        {
                        if ( pfcbNext->pidb != pidbNil && ( pfcbNext->pidb->fidb & fidbPrimary ) )
                                {
                                // If that primary index is not already deleted transaction
                                // but not yet committed.
                                if ( !FFCBDeletePending( pfcbNext ) )
                                        return JET_errIndexHasPrimary;
                                else
                                        // can break because there can only be one Primary index
                                        break;
                                }
                        Assert( pfcbNext != pfcbNext->pfcbNextIndex );
                        pfcbNext = pfcbNext->pfcbNextIndex;
                        }
                }

        /*      normalize index name and set key
        /**/
        SysNormText( szIndex, strlen( szIndex ), rgbIndexNorm, sizeof( rgbIndexNorm ), &keyIndex.cb );
        keyIndex.pb = rgbIndexNorm;

        CallR( ErrDIRBeginTransaction( ppib ) );

        if ( FFCBDenyDDL( pfcb, ppib ) )
                {
                /* abort if DDL modification in progress
                /**/
                err = JET_errWriteConflict;
                Call( err );
                }
        FCBSetDenyDDL( pfcb, ppib );

        /*      allocate FCB for index
        /**/
        pfcbIdx = NULL;
        if ( !fClustered )
                {
                err = ErrFCBAlloc( ppib, &pfcbIdx );
                if ( err < 0 )
                        {
                        FCBResetDenyDDL( pfcb );
                        goto HandleError;
                        }
                }

        /* wait for bookmark cleanup
        /* UNDONE: decouple operation from other index creations
        /**/
        while ( FFCBDomainOperation( pfcb ) )
                {
                BFSleep( cmsecWaitGeneric );
                }
        FCBSetDomainOperation( pfcb );
                
        /*      create index is flagged in version store so that
        /*      DDL will be undone.  If flag fails then pfcbIdx
        /*      must be released.
        /**/
        err = ErrVERFlag( pfucb, operCreateIndex, &pfcbIdx, sizeof(pfcbIdx) );
        if ( err < 0 )
                {
                FCBResetDenyDDL( pfcb );
                if ( !fClustered )
                        {
                        Assert( pfcbIdx != NULL );
                        Assert( pfcbIdx->cVersion == 0 );
                        MEMReleasePfcb( pfcbIdx );
                        }
                goto HandleError;
                }

        if ( ppib->level == 1 )
                {
                WaitTillOldest( ppib->trx );
                }

        /*      move to FDP root
        /**/
        DIRGotoFDPRoot( pfucb );

        /*      if this is not the clustered index, increment the index count
        /**/
        if ( !fClustered )
                {
                Call( ErrFILEIUpdateFDPData( pfucb, fBumpIndexCount | fDDLStamp ) );
                }

        /*      goto fields to get FID's
        /**/
        Call( ErrDIRSeekPath( pfucb, 1, pkeyFields, 0 ) );

        /*      get FID for each field
        /**/
        for ( iidxseg = 0 ; iidxseg < cFields ; ++iidxseg )
                {
                BYTE                    rgbColumnNorm[ JET_cbKeyMost ];
                KEY                     keyColumn;
                JET_COLTYP      coltyp;

                /*      normalize column name set key
                /**/
                SysNormText( rgsz[iidxseg], strlen( rgsz[iidxseg] ), rgbColumnNorm, sizeof( rgbColumnNorm ), &keyColumn.cb );
                keyColumn.pb = rgbColumnNorm;

                err = ErrDIRSeekPath( pfucb, 1, &keyColumn, 0 );
                Assert( err != JET_errNoCurrentRecord );
                if ( err < 0 )
                        {
                        if (err == JET_errRecordNotFound)
                                err = JET_errColumnNotFound;
                        goto HandleError;
                        }
                fid = ((FIELDDEFDATA *)pfucb->lineData.pb)->fid;
                coltyp = (JET_COLTYP)((FIELDDEFDATA *)pfucb->lineData.pb )->bColtyp;
//              if ( coltyp == JET_coltypLongBinary     || coltyp == JET_coltypLongText )
//                      {
//                      err = JET_errColumnCannotIndex;
//                      goto HandleError;
//                      }
                idd.rgidxseg[iidxseg] = rgfbDescending[iidxseg] ? -fid : fid;
                DIRUp( pfucb, 1 );
                }

        /*      go over to "INDEXES"
        /**/
        DIRUp( pfucb, 1 );
        Call( ErrDIRSeekPath( pfucb, 1, pkeyIndexes, 0 ) );

        /*      add index, checking for duplicate definition
        /**/
        idd.iidxsegMac = (BYTE)cFields;
        idd.bDensity = (BYTE)ulDensity;
        idd.bFlags = 0;
        if ( grbit & JET_bitIndexPrimary )
                idd.bFlags |= fidbPrimary | fidbUnique | fidbNoNullSeg;
        if ( grbit & JET_bitIndexUnique )
                idd.bFlags |= fidbUnique;
        if ( grbit & JET_bitIndexDisallowNull )
                idd.bFlags |= fidbNoNullSeg;
        if ( ! ( idd.bFlags & fidbNoNullSeg ) && !( grbit & JET_bitIndexIgnoreAnyNull ) )
                {
                idd.bFlags |= fidbAllowSomeNulls;
                if ( !( grbit & JET_bitIndexIgnoreNull ) )
                        idd.bFlags |= fidbAllowAllNulls;
                }
        strcpy( idd.szIndexName, szIndex );

        /*      set locale information
        /**/
        //      UNDONE: idd should not have a code page
        //      UNDONE: idd should not have a country code
        idd.cp = 0;
        idd.wCountry = 0;
        if ( fLangid )
                {
                idd.bFlags |= fidbLangid;
                idd.langid = langid;
                }
        else
                {
                Assert( ( idd.bFlags & fidbLangid ) == 0 );
                idd.langid = 0;
                }

        line.pb = (BYTE *)&idd;
        line.cb = (UINT)((BYTE *)( idd.rgidxseg + cFields ) - (BYTE *)&idd);
        if ( fClustered )
                {
                err = ErrDIRInsert( pfucb, &line, &keyIndex, fDIRVersion );
                /*      polymorph error.
                /**/
                if ( err < 0 )
                        {
                        if ( err == JET_errKeyDuplicate )
                                err = JET_errIndexDuplicate;
                        goto HandleError;
                        }

                fVersion = fDIRVersion;
                }
        else
                {
                err = ErrDIRInsertFDP( pfucb, &line, &keyIndex, fDIRVersion, (CPG)0 );
                /*      polymorph error.
                /**/
                if ( err < 0 )
                        {
                        if ( err == JET_errKeyDuplicate )
                                err = JET_errIndexDuplicate;
                        goto HandleError;
                        }

                fVersion = fDIRNoVersion;

                /*      index/OLCStats
                /**/
                line.pb = (BYTE *) &olcStatsInit;
                line.cb = sizeof( olcStatsInit );
                Call( ErrDIRInsert( pfucb, &line, pkeyOLCStats, fDIRNoVersion | fDIRBackToFather) );
                }

        /*      index/data
        /**/
        Call( ErrDIRInsert( pfucb, &lineNull, pkeyData, fVersion ) );
        pgnoIdxRoot = PcsrCurrent( pfucb )->pgno;
        itagIdxRoot = PcsrCurrent( pfucb )->itag;

        DIRUp( pfucb, 2 );

        /*      deal with clustered index definition
        /**/
        if ( fClustered )
                {
                DIB dib;

                Call( ErrDIRGet( pfucb ) );

                /*      if lineData.cb then clustered index already defined
                /**/
                if ( pfucb->lineData.cb != 0 )
                        {
                        err = JET_errIndexHasClustered;
                        goto HandleError;
                        }

                /*      replace NULL data with clustered index key
                /**/
                line.pb = keyIndex.pb;
                line.cb = keyIndex.cb;
                Call( ErrDIRReplace( pfucb, &line, fVersion ) );

                /*      down to sequential node, down to Data node
                /**/
                Call( ErrDIRSeekPath( pfucb, 1, (KEY *) &lineNull, 0 ) );
                Call( ErrDIRSeekPath( pfucb, 1, pkeyData, 0 ) );

                /*      make sure there are no data records
                /**/
                dib.pos = posFirst;
                if ( ( err = ErrDIRDown(pfucb, &dib ) ) != JET_errRecordNotFound )
                        {
                        err = JET_errTableNotEmpty;
                        goto HandleError;
                        }

                /*      up to NULL and delete.  Delete should delete all
                /*      decendants of NULL.
                /**/
                DIRUp( pfucb, 1 );
                Call( ErrDIRDelete( pfucb, fVersion ) );
                DIRUp( pfucb, 1 );
                }

#ifdef  SYSTABLES
        /*      insert index record into MSysIndexes before committing.
        /**/
        if ( fDoSTI )
                {
                LINE    rgline[ilineSxMax];
                OBJID   objidTable              = pfucb->u.pfcb->pgnoFDP;
                BOOL    fUnique                 = grbit & JET_bitIndexUnique;
                BOOL    fPrimary                        = grbit & JET_bitIndexPrimary;
                BOOL    fDisallowNull   = grbit & JET_bitIndexDisallowNull;
                BOOL    fIgnoreNull             = grbit & JET_bitIndexIgnoreNull;
                BOOL    fClustered              = grbit & JET_bitIndexClustered;

                rgline[iMSI_ObjectId].pb                                        = (BYTE *)&objidTable;
                rgline[iMSI_ObjectId].cb                                        = sizeof(objidTable);
                rgline[iMSI_Name].pb                                                    = szIndex;
                rgline[iMSI_Name].cb                                                    = strlen(szIndex);
                rgline[iMSI_FUnique].pb                                         = (BYTE *)&fUnique;
                rgline[iMSI_FUnique].cb                                         = sizeof(BYTE);
                rgline[iMSI_FPrimary].pb                                        = (BYTE *)&fPrimary;
                rgline[iMSI_FPrimary].cb                                        = sizeof(BYTE);
                rgline[iMSI_FDisallowNull].pb                           = (BYTE *)&fDisallowNull;
                rgline[iMSI_FDisallowNull].cb                           = sizeof(BYTE);
                rgline[iMSI_FExcludeAllNull].pb                 = (BYTE *)&fIgnoreNull;
                rgline[iMSI_FExcludeAllNull].cb                 = sizeof(BYTE);
                rgline[iMSI_FClustered].pb                              = (BYTE *)&fClustered;
                rgline[iMSI_FClustered].cb                              = sizeof(BYTE);
                rgline[iMSI_MatchType].cb                               = 0;
                rgline[iMSI_UpdateAction].cb                    = 0;
                rgline[iMSI_DeleteAction].cb                    = 0;
                rgline[iMSI_ObjectIdReference].cb               = 0;
                rgline[iMSI_IdxidReference].cb                  = 0;
                rgline[iMSI_RgkeydReference].cb                 = 0;
                rgline[iMSI_RglocaleReference].cb               = 0;
                rgline[iMSI_FDontEnforce].cb                    = 0;
                rgline[iMSI_RmtInfoShort].cb                    = 0;
                rgline[iMSI_RmtInfoLong].cb                     = 0;
                rgline[iMSI_LvExtra].cb                                         = 0;
                rgline[iMSI_Description].cb                             = 0;
                rgline[iMSI_Density].pb                                         = (BYTE *) &ulDensity;
                rgline[iMSI_Density].cb                                         = sizeof(ulDensity);
//              rgline[iMSI_LanguageId].pb                                      = (BYTE *)&langid;
//              rgline[iMSI_LanguageId].cb                                      = sizeof(langid);
                Call( ErrSysTabInsert( ppib, pfucb->dbid, itableSi, rgline, objidTable ) );
                }
#endif  /* SYSTABLES */

        /*      now at "INDEXES" node
        /**/
        if ( fClustered )
                {
                /*      remove extra CSR
                /**/
                DIRUp( pfucb, 1 );
                Call( ErrRECNewIDB( &pfcb->pidb ) );
                Call( ErrRECAddKeyDef(
                        (FDB *)pfcb->pfdb,
                        pfcb->pidb,
                        idd.iidxsegMac,
                        idd.rgidxseg,
                        idd.bFlags,
                        idd.langid ) );
                strcpy( pfcb->pidb->szName, szIndex );
                pfcb->pgnoRoot = pgnoIdxRoot;
                pfcb->itagRoot = itagIdxRoot;
                pfcb->bmRoot = SridOfPgnoItag( pgnoIdxRoot, itagIdxRoot );
                pfcb->cbDensityFree = ( ( 100 - idd.bDensity ) * cbPage ) / 100;

                /*      replace empty sequential STATS with empty clustered stats
                /**/
                //      UNDONE: defer creation of index stats when
                //                              movable DATA node
                Call( ErrSTATComputeIndexStats( ppib, pfcb ) );

                /*      restore current to BeforeFirst
                /**/
                DIRBeforeFirst( pfucb );
                }
        else
                {
                Call( ErrDIRSeekPath( pfucb, 1, &keyIndex, 0 ) );
                Call( ErrFILEIFillIn2ndIdxFCB( pfucb, (FDB *)pfcb->pfdb, pfcbIdx ) );
                pfcbIdx->pfcbNextIndex = pfcb->pfcbNextIndex;
                pfcb->pfcbNextIndex = pfcbIdx;
                DIRUp( pfucb, 2 );

                /*      build STATS node for new index
                /**/
                //      UNDONE: defer creation of index stats when
                //                              movable DATA node
                Call( ErrSTATComputeIndexStats( ppib, pfcbIdx ) );

                /*      move currency to before first
                /**/
                DIRBeforeFirst( pfucb );
                }

        if ( !fClustered )
                {
                Call( ErrFILEBuildIndex( ppib, pfucb, szIndex ) );
                }

        Call( ErrDIRCommitTransaction( ppib ) );

        /*      update all index mask.
        /**/
        FILESetAllIndexMask( pfcb );
        FCBResetDomainOperation( pfcb );

        return err;

HandleError:
        CallS( ErrDIRRollback( ppib ) );
        FCBResetDomainOperation( pfcb );

        return err;
        }


//+API
// BuildIndex
// ========================================================================
// ERR BuildIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
//
// Builds a new index for a file from scratch;  szIndex gives the
// name of an index definition.
//
// PARAMETERS   ppib                                            PIB of user
//                                      pfucb                                           Exclusively opened FUCB on file
//                                      szIndex                                         name of index to build
//
// RETURNS              Error code from DIRMAN or SORT or
//                                      JET_errSuccess                  Everything worked OK.
//                                      IndexCantBuild                  The index name specfied refers
//                                                                                              to the primary index.
// COMMENTS
//                      A transaction is wrapped around this function at the callee.
//
// SEE ALSO             ErrIsamCreateIndex
//-
ERR ErrFILEBuildIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
        {
        ERR             err;
        CHAR            szIdxOrig[ (JET_cbNameMost + 1) ];
        INT             fDIRFlags;
        INT             fDIRWithBackToFather;
        FUCB            *pfucbIndex = pfucbNil;
        FUCB            *pfucbSort = pfucbNil;
        DIB             dib;
        FDB             *pfdb;
        IDB             *pidb;
        LINE            rgline[2];
        BYTE            rgbKey[JET_cbKeyMost];
        SRID            sridData;
        ULONG           itagSequence;
        FCB             *pfcb;
        BOOL            fNoNullSeg;
        BOOL            fAllowNulls;
        BOOL            fAllowSomeNulls;
        INT             fUnique;
        LONG            cRecInput = 0;
        LONG            cRecOutput = 0;

        pfcb = pfucb->u.pfcb;

        CallS( ErrIsamGetCurrentIndex(ppib, pfucb, szIdxOrig, sizeof szIdxOrig ) );
        Call( ErrRECChangeIndex( pfucb, szIndex ) );
        pfucbIndex = pfucb->pfucbCurIndex;
        if ( pfucbIndex == pfucbNil )
                {
                err = JET_errIndexCantBuild;
                goto HandleError;
                }
        pfdb = (FDB *)pfcb->pfdb;
        pidb = pfucbIndex->u.pfcb->pidb;
        fNoNullSeg = ( pidb->fidb & fidbNoNullSeg ) ? fTrue : fFalse;
        fAllowNulls = ( pidb->fidb & fidbAllowAllNulls ) ? fTrue : fFalse;
        fAllowSomeNulls = ( pidb->fidb & fidbAllowSomeNulls ) ? fTrue : fFalse;
        fUnique = ( pidb->fidb & fidbUnique ) ? fSCBUnique : 0;

        /*      directory manager flags
        /**/
        fDIRFlags = fDIRNoVersion | fDIRAppendItem | ( fUnique ? 0 : fDIRDuplicate );
        fDIRWithBackToFather = fDIRFlags | fDIRBackToFather;

        /*      open sort
        /**/
        Call( ErrSORTOpen( ppib, &pfucbSort, fSCBIndex|fUnique ) );
        rgline[0].pb = rgbKey;
        rgline[1].cb = sizeof(SRID);
        rgline[1].pb = (BYTE *)&sridData;

        /*      build up new index in a sort file
        /**/
        dib.fFlags = fDIRNull;
        forever
                {
                err = ErrDIRNext( pfucb, &dib );
                if ( err < 0 )
                        {
                        if ( err == JET_errNoCurrentRecord )
                                break;
                        goto HandleError;
                        }

                Call( ErrDIRGet( pfucb ) );
                DIRGetBookmark( pfucb, &sridData );

                for ( itagSequence = 1; ; itagSequence++ )
                        {
                        KEY *pkey = &rgline[0];

                        Call( ErrRECExtractKey( pfucb, pfdb, pidb, &pfucb->lineData, pkey, itagSequence ) );
                        Assert( err == wrnFLDNullKey ||
                                err == wrnFLDOutOfKeys ||
                                err == wrnFLDNullSeg ||
                                err == JET_errSuccess );
                        if ( err == wrnFLDOutOfKeys )
                                {
                                Assert( itagSequence > 1 );
                                break;
                                }

                        if ( fNoNullSeg && ( err == wrnFLDNullSeg || err == wrnFLDNullKey ) )
                                {
                                err = JET_errNullKeyDisallowed;
                                goto HandleError;
                                }

                        if ( err == wrnFLDNullKey )
                                {
                                if ( fAllowNulls )
                                        {
                                        Call( ErrSORTInsert( pfucbSort, rgline ) );
                                        cRecInput++;
                                        }
                                break;
                                }
                        else
                                {
                                /* do not insert keys with null segment, if so specified
                                /**/
                                if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
                                        break;
                                }

                        Call( ErrSORTInsert( pfucbSort, rgline ) );
                        cRecInput++;

                        if ( !( pidb->fidb & fidbHasMultivalue ) )
                                break;

                        /*      currency may have been lost so refresh record for
                        /*      next tagged column
                        /**/
                        Call( ErrDIRGet( pfucb ) );
                        }
                }
        Call( ErrSORTEndRead( pfucbSort ) );

        /*      transfer index entries to actual index
        /*      insert first one in normal method!
        /**/
        if ( ( err = ErrSORTNext( pfucbSort ) ) == JET_errNoCurrentRecord )
                goto Done;
        if ( err < 0 )
                goto HandleError;
        cRecOutput++;

        /*      move to FDP root
        /**/
        DIRGotoDataRoot( pfucbIndex );
        Call( ErrDIRInsert( pfucbIndex, &pfucbSort->lineData,
                &pfucbSort->keyNode, fDIRFlags ) );

#ifdef BULK_INSERT_ITEM
        Call( ErrDIRInitAppendItem( pfucbIndex ) );
#endif

        Assert( dib.fFlags == fDIRNull );
        dib.pos = posLast;

        /*      from now on, try short circuit first
        /**/
        forever
                {
                err = ErrSORTNext( pfucbSort );
                if ( err == JET_errNoCurrentRecord )
                        break;
                if ( err < 0 )
                        goto HandleError;
                cRecOutput++;
                err = ErrDIRAppendItem( pfucbIndex, &pfucbSort->lineData, &pfucbSort->keyNode );
                if ( err < 0 )
                        {
                        if ( err == errDIRNoShortCircuit )
                                {
                                DIRUp( pfucbIndex, 1 );
                                Call( ErrDIRInsert( pfucbIndex,
                                        &pfucbSort->lineData,
                                        &pfucbSort->keyNode,
                                        fDIRFlags ) );
                                /*      leave currency on inserted item list for
                                /*      next in page item append.
                                /**/
                                }
                        else
                                goto HandleError;
                        }
                }

#ifdef BULK_INSERT_ITEM
        Call( ErrDIRTermAppendItem( pfucbIndex ) );
#endif

        if ( fUnique && cRecOutput < cRecInput )
                {
                err = JET_errKeyDuplicate;
                goto HandleError;
                }

Done:
        Call( ErrSORTClose( pfucbSort ) );
        (VOID) ErrRECChangeIndex( pfucb, szIdxOrig );
        return JET_errSuccess;

HandleError:
        if ( pfucbIndex != pfucbNil && pfucbIndex->pbfWorkBuf != pbfNil )
                {
                BFSFree(pfucbIndex->pbfWorkBuf);
                pfucbIndex->pbfWorkBuf = pbfNil;
                }
        if ( pfucbSort != pfucbNil )
                {
                (VOID) ErrSORTClose( pfucbSort );
                }
        (VOID) ErrRECChangeIndex( pfucb, NULL );
        (VOID) ErrRECChangeIndex( pfucb, szIdxOrig );
        return err;
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\fcb.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "pib.h"
#include "util.h"
#include "fmp.h"
#include "ssib.h"
#include "page.h"
#include "fcb.h"
#include "fucb.h"
#include "nver.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "recapi.h"
#include "recint.h"
#include "fileint.h"

DeclAssertFile;					/* Declare file name for assert macros */


/*	outstanding versions may be on non-clustered index and not on
/*	table FCB, so must check all non-clustered indexes before
/*	freeing table FCBs.
/**/
LOCAL BOOL FFCBINoVersion( FCB *pfcbTable )
	{
	FCB 	*pfcbT;

	for ( pfcbT = pfcbTable; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		{
		if ( pfcbT->cVersion > 0 )
			return fFalse;
		}

	return fTrue;
	}


/*	list of all file FCBs in the system which are currently available.
/*	Some may not be in use, and have wRefCnt == 0;  these may be
/*	reclaimed ( and any attendant index FCBs ) if the free pool is exhausted.
/**/
FCB * __near pfcbGlobalList = pfcbNil;
SgSemDefine( semGlobalFCBList );
SgSemDefine( semLinkUnlink );


VOID FCBLink( FUCB *pfucb, FCB *pfcb )
	{
	Assert( pfucb != pfucbNil );
	Assert( pfcb != pfcbNil );
	pfucb->u.pfcb = pfcb;
	pfucb->pfucbNextInstance = pfcb->pfucb;
	pfcb->pfucb = pfucb;
	pfcb->wRefCnt++;
	Assert( pfcb->wRefCnt > 0 );
#ifdef DEBUG
	{
	FUCB	*pfucbT = pfcb->pfucb;
	INT	cfcb = 0;

	while( cfcb++ < pfcb->wRefCnt && pfucbT != pfucbNil )
		{
		pfucbT = pfucbT->pfucbNextInstance;
		}
	Assert( pfucbT == pfucbNil );
	}
#endif
	}


VOID FCBUnlink( FUCB *pfucb )
	{
	FUCB   	*pfucbCurr;
	FUCB   	*pfucbPrev;
	FCB		*pfcb;

	Assert( pfucb != pfucbNil );
	pfcb = pfucb->u.pfcb;
	Assert( pfcb != pfcbNil );
	pfucb->u.pfcb = pfcbNil;
	pfucbPrev = pfucbNil;
	Assert( pfcb->pfucb != pfucbNil );
	pfucbCurr = pfcb->pfucb;
	while ( pfucbCurr != pfucb )
		{
		pfucbPrev = pfucbCurr;
		pfucbCurr = pfucbCurr->pfucbNextInstance;
		Assert( pfucbCurr != pfucbNil );
		}
	if ( pfucbPrev == pfucbNil )
		pfcb->pfucb = pfucbCurr->pfucbNextInstance;
	else
		pfucbPrev->pfucbNextInstance = pfucbCurr->pfucbNextInstance;
	Assert( pfcb->wRefCnt > 0 );
	pfcb->wRefCnt--;
	}

/*	returns index of bucket in FCB Hash given dbid, pgnoFDP
/**/
LOCAL ULONG UlFCBHashVal( DBID dbid, PGNO pgnoFDP )
	{
	return ( dbid + pgnoFDP ) % cFCBBuckets;
	}


/*	inserts fcb in hash
/**/
VOID FCBRegister( FCB *pfcb )
	{
	ULONG	cBucket = UlFCBHashVal( pfcb->dbid, pfcb->pgnoFDP );

	Assert( cBucket <= cFCBBuckets );
	Assert( pfcb->pfcbNextInHashBucket == pfcbNil );
	Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcbNil );

	Assert( pfcbHash[cBucket] != pfcb );
	pfcb->pfcbNextInHashBucket = pfcbHash[cBucket];
	pfcbHash[cBucket] = pfcb;
	return;
	}


/*	removes fcb from hash table
/**/
VOID FCBDiscard( FCB *pfcb )
	{
	ULONG  	cBucket = UlFCBHashVal( pfcb->dbid, pfcb->pgnoFDP );
	FCB		**ppfcb;

	Assert( cBucket <= cFCBBuckets );
	
	for ( ppfcb = &pfcbHash[cBucket]; *ppfcb != pfcbNil; ppfcb = &(*ppfcb)->pfcbNextInHashBucket )
		{
		Assert( UlFCBHashVal( (*ppfcb)->dbid, (*ppfcb)->pgnoFDP ) == cBucket );
		if ( *ppfcb == pfcb )
			{
			*ppfcb = pfcb->pfcbNextInHashBucket;
			pfcb->pfcbNextInHashBucket = pfcbNil;
			Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcbNil );
			return;
			}
		else
			{
			Assert( pfcb->dbid != (*ppfcb)->dbid || pfcb->pgnoFDP != (*ppfcb)->pgnoFDP );
			}
		}

	Assert( fFalse );
	}

/*	gets pointer to FCB with given dbid,pgnoFDP if one exists in hash;
/*	returns pfcbNil otherwise
/**/
FCB *PfcbFCBGet( DBID dbid, PGNO pgnoFDP )
	{
	ULONG  	cBucket = UlFCBHashVal( dbid, pgnoFDP );
	FCB		*pfcb = pfcbHash[cBucket];

	for ( ;	pfcb != pfcbNil && !( pfcb->dbid == dbid && pfcb->pgnoFDP == pgnoFDP );
		pfcb = pfcb->pfcbNextInHashBucket );

#ifdef DEBUG
	/* check for no duplicates in bucket
	/**/
	if ( pfcb != pfcbNil )
		{
		FCB	*pfcbT = pfcb->pfcbNextInHashBucket;

		for ( ; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextInHashBucket )
			{
			Assert ( pfcbT->dbid != dbid || pfcbT->pgnoFDP != pgnoFDP );
			}
		}
#endif

	Assert( pfcb == pfcbNil || ( pfcb->dbid == dbid && pfcb->pgnoFDP == pgnoFDP ) );
	return pfcb;
	}


/* this function is specifically for clean-up after redo.
/**/
FCB *FCBResetAfterRedo( void )
	{
	FCB	 	*pfcb;

	for ( pfcb = pfcbGlobalList; pfcb != pfcbNil; pfcb = pfcb->pfcbNext )
		{
		if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
			FCBDiscard( pfcb );
		pfcb->dbid = 0;
		pfcb->pgnoFDP = pgnoNull;
		pfcb->wRefCnt = 0;
		}

	return pfcbNil;
	}


ERR ErrFCBAlloc( PIB *ppib, FCB **ppfcb )
	{
	FCB		*pfcb;
	FCB		*pfcbPrev;

	/*	first try free pool
	/**/
	pfcb = PfcbMEMAlloc();
	if ( pfcb != pfcbNil )
		{
		FCBInit( pfcb );
		*ppfcb = pfcb;
		return JET_errSuccess;
		}

	/*	clean versions in order to make more FCBs avaiable
	/*	for reuse.  This must be done sinece FCBs are referenced
	/*	by versioned and can only be cleaned when the cVersion
	/*	count in the FCB is 0.
	/**/
	(VOID)ErrRCECleanAllPIB();

	/*	look for FCB with 0 reference count, and also, no deny read
	/*	flag set.  It is possible that the reference count will be
	/*	zero and the deny read flag set.
	/**/
	SgSemRequest( semGlobalFCBList );
	pfcbPrev = pfcbNil;
	for (	pfcb = pfcbGlobalList;
		pfcb != pfcbNil && !FFCBAvail( pfcb, ppib );
		pfcb = pfcb->pfcbNext )
		pfcbPrev = pfcb;
	if ( pfcb == pfcbNil )
		{
		SgSemRelease( semGlobalFCBList );
		return JET_errTooManyOpenTables;
		}

	Assert( !FFCBSentinel( pfcb ) );

	/*	remove from global list and deallocate
	/**/
	if ( pfcbPrev == pfcbNil )
		{
		Assert( pfcb == pfcbGlobalList );
		pfcbGlobalList = pfcb->pfcbNext;
		}
	else
		{
		Assert( pfcb->pfcbNext != pfcbPrev );
		pfcbPrev->pfcbNext = pfcb->pfcbNext;
		}
	SgSemRelease( semGlobalFCBList );
	FILEIDeallocateFileFCB( pfcb );

	/*	there should be some FCBs free now, unless somebody happened to
	/*	grab the newly freed FCBs between these 2 statements
	/**/
	pfcb = PfcbMEMAlloc( );
	if ( pfcb == pfcbNil )
		return JET_errOutOfMemory;
	
	FCBInit( pfcb );
	*ppfcb = pfcb;
	return JET_errSuccess;
	}


//	UNDONE:	remove the need for this routine by having open
//		   	database create an FCB and permanently hold it
//		   	open via reference count on database record
ERR ErrFCBNew( PIB *ppib, DBID dbid, PGNO pgno, FCB **ppfcb )
	{
	ERR	err;

	NotUsed( pgno );

	CallR( ErrFCBAlloc( ppib, ppfcb ) );

	/*	initialize FCB
	/**/
	FCBInit( *ppfcb );
	( *ppfcb )->dbid = dbid;
	( *ppfcb )->pgnoFDP = pgnoSystemRoot;
	( *ppfcb )->pgnoRoot = pgnoSystemRoot;
	( *ppfcb )->itagRoot = 0;
	( *ppfcb )->bmRoot = SridOfPgnoItag( pgnoSystemRoot, 0 );
	( *ppfcb )->cVersion = 0;

	/*	insert into global fcb list and hash
	/**/
	Assert( pfcbGlobalList != (*ppfcb) );
	(*ppfcb)->pfcbNext = pfcbGlobalList;
	pfcbGlobalList = *ppfcb;

	FCBRegister( *ppfcb );

	return JET_errSuccess;
	}


//+API
//	FCBPurgeDatabase
//	========================================================================
//	FCBPurgeDatabase( DBID dbid )
//
//	Removes alls FCBs from the global list for given dbid.  Called when
//	database detached, so newly created or attached database with
//	same dbid will not have tables confused with previous databases
//	tables.
//
//	PARAMETERS		dbid		dbid of database
//		   						or dbidNull if all FCBs are to be purged
//
//	SIDE EFFECTS	FCBs whose FDPpgno matches the given dbid are
//		   			removed from the global list.
//-
VOID FCBPurgeDatabase( DBID dbid )
	{
	FCB	*pfcbCurr;		// pointer to current FCB in list walk
	FCB	*pfcbCurrT;		// pointer to next FCB
	FCB	*pfcbPrev;		// pointer to previous FCB in list walk

	SgSemRequest(semGlobalFCBList);

	pfcbPrev = pfcbNil;
	pfcbCurr = pfcbGlobalList;
	while ( pfcbCurr != pfcbNil )
		{
		pfcbCurrT = pfcbCurr->pfcbNext;
		if ( pfcbCurr->dbid == dbid || dbid == 0 )
			{
			if ( FFCBSentinel( pfcbCurr ) )
				{
				if ( PfcbFCBGet( pfcbCurr->dbid, pfcbCurr->pgnoFDP ) == pfcbCurr )
					FCBDiscard( pfcbCurr );
				Assert( pfcbCurr->cVersion == 0 );
				MEMReleasePfcb( pfcbCurr );
				}
			else
				{
				FILEIDeallocateFileFCB( pfcbCurr );
				}

			if ( pfcbPrev == pfcbNil )
				pfcbGlobalList = pfcbCurrT;
			else
				{
				Assert( pfcbCurrT != pfcbPrev );
				pfcbPrev->pfcbNext = pfcbCurrT;
				}
			}
		else
			{
			/*	if did not deallocate current fcb, advance previous
			/*	fcb to current fcb
			/**/
			pfcbPrev = pfcbCurr;
			}
		pfcbCurr = pfcbCurrT;
		}
	SgSemRelease(semGlobalFCBList);
	}


//+FILE_PRIVATE
// FCBPurgeTable
// ========================================================================
// FCBPurgeTable( DBID dbid, PNGO pgnoFDP )
//
// Removes an FCB from the global list and frees it up.
//
// PARAMETERS	pgnoFDP		FDP page number of FCB to purge
//
// SIDE EFFECTS
//		The FCB whose FDPpgno matches the input parameter is
//		removed from the global list ( if it was there at all ).
//-
VOID FCBPurgeTable( DBID dbid, PGNO pgnoFDP )
	{
	FCB	*pfcb;
	FCB	*pfcbPrev;

	SgSemRequest(semGlobalFCBList);

	pfcbPrev = pfcbNil;
	pfcb = pfcbGlobalList;
	while ( pfcb != pfcbNil )
		{
		if ( pfcb->pgnoFDP == pgnoFDP && pfcb->dbid == dbid )
			break;
		pfcbPrev = pfcb;
		pfcb = pfcb->pfcbNext;
		}

	if ( pfcb == pfcbNil )
		{
		SgSemRelease( semGlobalFCBList );
		return;
		}

	if ( pfcbPrev == pfcbNil )
		{
		pfcbGlobalList = pfcb->pfcbNext;
		}
	else
		{
		Assert( pfcb->pfcbNext != pfcbPrev );
		pfcbPrev->pfcbNext = pfcb->pfcbNext;
		}

	Assert( pfcb->wRefCnt == 0 );

	if ( FFCBSentinel( pfcb ) )
		{
		if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
			FCBDiscard( pfcb );
		Assert( pfcb->cVersion == 0 );
		MEMReleasePfcb( pfcb );
		}
	else
		{
		FILEIDeallocateFileFCB( pfcb );
		}

	SgSemRelease(semGlobalFCBList);
	}


/*	set domain usage mode or return error.  Allow only one deny read
/*	or one deny write.  Sessions that own locks may open other read
/*	or read write cursors, but not another deny read or deny write cursor.
/*	This is done to facillitage flag management, but could be relaxed
/*	if required.
/**/
ERR ErrFCBISetMode( PIB *ppib, FCB *pfcb, JET_GRBIT grbit )
	{
	FUCB	*pfucbT;

	/*	if table is fake deny read, then return error
	/**/
	if ( FFCBSentinel( pfcb ) )
		return JET_errTableLocked;

	/*	all cursors can read so check for deny read flag by other session.
	/**/
	if ( FFCBDenyRead( pfcb, ppib ) )
		{
		/*	check if domain is deny read locked by other session.  If
		/*	deny read locked, then all cursors must be of same session.
		/**/
		Assert( pfcb->ppibDenyRead != ppibNil );
		if ( pfcb->ppibDenyRead != ppib )
			return JET_errTableLocked;
#ifdef DEBUG
		for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNext )
			{
			Assert( pfucbT->ppib == pfcb->ppibDenyRead );
			}
#endif
		}

	/*	check for deny write flag by other session.  If deny write flag
	/*	set then only cursors of that session may have write privlages.
	/**/
	if ( grbit & JET_bitTableUpdatable )
		{
		if ( FFCBDenyWrite( pfcb ) )
			{
			for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNext )
				{
				if ( pfucbT->ppib != ppib && FFUCBDenyWrite( pfucbT ) )
					return JET_errTableLocked;
				}
			}
		}

	/*	if deny write lock requested, check for updatable cursor of
	/*	other session.  If lock is already held, even by given session,
	/*	then return error.
	/**/
	if ( grbit & JET_bitTableDenyWrite )
		{
		/*	if any session has this table open deny write, including given
		/*	session, then return error.
		/**/
		if ( FFCBDenyWrite( pfcb ) )
			{
			return JET_errTableInUse;
			}

		/*	check is cursors with write mode on domain.
		/**/
		for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNext )
			{
			if ( pfucbT->ppib != ppib && FFUCBUpdatable( pfucbT ) )
				{
				return JET_errTableInUse;
				}
			}
		FCBSetDenyWrite( pfcb );
		}

	/*	if deny read lock requested, then check for cursor of other
	/*	session.  If lock is already held, even by given session, then
	/*	return error.
	/**/
	if ( grbit & JET_bitTableDenyRead )
		{
		/*	if any session has this table open deny read, including given
		/*	session, then return error.
		/**/
		if ( FFCBDenyRead( pfcb, ppib ) )
			{
			return JET_errTableInUse;
			}
		/*	check if cursors belonging to another session
		/*	are open on this domain.
		/**/
		for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNext )
			{
			if ( pfucbT->ppib != ppib )
				{
				return JET_errTableInUse;
				}
			}
		FCBSetDenyRead( pfcb, ppib );
		}

	return JET_errSuccess;
	}


/*	reset domain mode usage.
/**/
VOID FCBResetMode( PIB *ppib, FCB *pfcb, JET_GRBIT grbit )
	{
	if ( grbit & JET_bitTableDenyRead )
		{
		Assert( FFCBDenyRead( pfcb, ppib ) );
		FCBResetDenyRead( pfcb );
		}

	if ( grbit & JET_bitTableDenyWrite )
		{
		Assert( FFCBDenyWrite( pfcb ) );
		FCBResetDenyWrite( pfcb );
		}

	return;
	}


ERR ErrFCBSetDeleteTable( PIB *ppib, DBID dbid, PGNO pgno )
	{
	ERR	err;
	FCB	*pfcb;

	SgSemRequest(semGlobalFCBList);
	pfcb = PfcbFCBGet( dbid, pgno );
	if ( pfcb == pfcbNil )
		{
		CallR( ErrFCBAlloc( ppib, &pfcb ) );

		Assert( pfcbGlobalList != pfcb );
		pfcb->pfcbNext = pfcbGlobalList;
		pfcbGlobalList = pfcb;
		pfcb->dbid = dbid;
		pfcb->pgnoFDP = pgno;
		pfcb->wRefCnt = 0;
		FCBSetDenyRead( pfcb, ppib );
		FCBRegister( pfcb );
		FCBSetSentinel( pfcb );
		}
	else
		{
		INT	wRefCnt = pfcb->wRefCnt;
		FUCB	*pfucbT;

		/*	check for open cursors on table or deferred closed
		/*	cursors by other session.
		/**/
		for ( pfucbT = pfcb->pfucb;
			pfucbT != pfucbNil;
			pfucbT = pfucbT->pfucbNextInstance )
			{
			if ( FFUCBDeferClosed( pfucbT ) && pfucbT->ppib == ppib )
				{
				Assert( wRefCnt > 0 );
				wRefCnt--;
				}
			}

		if ( wRefCnt > 0 )
			{
			SgSemRelease(semGlobalFCBList);
			return JET_errTableInUse;
			}

		FCBSetDenyRead( pfcb, ppib );
		}

	SgSemRelease(semGlobalFCBList);
	return JET_errSuccess;
	}


VOID FCBResetDeleteTable( DBID dbid, PGNO pgnoFDP )
	{
	FCB	*pfcb;
	FCB	*pfcbPrev;

	SgSemRequest(semGlobalFCBList);

	pfcbPrev = pfcbNil;
	pfcb = pfcbGlobalList;
	while ( pfcb != pfcbNil )
		{
		if ( pfcb->pgnoFDP == pgnoFDP && pfcb->dbid == dbid )
			break;
		pfcbPrev = pfcb;
		pfcb = pfcb->pfcbNext;
		}

	Assert( pfcb != pfcbNil );

	if ( FFCBSentinel( pfcb ) )
		{
		if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
			FCBDiscard( pfcb );
		if ( pfcbPrev == pfcbNil )
			{
			pfcbGlobalList = pfcb->pfcbNext;
			}
		else
			{
			Assert( pfcb->pfcbNext != pfcbPrev );
			pfcbPrev->pfcbNext = pfcb->pfcbNext;
			}
		Assert( pfcb->cVersion == 0 );
		MEMReleasePfcb( pfcb );
		}
	else
		{
		FCBResetDenyRead( pfcb );
		}

	SgSemRelease( semGlobalFCBList );
	return;
	}


ERR ErrFCBSetRenameTable( PIB *ppib, DBID dbid, PGNO pgnoFDP )
	{
	ERR	err = JET_errSuccess;
	FCB	*pfcb;

	SgSemRequest( semGlobalFCBList );
	pfcb = PfcbFCBGet( dbid, pgnoFDP );
	if ( pfcb != pfcbNil )
		{
		Call( ErrFCBSetMode( ppib, pfcb, JET_bitTableDenyRead ) );
		}
	else
		{
		CallR( ErrFCBAlloc( ppib, &pfcb ) );

		Assert( pfcbGlobalList != pfcb );
		pfcb->pfcbNext = pfcbGlobalList;
		pfcbGlobalList = pfcb;
		pfcb->dbid = dbid;
		pfcb->pgnoFDP = pgnoFDP;
		pfcb->wRefCnt = 0;
		FCBSetDenyRead( pfcb, ppib );
		FCBSetSentinel( pfcb );
		FCBRegister( pfcb );
		}

HandleError:
	SgSemRelease( semGlobalFCBList );
	return err;
	}


/*	return fTrue if table open with one or more non deferred closed tables.
/**/
BOOL FFCBTableOpen( DBID dbid, PGNO pgnoFDP )
	{
	FCB 	*pfcb = PfcbFCBGet( dbid, pgnoFDP );
	FUCB	*pfucb;

	if ( pfcb == pfcbNil || pfcb->wRefCnt == 0 )
		return fFalse;

	for ( pfucb = pfcb->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNextInstance )
		{
		if ( !FFUCBDeferClosed( pfucb ) )
			return fTrue;
		}

	return fFalse;
	}


VOID FCBLinkIndex( FCB *pfcbTable, FCB *pfcbIndex )
	{
	pfcbIndex->pfcbNextIndex =	pfcbTable->pfcbNextIndex;
	pfcbTable->pfcbNextIndex = pfcbIndex;
	return;
	}


VOID FCBUnlinkIndex( FCB *pfcbTable, FCB *pfcbIndex )
	{
	FCB	*pfcbT;

	for ( pfcbT = pfcbTable;
		pfcbT != pfcbNil && pfcbT->pfcbNextIndex != pfcbIndex;
		pfcbT = pfcbT->pfcbNextIndex );
	Assert( pfcbT != pfcbNil );
	pfcbT->pfcbNextIndex = pfcbIndex->pfcbNextIndex;
	pfcbIndex->pfcbNextIndex = pfcbNil;
	return;
	}


BOOL FFCBUnlinkIndexIfFound( FCB *pfcbTable, FCB *pfcbIndex )
	{
	FCB	*pfcbT;

	for ( pfcbT = pfcbTable;
		pfcbT != pfcbNil && pfcbT->pfcbNextIndex != pfcbIndex;
		pfcbT = pfcbT->pfcbNextIndex );

	if ( pfcbT != pfcbNil )
		{
		pfcbT->pfcbNextIndex = pfcbIndex->pfcbNextIndex;
		pfcbIndex->pfcbNextIndex = pfcbNil;
		return fTrue;
		}

	return fFalse;
	}


/*	detach deleted index FCB from non-clustered index chain.
/**/
FCB *PfcbFCBUnlinkIndexByName( FCB *pfcb, CHAR *szIndex )
	{
	FCB	**ppfcbIdx;
	FCB	*pfcbT;

	/*	find non-clustered index in table index FCB list.
	/**/
	for ( ppfcbIdx = &pfcb->pfcbNextIndex;
		*ppfcbIdx != pfcbNil && SysCmpText( (*ppfcbIdx)->pidb->szName, szIndex ) != 0;
		ppfcbIdx = &(*ppfcbIdx)->pfcbNextIndex )
		{
		;/*** Null-body ***/
		}

	Assert( *ppfcbIdx != pfcbNil );

	/*	remove index FCB
	/**/
	pfcbT = *ppfcbIdx;
	*ppfcbIdx = (*ppfcbIdx)->pfcbNextIndex;
	return pfcbT;
	}


ERR ErrFCBSetDeleteIndex( PIB *ppib, FCB *pfcbTable, CHAR *szIndex )
	{
	FCB	*pfcbT;
	INT	wRefCnt;
	FUCB	*pfucbT;

	/*	find index pfcb in index list
	/**/
	for( pfcbT = pfcbTable->pfcbNextIndex; ; pfcbT = pfcbT->pfcbNextIndex )
		{
		if ( SysCmpText( szIndex, pfcbT->pidb->szName ) == 0 )
			break;
		Assert( pfcbT->pfcbNextIndex != pfcbNil );
		}

	wRefCnt = pfcbT->wRefCnt;

	/*	check for open cursors on table or deferred closed
	/*	cursors by other session.
	/**/
	if ( wRefCnt > 0 )
		{
		for ( pfucbT = pfcbT->pfucb;
			pfucbT != pfucbNil;
			pfucbT = pfucbT->pfucbNextInstance )
			{
			if ( FFUCBDeferClosed( pfucbT ) && pfucbT->ppib == ppib )
				{
				Assert( wRefCnt > 0 );
				wRefCnt--;
				}
			}
		}

	if ( wRefCnt > 0 )
		{
		SgSemRelease(semGlobalFCBList);
		return JET_errIndexInUse;
		}

	FCBSetDenyRead( pfcbT, ppib );
	FCBSetDeletePending( pfcbT );

	return JET_errSuccess;
	}


VOID FCBResetDeleteIndex( FCB *pfcbIndex )
	{
	FCBResetDeletePending( pfcbIndex );
	FCBResetDenyRead( pfcbIndex );
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\flddef.c ===
#include "config.h"

#include <string.h>

#include "daedef.h"
#include "fdb.h"
#include "idb.h"
#include "recapi.h"
#include "recint.h"
#include "util.h"

DeclAssertFile;					/* Declare file name for assert macros */

//+API
// ErrRECNewFDB
// ========================================================================
// ErrRECNewFDB(ppfdb, fidFixedLast, fidVarLast, fidTaggedLast)
//		FDB **ppfdb;			// OUT	 receives new FDB
//		FID fidFixedLast;	  // IN	   last fixed field id to be used
//		FID fidVarLast;		  // IN	   last var field id to be used
//		FID fidTaggedLast;	  // IN	   last tagged field id to be used
// Allocates a new FDB, initializing internal elements appropriately.
//
// PARAMETERS
//				ppfdb				receives new FDB
//				fidFixedLast   last fixed field id to be used
//									(should be fidFixedLeast-1 if none)
//				fidVarLast	   last var field id to be used
//									(should be fidVarLeast-1 if none)
//				fidTaggedLast  last tagged field id to be used
//									(should be fidTaggedLeast-1 if none)
// RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfMemory	Failed to allocate memory.
// SEE ALSO		ErrRECAddFieldDef
//-
ERR ErrRECNewFDB( FDB **ppfdb, FID fidFixedLast, FID fidVarLast, FID fidTaggedLast)
	{
	INT		iib;						// loop counter
	WORD		cfieldFixed;			// # of fixed fields
	WORD		cfieldVar;				// # of var fields
	WORD		cfieldTagged;			// # of tagged fields
	ULONG		cbAllocate;				// total cb to allocate for this FDB
	FDB  		*pfdb;					// temporary FDB pointer

	Assert(ppfdb != NULL);
	Assert(fidFixedLast <= fidFixedMost);
	Assert(fidVarLast >= fidVarLeast-1 && fidVarLast <= fidVarMost);
	Assert(fidTaggedLast >= fidTaggedLeast-1 && fidTaggedLast <= fidTaggedMost);
						
	/*** Calculate how many of each field type to allocate ***/
	cfieldFixed = fidFixedLast + 1 - fidFixedLeast;
	cfieldVar = fidVarLast + 1 - fidVarLeast;
	cfieldTagged = fidTaggedLast + 1 - fidTaggedLeast;

	/*** Allocate entire block of memory at once ***/
	cbAllocate = sizeof(FDB)								// pfdb
				+ cfieldFixed * sizeof(FIELD)				// pfdb->pfieldFixed
				+ cfieldVar * sizeof(FIELD)				// pfdb->pfieldVar
				+ cfieldTagged * sizeof(FIELD)			// pfdb->pfieldTagged
				+ (cfieldFixed+1) * sizeof(WORD);		// pfdb->pibFixedOffsets
	if ((pfdb = (FDB*)SAlloc(cbAllocate)) == NULL)
		return JET_errOutOfMemory;
	memset((BYTE*)pfdb, '\0', cbAllocate);

	/*** Fill in max field id numbers ***/
	pfdb->fidFixedLast = fidFixedLast;
	pfdb->fidVarLast = fidVarLast;
	pfdb->fidTaggedLast = fidTaggedLast;

	/*** Set pointers into memory area ***/
	pfdb->pfieldFixed = (FIELD*)((BYTE*)pfdb + sizeof(FDB));
	pfdb->pfieldVar = pfdb->pfieldFixed + cfieldFixed;
	pfdb->pfieldTagged = pfdb->pfieldVar + cfieldVar;
	pfdb->pibFixedOffsets = (WORD*)(pfdb->pfieldTagged + cfieldTagged);

	/*** Initialize fixed field offset table ***/
	for ( iib = 0; iib <= cfieldFixed; iib++ )
		pfdb->pibFixedOffsets[iib] = sizeof(RECHDR);

	/*** Set output parameter and return ***/
	*ppfdb = pfdb;
	return JET_errSuccess;
	}


//+API
// ErrRECAddFieldDef
// ========================================================================
// ErrRECAddFieldDef(pfdb, fid, pfieldNew)
//		FDB *pfdb;				  // INOUT	 FDB to add field definition to
//		FID fid;			// IN	   field id of new field
//		FIELD *pfieldNew;
// Adds a field descriptor to an FDB.
//
// PARAMETERS	pfdb			FDB to add new field definition to
//				fid				field id of new field (should be within
//									the ranges imposed by the parameters
//									supplied to ErrRECNewFDB)
//				ftFieldType		data type of field
//				cbField			field length (only important when
//									defining fixed textual fields)
//				bFlags			field behaviour flags:
//					VALUE				MEANING
//					========================================
//					ffieldNotNull		Field may not contain NULL values.
//				szFieldName		name of field
// RETURNS		Error code, one of:
//					 JET_errSuccess			Everything worked.
//					-ColumnInvalid				Field id given is greater than
//													the maximum which was given
//													to ErrRECNewFDB.
//					-JET_errBadColumnId		A nonsensical field id was given.
//					-errFLDInvalidFieldType The field type given is either
//													undefined, or is not acceptable
//													for this field id.
// COMMENTS		When adding a fixed field, the fixed field offset table
//					in the FDB is recomputed.
// SEE ALSO		ErrRECNewFDB
//-
ERR ErrRECAddFieldDef( FDB *pfdb, FID fid, FIELD *pfieldNew )
	{
	FIELD			*pfield;							// Pointer to new field's descriptor.
	WORD			cb;								// Length of fixed field.
	WORD			*pib;								// Loop counters.
	WORD			*pibMost;						// Loop counters.
	JET_COLTYP	coltyp = pfieldNew->coltyp;

	Assert( pfdb != pfdbNil );
	/*	fixed field: determine length, either from field type
	/*	or from parameter (for text/binary types)
	/**/
	if ( FFixedFid( fid ) )
		{
		if ( fid > pfdb->fidFixedLast )
			return JET_errColumnNotFound;
		Assert(pfdb->pfieldFixed != NULL);
		pfield = &pfdb->pfieldFixed[fid-fidFixedLeast];
		switch ( coltyp )
			{
			default:
				return JET_errInvalidColumnType;
			case JET_coltypBit:
			case JET_coltypUnsignedByte:
				cb = sizeof(BYTE);
				break;
			case JET_coltypShort:
				cb = sizeof(SHORT);
				break;
			case JET_coltypLong:
			case JET_coltypIEEESingle:
				cb = sizeof(long);
				break;
			case JET_coltypCurrency:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				cb = 8;//sizeof(DREAL);
				break;
			case JET_coltypBinary:
			case JET_coltypText:
				cb = (WORD)pfieldNew->cbMaxLen;
				break;
			}
		Assert(pfdb->pibFixedOffsets != NULL);
		/*	shift fixed field offsets by length of newly added field
		/**/
		pibMost = pfdb->pibFixedOffsets + pfdb->fidFixedLast;
		for (pib = pfdb->pibFixedOffsets + fid; pib <= pibMost; pib++)
			*pib += cb;
		}
	else if ( FVarFid( fid ) )
		{
		/*	Var field: check for bogus numeric and "long" types
		/**/
		if (fid > pfdb->fidVarLast)
			return JET_errColumnNotFound;
		Assert(pfdb->pfieldVar != NULL);
		pfield = &pfdb->pfieldVar[fid-fidVarLeast];
		if ( coltyp != JET_coltypBinary && coltyp != JET_coltypText )
			return JET_errInvalidColumnType;
		}
	else if ( FTaggedFid( fid ) )
		{
		/*	tagged field: any type is ok
		/**/
		if (fid > pfdb->fidTaggedLast)
			return JET_errColumnNotFound;
		Assert(pfdb->pfieldTagged != NULL);
		pfield = &pfdb->pfieldTagged[fid-fidTaggedLeast];
		}
	else
		return JET_errBadColumnId;

	/*	initialize field descriptor from parameters
	/**/
	*pfield = *pfieldNew;
	return JET_errSuccess;
	}


//+API
// ErrRECNewIDB
// ========================================================================
// ErrRECNewIDB( IDB **ppidb )
//
// Allocates a new IDB.
//
// PARAMETERS	ppidb			receives new IDB
// RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfMemory	Failed to allocate memory.
// SEE ALSO		ErrRECAddKeyDef, RECFreeIDB
//-
ERR ErrRECNewIDB( IDB **ppidb )
	{
	Assert(ppidb != NULL);
	if ( ( *ppidb = PidbMEMAlloc() ) == NULL )
		return JET_errOutOfMemory;
	memset( (BYTE *)*ppidb, '\0', sizeof(IDB) );
	return JET_errSuccess;
	}


//+API
// ErrRECAddKeyDef
// ========================================================================
//	ERR ErrRECAddKeyDef( 
//		FDB		*pfdb, 
//		IDB		*pidb, 
//		BYTE		iidxsegMac, 
//		IDXSEG	*rgidxseg, 
//		BYTE		bFlags, 
//		LANGID	langid )
//
// Adds a key definition to an IDB.	 Actually, since an IDB can only hold
// one key definition, "adding" is really "defining/overwriting".
//
// PARAMETERS
//				pfdb			field info for index (should contain field
//								definitions for each segment of the key)
//				pidb			IDB of index being defined
//				iidxsegMac	number of key segments
//				rgidxseg		key segment specifiers:	 each segment id
//								is really a field id, except that it is
//								should be the negative of the field id
//								if the field should be descending in the key.
//				bFlags		key behaviour flags:
//					VALUE				MEANING
//					========================================
//					fidbUnique			Specifies that duplicate entries
//											in this index are not allowed.
// RETURNS		Error code, one of:
//					 JET_errSuccess			Everything worked.
//					-errFLDTooManySegments	The number of key segments
//												specified is greater than the
//												maximum number allowed.
//					-ColumnInvalid			A segment id was specified for
//												which there is no field defined.
//					-JET_errBadColumnId	One of the segment ids in the
//												key is nonsensical.
// SEE ALSO		ErrRECNewIDB, RECFreeIDB
//-
ERR ErrRECAddKeyDef( FDB *pfdb, IDB *pidb, BYTE iidxsegMac, IDXSEG *rgidxseg, BYTE bFlags, LANGID langid  )
	{
	FID					fid;
	FIELD					*pfield;
	UNALIGNED IDXSEG	*pidxseg;
	IDXSEG 				*pidxsegMac;

	Assert( pfdb != pfdbNil );
	Assert( pidb != pidbNil );
	Assert( rgidxseg != NULL );
	if ( iidxsegMac > JET_ccolKeyMost )
		return errFLDTooManySegments;

	/*	check validity of each segment id and
	/*	also set index mask bits
	/**/
	pidxsegMac = rgidxseg+iidxsegMac;
	for ( pidxseg = rgidxseg; pidxseg < pidxsegMac; pidxseg++ )
		{
		/*	field id is absolute value of segment id
		/**/
		fid = *pidxseg >= 0 ? *pidxseg : -(*pidxseg);
		if ( FFixedFid( fid ) )
			{
			if ( fid > pfdb->fidFixedLast )
				return JET_errColumnNotFound;
			pfield = &pfdb->pfieldFixed[fid-fidFixedLeast];
			if ( pfield->coltyp == JET_coltypNil )
				return JET_errColumnNotFound;
			fid -= fidFixedLeast;
			pidb->rgbitIdx[fid/8] |= 1 << fid%8;
			}
		else if ( FVarFid( fid ) )
			{
			if ( fid > pfdb->fidVarLast )
				return JET_errColumnNotFound;
			pfield = &pfdb->pfieldVar[fid-fidVarLeast];
			if ( pfield->coltyp == JET_coltypNil )
				return JET_errColumnNotFound;
			fid -= fidVarLeast;
			pidb->rgbitIdx[16+fid/8] |= 1 << fid%8;
			}
		else if ( FTaggedFid( fid ) )
			{
			if ( fid > pfdb->fidTaggedLast )
				return JET_errColumnNotFound;
			pfield = &pfdb->pfieldTagged[fid-fidTaggedLeast];
			if ( pfield->coltyp == JET_coltypNil )
				return JET_errColumnNotFound;
			pidb->fidb |= fidbHasTagged;
			if ( pfield->ffield & ffieldMultivalue )
				pidb->fidb |= fidbHasMultivalue;
			}
		else
			return JET_errBadColumnId;
		}

	/*	copy info into IDB
	/**/
	pidb->iidxsegMac = iidxsegMac;
	pidb->fidb |= bFlags;
	memcpy( pidb->rgidxseg, rgidxseg, iidxsegMac * sizeof(IDXSEG) );
	pidb->langid = langid;

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\jet500\jet\dae\src\fldext.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>
#include <stddef.h>

#include "daedef.h"
#include "pib.h"
#include "page.h"
#include "fmp.h"
#include "ssib.h"
#include "fucb.h"
#include "fcb.h"
#include "stapi.h"
#include "fdb.h"
#include "idb.h"
#include "dirapi.h"
#include "recint.h"
#ifdef ANGEL
#include "utilwin.h"
#else
#include "recapi.h"
#endif

#ifndef ANGEL
DeclAssertFile;					/* Declare file name for assert macros */

LOCAL INLINE ERR ErrRECIRetrieveColumns( FUCB *pfucb, JET_RETRIEVECOLUMN *pretcols, ULONG cretcols );

#endif


//+API
//	ErrRECExtractField
//	========================================================================
//	ErrRECExtractField( FDB *pfdb, LINE *plineRec, FID *pfid, ULONG itagSequence, ULONG *pitagSequence, LINE *plineField)
//
//	Extracts a field from a record.  This amounts to returning a pointer
//	into the record (to where the field data starts) and a count of the
//	number of bytes in the field data.
//
// PARAMETERS	pfdb				field descriptors for this record
//				plineRec			record to extract field from
//				pfid				field id of field to extract
//						  			If this parameter is zero, then the
//						  			tagged fields are scanned without
//						  			regard to their field ids, and occurance
//						  			number "itagSequence" is returned.  This can
//						  			be used to sequentially scan all values in
//						  			the tagged area of the record.	The field
//						  			id of the field value returned is placed
//						  			in *pfid as an output parameter.
//				itagSequence	  	if a tagged field is being extracted,
//								  	this parameter specifies which occurance
//								  	of the tagged field to extract.	 Tagged
//								  	field occurances are number consecutively
//								  	starting with 1.  Occurance numbers greater
//								  	than the maximum occurance in the record
//								  	are returned as NULL-valued fields.
//	 			plineField			Receives extracted field.  plineField->pb
//								  	will point into the record, at the start
//								  	of the field.  plineField->cb will be set
//								  	to the length of the field data.
//								  	If the field requested contains a NULL
//								  	value, then plineField->pb will be set to
//								  	NULL and plineField->cb will be set to 0.
//								  	Additionally, JET_wrnColumnNull would be returned
//	RETURNS	
//		JET_errSuccess			 	Everything worked.
//		JET_errColumnInvalid	 	The field id given does not
//	 	   						 	correspond to a defined field.
//		JET_wrnColumnNull 			Extracted column has null value
//-
ERR ErrRECExtractField(
	FDB		*pfdb,
	LINE  	*plineRec,
	FID		*pfid,
	ULONG 	*pitagSequence,
	ULONG 	itagSequence,
	LINE  	*plineField )
	{
	FID	  	fid;			 		// field to extract
	ULONG 	ulNumOccurances;		// counts field occurances

	/* the following field used only when *pfid is 0
	/**/
	FID				fidCur;					// field to return
	ULONG			ulNumCurOccurances=0;	// returned field occurances count

	BYTE			*pbRec;					// efficiency var: ptr to record data
	FID				fidFixedLastInRec;		// highest fixed fid actually in record
	FID				fidVarLastInRec;		// highest var fid actually in record
	UNALIGNED WORD	*pibVarOffs;			// pointer to var field offsets
	BYTE			*pbRecMax;				// end of current data record
	TAGFLD			*ptagfld;				// pointer to tagged field

	/*** Efficiency variables ***/
	Assert( pfid != NULL );
	fid = *pfid;
	Assert( pfdb != pfdbNil );
	Assert( !FLineNull( plineRec ) );
	Assert( plineRec->cb >= 4 );
	pbRec = plineRec->pb;
	Assert( plineField != NULL );
	fidFixedLastInRec = ((RECHDR*)pbRec)->fidFixedLastInRec;
	Assert( fidFixedLastInRec <= fidFixedMost );

	/*** ---------EXTRACTING FIXED FIELD-------- ***/
	if ( FFixedFid( fid ) )
		{
		BYTE *prgbitNullity;		// pointer to fixed field bitmap
		WORD *pibFixOffs;			// fixed field offsets

		if ( fid > pfdb->fidFixedLast )
			return JET_errColumnNotFound;
		if ( pfdb->pfieldFixed[fid-fidFixedLeast].coltyp == JET_coltypNil )
			return JET_errColumnNotFound;

		/*** Field not represented in record:  field is NULL ***/
		if ( fid > fidFixedLastInRec )
			goto NullField;

		/*** Adjust fid to an index ***/
		fid -= fidFixedLeast;

		/*** Byte containing bit representing fid's nullity ***/
		pibFixOffs = pfdb->pibFixedOffsets;
		prgbitNullity = pbRec + pibFixOffs[fidFixedLastInRec] + fid/8;

		/*** Bit is not set: field is NULL ***/
		if (!(*prgbitNullity & (1 << fid % 8))) goto NullField;

		/*** Set output parameter to length and address of field ***/
		plineField->cb = pibFixOffs[fid+1] - pibFixOffs[fid];
		plineField->pb = pbRec + pibFixOffs[fid];
		return JET_errSuccess;
		}

	/*** More efficiency variables ***/
	fidVarLastInRec = ((RECHDR*)pbRec)->fidVarLastInRec;
	pibVarOffs = (WORD *)(pbRec + pfdb->pibFixedOffsets[fidFixedLastInRec] +
		(fidFixedLastInRec + 7) / 8);
	Assert(pibVarOffs[fidVarLastInRec+1-fidVarLeast] <= plineRec->cb);

	/*** ---------EXTRACTING VARIABLE FIELD-------- ***/
	if ( FVarFid( fid ) )
		{
		if (fid > pfdb->fidVarLast)
			return JET_errColumnNotFound;
		if (pfdb->pfieldVar[fid-fidVarLeast].coltyp == JET_coltypNil)
			return JET_errColumnNotFound;

		/*** Field not represented in record: field is NULL ***/
		if (fid > fidVarLastInRec )
			goto NullField;

		/*** Adjust fid to an index ***/
		fid -= fidVarLeast;

		/*** Set output parameter: field length ***/
		plineField->cb = ibVarOffset( pibVarOffs[fid+1] ) - ibVarOffset( pibVarOffs[fid] );
		Assert(plineField->cb <= plineRec->cb);

		/*** Field is set to Null ***/
		if ( FVarNullBit( pibVarOffs[fid] ) )
			{
			Assert( plineField->cb == 0 );
			goto NullField;
			}

		/*** Length is zero: return success [zero-length non-null values are allowed] ***/
		if (plineField->cb == 0)
			{
			plineField->pb = NULL;
			return JET_errSuccess;
			}

		/*** Set output parameter: field address ***/
		plineField->pb = pbRec + ibVarOffset( pibVarOffs[fid] );
		Assert(plineField->pb >= pbRec && plineField->pb <= pbRec+plineRec->cb);
		return JET_errSuccess;
		}

	/*** ---------EXTRACTING TAGGED FIELD-------- ***/

	/*	for the first occurrence, itagSequence must be 1, not 0
	/**/
	if ( itagSequence == 0 )
		return JET_errBadItagSequence;

	if (fid > pfdb->fidTaggedLast)
		return JET_errColumnNotFound;

	Assert(FTaggedFid(fid) || fid == 0);

	if (fid != 0 &&
		pfdb->pfieldTagged[fid - fidTaggedLeast].coltyp == JET_coltypNil)
		return JET_errColumnNotFound;

	/*** Scan tagged fields, counting occurances of desired field ***/
	pbRecMax = pbRec + plineRec->cb;
	ptagfld = (TAGFLD*)(pbRec + ibVarOffset( pibVarOffs[fidVarLastInRec+1-fidVarLeast] ) );
	ulNumOccurances = 0;
	fidCur = 0;
	while ( (BYTE*)ptagfld < pbRecMax )
		{
		if ( fid == 0 )
			{
			/*  if we are scanning the whole tag fields, count proper
			 *  occurrence of current fid.
			 */
			if ( fidCur == ptagfld->fid )
				ulNumCurOccurances++;
			else
				{
				fidCur = ptagfld->fid;
				ulNumCurOccurances = 1;
				}

			/* set possible returned values
			/**/
			*pfid = fidCur;
			*pitagSequence = ulNumCurOccurances;
			}

		if ( fid == 0 || ptagfld->fid == fid )
			{
			if ( ++ulNumOccurances == itagSequence )
				{
				BOOL	fLongField;

				plineField->cb = ptagfld->cb;
				plineField->pb = ptagfld->rgb;

				fLongField = pfdb->pfieldTagged[*pfid - fidTaggedLeast].coltyp == JET_coltypLongText ||
					pfdb->pfieldTagged[*pfid - fidTaggedLeast].coltyp == JET_coltypLongBinary;

				return fLongField ? wrnRECLongField : JET_errSuccess;
				}
			}
		ptagfld = (TAGFLD*)((BYTE*)(ptagfld+1) + ptagfld->cb);
		Assert((BYTE*)ptagfld <= pbRecMax);
		}

	/*** Occurance not found: field is NULL, fall through ***/

NullField:
	/*** Null Field common exit point ***/
	plineField->cb = 0;
	plineField->pb = NULL;
	return JET_wrnColumnNull;
	}


#ifndef ANGEL
/*	counts number of columns for a given column id in a given record.
/**/
ERR ErrRECCountColumn( FUCB *pfucb, FID fid, INT *pccolumn, JET_GRBIT grbit )
	{
	ERR					err = JET_errSuccess;
	LINE					lineRec;
	FDB					*pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	INT					ccolumn = 0;
	BYTE					*pbRec;						// efficiency var: ptr to record data
	FID					fidFixedLastInRec;		// highest fixed fid actually in record
	FID					fidVarLastInRec;			// highest var fid actually in record
	UNALIGNED WORD		*pibVarOffs;				// pointer to var field offsets
	BYTE					*pbRecMax;					// end of current data record
	TAGFLD				*ptagfld;					// pointer to tagged field

	Assert( pfdb != pfdbNil );

	/*	get record
	/**/
	if ( ( grbit & JET_bitRetrieveCopy ) && FFUCBRetPrepared( pfucb ) )
		{
		/*	only index cursors have copy buffers.
		/**/
		Assert( FFUCBIndex( pfucb ) );
		lineRec = pfucb->lineWorkBuf;
		}
	else
		{
		if ( FFUCBIndex( pfucb ) )
			{
			CallR( ErrDIRGet( pfucb ) );
			}
		else
			{
			Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||
				PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst ||
				PcsrCurrent( pfucb )->csrstat == csrstatAfterLast );
			if ( PcsrCurrent( pfucb )->csrstat != csrstatOnCurNode )
				return JET_errNoCurrentRecord;
			Assert( pfucb->lineData.cb != 0 || FFUCBIndex( pfucb ) );
			}
		lineRec = pfucb->lineData;
		}
	Assert( lineRec.cb >= 4 );
	pbRec = lineRec.pb;
	fidFixedLastInRec = ((RECHDR *)pbRec)->fidFixedLastInRec;
	Assert( fidFixedLastInRec <= fidFixedMost );

	/*** ---------EXTRACTING FIXED FIELD-------- ***/
	if ( FFixedFid( fid ) )
		{
		BYTE *prgbitNullity;		// pointer to fixed field bitmap
		WORD *pibFixOffs;			// fixed field offsets

		if ( fid > pfdb->fidFixedLast )
			return JET_errColumnNotFound;
		if ( pfdb->pfieldFixed[fid-fidFixedLeast].coltyp == JET_coltypNil )
			return JET_errColumnNotFound;

		/*	column is NULL
		/**/
		if ( fid > fidFixedLastInRec )
			goto NullField;

		/*	adjust fid to index
		/**/
		fid -= fidFixedLeast;

		/*	byte containing bit repres