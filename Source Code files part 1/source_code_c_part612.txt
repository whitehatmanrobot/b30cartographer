(for example, in a menu or combo box). the long
        //  name is intended for more descriptive displays (for example,
        //  in an 'about box').
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

        //
        //  the last three members are intended for 'about box' information.
        //  these members are optional and may be zero length strings if
        //  the driver wishes.
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }


    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(padd, &add, (UINT)add.cbStruct);


    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd
)
{
    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a custom about box, so
        //  return MMSYSERR_NOTSUPPORTED...
        //
        return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  this driver does not support a custom dialog, so tell the ACM or
    //  calling application to display one for us. note that this is the
    //  _recommended_ method for consistency and simplicity of ACM drivers.
    //  why write code when you don't have to?
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM, a wave mapper or
//      an application to quickly get a destination format that this driver
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible. This message is normally
//      sent in response to an acmFormatSuggest function call.
//
//      Another way to think about this message is: what format would this
//      driver like to convert the source format to?
//
//      The caller may place restrictions on the destination format that
//      should be suggested. The padfs->fdwSuggest member contains the
//      restriction bits passed by the caller--see the description for
//      the return value for more information.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to an ACMDRVFORMATSUGGEST
//      structure that describes the source and destination (possibly with
//      restrictions) for a conversion.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if one or more of
//      the destination restriction bits is not supported. It is strongly
//      recommended that the driver support at least the following suggestion
//      restriction bits:
//
//      ACM_FORMATSUGGESTF_WFORMATTAG: The destination format tag must be
//      the same as the wFormatTag member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NCHANNELS: The destination channel count must be
//      the same as the nChannels member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NSAMPLESPERSEC: The destination samples per
//      second must be the same as the nSamplesPerSec member in the
//      destination format header.
//
//      ACM_FORMATSUGGESTF_WBITSPERSAMPLE: The destination bits per sample
//      must be the same as the wBitsPerSample member in the destination
//      format header.
//
//      If no destintation format can be suggested, then the driver should
//      return ACMERR_NOTPOSSIBLE.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    DWORD                   fdwSuggest;


    //
    //  grab the suggestion restriction bits and verify that we support
    //  the ones that are specified... an ACM driver must return the
    //  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
    //  are not supported.
    //
    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  get the source and destination formats in more convenient variables
    //
    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;


    //
    //
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!pcmIsValidFormat(pwfxSrc))
                break;


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is able to encode to A-Law and u-Law
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if ((WAVE_FORMAT_ALAW  != pwfxDst->wFormatTag) &&
                    (WAVE_FORMAT_MULAW != pwfxDst->wFormatTag))
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_ALAW;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is only able to encode to 8 bit
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if (G711_BITS_PER_SAMPLE != pwfxDst->wBitsPerSample)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = G711_BITS_PER_SAMPLE;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize
            //
            pwfxDst->nBlockAlign     = G711_BLOCKALIGNMENT(pwfxDst);
            pwfxDst->nAvgBytesPerSec = G711_AVGBYTESPERSEC(pwfxDst);
            pwfxDst->cbSize          = G711_WFX_EXTRA_BYTES;

            return (MMSYSERR_NOERROR);


        case WAVE_FORMAT_ALAW:
        case WAVE_FORMAT_MULAW:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!g711IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is able to decode to PCM from u-Law and A-Law
            //  as well as convert between u-Law and A-Law
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                switch (pwfxDst->wFormatTag)
                {
                    case WAVE_FORMAT_PCM:
                        break;

                    case WAVE_FORMAT_ALAW:
                        if (WAVE_FORMAT_MULAW != pwfxSrc->wFormatTag)
                            return (ACMERR_NOTPOSSIBLE);
                        break;

                    case WAVE_FORMAT_MULAW:
                        if (WAVE_FORMAT_ALAW != pwfxSrc->wFormatTag)
                            return (ACMERR_NOTPOSSIBLE);
                        break;

                    default:
                        return (ACMERR_NOTPOSSIBLE);
                }


                if (WAVE_FORMAT_PCM == pwfxDst->wFormatTag)
                {
                    //
                    //  if the destination bits per sample is restricted,
                    //  verify that it is within our capabilities...
                    //
                    //  this driver is only able to decode to 16 bit
                    //
                    if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
                    {
                        if (16 != pwfxDst->wBitsPerSample)
                            return (ACMERR_NOTPOSSIBLE);
                    }
                    else
                    {
                        pwfxDst->wBitsPerSample = 16;
                    }
                }
                else
                {
                    //
                    //  if the destination bits per sample is restricted,
                    //  verify that it is within our capabilities...
                    //
                    //  this driver is only able to convert between u-Law and
                    //  A-Law at the same bit depth (8 bit)
                    //
                    if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
                    {
                        if (G711_BITS_PER_SAMPLE != pwfxDst->wBitsPerSample)
                            return (ACMERR_NOTPOSSIBLE);
                    }
                    else
                    {
                        pwfxDst->wBitsPerSample = G711_BITS_PER_SAMPLE;
                    }
                }
            }
            else
            {
                if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
                {
                    if (16 == pwfxDst->wBitsPerSample)
                    {
                        pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
                    }
                    else if (8 == pwfxDst->wBitsPerSample)
                    {
                        if (WAVE_FORMAT_ALAW == pwfxSrc->wFormatTag)
                        {
                            pwfxDst->wFormatTag = WAVE_FORMAT_MULAW;
                        }
                        else if (WAVE_FORMAT_MULAW == pwfxSrc->wFormatTag)
                        {
                            pwfxDst->wFormatTag = WAVE_FORMAT_ALAW;
                        }
                        else
                        {
                            return (ACMERR_NOTPOSSIBLE);
                        }
                    }
                    else
                    {
                        return (ACMERR_NOTPOSSIBLE);
                    }
                }
                else
                {
                    pwfxDst->wFormatTag     = WAVE_FORMAT_PCM;
                    pwfxDst->wBitsPerSample = 16;
                }
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //
            //
            //
            if (WAVE_FORMAT_PCM == pwfxDst->wFormatTag)
            {
                //
                //  at this point, we have filled in all fields except the
                //  following for our 'suggested' destination format:
                //
                //      nAvgBytesPerSec
                //      nBlockAlign
                //      cbSize              !!! not used for PCM !!!
                //
                pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfxDst);
                pwfxDst->nAvgBytesPerSec = PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfxDst);

                // pwfxDst->cbSize       = not used;
            }

            //
            //  the suggested destination format tag is not PCM
            //
            else
            {

                //
                //  at this point, we have filled in all fields except the
                //  following for our 'suggested' destination format:
                //
                //      nAvgBytesPerSec
                //      nBlockAlign
                //      cbSize
                //
                pwfxDst->nBlockAlign     = G711_BLOCKALIGNMENT(pwfxDst);
                pwfxDst->nAvgBytesPerSec = G711_AVGBYTESPERSEC(pwfxDst);
                pwfxDst->cbSize          = G711_WFX_EXTRA_BYTES;
            }
            return (MMSYSERR_NOERROR);
    }


    //
    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this ACM driver
    //  cannot deal with.
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdFormatSuggest()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format.  return error.
            //
            if (ACM_DRIVER_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_ALAW:
                    uFormatTag = WAVE_FORMAT_ALAW;
                    break;

                case WAVE_FORMAT_MULAW:
                    uFormatTag = WAVE_FORMAT_MULAW;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_ALAW:
                    uFormatTag = WAVE_FORMAT_ALAW;
                    break;

                case WAVE_FORMAT_MULAW:
                    uFormatTag = WAVE_FORMAT_MULAW;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0] = '\0';
            break;

        case WAVE_FORMAT_ALAW:
            padft->dwFormatTagIndex = 1;
            padft->dwFormatTag      = WAVE_FORMAT_ALAW;
            padft->cbFormatSize     = sizeof(WAVEFORMATEX) +
                                      G711_WFX_EXTRA_BYTES;
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_G711;

            LoadStringCodec(pdi->hinst,
                       IDS_ACM_DRIVER_TAG_NAME_ALAW,
                       padft->szFormatTag,
                       SIZEOFACMSTR(padft->szFormatTag));
            break;

        case WAVE_FORMAT_MULAW:
            padft->dwFormatTagIndex = 2;
            padft->dwFormatTag      = WAVE_FORMAT_MULAW;
            padft->cbFormatSize     = sizeof(WAVEFORMATEX) +
                                      G711_WFX_EXTRA_BYTES;
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_G711;

            LoadStringCodec(pdi->hinst,
                       IDS_ACM_DRIVER_TAG_NAME_MULAW,
                       padft->szFormatTag,
                       SIZEOFACMSTR(padft->szFormatTag));
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX      pwfx;
    UINT                uFormatIndex;
    UINT                u;


    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  put some stuff in more accessible variables--note that we
            //  bring variable sizes down to a reasonable size for 16 bit
            //  code...
            //
            pwfx = padf->pwfx;
            uFormatIndex = (UINT)padf->dwFormatIndex;

            switch (padf->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (ACM_DRIVER_MAX_FORMATS_PCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    //
                    //  now fill in the format structure
                    //
                    pwfx->wFormatTag      = WAVE_FORMAT_PCM;

                    u = uFormatIndex / (ACM_DRIVER_MAX_BITSPERSAMPLE_PCM * ACM_DRIVER_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;
                    pwfx->wBitsPerSample  = 16;

                    pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx);
                    pwfx->nAvgBytesPerSec = PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfx);

                    //
                    //  note that the cbSize field is NOT valid for PCM
                    //  formats
                    //
                    //  pwfx->cbSize      = 0;
                    break;

                case WAVE_FORMAT_MULAW:
                case WAVE_FORMAT_ALAW:
                    if (ACM_DRIVER_MAX_FORMATS_G711 <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    pwfx->wFormatTag      = LOWORD(padf->dwFormatTag);

                    u = uFormatIndex / (ACM_DRIVER_MAX_BITSPERSAMPLE_G711 * ACM_DRIVER_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;
                    pwfx->wBitsPerSample  = G711_BITS_PER_SAMPLE;

                    pwfx->nBlockAlign     = G711_BLOCKALIGNMENT(pwfx);
                    pwfx->nAvgBytesPerSec = G711_AVGBYTESPERSEC(pwfx);
                    pwfx->cbSize          = G711_WFX_EXTRA_BYTES;
                    break;


                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            pwfx = padf->pwfx;

            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (!pcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                case WAVE_FORMAT_ALAW:
                case WAVE_FORMAT_MULAW:
                    if (!g711IsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.
    //
    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    BOOL                fRealTime;
    STREAMCONVERTPROC   fnConvert;
    PSTREAMINSTANCE     psi;


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));


    //
    //  the most important condition to check before doing anything else
    //  is that this ACM driver can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this driver.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a driver that is suitable for the conversion. also note that
    //  the ACM may call this driver several times with slightly different
    //  format specifications before giving up.
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            if (!pcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!g711IsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

            //
            //
            //
            if (WAVE_FORMAT_ALAW == pwfxDst->wFormatTag)
                fnConvert = PcmToAlaw;
            else
                fnConvert = PcmToUlaw;
            break;


        case WAVE_FORMAT_ALAW:
        case WAVE_FORMAT_MULAW:
            if (!g711IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (WAVE_FORMAT_PCM == pwfxDst->wFormatTag)
            {
                if (!pcmIsValidFormat(pwfxDst))
                    return (ACMERR_NOTPOSSIBLE);

                //
                //
                //
                if (WAVE_FORMAT_ALAW == pwfxSrc->wFormatTag)
                    fnConvert = AlawToPcm;
                else
                    fnConvert = UlawToPcm;
            }
            else
            {
                if (!g711IsValidFormat(pwfxDst))
                    return (ACMERR_NOTPOSSIBLE);

                //
                //  we are not a converter for equivelant format tags
                //
                if (pwfxSrc->wFormatTag == pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);

                //
                //
                //
                if (WAVE_FORMAT_ALAW == pwfxSrc->wFormatTag)
                    fnConvert = AlawToUlaw;
                else
                    fnConvert = UlawToAlaw;
            }
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  for this driver, we must also verify that the nChannels and
    //  nSamplesPerSec members are the same between the source and
    //  destination formats.
    //
    if (pwfxSrc->nChannels != pwfxDst->nChannels)
        return (MMSYSERR_NOTSUPPORTED);

    if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (0 != (ACM_STREAMOPENF_QUERY & padsi->fdwOpen))
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this driver allocates a small instance structure for each stream
    //
    //
    psi = (PSTREAMINSTANCE)LocalAlloc(LPTR, sizeof(*psi));
    if (NULL == psi)
    {
        return (MMSYSERR_NOMEM);
    }


    //
    //  fill out our instance structure
    //
    //  this driver stores a pointer to the conversion function that will
    //  be used for each conversion on this stream. we also store a
    //  copy of the _current_ configuration of the driver instance we
    //  are opened on. this must not change during the life of the stream
    //  instance.
    //
    //  this is also very important! if the user is able to configure how
    //  the driver performs conversions, the changes should only affect
    //  future open streams. all current open streams should behave as
    //  they were configured during the open.
    //
    psi->fnConvert  = fnConvert;
    psi->fdwConfig  = pdi->fdwConfig;


    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0L;
    padsi->dwDriver  = (DWORD_PTR)psi;

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose). The ACM driver should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      NOTE! It is _strongly_ recommended that a driver not fail to close
//      a conversion stream.
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCE     psi;

    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (PSTREAMINSTANCE)padsi->dwDriver;
    if (NULL != psi)
    {
        //
        //  free the stream instance structure
        //
        LocalFree((HLOCAL)psi);
    }

    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    PSTREAMINSTANCE     psi;
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    DWORD               cb;

    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    //
    //
    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        //
        //  how many destination bytes are needed to hold the source data
        //  of padss->cbSrcLength bytes
        //
        //  always round UP (since G711 can be computed exactly, don't
        //  round. it is simply a 2:1 compression ratio--and we drop partial
        //  samples)
        //
        case ACM_STREAMSIZEF_SOURCE:
            cb = padss->cbSrcLength;

            switch (pwfxSrc->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    cb = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)pwfxSrc, cb);
                    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)pwfxSrc, cb);

                    if (0 == cb)
                    {
                        return (ACMERR_NOTPOSSIBLE);
                    }

                    cb = (cb / 2);
                    break;

                case WAVE_FORMAT_ALAW:
                case WAVE_FORMAT_MULAW:
                    cb = G711_BYTESTOSAMPLES(pwfxSrc, cb);
                    cb = G711_SAMPLESTOBYTES(pwfxSrc, cb);

                    if (0 == cb)
                    {
                        return (ACMERR_NOTPOSSIBLE);
                    }

                    if (WAVE_FORMAT_PCM == pwfxDst->wFormatTag)
                    {
                        // Make sure we won't overflow padss->cbDstLength
                        if ((0xFFFFFFFFL / 2) < cb)
                        {
                            return (ACMERR_NOTPOSSIBLE);
                        }
                        cb = (cb * 2);
                    }
                    break;
            }

            padss->cbDstLength = cb;
            return (MMSYSERR_NOERROR);


        //
        //  how many source bytes can be encoded into a
        //  destination buffer of padss->cbDstLength bytes
        //
        //  always round DOWN (drop partial samples)
        //
        case ACM_STREAMSIZEF_DESTINATION:
            cb = padss->cbDstLength;

            switch (pwfxDst->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    cb = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)pwfxDst, cb);
                    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)pwfxDst, cb);

                    cb = (cb / 2);

                    if (0 == cb)
                    {
                        return (ACMERR_NOTPOSSIBLE);
                    }

                    break;

                case WAVE_FORMAT_ALAW:
                case WAVE_FORMAT_MULAW:
                    cb = G711_BYTESTOSAMPLES(pwfxDst, cb);
                    cb = G711_SAMPLESTOBYTES(pwfxDst, cb);

                    if (0 == cb)
                    {
                        return (ACMERR_NOTPOSSIBLE);
                    }

                    if (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag)
                    {
                        // Make sure we won't overflow padss->cbDstLength
                        if ((0xFFFFFFFFL / 2) < cb)
                        {
                            return (ACMERR_NOTPOSSIBLE);
                        }
                        cb = (cb * 2);
                    }
                    break;
            }

            padss->cbSrcLength = cb;
            return (MMSYSERR_NOERROR);
    }

    //
    //  if the query type is not understood by this driver, then we need
    //  to return MMSYSERR_NOTSUPPORTED.
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR               dwId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PDRIVERINSTANCE     pdi;

    //
    //  make pdi either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwId is for other
    //  messages (instance data).
    //
    pdi = (PDRIVERINSTANCE)dwId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef _WIN32
            DbgInitialize(TRUE);
#endif
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
            return (1L);


        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
            lr = acmdDriverClose(pdi);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            lr = acmdDriverConfigure(pdi, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            lr = acmdDriverDetails(pdi, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            lr = acmdDriverAbout(pdi, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
       case ACMDM_FORMAT_SUGGEST:
            lr = acmdFormatSuggest(pdi, (LPACMDRVFORMATSUGGEST)lParam1);
            return (lr);


        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
            lr = acmdFormatTagDetails(pdi, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            lr = acmdFormatDetails(pdi, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            lr = acmdStreamOpen(pdi, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            lr = acmdStreamClose((LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
            lr = acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
        {
            PSTREAMINSTANCE         psi;
            LPACMDRVSTREAMINSTANCE  padsi;
            LPACMDRVSTREAMHEADER    padsh;

            //
            //  our stream instance data is a pointer to the conversion
            //  procedure needed to convert the pwfxSrc data to pwfxDst.
            //  the correct procedure to use was decided in acmdStreamOpen
            //
            padsi = (LPACMDRVSTREAMINSTANCE)lParam1;
            padsh = (LPACMDRVSTREAMHEADER)lParam2;

            psi   = (PSTREAMINSTANCE)padsi->dwDriver;

            lr = psi->fnConvert(padsi, padsh);
            return (lr);
        }
    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\unicode.h ===
#ifdef UNICODE

#define ATOI( pString ) UnicodeStringToNumber( pString )
#define ATOL( pString ) (LONG)UnicodeStringToNumber( pString )
#define STRCHR( pString, Char ) wcschr( pString, Char )
#define STRRCHR( pString, Char ) wcsrchr( pString, Char )
#define STRSTR( pString, pString1 ) wcsstr( pString, pString1 )
#define STRLEN( pString )   wcslen( pString )

#else

#define ATOI( pString ) atoi( pString )
#define ATOL( pString ) atol( pString )
#define STRCHR( pString, Char ) strchr( pString, Char )
#define STRRCHR( pString, Char ) strrchr( pString, Char )
#define STRSTR( pString, pString1 ) strstr( pString, pString1 )
#define STRLEN( pString )   strlen( pString )

#endif


#define UNKNOWN_LENGTH  -1

INT AnsiToUnicodeString( LPCSTR pAnsi, LPWSTR pUnicode, INT StringLength );
LPWSTR AllocateUnicodeString( LPCSTR pAnsi );
VOID FreeUnicodeString( LPWSTR pString );
int UnicodeStringToNumber( LPCWSTR pString );

#ifndef UNICODE

INT UnicodeToAnsiString( LPCWSTR pUnicode, LPSTR pAnsi, INT StringLength );
LPSTR AllocateAnsiString( LPCWSTR pUnicode );
VOID FreeAnsiString( LPSTR pString );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\mplayer2\unicode.c ===
#include <windows.h>
#include <stdlib.h>

#include "mplayer.h"
#include "unicode.h"

/* AnsiToUnicodeString
 *
 * Parameters:
 *
 *     pAnsi - A valid source ANSI string.
 *
 *     pUnicode - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source ANSI string
 *         excluding the null terminator.  This value may be
 *         UNKNOWN_LENGTH (-1).
 *
 *
 * Return:
 *
 *     The return value from MultiByteToWideChar, the number of
 *         wide characters returned.
 *
 *
 * andrewbe, 11 Jan 1993
 *
 * andrewbe, 01 Feb 1994: Added support for in-place conversion
 */
INT AnsiToUnicodeString( LPCSTR pAnsi, LPWSTR pUnicode, INT StringLength )
{
#ifdef IN_PLACE
    /* #def'ed out, 'cos it turned out I didn't need it.
     * It might be useful sometime, however.
     * BUT NOTE: COMPLETELY UNTESTED
     */
    LPWSTR pTemp
    LPWSTR pSave;
#endif
    INT    rc;

    if( !pAnsi )
    {
        DPF( "NULL pointer passed to AnsiToUnicodeString\n" );
        return 0;
    }

    if( StringLength == UNKNOWN_LENGTH )
        StringLength = strlen( pAnsi );

#ifdef IN_PLACE
    /* Allow in-place conversion.  We assume that the buffer is big enough.
     * MultiByteToWideChar doesn't support this.
     */
    if( pAnsi == (LPCSTR)pUnicode )
    {
        pTemp = AllocMem( StringLength * sizeof( WCHAR ) + sizeof( WCHAR ) );

        if( !pTemp )
            return 0;

        pSave = pUnicode;
        pUnicode = pTemp;
    }
#endif

    rc = MultiByteToWideChar( CP_ACP,
                              MB_PRECOMPOSED,
                              pAnsi,
                              StringLength + 1,
                              pUnicode,
                              StringLength + 1 );

#ifdef IN_PLACE
    if( pAnsi == (LPCSTR)pUnicode )
    {
        pTemp = pUnicode;
        pUnicode = pSave;

        lstrcpyW( pUnicode, pTemp );

        FreeMem( pTemp, StringLength * sizeof( WCHAR ) + sizeof( WCHAR ) );
    }
#endif

    return rc;
}


/* AllocateUnicodeString
 *
 * Parameter:
 *
 *     pAnsi - A valid source ANSI string.
 *
 * Return:
 *
 *     A Unicode copy of the supplied ANSI string.
 *     NULL if pAnsi is NULL or the allocation or conversion fails.
 *
 * andrewbe, 27 Jan 1994
 */
LPWSTR AllocateUnicodeString( LPCSTR pAnsi )
{
    LPWSTR pUnicode;
    INT    Length;

    if( !pAnsi )
    {
        DPF( "NULL pointer passed to AllocateUnicodeString\n" );
        return NULL;
    }

    Length = strlen( pAnsi );

    pUnicode = AllocMem( Length * sizeof( WCHAR ) + sizeof( WCHAR ) );

    if( pUnicode )
    {
        if( 0 == AnsiToUnicodeString( pAnsi, pUnicode, Length ) )
        {
            FreeMem( pUnicode, Length * sizeof( WCHAR ) + sizeof( WCHAR )  );
            pUnicode = NULL;
        }
    }

    return pUnicode;
}


/* FreeUnicodeString
 *
 * Parameter:
 *
 *     pString - A valid source Unicode string.
 *
 * Return:
 *
 *     TRUE if the string was successfully freed, FALSE otherwise.
 *
 * andrewbe, 27 Jan 1994
 */
VOID FreeUnicodeString( LPWSTR pString )
{
    if( !pString )
    {
        DPF( "NULL pointer passed to FreeUnicodeString\n" );
        return;
    }

    FreeMem( pString, wcslen( pString ) * sizeof( WCHAR ) + sizeof( WCHAR )  );
}



/* UnicodeStringToNumber
 *
 * Parameter:
 *
 *     pString - A valid source Unicode string.
 *
 * Return:
 *
 *     The integer value represented by the string.
 *
 * andrewbe, 27 Jan 1994
 */
#define BUF_LEN 265
int UnicodeStringToNumber( LPCWSTR pString )
{
    CHAR strAnsi[BUF_LEN];

#ifdef DEBUG
    if( ( wcslen( pString ) + 1 ) > BUF_LEN )
    {
        DPF( "Buffer cannot accommodate string passed to UnicodeStringToNumber\n" );
    }
#endif

    WideCharToMultiByte( CP_ACP, 0, pString, -1, strAnsi,
                         sizeof strAnsi, NULL, NULL );

    return atoi( strAnsi );
}


#ifndef UNICODE


/* UnicodeToAnsiString
 *
 * Parameters:
 *
 *     pUnicode - A valid source Unicode string.
 *
 *     pANSI - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source Unicode string.
 *         If 0 (NULL_TERMINATED), the string is assumed to be
 *         null-terminated.
 *
 * Return:
 *
 *     The return value from WideCharToMultiByte, the number of
 *         multi-byte characters returned.
 *
 *
 * andrewbe, 11 Jan 1993
 */
INT UnicodeToAnsiString( LPCWSTR pUnicode, LPSTR pAnsi, INT StringLength )
{
    INT   rc = 0;

    if( StringLength == UNKNOWN_LENGTH )
        StringLength = wcslen( pUnicode );

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength + 1,
                                  pAnsi,
                                  StringLength + 1,
                                  NULL,
                                  NULL );
    }

    return rc;

}


/* AllocateAnsiString
 *
 * Parameter:
 *
 *     pAnsi - A valid source Unicode string.
 *
 * Return:
 *
 *     An ANSI copy of the supplied Unicode string.
 *     NULL if pUnicode is NULL or the allocation or conversion fails.
 *
 * andrewbe, 27 Jan 1994
 */
LPSTR AllocateAnsiString( LPCWSTR pUnicode )
{
    LPSTR pAnsi;
    INT   Length;

    if( !pUnicode )
    {
        DPF( "NULL pointer passed to AllocateUnicodeString\n" );
        return NULL;
    }

    Length = wcslen( pUnicode );

    pAnsi = AllocMem( Length * sizeof( CHAR ) + sizeof( CHAR ) );

    if( pAnsi )
    {
        if( 0 == UnicodeToAnsiString( pUnicode, pAnsi, Length ) )
        {
            FreeMem( pAnsi, Length * sizeof( CHAR ) + sizeof( CHAR )  );
            pAnsi = NULL;
        }
    }

    return pAnsi;
}


/* FreeUnicodeString
 *
 * Parameter:
 *
 *     pString - A valid source Unicode string.
 *
 * Return:
 *
 *     TRUE if the string was successfully freed, FALSE otherwise.
 *
 * andrewbe, 27 Jan 1994
 */
VOID FreeAnsiString( LPSTR pString )
{
    if( !pString )
    {
        DPF( "NULL pointer passed to FreeAnsiString\n" );
        return;
    }

    FreeMem( pString, strlen( pString ) * sizeof( CHAR ) + sizeof( CHAR ) );
}

#endif /* NOT UNICODE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\g711\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define DEBUG_SECTION       "Debug"         // section name for 
#define DEBUG_MODULE_NAME   "MSG711"        // key name and prefix for output
#define DEBUG_MAX_LINE_LEN  255             // max line length (bytes)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define DPF      dprintf
#else
    #define DbgEnable(x)        FALSE
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #pragma warning(disable:4002)
    #define DPF()
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\g711\g711.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  g711.c
//
//  Description:
//      This file contains encode and decode routines for
//      CCITT Rec. G.711 (A-law and u-law).
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "g711.h"

#include "debug.h"


typedef BYTE HUGE *HPBYTE;
typedef WORD HUGE *HPWORD;


//
//
//
extern const SHORT BCODE AlawToPcmTable[256];
extern const SHORT BCODE UlawToPcmTable[256];
extern const BYTE BCODE AlawToUlawTable[256];
extern const BYTE BCODE UlawToAlawTable[256];


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL AlawToUlaw
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from A-law to u-law.  This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//      
//
//  History:
//      08/01/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AlawToUlaw
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{
    HPBYTE  hpbSrc, hpbDst;
    DWORD   cb;
    DWORD   i;
    PSTREAMINSTANCE     psi;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    cb = padsh->cbSrcLength;
    cb = G711_BYTESTOSAMPLES(padsi->pwfxSrc, cb);
    cb = G711_SAMPLESTOBYTES(padsi->pwfxSrc, cb);
    padsh->cbSrcLengthUsed = cb;

    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);

    hpbSrc = (HPBYTE) padsh->pbSrc;
    hpbDst = (HPBYTE) padsh->pbDst;
    
    for (i=cb; i>0; i--)
        *(hpbDst++) = AlawToUlawTable[*(hpbSrc++)];
        
    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = cb;

    return (MMSYSERR_NOERROR);
    
} // AlawToUlaw()


//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL UlawToAlaw
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from u-law to A-law. This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//  History:
//      08/01/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL UlawToAlaw
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{
    HPBYTE  hpbSrc, hpbDst;
    DWORD   cb;
    DWORD   i;
    PSTREAMINSTANCE     psi;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    cb = padsh->cbSrcLength;
    cb = G711_BYTESTOSAMPLES(padsi->pwfxSrc, cb);
    cb = G711_SAMPLESTOBYTES(padsi->pwfxSrc, cb);
    padsh->cbSrcLengthUsed = cb;
    
    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);

    hpbSrc = (HPBYTE) padsh->pbSrc;
    hpbDst = (HPBYTE) padsh->pbDst;
    
    for (i=cb; i>0; i--)
        *(hpbDst++) = UlawToAlawTable[*(hpbSrc++)];

    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = cb;
        
    return (MMSYSERR_NOERROR);
    
} // UlawToAlaw()


//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL AlawToPcm
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from A-law to PCM. This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//  History:
//      07/28/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AlawToPcm
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{
    HPWORD  hpwDst;
    HPBYTE  hpbSrc;
    DWORD   cb;
    DWORD   cSamples;
    DWORD   i;
    PSTREAMINSTANCE     psi;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    cb = padsh->cbSrcLength;
    cSamples = G711_BYTESTOSAMPLES(padsi->pwfxSrc, cb);
    
    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)padsi->pwfxDst, cSamples);
    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);
    
    cb = G711_SAMPLESTOBYTES(padsi->pwfxSrc, cSamples);
    padsh->cbSrcLengthUsed = cb;

    hpbSrc = (HPBYTE) padsh->pbSrc;
    hpwDst = (HPWORD) padsh->pbDst;
    
    for ( i=cb; i>0; i--)
        *(hpwDst++) = AlawToPcmTable[*(hpbSrc++)];

    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = (DWORD)(((HPBYTE)hpwDst) - (HPBYTE)padsh->pbDst);

    return (MMSYSERR_NOERROR);

} // AlawToPcm()


//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL PcmToAlaw
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from PCM to A-law. This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//  History:
//      07/28/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL PcmToAlaw
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{
    HPBYTE                  hpbDst;
    HPWORD                  hpwSrc;
    DWORD                   cb;
    DWORD		    cSamples;
    DWORD                   i;
    
    signed short int        wSample;
    BYTE                    alaw;
    PSTREAMINSTANCE     psi;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    cb = padsh->cbSrcLength;
    cSamples = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)padsi->pwfxSrc, cb);
    
    cb = G711_SAMPLESTOBYTES(padsi->pwfxDst, cSamples);
    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);

    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)padsi->pwfxSrc, cSamples);
    padsh->cbSrcLengthUsed = cb;

    // hpwSrc, hpdDst will walk thru src and dst buffers
    hpbDst = (HPBYTE) padsh->pbDst;
    hpwSrc = (HPWORD) padsh->pbSrc;
    
    //
    //
    // Compression from 16-bit PCM
    //
    //     
    
    // Walk thru the source buffer.  Since the source buffer has 16-bit PCM we
    // need to convert cb/2 samples.
    for (i=cb/2; i>0; i--)
        {
        
        //  Get a signed 16-bit PCM sample from the src buffer
        wSample = (signed short int) *(hpwSrc++);
        
        // We'll init our A-law value per the sign of the PCM sample.  A-law
        // characters have the MSB=1 for positive PCM data.  Also, we'll
        // convert our signed 16-bit PCM value to it's absolute value and
        // then work on that to get the rest of the A-law character bits.
        if (wSample < 0)
            {
            alaw = 0x00;
            wSample = -wSample;
            if (wSample < 0) wSample = 0x7FFF;
            }
        else
            {
            alaw = 0x80;
            }
                            
        // Now we test the PCM sample amplitude and create the A-law character.
        // Study the CCITT A-law for more detail.
        
        if (wSample >= 2048)
            // 2048 <= wSample < 32768
            {
            if (wSample >= 8192)
                // 8192 <= wSample < 32768
                {
                if (wSample >= 16384)
                    // 16384 <= wSample < 32768
                    {
                    alaw |= 0x70 | ((wSample >> 10) & 0x0F);
                    }
                    
                else
                    // 8192 <= wSample < 16384
                    {
                    alaw |= 0x60 | ((wSample >> 9) & 0x0F);
                    }
                }
            else
                // 2048 <= wSample < 8192
                {
                
                if (wSample >= 4096)
                    // 4096 <= wSample < 8192
                    {
                    alaw |= 0x50 | ((wSample >> 8) & 0x0F);
                    }
                    
                else
                    // 2048 <= wSample < 4096
                    {
                    alaw |= 0x40 | ((wSample >> 7) & 0x0F);
                    }
                }
            }
        else
            // 0 <= wSample < 2048
            {
            if (wSample >= 512)
                // 512 <= wSample < 2048
                {
                
                if (wSample >= 1024)
                    // 1024 <= wSample < 2048
                    {
                    alaw |= 0x30 | ((wSample >> 6) & 0x0F);
                    }
                
                else
                    // 512 <= wSample < 1024
                    {
                    alaw |= 0x20 | ((wSample >> 5) & 0x0F);
                    }
                }
            else
                    // 0 <= wSample < 512
                    {
                    alaw |= 0x00 | ((wSample >> 4) & 0x1F);
                    }
            }
                
        
            
        *(hpbDst++) = alaw ^ 0x55;      // Invert even bits
        }   // end for
    
    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = (DWORD)(hpbDst - (HPBYTE)padsh->pbDst);

    return (MMSYSERR_NOERROR);
    
} // PcmToAlaw()


//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL UlawToPcm
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from u-law to PCM. This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//  History:
//      08/01/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL UlawToPcm
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{
    HPBYTE  hpbSrc;
    HPWORD  hpwDst;
    DWORD   cb;
    DWORD   cSamples;
    DWORD   i;
    PSTREAMINSTANCE     psi;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    cb = padsh->cbSrcLength;
    cSamples = G711_BYTESTOSAMPLES(padsi->pwfxSrc, cb);
    
    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)padsi->pwfxDst, cSamples);
    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);

    cb = G711_SAMPLESTOBYTES(padsi->pwfxSrc, cSamples);
    padsh->cbSrcLengthUsed = cb;

    hpbSrc = (HPBYTE) padsh->pbSrc;
    hpwDst = (HPWORD) padsh->pbDst;
    
    for ( i=cb; i>0; i--)
        *(hpwDst++) = UlawToPcmTable[*(hpbSrc++)];

    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = (DWORD)(((HPBYTE)hpwDst) - (HPBYTE)padsh->pbDst);

    return (MMSYSERR_NOERROR);

} // UlawToPcm()


//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL PcmToUlaw
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from PCM to u-law. This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//  History:
//      08/01/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL PcmToUlaw
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{

    HPWORD                  hpwSrc;
    HPBYTE                  hpbDst;
    DWORD                   cb;
    DWORD		    cSamples;
    DWORD                   i;
    
    signed short int        wSample;
    BYTE                    ulaw;
    PSTREAMINSTANCE     psi;
    
    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    //
    // For now we are using a straight-forward/brute-force method
    // for converting from 16-bit PCM to u-law.  This can probably
    // be made more efficient if some thought is put into it...
    //

    cb = padsh->cbSrcLength;
    cSamples = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)padsi->pwfxSrc, cb);
    
    cb = G711_SAMPLESTOBYTES(padsi->pwfxDst, cSamples);
    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);
    
    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)padsi->pwfxSrc, cSamples);
    padsh->cbSrcLengthUsed = cb;

    // hpwSrc and hpbDst will walk thru the src and dst buffers
    hpwSrc = (HPWORD) padsh->pbSrc;
    hpbDst = (HPBYTE) padsh->pbDst;
     
    //
    //
    // Handle compression from 16-bit PCM
    //
    //     
    
    // Walk thru the source buffer.  Since the source buffer has 16-bit PCM we
    // need to convert cb/2 samples.
    for (i=cb/2; i>0; i--)
        {
        
        //  Get a signed 16-bit PCM sample from the src buffer
        wSample = (signed short int) *(hpwSrc++);
        
        // We'll init our u-law value per the sign of the PCM sample.  u-law
        // characters have the MSB=1 for positive PCM data.  Also, we'll
        // convert our signed 16-bit PCM value to it's absolute value and
        // then work on that to get the rest of the u-law character bits.
        if (wSample < 0)
            {
            ulaw = 0x00;
            wSample = -wSample;
            if (wSample < 0) wSample = 0x7FFF;
            }
        else
            {
            ulaw = 0x80;
            }
            
        // For now, let's shift this 16-bit value
        //  so that it is within the range defined
        //  by CCITT u-law.
        wSample = wSample >> 2;
                            
        // Now we test the PCM sample amplitude and create the u-law character.
        // Study the CCITT u-law for more details.
        if (wSample >= 8159)
            goto Gotulaw;
        if (wSample >= 4063)
            {
            ulaw |= 0x00 + 15-((wSample-4063)/256);
            goto Gotulaw;
            }
        if (wSample >= 2015)
            {
            ulaw |= 0x10 + 15-((wSample-2015)/128);
            goto Gotulaw;
            }
        if (wSample >= 991)
            {
            ulaw |= 0x20 + 15-((wSample-991)/64);
            goto Gotulaw;
            }
        if (wSample >= 479)
            {
            ulaw |= 0x30 + 15-((wSample-479)/32);
            goto Gotulaw;
            }
        if (wSample >= 223)
            {
            ulaw |= 0x40 + 15-((wSample-223)/16);
            goto Gotulaw;
            }
        if (wSample >= 95)
            {
            ulaw |= 0x50 + 15-((wSample-95)/8);
            goto Gotulaw;
            }
        if (wSample >= 31)
            {
            ulaw |= 0x60 + 15-((wSample-31)/4);
            goto Gotulaw;
            }
        ulaw |= 0x70 + 15-((wSample)/2);
        
Gotulaw:
        *(hpbDst++) = ulaw;
        }


    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = (DWORD)(hpbDst - (HPBYTE) padsh->pbDst);

    return (MMSYSERR_NOERROR);
    
} // PcmToUlaw()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  Name:
//      AlawToPcmTable
//
//
//  Description:
//      this array maps A-law characters to 16-bit PCM
//
//      
//  Arguments:
//      the index into the array is an A-law character
//
//  Return:
//      an element of the array is a 16-bit PCM value
//
//  Notes:
//
//
//  History:
//      07/28/93    Created.
//
//
//--------------------------------------------------------------------------;
const SHORT BCODE AlawToPcmTable[256] =
    {
         -5504,         // y[00]=   -688
         -5248,         // y[01]=   -656
         -6016,         // y[02]=   -752
         -5760,         // y[03]=   -720
         -4480,         // y[04]=   -560
         -4224,         // y[05]=   -528
         -4992,         // y[06]=   -624
         -4736,         // y[07]=   -592
         -7552,         // y[08]=   -944
         -7296,         // y[09]=   -912
         -8064,         // y[0a]=  -1008
         -7808,         // y[0b]=   -976
         -6528,         // y[0c]=   -816
         -6272,         // y[0d]=   -784
         -7040,         // y[0e]=   -880
         -6784,         // y[0f]=   -848
         -2752,         // y[10]=   -344
         -2624,         // y[11]=   -328
         -3008,         // y[12]=   -376
         -2880,         // y[13]=   -360
         -2240,         // y[14]=   -280
         -2112,         // y[15]=   -264
         -2496,         // y[16]=   -312
         -2368,         // y[17]=   -296
         -3776,         // y[18]=   -472
         -3648,         // y[19]=   -456
         -4032,         // y[1a]=   -504
         -3904,         // y[1b]=   -488
         -3264,         // y[1c]=   -408
         -3136,         // y[1d]=   -392
         -3520,         // y[1e]=   -440
         -3392,         // y[1f]=   -424
        -22016,         // y[20]=  -2752
        -20992,         // y[21]=  -2624
        -24064,         // y[22]=  -3008
        -23040,         // y[23]=  -2880
        -17920,         // y[24]=  -2240
        -16896,         // y[25]=  -2112
        -19968,         // y[26]=  -2496
        -18944,         // y[27]=  -2368
        -30208,         // y[28]=  -3776
        -29184,         // y[29]=  -3648
        -32256,         // y[2a]=  -4032
        -31232,         // y[2b]=  -3904
        -26112,         // y[2c]=  -3264
        -25088,         // y[2d]=  -3136
        -28160,         // y[2e]=  -3520
        -27136,         // y[2f]=  -3392
        -11008,         // y[30]=  -1376
        -10496,         // y[31]=  -1312
        -12032,         // y[32]=  -1504
        -11520,         // y[33]=  -1440
         -8960,         // y[34]=  -1120
         -8448,         // y[35]=  -1056
         -9984,         // y[36]=  -1248
         -9472,         // y[37]=  -1184
        -15104,         // y[38]=  -1888
        -14592,         // y[39]=  -1824
        -16128,         // y[3a]=  -2016
        -15616,         // y[3b]=  -1952
        -13056,         // y[3c]=  -1632
        -12544,         // y[3d]=  -1568
        -14080,         // y[3e]=  -1760
        -13568,         // y[3f]=  -1696
          -344,         // y[40]=    -43
          -328,         // y[41]=    -41
          -376,         // y[42]=    -47
          -360,         // y[43]=    -45
          -280,         // y[44]=    -35
          -264,         // y[45]=    -33
          -312,         // y[46]=    -39
          -296,         // y[47]=    -37
          -472,         // y[48]=    -59
          -456,         // y[49]=    -57
          -504,         // y[4a]=    -63
          -488,         // y[4b]=    -61
          -408,         // y[4c]=    -51
          -392,         // y[4d]=    -49
          -440,         // y[4e]=    -55
          -424,         // y[4f]=    -53
           -88,         // y[50]=    -11
           -72,         // y[51]=     -9
          -120,         // y[52]=    -15
          -104,         // y[53]=    -13
           -24,         // y[54]=     -3
            -8,         // y[55]=     -1
           -56,         // y[56]=     -7
           -40,         // y[57]=     -5
          -216,         // y[58]=    -27
          -200,         // y[59]=    -25
          -248,         // y[5a]=    -31
          -232,         // y[5b]=    -29
          -152,         // y[5c]=    -19
          -136,         // y[5d]=    -17
          -184,         // y[5e]=    -23
          -168,         // y[5f]=    -21
         -1376,         // y[60]=   -172
         -1312,         // y[61]=   -164
         -1504,         // y[62]=   -188
         -1440,         // y[63]=   -180
         -1120,         // y[64]=   -140
         -1056,         // y[65]=   -132
         -1248,         // y[66]=   -156
         -1184,         // y[67]=   -148
         -1888,         // y[68]=   -236
         -1824,         // y[69]=   -228
         -2016,         // y[6a]=   -252
         -1952,         // y[6b]=   -244
         -1632,         // y[6c]=   -204
         -1568,         // y[6d]=   -196
         -1760,         // y[6e]=   -220
         -1696,         // y[6f]=   -212
          -688,         // y[70]=    -86
          -656,         // y[71]=    -82
          -752,         // y[72]=    -94
          -720,         // y[73]=    -90
          -560,         // y[74]=    -70
          -528,         // y[75]=    -66
          -624,         // y[76]=    -78
          -592,         // y[77]=    -74
          -944,         // y[78]=   -118
          -912,         // y[79]=   -114
         -1008,         // y[7a]=   -126
          -976,         // y[7b]=   -122
          -816,         // y[7c]=   -102
          -784,         // y[7d]=    -98
          -880,         // y[7e]=   -110
          -848,         // y[7f]=   -106
          5504,         // y[80]=    688
          5248,         // y[81]=    656
          6016,         // y[82]=    752
          5760,         // y[83]=    720
          4480,         // y[84]=    560
          4224,         // y[85]=    528
          4992,         // y[86]=    624
          4736,         // y[87]=    592
          7552,         // y[88]=    944
          7296,         // y[89]=    912
          8064,         // y[8a]=   1008
          7808,         // y[8b]=    976
          6528,         // y[8c]=    816
          6272,         // y[8d]=    784
          7040,         // y[8e]=    880
          6784,         // y[8f]=    848
          2752,         // y[90]=    344
          2624,         // y[91]=    328
          3008,         // y[92]=    376
          2880,         // y[93]=    360
          2240,         // y[94]=    280
          2112,         // y[95]=    264
          2496,         // y[96]=    312
          2368,         // y[97]=    296
          3776,         // y[98]=    472
          3648,         // y[99]=    456
          4032,         // y[9a]=    504
          3904,         // y[9b]=    488
          3264,         // y[9c]=    408
          3136,         // y[9d]=    392
          3520,         // y[9e]=    440
          3392,         // y[9f]=    424
         22016,         // y[a0]=   2752
         20992,         // y[a1]=   2624
         24064,         // y[a2]=   3008
         23040,         // y[a3]=   2880
         17920,         // y[a4]=   2240
         16896,         // y[a5]=   2112
         19968,         // y[a6]=   2496
         18944,         // y[a7]=   2368
         30208,         // y[a8]=   3776
         29184,         // y[a9]=   3648
         32256,         // y[aa]=   4032
         31232,         // y[ab]=   3904
         26112,         // y[ac]=   3264
         25088,         // y[ad]=   3136
         28160,         // y[ae]=   3520
         27136,         // y[af]=   3392
         11008,         // y[b0]=   1376
         10496,         // y[b1]=   1312
         12032,         // y[b2]=   1504
         11520,         // y[b3]=   1440
          8960,         // y[b4]=   1120
          8448,         // y[b5]=   1056
          9984,         // y[b6]=   1248
          9472,         // y[b7]=   1184
         15104,         // y[b8]=   1888
         14592,         // y[b9]=   1824
         16128,         // y[ba]=   2016
         15616,         // y[bb]=   1952
         13056,         // y[bc]=   1632
         12544,         // y[bd]=   1568
         14080,         // y[be]=   1760
         13568,         // y[bf]=   1696
           344,         // y[c0]=     43
           328,         // y[c1]=     41
           376,         // y[c2]=     47
           360,         // y[c3]=     45
           280,         // y[c4]=     35
           264,         // y[c5]=     33
           312,         // y[c6]=     39
           296,         // y[c7]=     37
           472,         // y[c8]=     59
           456,         // y[c9]=     57
           504,         // y[ca]=     63
           488,         // y[cb]=     61
           408,         // y[cc]=     51
           392,         // y[cd]=     49
           440,         // y[ce]=     55
           424,         // y[cf]=     53
            88,         // y[d0]=     11
            72,         // y[d1]=      9
           120,         // y[d2]=     15
           104,         // y[d3]=     13
            24,         // y[d4]=      3
             8,         // y[d5]=      1
            56,         // y[d6]=      7
            40,         // y[d7]=      5
           216,         // y[d8]=     27
           200,         // y[d9]=     25
           248,         // y[da]=     31
           232,         // y[db]=     29
           152,         // y[dc]=     19
           136,         // y[dd]=     17
           184,         // y[de]=     23
           168,         // y[df]=     21
          1376,         // y[e0]=    172
          1312,         // y[e1]=    164
          1504,         // y[e2]=    188
          1440,         // y[e3]=    180
          1120,         // y[e4]=    140
          1056,         // y[e5]=    132
          1248,         // y[e6]=    156
          1184,         // y[e7]=    148
          1888,         // y[e8]=    236
          1824,         // y[e9]=    228
          2016,         // y[ea]=    252
          1952,         // y[eb]=    244
          1632,         // y[ec]=    204
          1568,         // y[ed]=    196
          1760,         // y[ee]=    220
          1696,         // y[ef]=    212
           688,         // y[f0]=     86
           656,         // y[f1]=     82
           752,         // y[f2]=     94
           720,         // y[f3]=     90
           560,         // y[f4]=     70
           528,         // y[f5]=     66
           624,         // y[f6]=     78
           592,         // y[f7]=     74
           944,         // y[f8]=    118
           912,         // y[f9]=    114
          1008,         // y[fa]=    126
           976,         // y[fb]=    122
           816,         // y[fc]=    102
           784,         // y[fd]=     98
           880,         // y[fe]=    110
           848          // y[ff]=    106
    };
        
//--------------------------------------------------------------------------;
//
//  Name:
//      UlawToPcmTable
//
//
//  Description:
//      this array maps u-law characters to 16-bit PCM
//      
//  Arguments:
//      the index into the array is a u-law character
//
//  Return:
//      an element of the array is a 16-bit PCM value
//
//  Notes:
//
//
//  History:
//      07/28/93    Created.
//
//
//--------------------------------------------------------------------------;
const SHORT BCODE UlawToPcmTable[256] =
    {
        -32124,         // y[00]=  -8031
        -31100,         // y[01]=  -7775
        -30076,         // y[02]=  -7519
        -29052,         // y[03]=  -7263
        -28028,         // y[04]=  -7007
        -27004,         // y[05]=  -6751
        -25980,         // y[06]=  -6495
        -24956,         // y[07]=  -6239
        -23932,         // y[08]=  -5983
        -22908,         // y[09]=  -5727
        -21884,         // y[0a]=  -5471
        -20860,         // y[0b]=  -5215
        -19836,         // y[0c]=  -4959
        -18812,         // y[0d]=  -4703
        -17788,         // y[0e]=  -4447
        -16764,         // y[0f]=  -4191
        -15996,         // y[10]=  -3999
        -15484,         // y[11]=  -3871
        -14972,         // y[12]=  -3743
        -14460,         // y[13]=  -3615
        -13948,         // y[14]=  -3487
        -13436,         // y[15]=  -3359
        -12924,         // y[16]=  -3231
        -12412,         // y[17]=  -3103
        -11900,         // y[18]=  -2975
        -11388,         // y[19]=  -2847
        -10876,         // y[1a]=  -2719
        -10364,         // y[1b]=  -2591
         -9852,         // y[1c]=  -2463
         -9340,         // y[1d]=  -2335
         -8828,         // y[1e]=  -2207
         -8316,         // y[1f]=  -2079
         -7932,         // y[20]=  -1983
         -7676,         // y[21]=  -1919
         -7420,         // y[22]=  -1855
         -7164,         // y[23]=  -1791
         -6908,         // y[24]=  -1727
         -6652,         // y[25]=  -1663
         -6396,         // y[26]=  -1599
         -6140,         // y[27]=  -1535
         -5884,         // y[28]=  -1471
         -5628,         // y[29]=  -1407
         -5372,         // y[2a]=  -1343
         -5116,         // y[2b]=  -1279
         -4860,         // y[2c]=  -1215
         -4604,         // y[2d]=  -1151
         -4348,         // y[2e]=  -1087
         -4092,         // y[2f]=  -1023
         -3900,         // y[30]=   -975
         -3772,         // y[31]=   -943
         -3644,         // y[32]=   -911
         -3516,         // y[33]=   -879
         -3388,         // y[34]=   -847
         -3260,         // y[35]=   -815
         -3132,         // y[36]=   -783
         -3004,         // y[37]=   -751
         -2876,         // y[38]=   -719
         -2748,         // y[39]=   -687
         -2620,         // y[3a]=   -655
         -2492,         // y[3b]=   -623
         -2364,         // y[3c]=   -591
         -2236,         // y[3d]=   -559
         -2108,         // y[3e]=   -527
         -1980,         // y[3f]=   -495
         -1884,         // y[40]=   -471
         -1820,         // y[41]=   -455
         -1756,         // y[42]=   -439
         -1692,         // y[43]=   -423
         -1628,         // y[44]=   -407
         -1564,         // y[45]=   -391
         -1500,         // y[46]=   -375
         -1436,         // y[47]=   -359
         -1372,         // y[48]=   -343
         -1308,         // y[49]=   -327
         -1244,         // y[4a]=   -311
         -1180,         // y[4b]=   -295
         -1116,         // y[4c]=   -279
         -1052,         // y[4d]=   -263
          -988,         // y[4e]=   -247
          -924,         // y[4f]=   -231
          -876,         // y[50]=   -219
          -844,         // y[51]=   -211
          -812,         // y[52]=   -203
          -780,         // y[53]=   -195
          -748,         // y[54]=   -187
          -716,         // y[55]=   -179
          -684,         // y[56]=   -171
          -652,         // y[57]=   -163
          -620,         // y[58]=   -155
          -588,         // y[59]=   -147
          -556,         // y[5a]=   -139
          -524,         // y[5b]=   -131
          -492,         // y[5c]=   -123
          -460,         // y[5d]=   -115
          -428,         // y[5e]=   -107
          -396,         // y[5f]=    -99
          -372,         // y[60]=    -93
          -356,         // y[61]=    -89
          -340,         // y[62]=    -85
          -324,         // y[63]=    -81
          -308,         // y[64]=    -77
          -292,         // y[65]=    -73
          -276,         // y[66]=    -69
          -260,         // y[67]=    -65
          -244,         // y[68]=    -61
          -228,         // y[69]=    -57
          -212,         // y[6a]=    -53
          -196,         // y[6b]=    -49
          -180,         // y[6c]=    -45
          -164,         // y[6d]=    -41
          -148,         // y[6e]=    -37
          -132,         // y[6f]=    -33
          -120,         // y[70]=    -30
          -112,         // y[71]=    -28
          -104,         // y[72]=    -26
           -96,         // y[73]=    -24
           -88,         // y[74]=    -22
           -80,         // y[75]=    -20
           -72,         // y[76]=    -18
           -64,         // y[77]=    -16
           -56,         // y[78]=    -14
           -48,         // y[79]=    -12
           -40,         // y[7a]=    -10
           -32,         // y[7b]=     -8
           -24,         // y[7c]=     -6
           -16,         // y[7d]=     -4
            -8,         // y[7e]=     -2
             0,         // y[7f]=      0
         32124,         // y[80]=   8031
         31100,         // y[81]=   7775
         30076,         // y[82]=   7519
         29052,         // y[83]=   7263
         28028,         // y[84]=   7007
         27004,         // y[85]=   6751
         25980,         // y[86]=   6495
         24956,         // y[87]=   6239
         23932,         // y[88]=   5983
         22908,         // y[89]=   5727
         21884,         // y[8a]=   5471
         20860,         // y[8b]=   5215
         19836,         // y[8c]=   4959
         18812,         // y[8d]=   4703
         17788,         // y[8e]=   4447
         16764,         // y[8f]=   4191
         15996,         // y[90]=   3999
         15484,         // y[91]=   3871
         14972,         // y[92]=   3743
         14460,         // y[93]=   3615
         13948,         // y[94]=   3487
         13436,         // y[95]=   3359
         12924,         // y[96]=   3231
         12412,         // y[97]=   3103
         11900,         // y[98]=   2975
         11388,         // y[99]=   2847
         10876,         // y[9a]=   2719
         10364,         // y[9b]=   2591
          9852,         // y[9c]=   2463
          9340,         // y[9d]=   2335
          8828,         // y[9e]=   2207
          8316,         // y[9f]=   2079
          7932,         // y[a0]=   1983
          7676,         // y[a1]=   1919
          7420,         // y[a2]=   1855
          7164,         // y[a3]=   1791
          6908,         // y[a4]=   1727
          6652,         // y[a5]=   1663
          6396,         // y[a6]=   1599
          6140,         // y[a7]=   1535
          5884,         // y[a8]=   1471
          5628,         // y[a9]=   1407
          5372,         // y[aa]=   1343
          5116,         // y[ab]=   1279
          4860,         // y[ac]=   1215
          4604,         // y[ad]=   1151
          4348,         // y[ae]=   1087
          4092,         // y[af]=   1023
          3900,         // y[b0]=    975
          3772,         // y[b1]=    943
          3644,         // y[b2]=    911
          3516,         // y[b3]=    879
          3388,         // y[b4]=    847
          3260,         // y[b5]=    815
          3132,         // y[b6]=    783
          3004,         // y[b7]=    751
          2876,         // y[b8]=    719
          2748,         // y[b9]=    687
          2620,         // y[ba]=    655
          2492,         // y[bb]=    623
          2364,         // y[bc]=    591
          2236,         // y[bd]=    559
          2108,         // y[be]=    527
          1980,         // y[bf]=    495
          1884,         // y[c0]=    471
          1820,         // y[c1]=    455
          1756,         // y[c2]=    439
          1692,         // y[c3]=    423
          1628,         // y[c4]=    407
          1564,         // y[c5]=    391
          1500,         // y[c6]=    375
          1436,         // y[c7]=    359
          1372,         // y[c8]=    343
          1308,         // y[c9]=    327
          1244,         // y[ca]=    311
          1180,         // y[cb]=    295
          1116,         // y[cc]=    279
          1052,         // y[cd]=    263
           988,         // y[ce]=    247
           924,         // y[cf]=    231
           876,         // y[d0]=    219
           844,         // y[d1]=    211
           812,         // y[d2]=    203
           780,         // y[d3]=    195
           748,         // y[d4]=    187
           716,         // y[d5]=    179
           684,         // y[d6]=    171
           652,         // y[d7]=    163
           620,         // y[d8]=    155
           588,         // y[d9]=    147
           556,         // y[da]=    139
           524,         // y[db]=    131
           492,         // y[dc]=    123
           460,         // y[dd]=    115
           428,         // y[de]=    107
           396,         // y[df]=     99
           372,         // y[e0]=     93
           356,         // y[e1]=     89
           340,         // y[e2]=     85
           324,         // y[e3]=     81
           308,         // y[e4]=     77
           292,         // y[e5]=     73
           276,         // y[e6]=     69
           260,         // y[e7]=     65
           244,         // y[e8]=     61
           228,         // y[e9]=     57
           212,         // y[ea]=     53
           196,         // y[eb]=     49
           180,         // y[ec]=     45
           164,         // y[ed]=     41
           148,         // y[ee]=     37
           132,         // y[ef]=     33
           120,         // y[f0]=     30
           112,         // y[f1]=     28
           104,         // y[f2]=     26
            96,         // y[f3]=     24
            88,         // y[f4]=     22
            80,         // y[f5]=     20
            72,         // y[f6]=     18
            64,         // y[f7]=     16
            56,         // y[f8]=     14
            48,         // y[f9]=     12
            40,         // y[fa]=     10
            32,         // y[fb]=      8
            24,         // y[fc]=      6
            16,         // y[fd]=      4
             8,         // y[fe]=      2
             0          // y[ff]=      0
    };
        
//--------------------------------------------------------------------------;
//
//  Name:
//      AlawToUlawTable
//
//
//  Description:
//      this array maps A-law characters to u-law characters
//      
//  Arguments:
//      the index into the array is an A-law character
//
//  Return:
//      an element of the array is a u-law character
//
//  Notes:
//
//
//  History:
//      08/01/93    Created.
//
//
//--------------------------------------------------------------------------;
const BYTE BCODE AlawToUlawTable[256] =
    {
        0x2a,           // A-law[00] ==> u-law[2a]
        0x2b,           // A-law[01] ==> u-law[2b]
        0x28,           // A-law[02] ==> u-law[28]
        0x29,           // A-law[03] ==> u-law[29]
        0x2e,           // A-law[04] ==> u-law[2e]
        0x2f,           // A-law[05] ==> u-law[2f]
        0x2c,           // A-law[06] ==> u-law[2c]
        0x2d,           // A-law[07] ==> u-law[2d]
        0x22,           // A-law[08] ==> u-law[22]
        0x23,           // A-law[09] ==> u-law[23]
        0x20,           // A-law[0a] ==> u-law[20]
        0x21,           // A-law[0b] ==> u-law[21]
        0x26,           // A-law[0c] ==> u-law[26]
        0x27,           // A-law[0d] ==> u-law[27]
        0x24,           // A-law[0e] ==> u-law[24]
        0x25,           // A-law[0f] ==> u-law[25]
        0x39,           // A-law[10] ==> u-law[39]
        0x3a,           // A-law[11] ==> u-law[3a]
        0x37,           // A-law[12] ==> u-law[37]
        0x38,           // A-law[13] ==> u-law[38]
        0x3d,           // A-law[14] ==> u-law[3d]
        0x3e,           // A-law[15] ==> u-law[3e]
        0x3b,           // A-law[16] ==> u-law[3b]
        0x3c,           // A-law[17] ==> u-law[3c]
        0x31,           // A-law[18] ==> u-law[31]
        0x32,           // A-law[19] ==> u-law[32]
        0x30,           // A-law[1a] ==> u-law[30]
        0x30,           // A-law[1b] ==> u-law[30]
        0x35,           // A-law[1c] ==> u-law[35]
        0x36,           // A-law[1d] ==> u-law[36]
        0x33,           // A-law[1e] ==> u-law[33]
        0x34,           // A-law[1f] ==> u-law[34]
        0x0a,           // A-law[20] ==> u-law[0a]
        0x0b,           // A-law[21] ==> u-law[0b]
        0x08,           // A-law[22] ==> u-law[08]
        0x09,           // A-law[23] ==> u-law[09]
        0x0e,           // A-law[24] ==> u-law[0e]
        0x0f,           // A-law[25] ==> u-law[0f]
        0x0c,           // A-law[26] ==> u-law[0c]
        0x0d,           // A-law[27] ==> u-law[0d]
        0x02,           // A-law[28] ==> u-law[02]
        0x03,           // A-law[29] ==> u-law[03]
        0x00,           // A-law[2a] ==> u-law[00]
        0x01,           // A-law[2b] ==> u-law[01]
        0x06,           // A-law[2c] ==> u-law[06]
        0x07,           // A-law[2d] ==> u-law[07]
        0x04,           // A-law[2e] ==> u-law[04]
        0x05,           // A-law[2f] ==> u-law[05]
        0x1a,           // A-law[30] ==> u-law[1a]
        0x1b,           // A-law[31] ==> u-law[1b]
        0x18,           // A-law[32] ==> u-law[18]
        0x19,           // A-law[33] ==> u-law[19]
        0x1e,           // A-law[34] ==> u-law[1e]
        0x1f,           // A-law[35] ==> u-law[1f]
        0x1c,           // A-law[36] ==> u-law[1c]
        0x1d,           // A-law[37] ==> u-law[1d]
        0x12,           // A-law[38] ==> u-law[12]
        0x13,           // A-law[39] ==> u-law[13]
        0x10,           // A-law[3a] ==> u-law[10]
        0x11,           // A-law[3b] ==> u-law[11]
        0x16,           // A-law[3c] ==> u-law[16]
        0x17,           // A-law[3d] ==> u-law[17]
        0x14,           // A-law[3e] ==> u-law[14]
        0x15,           // A-law[3f] ==> u-law[15]
        0x62,           // A-law[40] ==> u-law[62]
        0x63,           // A-law[41] ==> u-law[63]
        0x60,           // A-law[42] ==> u-law[60]
        0x61,           // A-law[43] ==> u-law[61]
        0x66,           // A-law[44] ==> u-law[66]
        0x67,           // A-law[45] ==> u-law[67]
        0x64,           // A-law[46] ==> u-law[64]
        0x65,           // A-law[47] ==> u-law[65]
        0x5d,           // A-law[48] ==> u-law[5d]
        0x5d,           // A-law[49] ==> u-law[5d]
        0x5c,           // A-law[4a] ==> u-law[5c]
        0x5c,           // A-law[4b] ==> u-law[5c]
        0x5f,           // A-law[4c] ==> u-law[5f]
        0x5f,           // A-law[4d] ==> u-law[5f]
        0x5e,           // A-law[4e] ==> u-law[5e]
        0x5e,           // A-law[4f] ==> u-law[5e]
        0x74,           // A-law[50] ==> u-law[74]
        0x76,           // A-law[51] ==> u-law[76]
        0x70,           // A-law[52] ==> u-law[70]
        0x72,           // A-law[53] ==> u-law[72]
        0x7c,           // A-law[54] ==> u-law[7c]
        0x7e,           // A-law[55] ==> u-law[7e]
        0x78,           // A-law[56] ==> u-law[78]
        0x7a,           // A-law[57] ==> u-law[7a]
        0x6a,           // A-law[58] ==> u-law[6a]
        0x6b,           // A-law[59] ==> u-law[6b]
        0x68,           // A-law[5a] ==> u-law[68]
        0x69,           // A-law[5b] ==> u-law[69]
        0x6e,           // A-law[5c] ==> u-law[6e]
        0x6f,           // A-law[5d] ==> u-law[6f]
        0x6c,           // A-law[5e] ==> u-law[6c]
        0x6d,           // A-law[5f] ==> u-law[6d]
        0x48,           // A-law[60] ==> u-law[48]
        0x49,           // A-law[61] ==> u-law[49]
        0x46,           // A-law[62] ==> u-law[46]
        0x47,           // A-law[63] ==> u-law[47]
        0x4c,           // A-law[64] ==> u-law[4c]
        0x4d,           // A-law[65] ==> u-law[4d]
        0x4a,           // A-law[66] ==> u-law[4a]
        0x4b,           // A-law[67] ==> u-law[4b]
        0x40,           // A-law[68] ==> u-law[40]
        0x41,           // A-law[69] ==> u-law[41]
        0x3f,           // A-law[6a] ==> u-law[3f]
        0x3f,           // A-law[6b] ==> u-law[3f]
        0x44,           // A-law[6c] ==> u-law[44]
        0x45,           // A-law[6d] ==> u-law[45]
        0x42,           // A-law[6e] ==> u-law[42]
        0x43,           // A-law[6f] ==> u-law[43]
        0x56,           // A-law[70] ==> u-law[56]
        0x57,           // A-law[71] ==> u-law[57]
        0x54,           // A-law[72] ==> u-law[54]
        0x55,           // A-law[73] ==> u-law[55]
        0x5a,           // A-law[74] ==> u-law[5a]
        0x5b,           // A-law[75] ==> u-law[5b]
        0x58,           // A-law[76] ==> u-law[58]
        0x59,           // A-law[77] ==> u-law[59]
        0x4f,           // A-law[78] ==> u-law[4f]
        0x4f,           // A-law[79] ==> u-law[4f]
        0x4e,           // A-law[7a] ==> u-law[4e]
        0x4e,           // A-law[7b] ==> u-law[4e]
        0x52,           // A-law[7c] ==> u-law[52]
        0x53,           // A-law[7d] ==> u-law[53]
        0x50,           // A-law[7e] ==> u-law[50]
        0x51,           // A-law[7f] ==> u-law[51]
        0xaa,           // A-law[80] ==> u-law[aa]
        0xab,           // A-law[81] ==> u-law[ab]
        0xa8,           // A-law[82] ==> u-law[a8]
        0xa9,           // A-law[83] ==> u-law[a9]
        0xae,           // A-law[84] ==> u-law[ae]
        0xaf,           // A-law[85] ==> u-law[af]
        0xac,           // A-law[86] ==> u-law[ac]
        0xad,           // A-law[87] ==> u-law[ad]
        0xa2,           // A-law[88] ==> u-law[a2]
        0xa3,           // A-law[89] ==> u-law[a3]
        0xa0,           // A-law[8a] ==> u-law[a0]
        0xa1,           // A-law[8b] ==> u-law[a1]
        0xa6,           // A-law[8c] ==> u-law[a6]
        0xa7,           // A-law[8d] ==> u-law[a7]
        0xa4,           // A-law[8e] ==> u-law[a4]
        0xa5,           // A-law[8f] ==> u-law[a5]
        0xb9,           // A-law[90] ==> u-law[b9]
        0xba,           // A-law[91] ==> u-law[ba]
        0xb7,           // A-law[92] ==> u-law[b7]
        0xb8,           // A-law[93] ==> u-law[b8]
        0xbd,           // A-law[94] ==> u-law[bd]
        0xbe,           // A-law[95] ==> u-law[be]
        0xbb,           // A-law[96] ==> u-law[bb]
        0xbc,           // A-law[97] ==> u-law[bc]
        0xb1,           // A-law[98] ==> u-law[b1]
        0xb2,           // A-law[99] ==> u-law[b2]
        0xb0,           // A-law[9a] ==> u-law[b0]
        0xb0,           // A-law[9b] ==> u-law[b0]
        0xb5,           // A-law[9c] ==> u-law[b5]
        0xb6,           // A-law[9d] ==> u-law[b6]
        0xb3,           // A-law[9e] ==> u-law[b3]
        0xb4,           // A-law[9f] ==> u-law[b4]
        0x8a,           // A-law[a0] ==> u-law[8a]
        0x8b,           // A-law[a1] ==> u-law[8b]
        0x88,           // A-law[a2] ==> u-law[88]
        0x89,           // A-law[a3] ==> u-law[89]
        0x8e,           // A-law[a4] ==> u-law[8e]
        0x8f,           // A-law[a5] ==> u-law[8f]
        0x8c,           // A-law[a6] ==> u-law[8c]
        0x8d,           // A-law[a7] ==> u-law[8d]
        0x82,           // A-law[a8] ==> u-law[82]
        0x83,           // A-law[a9] ==> u-law[83]
        0x80,           // A-law[aa] ==> u-law[80]
        0x81,           // A-law[ab] ==> u-law[81]
        0x86,           // A-law[ac] ==> u-law[86]
        0x87,           // A-law[ad] ==> u-law[87]
        0x84,           // A-law[ae] ==> u-law[84]
        0x85,           // A-law[af] ==> u-law[85]
        0x9a,           // A-law[b0] ==> u-law[9a]
        0x9b,           // A-law[b1] ==> u-law[9b]
        0x98,           // A-law[b2] ==> u-law[98]
        0x99,           // A-law[b3] ==> u-law[99]
        0x9e,           // A-law[b4] ==> u-law[9e]
        0x9f,           // A-law[b5] ==> u-law[9f]
        0x9c,           // A-law[b6] ==> u-law[9c]
        0x9d,           // A-law[b7] ==> u-law[9d]
        0x92,           // A-law[b8] ==> u-law[92]
        0x93,           // A-law[b9] ==> u-law[93]
        0x90,           // A-law[ba] ==> u-law[90]
        0x91,           // A-law[bb] ==> u-law[91]
        0x96,           // A-law[bc] ==> u-law[96]
        0x97,           // A-law[bd] ==> u-law[97]
        0x94,           // A-law[be] ==> u-law[94]
        0x95,           // A-law[bf] ==> u-law[95]
        0xe2,           // A-law[c0] ==> u-law[e2]
        0xe3,           // A-law[c1] ==> u-law[e3]
        0xe0,           // A-law[c2] ==> u-law[e0]
        0xe1,           // A-law[c3] ==> u-law[e1]
        0xe6,           // A-law[c4] ==> u-law[e6]
        0xe7,           // A-law[c5] ==> u-law[e7]
        0xe4,           // A-law[c6] ==> u-law[e4]
        0xe5,           // A-law[c7] ==> u-law[e5]
        0xdd,           // A-law[c8] ==> u-law[dd]
        0xdd,           // A-law[c9] ==> u-law[dd]
        0xdc,           // A-law[ca] ==> u-law[dc]
        0xdc,           // A-law[cb] ==> u-law[dc]
        0xdf,           // A-law[cc] ==> u-law[df]
        0xdf,           // A-law[cd] ==> u-law[df]
        0xde,           // A-law[ce] ==> u-law[de]
        0xde,           // A-law[cf] ==> u-law[de]
        0xf4,           // A-law[d0] ==> u-law[f4]
        0xf6,           // A-law[d1] ==> u-law[f6]
        0xf0,           // A-law[d2] ==> u-law[f0]
        0xf2,           // A-law[d3] ==> u-law[f2]
        0xfc,           // A-law[d4] ==> u-law[fc]
        0xfe,           // A-law[d5] ==> u-law[fe]
        0xf8,           // A-law[d6] ==> u-law[f8]
        0xfa,           // A-law[d7] ==> u-law[fa]
        0xea,           // A-law[d8] ==> u-law[ea]
        0xeb,           // A-law[d9] ==> u-law[eb]
        0xe8,           // A-law[da] ==> u-law[e8]
        0xe9,           // A-law[db] ==> u-law[e9]
        0xee,           // A-law[dc] ==> u-law[ee]
        0xef,           // A-law[dd] ==> u-law[ef]
        0xec,           // A-law[de] ==> u-law[ec]
        0xed,           // A-law[df] ==> u-law[ed]
        0xc8,           // A-law[e0] ==> u-law[c8]
        0xc9,           // A-law[e1] ==> u-law[c9]
        0xc6,           // A-law[e2] ==> u-law[c6]
        0xc7,           // A-law[e3] ==> u-law[c7]
        0xcc,           // A-law[e4] ==> u-law[cc]
        0xcd,           // A-law[e5] ==> u-law[cd]
        0xca,           // A-law[e6] ==> u-law[ca]
        0xcb,           // A-law[e7] ==> u-law[cb]
        0xc0,           // A-law[e8] ==> u-law[c0]
        0xc1,           // A-law[e9] ==> u-law[c1]
        0xbf,           // A-law[ea] ==> u-law[bf]
        0xbf,           // A-law[eb] ==> u-law[bf]
        0xc4,           // A-law[ec] ==> u-law[c4]
        0xc5,           // A-law[ed] ==> u-law[c5]
        0xc2,           // A-law[ee] ==> u-law[c2]
        0xc3,           // A-law[ef] ==> u-law[c3]
        0xd6,           // A-law[f0] ==> u-law[d6]
        0xd7,           // A-law[f1] ==> u-law[d7]
        0xd4,           // A-law[f2] ==> u-law[d4]
        0xd5,           // A-law[f3] ==> u-law[d5]
        0xda,           // A-law[f4] ==> u-law[da]
        0xdb,           // A-law[f5] ==> u-law[db]
        0xd8,           // A-law[f6] ==> u-law[d8]
        0xd9,           // A-law[f7] ==> u-law[d9]
        0xcf,           // A-law[f8] ==> u-law[cf]
        0xcf,           // A-law[f9] ==> u-law[cf]
        0xce,           // A-law[fa] ==> u-law[ce]
        0xce,           // A-law[fb] ==> u-law[ce]
        0xd2,           // A-law[fc] ==> u-law[d2]
        0xd3,           // A-law[fd] ==> u-law[d3]
        0xd0,           // A-law[fe] ==> u-law[d0]
        0xd1            // A-law[ff] ==> u-law[d1]
    };
    
//--------------------------------------------------------------------------;
//
//  Name:
//      UlawToAlawTable
//
//
//  Description:
//      this array maps u-law characters to A-law characters
//      
//  Arguments:
//      the index into the array is a u-law character
//
//  Return:
//      an element of the array is an A-law character
//
//  Notes:
//
//
//  History:
//      08/01/93    Created.
//
//
//--------------------------------------------------------------------------;
const BYTE BCODE UlawToAlawTable[256] =
    {
        0x2a,           // u-law[00] ==> A-law[2a]
        0x2b,           // u-law[01] ==> A-law[2b]
        0x28,           // u-law[02] ==> A-law[28]
        0x29,           // u-law[03] ==> A-law[29]
        0x2e,           // u-law[04] ==> A-law[2e]
        0x2f,           // u-law[05] ==> A-law[2f]
        0x2c,           // u-law[06] ==> A-law[2c]
        0x2d,           // u-law[07] ==> A-law[2d]
        0x22,           // u-law[08] ==> A-law[22]
        0x23,           // u-law[09] ==> A-law[23]
        0x20,           // u-law[0a] ==> A-law[20]
        0x21,           // u-law[0b] ==> A-law[21]
        0x26,           // u-law[0c] ==> A-law[26]
        0x27,           // u-law[0d] ==> A-law[27]
        0x24,           // u-law[0e] ==> A-law[24]
        0x25,           // u-law[0f] ==> A-law[25]
        0x3a,           // u-law[10] ==> A-law[3a]
        0x3b,           // u-law[11] ==> A-law[3b]
        0x38,           // u-law[12] ==> A-law[38]
        0x39,           // u-law[13] ==> A-law[39]
        0x3e,           // u-law[14] ==> A-law[3e]
        0x3f,           // u-law[15] ==> A-law[3f]
        0x3c,           // u-law[16] ==> A-law[3c]
        0x3d,           // u-law[17] ==> A-law[3d]
        0x32,           // u-law[18] ==> A-law[32]
        0x33,           // u-law[19] ==> A-law[33]
        0x30,           // u-law[1a] ==> A-law[30]
        0x31,           // u-law[1b] ==> A-law[31]
        0x36,           // u-law[1c] ==> A-law[36]
        0x37,           // u-law[1d] ==> A-law[37]
        0x34,           // u-law[1e] ==> A-law[34]
        0x35,           // u-law[1f] ==> A-law[35]
        0x0a,           // u-law[20] ==> A-law[0a]
        0x0b,           // u-law[21] ==> A-law[0b]
        0x08,           // u-law[22] ==> A-law[08]
        0x09,           // u-law[23] ==> A-law[09]
        0x0e,           // u-law[24] ==> A-law[0e]
        0x0f,           // u-law[25] ==> A-law[0f]
        0x0c,           // u-law[26] ==> A-law[0c]
        0x0d,           // u-law[27] ==> A-law[0d]
        0x02,           // u-law[28] ==> A-law[02]
        0x03,           // u-law[29] ==> A-law[03]
        0x00,           // u-law[2a] ==> A-law[00]
        0x01,           // u-law[2b] ==> A-law[01]
        0x06,           // u-law[2c] ==> A-law[06]
        0x07,           // u-law[2d] ==> A-law[07]
        0x04,           // u-law[2e] ==> A-law[04]
        0x05,           // u-law[2f] ==> A-law[05]
        0x1b,           // u-law[30] ==> A-law[1b]
        0x18,           // u-law[31] ==> A-law[18]
        0x19,           // u-law[32] ==> A-law[19]
        0x1e,           // u-law[33] ==> A-law[1e]
        0x1f,           // u-law[34] ==> A-law[1f]
        0x1c,           // u-law[35] ==> A-law[1c]
        0x1d,           // u-law[36] ==> A-law[1d]
        0x12,           // u-law[37] ==> A-law[12]
        0x13,           // u-law[38] ==> A-law[13]
        0x10,           // u-law[39] ==> A-law[10]
        0x11,           // u-law[3a] ==> A-law[11]
        0x16,           // u-law[3b] ==> A-law[16]
        0x17,           // u-law[3c] ==> A-law[17]
        0x14,           // u-law[3d] ==> A-law[14]
        0x15,           // u-law[3e] ==> A-law[15]
        0x6a,           // u-law[3f] ==> A-law[6a]
        0x68,           // u-law[40] ==> A-law[68]
        0x69,           // u-law[41] ==> A-law[69]
        0x6e,           // u-law[42] ==> A-law[6e]
        0x6f,           // u-law[43] ==> A-law[6f]
        0x6c,           // u-law[44] ==> A-law[6c]
        0x6d,           // u-law[45] ==> A-law[6d]
        0x62,           // u-law[46] ==> A-law[62]
        0x63,           // u-law[47] ==> A-law[63]
        0x60,           // u-law[48] ==> A-law[60]
        0x61,           // u-law[49] ==> A-law[61]
        0x66,           // u-law[4a] ==> A-law[66]
        0x67,           // u-law[4b] ==> A-law[67]
        0x64,           // u-law[4c] ==> A-law[64]
        0x65,           // u-law[4d] ==> A-law[65]
        0x7a,           // u-law[4e] ==> A-law[7a]
        0x78,           // u-law[4f] ==> A-law[78]
        0x7e,           // u-law[50] ==> A-law[7e]
        0x7f,           // u-law[51] ==> A-law[7f]
        0x7c,           // u-law[52] ==> A-law[7c]
        0x7d,           // u-law[53] ==> A-law[7d]
        0x72,           // u-law[54] ==> A-law[72]
        0x73,           // u-law[55] ==> A-law[73]
        0x70,           // u-law[56] ==> A-law[70]
        0x71,           // u-law[57] ==> A-law[71]
        0x76,           // u-law[58] ==> A-law[76]
        0x77,           // u-law[59] ==> A-law[77]
        0x74,           // u-law[5a] ==> A-law[74]
        0x75,           // u-law[5b] ==> A-law[75]
        0x4b,           // u-law[5c] ==> A-law[4b]
        0x49,           // u-law[5d] ==> A-law[49]
        0x4f,           // u-law[5e] ==> A-law[4f]
        0x4d,           // u-law[5f] ==> A-law[4d]
        0x42,           // u-law[60] ==> A-law[42]
        0x43,           // u-law[61] ==> A-law[43]
        0x40,           // u-law[62] ==> A-law[40]
        0x41,           // u-law[63] ==> A-law[41]
        0x46,           // u-law[64] ==> A-law[46]
        0x47,           // u-law[65] ==> A-law[47]
        0x44,           // u-law[66] ==> A-law[44]
        0x45,           // u-law[67] ==> A-law[45]
        0x5a,           // u-law[68] ==> A-law[5a]
        0x5b,           // u-law[69] ==> A-law[5b]
        0x58,           // u-law[6a] ==> A-law[58]
        0x59,           // u-law[6b] ==> A-law[59]
        0x5e,           // u-law[6c] ==> A-law[5e]
        0x5f,           // u-law[6d] ==> A-law[5f]
        0x5c,           // u-law[6e] ==> A-law[5c]
        0x5d,           // u-law[6f] ==> A-law[5d]
        0x52,           // u-law[70] ==> A-law[52]
        0x52,           // u-law[71] ==> A-law[52]
        0x53,           // u-law[72] ==> A-law[53]
        0x53,           // u-law[73] ==> A-law[53]
        0x50,           // u-law[74] ==> A-law[50]
        0x50,           // u-law[75] ==> A-law[50]
        0x51,           // u-law[76] ==> A-law[51]
        0x51,           // u-law[77] ==> A-law[51]
        0x56,           // u-law[78] ==> A-law[56]
        0x56,           // u-law[79] ==> A-law[56]
        0x57,           // u-law[7a] ==> A-law[57]
        0x57,           // u-law[7b] ==> A-law[57]
        0x54,           // u-law[7c] ==> A-law[54]
        0x54,           // u-law[7d] ==> A-law[54]
        0x55,           // u-law[7e] ==> A-law[55]
        0x55,           // u-law[7f] ==> A-law[55]
        0xaa,           // u-law[80] ==> A-law[aa]
        0xab,           // u-law[81] ==> A-law[ab]
        0xa8,           // u-law[82] ==> A-law[a8]
        0xa9,           // u-law[83] ==> A-law[a9]
        0xae,           // u-law[84] ==> A-law[ae]
        0xaf,           // u-law[85] ==> A-law[af]
        0xac,           // u-law[86] ==> A-law[ac]
        0xad,           // u-law[87] ==> A-law[ad]
        0xa2,           // u-law[88] ==> A-law[a2]
        0xa3,           // u-law[89] ==> A-law[a3]
        0xa0,           // u-law[8a] ==> A-law[a0]
        0xa1,           // u-law[8b] ==> A-law[a1]
        0xa6,           // u-law[8c] ==> A-law[a6]
        0xa7,           // u-law[8d] ==> A-law[a7]
        0xa4,           // u-law[8e] ==> A-law[a4]
        0xa5,           // u-law[8f] ==> A-law[a5]
        0xba,           // u-law[90] ==> A-law[ba]
        0xbb,           // u-law[91] ==> A-law[bb]
        0xb8,           // u-law[92] ==> A-law[b8]
        0xb9,           // u-law[93] ==> A-law[b9]
        0xbe,           // u-law[94] ==> A-law[be]
        0xbf,           // u-law[95] ==> A-law[bf]
        0xbc,           // u-law[96] ==> A-law[bc]
        0xbd,           // u-law[97] ==> A-law[bd]
        0xb2,           // u-law[98] ==> A-law[b2]
        0xb3,           // u-law[99] ==> A-law[b3]
        0xb0,           // u-law[9a] ==> A-law[b0]
        0xb1,           // u-law[9b] ==> A-law[b1]
        0xb6,           // u-law[9c] ==> A-law[b6]
        0xb7,           // u-law[9d] ==> A-law[b7]
        0xb4,           // u-law[9e] ==> A-law[b4]
        0xb5,           // u-law[9f] ==> A-law[b5]
        0x8a,           // u-law[a0] ==> A-law[8a]
        0x8b,           // u-law[a1] ==> A-law[8b]
        0x88,           // u-law[a2] ==> A-law[88]
        0x89,           // u-law[a3] ==> A-law[89]
        0x8e,           // u-law[a4] ==> A-law[8e]
        0x8f,           // u-law[a5] ==> A-law[8f]
        0x8c,           // u-law[a6] ==> A-law[8c]
        0x8d,           // u-law[a7] ==> A-law[8d]
        0x82,           // u-law[a8] ==> A-law[82]
        0x83,           // u-law[a9] ==> A-law[83]
        0x80,           // u-law[aa] ==> A-law[80]
        0x81,           // u-law[ab] ==> A-law[81]
        0x86,           // u-law[ac] ==> A-law[86]
        0x87,           // u-law[ad] ==> A-law[87]
        0x84,           // u-law[ae] ==> A-law[84]
        0x85,           // u-law[af] ==> A-law[85]
        0x9b,           // u-law[b0] ==> A-law[9b]
        0x98,           // u-law[b1] ==> A-law[98]
        0x99,           // u-law[b2] ==> A-law[99]
        0x9e,           // u-law[b3] ==> A-law[9e]
        0x9f,           // u-law[b4] ==> A-law[9f]
        0x9c,           // u-law[b5] ==> A-law[9c]
        0x9d,           // u-law[b6] ==> A-law[9d]
        0x92,           // u-law[b7] ==> A-law[92]
        0x93,           // u-law[b8] ==> A-law[93]
        0x90,           // u-law[b9] ==> A-law[90]
        0x91,           // u-law[ba] ==> A-law[91]
        0x96,           // u-law[bb] ==> A-law[96]
        0x97,           // u-law[bc] ==> A-law[97]
        0x94,           // u-law[bd] ==> A-law[94]
        0x95,           // u-law[be] ==> A-law[95]
        0xea,           // u-law[bf] ==> A-law[ea]
        0xe8,           // u-law[c0] ==> A-law[e8]
        0xe9,           // u-law[c1] ==> A-law[e9]
        0xee,           // u-law[c2] ==> A-law[ee]
        0xef,           // u-law[c3] ==> A-law[ef]
        0xec,           // u-law[c4] ==> A-law[ec]
        0xed,           // u-law[c5] ==> A-law[ed]
        0xe2,           // u-law[c6] ==> A-law[e2]
        0xe3,           // u-law[c7] ==> A-law[e3]
        0xe0,           // u-law[c8] ==> A-law[e0]
        0xe1,           // u-law[c9] ==> A-law[e1]
        0xe6,           // u-law[ca] ==> A-law[e6]
        0xe7,           // u-law[cb] ==> A-law[e7]
        0xe4,           // u-law[cc] ==> A-law[e4]
        0xe5,           // u-law[cd] ==> A-law[e5]
        0xfa,           // u-law[ce] ==> A-law[fa]
        0xf8,           // u-law[cf] ==> A-law[f8]
        0xfe,           // u-law[d0] ==> A-law[fe]
        0xff,           // u-law[d1] ==> A-law[ff]
        0xfc,           // u-law[d2] ==> A-law[fc]
        0xfd,           // u-law[d3] ==> A-law[fd]
        0xf2,           // u-law[d4] ==> A-law[f2]
        0xf3,           // u-law[d5] ==> A-law[f3]
        0xf0,           // u-law[d6] ==> A-law[f0]
        0xf1,           // u-law[d7] ==> A-law[f1]
        0xf6,           // u-law[d8] ==> A-law[f6]
        0xf7,           // u-law[d9] ==> A-law[f7]
        0xf4,           // u-law[da] ==> A-law[f4]
        0xf5,           // u-law[db] ==> A-law[f5]
        0xcb,           // u-law[dc] ==> A-law[cb]
        0xc9,           // u-law[dd] ==> A-law[c9]
        0xcf,           // u-law[de] ==> A-law[cf]
        0xcd,           // u-law[df] ==> A-law[cd]
        0xc2,           // u-law[e0] ==> A-law[c2]
        0xc3,           // u-law[e1] ==> A-law[c3]
        0xc0,           // u-law[e2] ==> A-law[c0]
        0xc1,           // u-law[e3] ==> A-law[c1]
        0xc6,           // u-law[e4] ==> A-law[c6]
        0xc7,           // u-law[e5] ==> A-law[c7]
        0xc4,           // u-law[e6] ==> A-law[c4]
        0xc5,           // u-law[e7] ==> A-law[c5]
        0xda,           // u-law[e8] ==> A-law[da]
        0xdb,           // u-law[e9] ==> A-law[db]
        0xd8,           // u-law[ea] ==> A-law[d8]
        0xd9,           // u-law[eb] ==> A-law[d9]
        0xde,           // u-law[ec] ==> A-law[de]
        0xdf,           // u-law[ed] ==> A-law[df]
        0xdc,           // u-law[ee] ==> A-law[dc]
        0xdd,           // u-law[ef] ==> A-law[dd]
        0xd2,           // u-law[f0] ==> A-law[d2]
        0xd2,           // u-law[f1] ==> A-law[d2]
        0xd3,           // u-law[f2] ==> A-law[d3]
        0xd3,           // u-law[f3] ==> A-law[d3]
        0xd0,           // u-law[f4] ==> A-law[d0]
        0xd0,           // u-law[f5] ==> A-law[d0]
        0xd1,           // u-law[f6] ==> A-law[d1]
        0xd1,           // u-law[f7] ==> A-law[d1]
        0xd6,           // u-law[f8] ==> A-law[d6]
        0xd6,           // u-law[f9] ==> A-law[d6]
        0xd7,           // u-law[fa] ==> A-law[d7]
        0xd7,           // u-law[fb] ==> A-law[d7]
        0xd4,           // u-law[fc] ==> A-law[d4]
        0xd4,           // u-law[fd] ==> A-law[d4]
        0xd5,           // u-law[fe] ==> A-law[d5]
        0xd5            // u-law[ff] ==> A-law[d5]
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\g711\init.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  init.c
//
//  Description:
//      This file contains module initialization routines.  Note that there
//      is no module initialization for Win32 - the only initialization
//      required is to set ghinst, which is done in the DRV_LOAD message
//      of DriverProc (in codec.c).
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "debug.h"


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef _WIN32

//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//  Arguments:
//      HINSTANCE hinst: Our module handle.
//
//      WORD wDataSeg: Specifies the DS value for this DLL.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    Created. 
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE               hinst, 
    WORD                    wDataSeg, 
    WORD                    cbHeapSize,
    LPSTR                   pszCmdLine
)
{
    DbgInitialize(TRUE);

    //
    //  if debug level is 5 or greater, then do a DebugBreak() to debug
    //  loading of this driver
    //
    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);
    DPF(5, "!*** break for debugging ***");

    return (TRUE);
} // LibMain()


//--------------------------------------------------------------------------;
//  
//  int WEP
//  
//  Description:
//  
//  
//  Arguments:
//      WORD wUselessParam:
//  
//  Return (int):
//  
//  History:
//      03/28/93    Created.
//  
//--------------------------------------------------------------------------;

EXTERN_C int FNEXPORT WEP
(
    WORD                    wUselessParam
)
{
    DPF(1, "WEP(wUselessParam=%u)", wUselessParam);

    //
    //  always return 1.
    //
    return (1);
} // WEP()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\g711\g711.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  g711.h
//
//  Description:
//      This file contains prototypes for the filtering routines.
//
//
//==========================================================================;

#ifndef _INC_G711
#define _INC_G711                   // #defined if g711.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//
//
//
#define G711_MAX_CHANNELS               2
#define G711_BITS_PER_SAMPLE            8
#define G711_WFX_EXTRA_BYTES            0


//
//  macros to compute block alignment and convert between samples and bytes
//  of G711 data. note that these macros assume:
//
//      wBitsPerSample  =  8
//      nChannels       =  1 or 2
//
//  the pwfx argument is a pointer to a WAVEFORMATEX structure.
//
#define G711_BLOCKALIGNMENT(pwfx)       (UINT)(pwfx->nChannels)
#define G711_AVGBYTESPERSEC(pwfx)       (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nChannels)
#define G711_BYTESTOSAMPLES(pwfx, dw)   (DWORD)(dw / G711_BLOCKALIGNMENT(pwfx))
#define G711_SAMPLESTOBYTES(pwfx, dw)   (DWORD)(dw * G711_BLOCKALIGNMENT(pwfx))

 
//
//  function prototypes from G711.C
//
// 
LRESULT FNGLOBAL AlawToPcm
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);

LRESULT FNGLOBAL PcmToAlaw
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);

LRESULT FNGLOBAL UlawToPcm
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);

LRESULT FNGLOBAL PcmToUlaw
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);

LRESULT FNGLOBAL AlawToUlaw
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);

LRESULT FNGLOBAL UlawToAlaw
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _INC_G711
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\gsm610\codec.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.c
//
//  Description:
//      This file contains the DriverProc and other routines which respond
//      to ACM messages.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "gsm610.h"
#include "debug.h"


//
//  array of supported format tags
//
//
const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM,
    WAVE_FORMAT_GSM610
};

#define ACM_DRIVER_MAX_FORMAT_TAGS   SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define ACM_DRIVER_MAX_FILTER_TAGS   0


//
//  array of sample rates supported
//
//
const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

//
//  array of pcm bits per sample supported
//
//
const UINT gauPcmFormatIndexToBitsPerSample[] =
{
    8,
    16
};

const UINT ACM_DRIVER_MAX_SAMPLE_RATES = SIZEOF_ARRAY(gauFormatIndexToSampleRate);

#define ACM_DRIVER_MAX_CHANNELS     GSM610_MAX_CHANNELS


//
//  bits per sample supported
//
//
#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM	2
#define ACM_DRIVER_MAX_BITSPERSAMPLE_GSM610	1


//
//  number of formats we enumerate per channel is number of sample rates
//  times number of channels times number of types (bits per sample).
//
#define ACM_DRIVER_MAX_FORMATS_PCM	(ACM_DRIVER_MAX_SAMPLE_RATES *  \
                                         ACM_DRIVER_MAX_CHANNELS *      \
                                         ACM_DRIVER_MAX_BITSPERSAMPLE_PCM)

#define ACM_DRIVER_MAX_FORMATS_GSM610   (ACM_DRIVER_MAX_SAMPLE_RATES *  \
                                         ACM_DRIVER_MAX_CHANNELS *      \
                                         ACM_DRIVER_MAX_BITSPERSAMPLE_GSM610)


//--------------------------------------------------------------------------;
//
//  This array describes the configuration settings for this codec.
//
//  Each line in the realtime encode/decode rate listbox must have one of
//  these structures to describe it.  The type of line is defined in
//  nFormatType, which can have one of the following values:
//
//      CONFIG_RLF_NONUMBER     - the string in idsFormat is displayed as is.
//      CONFIG_RLF_MONOONLY     - dwMonoRate is written into idsFormat, then
//                                  displayed as a mono rate.
//
//  The index to the gaRateListFormat array corresponds to the value which
//  is stored as configuration information in the registry or .ini file.
//  To find out if a certain conversion can be performed in real time,
//  check that:
//
//    SamplingRate <= gaRateListFormat[ConfigSetting].dwMonoRate / nChannels
//
//  Note:  The gaRateListFormat array must change when
//          gauFormatIndexToSampleRate changes.
//
//--------------------------------------------------------------------------;

const RATELISTFORMAT gaRateListFormat[] =
{
    { CONFIG_RLF_NONUMBER,      IDS_CONFIG_NORATES,     0 },
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    8000 },  // gauFormatIndexToSampleRate[0]
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    11025 }, // gauFormatIndexToSampleRate[1]
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    22050 }, // gauFormatIndexToSampleRate[2]
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    44100 }, // gauFormatIndexToSampleRate[3]
    { CONFIG_RLF_NONUMBER,      IDS_CONFIG_ALLRATES,    88200 }  // 2 * gauFormatIndexToSampleRate[3]
};

const UINT MSGSM610_CONFIG_NUMSETTINGS = SIZEOF_ARRAY( gaRateListFormat );


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // WIN32


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if ( (16 != pwfx->wBitsPerSample) && (8 != pwfx->wBitsPerSample) )
	return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    if (PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx) != pwfx->nBlockAlign)
        return (FALSE);

    //
    //  finally, verify that avg bytes per second is correct
    //
    if (PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL gsm610IsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid
//      GSM 6.10 format header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL gsm610IsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{

    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_GSM610 != pwfx->wFormatTag)
        return (FALSE);

    //
    //  check channels
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);


    //
    //  now verify that the block alignment is correct..
    //
    if (GSM610_BLOCKALIGNMENT(pwfx) != pwfx->nBlockAlign)
        return (FALSE);

    //
    //  verify that avg bytes per second is correct
    //
    if (GSM610_AVGBYTESPERSEC(pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    //
    //  check wBitsPerSample
    //
    if (GSM610_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
        return (FALSE);

    //
    //  cbSize must be validated also..
    //
    if (GSM610_WFX_EXTRA_BYTES != pwfx->cbSize)
        return (FALSE);

    //
    //	check wSamplesPerBlock
    //
    if (GSM610_SAMPLESPERBLOCK(pwfx) != ((LPGSM610WAVEFORMAT)pwfx)->wSamplesPerBlock)
	return (FALSE);

    return (TRUE);

} // gsm610IsValidFormat()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PDRIVERINSTANCE     pdi;

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (NULL != paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        {
            return (0L);
        }
    }


    //
    //  we are being opened as an installable driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure. note that we
    //  rely on allocating the memory as zero-initialized!
    //
    pdi = (PDRIVERINSTANCE)LocalAlloc(LPTR, sizeof(*pdi));
    if (NULL == pdi)
    {
        //
        //  if this open attempt was as an ACM driver, then return the
        //  reason we are failing in the open description structure..
        //
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        //
        //  fail to open
        //
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pdi->hdrvr          = hdrvr;
    pdi->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.
    pdi->fHelpRunning   = FALSE;

    if (NULL != paod)
    {
        pdi->fnDriverProc = NULL;
        pdi->fccType      = paod->fccType;
        pdi->vdwACM       = paod->dwVersion;
        pdi->fdwOpen      = paod->dwFlags;
        pdi->hkey         = NULL;           // This is important!

        paod->dwError     = MMSYSERR_NOERROR;
    }

    //
    // Get config info for this driver.  If we're not passed an
    // an ACMDRVOPENDESC structure then we'll assume we are being
    // opened for configuration and will put off getting the config
    // info until we receive the DRV_CONFIGURE message.  Otherwise we
    // get the config info now using the alias passed through the
    // ACMDRVOPENDESC structure.
    //
    if (NULL != paod)
    {
#if defined(WIN32) && !defined(UNICODE)
        //
        //  We must translate the UNICODE alias name to an ANSI version
        //  that we can use.
        //
    	LPSTR	lpstr;
        int     iLen;

        //
        //  Calculate required length without calling UNICODE APIs or CRT.
        //
        iLen  = WideCharToMultiByte( GetACP(), 0, paod->pszAliasName,-1,
                                                    NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)GlobalAlloc(GPTR, iLen);
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, paod->pszAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        GlobalFree((HGLOBAL)lpstr);
	    }
#else
    	acmdDriverConfigInit(pdi, paod->pszAliasName);
#endif
    }

    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)pdi);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PDRIVERINSTANCE         pdi
)
{
    //
    //  Release the registry key, if we allocated one.
    //
    if( NULL != pdi->hkey )
    {
        (void)RegCloseKey( pdi->hkey );
    }


    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (NULL != pdi)
    {
        //
        //  close down the driver instance. this driver simply needs
        //  to free the instance data structure... note that if this
        //  'free' fails, then this ACM driver probably trashed its
        //  heap; assume we didn't do that.
        //
        LocalFree((HLOCAL)pdi);
    }


    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      the user pressed OK.  This value should be returned even if the
//      user didn't change anything - otherwise, the driver may not
//      install properly.
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
    INT_PTR         n;

    //
    //  first check if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver supports a configuration dialog box, so
        //  return non-zero...
        //
        return (1L);
    }


    //
    //  we are being asked to bring up our configuration dialog. if this
    //  driver supports a configuration dialog box, then after the dialog
    //  is dismissed we must return one of the following values:
    //
    //  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
    //  and canceled by the user. this value should also be returned if
    //  no configuration information was modified.
    //
    //  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
    //  the user pressed OK.  This value should be returned even if the
    //  user didn't change anything - otherwise, the driver may not
    //  install properly.
    //
    //  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
    //  and some configuration information was changed that requires
    //  Windows to be restarted before the changes take affect. the driver
    //  should remain configured with current values until the driver
    //  has been 'rebooted'.
    //
    //
    if (NULL == pdci)
    {
        //
        //  !!!
        //
        return (DRVCNF_CANCEL);
    }

    pdi->pdci = pdci;

    //
    // We may not have our config info yet if the driver has only been
    // opened specifically for configuration.  So, read our configuration
    // using the alias passed in the DRVCONFIGINFO structure passed
    // through the DRV_CONFIGURE message
    //
#if (defined(WIN32) && !defined(UNICODE))
    {
        //
        //  We must translate the UNICODE alias name to an ANSI version
        //  that we can use.
        //
    	LPSTR	lpstr;
        int     iLen;

        //
        //  Calculate required length without calling UNICODE APIs or CRT.
        //
        iLen  = WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, -1,
                                                    NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)LocalAlloc(LPTR, iLen);
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        LocalFree((HLOCAL)lpstr);
	    }
    }
#else
    acmdDriverConfigInit(pdi, pdci->lpszDCIAliasName);
#endif

    n = DialogBoxParam(pdi->hinst,
                       IDD_CONFIG,
                       hwnd,
                       acmdDlgProcConfigure,
                       (LPARAM)pdi);

    pdi->pdci = NULL;

    return ((LRESULT)n);
} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMDRIVERDETAILS      padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;


    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    add.wMid            = MM_MICROSOFT;
    add.wPid            = MM_MSFT_ACM_GSM610;


    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;


    //
    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.
    //
    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

    //
    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.
    //
    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;


    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        //  See the MSFILTER sample for a codec which contains a custom icon.
        //
        add.hicon = NULL;

        //
        //  the short name and long name are used to represent the driver
        //  in a unique description. the short name is intended for small
        //  display areas (for example, in a menu or combo box). the long
        //  name is intended for more descriptive displays (for example,
        //  in an 'about box').
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

        //
        //  the last three members are intended for 'about box' information.
        //  these members are optional and may be zero length strings if
        //  the driver wishes.
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }


    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(padd, &add, (UINT)add.cbStruct);


    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd
)
{
    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a custom about box, so
        //  return MMSYSERR_NOTSUPPORTED...
        //
        return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  this driver does not support a custom dialog, so tell the ACM or
    //  calling application to display one for us. note that this is the
    //  _recommended_ method for consistency and simplicity of ACM drivers.
    //  why write code when you don't have to?
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM, a wave mapper or
//      an application to quickly get a destination format that this driver
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible. This message is normally
//      sent in response to an acmFormatSuggest function call.
//
//      Another way to think about this message is: what format would this
//      driver like to convert the source format to?
//
//      The caller may place restrictions on the destination format that
//      should be suggested. The padfs->fdwSuggest member contains the
//      restriction bits passed by the caller--see the description for
//      the return value for more information.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to an ACMDRVFORMATSUGGEST
//      structure that describes the source and destination (possibly with
//      restrictions) for a conversion.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if one or more of
//      the destination restriction bits is not supported. It is strongly
//      recommended that the driver support at least the following suggestion
//      restriction bits:
//
//      ACM_FORMATSUGGESTF_WFORMATTAG: The destination format tag must be
//      the same as the wFormatTag member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NCHANNELS: The destination channel count must be
//      the same as the nChannels member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NSAMPLESPERSEC: The destination samples per
//      second must be the same as the nSamplesPerSec member in the
//      destination format header.
//
//      ACM_FORMATSUGGESTF_WBITSPERSAMPLE: The destination bits per sample
//      must be the same as the wBitsPerSample member in the destination
//      format header.
//
//      If no destintation format can be suggested, then the driver should
//      return ACMERR_NOTPOSSIBLE.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    DWORD                   fdwSuggest;


    //
    //  grab the suggestion restriction bits and verify that we support
    //  the ones that are specified... an ACM driver must return the
    //  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
    //  are not supported.
    //
    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  get the source and destination formats in more convenient variables
    //
    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;


    //
    //
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver.
            //
            if (!pcmIsValidFormat(pwfxSrc))
                break;


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is able to encode only to GSM 6.10
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_GSM610 != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_GSM610;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if (GSM610_BITS_PER_SAMPLE != pwfxDst->wBitsPerSample)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = GSM610_BITS_PER_SAMPLE;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize
	    //	    wSamplesPerBlock
            //
            pwfxDst->nBlockAlign     = GSM610_BLOCKALIGNMENT(pwfxDst);
            pwfxDst->nAvgBytesPerSec = GSM610_AVGBYTESPERSEC(pwfxDst);
            pwfxDst->cbSize          = GSM610_WFX_EXTRA_BYTES;
	    ((LPGSM610WAVEFORMAT)pwfxDst)->wSamplesPerBlock
		    = GSM610_SAMPLESPERBLOCK(pwfxDst);

            return (MMSYSERR_NOERROR);


        case WAVE_FORMAT_GSM610:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!gsm610IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is able to decode to PCM
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_PCM != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            //  We prefer decoding to 16-bit PCM.
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if ( (16 != pwfxDst->wBitsPerSample) && (8 != pwfxDst->wBitsPerSample) )
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = 16;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize              !!! not used for PCM !!!
            //
            pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfxDst);
            pwfxDst->nAvgBytesPerSec = PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfxDst);

            // pwfxDst->cbSize       = not used;
            return (MMSYSERR_NOERROR);
    }


    //
    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this ACM driver
    //  cannot deal with.
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdFormatSuggest()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format. return error.
            //
            if (ACM_DRIVER_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_GSM610:
                    uFormatTag = WAVE_FORMAT_GSM610;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_GSM610:
                    uFormatTag = WAVE_FORMAT_GSM610;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0] = '\0';
            break;

        case WAVE_FORMAT_GSM610:
            padft->dwFormatTagIndex = 1;
            padft->dwFormatTag      = WAVE_FORMAT_GSM610;
            padft->cbFormatSize     = sizeof(GSM610WAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_GSM610;

            LoadStringCodec(pdi->hinst,
                       IDS_ACM_DRIVER_TAG_NAME,
                       padft->szFormatTag,
                       SIZEOFACMSTR(padft->szFormatTag));
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX      pwfx;
    UINT		uq;		// quotient and
    UINT		ur;		// remainder for arithmetic below.


    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  put some stuff in more accessible variables--note that we
            //  bring variable sizes down to a reasonable size for 16 bit
            //  code...
            //
            pwfx = padf->pwfx;

            switch (padf->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
		    if (ACM_DRIVER_MAX_FORMATS_PCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    //
                    //  now fill in the format structure
		    //
                    pwfx->wFormatTag      = WAVE_FORMAT_PCM;

		    uq = (UINT) padf->dwFormatIndex;
		
		    ur = uq % ACM_DRIVER_MAX_CHANNELS;
		    uq = uq / ACM_DRIVER_MAX_CHANNELS;
		    pwfx->nChannels	    = ur + 1;

		    ur = uq % ACM_DRIVER_MAX_BITSPERSAMPLE_PCM;
		    uq = uq / ACM_DRIVER_MAX_BITSPERSAMPLE_PCM;
		    pwfx->wBitsPerSample =  (WORD)gauPcmFormatIndexToBitsPerSample[ur];

		    ur = uq % ACM_DRIVER_MAX_SAMPLE_RATES;
		    uq = uq / ACM_DRIVER_MAX_SAMPLE_RATES;
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[ur];

                    pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx);
                    pwfx->nAvgBytesPerSec = PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfx);

                    //
                    //  note that the cbSize field is NOT valid for PCM
                    //  formats
                    //
                    //  pwfx->cbSize      = 0;

                    break;


                case WAVE_FORMAT_GSM610:
                    if (ACM_DRIVER_MAX_FORMATS_GSM610 <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    pwfx->wFormatTag      = LOWORD(padf->dwFormatTag);

		    uq = (UINT) padf->dwFormatIndex;
		
		    ur = uq % ACM_DRIVER_MAX_CHANNELS;
		    uq = uq / ACM_DRIVER_MAX_CHANNELS;
		    pwfx->nChannels =	    ur + 1;

		    ur = uq % ACM_DRIVER_MAX_SAMPLE_RATES;
		    uq = uq / ACM_DRIVER_MAX_SAMPLE_RATES;
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[ur];

                    pwfx->wBitsPerSample  = GSM610_BITS_PER_SAMPLE;

                    pwfx->nBlockAlign     = GSM610_BLOCKALIGNMENT(pwfx);
                    pwfx->nAvgBytesPerSec = GSM610_AVGBYTESPERSEC(pwfx);

		    //
		    //
		    //
                    pwfx->cbSize          = GSM610_WFX_EXTRA_BYTES;
		
		    ((LPGSM610WAVEFORMAT)pwfx)->wSamplesPerBlock
					  = GSM610_SAMPLESPERBLOCK(pwfx);
		
		    //
		    //	acm format details support flags.
		    //
		    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
		
                    break;


                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            pwfx = padf->pwfx;

            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (!pcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
		    break;

                case WAVE_FORMAT_GSM610:
                    if (!gsm610IsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.
    //

    //
    //	acm format details support flags.  if 8-bit pcm is
    //	completely disabled (both realtime and non-realtime)
    //	then don't set SUPPORTF_CODEC.
    //
	padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;

    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    BOOL                fRealTime;
    STREAMCONVERTPROC   fnConvert;
    PSTREAMINSTANCE     psi;
    DWORD               nConfigMaxRTEncodeSamplesPerSec;
    DWORD               nConfigMaxRTDecodeSamplesPerSec;

    DWORD               dw;


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));

    nConfigMaxRTEncodeSamplesPerSec =
                gaRateListFormat[pdi->nConfigMaxRTEncodeSetting].dwMonoRate;
    DPF(2,"nConfigMaxRTEncodeSamplesPerSec=%u",nConfigMaxRTEncodeSamplesPerSec);

    nConfigMaxRTDecodeSamplesPerSec =
                gaRateListFormat[pdi->nConfigMaxRTDecodeSetting].dwMonoRate;
    DPF(2,"nConfigMaxRTDecodeSamplesPerSec=%u",nConfigMaxRTDecodeSamplesPerSec);


    //
    //  the most important condition to check before doing anything else
    //  is that this ACM driver can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this driver.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a driver that is suitable for the conversion. also note that
    //  the ACM may call this driver several times with slightly different
    //  format specifications before giving up.
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            if (!pcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!gsm610IsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

            //
            //  if a driver cannot perform real-time encoding then
            //  the driver should fail when opened for a real-time
            //  conversion. note that the driver MUST return
            //  MMSYSERR_NOTSUPPORTED in this case!
            //
            //  this driver may or may not be able to perform real-time
            //  encoding, depending on the system on which it is running.
            //  this driver allows the user to select whether to support
            //  real-time encoding thru the config dialog.
            //
            //  if this open is for a real-time conversion, fail if
            //  real-time encoding hasn't been enabled in the config
            //  dialog.
            //
            if (fRealTime)
            {
                dw = nConfigMaxRTEncodeSamplesPerSec;
                dw = dw / pwfxSrc->nChannels;
                if (dw < pwfxSrc->nSamplesPerSec)
                {
                    return (MMSYSERR_NOTSUPPORTED);
                }
            }

            fnConvert = gsm610Encode;
            break;


        case WAVE_FORMAT_GSM610:
            if (!gsm610IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!pcmIsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

            //
            //  if a driver cannot perform real-time encoding then
            //  the driver should fail when opened for a real-time
            //  conversion. note that the driver MUST return
            //  MMSYSERR_NOTSUPPORTED in this case!
            //
            //  this driver may or may not be able to perform real-time
            //  encoding, depending on the system on which it is running.
            //  this driver allows the user to select whether to support
            //  real-time encoding thru the config dialog.
            //
            //  if this open is for a real-time conversion, fail if
            //  real-time encoding hasn't been enabled in the config
            //  dialog.
            //
            if (fRealTime)
            {
                dw = nConfigMaxRTDecodeSamplesPerSec;
                dw = dw / pwfxSrc->nChannels;
                if (dw < pwfxSrc->nSamplesPerSec)
                {
                    return (MMSYSERR_NOTSUPPORTED);
                }
            }

            fnConvert = gsm610Decode;
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  for this driver, we must also verify that the nChannels and
    //  nSamplesPerSec members are the same between the source and
    //  destination formats.
    //
    if (pwfxSrc->nChannels != pwfxDst->nChannels)
        return (MMSYSERR_NOTSUPPORTED);

    if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (0 != (ACM_STREAMOPENF_QUERY & padsi->fdwOpen))
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this driver allocates a small instance structure for each stream
    //
    //
    psi = (PSTREAMINSTANCE)LocalAlloc(LPTR, sizeof(*psi));
    if (NULL == psi)
    {
        return (MMSYSERR_NOMEM);
    }


    //
    //  fill out our instance structure
    //
    //  this driver stores a pointer to the conversion function that will
    //  be used for each conversion on this stream. we also store a
    //  copy of the _current_ configuration of the driver instance we
    //  are opened on. this must not change during the life of the stream
    //  instance.
    //
    //  this is also very important! if the user is able to configure how
    //  the driver performs conversions, the changes should only affect
    //  future open streams. all current open streams should behave as
    //  they were configured during the open.
    //
    psi->fnConvert  = fnConvert;

    //
    //  this driver must also initialize of few things
    //
    gsm610Reset(psi);


    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0L;
    padsi->dwDriver  = (DWORD_PTR)psi;

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose). The ACM driver should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      NOTE! It is _strongly_ recommended that a driver not fail to close
//      a conversion stream.
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCE     psi;

    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (PSTREAMINSTANCE)padsi->dwDriver;
    if (NULL != psi)
    {
        //
        //  free the stream instance structure
        //
        LocalFree((HLOCAL)psi);
    }

    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    PSTREAMINSTANCE     psi;
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    DWORD               cb;
    DWORD		dwcSamples;
    DWORD               cBlocks;

    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    //
    //
    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
	case ACM_STREAMSIZEF_SOURCE:

            if (WAVE_FORMAT_GSM610 == pwfxSrc->wFormatTag)
            {
                //
                //  how many destination PCM bytes are needed to hold
                //  the decoded GSM 6.10 data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
		cb = padss->cbSrcLength;
		cBlocks = cb / GSM610_BLOCKALIGNMENT(pwfxSrc);

                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                if ((0xFFFFFFFFL / (GSM610_SAMPLESPERBLOCK(pwfxSrc))) < cBlocks)
                    return (ACMERR_NOTPOSSIBLE);
		dwcSamples = cBlocks * GSM610_SAMPLESPERBLOCK(pwfxSrc);

		if (PCM_BYTESTOSAMPLES(((LPPCMWAVEFORMAT)(pwfxDst)), 0xFFFFFFFFL) < dwcSamples)
		    return (ACMERR_NOTPOSSIBLE);
		cb = PCM_SAMPLESTOBYTES(((LPPCMWAVEFORMAT)(pwfxDst)), dwcSamples);

            }
            else
            {
                //
                //  how many destination GSM 6.10 bytes are needed to hold
                //  the encoded PCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
		cb = padss->cbSrcLength;
		dwcSamples = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)(pwfxSrc), cb);
                cBlocks = dwcSamples / GSM610_SAMPLESPERBLOCK(pwfxDst);
		
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

		if (0 != dwcSamples % GSM610_SAMPLESPERBLOCK(pwfxDst))
		{
		    // Another block to possibly hold the last
		    // fragment of source data if acmdStreamConvert
		    // is called without block align
		    cBlocks++;
		}

                cb = cBlocks * GSM610_BLOCKALIGNMENT(pwfxDst);
            }

            padss->cbDstLength = cb;
            return (MMSYSERR_NOERROR);

        case ACM_STREAMSIZEF_DESTINATION:

            if (WAVE_FORMAT_GSM610 == pwfxDst->wFormatTag)
            {
                //
                //  how many source PCM bytes can be encoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
		cb = padss->cbDstLength;
                cBlocks = cb / GSM610_BLOCKALIGNMENT(pwfxDst);

                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                if ((0xFFFFFFFFL / (GSM610_SAMPLESPERBLOCK(pwfxDst))) < cBlocks)
		    return (ACMERR_NOTPOSSIBLE);
		dwcSamples = cBlocks * GSM610_SAMPLESPERBLOCK(pwfxDst);

		if (PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)pwfxSrc, 0xFFFFFFFFL) < dwcSamples)
		    return (ACMERR_NOTPOSSIBLE);
		cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)pwfxSrc, dwcSamples);

            }
            else
            {
                //
                //  how many source GSM 6.10 bytes can be decoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
		cb = padss->cbDstLength;
		dwcSamples = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)(pwfxDst), cb);
		cBlocks = dwcSamples / GSM610_SAMPLESPERBLOCK(pwfxSrc);

                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * GSM610_BLOCKALIGNMENT(pwfxSrc);
            }

            padss->cbSrcLength = cb;
            return (MMSYSERR_NOERROR);

    }

    //
    //  if the query type is not understood by this driver, then we need
    //  to return MMSYSERR_NOTSUPPORTED.
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR               dwId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PDRIVERINSTANCE     pdi;

    //
    //  make pdi either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwId is for other
    //  messages (instance data).
    //
    pdi = (PDRIVERINSTANCE)dwId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef WIN32
            DbgInitialize(TRUE);
	    DPF(4, "DRV_LOAD");
#endif
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
	    DPF(4, "DRV_FREE");
            return (1L);

        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
	    DPF(4, "DRV_OPEN");
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
	    DPF(4, "DRV_CLOSE");
            lr = acmdDriverClose(pdi);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
	    DPF(4, "DRV_INSTALL");
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
	    DPF(4, "DRV_REMOVE");
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
	    DPF(4, "DRV_QUERYCONFIGURE");
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
	    DPF(4, "DRV_CONFIGURE");
            lr = acmdDriverConfigure(pdi, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
	    DPF(4, "ACMDM_DRIVER_DETAILS");
            lr = acmdDriverDetails(pdi, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
	    DPF(4, "ACMDM_DRIVER_ABOUT");
            lr = acmdDriverAbout(pdi, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
       case ACMDM_FORMAT_SUGGEST:
	    DPF(4, "ACMDM_FORMAT_SUGGEST");
            lr = acmdFormatSuggest(pdi, (LPACMDRVFORMATSUGGEST)lParam1);
            return (lr);


        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
	    DPF(4, "ACMDM_FORMATTAG_DETAILS");
            lr = acmdFormatTagDetails(pdi, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
	    DPF(4, "ACMDM_FORMAT_DETAILS");
            lr = acmdFormatDetails(pdi, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
	    DPF(4, "ACMDM_STREAM_OPEN");
            lr = acmdStreamOpen(pdi, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
	    DPF(4, "ACMDM_STREAM_CLOSE");
            lr = acmdStreamClose((LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
	    DPF(4, "ACMDM_STREAM_SIZE");
            lr = acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
	{
	    PSTREAMINSTANCE         psi;
	    LPACMDRVSTREAMINSTANCE  padsi;
	    LPACMDRVSTREAMHEADER    padsh;

	    DPF(4, "ACMDM_STREAM_CONVERT");
            //
            //  our stream instance data is a pointer to the conversion
            //  procedure needed to convert the pwfxSrc data to pwfxDst.
            //  the correct procedure to use was decided in acmdStreamOpen
            //
            padsi = (LPACMDRVSTREAMINSTANCE)lParam1;
            padsh = (LPACMDRVSTREAMHEADER)lParam2;

            psi   = (PSTREAMINSTANCE)padsi->dwDriver;

            lr = psi->fnConvert(padsi, padsh);
            return (lr);
        }
    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\g711\gentable.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  gentable.c
//
//  Description:
//      This is a utility program to generate various tables in the
//      form of 'C' source code.  Portions of some of these tables can
//      be pasted into codec source code.  The output is to stdio
//      and can be redirected into a file.  Portions of the file can
//      then be cut and pasted into another 'C' source file as necessary.
//
//==========================================================================;


#include <stdio.h>

//--------------------------------------------------------------------------;
//
//  Name:
//      UlawToAlawTable
//
//
//  Description:
/*      This table was copied directly from the G.711 specification.  Using
        the G.711 spec terminology, this table converts u-law decoder output
        value numbers to A-law decoder output value numbers.
*/      
//      
//  Arguments:
//
//
//  Return:
//
//
//  Notes:
//
//
//  History:
//      08/01/93    Created.
//
//
//--------------------------------------------------------------------------;
unsigned char UlawToAlawTable[128] =
    {
    1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,
    9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
    27,29,31,
    33,34,35,36,37,38,39,40,41,42,43,44,
    46,
    48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,
    64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
    81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
    100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,
    120,121,122,123,124,125,126,127,128
    };

//--------------------------------------------------------------------------;
//
//  Name:
//      AlawToUlawTable
//
//
//  Description:
/*      This table was copied directly from the G.711 specification.  Using
        the G.711 spec terminology, this table converts A-law decoder output
        value numbers to u-law decoder output value numbers.  A-law decoder
        output value numbers range from 1 to 128, so AlawToUlawTable[0] is
        unused.  Note that u-law decoder output value numbers range from
        0 to 127.
*/      
//      
//  Arguments:
//
//
//  Return:
//
//
//  Notes:
//
//
//  History:
//      08/01/93    Created.
//
//
//--------------------------------------------------------------------------;
unsigned char AlawToUlawTable[129] =
    {
    0,      // this first entry not used
    1,3,5,7,9,11,13,
    15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
    32,32,33,33,34,34,35,35,
    36,37,38,39,40,41,42,43,44,45,46,47,
    48,48,49,49,
    50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
    64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
    79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
    100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,
    116,117,118,119,120,121,122,123,124,125,126,127
    };
    
short DecodeTable[256];


//
// Our main procedure.
//

void main()
    {

    short i,j;
    
    short SegBase[16];
    short IntervalStep[16];
    
    short Sample;
    
      
      
    //
    // This generates a decode table for A-law.  The resulting
    // table can be used to convert an A-law character to
    // a 16-bit PCM value.
    //
    
    // These seg base values and interval steps are based directly
    // on the G.711 A-law spec.  They correspond to 13-bit PCM data.
    SegBase[ 0] =    -1;        IntervalStep[ 0] =   -2;
    SegBase[ 1] =   -33;        IntervalStep[ 1] =   -2;
    SegBase[ 2] =   -66;        IntervalStep[ 2] =   -4;
    SegBase[ 3] =  -132;        IntervalStep[ 3] =   -8;
    SegBase[ 4] =  -264;        IntervalStep[ 4] =  -16;
    SegBase[ 5] =  -528;        IntervalStep[ 5] =  -32;
    SegBase[ 6] = -1056;        IntervalStep[ 6] =  -64;
    SegBase[ 7] = -2112;        IntervalStep[ 7] = -128;
    SegBase[ 8] =     1;        IntervalStep[ 8] =    2;
    SegBase[ 9] =    33;        IntervalStep[ 9] =    2;
    SegBase[10] =    66;        IntervalStep[10] =    4;
    SegBase[11] =   132;        IntervalStep[11] =    8;
    SegBase[12] =   264;        IntervalStep[12] =   16;
    SegBase[13] =   528;        IntervalStep[13] =   32;
    SegBase[14] =  1056;        IntervalStep[14] =   64;
    SegBase[15] =  2112;        IntervalStep[15] =  128;
    
    printf("\n\n\n\n\n// A-law decode table:\n\n");
    
    for (i=0; i<16; i++)
        for (j=0; j<16; j++)
            {
            Sample = SegBase[i^0x05] + IntervalStep[i^0x05]*(j^0x05);
            // Sample is a 13-bit signed PCM value.
            // In our table, we'll convert it to 16-bit.  The
            // generated comment will indicate the 13-bit value.
            printf( "\t%6d,\t\t// y[%02x]= %6d\n",
                    Sample << 3,
                    i*16 + j,
                    Sample);
            }
            
            
            
    //
    // This generates a decode table for u-law.  The resulting
    // table can be used to convert a u-law character to
    // a 16-bit PCM value.
    //      
    
    // These seg base values and interval steps are based directly
    // on the G.711 A-law spec.  They correspond to 14-bit PCM data.
    SegBase[ 0] = -8031;        IntervalStep[ 0] =  256;
    SegBase[ 1] = -3999;        IntervalStep[ 1] =  128;
    SegBase[ 2] = -1983;        IntervalStep[ 2] =   64;
    SegBase[ 3] =  -975;        IntervalStep[ 3] =   32;
    SegBase[ 4] =  -471;        IntervalStep[ 4] =   16;
    SegBase[ 5] =  -219;        IntervalStep[ 5] =    8;
    SegBase[ 6] =   -93;        IntervalStep[ 6] =    4;
    SegBase[ 7] =   -30;        IntervalStep[ 7] =    2;
    SegBase[ 8] =  8031;        IntervalStep[ 8] = -256;
    SegBase[ 9] =  3999;        IntervalStep[ 9] = -128;
    SegBase[10] =  1983;        IntervalStep[10] =  -64;
    SegBase[11] =   975;        IntervalStep[11] =  -32;
    SegBase[12] =   471;        IntervalStep[12] =  -16;
    SegBase[13] =   219;        IntervalStep[13] =   -8;
    SegBase[14] =    93;        IntervalStep[14] =   -4;
    SegBase[15] =    30;        IntervalStep[15] =   -2;
    
    printf("\n\n\n\n\n// u-law decode table:\n\n");
    
    for (i=0; i<16; i++)
        for (j=0; j<16; j++)
            {
            Sample = SegBase[i] + IntervalStep[i]*j;
            // Sample is a 14-bit signed PCM value.
            // In our table, we'll convert it to 16-bit.  The
            // generated comment will indicate the 14-bit value.
            printf( "\t%6d,\t\t// y[%02x]= %6d\n",
                    Sample << 2,
                    i*16 + j,
                    Sample);
            }
    
        


    //
    // This generates a conversion table from A-law chars
    // to u-law chars.  The AlawToUlawTable above converts
    // decoder output value numbers, which is not quite what
    // we want.  Using that table, this routine will generate
    // 'C' source code for a table that converts directly from
    // A-law chars to u-law chars.
    //
    printf("\n\n\n\n\n// A-law to u-law char conversion table:\n\n");
    for (i=0; i<256; i++)       // i counts thru all A-law chars
        {
        // Here is the process to go from an A-law char
        // to a u-law char.
        
        // 1.   convert from A-law char to A-law decoder
        //      output value number.  from observing the tables
        //      in the G.711 spec it can be seen that this is
        //      done by inverting the even bits and dropping the
        //      sign bit of the A-law char and then adding 1.
        // 2.   using the AlawToUlawTable above, convert from
        //      the A-law decoder output value number to the
        //      corresponding u-law output value number.
        // 3.   convert from u-law decoder output value
        //      number to u-law char.  from observing the tables
        //      in the G.711 spec it can be seen that this is
        //      done by inverting the 7 LSBs of the u-law
        //      decoder output value number.
        // 4.   apply polarity to the u-law char.  that is,
        //      set the sign bit of the u-law char the same
        //      as the sign bit of the original A-law char.
                  
        j = i;                  // j starts of as original A-law char                 
        // Step 1:            
        j = ((i^0x55) & 0x7F) + 1;
        // Step 2:
        j = AlawToUlawTable[j];
        // Step 3:
        j = (j ^ 0x7F);
        // Step 4:
        j = j | (i & 0x80);     // j ends as corresponding u-law char
        
        // Now i is an A-law char and j is the corresponding u-law char
        printf( "\t0x%02x,\t\t// A-law[%02x] ==> u-law[%02x]\n",
                j,
                i,
                j);
                
        }
        
        
        
                
    //
    // This generates a conversion table from u-law chars
    // to A-law chars.  The UlawToAlawTable above converts
    // decoder output value numbers, which is not quite what
    // we want.  Using that table, this routine will generate
    // 'C' source code for a table that converts directly from
    // u-law chars to A-law chars.
    //
    printf("\n\n\n\n\n// u-law to A-law char conversion table:\n\n");
    for (i=0; i<256; i++)       // i counts thru all U-law chars
        {
        // Here is the process to go from a u-law char
        // to a A-law char.
        
        // 1.   convert from u-law char to u-law decoder
        //      output value number.  from observing the tables
        //      in the G.711 spec it can be seen that this is
        //      done by dropping the sign bit of the u-law
        //      char and then inverting the 7 LSBs.
        // 2.   using the UlawToAlawTable above, convert from
        //      the u-law decoder output value number to the
        //      corresponding A-law output value number.
        // 3.   convert from A-law decoder output value
        //      number to A-law char.  from observing the tables
        //      in the G.711 spec it can be seen that this is
        //      done by subtracting 1 from the A-law decoder output
        //      value number and inverting the even bits.
        // 4.   apply polarity to the A-law char.  that is,
        //      set the sign bit of the A-law char the same
        //      as the sign bit of the original u-law char.
                  
        j = i;                  // j starts of as original u-law char                 
        // Step 1:            
        j = (i & 0x7F) ^ 0x7F;
        // Step 2:
        j = UlawToAlawTable[j];
        // Step 3:
        j = (j - 1)^0x55;
        // Step 4:
        j = j | (i & 0x80);     // j ends as corresponding A-law char
        
        // Now i is a u-law char and j is the corresponding A-law char
        printf( "\t0x%02x,\t\t// u-law[%02x] ==> A-law[%02x]\n",
                j,
                i,
                j);
                
        }
    
    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\gsm610\codec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.h
//
//  Description:
//      This file contains codec definitions, Win16/Win32 compatibility
//      definitions, and instance structure definitions.
//
//
//==========================================================================;

#ifndef _INC_CODEC
#define _INC_CODEC                  // #defined if codec.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_ACM_DRIVER is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(4,  0, 0)
#else
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(3, 51, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(1, 0, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
	typedef LPCSTR		LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))

//
//
//
typedef BOOL FAR*   LPBOOL;


#ifndef INLINE
    #define INLINE __inline
#endif


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwf argument is a pointer to a PCMWAVEFORMAT structure.
//
#define PCM_BLOCKALIGNMENT(pwf)     (UINT)(((pwf)->wBitsPerSample >> 3) << ((pwf)->wf.nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwf)     (DWORD)((pwf)->wf.nSamplesPerSec * (pwf)->wf.nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwf, dw) (DWORD)(dw / PCM_BLOCKALIGNMENT(pwf))
#define PCM_SAMPLESTOBYTES(pwf, dw) (DWORD)(dw * PCM_BLOCKALIGNMENT(pwf))



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tDRIVERINSTANCE
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the driver will be easier to combine
    //  with other types of drivers (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of driver: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your driver requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           fdwOpen;        // flags from open description

    LPDRVCONFIGINFO pdci;
    DWORD           fdwConfig;      // stream instance configuration flags

    HKEY            hkey;
    UINT            nConfigMaxRTEncodeSetting;
    UINT            nConfigMaxRTDecodeSetting;
    UINT            nConfigPercentCPU;
    BOOL            fHelpRunning;           // Used by config DlgProc only.
#ifdef WIN4
    HBRUSH          hbrDialog;              // Used by config DlgProc only.
#endif

} DRIVERINSTANCE, *PDRIVERINSTANCE, FAR *LPDRIVERINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;


//
//  Structure used for storing configuration setting.
//  See codec.c for a description of this structure and its use.
//
typedef struct tRATELISTFORMAT
{
    UINT        uFormatType;
    UINT        idsFormat;
    DWORD       dwMonoRate;
} RATELISTFORMAT;
typedef RATELISTFORMAT *PRATELISTFORMAT;

#define CONFIG_RLF_NONUMBER     1
#define CONFIG_RLF_MONOONLY     2
#define CONFIG_RLF_STEREOONLY   3
#define CONFIG_RLF_MONOSTEREO   4


//
//
//
//
typedef LRESULT (FNGLOBAL *STREAMCONVERTPROC)
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);


//
//
//
//
typedef struct tSTREAMINSTANCE
{
    STREAMCONVERTPROC   fnConvert;  // stream instance conversion proc
    DWORD               fdwConfig;  // stream instance configuration flags

    //
    //  This GSM610 codec requires the following parameters
    //  per stream instance.  These parameters are used by
    //  the encode and decode routines.
    //
    SHORT               dp[120];
    SHORT               drp[160];
    SHORT               z1;
    LONG                l_z2;
    SHORT               mp;
    SHORT               OldLARpp[9];
    SHORT               u[8];
    SHORT               nrp;
    SHORT               OldLARrpp[9];
    SHORT               msr;
    SHORT               v[9];

} STREAMINSTANCE, *PSTREAMINSTANCE, FAR *LPSTREAMINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  resource id's
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDS_ACM_DRIVER_SHORTNAME    (1)     // ACMDRIVERDETAILS.szShortName
#define IDS_ACM_DRIVER_LONGNAME     (2)     // ACMDRIVERDETAILS.szLongName
#define IDS_ACM_DRIVER_COPYRIGHT    (3)     // ACMDRIVERDETAILS.szCopyright
#define IDS_ACM_DRIVER_LICENSING    (4)     // ACMDRIVERDETAILS.szLicensing
#define IDS_ACM_DRIVER_FEATURES     (5)     // ACMDRIVERDETAILS.szFeatures

#define IDS_ACM_DRIVER_TAG_NAME     (20)    // ACMFORMATTAGDETAILS.szFormatTag

#define IDS_ERROR		    (30)
#define IDS_ERROR_NOMEM		    (31)
#define IDS_CONFIG_NORATES          (32)
#define IDS_CONFIG_ALLRATES         (33)
#define IDS_CONFIG_MONOONLY         (34)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  resource id's for gsm 610 configuration dialog box
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDD_CONFIG                      RCID(100)
#define IDC_BTN_AUTOCONFIG              1001
#define IDC_BTN_HELP                    1002
#define IDC_COMBO_MAXRTENCODE           1003
#define IDC_COMBO_MAXRTDECODE           1004
#define IDC_STATIC_COMPRESS				1005
#define IDC_STATIC_DECOMPRESS			1006
#define IDC_STATIC                      -1

#define MSGSM610_CONFIG_DEFAULT_MAXRTENCODESETTING          0
#define MSGSM610_CONFIG_DEFAULT_MAXRTDECODESETTING          1
#define MSGSM610_CONFIG_UNCONFIGURED                        0x0999
#define MSGSM610_CONFIG_DEFAULT_PERCENTCPU		    50
#define MSGSM610_CONFIG_DEFAULTKEY                          HKEY_CURRENT_USER


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  global variables, etc...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

extern const UINT   gauFormatIndexToSampleRate[];
extern const UINT   ACM_DRIVER_MAX_SAMPLE_RATES;
extern const RATELISTFORMAT gaRateListFormat[];
extern const UINT   MSGSM610_CONFIG_NUMSETTINGS;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  function prototypes
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

BOOL FNGLOBAL acmdDriverConfigInit
(
    PDRIVERINSTANCE	    pdi,
    LPCTSTR		    pszAliasName
);

INT_PTR FNWCALLBACK acmdDlgProcConfigure
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_CODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\gsm610\config.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  config.c
//
//  Description:
//	GSM 6.10 configuration init and dialog
//
//
//	The configuration parameters for this codec are:
//
//	    MaxRTEncodeSetting:
//	    MaxRTDecodeSetting:
//		These determine the highest mono sample rate that
//		the codec will attempt to convert in real-time.
//
//	    PercentCPU:
//		This configuration parameter is not normally changed
//		by the user and is not presented in the config dialog.
//		This value affects the config dialog's 'Auto-Config'
//		calculation of MaxRTXxcodeSamplesPerSec.
//
//  These parameters may be set in the registry, using the gsm610 subkey
//  (which corresponds to the alias name used for installation) under
//  the following key:
//
//      HKEY_CURRENT_USER\Software\Microsoft\Multimedia
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "gsm610.h"
#include "debug.h"

#ifdef WIN32
#include <tchar.h>
#else
#define _tcstoul strtoul
#define _tcsncpy _fstrncpy
#endif

#include <string.h>
#include <stdlib.h>


//
//  Strings required to access configuration information in the registry.
//
const TCHAR BCODE gszMaxRTEncodeSetting[]   = TEXT("MaxRTEncodeSetting");
const TCHAR BCODE gszMaxRTDecodeSetting[]   = TEXT("MaxRTDecodeSetting");
const TCHAR BCODE gszPercentCPU[]		    = TEXT("PercentCPU");
const TCHAR gszMultimediaKey[] = TEXT("Software\\Microsoft\\Multimedia\\");

#define MSGSM610_CONFIG_TEXTLEN         80


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//  Be careful changing the following!
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//  Data required to access the dialog box help.
//
//  Note that you must write your own help file for your codec, even if
//  the configuration dialog box looks identical.  If you use the file
//  listed here, then the title will say "GSM 6.10" or something.
//
//  Note:  the number HELPCONTEXT_MSGSM610 must be unique in the file
//          gszHelpFilename, and the number must defined in the [MAP]
//          section of the .hpj help project file.  Then the .rtf file
//          will reference that number (using the keyword defined in
//          the .hpj file).  Then when we call WinHelp with the number,
//          WinHelp will go to the right help entry.
//
const TCHAR BCODE gszHelpFilename[]         = TEXT("audiocdc.hlp");
#define HELPCONTEXT_MSGSM610          1002
#define IDH_AUDIOCDC_COMPRESSION	  100
#define IDH_AUDIOCDC_DECOMPRESSION    200
#define IDH_AUDIOCDC_AUTOCONFIGURE	  300
static int aKeyWordIds[] = {
				   IDC_COMBO_MAXRTENCODE, IDH_AUDIOCDC_COMPRESSION,
				   IDC_STATIC_COMPRESS, IDH_AUDIOCDC_COMPRESSION,
				   IDC_COMBO_MAXRTDECODE, IDH_AUDIOCDC_DECOMPRESSION,
				   IDC_STATIC_DECOMPRESS, IDH_AUDIOCDC_DECOMPRESSION,
				   IDC_BTN_AUTOCONFIG, IDH_AUDIOCDC_AUTOCONFIGURE,
				   0, 0
			       };



//==========================================================================;
//
//
//
//
//==========================================================================;

LPVOID FNLOCAL GlobalAllocLock(HGLOBAL far * ph, DWORD dwc)
{
    *ph = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, dwc);
    if (NULL != *ph)
	return GlobalLock(*ph);
    else
	return NULL;
}

VOID FNLOCAL GlobalUnlockFree(LPVOID p, HGLOBAL h)
{
    if (NULL != h)
    {
	if (NULL != p) GlobalUnlock(h);
	GlobalFree(h);
    }
    return;
}

//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  VOID configWriteConfiguration
//  
//  Description:
//
//      This routine writes the configuration data in PDI to the registry.
//      This consists of the max real-time Encode and Decode settings.
//  
//  Arguments:
//      PDRIVERINSTANCE     pdi
//  
//  Return (VOID):  None.
//  
//--------------------------------------------------------------------------;

VOID configWriteConfiguration
(
    PDRIVERINSTANCE     pdi
)
{
    DWORD               dw;


    if( NULL != pdi->hkey )
    {
        dw   = (DWORD)pdi->nConfigMaxRTEncodeSetting;
        (void)RegSetValueEx( pdi->hkey, (LPTSTR)gszMaxRTEncodeSetting, 0,
                                REG_DWORD, (LPBYTE)&dw, sizeof(DWORD) );

        dw   = (DWORD)pdi->nConfigMaxRTDecodeSetting;
        (void)RegSetValueEx( pdi->hkey, (LPTSTR)gszMaxRTDecodeSetting, 0,
                                REG_DWORD, (LPBYTE)&dw, sizeof(DWORD) );
    }
}


//--------------------------------------------------------------------------;
//  
//  DWORD dwReadRegistryDefault
//  
//  Description:
//
//      This routine reads a given value from the registry, and returns a
//      default value if the read is not successful.
//  
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPTSTR  lpszEntry:
//      DWORD   dwDefault:
//  
//  Return (DWORD):
//  
//--------------------------------------------------------------------------;

INLINE DWORD dwReadRegistryDefault
(
    HKEY                hkey,
    LPTSTR              lpszEntry,
    DWORD               dwDefault
)
{
    DWORD   dwType = (DWORD)~REG_DWORD;  // Init to anything but REG_DWORD.
    DWORD   cbSize = sizeof(DWORD);
    DWORD   dwRet;
    LONG    lError;

    ASSERT( NULL != hkey );
    ASSERT( NULL != lpszEntry );


    lError = RegQueryValueEx( hkey,
                              lpszEntry,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwRet,
                              &cbSize );

    if( ERROR_SUCCESS != lError  ||  REG_DWORD != dwType )
        dwRet = dwDefault;

    return dwRet;
}


//--------------------------------------------------------------------------;
//  
//  VOID configSetDefaults
//  
//  Description:
//
//      This routine sets the configuration parameters to their default
//      values.
//  
//  Arguments:
//      PDRIVERINSTANCE pdi:
//  
//--------------------------------------------------------------------------;

VOID configSetDefaults
(
    PDRIVERINSTANCE     pdi
)
{
    pdi->nConfigMaxRTEncodeSetting =
            MSGSM610_CONFIG_DEFAULT_MAXRTENCODESETTING;

    pdi->nConfigMaxRTDecodeSetting =
            MSGSM610_CONFIG_DEFAULT_MAXRTDECODESETTING;

    pdi->nConfigPercentCPU =
            MSGSM610_CONFIG_DEFAULT_PERCENTCPU;
}


//--------------------------------------------------------------------------;
//  
//  UINT configAutoConfig
//  
//  Description:
//
//	We will determine how much time it takes to encode and then decode
//	2 seconds of data and use this to guess at the max sample
//	rate we can convert in real-time.
//
//	The max is computed with essentially 100% of the CPU.  Practically,
//	we won't have 100% of the CPU available.  So we take a percentage
//	of the computed max and use that as the max in the config dialog.
//
//	The percentage that we use can be set in the ini file gsm610
//	section by PercentCPU=xx.
//
//  
//  Arguments:
//      HWND hwnd:
//  
//  Return (UINT):  String identifier (IDS) of error message, or zero if
//      the call succeeded.
//  
//--------------------------------------------------------------------------;

UINT FNLOCAL configAutoConfig
(
    PDRIVERINSTANCE             pdi,
    UINT                        *pnEncodeSetting,
    UINT                        *pnDecodeSetting
)
{
    UINT		    nConfig;
    
    UINT		    uIDS;
    HCURSOR		    hCursorSave;

    PSTREAMINSTANCE	    psi;
    
    HGLOBAL		    hbPCM;
    HGLOBAL		    hbGSM;
    HGLOBAL		    hpcmwf;
    HGLOBAL		    hgsmwf;
    HGLOBAL		    hadsi;
    HGLOBAL		    hadsh;
    
    LPBYTE		    pbPCM, pbGSM;
    DWORD		    cbPCMLength, cbGSMLength;

    LPPCMWAVEFORMAT	    ppcmwf;
    LPGSM610WAVEFORMAT	    pgsmwf;

    LPACMDRVSTREAMINSTANCE  padsi;
    LPACMDRVSTREAMHEADER    padsh;

    DWORD		    dwTime;
    DWORD		    dwMaxRate;


    //
    //  We divide by this!
    //
    ASSERT( 0 != pdi->nConfigPercentCPU );

    
    //
    // Init stuff that gets cleaned up at errReturn
    //
    //
    uIDS   = 0;
    
    psi    = NULL;

    hbPCM  = NULL;
    hbGSM  = NULL;
    hpcmwf = NULL;
    hgsmwf = NULL;
    hadsi  = NULL;
    hadsh  = NULL;
    
    pbPCM  = NULL;
    pbGSM  = NULL;
    ppcmwf = NULL;
    pgsmwf = NULL;
    padsi  = NULL;
    padsh  = NULL;


    //
    // This function may take a while.  Set hour glass cursor
    //
    //
    hCursorSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Allocate memory for all our structures
    //
    //
    psi    = (PSTREAMINSTANCE)LocalAlloc(LPTR, sizeof(*psi));

    cbPCMLength	    = 2 * (8000 / 1 * 2);
    cbGSMLength	    = 2 * (8000 / 320 * 65);

    pbPCM = GlobalAllocLock(&hbPCM, cbPCMLength);
    pbGSM = GlobalAllocLock(&hbGSM, cbGSMLength);
    
    ppcmwf = GlobalAllocLock(&hpcmwf, sizeof(*ppcmwf));
    pgsmwf = GlobalAllocLock(&hgsmwf, sizeof(*pgsmwf));
    
    padsi = GlobalAllocLock(&hadsi, sizeof(*padsi));
    padsh = GlobalAllocLock(&hadsh, sizeof(*padsh));


    //
    // if we couldn't allocate some of the memory
    //
    //
    if ( (psi == NULL)	    ||
	 (pbPCM == NULL)    ||
	 (pbGSM == NULL)    ||
	 (ppcmwf == NULL)   ||
	 (pgsmwf == NULL)   ||
	 (padsi == NULL)    ||
	 (padsh == NULL) )
    {
	uIDS = IDS_ERROR_NOMEM;
	goto errReturn;
    }

    //
    //
    //

    //
    // Fill in format structures for GSM 6.10 and PCM
    //
    //
    pgsmwf->wfx.wFormatTag	= WAVE_FORMAT_GSM610;
    pgsmwf->wfx.nChannels	= 1;
    pgsmwf->wfx.nSamplesPerSec	= 8000;
    pgsmwf->wfx.nAvgBytesPerSec	= 8000 / 320 * 65;
    pgsmwf->wfx.nBlockAlign	= 65;
    pgsmwf->wfx.wBitsPerSample	= 0;
    pgsmwf->wfx.cbSize		= 0;
    pgsmwf->wSamplesPerBlock	= 320;
    
    ppcmwf->wf.wFormatTag	= WAVE_FORMAT_PCM;
    ppcmwf->wf.nChannels	= 1;
    ppcmwf->wf.nSamplesPerSec	= 8000;
    ppcmwf->wf.nAvgBytesPerSec	= 8000 / 1 * 2;
    ppcmwf->wf.nBlockAlign	= 2;
    ppcmwf->wBitsPerSample	= 16;

    //
    // get the time, do encode, get the time.  btw, we've never written
    // any data into our audio data buffers.  we don't know what's in
    // them nor do we care.  we just want to see how long it takes to
    // perform the conversion.
    //
    //
    dwTime = timeGetTime();
    
    padsi->cbStruct	= sizeof(padsi);
    padsi->pwfxSrc	= (LPWAVEFORMATEX) ppcmwf;
    padsi->pwfxDst	= (LPWAVEFORMATEX) pgsmwf;
    padsi->dwDriver	= (DWORD_PTR) psi;

    padsh->cbStruct	= sizeof(padsh);
    padsh->pbSrc	= pbPCM;
    padsh->cbSrcLength	= cbPCMLength;
    padsh->pbDst	= pbGSM;
    padsh->cbDstLength	= cbGSMLength;
    padsh->fdwConvert	= ACM_STREAMCONVERTF_BLOCKALIGN | ACM_STREAMCONVERTF_START;

    gsm610Encode(padsi, padsh);
    
    dwTime = timeGetTime() - dwTime;

    //
    // calculate what we might be able to do in real-time
    //
    //
    if (dwTime == 0)
	dwMaxRate = 0xFFFFFFFFL;
    else
	dwMaxRate = (1000L * 2L * ppcmwf->wf.nSamplesPerSec / dwTime);
    
    if ( (0xFFFFFFFFL / pdi->nConfigPercentCPU) >= dwMaxRate )
	dwMaxRate = dwMaxRate * pdi->nConfigPercentCPU / 100;
    
    if (dwMaxRate > 0xFFFFL)
	dwMaxRate = 0xFFFFL;
    
    DPF(1,"Encode dwMaxRate=%u", dwMaxRate);
    
    //
    //  Now set the configuration based on dwMaxRate.  We scan the
    //  gaRateListFormat[] array looking at the dwMonoRate to determine
    //  the appropriate setting.
    //
    nConfig = 0;                                                
    while( gaRateListFormat[nConfig].dwMonoRate < dwMaxRate  &&
           MSGSM610_CONFIG_NUMSETTINGS > nConfig )
    {
        nConfig++;
    }
    *pnEncodeSetting = nConfig - 1;  // We went too far.

    
    //
    // get the time, do decode, get the time
    //
    //
    dwTime = timeGetTime();
    
    padsi->cbStruct	= sizeof(*padsi);
    padsi->pwfxSrc	= (LPWAVEFORMATEX) pgsmwf;
    padsi->pwfxDst	= (LPWAVEFORMATEX) ppcmwf;
    padsi->dwDriver	= (DWORD_PTR) psi;

    padsh->cbStruct	= sizeof(*padsh);
    padsh->pbSrc	= pbGSM;
    padsh->cbSrcLength	= cbGSMLength;
    padsh->pbDst	= pbPCM;
    padsh->cbDstLength	= cbPCMLength;
    padsh->fdwConvert	= ACM_STREAMCONVERTF_BLOCKALIGN | ACM_STREAMCONVERTF_START;

    gsm610Decode(padsi, padsh);
    
    dwTime = timeGetTime() - dwTime;

    //
    // calculate what we might be able to do in real-time
    //
    //
    if (dwTime == 0)
	dwMaxRate = 0xFFFFFFFFL;
    else
	dwMaxRate = (1000L * 2L * ppcmwf->wf.nSamplesPerSec / dwTime);
    
    if ( (0xFFFFFFFFL / pdi->nConfigPercentCPU) >= dwMaxRate )
	dwMaxRate = dwMaxRate * pdi->nConfigPercentCPU / 100;
    
    if (dwMaxRate > 0xFFFFL)
	dwMaxRate = 0xFFFFL;
    
    DPF(1,"Decode dwMaxRate=%u", dwMaxRate);

    //
    //  Now set the configuration based on these values.  We scan the
    //  gaRateListFormat[] array looking at the dwMonoRate to determine
    //  the appropriate setting.
    //
    nConfig = 0;                                                
    while( gaRateListFormat[nConfig].dwMonoRate < dwMaxRate  &&
           MSGSM610_CONFIG_NUMSETTINGS > nConfig )
    {
        nConfig++;
    }
    *pnDecodeSetting = nConfig - 1;  // We went too far.

        
    //
    // Clean up
    //
    //
errReturn:
    GlobalUnlockFree(padsh, hadsh);
    GlobalUnlockFree(padsi, hadsi);
    
    GlobalUnlockFree(ppcmwf, hpcmwf);
    GlobalUnlockFree(pgsmwf, hgsmwf);
    
    GlobalUnlockFree(pbPCM, hbPCM);
    GlobalUnlockFree(pbGSM, hbGSM);
    
    SetCursor(hCursorSave);
    
    return uIDS;
}


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL acmdDlgProcConfigure
//  
//  Description:
//      This routine handles the configuration dialog box.
//  
//  Arguments:
//      HWND hwnd:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (BOOL):
//
//
//  Note:  In order to avoid using a static fHelpRunning flag which will
//          still be here after we exit, we allocate an fHelpRunning
//          variable in the DRIVERINSTANCE structure.  This is purely to
//          avoid static variables (which force us to have a data segment
//          of 4K); the fHelpRunning is not used in any other procedures.
//  
//--------------------------------------------------------------------------;

INT_PTR FNWCALLBACK acmdDlgProcConfigure
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    PDRIVERINSTANCE     pdi;
    
    HWND                hctrlEnc;
    HWND                hctrlDec;
    UINT                uCmdId;
    UINT                u;
    int                 n;
    TCHAR               szFormat[MSGSM610_CONFIG_TEXTLEN];
    TCHAR               szOutput[MSGSM610_CONFIG_TEXTLEN];

    UINT                nConfigMaxRTEncodeSetting;
    UINT                nConfigMaxRTDecodeSetting;


    switch (uMsg)
    {
        case WM_INITDIALOG:

            pdi = (PDRIVERINSTANCE)lParam;
            pdi->fHelpRunning = FALSE;  // Used only in this procedure.
	    
#ifdef WIN4
            //
            //  This driver is marked Windows Subsystem version 3.5 in order
            //  that it be compatible with Daytona - however, that means that
            //  Chicago will think it is a Win 3.1 application and give it
            //  Win 3.1 default colors.  This makes the config dialog look
            //  white, whereas the Chicago default uses 3DFACE.  This code
            //  (and the CTLCOLOR messages) sets the colors explicitly.
            //
            pdi->hbrDialog = CreateSolidBrush( GetSysColor(COLOR_3DFACE) );
#endif
	    
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            nConfigMaxRTEncodeSetting = pdi->nConfigMaxRTEncodeSetting;
            nConfigMaxRTDecodeSetting = pdi->nConfigMaxRTDecodeSetting;

            hctrlEnc = GetDlgItem(hwnd, IDC_COMBO_MAXRTENCODE);
            hctrlDec = GetDlgItem(hwnd, IDC_COMBO_MAXRTDECODE);

            for( u=0; u<MSGSM610_CONFIG_NUMSETTINGS; u++ )
            {
                LoadString( pdi->hinst, gaRateListFormat[u].idsFormat,
                            szFormat, SIZEOF(szFormat) );

                switch( gaRateListFormat[u].uFormatType )
                {
                    case CONFIG_RLF_NONUMBER:
                        lstrcpy( szOutput, szFormat );
                        break;

                    case CONFIG_RLF_MONOONLY:
                        wsprintf( szOutput, szFormat,
                                    gaRateListFormat[u].dwMonoRate );
                        break;
                }

                ComboBox_AddString(hctrlEnc, szOutput);
                ComboBox_AddString(hctrlDec, szOutput);
            }

            ComboBox_SetCurSel( hctrlEnc, nConfigMaxRTEncodeSetting );
            ComboBox_SetCurSel( hctrlDec, nConfigMaxRTDecodeSetting );

	    return (TRUE);

	case WM_DESTROY:
            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);
	    if (pdi->fHelpRunning)
	    {
		WinHelp(hwnd, gszHelpFilename, HELP_QUIT, 0L);
	    }
#ifdef WIN4
            DeleteObject( pdi->hbrDialog );
#endif

	    //
	    // Let dialog box process this message
	    //
	    //
	    return (FALSE);

#ifdef WIN4
        //
        //  Handle CTLCOLOR messages to get the dialog boxes to the default
        //  Chicago colors.  See the INITDIALOG message, above.
        //
        case WM_CTLCOLORSTATIC:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORBTN:
            SetTextColor( (HDC)wParam, GetSysColor(COLOR_WINDOWTEXT) );
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_3DFACE) );
            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);
            return (UINT_PTR)(pdi->hbrDialog);
#endif

		case WM_HELP:
			WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszHelpFilename,
				HELP_WM_HELP, (ULONG_PTR)aKeyWordIds);
			return TRUE;

        case WM_COMMAND:
            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);

            uCmdId = (UINT) wParam;

            switch (uCmdId)
            {
                case IDC_BTN_AUTOCONFIG:
                    {
                        UINT        uErrorIDS;

                        uErrorIDS   = configAutoConfig( pdi,
                                            &nConfigMaxRTEncodeSetting,
                                            &nConfigMaxRTDecodeSetting );
                        if( 0==uErrorIDS )
                        {
                            //
                            //  No error - set dialog box settings.
                            //
                            hctrlEnc = GetDlgItem( hwnd, IDC_COMBO_MAXRTENCODE );
                            ComboBox_SetCurSel( hctrlEnc, nConfigMaxRTEncodeSetting );
                            hctrlDec = GetDlgItem( hwnd, IDC_COMBO_MAXRTDECODE );
                            ComboBox_SetCurSel( hctrlDec, nConfigMaxRTDecodeSetting );
                        }
                        else
                        {
                            //
                            //  Display error message.
                            //
                            TCHAR       tstrErr[200];
                            TCHAR       tstrErrTitle[200];

                            if (0 == LoadString(pdi->hinst, IDS_ERROR, tstrErrTitle, SIZEOF(tstrErrTitle)))
                                break;
                            if (0 == LoadString(pdi->hinst, uErrorIDS, tstrErr, SIZEOF(tstrErr)))
                                break;
                            MessageBox(hwnd, tstrErr, tstrErrTitle, MB_ICONEXCLAMATION | MB_OK);
                        }
                    }
                    break;


                case IDOK:
                    n = DRVCNF_CANCEL;

                    //
                    //  RT Encode setting
                    //
                    hctrlEnc = GetDlgItem(hwnd, IDC_COMBO_MAXRTENCODE);
                    nConfigMaxRTEncodeSetting = ComboBox_GetCurSel( hctrlEnc );
                    if (nConfigMaxRTEncodeSetting != pdi->nConfigMaxRTEncodeSetting)
                    {
                        pdi->nConfigMaxRTEncodeSetting = nConfigMaxRTEncodeSetting;
                        n = DRVCNF_OK;
                    }

                    //
                    //  RT Decode setting
                    //
                    hctrlDec = GetDlgItem(hwnd, IDC_COMBO_MAXRTDECODE);
                    nConfigMaxRTDecodeSetting = ComboBox_GetCurSel( hctrlDec );
                    if (nConfigMaxRTDecodeSetting != pdi->nConfigMaxRTDecodeSetting)
                    {
                        pdi->nConfigMaxRTDecodeSetting = nConfigMaxRTDecodeSetting;
                        n = DRVCNF_OK;
                    }

                    //
                    //  If we changed something, write the data to the
                    //  registry.
                    //
                    if( DRVCNF_OK == n )
                    {
                        configWriteConfiguration( pdi );
                    }

                    EndDialog(hwnd, DRVCNF_OK);
                    break;


                case IDCANCEL:
                    EndDialog(hwnd, DRVCNF_CANCEL);
                    break;

                case IDC_BTN_HELP:
		    pdi->fHelpRunning = TRUE;
		    WinHelp(hwnd, gszHelpFilename, HELP_CONTEXT, HELPCONTEXT_MSGSM610);
                    break;
            }
            return (TRUE);
    }

    return (FALSE);
} // gsm610DlgProcConfigure()


//--------------------------------------------------------------------------;
//  
//  BOOL acmdDriverConfigInit
//  
//  Description:
//      This routine initializes the configuration parameters by reading them
//      from the registry.  If there are no entries in the registry, this
//      codec auto-configures itself and writes the results to the registry.
//      If the auto-configure fails, or if we don't know our alias name,
//      then we set the configuration to default values.
//  
//  Arguments:
//      PDRIVERINSTANCE pdi:
//  
//      LPCTSTR pszAliasName:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL acmdDriverConfigInit
(
    PDRIVERINSTANCE         pdi,
    LPCTSTR		    pszAliasName
)
{
    HKEY    hkey;
    UINT    nEncodeSetting;
    UINT    nDecodeSetting;
    UINT    uErrorIDS;


    //
    //	If pszAliasName is NULL then just set all defaults
    //
    //
    if (NULL == pszAliasName)
    {
        DPF(2,"acmdDriverConfigInit: no alias name; using default settings.");

        configSetDefaults( pdi );
        return (TRUE);
    }

    
    //
    //  If we haven't got an open hkey, then open it.  Note that this routine
    //  may be called more than once; on the second time, we should not
    //  re-open the key.
    //
    if( NULL == pdi->hkey )
    {
        RegCreateKeyEx( MSGSM610_CONFIG_DEFAULTKEY, gszMultimediaKey, 0,
                        NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkey, NULL );

        if( NULL != hkey )
        {
            ASSERT( NULL != pszAliasName );

            RegCreateKeyEx( hkey, pszAliasName, 0, NULL, 0,
                    KEY_SET_VALUE | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                    NULL, &pdi->hkey, NULL );

            RegCloseKey( hkey );
        }
    }


    //
    //  Read configuration data from registry.
    //
    if( NULL == pdi->hkey )
    {
        configSetDefaults( pdi );
    }
    else
    {
        pdi->nConfigMaxRTEncodeSetting =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszMaxRTEncodeSetting,
                    MSGSM610_CONFIG_UNCONFIGURED );

        pdi->nConfigMaxRTDecodeSetting =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszMaxRTDecodeSetting,
                    MSGSM610_CONFIG_UNCONFIGURED );

        pdi->nConfigPercentCPU =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszPercentCPU,
                    MSGSM610_CONFIG_DEFAULT_PERCENTCPU );
        
        //
        //  Check that nConfigPercentCPU is a valid value.
        //
        if( pdi->nConfigPercentCPU <= 0 )
        {
            pdi->nConfigPercentCPU = MSGSM610_CONFIG_DEFAULT_PERCENTCPU;
        }
    }


	//
    //  If either the encode or decode setting is out of range, then
    //  we call the auto-configure routine and write out the results.
    //  This should only happen the first time the codec is run.
    //
    if( MSGSM610_CONFIG_NUMSETTINGS <= pdi->nConfigMaxRTEncodeSetting ||
        MSGSM610_CONFIG_NUMSETTINGS <= pdi->nConfigMaxRTDecodeSetting )
    {
        DPF( 1, "acmdDriverConfigInit: performing initial auto-config." );
        uErrorIDS = configAutoConfig( pdi,
                                      &nEncodeSetting,
                                      &nDecodeSetting );

        if( 0 != uErrorIDS )
        {
            //
            //  Error in auto-config.  Use defaults instead.
            //
            nEncodeSetting = MSGSM610_CONFIG_DEFAULT_MAXRTENCODESETTING;
            nDecodeSetting = MSGSM610_CONFIG_DEFAULT_MAXRTDECODESETTING;
        }

        pdi->nConfigMaxRTEncodeSetting = nEncodeSetting;
        pdi->nConfigMaxRTDecodeSetting = nDecodeSetting;

        //
        //  Always write the results to the registry, even if we hit an
        //  error, so we won't hit the automatic auto-config next
        //  time we run.  One failure is enough!
        //
        configWriteConfiguration( pdi );
    }

    return (TRUE);
} // acmdDriverConfigInit()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\gsm610\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code to support easy-to-use debugging support.
//      All code compiles to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static CHAR     ach[300];       // debug output (avoid stack overflow)
    int	            id;


    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
        FatalAppExit(0, TEXT("Good Bye"));
		break;

	case IDRETRY:               // Break into the debugger.
#if DBG
		DebugBreak();
#endif
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\gsm610\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "MSGSM610"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\imaadpcm\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code to support easy-to-use debugging support.
//      All code compiles to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static CHAR     ach[300];       // debug output (avoid stack overflow)
    int	            id;


    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
        FatalAppExit(0, TEXT("Good Bye"));
		break;

	case IDRETRY:               // Break into the debugger.
#if DBG
		DebugBreak();
#endif
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\gsm610\gsm610.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  gsm610.h
//
//  Description:
//      This file contains prototypes for the filtering routines, and
//      some parameters used by the algorithm.
//
//
//==========================================================================;

#ifndef _INC_GSM610
#define _INC_GSM610                 // #defined if gsm610.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

//
// The following constants are defined in order to make portions
// of the program more readable.  In general, these constants
// cannot be changed without requiring changes in related program code.
//
#define GSM610_MAX_CHANNELS             1
#define GSM610_BITS_PER_SAMPLE          0
#define GSM610_WFX_EXTRA_BYTES          (2)
 
#define GSM610_SAMPLESPERFRAME          160
#define GSM610_NUMSUBFRAMES             4
#define GSM610_SAMPLESPERSUBFRAME       40
#define GSM610_FRAMESPERMONOBLOCK       2
#define GSM610_BITSPERFRAME             260
#define GSM610_BYTESPERMONOBLOCK        (GSM610_FRAMESPERMONOBLOCK * GSM610_BITSPERFRAME / 8)
#define GSM610_SAMPLESPERMONOBLOCK      (GSM610_FRAMESPERMONOBLOCK * GSM610_SAMPLESPERFRAME)

//
//  these assume mono
//
#define GSM610_BLOCKALIGNMENT(pwf)    (GSM610_BYTESPERMONOBLOCK)
#define GSM610_AVGBYTESPERSEC(pwf)    (((LPGSM610WAVEFORMAT)pwf)->wfx.nSamplesPerSec * GSM610_BYTESPERMONOBLOCK / GSM610_SAMPLESPERMONOBLOCK)
#define GSM610_SAMPLESPERBLOCK(pwf)   (GSM610_SAMPLESPERMONOBLOCK)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

//
//  function prototypes from GSM610.C
//
//
void FNGLOBAL gsm610Reset
(
    PSTREAMINSTANCE         psi
);

LRESULT FNGLOBAL gsm610Decode
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);
                             
LRESULT FNGLOBAL gsm610Encode
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _INC_GSM610
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\gsm610\init.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  init.c
//
//  Description:
//      This file contains module initialization routines.  Note that there
//      is no module initialization for Win32.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "debug.h"


#ifndef WIN32

//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//  Arguments:
//      HINSTANCE hinst: Our module handle.
//
//      WORD wDataSeg: Specifies the DS value for this DLL.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    Created. 
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE               hinst, 
    WORD                    wDataSeg, 
    WORD                    cbHeapSize,
    LPSTR                   pszCmdLine
)
{
    DbgInitialize(TRUE);

    //
    //  if debug level is 5 or greater, then do a DebugBreak() to debug
    //  loading of this driver
    //
    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);
    DPF(5, "!*** break for debugging ***");

    return (TRUE);
} // LibMain()


//--------------------------------------------------------------------------;
//  
//  int WEP
//  
//  Description:
//  
//  
//  Arguments:
//      WORD wUselessParam:
//  
//  Return (int):
//  
//  History:
//      03/28/93    Created.
//  
//--------------------------------------------------------------------------;

EXTERN_C int FNEXPORT WEP
(
    WORD                    wUselessParam
)
{
    DPF(1, "WEP(wUselessParam=%u)", wUselessParam);

    //
    //  always return 1.
    //
    return (1);
} // WEP()

#endif	// !WIN32


#ifdef WIN32

//==========================================================================;
//
//  WIN 32 SPECIFIC SUPPORT
//
//==========================================================================;

#if (defined(WIN4) && defined(DEBUG))

#if FALSE
//--------------------------------------------------------------------------;
//
//  BOOL Gsm610DllMain
//
//  Description:
//      This is the standard DLL entry point for Win 32.
//
//  Arguments:
//      HINSTANCE hinst: Our instance handle.
//
//      DWORD dwReason: The reason we've been called--process/thread attach
//      and detach.
//
//      LPVOID lpReserved: Reserved. Should be NULL--so ignore it.
//
//  Return (BOOL):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT Gsm610DllMain
(
    HINSTANCE               hinst,
    DWORD                   dwReason,
    LPVOID                  lpReserved
)
{

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
	{
	    char strModuleFilename[80];
	    
	    DbgInitialize(TRUE);

	    GetModuleFileNameA(NULL, (LPSTR) strModuleFilename, 80);
            DPF(1, "Gsm610DllMain: DLL_PROCESS_ATTACH: HINSTANCE=%08lx ModuleFilename=%s", hinst, strModuleFilename);
	    return TRUE;
	}

        case DLL_PROCESS_DETACH:
            DPF(1, "Gsm610DllMain: DLL_PROCESS_DETACH");
	    return TRUE;

	case DLL_THREAD_ATTACH:
	    DPF(1, "Gsm610DllMain: DLL_THREAD_ATTACH");
	    return TRUE;

	case DLL_THREAD_DETACH:
	    DPF(1, "Gsm610DllMain: DLL_THREAD_DETACH");
	    return TRUE;
    }

    return TRUE;
} // Gsm610DllMain()
#endif

#endif	// WIN4 && DEBUG

#endif	// WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\imaadpcm\codec.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.c
//
//  Description:
//      This file contains the DriverProc and other routines which respond
//      to ACM messages.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <ctype.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "imaadpcm.h"
#include "debug.h"


const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM,
    WAVE_FORMAT_IMA_ADPCM
};

#define ACM_DRIVER_MAX_FORMAT_TAGS      SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define ACM_DRIVER_MAX_FILTER_TAGS      0


//
//  array of sample rates supported
//
//
const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

#ifdef IMAADPCM_USECONFIG
//
//  Required by config.c as well as codec.c.
//
const UINT ACM_DRIVER_MAX_SAMPLE_RATES = SIZEOF_ARRAY(gauFormatIndexToSampleRate);
const UINT ACM_DRIVER_MAX_CHANNELS =    IMAADPCM_MAX_CHANNELS;
#else
#define ACM_DRIVER_MAX_SAMPLE_RATES     SIZEOF_ARRAY(gauFormatIndexToSampleRate)
#define ACM_DRIVER_MAX_CHANNELS         IMAADPCM_MAX_CHANNELS
#endif


//
//  array of bits per sample supported
//
//
const UINT gauFormatIndexToBitsPerSample[] =
{
    8,
    16
};

#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM    SIZEOF_ARRAY(gauFormatIndexToBitsPerSample)
#define ACM_DRIVER_MAX_BITSPERSAMPLE_ADPCM  1



//
//  number of formats we enumerate per channel is number of sample rates
//  times number of channels times number of types (bits per sample).
//
#define ACM_DRIVER_MAX_FORMATS_PCM      (ACM_DRIVER_MAX_SAMPLE_RATES *  \
                                         ACM_DRIVER_MAX_CHANNELS *      \
                                         ACM_DRIVER_MAX_BITSPERSAMPLE_PCM)

#define ACM_DRIVER_MAX_FORMATS_ADPCM    (ACM_DRIVER_MAX_SAMPLE_RATES *  \
                                         ACM_DRIVER_MAX_CHANNELS *      \
                                         ACM_DRIVER_MAX_BITSPERSAMPLE_ADPCM)



#ifdef IMAADPCM_USECONFIG
//
//  This array describes the configuration settings for this codec.
//
//  Each line in the realtime encode/decode rate listbox must have one of
//  these structures to describe it.  The type of line is defined in
//  nFormatType, which can have one of the following values:
//
//      CONFIG_RLF_NONUMBER     - the string in idsFormat is displayed as is.
//      CONFIG_RLF_MONOONLY     - dwMonoRate is written into idsFormat, then
//                                  displayed as a mono rate.
//      CONFIG_RLF_STEREOONLY   - dwMonoRate is written into idsFormat, then
//                                  displayed as a stereo rate.
//      CONFIG_RLF_MONOSTEREO   - dwMonoRate followed by nRate/2 are written
//                                  into idsFormat, then displayed as a pair
//                                  of mono and stereo rates.
//
//  The index to the gaRateListFormat array corresponds to the value which
//  is stored as configuration information in the registry or .ini file.
//  To find out if a certain conversion can be performed in real time,
//  check that:
//
//    SamplingRate <= gaRateListFormat[ConfigSetting].dwMonoRate / nChannels
//
//  Note:  The gaRateListFormat array must change when
//          gauFormatIndexToSampleRate changes.
//

const RATELISTFORMAT gaRateListFormat[] =
{
    { CONFIG_RLF_NONUMBER,      IDS_CONFIG_NORATES,     0 },
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    8000 },  // gauFormatIndexToSampleRate[0]
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    11025 }, // gauFormatIndexToSampleRate[1]
    { CONFIG_RLF_STEREOONLY,    IDS_CONFIG_STEREOONLY,  16000 }, // 2 * gauFormatIndexToSampleRate[0]
    { CONFIG_RLF_MONOSTEREO,    IDS_CONFIG_MONOSTEREO,  22050 }, // gauFormatIndexToSampleRate[2]
    { CONFIG_RLF_MONOSTEREO,    IDS_CONFIG_MONOSTEREO,  44100 }, // gauFormatIndexToSampleRate[3]
    { CONFIG_RLF_NONUMBER,      IDS_CONFIG_ALLRATES,    88200 }  // 2 * gauFormatIndexToSampleRate[3]
};

const UINT IMAADPCM_CONFIG_NUMSETTINGS = SIZEOF_ARRAY( gaRateListFormat );

#endif // IMAADPCM_USECONFIG


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // WIN32


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  WORD imaadpcmBlockAlign
//
//  Description:
//      This function computes the standard block alignment that should
//      be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid IMA-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels
//          nSamplesPerSec
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header.
//
//  Return (UINT):
//      The return value is the block alignment that should be placed in
//      the pwfx->nBlockAlign field.
//
//--------------------------------------------------------------------------;

WORD FNLOCAL imaadpcmBlockAlign
(
    LPWAVEFORMATEX          pwfx
)
{
    UINT                uBlockAlign;
    UINT                uChannelShift;

    //
    //  The data must be an integral number of DWORDs for mono, an even
    //  number of DWORDs for stereo.
    //
    uChannelShift  = pwfx->nChannels >> 1;
    uBlockAlign    = 256 << uChannelShift;

    //
    //  choose a block alignment that makes sense for the sample rate
    //  that the original PCM data is. basically, this needs to be
    //  some reasonable number to allow efficient streaming, etc.
    //
    //  don't let block alignment get too small...
    //
    if (pwfx->nSamplesPerSec > 11025)
    {
        uBlockAlign *= (UINT)(pwfx->nSamplesPerSec / 11000);
    }

    //
    //  Just make sure that the alignment is valid.
    //
    ASSERT( 0 == uBlockAlign % (sizeof(DWORD)*pwfx->nChannels) );

    return (WORD)(uBlockAlign);
} // imaadpcmBlockAlign()


//--------------------------------------------------------------------------;
//
//  WORD imaadpcmSamplesPerBlock
//
//  Description:
//      This function computes the Samples Per Block that should be used
//      given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid IMA-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels       = must be 1 or 2!
//          nSamplesPerSec
//          nBlockAlign
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header.
//
//  Return (DWORD):
//      The return value is the average bytes per second that should be
//      placed in the pwfx->nAvgBytesPerSec field.
//
//--------------------------------------------------------------------------;

WORD FNLOCAL imaadpcmSamplesPerBlock
(
    LPWAVEFORMATEX          pwfx
)
{
    UINT                uSamplesPerBlock;
    UINT                uChannelShift;
    UINT                uHeaderBytes;
    UINT                uBitsPerSample;

    //
    //
    //
    uChannelShift  = pwfx->nChannels >> 1;
    uHeaderBytes   = 4 << uChannelShift;
    uBitsPerSample = IMAADPCM_BITS_PER_SAMPLE << uChannelShift;

    //
    //  compute the 'samples per block' that will be in the encoded
    //  ADPCM data blocks. this is determined by subtracting out the
    //  'other info' contained in each block--a block is composed of
    //  a header followed by the encoded data.
    //
    //  the block header is composed of the following data:
    //      2 bytes (16 bit) sample per channel
    //      1 byte for step table index per channel
    //      1 byte padding per channel (dword align)
    //
    //  this gives us (4 * uChannels) bytes of header information that
    //  contains our first full sample (so we add one below).
    //
    uSamplesPerBlock  = (pwfx->nBlockAlign - uHeaderBytes) * 8;
    uSamplesPerBlock /= uBitsPerSample;
    uSamplesPerBlock += 1;

    return (WORD)(uSamplesPerBlock);
} // imaadpcmSamplesPerBlock()


//--------------------------------------------------------------------------;
//
//  UINT imaadpcmAvgBytesPerSec
//
//  Description:
//      This function computes the Average Bytes Per Second that should
//      be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid IMA-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels       = must be 1 or 2!
//          nSamplesPerSec
//          nBlockAlign
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header.
//
//  Return (DWORD):
//      The return value is the average bytes per second that should be
//      placed in the pwfx->nAvgBytesPerSec field.
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL imaadpcmAvgBytesPerSec
(
    LPWAVEFORMATEX          pwfx
)
{
    DWORD               dwAvgBytesPerSec;
    UINT                uSamplesPerBlock;

    //
    //
    //
    uSamplesPerBlock = imaadpcmSamplesPerBlock(pwfx);


    //
    //  compute bytes per second including header bytes
    //
    dwAvgBytesPerSec = (pwfx->nSamplesPerSec * pwfx->nBlockAlign) /
                            uSamplesPerBlock;

    return (dwAvgBytesPerSec);
} // imaadpcmAvgBytesPerSec()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if ((16 != pwfx->wBitsPerSample) && (8 != pwfx->wBitsPerSample))
        return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    if (PCM_BLOCKALIGNMENT(pwfx) != pwfx->nBlockAlign)
        return (FALSE);

    //
    //  finally, verify that avg bytes per second is correct
    //
    if (PCM_AVGBYTESPERSEC(pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL imaadpcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid
//      IMA ADPCM header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL imaadpcmIsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
    LPIMAADPCMWAVEFORMAT    pwfadpcm;

    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_IMA_ADPCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  check wBitsPerSample
    //
    if (IMAADPCM_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
        return (FALSE);

    //
    //  check channels
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > IMAADPCM_MAX_CHANNELS))
        return (FALSE);

    //
    //  Check block alignment - must be an integral number of DWORDs for
    //  mono, or an even number of DWORDs for stereo.
    //
    if( 0 != pwfx->nBlockAlign % (sizeof(DWORD)*pwfx->nChannels) )
        return FALSE;

    //
    //  cbSize must be 2 for IMA's ADPCM
    //
    if (IMAADPCM_WFX_EXTRA_BYTES != pwfx->cbSize)
        return (FALSE);

    //
    //  wSamplesPerBlock must be equal to 4n+1, where n is at least 1.
    //
    pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfx;

    if( ( pwfadpcm->wSamplesPerBlock < 5 )  ||
        ( pwfadpcm->wSamplesPerBlock%4 != 1 )  )
        return FALSE;

    //
    //  Verifying nBlockAlign and wSamplesPerBlock are consistent.
    //
    if ( (pwfadpcm->wSamplesPerBlock != imaadpcmSamplesPerBlock(pwfx)) )
        return FALSE;

    return (TRUE);
} // imaadpcmIsValidFormat()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PDRIVERINSTANCE     pdi;

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (NULL != paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        {
            return (0L);
        }
    }


    //
    //  we are being opened as an installable driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure. note that we
    //  rely on allocating the memory as zero-initialized!
    //
    pdi = (PDRIVERINSTANCE)LocalAlloc(LPTR, sizeof(*pdi));
    if (NULL == pdi)
    {
        //
        //  if this open attempt was as an ACM driver, then return the
        //  reason we are failing in the open description structure..
        //
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        //
        //  fail to open
        //
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pdi->hdrvr          = hdrvr;
    pdi->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.

    if (NULL != paod)
    {
        pdi->fnDriverProc = NULL;
        pdi->fccType      = paod->fccType;
        pdi->vdwACM       = paod->dwVersion;
        pdi->fdwOpen      = paod->dwFlags;

        paod->dwError     = MMSYSERR_NOERROR;
    }


#ifdef IMAADPCM_USECONFIG
    //
    // Get config info for this driver.  If we're not passed an
    // an ACMDRVOPENDESC structure then we'll assume we are being
    // opened for configuration and will put off getting the config
    // info until we receive the DRV_CONFIGURE message.  Otherwise we
    // get the config info now using the alias passed through the
    // ACMDRVOPENDESC structure.
    //
    pdi->hkey = NULL;           // This is important!

    if (NULL != paod)
    {
#if defined(WIN32) && !defined(UNICODE)
        //
        //  We must translate the UNICODE alias name to an ANSI version
        //  that we can use.
        //
    	LPSTR	lpstr;
        int     iLen;

        //
        //  Calculate required length without calling UNICODE APIs or CRT.
        //
        iLen  = WideCharToMultiByte( GetACP(), 0, paod->pszAliasName,-1,
                                                    NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)GlobalAllocPtr( GPTR, iLen );
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, paod->pszAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        GlobalFreePtr( lpstr );
	    }
#else
    	acmdDriverConfigInit(pdi, paod->pszAliasName);
#endif // WIN32 && !UNICODE
    }
#else
    //
    //  Actually, fdwConfig is not used - there is no configuration data.
    //
    pdi->fdwConfig    = 0L;
#endif // IMAADPCM_USECONFIG

    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)pdi);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PDRIVERINSTANCE         pdi
)
{
#ifdef IMAADPCM_USECONFIG
    //
    //  Release the registry key, if we allocated one.
    //
    if( NULL != pdi->hkey )
    {
        (void)RegCloseKey( pdi->hkey );
    }
#endif

    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (NULL != pdi)
    {
        //
        //  close down the driver instance. this driver simply needs
        //  to free the instance data structure... note that if this
        //  'free' fails, then this ACM driver probably trashed its
        //  heap; assume we didn't do that.
        //
        LocalFree((HLOCAL)pdi);
    }


    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      the user pressed OK.  This value should be returned even if the
//      user didn't change anything - otherwise, the driver may not
//      install properly.
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
#ifdef IMAADPCM_USECONFIG
    INT_PTR     n;
#endif

    //
    //  first check to see if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
#ifdef IMAADPCM_USECONFIG
        //
        //  this ACM driver supports a configuration dialog box, so
        //  return non-zero...
        //
        return (1L);
#else
        //
        //  this ACM driver does not support a configuration dialog box, so
        //  return zero...
        //
        return (0L);
#endif
    }


    //
    //  we are being asked to bring up our configuration dialog. if this
    //  driver supports a configuration dialog box, then after the dialog
    //  is dismissed we must return one of the following values:
    //
    //  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
    //  and canceled by the user. this value should also be returned if
    //  no configuration information was modified.
    //
    //  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
    //  the user pressed OK.  This value should be returned even if the
    //  user didn't change anything - otherwise, the driver may not
    //  install properly.
    //
    //  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
    //  and some configuration information was changed that requires
    //  Windows to be restarted before the changes take affect. the driver
    //  should remain configured with current values until the driver
    //  has been 'rebooted'.
    //
#ifdef IMAADPCM_USECONFIG
    if (NULL == pdci)
    {
        //
        //  !!!
        //
        DPF(2,"acmdDriverConfigure returning CANCEL due to NULL==pdci.");
        return (DRVCNF_CANCEL);
    }

    pdi->pdci = pdci;

    //
    // We may not have our config info yet if the driver has only been
    // opened specifically for configuration.  So, read our configuration
    // using the alias passed in the DRVCONFIGINFO structure passed
    // through the DRV_CONFIGURE message
    //
#if (defined(WIN32) && !defined(UNICODE))
    {
        //
        //  We must translate the UNICODE alias name to an ANSI version
        //  that we can use.
        //
    	LPSTR	lpstr;
        int     iLen;

        //
        //  Calculate required length without calling UNICODE APIs or CRT.
        //
        iLen  = WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, -1,
                                                    NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)GlobalAllocPtr( GPTR, iLen );
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        GlobalFreePtr( lpstr );
	    }
    }
#else
    acmdDriverConfigInit(pdi, pdci->lpszDCIAliasName);
#endif // WIN32 && !UNICODE

    n = DialogBoxParam(pdi->hinst,
                       IDD_CONFIG,
                       hwnd,
                       acmdDlgProcConfigure,
                       (LPARAM)pdi);

    pdi->pdci = NULL;

    return ((LRESULT)n);
#else
    //
    //  return DRVCNF_CANCEL--this ACM driver does not support configuration
    //
    return (DRVCNF_CANCEL);
#endif // IMAADPCM_USECONFIG

} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMDRIVERDETAILS      padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;


    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    add.wMid            = MM_MICROSOFT;
    add.wPid            = MM_MSFT_ACM_IMAADPCM;


    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;


    //
    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.
    //
    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

    //
    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.
    //
    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;


    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        //  See the MSFILTER sample for a codec which contains a custom icon.
        //
        add.hicon = NULL;

        //
        //  the short name and long name are used to represent the driver
        //  in a unique description. the short name is intended for small
        //  display areas (for example, in a menu or combo box). the long
        //  name is intended for more descriptive displays (for example,
        //  in an 'about box').
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

        //
        //  the last three members are intended for 'about box' information.
        //  these members are optional and may be zero length strings if
        //  the driver wishes.
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }


    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(padd, &add, (UINT)add.cbStruct);


    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd
)
{
    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a custom about box, so
        //  return MMSYSERR_NOTSUPPORTED...
        //
        return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  this driver does not support a custom dialog, so tell the ACM or
    //  calling application to display one for us. note that this is the
    //  _recommended_ method for consistency and simplicity of ACM drivers.
    //  why write code when you don't have to?
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM, a wave mapper or
//      an application to quickly get a destination format that this driver
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible. This message is normally
//      sent in response to an acmFormatSuggest function call.
//
//      Another way to think about this message is: what format would this
//      driver like to convert the source format to?
//
//      The caller may place restrictions on the destination format that
//      should be suggested. The padfs->fdwSuggest member contains the
//      restriction bits passed by the caller--see the description for
//      the return value for more information.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to an ACMDRVFORMATSUGGEST
//      structure that describes the source and destination (possibly with
//      restrictions) for a conversion.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if one or more of
//      the destination restriction bits is not supported. It is strongly
//      recommended that the driver support at least the following suggestion
//      restriction bits:
//
//      ACM_FORMATSUGGESTF_WFORMATTAG: The destination format tag must be
//      the same as the wFormatTag member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NCHANNELS: The destination channel count must be
//      the same as the nChannels member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NSAMPLESPERSEC: The destination samples per
//      second must be the same as the nSamplesPerSec member in the
//      destination format header.
//
//      ACM_FORMATSUGGESTF_WBITSPERSAMPLE: The destination bits per sample
//      must be the same as the wBitsPerSample member in the destination
//      format header.
//
//      If no destintation format can be suggested, then the driver should
//      return ACMERR_NOTPOSSIBLE.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    LPIMAADPCMWAVEFORMAT    pwfadpcm;
    DWORD                   fdwSuggest;


    //
    //  grab the suggestion restriction bits and verify that we support
    //  the ones that are specified... an ACM driver must return the
    //  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
    //  are not supported.
    //
    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  get the source and destination formats in more convenient variables
    //
    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;


    //
    //
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!pcmIsValidFormat(pwfxSrc))
                break;


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is only able to encode to IMA ADPCM
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_IMA_ADPCM != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_IMA_ADPCM;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is only able to encode to 4 bit
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if (IMAADPCM_BITS_PER_SAMPLE != pwfxDst->wBitsPerSample)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize
            //
            //      wSamplesPerBlock    ->  IMA ADPCM extended information
            //
            pwfxDst->nBlockAlign     = imaadpcmBlockAlign(pwfxDst);
            pwfxDst->nAvgBytesPerSec = imaadpcmAvgBytesPerSec(pwfxDst);
            pwfxDst->cbSize          = IMAADPCM_WFX_EXTRA_BYTES;

            pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfxDst;

            pwfadpcm->wSamplesPerBlock = imaadpcmSamplesPerBlock(pwfxDst);

            return (MMSYSERR_NOERROR);


        case WAVE_FORMAT_IMA_ADPCM:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!imaadpcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is only able to decode to PCM
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_PCM != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is only able to decode to 16 or 8 bit
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if ((16 != pwfxDst->wBitsPerSample) &&
                    (8  != pwfxDst->wBitsPerSample))
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = 16;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize              !!! not used for PCM !!!
            //
            pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfxDst);
            pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec *
                                       pwfxDst->nBlockAlign;

            // pwfxDst->cbSize       = not used;

            return (MMSYSERR_NOERROR);
    }


    //
    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this ACM driver
    //  cannot deal with.
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdFormatSuggest()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format.  return error.
            //
            if (ACM_DRIVER_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_IMA_ADPCM:
                    uFormatTag = WAVE_FORMAT_IMA_ADPCM;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_IMA_ADPCM:
                    uFormatTag = WAVE_FORMAT_IMA_ADPCM;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0]   =  '\0';
            break;

        case WAVE_FORMAT_IMA_ADPCM:
            padft->dwFormatTagIndex = 1;
            padft->dwFormatTag      = WAVE_FORMAT_IMA_ADPCM;
            padft->cbFormatSize     = sizeof(WAVEFORMATEX) +
                                      IMAADPCM_WFX_EXTRA_BYTES;
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_ADPCM;

            LoadStringCodec(pdi->hinst,
			 IDS_ACM_DRIVER_TAG_NAME,
			 padft->szFormatTag,
			 SIZEOFACMSTR(padft->szFormatTag));
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX          pwfx;
    LPIMAADPCMWAVEFORMAT    pwfadpcm;
    UINT                    uFormatIndex;
    UINT                    u;


    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  put some stuff in more accessible variables--note that we
            //  bring variable sizes down to a reasonable size for 16 bit
            //  code...
            //
            pwfx = padf->pwfx;
            uFormatIndex = (UINT)padf->dwFormatIndex;

            switch (padf->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (ACM_DRIVER_MAX_FORMATS_PCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    //
                    //  now fill in the format structure
                    //
                    pwfx->wFormatTag      = WAVE_FORMAT_PCM;

                    u = uFormatIndex / (ACM_DRIVER_MAX_BITSPERSAMPLE_PCM * ACM_DRIVER_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;

                    u = (uFormatIndex / ACM_DRIVER_MAX_CHANNELS) % ACM_DRIVER_MAX_CHANNELS;
                    pwfx->wBitsPerSample  = (WORD)gauFormatIndexToBitsPerSample[u];

                    pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfx);
                    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

                    //
                    //  note that the cbSize field is NOT valid for PCM
                    //  formats
                    //
                    //  pwfx->cbSize      = 0;
                    break;


                case WAVE_FORMAT_IMA_ADPCM:
                    if (ACM_DRIVER_MAX_FORMATS_ADPCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    pwfx->wFormatTag      = WAVE_FORMAT_IMA_ADPCM;

                    u = uFormatIndex / (ACM_DRIVER_MAX_BITSPERSAMPLE_ADPCM * ACM_DRIVER_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;
                    pwfx->wBitsPerSample  = IMAADPCM_BITS_PER_SAMPLE;

                    pwfx->nBlockAlign     = imaadpcmBlockAlign(pwfx);
                    pwfx->nAvgBytesPerSec = imaadpcmAvgBytesPerSec(pwfx);
                    pwfx->cbSize          = IMAADPCM_WFX_EXTRA_BYTES;

                    pwfadpcm     = (LPIMAADPCMWAVEFORMAT)pwfx;

                    pwfadpcm->wSamplesPerBlock = imaadpcmSamplesPerBlock(pwfx);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            pwfx = padf->pwfx;

            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (!pcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                case WAVE_FORMAT_IMA_ADPCM:
                    if (!imaadpcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.
    //
    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    BOOL                fRealTime;
    STREAMCONVERTPROC   fnConvert;
    PSTREAMINSTANCE     psi;
#ifdef IMAADPCM_USECONFIG
    DWORD               nConfigMaxRTEncodeSamplesPerSec;
    DWORD               nConfigMaxRTDecodeSamplesPerSec;
    DWORD               dw;
#endif


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

#ifdef IMAADPCM_USECONFIG
    nConfigMaxRTEncodeSamplesPerSec =
                gaRateListFormat[pdi->nConfigMaxRTEncodeSetting].dwMonoRate;
    DPF(2,"nConfigMaxRTEncodeSamplesPerSec=%u",nConfigMaxRTEncodeSamplesPerSec);

    nConfigMaxRTDecodeSamplesPerSec =
                gaRateListFormat[pdi->nConfigMaxRTDecodeSetting].dwMonoRate;
    DPF(2,"nConfigMaxRTDecodeSamplesPerSec=%u",nConfigMaxRTDecodeSamplesPerSec);
#endif

    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));


    //
    //  the most important condition to check before doing anything else
    //  is that this ACM driver can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this driver.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a driver that is suitable for the conversion. also note that
    //  the ACM may call this driver several times with slightly different
    //  format specifications before giving up.
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            if (!pcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!imaadpcmIsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

#ifdef IMAADPCM_USECONFIG
            //
            //  if a driver cannot perform real-time encoding then
            //  the driver should fail when opened for a real-time
            //  conversion. note that the driver MUST return
            //  MMSYSERR_NOTSUPPORTED in this case!
            //
            //  this driver may or may not be able to perform real-time
            //  encoding, depending on the system on which it is running.
            //  this driver allows the user to select whether to support
            //  real-time encoding thru the config dialog.
            //
            //  if this open is for a real-time conversion, fail if
            //  real-time encoding hasn't been enabled in the config
            //  dialog.  Note that nConfigMaxRTDecodeSamplesPerSec is
            //  the value for a mono conversion - if it's a stereo
            //  conversion, we can only convert half as high...
            //
            if (fRealTime)
            {
                dw = nConfigMaxRTEncodeSamplesPerSec / pwfxSrc->nChannels;
                if (dw < pwfxSrc->nSamplesPerSec)
                {
                    return (MMSYSERR_NOTSUPPORTED);
                }
            }
#endif

            //
            //  Determine the correct conversion routine.
            //
            switch (pwfxSrc->nChannels)
            {
                case 1:
                    if (8 == pwfxSrc->wBitsPerSample)
                        fnConvert = imaadpcmEncode4Bit_M08;
                    else
                        fnConvert = imaadpcmEncode4Bit_M16;
                    break;

                case 2:
                    if (8 == pwfxSrc->wBitsPerSample)
                        fnConvert = imaadpcmEncode4Bit_S08;
                    else
                        fnConvert = imaadpcmEncode4Bit_S16;
                    break;

                default:
                    return ACMERR_NOTPOSSIBLE;
            }
            break;

        case WAVE_FORMAT_IMA_ADPCM:
            if (!imaadpcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!pcmIsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

#ifdef IMAADPCM_USECONFIG
            //
            //  if a driver cannot perform real-time encoding then
            //  the driver should fail when opened for a real-time
            //  conversion. note that the driver MUST return
            //  MMSYSERR_NOTSUPPORTED in this case!
            //
            //  this driver may or may not be able to perform real-time
            //  encoding, depending on the system on which it is running.
            //  this driver allows the user to select whether to support
            //  real-time encoding thru the config dialog.
            //
            //  if this open is for a real-time conversion, fail if
            //  real-time decoding hasn't been enabled in the config
            //  dialog.  Note that nConfigMaxRTDecodeSamplesPerSec is
            //  the value for a mono conversion - if it's a stereo
            //  conversion, we can only convert half as high...
            //
            if (fRealTime)
            {
                dw = nConfigMaxRTDecodeSamplesPerSec / pwfxSrc->nChannels;
                if( dw < pwfxSrc->nSamplesPerSec )
                {
                    return (MMSYSERR_NOTSUPPORTED);
                }
            }
#endif

            //
            //  Determine the correct conversion routine.
            //
            switch (pwfxSrc->nChannels)
            {
                case 1:
                    if (8 == pwfxDst->wBitsPerSample)
                        fnConvert = imaadpcmDecode4Bit_M08;
                    else
                        fnConvert = imaadpcmDecode4Bit_M16;
                    break;

                case 2:
                    if (8 == pwfxDst->wBitsPerSample)
                        fnConvert = imaadpcmDecode4Bit_S08;
                    else
                        fnConvert = imaadpcmDecode4Bit_S16;
                    break;

                default:
                    return ACMERR_NOTPOSSIBLE;
            }
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  for this driver, we must also verify that the nChannels and
    //  nSamplesPerSec members are the same between the source and
    //  destination formats.
    //
    if (pwfxSrc->nChannels != pwfxDst->nChannels)
        return (MMSYSERR_NOTSUPPORTED);

    if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (0 != (ACM_STREAMOPENF_QUERY & padsi->fdwOpen))
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this driver allocates a small instance structure for each stream
    //
    //
    psi = (PSTREAMINSTANCE)LocalAlloc(LPTR, sizeof(*psi));
    if (NULL == psi)
    {
        return (MMSYSERR_NOMEM);
    }


    //
    //  fill out our instance structure
    //
    //  this driver stores a pointer to the conversion function that will
    //  be used for each conversion on this stream. we also store a
    //  copy of the _current_ configuration of the driver instance we
    //  are opened on. this must not change during the life of the stream
    //  instance.
    //
    //  this is also very important! if the user is able to configure how
    //  the driver performs conversions, the changes should only affect
    //  future open streams. all current open streams should behave as
    //  they were configured during the open.
    //
    psi->fnConvert      = fnConvert;
    psi->fdwConfig      = pdi->fdwConfig;
    psi->nStepIndexL    = 0;
    psi->nStepIndexR    = 0;


    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0L;
    padsi->dwDriver  = (DWORD_PTR)psi;

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose). The ACM driver should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      NOTE! It is _strongly_ recommended that a driver not fail to close
//      a conversion stream.
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCE     psi;

    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (PSTREAMINSTANCE)padsi->dwDriver;
    if (NULL != psi)
    {
        //
        //  free the stream instance structure
        //
        LocalFree((HLOCAL)psi);
    }

    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    PSTREAMINSTANCE         psi;
    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    LPIMAADPCMWAVEFORMAT    pwfadpcm;
    DWORD                   cb;
    DWORD                   cBlocks;
    DWORD                   cbBytesPerBlock;


    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    //
    //
    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            cb = padss->cbSrcLength;

            if (WAVE_FORMAT_IMA_ADPCM == pwfxSrc->wFormatTag)
            {
                //
                //  how many destination PCM bytes are needed to hold
                //  the decoded ADPCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                cBlocks = cb / pwfxSrc->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfxSrc;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxDst->nBlockAlign;

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                if (0 == (cb % pwfxSrc->nBlockAlign))
                {
                    cb = cBlocks * cbBytesPerBlock;
                }
                else
                {
                    cb = (cBlocks + 1) * cbBytesPerBlock;
                }
            }
            else
            {
                //
                //  how many destination ADPCM bytes are needed to hold
                //  the encoded PCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfxDst;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxSrc->nBlockAlign;

                cBlocks = cb / cbBytesPerBlock;

                if (0 == (cb % cbBytesPerBlock))
                {
                    cb = cBlocks * pwfxDst->nBlockAlign;
                }
                else
                {
                    cb = (cBlocks + 1) * pwfxDst->nBlockAlign;
                }

                if (0L == cb)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
            }

            padss->cbDstLength = cb;
            return (MMSYSERR_NOERROR);


        case ACM_STREAMSIZEF_DESTINATION:
            cb = padss->cbDstLength;

            if (WAVE_FORMAT_IMA_ADPCM == pwfxDst->wFormatTag)
            {
                //
                //  how many source PCM bytes can be encoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                cBlocks = cb / pwfxDst->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfxDst;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxSrc->nBlockAlign;

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * cbBytesPerBlock;
            }
            else
            {
                //
                //  how many source ADPCM bytes can be decoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfxSrc;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxDst->nBlockAlign;

                cBlocks = cb / cbBytesPerBlock;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * pwfxSrc->nBlockAlign;
            }

            padss->cbSrcLength = cb;
            return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()



//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamConvert
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamConvert
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    BOOL                    fBlockAlign;
    BOOL                    fStart;
    LPWAVEFORMATEX          pwfpcm;
    LPIMAADPCMWAVEFORMAT    pwfadpcm;
    DWORD                   dw;
    DWORD                   cbConvert;
    PSTREAMINSTANCE         psi;

    //
    //  Determine the conversion flags.
    //
    fBlockAlign = (0 != (ACM_STREAMCONVERTF_BLOCKALIGN & padsh->fdwConvert));
    fStart      = (0 != (ACM_STREAMCONVERTF_START      & padsh->fdwConvert));

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    DPF(4,"acmdStreamConvert: fBlockAlign=%d, fStart=%d, cbSrcLength=%ld",fBlockAlign,fStart,padsh->cbSrcLength);


    if (WAVE_FORMAT_PCM == padsi->pwfxSrc->wFormatTag) {

        //
        //  Encode.
        //

        pwfpcm   = padsi->pwfxSrc;
        pwfadpcm = (LPIMAADPCMWAVEFORMAT)padsi->pwfxDst;

        //
        // Determine the number of samples to convert.  We ALWAYS convert
        // block-aligned.
        //
        dw = PCM_BYTESTOSAMPLES(pwfpcm, padsh->cbSrcLength);
        dw = (dw / pwfadpcm->wSamplesPerBlock) * pwfadpcm->wSamplesPerBlock;
        cbConvert = PCM_SAMPLESTOBYTES(pwfpcm, dw);

        //
        //  Reset step index if we have a start condition.
        //
        if( fStart ) {
            psi->nStepIndexL = 0;
            psi->nStepIndexR = 0;   // Not necessary for mono, but...
        }

    } else {

        //
        //  Decode.
        //

        pwfadpcm = (LPIMAADPCMWAVEFORMAT)padsi->pwfxSrc;
        pwfpcm   = padsi->pwfxDst;

        //
        // Determine the number of bytes to convert.  We ALWAYS convert
        // block-aligned.
        //
        cbConvert = (padsh->cbSrcLength/pwfadpcm->wfx.nBlockAlign) *
                                        pwfadpcm->wfx.nBlockAlign;
    }


    //
    //  Set the number of Src bytes used.  If fBlockAlign is not set, then
    //  we throw away any bytes which aren't used, by marking them as used
    //  even though we don't actually convert them.
    //
    padsh->cbSrcLengthUsed = ( fBlockAlign ?
                                cbConvert :
                                padsh->cbSrcLength );


    //
    //  Call the conversion routine.
    //
    padsh->cbDstLengthUsed = psi->fnConvert(
                (HPBYTE)padsh->pbSrc,
                cbConvert,
                (HPBYTE)padsh->pbDst,
                (UINT)pwfadpcm->wfx.nBlockAlign,   // Used for decode only.
                (UINT)pwfadpcm->wSamplesPerBlock,  // Used for encode only.
                &psi->nStepIndexL,                 // Used for encode only.
                &psi->nStepIndexR                  // For stereo encode only.
    );

    return (MMSYSERR_NOERROR);
} // acmdStreamConvert()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR               dwpId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PDRIVERINSTANCE     pdi;

    //
    //  make pdi either NULL or a valid instance pointer. note that dwpId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwpId is for other
    //  messages (instance data).
    //
    pdi = (PDRIVERINSTANCE)dwpId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef WIN32
            DbgInitialize(TRUE);
#endif
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
            return (1L);

        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
            lr = acmdDriverClose(pdi);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            lr = acmdDriverConfigure(pdi, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            lr = acmdDriverDetails(pdi, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            lr = acmdDriverAbout(pdi, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
       case ACMDM_FORMAT_SUGGEST:
            lr = acmdFormatSuggest(pdi, (LPACMDRVFORMATSUGGEST)lParam1);
            return (lr);


        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
            lr = acmdFormatTagDetails(pdi, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            lr = acmdFormatDetails(pdi, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            lr = acmdStreamOpen(pdi, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            lr = acmdStreamClose((LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
            lr = acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
            lr = acmdStreamConvert(pdi, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMHEADER)lParam2);
            return (lr);
    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwpId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\imaadpcm\codec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.h
//
//  Description:
//      This file contains codec definitions, Win16/Win32 compatibility
//      definitions, and instance structure definitions.
//
//
//==========================================================================;

#ifndef _INC_CODEC
#define _INC_CODEC                  // #defined if codec.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_ACM_DRIVER is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(4,  0, 0)
#else
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(3, 51, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(2, 3, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL __loadds
        #define FNEXPORT    FAR PASCAL __export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL __export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)
    typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD_PTR, HDRVR, UINT, LPARAM, LPARAM);

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Compilation options:
//
//      If IMAADPCM_USECONFIG is defined, then the codec will be compiled
//      with a configuration dialog.  If not, then the codec will not be
//      configurable.  It is expected that the configuration is only
//      necessary for certain platforms...
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IMAADPCM_USECONFIG


#ifdef IMAADPCM_USECONFIG

//
//  See codec.c for a description of this structure and its use.
//
typedef struct tRATELISTFORMAT
{
    UINT        uFormatType;
    UINT        idsFormat;
    DWORD       dwMonoRate;
} RATELISTFORMAT;
typedef RATELISTFORMAT *PRATELISTFORMAT;

#define CONFIG_RLF_NONUMBER     1
#define CONFIG_RLF_MONOONLY     2
#define CONFIG_RLF_STEREOONLY   3
#define CONFIG_RLF_MONOSTEREO   4

#endif // IMAADPCM_USECONFIG



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))

//
//
//
typedef BOOL FAR*   LPBOOL;


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwfx argument is a pointer to a WAVEFORMATEX structure.
//
#define PCM_BLOCKALIGNMENT(pwfx)        (UINT)(((pwfx)->wBitsPerSample >> 3) << ((pwfx)->nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwfx)        (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwfx, cb)    (DWORD)(cb / PCM_BLOCKALIGNMENT(pwfx))
#define PCM_SAMPLESTOBYTES(pwfx, dw)    (DWORD)(dw * PCM_BLOCKALIGNMENT(pwfx))



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tDRIVERINSTANCE
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the driver will be easier to combine
    //  with other types of drivers (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of driver: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your driver requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           fdwOpen;        // flags from open description

    DWORD           fdwConfig;      // stream instance configuration flags

#ifdef IMAADPCM_USECONFIG
    LPDRVCONFIGINFO pdci;
    HKEY            hkey;
    UINT            nConfigMaxRTEncodeSetting;
    UINT            nConfigMaxRTDecodeSetting;
    UINT    	    nConfigPercentCPU;
    BOOL            fHelpRunning;           // Used by config DlgProc only.
#ifdef WIN4
    HBRUSH          hbrDialog;              // Used by config DlgProc only.
#endif
#endif

} DRIVERINSTANCE, *PDRIVERINSTANCE, FAR *LPDRIVERINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;


//
//  This define deals with unaligned data for Win32, and huge data for Win16.
//  Basically, any time you cast an HPBYTE to a non-byte variable (ie long or
//  short), you should cast it to ( {short,long} HUGE_T *).  This will cast
//  it to _huge for Win16, and make sure that there are no alignment problems
//  for Win32 on MIPS and Alpha machines.
//

typedef BYTE HUGE *HPBYTE;

#ifdef WIN32
    #define HUGE_T  UNALIGNED
#else
    #define HUGE_T  _huge
#endif


//
//
//
//
typedef DWORD (FNGLOBAL *STREAMCONVERTPROC)
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);


//
//
//
//
typedef struct tSTREAMINSTANCE
{
    STREAMCONVERTPROC   fnConvert;  // stream instance conversion proc
    DWORD               fdwConfig;  // stream instance configuration flags

    int                 nStepIndexL; // Used to ensure that the step index
    int                 nStepIndexR; //  is maintained across converts.  For
                                     //  mono signals, the index is stored in
                                     //  nStepIndexL.

} STREAMINSTANCE, *PSTREAMINSTANCE, FAR *LPSTREAMINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  resource id's
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDS_ACM_DRIVER_SHORTNAME    (1)     // ACMDRIVERDETAILS.szShortName
#define IDS_ACM_DRIVER_LONGNAME     (2)     // ACMDRIVERDETAILS.szLongName
#define IDS_ACM_DRIVER_COPYRIGHT    (3)     // ACMDRIVERDETAILS.szCopyright
#define IDS_ACM_DRIVER_LICENSING    (4)     // ACMDRIVERDETAILS.szLicensing
#define IDS_ACM_DRIVER_FEATURES     (5)     // ACMDRIVERDETAILS.szFeatures

#define IDS_ACM_DRIVER_TAG_NAME     (20)    // ACMFORMATTAGDETAILS.szFormatTag

#ifdef IMAADPCM_USECONFIG
//
//  resource id's for the configuration dialog box
//

#define IDS_CONFIG_NORATES          (30)
#define IDS_CONFIG_ALLRATES         (31)
#define IDS_CONFIG_MONOONLY         (32)
#define IDS_CONFIG_STEREOONLY       (33)
#define IDS_CONFIG_MONOSTEREO       (34)
#define IDS_ERROR                   (35)
#define IDS_ERROR_NOMEM             (36)

#define IDD_CONFIG                      RCID(100)
#define IDC_BTN_AUTOCONFIG              1001
#define IDC_BTN_HELP                    1002
#define IDC_COMBO_MAXRTENCODE           1003
#define IDC_COMBO_MAXRTDECODE           1004
#define IDC_STATIC_COMPRESS				1005
#define IDC_STATIC_DECOMPRESS			1006
#define IDC_STATIC                      -1

#endif


//
//  global variables, etc...
//
#ifdef IMAADPCM_USECONFIG

extern const UINT   gauFormatIndexToSampleRate[];
extern const UINT   ACM_DRIVER_MAX_SAMPLE_RATES;
extern const UINT   ACM_DRIVER_MAX_CHANNELS;
extern const RATELISTFORMAT gaRateListFormat[];
extern const UINT   IMAADPCM_CONFIG_NUMSETTINGS;

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  function prototypes
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef IMAADPCM_USECONFIG

BOOL FNGLOBAL acmdDriverConfigInit
(
    PDRIVERINSTANCE	    pdi,
    LPCTSTR		    pszAliasName
);

INT_PTR FNWCALLBACK acmdDlgProcConfigure
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
);

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
);

LRESULT FNLOCAL acmdStreamConvert
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_CODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\imaadpcm\config.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  config.c
//
//  Description:
//	    IMA ADPCM codec configuration init and dialog
//
//
//	The configuration parameters for this codec are:
//
//	    MaxRTEncodeSetting:
//	    MaxRTDecodeSetting:
//		These determine the highest mono sample rate that
//		the codec will attempt to convert in real-time.
//
//	    PercentCPU:
//		This configuration parameter is not normally changed
//		by the user and is not presented in the config dialog.
//		This value affects the config dialog's 'Auto-Config'
//		calculation of MaxRTXxcodeSetting.
//
//  These parameters may be set in the registry, using the imaadpcm subkey
//  (which corresponds to the alias name used for installation) under
//  the following key:
//
//      HKEY_CURRENT_USER\Software\Microsoft\Multimedia
//
// 
//  Note:  The configuration dialog is only compiled into the code if the
//      IMAADPCM_USECONFIG symbol is defined.  This is designed to make it
//      easy to remove the dialog box completely for certain platforms,
//      such as MIPS and Alpha under Windows NT.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "muldiv32.h"

#include "codec.h"
#include "imaadpcm.h"
#include "debug.h"

#ifdef WIN32
#include <tchar.h>
#else
#define _tcstoul strtoul
#define _tcsncpy _fstrncpy
#endif

#include <string.h>
#include <stdlib.h>


#ifndef WIN32
#error Win16 support has been dropped from this codec!  Compile for Win32.
#endif


#ifdef IMAADPCM_USECONFIG


//
//  Strings required to access configuration information in the registry.
//
const TCHAR BCODE gszMaxRTEncodeSetting[]   = TEXT("MaxRTEncodeSetting");
const TCHAR BCODE gszMaxRTDecodeSetting[]   = TEXT("MaxRTDecodeSetting");
const TCHAR BCODE gszPercentCPU[]           = TEXT("PercentCPU");
const TCHAR gszMultimediaKey[] = TEXT("Software\\Microsoft\\Multimedia\\");


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//  Be careful changing the following!
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//  Data required to access the dialog box help.
//
//  Note that you must write your own help file for your codec, even if
//  the configuration dialog box looks identical.  If you use the file
//  listed here, then the title will say "IMA ADPCM" or something.
//
//  Note:  the number HELPCONTEXT_IMAADPCM must be unique in the file
//          gszHelpFilename, and the number must defined in the [MAP]
//          section of the .hpj help project file.  Then the .rtf file
//          will reference that number (using the keyword defined in
//          the .hpj file).  Then when we call WinHelp with the number,
//          WinHelp will go to the right help entry.
//
const TCHAR BCODE gszHelpFilename[]         = TEXT("audiocdc.hlp");
#define HELPCONTEXT_IMAADPCM          1001
#define IDH_AUDIOCDC_COMPRESSION	  100
#define IDH_AUDIOCDC_DECOMPRESSION    200
#define IDH_AUDIOCDC_AUTOCONFIGURE	  300
static int aKeyWordIds[] = {
				   IDC_COMBO_MAXRTENCODE, IDH_AUDIOCDC_COMPRESSION,
				   IDC_STATIC_COMPRESS, IDH_AUDIOCDC_COMPRESSION,
				   IDC_COMBO_MAXRTDECODE, IDH_AUDIOCDC_DECOMPRESSION,
				   IDC_STATIC_DECOMPRESS, IDH_AUDIOCDC_DECOMPRESSION,
				   IDC_BTN_AUTOCONFIG, IDH_AUDIOCDC_AUTOCONFIGURE,
				   0, 0
			       };




//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  VOID configWriteConfiguration
//  
//  Description:
//
//      This routine writes the configuration data in PDI to the registry.
//      This consists of the max real-time Encode and Decode settings.
//  
//  Arguments:
//      PDRIVERINSTANCE     pdi
//  
//  Return (VOID):  None.
//  
//--------------------------------------------------------------------------;

VOID configWriteConfiguration
(
    PDRIVERINSTANCE     pdi
)
{
    DWORD               dw;


    if( NULL != pdi->hkey )
    {
        dw   = (DWORD)pdi->nConfigMaxRTEncodeSetting;
        (void)RegSetValueEx( pdi->hkey, (LPTSTR)gszMaxRTEncodeSetting, 0,
                                REG_DWORD, (LPBYTE)&dw, sizeof(DWORD) );

        dw   = (DWORD)pdi->nConfigMaxRTDecodeSetting;
        (void)RegSetValueEx( pdi->hkey, (LPTSTR)gszMaxRTDecodeSetting, 0,
                                REG_DWORD, (LPBYTE)&dw, sizeof(DWORD) );
    }
}


//--------------------------------------------------------------------------;
//  
//  DWORD dwReadRegistryDefault
//  
//  Description:
//
//      This routine reads a given value from the registry, and returns a
//      default value if the read is not successful.
//  
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPTSTR  lpszEntry:
//      DWORD   dwDefault:
//  
//  Return (DWORD):
//  
//--------------------------------------------------------------------------;

INLINE DWORD dwReadRegistryDefault
(
    HKEY                hkey,
    LPTSTR              lpszEntry,
    DWORD               dwDefault
)
{
    DWORD   dwType = (DWORD)~REG_DWORD;  // Init to anything but REG_DWORD.
    DWORD   cbSize = sizeof(DWORD);
    DWORD   dwRet;
    LONG    lError;

    ASSERT( NULL != hkey );
    ASSERT( NULL != lpszEntry );


    lError = RegQueryValueEx( hkey,
                              lpszEntry,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwRet,
                              &cbSize );

    if( ERROR_SUCCESS != lError  ||  REG_DWORD != dwType )
        dwRet = dwDefault;

    return dwRet;
}


//--------------------------------------------------------------------------;
//  
//  VOID configSetDefaults
//  
//  Description:
//
//      This routine sets the configuration parameters to their default
//      values.
//  
//  Arguments:
//      PDRIVERINSTANCE pdi:
//  
//--------------------------------------------------------------------------;

VOID configSetDefaults
(
    PDRIVERINSTANCE     pdi
)
{
    pdi->nConfigMaxRTEncodeSetting =
            IMAADPCM_CONFIG_DEFAULT_MAXRTENCODESETTING;

    pdi->nConfigMaxRTDecodeSetting =
            IMAADPCM_CONFIG_DEFAULT_MAXRTDECODESETTING;

    pdi->nConfigPercentCPU =
            IMAADPCM_CONFIG_DEFAULT_PERCENTCPU;
}


//--------------------------------------------------------------------------;
//  
//  UINT configAutoConfig
//  
//  Description:
//
//	We will determine how much time it takes to encode and then decode
//	2 seconds of data and use this to guess at the max sample
//	rate we can convert in real-time.
//
//	The max is computed with essentially 100% of the CPU.  Practically,
//	we won't have 100% of the CPU available.  So we take a percentage
//	of the computed max and use that as the max in the config dialog.
//
//	The percentage that we use can be set in the ini file imaadpcm
//	section by PercentCPU=xx.
//
//  
//  Arguments:
//      HWND hwnd:
//  
//  Return (UINT):  String identifier (IDS) of error message, or zero if
//      the call succeeded.
//  
//--------------------------------------------------------------------------;

UINT FNLOCAL configAutoConfig
(
    PDRIVERINSTANCE             pdi,
    UINT                        *pnEncodeSetting,
    UINT                        *pnDecodeSetting
)
{
    LPPCMWAVEFORMAT             pwfPCM = NULL;
    LPIMAADPCMWAVEFORMAT        pwfADPCM = NULL;
    LPACMDRVFORMATSUGGEST       padfs = NULL;
    LPACMDRVSTREAMINSTANCE      padsi = NULL;
    LPACMDRVSTREAMHEADER        padsh = NULL;
    LPACMDRVSTREAMSIZE          padss = NULL;
    PSTREAMINSTANCE             psi = NULL;

    LPBYTE                      pBufPCM;
    LPBYTE                      pBufADPCM;
    DWORD                       cbPCM;
    DWORD                       cbADPCM;

    DWORD                       dwEncodeTime;
    DWORD                       dwDecodeTime;
    DWORD                       dwStartTime;
    DWORD                       dwMaxEncodeRate;
    DWORD                       dwMaxDecodeRate;

    UINT                        nConfig;

    UINT                        uIDS;
    HCURSOR                     hCursorSave;


    //
    //  We divide by this!
    //
    ASSERT( 0 != pdi->nConfigPercentCPU );


    uIDS = 0;       // No errors yet - this is our "success" return.
    

    //
    // This function may take a while.  Set hour glass cursor
    //
    hCursorSave     = SetCursor(LoadCursor(NULL, IDC_WAIT));


    //
    //  Set up the input PCM wave format structure.
    //
    pwfPCM  = (LPPCMWAVEFORMAT)GlobalAllocPtr( GPTR, sizeof(*pwfPCM) );
    if( NULL == pwfPCM )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }

    pwfPCM->wf.wFormatTag       = WAVE_FORMAT_PCM;      // Mono 16-bit!!!
    pwfPCM->wf.nChannels        = 1;
    pwfPCM->wf.nSamplesPerSec   = 8000;
    pwfPCM->wf.nBlockAlign      = 2;
    pwfPCM->wBitsPerSample      = 16;
    pwfPCM->wf.nAvgBytesPerSec  = pwfPCM->wf.nSamplesPerSec *
                                    pwfPCM->wf.nBlockAlign;


    //
    //  Get this driver to suggest a format to convert to.  Note:  we may
    //  want to constrain the suggestion partly, depending on the
    //  capabilities of the codec.  We should always choose the most
    //  complex conversion if there are several possibilities.
    //
    padfs       = (LPACMDRVFORMATSUGGEST)GlobalAllocPtr( GPTR, sizeof(*padfs) );
    pwfADPCM    = (LPIMAADPCMWAVEFORMAT)GlobalAllocPtr( GPTR, sizeof(*pwfADPCM) );
    if( NULL == padfs  ||  NULL == pwfADPCM )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }

    padfs->cbStruct             = sizeof(*padfs);
    padfs->fdwSuggest           = 0;                // Default everything.
    padfs->pwfxSrc              = (LPWAVEFORMATEX)pwfPCM;
    padfs->cbwfxSrc             = sizeof(*pwfPCM);
    padfs->pwfxDst              = (LPWAVEFORMATEX)pwfADPCM;
    padfs->cbwfxDst             = sizeof(*pwfADPCM);

    (void)acmdFormatSuggest( pdi, padfs );  // This will always work, right?


    //
    //  Set stream instance data.  Note: we assume that the members that
    //  we don't set here never actually get used.  Make sure that this
    //  is really true!
    //
    padsi       = (LPACMDRVSTREAMINSTANCE)GlobalAllocPtr( GPTR, sizeof(*padsi) );
    psi         = (PSTREAMINSTANCE)LocalAlloc( LPTR, sizeof(*psi) );
    if( NULL == padsi  ||  NULL == psi )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }

    // Make sure that psi->fnConvert matches the PCM format in pwfPCM!!!
    psi->fnConvert              = imaadpcmEncode4Bit_M16;
    psi->fdwConfig              = pdi->fdwConfig;
    psi->nStepIndexL            = 0;
    psi->nStepIndexR            = 0;

    //  Make sure that no other members of padsi are used!!!
    padsi->cbStruct             = sizeof(*padsi);
    padsi->pwfxSrc              = (LPWAVEFORMATEX)pwfPCM;
    padsi->pwfxDst              = (LPWAVEFORMATEX)pwfADPCM;
    padsi->dwDriver             = (DWORD_PTR)psi;


    //
    //  Now, get the driver to tell us how much space is required for the
    //  destination buffer.
    //
    cbPCM       = IMAADPCM_CONFIGTESTTIME * pwfPCM->wf.nAvgBytesPerSec;

    padss       = (LPACMDRVSTREAMSIZE)GlobalAllocPtr( GPTR, sizeof(*padss) );
    if( NULL == padss )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }

    padss->cbStruct             = sizeof(padss);
    padss->fdwSize              = ACM_STREAMSIZEF_SOURCE;
    padss->cbSrcLength          = cbPCM;

    (void)acmdStreamSize( padsi, padss );   // This will always work, right?


    //
    //  Allocate source and destination buffers.  Note that we specifically
    //  don't zero-initialize them, so that we will get random PCM data in
    //  the PCM buffer.                           
    //
    cbADPCM     = padss->cbDstLength;
    pBufPCM     = (LPBYTE)GlobalAllocPtr( GMEM_FIXED, (UINT)cbPCM );
    pBufADPCM   = (LPBYTE)GlobalAllocPtr( GMEM_FIXED, (UINT)cbADPCM );
    if( NULL == pBufPCM  || NULL == pBufADPCM )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }


    //
    //  Now, tell the driver to convert our buffer and measure the time.
    //  Note that we don't care what is in the source buffer, we only
    //  care how long it takes.
    //
    padsh       = (LPACMDRVSTREAMHEADER)GlobalAllocPtr( GPTR, sizeof(*padsh) );
    if( NULL == padsh )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }

    //  Make sure that no other members of padsh are used!!!
    padsh->cbStruct             = sizeof(*padsh);
    padsh->pbSrc                = pBufPCM;
    padsh->cbSrcLength          = cbPCM;
    padsh->pbDst                = pBufADPCM;
    padsh->cbDstLength          = cbADPCM;
    padsh->fdwConvert           = 0;        // Should be 0 already, but...

    dwStartTime     = timeGetTime();
    (void)acmdStreamConvert( pdi, padsi, padsh );   // Won't fail?!
    dwEncodeTime    = timeGetTime() - dwStartTime;


    //
    //  Now, we have an encoded IMA ADPCM buffer.  Tell the driver to
    //  convert it back to PCM, measuring the time.  First we reset the
    //  size of the ADPCM buffer to correspond with the buffer returned
    //  by the convert.  Then we zero out our structure buffers and reset
    //  them for the new conversion.  Note: we assume that the PCM buffer
    //  is already large enough to handle the conversion.
    //
    cbADPCM                     = padsh->cbDstLengthUsed;

#ifdef WIN32
    ZeroMemory( psi, sizeof(*psi) );
    ZeroMemory( padsi, sizeof(*padsi) );
    ZeroMemory( padsh, sizeof(*padsh) );
#else
    _fmemset( psi, 0, sizeof(*psi) );
    _fmemset( padsi, 0, sizeof(*padsi) );
    _fmemset( padsh, 0, sizeof(*padsh) );
#endif

    // Make sure that psi->fnConvert matches the format in pfwADPCM!!!
    psi->fnConvert              = imaadpcmDecode4Bit_M16;
    psi->fdwConfig              = pdi->fdwConfig;
    psi->nStepIndexL            = 0;
    psi->nStepIndexR            = 0;

    //  Make sure that no other members of padsi are used!!!
    padsi->cbStruct             = sizeof(*padsi);
    padsi->pwfxSrc              = (LPWAVEFORMATEX)pwfADPCM;
    padsi->pwfxDst              = (LPWAVEFORMATEX)pwfPCM;
    padsi->dwDriver             = (DWORD_PTR)psi;

    //  Make sure that no other members of padsh are used!!!
    padsh->cbStruct             = sizeof(*padsh);
    padsh->pbSrc                = pBufADPCM;
    padsh->cbSrcLength          = cbADPCM;
    padsh->pbDst                = pBufPCM;
    padsh->cbDstLength          = cbPCM;
    padsh->fdwConvert           = 0;        // Should be 0 already, but...

    dwStartTime     = timeGetTime();
    (void)acmdStreamConvert( pdi, padsi, padsh );   // Won't fail?!
    dwDecodeTime    = timeGetTime() - dwStartTime;


    //
    //  Now, figure out the max encode and decode rates implied by the
    //  times required by the conversions.
    //
    if( dwEncodeTime == 0 )
        dwMaxEncodeRate = 0xFFFFFFFFL;
    else
        dwMaxEncodeRate = MulDiv32( pwfPCM->wf.nSamplesPerSec,
                                    1000L * IMAADPCM_CONFIGTESTTIME,
                                    dwEncodeTime )  *
                                pdi->nConfigPercentCPU / 100;

    if( dwDecodeTime == 0 )
        dwMaxDecodeRate = 0xFFFFFFFFL;
    else
        dwMaxDecodeRate = MulDiv32( pwfPCM->wf.nSamplesPerSec,
                                    1000L * IMAADPCM_CONFIGTESTTIME,
                                    dwDecodeTime )  *
                                pdi->nConfigPercentCPU / 100;

    DPF(1,"dwEncodeTime=%d, dwMaxEncodeRate=%d", dwEncodeTime,dwMaxEncodeRate);
    DPF(1,"dwDecodeTime=%d, dwMaxDecodeRate=%d", dwDecodeTime,dwMaxDecodeRate);


    //
    //  Now set the configuration based on these values.  We scan the
    //  gaRateListFormat[] array looking at the dwMonoRate to determine
    //  the appropriate setting.
    //
    //  Encode.
    //
    nConfig = 0;                                                
    while( gaRateListFormat[nConfig].dwMonoRate < dwMaxEncodeRate  &&
           IMAADPCM_CONFIG_NUMSETTINGS > nConfig )
    {
        nConfig++;
    }
    *pnEncodeSetting = nConfig - 1;  // We went too far.

    //
    //  Decode.
    //
    nConfig = 0;                                                
    while( gaRateListFormat[nConfig].dwMonoRate < dwMaxDecodeRate  &&
           IMAADPCM_CONFIG_NUMSETTINGS > nConfig )
    {
        nConfig++;
    }
    *pnDecodeSetting = nConfig - 1;  // We went too far.


    //
    //  Free structure allocations and exit.
    //
    //
errReturn:

    if( NULL != pwfPCM )
        GlobalFreePtr( pwfPCM );

    if( NULL != pwfADPCM )
        GlobalFreePtr( pwfADPCM );
    
    if( NULL != padfs )
        GlobalFreePtr( padfs );
    
    if( NULL != padsi )
        GlobalFreePtr( padsi );
    
    if( NULL != padsh )
        GlobalFreePtr( padsh );
    
    if( NULL != padss )
        GlobalFreePtr( padss );
    
    if( NULL != psi )
        LocalFree( (HLOCAL)psi );

    SetCursor( hCursorSave );

    return uIDS;
}


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  INT_PTR acmdDlgProcConfigure
//  
//  Description:
//      This routine handles the configuration dialog box.
//  
//  Arguments:
//      HWND hwnd:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (BOOL):
//
//
//  Note:  In order to avoid using a static fHelpRunning flag which will
//          still be here after we exit, we allocate an fHelpRunning
//          variable in the DRIVERINSTANCE structure.  This is purely to
//          avoid static variables (which force us to have a data segment
//          of 4K); the fHelpRunning is not used in any other procedures.
//  
//--------------------------------------------------------------------------;

INT_PTR FNWCALLBACK acmdDlgProcConfigure
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    PDRIVERINSTANCE     pdi;
    
    HWND                hctrlEnc;
    HWND                hctrlDec;
    UINT                uCmdId;
    UINT                u;
    int                 n;
    TCHAR               szFormat[IMAADPCM_CONFIG_TEXTLEN];
    TCHAR               szOutput[IMAADPCM_CONFIG_TEXTLEN];

    UINT                nConfigMaxRTEncodeSetting;
    UINT                nConfigMaxRTDecodeSetting;


    switch (uMsg)
    {
        case WM_INITDIALOG:

            pdi = (PDRIVERINSTANCE)(UINT_PTR)lParam;
            pdi->fHelpRunning = FALSE;  // Used only in this procedure.

#ifdef WIN4
            //
            //  This driver is marked Windows Subsystem version 3.5 in order
            //  that it be compatible with Daytona - however, that means that
            //  Chicago will think it is a Win 3.1 application and give it
            //  Win 3.1 default colors.  This makes the config dialog look
            //  white, whereas the Chicago default uses 3DFACE.  This code
            //  (and the CTLCOLOR messages) sets the colors explicitly.
            //
            pdi->hbrDialog = CreateSolidBrush( GetSysColor(COLOR_3DFACE) );
#endif
	    
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            nConfigMaxRTEncodeSetting = pdi->nConfigMaxRTEncodeSetting;
            nConfigMaxRTDecodeSetting = pdi->nConfigMaxRTDecodeSetting;

            hctrlEnc = GetDlgItem(hwnd, IDC_COMBO_MAXRTENCODE);
            hctrlDec = GetDlgItem(hwnd, IDC_COMBO_MAXRTDECODE);

            for( u=0; u<IMAADPCM_CONFIG_NUMSETTINGS; u++ )
            {
                LoadString( pdi->hinst, gaRateListFormat[u].idsFormat,
                            szFormat, SIZEOF(szFormat) );

                switch( gaRateListFormat[u].uFormatType )
                {
                    case CONFIG_RLF_NONUMBER:
                        lstrcpy( szOutput, szFormat );
                        break;

                    case CONFIG_RLF_MONOONLY:
                        wsprintf( szOutput, szFormat,
                                    gaRateListFormat[u].dwMonoRate );
                        break;

                    case CONFIG_RLF_STEREOONLY:
                        wsprintf( szOutput, szFormat,
                                    gaRateListFormat[u].dwMonoRate / 2 );
                        break;

                    case CONFIG_RLF_MONOSTEREO:
                        wsprintf( szOutput, szFormat,
                                    gaRateListFormat[u].dwMonoRate,
                                    gaRateListFormat[u].dwMonoRate / 2 );
                        break;
                }

                ComboBox_AddString(hctrlEnc, szOutput);
                ComboBox_AddString(hctrlDec, szOutput);
            }

            ComboBox_SetCurSel( hctrlEnc, nConfigMaxRTEncodeSetting );
            ComboBox_SetCurSel( hctrlDec, nConfigMaxRTDecodeSetting );

            return (TRUE);

	case WM_DESTROY:

            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);
	    if (pdi->fHelpRunning)
	    {
		WinHelp(hwnd, gszHelpFilename, HELP_QUIT, 0L);
	    }
#ifdef WIN4
            DeleteObject( pdi->hbrDialog );
#endif

	    //
	    // Let dialog box process this message
	    //
	    //
	    return (FALSE);

#ifdef WIN4
        //
        //  Handle CTLCOLOR messages to get the dialog boxes to the default
        //  Chicago colors.  See the INITDIALOG message, above.
        //
        case WM_CTLCOLORSTATIC:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORBTN:
            SetTextColor( (HDC)wParam, GetSysColor(COLOR_WINDOWTEXT) );
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_3DFACE) );
            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);
            return (UINT_PTR)pdi->hbrDialog;
#endif

		case WM_HELP:
			WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszHelpFilename,
				HELP_WM_HELP, (ULONG_PTR)aKeyWordIds);
			return (TRUE);

        case WM_COMMAND:

            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);

            uCmdId = (UINT) wParam;

            switch (uCmdId)
            {
                case IDC_BTN_AUTOCONFIG:
                    {
                        UINT        uErrorIDS;

                        uErrorIDS   = configAutoConfig( pdi,
                                            &nConfigMaxRTEncodeSetting,
                                            &nConfigMaxRTDecodeSetting );
                        if( 0==uErrorIDS )
                        {
                            //
                            //  No error - set dialog box settings.
                            //
                            hctrlEnc = GetDlgItem( hwnd, IDC_COMBO_MAXRTENCODE );
                            ComboBox_SetCurSel( hctrlEnc, nConfigMaxRTEncodeSetting );
                            hctrlDec = GetDlgItem( hwnd, IDC_COMBO_MAXRTDECODE );
                            ComboBox_SetCurSel( hctrlDec, nConfigMaxRTDecodeSetting );
                        }
                        else
                        {
                            //
                            //  Display error message.
                            //
                            TCHAR       tstrErr[200];
                            TCHAR       tstrErrTitle[200];

                            if (0 == LoadString(pdi->hinst, IDS_ERROR, tstrErrTitle, SIZEOF(tstrErrTitle)))
                                break;
                            if (0 == LoadString(pdi->hinst, uErrorIDS, tstrErr, SIZEOF(tstrErr)))
                                break;
                            MessageBox(hwnd, tstrErr, tstrErrTitle, MB_ICONEXCLAMATION | MB_OK);
                        }
                    }
                    break;


                case IDOK:
                    n = DRVCNF_CANCEL;

                    //
                    //  RT Encode setting
                    //
                    hctrlEnc = GetDlgItem(hwnd, IDC_COMBO_MAXRTENCODE);
                    nConfigMaxRTEncodeSetting = ComboBox_GetCurSel( hctrlEnc );
                    if (nConfigMaxRTEncodeSetting != pdi->nConfigMaxRTEncodeSetting)
                    {
                        pdi->nConfigMaxRTEncodeSetting = nConfigMaxRTEncodeSetting;
                        n = DRVCNF_OK;
                    }

                    //
                    //  RT Decode setting
                    //
                    hctrlDec = GetDlgItem(hwnd, IDC_COMBO_MAXRTDECODE);
                    nConfigMaxRTDecodeSetting = ComboBox_GetCurSel( hctrlDec );
                    if (nConfigMaxRTDecodeSetting != pdi->nConfigMaxRTDecodeSetting)
                    {
                        pdi->nConfigMaxRTDecodeSetting = nConfigMaxRTDecodeSetting;
                        n = DRVCNF_OK;
                    }

                    //
                    //  If we changed something, write the data to the
                    //  registry.
                    //
                    if( DRVCNF_OK == n )
                    {
                        configWriteConfiguration( pdi );
                    }

                    EndDialog(hwnd, DRVCNF_OK);
                    break;


                case IDCANCEL:
                    EndDialog(hwnd, DRVCNF_CANCEL);
                    break;

                case IDC_BTN_HELP:
		    pdi->fHelpRunning = TRUE;
		    WinHelp(hwnd, gszHelpFilename, HELP_CONTEXT, HELPCONTEXT_IMAADPCM);
                    break;
            }
            return (TRUE);
    }

    return (FALSE);
} // acmdDlgProcConfigure()


//--------------------------------------------------------------------------;
//  
//  BOOL acmdDriverConfigInit
//  
//  Description:
//      This routine initializes the configuration parameters by reading them
//      from the registry.  If there are no entries in the registry, this
//      codec auto-configures itself and writes the results to the registry.
//      If the auto-configure fails, or if we don't know our alias name,
//      then we set the configuration to default values.
//  
//  Arguments:
//      PDRIVERINSTANCE pdi:
//  
//      LPCTSTR pszAliasName:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL acmdDriverConfigInit
(
    PDRIVERINSTANCE         pdi,
    LPCTSTR		    pszAliasName
)
{
    HKEY    hkey;
    UINT    nEncodeSetting;
    UINT    nDecodeSetting;
    UINT    uErrorIDS;


    //
    //	If pszAliasName is NULL then just set all defaults
    //
    //
    if (NULL == pszAliasName)
    {
        DPF(2,"acmdDriverConfigInit: no alias name; using default settings.");

        configSetDefaults( pdi );
        return (TRUE);
    }

    
    //
    //  If we haven't got an open hkey, then open it.  Note that this routine
    //  may be called more than once; on the second time, we should not
    //  re-open the key.
    //
    if( NULL == pdi->hkey )
    {
        RegCreateKeyEx( IMAADPCM_CONFIG_DEFAULTKEY, gszMultimediaKey, 0,
                        NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkey, NULL );

        if( NULL != hkey )
        {
            ASSERT( NULL != pszAliasName );

            RegCreateKeyEx( hkey, pszAliasName, 0, NULL, 0,
                    KEY_SET_VALUE | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                    NULL, &pdi->hkey, NULL );

            RegCloseKey( hkey );
        }
    }


    //
    //  Read configuration data from registry.
    //
    if( NULL == pdi->hkey )
    {
        configSetDefaults( pdi );
    }
    else
    {
        pdi->nConfigMaxRTEncodeSetting =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszMaxRTEncodeSetting,
                    IMAADPCM_CONFIG_UNCONFIGURED );

        pdi->nConfigMaxRTDecodeSetting =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszMaxRTDecodeSetting,
                    IMAADPCM_CONFIG_UNCONFIGURED );

        pdi->nConfigPercentCPU =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszPercentCPU,
                    IMAADPCM_CONFIG_DEFAULT_PERCENTCPU );
        
        //
        //  Check that nConfigPercentCPU is a valid value.
        //
        if( pdi->nConfigPercentCPU <= 0 )
        {
            pdi->nConfigPercentCPU = IMAADPCM_CONFIG_DEFAULT_PERCENTCPU;
        }
    }


	//
    //  If either the encode or decode setting is out of range, then
    //  we call the auto-configure routine and write out the results.
    //  This should only happen the first time the codec is run.
    //
    if( IMAADPCM_CONFIG_NUMSETTINGS <= pdi->nConfigMaxRTEncodeSetting ||
        IMAADPCM_CONFIG_NUMSETTINGS <= pdi->nConfigMaxRTDecodeSetting )
    {
        DPF( 1, "acmdDriverConfigInit: performing initial auto-config." );
        uErrorIDS = configAutoConfig( pdi,
                                      &nEncodeSetting,
                                      &nDecodeSetting );

        if( 0 != uErrorIDS )
        {
            //
            //  Error in auto-config.  Use defaults instead.
            //
            nEncodeSetting = IMAADPCM_CONFIG_DEFAULT_MAXRTENCODESETTING;
            nDecodeSetting = IMAADPCM_CONFIG_DEFAULT_MAXRTDECODESETTING;
        }

        pdi->nConfigMaxRTEncodeSetting = nEncodeSetting;
        pdi->nConfigMaxRTDecodeSetting = nDecodeSetting;

        //
        //  Always write the results to the registry, even if we hit an
        //  error, so we won't hit the automatic auto-config next
        //  time we run.  One failure is enough!
        //
        configWriteConfiguration( pdi );
    }

    return (TRUE);
} // acmdDriverConfigInit()

#endif // IMAADPCM_USECONFIG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\gsm610\gsm610.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  gsm610.c
//
//  Description:
//	This file contains encode and decode routines for the
//	GSM 06.10 standard.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "gsm610.h"

#include "debug.h"

typedef BYTE HUGE *HPBYTE;

#ifdef WIN32
    typedef WORD UNALIGNED *HPWORD;
#else
    typedef WORD HUGE *HPWORD;
#endif


//**************************************************************************
/*

This source module has the following structure.

Section 1:

    Highest level functions.  These functions are called from outside
    this module.
    
Section 2:

    Encoding support functions.	 These functions support
    the encoding process.
    
Section 3:

    Decoding support functions.	 These functions support
    the decoding process.
    
Section 4:

    Math functions used by any of the above functions.

    
Most of the encode and decode support routines are direct implementations of
the pseudocode algorithms described in the GSM 6.10 specification.  Some
changes were made where necessary or where optimization was obvious or
necessary.

Most variables are named as in the GSM 6.10 spec, departing from the common
hungarian notation.  This facilitates referencing the specification when
studying this implementation.

Some of the functions are conditionally compiled per the definition of
the WIN32 and _X86_ symbol.  These functions have analogous alternate
implementations in 80386 assembler (in GSM61016.ASM and GSM61032.ASM) for
the purposes of execution speed.  The 'C' implementations of these functions
are left intact for portability and can also be referenced when studying the
assembler implementations.  Symbols accessed in/from GSM610xx.ASM are
declared with the EXTERN_C linkage macro.

*/
//**************************************************************************


//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//
// Typedefs
//
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

#ifndef LPSHORT
typedef SHORT FAR *LPSHORT;
#endif

//
//  XM is an RPE sequence containing 13 samples.  There is one
//  RPE sequence per sub-frame.	 This is typedefed in order to
//  facilitate passing the array thru function calls.
//
typedef SHORT XM[13];


//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//
// Macros
//
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

#define BITSHIFTLEFT(x,c)  ( ((c)>=0) ? ((x)<<(c)) : ((x)>>(-(c))) )
#define BITSHIFTRIGHT(x,c) ( ((c)>=0) ? ((x)>>(c)) : ((x)<<(-(c))) )


//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//
// function protos
//
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

//
//
// Math function protos
//

__inline SHORT add(SHORT var1, SHORT var2);
__inline SHORT sub(SHORT var1, SHORT var2);
__inline SHORT mult(SHORT var1, SHORT var2);
__inline SHORT mult_r(SHORT var1, SHORT var2);
__inline SHORT gabs(SHORT var1);
__inline SHORT gdiv(SHORT var1, SHORT var2);
__inline LONG  l_mult(SHORT var1, SHORT var2);
__inline LONG  l_add(LONG l_var1, LONG l_var2);
__inline LONG  l_sub(LONG l_var1, LONG l_var2);
__inline SHORT norm(LONG l_var1);
__inline LONG  IsNeg(LONG x);

//
// helper functions
//
__inline SHORT Convert8To16BitPCM(BYTE);
__inline BYTE  Convert16To8BitPCM(SHORT);

//
//
// encode functions
//

void encodePreproc
(   PSTREAMINSTANCE psi,
    LPSHORT sop,
    LPSHORT s	    );

void encodeLPCAnalysis
(   PSTREAMINSTANCE psi,
    LPSHORT s,
    LPSHORT LARc    );

void encodeLPCFilter
(   PSTREAMINSTANCE psi,
    LPSHORT LARc,
    LPSHORT s,
    LPSHORT d	    );

EXTERN_C void encodeLTPAnalysis
(   PSTREAMINSTANCE psi,
    LPSHORT d,
    LPSHORT pNc,
    LPSHORT pbc	    );

void encodeLTPFilter
(   PSTREAMINSTANCE psi,
    SHORT bc,
    SHORT Nc,
    LPSHORT d,
    LPSHORT e,
    LPSHORT dpp	    );

void encodeRPE
(   PSTREAMINSTANCE psi,
    LPSHORT e,
    LPSHORT pMc,
    LPSHORT pxmaxc,
    LPSHORT xMc,
    LPSHORT ep	    );

void encodeUpdate
(   PSTREAMINSTANCE psi,
    LPSHORT ep,
    LPSHORT dpp	    );

void PackFrame0
(   BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]   );

void PackFrame1
(   BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]   );

//
//
// decode functions
//

void decodeRPE
(   PSTREAMINSTANCE psi,
    SHORT   Mcr,
    SHORT   xmaxcr,
    LPSHORT xMcr,
    LPSHORT erp	    );

EXTERN_C void decodeLTP
(   PSTREAMINSTANCE psi,
    SHORT   bcr,
    SHORT   Ncr,
    LPSHORT erp	    );

void decodeLPC
(   PSTREAMINSTANCE psi,
    LPSHORT LARcr,
    LPSHORT wt,
    LPSHORT sr	    );

EXTERN_C void decodePostproc
(   PSTREAMINSTANCE psi,
    LPSHORT sr,
    LPSHORT srop    );

void UnpackFrame0
(   BYTE    FAR ab[],
    SHORT   FAR LAR[],
    SHORT   FAR N[],
    SHORT   FAR b[],
    SHORT   FAR M[],
    SHORT   FAR Xmax[],
    XM      FAR X[] );

void UnpackFrame1
(   BYTE    FAR ab[],
    SHORT   FAR LAR[],
    SHORT   FAR N[],
    SHORT   FAR b[],
    SHORT   FAR M[],
    SHORT   FAR Xmax[],
    XM      FAR X[] );


//---------------------------------------------------------------------
//---------------------------------------------------------------------
//
// Functions
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------


//---------------------------------------------------------------------
//
// gsm610Reset(PSTREAMINSTANCE psi)
//
// Description:
//	Resets the gsm610-specific stream instance data for
//	the encode/decode routines
//
// Arguments:
//	PSTREAMINSTANCE psi
//	    Pointer to stream instance structure
//
// Return value:
//	void
//	    No return value
//
//---------------------------------------------------------------------

void FNGLOBAL gsm610Reset(PSTREAMINSTANCE psi)
{
    
    // For our gsm610 codec, almost all our instance data resets to 0
    
    UINT i;

    for (i=0; i<SIZEOF_ARRAY(psi->dp); i++) psi->dp[i] = 0;
    for (i=0; i<SIZEOF_ARRAY(psi->drp); i++) psi->drp[i] = 0;
    psi->z1 = 0;
    psi->l_z2 = 0;
    psi->mp = 0;
    for (i=0; i<SIZEOF_ARRAY(psi->OldLARpp); i++) psi->OldLARpp[i] = 0;
    for (i=0; i<SIZEOF_ARRAY(psi->u); i++) psi->u[i] = 0;
    psi->nrp = 40;	// The only non-zero init
    for (i=0; i<SIZEOF_ARRAY(psi->OldLARrpp); i++) psi->OldLARrpp[i] = 0;
    psi->msr = 0;
    for (i=0; i<SIZEOF_ARRAY(psi->v); i++) psi->v[i] = 0;
	    
    return;
}   
    

//--------------------------------------------------------------------------;
//  
//  LRESULT gsm610Encode
//  
//  Description:
//	This function handles the ACMDM_STREAM_CONVERT message. This is the
//	whole purpose of writing an ACM driver--to convert data. This message
//	is sent after a stream has been opened (the driver receives and
//	succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//	LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//	conversion stream. This structure was allocated by the ACM and
//	filled with the most common instance data needed for conversions.
//	The information in this structure is exactly the same as it was
//	during the ACMDM_STREAM_OPEN message--so it is not necessary
//	to re-verify the information referenced by this structure.
//  
//	LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//	that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//	The return value is zero (MMSYSERR_NOERROR) if this function
//	succeeds with no errors. The return value is a non-zero error code
//	if the function fails.
//  
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL gsm610Encode
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
#if (GSM610_FRAMESPERMONOBLOCK != 2)
    #error THIS WAS WRITTEN FOR 2 FRAMES PER BLOCK!!!
#endif
#if (GSM610_MAXCHANNELS > 1)
    #error THIS WAS WRITTEN FOR MONO ONLY!!!
#endif

    PSTREAMINSTANCE	psi;
    DWORD		cbSrcLen;
    BOOL		fBlockAlign;
    DWORD		cb;
    DWORD		dwcSamples;	// dw count of samples
    DWORD		cBlocks;
    UINT		i;
    HPBYTE		hpbSrc, hpbDst;
    
    SHORT   sop[GSM610_SAMPLESPERFRAME];
    SHORT   s[GSM610_SAMPLESPERFRAME];
    SHORT   d[GSM610_SAMPLESPERFRAME];
    SHORT   e[GSM610_SAMPLESPERSUBFRAME];
    SHORT   dpp[GSM610_SAMPLESPERSUBFRAME];
    SHORT   ep[GSM610_SAMPLESPERSUBFRAME];
    
    // The GSM610 stream data:
    SHORT   LARc[9];			    // LARc[1..8] (one array per frame)
    SHORT   Nc[GSM610_NUMSUBFRAMES];	    // Nc (one per sub-frame)
    SHORT   bc[GSM610_NUMSUBFRAMES];	    // bc (one per sub-frame)
    SHORT   Mc[GSM610_NUMSUBFRAMES];	    // Mc (one per sub-frame)
    SHORT   xmaxc[GSM610_NUMSUBFRAMES];	    // Xmaxc (one per sub-frame)
    XM	    xMc[GSM610_NUMSUBFRAMES];	    // xMc (one sequence per sub-frame)
    
    // Temp buffer to hold a block (two frames) of packed stream data
    BYTE  abBlock[ GSM610_BYTESPERMONOBLOCK ];
    
    UINT    nFrame;
    UINT    cSamples;
    
#ifdef DEBUG
//  ProfSetup(1000,0);
//  ProfStart();
#endif

    psi		= (PSTREAMINSTANCE)padsi->dwDriver;

    //
    // If this is flagged as the first block of a conversion
    // then reset the stream instance data.
    //
    if (0 != (ACM_STREAMCONVERTF_START & padsh->fdwConvert))
    {
	gsm610Reset(psi);
    }
    
    fBlockAlign = (0 != (ACM_STREAMCONVERTF_BLOCKALIGN & padsh->fdwConvert));


    //
    //	-= encode PCM to GSM 6.10 =-
    //
    //
    //
    dwcSamples = PCM_BYTESTOSAMPLES(((LPPCMWAVEFORMAT)(padsi->pwfxSrc)), padsh->cbSrcLength);
    cBlocks = dwcSamples / GSM610_SAMPLESPERMONOBLOCK;
    if (!fBlockAlign)
    {
	//
	// Add on another block to hold the fragment of
	// data at the end of our source data.
	//
	if (0 != dwcSamples % GSM610_SAMPLESPERMONOBLOCK)
	    cBlocks++;
    }

    //
    //
    //
    cb = cBlocks * GSM610_BLOCKALIGNMENT(padsi->pwfxDst);
    if (cb > padsh->cbDstLength)
    {
	return (ACMERR_NOTPOSSIBLE);
    }
    padsh->cbDstLengthUsed = cb;

    if (fBlockAlign)
    {
	dwcSamples = cBlocks * GSM610_SAMPLESPERMONOBLOCK;
	cb = PCM_SAMPLESTOBYTES(((LPPCMWAVEFORMAT)(padsi->pwfxSrc)), dwcSamples);
    }
    else
    {
	cb = padsh->cbSrcLength;
    }
    padsh->cbSrcLengthUsed = cb;



    //
    //
    //
    cbSrcLen = padsh->cbSrcLengthUsed;

    // Setup huge pointers to our src and dst buffers
    hpbSrc = (HPBYTE)padsh->pbSrc;
    hpbDst = (HPBYTE)padsh->pbDst;
    
    // Loop thru entire source buffer
    while (cbSrcLen)
    {
    
	// Process source buffer as two full GSM610 frames
	
	for (nFrame=0; nFrame < 2; nFrame++)
	{
	    //
	    // the src contains 8- or 16-bit PCM.  currently we only
	    // handle mono conversions.
	    //

	    //
	    // we will fill sop[] with one frame of 16-bit PCM samples
	    //
	    
	    //
	    // copy min( cSrcSamplesLeft, GSM610_SAMPLESPERFRAME ) samples
	    // to array sop[].
	    //
	    dwcSamples = PCM_BYTESTOSAMPLES(((LPPCMWAVEFORMAT)(padsi->pwfxSrc)), cbSrcLen);
	    cSamples = (int) min(dwcSamples, (DWORD) GSM610_SAMPLESPERFRAME);

	    if (padsi->pwfxSrc->wBitsPerSample == 16)
	    {
		// copy 16-bit samples from hpbSrc to sop
		for (i=0; i < cSamples; i++)
		{
		    sop[i] = *( ((HPWORD)hpbSrc)++ );
		}
	    }
	    else
	    {
		// copy 8-bit samples from hpbSrc to 16-bit samples in sop
		for (i=0; i < cSamples; i++)
		{
		    sop[i] = Convert8To16BitPCM(*hpbSrc++);
		}
	    }

	    cbSrcLen -= PCM_SAMPLESTOBYTES(((LPPCMWAVEFORMAT)(padsi->pwfxSrc)), cSamples);

	    // fill out sop[] with silence if necessary.
	    for ( ; i < GSM610_SAMPLESPERFRAME; i++)
	    {
		sop[i] = 0;
	    }
	
	    //
	    // Encode a frame of data
	    //
	
	    encodePreproc(psi, sop, s);
	    encodeLPCAnalysis(psi, s, LARc);
	    encodeLPCFilter(psi, LARc, s, d);

	    // For each of four sub-frames
	    for (i=0; i<4; i++)
	    {	    
		encodeLTPAnalysis(psi, &d[i*40], &Nc[i], &bc[i]);
		encodeLTPFilter(psi, bc[i], Nc[i], &d[i*40], e, dpp);
		encodeRPE(psi, e, &Mc[i], &xmaxc[i], xMc[i], ep);
		encodeUpdate(psi, ep, dpp);
	    }
	
	    //
	    // Pack the data and store in dst buffer
	    //
	    if (nFrame == 0)
		PackFrame0(abBlock, LARc, Nc, bc, Mc, xmaxc, xMc);
	    else
	    {
		PackFrame1(abBlock, LARc, Nc, bc, Mc, xmaxc, xMc);
		for (i=0; i<GSM610_BYTESPERMONOBLOCK; i++)
		    *(hpbDst++) = abBlock[i];
	    }
	}   // for (nFrame...
    }
    

#ifdef DEBUG
//  ProfStop();
#endif
    
    return (MMSYSERR_NOERROR);
}


//--------------------------------------------------------------------------;
//  
//  LRESULT gsm610Decode
//  
//  Description:
//	This function handles the ACMDM_STREAM_CONVERT message. This is the
//	whole purpose of writing an ACM driver--to convert data. This message
//	is sent after a stream has been opened (the driver receives and
//	succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//	LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//	conversion stream. This structure was allocated by the ACM and
//	filled with the most common instance data needed for conversions.
//	The information in this structure is exactly the same as it was
//	during the ACMDM_STREAM_OPEN message--so it is not necessary
//	to re-verify the information referenced by this structure.
//  
//	LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//	that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//	The return value is zero (MMSYSERR_NOERROR) if this function
//	succeeds with no errors. The return value is a non-zero error code
//	if the function fails.
//  
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL gsm610Decode
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
#if (GSM610_FRAMESPERMONOBLOCK != 2)
    #error THIS WAS WRITTEN FOR 2 FRAMES PER BLOCK!!!
#endif
#if (GSM610_MAXCHANNELS > 1)
    #error THIS WAS WRITTEN FOR MONO ONLY!!!
#endif

    PSTREAMINSTANCE	psi;
    DWORD		cbSrcLen;
    BOOL		fBlockAlign;
    DWORD		cb;
    DWORD		dwcSamples;
    DWORD		cBlocks;
    HPBYTE		hpbSrc, hpbDst;
    
    SHORT   erp[GSM610_SAMPLESPERSUBFRAME];
    SHORT   wt[GSM610_SAMPLESPERFRAME];
    SHORT   sr[GSM610_SAMPLESPERFRAME];
    SHORT   srop[GSM610_SAMPLESPERFRAME];
    
    // The GSM610 stream data:
    SHORT   LARcr[9];			    // LARc[1..8] (one array per frame)
    SHORT   Ncr[GSM610_NUMSUBFRAMES];	    // Nc (one per sub-frame)
    SHORT   bcr[GSM610_NUMSUBFRAMES];	    // bc (one per sub-frame)
    SHORT   Mcr[GSM610_NUMSUBFRAMES];	    // Mc (one per sub-frame)
    SHORT   xmaxcr[GSM610_NUMSUBFRAMES];    // Xmaxc (one per sub-frame)
    XM	    xMcr[GSM610_NUMSUBFRAMES];	    // xMc (one sequence per sub-frame)
    
    UINT    i,j;
    UINT    nFrame;

    // Temp buffer to hold a block (two frames) of packed stream data
    BYTE    abBlock[ GSM610_BYTESPERMONOBLOCK ];
    
    
#ifdef DEBUG
//  ProfStart();
#endif

    psi		= (PSTREAMINSTANCE)padsi->dwDriver;

    // If this is flagged as the first block of a conversion
    // then reset the stream instance data.
    if (0 != (ACM_STREAMCONVERTF_START & padsh->fdwConvert))
    {
	gsm610Reset(psi);
    }
    
    fBlockAlign = (0 != (ACM_STREAMCONVERTF_BLOCKALIGN & padsh->fdwConvert));



    //
    //	-= decode GSM 6.10 to PCM =-
    //
    //
    cb = padsh->cbSrcLength;

    cBlocks = cb / GSM610_BLOCKALIGNMENT(padsi->pwfxSrc);

    if (0L == cBlocks)
    {
       padsh->cbSrcLengthUsed = cb;
       padsh->cbDstLengthUsed = 0L;

       return (MMSYSERR_NOERROR);
    }


    //
    // Compute bytes we will use in destination buffer.  Carefull!  Look
    // out for overflow in our calculations!
    //
    if ((0xFFFFFFFFL / GSM610_SAMPLESPERMONOBLOCK) < cBlocks)
	return (ACMERR_NOTPOSSIBLE);
    dwcSamples = cBlocks * GSM610_SAMPLESPERMONOBLOCK;

    if (PCM_BYTESTOSAMPLES(((LPPCMWAVEFORMAT)(padsi->pwfxDst)), 0xFFFFFFFFL) < dwcSamples)
	return (ACMERR_NOTPOSSIBLE);
    cb = PCM_SAMPLESTOBYTES(((LPPCMWAVEFORMAT)(padsi->pwfxDst)), dwcSamples);
    
    if (cb > padsh->cbDstLength)
    {
       return (ACMERR_NOTPOSSIBLE);
    }

    padsh->cbDstLengthUsed = cb;
    padsh->cbSrcLengthUsed = cBlocks * GSM610_BLOCKALIGNMENT(padsi->pwfxSrc);



    //
    //
    //
    cbSrcLen = padsh->cbSrcLengthUsed;

	
    // Setup huge pointers to our src and dst buffers
    hpbSrc = (HPBYTE)padsh->pbSrc;
    hpbDst = (HPBYTE)padsh->pbDst;

    
    // while at least another full block of coded data
    while (cbSrcLen >= GSM610_BYTESPERMONOBLOCK)
    {
	
	// copy a block of data from stream buffer to our temp buffer	    
	for (i=0; i<GSM610_BYTESPERMONOBLOCK; i++) abBlock[i] = *(hpbSrc++);
	cbSrcLen -= GSM610_BYTESPERMONOBLOCK;
	
	// for each of the two frames in the block
	for (nFrame=0; nFrame < 2; nFrame++)
	{
	    // Unpack data from stream
	    if (nFrame == 0)
		UnpackFrame0(abBlock, LARcr, Ncr, bcr, Mcr, xmaxcr, xMcr);
	    else
		UnpackFrame1(abBlock, LARcr, Ncr, bcr, Mcr, xmaxcr, xMcr);
	    
	    
	    for (i=0; i<4; i++) // for each of 4 sub-blocks
	    {
		// reconstruct the long term residual signal erp[0..39]
		// from Mcr, xmaxcr, and xMcr
		decodeRPE(psi, Mcr[i], xmaxcr[i], xMcr[i], erp);
		
		// reconstruct the short term residual signal drp[0..39]
		// and also update drp[-120..-1]
		decodeLTP(psi, bcr[i], Ncr[i], erp);
    
		// accumulate the four sub-blocks of reconstructed short
		// term residual signal drp[0..39] into wt[0..159]
		for (j=0; j<40; j++) wt[(i*40) + j] = psi->drp[120+j];
		
	    }
	    
	    // reconstruct the signal s
	    decodeLPC(psi, LARcr, wt, sr);
	    
	    // post-process the signal s
	    decodePostproc(psi, sr, srop);

	    //
	    // write decoded 16-bit PCM to dst.  our dst format
	    // may be 8- or 16-bit PCM.
	    //
	    if (padsi->pwfxDst->wBitsPerSample == 16)
	    {
		// copy 16-bit samples from srop to hpbDst
		for (j=0; j < GSM610_SAMPLESPERFRAME; j++)
		{
		    *( ((HPWORD)hpbDst)++ ) = srop[j];
		}
	    }
	    else
	    {
		// copy 16-bit samples from srop to 8-bit samples in hpbDst
		for (j=0; j < GSM610_SAMPLESPERFRAME; j++)
		{
		    *(hpbDst++) = Convert16To8BitPCM(srop[j]);
		}
	    }

	    
	} // for (nFrame...
	
    }
    
#ifdef DEBUG
//  ProfStop();
#endif
    
    return (MMSYSERR_NOERROR);
}


//=====================================================================
//=====================================================================
//
//  Encode routines
//
//=====================================================================
//=====================================================================

//---------------------------------------------------------------------
//--------------------------------------------------------------------
//
// Function protos
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------
EXTERN_C void CompACF(LPSHORT s, LPLONG l_ACF);
void Compr(PSTREAMINSTANCE psi, LPLONG l_ACF, LPSHORT r);
void CompLAR(PSTREAMINSTANCE psi, LPSHORT r, LPSHORT LAR);
void CompLARc(PSTREAMINSTANCE psi, LPSHORT LAR, LPSHORT LARc);

void CompLARpp(PSTREAMINSTANCE psi, LPSHORT LARc, LPSHORT LARpp);
void CompLARp(PSTREAMINSTANCE psi, LPSHORT LARpp, LPSHORT LARp1, LPSHORT LARp2, LPSHORT LARp3, LPSHORT LARp4);
void Comprp(PSTREAMINSTANCE psi, LPSHORT LARp, LPSHORT rp);
EXTERN_C void Compd(PSTREAMINSTANCE psi, LPSHORT rp, LPSHORT s, LPSHORT d, UINT k_start, UINT k_end);

void WeightingFilter(PSTREAMINSTANCE psi, LPSHORT e, LPSHORT x);
void RPEGridSelect(PSTREAMINSTANCE psi, LPSHORT x, LPSHORT pMc, LPSHORT xM);
void APCMQuantize(PSTREAMINSTANCE psi, LPSHORT xM, LPSHORT pxmaxc, LPSHORT xMc, LPSHORT pexp, LPSHORT pmant);
void APCMInvQuantize(PSTREAMINSTANCE psi, SHORT exp, SHORT mant, LPSHORT xMc, LPSHORT xMp);
void RPEGridPosition(PSTREAMINSTANCE psi, SHORT Mc, LPSHORT xMp, LPSHORT ep);


//---------------------------------------------------------------------
//---------------------------------------------------------------------
//
// Global constant data
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------

const SHORT BCODE A[9] = {
    0,	    // not used
    20480, 20480, 20480, 20480, 13964, 15360, 8534, 9036 };

const SHORT BCODE B[9] = {
    0,	    // not used
    0, 0, 2048, -2560, 94, -1792, -341, -1144 };

const SHORT BCODE MIC[9] = {
    0,	    // not used
    -32, -32, -16, -16, -8, -8, -4, -4 };

const SHORT BCODE MAC[9] = {
    0,	    // not used
    31, 31, 15, 15, 7, 7, 3, 3 };

const SHORT BCODE INVA[9] = {
    0,	// unused
    13107, 13107, 13107, 13107, 19223, 17476, 31454, 29708 };

EXTERN_C const SHORT BCODE DLB[4] = { 6554, 16384, 26214, 32767 };
EXTERN_C const SHORT BCODE QLB[4] = { 3277, 11469, 21299, 32767 };

const SHORT BCODE H[11] = { -134, -374, 0, 2054, 5741, 8192, 5741, 2054, 0, -374, -134 };
const SHORT BCODE NRFAC[8] = { 29128, 26215, 23832, 21846, 20165, 18725, 17476, 16384 };
const SHORT BCODE FAC[8] = { 18431, 20479, 22527, 24575, 26623, 28671, 30719, 32767 };

//---------------------------------------------------------------------
//---------------------------------------------------------------------
//
// Procedures
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------


//---------------------------------------------------------------------
//
// PackFrame0
//
//---------------------------------------------------------------------

void PackFrame0
(
    BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]
)
{
    int i;
    
    // Pack the LAR[1..8] into the first 4.5 bytes
    ab[0] = ((LAR[1]	 ) & 0x3F) | ((LAR[2] << 6) & 0xC0);
    ab[1] = ((LAR[2] >> 2) & 0x0F) | ((LAR[3] << 4) & 0xF0);
    ab[2] = ((LAR[3] >> 4) & 0x01) | ((LAR[4] << 1) & 0x3E) | ((LAR[5] << 6) & 0xC0);
    ab[3] = ((LAR[5] >> 2) & 0x03) | ((LAR[6] << 2) & 0x3C) | ((LAR[7] << 6) & 0xC0);
    ab[4] = ((LAR[7] >> 2) & 0x01) | ((LAR[8] << 1) & 0x0E);
    
    // Pack N, b, M, Xmax, and X for each of the 4 sub-frames
    for (i=0; i<4; i++)
    {
    
	ab[4+i*7+0] |= ((N[i] << 4) & 0xF0);
	ab[4+i*7+1] = ((N[i] >> 4) & 0x07) | ((b[i] << 3) & 0x18) | ((M[i] << 5) & 0x60) | ((Xmax[i] << 7) & 0x80);
	ab[4+i*7+2] = ((Xmax[i] >> 1) & 0x1F) | ((X[i][0] << 5) & 0xE0);
	ab[4+i*7+3] = (X[i][1] & 0x07) | ((X[i][2] << 3) & 0x38) | ((X[i][3] << 6) & 0xC0);
	ab[4+i*7+4] = ((X[i][3] >> 2) & 0x01) | ((X[i][4] << 1) & 0x0E) | ((X[i][5] << 4) & 0x70) | ((X[i][6] << 7) & 0x80);
	ab[4+i*7+5] = ((X[i][6] >> 1) & 0x03) | ((X[i][7] << 2) & 0x1C) | ((X[i][8] << 5) & 0xE0);
	ab[4+i*7+6] = (X[i][9] & 0x07) | ((X[i][10] << 3) & 0x38) | ((X[i][11] << 6) & 0xC0);
	ab[4+i*7+7] = ((X[i][11] >> 2) & 0x01) | ((X[i][12] << 1) & 0x0E);
    
    }
    
    return;
}	


//---------------------------------------------------------------------
//
// PackFrame1
//
//---------------------------------------------------------------------

void PackFrame1
(
    BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]
)
{
    int i;
    
    // Pack the LAR[1..8] into the first 4.5 bytes, starting with the
    // more significant nibble of the first byte.
    ab[32] |= ((LAR[1] << 4) & 0xF0);
    ab[33] = ((LAR[1] >> 4) & 0x03) | ((LAR[2] << 2) & 0xFC);
    ab[34] = ((LAR[3]	  ) & 0x1F) | ((LAR[4] << 5) & 0xE0);
    ab[35] = ((LAR[4] >> 3) & 0x03) | ((LAR[5] << 2) & 0x3C) | ((LAR[6] << 6) & 0xC0);
    ab[36] = ((LAR[6] >> 2) & 0x03) | ((LAR[7] << 2) & 0x1C) | ((LAR[8] << 5) & 0xE0);
    
    // Pack N, b, M, Xmax, and X for each of the 4 sub-frames
    for (i=0; i<4; i++)
    {
	ab[37+i*7+0] = (N[i] & 0x7F) | ((b[i] << 7) & 0x80);
	ab[37+i*7+1] = ((b[i] >> 1) & 0x01) | ((M[i] << 1) & 0x06) | ((Xmax[i] << 3) & 0xF8);
	ab[37+i*7+2] = ((Xmax[i] >> 5) & 0x01) | ((X[i][0] << 1) & 0x0E) | ((X[i][1] << 4) & 0x70) | ((X[i][2] << 7) & 0x80);
	ab[37+i*7+3] = ((X[i][2] >> 1) & 0x03) | ((X[i][3] << 2) & 0x1C) | ((X[i][4] << 5) & 0xE0);
	ab[37+i*7+4] = ((X[i][5]     ) & 0x07) | ((X[i][6] << 3) & 0x38) | ((X[i][7] << 6) & 0xC0);
	ab[37+i*7+5] = ((X[i][7] >> 2) & 0x01) | ((X[i][8] << 1) & 0x0E) | ((X[i][9] << 4) & 0x70) | ((X[i][10] << 7) & 0x80);
	ab[37+i*7+6] = ((X[i][10] >> 1) & 0x03) | ((X[i][11] << 2) & 0x1C) | ((X[i][12] << 5) & 0xE0);
    }
    
    return;
}	


//---------------------------------------------------------------------
//
// encodePreproc()
//
//---------------------------------------------------------------------

void encodePreproc(PSTREAMINSTANCE psi, LPSHORT sop, LPSHORT s)
{
    
    SHORT   so[160];
    SHORT   sof[160];
    
    UINT    k;
    SHORT   s1;
    SHORT   temp;
    SHORT   msp, lsp;
    LONG    l_s2;
    
    // downscale
    for (k=0; k<160; k++)
    {
	so[k] = sop[k] >> 3;
	so[k] = so[k]  << 2;
    }
	
    // offset compensation
    for (k=0; k<160; k++)
    {
	
	// Compute the non-recursive part
	s1 = sub(so[k], psi->z1);
	psi->z1 = so[k];
	
	// compute the recursive part
	l_s2 = s1;
	l_s2 = l_s2 << 15;
	
	// execution of 31 by 16 bits multiplication
	msp = (SHORT) (psi->l_z2 >> 15);
	lsp = (SHORT) l_sub(psi->l_z2, ( ((LONG)msp) << 15));
	temp = mult_r(lsp, 32735);
	l_s2 = l_add(l_s2, temp);
	psi->l_z2 = l_add(l_mult(msp, 32735) >> 1, l_s2);
	
	// compute sof[k] with rounding
	sof[k] = (SHORT) (l_add(psi->l_z2, 16384) >> 15);
    }
	
    // preemphasis
    for (k=0; k<160; k++)
    {
	s[k] = add(sof[k], mult_r(psi->mp, -28180));
	psi->mp = sof[k];
    }
	
		   
    return;
}
    
    
//---------------------------------------------------------------------
//
// encodeLPCAnalysis()
//
//---------------------------------------------------------------------

void encodeLPCAnalysis(PSTREAMINSTANCE psi, LPSHORT s, LPSHORT LARc)
{

    LONG    l_ACF[9];
    SHORT   r[9];
    SHORT   LAR[9];

    CompACF(s, l_ACF);
    Compr(psi, l_ACF, r);
    CompLAR(psi, r, LAR);
    CompLARc(psi, LAR, LARc);
    
    return;

}


//---------------------------------------------------------------------
//
// CompACF()
//
//---------------------------------------------------------------------

void CompACF(LPSHORT s, LPLONG l_ACF)
{
    SHORT   smax, temp, scalauto;
    UINT    i, k;
    
    //
    // Dynamic scaling of array s[0..159]
    //
    
    // Search for the maximum
    smax = 0;
    for (k=0; k<160; k++)
    {
	temp = gabs(s[k]);
	if (temp > smax) smax = temp;
    }
    
    // Computation of the scaling factor
    if (smax == 0) scalauto = 0;
    else scalauto = sub( 4, norm( ((LONG)smax)<<16 ) );
    
    // Scaling of the array s
    if (scalauto > 0)
    {
	temp = BITSHIFTRIGHT(16384, sub(scalauto,1));
	for (k=0; k<160; k++)
	{
	    // s[k] = mult_r(s[k], temp);
	    s[k] = HIWORD( ( (((LONG)s[k])<<(15-scalauto)) + 0x4000L ) << 1 );
	}
    }
    
    
    //
    // Compute the l_ACF[..]
    //
    
    for (k=0; k<9; k++)
    {
	l_ACF[k] = 0;
	for (i=k; i<160; i++)
	{
	    l_ACF[k] = l_add(l_ACF[k], l_mult(s[i], s[i-k]));
	}
    }
    
    
    //
    // Rescaling of array s
    //
    
    if (scalauto > 0)
    {
	for (k=0; k<160; k++)
	{
	    // We don't need the BITSHIFTLEFT macro
	    // cuz we know scalauto>0 due to above test
	    s[k] = s[k] << scalauto;
	}
    }


    //
    //
    //
    return;
}


//---------------------------------------------------------------------
//
// Compr()
//
//---------------------------------------------------------------------

void Compr(PSTREAMINSTANCE psi, LPLONG l_ACF, LPSHORT r)
{

    UINT    i, k, m, n;
    SHORT   temp, ACF[9];
    SHORT   K[9], P[9];	    // K[2..8], P[0..8]

    //
    // Schur recursion with 16 bits arithmetic
    //

    if (l_ACF[0] == 0)
    {
	for (i=1; i<=8; i++)
	{
	    r[i] = 0;
	}
	return;
    }
    
    
    temp = norm(l_ACF[0]);
    
    for (k=0; k<=8; k++)
    {
	ACF[k] = (SHORT) ((BITSHIFTLEFT(l_ACF[k], temp)) >> 16);
    }
    
    
    //
    // Init array P and K for the recursion
    //
    
    for (i=1; i<=7; i++)
    {
	K[9-i] = ACF[i];
    }
    
    for (i=0; i<=8; i++)
    {
	P[i] = ACF[i];
    }
    
    
    //
    // Compute reflection coefficients
    //
    
    for (n=1; n<=8; n++)
    {
	if (P[0] < gabs(P[1]))
	{
	    for (i=n; i<=8; i++)
	    {
		r[i] = 0;
	    }
	    return;
	}
	
	r[n] = gdiv(gabs(P[1]),P[0]);
	
	if (P[1] > 0) r[n] = sub(0,r[n]);
    
	// Here's the real exit from this for loop  
	if (n==8) return;
	
	
	// Schur recursion
	P[0] = add(P[0], mult_r(P[1], r[n]));
	for (m=1; m<=8-n; m++)
	{
	    P[m] = add( P[m+1], mult_r(K[9-m],r[n]) );
	    K[9-m] = add( K[9-m], mult_r(P[m+1], r[n]) );
	}
	
    }
    
}


//---------------------------------------------------------------------
//
// CompLAR()
//
//---------------------------------------------------------------------

void CompLAR(PSTREAMINSTANCE psi, LPSHORT r, LPSHORT LAR)
{

    UINT  i;
    SHORT temp;

    //
    // Computation of LAR[1..8] from r[1..8]
    //
    
    for (i=1; i<=8; i++)
    {
	temp = gabs(r[i]);
	
	if (temp < 22118)
	{
	    temp = temp >> 1;
	}
	else if (temp < 31130)
	{
	    temp = sub(temp, 11059);
	}
	else
	{
	    temp = sub(temp, 26112) << 2;
	}
	
	LAR[i] = temp;
	
	if (r[i] < 0)
	{
	    LAR[i] = sub(0, LAR[i]);
	}
	
    }
    
    return;
}
    

//---------------------------------------------------------------------
//
// CompLARc()
//
//---------------------------------------------------------------------

void CompLARc(PSTREAMINSTANCE psi, LPSHORT LAR, LPSHORT LARc)
{

    UINT  i;
    SHORT temp;

    for (i=1; i<=8; i++)
    {
	temp = mult(A[i], LAR[i]);
	temp = add(temp, B[i]);
	temp = add(temp, 256);
	LARc[i] = temp >> 9;
	
	// Check if LARc[i] between MIN and MAX
	if (LARc[i] > MAC[i]) LARc[i] = MAC[i];
	if (LARc[i] < MIC[i]) LARc[i] = MIC[i];
	
	// This is used to make all LARc positive
	LARc[i] = sub(LARc[i], MIC[i]);
	
    }
    
    return;
}


//---------------------------------------------------------------------
//
// encodeLPCFilter()
//
//---------------------------------------------------------------------

void encodeLPCFilter(PSTREAMINSTANCE psi, LPSHORT LARc, LPSHORT s, LPSHORT d)
{
    SHORT LARpp[9];				    // array [1..8]
    SHORT LARp1[9], LARp2[9], LARp3[9], LARp4[9];   // array [1..8]
    SHORT rp[9];				    // array [1..8]

    CompLARpp(psi, LARc, LARpp);
    CompLARp(psi, LARpp, LARp1, LARp2, LARp3, LARp4);
    
    Comprp(psi, LARp1, rp);
    Compd(psi, (LPSHORT)rp, s, d, 0, 12);
    
    Comprp(psi, LARp2, rp);
    Compd(psi, (LPSHORT)rp, s, d, 13, 26);
    
    Comprp(psi, LARp3, rp);
    Compd(psi, (LPSHORT)rp, s, d, 27, 39);
    
    Comprp(psi, LARp4, rp);
    Compd(psi, (LPSHORT)rp, s, d, 40, 159);
    
    return;
}


//---------------------------------------------------------------------
//
// CompLARpp()
//
//---------------------------------------------------------------------

void CompLARpp(PSTREAMINSTANCE psi, LPSHORT LARc, LPSHORT LARpp)
{
    UINT    i;
    SHORT   temp1, temp2;
    
    for (i=1; i<=8; i++)
    {
	temp1 = add(LARc[i], MIC[i]) << 10;
	temp2 = B[i] << 1;
	temp1 = sub(temp1,temp2);
	temp1 = mult_r(INVA[i], temp1);
	LARpp[i] = add(temp1, temp1);
    }
    
    return;
}


//---------------------------------------------------------------------
//
// CompLARp()
//
//---------------------------------------------------------------------

void CompLARp(PSTREAMINSTANCE psi, LPSHORT LARpp, LPSHORT LARp1, LPSHORT LARp2, LPSHORT LARp3, LPSHORT LARp4)
{
    UINT i;
    
    for (i=1; i<=8; i++)
    {
	LARp1[i] = add( (SHORT)(psi->OldLARpp[i] >> 2), (SHORT)(LARpp[i] >> 2) );
	LARp1[i] = add( LARp1[i], (SHORT)(psi->OldLARpp[i] >> 1) );
	
	LARp2[i] = add( (SHORT)(psi->OldLARpp[i] >> 1), (SHORT)(LARpp[i] >> 1) );
	
	LARp3[i] = add( (SHORT)(psi->OldLARpp[i] >> 2), (SHORT)(LARpp[i] >> 2) );
	LARp3[i] = add( LARp3[i], (SHORT)(LARpp[i] >> 1) );
	
	LARp4[i] = LARpp[i];
    }
    
    for (i=1; i<=8; i++)
    {
	psi->OldLARpp[i] = LARpp[i];
    }
    
    return;
    
}


//---------------------------------------------------------------------
//
// Comprp()
//
//---------------------------------------------------------------------

void Comprp(PSTREAMINSTANCE psi, LPSHORT LARp, LPSHORT rp)
{
    UINT    i;
    SHORT   temp;

    for (i=1; i<=8; i++)
    {
	temp = gabs(LARp[i]);
	if (temp < 11059)
	{
	    temp = temp << 1;
	}
	else if (temp < 20070)
	{
	    temp = add(temp, 11059);
	}
	else
	{
	    temp = add((SHORT)(temp>>2), 26112);
	}
	
	rp[i] = temp;
	
	if (LARp[i] < 0)
	{
	    rp[i] = sub(0,rp[i]);
	}
	
    }
    
    return;
}


//---------------------------------------------------------------------
//
// Compd()
//
//---------------------------------------------------------------------

void Compd(PSTREAMINSTANCE psi, LPSHORT rp, LPSHORT s, LPSHORT d, UINT k_start, UINT k_end)
{
    UINT    k, i;
    
    SHORT   sav;
    SHORT   di;
    SHORT   temp;
    
    for (k=k_start; k<=k_end; k++)
    {
	di = s[k];
	sav = di;
	
	for (i=1; i<=8; i++)
	{
	    temp = add( psi->u[i-1], mult_r(rp[i],di) );
	    di = add( di, mult_r(rp[i], psi->u[i-1]) );
	    psi->u[i-1] = sav;
	    sav = temp;
	}
	
	d[k] = di;
    }
    
    return;
}


//---------------------------------------------------------------------
//
// encodeLTPAnalysis()
//
//---------------------------------------------------------------------

void encodeLTPAnalysis(PSTREAMINSTANCE psi, LPSHORT d, LPSHORT pNc, LPSHORT pbc)
{
    SHORT dmax;
    SHORT temp;
    SHORT scal;
    SHORT wt[40];
    SHORT lambda;
    LONG  l_max, l_power;
    SHORT R, S;
    SHORT Nc;
    
    int   k;               // k must be int, not UINT!

    Nc = *pNc;
	
    // Search of the optimum scaling of d[0..39]
	   
    dmax = 0;
    
    for (k=39; k>=0; k--)
    {
        temp = gabs( d[k] );
        if (temp > dmax) dmax = temp;
    }

    temp = 0;
    
    if (dmax == 0) scal = 0;
    else temp = norm( ((LONG)dmax) << 16);
    
    if (temp > 6) scal = 0;
    else scal = sub(6,temp);
    

    // Init of working array wt[0..39]
    ASSERT( scal >= 0 );
    for (k=39; k>=0; k--)
    {
        wt[k] = d[k] >> scal;
    }
    
    // Search for max cross-correlation and coding of LTP lag
    
    l_max = 0;
    Nc = 40;
    
    for (lambda=40; lambda<=120; lambda++)
    {
        register LONG l_result = 0;
        for (k=39; k>=0; k--)
        {
            l_result += (LONG)(wt[k]) * (LONG)(psi->dp[120-lambda+k]);
        }
        if (l_result > l_max)
        {
            Nc = lambda;
            l_max = l_result;
        }
    }
    l_max <<= 1;    // This operation should be on l_result as part of the
                    //  multiply/add, but for efficiency we shift it all
                    //  the way out of the loops.
    
    // Rescaling of l_max
    ASSERT( sub(6,scal) >= 0 );
    l_max = l_max >> sub(6,scal);
    
    // Compute the power of the reconstructed short term residual
    // signal dp[..].
    l_power = 0;
    {
        SHORT s;
        for (k=39; k>=0; k--)
        {
            s = psi->dp[120-Nc+k] >> 3;
            l_power += s*s;   // This sum can never overflow!!!
        }
        ASSERT( l_power >= 0 );
        if( l_power >= 1073741824 ) {           // 2**30
            l_power = 2147483647;               // 2**31 - 1
        } else {
            l_power <<= 1;   // This shift is normally part of l_mult().
        }
    }

    *pNc = Nc;
	
    // Normalization of l_max and l_power
    if (l_max <= 0)
    {
	*pbc = 0;
	return;
    }
    
    if (l_max >= l_power)
    {
	*pbc = 3;
	return;
    }
    
    temp = norm(l_power);
    ASSERT( temp >= 0 );
    R = (SHORT) ((l_max<<temp) >> 16);
    S = (SHORT) ((l_power<<temp) >> 16);
    
    // Codeing of the LTP gain
    
    for ( *pbc=0; *pbc<=2; (*pbc)++ )
    {
	if (R <= mult(S, DLB[*pbc]))
	{
	    return;
	}
    }
    *pbc = 3;
    
    return;
}


//---------------------------------------------------------------------
//
// encodeLTPFilter()
//
//---------------------------------------------------------------------

void encodeLTPFilter(PSTREAMINSTANCE psi, SHORT bc, SHORT Nc, LPSHORT d, LPSHORT e, LPSHORT dpp)
{
    SHORT   bp;
    UINT    k;

    // Decoding of the coded LTP gain
    bp = QLB[bc];
    
    // Calculating the array e[0..39] and the array dpp[0..39]
    for (k=0; k<=39; k++)
    {
	dpp[k] = mult_r(bp, psi->dp[120+k-Nc]);
	e[k] = sub(d[k], dpp[k]);
    }
    
    return;
}


//---------------------------------------------------------------------
//
// encodeRPE()
//
//---------------------------------------------------------------------

void encodeRPE(PSTREAMINSTANCE psi, LPSHORT e, LPSHORT pMc, LPSHORT pxmaxc, LPSHORT xMc, LPSHORT ep)
{
    SHORT x[40];
    SHORT xM[13];
    SHORT exp, mant;
    SHORT xMp[13];

    WeightingFilter(psi, e, x);
    RPEGridSelect(psi, x, pMc, xM);
    APCMQuantize(psi, xM, pxmaxc, xMc, &exp, &mant);
    APCMInvQuantize(psi, exp, mant, xMc, xMp);
    RPEGridPosition(psi, *pMc, xMp, ep);
    
    
    return;
    
}


//---------------------------------------------------------------------
//
// WeightingFilter()
//
//---------------------------------------------------------------------

void WeightingFilter(PSTREAMINSTANCE psi, LPSHORT e, LPSHORT x)
{
    UINT    i, k;
    
    LONG    l_result, l_temp;
    SHORT   wt[50];


    // Initialization of a temporary working array wt[0..49]
    for (k= 0; k<= 4; k++) wt[k] = 0;
    for (k= 5; k<=44; k++) wt[k] = e[k-5];
    for (k=45; k<=49; k++) wt[k] = 0;
    
    // Compute the signal x[0..39]
    for (k=0; k<=39; k++)
    {
	l_result = 8192;    // rounding of the output of the filter
	
	for (i=0; i<=10; i++)
	{
	    l_temp = l_mult(wt[k+i], H[i]);
	    l_result = l_add(l_result, l_temp);
	}
	
	l_result = l_add(l_result, l_result);	// scaling x2
	l_result = l_add(l_result, l_result);	// scaling x4
	
	x[k] = (SHORT) (l_result >> 16);
    }
    return;
}


//---------------------------------------------------------------------
//
// RPEGridSelect()
//
//---------------------------------------------------------------------

void RPEGridSelect(PSTREAMINSTANCE psi, LPSHORT x, LPSHORT pMc, LPSHORT xM)
{
    UINT    m, i;

    LONG    l_EM;
    SHORT   temp1;
    LONG    l_result, l_temp;

    // the signal x[0..39] is used to select the RPE grid which is
    // represented by Mc
    l_EM = 0;
    *pMc = 0;
    
    for (m=0; m<=3; m++)
    {
	l_result = 0;
	for (i=0; i<=12; i++)
	{
	    temp1 = x[m+(3*i)] >> 2;
	    l_temp = l_mult(temp1, temp1);
	    l_result = l_add(l_temp, l_result);
	}
	if (l_result > l_EM)
	{
	    *pMc = (SHORT)m;
	    l_EM = l_result;
	}
    }
    
    // down-sampling by a factor of 3 to get the selected xM[0..12]
    // RPE sequence
    for (i=0; i<=12; i++)
    {
	xM[i] = x[*pMc + (3*i)];
    }
    

    return; 
}


//---------------------------------------------------------------------
//
// APCMQuantize()
//
//---------------------------------------------------------------------

void APCMQuantize(PSTREAMINSTANCE psi, LPSHORT xM, LPSHORT pxmaxc, LPSHORT xMc, LPSHORT pexp, LPSHORT pmant)
{
    UINT    i;
    SHORT   xmax;
    SHORT   temp;
    SHORT   itest;
    SHORT   temp1, temp2;

    // find the maximum absolute value xmax or xM[0..12]
    xmax = 0;
    for (i=0; i<=12; i++)
    {
	temp = gabs(xM[i]);
	if (temp > xmax) xmax = temp;
    }
    
    // quantizing and coding of xmax to get xmaxc
    *pexp = 0;
    temp = xmax >> 9;
    itest = 0;
    for (i=0; i<=5; i++)
    {
	if (temp <=0) itest = 1;
	temp = temp >> 1;
	if (itest == 0) *pexp = add(*pexp,1);
    }
    temp = add(*pexp,5);
    *pxmaxc = add( (SHORT)BITSHIFTRIGHT(xmax,temp), (SHORT)(*pexp << 3) );
    
    //
    // quantizing and coding of the xM[0..12] RPE sequence to get
    // the xMc[0..12]
    //
    
    // compute exponent and mantissa of the decoded version of xmaxc
    *pexp = 0;
    if (*pxmaxc > 15) *pexp = sub((SHORT)(*pxmaxc >> 3),1);
    *pmant = sub(*pxmaxc,(SHORT)(*pexp<<3));
    
    // normalize mantissa 0 <= mant <= 7
    if (*pmant==0)
    {
	*pexp = -4;
	*pmant = 15;
    }
    else
    {
	itest = 0;
	for (i=0; i<=2; i++)
	{
	    if (*pmant > 7) itest = 1;
	    if (itest == 0) *pmant = add((SHORT)(*pmant << 1),1);
	    if (itest == 0) *pexp = sub(*pexp,1);
	}
    }
    
    *pmant = sub(*pmant,8);
    
    // direct computation of xMc[0..12] using table
    temp1 = sub(6,*pexp);	// normalization by the exponent
    temp2 = NRFAC[*pmant];  // see table (inverse mantissa)
    for (i=0; i<=12; i++)
    {
	temp = BITSHIFTLEFT(xM[i], temp1);
	temp = mult( temp, temp2 );
	xMc[i] = add( (SHORT)(temp >> 12), 4 );    // makes all xMc[i] positive
    }
    
    return;
}


//---------------------------------------------------------------------
//
// APCMInvQuantize()
//
//---------------------------------------------------------------------

void APCMInvQuantize(PSTREAMINSTANCE psi, SHORT exp, SHORT mant, LPSHORT xMc, LPSHORT xMp)
{
    SHORT   temp1, temp2, temp3, temp;
    UINT    i;

    temp1 = FAC[mant];
    temp2 = sub(6,exp);
    temp3 = BITSHIFTLEFT(1, sub(temp2,1));
    
    for (i=0; i<=12; i++)
    {
	temp = sub( (SHORT)(xMc[i] << 1), 7);	// restores sign of xMc[i]
	temp = temp << 12;
	temp = mult_r(temp1, temp);
	temp = add(temp, temp3);
	xMp[i] = BITSHIFTRIGHT(temp,temp2);
    }
    
    return;
}


//---------------------------------------------------------------------
//
// RPEGridPosition(SHORT Mc, LPSHORT xMp, LPSHORT ep)
//
//---------------------------------------------------------------------

void RPEGridPosition(PSTREAMINSTANCE psi, SHORT Mc, LPSHORT xMp, LPSHORT ep)
{
    UINT    k, i;

    for (k=0; k<=39; k++)
    {
	ep[k] = 0;
    }
    
    for (i=0; i<=12; i++)
    {
	ep[Mc + (3*i)] = xMp[i];
    }
    
    return;
}


//---------------------------------------------------------------------
//
// encodeUpdate()
//
//---------------------------------------------------------------------

void encodeUpdate(PSTREAMINSTANCE psi, LPSHORT ep, LPSHORT dpp)
{
    UINT k;
    
    for (k=0; k<=79; k++)
	psi->dp[120-120+k] = psi->dp[120-80+k];
	
    for (k=0; k<=39; k++)
	psi->dp[120-40+k] = add(ep[k], dpp[k]);
	
    return;
}


//=====================================================================
//=====================================================================
//
//  Decode routines
//
//=====================================================================
//=====================================================================


//---------------------------------------------------------------------
//---------------------------------------------------------------------
//
// Function protos
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------

EXTERN_C void Compsr(PSTREAMINSTANCE psi, LPSHORT wt, LPSHORT rrp, UINT k_start, UINT k_end, LPSHORT sr);


//---------------------------------------------------------------------
//---------------------------------------------------------------------
//
// Procedures
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------


//---------------------------------------------------------------------
//
// UnpackFrame0
//
//---------------------------------------------------------------------

void UnpackFrame0
(
    BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]
)
{
    UINT i;
    
    // Unpack the LAR[1..8] from the first 4.5 bytes
    LAR[1] =  (ab[0] & 0x3F);
    LAR[2] = ((ab[0] & 0xC0) >> 6) | ((ab[1] & 0x0F) << 2);
    LAR[3] = ((ab[1] & 0xF0) >> 4) | ((ab[2] & 0x01) << 4);
    LAR[4] = ((ab[2] & 0x3E) >> 1);
    LAR[5] = ((ab[2] & 0xC0) >> 6) | ((ab[3] & 0x03) << 2);
    LAR[6] = ((ab[3] & 0x3C) >> 2);
    LAR[7] = ((ab[3] & 0xC0) >> 6) | ((ab[4] & 0x01) << 2);
    LAR[8] = ((ab[4] & 0x0E) >> 1);

    // Unpack N, b, M, Xmax, and X for each of the four sub-frames
    for (i=0; i<4; i++)
    {
	// A convenient macro for getting bytes out of the array for
	// construction of the subframe parameters
#define sfb(x) (ab[4+i*7+x])

	N[i] = ((sfb(0) & 0xF0) >> 4) | ((sfb(1) & 0x07) << 4);
	b[i] = ((sfb(1) & 0x18) >> 3);
	M[i] = ((sfb(1) & 0x60) >> 5);
	Xmax[i] = ((sfb(1) & 0x80) >> 7) | ((sfb(2) & 0x1F) << 1);
	X[i][0] = ((sfb(2) & 0xE0) >> 5);
	X[i][1] =  (sfb(3) & 0x07);
	X[i][2] = ((sfb(3) & 0x3C) >> 3);
	X[i][3] = ((sfb(3) & 0xC0) >> 6) | ((sfb(4) & 0x01) << 2);
	X[i][4] = ((sfb(4) & 0x0E) >> 1);
	X[i][5] = ((sfb(4) & 0x70) >> 4);
	X[i][6] = ((sfb(4) & 0x80) >> 7) | ((sfb(5) & 0x03) << 1);
	X[i][7] = ((sfb(5) & 0x1C) >> 2);
	X[i][8] = ((sfb(5) & 0xE0) >> 5);
	X[i][9] =  (sfb(6) & 0x07);
	X[i][10] = ((sfb(6) & 0x38) >> 3);
	X[i][11] = ((sfb(6) & 0xC0) >> 6) | ((sfb(7) & 0x01) << 2);
	X[i][12] = ((sfb(7) & 0x0E) >> 1);

#undef sfb
    }
    
    return;
}	


//---------------------------------------------------------------------
//
// UnpackFrame1
//
//---------------------------------------------------------------------

void UnpackFrame1
(
    BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]
)
{
    UINT i;
    
    // Unpack the LAR[1..8] from the first 4.5 bytes
    LAR[1] = ((ab[32] & 0xF0) >> 4) | ((ab[33] & 0x03) << 4);
    LAR[2] = ((ab[33] & 0xFC) >> 2);
    LAR[3] = ((ab[34] & 0x1F)	  );
    LAR[4] = ((ab[34] & 0xE0) >> 5) | ((ab[35] & 0x03) << 3);
    LAR[5] = ((ab[35] & 0x3C) >> 2);
    LAR[6] = ((ab[35] & 0xC0) >> 6) | ((ab[36] & 0x03) << 2);
    LAR[7] = ((ab[36] & 0x1C) >> 2);
    LAR[8] = ((ab[36] & 0xE0) >> 5);

    // Unpack N, b, M, Xmax, and X for each of the four sub-frames
    for (i=0; i<4; i++)
    {
	// A convenient macro for getting bytes out of the array for
	// construction of the subframe parameters
#define sfb(x) (ab[37+i*7+x])

	N[i] = sfb(0) & 0x7F;
	b[i] = ((sfb(0) & 0x80) >> 7) | ((sfb(1) & 0x01) << 1);
	M[i] = ((sfb(1) & 0x06) >> 1);
	Xmax[i] = ((sfb(1) & 0xF8) >> 3) | ((sfb(2) & 0x01) << 5);

	X[i][0] = ((sfb(2) & 0x0E) >> 1);
	X[i][1] = ((sfb(2) & 0x70) >> 4);
	X[i][2] = ((sfb(2) & 0x80) >> 7) | ((sfb(3) & 0x03) << 1);
	X[i][3] = ((sfb(3) & 0x1C) >> 2);
	X[i][4] = ((sfb(3) & 0xE0) >> 5);
	X[i][5] = ((sfb(4) & 0x07)     );
	X[i][6] = ((sfb(4) & 0x38) >> 3);
	X[i][7] = ((sfb(4) & 0xC0) >> 6) | ((sfb(5) & 0x01) << 2);
	X[i][8] = ((sfb(5) & 0x0E) >> 1);
	X[i][9] = ((sfb(5) & 0x70) >> 4);
	X[i][10] = ((sfb(5) & 0x80) >> 7) | ((sfb(6) & 0x03) << 1);
	X[i][11] = ((sfb(6) & 0x1C) >> 2);
	X[i][12] = ((sfb(6) & 0xE0) >> 5);

#undef sfb

    }
    
    return;
}	


//---------------------------------------------------------------------
//
// decodeRPE()
//
//---------------------------------------------------------------------

void decodeRPE(PSTREAMINSTANCE psi, SHORT Mcr, SHORT xmaxcr, LPSHORT xMcr, LPSHORT erp)
{

    SHORT   exp, mant;
    SHORT   itest;
    UINT    i;
    SHORT   temp1, temp2, temp3, temp;
    SHORT   xMrp[13];
    UINT    k;

    // compute the exponent and mantissa of the decoded
    // version of xmaxcr
    
    exp = 0;
    if (xmaxcr > 15) exp = sub( (SHORT)(xmaxcr >> 3), 1 );
    mant = sub( xmaxcr, (SHORT)(exp << 3) );
    
    // normalize the mantissa 0 <= mant <= 7
    if (mant == 0)
    {
	exp = -4;
	mant = 15;
    }
    else
    {
	itest = 0;
	for (i=0; i<=2; i++)
	{
	    if (mant > 7) itest = 1;
	    if (itest == 0) mant = add((SHORT)(mant << 1),1);
	    if (itest == 0) exp = sub(exp,1);
	}
    }
    
    mant = sub(mant, 8);
    
    // APCM inverse quantization
    temp1 = FAC[mant];
    temp2 = sub(6,exp);
    temp3 = BITSHIFTLEFT(1, sub(temp2, 1));
    
    for (i=0; i<=12; i++)
    {
	temp = sub( (SHORT)(xMcr[i] << 1), 7 );
	temp = temp << 12;
	temp = mult_r(temp1, temp);
	temp = add(temp, temp3);
	xMrp[i] = BITSHIFTRIGHT(temp, temp2);
    }
    
    // RPE grid positioning
    for (k=0; k<=39; k++) erp[k] = 0;
    for (i=0; i<=12; i++) erp[Mcr + (3*i)] = xMrp[i];
	
    
    //
    return; 
}


//---------------------------------------------------------------------
//
// decodeLTP()
//
//---------------------------------------------------------------------

void decodeLTP(PSTREAMINSTANCE psi, SHORT bcr, SHORT Ncr, LPSHORT erp)
{
    SHORT   Nr;
    SHORT   brp;
    UINT    k;
    SHORT   drpp;

    // check limits of Nr
    Nr = Ncr;
    if (Ncr < 40) Nr = psi->nrp;
    if (Ncr > 120) Nr = psi->nrp;
    psi->nrp = Nr;
    
    // decoding of the LTP gain bcr
    brp = QLB[bcr];
    
    // computation of the reconstructed short term residual
    // signal drp[0..39]
    for (k=0; k<=39; k++)
    {
	drpp = mult_r( brp, psi->drp[120+k-Nr] );
	psi->drp[120+k] = add( erp[k], drpp );
    }
    
    // update of the reconstructed short term residual
    // signal drp[-1..-120]
    for (k=0; k<=119; k++)
    {
	psi->drp[120-120+k] = psi->drp[120-80+k];
    }
    
    return;
}


//---------------------------------------------------------------------
//
// decodeLPC
//
//---------------------------------------------------------------------

void decodeLPC
(
    PSTREAMINSTANCE psi,    // instance data
    LPSHORT LARcr,	    // received coded Log.-Area Ratios [1..8]
    LPSHORT wt,		    // accumulated drp signal [0..159]
    LPSHORT sr		    // reconstructed s [0..159]
)
{

    UINT    i;
    SHORT   LARrpp[9];	    // LARrpp[1..8], decoded LARcr
    SHORT   LARrp[9];	    // LARrp[1..9], interpolated LARrpp
    SHORT   rrp[9];	    // rrp[1..8], reflection coefficients
    SHORT   temp1, temp2;
    
    //
    // decoding of the coded log area ratios to get LARrpp[1..8]
    //
    
    // compute LARrpp[1..8]
    for (i=1; i<=8; i++)
    {
	temp1 = add( LARcr[i], MIC[i] ) << 10;
	temp2 = B[i] << 1;
	temp1 = sub( temp1, temp2);
	temp1 = mult_r( INVA[i], temp1 );
	LARrpp[i] = add( temp1, temp1 );
    }
    

    //
    // for k_start=0 to k_end=12
    //
	
    // interpolation of LARrpp[1..8] to get LARrp[1..8]
    for (i=1; i<=8; i++)
    {
	// for k_start=0 to k_end=12
	LARrp[i] = add( (SHORT)(psi->OldLARrpp[i] >> 2), (SHORT)(LARrpp[i] >> 2) );
	LARrp[i] = add( LARrp[i], (SHORT)(psi->OldLARrpp[i] >> 1) );
    }
    
    // computation of reflection coefficients rrp[1..8]
    Comprp(psi, LARrp, rrp);
    
    // short term synthesis filtering
    Compsr(psi, wt, rrp, 0, 12, sr);
    
    
    //
    // for k_start=13 to k_end=26
    //
	
    // interpolation of LARrpp[1..8] to get LARrp[1..8]
    for (i=1; i<=8; i++)
    {
	// for k_start=13 to k_end=26
	LARrp[i] = add( (SHORT)(psi->OldLARrpp[i] >> 1), (SHORT)(LARrpp[i] >> 1) );
    }
    
    // computation of reflection coefficients rrp[1..8]
    Comprp(psi, LARrp, rrp);
    
    // short term synthesis filtering
    Compsr(psi, wt, rrp, 13, 26, sr);
    
    //
    // for k_start=27 to k_end=39
    //
	
    // interpolation of LARrpp[1..8] to get LARrp[1..8]
    for (i=1; i<=8; i++)
    {
	// for k_start=27 to k_end=39
	LARrp[i] = add( (SHORT)(psi->OldLARrpp[i] >> 2), (SHORT)(LARrpp[i] >> 2) );
	LARrp[i] = add( LARrp[i], (SHORT)(LARrpp[i] >> 1) );
    }
    
    // computation of reflection coefficients rrp[1..8]
    Comprp(psi, LARrp, rrp);
    
    // short term synthesis filtering
    Compsr(psi, wt, rrp, 27, 39, sr);
    
    //
    // for k_start=40 to k_end=159
    //
	
    // interpolation of LARrpp[1..8] to get LARrp[1..8]
    for (i=1; i<=8; i++)
    {
	// for k_start=40 to k_end=159
	LARrp[i] = LARrpp[i];
    }
    
    // computation of reflection coefficients rrp[1..8]
    Comprp(psi, LARrp, rrp);
    
    // short term synthesis filtering
    Compsr(psi, wt, rrp, 40, 159, sr);


    //	
    // update oldLARrpp[1..8]
    //
    for (i=1; i<=8; i++)
    {
	psi->OldLARrpp[i] = LARrpp[i];
    }
    
    
    return;
}


//---------------------------------------------------------------------
//
// decodePostproc()
//
//---------------------------------------------------------------------

void decodePostproc(PSTREAMINSTANCE psi, LPSHORT sr, LPSHORT srop)
{
    UINT k;
    
    // deemphasis filtering
    for (k=0; k<=159; k++)
    {
	srop[k] = psi->msr = add(sr[k], mult_r(psi->msr, 28180));

	// upscaling and truncation of the output signal
	srop[k] = (add(srop[k], srop[k])) & 0xFFF8;
    }
    
    return;
}


//---------------------------------------------------------------------
//
// Compsr()
//
//---------------------------------------------------------------------

void Compsr(PSTREAMINSTANCE psi, LPSHORT wt, LPSHORT rrp, UINT k_start, UINT k_end, LPSHORT sr)
{
    UINT    i, k;
    SHORT   sri;

    for (k=k_start; k<=k_end; k++)
    {
	sri = wt[k];
	for (i=1; i<=8; i++)
	{
	    sri = sub( sri, mult_r(rrp[9-i], psi->v[8-i]) );
	    psi->v[9-i] = add( psi->v[8-i], mult_r( rrp[9-i], sri ) );
	}
	sr[k] = sri;
	psi->v[0] = sri;
    }
    
    return;
}


//=====================================================================
//=====================================================================
//
//  Math and helper routines
//
//=====================================================================
//=====================================================================


//
// The 8-/16-bit PCM conversion routines are implemented as seperate
// functions to allow easy modification if we someday wish to do
// something more sophisticated that simple truncation...  They are
// prototyped as inline so there should be no performance penalty.
//
//
SHORT Convert8To16BitPCM(BYTE bPCM8)
{
    return  ( ((SHORT)bPCM8) - 0x80 ) << 8;
}

BYTE Convert16To8BitPCM(SHORT iPCM16)
{
    return (BYTE)((iPCM16 >> 8) + 0x80);
}

SHORT add(SHORT var1, SHORT var2)
{
    LONG sum;

    sum = (LONG) var1 + (LONG) var2;
    
    if (sum < -32768L) return -32768;
    if (sum > 32767L) return 32767;
    return (SHORT) sum;

}

SHORT sub(SHORT var1, SHORT var2)
{
    LONG diff;
    
    diff = (LONG) var1 - (LONG) var2;
    if (diff < -32768L) return -32768;
    if (diff > 32767L) return 32767;
    return (SHORT) diff;

}

SHORT mult(SHORT var1, SHORT var2)
{
    LONG product;

    product = (LONG) var1 * (LONG) var2;
    if (product >= 0x40000000) product=0x3FFFFFFF;
    return ( (SHORT) HIWORD((DWORD)(product<<1)) );
}

SHORT mult_r(SHORT var1, SHORT var2)
{
    LONG product;

    product = ((LONG) var1 * (LONG) var2) + 16384L;
    if (product >= 0x40000000) product=0x3FFFFFFF;
    return ( (SHORT) HIWORD((DWORD)(product<<1)) );
}

SHORT gabs(SHORT var1)
{
    if (var1 >= 0) return var1;
    if (var1 == -32768) return 32767;
    return -var1;
}

SHORT gdiv(SHORT num, SHORT denum)
{   
    UINT k;
    LONG l_num, l_denum;
    SHORT div;
    
    l_num = num;
    l_denum = denum;
    
    div = 0;

    for (k=0; k<15; k++)
    {
	div = div << 1;
	l_num = l_num << 1;
	if (l_num >= l_denum)
	{
	    l_num = l_sub(l_num, l_denum);
	    div = add(div,1);
	}
    }

    return div;
}
    
LONG l_mult(SHORT var1, SHORT var2)
{
    LONG product;
    
    product = (LONG) var1 * (LONG) var2;
    return product << 1;
}

LONG l_add(LONG l_var1, LONG l_var2)
{
    LONG l_sum;
    
    // perform long addition
    l_sum = l_var1 + l_var2;

    // check for under or overflow
    if (IsNeg(l_var1))
    {		     
	if (IsNeg(l_var2) && !IsNeg(l_sum))
	{
	    return 0x80000000;
	}
    }
    else
    {
	if (!IsNeg(l_var2) && IsNeg(l_sum))
	{
	    return 0x7FFFFFFF;
	}
    }
    
    return l_sum;
    
}

LONG l_sub(LONG l_var1, LONG l_var2)
{
    LONG l_diff;

    // perform subtraction
    l_diff = l_var1 - l_var2;

    // check for underflow
    if ( (l_var1<0) && (l_var2>0) && (l_diff>0) ) l_diff=0x80000000;
    // check for overflow
    if ( (l_var1>0) && (l_var2<0) && (l_diff<0) ) l_diff=0x7FFFFFFF;

    return l_diff;
}

SHORT norm(LONG l_var)
{
    UINT i;
    
    i=0;
    
    if (l_var > 0)
    {
	while (l_var < 1073741824)
	{
	    i++;
	    l_var = l_var << 1;
	}
    }
    else if (l_var < 0)
    {
	while (l_var > -1073741824)
	{
	    i++;
	    l_var = l_var << 1;
	}
    }

    return (SHORT)i;
}

LONG IsNeg(LONG x)
{
    return(x & 0x80000000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\imaadpcm\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "IMAADPCM"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\imaadpcm\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\imaadpcm\imaadpcm.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  imaadpcm.h
//
//  Description:
//      This file contains prototypes for the filtering routines.
//
//
//==========================================================================;

#ifndef _IMAADPCM_H_
#define _IMAADPCM_H_

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//
//
//
//
#define IMAADPCM_MAX_CHANNELS       2
#define IMAADPCM_BITS_PER_SAMPLE    4
#define IMAADPCM_WFX_EXTRA_BYTES    (sizeof(IMAADPCMWAVEFORMAT) - sizeof(WAVEFORMATEX))
#define IMAADPCM_HEADER_LENGTH      4    // In bytes, per channel.

#ifdef IMAADPCM_USECONFIG
#define IMAADPCM_CONFIGTESTTIME     4   // seconds of PCM data for test.
#define IMAADPCM_CONFIG_DEFAULT                             0x0000
#define IMAADPCM_CONFIG_DEFAULT_MAXRTENCODESETTING          5
#define IMAADPCM_CONFIG_DEFAULT_MAXRTDECODESETTING          6
#define IMAADPCM_CONFIG_UNCONFIGURED                        0x0999
#define IMAADPCM_CONFIG_DEFAULT_PERCENTCPU	        	    50
#define IMAADPCM_CONFIG_TEXTLEN                             80
#define IMAADPCM_CONFIG_DEFAULTKEY                          HKEY_CURRENT_USER
#endif


//
//  Conversion function prototypes.
//
DWORD FNGLOBAL imaadpcmDecode4Bit_M08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmDecode4Bit_M16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmDecode4Bit_S08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmDecode4Bit_S16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmEncode4Bit_M08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmEncode4Bit_M16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmEncode4Bit_S08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmEncode4Bit_S16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _IMAADPCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\imaadpcm\imaadpcm.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  imaadpcm.c
//
//  Description:
//      This file contains encode and decode routines for the IMA's ADPCM
//      format. This format is the same format used in Intel's DVI standard.
//      Intel has made this algorithm public domain and the IMA has endorsed
//      this format as a standard for audio compression.
//
//  Implementation notes:
//
//      A previous distribution of this codec used a data format which did
//      not comply with the IMA standard.  For stereo files, the interleaving
//      of left and right samples was incorrect:  the IMA standard requires
//      that a DWORD of left-channel data be followed by a DWORD of right-
//      channel data, but the previous implementation of this codec
//      interleaved the data at the byte level, with the 4 LSBs being the
//      left channel data and the 4 MSBs being the right channel data.
//      For mono files, each pair of samples was reversed:  the first sample
//      was stored in the 4 MSBs rather than the 4 LSBs.  This problem is
//      fixed during the current release.  Note: files compressed by the
//      old codec will sound distorted when played back with the new codec,
//      and vice versa.  Please recompress these files with the new codec,
//      since they do not conform to the standard and will not be reproduced
//      correctly by hardware codecs, etc.
//
//      A previous distribution of this codec had an implementation problem
//      which degraded the sound quality of the encoding.  This was due to
//      the fact that the step index was not properly maintained between
//      conversions.   This problem has been fixed in the current release.
//
//      The codec has been speeded up considerably by breaking
//      the encode and decode routines into four separate routines each:
//      mono 8-bit, mono 16-bit, stereo 8-bit, and stereo 16-bit.  This
//      approach is recommended for real-time conversion routines.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "codec.h"
#include "imaadpcm.h"

#include "debug.h"


//
//  This array is used by imaadpcmNextStepIndex to determine the next step
//  index to use.  The step index is an index to the step[] array, below.
//
const short next_step[16] =
{
    -1, -1, -1, -1, 2, 4, 6, 8,
    -1, -1, -1, -1, 2, 4, 6, 8
};

//
//  This array contains the array of step sizes used to encode the ADPCM
//  samples.  The step index in each ADPCM block is an index to this array.
//
const short step[89] =
{
        7,     8,     9,    10,    11,    12,    13,
       14,    16,    17,    19,    21,    23,    25,
       28,    31,    34,    37,    41,    45,    50,
       55,    60,    66,    73,    80,    88,    97,
      107,   118,   130,   143,   157,   173,   190,
      209,   230,   253,   279,   307,   337,   371,
      408,   449,   494,   544,   598,   658,   724,
      796,   876,   963,  1060,  1166,  1282,  1411,
     1552,  1707,  1878,  2066,  2272,  2499,  2749,
     3024,  3327,  3660,  4026,  4428,  4871,  5358,
     5894,  6484,  7132,  7845,  8630,  9493, 10442,
    11487, 12635, 13899, 15289, 16818, 18500, 20350,
    22385, 24623, 27086, 29794, 32767
};




#ifndef INLINE
    #define INLINE __inline
#endif



//--------------------------------------------------------------------------;
//  
//  DWORD pcmM08BytesToSamples
//  DWORD pcmM16BytesToSamples
//  DWORD pcmS08BytesToSamples
//  DWORD pcmS16BytesToSamples
//  
//  Description:
//      These functions return the number of samples in a buffer of PCM
//      of the specified format.  For efficiency, it is declared INLINE.
//      Note that, depending on the optimization flags, it may not
//      actually be implemented as INLINE.  Optimizing for speed (-Oxwt)
//      will generally obey the INLINE specification.
//  
//  Arguments:
//      DWORD cb: The length of the buffer, in bytes.
//  
//  Return (DWORD):  The length of the buffer in samples.
//  
//--------------------------------------------------------------------------;

INLINE DWORD pcmM08BytesToSamples(
    DWORD cb
)
{
    return cb;
}

INLINE DWORD pcmM16BytesToSamples(
    DWORD cb
)
{
    return cb / ((DWORD)2);
}

INLINE DWORD pcmS08BytesToSamples(
    DWORD cb
)
{
    return cb / ((DWORD)2);
}

INLINE DWORD pcmS16BytesToSamples(
    DWORD cb
)
{
    return cb / ((DWORD)4);
}



#ifdef WIN32
//
// This code assumes that the integer nPredictedSample is 32-bits wide!!!
//
// The following define replaces the pair of calls to the inline functions
// imaadpcmSampleEncode() and imaadpcmSampleDecode which are called in the
// encode routines.  There is some redundancy between them which is exploited
// in this define.  Because there are two returns (nEncodedSample and
// nPredictedSample), it is more efficient to use a #define rather than an
// inline function which would require a pointer to one of the returns.
// 
// Basically, nPredictedSample is calculated based on the lDifference value
// already there, rather than regenerating it through imaadpcmSampleDecode().
//
#define imaadpcmFastEncode(nEncodedSample,nPredictedSample,nInputSample,nStepSize) \
{                                                                       \
    LONG            lDifference;                                        \
                                                                        \
    lDifference = nInputSample - nPredictedSample;                      \
    nEncodedSample = 0;                                                 \
    if( lDifference<0 ) {                                               \
        nEncodedSample = 8;                                             \
        lDifference = -lDifference;                                     \
    }                                                                   \
                                                                        \
    if( lDifference >= nStepSize ) {                                    \
        nEncodedSample |= 4;                                            \
        lDifference -= nStepSize;                                       \
    }                                                                   \
                                                                        \
    nStepSize >>= 1;                                                    \
    if( lDifference >= nStepSize ) {                                    \
        nEncodedSample |= 2;                                            \
        lDifference -= nStepSize;                                       \
    }                                                                   \
                                                                        \
    nStepSize >>= 1;                                                    \
    if( lDifference >= nStepSize ) {                                    \
        nEncodedSample |= 1;                                            \
        lDifference -= nStepSize;                                       \
    }                                                                   \
                                                                        \
    if( nEncodedSample & 8 )                                            \
        nPredictedSample = nInputSample + lDifference - (nStepSize>>1); \
    else                                                                \
        nPredictedSample = nInputSample - lDifference + (nStepSize>>1); \
                                                                        \
    if( nPredictedSample > 32767 )                                      \
        nPredictedSample = 32767;                                       \
    else if( nPredictedSample < -32768 )                                \
        nPredictedSample = -32768;                                      \
}

#else

//--------------------------------------------------------------------------;
//  
//  int imaadpcmSampleEncode
//  
//  Description:
//      This routine encodes a single ADPCM sample.  For efficiency, it is
//      declared INLINE.  Note that, depending on the optimization flags,
//      it may not actually be implemented as INLINE.  Optimizing for speed
//      (-Oxwt) will generally obey the INLINE specification.
//  
//  Arguments:
//      int nInputSample:  The sample to be encoded.
//      int nPredictedSample:  The predicted value of nInputSample.
//      int nStepSize:  The quantization step size for the difference between
//                      nInputSample and nPredictedSample.
//  
//  Return (int):  The 4-bit ADPCM encoded sample, which corresponds to the
//                  quantized difference value.
//  
//--------------------------------------------------------------------------;

INLINE int imaadpcmSampleEncode
(
    int                 nInputSample,
    int                 nPredictedSample,
    int                 nStepSize
)
{
    LONG            lDifference;    // difference may require 17 bits!
    int             nEncodedSample;


    //
    //  set sign bit (bit 3 of the encoded sample) based on sign of the
    //  difference (nInputSample-nPredictedSample).  Note that we want the
    //  absolute value of the difference for the subsequent quantization.
    //
    lDifference = nInputSample - nPredictedSample;
    nEncodedSample = 0;
    if( lDifference<0 ) {
        nEncodedSample = 8;
        lDifference = -lDifference;
    }

    //
    //  quantize lDifference sample
    //
    if( lDifference >= nStepSize ) {        // Bit 2.
        nEncodedSample |= 4;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;
    if( lDifference >= nStepSize ) {        // Bit 1.
        nEncodedSample |= 2;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;
    if( lDifference >= nStepSize ) {     // Bit 0.
        nEncodedSample |= 1;
    }

    return (nEncodedSample);
}

#endif


//--------------------------------------------------------------------------;
//  
//  int imaadpcmSampleDecode
//  
//  Description:
//      This routine decodes a single ADPCM sample.  For efficiency, it is
//      declared INLINE.  Note that, depending on the optimization flags,
//      it may not actually be implemented as INLINE.  Optimizing for speed
//      (-Oxwt) will generally obey the INLINE specification.
//  
//  Arguments:
//      int nEncodedSample:  The sample to be decoded.
//      int nPredictedSample:  The predicted value of the sample (in PCM).
//      int nStepSize:  The quantization step size used to encode the sample.
//  
//  Return (int):  The decoded PCM sample.
//  
//--------------------------------------------------------------------------;

INLINE int imaadpcmSampleDecode
(
    int                 nEncodedSample,
    int                 nPredictedSample,
    int                 nStepSize
)
{
    LONG            lDifference;
    LONG            lNewSample;

    //
    //  calculate difference:
    //
    //      lDifference = (nEncodedSample + 1/2) * nStepSize / 4
    //
    lDifference = nStepSize>>3;

    if (nEncodedSample & 4) 
        lDifference += nStepSize;

    if (nEncodedSample & 2) 
        lDifference += nStepSize>>1;

    if (nEncodedSample & 1) 
        lDifference += nStepSize>>2;

    //
    //  If the 'sign bit' of the encoded nibble is set, then the
    //  difference is negative...
    //
    if (nEncodedSample & 8)
        lDifference = -lDifference;

    //
    //  adjust predicted sample based on calculated difference
    //
    lNewSample = nPredictedSample + lDifference;

    //
    //  check for overflow and clamp if necessary to a 16 signed sample.
    //  Note that this is optimized for the most common case, when we
    //  don't have to clamp.
    //
    if( (long)(short)lNewSample == lNewSample )
    {
        return (int)lNewSample;
    }

    //
    //  Clamp.
    //
    if( lNewSample < -32768 )
        return (int)-32768;
    else
        return (int)32767;
}


//--------------------------------------------------------------------------;
//  
//  int imaadpcmNextStepIndex
//  
//  Description:
//      This routine calculates the step index value to use for the next
//      encode, based on the current value of the step index and the current
//      encoded sample.  For efficiency, it is declared INLINE.  Note that,
//      depending on the optimization flags, it may not actually be 
//      implemented as INLINE.  Optimizing for speed (-Oxwt) will generally 
//      obey the INLINE specification.
//  
//  Arguments:
//      int nEncodedSample:  The current encoded ADPCM sample.
//      int nStepIndex:  The step index value used to encode nEncodedSample.
//  
//  Return (int):  The step index to use for the next sample.
//  
//--------------------------------------------------------------------------;

INLINE int imaadpcmNextStepIndex
(
    int                     nEncodedSample,
    int                     nStepIndex
)
{
    //
    //  compute new stepsize step
    //
    nStepIndex += next_step[nEncodedSample];

    if (nStepIndex < 0)
        nStepIndex = 0;
    else if (nStepIndex > 88)
        nStepIndex = 88;

    return (nStepIndex);
}



//--------------------------------------------------------------------------;
//  
//  BOOL imaadpcmValidStepIndex
//  
//  Description:
//      This routine checks the step index value to make sure that it is
//      within the legal range.
//  
//  Arguments:
//      
//      int nStepIndex:  The step index value.
//  
//  Return (BOOL):  TRUE if the step index is valid; FALSE otherwise.
//  
//--------------------------------------------------------------------------;

INLINE BOOL imaadpcmValidStepIndex
(
    int                     nStepIndex
)
{

    if( nStepIndex >= 0 && nStepIndex <= 88 )
        return TRUE;
    else
        return FALSE;
}



//==========================================================================;
//
//      DECODE ROUTINES
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  DWORD imaadpcmDecode4Bit_M08
//  DWORD imaadpcmDecode4Bit_M16
//  DWORD imaadpcmDecode4Bit_S08
//  DWORD imaadpcmDecode4Bit_S16
//  
//  Description:
//      These functions decode a buffer of data from ADPCM to PCM in the
//      specified format.  The appropriate function is called once for each
//      ACMDM_STREAM_CONVERT message received.  Note that since these
//      functions must share the same prototype as the encoding functions
//      (see acmdStreamOpen() and acmdStreamConvert() in codec.c for more
//      details), not all the parameters are used by these routines.
//  
//  Arguments:
//      HPBYTE pbSrc:  Pointer to the source buffer (ADPCM data).
//      DWORD cbSrcLength:  The length of the source buffer (in bytes).
//      HPBYTE pbDst:  Pointer to the destination buffer (PCM data).  Note
//                      that it is assumed that the destination buffer is
//                      large enough to hold all the encoded data; see
//                      acmdStreamSize() in codec.c for more details.
//      UINT nBlockAlignment:  The block alignment of the ADPCM data (in
//                      bytes).
//      UINT cSamplesPerBlock:  The number of samples in each ADPCM block;
//                      not used for decoding.
//      int *pnStepIndexL:  Pointer to the step index value (left channel)
//                      in the STREAMINSTANCE structure; not used for
//                      decoding.
//      int *pnStepIndexR:  Pointer to the step index value (right channel)
//                      in the STREAMINSTANCE structure; not used for
//                      decoding.
//  
//  Return (DWORD):  The number of bytes used in the destination buffer.
//  
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmDecode4Bit_M08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    UINT                    cbHeader;
    UINT                    cbBlockLength;
    BYTE                    bSample;
    int                     nStepSize;

    int                     nEncSample;
    int                     nPredSample;
    int                     nStepIndex;

    
    pbDstStart = pbDst;
    cbHeader = IMAADPCM_HEADER_LENGTH * 1;  //  1 = number of channels.


    DPF(3,"Starting imaadpcmDecode4Bit_M08().");


    //
    //
    //
    while (cbSrcLength >= cbHeader)
    {
        DWORD       dwHeader;

        cbBlockLength  = (UINT)min(cbSrcLength, nBlockAlignment);
        cbSrcLength   -= cbBlockLength;
        cbBlockLength -= cbHeader;

        //
        //  block header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSample = (int)(short)LOWORD(dwHeader);
        nStepIndex  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndex) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_M08: invalid step index.");
            return 0;
        }
        

        //
        //  write out first sample
        //
        *pbDst++ = (BYTE)((nPredSample >> 8) + 128);


        //
        //
        //
        while (cbBlockLength--)
        {
            bSample = *pbSrc++;

            //
            //  sample 1
            //
            nEncSample  = (bSample & (BYTE)0x0F);
            nStepSize   = step[nStepIndex];
            nPredSample = imaadpcmSampleDecode(nEncSample, nPredSample, nStepSize);
            nStepIndex  = imaadpcmNextStepIndex(nEncSample, nStepIndex);

            //
            //  write out sample
            //
            *pbDst++ = (BYTE)((nPredSample >> 8) + 128);

            //
            //  sample 2
            //
            nEncSample  = (bSample >> 4);
            nStepSize   = step[nStepIndex];
            nPredSample = imaadpcmSampleDecode(nEncSample, nPredSample, nStepSize);
            nStepIndex  = imaadpcmNextStepIndex(nEncSample, nStepIndex);

            //
            //  write out sample
            //
            *pbDst++ = (BYTE)((nPredSample >> 8) + 128);
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmDecode4Bit_M08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmDecode4Bit_M16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    UINT                    cbHeader;
    UINT                    cbBlockLength;
    BYTE                    bSample;
    int                     nStepSize;

    int                     nEncSample;
    int                     nPredSample;
    int                     nStepIndex;

    
    pbDstStart = pbDst;
    cbHeader = IMAADPCM_HEADER_LENGTH * 1;  //  1 = number of channels.


    DPF(3,"Starting imaadpcmDecode4Bit_M16().");


    //
    //
    //
    while (cbSrcLength >= cbHeader)
    {
        DWORD       dwHeader;

        cbBlockLength  = (UINT)min(cbSrcLength, nBlockAlignment);
        cbSrcLength   -= cbBlockLength;
        cbBlockLength -= cbHeader;

        //
        //  block header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSample = (int)(short)LOWORD(dwHeader);
        nStepIndex  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndex) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_M16: invalid step index.");
            return 0;
        }
        

        //
        //  write out first sample
        //
        *(short HUGE_T *)pbDst = (short)nPredSample;
        pbDst += sizeof(short);


        //
        //
        //
        while (cbBlockLength--)
        {
            bSample = *pbSrc++;

            //
            //  sample 1
            //
            nEncSample  = (bSample & (BYTE)0x0F);
            nStepSize   = step[nStepIndex];
            nPredSample = imaadpcmSampleDecode(nEncSample, nPredSample, nStepSize);
            nStepIndex  = imaadpcmNextStepIndex(nEncSample, nStepIndex);

            //
            //  write out sample
            //
            *(short HUGE_T *)pbDst = (short)nPredSample;
            pbDst += sizeof(short);

            //
            //  sample 2
            //
            nEncSample  = (bSample >> 4);
            nStepSize   = step[nStepIndex];
            nPredSample = imaadpcmSampleDecode(nEncSample, nPredSample, nStepSize);
            nStepIndex  = imaadpcmNextStepIndex(nEncSample, nStepIndex);

            //
            //  write out sample
            //
            *(short HUGE_T *)pbDst = (short)nPredSample;
            pbDst += sizeof(short);
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmDecode4Bit_M16()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmDecode4Bit_S08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    UINT                    cbHeader;
    UINT                    cbBlockLength;
    int                     nStepSize;
    DWORD                   dwHeader;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     i;

    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;

    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;

    
    pbDstStart = pbDst;
    cbHeader = IMAADPCM_HEADER_LENGTH * 2;  //  2 = number of channels.


    DPF(3,"Starting imaadpcmDecode4Bit_S08().");


    //
    //
    //
    while( 0 != cbSrcLength )
    {
        //
        //  The data should always be block aligned.
        //
        ASSERT( cbSrcLength >= nBlockAlignment );

        cbBlockLength  = nBlockAlignment;
        cbSrcLength   -= cbBlockLength;
        cbBlockLength -= cbHeader;


        //
        //  LEFT channel header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSampleL = (int)(short)LOWORD(dwHeader);
        nStepIndexL  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndexL) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_S08: invalid step index (L).");
            return 0;
        }
        
        //
        //  RIGHT channel header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSampleR = (int)(short)LOWORD(dwHeader);
        nStepIndexR  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndexR) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_S08: invalid step index (R).");
            return 0;
        }
        

        //
        //  write out first sample
        //
        *pbDst++ = (BYTE)((nPredSampleL >> 8) + 128);
        *pbDst++ = (BYTE)((nPredSampleR >> 8) + 128);


        //
        //  The first DWORD contains 4 left samples, the second DWORD
        //  contains 4 right samples.  We process the source in 8-byte
        //  chunks to make it easy to interleave the output correctly.
        //
        ASSERT( 0 == cbBlockLength%8 );
        while( 0 != cbBlockLength )
        {
            cbBlockLength -= 8;

            dwLeft   = *(DWORD HUGE_T *)pbSrc;
            pbSrc   += sizeof(DWORD);
            dwRight  = *(DWORD HUGE_T *)pbSrc;
            pbSrc   += sizeof(DWORD);

            for( i=8; i>0; i-- )
            {
                //
                //  LEFT channel
                //
                nEncSampleL  = (dwLeft & 0x0F);
                nStepSize    = step[nStepIndexL];
                nPredSampleL = imaadpcmSampleDecode(nEncSampleL, nPredSampleL, nStepSize);
                nStepIndexL  = imaadpcmNextStepIndex(nEncSampleL, nStepIndexL);

                //
                //  RIGHT channel
                //
                nEncSampleR  = (dwRight & 0x0F);
                nStepSize    = step[nStepIndexR];
                nPredSampleR = imaadpcmSampleDecode(nEncSampleR, nPredSampleR, nStepSize);
                nStepIndexR  = imaadpcmNextStepIndex(nEncSampleR, nStepIndexR);

                //
                //  write out sample
                //
                *pbDst++ = (BYTE)((nPredSampleL >> 8) + 128);
                *pbDst++ = (BYTE)((nPredSampleR >> 8) + 128);

                //
                //  Shift the next input sample into the low-order 4 bits.
                //
                dwLeft  >>= 4;
                dwRight >>= 4;
            }
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmDecode4Bit_S08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmDecode4Bit_S16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    UINT                    cbHeader;
    UINT                    cbBlockLength;
    int                     nStepSize;
    DWORD                   dwHeader;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     i;

    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;

    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;

    
    pbDstStart = pbDst;
    cbHeader = IMAADPCM_HEADER_LENGTH * 2;  //  2 = number of channels.


    DPF(3,"Starting imaadpcmDecode4Bit_S16().");


    //
    //
    //
    while( 0 != cbSrcLength )
    {
        //
        //  The data should always be block aligned.
        //
        ASSERT( cbSrcLength >= nBlockAlignment );

        cbBlockLength  = nBlockAlignment;
        cbSrcLength   -= cbBlockLength;
        cbBlockLength -= cbHeader;


        //
        //  LEFT channel header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSampleL = (int)(short)LOWORD(dwHeader);
        nStepIndexL  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndexL) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_S16: invalid step index %u (L).", nStepIndexL);
            return 0;
        }
        
        //
        //  RIGHT channel header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSampleR = (int)(short)LOWORD(dwHeader);
        nStepIndexR  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndexR) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_S16: invalid step index %u (R).",nStepIndexR);
            return 0;
        }
        

        //
        //  write out first sample
        //
        *(DWORD HUGE_T *)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
        pbDst += sizeof(DWORD);


        //
        //  The first DWORD contains 4 left samples, the second DWORD
        //  contains 4 right samples.  We process the source in 8-byte
        //  chunks to make it easy to interleave the output correctly.
        //
        ASSERT( 0 == cbBlockLength%8 );
        while( 0 != cbBlockLength )
        {
            cbBlockLength -= 8;

            dwLeft   = *(DWORD HUGE_T *)pbSrc;
            pbSrc   += sizeof(DWORD);
            dwRight  = *(DWORD HUGE_T *)pbSrc;
            pbSrc   += sizeof(DWORD);

            for( i=8; i>0; i-- )
            {
                //
                //  LEFT channel
                //
                nEncSampleL  = (dwLeft & 0x0F);
                nStepSize    = step[nStepIndexL];
                nPredSampleL = imaadpcmSampleDecode(nEncSampleL, nPredSampleL, nStepSize);
                nStepIndexL  = imaadpcmNextStepIndex(nEncSampleL, nStepIndexL);

                //
                //  RIGHT channel
                //
                nEncSampleR  = (dwRight & 0x0F);
                nStepSize    = step[nStepIndexR];
                nPredSampleR = imaadpcmSampleDecode(nEncSampleR, nPredSampleR, nStepSize);
                nStepIndexR  = imaadpcmNextStepIndex(nEncSampleR, nStepIndexR);

                //
                //  write out sample
                //
                *(DWORD HUGE_T *)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
                pbDst += sizeof(DWORD);

                //
                //  Shift the next input sample into the low-order 4 bits.
                //
                dwLeft  >>= 4;
                dwRight >>= 4;
            }
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmDecode4Bit_S16()



//==========================================================================;
//
//     ENCODE ROUTINES
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  DWORD imaadpcmEncode4Bit_M08
//  DWORD imaadpcmEncode4Bit_M16
//  DWORD imaadpcmEncode4Bit_S08
//  DWORD imaadpcmEncode4Bit_S16
//  
//  Description:
//      These functions encode a buffer of data from PCM to ADPCM in the
//      specified format.  The appropriate function is called once for each
//      ACMDM_STREAM_CONVERT message received.  Note that since these
//      functions must share the same prototype as the decoding functions
//      (see acmdStreamOpen() and acmdStreamConvert() in codec.c for more
//      details), not all the parameters are used by these routines.
//  
//  Arguments:
//      HPBYTE pbSrc:  Pointer to the source buffer (PCM data).
//      DWORD cbSrcLength:  The length of the source buffer (in bytes).
//      HPBYTE pbDst:  Pointer to the destination buffer (ADPCM data).  Note
//                      that it is assumed that the destination buffer is
//                      large enough to hold all the encoded data; see
//                      acmdStreamSize() in codec.c for more details.
//      UINT nBlockAlignment:  The block alignment of the ADPCM data (in
//                      bytes);  not used for encoding.
//      UINT cSamplesPerBlock:  The number of samples in each ADPCM block.
//      int *pnStepIndexL:  Pointer to the step index value (left channel)
//                      in the STREAMINSTANCE structure; this is used to
//                      maintain the step index across converts.
//      int *pnStepIndexR:  Pointer to the step index value (right channel)
//                      in the STREAMINSTANCE structure; this is used to 
//                      maintain the step index across converts.  It is only
//                      used for stereo converts.
//  
//  Return (DWORD):  The number of bytes used in the destination buffer.
//  
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmEncode4Bit_M08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    DWORD                   cSrcSamples;
    UINT                    cBlockSamples;
    int                     nSample;
    int                     nStepSize;

    int                     nEncSample1;
    int                     nEncSample2;
    int                     nPredSample;
    int                     nStepIndex;


    pbDstStart = pbDst;
    cSrcSamples = pcmM08BytesToSamples(cbSrcLength);

    //
    //  Restore the Step Index to that of the final convert of the previous
    //  buffer.  Remember to restore this value to psi->nStepIndexL.
    //
    nStepIndex = (*pnStepIndexL);


    //
    //
    //
    //
    while (0 != cSrcSamples)
    {
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;

        //
        //  block header
        //
        nPredSample = ((short)*pbSrc++ - 128) << 8;
        cBlockSamples--;

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSample, nStepIndex);
        pbDst += sizeof(LONG);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).  Note
        //  that if we don't have enough data to fill a complete byte, then
        //  we add a 0 nibble on the end.
        //
        while( cBlockSamples>0 )
        {
            //
            //  sample 1
            //
            nSample = ((short)*pbSrc++ - 128) << 8;
            cBlockSamples--;

            nStepSize    = step[nStepIndex];
            imaadpcmFastEncode(nEncSample1,nPredSample,nSample,nStepSize);
            nStepIndex   = imaadpcmNextStepIndex(nEncSample1, nStepIndex);

            //
            //  sample 2
            //
            nEncSample2  = 0;
            if( cBlockSamples>0 ) {

                nSample = ((short)*pbSrc++ - 128) << 8;
                cBlockSamples--;

                nStepSize    = step[nStepIndex];
                imaadpcmFastEncode(nEncSample2,nPredSample,nSample,nStepSize);
                nStepIndex   = imaadpcmNextStepIndex(nEncSample2, nStepIndex);
            }

            //
            //  Write out encoded byte.
            //
            *pbDst++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));
        }
    }


    //
    //  Restore the value of the Step Index, to be used on the next buffer.
    //
    (*pnStepIndexL) = nStepIndex;


    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmEncode4Bit_M08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmEncode4Bit_M16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    DWORD                   cSrcSamples;
    UINT                    cBlockSamples;
    int                     nSample;
    int                     nStepSize;

    int                     nEncSample1;
    int                     nEncSample2;
    int                     nPredSample;
    int                     nStepIndex;


    pbDstStart = pbDst;
    cSrcSamples = pcmM16BytesToSamples(cbSrcLength);

    //
    //  Restore the Step Index to that of the final convert of the previous
    //  buffer.  Remember to restore this value to psi->nStepIndexL.
    //
    nStepIndex = (*pnStepIndexL);


    //
    //
    //
    //
    while (0 != cSrcSamples)
    {
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;

        //
        //  block header
        //
        nPredSample = *(short HUGE_T *)pbSrc;
        pbSrc += sizeof(short);
        cBlockSamples--;

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSample, nStepIndex);
        pbDst += sizeof(LONG);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).  Note
        //  that if we don't have enough data to fill a complete byte, then
        //  we add a 0 nibble on the end.
        //
        while( cBlockSamples>0 )
        {
            //
            //  sample 1
            //
            nSample = *(short HUGE_T *)pbSrc;
            pbSrc  += sizeof(short);
            cBlockSamples--;

            nStepSize    = step[nStepIndex];
            imaadpcmFastEncode(nEncSample1,nPredSample,nSample,nStepSize);
            nStepIndex   = imaadpcmNextStepIndex(nEncSample1, nStepIndex);

            //
            //  sample 2
            //
            nEncSample2  = 0;
            if( cBlockSamples>0 ) {

                nSample = *(short HUGE_T *)pbSrc;
                pbSrc  += sizeof(short);
                cBlockSamples--;

                nStepSize    = step[nStepIndex];
                imaadpcmFastEncode(nEncSample2,nPredSample,nSample,nStepSize);
                nStepIndex   = imaadpcmNextStepIndex(nEncSample2, nStepIndex);
            }

            //
            //  Write out encoded byte.
            //
            *pbDst++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));
        }
    }


    //
    //  Restore the value of the Step Index, to be used on the next buffer.
    //
    (*pnStepIndexL) = nStepIndex;


    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmEncode4Bit_M16()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmEncode4Bit_S08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    DWORD                   cSrcSamples;
    UINT                    cBlockSamples;
    int                     nSample;
    int                     nStepSize;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     i;

    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;

    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;


    pbDstStart = pbDst;
    cSrcSamples = pcmS08BytesToSamples(cbSrcLength);

    //
    //  Restore the Step Index to that of the final convert of the previous
    //  buffer.  Remember to restore this value to psi->nStepIndexL,R.
    //
    nStepIndexL = (*pnStepIndexL);
    nStepIndexR = (*pnStepIndexR);


    //
    //
    //
    //
    while( 0 != cSrcSamples )
    {
        //
        //  The samples should always be block aligned.
        //
        ASSERT( cSrcSamples >= cSamplesPerBlock );

        cBlockSamples = cSamplesPerBlock;
        cSrcSamples  -= cBlockSamples;

        //
        //  LEFT channel block header
        //
        nPredSampleL = ((short)*pbSrc++ - 128) << 8;

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSampleL, nStepIndexL);
        pbDst += sizeof(LONG);

        //
        //  RIGHT channel block header
        //
        nPredSampleR = ((short)*pbSrc++ - 128) << 8;

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSampleR, nStepIndexR);
        pbDst += sizeof(LONG);


        cBlockSamples--;  // One sample is in the header.


        //
        //  We have written the header for this block--now write the data
        //  chunk.  This consists of 8 left samples (one DWORD of output)
        //  followed by 8 right samples (also one DWORD).  Since the input
        //  samples are interleaved, we create the left and right DWORDs
        //  sample by sample, and then write them both out.
        //
        ASSERT( 0 == cBlockSamples%8 );
        while( 0 != cBlockSamples )
        {
            cBlockSamples -= 8;
            dwLeft  = 0;
            dwRight = 0;

            for( i=0; i<8; i++ )
            {
                //
                //  LEFT channel
                //
                nSample     = ((short)*pbSrc++ - 128) << 8;
                nStepSize   = step[nStepIndexL];
                imaadpcmFastEncode(nEncSampleL,nPredSampleL,nSample,nStepSize);
                nStepIndexL = imaadpcmNextStepIndex(nEncSampleL, nStepIndexL);
                dwLeft     |= ((DWORD)nEncSampleL) << 4*i;

                //
                //  RIGHT channel
                //
                nSample     = ((short)*pbSrc++ - 128) << 8;
                nStepSize   = step[nStepIndexR];
                imaadpcmFastEncode(nEncSampleR,nPredSampleR,nSample,nStepSize);
                nStepIndexR = imaadpcmNextStepIndex(nEncSampleR, nStepIndexR);
                dwRight    |= ((DWORD)nEncSampleR) << 4*i;
            }


            //
            //  Write out encoded DWORDs.
            //
            *(DWORD HUGE_T *)pbDst = dwLeft;
            pbDst += sizeof(DWORD);
            *(DWORD HUGE_T *)pbDst = dwRight;
            pbDst += sizeof(DWORD);
        }
    }


    //
    //  Restore the value of the Step Index, to be used on the next buffer.
    //
    (*pnStepIndexL) = nStepIndexL;
    (*pnStepIndexR) = nStepIndexR;


    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmEncode4Bit_S08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmEncode4Bit_S16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    DWORD                   cSrcSamples;
    UINT                    cBlockSamples;
    int                     nSample;
    int                     nStepSize;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     i;

    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;

    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;


    pbDstStart = pbDst;
    cSrcSamples = pcmS16BytesToSamples(cbSrcLength);

    //
    //  Restore the Step Index to that of the final convert of the previous
    //  buffer.  Remember to restore this value to psi->nStepIndexL,R.
    //
    nStepIndexL = (*pnStepIndexL);
    nStepIndexR = (*pnStepIndexR);


    //
    //
    //
    //
    while( 0 != cSrcSamples )
    {
        //
        //  The samples should always be block aligned.
        //
        ASSERT( cSrcSamples >= cSamplesPerBlock );

        cBlockSamples = cSamplesPerBlock;
        cSrcSamples  -= cBlockSamples;


        //
        //  LEFT channel block header
        //
        nPredSampleL = *(short HUGE_T *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSampleL, nStepIndexL);
        pbDst += sizeof(LONG);

        //
        //  RIGHT channel block header
        //
        nPredSampleR = *(short HUGE_T *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSampleR, nStepIndexR);
        pbDst += sizeof(LONG);


        cBlockSamples--;  // One sample is in the header.


        //
        //  We have written the header for this block--now write the data
        //  chunk.  This consists of 8 left samples (one DWORD of output)
        //  followed by 8 right samples (also one DWORD).  Since the input
        //  samples are interleaved, we create the left and right DWORDs
        //  sample by sample, and then write them both out.
        //
        ASSERT( 0 == cBlockSamples%8 );
        while( 0 != cBlockSamples )
        {
            cBlockSamples -= 8;
            dwLeft  = 0;
            dwRight = 0;

            for( i=0; i<8; i++ )
            {
                //
                //  LEFT channel
                //
                nSample = *(short HUGE_T *)pbSrc;
                pbSrc  += sizeof(short);

                nStepSize   = step[nStepIndexL];
                imaadpcmFastEncode(nEncSampleL,nPredSampleL,nSample,nStepSize);
                nStepIndexL = imaadpcmNextStepIndex(nEncSampleL, nStepIndexL);
                dwLeft     |= ((DWORD)nEncSampleL) << 4*i;

                //
                //  RIGHT channel
                //
                nSample = *(short HUGE_T *)pbSrc;
                pbSrc  += sizeof(short);

                nStepSize   = step[nStepIndexR];
                imaadpcmFastEncode(nEncSampleR,nPredSampleR,nSample,nStepSize);
                nStepIndexR = imaadpcmNextStepIndex(nEncSampleR, nStepIndexR);
                dwRight    |= ((DWORD)nEncSampleR) << 4*i;
            }


            //
            //  Write out encoded DWORDs.
            //
            *(DWORD HUGE_T *)pbDst = dwLeft;
            pbDst += sizeof(DWORD);
            *(DWORD HUGE_T *)pbDst = dwRight;
            pbDst += sizeof(DWORD);
        }
    }


    //
    //  Restore the value of the Step Index, to be used on the next buffer.
    //
    (*pnStepIndexL) = nStepIndexL;
    (*pnStepIndexR) = nStepIndexR;


    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmEncode4Bit_S16()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\acmi.h ===
//==========================================================================;
//
//  acmi.h
//
//  Copyright (c) 1991-1999 Microsoft Corporation
//
//  Description:
//      Internal Audio Compression Manager header file. Defines internal
//      data structures and things not needed outside of the ACM itself.
//
//  History:
//
//==========================================================================;


#ifndef _INC_ACMI
#define _INC_ACMI       /* #defined if acmi.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */


#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
//
//
#ifdef DEBUG
    #define RDEBUG
#endif

#ifndef MMREVISION
#include <verinfo.h>
#endif

#ifdef WIN32
#include "locks.h"
#endif

//
//  If we're in Daytona, manually initialize friendly name stuff into
//  HKCU.
//
#if defined(WIN32) && !defined(WIN4)
#define USEINITFRIENDLYNAMES
#endif

//
//
//
//
#if defined(NTWOW)
//  Version number needs to be updated every product cycle!!
#define VERSION_MSACM_MAJOR     4
#define VERSION_MSACM_MINOR     00
#define VERSION_MSACM_MINOR_REQ 00
#else
#define VERSION_MSACM_MAJOR     MMVERSION
#define VERSION_MSACM_MINOR     MMREVISION
#endif

//
//  make build number returned only in _[retail] debug_ version
//
#ifdef RDEBUG
#define VERSION_MSACM_BUILD     MMRELEASE
#else
#define VERSION_MSACM_BUILD     0
#endif

#define VERSION_MSACM           MAKE_ACM_VERSION(VERSION_MSACM_MAJOR,   \
						 VERSION_MSACM_MINOR,   \
						 VERSION_MSACM_BUILD)

// The version of ACM the builtin PCM codec requires
#define VERSION_MSACM_REQ       MAKE_ACM_VERSION(3,50,0)


//
//
//
#ifndef SIZEOF_WAVEFORMATEX
#define SIZEOF_WAVEFORMATEX(pwfx)   ((WAVE_FORMAT_PCM==(pwfx)->wFormatTag)?sizeof(PCMWAVEFORMAT):(sizeof(WAVEFORMATEX)+(pwfx)->cbSize))
#endif

#ifdef WIN32
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  When compiling msacm for WIN32, define all functions as unicode.
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#undef acmDriverAdd

#undef acmDriverDetails

#undef acmFormatTagDetails

#undef ACMFORMATTAGENUMCB
#undef acmFormatTagEnum

#undef acmFormatDetails

#undef ACMFORMATENUMCB
#undef acmFormatEnum

#undef ACMFORMATCHOOSEHOOKPROC

#undef acmFormatChoose

#undef acmFilterTagDetails

#undef ACMFILTERTAGENUMCB
#undef acmFilterTagEnum

#undef acmFilterDetails

#undef ACMFILTERENUMCB
#undef acmFilterEnum

#undef ACMFILTERCHOOSEHOOKPROC

#undef acmFilterChoose

#define acmDriverAdd                acmDriverAddW

#define acmDriverDetails            acmDriverDetailsW

#define acmFormatTagDetails         acmFormatTagDetailsW

#define ACMFORMATTAGENUMCB          ACMFORMATTAGENUMCBW
#define acmFormatTagEnum            acmFormatTagEnumW

#define acmFormatDetails            acmFormatDetailsW

#define ACMFORMATENUMCB             ACMFORMATENUMCBW
#define acmFormatEnum               acmFormatEnumW

#define ACMFORMATCHOOSEHOOKPROC     ACMFORMATCHOOSEHOOKPROCW

#define acmFormatChoose             acmFormatChooseW

#define acmFilterTagDetails         acmFilterTagDetailsW

#define ACMFILTERTAGENUMCB          ACMFILTERTAGENUMCBW
#define acmFilterTagEnum            acmFilterTagEnumW

#define acmFilterDetails            acmFilterDetailsW

#define ACMFILTERENUMCB             ACMFILTERENUMCBW
#define acmFilterEnum               acmFilterEnumW

#define ACMFILTERCHOOSEHOOKPROC     ACMFILTERCHOOSEHOOKPROCW

#define acmFilterChoose             acmFilterChooseW

#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#ifdef WIN32
    #ifndef FNLOCAL
	#define FNLOCAL     _stdcall
	#define FNCLOCAL    _stdcall
	#define FNGLOBAL    _stdcall
	#define FNCGLOBAL   _stdcall
	#define FNWCALLBACK CALLBACK
	#define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE                   CONST

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
	((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    //
    //  for compiling Unicode
    //
    #define SIZEOFW(x) (sizeof(x)/sizeof(WCHAR))
    #define SIZEOFA(x) (sizeof(x))
    #ifdef UNICODE
	#define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
	#define SIZEOF(x)   sizeof(x)
    #endif

    #define GetCurrentTask()  (HTASK)ULongToPtr(GetCurrentThreadId())

    //
    //  we need to try to quit using this if possible...
    //
    void WINAPI DirectedYield(HTASK);
#endif // #ifdef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
	#define FNLOCAL     NEAR PASCAL
	#define FNCLOCAL    NEAR _cdecl
	#define FNGLOBAL    FAR PASCAL
	#define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
	#define FNWCALLBACK FAR PASCAL _loadds
	#define FNEXPORT    FAR PASCAL _export
    #else
	#define FNWCALLBACK FAR PASCAL
	#define FNEXPORT    FAR PASCAL _export
    #endif
    #endif


    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge


    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif


    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
	#define _TCHAR_DEFINED
	typedef char            TCHAR, *PTCHAR;
	typedef unsigned char   TBYTE, *PTUCHAR;

	typedef PSTR            PTSTR, PTCH;
	typedef LPSTR           LPTSTR, LPTCH;
	typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
	DWORD   dw;                                                 \
	dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
	*pnE = (int)HIWORD(dw);                                     \
	*pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef WIN32
#endif // #ifndef RC_INVOKED


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  A few unicode APIs that we implement internally if not
//  compiled for UNICODE.
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
#ifndef UNICODE

#define lstrcmpW IlstrcmpW
#define lstrcpyW IlstrcpyW
#define lstrlenW IlstrlenW
#define DialogBoxParamW IDialogBoxParamW
#define LoadStringW ILoadStringW

#endif
#endif

//--------------------------------------------------------------------------;
//
//  Description:
//      The following are inline wrappers for some of the ComboBox message
//      crackers.  Using these allows better type checking on the parameters
//      used in the cracker.
//
//      The W32 suffix means that the strings are always Wide if WIN32 is
//      defined.  The strings are still Ansi when not WIN32.
//
//  History:
//      03/17/93    fdy     [frankye]
//
//--------------------------------------------------------------------------;
#if defined (WIN32) && !defined(UNICODE)
#define IComboBox_GetLBTextW32          IComboBox_GetLBText_mbstowcs
#define IComboBox_FindStringExactW32    IComboBox_FindStringExact_wcstombs
#define IComboBox_AddStringW32          IComboBox_AddString_wcstombs
#else
#define IComboBox_GetLBTextW32          IComboBox_GetLBText
#define IComboBox_FindStringExactW32    IComboBox_FindStringExact
#define IComboBox_AddStringW32          IComboBox_AddString
#endif

DWORD __inline IComboBox_GetLBText(HWND hwndCtl, int index, LPTSTR lpszBuffer)
{
    return ComboBox_GetLBText(hwndCtl, index, lpszBuffer);
}

int __inline IComboBox_FindStringExact(HWND hwndCtl, int indexStart, LPCTSTR lpszFind)
{
    return ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind);
}

int __inline IComboBox_InsertString(HWND hwndCtl, int index, LPCTSTR lpsz)
{
    return ComboBox_InsertString(hwndCtl, index, lpsz);
}

int __inline IComboBox_AddString(HWND hwndCtl, LPCTSTR lpsz)
{
    return ComboBox_AddString(hwndCtl, lpsz);
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define MAX_DRIVER_NAME_CHARS           144 // path + name or other...


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Internal structure for driver management
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Format/Filter structures containing minimal infomation
//  about a filter tag
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tACMFORMATTAGCACHE
{
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
} ACMFORMATTAGCACHE, *PACMFORMATTAGCACHE, FAR *LPACMFORMATTAGCACHE;

typedef struct tACMFILTERTAGCACHE
{
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
} ACMFILTERTAGCACHE, *PACMFILTERTAGCACHE, FAR *LPACMFILTERTAGCACHE;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Stream Instance Structure
//
//  this structure is used to maintain an open stream (acmStreamOpen)
//  and maps directly to the HACMSTREAM returned to the caller. this is
//  an internal structure to the ACM and will not be exposed.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tACMSTREAM      *PACMSTREAM;
typedef struct tACMSTREAM
{
    UINT                    uHandleType;    // for param validation (TYPE_HACMSTREAM)
    DWORD                   fdwStream;      // stream state flags, etc.
    PACMSTREAM              pasNext;        // next stream for driver instance (had)
    HACMDRIVER              had;            // handle to driver.
    UINT                    cPrepared;      // number of headers prepared
    ACMDRVSTREAMINSTANCE    adsi;           // passed to driver

} ACMSTREAM;

#define ACMSTREAM_STREAMF_USERSUPPLIEDDRIVER    0x00000001L
#define ACMSTREAM_STREAMF_ASYNCTOSYNC		0x00000002L


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Instance Structure
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tACMDRIVER      *PACMDRIVER;
typedef struct tACMDRIVER
{
    UINT                uHandleType;    // param validation (TYPE_HACMDRIVER)

    PACMDRIVER          padNext;        //
    PACMSTREAM          pasFirst;       //

    HACMDRIVERID        hadid;          // identifier to driver
    HTASK               htask;          // task handle of client
    DWORD               fdwOpen;        // flags used when opened

    HDRVR               hdrvr;          // open driver handle (if driver)
    ACMDRIVERPROC       fnDriverProc;   // function entry (if not driver)
    DWORD_PTR           dwInstance;     // instance data for functions..
#ifndef WIN32
    DWORD               had32;          // 32-bit had for 32-bit drivers
#endif

} ACMDRIVER;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Identifier Structure
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tACMGARB        *PACMGARB;
typedef struct tACMDRIVERID    *PACMDRIVERID;
typedef struct tACMDRIVERID
{
    //
    // !!! prmval16.asm relies on uHandleType as first int in this struct !!!
    //
    UINT                uHandleType;    // param validation (TYPE_HACMDRIVERID)

    //
    //
    //
    PACMGARB            pag;            // ptr back to garb

    BOOL		fRemove;	// this driver needs to be removed

    UINT                uPriority;      // current global priority
    PACMDRIVERID        padidNext;      // next driver identifier in list
    PACMDRIVER          padFirst;       // first open instance of driver

    HTASK               htask;          // task handle if driver is local

    LPARAM              lParam;         // lParam used when 'added'
    DWORD               fdwAdd;         // flags used when 'added'

    DWORD               fdwDriver;      // ACMDRIVERID_DRIVERF_* info bits

    //
    //	The following members of this structure are cached in the
    //	registry for each driver alias.
    //
    //	    fdwSupport
    //	    cFormatTags
    //	    *paFormatTagCache (for each format tag)
    //	    cFilterTags
    //	    *paFilterTagCache (for each filter tag)
    //

    DWORD               fdwSupport;     // ACMDRIVERID_SUPPORTF_* info bits

    UINT                cFormatTags;
    PACMFORMATTAGCACHE	paFormatTagCache;

    UINT                cFilterTags;    // from aci.cFilterTags
    PACMFILTERTAGCACHE	paFilterTagCache;

    //
    //
    //
    HDRVR               hdrvr;          // open driver handle (if driver)
    ACMDRIVERPROC       fnDriverProc;   // function entry (if not driver)
    DWORD_PTR           dwInstance;     // instance data for functions..

#ifdef WIN32
    LPCWSTR		pszSection;
    WCHAR               szAlias[MAX_DRIVER_NAME_CHARS];
    PWSTR		pstrPnpDriverFilename;
    DWORD		dnDevNode;
#else
    LPCTSTR		pszSection;
    TCHAR               szAlias[MAX_DRIVER_NAME_CHARS];
    PTSTR		pstrPnpDriverFilename;
    DWORD		dnDevNode;

    DWORD               hadid32;        // 32-bit had for 32-bit drivers
#endif


} ACMDRIVERID;

#define ACMDRIVERID_DRIVERF_LOADED      0x00000001L // driver has been loaded
#define ACMDRIVERID_DRIVERF_CONFIGURE   0x00000002L // supports configuration
#define ACMDRIVERID_DRIVERF_ABOUT       0x00000004L // supports custom about
#define ACMDRIVERID_DRIVERF_NOTIFY      0x10000000L // notify only proc
#define ACMDRIVERID_DRIVERF_LOCAL       0x40000000L //
#define ACMDRIVERID_DRIVERF_DISABLED    0x80000000L //




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  This structure is used to store priorities for drivers that aren't
//  actually installed.  This occurs because Win32 doesn't load 16-bit
//  drivers, but Win16 loads both 16- and 32-bit drivers.
//
//  This structure, and all routines that process it, are only used if
//  USETHUNKLIST is defined.  Here, we define it for Win32 only.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
#define USETHUNKLIST
#endif


#ifdef USETHUNKLIST

    typedef struct tPRIORITIESTHUNKLIST *PPRIORITIESTHUNKLIST;
    typedef struct tPRIORITIESTHUNKLIST
    {
	BOOL                fFakeDriver;
	union
	{
	    LPTSTR          pszPrioritiesText;  // if( fFakeDriver )
	    HACMDRIVERID    hadid;              // if( fFakeDriver )
	};
	PPRIORITIESTHUNKLIST pptNext;
    } PRIORITIESTHUNKLIST;

#endif // USETHUNKLIST



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Internal ACM Driver Manager API's in ACM.C
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LRESULT FNGLOBAL IDriverMessageId
(
    HACMDRIVERID            hadid,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
);

LRESULT FNGLOBAL IDriverConfigure
(
    HACMDRIVERID            hadid,
    HWND                    hwnd
);

MMRESULT FNGLOBAL IDriverGetNext
(
    PACMGARB                pag,
    LPHACMDRIVERID          phadidNext,
    HACMDRIVERID            hadid,
    DWORD                   fdwGetNext
);

MMRESULT FNGLOBAL IDriverAdd
(
    PACMGARB                pag,
    LPHACMDRIVERID          phadidNew,
    HINSTANCE               hinstModule,
    LPARAM                  lParam,
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);

MMRESULT FNGLOBAL IDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
);

MMRESULT FNGLOBAL IDriverOpen
(
    LPHACMDRIVER            phadNew,
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
);

MMRESULT FNGLOBAL IDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
);

LRESULT FNGLOBAL IDriverMessage
(
    HACMDRIVER              had,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
);

MMRESULT FNGLOBAL IDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
);


MMRESULT FNGLOBAL IDriverPriority
(
    PACMGARB                pag,
    PACMDRIVERID            padid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
);

MMRESULT FNGLOBAL IDriverSupport
(
    HACMDRIVERID            hadid,
    LPDWORD                 pfdwSupport,
    BOOL                    fFullSupport
);

MMRESULT FNGLOBAL IDriverCount
(
    PACMGARB                pag,
    LPDWORD                 pdwCount,
    DWORD                   fdwSupport,
    DWORD                   fdwEnum
);

MMRESULT FNGLOBAL IDriverGetWaveIdentifier
(
    HACMDRIVERID            hadid,
    LPDWORD                 pdw,
    BOOL                    fInput
);

#ifndef WIN32
MMRESULT FNGLOBAL acmBoot32BitDrivers
(
    PACMGARB    pag
);
#endif

MMRESULT FNGLOBAL acmBootPnpDrivers
(
    PACMGARB    pag
);

MMRESULT FNGLOBAL acmBootDrivers
(
    PACMGARB    pag
);

VOID FNGLOBAL IDriverRefreshPriority
(
    PACMGARB    pag
);

BOOL FNGLOBAL IDriverPrioritiesRestore
(
    PACMGARB pag
);

BOOL FNGLOBAL IDriverPrioritiesSave
(
    PACMGARB pag
);

BOOL FNGLOBAL IDriverBroadcastNotify
(
    PACMGARB            pag
);

MMRESULT FNGLOBAL IMetricsMaxSizeFormat
(
    PACMGARB		pag,
    HACMDRIVER          had,
    LPDWORD             pdwSize
);

MMRESULT FNGLOBAL IMetricsMaxSizeFilter
(
    PACMGARB		pag,
    HACMDRIVER          had,
    LPDWORD             pdwSize
);

DWORD FNGLOBAL IDriverCountGlobal
(
    PACMGARB                pag
);


//
//  Priorities locking stuff.
//
#define ACMPRIOLOCK_GETLOCK             1
#define ACMPRIOLOCK_RELEASELOCK         2
#define ACMPRIOLOCK_ISMYLOCK            3
#define ACMPRIOLOCK_ISLOCKED            4
#define ACMPRIOLOCK_LOCKISOK            5

#define ACMPRIOLOCK_FIRST               ACMPRIOLOCK_GETLOCK
#define ACMPRIOLOCK_LAST                ACMPRIOLOCK_LOCKISOK

BOOL IDriverLockPriority
(
    PACMGARB                pag,
    HTASK                   htask,
    UINT                    uRequest
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Resource defines
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ICON_MSACM                  RCID(10)

#define IDS_TXT_TAG                     150
#define IDS_TXT_NONE                    (IDS_TXT_TAG+0)
#define IDS_TXT_UNTITLED                (IDS_TXT_TAG+1)
#define IDS_TXT_UNAVAILABLE             (IDS_TXT_TAG+2)

#define IDS_FORMAT_TAG_BASE             300
#define IDS_FORMAT_TAG_PCM              (IDS_FORMAT_TAG_BASE + 0)

#define IDS_FORMAT_BASE                     350
#define IDS_FORMAT_FORMAT_MONOSTEREO        (IDS_FORMAT_BASE + 0)
#define IDS_FORMAT_FORMAT_MONOSTEREO_0BIT   (IDS_FORMAT_BASE + 1)
#define IDS_FORMAT_FORMAT_MULTICHANNEL      (IDS_FORMAT_BASE + 2)
#define IDS_FORMAT_FORMAT_MULTICHANNEL_0BIT (IDS_FORMAT_BASE + 3)
#define IDS_FORMAT_CHANNELS_MONO            (IDS_FORMAT_BASE + 4)
#define IDS_FORMAT_CHANNELS_STEREO          (IDS_FORMAT_BASE + 5)
#define IDS_FORMAT_MASH                     (IDS_FORMAT_BASE + 6)



//
//  these are defined in PCM.H
//
#define IDS_PCM_TAG                     500

#define IDS_CHOOSER_TAG                 600

    // unused				(IDS_CHOOSER_TAG+0)
    // unused				(IDS_CHOOSER_TAG+1)
    // unused				(IDS_CHOOSER_TAG+2)
#define IDS_CHOOSEFMT_APPTITLE          (IDS_CHOOSER_TAG+3)
#define IDS_CHOOSEFMT_RATE_FMT          (IDS_CHOOSER_TAG+4)

#define IDS_CHOOSE_FORMAT_DESC          (IDS_CHOOSER_TAG+8)
#define IDS_CHOOSE_FILTER_DESC          (IDS_CHOOSER_TAG+9)

#define IDS_CHOOSE_QUALITY_CD           (IDS_CHOOSER_TAG+10)
#define IDS_CHOOSE_QUALITY_RADIO        (IDS_CHOOSER_TAG+11)
#define IDS_CHOOSE_QUALITY_TELEPHONE    (IDS_CHOOSER_TAG+12)

#define IDS_CHOOSE_QUALITY_DEFAULT      (IDS_CHOOSE_QUALITY_RADIO)

#define IDS_CHOOSE_ERR_TAG              650

#define IDS_ERR_FMTSELECTED             (IDS_CHOOSE_ERR_TAG+0)
#define IDS_ERR_FMTEXISTS               (IDS_CHOOSE_ERR_TAG+1)
#define IDS_ERR_BLANKNAME               (IDS_CHOOSE_ERR_TAG+2)
#define IDS_ERR_INVALIDNAME             (IDS_CHOOSE_ERR_TAG+3)



#define DLG_CHOOSE_SAVE_NAME            RCID(75)
#define IDD_EDT_NAME                    100
#define IDD_STATIC_DESC                 101



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#pragma pack(push, 8)

typedef struct tACMGARB
{
    PACMGARB        pagNext;            // next garb structure
    DWORD           pid;                // process id associated with this garb
    UINT            cUsage;             // usage count for this process

    //
    //	boot flags
    //
    BOOL            fDriversBooted;     // have we booted drivers?
#if defined(WIN32) && defined(WIN4)
    CRITICAL_SECTION csBoot;		// protects boot code from multiple threads
#endif
#ifdef DEBUG
    BOOL            fDriversBooting;    // are we already booting drivers?
#endif

    //
    //	change notification counters.  used to determine when there has been
    //	a change in pnp drivers or in 32-bit drivers.  when the counters
    //	become inconsistent then we know something may have changed and
    //	we need to look for drivers that may have been added or removed.
    //
    DWORD	    dwPnpLastChangeNotify;
    LPDWORD	    lpdwPnpChangeNotify;

#ifdef WIN32
    LPDWORD	    lpdw32BitChangeNotify;
#else
    DWORD	    dw32BitLastChangeNotify;
    DWORD	    dw32BitChangeNotify;
#endif

    //
    //
    //
    HINSTANCE       hinst;              // hinst of ACM module

    PACMDRIVERID    padidFirst;         // list of installed drivers

    HACMDRIVERID    hadidDestroy;       // driver being destroyed
    HACMDRIVER      hadDestroy;         // driver handle being destroyed

    HTASK           htaskPriority;      // !!! hack !!!

    //
    //	For implementing driver list locking.
    //
#ifdef WIN32
    LOCK_INFO       lockDriverIds;
#endif
    DWORD	    dwTlsIndex;		// index for thread local storage.  For
					// 16-bit, this IS the local storage.

    //
    //  Cache of ACM registry keys, so we don't have to open and close them
    //  all the time.  They should be initialized on startup and released
    //  on shutdown.
    //
//    HKEY            hkeyACM;            //  Key name:  gszSecACM
//    HKEY            hkeyPriority;       //  Key name:  gszSecPriority

    //
    //  Thunking stuff
    //
#ifndef WIN32
    BOOL            fWOW;               // thunks connected
#ifndef WIN4
    DWORD           (FAR PASCAL *lpfnCallproc32W_6)(DWORD, DWORD, DWORD,
	                                            DWORD, DWORD, DWORD,
						    LPVOID, DWORD, DWORD);
    LPVOID          lpvAcmThunkEntry;

    DWORD           (FAR PASCAL *lpfnCallproc32W_9)(DWORD, DWORD, DWORD,
	                                            DWORD, DWORD, DWORD,
	                                            DWORD, DWORD, DWORD,
						    LPVOID, DWORD, DWORD);
    LPVOID          lpvXRegThunkEntry;

    DWORD           dwMsacm32Handle;
#endif
#endif // !WIN32


} ACMGARB, *PACMGARB, FAR *LPACMGARB;

#pragma pack(pop)

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN4
PACMGARB FNGLOBAL pagFind(void);
PACMGARB FNGLOBAL pagFindAndBoot(void);
#else
#define pagFind() gplag
#define pagFindAndBoot() gplag
#endif
PACMGARB FNGLOBAL pagNew(void);
void     FNGLOBAL pagDelete(PACMGARB pag);

VOID FNGLOBAL threadInitializeProcess(PACMGARB pag);
VOID FNGLOBAL threadTerminateProcess(PACMGARB pag);
VOID FNGLOBAL threadInitialize(PACMGARB pag);
VOID FNGLOBAL threadTerminate(PACMGARB pag);
VOID FNGLOBAL threadEnterListShared(PACMGARB pag);
VOID FNGLOBAL threadLeaveListShared(PACMGARB pag);
BOOL FNGLOBAL threadQueryInListShared(PACMGARB pag);

#ifndef WIN32
BOOL FNLOCAL acmInitThunks
(
    VOID
);

LRESULT FNGLOBAL IDriverMessageId32
(
    DWORD               hadid32,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
);
LRESULT FNGLOBAL IDriverMessage32
(
    DWORD               hadid32,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
);
MMRESULT FNGLOBAL IDriverLoad32
(
    DWORD   hadid32,
    DWORD   fdwFlags
);
MMRESULT FNGLOBAL IDriverOpen32
(
    LPDWORD             lpahadNew,
    DWORD               hadid32,
    DWORD               fdwOpen
);
LRESULT FNGLOBAL IDriverClose32
(
    DWORD               hdrvr,
    DWORD               fdwClose
);

MMRESULT FNGLOBAL IDriverPriority32
(
    PACMGARB                pag,
    DWORD		    padid32,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
);

MMRESULT FNGLOBAL IDriverGetInfo32
(
    PACMGARB		pag,
    DWORD		hadid32,
    LPSTR		lpstrAlias,
    LPACMDRIVERPROC	lpfnDriverProc,
    LPDWORD		lpdnDevNode,
    LPDWORD		lpfdwAdd
);

MMRESULT FNGLOBAL IDriverGetNext32
(
    PACMGARB		    pag,
    LPDWORD		    phadid32Next,
    DWORD		    hadid32,
    DWORD                   fdwGetNext
);

MMRESULT FNGLOBAL pagFindAndBoot32
(
    PACMGARB		    pag
);

#endif // !WIN32

//
//
//
extern PACMGARB         gplag;
extern CONST TCHAR	gszKeyDrivers[];
extern CONST TCHAR	gszDevNode[];
extern CONST TCHAR	gszSecDrivers[];
#ifdef WIN32
extern CONST WCHAR	gszSecDriversW[];
#endif
extern CONST TCHAR	gszSecDrivers32[];
extern CONST TCHAR	gszIniSystem[];


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Parameter Validation stuff
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  handle types for V_HANDLE (these can be anything except zero!) for
//  HACMOBJ, the parameter validation will test to make sure the handle
//  is one of the three types..
//
#define TYPE_HACMOBJ            0
#define TYPE_HACMDRIVERID       1
#define TYPE_HACMDRIVER         2
#define TYPE_HACMSTREAM         3
#define TYPE_HACMNOTVALID       666


//
//  for parameter validation of flags...
//
#define IDRIVERGETNEXT_VALIDF   (ACM_DRIVERENUMF_VALID)
#define IDRIVERADD_VALIDF       (ACM_DRIVERADDF_VALID)
#define IDRIVERREMOVE_VALIDF    (0L)
#define IDRIVERLOAD_VALIDF      (0L)
#define IDRIVERFREE_VALIDF      (0L)
#define IDRIVEROPEN_VALIDF      (0L)
#define IDRIVERCLOSE_VALIDF     (0L)
#define IDRIVERDETAILS_VALIDF   (0L)


//
//  No error logging for Win32
//

#ifdef WIN32

#define DRVEA_NORMALEXIT    0x0001
#define DRVEA_ABNORMALEXIT  0x0002


#ifndef NOLOGERROR

#if 0
void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);
#else
#define LogError(a, b)
#define LogParamError(a, b, c)
#endif

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING     0x8000
#define ERR_PARAM       0x4000

#define ERR_SIZE_MASK   0x3000
#define ERR_BYTE        0x1000
#define ERR_WORD        0x2000
#define ERR_DWORD       0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE       0x6001
#define ERR_BAD_FLAGS       0x6002
#define ERR_BAD_INDEX       0x6003
#define ERR_BAD_DVALUE      0x7004
#define ERR_BAD_DFLAGS      0x7005
#define ERR_BAD_DINDEX      0x7006
#define ERR_BAD_PTR         0x7007
#define ERR_BAD_FUNC_PTR    0x7008
#define ERR_BAD_SELECTOR    0x6009
#define ERR_BAD_STRING_PTR  0x700a
#define ERR_BAD_HANDLE      0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS          0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

#if 0
    /* Debugging support (DEBUG SYSTEM ONLY) */
    typedef struct tagWINDEBUGINFO
    {
	UINT    flags;
	DWORD   dwOptions;
	DWORD   dwFilter;
	char    achAllocModule[8];
	DWORD   dwAllocBreak;
	DWORD   dwAllocCount;
    #if (WINVER >= 0x0400)
	WORD    chDefRIP;
    #endif /* WINVER >= 0x0400 */
    } WINDEBUGINFO;

    BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
    BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);
#endif

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS             0x0001
#define WDI_FILTER              0x0002
#define WDI_ALLOCBREAK          0x0004
#define WDI_DEFRIP              0x0008

/* dwOptions values */
#define DBO_CHECKHEAP           0x0001
#define DBO_BUFFERFILL          0x0004
#define DBO_DISABLEGPTRAPPING   0x0010
#define DBO_CHECKFREE           0x0020

#define DBO_SILENT              0x8000

#define DBO_TRACEBREAK          0x2000
#define DBO_WARNINGBREAK        0x1000
#define DBO_NOERRORBREAK        0x0800
#define DBO_NOFATALBREAK        0x0400
#define DBO_INT3BREAK           0x0100

/* DebugOutput flags values */
#define DBF_TRACE               0x0000
#define DBF_WARNING             0x4000
#define DBF_ERROR               0x8000
#define DBF_FATAL               0xc000

/* dwFilter values */
#define DBF_KERNEL              0x1000
#define DBF_KRN_MEMMAN          0x0001
#define DBF_KRN_LOADMODULE      0x0002
#define DBF_KRN_SEGMENTLOAD     0x0004
#define DBF_USER                0x0800
#define DBF_GDI                 0x0400
#define DBF_MMSYSTEM            0x0040
#define DBF_PENWIN              0x0020
#define DBF_APPLICATION         0x0008
#define DBF_DRIVER              0x0010

#endif  /* NOLOGERROR */
#endif // WIN32



//
//
//
BOOL FNGLOBAL ValidateHandle(HANDLE h, UINT uType);
BOOL FNGLOBAL ValidateReadWaveFormat(LPWAVEFORMATEX pwfx);
BOOL FNGLOBAL ValidateReadWaveFilter(LPWAVEFILTER pwf);
BOOL FNGLOBAL ValidateReadPointer(const void FAR* p, DWORD len);
BOOL FNGLOBAL ValidateWritePointer(const void FAR* p, DWORD len);
BOOL FNGLOBAL ValidateDriverCallback(DWORD_PTR dwCallback, UINT uFlags);
BOOL FNGLOBAL ValidateCallback(FARPROC lpfnCallback);

#ifdef WIN32
BOOL FNGLOBAL ValidateStringA(LPCSTR lsz, UINT cchMaxLen);
BOOL FNGLOBAL ValidateStringW(LPCWSTR lsz, UINT cchMaxLen);
#ifdef UNICODE
#define ValidateString      ValidateStringW
#else
#define ValidateString      ValidateStringA
#endif
#else // WIN32
BOOL FNGLOBAL ValidateString(LPCSTR lsz, UINT cchMaxLen);
#endif


//
//  unless we decide differently, ALWAYS do parameter validation--even
//  in retail. this is the 'safest' thing we can do. note that we do
//  not LOG parameter errors in retail (see prmvalXX).
//
#if 1

#define V_HANDLE(h, t, r)       { if (!ValidateHandle(h, t)) return (r); }
#define V_RWAVEFORMAT(p, r)     { if (!ValidateReadWaveFormat(p)) return (r); }
#define V_RWAVEFILTER(p, r)     { if (!ValidateReadWaveFilter(p)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!ValidateReadPointer((p), (l))) return (r); }
#define V_WPOINTER(p, l, r)     { if (!ValidateWritePointer((p), (l))) return (r); }
#define V_DCALLBACK(d, w, r)    { if (!ValidateDriverCallback((d), (w))) return (r); }
#define V_CALLBACK(f, r)        { if (!ValidateCallback(f)) return (r); }
#define V_STRING(s, l, r)       { if (!ValidateString(s,l)) return (r); }
#define V_STRINGW(s, l, r)      { if (!ValidateStringW(s,l)) return (r); }
#define _V_STRING(s, l)         (ValidateString(s,l))
#define _V_STRINGW(s, l)        (ValidateStringW(s,l))
#ifdef DEBUG
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b)) {LogParamError(ERR_BAD_DFLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t)); return (r); }}
#else
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b))  return (r); }
#endif
#define V_FLAGS(t, b, f, r)     V_DFLAGS(t, b, f, r)
#define V_MMSYSERR(e, f, t, r)  { LogParamError(e, (FARPROC)(f), (LPVOID)(DWORD)(t)); return (r); }

#else

#define V_HANDLE(h, t, r)       { if (!(h)) return (r); }
#define V_RWAVEFORMAT(p, r)     { if (!(p)) return (r); }
#define V_RWAVEFILTER(p, r)     { if (!(p)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_WPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_DCALLBACK(d, w, r)    0
#define V_CALLBACK(f, r)        { if (!(f)) return (r); }
#define V_STRING(s, l, r)       { if (!(s)) return (r); }
#define V_STRINGW(s, l, r)      { if (!(s)) return (r); }
#define _V_STRING(s, l)         (s)
#define _V_STRINGW(s, l)        (s)
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b))  return (r); }
#define V_FLAGS(t, b, f, r)     V_DFLAGS(t, b, f, r)

#endif


//
//  the DV_xxxx macros are for internal DEBUG builds--aid to debugging.
//  we do 'loose' parameter validation in retail builds...
//
#ifdef DEBUG

#define DV_HANDLE(h, t, r)      V_HANDLE(h, t, r)
#define DV_RWAVEFORMAT(p, r)    V_RWAVEFORMAT(p, r)
#define DV_RPOINTER(p, l, r)    V_RPOINTER(p, l, r)
#define DV_WPOINTER(p, l, r)    V_WPOINTER(p, l, r)
#define DV_DCALLBACK(d, w, r)   V_DCALLBACK(d, w, r)
#define DV_CALLBACK(f, r)       V_CALLBACK(f, r)
#define DV_STRING(s, l, r)      V_STRING(s, l, r)
#define DV_DFLAGS(t, b, f, r)   V_DFLAGS(t, b, f, r)
#define DV_FLAGS(t, b, f, r)    V_FLAGS(t, b, f, r)
#define DV_MMSYSERR(e, f, t, r) V_MMSYSERR(e, f, t, r)

#else

#define DV_HANDLE(h, t, r)      { if (!(h)) return (r); }
#define DV_RWAVEFORMAT(p, r)    { if (!(p)) return (r); }
#define DV_RPOINTER(p, l, r)    { if (!(p)) return (r); }
#define DV_WPOINTER(p, l, r)    { if (!(p)) return (r); }
#define DV_DCALLBACK(d, w, r)   0
#define DV_CALLBACK(f, r)       { if (!(f)) return (r); }
#define DV_STRING(s, l, r)      { if (!(s)) return (r); }
#define DV_DFLAGS(t, b, f, r)   { if ((t) & ~(b))  return (r); }
#define DV_FLAGS(t, b, f, r)    DV_DFLAGS(t, b, f, r)
#define DV_MMSYSERR(e, f, t, r) { return (r); }

#endif

//
//  Locking stuff
//

#if defined(WIN32) && defined(_MT)
    //
    //
    //
    typedef struct {
	CRITICAL_SECTION CritSec;
    } ACM_HANDLE, *PACM_HANDLE;
    #define HtoPh(h) (((PACM_HANDLE)(h)) - 1)
    HLOCAL NewHandle(UINT length);
    VOID   DeleteHandle(HLOCAL h);
    #define EnterHandle(h) EnterCriticalSection(&HtoPh(h)->CritSec)
    #define LeaveHandle(h) LeaveCriticalSection(&HtoPh(h)->CritSec)
    #define ENTER_LIST_EXCLUSIVE AcquireLockExclusive(&pag->lockDriverIds)
    #define LEAVE_LIST_EXCLUSIVE ReleaseLock(&pag->lockDriverIds)
    #define ENTER_LIST_SHARED {AcquireLockShared(&pag->lockDriverIds); threadEnterListShared(pag);}
    #define LEAVE_LIST_SHARED {threadLeaveListShared(pag); ReleaseLock(&pag->lockDriverIds);}
#else
    #define NewHandle(length) LocalAlloc(LPTR, length)
    #define DeleteHandle(h)   LocalFree(h)
    #define EnterHandle(h)
    #define LeaveHandle(h)
    #define ENTER_LIST_EXCLUSIVE
    #define LEAVE_LIST_EXCLUSIVE
    #define ENTER_LIST_SHARED threadEnterListShared(pag)
    #define LEAVE_LIST_SHARED threadLeaveListShared(pag)
#endif // !(WIN32 && _MT)

;
//
//  Event stuff for async conversion to sync conversion support
//
//	Since the code should never try to call these APIs in WIN16
//	compiles, we just #define these WIN32 APIs to return failures
//
#ifndef WIN32
#define CreateEvent(a, b, c, d) ((HANDLE)(0))
#define ResetEvent(x) ((BOOL)(FALSE))
#define WaitForSingleObject(x,y) ((DWORD)(0xFFFFFFFF))
#define CloseHandle(x) ((BOOL)(FALSE))
#define WAIT_OBJECT_0  (0x00000000)
#define INFINITE (0xFFFFFFFF)
#endif


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_ACMI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\acmfltr.c ===
/****************************************************************************
 *
 *   acmfltr.c
 *
 *   Copyright (c) 1991-1998 Microsoft Corporation
 *
 *   This module provides the wave filter enumeration and string API's.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include "msacm.h"
#include "msacmdrv.h"
#include <stdlib.h>
#include "acmi.h"
#include "uchelp.h"
#include "debug.h"


//--------------------------------------------------------------------------;
//  
//  MMRESULT IFilterTagDetails
//  
//  Description:
//  
//  
//  Arguments:
//	PACMGARB pag:
//
//	HACMDRIVERID hadid:
//
//      LPACMFILTERTAGDETAILS pafd:
//
//	DWORD fdwDetails:
//  
//  Return (UINT):
//  
//  History:
//      08/31/94    frankye
//  
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IFilterTagDetails
(
    PACMGARB		    pag,
    HACMDRIVERID	    hadid,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    PACMDRIVERID            padid;
    UINT                    u;
    DWORD                   fdwQuery;
    MMRESULT		    mmr;

    ASSERT( NULL != pag );
    ASSERT( NULL != hadid );

    
    padid	= (PACMDRIVERID)hadid;
    fdwQuery	= (ACM_FILTERTAGDETAILSF_QUERYMASK & fdwDetails);
    mmr		= ACMERR_NOTPOSSIBLE;
	
    switch (fdwQuery)
    {
	case ACM_FILTERTAGDETAILSF_FILTERTAG:
	{
	    for (u=0; u<padid->cFilterTags; u++)
	    {
		if (padid->paFilterTagCache[u].dwFilterTag == paftd->dwFilterTag)
		{
		    mmr = MMSYSERR_NOERROR;
		    break;
		}
	    }
	    break;
	}

	case ACM_FILTERTAGDETAILSF_LARGESTSIZE:
	case ACM_FILTERTAGDETAILSF_INDEX:
	    mmr = MMSYSERR_NOERROR;
	    break;
    }

    //
    //
    //
    if (MMSYSERR_NOERROR == mmr)
    {
	EnterHandle((HACMDRIVERID)padid);
	mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)padid,
					 ACMDM_FILTERTAG_DETAILS,
					 (LPARAM)(LPVOID)paftd,
					 fdwDetails);
	LeaveHandle((HACMDRIVERID)padid);
    }
	
    
    if (MMSYSERR_NOERROR != mmr)
    {
	return (mmr);
    }

    switch (paftd->dwFilterTag)
    {
	case WAVE_FILTER_UNKNOWN:
	    DebugErr(DBF_ERROR, "IDriverGetFilterTags(): driver returned Filter tag 0!");
	    return (MMSYSERR_ERROR);

	case WAVE_FILTER_DEVELOPMENT:
	    DebugErr(DBF_WARNING, "IDriverGetFilterTags(): driver returned DEVELOPMENT Filter tag--do not ship this way.");
	    break;

    }

    return(mmr);

}


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 * 
 *  @types WAVEFILTER | The <t WAVEFILTER> structure defines a filter
 *      for waveform data. Only filter information common to all
 *      waveform data filters is included in this structure. For filters
 *      that require additional information, this structure is included
 *      as the first member in another structure, along with the additional
 *      information.
 * 
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t WAVEFILTER> structure. The size specified in this member must be
 *      large enough to contain the base <t WAVEFILTER> structure.
 * 
 *  @field DWORD | dwFilterTag | Specifies the waveform filter type. Filter
 *      tags are registered with Microsoft for various filter algorithms.
 *      A complete list of filter tags can be found in the MMREG.H header
 *      file available from Microsoft. For more information on filter
 *      tags, contact Microsoft for availability of the Multimedia Developer
 *      Registration Kit:
 *  
 *          Microsoft Corporation
 *          Advanced Consumer Technology
 *          Product Marketing
 *          One Microsoft Way
 *          Redmond, WA 98052-6399
 * 
 *  @field DWORD | fdwFilter | Specifies flags for the <e WAVEFILTER.dwFilterTag>.
 *      The flags defined for this member are universal to all filters.
 *      Currently, no flags are defined.
 * 
 *  @field DWORD | dwReserved[5] | This member is reserved for system use and should not
 *      be examined or modified by an application.
 * 
 *  @tagname wavefilter_tag
 * 
 *  @othertype WAVEFILTER FAR * | LPWAVEFILTER | A pointer to a <t WAVEFILTER>
 *      structure.
 *
 *  @xref <t WAVEFORMAT> <t WAVEFORMATEX> <t PCMWAVEFORMAT>
 *
 ****************************************************************************/


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 * 
 *  @types ACMFILTERTAGDETAILS | The <t ACMFILTERTAGDETAILS> structure
 *      details a wave filter tag for an Audio Compression Manager (ACM)
 *      filter driver.
 *
 *  @field DWORD | cbStruct | Specifies the size in bytes of the
 *      <t ACMFILTERTAGDETAILS> structure. This member must be initialized 
 *      before calling the <f acmFilterTagDetails> or <f acmFilterTagEnum>
 *      functions. The size specified in this member must be large enough to
 *      contain the base <t ACMFILTERTAGDETAILS> structure. When the
 *      <f acmFilterTagDetails> function returns, this member contains the
 *      actual size of the information returned. The returned information
 *      will never exceed the requested size.
 *
 *  @field DWORD | dwFilterTagIndex | Specifies the index of the filter tag
 *      to retrieve details for. The index ranges from zero to one
 *      less than the number of filter tags supported by an ACM driver. The
 *      number of filter tags supported by a driver is contained in the 
 *      <e ACMDRIVERDETAILS.cFilterTags> member of the <t ACMDRIVERDETAILS>
 *      structure. The <e ACMFILTERTAGDETAILS.dwFilterTagIndex> member is
 *      only used when querying filter tag details on a driver by index;
 *      otherwise, this member should be zero.
 *
 *  @field DWORD | dwFilterTag | Specifies the wave filter tag that the
 *      <t ACMFILTERTAGDETAILS> structure describes. This member is used
 *      as an input for the ACM_FILTERTAGDETAILSF_FILTERTAG and
 *      ACM_FILTERTAGDETAILSF_LARGESTSIZE query flags. This member is always
 *      returned if the <f acmFilterTagDetails> is successful. This member
 *      should be set to WAVE_FILTER_UNKNOWN for all other query flags.
 *
 *  @field DWORD | cbFilterSize | Specifies the largest total size in bytes
 *      of a wave filter of the <e ACMFILTERTAGDETAILS.dwFilterTag> type.
 *      For example, this member will be 40 for WAVE_FILTER_ECHO and 36 for
 *      WAVE_FILTER_VOLUME.
 *
 *  @field DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the filter tag. These flags are identical to the <e ACMDRIVERDETAILS.fdwSupport>
 *      flags of the <t ACMDRIVERDETAILS> structure. This argument can be a
 *      combination of the following values and identifies which operations the
 *      driver supports with the filter tag:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags while using
 *      the specified filter tag. For example, if a driver supports
 *      compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the
 *      specifed filter tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified filter tag. For example,
 *      if a driver supports resampling of WAVE_FORMAT_PCM with the specified
 *      filter tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified format tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output with the specified filter tag
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @field DWORD | cStandardFilters | Specifies the number of standard filters of the
 *      <e ACMFILTERTAGDETAILS.dwFilterTag> type. (that is, the combination of all
 *      filter characteristics). This value cannot specify all filters supported by the driver.
 *
 *  @field char | szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS] |
 *      Specifies a string that describes the <e ACMFILTERTAGDETAILS.dwFilterTag>
 *      type. This string is always returned if the <f acmFilterTagDetails>
 *      function is successful.
 * 
 *  @xref <f acmFilterTagDetails> <f acmFilterTagEnum>
 * 
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api MMRESULT | acmFilterTagDetails | This function queries the Audio Compression 
 *      Manager (ACM) for details on a specific wave filter tag.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave filter tag details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver. Note that
 *      an application must specify a valid <t HACMDRIVER> or <t HACMDRIVERID>
 *      when using the ACM_FILTERTAGDETAILSF_INDEX query type. Driver
 *      identifiers for disabled drivers are not allowed.
 *
 *  @parm LPACMFILTERTAGDETAILS | paftd | Specifies a pointer to the
 *      <t ACMFILTERTAGDETAILS> structure that is to receive the filter
 *      tag details.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for getting the details.
 *
 *      @flag ACM_FILTERTAGDETAILSF_INDEX | Indicates that a filter tag index
 *      was given in the <e ACMFILTERTAGDETAILS.dwFilterTagIndex> member of
 *      the <t ACMFILTERTAGDETAILS> structure. The filter tag and details
 *      will be returned in the structure defined by <p paftd>. The index
 *      ranges from zero to one less than the <e ACMDRIVERDETAILS.cFilterTags>
 *      member returned in the <t ACMDRIVERDETAILS> structure for an ACM
 *      driver. An application must specify a driver handle (<p had>) when
 *      retrieving filter tag details with this flag.
 *
 *      @flag ACM_FILTERTAGDETAILSF_FILTERTAG | Indicates that a filter tag
 *      was given in the <e ACMFILTERTAGDETAILS.dwFilterTag> member of
 *      the <t ACMFILTERTAGDETAILS> structure. The filter tag details will
 *      be returned in the structure defined by <p paftd>. If an application
 *      specifies an ACM driver handle (<p had>), then details on the filter
 *      tag will be returned for that driver. If an application specifies
 *      NULL for <p had>, then the ACM finds the first acceptable driver
 *      to return the details.
 *
 *      @flag ACM_FILTERTAGDETAILSF_LARGESTSIZE | Indicates that the details
 *      on the filter tag with the largest filter size in bytes is to be
 *      returned. The <e ACMFILTERTAGDETAILS.dwFilterTag> member must either
 *      be WAVE_FILTER_UNKNOWN or the filter tag to find the largest size
 *      for. If an application specifies an ACM driver handle (<p had>), then
 *      details on the largest filter tag will be returned for that driver.
 *      If an application specifies NULL for <p had>, then the ACM finds an
 *      acceptable driver with the largest filter tag requested to return 
 *      the details.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details requested are not available.
 *
 *  @xref <f acmDriverDetails> <f acmDriverOpen> <f acmFilterDetails>
 *      <f acmFilterTagEnum> <f acmFormatTagDetails>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFilterTagDetails
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    PACMGARB		    pag;
    PACMDRIVER		    pad;
    HACMDRIVERID            hadid;
    PACMDRIVERID            padid;
    DWORD                   fdwQuery;
    MMRESULT		    mmr;
    UINT                    u;

    pad	    = NULL;
    padid   = NULL;
    
    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFilterTagDetails: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }


    //
    //
    //
    V_DFLAGS(fdwDetails, ACM_FILTERTAGDETAILSF_VALID, acmFilterTagDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFILTERTAGDETAILS) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterTagDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    if (0L != paftd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFilterTagDetails: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    //
    fdwQuery = (ACM_FILTERTAGDETAILSF_QUERYMASK & fdwDetails);

    switch (fdwQuery)
    {
        case ACM_FILTERTAGDETAILSF_INDEX:
            //
            //  we don't (currently) support index based enumeration across
            //  all drivers... may never support this. so validate the
            //  handle and fail if not valid (like NULL).
            //
            V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

            if (WAVE_FILTER_UNKNOWN != paftd->dwFilterTag)
            {
                DebugErr(DBF_ERROR, "acmFilterTagDetails: dwFilterTag must be WAVE_FILTER_UNKNOWN for index query.");
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case ACM_FILTERTAGDETAILSF_FILTERTAG:
            if (WAVE_FILTER_UNKNOWN == paftd->dwFilterTag)
            {
                DebugErr(DBF_ERROR, "acmFilterTagDetails: dwFilterTag cannot be WAVE_FILTER_UNKNOWN for tag query.");
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case ACM_FILTERTAGDETAILSF_LARGESTSIZE:
            break;


        //
        //  we don't (currently) support the requested query type--so return
        //  not supported.
        //
        default:
            DebugErr(DBF_ERROR, "acmFilterTagDetails: unknown query type specified.");
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //
    //
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

        pad = (PACMDRIVER)had;
        if (TYPE_HACMDRIVERID == pad->uHandleType)
        {
            padid = (PACMDRIVERID)pad;
	    pad	  = NULL;

            if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
            {
		DebugErr1(DBF_ERROR, "acmFilterTagDetails: driver (%.04Xh) is disabled.", padid);
                return (MMSYSERR_NOTENABLED);
            }
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
            padid = (PACMDRIVERID)pad->hadid;
        }
    }


    if (NULL == padid)
    {
	PACMDRIVERID    padidT;
	DWORD		cbFilterSizeLargest;

	padidT		    = NULL;
	cbFilterSizeLargest = 0;
	hadid = NULL;
		
	ENTER_LIST_SHARED;

	while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
	{
	    padidT = (PACMDRIVERID)hadid;
	    
	    switch (fdwQuery)
	    {
		case ACM_FILTERTAGDETAILSF_FILTERTAG:
		{
		    for (u=0; u<padidT->cFilterTags; u++)
		    {
			if (padidT->paFilterTagCache[u].dwFilterTag == paftd->dwFilterTag)
			{
			    padid = padidT;
			    break;
			}
		    }
		    break;
		}

		case ACM_FILTERTAGDETAILSF_LARGESTSIZE:
		{
		    for (u=0; u<padidT->cFilterTags; u++)
		    {
			if (WAVE_FORMAT_UNKNOWN != paftd->dwFilterTag)
			{
			    if (padidT->paFilterTagCache[u].dwFilterTag != paftd->dwFilterTag)
			    {
				continue;
			    }
			}
			if (padidT->paFilterTagCache[u].cbFilterSize > cbFilterSizeLargest)
			{
			    cbFilterSizeLargest = padidT->paFilterTagCache[u].cbFilterSize;
			    padid = padidT;
			}
		    }
		    break;
		}

		default:
		{
		    DPF(0, "!acmFilterTagDetails(): unknown query type got through param validation?!?!");
		}
	    }
	}

	LEAVE_LIST_SHARED;
    }

    if (NULL != padid)
    {

	mmr = IFilterTagDetails(pag, (HACMDRIVERID)padid, paftd, fdwDetails);
	
    }
    else
    {

	mmr = ACMERR_NOTPOSSIBLE;

    }

    return(mmr);

} // acmFilterTagDetails()


#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFilterTagDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT                mmr;
    ACMFILTERTAGDETAILSW    aftdW;

    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*paftd) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterTagDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    aftdW.cbStruct = sizeof(aftdW);
    memcpy(&aftdW.dwFilterTagIndex,
           &paftd->dwFilterTagIndex,
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, szFilterTag) -
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, dwFilterTagIndex));

    mmr = acmFilterTagDetailsW(had, &aftdW, fdwDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        memcpy(&paftd->dwFilterTagIndex,
               &aftdW.dwFilterTagIndex,
               FIELD_OFFSET(ACMFILTERTAGDETAILSA, szFilterTag) -
               FIELD_OFFSET(ACMFILTERTAGDETAILSA, dwFilterTagIndex));

        paftd->cbStruct = min(paftd->cbStruct, sizeof(*paftd));
        Iwcstombs(paftd->szFilterTag, aftdW.szFilterTag, sizeof(paftd->szFilterTag));
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFilterTagDetailsW
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSW  paftd,
    DWORD                   fdwDetails
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif



/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 * 
 *  @types ACMFILTERDETAILS | The <t ACMFILTERDETAILS> structure details a
 *      wave filter for a specific filter tag for an Audio Compression
 *      Manager (ACM) driver.
 *
 *  @field DWORD | cbStruct | Specifies the size in bytes of the
 *      <t ACMFILTERDETAILS> structure. This member must be initialized 
 *      before calling the <f acmFilterDetails> or <f acmFilterEnum>
 *      functions. The size specified in this member must be large enough to
 *      contain the base <t ACMFILTERDETAILS> structure. When the
 *      <f acmFilterDetails> function returns, this member contains the
 *      actual size of the information returned. The returned information
 *      will never exceed the requested size.
 *
 *  @field DWORD | dwFilterIndex | Specifies the index of the filter about which
 *      details will be retrieved. The index ranges from zero to one
 *      less than the number of standard filters supported by an ACM driver
 *      for a filter tag. The number of standard filters supported by a
 *      driver for a filter tag is contained in the
 *      <e ACMFILTERTAGDETAILS.cStandardFilters> member of the
 *      <t ACMFILTERTAGDETAILS> structure. The
 *      <e ACMFILTERDETAILS.dwFilterIndex> member is only used when querying
 *      standard filter details on a driver by index; otherwise, this member
 *      should be zero. Also note that this member will be set to zero
 *      by the ACM when an application queries for details on a filter; in
 *      other words, this member is only used as an input argument and is
 *      never returned by the ACM or an ACM driver.
 *
 *  @field DWORD | dwFilterTag | Specifies the wave filter tag that the
 *      <t ACMFILTERDETAILS> structure describes. This member is used
 *      as an input for the ACM_FILTERDETAILSF_INDEX query flag.  For
 *      the ACM_FILTERDETAILSF_FORMAT query flag, this member
 *      must be initialized to the same filter tag as the
 *      <e ACMFILTERDETAILS.pwfltr> member specifies.
 *      This member is always returned if the <f acmFilterDetails> function is
 *      successful. This member should be set to WAVE_FILTER_UNKNOWN for all 
 *      other query flags.
 *
 *  @field DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the specified filter. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure, but are specific to the filter that is being queried.
 *      This argument can be a combination of the following values and
 *      identifies which operations the driver supports for the filter tag:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags while using the
 *      specified filter. For example, if a driver supports compression from 
 *      WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specifed
 *      filter, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified filter. For example, if a
 *      driver supports resampling of WAVE_FORMAT_PCM with the specified
 *      filter, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified filter tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output with the specified filter
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @field LPWAVEFILTER | pwfltr | Specifies a pointer to a <t WAVEFILTER>
 *      data structure that will receive the filter details. This structure
 *      requires no initialization by the application unless the
 *      ACM_FILTERDETAILSF_FILTER flag is specified to <f acmFilterDetails>.
 *      In this case, the <e WAVEFILTER.dwFilterTag> must be equal to
 *      the <e ACMFILTERDETAILS.dwFilterTag> of the <t ACMFILTERDETAILS>
 *      structure.
 *
 *  @field DWORD | cbwfltr | Specifies the size, in bytes, available for 
 *      the <e ACMFILTERDETAILS.pwfltr> to receive the filter details. The
 *      <f acmMetrics> and <f acmFilterTagDetails> functions can be used to
 *      determine the maximum size required for any filter available for the
 *      specified driver (or for all installed ACM drivers).
 *
 *  @field char | szFilter[ACMFILTERDETAILS_FILTER_CHARS] |
 *      Specifies a string that describes the filter for the
 *      <e ACMFILTERDETAILS.dwFilterTag> type. This string is always returned
 *      if the <f acmFilterDetails> function is successful.
 * 
 *  @xref <f acmFilterDetails> <f acmFilterEnum> <f acmFilterTagDetails>
 *      <f acmFilterTagEnum>
 * 
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api MMRESULT | acmFilterDetails | This function queries the Audio Compression 
 *      Manager (ACM) for details about a filter with a specific wave filter tag.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave filter details for a filter tag. If this argument is NULL,
 *      then the ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFILTERDETAILS | pafd | Specifies a pointer to the
 *      <t ACMFILTERDETAILS> structure that is to receive the filter
 *      details for the given filter tag.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for getting the details.
 *
 *      @flag ACM_FILTERDETAILSF_INDEX | Indicates that a filter index for
 *      the filter tag was given in the <e ACMFILTERDETAILS.dwFilterIndex>
 *      member of the <t ACMFILTERDETAILS> structure. The filter details
 *      will be returned in the structure defined by <p pafd>. The index
 *      ranges from zero to one less than the
 *      <e ACMFILTERTAGDETAILS.cStandardFilters> member returned in the
 *      <t ACMFILTERTAGDETAILS> structure for a filter tag. An application
 *      must specify a driver handle (<p had>) when retrieving
 *      filter details with this flag. Refer to the description for the
 *      <t ACMFILTERDETAILS> structure for information on what members
 *      should be initialized before calling this function.
 *
 *      @flag ACM_FILTERDETAILSF_FILTER | Indicates that a <t WAVEFILTER>
 *      structure pointed to by <e ACMFILTERDETAILS.pwfltr> of the 
 *      <t ACMFILTERDETAILS> structure was given and the remaining details
 *      should be returned. The <e ACMFILTERDETAILS.dwFilterTag> member 
 *      of the <t ACMFILTERDETAILS> structure must be initialized to the same filter
 *      tag as the <e ACMFILTERDETAILS.pwfltr> member specifies. This 
 *      query type can be used to get a string description of an arbitrary
 *      filter structure. If an application specifies an ACM driver handle
 *      (<p had>), then details on the filter will be returned for that
 *      driver. If an application specifies NULL for <p had>, then the ACM
 *      finds the first acceptable driver to return the details.
 *
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details requested are not available.
 *
 *  @xref <f acmFilterTagDetails> <f acmDriverDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFilterDetails
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    DWORD                   fdwDetails
)
{
    PACMGARB	    pag;
    MMRESULT        mmr;
    PACMDRIVER      pad;
    HACMDRIVERID    hadid;
    PACMDRIVERID    padid;
    DWORD           dwQuery;

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFilterDetails: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //
    //
    V_DFLAGS(fdwDetails, ACM_FILTERDETAILSF_VALID, acmFilterDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFILTERDETAILS) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(WAVEFILTER) > pafd->cbwfltr)
    {
        DebugErr(DBF_ERROR, "acmFilterDetails: cbwfltr member must be at least sizeof(WAVEFILTER).");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd->pwfltr, pafd->cbwfltr, MMSYSERR_INVALPARAM);

    if (0L != pafd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFilterDetails: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }


    //
    //
    //
    dwQuery = ACM_FILTERDETAILSF_QUERYMASK & fdwDetails;

    switch (dwQuery)
    {
        case ACM_FILTERDETAILSF_FILTER:
            if (pafd->dwFilterTag != pafd->pwfltr->dwFilterTag)
            {
                DebugErr(DBF_ERROR, "acmFilterDetails: filter tags must match.");
                return  (MMSYSERR_INVALPARAM);
            }

            // -- fall through -- //

        case ACM_FILTERDETAILSF_INDEX:
            if (WAVE_FILTER_UNKNOWN == pafd->dwFilterTag)
            {
                DebugErr(DBF_ERROR, "acmFilterDetails: dwFilterTag cannot be WAVE_FILTER_UNKNOWN for requested details query.");
                return (MMSYSERR_INVALPARAM);
            }

            //
            //  we don't (currently) support index based enumeration across
            //  all drivers... may never support this. so validate the
            //  handle and fail if not valid (like NULL).
            //
            if (ACM_FILTERDETAILSF_INDEX == dwQuery)
            {
                ACMFILTERTAGDETAILS aftd;

                V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

                _fmemset(&aftd, 0, sizeof(aftd));
                aftd.cbStruct    = sizeof(aftd);
                aftd.dwFilterTag = pafd->dwFilterTag;
                mmr = acmFilterTagDetails(had, &aftd, ACM_FILTERTAGDETAILSF_FILTERTAG);
                if (MMSYSERR_NOERROR != mmr)
                {
                    return (mmr);
                }

                if (pafd->dwFilterIndex >= aftd.cStandardFilters)
                {
                    DebugErr1(DBF_ERROR, "acmFilterTagDetails: dwFilterIndex (%lu) out of range.", pafd->dwFilterIndex);
                    return (MMSYSERR_INVALPARAM);
                }
            }
            break;

        default:
            DebugErr(DBF_ERROR, "acmFilterDetails: unknown query type specified.");
            return  (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  if we are passed a driver handle, then use it
    //
    if (NULL != had)
    {
        pad = (PACMDRIVER)had;
        if (TYPE_HACMDRIVERID == pad->uHandleType)
        {
            V_HANDLE(had, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

            //
            //  !!! yes, this is right !!!
            //
            padid = (PACMDRIVERID)had;

            if (0 == (ACMDRIVERDETAILS_SUPPORTF_FILTER & padid->fdwSupport))
            {
                DebugErr(DBF_ERROR, "acmFilterDetails: driver does not support filter operations.");
                return (MMSYSERR_INVALPARAM);
            }


            //
            //
            //
            EnterHandle(had);
            mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)had,
                                             ACMDM_FILTER_DETAILS,
                                             (LPARAM)pafd,
                                             fdwDetails);
            LeaveHandle(had);
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

            pad   = (PACMDRIVER)had;
            padid = (PACMDRIVERID)pad->hadid;

            if (0 == (ACMDRIVERDETAILS_SUPPORTF_FILTER & padid->fdwSupport))
            {
                DebugErr(DBF_ERROR, "acmFilterDetails: driver does not support filter operations.");
                return (MMSYSERR_INVALPARAM);
            }


            //
            //
            //
            EnterHandle(had);
            mmr = (MMRESULT)IDriverMessage(had,
                                           ACMDM_FILTER_DETAILS,
                                           (LPARAM)pafd,
                                           fdwDetails);
            LeaveHandle(had);
        }

        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  if caller is asking for details on a specific filter, then
            //  always return index equal to zero (it means nothing)
            //
            if (ACM_FILTERDETAILSF_FILTER == dwQuery)
            {
                pafd->dwFilterIndex = 0;
            }
        }

        return (mmr);
    }


    //
    //
    //
    hadid = NULL;
    mmr   = MMSYSERR_NODRIVER;

    ENTER_LIST_SHARED;

    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
    {
        padid = (PACMDRIVERID)hadid;

        if (0 == (ACMDRIVERDETAILS_SUPPORTF_FILTER & padid->fdwSupport))
        {
            continue;
        }

        //
        //
        //
        EnterHandle(hadid);
        mmr = (MMRESULT)IDriverMessageId(hadid,
                                         ACMDM_FILTER_DETAILS,
                                         (LPARAM)pafd,
                                         fdwDetails);
        LeaveHandle(hadid);

        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  if caller is asking for details on a specific filter, then
            //  always return index equal to zero (it means nothing)
            //
            if (ACM_FILTERDETAILSF_FILTER == dwQuery)
            {
                pafd->dwFilterIndex = 0;
            }
            break;
        }
    }
    
    LEAVE_LIST_SHARED;

    return (mmr);
} // acmFilterDetails()


#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFilterDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT                mmr;
    ACMFILTERDETAILSW       afdW;

    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*pafd) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    afdW.cbStruct = sizeof(afdW);
    memcpy(&afdW.dwFilterIndex,
           &pafd->dwFilterIndex,
           FIELD_OFFSET(ACMFILTERDETAILSA, szFilter) -
           FIELD_OFFSET(ACMFILTERDETAILSA, dwFilterIndex));

    mmr = acmFilterDetailsW(had, &afdW, fdwDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        memcpy(&pafd->dwFilterIndex,
               &afdW.dwFilterIndex,
               FIELD_OFFSET(ACMFILTERDETAILSA, szFilter) -
               FIELD_OFFSET(ACMFILTERDETAILSA, dwFilterIndex));

        pafd->cbStruct = min(pafd->cbStruct, sizeof(*pafd));
        Iwcstombs(pafd->szFilter, afdW.szFilter, sizeof(pafd->szFilter));
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFilterDetailsW
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSW     pafd,
    DWORD                   fdwDetails
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api BOOL ACMFILTERTAGENUMCB | acmFilterTagEnumCallback |
 *      The <f acmFilterTagEnumCallback> function  is a placeholder for an
 *      application-supplied function name and refers to the callback function
 *      used for Audio Compression Manager (ACM) wave filter tag enumeration. 
 *      
 *
 *  @parm HACMDRIVERID | hadid | Specifies an ACM driver identifier.
 *
 *  @parm  LPACMFILTERTAGDETAILS | paftd | Specifies a pointer to an
 *      <t ACMFILTERTAGDETAILS> structure that contains the enumerated
 *      filter tag details.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f acmFilterTagEnum> function.
 *
 *  @parm DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the driver identifier <p hadid>. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure. This argument can be a combination of the following
 *      values and identifies which operations the driver supports with the
 *      filter tag
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags while using
 *      the specified filter tag. For example, if a driver supports
 *      compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the
 *      specifed filter tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified filter tag. For example,
 *      if a driver supports resampling of WAVE_FORMAT_PCM with the specified
 *      filter tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified filter tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output with the specified filter tag
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f acmFilterTagEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no filter tags are to be enumerated. Moreover, the callback
 *      function will not be called.
 *
 *  @xref <f acmFilterTagEnum> <f acmFilterTagDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api MMRESULT | acmFilterTagEnum | The <f acmFilterTagEnum> function
 *      enumerates wave filter tags available from an Audio Compression
 *      Manager (ACM) driver. The <f acmFilterTagEnum> function continues
 *      enumerating until there are no more suitable filter tags or the
 *      callback function returns FALSE.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave filter tag details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFILTERTAGDETAILS | paftd | Specifies a pointer to the
 *      <t ACMFILTERTAGDETAILS> structure that is to receive the filter
 *      tag details passed to the <p fnCallback> function. This structure
 *      must have the <e ACMFILTERTAGDETAILS.cbStruct> member of the
 *      <t ACMFILTERTAGDETAILS> structure initialized.
 *
 *  @parm ACMFILTERTAGENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function. The callback
 *      address must be created by the <f MakeProcInstance> function, or
 *      the callback function must contain the proper prolog and epilog code
 *      for callbacks.
 *
 *  @parm DWORD_PTR | dwInstance | Specifies a pointer sized,
 *      application-defined value that is passed to the callback function
 *      along with ACM filter tag details.
 *
 *  @parm DWORD | fdwEnum | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *  @comm The <f acmFilterTagEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no suitable ACM drivers are installed. Moreover, the
 *      callback function will not be called.
 *
 *  @xref <f acmFilterTagEnumCallback> <f acmFilterTagDetails>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFilterTagEnum
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    ACMFILTERTAGENUMCB      fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
)
{
    PACMGARB		pag;
    PACMDRIVER          pad;
    PACMDRIVERID        padid;
    UINT                uIndex;
    UINT                uFilterTag;
    BOOL                f;
    HACMDRIVERID        hadid;
    PACMDRIVERID        padidCur;
    HACMDRIVERID        hadidCur;
    BOOL                fSent;
    DWORD               cbaftd;
    DWORD               fdwSupport;
    MMRESULT		mmr;
    
    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFilterTagEnum: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }
    
    //
    //
    //
    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwEnum, ACM_FILTERTAGENUMF_VALID, acmFilterTagEnum, MMSYSERR_INVALFLAG);
    
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFILTERTAGDETAILS) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterTagEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);
    
    if (0L != paftd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFilterTagEnum: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    cbaftd = min(paftd->cbStruct, sizeof(ACMFILTERTAGDETAILS));


    //
    //
    //
    //
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

        //
        //  enum filter tags for this driver only.
        //
        pad   = (PACMDRIVER)had;
        padid = (PACMDRIVERID)pad->hadid;

        //
        //  do NOT include the 'disabled' bit!
        //
        fdwSupport = padid->fdwSupport;

        //
        //  while there are Filters to enumerate and we have not been
        //  told to stop (client returns FALSE to stop enum)
        //
	mmr = MMSYSERR_NOERROR;
        for (uIndex = 0; uIndex < padid->cFilterTags; uIndex++)
        {
	    paftd->cbStruct = cbaftd;
	    paftd->dwFilterTagIndex = uIndex;
	    mmr = IFilterTagDetails(pag, (HACMDRIVERID)padid, paftd, ACM_FILTERTAGDETAILSF_INDEX);
	    if (MMSYSERR_NOERROR != mmr) {
		break;
	    }
	    
            f = (* fnCallback)(pad->hadid, paftd, dwInstance, fdwSupport);
            if (FALSE == f)
                break;
        }

        return (mmr);
    }


    //
    //
    //
    //
    hadidCur = NULL;

    ENTER_LIST_SHARED;

    while (!IDriverGetNext(pag, &hadidCur, hadidCur, 0L))
    {
        padidCur = (PACMDRIVERID)hadidCur;

        for (uIndex = 0; uIndex < padidCur->cFilterTags; uIndex++)
        {
            uFilterTag = (UINT)(padidCur->paFilterTagCache[uIndex].dwFilterTag);
            fSent = FALSE;
            hadid = NULL;
            while (!fSent && !IDriverGetNext(pag, &hadid, hadid, 0L))
            {
                UINT    u;

                //
                //  same driver ?
                //
                if (hadid == hadidCur)
                    break;


                //
                //  for every previous driver 
                //
                padid = (PACMDRIVERID)hadid;

                for (u = 0; u < padid->cFilterTags; u++)
                {
                    //
                    //  for every FilterTag in the driver 
                    //
                    if (uFilterTag == padid->paFilterTagCache[u].dwFilterTag)
                    {
                        //
                        //  we have a match, but this was already given.
                        //
                        fSent = TRUE;
                        break;
                    }
                }
            }

            if (!fSent)
            {
                //
                //  we have a filter that has not been sent yet.
                //
		paftd->dwFilterTagIndex = uIndex;
		paftd->cbStruct = cbaftd;
		mmr = IFilterTagDetails(pag, (HACMDRIVERID)padidCur,
					paftd, ACM_FILTERTAGDETAILSF_INDEX);
		if (MMSYSERR_NOERROR != mmr)
		{
		    LEAVE_LIST_SHARED;
		    return mmr;
		}

                //
                //  do NOT include the 'disabled' bit!
                //
                fdwSupport = padidCur->fdwSupport;

                f = (* fnCallback)(hadidCur, paftd, dwInstance, fdwSupport);
                if (FALSE == f) {
                    LEAVE_LIST_SHARED;
                    return (MMSYSERR_NOERROR);
		}
            }
        }
    }

    LEAVE_LIST_SHARED;

    return (MMSYSERR_NOERROR);
}


#ifdef WIN32
#if TRUE    // defined(UNICODE)

typedef struct tIFILTERTAGENUMCBINSTANCEW
{
    ACMFILTERTAGENUMCBA         fnCallback;
    DWORD_PTR                   dwInstance;
    LPACMFILTERTAGDETAILSA      paftd;

} IFILTERTAGENUMCBINSTANCEW, *PIFILTERTAGENUMCBINSTANCEW;

BOOL FNWCALLBACK IFilterTagEnumCallbackW
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILSW  paftdW,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    PIFILTERTAGENUMCBINSTANCEW  pfti;
    BOOL                        f;

    pfti = (PIFILTERTAGENUMCBINSTANCEW)dwInstance;

    memcpy(&pfti->paftd->dwFilterTagIndex,
           &paftdW->dwFilterTagIndex,
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, szFilterTag) -
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, dwFilterTagIndex));

    pfti->paftd->cbStruct = sizeof(*pfti->paftd);
    Iwcstombs(pfti->paftd->szFilterTag, paftdW->szFilterTag, sizeof(pfti->paftd->szFilterTag));

    f = pfti->fnCallback(hadid, pfti->paftd, pfti->dwInstance, fdwSupport);

    return (f);
}


MMRESULT ACMAPI acmFilterTagEnumA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    ACMFILTERTAGENUMCBA     fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT                    mmr;
    ACMFILTERTAGDETAILSW        aftdW;
    IFILTERTAGENUMCBINSTANCEW   fti;

    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*paftd) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterTagEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    aftdW.cbStruct = sizeof(aftdW);
    memcpy(&aftdW.dwFilterTagIndex,
           &paftd->dwFilterTagIndex,
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, szFilterTag) -
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, dwFilterTagIndex));

    fti.fnCallback = fnCallback;
    fti.dwInstance = dwInstance;
    fti.paftd      = paftd;

    mmr = acmFilterTagEnumW(had, &aftdW, IFilterTagEnumCallbackW, (DWORD_PTR)&fti, fdwEnum);

    return (mmr);
}
#else
MMRESULT ACMAPI acmFilterTagEnumW
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSW  paftd,
    ACMFILTERTAGENUMCBW     fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


//--------------------------------------------------------------------------;
//  
//  MMRESULT IFilterEnum
//  
//  Description:
//  
//  
//  Arguments:
//      HACMDRIVERID hadid:
//  
//      LPACMFILTERTAGDETAILS paftd:
//  
//      LPACMFILTERDETAILS pafd:
//  
//      ACMFILTERENUMCB fnCallback:
//  
//      DWORD_PTR dwInstance:
//  
//  Return (MMRESULT):
//  
//  History:
//      06/17/93    cjp     [curtisp]
//  
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IFilterEnum
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILS   paftd,
    LPACMFILTERDETAILS      pafd,
    ACMFILTERENUMCB         fnCallback,
    DWORD_PTR               dwInstance
)
{
    MMRESULT            mmr;
    BOOL                f;
    DWORD               cbafd;
    LPWAVEFILTER        pwfltr;
    DWORD               cbwfltr;
    UINT                u;
    PACMDRIVERID        padid;
    DWORD               fdwSupport;

    //
    //  be a bit paranoid and save some stuff so we can always reinit
    //  the structure between calling the driver (i just don't trust
    //  driver writers... though Media Vision is bound to find a way
    //  to cause trouble anyway)
    //
    cbafd   = pafd->cbStruct;
    pwfltr  = pafd->pwfltr;
    cbwfltr = pafd->cbwfltr;

    padid = (PACMDRIVERID)hadid;

    //
    //  do NOT include whether the 'disabled' bit!
    //
    fdwSupport = padid->fdwSupport;


    //
    //
    //
    for (u = 0; u < paftd->cStandardFilters; u++)
    {
        pafd->cbStruct      = cbafd;
        pafd->dwFilterIndex = u;
        pafd->dwFilterTag   = paftd->dwFilterTag;
        pafd->fdwSupport    = 0;
        pafd->pwfltr        = pwfltr;
        pafd->cbwfltr       = cbwfltr;

        if (FIELD_OFFSET(ACMFILTERDETAILS, szFilter) < cbafd)
            pafd->szFilter[0] = '\0';
        
        mmr = acmFilterDetails((HACMDRIVER)hadid,
                                pafd,
                                ACM_FILTERDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
            continue;

        f = (* fnCallback)(hadid, pafd, dwInstance, fdwSupport);
        if (FALSE == f)
            return (MMSYSERR_ERROR);
    }

    return (MMSYSERR_NOERROR);
} // IFilterEnum()


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api BOOL ACMFILTERENUMCB | acmFilterEnumCallback |
 *      <f acmFilterEnumCallback>  is a placeholder for an application-
 *      supplied function name and refers to the callback function used for
 *      Audio Compression Manager (ACM) wave filter detail enumeration.
 *     
 *
 *  @parm HACMDRIVERID | hadid | Specifies an ACM driver identifier.
 *
 *  @parm  LPACMFILTERDETAILS | pafd | Specifies a pointer to an
 *      <t ACMFILTERDETAILS> structure that contains the enumerated
 *      filter details for a filter tag.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f acmFilterEnum> function.
 *
 *  @parm DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the driver identifier <p hadid> for the specified filter. These flags
 *      are identical to the <e ACMDRIVERDETAILS.fdwSupport> flags of the
 *      <t ACMDRIVERDETAILS> structure, but are specific to the filter that
 *      is being enumerated. This argument can be a combination of the
 *      following values and identifies which operations the driver supports
 *      for the filter tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags while using
 *      the specified filter. For example, if a driver supports compression
 *      from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specifed
 *      filter, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified filter. For example, if a
 *      driver supports resampling of WAVE_FORMAT_PCM with the specified
 *      filter, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified filter tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output with the specified filter
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f acmFilterEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no filters are to be enumerated. Moreover, the callback
 *      function will not be called.
 *
 *  @xref <f acmFilterEnum> <f acmFilterTagDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api MMRESULT | acmFilterEnum | The <f acmFilterEnum> function
 *      enumerates wave filters available for a given filter tag from
 *      an Audio Compression Manager (ACM) driver. The <f acmFilterEnum>
 *      function continues enumerating until there are no more suitable
 *      filters for the filter tag or the callback function returns FALSE.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave filter details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFILTERDETAILS | pafd | Specifies a pointer to the
 *      <t ACMFILTERDETAILS> structure that is to receive the filter details
 *      passed to the <p fnCallback> function. This structure must have the
 *      <e ACMFILTERDETAILS.cbStruct>, <e ACMFILTERDETAILS.pwfltr>, and
 *      <e ACMFILTERDETAILS.cbwfltr> members of the <t ACMFILTERDETAILS>
 *      structure initialized. The <e ACMFILTERDETAILS.dwFilterTag> member
 *      must also be initialized to either WAVE_FILTER_UNKNOWN or a 
 *      valid filter tag.
 *
 *  @parm ACMFILTERENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function. The callback
 *      address must be created by the <f MakeProcInstance> function, or
 *      the callback function must contain the proper prolog and epilog code
 *      for callbacks.
 *
 *  @parm DWORD | dwInstance | Specifies a 32-bit, application-defined value
 *      that is passed to the callback function along with ACM filter details.
 *
 *  @parm DWORD | fdwEnum | Specifies flags for enumerating the filters for
 *      a given filter tag.
 *
 *      @flag ACM_FILTERENUMF_DWFILTERTAG | Specifies that the
 *      <e WAVEFILTER.dwFilterTag> member of the <t WAVEFILTER> structure
 *      referred to by the <e ACMFILTERDETAILS.pwfltr> member of the 
 *      <t ACMFILTERDETAILS> structure is valid. The enumerator will only
 *      enumerate a filter that conforms to this attribute. Note that the
 *      <e ACMFILTERDETAILS.dwFilterTag> member of the <t ACMFILTERDETAILS>
 *      structure must be equal to the <e WAVEFILTER.dwFilterTag> member.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details for the filter cannot be
 *      returned.
 *
 *  @comm The <f acmFilterEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no suitable ACM drivers are installed. Moreover, the
 *      callback function will not be called.
 *
 *  @xref <f acmFilterEnumCallback> <f acmFilterDetails> <f acmFilterSuggest>
 *      <f acmFilterTagDetails> <f acmFormatEnum>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFilterEnum
(
    HACMDRIVER          had,
    LPACMFILTERDETAILS  pafd,
    ACMFILTERENUMCB     fnCallback,
    DWORD_PTR           dwInstance, 
    DWORD               fdwEnum
)
{
    PACMGARB		pag;
    MMRESULT		mmr;
    PACMDRIVER		pad;
    PACMDRIVERID	padid;
    HACMDRIVERID	hadid;
    PACMDRIVERID	padidCur;
    PACMDRIVERID	padidBestCount;
    DWORD		cBestCount;
    HACMDRIVERID	hadidCur;
    ACMFILTERTAGDETAILS	aftd;
    UINT		u;
    UINT		uBestCount;
    UINT		uIndex;
    UINT		uFilterTag;
    BOOL		fDone;
    BOOL		fStop;
    
    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFilterEnum: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }
    
    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFILTERDETAILS) > pafd->cbStruct)
    {                     
        DebugErr(DBF_ERROR, "acmFilterEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
    }
    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwEnum, ACM_FILTERENUMF_VALID, acmFilterEnum, MMSYSERR_INVALFLAG);
    if (sizeof(WAVEFILTER) > pafd->cbwfltr)
    {
        DebugErr(DBF_ERROR, "acmFilterEnum: cbwfltr member must be at least sizeof(WAVEFILTER).");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd->pwfltr, pafd->cbwfltr, MMSYSERR_INVALPARAM);
    
    if (0L != pafd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFilterEnum: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }


    //
    //  Get the restrictions on the enum.
    //
    if( fdwEnum & ACM_FILTERENUMF_DWFILTERTAG ) {
        uFilterTag = (UINT)(pafd->pwfltr->dwFilterTag);

        if (WAVE_FILTER_UNKNOWN == uFilterTag)
        {
            DebugErr(DBF_ERROR, "acmFilterEnum: ACM_FILTERENUMF_DWFILTERTAG cannot be used with WAVE_FILTER_UNKNOWN.");
            return (MMSYSERR_INVALPARAM);
        }

#if 0
        if (pafd->dwFilterTag != uFilterTag)
        {
            DebugErr(DBF_ERROR, "acmFilterEnum: filter tags must match.");
            return  (MMSYSERR_INVALPARAM);
        }
#endif
    } else {
        uFilterTag = WAVE_FILTER_UNKNOWN;
    }

    //
    //
    //
    mmr = MMSYSERR_NOERROR;


    //
    //
    //
    //
    if (NULL != had)
    {
        pad   = (PACMDRIVER)had;
        padid = (PACMDRIVERID)pad->hadid;

        //
        //  step through all Filter tags that the caller is interested in
        //  and enumerate the Filters...
        //
        for (u = 0; u < padid->cFilterTags; u++)
        {
            if( fdwEnum & ACM_FILTERENUMF_DWFILTERTAG ) {
                if (uFilterTag != padid->paFilterTagCache[u].dwFilterTag)
                    continue;
            }

	    aftd.cbStruct = sizeof(aftd);
	    aftd.dwFilterTagIndex = u;
	    mmr = IFilterTagDetails( pag, (HACMDRIVERID)padid,
				     &aftd, ACM_FILTERTAGDETAILSF_INDEX );

	    if (MMSYSERR_NOERROR == mmr)
	    {

		mmr = IFilterEnum( pad->hadid,
				   &aftd,
				   pafd,
				   fnCallback,
				   dwInstance );

	    }
            
            if( mmr == MMSYSERR_ERROR ) {
                // Returned generic error to stop the enumeration.
                mmr = MMSYSERR_NOERROR;
                break;
            }
            if( fdwEnum & ACM_FILTERENUMF_DWFILTERTAG ) {
                break;
            }
        }
    } else if( fdwEnum & ACM_FILTERENUMF_DWFILTERTAG ) {
        hadid = NULL;
        fDone = FALSE;
	padidBestCount = NULL;
	cBestCount     = 0;

        ENTER_LIST_SHARED;

        while( !IDriverGetNext(pag, &hadid, hadid, 0L) ) {
            padid = (PACMDRIVERID)hadid;

            //
            //  find the Filter tag that the caller is interested in and
            //  enumerate the Filters...
            //
            for (u = 0; u < padid->cFilterTags; u++)
            {
                if (uFilterTag != padid->paFilterTagCache[u].dwFilterTag)
                    continue;

		aftd.cbStruct = sizeof(aftd);
		aftd.dwFilterTagIndex = u;
		mmr = IFilterTagDetails( pag, (HACMDRIVERID)padid,
					 &aftd, ACM_FILTERTAGDETAILSF_INDEX );

		if( !padidBestCount ||
		    (aftd.cStandardFilters > cBestCount) ) {
		    padidBestCount = padid;
		    uBestCount = u;
		    cBestCount = aftd.cStandardFilters;
		}
		break;
            }
	}

	if( padidBestCount ) {
	    
	    aftd.cbStruct = sizeof(aftd);
	    aftd.dwFilterTagIndex = uBestCount;
	    mmr = IFilterTagDetails( pag, (HACMDRIVERID)padidBestCount,
				     &aftd, ACM_FILTERTAGDETAILSF_INDEX );

	    if (MMSYSERR_NOERROR == mmr)
	    {
		mmr = IFilterEnum( (HACMDRIVERID)padidBestCount,
				   &aftd,
				   pafd,
                                   fnCallback,
                                   dwInstance);
	    }
	    
	    if( mmr == MMSYSERR_ERROR ) {
		// Returned generic error to stop the enumeration.
		mmr = MMSYSERR_NOERROR;
	    }
	    fDone = TRUE;
        }

        LEAVE_LIST_SHARED;

    } else {
        // Enum Filters across all drivers.

        fStop = FALSE;
        hadidCur = NULL;

        ENTER_LIST_SHARED;

        while( !fStop && !IDriverGetNext(pag, &hadidCur, hadidCur, 0L)) {
            padidCur = (PACMDRIVERID)hadidCur;

            for (uIndex = 0; (uIndex < padidCur->cFilterTags)
                              && !fStop; uIndex++) {
                uFilterTag =
                        (UINT)(padidCur->paFilterTagCache[uIndex].dwFilterTag);
                fDone = FALSE;
                hadid = NULL;
                while (!fDone && !IDriverGetNext(pag, &hadid, hadid, 0L)) {

                    //
                    //  same driver ?
                    //
                    if (hadid == hadidCur)
                        break;


                    //
                    //  for every previous driver 
                    //
                    padid = (PACMDRIVERID)hadid;

                    for (u = 0; u < padid->cFilterTags; u++) {
                        //
                        //  for every FilterTag in the driver 
                        //
                        if (uFilterTag ==
                                padid->paFilterTagCache[u].dwFilterTag) {
                            //
                            //  we have a match, but this was already given.
                            //
                            fDone = TRUE;
                            break;
                        }
                    }
                }

                if (!fDone) {
                    //
                    //  we have a Filter that has not been sent yet.
                    //
		    aftd.cbStruct = sizeof(aftd);
		    aftd.dwFilterTagIndex = uIndex;
		    mmr = IFilterTagDetails( pag, hadid, &aftd,
					     ACM_FILTERTAGDETAILSF_INDEX );
		    
		    if (MMSYSERR_NOERROR == mmr)
		    {
			mmr = IFilterEnum( hadid,
					   &aftd,
					   pafd,
					   fnCallback,
					   dwInstance );
		    }
		    
                    if( mmr == MMSYSERR_ERROR ) {
                        // Returned generic error to stop the enumeration.
                        mmr = MMSYSERR_NOERROR;
                        fStop = TRUE;
                        break;
                    }
                }
            }
        }

        LEAVE_LIST_SHARED;
    }


    //
    //
    //
    //
    return (mmr);
 }

#ifdef WIN32
#if TRUE    // defined(UNICODE)

typedef struct tIFILTERENUMCBINSTANCEW
{
    ACMFILTERENUMCBA            fnCallback;
    DWORD_PTR                   dwInstance;
    LPACMFILTERDETAILSA         pafd;

} IFILTERENUMCBINSTANCEW, *PIFILTERENUMCBINSTANCEW;

BOOL FNWCALLBACK IFilterEnumCallbackW
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILSW     pafdW,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    PIFILTERENUMCBINSTANCEW     pfi;
    BOOL                        f;

    pfi = (PIFILTERENUMCBINSTANCEW)dwInstance;

    memcpy(&pfi->pafd->dwFilterIndex,
           &pafdW->dwFilterIndex,
           FIELD_OFFSET(ACMFILTERDETAILSA, szFilter) -
           FIELD_OFFSET(ACMFILTERDETAILSA, dwFilterIndex));

    pfi->pafd->cbStruct = sizeof(*pfi->pafd);
    Iwcstombs(pfi->pafd->szFilter, pafdW->szFilter, sizeof(pfi->pafd->szFilter));

    f = pfi->fnCallback(hadid, pfi->pafd, pfi->dwInstance, fdwSupport);

    return (f);
}


MMRESULT ACMAPI acmFilterEnumA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    ACMFILTERENUMCBA        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT                    mmr;
    ACMFILTERDETAILSW           afdW;
    IFILTERENUMCBINSTANCEW      fi;

    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*pafd) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    afdW.cbStruct = sizeof(afdW);
    memcpy(&afdW.dwFilterIndex,
           &pafd->dwFilterIndex,
           FIELD_OFFSET(ACMFILTERDETAILSA, szFilter) -
           FIELD_OFFSET(ACMFILTERDETAILSA, dwFilterIndex));

    fi.fnCallback = fnCallback;
    fi.dwInstance = dwInstance;
    fi.pafd       = pafd;

    mmr = acmFilterEnumW(had, &afdW, IFilterEnumCallbackW, (DWORD_PTR)&fi, fdwEnum);

    return (mmr);
}
#else
MMRESULT ACMAPI acmFilterEnumW
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSW     pafd,
    ACMFILTERENUMCBW        fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\acmdrvr.c ===
/****************************************************************************
 *
 *   acmdrvr.c
 *
 *   Copyright (c) 1991-1999 Microsoft Corporation
 *
 *   This module provides ACM driver add/remove/enumeration
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include "msacm.h"
#include "msacmdrv.h"
#include <stdlib.h>
#include "acmi.h"
#include "uchelp.h"
#include "debug.h"


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverID | Returns the handle to an Audio Compression
 *      Manager (ACM) driver identifier associated with an open ACM driver
 *      instance or stream handle. <t HACMOBJ> is the handle to an ACM
 *      object, such as an open <t HACMDRIVER> or <t HACMSTREAM>.
 *
 *  @parm HACMOBJ | hao | Specifies the open driver instance or stream
 *      handle.
 *
 *  @parm LPHACMDRIVERID | phadid | Specifies a pointer to an <t HACMDRIVERID>
 *      handle. This location is filled with a handle identifying the
 *      installed driver that is associated with the <p hao>.
 *
 *  @parm DWORD | fdwDriverID | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *  @xref <f acmDriverDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverID
(
    HACMOBJ                 hao,
    LPHACMDRIVERID          phadid,
    DWORD                   fdwDriverID
)
{
    V_HANDLE(hao, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);
    V_WPOINTER(phadid, sizeof(HACMDRIVERID), MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwDriverID, ACM_DRIVERIDF_VALID, acmDriverID, MMSYSERR_INVALFLAG);

    switch (*(UINT *)hao)
    {
        case TYPE_HACMDRIVERID:
            V_HANDLE(hao, TYPE_HACMDRIVERID, MMSYSERR_INVALPARAM);

            *phadid = (HACMDRIVERID)hao;
            break;

        case TYPE_HACMDRIVER:
            V_HANDLE(hao, TYPE_HACMDRIVER, MMSYSERR_INVALPARAM);

            *phadid = ((PACMDRIVER)hao)->hadid;
            break;

        case TYPE_HACMSTREAM:
            V_HANDLE(hao, TYPE_HACMSTREAM, MMSYSERR_INVALPARAM);

            *phadid = ((PACMDRIVER)((PACMSTREAM)hao)->had)->hadid;
            break;

        default:
            return (MMSYSERR_INVALPARAM);
    }

    return (MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api LRESULT CALLBACK | acmDriverProc | The <f acmDriverProc> function
 *      is a placeholder for an application-defined function name, and refers to the
 *      callback function used with the ACM. The actual name
 *      must be exported by including it in the module-deefinition file of the
 *      executable or DLL.
 *
 *  @parm DWORD | dwID | Specifies an identifier of the installable ACM
 *      driver.
 *
 *  @parm HDRIVER | hdrvr | Identifies the installable ACM driver. This
 *      argument is a unique handle the ACM assigns to the driver.
 *
 *  @parm UINT | uMsg | Specifies an ACM driver message.
 *
 *  @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 *  @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 *  @xref <f acmDriverAdd> <f acmDriverRemove> <f acmDriverDetails>
 *      <f acmDriverOpen> <f DriverProc>
 *
 ***************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverAdd | Adds a driver to the list of available
 *      Audio Compression Manager (ACM) drivers. The driver type and
 *      location are dependent on the <p fdwAdd> flags. Once a driver is
 *      successfully added, the driver entry function will receive ACM
 *      driver messages.
 *
 *  @parm LPHACMDRIVERID | phadid | Specifies a pointer to an <t HACMDRIVERID>
 *      handle. This location is filled with a handle identifying the
 *      installed driver. Use the handle to identify the driver when
 *      calling other ACM functions.
 *
 *  @parm HINSTANCE | hinstModule | Identifies the instance of the module
 *      whose executable or dynamic link library (DLL) contains the driver
 *      entry function.
 *
 *  @parm LPARAM | lParam | <p lParam> is a handle to an installable driver
 *      or a driver function address, depending on the <p fdwAdd> flags.
 *
 *  @parm DWORD | dwPriority | This parameter is currently only used with
 *      the ACM_DRIVERADDF_NOTIFYHWND flag to specify the window message
 *      to send for notification broadcasts. All other flags require that
 *      this member be set to zero.
 *
 *  @parm DWORD | fdwAdd | Specifies flags for adding ACM drivers.
 *
 *      @flag ACM_DRIVERADDF_GLOBAL | Specifies if the driver can be used
 *      by any application in the system. This flag may not be used with
 *      functions contained in executables.
 *
 *      @flag ACM_DRIVERADDF_FUNCTION | Specifies that <p lParam> is a driver
 *      function address conforming to the <f acmDriverProc> prototype. The
 *      function may reside in either an executable or a DLL. If the
 *      ACM_DRIVERADDF_GLOBAL flag is specified, then the function must
 *      reside in a .DLL.
 *
 *      @flag ACM_DRIVERADDF_NOTIFYHWND | Specifies that <p lParam> is a
 *      notification window handle to receive messages when changes to
 *      global driver priorities and states are made. The window message
 *      to receive is defined by the application and must be passed in
 *      the <p dwPriority> argument. The <p wParam> and <p lParam> arguments
 *      passed with the window message are reserved for future use and
 *      should be ignored. The ACM_DRIVERADDF_GLOBAL flag cannot be
 *      specified in conjunction with the ACM_DRIVERADDF_NOTIFYHWND flag.
 *      See the description for <f acmDriverPriority> for more information
 *      on driver priorities.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *  @comm If the ACM_DRIVERADDF_GLOBAL flag is not set, only the current
 *      task when the driver entry is added will be able to use it. Global
 *      drivers that are added as functions must reside in a DLL.
 *
 *  @xref <f acmDriverProc> <f acmDriverRemove> <f acmDriverDetails>
 *      <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverAdd
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam,
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    PACMGARB                pag;
    MMRESULT                mmr;
    PACMDRIVERID            padid;
    BOOL                    fIsNotify;
    BOOL                    fIsLocal;

    V_WPOINTER(phadid, sizeof(HACMDRIVERID), MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwAdd, ACM_DRIVERADDF_VALID, acmDriverAdd, MMSYSERR_INVALFLAG);

    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmDriverAdd: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }
    

    if (threadQueryInListShared(pag))
    {
	return (ACMERR_NOTPOSSIBLE);
    }
    ENTER_LIST_EXCLUSIVE;
    mmr = IDriverAdd(pag, phadid, hinstModule, lParam, dwPriority, fdwAdd);
    LEAVE_LIST_EXCLUSIVE;

    if( MMSYSERR_NOERROR != mmr )
        return mmr;


    //
    //  if deferred broadcast is not enabled, then do a change broadcast
    //
    //  do NOT refresh global cache for local and notification handles
    //
    padid     = (PACMDRIVERID)(*phadid);
    fIsNotify = (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver));
    fIsLocal  = (0 != (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));

    if( !fIsLocal && !fIsNotify )
    {
        IDriverRefreshPriority( pag );
        if( !IDriverLockPriority( pag,
                                  GetCurrentTask(),
                                  ACMPRIOLOCK_ISLOCKED ) )
        {
            IDriverPrioritiesSave( pag );
            IDriverBroadcastNotify( pag );
        }
    }

    return MMSYSERR_NOERROR;
}


#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmDriverAddA
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam,
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    WCHAR               szAlias[MAX_DRIVER_NAME_CHARS];


    if (ACM_DRIVERADDF_NAME == (ACM_DRIVERADDF_TYPEMASK & fdwAdd))
    {
        szAlias[0] = L'\0';     // Init to emptry string in case Imbstowcs fails

	Imbstowcs(szAlias, (LPSTR)lParam, SIZEOF(szAlias));

        lParam = (LPARAM)szAlias;
    }

    return acmDriverAdd( phadid, hinstModule, lParam, dwPriority, fdwAdd );
}
#else
MMRESULT ACMAPI acmDriverAddW
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam,
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverRemove | Removes an Audio Compression Manager
 *      (ACM) driver from the list of available ACM drivers.
 *
 *  @parm HACMDRIVERID | hadid | Handle to the driver identifier to be
 *      removed.
 *
 *  @parm DWORD | fdwRemove | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_BUSY | The driver is in use and cannot be removed.
 *
 *  @xref <f acmDriverAdd>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
)
{
    PACMGARB                pag;
    MMRESULT                mmr;
    PACMDRIVERID            padid;
    BOOL                    fIsNotify;
    BOOL                    fIsLocal;

    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmDriverRemove: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }
    
    V_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwRemove, ACM_DRIVERREMOVEF_VALID, acmDriverRemove, MMSYSERR_INVALFLAG);


    padid     = (PACMDRIVERID)hadid;

    fIsNotify = (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver));
    fIsLocal  = (0 != (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));


    if (threadQueryInListShared(pag))
    {
	return (ACMERR_NOTPOSSIBLE);
    }
    ENTER_LIST_EXCLUSIVE;
    mmr = IDriverRemove( hadid, fdwRemove );
    LEAVE_LIST_EXCLUSIVE;

    if( MMSYSERR_NOERROR != mmr )
        return mmr;


    //
    //  if deferred broadcast is not enabled, then do a change broadcast
    //
    //  do NOT refresh global cache for local and notification handles
    //
    if( !fIsLocal && !fIsNotify )
    {
        IDriverRefreshPriority( pag );
        if( !IDriverLockPriority( pag,
                                  GetCurrentTask(),
                                  ACMPRIOLOCK_ISLOCKED ) )
        {
            IDriverPrioritiesSave( pag );
            IDriverBroadcastNotify( pag );
        }
    }

    return MMSYSERR_NOERROR;
}



/****************************************************************************
 *
 *  @doc EXTERNAL ACM_API
 *
 *  @api BOOL ACMDRIVERENUMCB | acmDriverEnumCallback | The
 *      <f acmDriverEnumCallback> function is a placeholder for an
 *      application-defined function name, and refers to the callback function
 *     used with <f acmDriverEnum>.
 *
 *  @parm HACMDRIVERID | hadid | Specifies an ACM driver identifier.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f acmDriverEnum> function.
 *
 *  @parm DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the driver identifier <p hadid>. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure. This argument can be a combination of the following
 *      values:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags. For example,
 *      if a driver supports compression from WAVE_FORMAT_PCM to
 *      WAVE_FORMAT_ADPCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag. For example, if a driver supports resampling of
 *      WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_DISABLED | Specifies that this
 *      driver has been disabled. An application must specify the
 *      ACM_DRIVERENUMF_DISABLED to the <f acmDriverEnum> function to
 *      include disabled drivers in the enumeration.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f acmDriverEnum> function will return MMSYSERR_NOERROR (zero)
 *      if no ACM drivers are installed. Moreover, the callback function will
 *      not be called.
 *
 *  @xref <f acmDriverEnum> <f acmDriverDetails> <f acmDriverOpen>
 *
 ***************************************************************************/


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverEnum | The <f acmDriverEnum> function enumerates
 *      the available Audio Compression Manager (ACM) drivers, continuing
 *      until there are no more ACM drivers or the callback function returns FALSE.
 *
 *  @parm ACMDRIVERENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function. The callback
 *      address must be created by the <f MakeProcInstance> function, or
 *      the callback function must contain the proper prolog and epilog code
 *      for callbacks.
 *
 *  @parm DWORD | dwInstance | Specifies a 32-bit application-defined value
 *      that is passed to the callback function along with ACM driver
 *      information.
 *
 *  @parm DWORD | fdwEnum | Specifies flags for enumerating ACM drivers.
 *
 *      @flag ACM_DRIVERENUMF_DISABLED | Specifies that disabled ACM drivers
 *      should be included in the enumeration. Drivers can be disabled
 *      through the Sound Mapper Control Panel option. If a driver is
 *      disabled, the <p fdwSupport> argument to the callback function will
 *      have the ACMDRIVERDETAILS_SUPPORTF_DISABLED flag set.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *  @comm The <f acmDriverEnum> function will return MMSYSERR_NOERROR (zero)
 *      if no ACM drivers are installed. Moreover, the callback function will
 *      not be called.
 *
 *  @xref <f acmDriverEnumCallback> <f acmDriverDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverEnum
(
    ACMDRIVERENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
)
{
    PACMGARB	    pag;
    MMRESULT        mmr;
    HACMDRIVERID    hadid;
    BOOL            f;
    DWORD           fdwSupport;
    HTASK           htask;

    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmDriverEnum: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }
    
    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwEnum, ACM_DRIVERENUMF_VALID, acmDriverEnum, MMSYSERR_INVALFLAG);


    //
    //  If we don't have it locked, then update the priorities from the
    //  INI file before changing anything.  The GETLOCK call will fail
    //  if we already have it locked...
    //
    if (!threadQueryInListShared(pag))
    {
	htask = GetCurrentTask();
	if( !IDriverLockPriority( pag, htask, ACMPRIOLOCK_ISLOCKED ) )
	{
	    ENTER_LIST_EXCLUSIVE;
            if( IDriverPrioritiesRestore(pag) ) {   // Something changed!
                IDriverBroadcastNotify( pag );      
            }
	    LEAVE_LIST_EXCLUSIVE;
	}
    }


    hadid = NULL;

    ENTER_LIST_SHARED;

    while (!IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        mmr = IDriverSupport(hadid, &fdwSupport, TRUE);
        if (MMSYSERR_NOERROR != mmr)
        {
            continue;
        }

        //
        //  do the callback--if the client returns FALSE we need to
        //  terminate the enumeration process...
        //
        f = (* fnCallback)(hadid, dwInstance, fdwSupport);
        if (FALSE == f)
            break;
    }

    LEAVE_LIST_SHARED;

    return (MMSYSERR_NOERROR);
}


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMDRIVERDETAILS | The <t ACMDRIVERDETAILS> structure describes
 *      various details of an Audio Compression Manager (ACM) driver.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes,  of the valid
 *      information contained in the <t ACMDRIVERDETAILS> structure.
 *      An application should initialize this member to the size, in bytes, of
 *      the desired information. The size specified in this member must be
 *      large enough to contain the <e ACMDRIVERDETAILS.cbStruct> member of
 *      the <t ACMDRIVERDETAILS> structure. When the <f acmDriverDetails>
 *      function returns, this member contains the actual size of the
 *      information returned. The returned information will never exceed
 *      the requested size.
 *
 *  @field FOURCC | fccType | Specifies the type of the driver. For ACM drivers, set
 *      this member  to <p audc>, which represents ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC.
 *
 *  @field FOURCC | fccComp | Specifies the sub-type of the driver. This
 *      member is currently set to ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (zero).
 *
 *  @field WORD | wMid | Specifies a manufacturer ID for the ACM driver.
 *
 *  @field WORD | wPid | Specifies a product ID for the ACM driver.
 *
 *  @field DWORD | vdwACM | Specifies the version of the ACM for which
 *      this driver was compiled. The version number is a hexadecimal number
 *      in the format 0xAABBCCCC, where AA is the major version number,
 *      BB is the minor version number, and CCCC is the build number.
 *      Note that the version parts (major, minor, and build) should be
 *      displayed as decimal numbers.
 *
 *  @field DWORD | vdwDriver | Specifies the version of the driver.
 *      The version number is a hexadecimal number in the format 0xAABBCCCC, where
 *      AA is the major version number, BB is the minor version number,
 *      and CCCC is the build number. Note that the version parts (major,
 *      minor, and build) should be displayed as decimal numbers.
 *
 *  @field DWORD | fdwSupport | Specifies support flags for the driver.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags. For example,
 *      if a driver supports compression from WAVE_FORMAT_PCM to
 *      WAVE_FORMAT_ADPCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag. For example, if a driver supports resampling of
 *      WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output through a waveform device. An
 *      application should use <f acmMetrics> with the
 *      ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT
 *      metric indexes to get the waveform device identifiers associated with
 *      the supporting ACM driver.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_DISABLED | Specifies that this driver
 *      has been disabled. This flag is set by the ACM for a driver when
 *      it has been disabled for any of a number of reasons. Disabled
 *      drivers cannot be opened and can only be used under very limited
 *      circumstances.
 *
 *  @field DWORD | cFormatTags | Specifies the number of unique format tags
 *      supported by this driver.
 *
 *  @field DWORD | cFilterTags | Specifies the number of unique filter tags
 *      supported by this driver.
 *
 *  @field HICON | hicon | Specifies an optional handle to a custom icon for
 *      this driver. An application can use this icon for referencing the
 *      driver visually. This member can be NULL.
 *
 *  @field char | szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS] | Specifies
 *      a NULL-terminated string that describes the name of the driver. This
 *      string is intended to be displayed in small spaces.
 *
 *  @field char | szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS] | Specifies a
 *      NULL-terminated string that describes the full name of the driver.
 *      This string is intended to be displayed in large (descriptive)
 *      spaces.
 *
 *  @field char | szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS] | Specifies
 *      a NULL-terminated string that provides copyright information for the
 *      driver.
 *
 *  @field char | szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS] | Specifies a
 *      NULL-terminated string that provides special licensing information
 *      for the driver.
 *
 *  @field char | szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS] | Specifies a
 *      NULL-terminated string that provides special feature information for
 *      the driver.
 *
 *  @xref <f acmDriverDetails>
 *
 ****************************************************************************/


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverDetails | This function queries a specified
 *      Audio Compression Manager (ACM) driver to determine its capabilities.
 *
 *  @parm HACMDRIVERID | hadid | Handle to the driver identifier of an
 *      installed ACM driver. Disabled drivers can be queried for details.
 *
 *  @parm LPACMDRIVERDETAILS | padd | Pointer to an <t ACMDRIVERDETAILS>
 *      structure that will receive the driver details. The
 *      <e ACMDRIVERDETAILS.cbStruct> member must be initialized to the
 *      size, in bytes,  of the structure.
 *
 *  @parm DWORD | fdwDetails | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *  @xref <f acmDriverAdd> <f acmDriverEnum> <f acmDriverID>
 *      <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
)
{
    //
    //  note that we allow both HACMDRIVERID's and HACMDRIVER's
    //
    V_HANDLE(hadid, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);
    if (TYPE_HACMDRIVER == ((PACMDRIVERID)hadid)->uHandleType)
    {
        hadid = ((PACMDRIVER)hadid)->hadid;
    }
    V_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    V_WPOINTER(padd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(DWORD) > padd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmDriverDetails: cbStruct must be >= sizeof(DWORD).");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(padd, padd->cbStruct, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwDetails, ACM_DRIVERDETAILSF_VALID, acmDriverDetails, MMSYSERR_INVALFLAG);

    return (IDriverDetails(hadid, padd, fdwDetails));
}

#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmDriverDetailsA
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSA     padd,
    DWORD                   fdwDetails
)
{
    MMRESULT            mmr;
    LPACMDRIVERDETAILSA paddA;
    LPACMDRIVERDETAILSW paddW;

    V_WPOINTER(padd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(DWORD) > padd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmDriverDetails: cbStruct must be >= sizeof(DWORD).");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(padd, padd->cbStruct, MMSYSERR_INVALPARAM);

    paddA = (LPACMDRIVERDETAILSA)GlobalAlloc(GPTR, sizeof(*paddA));
    if (NULL == paddA)
    {
	return(MMSYSERR_NOMEM);
    }
    paddW = (LPACMDRIVERDETAILSW)GlobalAlloc(GPTR, sizeof(*paddW));
    if (NULL == paddW)
    {
	GlobalFree((HGLOBAL)paddA);
	return(MMSYSERR_NOMEM);
    }

    paddW->cbStruct = sizeof(ACMDRIVERDETAILSW);

    mmr = acmDriverDetailsW(hadid, paddW, fdwDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        memcpy(paddA, paddW, FIELD_OFFSET(ACMDRIVERDETAILSA, szShortName[0]));

        if (padd->cbStruct > (DWORD)FIELD_OFFSET(ACMDRIVERDETAILSA, szShortName[0]))
        {
            Iwcstombs(paddA->szShortName, paddW->szShortName, sizeof(paddA->szShortName));
            Iwcstombs(paddA->szLongName,  paddW->szLongName,  sizeof(paddA->szLongName));
            Iwcstombs(paddA->szCopyright, paddW->szCopyright, sizeof(paddA->szCopyright));
            Iwcstombs(paddA->szLicensing, paddW->szLicensing, sizeof(paddA->szLicensing));
            Iwcstombs(paddA->szFeatures,  paddW->szFeatures,  sizeof(paddA->szFeatures));
        }

        padd->cbStruct = min(padd->cbStruct, sizeof(*paddA));
        memcpy(&padd->fccType,
               &paddA->fccType,
               padd->cbStruct - FIELD_OFFSET(ACMDRIVERDETAILSA, fccType));
    }

    GlobalFree((HGLOBAL)paddW);
    GlobalFree((HGLOBAL)paddA);

    return (mmr);
}
#else
MMRESULT ACMAPI acmDriverDetailsW
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSW     padd,
    DWORD                   fdwDetails
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverPriority | This function modifies the priority
 *      and state of an Audio Compression Manager (ACM) driver.
 *
 *  @parm HACMDRIVERID | hadid | Handle to the driver identifier of an
 *      installed ACM driver. This argument must be NULL when specifying
 *      the ACM_DRIVERPRIORITYF_BEGIN and ACM_DRIVERPRIORITYF_END flags.
 *
 *  @parm DWORD | dwPriority | Specifies the new priority for a global
 *      ACM driver identifier. A zero value specifies that the priority of
 *      the driver identifier should remain unchanged. A value of one (1)
 *      specifies that the driver should be placed as the highest search
 *      priority driver. A value of (DWORD)-1 specifies that the driver
 *      should be placed as the lowest search priority driver. Priorities
 *      are only used for global drivers.
 *
 *  @parm DWORD | fdwPriority | Specifies flags for setting priorities of
 *      ACM drivers.
 *
 *      @flag ACM_DRIVERPRIORITYF_ENABLE | Specifies that the ACM driver
 *      should be enabled if it is currently disabled. Enabling an already
 *      enabled driver does nothing.
 *
 *      @flag ACM_DRIVERPRIORITYF_DISABLE | Specifies that the ACM driver
 *      should be disabled if it is currently enabled. Disabling an already
 *      disabled driver does nothing.
 *
 *      @flag ACM_DRIVERPRIORITYF_BEGIN | Specifies that the calling task
 *      wants to defer change notification broadcasts. An application must
 *      take care to reenable notification broadcasts as soon as possible
 *      with the ACM_DRIVERPRIORITYF_END flag. Note that <p hadid> must be
 *      NULL, <p dwPriority> must be zero, and only the
 *      ACM_DRIVERPRIORITYF_BEGIN flag can be set.
 *
 *      @flag ACM_DRIVERPRIORITYF_END | Specifies that the calling task
 *      wants to reenable change notification broadcasts. An application
 *      must call <f acmDriverPriority> with ACM_DRIVERPRIORITYF_END for
 *      each successful call with the ACM_DRIVERPRIORITYF_BEGIN flag. Note
 *      that <p hadid> must be NULL, <p dwPriority> must be zero, and only
 *      the ACM_DRIVERPRIORITYF_END flag can be set.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_ALLOCATED | Returned if the deferred broadcast lock
 *      is owned by a different task.
 *
 *      @flag MMSYSERR_NOTSUPPORTED | The requested operation is not
 *      supported for the specified driver. For example, local and notify
 *      driver identifiers do not support priorities (but can be enabled
 *      and disabled). This error will therefore be returned if an
 *      application specifies a non-zero <p dwPriority> for a local and
 *      notify driver identifiers.
 *
 *  @comm All driver identifiers can be enabled and disabled; this includes
 *      global, local and notification driver identifiers.
 *
 *      If more than one global driver identifier needs to be enabled,
 *      disabled or shifted in priority, then an application should defer
 *      change notification broadcasts using the ACM_DRIVERPRIORITYF_BEGIN
 *      flag. A single change notification will be broadcast when the
 *      ACM_DRIVERPRIORITYF_END flag is specified.
 *
 *      An application can use the <f acmMetrics> function with the
 *      ACM_METRIC_DRIVER_PRIORITY metric index to retrieve the current
 *      priority of a global driver. Also note that drivers are always
 *      enumerated from highest to lowest priority by the <f acmDriverEnum>
 *      function.
 *
 *      All enabled driver identifiers will receive change notifications.
 *      An application can register a notification message using the
 *      <f acmDriverAdd> function in conjunction with the
 *      ACM_DRIVERADDF_NOTIFYHWND flag. Note that changes to non-global
 *      driver identifiers will not be broadcast.
 *
 *      Note that global priorities are simply used for the search order
 *      when an application does not specify a driver. Boosting the
 *      priority of a driver will have no effect on the performance of
 *      a driver.
 *
 *  @xref <f acmDriverAdd> <f acmDriverEnum> <f acmDriverDetails>
 *      <f acmMetrics>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverPriority
(
    HACMDRIVERID            hadid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
)
{
    PACMGARB                pag;
    MMRESULT                mmr;
    HTASK                   htask;
    PACMDRIVERID            padid;
    DWORD                   fdwDeferred;
    BOOL                    fIsNotify;
    BOOL                    fIsLocal;
    DWORD                   cTotalGlobal;
    BOOL                    fSucceeded;


    DPF(2, "acmDriverPriorities: prio %ld f %.08Xh ", dwPriority, fdwPriority);


    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmDriverPriority: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //	If this thread already has a shared lock on the driver list, then
    //	we can't do much with priorities, so we'll just bail in that case.
    //
    if (threadQueryInListShared(pag))
    {
	return ACMERR_NOTPOSSIBLE;
    }


    htask = GetCurrentTask();

    //
    //  Validate the flags.
    //
    V_DFLAGS(fdwPriority, ACM_DRIVERPRIORITYF_VALID, acmDriverPriority, MMSYSERR_INVALFLAG);


    //
    //  Make sure that we are allowed to access the list.
    //
    if( !IDriverLockPriority( pag, htask, ACMPRIOLOCK_LOCKISOK ) )
    {
        DebugErr(DBF_WARNING, "acmDriverPriority: deferred lock owned by different task.");
        return (MMSYSERR_ALLOCATED);
    }


    //
    //  If we don't have it locked, then update the priorities from the
    //  INI file before changing anything.  The GETLOCK call will fail
    //  if we already have it locked...
    //
	if( !IDriverLockPriority( pag, htask, ACMPRIOLOCK_ISLOCKED ) )
    {
	ENTER_LIST_EXCLUSIVE;
        if( IDriverPrioritiesRestore(pag) ) {   // Something changed!
            IDriverBroadcastNotify( pag );      
        }
	LEAVE_LIST_EXCLUSIVE;
    }


    //
    //  If hadid is NULL, then they are requesting a lock on the priorities
    //  list.  On the BEGIN flag, give them the lock.  On the END flag,
    //  unlock the list and broadcast the new priorities.
    //
    if (NULL == hadid)
    {
        fdwDeferred = (ACM_DRIVERPRIORITYF_DEFERMASK & fdwPriority);

        switch (fdwDeferred)
        {
            case ACM_DRIVERPRIORITYF_BEGIN:
                fSucceeded = IDriverLockPriority( pag,
                                                  htask,
                                                  ACMPRIOLOCK_GETLOCK );
                if( !fSucceeded )
                {
                    DebugErr(DBF_WARNING, "acmDriverPriority: deferred lock already owned.");
                    return (MMSYSERR_ALLOCATED);
                }
                return (MMSYSERR_NOERROR);

            case ACM_DRIVERPRIORITYF_END:
                fSucceeded = IDriverLockPriority( pag,
                                                  htask,
                                                  ACMPRIOLOCK_RELEASELOCK );
                if( !fSucceeded )
                {
                    DebugErr(DBF_ERROR, "acmDriverPriority: deferred lock unowned.");
                    return (MMSYSERR_ALLOCATED);
                }

                //
                //  We don't need to refresh the priorities first, because
                //  they are refreshed (below) every time a change is made,
                //  even if the priorities lock is set.
                //
                IDriverPrioritiesSave( pag );
                IDriverBroadcastNotify( pag );
                return (MMSYSERR_NOERROR);
        }

        DebugErr(DBF_ERROR, "acmDriverPriority: deferred flag must be specified with NULL hadid.");
        return (MMSYSERR_INVALFLAG);
    }


    //
    //  Validate the hadid.
    //
    V_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    padid = (PACMDRIVERID)hadid;


    //
    //  Check the type of handle...
    //
    fIsNotify = (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver));
    fIsLocal  = (0 != (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));

    if (0L != dwPriority)
    {
        if (fIsNotify)
        {
            DebugErr(DBF_ERROR, "acmDriverPriority(): notification handles have no priority.");
            return (MMSYSERR_NOTSUPPORTED);
        }

        if (fIsLocal)
        {
            DebugErr(DBF_ERROR, "acmDriverPriority(): local drivers have no priority.");
            return (MMSYSERR_NOTSUPPORTED);
        }
    }


    //
    //  Check that the requested priority is in range.  dwPriority == -1
    //  means that we add it on the end, so that's OK.  0 means that we don't
    //  change the priority at all.
    //
    if( ((DWORD)-1L) != dwPriority  &&  0L != dwPriority )
    {
        cTotalGlobal = IDriverCountGlobal( pag );
        if( dwPriority > cTotalGlobal )
        {
            DebugErr1(DBF_ERROR, "acmDriverPriority(): priority value %lu out of range.", dwPriority);
            return (MMSYSERR_INVALPARAM);
        }
    }


    //
    //  Change the priority!
    //
    ENTER_LIST_EXCLUSIVE;
    mmr = IDriverPriority( pag, padid, dwPriority, fdwPriority );
    LEAVE_LIST_EXCLUSIVE;

    if( MMSYSERR_NOERROR != mmr )
        return mmr;


    //
    //  if deferred broadcast is not enabled, then do a change broadcast
    //
    //  do NOT refresh global cache for local and notification handles
    //
    if( !fIsLocal && !fIsNotify )
    {
        IDriverRefreshPriority( pag );
        if( !IDriverLockPriority( pag, htask, ACMPRIOLOCK_ISLOCKED ) )
        {
            IDriverPrioritiesSave( pag );
            IDriverBroadcastNotify( pag );
        }
    }

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverOpen | This function opens the specified Audio
 *      Compression Manager (ACM) driver and returns a driver-instance handle
 *      that can be used to communicate with the driver.
 *
 *  @parm LPHACMDRIVER | phad | Specifies a pointer to a <t HACMDRIVER>
 *      handle that will receive the new driver instance handle that can
 *      be used to communicate with the driver.
 *
 *  @parm HACMDRIVERID | hadid | Handle to the driver identifier of an
 *      installed and enabled ACM driver.
 *
 *  @parm DWORD | fdwOpen | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_NOTENABLED | The driver is not enabled.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *  @xref <f acmDriverAdd> <f acmDriverEnum> <f acmDriverID>
 *      <f acmDriverClose>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverOpen
(
    LPHACMDRIVER            phad,
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
)
{
    MMRESULT mmr;

    V_WPOINTER(phad, sizeof(HACMDRIVER), MMSYSERR_INVALPARAM);
    *phad = NULL;
    V_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwOpen, ACM_DRIVEROPENF_VALID, acmDriverOpen, MMSYSERR_INVALFLAG);

    EnterHandle(hadid);
    mmr = IDriverOpen(phad, hadid, fdwOpen);
    LeaveHandle(hadid);

    return mmr;
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverClose | Closes a previously opened Audio
 *      Compression Manager (ACM) driver instance. If the function is
 *      successful, the handle is invalidated.
 *
 *  @parm HACMDRIVER | had | Identifies the open driver instance to be
 *      closed.
 *
 *  @parm DWORD | fdwClose | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_BUSY | The driver is in use and cannot be closed.
 *
 *  @xref <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
)
{
    MMRESULT     mmr;
#ifdef WIN32
    HACMDRIVERID hadid;
#endif // WIN32

    V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwClose, ACM_DRIVERCLOSEF_VALID, acmDriverClose, MMSYSERR_INVALFLAG);

#ifdef WIN32
    hadid = ((PACMDRIVER)had)->hadid;
#endif // WIN32
    EnterHandle(hadid);
    mmr = IDriverClose(had, fdwClose);
    LeaveHandle(hadid);

    return mmr;
}


/*****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api LRESULT | acmDriverMessage | This function sends a user-defined
 *      message to a given Audio Compression Manager (ACM) driver instance.
 *
 *  @parm HACMDRIVER | had | Specifies the ACM driver instance to which the
 *      message will be sent.
 *
 *  @parm UINT | uMsg | Specifies the message that the ACM driver must
 *      process. This message must be in the <m ACMDM_USER> message range
 *      (above or equal to <m ACMDM_USER> and less than
 *      <m ACMDM_RESERVED_LOW>). The exception to this restriction is
 *      the <m ACMDM_DRIVER_ABOUT> message.
 *
 *  @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 *  @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 *  @rdesc The return value is specific to the user-defined ACM driver
 *      message <p uMsg> sent. However, the following return values are
 *      possible:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | <p uMsg> is not in the ACMDM_USER range.
 *
 *      @flag MMSYSERR_NOTSUPPORTED | The ACM driver did not process the
 *      message.
 *
 *  @comm The <f acmDriverMessage> function is provided to allow ACM driver-
 *      specific messages to be sent to an ACM driver. The messages that
 *      can be sent through this function must be above or equal to the
 *      <m ACMDM_USER> message and less than <m ACMDM_RESERVED_LOW>. The
 *      exceptions to this restriction are the <m ACMDM_DRIVER_ABOUT>,
 *      <m DRV_QUERYCONFIGURE> and <m DRV_CONFIGURE> messages.
 *
 *      To display a custom About dialog box from an ACM driver,an application
 *      must send the <m ACMDM_DRIVER_ABOUT> message to the
 *      driver. The <p lParam1> argument should be the handle of the
 *      owner window for the custom about box; <p lParam2> must be set to
 *      zero. If the driver does not support a custom about box, then
 *      MMSYSERR_NOTSUPPORTED will be returned and it is up to the calling
 *      application to display its own dialog box. For example, the
 *      Control Panel Sound Mapper option will display a default about
 *      box based on the <t ACMDRIVERDETAILS> structure when an ACM driver
 *      returns MMSYSERR_NOTSUPPORTED. An application can query a driver
 *      for custom about box support without the dialog box being displayed
 *      by setting <p lParam1> to -1L. If the driver supports a custom
 *      about box, then MMSYSERR_NOERROR will be returned. Otherwise,
 *      the return value is MMSYSERR_NOTSUPPORTED.
 *
 *      User-defined messages must only be sent to an ACM driver that
 *      specifically supports the messages. The caller should verify that
 *      the ACM driver is in fact the correct driver by getting the
 *      driver details and checking the <e ACMDRIVERDETAILS.wMid>,
 *      <e ACMDRIVERDETAILS.wPid>, and <e ACMDRIVERDETAILS.vdwDriver> members.
 *
 *      Never send user-defined messages to an unknown ACM driver.
 *
 *  @xref <f acmDriverOpen> <f acmDriverDetails>
 *
 ****************************************************************************/

LRESULT ACMAPI acmDriverMessage
(
    HACMDRIVER              had,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    BOOL                fAllowDriverId;

    //
    //  assume no driver id allowed
    //
    fAllowDriverId = FALSE;

    //
    //  do not allow non-user range messages through!
    //
    //  we have to allow ACMDM_DRIVER_ABOUT through because we define no
    //  other interface to bring up the about box for a driver. so special
    //  case this message and validate the arguments for it...
    //
    //  we also have to allow DRV_QUERYCONFIGURE and DRV_CONFIGURE through.
    //
    if ((uMsg < ACMDM_USER) || (uMsg >= ACMDM_RESERVED_LOW))
    {
        switch (uMsg)
        {
            case DRV_QUERYCONFIGURE:
                if ((0L != lParam1) || (0L != lParam2))
                {
                    DebugErr(DBF_ERROR, "acmDriverMessage: DRV_QUERYCONFIGURE requires lParam1 = lParam2 = 0.");
                    return (MMSYSERR_INVALPARAM);
                }

                fAllowDriverId = TRUE;
                break;

            case DRV_CONFIGURE:
                if ((0L != lParam1) && !IsWindow((HWND)lParam1))
                {
                    DebugErr(DBF_ERROR, "acmDriverMessage: DRV_CONFIGURE, lParam1 must contain a valid window handle.");
                    return (DRVCNF_CANCEL);
                }

                if (0L != lParam2)
                {
                    DebugErr(DBF_ERROR, "acmDriverMessage: DRV_CONFIGURE, lParam2 must be zero.");
                    return (DRVCNF_CANCEL);
                }

                V_HANDLE(had, TYPE_HACMOBJ, DRVCNF_CANCEL);

                EnterHandle(had);
                lr = IDriverConfigure((HACMDRIVERID)had, (HWND)lParam1);
                LeaveHandle(had);
                return (lr);

            case ACMDM_DRIVER_ABOUT:
                if ((-1L != lParam1) && (0L != lParam1) && !IsWindow((HWND)lParam1))
                {
                    DebugErr(DBF_ERROR, "acmDriverMessage: ACMDM_DRIVER_ABOUT, lParam1 must contain a valid window handle.");
                    return (MMSYSERR_INVALHANDLE);
                }

                if (0L != lParam2)
                {
                    DebugErr(DBF_ERROR, "acmDriverMessage: ACMDM_DRIVER_ABOUT, lParam2 must be zero.");
                    return (MMSYSERR_INVALPARAM);
                }

                fAllowDriverId = TRUE;
                break;

            default:
                DebugErr(DBF_ERROR, "acmDriverMessage: non-user range messages are not allowed.");
                return (MMSYSERR_INVALPARAM);
        }
    }


    //
    //  validate handle as an HACMOBJ. this API can take an HACMDRIVERID
    //  as well as an HACMDRIVER. an HACMDRIVERID can only be used with
    //  the following messages:
    //
    //      DRV_QUERYCONFIGURE
    //      DRV_CONFIGURE
    //      ACMDM_DRIVER_ABOUT
    //
    V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);
    if (TYPE_HACMDRIVER == ((PACMDRIVER)had)->uHandleType)
    {
        EnterHandle(had);
        lr = IDriverMessage(had, uMsg, lParam1, lParam2);
        LeaveHandle(had);
        return (lr);
    }

    if (!fAllowDriverId)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
    }

    V_HANDLE(had, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    EnterHandle(had);
    lr = IDriverMessageId((HACMDRIVERID)had, uMsg, lParam1, lParam2);
    LeaveHandle(had);
    return (lr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\acm.c ===
//==========================================================================;
//
//  acm.c
//
//  Copyright (c) 1991-1999 Microsoft Corporation
//
//  Description:
//      This module provides the Audio Compression Manager API to the
//      installable audio drivers
//
//  History:
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <stdlib.h>
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "profile.h"
#include "uchelp.h"
#include "debug.h"


//
//
//
#ifndef WIN32
#ifdef DEBUG
EXTERN_C HANDLE FAR PASCAL GetTaskDS(void);
#endif
EXTERN_C UINT FAR PASCAL LocalCountFree(void);
EXTERN_C UINT FAR PASCAL LocalHeapSize(void);
#endif


//
//
//
CONST TCHAR gszKeyDrivers[]	    = TEXT("System\\CurrentControlSet\\Control\\MediaResources\\acm");
CONST TCHAR gszDevNode[]	    = TEXT("DevNode");
TCHAR BCODE gszFormatDriverKey[]    = TEXT("%s\\%s");
TCHAR BCODE gszDriver[]		    = TEXT("Driver");
TCHAR BCODE gszDriverCache[]	    = TEXT("Software\\Microsoft\\AudioCompressionManager\\DriverCache");
TCHAR gszValfdwSupport[]	    = TEXT("fdwSupport");
TCHAR gszValcFormatTags[]	    = TEXT("cFormatTags");
TCHAR gszValaFormatTagCache[]	    = TEXT("aFormatTagCache");
TCHAR gszValcFilterTags[]	    = TEXT("cFilterTags");
TCHAR gszValaFilterTagCache[]	    = TEXT("aFilterTagCache");


//==========================================================================;
//
//
//
//
//
//==========================================================================;

MMRESULT FNLOCAL IDriverLoad( HACMDRIVERID hadid, DWORD fdwLoad );

//==========================================================================;
//
//
//
//
//
//==========================================================================;

#if defined(WIN32) && defined(_MT)
//
//  Handle support routines
//

HLOCAL NewHandle(UINT cbSize)
{
    PACM_HANDLE pacmh;

    pacmh = (PACM_HANDLE)LocalAlloc(LPTR, sizeof(ACM_HANDLE) + cbSize);
    if (pacmh) {
	try {
	    InitializeCriticalSection(&pacmh->CritSec);
	} except(EXCEPTION_EXECUTE_HANDLER) {
	    LocalFree((HLOCAL)pacmh);
	    pacmh = NULL;
	}
    }

    if (pacmh) {
	return (HLOCAL)(pacmh + 1);
    } else {
	return NULL;
    }
}

VOID DeleteHandle(HLOCAL h)
{
    DeleteCriticalSection(&HtoPh(h)->CritSec);

    LocalFree((HLOCAL)HtoPh(h));
}

#endif // WIN32 && _MT

//==========================================================================;
//
//
//  ACMGARB routines
//
//  These routines are used to access the linked list of ACMGARB structures.
//  Each structure is associated with one process id.  whenever the acm is
//  called it finds the acmgarb structure associated with the process in
//  which it is called and then uses the data stored in that acmgarb structure.
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD GetCurrentProcessId
//
//  Description:
//	This function returns the current process id
//
//  Arguments:
//
//  Return (DWORD):
//	Id of current process
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//
//	WIN32:
//	This function exists in the 32-bit kernels on both Chicago and
//	Daytona and we provide no prototype for WIN32 compiles.
//
//	16-bit Chicago:
//	It is exported as in internal API by the 16-bit Chicago kernel.
//	We provide the prototype here and import it in the def file.
//
//	16-bit Daytona:
//	Has no such 16-bit function and really doesn't need one since all
//	16-bit tasks are part of the same process under Daytona.  Therefore
//	we just #define this to return (1) for 16-bit non-Chicago builds.
//
//--------------------------------------------------------------------------;
#ifndef WIN32
#ifdef  WIN4
DWORD WINAPI GetCurrentProcessId(void);
#else
#define GetCurrentProcessId() (1)
#endif
#endif

//--------------------------------------------------------------------------;
//
//  PACMGARB pagFind
//
//  Description:
//	This function searches the linked list of ACMGARB structures for
//	one that is associated with the current process.
//
//	CHICAGO:
//	This function calls GetCurrentProcessId() and searches the linked
//	list of ACMGARBs (gplag) for an ACMGARB for the current process.
//	See notes for the GetCurrentProcessId() function above.
//
//	DAYTONA:
//	The pag list always contains only one node (since msacm32.dll is
//	always loaded into seperate process address spaces, and since
//	msacm.dll is loaded only once into each wow address space).  Since
//	the pag list always contains only one node, this function is simply
//	#defined in acmi.h to return gplag instead of searching the pag list.
//
//  Arguments:
//
//  Return (PACMGARB):
//	Pointer to ACMGARB structure for the current process.  Returns
//	NULL if none found.
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
#ifdef WIN4
PACMGARB FNGLOBAL pagFind(void)
{
    PACMGARB	pag;
    DWORD	pid;

    pag = gplag;

    pid = GetCurrentProcessId();

    while (pag && (pag->pid != pid)) pag = pag->pagNext;

    return (pag);
}
#endif

//--------------------------------------------------------------------------;
//
//  PACMGARB pagFindAndBoot
//
//  Description:
//	This function searches for a pag that is associated with
//	the current process.  It will then boot drivers if there
//	are any that need to be booted.
//
//  Arguments:
//	(void)
//
//  Return (PACMGARB):
//	Pointer to ACMGARB structure for the current process.  Returns
//	NULL if none found.
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//
//	DAYTONA:
//	acmBootXDrivers is called from acmInitialize, so there
//	is no need to check for booting drivers.  Furthermore, given the
//	reasons stated in the description of pagFind() below, this
//	function is simply #defined in acmi.h to return gplag.
//
//--------------------------------------------------------------------------;
#ifdef WIN4
PACMGARB FNGLOBAL pagFindAndBoot(void)
{
    PACMGARB	pag;

    pag = pagFind();
    if (NULL == pag)
    {
	return(pag);
    }

#ifndef WIN32
    if( pag->fWOW )
    {
        pagFindAndBoot32(pag);
    }
#endif

    //
    //	If this thread already has a shared lock on the driver list,
    //	then don't bother trying to boot drivers.  (It is possible for
    //	this thread to have a shared lock if, for example, it is calling
    //	into an ACM API from an acmDriverEnumCallback.)
    //
    //	It is important to do this before entering csBoot, because the
    //	owner of csBoot might be waiting for this thread to release the
    //	list lock.  Note we are assuming that this thread does NOT own an
    //	exclusive lock on the list.
    //
    if (threadQueryInListShared(pag))
    {
	return(pag);
    }

	
#ifdef WIN32
    //
    //  This critical section protects the boot-related flags and counters,
    //  ie, fDriversBooted and the dwXXXChangeNotify counters.
    //
    EnterCriticalSection(&pag->csBoot);
#endif

    //
    //  See if we need to do the initial boot of the drivers.
    //
    if (FALSE == pag->fDriversBooted)
    {
	//
	//  Since we haven't done the initial boot of the drivers,
	//  nobody should have any kind of a lock right now.  Also,
	//  since we've entered the csBoot critical section, no
	//  other threads can get into any APIs in order to attempt
	//  to get a lock.  Therefore, there really isn't any need
	//  for us to grab a list lock.
	//
	//  Furthermore, we should not reenter the boot code.
	//
	ASSERT(FALSE == pag->fDriversBooting);
		
#ifdef DEBUG
	pag->fDriversBooting = TRUE;
#endif
	
#ifndef WIN32
	pag->dw32BitLastChangeNotify = pag->dw32BitChangeNotify;
	acmBoot32BitDrivers(pag);
#endif

	acmBootDrivers(pag);

	pag->dwPnpLastChangeNotify = *pag->lpdwPnpChangeNotify;
	acmBootPnpDrivers(pag);

#ifdef DEBUG
	pag->fDriversBooting = FALSE;
#endif

	pag->fDriversBooted = TRUE;
    }



    //
    //  Check for pnp changes
    //
    if (pag->dwPnpLastChangeNotify != *pag->lpdwPnpChangeNotify)
    {
	//
	//  Looks like there's been a change in the pnp drivers.
	//
	ASSERT(FALSE==pag->fDriversBooting);
	
	ENTER_LIST_EXCLUSIVE;
	
#ifdef DEBUG
	pag->fDriversBooting = TRUE;
#endif
	pag->dwPnpLastChangeNotify = *pag->lpdwPnpChangeNotify;
	acmBootPnpDrivers(pag);
		
#ifdef DEBUG
	pag->fDriversBooting = FALSE;
#endif
		
	LEAVE_LIST_EXCLUSIVE;

    }


#ifndef WIN32
    //
    //  Check for 32-bit driver changes
    //
    if (pag->dw32BitLastChangeNotify != pag->dw32BitChangeNotify)
    {
	//
	//  Looks like there's been a change in the 32bit drivers.
	//
	ASSERT(FALSE==pag->fDriversBooting);
		
	ENTER_LIST_EXCLUSIVE;

#ifdef DEBUG
	pag->fDriversBooting = TRUE;
#endif
		
	pag->dw32BitLastChangeNotify = pag->dw32BitChangeNotify;
	acmBoot32BitDrivers(pag);
		
#ifdef DEBUG
	pag->fDriversBooting = FALSE;
#endif
		
	LEAVE_LIST_EXCLUSIVE;

    }
#endif
	
	
#ifdef WIN32
    LeaveCriticalSection(&pag->csBoot);
#endif
	
    return (pag);

}
#endif

//--------------------------------------------------------------------------;
//
//  PACMGARB pagNew
//
//  Description:
//	This function allocs a new ACMGARB structure, fills in the pid
//	member with the current process id, initializes the boot flags
//	critical section, and inserts the struture into the linked list
//	of ACMGARB structures.
//
//  Arguments:
//
//  Return (PACMGARB):
//	Pointer to ACMGARB structure for the current process.  Returns
//	NULL if couldn't create one.
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//	Since this function writes to the change notify counters, we are
//	assuming that this function is protected from multiple threads.  Since
//	this is only called from within DllEntryPoint on DLL_PROCESS_ATTACH,
//	I think we are safe.
//
//--------------------------------------------------------------------------;
PACMGARB FNGLOBAL pagNew(void)
{
    PACMGARB pag;

    pag = (PACMGARB)LocalAlloc(LPTR, sizeof(*pag));

    if (NULL != pag)
    {
	pag->pid = GetCurrentProcessId();

	//
	//  As a default, we point lpdwPnpChangeNotify at our own notify
	//  counter.  Unless we get a pointer to some other notify counter
	//  (ie, from mmdevldr) we leave it this way.
	//
	pag->dwPnpLastChangeNotify = 0;
	pag->lpdwPnpChangeNotify = &pag->dwPnpLastChangeNotify;

#ifdef WIN32
	pag->lpdw32BitChangeNotify = NULL;
#else
	pag->dw32BitLastChangeNotify = 0;
	pag->dw32BitChangeNotify = 0;
#endif
	
	pag->pagNext = gplag;
	gplag = pag;
    }

    return (pag);
}

//--------------------------------------------------------------------------;
//
//  PACMGARB pagDelete
//
//  Description:
//	This function removes an ACMGARB structure from the linked list
//	and frees it.
//
//  Arguments:
//	PACMGARB pag: pointer to ACMGARB to remove from list.
//
//  Return (void):
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
void FNGLOBAL pagDelete(PACMGARB pag)
{
    PACMGARB pagPrev, pagT;

    if (gplag == pag)
    {
	gplag = pag->pagNext;
    }
    else
    {
	if (NULL != gplag)
	{
	    pagPrev = gplag;
	    pagT = pagPrev->pagNext;
	    while ( pagT && (pagT != pag) )
	    {
		pagPrev = pagT;
		pagT = pagT->pagNext;
	    }

	    if (pagT == pag)
	    {
		pagPrev->pagNext = pagT->pagNext;
	    }
	}
    }

    LocalFree((HLOCAL)pag);
}

//==========================================================================;
//
//
//  Thread routines for tracking shared locks
//
//  The incentive for having these routines is to prevent scenarios like
//  this:  Supposed FranksBadApp calls acmDriverEnum to enumerate drivers.
//  This API will obtain a shared lock on the driver list while it
//  enumerates the drivers.  FranksEvilDriverEnumCallback function
//  decides to call acmDriverAdd.  The acmDriverAdd API wants
//  to obtain an exclusive lock on the driver list so that it can write to
//  the driver list.  But, it can't because it already has a shared lock.
//  Without the following routines and associated logic, this thread would
//  deadlock waiting to obtain an exclusive lock.
//
//  Furthermore, some APIs that we wouldn't expect to write to the driver list
//  actually do, usually to update driver priorities.  Fixing the above
//  problem leads to an easy solution for this as well.  If the thread already
//  has an shared lock, then the API can simply blow off updating priorities
//  but still succeed the call if possible.  By doing this, we allow callback
//  functions to still make API calls to seemingly harmless functions
//  like acmMetrics.
//
//
//  These routines are used to track shared locks on the driver list
//  on a per thread basis.  Each time a thread obtains a shared lock, it
//  increments a per-thread counter which tracks the number of shared locks
//  held by that thread.  Whenever we try to obtain on exclusive lock, we
//  query whether the current thread already has a shared lock.  If it does,
//  then there is NO WAY this thread can obtain an exclusive lock.  We MUST
//  either get by without obtaining the exclusive lock or fail the call.
//
//  Behavior/implementation for various compiles:
//
//	32-bit Chicago or Daytona:
//	    The per-thread counter is maintained using the Tls (Thread
//	    local storage) APIs.  The dwTlsIndex is stored in the process
//	    wide pag (pointer to ACMGARB) structure.  If a thread within a
//	    process tries to obtain an exclusive lock when that same thread
//	    already owns a shared lock, then we fail or work-around.
//	    Other threads in that process will either immediately get
//	    the lock or wait, depending on the type of lock.
//
//	16-bit (Chicago and Daytona):
//	    We don't really have a locking mechanism, but the concept of
//	    the shared lock counter does help prevent us from writing
//	    to the driver list at the same time that we are reading from it.
//
//	16-bit Chicago:
//	    The shared lock counter is maintained in the pag (in a variable
//	    that, for some strange reason, is called dwTlsIndex).  Since
//	    in Chicago every win 16 task is a seperate process, we have
//	    a seperate pag, driver list, and shared-lock counter for each
//	    win 16 app.  So, app1 can call acmDriverEnum, yield in its
//	    callback, and app2 can successfully call acmDriverAdd.  However,
//	    app1 cannot try to do acmDriverAdd from within its
//	    acmDriverEnumCallback.
//
//	16-bit Daytona:
//	    The shared lock counter is maintained in the pag (in a variable
//	    that, for some strange reason, is called dwTlsIndex).  Since
//	    in Daytona all win 16 tasks are one process, we have only
//	    one pag, driver list, and shared-lock counter for all
//	    win 16 apps.  So, if app1 calls acmDriverEnum, yields in its
//	    callback, app2 CANNOT successfully call acmDriverAdd.  Furthermore
//	    app1 cannot try to do acmDriverAdd from within its
//	    acmDriverEnumCallback.
//
//	
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  VOID threadInitializeProcess
//
//  Description:
//	Should be called once during process initialization to initialize
//	the thread local storage mechanism.
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadInitializeProcess(PACMGARB pag)
{
#ifdef WIN32
    pag->dwTlsIndex = TlsAlloc();
#else
    pag->dwTlsIndex = 0;
#endif
    return;
}

//--------------------------------------------------------------------------;
//
//  VOID threadTerminateProcess
//
//  Description:
//	Should be called once during process termination to clean up and
//	terminate the thread local storage mechanism.
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadTerminateProcess(PACMGARB pag)
{
#ifdef WIN32
    if (0xFFFFFFFF != pag->dwTlsIndex)
    {
	TlsFree(pag->dwTlsIndex);
    }
#else
    pag->dwTlsIndex = 0;
#endif
    return;
}

//--------------------------------------------------------------------------;
//
//  VOID threadInitialize
//
//  Description:
//	Should be called once for each thread to initialize the
//	thread local storage on a per-thread basis.
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadInitialize(PACMGARB pag)
{
    if (NULL == pag) return;
#ifdef WIN32
    if (0xFFFFFFFF != pag->dwTlsIndex)
    {
	TlsSetValue(pag->dwTlsIndex, 0);
    }
#else
    pag->dwTlsIndex = 0;
#endif
    return;
}

//--------------------------------------------------------------------------;
//
//  VOID threadTerminate
//
//  Description:
//	Should be called once for each thread to terminate the
//	thread local storage on a per-thread basis.
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadTerminate(PACMGARB pag)
{
    return;
}

//--------------------------------------------------------------------------;
//
//  VOID threadEnterListShared
//
//  Description:
//	Should be called by ENTER_LIST_SHARED (ie, each time a shared
//	lock is aquired on the driver list)
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadEnterListShared(PACMGARB pag)
{
#ifdef WIN32
    INT_PTR Count;

    if (0xFFFFFFFF != pag->dwTlsIndex)
    {
	Count = (INT_PTR)TlsGetValue(pag->dwTlsIndex);
	TlsSetValue(pag->dwTlsIndex, (LPVOID)++Count);
    }
#else
    pag->dwTlsIndex++;
#endif
    return;
}

//--------------------------------------------------------------------------;
//
//  VOID threadLeaveListShared
//
//  Description:
//	Should be called by LEAVE_LIST_SHARED (ie, each time a shared
//	lock on the driver list is released).
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadLeaveListShared(PACMGARB pag)
{
#ifdef WIN32
    INT_PTR Count;

    if (0xFFFFFFFF != pag->dwTlsIndex)
    {
	Count = (INT_PTR)TlsGetValue(pag->dwTlsIndex);
	TlsSetValue(pag->dwTlsIndex, (LPVOID)--Count);
    }
#else
    pag->dwTlsIndex--;
#endif
    return;
}

//--------------------------------------------------------------------------;
//
//  DWORD threadQueryInListShared
//
//  Description:
//	Can be called to determine whether the current thread has a
//	shared lock on the driver list.  Should call this before EVERY
//	call to ENTER_LIST_EXCLUSIVE.  If this function returns non-zero,
//	then the current thread already has a shared lock and
//	ENTER_LIST_EXCLUSIVE will deadlock!!!  Caller should figure out what
//	to do from there...
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (BOOL): TRUE if shared locks are held by this thread.  FALSE
//	if this thread does not hold a shared lock on the driver list.
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
BOOL FNGLOBAL threadQueryInListShared(PACMGARB pag)
{
#ifdef WIN32
    if (0xFFFFFFFF != pag->dwTlsIndex)
    {
	return (0 != TlsGetValue(pag->dwTlsIndex));
    }
    else
    {
	return 0;
    }
#else
    return (0 != pag->dwTlsIndex);
#endif
}

//==========================================================================;
//
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessageId
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverMessageId
(
    HACMDRIVERID        hadid,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    PACMDRIVERID    padid;
    LRESULT         lr;

    //
    //  only validate hadid in DEBUG build for this function (it is internal
    //  and will only be called by us...)
    //
    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    padid = (PACMDRIVERID)hadid;

    //
    //	Better make sure the driver is loaded if we're going to use the hadid
    //
    if (0 == (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
    {
	if ( (DRV_LOAD != uMsg) && (DRV_ENABLE != uMsg) && (DRV_OPEN != uMsg) )
	{
	    lr = (LRESULT)IDriverLoad(hadid, 0L);
	    if (MMSYSERR_NOERROR != lr) {
		return (lr);
	    }
	}
    }

#ifndef WIN32
    //
    //  Are we thunking?
    //

    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
        return IDriverMessageId32(padid->hadid32, uMsg, lParam1, lParam2);
    }
#endif // !WIN32

    if (NULL != padid->fnDriverProc)
    {
        if ((ACMDRIVERPROC)(DWORD_PTR)-1L == padid->fnDriverProc)
        {
            return (MMSYSERR_ERROR);
        }

        if (IsBadCodePtr((FARPROC)padid->fnDriverProc))
        {
            DPF(0, "!IDriverMessageId: bad function pointer for driver");

            padid->fnDriverProc = (ACMDRIVERPROC)(DWORD_PTR)-1L;

            return (MMSYSERR_ERROR);
        }

        //
        //
        //
        lr = padid->fnDriverProc(padid->dwInstance, hadid, uMsg, lParam1, lParam2);
        return (lr);
    }

    //
    //
    //
    if (NULL != padid->hdrvr)
    {
        lr = SendDriverMessage(padid->hdrvr, uMsg, lParam1, lParam2);
        return (lr);
    }

    //
    //  NOTE: this is very bad--and we don't really know what to return
    //  since anything could be valid depending on the message... so we
    //  assume that people follow the ACM conventions and return MMRESULT's.
    //
    DPF(0, "!IDriverMessageId: invalid hadid passed! %.04Xh", hadid);

    return (MMSYSERR_INVALHANDLE);
} // IDriverMessageId()


//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessage
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVER had:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverMessage
(
    HACMDRIVER          had,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    PACMDRIVER      pad;
    LRESULT         lr;

    //
    //  only validate hadid in DEBUG build for this function (it is internal
    //  and will only be called by us...)
    //
    DV_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

    pad = (PACMDRIVER)had;

#ifndef WIN32
    //
    //  Are we thunking?
    //

    if (((PACMDRIVERID)pad->hadid)->fdwAdd & ACM_DRIVERADDF_32BIT) {
        return IDriverMessage32(pad->had32, uMsg, lParam1, lParam2);
    }
#endif // !WIN32

    if (NULL != pad->fnDriverProc)
    {
        if ((ACMDRIVERPROC)(DWORD_PTR)-1L == pad->fnDriverProc)
        {
            return (MMSYSERR_ERROR);
        }

        if (IsBadCodePtr((FARPROC)pad->fnDriverProc))
        {
            DPF(0, "!IDriverMessage: bad function pointer for driver");

            pad->fnDriverProc = (ACMDRIVERPROC)(DWORD_PTR)-1L;

            return (MMSYSERR_ERROR);
        }

        //
        //
        //
        lr = pad->fnDriverProc(pad->dwInstance, pad->hadid, uMsg, lParam1, lParam2);
        return (lr);
    }

    //
    //
    //
    if (NULL != pad->hdrvr)
    {
        lr = SendDriverMessage(pad->hdrvr, uMsg, lParam1, lParam2);
        return (lr);
    }

    //
    //  NOTE: this is very bad--and we don't really know what to return
    //  since anything could be valid depending on the message... so we
    //  assume that people follow the ACM conventions and return MMRESULT's.
    //
    DPF(0, "!IDriverMessage: invalid had passed! %.04Xh", had);

    return (MMSYSERR_INVALHANDLE);
} // IDriverMessage()


//==========================================================================;
//
//
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT IDriverConfigure
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      HWND hwnd:
//
//  Return (LRESULT):
//
//  History:
//      10/01/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverConfigure
(
    HACMDRIVERID            hadid,
    HWND                    hwnd
)
{
    LRESULT             lr;
    PACMDRIVERID        padid;
#ifdef WIN4
    DRVCONFIGINFOEX     dci;
#else
    DRVCONFIGINFO       dci;
#endif
    HACMDRIVER          had;
    LPARAM              lParam2;

    padid = (PACMDRIVERID)hadid;
    if (TYPE_HACMDRIVER == padid->uHandleType)
    {
        had   = (HACMDRIVER)hadid;
        hadid = ((PACMDRIVER)had)->hadid;
    }
    else if (TYPE_HACMDRIVERID == padid->uHandleType)
    {
        had   = NULL;
    }
    else
    {
        DPF(0, "!IDriverConfigure(): bogus handle passed!");
        return (DRVCNF_CANCEL);
    }

    padid = (PACMDRIVERID)hadid;


    //
    //
    //
    if (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
    {
        DebugErr(DBF_ERROR, "acmDriverMessage(): notification handles cannot be configured.");
        return (MMSYSERR_INVALHANDLE);
    }


    //
    //
    //
    {
	//
	//
	//
	lParam2 = 0L;
	if (ACM_DRIVERADDF_NAME == (ACM_DRIVERADDF_TYPEMASK & padid->fdwAdd))
	{
	    dci.dwDCISize          = sizeof(dci);
	    dci.lpszDCISectionName = padid->pszSection;
	    dci.lpszDCIAliasName   = padid->szAlias;
#ifdef WIN4
	    dci.dnDevNode	   = padid->dnDevNode;
#endif

	    lParam2 = (LPARAM)(LPVOID)&dci;
	}

	//
	//
	//
	//
	if (NULL != had)
	{
	    lr = IDriverMessage(had, DRV_CONFIGURE, (LPARAM)(UINT_PTR)hwnd, lParam2);
	}
	else
	{
	    lr = IDriverMessageId(hadid, DRV_CONFIGURE, (LPARAM)(UINT_PTR)hwnd, lParam2);
	}
    }

    return (lr);
} // IDriverConfigure()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverDetails
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPACMDRIVERDETAILS padd:
//
//      DWORD fdwDetails:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
)
{
    MMRESULT            mmr;
    PACMDRIVERDETAILS	paddT;
    DWORD               cbStruct;
    PACMDRIVERID        padid;

    paddT = NULL;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    DV_DFLAGS(fdwDetails, IDRIVERDETAILS_VALIDF, IDriverDetails, MMSYSERR_INVALFLAG);
    DV_WPOINTER(padd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    DV_WPOINTER(padd, padd->cbStruct, MMSYSERR_INVALPARAM);

    padid = (PACMDRIVERID)hadid;

    //
    //
    //
    if (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
    {
        DebugErr(DBF_ERROR, "acmDriverDetails(): notification handles have no details.");
        return (MMSYSERR_NOTSUPPORTED);
    }


    paddT = (PACMDRIVERDETAILS)LocalAlloc(LPTR, sizeof(*paddT));
    if (NULL == paddT)
    {
	DPF(0, "!IDriverDetails: out of memory for caching details!");
	return (MMSYSERR_NOMEM);
    }


    //
    //  default all info then call driver to fill in what it wants
    //
    paddT->cbStruct = sizeof(*padd);
    mmr = (MMRESULT)IDriverMessageId(hadid,
				     ACMDM_DRIVER_DETAILS,
				     (LPARAM)(LPACMDRIVERDETAILS)paddT,
				     0L);
    if ((MMSYSERR_NOERROR != mmr) || (0L == paddT->vdwACM))
    {
	DPF(0, "!IDriverDetails: mmr=%u getting details for hadid=%.04Xh!", mmr, hadid);
	mmr = MMSYSERR_NOTSUPPORTED;
	goto Destruct;
    }

#ifndef WIN32
        //
        //  If this driver is a 32-bit driver, then the 32-bit side will
        //  already have set the DISABLED and LOCAL flags.  These are not
        //  really part of the drivers add, so we mask them off.  These
        //  flags are set below, and should be set every time IDriverDetails
        //  is called, rather than being cached.
        //
        if (padid->fdwAdd & ACM_DRIVERADDF_32BIT)
        {
            paddT->fdwSupport &= 0x0000001FL;
        }
#endif // !WIN32


    //
    //  copy the info from our cache
    //
    cbStruct = min(paddT->cbStruct, padd->cbStruct);
    _fmemcpy(padd, paddT, (UINT)cbStruct);
    padd->cbStruct = cbStruct;


    //
    //  Check that the driver didn't set any of the reserved flags; then
    //  set the DISABLED and LOCAL flags.
    //
    if (~0x0000001FL & padd->fdwSupport)
    {
#ifdef WIN32
        DebugErr1(DBF_ERROR, "%ls: driver set reserved bits in fdwSupport member of details struct.", (LPWSTR)padid->szAlias);
#else
        DebugErr1(DBF_ERROR, "%s: driver set reserved bits in fdwSupport member of details struct.", (LPTSTR)padid->szAlias);
#endif
	mmr = MMSYSERR_ERROR;
	goto Destruct;
    }

    if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
    {
        padd->fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_DISABLED;
    }

    if (0 != (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver))
    {
        padd->fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
    }

    //
    //
    //
Destruct:
    if (NULL != paddT) {
	LocalFree((HLOCAL)paddT);
    }

    return (mmr);
} // IDriverDetails()


//==========================================================================;
//
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetFormatTags
//
//  Description:
//
//
//  Arguments:
//      PACMDRIVERID padid:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverGetFormatTags
(
    PACMDRIVERID            padid
)
{
    MMRESULT                mmr;
    UINT                    u;
    ACMFORMATTAGDETAILS     aftd;
    PACMFORMATTAGCACHE	    paftc = NULL;
    DWORD                   cb;

    DV_HANDLE((HACMDRIVERID)padid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    if (NULL != padid->paFormatTagCache) {
	LocalFree((HLOCAL)padid->paFormatTagCache);
    }
    padid->paFormatTagCache = NULL;

    //
    //  check to see if there are no formats for this driver. if not, dump
    //  them...
    //
    if (0 == padid->cFormatTags)
    {
        DebugErr(DBF_ERROR, "IDriverLoad(): driver reports no format tags?");
        mmr = MMSYSERR_ERROR;
        goto Destruct;
    }


    //
    //  alloc an array of tag data structures to hold info for format tags
    //
    cb    = sizeof(*paftc) * padid->cFormatTags;
    paftc = (PACMFORMATTAGCACHE)LocalAlloc(LPTR, (UINT)cb);
    if (NULL == paftc)
    {
        DebugErr(DBF_ERROR, "IDriverGetFormatTags(): out of memory for format cache!");
        mmr = MMSYSERR_NOMEM;
        goto Destruct;
    }


    //
    //
    //
    padid->paFormatTagCache = paftc;
    for (u = 0; u < padid->cFormatTags; u++)
    {
        aftd.cbStruct         = sizeof(aftd);
        aftd.dwFormatTagIndex = u;

        mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)padid,
					 ACMDM_FORMATTAG_DETAILS,
					 (LPARAM)(LPVOID)&aftd,
					 ACM_FORMATTAGDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
        {
            DebugErr(DBF_ERROR, "IDriverGetFormatTags(): driver failed format tag details query!");
            goto Destruct;
        }

	//
	//  Following switch is just some validation for debug
	//
#ifdef RDEBUG
        switch (aftd.dwFormatTag)
        {
            case WAVE_FORMAT_UNKNOWN:
                DebugErr(DBF_ERROR, "IDriverGetFormatTags(): driver returned format tag 0!");
                mmr = MMSYSERR_ERROR;
                goto Destruct;

            case WAVE_FORMAT_PCM:
                if ('\0' != aftd.szFormatTag[0])
                {
                    DebugErr(DBF_WARNING, "IDriverGetFormatTags(): driver returned custom PCM format tag name! ignoring it!");
                }
                break;

            case WAVE_FORMAT_DEVELOPMENT:
                DebugErr(DBF_WARNING, "IDriverGetFormatTags(): driver returned DEVELOPMENT format tag--do not ship this way.");
                break;

        }
#endif

	paftc[u].dwFormatTag = aftd.dwFormatTag;
	paftc[u].cbFormatSize = aftd.cbFormatSize;

    }

    //
    //
    //
Destruct:
    if (MMSYSERR_NOERROR != mmr)
    {
	if (NULL != paftc ) {
	    LocalFree((HLOCAL)paftc);
	}
    }

    return (mmr);

} // IDriverGetFormatTags()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetFilterTags
//
//  Description:
//
//
//  Arguments:
//      PACMDRIVERID padid:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverGetFilterTags
(
    PACMDRIVERID    padid
)
{
    MMRESULT                mmr;
    UINT                    u;
    ACMFILTERTAGDETAILS     aftd;
    PACMFILTERTAGCACHE	    paftc = NULL;
    DWORD                   cb;

    DV_HANDLE((HACMDRIVERID)padid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    if (NULL != padid->paFilterTagCache) {
	LocalFree((HLOCAL)padid->paFilterTagCache);
    }
    padid->paFilterTagCache = NULL;

    //
    //  check to see if there are no filters for this driver. if not, null
    //  our cache pointers and succeed..
    //
    if (0 != (ACMDRIVERDETAILS_SUPPORTF_FILTER & padid->fdwSupport))
    {
        if (0 == padid->cFilterTags)
        {
            DebugErr(DBF_ERROR, "IDriverLoad(): filter driver reports no filter tags?");
            mmr = MMSYSERR_ERROR;
            goto Destruct;
        }
    }
    else
    {
        if (0 == padid->cFilterTags)
            return (MMSYSERR_NOERROR);

        DebugErr(DBF_ERROR, "IDriverLoad(): non-filter driver reports filter tags?");
        mmr = MMSYSERR_ERROR;
        goto Destruct;
    }



    //
    //  alloc an array of details structures to hold info for filter tags
    //
    cb    = sizeof(*paftc) * padid->cFilterTags;
    paftc = (PACMFILTERTAGCACHE)LocalAlloc(LPTR, (UINT)cb);
    if (NULL == paftc)
    {
        DebugErr(DBF_ERROR, "IDriverGetFilterTags(): out of memory for filter cache!");
        mmr = MMSYSERR_NOMEM;
        goto Destruct;
    }


    //
    //
    //
    padid->paFilterTagCache = paftc;
    for (u = 0; u < padid->cFilterTags; u++)
    {

        aftd.cbStruct         = sizeof(aftd);
        aftd.dwFilterTagIndex = u;

        mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)padid,
                                         ACMDM_FILTERTAG_DETAILS,
                                         (LPARAM)(LPVOID)&aftd,
					 ACM_FILTERTAGDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
        {
            DebugErr(DBF_ERROR, "IDriverGetFilterTags(): driver failed filter tag details query!");
            goto Destruct;
        }

	//
	//  Following switch is just some validation for debug
	//
#ifdef RDEBUG
        switch (aftd.dwFilterTag)
        {
            case WAVE_FILTER_UNKNOWN:
                DebugErr(DBF_ERROR, "IDriverGetFilterTags(): driver returned filter tag 0!");
                mmr = MMSYSERR_ERROR;
                goto Destruct;

            case WAVE_FILTER_DEVELOPMENT:
                DebugErr(DBF_WARNING, "IDriverGetFilterTags(): driver returned DEVELOPMENT filter tag--do not ship this way.");
                break;
        }
#endif

        paftc[u].dwFilterTag = aftd.dwFilterTag;
        paftc[u].cbFilterSize = aftd.cbFilterSize;
	
    }


    //
    //
    //
Destruct:
    if (MMSYSERR_NOERROR != mmr)
    {
	if (NULL != paftc ) {
	    LocalFree((HLOCAL)paftc);
	}
    }

    return (mmr);

} // IDriverGetFilterTags()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetWaveIdentifier
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPDWORD pdw:
//
//      BOOL fInput:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverGetWaveIdentifier
(
    HACMDRIVERID            hadid,
    LPDWORD                 pdw,
    BOOL                    fInput
)
{
    PACMDRIVERID        padid;
    MMRESULT            mmr;
    UINT                u;
    UINT                cDevs;
    UINT                uId;

    DV_WPOINTER(pdw, sizeof(DWORD), MMSYSERR_INVALPARAM);

    *pdw = (DWORD)-1L;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    padid = (PACMDRIVERID)hadid;

    uId = (UINT)WAVE_MAPPER;

    //
    //  check to see if there is hardware support
    //
    if (0 == (ACMDRIVERDETAILS_SUPPORTF_HARDWARE & padid->fdwSupport))
    {
        DebugErr1(DBF_ERROR, "IDriverGetWaveIdentifier: driver (%ls) does not support _HARDWARE.", (LPTSTR)padid->szAlias);
        return (MMSYSERR_INVALHANDLE);
    }

    if (fInput)
    {
        WAVEINCAPS          wic;
        WAVEINCAPS          wicSearch;

        _fmemset(&wic, 0, sizeof(wic));
        mmr = (MMRESULT)IDriverMessageId(hadid,
                                         ACMDM_HARDWARE_WAVE_CAPS_INPUT,
                                         (LPARAM)(LPVOID)&wic,
                                         sizeof(wic));
        if (MMSYSERR_NOERROR == mmr)
        {
            mmr   = MMSYSERR_NODRIVER;

            wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

            cDevs = waveInGetNumDevs();

            for (u = 0; u < cDevs; u++)
            {
                _fmemset(&wicSearch, 1, sizeof(wicSearch));
		if (0 != waveInGetDevCaps(u, &wicSearch, sizeof(wicSearch)))
                {
                    continue;
                }

                wicSearch.szPname[SIZEOF(wicSearch.szPname) - 1] = '\0';

                if (0 == lstrcmp(wic.szPname, wicSearch.szPname))
                {
                    uId = u;
                    mmr = MMSYSERR_NOERROR;
                    break;
                }
            }
        }
    }
    else
    {
        WAVEOUTCAPS         woc;
        WAVEOUTCAPS         wocSearch;

        _fmemset(&woc, 0, sizeof(woc));
        mmr = (MMRESULT)IDriverMessageId(hadid,
                                         ACMDM_HARDWARE_WAVE_CAPS_OUTPUT,
                                         (LPARAM)(LPVOID)&woc,
                                         sizeof(woc));
        if (MMSYSERR_NOERROR == mmr)
        {
            mmr   = MMSYSERR_NODRIVER;

            woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

            cDevs = waveOutGetNumDevs();

            for (u = 0; u < cDevs; u++)
            {
                _fmemset(&wocSearch, 1, sizeof(wocSearch));
                if (0 != waveOutGetDevCaps(u, (LPWAVEOUTCAPS)&wocSearch, sizeof(wocSearch)))
                {
                    continue;
                }

                wocSearch.szPname[SIZEOF(wocSearch.szPname) - 1] = '\0';

                if (0 == lstrcmp(woc.szPname, wocSearch.szPname))
                {
                    uId = u;
                    mmr = MMSYSERR_NOERROR;
                    break;
                }
            }
        }

    }

    *pdw = (DWORD)(long)(int)uId;

    //
    //
    //
    return (mmr);
} // IDriverGetWaveIdentifier()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverFree
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD fdwFree:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverFree
(
    HACMDRIVERID            hadid,
    DWORD                   fdwFree
)
{
    PACMDRIVERID        padid;
    BOOL                f;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    DV_DFLAGS(fdwFree, IDRIVERFREE_VALIDF, IDriverFree, MMSYSERR_INVALFLAG);

    padid = (PACMDRIVERID)hadid;

    //
    //
    //
    if (0 == (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
    {
        DebugErr1(DBF_WARNING, "ACM driver (%ls) is not loaded.", (LPTSTR)padid->szAlias);
        return (MMSYSERR_NOERROR);
    }

#ifdef WIN32
    DPF(1, "IDriverFree(): freeing ACM driver (%ls).", (LPWSTR)padid->szAlias);
#else
    DPF(1, "IDriverFree(): freeing ACM driver (%s).",  (LPTSTR)padid->szAlias);
#endif

    //
    //
    //
    //
    if (NULL != padid->padFirst)
    {
        DebugErr1(DBF_ERROR, "ACM driver (%ls) has open instances--unable to unload.", (LPTSTR)padid->szAlias);
        return (MMSYSERR_ALLOCATED);
    }

#ifndef WIN32

    //
    //  We never really remove a 32-bit driver like this from
    //  the 16-bit side - but we can remove our knowledge of it - so
    //  we don't do the driver close bit in this case.
    //

    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
        f = TRUE;
        padid->hadid32 = 0;
    } else
#endif // !WIN32
    {
        //
        //  clear the rest of the table entry
        //
        f = TRUE;
        if (NULL != padid->fnDriverProc)
        {
            if (0 == (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
            {
                //
                //  bogus the CloseDriver sequence to the driver function
                //
                f = (0L != IDriverMessageId(hadid, DRV_CLOSE, 0L, 0L));
                if (f)
                {
                    IDriverMessageId(hadid, DRV_DISABLE, 0L, 0L);
                    IDriverMessageId(hadid, DRV_FREE, 0L, 0L);
                }
            }
        }
        else if (NULL != padid->hdrvr)
        {
            f = 0L != CloseDriver(padid->hdrvr, 0L, 0L);
        }
    }

    if (!f)
    {
        DebugErr1(DBF_WARNING, "ACM driver (%ls) is refusing to close.", (LPTSTR)padid->szAlias);
        return (MMSYSERR_ERROR);
    }

    //
    //
    //
    padid->fdwDriver  &= ~ACMDRIVERID_DRIVERF_LOADED;
    padid->dwInstance  = 0L;
    padid->hdrvr       = NULL;

    return (MMSYSERR_NOERROR);
} // IDriverFree()


//==========================================================================;
//
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverWriteRegistryData
//
//  Description:
//	Writes to the registry some data which describes a driver.
//
//  Arguments:
//      PACMDRIVERID padid:
//	    Pointer to ACMDRIVERID.
//
//  Return (MMRESULT):
//
//  History:
//      08/30/94    frankye
//
//  Notes:
//	This function will succeed only for drivers added with
//	ACM_DRIVERADDF_NAME.  The function attempts to open a key having
//	the same name as the szAlias member of ACMDRIVERID.  The data
//	stored under that key is:
//
//		    !!! TBD !!!
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverWriteRegistryData(PACMDRIVERID padid)
{
    DWORD		fdwSupport;
    DWORD		cFormatTags;
    PACMFORMATTAGCACHE	paFormatTagCache;
    UINT		cbaFormatTagCache;
    DWORD		cFilterTags;
    PACMFILTERTAGCACHE	paFilterTagCache;
    UINT		cbaFilterTagCache;
    HKEY		hkeyDriverCache;
    HKEY		hkeyCache = NULL;
    TCHAR		szAlias[MAX_DRIVER_NAME_CHARS];
    MMRESULT		mmr;

#ifdef DEBUG
    DWORD   dwTime;

    dwTime = timeGetTime();
#endif

    hkeyDriverCache	= NULL;
    hkeyCache		= NULL;

    //
    //  We only keep registry data for ACM_DRIVERADDF_NAME drivers.
    //
    if (ACM_DRIVERADDF_NAME != (padid->fdwAdd & ACM_DRIVERADDF_TYPEMASK))
    {
	mmr = MMSYSERR_NOTSUPPORTED;
	goto Destruct;
    }

    //
    //	Get fdwSupport and counts of format/filter tags and ptrs to their
    //	cache arrays into more convenient variables.  Also compute the size
    //	of the cache arrays.
    //
    fdwSupport  = padid->fdwSupport;
    cFormatTags = padid->cFormatTags;
    paFormatTagCache = padid->paFormatTagCache;
    cbaFormatTagCache = (UINT)cFormatTags * sizeof(*paFormatTagCache);

    cFilterTags = padid->cFilterTags;
    paFilterTagCache = padid->paFilterTagCache;
    cbaFilterTagCache = (UINT)cFilterTags * sizeof(*paFilterTagCache);

    ASSERT( (0 == cFormatTags) || (NULL != paFormatTagCache) );
    ASSERT( (0 == cFilterTags) || (NULL != paFilterTagCache) );

    //
    //	Open/create registry keys under which we store the cache information.
    //
    if (ERROR_SUCCESS != XRegCreateKey( HKEY_LOCAL_MACHINE, gszDriverCache, &hkeyDriverCache ))
    {
	hkeyDriverCache = NULL;
	mmr = MMSYSERR_NOMEM;	// Can't think of anything better
	goto Destruct;
    }

#if defined(WIN32) && !defined(UNICODE)
    Iwcstombs(szAlias, padid->szAlias, SIZEOF(szAlias));
#else
    lstrcpy(szAlias, padid->szAlias);
#endif
    if (ERROR_SUCCESS != XRegCreateKey( hkeyDriverCache, szAlias, &hkeyCache ))
    {
	mmr = MMSYSERR_NOMEM;	// Can't think of anything better
	goto Destruct;
    }

    //
    //	Write all our cache information to the registry.
    //	    fdwSupport
    //	    cFormatTags
    //	    aFormatTagCache
    //	    cFilterTags
    //	    aFilterTagCache
    //
    XRegSetValueEx( hkeyCache, gszValfdwSupport, 0L, REG_DWORD,
		   (LPBYTE)&fdwSupport, sizeof(fdwSupport) );

    XRegSetValueEx( hkeyCache, gszValcFormatTags, 0L, REG_DWORD,
		   (LPBYTE)&cFormatTags, sizeof(cFormatTags) );

    if (0 != cFormatTags) {
	XRegSetValueEx( hkeyCache, gszValaFormatTagCache, 0L, REG_BINARY,
		       (LPBYTE)paFormatTagCache, cbaFormatTagCache );
    }

    XRegSetValueEx( hkeyCache, gszValcFilterTags, 0L, REG_DWORD,
		   (LPBYTE)&cFilterTags, sizeof(cFilterTags) );

    if (0 != cFilterTags) {
	XRegSetValueEx( hkeyCache, gszValaFilterTagCache, 0L, REG_BINARY,
		       (LPBYTE)paFilterTagCache, cbaFilterTagCache );
    }

    //
    //
    //
    mmr	    = MMSYSERR_NOERROR;

    //
    //	Clean up and return
    //
Destruct:
    if (NULL != hkeyCache) {
	XRegCloseKey(hkeyCache);
    }
    if (NULL != hkeyDriverCache) {
	XRegCloseKey(hkeyDriverCache);
    }

#ifdef DEBUG
    dwTime = timeGetTime() - dwTime;
    DPF(4, "IDriverWriteRegistryData: took %d ms", dwTime);
#endif
	
    return (mmr);
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverReadRegistryData
//
//  Description:
//	Reads from the registry data which describes a driver.
//
//  Arguments:
//      PACMDRIVERID padid:
//	    Pointer to ACMDRIVERID.
//
//  Return (MMRESULT):
//
//  History:
//      08/30/94    frankye
//
//  Notes:
//	This function will succeed only for drivers added with
//	ACM_DRIVERADDF_NAME.  The function attempts to open a key having
//	the same name as the szAlias member of ACMDRIVERID.  The data
//	stored under that key is described in the comment header for
//	IDriverWriteRegistryData().
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverReadRegistryData(PACMDRIVERID padid)
{

    HKEY		    hkeyDriverCache;
    HKEY		    hkeyCache;
    DWORD		    fdwSupport;
    DWORD		    cFormatTags;
    DWORD		    cFilterTags;
    PACMFORMATTAGCACHE	    paFormatTagCache;
    UINT		    cbaFormatTagCache;
    PACMFILTERTAGCACHE	    paFilterTagCache;
    UINT		    cbaFilterTagCache;
    TCHAR		    szAlias[MAX_DRIVER_NAME_CHARS];
    DWORD		    dwType;
    DWORD		    cbData;
    LONG		    lr;
    MMRESULT		    mmr;

#ifdef DEBUG
    DWORD dwTime;

    dwTime = timeGetTime();
#endif

    hkeyDriverCache	= NULL;
    hkeyCache		= NULL;
    paFormatTagCache	= NULL;
    paFilterTagCache	= NULL;

    //
    //  We only keep registry data for ACM_DRIVERADDF_NAME drivers.
    //
    if (ACM_DRIVERADDF_NAME != (padid->fdwAdd & ACM_DRIVERADDF_TYPEMASK))
    {
	mmr = MMSYSERR_NOTSUPPORTED;
	goto Destruct;
    }

    //
    //	Open the registry keys under which we store the cache information
    //
    lr = XRegOpenKey( HKEY_LOCAL_MACHINE, gszDriverCache, &hkeyDriverCache );
    if ( ERROR_SUCCESS != lr )
    {
	hkeyDriverCache = NULL;
	mmr = MMSYSERR_NOMEM;	// Can't think of anything better
	goto Destruct;
    }

#if defined(WIN32) && !defined(UNICODE)
    Iwcstombs(szAlias, padid->szAlias, SIZEOF(szAlias));
#else
    lstrcpy(szAlias, padid->szAlias);
#endif
    lr = XRegOpenKey( hkeyDriverCache, szAlias, &hkeyCache );
    if (ERROR_SUCCESS != lr)
    {
	mmr = ACMERR_NOTPOSSIBLE;    // Can't think of anything better
	goto Destruct;
    }

    //
    //	Attempt to read the fdwSupport for this driver
    //
    cbData = sizeof(fdwSupport);
    lr = XRegQueryValueEx( hkeyCache, gszValfdwSupport, 0L, &dwType,
			  (LPBYTE)&fdwSupport, &cbData );

    if ( (ERROR_SUCCESS != lr) ||
	 (REG_DWORD != dwType) ||
	 (sizeof(fdwSupport) != cbData) )
    {
	mmr = ACMERR_NOTPOSSIBLE;
	goto Destruct;
    }

    //
    //	Attempt to read cFormatTags for this driver.  If more than zero
    //	format tags, then allocate a FormatTagCache array and attempt to
    //	read the cache array from the registry.
    //
    cbData = sizeof(cFormatTags);
    lr = XRegQueryValueEx( hkeyCache, gszValcFormatTags, 0L, &dwType,
			  (LPBYTE)&cFormatTags, &cbData );

    if ( (ERROR_SUCCESS != lr) ||
	 (REG_DWORD != dwType) ||
	 (sizeof(cFormatTags) != cbData) )
    {
	mmr = ACMERR_NOTPOSSIBLE;
	goto Destruct;
    }

    if (0 != cFormatTags)
    {
	cbaFormatTagCache = (UINT)cFormatTags * sizeof(*paFormatTagCache);
	paFormatTagCache = (PACMFORMATTAGCACHE)LocalAlloc(LPTR, cbaFormatTagCache);
	if (NULL == paFormatTagCache) {
	    mmr = MMSYSERR_NOMEM;
	    goto Destruct;
	}

	cbData = cbaFormatTagCache;
	lr = XRegQueryValueEx( hkeyCache, gszValaFormatTagCache, 0L, &dwType,
			      (LPBYTE)paFormatTagCache, &cbData );

	if ( (ERROR_SUCCESS != lr) ||
	     (REG_BINARY != dwType) ||
	     (cbaFormatTagCache != cbData) )
	{
	    mmr = ACMERR_NOTPOSSIBLE;
	    goto Destruct;
	}

    }

    //
    //	Attempt to read cFilterTags for this driver.  If more than zero
    //	filter tags, then allocate a FilterTagCache array and attempt to
    //	read the cache array from the registry.
    //
    cbData = sizeof(cFilterTags);
    lr = XRegQueryValueEx( hkeyCache, gszValcFilterTags, 0L, &dwType,
			  (LPBYTE)&cFilterTags, &cbData );

    if ( (ERROR_SUCCESS != lr) ||
	 (REG_DWORD != dwType) ||
	 (sizeof(cFilterTags) != cbData) )
    {
	mmr = ACMERR_NOTPOSSIBLE;
	goto Destruct;
    }

    if (0 != cFilterTags)
    {
	cbaFilterTagCache = (UINT)cFilterTags * sizeof(*paFilterTagCache);
	paFilterTagCache = (PACMFILTERTAGCACHE)LocalAlloc(LPTR, cbaFilterTagCache);
	if (NULL == paFilterTagCache) {
	    mmr = MMSYSERR_NOMEM;
	    goto Destruct;
	}

	cbData = cbaFilterTagCache;
	lr = XRegQueryValueEx( hkeyCache, gszValaFilterTagCache, 0L, &dwType,
			      (LPBYTE)paFilterTagCache, &cbData );

	if ( (ERROR_SUCCESS != lr) ||
	     (REG_BINARY != dwType) ||
	     (cbaFilterTagCache != cbData) )
	{
	    mmr = ACMERR_NOTPOSSIBLE;
	    goto Destruct;
	}

    }

    //
    //	Copy all the cache information to the ACMDRIVERID structure for
    //	this driver.  Note that we use the cache arrays that were allocated
    //	in this function.
    //
    padid->fdwSupport	    = fdwSupport;
    padid->cFormatTags	    = (UINT)cFormatTags;
    padid->paFormatTagCache = paFormatTagCache;
    padid->cFilterTags	    = (UINT)cFilterTags;
    padid->paFilterTagCache = paFilterTagCache;

    mmr			    = MMSYSERR_NOERROR;

    //
    //	Clean up and return.
    //
Destruct:
    if (MMSYSERR_NOERROR != mmr)
    {
	if (NULL != paFormatTagCache) {
	    LocalFree((HLOCAL)paFormatTagCache);
	}
	if (NULL != paFilterTagCache) {
	    LocalFree((HLOCAL)paFilterTagCache);
	}
    }
    if (NULL != hkeyCache) {
	XRegCloseKey(hkeyCache);
    }
    if (NULL != hkeyDriverCache) {
	XRegCloseKey(hkeyDriverCache);
    }

#ifdef DEBUG
    dwTime = timeGetTime() - dwTime;
    DPF(4, "IDriverReadRegistryData: took %d ms", dwTime);
#endif

    return (mmr);
}


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverLoad
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD fdwLoad:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverLoad
(
    HACMDRIVERID            hadid,
    DWORD                   fdwLoad
)
{
    BOOL                f;
    PACMDRIVERID        padid;
    PACMDRIVERDETAILS   padd;
    MMRESULT            mmr;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    DV_DFLAGS(fdwLoad, IDRIVERLOAD_VALIDF, IDriverLoad, MMSYSERR_INVALFLAG);

    padd  = NULL;
    padid = (PACMDRIVERID)hadid;

    //
    //
    //
    if (0 != (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
    {
        DPF(0, "!IDriverLoad: driver is already loaded!");
	mmr = MMSYSERR_NOERROR;
	goto Destruct;
    }

    //
    //
    //
#ifdef WIN32
    DPF(1, "IDriverLoad(): loading ACM driver (%ls).", (LPWSTR)padid->szAlias);
#else
    DPF(1, "IDriverLoad(): loading ACM driver (%s).",  (LPTSTR)padid->szAlias);
#endif

    //
    //  note that lParam2 is set to 0L in this case to signal the driver
    //  that it is merely being loaded to put it in the list--not for an
    //  actual conversion. therefore, drivers do not need to allocate
    //  any instance data on this initial DRV_OPEN (unless they want to)
    //
    mmr = MMSYSERR_NOERROR;

#ifndef WIN32
    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT)
    {
	mmr = IDriverLoad32(padid->hadid32, padid->fdwAdd);
    }
    else
#endif // !WIN32
    {
        if (NULL == padid->fnDriverProc)
        {
	    if (padid->fdwAdd & ACM_DRIVERADDF_PNP)
	    {
		padid->hdrvr = OpenDriver(padid->pstrPnpDriverFilename, NULL, 0L);
	    }
	    else
	    {
		padid->hdrvr = OpenDriver(padid->szAlias, padid->pszSection, 0L);
	    }
	
	    if (padid->hdrvr == NULL)
            {
                mmr = MMSYSERR_NODRIVER;
            }
        }
        //
        //  if the driver is a ACM_DRIVERADDF_FUNCTION, then we bogus
        //  what an OpenDriver() call would look like to the function.
        //
        else if (0 == (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
        {
            if (!IDriverMessageId(hadid, DRV_LOAD, 0L, 0L))
            {
                mmr = MMSYSERR_NODRIVER;
            }
            else
            {
                IDriverMessageId(hadid, DRV_ENABLE, 0L, 0L);

                padid->dwInstance = IDriverMessageId(hadid, DRV_OPEN, 0L, 0L);
                if (0L == padid->dwInstance)
                {
                    mmr = MMSYSERR_NODRIVER;
                }
            }
        }
    }

    if (MMSYSERR_NOERROR != mmr)
    {
        DebugErr1(DBF_WARNING, "ACM driver (%ls) failed to load.", (LPTSTR)padid->szAlias);
	padid->fRemove = TRUE;	    // Try to remove next chance.
	goto Destruct;
    }


    //
    //  mark driver as loaded (although we may dump it back out if something
    //  is bogus below...)
    //
    padid->fdwDriver |= ACMDRIVERID_DRIVERF_LOADED;

    if (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
    {
	mmr = (MMSYSERR_NOERROR);
	goto Destruct;
    }


    //
    //	In case any of the following validation fails, flag this driver
    //	to be removed next chance
    //
    padid->fRemove = TRUE;

    //
    //  now get the driver details--we use this all the time, so we will
    //  cache it. this also enables us to free a driver until it is needed
    //  for real work...
    //
    padd = (PACMDRIVERDETAILS)LocalAlloc(LPTR, sizeof(*padd));
    if (NULL == padd) {
	mmr = MMSYSERR_NOMEM;
	goto Destruct;
    }
    padd->cbStruct = sizeof(*padd);
    mmr = IDriverDetails(hadid, padd, 0L);

    if (MMSYSERR_NOERROR != mmr)
    {
        DebugErr1(DBF_ERROR, "%ls: failed driver details query.", (LPTSTR)padid->szAlias);
	goto Destruct;
    }

    if (HIWORD(VERSION_MSACM) < HIWORD(padd->vdwACM))
    {
        DebugErr2(DBF_ERROR, "%ls: driver requires V%.04Xh of ACM.", (LPTSTR)padid->szAlias, HIWORD(padd->vdwACM));
	mmr = (MMSYSERR_ERROR);
	goto Destruct;
    }

    if (sizeof(*padd) != padd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "%ls: driver returned incorrect driver details struct size.", (LPTSTR)padid->szAlias);
	mmr = (MMSYSERR_ERROR);
	goto Destruct;
    }

    if ((ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != padd->fccType) ||
        (ACMDRIVERDETAILS_FCCCOMP_UNDEFINED  != padd->fccComp))
    {
        DebugErr1(DBF_ERROR, "%ls: driver returned incorrect fccType or fccComp in driver details.", (LPTSTR)padid->szAlias);
	mmr = (MMSYSERR_ERROR);
	goto Destruct;
    }

    if ((0 == padd->wMid) || (0 == padd->wPid))
    {
        DebugErr1(DBF_WARNING, "%ls: wMid/wPid must be finalized before shipping.", (LPTSTR)padid->szAlias);
    }

#if defined(WIN32) && !defined(UNICODE)
    if ( (!_V_STRINGW(padd->szShortName, SIZEOFW(padd->szShortName))) ||
	 (!_V_STRINGW(padd->szLongName,  SIZEOFW(padd->szLongName)))  ||
	 (!_V_STRINGW(padd->szCopyright, SIZEOFW(padd->szCopyright))) ||
	 (!_V_STRINGW(padd->szLicensing, SIZEOFW(padd->szLicensing))) ||
	 (!_V_STRINGW(padd->szFeatures,  SIZEOFW(padd->szFeatures))) )
    {
	mmr = MMSYSERR_ERROR;
	goto Destruct;
    }
#else
    if ( (!_V_STRING(padd->szShortName, SIZEOF(padd->szShortName))) ||
	 (!_V_STRING(padd->szLongName, SIZEOF(padd->szLongName)))   ||
	 (!_V_STRING(padd->szCopyright, SIZEOF(padd->szCopyright))) ||
	 (!_V_STRING(padd->szLicensing, SIZEOF(padd->szLicensing))) ||
	 (!_V_STRING(padd->szFeatures, SIZEOF(padd->szFeatures))) )
    {
	mmr = MMSYSERR_ERROR;
	goto Destruct;
    }
#endif

    //
    //	Above validation succeeded.  Reset the fRemove flag.
    //
    padid->fRemove = FALSE;

    //
    //	We don't keep the DISABLED flag in the fdwSupport cache.
    //
    padid->fdwSupport = padd->fdwSupport & ~ACMDRIVERDETAILS_SUPPORTF_DISABLED;

    padid->cFormatTags = (UINT)padd->cFormatTags;
    mmr = IDriverGetFormatTags(padid);
    if (MMSYSERR_NOERROR != mmr)
    {
	padid->fRemove = TRUE;
	goto Destruct;
    }

    padid->cFilterTags = (UINT)padd->cFilterTags;
    mmr = IDriverGetFilterTags(padid);
    if (MMSYSERR_NOERROR != mmr)
    {
	padid->fRemove = TRUE;
	goto Destruct;
    }

    //
    //  now get some info about the driver so we don't have to keep
    //  asking all the time...
    //
    f = (0L != IDriverMessageId(hadid, DRV_QUERYCONFIGURE, 0L, 0L));
    if (f)
    {
        padid->fdwDriver |= ACMDRIVERID_DRIVERF_CONFIGURE;
    }

    f = (MMSYSERR_NOERROR == IDriverMessageId(hadid, ACMDM_DRIVER_ABOUT, -1L, 0L));
    if (f)
    {
        padid->fdwDriver |= ACMDRIVERID_DRIVERF_ABOUT;
    }

    //
    //	Save some of the ACMDRIVERID stuff to the registry
    //
    IDriverWriteRegistryData(padid);

    mmr = MMSYSERR_NOERROR;

    //
    //
    //
Destruct:
    if (NULL != padd) {
	LocalFree((HLOCAL)padd);
    }
    return (mmr);

} // IDriverLoad()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetNext
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//      LPHACMDRIVERID phadidNext:
//
//      HACMDRIVERID hadid:
//
//      DWORD fdwGetNext:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverGetNext
(
    PACMGARB		    pag,
    LPHACMDRIVERID          phadidNext,
    HACMDRIVERID            hadid,
    DWORD                   fdwGetNext
)
{
    HTASK               htask;
    PACMDRIVERID        padid;
    BOOL                fDisabled;
    BOOL                fLocal;
    BOOL                fNotify;
    BOOL                fEverything;
    BOOL		fRemove;

    DV_WPOINTER(phadidNext, sizeof(HACMDRIVERID), MMSYSERR_INVALPARAM);

    *phadidNext = NULL;

    if (-1L == fdwGetNext)
    {
        fEverything = TRUE;
    }
    else
    {
        DV_DFLAGS(fdwGetNext, IDRIVERGETNEXT_VALIDF, IDriverGetNext, MMSYSERR_INVALFLAG);

        fEverything = FALSE;

        //
        //  put flags in more convenient (cheaper) variables
        //
        fDisabled = (0 != (ACM_DRIVERENUMF_DISABLED & fdwGetNext));
        fLocal    = (0 == (ACM_DRIVERENUMF_NOLOCAL & fdwGetNext));
        fNotify   = (0 != (ACM_DRIVERENUMF_NOTIFY & fdwGetNext));
	fRemove   = (0 != (ACM_DRIVERENUMF_REMOVED & fdwGetNext));
    }

    //
    //  init where to start searching from
    //
    if (NULL != hadid)
    {
        DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

        padid = (PACMDRIVERID)hadid;
	if (pag != padid->pag)
	{
	    return (MMSYSERR_INVALHANDLE);
	}
        htask = padid->htask;
        padid = padid->padidNext;
    }
    else
    {
        padid = pag->padidFirst;
        htask = GetCurrentTask();
    }

    if (fEverything)
    {
        htask = NULL;
    }

Driver_Get_Next_Find_Driver:

    for ( ; padid; padid = padid->padidNext)
    {
        if (fEverything)
        {
            *phadidNext = (HACMDRIVERID)padid;
            return (MMSYSERR_NOERROR);
        }

        //
        //  htask will be NULL for global drivers--do not return padid
        //  if it is a local driver to another task
        //
        if (padid->htask != htask)
            continue;

        if (!fNotify && (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
            continue;

        if (!fLocal && (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver))
            continue;

        //
        //  if we are not supposed to include disabled drivers and
        //  padid is disabled, then skip it
        //
        if (!fDisabled && (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
            continue;

	//
	//  if we are not supposed to include drivers to be removed and
	//  this padid is to be removed then skip it.
	//
	if (!fRemove && padid->fRemove)
	    continue;

        *phadidNext = (HACMDRIVERID)padid;

        return (MMSYSERR_NOERROR);
    }

    if (NULL != htask)
    {
        //
        //  all done with the local drivers, now go try the global ones.
        //
        htask = NULL;
        padid = pag->padidFirst;

        goto Driver_Get_Next_Find_Driver;
    }

    //
    //  no more drivers in the list--*phadNext is set to NULL and we
    //  return the stopping condition error (not really an error...)
    //
    DPF(5, "IDriverGetNext()--NO MORE DRIVERS");

    //
    //  We should be returning NULL in *phadidNext ... let's just make sure.
    //
    ASSERT( NULL == *phadidNext );

    return (MMSYSERR_BADDEVICEID);
} // IDriverGetNext()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverSupport
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPDWORD pfdwSupport:
//
//      BOOL fFullSupport:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverSupport
(
    HACMDRIVERID            hadid,
    LPDWORD                 pfdwSupport,
    BOOL                    fFullSupport
)
{
    PACMDRIVERID        padid;
    DWORD               fdwSupport;

    DV_WPOINTER(pfdwSupport, sizeof(DWORD), MMSYSERR_INVALPARAM);

    *pfdwSupport = 0L;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);


    padid = (PACMDRIVERID)hadid;

    fdwSupport = padid->fdwSupport;

    if (fFullSupport)
    {
        if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
        {
            fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_DISABLED;
        }

        if (0 != (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver))
        {
            fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
        }

        if (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
        {
            fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_NOTIFY;
        }
    }

    *pfdwSupport = fdwSupport;

    return (MMSYSERR_NOERROR);
} // IDriverSupport()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverCount
//
//  Description:
//
//
//  Arguments:
//
//	PACMGARB pag:
//
//      DWORD pdwCount:
//
//      DWORD fdwSupport:
//
//      DWORD fdwEnum:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverCount
(
    PACMGARB		    pag,
    LPDWORD                 pdwCount,
    DWORD                   fdwSupport,
    DWORD                   fdwEnum
)
{
    MMRESULT            mmr;
    DWORD               fdw;
    DWORD               cDrivers;
    HACMDRIVERID        hadid;

    DV_WPOINTER(pdwCount, sizeof(DWORD), MMSYSERR_INVALPARAM);

    *pdwCount = 0;

    DV_DFLAGS(fdwEnum, ACM_DRIVERENUMF_VALID, IDriverCount, MMSYSERR_INVALFLAG);

    cDrivers = 0;

    hadid = NULL;

    ENTER_LIST_SHARED;

    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        mmr = IDriverSupport(hadid, &fdw, TRUE);
        if (MMSYSERR_NOERROR != mmr)
            continue;

        if (fdwSupport == (fdw & fdwSupport))
        {
            cDrivers++;
        }
    }

    LEAVE_LIST_SHARED;

    *pdwCount = cDrivers;

    return (MMSYSERR_NOERROR);
} // IDriverCount()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverCountGlobal
//
//  Description:
//      You can't really count the number of global drivers with
//      IDriverCount, so rather than mess with it I'm writing another
//      routine.
//
//  Arguments:
//
//	PACMGARB pag:
//
//      DWORD pdwCount:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL IDriverCountGlobal
(
    PACMGARB	            pag
)
{
    DWORD               cDrivers = 0;
    HACMDRIVERID        hadid;
    DWORD               fdwEnum;

    ASSERT( NULL != pag );


    //
    //  We can enumerate all global drivers using the following flags.
    //
    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;

    hadid   = NULL;


    ENTER_LIST_SHARED;
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        cDrivers++;
    }
    LEAVE_LIST_SHARED;


    return cDrivers;

} // IDriverCount()


//--------------------------------------------------------------------------;
//
//  VOID IDriverRefreshPriority
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//      HTASK htask:
//
//  Return (MMRESULT):
//
//  History:
//      09/28/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

VOID FNGLOBAL IDriverRefreshPriority
(
    PACMGARB		    pag
)
{
    HACMDRIVERID        hadid;
    PACMDRIVERID        padid;
    UINT                uPriority;
    DWORD               fdwEnum;


    //
    //  We only set priorities for non-local and non-notify drivers.
    //
    fdwEnum   = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;

    uPriority = 1;

    hadid = NULL;
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        padid = (PACMDRIVERID)hadid;

        padid->uPriority = uPriority;

        uPriority++;
    }

} // IDriverRefreshPriority()


//--------------------------------------------------------------------------;
//
//  BOOL IDriverBroadcastNotify
//
//  Description:
//
//
//  Arguments:
//      None.
//
//  Return (BOOL):
//
//  History:
//      10/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IDriverBroadcastNotify
(
    PACMGARB		pag
)
{
    HACMDRIVERID        hadid;
    PACMDRIVERID        padid;

    DPF(1, "IDriverBroadcastNotify: begin notification...");

    ASSERT( !IDriverLockPriority( pag, GetCurrentTask(), ACMPRIOLOCK_ISLOCKED ) );


    hadid = NULL;
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, (DWORD)-1L))
    {
        padid = (PACMDRIVERID)hadid;

        //
        //  skip drivers that are not loaded--when we load them, they
        //  can refresh themselves...
        //
        if (0 == (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
            continue;

        //
        //  skip disabled drivers also
        //
        if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
            continue;

        if (ACM_DRIVERADDF_NOTIFYHWND == (ACM_DRIVERADDF_TYPEMASK & padid->fdwAdd))
        {
            HWND        hwnd;
            UINT        uMsg;

            hwnd = (HWND)padid->lParam;
            uMsg = (UINT)padid->dwInstance;

            if (IsWindow(hwnd))
            {
                DPF(1, "IDriverBroadcastNotify: posting hwnd notification");
                PostMessage(hwnd, uMsg, 0, 0L);
            }
        }
        else
        {
            IDriverMessageId(hadid, ACMDM_DRIVER_NOTIFY, 0L, 0L);
        }
    }

    DPF(1, "IDriverBroadcastNotify: end notification...");

    return (TRUE);
} // IDriverBroadcastNotify()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  PACMDRIVERID IDriverFind
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//      LPARAM lParam:
//
//      DWORD fdwAdd:
//
//  Return (PACMDRIVERID):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

PACMDRIVERID FNLOCAL IDriverFind
(
    PACMGARB		    pag,
    LPARAM                  lParam,
    DWORD                   fdwAdd
)
{
    PACMDRIVERID        padid;
    HTASK               htask;
    DWORD               fdwAddType;

    if (NULL == pag->padidFirst)
    {
        return (NULL);
    }

    //
    //  !!! hack for sndPlaySound() and local drivers. !!!
    //
    htask = NULL;
    if (0 == (ACM_DRIVERADDF_GLOBAL & fdwAdd))
    {
        htask = GetCurrentTask();
    }

    fdwAddType = (ACM_DRIVERADDF_TYPEMASK & fdwAdd);


    //
    //
    //
    //
    for (padid = pag->padidFirst; padid; padid = padid->padidNext)
    {
        if (padid->htask != htask)
            continue;

        switch (fdwAddType)
        {
            case ACM_DRIVERADDF_NOTIFY:
            case ACM_DRIVERADDF_FUNCTION:
            case ACM_DRIVERADDF_NOTIFYHWND:
                if (padid->lParam == lParam)
                {
                    return (padid);
                }
                break;

            case ACM_DRIVERADDF_NAME:
                //
                //  This driver's alias is in lParam.
                //
#if defined(WIN32) && !defined(UNICODE)
                if( 0==Ilstrcmpwcstombs( (LPTSTR)lParam, padid->szAlias ) )
#else
                if( 0==lstrcmp( (LPTSTR)lParam, padid->szAlias ) )
#endif
                {
                    return padid;
                }
                break;

            default:
                return (NULL);
        }
    }

    return (padid);
} // IDriverFind()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverRemove
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD fdwRemove:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
)
{
    PACMDRIVERID        padid;
    PACMDRIVERID        padidT;
    MMRESULT            mmr;
    PACMGARB		pag;

    padid   = (PACMDRIVERID)hadid;
    ASSERT( NULL != padid );

    pag	    = padid->pag;

    //
    //	Uninstall this driver from system.ini?  Note that this is currently
    //	an internal flag used by the control panel.
    //
    if (ACM_DRIVERREMOVEF_UNINSTALL & fdwRemove)
    {
	TCHAR	szDummy[] = TEXT(" default ");
	TCHAR	szReturn[128];
	TCHAR	szAlias[MAX_DRIVER_NAME_CHARS];
	TCHAR	szSection[MAX_DRIVER_NAME_CHARS];
	HKEY	hkey;

	//
	//
	//
#if defined(WIN32) && !defined(UNICODE)
	Iwcstombs(szAlias, padid->szAlias, SIZEOF(szAlias));
#else
	lstrcpy(szAlias, padid->szAlias);
#endif
	
	//
	//  Dont allow uninstall of pnp drivers
	//
	if (ACM_DRIVERADDF_PNP & padid->fdwAdd) {
	    return(ACMERR_NOTPOSSIBLE);
	}
	
	//
	//  Verify that the alias is really there in system.ini.
	//
#if defined(WIN32) && !defined(UNICODE)
	Iwcstombs(szSection, padid->pszSection, SIZEOF(szSection));
#else
	lstrcpy(szSection, padid->pszSection);
#endif

	GetPrivateProfileString(szSection, szAlias, szDummy, szReturn, SIZEOF(szReturn), gszIniSystem);

	if (!lstrcmp(szDummy, szReturn))
	{
	    //
	    //	This driver is not one installed in system.ini.  Then what the
	    //	heck is it?  Maybe it's the internal PCM codec.
	    //
	    return(MMSYSERR_NODRIVER);
	}

	//
	//  Remove the alias from system.ini
	//
	WritePrivateProfileString(szSection, szAlias, NULL, gszIniSystem);

	//
	//  Remove it from the registry as well
	//
	if ( ERROR_SUCCESS == XRegOpenKey(HKEY_LOCAL_MACHINE,
					 gszKeyDrivers,
					 &hkey) )
	{
	    XRegDeleteKey(hkey, szAlias);
	    XRegCloseKey(hkey);
	}
    }
	
    //
    //
    //
    //
    if (0 != (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
    {
        mmr = IDriverFree(hadid, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            if (pag->hadidDestroy != hadid)
            {
                DebugErr1(DBF_ERROR, "acmDriverRemove(%.04Xh): driver cannot be removed while in use.", hadid);
                return (mmr);
            }

            DebugErr1(DBF_WARNING, "acmDriverRemove(%.04Xh): driver in use--forcing removal.", hadid);
        }
    }


    //
    //
    //
    DebugErr1(DBF_TRACE, "removing ACM driver (%ls).", (LPTSTR)padid->szAlias);


    //
    //  remove the driver from the linked list and free its memory
    //
    if (padid == pag->padidFirst)
    {
        pag->padidFirst = padid->padidNext;
    }
    else
    {
        for (padidT = pag->padidFirst;
             padidT && (padidT->padidNext != padid);
             padidT = padidT->padidNext)
            ;

        if (NULL == padidT)
        {
            DPF(0, "!IDriverRemove(%.04Xh): driver not in list!!!", padid);
            return (MMSYSERR_INVALHANDLE);
        }

        padidT->padidNext = padid->padidNext;
    }

    padid->padidNext = NULL;



    //
    //  free all resources allocated for this thing
    //
    if (NULL != padid->paFormatTagCache)
    {
        LocalFree((HLOCAL)padid->paFormatTagCache);
    }

    if (NULL != padid->paFilterTagCache)
    {
        LocalFree((HLOCAL)padid->paFilterTagCache);
    }

    if (NULL != padid->pstrPnpDriverFilename)
    {
	LocalFree((HLOCAL)padid->pstrPnpDriverFilename);
    }


    //
    //  set handle type to 'dead'
    //
    padid->uHandleType = TYPE_HACMNOTVALID;
    DeleteHandle((HLOCAL)padid);

    //
    //	notify 16-bit acm of driver change
    //
#ifdef WIN32
    if (NULL != pag->lpdw32BitChangeNotify)
    {
	(*pag->lpdw32BitChangeNotify)++;
    }
#endif

    return (MMSYSERR_NOERROR);
} // IDriverRemove()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverAdd
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//      LPHACMDRIVERID phadidNew:
//
//      HINSTANCE hinstModule:
//
//      LPARAM lParam:
//
//      DWORD dwPriority:
//
//      DWORD fdwAdd:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverAdd
(
    PACMGARB		    pag,
    LPHACMDRIVERID          phadidNew,
    HINSTANCE               hinstModule,
    LPARAM                  lParam,
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    PACMDRIVERID        padid;
    PACMDRIVERID        padidT;
    TCHAR               szAlias[MAX_DRIVER_NAME_CHARS];
    BOOL                fGlobal;
    MMRESULT            mmr;
    DWORD               fdwAddType;
#ifndef WIN32
    DWORD		hadid32;
    DWORD		dnDevNode32;
#endif

    DV_WPOINTER(phadidNew, sizeof(HACMDRIVERID), MMSYSERR_INVALPARAM);

    *phadidNew = NULL;

    DV_DFLAGS(fdwAdd, IDRIVERADD_VALIDF | ACM_DRIVERADDF_32BIT | ACM_DRIVERADDF_PNP, IDriverAdd, MMSYSERR_INVALFLAG);

#ifndef WIN32
    //
    //
    //
    if (fdwAdd & ACM_DRIVERADDF_32BIT)
    {
	ACMDRIVERPROC	fnDriverProc;
	DWORD		fdwAdd32;

	ASSERT(0 == (fdwAdd & ~ACM_DRIVERADDF_32BIT));
	
	//
	//  For 32-bit driver adds, lParam is the 32-bit hadid.  Get some
	//  info about the 32-bit hadid and prepare it to fall through to
	//  rest of this function.
	//
	hadid32 = (DWORD)lParam;
	mmr = IDriverGetInfo32(pag, hadid32, szAlias, &fnDriverProc, &dnDevNode32, &fdwAdd32);
	if (MMSYSERR_NOERROR != mmr)
	{
	    return (mmr);
	}

	//
	//  Use same add flags as 32-bit side (along with ACM_DRIVERADDF_32BIT)
	//
	fdwAdd |= fdwAdd32;
	
	//
	//  Set up lParam to fall through
	//
	fdwAddType = (ACM_DRIVERADDF_TYPEMASK & fdwAdd);
	if (ACM_DRIVERADDF_NAME == fdwAddType)
	{
	    lParam = (LPARAM)szAlias;
	}
	if (ACM_DRIVERADDF_FUNCTION == fdwAddType)
	{
	    lParam = (LPARAM)fnDriverProc;
	}
    }
#endif

    //
    //
    //
    //
    fGlobal    = (0 != (ACM_DRIVERADDF_GLOBAL & fdwAdd));
    fdwAddType = (ACM_DRIVERADDF_TYPEMASK & fdwAdd);


    switch (fdwAddType)
    {
        case ACM_DRIVERADDF_NAME:
            if (IsBadStringPtr((LPTSTR)lParam, SIZEOF(szAlias)))
            {
                return (MMSYSERR_INVALPARAM);
            }

            lstrcpy(szAlias, (LPTSTR)lParam);
            break;

//#pragma message(REMIND("IDriverAdd: no validation for global function pointers in DLL's"))

        case ACM_DRIVERADDF_FUNCTION:
            if (0 != dwPriority)
            {
                DebugErr(DBF_ERROR, "acmDriverAdd: dwPriority must be zero.");
                return (MMSYSERR_INVALPARAM);
            }

	    //
	    //	For 32-bit codecs, szAlias is already setup, don't
	    //	validate the function pointer, so don't fall through.
	    //
#ifndef WIN32
	    if (0 != (fdwAdd & ACM_DRIVERADDF_32BIT))
	    {
		break;
	    }
#endif

	    //	fall through //
	
        case ACM_DRIVERADDF_NOTIFY:
            if (IsBadCodePtr((FARPROC)lParam))
            {
                DebugErr1(DBF_ERROR, "acmDriverAdd: function pointer %.08lXh is invalid.", lParam);
                return (MMSYSERR_INVALPARAM);
            }

            if ((NULL == hinstModule) ||
                !GetModuleFileName(hinstModule, szAlias, SIZEOF(szAlias)))
            {
                return (MMSYSERR_INVALPARAM);
            }

            //
            //  Make sure that we always use the lower-case version;
            //  otherwise the priorities will not necessarily work right
            //  because the case of the module name will be different and
            //  the comparison may fail.
            //
#ifdef WIN32
            CharLowerBuff( szAlias, MAX_DRIVER_NAME_CHARS );
#else
            AnsiLowerBuff( szAlias, MAX_DRIVER_NAME_CHARS );
#endif

            break;

        case ACM_DRIVERADDF_NOTIFYHWND:
            if (fGlobal)
            {
                DebugErr1(DBF_ERROR, "acmDriverAdd: ACM_DRIVERADDF_NOTIFYHWND cannot be used with ACM_DRIVERADDF_GLOBAL.", lParam);
                return (MMSYSERR_INVALPARAM);
            }

            if (!IsWindow((HWND)lParam))
            {
                DebugErr1(DBF_ERROR, "acmDriverAdd: window handle %.08lXh is invalid.", lParam);
                return (MMSYSERR_INVALHANDLE);
            }

            if ((NULL == hinstModule) ||
                !GetModuleFileName(hinstModule, szAlias, SIZEOF(szAlias)))
            {
                DebugErr1(DBF_ERROR, "acmDriverAdd: hinstModule %.08lXh is invalid.", hinstModule);
                return (MMSYSERR_INVALPARAM);
            }

#ifdef WIN32
            CharLowerBuff( szAlias, MAX_DRIVER_NAME_CHARS );
#else
            AnsiLowerBuff( szAlias, MAX_DRIVER_NAME_CHARS );
#endif

            break;

        default:
            DebugErr1(DBF_ERROR, "acmDriverAdd: invalid driver add type (%.08lXh).", fdwAddType);
            return (MMSYSERR_INVALPARAM);
    }


    DebugErr1(DBF_TRACE, "adding ACM driver (%ls).", (LPTSTR)szAlias);

    //
    //  if the driver has already been added (by the same task) then
    //  fail.. we don't support this currently--and may never.
    //
    padid = IDriverFind(pag, lParam, fdwAdd);
    if (NULL != padid)
    {
	if (fdwAdd & ACM_DRIVERADDF_32BIT)
	{
	    DPF(3, "acmDriverAdd: 32-bit driver already added");
	}
	else if (fdwAdd & ACM_DRIVERADDF_PNP)
	{
	    DPF(3, "acmDriverAdd: Pnp driver already added");
	}
	else
	{
	    DPF(3, "acmDriverAdd: attempt to add duplicate reference to driver.");
	    DebugErr(DBF_WARNING, "acmDriverAdd: attempt to add duplicate reference to driver.");
	}
        return (MMSYSERR_ERROR);
    }

    //
    //  new driver - Alloc space for the new driver identifier.
    //
    //  NOTE: we rely on this memory being zero-init'd!!
    //
    padid = (PACMDRIVERID)NewHandle(sizeof(ACMDRIVERID));
    if (NULL == padid)
    {
        DPF(0, "!IDriverAdd: local heap full--cannot create identifier!!!");
        return (MMSYSERR_NOMEM);
    }


    //
    //  save the filename, function ptr or hinst, and ptr back to garb
    //
    padid->pag		= pag;
    padid->uHandleType  = TYPE_HACMDRIVERID;
    padid->uPriority    = 0;
    padid->lParam       = lParam;
    padid->fdwAdd       = fdwAdd;
#ifndef WIN32
    padid->hadid32	= hadid32;
    padid->dnDevNode	= dnDevNode32;
#endif
#if defined(WIN32) && !defined(UNICODE)
    Imbstowcs(padid->szAlias, szAlias, SIZEOFW(padid->szAlias));
#else
    lstrcpy(padid->szAlias, szAlias);
#endif

    //
    //	Set up the section name for this driver
    //
    if (fdwAdd & ACM_DRIVERADDF_PNP)
    {
	//
	//  A pnp driver (may/may not be native bitness)
	//
	padid->pszSection = NULL;
    }
    else
    {
#ifndef WIN32
	if (fdwAdd & ACM_DRIVERADDF_32BIT)
	{
	    //
	    //  A thunked non-pnp driver (system.ini driver)
	    //
	    padid->pszSection = gszSecDrivers32;
	}
	else
#endif
	{
	    //
	    //	A native bitness non-pnp driver
	    //
#ifdef WIN32
	    padid->pszSection = gszSecDriversW;
#else
	    padid->pszSection = gszSecDrivers;
#endif
	}
    }

	
#ifdef WIN32
    if (fdwAdd & ACM_DRIVERADDF_PNP)
    {
	//
	//  Need to get the pnp devnode id the the driver filename from
	//  the registry.
	//
	
	LONG	lr;
	TCHAR	achDriverKey[SIZEOF(gszKeyDrivers) + MAX_DRIVER_NAME_CHARS];
	DWORD	cbData;
	DWORD	dwType;
	DWORD	cbDriverFilename;
	DWORD	cchDriverFilename;
	DWORD	cbPnpDriverFilename;
	PTSTR	pstrDriverFilename;
	HKEY	hkeyDriver;

	pstrDriverFilename = NULL;
	padid->pstrPnpDriverFilename = NULL;
	
	wsprintf(achDriverKey, gszFormatDriverKey, gszKeyDrivers, szAlias);
	lr = XRegOpenKeyEx(HKEY_LOCAL_MACHINE,
			  achDriverKey,
			  0L,
			  KEY_QUERY_VALUE,
			  &hkeyDriver);

	if (ERROR_SUCCESS == lr)
	{
	    //
	    //  Get pnp devnode id from the registry.
	    //

	    cbData = sizeof(padid->dnDevNode);
	    lr = XRegQueryValueEx(hkeyDriver,
				 (LPTSTR)gszDevNode,
				 NULL,
				 &dwType,
				 (LPBYTE)&padid->dnDevNode,
				 &cbData);

	    if (ERROR_SUCCESS == lr)
	    {
		if ( (dwType != REG_DWORD && dwType != REG_BINARY) ||
		     (sizeof(padid->dnDevNode) != cbData) )
		{
		    lr = ERROR_CANTOPEN;	// whatever
		}
	    }		


	    if (ERROR_SUCCESS == lr)
	    {
		//
		//  Get the driver filename of the pnp driver
		//
	
		//
		//  Determine size of buffer needed to store the filename
		//
		lr = XRegQueryValueEx(hkeyDriver,
				     (LPTSTR)gszDriver,
				     NULL,
				     NULL,
				     NULL,
				     &cbDriverFilename);

		if (ERROR_SUCCESS == lr)
		{
		    //
		    //
		    //
		    pstrDriverFilename = (PTSTR)LocalAlloc(LPTR, cbDriverFilename);
		
		    if (NULL == pstrDriverFilename) {
			lr = ERROR_OUTOFMEMORY;
		    } else {
			lr = XRegQueryValueEx(hkeyDriver,
					     (LPTSTR)gszDriver,
					     NULL,
					     &dwType,
					     (LPBYTE)pstrDriverFilename,
					     &cbDriverFilename);
			if (ERROR_SUCCESS == lr)
			{
			    if (REG_SZ != dwType) {
				lr = ERROR_CANTOPEN;
			    }
			}
		    }
		}
	    }

	    XRegCloseKey(hkeyDriver);
	}

	if (ERROR_SUCCESS == lr)
	{
	    cchDriverFilename = cbDriverFilename / sizeof(TCHAR);
#if defined(WIN32) && !defined(UNICODE)
	    cbPnpDriverFilename = cchDriverFilename * sizeof(WCHAR);
	    padid->pstrPnpDriverFilename = (PWSTR)LocalAlloc( LPTR, cbPnpDriverFilename);
	    if (NULL == padid->pstrPnpDriverFilename) {
		lr = ERROR_OUTOFMEMORY;
	    } else {
		Imbstowcs(padid->pstrPnpDriverFilename, pstrDriverFilename, cbPnpDriverFilename);
	    }
#else
	    cbPnpDriverFilename = cchDriverFilename * sizeof(TCHAR);
	    padid->pstrPnpDriverFilename = (PTSTR)LocalAlloc( LPTR, cbPnpDriverFilename);
	    if (NULL == padid->pstrPnpDriverFilename) {
		lr = ERROR_OUTOFMEMORY;
	    } else {
		lstrcpy(padid->pstrPnpDriverFilename, pstrDriverFilename);
	    }
#endif
	    LocalFree((HLOCAL)pstrDriverFilename);
	    DPF(0, "IDriverAdd: added pnp driver filename %s for devnode %08lXh", pstrDriverFilename, padid->dnDevNode);
	}

	switch (lr)
	{
	    //
	    //	Try to return a sensible MMSYSERR_* given ERROR_*
	    //
	    case ERROR_SUCCESS:
		mmr = MMSYSERR_NOERROR;
		break;
	    case ERROR_OUTOFMEMORY:
		mmr = MMSYSERR_NOMEM;
		break;
	    // case ERROR_FILE_NOT_FOUND:	
	    // case ERROR_BADDB:
	    // case ERROR_MORE_DATA:
	    // case ERROR_BADKEY:
	    // case ERROR_CANTOPEN:
	    // case ERROR_CANTREAD:
	    // case ERROR_CANT_WRITE:
	    // case ERROR_REGISTRY_CORRUPT:
	    // case ERROR_REGISTRY_IO_FAILED:
	    // case ERROR_KEY_DELETED:
	    // case ERROR_INVALID_PARAMETER:
	    // case ERROR_LOCK_FAILED:
	    // case ERROR_NO_MORE_ITEMS:
	    default:
		mmr = MMSYSERR_ERROR;
		break;
	}

	if (MMSYSERR_NOERROR != mmr)
	{
	    return (mmr);
	}
    }
#endif

	

    switch (fdwAddType)
    {
        case ACM_DRIVERADDF_NOTIFYHWND:
            padid->fdwDriver   |= ACMDRIVERID_DRIVERF_NOTIFY;
            padid->fnDriverProc = (ACMDRIVERPROC)(DWORD_PTR)-1L;
            padid->dwInstance   = dwPriority;
            break;

        case ACM_DRIVERADDF_NOTIFY:
            padid->fdwDriver   |= ACMDRIVERID_DRIVERF_NOTIFY;
            padid->dwInstance   = dwPriority;

            // -- fall through -- //

        case ACM_DRIVERADDF_FUNCTION:
            padid->fnDriverProc = (ACMDRIVERPROC)lParam;
            break;
    }



    //
    //  if the driver is 'GLOBAL' then set fGlobal to TRUE
    //
    //  if this is not a global driver, then we need to associate the
    //  current task with this driver so it will only be enumerated
    //  and used in the context of the task that is adding it.
    //
    //  THIS PRESENTS A PROBLEM for applications that want to add a local
    //  driver and expect it to work with sndPlaySound because all
    //  processing for the sndPlaySound is on a separate task--meaning
    //  that the local driver will not be used when the application
    //  calls sndPlaySound... currently, we are just going to require
    //  that drivers be global if they are to work with sndPlaySound.
    //
    if (fGlobal)
    {
        padid->htask = NULL;
    }
    else
    {
        padid->fdwDriver |= ACMDRIVERID_DRIVERF_LOCAL;
        padid->htask      = GetCurrentTask();
    }


    //
    //  add the driver to the linked list of drivers
    //
    //  PRIORITY RULES:
    //
    //  o   GLOBAL drivers always get added to the _END_ of the list
    //
    //  o   LOCAL drivers always get added to the _HEAD_ of the list so
    //      the latest installed local drivers are queried first
    //
    if (!fGlobal)
    {
        padid->padidNext = pag->padidFirst;
	pag->padidFirst = padid;
    }
    else
    {
        padidT = pag->padidFirst;
        for ( ; padidT && padidT->padidNext; padidT = padidT->padidNext)
            ;

        if (NULL != padidT)
            padidT->padidNext = padid;
        else
            pag->padidFirst = padid;
    }


    //
    //	We need to get some data about this driver into the ACMDRIVERID
    //	for this driver.  First see if we can get this data from the
    //	registry.  If that doesn't work, then we'll load the driver
    //	and that will load the necessary data into ACMDRIVERID.
    //
    mmr = IDriverReadRegistryData(padid);
    if (MMSYSERR_NOERROR != mmr)
    {
	//
	//  Registry information doesn't exist or appears out of date.  Load
	//  the driver now so we can get some information about the driver
	//  into the ACMDRIVERID for this driver.
	//
	DPF(3, "IDriverAdd: Couldn't load registry data for driver.  Attempting to load.");
	mmr = IDriverLoad((HACMDRIVERID)padid, 0L);
    }

    if (MMSYSERR_NOERROR != mmr)
    {
        DebugErr(DBF_TRACE, "IDriverAdd(): driver had fatal error during load--unloading it now.");
	IDriverRemove((HACMDRIVERID)padid, 0L);
	return (mmr);
    }


    //
    //  Success!  Store the new handle, notify 16-bit side of driver change,
    //	and return.
    //
    *phadidNew = (HACMDRIVERID)padid;
#ifdef WIN32
    if (NULL != pag->lpdw32BitChangeNotify)
    {
	(*pag->lpdw32BitChangeNotify)++;
    }
#endif

    return (MMSYSERR_NOERROR);
} // IDriverAdd()



//--------------------------------------------------------------------------;
//
//  BOOL IDriverLockPriority
//
//  Description:
//      This routine manages the htaskPriority lock (pag->htaskPriority).
//
//      ACMPRIOLOCK_GETLOCK:     If the lock is free, set it to this task.
//      ACMPRIOLOCK_RELEASELOCK: If the lock is yours, release it.
//      ACMPRIOLOCK_ISMYLOCK:    Return TRUE if this task has the lock.
//      ACMPRIOLOCK_ISLOCKED:    Return TRUE if some task has the lock.
//      ACMPRIOLOCK_LOCKISOK:    Return TRUE if it's unlocked, or if it's
//                                  my lock - ie. if it's not locked for me.
//
//  Arguments:
//      PACMGARB pag:
//      HTASK htask:    The current task.
//      UINT flags:
//
//  Return (BOOL):  Success or failure.  Failure on RELEASELOCK means that
//                  the lock didn't really belong to this task.
//
//--------------------------------------------------------------------------;

BOOL IDriverLockPriority
(
    PACMGARB                pag,
    HTASK                   htask,
    UINT                    uRequest
)
{
    ASSERT( uRequest >= ACMPRIOLOCK_FIRST );
    ASSERT( uRequest <= ACMPRIOLOCK_LAST );
    ASSERT( htask == GetCurrentTask() );

    switch( uRequest )
    {
        case ACMPRIOLOCK_GETLOCK:
            if( NULL != pag->htaskPriority )
                return FALSE;
            pag->htaskPriority = htask;
            return TRUE;

        case ACMPRIOLOCK_RELEASELOCK:
            if( htask != pag->htaskPriority )
                return FALSE;
            pag->htaskPriority = NULL;
            return TRUE;

        case ACMPRIOLOCK_ISMYLOCK:
            return ( htask == pag->htaskPriority );

        case ACMPRIOLOCK_ISLOCKED:
            return ( NULL != pag->htaskPriority );

        case ACMPRIOLOCK_LOCKISOK:
            return ( htask == pag->htaskPriority ||
                     NULL == pag->htaskPriority );
    }

    DPF( 1, "!IDriverLockPriority: invalid uRequest (%u) received.",uRequest);
    return FALSE;
}


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverPriority
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD dwPriority:
//
//      DWORD fdwPriority:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverPriority
(
    PACMGARB                pag,
    PACMDRIVERID            padid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
)
{
    PACMDRIVERID        padidT;
    PACMDRIVERID        padidPrev;
    DWORD               fdwAble;
    UINT                uCurPriority;


    ASSERT( NULL != padid );


    //
    //  Enable or disable the driver.
    //
    fdwAble = ( ACM_DRIVERPRIORITYF_ABLEMASK & fdwPriority );

    switch (fdwAble)
    {
        case ACM_DRIVERPRIORITYF_ENABLE:
            padid->fdwDriver &= ~ACMDRIVERID_DRIVERF_DISABLED;
            break;

        case ACM_DRIVERPRIORITYF_DISABLE:
            padid->fdwDriver |= ACMDRIVERID_DRIVERF_DISABLED;
            break;
    }


    //
    //  Change the priority.  If dwPriority==0, then we only want to
    //  enable/disable the driver - leave the priority alone.
    //
    if( 0L != dwPriority  &&  dwPriority != padid->uPriority )
    {
        //
        //  first remove the driver from the linked list
        //
        if (padid == pag->padidFirst)
        {
            pag->padidFirst = padid->padidNext;
        }
        else
        {
            padidT = pag->padidFirst;

            for ( ; NULL != padidT; padidT = padidT->padidNext)
            {
                if (padidT->padidNext == padid)
                    break;
            }

            if (NULL == padidT)
            {
                DebugErr1(DBF_ERROR, "acmDriverPriority(): driver (%.04Xh) not in list. very strange.", (HACMDRIVERID)padid);
                return (MMSYSERR_INVALHANDLE);
            }

            padidT->padidNext = padid->padidNext;
        }

        padid->padidNext = NULL;


        //
        //  now add the driver at the correct position--this will be in
        //  the position of the current global driver
        //
        //  robinsp: i'm really sorry about all this linked list
        //  stuff--if i had one free day, i would fix all of this before you
        //  ever looked at it... but i am in 'just get it done' mode!
        //
        uCurPriority = 1;

        padidPrev = NULL;
        for (padidT = pag->padidFirst; NULL != padidT; )
        {
            //
            //  skip local and notify handles
            //
            if (0 == ((ACMDRIVERID_DRIVERF_LOCAL | ACMDRIVERID_DRIVERF_NOTIFY) & padidT->fdwDriver))
            {
                if (uCurPriority == dwPriority)
                {
                    break;
                }

                uCurPriority++;
            }

            padidPrev = padidT;
            padidT = padidT->padidNext;
        }

        if (NULL == padidPrev)
        {
            padid->padidNext = pag->padidFirst;
            pag->padidFirst = padid;
        }
        else
        {
            padid->padidNext = padidPrev->padidNext;
            padidPrev->padidNext = padid;
        }
    }

    //
    //	We need to keep the enable/disable state consistent on the 32-bit side.
    //	Otherwise, if the 32-bit side booted with a driver disabled, we may
    //	not be able to IDriverOpen32 it.  So, we'll call the 32-bit side's
    //	IDriverPriority as well.  This may adjust priorities on the 32-bit side
    //	in addition to enable/disable, but that doesn't matter.
    //
#ifndef WIN32
    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
	if (MMSYSERR_NOERROR != IDriverPriority32(pag, padid->hadid32, dwPriority, fdwPriority)) {
	    DPF(0, "!IDriverPriority: IDriverPriority32 failed!");
	}
    }
#endif // !WIN32


    return (MMSYSERR_NOERROR);
} // IDriverPriority()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverClose
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVER had:
//
//      DWORD fdwClose:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
)
{
    BOOL                f;
    PACMDRIVERID        padid;
    PACMDRIVER          pad;
    PACMGARB		pag;

    DV_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
    DV_DFLAGS(fdwClose, IDRIVERCLOSE_VALIDF, IDriverClose, MMSYSERR_INVALFLAG);


    //
    //
    //
    pad	    = (PACMDRIVER)had;
    padid   = (PACMDRIVERID)pad->hadid;
    pag	    = padid->pag;


    //
    //  Kill all the streams
    //
    if (NULL != pad->pasFirst)
    {
        if (pag->hadDestroy != had)
        {
            DebugErr1(DBF_ERROR, "acmDriverClose(%.04Xh): driver has open streams--cannot be closed!", had);
            return (ACMERR_BUSY);
        }

        DebugErr1(DBF_WARNING, "acmDriverClose(%.04Xh): driver has open streams--forcing close!", had);
    }

#ifdef WIN32
    DPF(1, "closing ACM driver instance (%ls).", (LPWSTR)padid->szAlias);
#else
    DPF(1, "closing ACM driver instance (%s).",  (LPTSTR)padid->szAlias);
#endif

    //
    //  if the driver is open for this instance, then close it down...
    //
    //
#ifndef WIN32
    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
        f = 0L == IDriverClose32(pad->had32, fdwClose);
        if (!f)
        {
            DebugErr1(DBF_WARNING, "acmDriverClose(%.04Xh): driver failed close message!?!", had);

            if (pag->hadDestroy != had)
            {
                return (MMSYSERR_ERROR);
            }
        }
    }
    else
#endif // !WIN32
    {
        if ((NULL != pad->hdrvr) || (0L != pad->dwInstance))
        {
            //
            //  clear the rest of the table entry
            //
            f = FALSE;
            if (NULL != pad->fnDriverProc)
            {
                f = (0L != IDriverMessage(had, DRV_CLOSE, 0L, 0L));
            }
            else if (NULL != pad->hdrvr)
            {
                f = (0L != (
                CloseDriver(pad->hdrvr, 0L, 0L)));
            }

            if (!f)
            {
                DebugErr1(DBF_WARNING, "acmDriverClose(%.04Xh): driver failed close message!?!", had);

                if (pag->hadDestroy != had)
                {
                    return (MMSYSERR_ERROR);
                }
            }
        }
    }

    //
    //  remove the driver instance from the linked list and free its memory
    //
    if (pad == padid->padFirst)
    {
        padid->padFirst = pad->padNext;
    }
    else
    {
        PACMDRIVER  padCur;

        //
        //
        //
        for (padCur = padid->padFirst;
             (NULL != padCur) && (pad != padCur->padNext);
             padCur = padCur->padNext)
            ;

        if (NULL == padCur)
        {
            DPF(0, "!IDriverClose(%.04Xh): driver not in list!!!", pad);
            return (MMSYSERR_INVALHANDLE);
        }

        padCur->padNext = pad->padNext;
    }

    pad->uHandleType = TYPE_HACMNOTVALID;
    DeleteHandle((HLOCAL)pad);

    return (MMSYSERR_NOERROR);
} // IDriverClose()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverOpen
//
//  Description:
//
//
//  Arguments:
//      LPHACMDRIVER phadNew:
//
//      HACMDRIVERID hadid:
//
//      DWORD fdwOpen:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverOpen
(
    LPHACMDRIVER            phadNew,
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
)
{
    ACMDRVOPENDESC      aod;
    PACMDRIVERID        padid;
    PACMDRIVER          pad;
    MMRESULT            mmr;
    PACMGARB		pag;

    DV_WPOINTER(phadNew, sizeof(HACMDRIVER), MMSYSERR_INVALPARAM);

    *phadNew = NULL;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    DV_DFLAGS(fdwOpen, IDRIVEROPEN_VALIDF, IDriverOpen, MMSYSERR_INVALFLAG);


    padid   = (PACMDRIVERID)hadid;
    pag	    = padid->pag;


    //
    //  if the driver has never been loaded, load it and keep it loaded.
    //
    if (0L == (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
    {
        //
        //
        //
        mmr = IDriverLoad(hadid, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            DebugErr1(DBF_TRACE, "acmDriverOpen(%.04Xh): driver had fatal error during load", hadid);
            return (mmr);
        }
    }


    //
    //
    //
    if (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
    {
        DebugErr1(DBF_ERROR, "acmDriverOpen(%.04Xh): notification handles cannot be opened.", hadid);
        return (MMSYSERR_INVALHANDLE);
    }


    //
    //  do not allow opening of a disabled driver
    //
    if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
    {
        DebugErr1(DBF_ERROR, "acmDriverOpen(%.04Xh): driver is disabled.", hadid);
        return (MMSYSERR_NOTENABLED);
    }


    //
    //
    //
#ifdef WIN32
    DPF(1, "opening ACM driver instance (%ls).", (LPWSTR)padid->szAlias);
#else
    DPF(1, "opening ACM driver instance (%s).",  (LPTSTR)padid->szAlias);
#endif

    //
    //  alloc space for the new driver instance.
    //
    pad = (PACMDRIVER)NewHandle(sizeof(ACMDRIVER));
    if (NULL == pad)
    {
        DPF(0, "!IDriverOpen: local heap full--cannot create instance!");
        return (MMSYSERR_NOMEM);
    }

    pad->uHandleType = TYPE_HACMDRIVER;
    pad->pasFirst    = NULL;
    pad->hadid       = hadid;
    pad->htask       = GetCurrentTask();
    pad->fdwOpen     = fdwOpen;


    //
    //  add the new driver instance to the head of our list of open driver
    //  instances for this driver identifier.
    //
    pad->padNext    = padid->padFirst;
    padid->padFirst = pad;


#ifndef WIN32
    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {

        //
        //  The 32-bit hadid is the hdrvr of our hadid.
        //  The 32-bit had will be returned in our had's hdrvr
        //
        mmr = IDriverOpen32(&pad->had32, padid->hadid32, fdwOpen);
        if (mmr != MMSYSERR_NOERROR) {
            IDriverClose((HACMDRIVER)pad, 0L);
            return mmr;
        }
    } else
#endif // !WIN32
    {
        //
        //
        //
        //
        //
        aod.cbStruct       = sizeof(aod);
        aod.fccType        = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
        aod.fccComp        = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;
        aod.dwVersion      = VERSION_MSACM;
        aod.dwFlags        = fdwOpen;
        aod.dwError        = MMSYSERR_NOERROR;
        aod.pszSectionName = padid->pszSection;
        aod.pszAliasName   = padid->szAlias;
	aod.dnDevNode	   = padid->dnDevNode;

        //
        //  send the DRV_OPEN message that contains the ACMDRVOPENDESC info
        //
        //
        if (NULL != padid->hdrvr)
        {
            HDRVR       hdrvr;

	    if (padid->fdwAdd & ACM_DRIVERADDF_PNP)
	    {
		//
		//  Note thunked 32-bit [pnp] drivers were handled above.
		//
		hdrvr = OpenDriver(padid->pstrPnpDriverFilename, NULL, (LPARAM)(LPVOID)&aod);
	    }
	    else
	    {
		hdrvr = OpenDriver(padid->szAlias, padid->pszSection, (LPARAM)(LPVOID)&aod);
	    }
	
            if (NULL == hdrvr)
            {
                DebugErr1(DBF_WARNING, "ACM driver instance (%ls) failed open.", (LPTSTR)padid->szAlias);
                IDriverClose((HACMDRIVER)pad, 0L);

                if (MMSYSERR_NOERROR == aod.dwError)
                    return (MMSYSERR_ERROR);

                return ((MMRESULT)aod.dwError);
            }

            pad->hdrvr = hdrvr;
        }
        else
        {
            LRESULT lr;

            lr = IDriverMessageId(hadid, DRV_OPEN, 0L, (LPARAM)(LPVOID)&aod);
            if (0 == lr)
            {
                IDriverClose((HACMDRIVER)pad, 0L);

                if (MMSYSERR_NOERROR == aod.dwError)
                    return (MMSYSERR_ERROR);

                return ((MMRESULT)aod.dwError);
            }

            pad->dwInstance   = lr;
            pad->fnDriverProc = padid->fnDriverProc;
        }
    }

    *phadNew = (HACMDRIVER)pad;

    return (MMSYSERR_NOERROR);
} // IDriverOpen()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT IDriverAppExit
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//      HTASK htask:
//
//      BOOL fNormalExit:
//
//  Return (LRESULT):
//
//  History:
//      07/18/93    cjp     [curtisp]
//	07/19/94    fdy	    [frankye]
//	    !!!HACK- When the ACM is shutting down, we are within our
//	    DllEntryPoint and we can't use our thunks.  So, for unreleased
//	    streams and driver handles, we can't do much about the 32-bit
//	    codecs from the 16-bit side.
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverAppExit
(
    PACMGARB		    pag,
    HTASK                   htask,
    LPARAM                  lParam
)
{
    HACMDRIVERID        hadid;
    BOOL                fNormalExit;
    DWORD               fdwEnum;
    UINT                fuDebugFlags;
#if !defined(WIN32) && defined(DEBUG)
    TCHAR               szTask[128];
#endif


    if (NULL == pag)
    {
	return (0L);
    }

    fNormalExit = (DRVEA_NORMALEXIT == lParam);

#ifdef DEBUG
#ifndef WIN32
    szTask[0] = '\0';
    if (0 != GetModuleFileName((HINSTANCE)GetTaskDS(), szTask, SIZEOF(szTask)))
    {
        DPF(2, "IDriverAppExit(htask=%.04Xh [%s], fNormalExit=%u) BEGIN", htask, (LPSTR)szTask, fNormalExit);
    }
    else
#endif
    {
        DPF(2, "IDriverAppExit(htask=%.04Xh, fNormalExit=%u) BEGIN", htask, fNormalExit);
    }
#endif

#ifdef DEBUG
    if (NULL != pag->hadidDestroy)
    {
        DPF(0, "!Hey! IDriverAppExit has been re-entered!");
    }
#endif

    //
    //  either log a error or a warning depending on wether it was
    //  a normal exit or not.
    //
    if (fNormalExit)
    {
        fuDebugFlags = DBF_ERROR;
    }
    else
    {
        fuDebugFlags = DBF_WARNING; // DBF_TRACE?
        DPF(0, "*** abnormal app termination ***");
    }

    //
    //
    //
    //
    if (NULL == htask)
        fdwEnum = (DWORD)-1L;
    else
        fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOTIFY;

IDriver_App_Exit_Again:

    hadid = NULL;
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        PACMDRIVERID        padid;
        PACMDRIVER          pad;
        PACMSTREAM          pas;

	pag->hadidDestroy = hadid;

        padid = (PACMDRIVERID)hadid;

        for (pad = padid->padFirst; NULL != pad; pad = pad->padNext)
        {
            //
            //  if htask is NULL, then acm is unloading--so kill all!
            //
            if (NULL != htask)
            {
                if (htask != pad->htask)
                    continue;
            }

	    pag->hadDestroy = (HACMDRIVER)pad;

            for (pas = pad->pasFirst; NULL != pas; pas = pas->pasNext)
            {
                DebugErr1(fuDebugFlags, "ACM stream handle (%.04Xh) was not released.", pas);

		if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
		    continue;
		} else {
		    acmStreamReset((HACMSTREAM)pas, 0L);
		    acmStreamClose((HACMSTREAM)pas, 0L);

		    goto IDriver_App_Exit_Again;
		}
            }

            DebugErr1(fuDebugFlags, "ACM driver handle (%.04Xh) was not released.", pad);

	    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
		continue;
	    } else {
		acmDriverClose((HACMDRIVER)pad, 0L);
	    }

            goto IDriver_App_Exit_Again;
        }

        if ((NULL != htask) && (htask == padid->htask))
        {
            DebugErr1(fuDebugFlags, "ACM driver (%.04Xh) was not removed.", hadid);

            acmDriverRemove(hadid, 0L);

            goto IDriver_App_Exit_Again;
        }
    }


    //
    //
    //
    pag->hadidDestroy = NULL;
    pag->hadDestroy   = NULL;


    if( NULL != htask )
    {
        if( IDriverLockPriority( pag, htask, ACMPRIOLOCK_ISMYLOCK ) )
        {
            IDriverLockPriority( pag, htask, ACMPRIOLOCK_RELEASELOCK );
            DebugErr(fuDebugFlags, "acmApplicationExit: exiting application owns deferred notification lock!");

            //
            //  do NOT do a broadcast of changes during app exit! might
            //  be very bad!
            //
            // !!! IDriverBroadcastNotify();
        }
    }



    //
    //  shrink our heap, down to minimal size.
    //
#ifndef WIN32
{
    UINT                cFree;
    UINT                cHeap;

    if ((cFree = LocalCountFree()) > 8192)
    {
        cHeap = LocalHeapSize() - (cFree - 512);
        LocalShrink(NULL, cHeap);

        DPF(1, "shrinking the heap (%u)", cHeap);
    }
}
#endif

#ifndef WIN32
    DPF(2, "IDriverAppExit(htask=%.04Xh [%s], fNormalExit=%u) END", htask, (LPSTR)szTask, fNormalExit);
#else
    DPF(2, "IDriverAppExit(htask=%.04Xh, fNormalExit=%u) END", htask, fNormalExit);
#endif


    //
    //  the return value is ignored--but return zero..
    //
    return (0L);
} // IDriverAppExit()


//--------------------------------------------------------------------------;
//
//  LRESULT acmApplicationExit
//
//  Description:
//
//
//  Arguments:
//      HTASK htask:
//
//      LPARAM lParam:
//
//  Return (LRESULT):
//
//  History:
//      09/26/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;
#ifndef WIN32
LRESULT ACMAPI acmApplicationExit
(
    HTASK                   htask,
    LPARAM                  lParam
)
{
    LRESULT             lr;

    lr = IDriverAppExit(pagFind(), htask, lParam);

    return (lr);
} // acmApplicationExit()
#endif


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      that the driver is opened, through the DrvOpen API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;
#ifndef WIN32
EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR               dwId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;

    switch (uMsg)
    {
        case DRV_LOAD:
        case DRV_FREE:
        case DRV_OPEN:
        case DRV_CLOSE:
        case DRV_ENABLE:
        case DRV_DISABLE:
            return (1L);

        case DRV_EXITAPPLICATION:
            lr = IDriverAppExit(pagFind(), GetCurrentTask(), lParam1);
            return (lr);

        case DRV_INSTALL:
        case DRV_REMOVE:
            return (DRVCNF_RESTART);
    }

    return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\acmstrm.c ===
/****************************************************************************
 *
 *   acmstrm.c
 *
 *   Copyright (c) 1991-1998 Microsoft Corporation
 *
 *   This module provides the Buffer to Buffer API's
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>

#include "muldiv32.h"

#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "debug.h"



/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | IStreamOpenQuery | Helper fn to do a stream query.
 *
 * @parm LPWAVEFORMATEX | pwfxSrc | Source format.
 *
 * @parm LPWAVEFORMATEX | pwfxDst | Destination format.
 *
 * @parm LPWAVEFILTER  | pwfltr | Filter to apply.
 *
 * @parm DWORD | fdwOpen |
 *
 * @rdesc Returns error number.
 *
 ****************************************************************************/

MMRESULT FNLOCAL IStreamOpenQuery
(
    HACMDRIVER          had,
    LPWAVEFORMATEX      pwfxSrc,
    LPWAVEFORMATEX      pwfxDst,
    LPWAVEFILTER        pwfltr,
    DWORD               fdwOpen
)
{
    ACMDRVSTREAMINSTANCE    adsi;
    MMRESULT                mmr;


    //
    //
    //
    _fmemset(&adsi, 0, sizeof(adsi));

    adsi.cbStruct           = sizeof(adsi);
    adsi.pwfxSrc            = pwfxSrc;
    adsi.pwfxDst            = pwfxDst;
    adsi.pwfltr             = pwfltr;
////adsi.dwCallback         = 0L;
////adsi.dwInstance         = 0L;
    adsi.fdwOpen            = fdwOpen | ACM_STREAMOPENF_QUERY;
////adsi.dwDriverFlags      = 0L;
////adsi.dwDriverInstance   = 0L;
////adsi.has                = NULL;

    EnterHandle(had);
    mmr = (MMRESULT)IDriverMessage(had,
                                   ACMDM_STREAM_OPEN,
                                   (LPARAM)(LPVOID)&adsi,
                                   0L);
    LeaveHandle(had);

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatSuggest | This function asks the Audio Compression Manager
 *      (ACM) or a specified ACM driver to suggest a destination format for
 *      the supplied source format. For example, an application can use this
 *      function to determine one or more valid PCM formats to which a
 *      compressed format can be decompressed.
 *
 *  @parm HACMDRIVER | had | Identifies an optional open instance of a
 *      driver to query for a suggested destination format. If this
 *      argument is NULL, the ACM attempts to find the best driver to suggest
 *      a destination format.
 *
 *  @parm LPWAVEFORMATEX | pwfxSrc | Specifies a pointer to a <t WAVEFORMATEX>
 *      structure that identifies the source format to suggest a destination
 *      format to be used for a conversion.
 *
 *  @parm LPWAVEFORMATEX | pwfxDst | Specifies a pointer to a <t WAVEFORMATEX>
 *      data structure that will receive the suggested destination format
 *      for the <p pwfxSrc> format. Note that based on the <p fdwSuggest>
 *      argument, some members of the structure pointed to by <p pwfxDst>
 *      may require initialization.
 *
 *  @parm DWORD | cbwfxDst | Specifies the size in bytes available for
 *      the destination format. The <f acmMetrics> and <f acmFormatTagDetails>
 *      functions can be used to determine the maximum size required for any
 *      format available for the specified driver (or for all installed ACM
 *      drivers).
 *
 *  @parm DWORD | fdwSuggest | Specifies flags for matching the desired
 *      destination format.
 *
 *      @flag ACM_FORMATSUGGESTF_WFORMATTAG | Specifies that the
 *      <e WAVEFORMATEX.wFormatTag> member of the <p pwfxDst> structure is
 *      valid.  The ACM will query acceptable installed drivers that can
 *      suggest a destination format matching the <e WAVEFORMATEX.wFormatTag>
 *      member or fail.
 *
 *      @flag ACM_FORMATSUGGESTF_NCHANNELS | Specifies that the
 *      <e WAVEFORMATEX.nChannels> member of the <p pwfxDst> structure is
 *      valid.  The ACM will query acceptable installed drivers that can
 *      suggest a destination format matching the <e WAVEFORMATEX.nChannels>
 *      member or fail.
 *
 *      @flag ACM_FORMATSUGGESTF_NSAMPLESPERSEC | Specifies that the
 *      <e WAVEFORMATEX.nSamplesPerSec> member of the <p pwfxDst> structure
 *      is valid.  The ACM will query acceptable installed drivers that can
 *      suggest a destination format matching the <e WAVEFORMATEX.nSamplesPerSec>
 *      member or fail.
 *
 *      @flag ACM_FORMATSUGGESTF_WBITSPERSAMPLE | Specifies that the
 *      <e WAVEFORMATEX.wBitsPerSample> member of the <p pwfxDst> structure
 *      is valid.  The ACM will query acceptable installed drivers that can
 *      suggest a destination format matching the <e WAVEFORMATEX.wBitsPerSample>
 *      member or fail.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *  @xref <f acmDriverOpen> <f acmFormatTagDetails> <f acmMetrics>
 *      <f acmFormatEnum>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFormatSuggest
(
    HACMDRIVER              had,
    LPWAVEFORMATEX          pwfxSrc,
    LPWAVEFORMATEX          pwfxDst,
    DWORD                   cbwfxDst,
    DWORD                   fdwSuggest
)
{
    PACMGARB		pag;
    MMRESULT            mmr;
    HACMDRIVERID        hadid;
    PACMDRIVERID        padid;
    UINT                i,j;
    BOOL                fFound;
    ACMDRVFORMATSUGGEST adfs;
    DWORD               cbwfxDstRqd;
    ACMFORMATTAGDETAILS aftd;

    V_DFLAGS(fdwSuggest, ACM_FORMATSUGGESTF_VALID, acmFormatSuggest, MMSYSERR_INVALFLAG);
    V_RWAVEFORMAT(pwfxSrc, MMSYSERR_INVALPARAM);
    V_WPOINTER(pwfxDst, cbwfxDst, MMSYSERR_INVALPARAM);

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFormatSuggest: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //	if the source format is PCM, and we aren't restricting the destination
    //	format, and we're not requesting a specific driver, then first try to
    //	suggest a PCM format.  This is kinda like giving the PCM converter
    //	priority for this case.
    //
    if ( (NULL == had) &&
	 (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag) &&
	 (0 == (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)) )
    {
	//
	//  I'll be a bit paranoid and restore pwfxDst->wFormatTag
	//  if this fails.
	//
	WORD wDstFormatTagSave;

	wDstFormatTagSave = pwfxDst->wFormatTag;
	pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
	mmr = acmFormatSuggest(NULL, pwfxSrc, pwfxDst, cbwfxDst, fdwSuggest | ACM_FORMATSUGGESTF_WFORMATTAG);
	if (MMSYSERR_NOERROR == mmr)
	{
	    return (MMSYSERR_NOERROR);
	}
	pwfxDst->wFormatTag = wDstFormatTagSave;
    }
	

    //
    //
    //
    if (0 == (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest))
    {
        mmr = IMetricsMaxSizeFormat( pag, had, &cbwfxDstRqd );
        if (MMSYSERR_NOERROR != mmr)
        {
            return (mmr);
        }
    }
    else
    {
        _fmemset(&aftd, 0, sizeof(aftd));
        aftd.cbStruct    = sizeof(aftd);
        aftd.dwFormatTag = pwfxDst->wFormatTag;

        mmr = acmFormatTagDetails(had,
                                  &aftd,
                                  ACM_FORMATTAGDETAILSF_FORMATTAG);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (mmr);
        }

        cbwfxDstRqd = aftd.cbFormatSize;
    }

    if (cbwfxDst < cbwfxDstRqd)
    {
        DebugErr1(DBF_ERROR, "acmFormatSuggest: destination buffer must be at least %lu bytes.", cbwfxDstRqd);
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    adfs.cbStruct   = sizeof(adfs);
    adfs.fdwSuggest = fdwSuggest;
    adfs.pwfxSrc    = pwfxSrc;
    adfs.cbwfxSrc   = SIZEOF_WAVEFORMATEX(pwfxSrc);
    adfs.pwfxDst    = pwfxDst;
    adfs.cbwfxDst   = cbwfxDst;

    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

        //
        //  we were given a driver handle
        //

        EnterHandle(had);
        mmr = (MMRESULT)IDriverMessage(had,
                                       ACMDM_FORMAT_SUGGEST,
                                       (LPARAM)(LPVOID)&adfs,
                                       0L);
        LeaveHandle(had);

        return (mmr);
    }


    //
    //  if we are being asked to 'suggest anything from any driver'
    //  (that is, (0L == fdwSuggest) and (NULL == had)) AND the source format
    //  is PCM, then simply return the same format as the source... this
    //  keeps seemingly random destination suggestions for a source of PCM
    //  from popping up..
    //
    //  note that this is true even if ALL drivers are disabled!
    //
    if ((0L == fdwSuggest) && (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag))
    {
        _fmemcpy(pwfxDst, pwfxSrc, sizeof(PCMWAVEFORMAT));
        return (MMSYSERR_NOERROR);
    }



    //
    //  find a driver to match the formats
    //
    //
    mmr  = MMSYSERR_NODRIVER;
    hadid = NULL;

    ENTER_LIST_SHARED;

    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
    {
        padid = (PACMDRIVERID)hadid;
        fFound = FALSE;
        for(i = 0; i < padid->cFormatTags; i++ ) {
            //
            //  for every FormatTag in the driver
            //
            if (pwfxSrc->wFormatTag == padid->paFormatTagCache[i].dwFormatTag){
                //
                //  This driver supports the source format.
                //
                if( fdwSuggest & ACM_FORMATSUGGESTF_WFORMATTAG ) {
                    //
                    //  See if this driver supports the desired dest format.
                    //
                    for(j = 0; j < padid->cFormatTags; j++ ) {
                        //
                        //  for every FormatTag in the driver
                        //
                        if (pwfxDst->wFormatTag ==
                                padid->paFormatTagCache[j].dwFormatTag){
                            //
                            //  This driver supports the dest format.
                            //
                            fFound = TRUE;
                            break;
                        }
                    }
                } else {
                    fFound = TRUE;
                }
                break;
            }
        }

        if( fFound ) {
            EnterHandle(hadid);
            mmr = (MMRESULT)IDriverMessageId(hadid,
                                            ACMDM_FORMAT_SUGGEST,
                                            (LPARAM)(LPVOID)&adfs,
                                            0L );
            LeaveHandle(hadid);
            if (MMSYSERR_NOERROR == mmr)
                break;
        }
    }

    LEAVE_LIST_SHARED;

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api void CALLBACK | acmStreamConvertCallback | The <f acmStreamConvertCallback>
 *      function is a placeholder for an application-supplied function name and refers to the callback
 *      function used with an asynchronous Audio  Compression Manager (ACM) conversion stream.
 *      The actual name must be exported by including it in an EXPORTS statement
 *      in the module-definition file for the DLL..
 *
 *  @parm HACMSTREAM | has | Specifies a handle to the ACM conversion stream
 *      associated with the callback.
 *
 *  @parm UINT | uMsg | Specifies an ACM conversion stream message.
 *
 *      @flag MM_ACM_OPEN | Specifies that the ACM has successfully opened
 *      the conversion stream identified by <p has>.
 *
 *      @flag MM_ACM_CLOSE | Specifies that the ACM has successfully closed
 *      the conversion stream identified by <p has>. The <t HACMSTREAM>
 *      handle (<p has>) is no longer valid after receiving this message.
 *
 *      @flag MM_ACM_DONE | Specifies that the ACM has successfully converted
 *      the buffer identified by <p lParam1> (which is a pointer to the
 *      <t ACMSTREAMHEADER> structure) for the stream handle specified by <p has>.
 *
 *  @parm DWORD | dwInstance | Specifies the user-instance data given
 *      as the <p dwInstance> argument of <f acmStreamOpen>.
 *
 *  @parm LPARAM | lParam1 | Specifies a parameter for the message.
 *
 *  @parm LPARAM | lParam2 | Specifies a parameter for the message.
 *
 *  @comm If the callback is a function (specified by the CALLBACK_FUNCTION
 *	flag in <p fdwOpen> of <f acmStreamOpen>) then the callback may be
 *	accessed at interrupt time.  Therefore the callback must reside in a
 *	DLL and its code segment must be specified as FIXED in the
 *	module-definition file for the DLL. Any data that the callback
 *      accesses must be in a FIXED data segment as well. The callback cannot
 *      make any system calls except for <f PostMessage>, <f PostAppMessage>,
 *      <f timeGetSystemTime>, <f timeGetTime>, <f timeSetEvent>,
 *      <f timeKillEvent>, <f midiOutShortMsg>, <f midiOutLongMsg>, and
 *      <f OutputDebugStr>.
 *
 *  @xref <f acmStreamOpen> <f acmStreamConvert> <f acmStreamClose>
 *
 ***************************************************************************/


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamOpen | The acmStreamOpen function opens an Audio Compression
 *      Manager (ACM) conversion stream. Conversion streams are used to convert data from
 *      one specified audio format to another.
 *
 *  @parm LPHACMSTREAM | phas | Specifies a pointer to a <t HACMSTREAM>
 *      handle that will receive the new stream handle that can be used to
 *      perform conversions. Use this handle to identify the stream
 *      when calling other ACM stream conversion functions. This parameter
 *      should be NULL if the ACM_STREAMOPENF_QUERY flag is specified.
 *
 *  @parm HACMDRIVER | had | Specifies an optional handle to an ACM driver.
 *      If specified, this handle identifies a specific driver to be used
 *      for a conversion stream. If this argument is NULL, then all suitable
 *      installed ACM drivers are queried until a match is found.
 *
 *  @parm LPWAVEFORMATEX | pwfxSrc | Specifies a pointer to a <t WAVEFORMATEX>
 *      structure that identifies the desired source format for the
 *      conversion.
 *
 *  @parm LPWAVEFORMATEX | pwfxDst | Specifies a pointer to a <t WAVEFORMATEX>
 *      structure that identifies the desired destination format for the
 *      conversion.
 *
 *  @parm LPWAVEFILTER | pwfltr | Specifies a pointer to a <t WAVEFILTER>
 *      structure that identifies the desired filtering operation to perform
 *      on the conversion stream. This argument can be NULL if no filtering
 *      operation is desired. If a filter is specified, the source
 *      (<p pwfxSrc>) and destination (<p pwfxDst>) formats must be the same.
 *
 *  @parm DWORD | dwCallback | Specifies the address of a callback function
 *      or a handle to a window called after each buffer is converted. A
 *      callback will only be called if the conversion stream is opened with
 *      the ACM_STREAMOPENF_ASYNC flag. If the conversion stream is opened
 *	without the ACM_STREAMOPENF_ASYNC flag, then this parameter should
 *	be set to zero.
 *
 *  @parm DWORD | dwInstance | Specifies user-instance data passed on to the
 *      callback specified by <p dwCallback>. This argument is not used with
 *      window callbacks. If the conversion stream is opened without the
 *	ACM_STREAMOPENF_ASYNC flag, then this parameter should be set to zero.
 *
 *  @parm DWORD | fdwOpen | Specifies flags for opening the conversion stream.
 *
 *      @flag ACM_STREAMOPENF_QUERY | Specifies that the ACM will be queried
 *      to determine whether it supports the given conversion. A conversion
 *      stream will not be opened and no <t HACMSTREAM> handle will be
 *      returned.
 *
 *      @flag ACM_STREAMOPENF_NONREALTIME | Specifies that the ACM will not
 *      consider time constraints when converting the data. By default, the
 *      driver will attempt to convert the data in real time. Note that for
 *      some formats, specifying this flag might improve the audio quality
 *      or other characteristics.
 *
 *      @flag ACM_STREAMOPENF_ASYNC | Specifies that conversion of the stream should
 *      be performed asynchronously. If this flag is specified, the application
 *      can use a callback to be notified on open and close of the conversion
 *      stream, and after each buffer is converted. In addition to using a
 *      callback, an application can examine the <e ACMSTREAMHEADER.fdwStatus>
 *      of the <t ACMSTREAMHEADER> structure for the ACMSTREAMHEADER_STATUSF_DONE
 *      flag.
 *
 *      @flag CALLBACK_WINDOW | Specifies that <p dwCallback> is assumed to
 *      be a window handle.
 *
 *      @flag CALLBACK_FUNCTION | Specifies that <p dwCallback> is assumed to
 *      be a callback procedure address. The function prototype must conform
 *      to the <f acmStreamConvertCallback> convention.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The requested operation cannot be performed.
 *
 *  @comm Note that if an ACM driver cannot perform real-time conversions,
 *      and the ACM_STREAMOPENF_NONREALTIME flag is not specified for
 *      the <p fdwOpen> argument, the open will fail returning an
 *      ACMERR_NOTPOSSIBLE error code. An application can use the
 *      ACM_STREAMOPENF_QUERY flag to determine if real-time conversions
 *      are supported for the input arguments.
 *
 *	If a window is chosen to receive callback information, the
 *      following messages are sent to the window procedure function to
 *      indicate the progress of the conversion stream: <m MM_ACM_OPEN>,
 *      <m MM_ACM_CLOSE>, and <m MM_ACM_DONE>. The <p wParam>  parameter identifies
 *      the <t HACMSTREAM> handle. The <p lParam>  parameter identifies the
 *      <t ACMSTREAMHEADER> structure for <m MM_ACM_DONE>, but is not used
 *      for <m MM_ACM_OPEN> and <m MM_ACM_CLOSE>.
 *
 *      If a function is chosen to receive callback information, the
 *      following messages are sent to the function to indicate the progress
 *      of waveform output: <m MM_ACM_OPEN>, <m MM_ACM_CLOSE>, and
 *      <m MM_ACM_DONE>. The callback function must reside in a DLL. You do
 *      not need to use <f MakeProcInstance> to get a procedure-instance
 *      address for the callback function.
 *
 *  @xref <f acmStreamClose> <f acmStreamConvert> <f acmDriverOpen>
 *      <f acmFormatSuggest> <f acmStreamConvertCallback>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamOpen
(
    LPHACMSTREAM            phas,
    HACMDRIVER              had,
    LPWAVEFORMATEX          pwfxSrc,
    LPWAVEFORMATEX          pwfxDst,
    LPWAVEFILTER            pwfltr,
    DWORD_PTR               dwCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwOpen
)
{
    PACMGARB		pag;
    PACMSTREAM          pas;
    PACMDRIVERID        padid;
    HACMDRIVERID        hadid;
    MMRESULT            mmr;
    UINT                cbas;
    DWORD               fdwSupport;
    UINT                cbwfxSrc;
    UINT                cbwfxDst;
    UINT                cbwfltr;
    DWORD               fdwStream;
    BOOL                fAsync;
    BOOL                fQuery;
    UINT                uFormatTag;
    HANDLE		hEvent;


    if (NULL != phas)
    {
        V_WPOINTER(phas, sizeof(HACMSTREAM), MMSYSERR_INVALPARAM);
        *phas = NULL;
    }

    V_DFLAGS(fdwOpen, ACM_STREAMOPENF_VALID, acmStreamOpen, MMSYSERR_INVALFLAG);

    fQuery = (0 != (fdwOpen & ACM_STREAMOPENF_QUERY));

    if (fQuery)
    {
        //
        //  ignore what caller gave us--set to NULL so we will FAULT if
        //  someone screws up this code
        //
        phas = NULL;
    }
    else
    {
        //
        //  cause a rip if NULL pointer..
        //
        if (NULL == phas)
        {
            V_WPOINTER(phas, sizeof(HACMSTREAM), MMSYSERR_INVALPARAM);
        }
    }

    V_RWAVEFORMAT(pwfxSrc, MMSYSERR_INVALPARAM);
    V_RWAVEFORMAT(pwfxDst, MMSYSERR_INVALPARAM);

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmStreamOpen: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    
    //
    //
    //
    hEvent = NULL;
    fAsync = (0 != (fdwOpen & ACM_STREAMOPENF_ASYNC));
    if (!fAsync)
    {
        if ((0L != dwCallback) || (0L != dwInstance))
        {
            DebugErr(DBF_ERROR, "acmStreamOpen: dwCallback and dwInstance must be zero for sync streams.");
            return (MMSYSERR_INVALPARAM);
        }
    }

    V_DCALLBACK(dwCallback, HIWORD(fdwOpen), MMSYSERR_INVALPARAM);


    fdwSupport = fAsync ? ACMDRIVERDETAILS_SUPPORTF_ASYNC : 0;

    hadid = NULL;

    //
    //
    //
    fdwStream  = (NULL == had) ? 0L : ACMSTREAM_STREAMF_USERSUPPLIEDDRIVER;


    //
    //  if a filter is given, then check that source and destination formats
    //  are the same...
    //
    if (NULL != pwfltr)
    {
        V_RWAVEFILTER(pwfltr, MMSYSERR_INVALPARAM);

        //
        //  filters do not allow different geometries between source and
        //  destination formats--verify that they are _exactly_ the same.
        //  this includes avg bytes per second!
        //
        //  however, only validate up to wBitsPerSample (the size of a
        //  PCM format header). cbSize can be verified (if necessary) by
        //  the filter driver if it supports non-PCM filtering.
        //
        if (0 != _fmemcmp(pwfxSrc, pwfxDst, sizeof(PCMWAVEFORMAT)))
            return (ACMERR_NOTPOSSIBLE);

        fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_FILTER;

        uFormatTag = pwfxSrc->wFormatTag;
    }
    else
    {
        if (pwfxSrc->wFormatTag == pwfxDst->wFormatTag)
        {
            fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_CONVERTER;

            uFormatTag = pwfxSrc->wFormatTag;
        }
        else
        {
            fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_CODEC;

            //
            //  choose the most common case in an attempt to reduce the
            //  number of driver opens we do--note that even if one of
            //  the tags is not PCM everything will still work..
            //
            if (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag)
            {
                uFormatTag = pwfxDst->wFormatTag;
            }
            else
            {
                uFormatTag = pwfxSrc->wFormatTag;
            }
        }
    }



    DPF(2, "acmStreamOpen(%s): Tag=%u, %lu Hz, %u Bit, %u Channel(s)",
            fQuery ? (LPSTR)"query" : (LPSTR)"real",
            pwfxSrc->wFormatTag,
            pwfxSrc->nSamplesPerSec,
            pwfxSrc->wBitsPerSample,
            pwfxSrc->nChannels);

    DPF(2, "               To: Tag=%u, %lu Hz, %u Bit, %u Channel(s)",
            pwfxDst->wFormatTag,
            pwfxDst->nSamplesPerSec,
            pwfxDst->wBitsPerSample,
            pwfxDst->nChannels);

    //
    //
    //
    if (NULL != had)
    {
        PACMDRIVER      pad;

        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

        pad   = (PACMDRIVER)had;
        padid = (PACMDRIVERID)pad->hadid;

        if (fdwSupport != (fdwSupport & padid->fdwSupport))
        {
            return (ACMERR_NOTPOSSIBLE);
        }

        if (fQuery)
        {
            EnterHandle(had);
            mmr = IStreamOpenQuery(had, pwfxSrc, pwfxDst, pwfltr, fdwOpen);
#if defined(WIN32) && defined(WIN4)
	    //
	    //	We only support async conversion to sync conversion
	    //	on the 32-bit side.
	    //
	    if (MMSYSERR_NOERROR != mmr)
	    {
		//
		//  If this driver supports async conversions, and we're
		//  opening for sync conversion, then attempt to open
		//  async and the acm will handle making the async conversion
		//  look like a sync conversion.
		//
		if ( !fAsync &&
		     (ACMDRIVERDETAILS_SUPPORTF_ASYNC & padid->fdwSupport) )
		{
		    mmr = IStreamOpenQuery(had, pwfxSrc, pwfxDst, pwfltr, fdwOpen | ACM_STREAMOPENF_ASYNC);
		}
	    }
#endif
            LeaveHandle(had);
            if (MMSYSERR_NOERROR != mmr)
                return (mmr);
        }
    }

    //
    //  we need to find a driver to match the formats--so enumerate
    //  all drivers until we find one that works. if none can be found,
    //  then fail..
    //
    else
    {
        hadid = NULL;

        ENTER_LIST_SHARED;

        while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
        {
            ACMFORMATTAGDETAILS aftd;

            //
            //  if this driver does not support the basic function we
            //  need, then don't even attempt to open it..
            //
            padid = (PACMDRIVERID)hadid;

            if (fdwSupport != (fdwSupport & padid->fdwSupport))
                continue;

            //
            //
            //
            aftd.cbStruct    = sizeof(aftd);
            aftd.dwFormatTag = uFormatTag;
            aftd.fdwSupport  = 0L;

            mmr = acmFormatTagDetails((HACMDRIVER)hadid,
                                      &aftd,
                                      ACM_FORMATTAGDETAILSF_FORMATTAG);
            if (MMSYSERR_NOERROR != mmr)
                continue;

            if (fdwSupport != (fdwSupport & aftd.fdwSupport))
                continue;


            //
            //
            //
            //
            EnterHandle(hadid);
            mmr = IDriverOpen(&had, hadid, 0L);
            LeaveHandle(hadid);
            if (MMSYSERR_NOERROR != mmr)
                continue;

            EnterHandle(had);
            mmr = IStreamOpenQuery(had, pwfxSrc, pwfxDst, pwfltr, fdwOpen);
#if defined(WIN32) && defined(WIN4)
	    //
	    //	We only support async conversion to sync conversion
	    //	on the 32-bit side.
	    //
	    if (MMSYSERR_NOERROR != mmr)
	    {
		//
		//  If this driver supports async conversions, and we're
		//  opening for sync conversion, then attempt to open
		//  async and the acm will handle making the async conversion
		//  look like a sync conversion.
		//
		if ( !fAsync &&
		     (ACMDRIVERDETAILS_SUPPORTF_ASYNC & padid->fdwSupport) )
		{
		    mmr = IStreamOpenQuery(had, pwfxSrc, pwfxDst, pwfltr, fdwOpen | ACM_STREAMOPENF_ASYNC);
		}
	    }
#endif
            LeaveHandle(had);

            if (MMSYSERR_NOERROR == mmr)
                break;

            EnterHandle(hadid);
            IDriverClose(had, 0L);
            LeaveHandle(hadid);
            had = NULL;
        }

        LEAVE_LIST_SHARED;

        if (NULL == had)
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  if just being queried, then we succeeded this far--so succeed
    //  the call...
    //
    if (fQuery)
    {
        mmr = MMSYSERR_NOERROR;
        goto Stream_Open_Exit_Error;
    }


    //
    //  alloc an ACMSTREAM structure--we need to alloc enough space for
    //  both the source and destination format headers.
    //
    //  size of one format is sizeof(WAVEFORMATEX) + size of extra format
    //  (wfx->cbSize) informatation. for PCM, the size is simply the
    //  sizeof(PCMWAVEFORMAT)
    //
    cbwfxSrc = SIZEOF_WAVEFORMATEX(pwfxSrc);
    cbwfxDst = SIZEOF_WAVEFORMATEX(pwfxDst);
    cbwfltr  = (NULL == pwfltr) ? 0 : (UINT)pwfltr->cbStruct;


    //
    //  allocate stream instance structure
    //
    cbas = sizeof(ACMSTREAM) + cbwfxSrc + cbwfxDst + (UINT)cbwfltr;
    pas  = (PACMSTREAM)NewHandle(cbas);
    if (NULL == pas)
    {
        DPF(0, "!acmStreamOpen: cannot allocate ACMSTREAM--local heap full!");

        mmr = MMSYSERR_NOMEM;
        goto Stream_Open_Exit_Error;
    }


    //
    //  initialize the ACMSTREAM structure
    //
    //
    pas->uHandleType            = TYPE_HACMSTREAM;
////pas->pasNext                = NULL;
    pas->fdwStream              = fdwStream;
    pas->had                    = had;
    pas->adsi.cbStruct          = sizeof(pas->adsi);
    pas->adsi.pwfxSrc           = (LPWAVEFORMATEX)((PBYTE)(pas + 1));
    pas->adsi.pwfxDst           = (LPWAVEFORMATEX)((PBYTE)(pas + 1) + cbwfxSrc);

    if (NULL != pwfltr)
    {
        pas->adsi.pwfltr        = (LPWAVEFILTER)((PBYTE)(pas + 1) + cbwfxSrc + cbwfxDst);
        _fmemcpy(pas->adsi.pwfltr, pwfltr, (UINT)cbwfltr);
    }

    pas->adsi.dwCallback        = dwCallback;
    pas->adsi.dwInstance        = dwInstance;
    pas->adsi.fdwOpen           = fdwOpen;
////pas->adsi.dwDriverFlags     = 0L;
////pas->adsi.dwDriverInstance  = 0L;
    pas->adsi.has               = (HACMSTREAM)pas;

    _fmemcpy(pas->adsi.pwfxSrc, pwfxSrc, cbwfxSrc);
    _fmemcpy(pas->adsi.pwfxDst, pwfxDst, cbwfxDst);


    //
    //
    //
    //
    //
    EnterHandle(had);
    mmr = (MMRESULT)IDriverMessage(had,
                                   ACMDM_STREAM_OPEN,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   0L);

#if defined(WIN32) && defined(WIN4)
    if ( (MMSYSERR_NOERROR != mmr) &&
	 (!fAsync) &&
	 (padid->fdwSupport & ACMDRIVERDETAILS_SUPPORTF_ASYNC) )
    {
	//
	//  Try making async look like sync
	//
	DPF(2, "acmStreamOpen: Trying async to sync");
	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (NULL != hEvent)
	{
	    pas->fdwStream |= ACMSTREAM_STREAMF_ASYNCTOSYNC;
	    pas->adsi.dwCallback = (DWORD)(UINT)hEvent;
	    pas->adsi.fdwOpen &= ~CALLBACK_TYPEMASK;
	    pas->adsi.fdwOpen |= CALLBACK_EVENT;
	    pas->adsi.fdwOpen |= ACM_STREAMOPENF_ASYNC;
	    mmr = (MMRESULT)IDriverMessage(had,
					   ACMDM_STREAM_OPEN,
					   (LPARAM)(LPVOID)&pas->adsi,
					   0L);
	    if (MMSYSERR_NOERROR == mmr)
	    {
		DPF(2, "acmStreamOpen: Succeeded async to sync open, waiting for CALLBACK_EVENT");
		WaitForSingleObject(hEvent, INFINITE);
	    }
	}
	else
	{
	    DPF(0, "acmStreamOpen: CreateEvent failed, can't make async codec look like sync codec");
	}
    }
#endif
    LeaveHandle(had);

    if (MMSYSERR_NOERROR == mmr)
    {
        PACMDRIVER      pad;

        pad = (PACMDRIVER)had;

        pas->pasNext  = pad->pasFirst;
        pad->pasFirst = pas;


        //
        //  succeed!
        //
        *phas = (HACMSTREAM)pas;

        return (MMSYSERR_NOERROR);
    }


    //
    //  we are failing, so free the instance data that we alloc'd!
    //
    pas->uHandleType = TYPE_HACMNOTVALID;
    DeleteHandle((HLOCAL)pas);


Stream_Open_Exit_Error:

    //
    //	Close the event handle if it was created
    //
    if (hEvent)
    {
	CloseHandle(hEvent);
    }

    //
    //  only close driver if _we_ opened it...
    //
    if (0 == (fdwStream & ACMSTREAM_STREAMF_USERSUPPLIEDDRIVER))
    {
#ifdef WIN32
        hadid = ((PACMDRIVER)had)->hadid;
#endif
        EnterHandle(hadid);
        IDriverClose(had, 0L);
        LeaveHandle(hadid);
    }

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamClose | The acmStreamClose function closes a previously opened Audio
 *      Compression Manager (ACM) conversion stream. If the function is
 *      successful, the handle is invalidated.
 *
 *  @parm HACMSTREAM | has | Identifies the open conversion stream to be
 *      closed.
 *
 *  @parm DWORD | fdwClose | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_BUSY | The conversion stream cannot be closed because
 *      an asynchronous conversion is still in progress.
 *
 *  @xref <f acmStreamOpen> <f acmStreamReset>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamClose
(
    HACMSTREAM          has,
    DWORD               fdwClose
)
{
    MMRESULT        mmr;
    PACMSTREAM      pas;
    PACMDRIVER	    pad;
    PACMDRIVERID    padid;
    PACMGARB	    pag;
    HANDLE	    hEvent;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwClose, ACM_STREAMCLOSEF_VALID, acmStreamClose, MMSYSERR_INVALFLAG);

    pas	    = (PACMSTREAM)has;
    pad	    = (PACMDRIVER)pas->had;
    padid   = (PACMDRIVERID)pad->hadid;
    pag	    = padid->pag;

    //
    //	Verify the handle is for this process
    //
    if (pag != pagFind())
    {
	DebugErr(DBF_ERROR, "acmStreamClose: handle not opened from calling process!");
	return (MMSYSERR_INVALHANDLE);
    }

    if (0 != pas->cPrepared)
    {
        if (pag->hadDestroy != pas->had)
        {
	    DebugErr1(DBF_ERROR, "acmStreamClose: stream contains %u prepared headers!", pas->cPrepared);
            return (MMSYSERR_INVALPARAM);
        }

        DebugErr1(DBF_WARNING, "acmStreamClose: stream contains %u prepared headers--forcing close", pas->cPrepared);
        pas->cPrepared = 0;
    }


    //
    //	Callback event if we are converting async conversion to sync conversion
    //
    hEvent = (pas->fdwStream & ACMSTREAM_STREAMF_ASYNCTOSYNC) ? (HANDLE)pas->adsi.dwCallback : NULL;


    //
    //  tell driver that conversion stream is terminating
    //
    //

    EnterHandle(pas->had);
#ifdef RDEBUG
    if ( (hEvent) && (WAIT_OBJECT_0 == WaitForSingleObject(hEvent, 0)) )
    {
	//
	//  The event is already signaled!  Bad bad!
	//
	DebugErr(DBF_ERROR, "acmStreamClose: asynchronous codec called callback unexpectedly");
    }
#endif
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_CLOSE,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   fdwClose);
    if ( (hEvent) && (MMSYSERR_NOERROR == mmr) ) {
	DPF(4, "acmStreamClose: waiting for CALLBACK_EVENT");
	WaitForSingleObject(hEvent, INFINITE);
    }
    LeaveHandle(pas->had);

    if ((MMSYSERR_NOERROR == mmr) || (pag->hadDestroy == pas->had))
    {
        if (MMSYSERR_NOERROR != mmr)
        {
            DebugErr(DBF_WARNING, "acmStreamClose: forcing close of stream handle!");
        }

	//
	//  Close the event handle
	//
	if (hEvent) {
	    CloseHandle(hEvent);
	}
	
        //
        //  remove the stream handle from the linked list and free its memory
        //
        pad = (PACMDRIVER)pas->had;

        EnterHandle(pad);
        if (pas == pad->pasFirst)
        {
            pad->pasFirst = pas->pasNext;

            //
            //  if this was the last open stream on this driver, then close
            //  the driver instance also...
            //
            if (NULL == pad->pasFirst)
            {
		LeaveHandle(pad);
                if (0 == (pas->fdwStream & ACMSTREAM_STREAMF_USERSUPPLIEDDRIVER))
                {
                    IDriverClose(pas->had, 0L);
                }
            }
	    else
	    {
		LeaveHandle(pad);
	    }
        }
        else
        {
            PACMSTREAM  pasCur;

            //
            //
            //
            for (pasCur = pad->pasFirst;
                (NULL != pasCur) && (pas != pasCur->pasNext);
                pasCur = pasCur->pasNext)
                ;

            if (NULL == pasCur)
            {
                DPF(0, "!acmStreamClose(%.04Xh): stream handle not in list!!!", pas);
                LeaveHandle(pad);
                return (MMSYSERR_INVALHANDLE);
            }

            pasCur->pasNext = pas->pasNext;
	    
	    LeaveHandle(pad);
        }

        //
        //  finally free the stream handle
        //
        pas = (PACMSTREAM)has;
        pas->uHandleType = TYPE_HACMNOTVALID;
        DeleteHandle((HLOCAL)has);
    }

    return (mmr);
}




/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamMessage | This function sends a user-defined
 *      message to a given Audio Compression Manager (ACM) stream instance.
 *
 *  @parm HACMSTREAM | has | Specifies the conversion stream.
 *
 *
 *  @parm UINT | uMsg | Specifies the message that the ACM stream must
 *      process. This message must be in the <m ACMDM_USER> message range
 *      (above or equal to <m ACMDM_USER> and less than
 *      <m ACMDM_RESERVED_LOW>). The exception to this restriction is
 *      the <m ACMDM_STREAM_UPDATE> message.
 *
 *  @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 *  @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 *  @rdesc The return value is specific to the user-defined ACM driver
 *      message <p uMsg> sent. However, the following return values are
 *      possible:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | <p uMsg> is not in the ACMDM_USER range.
 *
 *      @flag MMSYSERR_NOTSUPPORTED | The ACM driver did not process the
 *      message.
 *
 ***************************************************************************/
MMRESULT ACMAPI acmStreamMessage
(
    HACMSTREAM              has,
    UINT                    uMsg, 
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    MMRESULT		mmr;
    PACMSTREAM		pas;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);

    pas = (PACMSTREAM)has;


    //
    //  do not allow non-user range messages through!
    //
    if ( ((uMsg < ACMDM_USER) || (uMsg >= ACMDM_RESERVED_LOW)) &&
	 (uMsg != ACMDM_STREAM_UPDATE) )
    {
	DebugErr(DBF_ERROR, "acmStreamMessage: non-user range messages are not allowed.");
	return (MMSYSERR_INVALPARAM);
    }
    
    EnterHandle(pas);
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   uMsg,
				   lParam1,
				   lParam2 );
    LeaveHandle(pas);

    return (mmr);
}




/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamReset | The acmStreamReset function stops conversions
 *      for a given Audio Compression Manager (ACM) stream. All pending
 *      buffers are marked as done and returned to the application.
 *
 *  @parm HACMSTREAM | has | Specifies the conversion stream.
 *
 *  @parm DWORD | fdwReset | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *  @comm Resetting an ACM conversion stream is only necessary to reset
 *      asynchronous conversion streams. However, resetting a synchronous
 *      conversion stream will succeed, but no action will be taken.
 *
 *  @xref <f acmStreamConvert> <f acmStreamClose>
 *
 ***************************************************************************/
MMRESULT ACMAPI acmStreamReset
(
    HACMSTREAM          has,
    DWORD               fdwReset
)
{
    MMRESULT        mmr;
    PACMSTREAM      pas;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwReset, ACM_STREAMRESETF_VALID, acmStreamReset, MMSYSERR_INVALFLAG);

    pas = (PACMSTREAM)has;

    //
    //  if the stream was not opened as async, then just succeed the reset
    //  call--it only makes sense with async streams...
    //
    if (0 == (ACM_STREAMOPENF_ASYNC & pas->adsi.fdwOpen))
    {
        return (MMSYSERR_NOERROR);
    }

    EnterHandle(pas);
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_RESET,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   fdwReset);
    LeaveHandle(pas);

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamSize | The acmStreamSize function returns a recommended size for a
 *      source or destination buffer on an Audio Compression Manager (ACM)
 *      stream.
 *
 *  @parm HACMSTREAM | has | Specifies the conversion stream.
 *
 *  @parm DWORD | cbInput | Specifies the size in bytes of either the source
 *      or destination buffer. The <p fdwSize> flags specify what the
 *      input argument defines. This argument must be non-zero.
 *
 *  @parm LPDWORD | pdwOutputBytes | Specifies a pointer to a <t DWORD>
 *      that contains the size in bytes of the source or destination buffer.
 *      The <p fdwSize> flags specify what the output argument defines.
 *      If the <f acmStreamSize> function succeeds, this location will
 *      always be filled with a non-zero value.
 *
 *  @parm DWORD | fdwSize | Specifies flags for the stream-size query.
 *
 *      @flag ACM_STREAMSIZEF_SOURCE | Indicates that <p cbInput> contains
 *      the size of the source buffer. The <p pdwOutputBytes> argument will
 *      receive the recommended destination buffer size in bytes.
 *
 *      @flag ACM_STREAMSIZEF_DESTINATION | Indicates that <p cbInput>
 *      contains the size of the destination buffer. The <p pdwOutputBytes>
 *      argument will receive the recommended source buffer size in bytes.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The requested operation cannot be performed.
 *
 *  @comm An application can use the <f acmStreamSize> function to determine
 *      suggested buffer sizes for either source or destination buffers.
 *      The buffer sizes returned might be only an estimation of the
 *      actual sizes required for conversion. Because actual conversion
 *      sizes cannot always be determined without performing the conversion,
 *      the sizes returned will usually be overestimated.
 *
 *      In the event of an error, the location pointed to by
 *      <p pdwOutputBytes> will receive zero. This assumes that the pointer
 *      specified by <p pdwOutputBytes> is valid.
 *
 *  @xref <f acmStreamPrepareHeader> <f acmStreamConvert>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamSize
(
    HACMSTREAM          has,
    DWORD               cbInput,
    LPDWORD             pdwOutputBytes,
    DWORD               fdwSize
)
{
    MMRESULT            mmr;
    PACMSTREAM          pas;
    ACMDRVSTREAMSIZE    adss;

    V_WPOINTER(pdwOutputBytes, sizeof(DWORD), MMSYSERR_INVALPARAM);

    *pdwOutputBytes = 0L;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwSize, ACM_STREAMSIZEF_VALID, acmStreamSize, MMSYSERR_INVALFLAG);

    if (0L == cbInput)
    {
        DebugErr(DBF_ERROR, "acmStreamSize: input size cannot be zero.");
        return (MMSYSERR_INVALPARAM);
    }

    pas = (PACMSTREAM)has;

    adss.cbStruct = sizeof(adss);
    adss.fdwSize  = fdwSize;

    switch (ACM_STREAMSIZEF_QUERYMASK & fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            adss.cbSrcLength = cbInput;
            adss.cbDstLength = 0L;
            break;

        case ACM_STREAMSIZEF_DESTINATION:
            adss.cbSrcLength = 0L;
            adss.cbDstLength = cbInput;
            break;

        default:
            DebugErr(DBF_WARNING, "acmStreamSize: unknown query type requested.");
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //
    //
    //

    EnterHandle(pas);
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_SIZE,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   (LPARAM)(LPVOID)&adss);
    LeaveHandle(pas);
    if (MMSYSERR_NOERROR == mmr)
    {
        switch (ACM_STREAMSIZEF_QUERYMASK & fdwSize)
        {
            case ACM_STREAMSIZEF_SOURCE:
                *pdwOutputBytes  = adss.cbDstLength;
                break;

            case ACM_STREAMSIZEF_DESTINATION:
                *pdwOutputBytes  = adss.cbSrcLength;
                break;
        }


        //
        //
        //
        if (0L == *pdwOutputBytes)
        {
            DebugErr(DBF_ERROR, "acmStreamSize: buggy driver returned zero bytes for output?!?");
            return (ACMERR_NOTPOSSIBLE);
        }
    }

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamPrepareHeader | The acmStreamPrepareHeader
 *	function prepares an <t ACMSTREAMHEADER> for an Audio Compression
 *	Manager (ACM) stream conversion. This function must be called for
 *	every stream header before it can be used in a conversion stream. An
 *	application only needs to prepare a stream header once for the life of
 *	a given stream; the stream header can be reused as long as the same
 *	source and destiniation buffers are used, and the size of the source
 *	and destination buffers do not exceed the sizes used when the stream
 *	header was originally prepared.
 *
 *  @parm HACMSTREAM | has | Specifies a handle to the conversion steam.
 *
 *  @parm LPACMSTREAMHEADER | pash | Specifies a pointer to an <t ACMSTREAMHEADER>
 *      structure that identifies the source and destination data buffers to
 *      be prepared.
 *
 *  @parm DWORD | fdwPrepare | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *  @comm Preparing a stream header that has already been prepared has no
 *      effect, and the function returns zero. However, an application should
 *      take care to structure code so multiple prepares do not occur.
 *
 *  @xref <f acmStreamUnprepareHeader> <f acmStreamOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamPrepareHeader
(
    HACMSTREAM              has,
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwPrepare
)
{
    MMRESULT                mmr;
    PACMSTREAM              pas;
    LPACMDRVSTREAMHEADER    padsh;
    DWORD                   cbDstRequired;
#if 0
    DWORD                   cbSlop;
#endif // 0
    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_WPOINTER(pash, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pash, pash->cbStruct, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwPrepare, ACM_STREAMPREPAREF_VALID, acmStreamPrepareHeader, MMSYSERR_INVALFLAG);

    if (pash->cbStruct < sizeof(ACMDRVSTREAMHEADER))
    {
        DebugErr(DBF_ERROR, "acmStreamPrepareHeader: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    if (0 != (pash->fdwStatus & ~ACMSTREAMHEADER_STATUSF_VALID))
    {
        DebugErr(DBF_ERROR, "acmStreamPrepareHeader: header contains invalid status flags.");
        return (MMSYSERR_INVALFLAG);
    }


    //
    //
    //
    if (0 != (pash->fdwStatus & ACMSTREAMHEADER_STATUSF_PREPARED))
    {
        DebugErr(DBF_WARNING, "acmStreamPrepareHeader: header is already prepared.");
        return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    pas   = (PACMSTREAM)has;
    padsh = (LPACMDRVSTREAMHEADER)pash;

    //
    //	For debug builds, verify the handle is for this process
    //
#ifdef RDEBUG
    if ( ((PACMGARB)(((PACMDRIVERID)(((PACMDRIVER)pas->had)->hadid))->pag)) != pagFind() )
    {
	DebugErr(DBF_ERROR, "acmStreamPrepareHeader: handle not opened by calling process!");
	return (MMSYSERR_INVALHANDLE);
    }
#endif
    
    //
    //
    //
    //
    mmr = acmStreamSize(has, pash->cbSrcLength, &cbDstRequired, ACM_STREAMSIZEF_SOURCE);
    if (MMSYSERR_NOERROR != mmr)
    {
        return (mmr);
    }

    //
    //  Huh huh uhh huh...
    //
    //
    pwfxSrc = pas->adsi.pwfxSrc;
    pwfxDst = pas->adsi.pwfxDst;

#if 0
    if (pwfxSrc->nSamplesPerSec >= pwfxDst->nSamplesPerSec)
    {
        cbSlop = MulDivRU(pwfxSrc->nSamplesPerSec,
                          pwfxSrc->nBlockAlign,
                          pwfxDst->nSamplesPerSec);
    }
    else
    {
        cbSlop = MulDivRU(pwfxDst->nSamplesPerSec,
                          pwfxDst->nBlockAlign,
                          pwfxSrc->nSamplesPerSec);
    }

    DPF(1, "acmStreamPrepareHeader: cbSrcLength=%lu, cbDstLength=%lu, cbDstRequired=%lu, cbSlop=%lu",
        pash->cbSrcLength, pash->cbDstLength, cbDstRequired, cbSlop);

    if (cbDstRequired > cbSlop)
    {
        cbDstRequired -= cbSlop;
    }

    if (cbDstRequired > pash->cbDstLength)
    {
        DebugErr2(DBF_ERROR, "acmStreamPrepareHeader: src=%lu, dst buffer must be >= %lu bytes.",
                    pash->cbSrcLength, cbDstRequired);
        return (MMSYSERR_INVALPARAM);
    }
#endif

    //
    //  after all the size verification stuff done above, now we check
    //  the src and dst buffer pointers...
    //
    V_RPOINTER(pash->pbSrc, pash->cbSrcLength, MMSYSERR_INVALPARAM);
    V_WPOINTER(pash->pbDst, pash->cbDstLength, MMSYSERR_INVALPARAM);


    //
    //  init a couple of things for the driver
    //
    padsh->fdwConvert           = fdwPrepare;
    padsh->padshNext            = NULL;
    padsh->fdwDriver            = 0L;
    padsh->dwDriver             = 0L;

    padsh->fdwPrepared          = 0L;
    padsh->dwPrepared           = 0L;
    padsh->pbPreparedSrc        = NULL;
    padsh->cbPreparedSrcLength  = 0L;
    padsh->pbPreparedDst        = NULL;
    padsh->cbPreparedDstLength  = 0L;


    //
    //  set up driver instance info--copy over driver data that is saved
    //  in ACMSTREAM
    //
    EnterHandle(pas);
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_PREPARE,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   (LPARAM)(LPVOID)padsh);
    LeaveHandle(pas);

    if (MMSYSERR_NOTSUPPORTED == mmr ||
        MMSYSERR_NOERROR      == mmr &&
        (((PACMDRIVERID)((PACMDRIVER)pas->had)->hadid)->fdwAdd &
         ACM_DRIVERADDF_32BIT))
    {
        //
        //  the driver doesn't seem to think it needs anything special
        //  so just succeed the call
        //
        //  note that if the ACM needs to do something special, it should
        //  do it here...
        //
#ifndef WIN32
{
        BOOL            fAsync;

        fAsync = (0 != (pas->adsi.fdwOpen & ACM_STREAMOPENF_ASYNC));
        if (fAsync)
        {
            DPF(1, "acmStreamPrepareHeader: preparing async header and buffers");

            if (!acmHugePageLock((LPBYTE)padsh, padsh->cbStruct, FALSE))
            {
                return (MMSYSERR_NOMEM);
            }

            if (!acmHugePageLock(padsh->pbSrc, pash->cbSrcLength, FALSE))
            {
                acmHugePageUnlock((LPBYTE)padsh, padsh->cbStruct, FALSE);
                return MMSYSERR_NOMEM;
            }

            if (!acmHugePageLock(padsh->pbDst, pash->cbDstLength, FALSE))
            {
                acmHugePageUnlock(padsh->pbSrc, pash->cbSrcLength, FALSE);
                acmHugePageUnlock((LPBYTE)padsh, padsh->cbStruct, FALSE);
                return (MMSYSERR_NOMEM);
            }
        }
}
#endif

        mmr = MMSYSERR_NOERROR;
    }

    //
    //
    //
    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  set the prepared bit (and also kill any invalid flags that
        //  the driver might have felt it should set--when the driver
        //  writer sees that his flags are not being preserved he will
        //  probably read the docs and use pash->fdwDriver instead).
        //
        pash->fdwStatus  = pash->fdwStatus | ACMSTREAMHEADER_STATUSF_PREPARED;
        pash->fdwStatus &= ACMSTREAMHEADER_STATUSF_VALID;


        //
        //  save the original prepared pointers and sizes so we can keep
        //  track of this stuff for the calling app..
        //
        padsh->fdwPrepared          = fdwPrepare;
        padsh->dwPrepared           = (DWORD_PTR)(UINT_PTR)has;
        padsh->pbPreparedSrc        = padsh->pbSrc;
        padsh->cbPreparedSrcLength  = padsh->cbSrcLength;
        padsh->pbPreparedDst        = padsh->pbDst;
        padsh->cbPreparedDstLength  = padsh->cbDstLength;

        pas->cPrepared++;
    }

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamUnprepareHeader | The acmStreamUnprepareHeader function
 *      cleans up the preparation performed by the <f acmStreamPrepareHeader>
 *      function for an Audio Compression Manager (ACM) stream. This function must
 *      be called after the ACM is finished with the given buffers. An
 *      application must call this function before freeing the source and
 *      destination buffers.
 *
 *  @parm HACMSTREAM | has | Specifies a handle to the conversion steam.
 *
 *  @parm LPACMSTREAMHEADER | pash | Specifies a pointer to an <t ACMSTREAMHEADER>
 *      structure that identifies the source and destination data buffers to
 *      be unprepared.
 *
 *  @parm DWORD | fdwUnprepare | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_BUSY | The stream header <p pash> is currently in use
 *      and cannot be unprepared.
 *
 *      @flag ACMERR_UNPREPARED | The stream header <p pash> is currently
 *      not prepared by the <f acmStreamPrepareHeader> function.
 *
 *  @comm Unpreparing a stream header that has already been unprepared is
 *      an error. An application must specify the source and destination
 *      buffer lengths (<e ACMSTREAMHEADER.cbSrcLength> and
 *      <e ACMSTREAMHEADER.cbDstLength> respectively) that were used
 *      during the corresponding <f acmStreamPrepareHeader> call. Failing
 *      to reset these member values will cause <f acmStreamUnprepareHeader>
 *      to fail with MMSYSERR_INVALPARAM.
 *
 *      Note that there are some errors that the ACM can recover from. The
 *      ACM will return a non-zero error, yet the stream header will be
 *      properly unprepared. To determine whether the stream header was
 *      actually unprepared an application can examine the
 *      ACMSTREAMHEADER_STATUSF_PREPARED flag. The header will always be
 *      unprepared if <f acmStreamUnprepareHeader> returns success.
 *
 *  @xref <f acmStreamPrepareHeader> <f acmStreamClose>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamUnprepareHeader
(
    HACMSTREAM              has,
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwUnprepare
)
{
    MMRESULT                mmr;
    PACMSTREAM              pas;
    LPACMDRVSTREAMHEADER    padsh;
    BOOL                    fStupidApp;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_WPOINTER(pash, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pash, pash->cbStruct, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwUnprepare, ACM_STREAMPREPAREF_VALID, acmStreamUnprepareHeader, MMSYSERR_INVALFLAG);

    if (pash->cbStruct < sizeof(ACMDRVSTREAMHEADER))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    if (0 != (pash->fdwStatus & ~ACMSTREAMHEADER_STATUSF_VALID))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header contains invalid status flags.");
        return (MMSYSERR_INVALFLAG);
    }

    //
    //
    //
    if (0 != (pash->fdwStatus & ACMSTREAMHEADER_STATUSF_INQUEUE))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header is still in use.");
        return (ACMERR_BUSY);
    }


    if (0 == (pash->fdwStatus & ACMSTREAMHEADER_STATUSF_PREPARED))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header is not prepared.");
        return (ACMERR_UNPREPARED);
    }

    //
    //
    //
    pas   = (PACMSTREAM)has;
    padsh = (LPACMDRVSTREAMHEADER)pash;

    //
    //	For debug builds, verify the handle is for this process
    //
#ifdef RDEBUG
    if ( ((PACMGARB)(((PACMDRIVERID)(((PACMDRIVER)pas->had)->hadid))->pag)) != pagFind() )
    {
	DebugErr(DBF_ERROR, "acmStreamUnprepareHandle: handle not opened by calling process!");
	return (MMSYSERR_INVALHANDLE);
    }
#endif

    //
    //
    //
    if ((UINT_PTR)has != padsh->dwPrepared)
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header prepared for different stream.");
        return (MMSYSERR_INVALHANDLE);
    }

    fStupidApp = FALSE;
    if ((padsh->pbSrc != padsh->pbPreparedSrc) ||
        (padsh->cbSrcLength != padsh->cbPreparedSrcLength))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header prepared with different source buffer/length.");

        if (padsh->pbSrc != padsh->pbPreparedSrc)
        {
            return (MMSYSERR_INVALPARAM);
        }

        padsh->cbSrcLength = padsh->cbPreparedSrcLength;
        fStupidApp = TRUE;
    }

    if ((padsh->pbDst != padsh->pbPreparedDst) ||
        (padsh->cbDstLength != padsh->cbPreparedDstLength))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header prepared with different destination buffer/length.");

        if (padsh->pbDst != padsh->pbPreparedDst)
        {
            return (MMSYSERR_INVALPARAM);
        }

        padsh->cbDstLength = padsh->cbPreparedDstLength;
        fStupidApp = TRUE;
    }



    //
    //  init things for the driver
    //
    padsh->fdwConvert = fdwUnprepare;

    EnterHandle(pas);
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_UNPREPARE,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   (LPARAM)(LPVOID)padsh);
    LeaveHandle(pas);

    if (MMSYSERR_NOTSUPPORTED == mmr)
    {
        //
        //  note that if the ACM needs to undo something special, it should
        //  do it here...
        //
#ifndef WIN32
{
        BOOL            fAsync;

        fAsync = (0 != (pas->adsi.fdwOpen & ACM_STREAMOPENF_ASYNC));
        if (fAsync)
        {
            DPF(1, "acmStreamUnprepareHeader: unpreparing async header and buffers");
            acmHugePageUnlock(padsh->pbDst, pash->cbDstLength, FALSE);
            acmHugePageUnlock(padsh->pbSrc, pash->cbSrcLength, FALSE);
            acmHugePageUnlock((LPBYTE)padsh, padsh->cbStruct, FALSE);
        }
}
#endif

        mmr = MMSYSERR_NOERROR;
    }

    //
    //
    //
    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  UNset the prepared bit (and also kill any invalid flags that
        //  the driver might have felt it should set--when the driver
        //  writer sees that his flags are not being preserved he will
        //  probably read the docs and use pash->fdwDriver instead).
        //
        pash->fdwStatus  = pash->fdwStatus & ~ACMSTREAMHEADER_STATUSF_PREPARED;
        pash->fdwStatus &= ACMSTREAMHEADER_STATUSF_VALID;

        padsh->fdwPrepared          = 0L;
        padsh->dwPrepared           = 0L;
        padsh->pbPreparedSrc        = NULL;
        padsh->cbPreparedSrcLength  = 0L;
        padsh->pbPreparedDst        = NULL;
        padsh->cbPreparedDstLength  = 0L;

        pas->cPrepared--;

        //
        //  if we fixed up a bug for the app, still return an error...
        //
        if (fStupidApp)
        {
            mmr = MMSYSERR_INVALPARAM;
        }
    }

    return (mmr);
}



/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMSTREAMHEADER | The <t ACMSTREAMHEADER> structure defines the
 *      header used to identify an Audio Compression Manager (ACM) conversion
 *      source and destination buffer pair for a conversion stream.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t ACMSTREAMHEADER> structure. This member must be initialized
 *      before calling any ACM stream functions using this structure.
 *      The size specified in this member must be large enough to contain
 *      the base <t ACMSTREAMHEADER> structure.
 *
 *  @field DWORD | fdwStatus | Specifies flags giving information about
 *      the conversion buffers. This member must be initialized to zero
 *      before calling <f acmStreamPrepareHeader> and should not be modified
 *      by the application while the stream header remains prepared.
 *
 *      @flag ACMSTREAMHEADER_STATUSF_DONE | Set by the ACM or driver to
 *      indicate that it is finished with the conversion and is returning it
 *      to the application.
 *
 *      @flag ACMSTREAMHEADER_STATUSF_PREPARED | Set by the ACM to indicate
 *      that the data buffers have been prepared with <f acmStreamPrepareHeader>.
 *
 *      @flag ACMSTREAMHEADER_STATUSF_INQUEUE | Set by the ACM or driver to
 *      indicate that the data buffers are queued for conversion.
 *
 *  @field DWORD | dwUser | Specifies 32 bits of user data. This can be any
 *      instance data specified by the application.
 *
 *  @field LPBYTE | pbSrc | Specifies a pointer to the source data buffer.
 *      This pointer must always refer to the same location while the stream
 *      header remains prepared. If an application needs to change the
 *      source location, it must unprepare the header and re-prepare it
 *      with the alternate location.
 *
 *  @field DWORD | cbSrcLength | Specifies the length, in bytes, of the source
 *      data buffer pointed to by <e ACMSTREAMHEADER.pbSrc>. When the
 *      header is prepared, this member must specify the maximum size
 *      that will be used in the source buffer. Conversions can be performed
 *      on source lengths less than or equal to the original prepared size.
 *      However, this member must be reset to the original size when
 *      unpreparing the header.
 *
 *  @field DWORD | cbSrcLengthUsed | Specifies the amount of data, in bytes,
 *      used for the conversion. This member is not valid until the
 *      conversion is complete. Note that this value can be less than or
 *      equal to <e ACMSTREAMHEADER.cbSrcLength>. An application must use
 *      the <e ACMSTREAMHEADER.cbSrcLengthUsed> member when advancing to
 *      the next piece of source data for the conversion stream.
 *
 *  @field DWORD | dwSrcUser | Specifies 32 bits of user data. This can be
 *      any instance data specified by the application.
 *
 *  @field LPBYTE | pbDst | Specifies a pointer to the destination data
 *      buffer. This pointer must always refer to the same location while
 *      the stream header remains prepared. If an application needs to change
 *      the destination location, it must unprepare the header and re-prepare
 *      it with the alternate location.
 *
 *  @field DWORD | cbDstLength | Specifies the length, in bytes, of the
 *      destination data buffer pointed to by <e ACMSTREAMHEADER.pbDst>.
 *      When the header is prepared, this member must specify the maximum
 *      size that will be used in the destination buffer. Conversions can be
 *      performed to destination lengths less than or equal to the original
 *      prepared size. However, this member must be reset to the original
 *      size when unpreparing the header.
 *
 *  @field DWORD | cbDstLengthUsed | Specifies the amount of data, in bytes,
 *      returned by a conversion. This member is not valid until the
 *      conversion is complete. Note that this value may be less than or
 *      equal to <e ACMSTREAMHEADER.cbDstLength>. An application must use
 *      the <e ACMSTREAMHEADER.cbDstLengthUsed> member when advancing to
 *      the next destination location for the conversion stream.
 *
 *  @field DWORD | dwDstUser | Specifies 32 bits of user data. This can be
 *      any instance data specified by the application.
 *
 *  @field DWORD | dwReservedDriver[10] | This member is reserved and should not be used.
 *      This member requires no initialization by the application and should
 *      never be modified while the header remains prepared.
 *
 *  @tagname tACMSTREAMHEADER
 *
 *  @othertype ACMSTREAMHEADER FAR * | LPACMSTREAMHEADER | Pointer to a
 *      <t ACMSTREAMHEADER> structure.
 *
 *  @comm Before an <t ACMSTREAMHEADER> structure can be used for a conversion, it must
 *      be prepared with <f acmStreamPrepareHeader>. When an application
 *      is finished with an <t ACMSTREAMHEADER> structure, the <f acmStreamUnprepareHeader>
 *      function must be called before freeing the source and destination buffers.
 *
 *  @xref <f acmStreamPrepareHeader> <f acmStreamUnprepareHeader>
 *      <f acmStreamConvert>
 *
 ****************************************************************************/


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamConvert | The acmStreamConvert function requests the Audio
 *      Compression Manager (ACM) to perform a conversion on the specified conversion stream. A
 *      conversion may be synchronous or asynchronous depending on how the
 *      stream was opened.
 *
 *  @parm HACMSTREAM | has | Identifies the open conversion stream.
 *
 *  @parm LPACMSTREAMHEADER | pash | Specifies a pointer to a stream header
 *      that describes source and destination buffers for a conversion. This
 *      header must have been prepared previously using the
 *      <f acmStreamPrepareHeader> function.
 *
 *  @parm  DWORD | fdwConvert | Specifies flags for doing the conversion.
 *
 *      @flag ACM_STREAMCONVERTF_BLOCKALIGN | Specifies that only integral
 *      numbers of blocks will be converted. Converted data will end on
 *      block aligned boundaries. An application should use this flag for
 *      all conversions on a stream until there is not enough source data
 *      to convert to a block-aligned destination. In this case, the last
 *      conversion should be specified without this flag.
 *
 *      @flag ACM_STREAMCONVERTF_START | Specifies that the ACM conversion
 *      stream should reinitialize its instance data. For example, if a
 *      conversion stream holds instance data, such as delta or predictor
 *      information, this flag will restore the stream to starting defaults.
 *      Note that this flag can be specified with the ACM_STREAMCONVERTF_END
 *      flag.
 *
 *      @flag ACM_STREAMCONVERTF_END | Specifies that the ACM conversion
 *      stream should begin returning pending instance data. For example, if
 *      a conversion stream holds instance data, such as the tail end of an
 *      echo filter operation, this flag will cause the stream to start
 *      returning this remaining data with optional source data. Note that
 *      this flag can be specified with the ACM_STREAMCONVERTF_START flag.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_BUSY | The stream header <p pash> is currently in use
 *      and cannot be reused.
 *
 *      @flag ACMERR_UNPREPARED | The stream header <p pash> is currently
 *      not prepared by the <f acmStreamPrepareHeader> function.
 *
 *  @comm The source and destination data buffers must be prepared with
 *      <f acmStreamPrepareHeader> before they are passed to <f acmStreamConvert>.
 *
 *      If an asynchronous conversion request is successfully queued by
 *      the ACM or driver, and later the conversion is determined to
 *      be impossible, then the <t ACMSTREAMHEADER> will be posted back to
 *      the application's callback with the <e ACMSTREAMHEADER.cbDstLengthUsed>
 *      member set to zero.
 *
 *  @xref <f acmStreamOpen> <f acmStreamReset> <f acmStreamPrepareHeader>
 *      <f acmStreamUnprepareHeader>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamConvert
(
    HACMSTREAM              has,
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwConvert
)
{
    MMRESULT                mmr;
    PACMSTREAM              pas;
    LPACMDRVSTREAMHEADER    padsh;
    HANDLE		    hEvent;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_WPOINTER(pash, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pash, pash->cbStruct, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwConvert, ACM_STREAMCONVERTF_VALID, acmStreamConvert, MMSYSERR_INVALFLAG);

    if (pash->cbStruct < sizeof(ACMDRVSTREAMHEADER))
    {
        DebugErr(DBF_ERROR, "acmStreamConvert: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    if (0 != (pash->fdwStatus & ACMSTREAMHEADER_STATUSF_INQUEUE))
    {
        DebugErr(DBF_WARNING,"acmStreamConvert: header is already being converted.");
        return (ACMERR_BUSY);
    }

    if (0 == (pash->fdwStatus & ACMSTREAMHEADER_STATUSF_PREPARED))
    {
        DebugErr(DBF_ERROR, "acmStreamConvert: header is not prepared.");
        return (ACMERR_UNPREPARED);
    }

    //
    //
    //
    padsh = (LPACMDRVSTREAMHEADER)pash;
    pas   = (PACMSTREAM)has;

    //
    //	For debug builds, verify the handle is for this process
    //
#ifdef RDEBUG
    if ( ((PACMGARB)(((PACMDRIVERID)(((PACMDRIVER)pas->had)->hadid))->pag)) != pagFind() )
    {
	DebugErr(DBF_ERROR, "acmStreamConvert: handle not opened by calling process!");
	return (MMSYSERR_INVALHANDLE);
    }
#endif

    padsh->cbSrcLengthUsed = 0L;
    padsh->cbDstLengthUsed = 0L;


    //
    //  validate that the header is appropriate for conversions.
    //
    //  NOTE! do not allow a destination buffer length that is smaller than
    //  it was prepared for--this keeps drivers from having to validate
    //  whether the destination buffer is large enough for the conversion
    //  from the source. so don't break this code!!!
    //
    if ((UINT_PTR)has != padsh->dwPrepared)
    {
        DebugErr(DBF_ERROR, "acmStreamConvert: header prepared for different stream.");
        return (MMSYSERR_INVALHANDLE);
    }

    if ((padsh->pbSrc != padsh->pbPreparedSrc) ||
        (padsh->cbSrcLength > padsh->cbPreparedSrcLength))
    {
        DebugErr(DBF_ERROR, "acmStreamConvert: header prepared with incompatible source buffer/length.");
        return (MMSYSERR_INVALPARAM);
    }

    if ((padsh->pbDst != padsh->pbPreparedDst) ||
        (padsh->cbDstLength != padsh->cbPreparedDstLength))
    {
        DebugErr(DBF_ERROR, "acmStreamConvert: header prepared with incompatible destination buffer/length.");
        return (MMSYSERR_INVALPARAM);
    }


    //
    //	Callback event if we are converting async conversion to sync conversion.
    //
    hEvent = (ACMSTREAM_STREAMF_ASYNCTOSYNC & pas->fdwStream) ? (HANDLE)pas->adsi.dwCallback : NULL;
    
    //
    //  init things for the driver
    //
    padsh->fdwStatus  &= ~ACMSTREAMHEADER_STATUSF_DONE;
    padsh->fdwConvert  = fdwConvert;
    padsh->padshNext   = NULL;

    EnterHandle(pas);
#ifdef RDEBUG
    if ( (hEvent) && (WAIT_OBJECT_0 == WaitForSingleObject(hEvent, 0)) )
    {
	//
	//  The event is already signaled!  Bad bad!
	//
	DebugErr(DBF_ERROR, "acmStreamConvert: asynchronous codec called callback unexpectedly");
    }
#endif
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_CONVERT,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   (LPARAM)(LPVOID)padsh);
    if ( (hEvent) && (MMSYSERR_NOERROR == mmr) )
    {
	DPF(4, "acmStreamConvert: waiting for CALLBACK_EVENT");
	WaitForSingleObject(hEvent, INFINITE);
	ResetEvent(hEvent);
    }
    LeaveHandle(pas);

    if (MMSYSERR_NOERROR == mmr)
    {
        if (pash->cbSrcLength < pash->cbSrcLengthUsed)
        {
            DebugErr(DBF_ERROR, "acmStreamConvert: buggy driver returned more data used than given!?!");
            pash->cbSrcLengthUsed = pash->cbSrcLength;
        }

        if (pash->cbDstLength < pash->cbDstLengthUsed)
        {
            DebugErr(DBF_ERROR, "acmStreamConvert: buggy driver used more destination space than allowed!?!");
            pash->cbDstLengthUsed = pash->cbDstLength;
        }

        //
        //  if sync conversion succeeded, then mark done bit for the
        //  driver...
        //
        if (0 == (ACM_STREAMOPENF_ASYNC & pas->adsi.fdwOpen))
        {
            padsh->fdwStatus |= ACMSTREAMHEADER_STATUSF_DONE;
        }
    }

    //
    //  don't allow driver to set bits that we don't want them to!
    //
    pash->fdwStatus &= ACMSTREAMHEADER_STATUSF_VALID;

    return (mmr);
}



//==========================================================================;
//
//  Compatibility with Foghorn's Quick Recorder
//
//
//
//==========================================================================;

#ifndef WIN32

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Compatibility with Foghorn's Quick Recorder--internal now.
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  old convert header for buffer conversion
//
//
//
typedef struct
{
    DWORD               dwFlags;
    LPBYTE              pbSrc;
    DWORD               dwSrcLength;
    DWORD               dwSrcLengthUsed;
    LPBYTE              pbDst;
    DWORD               dwDstLength;
    DWORD               dwDstLengthUsed;
    DWORD               dwUser;
    DWORD               dwUserReserved[2];
    DWORD               dwDrvReserved[4];

} OLD_ACMCONVERTHDR, *POLD_ACMCONVERTHDR, FAR *LPOLD_ACMCONVERTHDR;


/****************************************************************************
 * @doc INTERNAL ACM_API
 *
 * @api LRESULT | acmOpenConversion | Opens a channel to convert data from
 * one specified audio format to another. Optionally specifies a particular codec to use.
 *
 * @parm LPHACMSTREAM | phas | Specifies a pointer to a stream handle that
 * identifies the open converter. Use this handle to identify the converter channel when calling
 * other ACM conversion functions.
 *
 * @parm HACMCONV | hac | Optional handle to an ACM converter.
 * This is used to specify a particular converter.
 *
 * @parm  LPWAVEFORMATEX | pwfxSrc | Specifies a pointer to a WAVEFORMATEX
 * data structure that identifies the source format.
 *
 * @parm  LPWAVEFORMATEX | pwfxDst | Specifies a pointer to a WAVEFORMATEX
 * data structure that identifies the desired destination format after conversion.
 *
 * @parm  DWORD | dwFoo | Used to be conversion parameters. Not supported.
 *
 * @parm  DWORD | dwCallback | Not supported.
 *
 * @parm  DWORD | dwInstance | Not supported.
 *
 * @parm  DWORD | dwFlags | Specifies flags for opening the
 * conversion channel. None are used by anyone calling this old API.
 *
 * @rdesc Returns Zero if the function was successful. Otherwise it
 * returns an error number.
 *
 ***************************************************************************/

EXTERN_C LRESULT ACMAPI acmOpenConversion
(
    LPHACMSTREAM    phas,
    HACMDRIVER      had,
    LPWAVEFORMATEX  pwfxSrc,
    LPWAVEFORMATEX  pwfxDst,
    DWORD           dwFoo,
    DWORD           dwCallback,
    DWORD           dwInstance,
    DWORD           dwFlags
)
{
    //
    //  NOTE! dwFoo is NOT USED by quick recorder, so we don't
    //  pass it on... dwCallback and dwInstance are also not used.
    //
    return (acmStreamOpen(phas, had, pwfxSrc, pwfxDst, NULL, 0L, 0L, 0L));
}


/****************************************************************************
 * @doc INTERNAL ACM_API
 *
 * @api LRESULT | acmCloseConversion | Closes a conversion channel.
 *
 * @parm HACMSTREAM | has | Specifies the conversion channel to close.
 * If the function is successful, the handle is no longer valid after this call.
 *
 * @parm  DWORD | dwFlags | Specifies flags for closing the
 * conversion channel.
 *
 * @rdesc Returns Zero if the function was successful. Otherwise it
 * returns an error number.
 *
 ***************************************************************************/
EXTERN_C LRESULT ACMAPI acmCloseConversion
(
    HACMSTREAM  has,
    DWORD       dwFlags
)
{
    return (acmStreamClose(has, dwFlags));
}


/*****************************************************************************
 * @doc INTERNAL ACM_API_STRUCTURE
 *
 * @types OLD_ACMCONVERTHDR | This structure contains all the information
 * required about a buffer for conversion.
 *
 * @field DWORD | dwFlags | Specifies the status of the buffer.
 *
 * @field LPBYTE | pbSrc | Specifies a pointer to the data area.
 *
 * @field DWORD | dwSrcLength | Specifies the length in bytes of the buffer.
 *
 * @field DWORD | dwSrcLengthUsed | Specifies the amout of data (in bytes)
 * used for the conversion.
 *
 * @field LPBYTE | pbDst | Specifies a pointer to the data area.
 *
 * @field DWORD | dwDstLength | Specifies the length in bytes of the buffer.
 *
 * @field DWORD | dwDstLengthUsed | Specifies the amout of data (in bytes)
 * used for the conversion.
 *
 * @field DWORD | dwUser | Specifies user information.
 *
 * @field DWORD | dwUserReserved[2] | Reserved for future use.
 *
 * @field DWORD | dwDrvReserved[4] | Reserved for the driver.
 *
 *
 ****************************************************************************/


/****************************************************************************
 * @doc INTERNAL ACM_API
 *
 * @api LRESULT | acmConvert | This function tells the ACM to convert
 * the data in one buffer to the space in the other buffer.
 *
 * @parm HACMSTREAM | has | Specifies the open conversion channel
 * to be used for the conversion.
 *
 * @parm LPOLD_ACMCONVERTHDR | pConvHdr | Specifies the buffer information.
 *
 * @parm  DWORD | dwFlags | Specifies flags for opening the
 * conversion channel. (None are defined yet.)
 *
 * @rdesc Returns Zero if the function was successful. Otherwise
 * returns an error number.
 *
 *
 ***************************************************************************/
EXTERN_C LRESULT ACMAPI acmConvert
(
    HACMSTREAM          has,
    LPOLD_ACMCONVERTHDR pConvHdr,
    DWORD               dwFlags
)
{
    MMRESULT            mmr;
    ACMSTREAMHEADER     ash;

    _fmemset(&ash, 0, sizeof(ash));

    ash.cbStruct        = sizeof(ash);
////ash.fdwStatus       = pConvHdr->dwFlags;
    ash.pbSrc           = pConvHdr->pbSrc;
    ash.cbSrcLength     = pConvHdr->dwSrcLength;
////ash.cbSrcLengthUsed = pConvHdr->dwSrcLengthUsed;
    ash.pbDst           = pConvHdr->pbDst;
    ash.cbDstLength     = pConvHdr->dwDstLength;
////ash.cbDstLengthUsed = pConvHdr->dwDstLengthUsed;

    mmr = acmStreamPrepareHeader(has, &ash, 0L);
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

    mmr = acmStreamConvert(has, &ash, 0L);

    acmStreamUnprepareHeader(has, &ash, 0L);

    return (mmr);
}

#endif // #ifndef WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\acmthunk.c ===
//==========================================================================;
//
//  acmthunk.c
//
//  Copyright (c) 1991-1998 Microsoft Corporation
//
//  Description:
//      This module contains routines for assisting thunking of the ACM
//      APIs from 16-bit Windows to 32-bit WOW.
//
//  History:
//
//==========================================================================;

/*

    WOW Thunking design:

        Thunks are generated as follows :

        16-bit :
	    acmInitialize->acmThunkInit :

		Initialize the thunk connection with the 32-bit side.

	    pagFindAndBoot->pagFindAndBoot32 :

		For Daytona, both bitness pagFindAndBoot[32] are called
		during LibMain/DllMain.

		For Chicago, pagFindAndBoot calls pagFindAndBoot32 to
		make sure the 32-bit side has booted all drivers.

	    pagFindAndBoot->acmBoot32BitDrivers->IDriverGetNext32 :

		acmBoot32BitDrivers will enumerate and IDriverAdd
		all 32-bit hadids.
	
		The internal flag ACM_DRIVERADDF_32BIT is specified when
		calling IDriverAdd and this flag is stored in the ACMDRIVERID
		structure.  The 32-bit hadid is the lParam for IDriverAdd.

           IDriverAdd->IDriverLoad->IDriverLoad32

	       IDriverAdd saves the 32-bit hadid in the hadid32 field of
	       the newly allocated 16-bit padid and calls the 32-bit side
	       passing in hadid32 which is used to compare against the hadids
	       on the 32-bit side.  This isn't a very usefull step and simply
	       verifies that the 32-bit hadid exists on the 32-bit size.

           IDriverOpen->IDriverOpen32

               The parameters are passed to the 32-bit side using the hadid32
               field deduced from the HACMDRIVERID as the 32-bit HACMDRIVERID.

           IDriverMessageId->IDriverMessageId32 :

               If the driver is 32-bit (as identified in the ACMDRIVERID
               structure) then call IDriverMessageId32.  The hadid for
               the 32-bit driver is stored in the hadid32 field of ACMDRIVERID
               on the 16-bit side.

           IDriverMessage->IDriverMessage32

               If the driver is 32-bit (as identified in the ACMDRIVERID
               structure pointed to by the ACMDRIVER structure) then call
               IDriverMessage32.  The had for the 32-bit driver is stored
               in the hadid32 field of ACMDRIVER on the 16-bit side.

           Stream headers

               These must be persistent on the 32-bit side too and kept
               in synch.

               They are allocated on the 32-bit side for ACMDM_STREAM_PREPARE
               and freed on ACMDM_STREAM_UNPREPARE.  While in existence
               the 32-bit stream header is stored in the dwDriver field in

*/

/*
    Additional Chicago implementation notes:

	PUT SOMETHING HERE FRANK!!!

*/

#ifndef _WIN64

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>

#ifdef WIN32
#ifndef WIN4
#include <wownt32.h>
#endif
#endif // WIN32

#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "pcm.h"
#include "chooseri.h"
#include "uchelp.h"
#include "acmthunk.h"
#include "debug.h"


//
//  Daytona PPC Merge:  The Chicago source uses DRVCONFIGINFOEX, a stucture
//  which isn't defined on Daytona.  In order to avoid hacking the code, I'm
//  defining DCI to be either DRVCONFIGINFO or DRVCONFIGINFOEX.
//  The only difference between the two structures is
//  that DRVCONFIGINFOEX has a dnDevNode member, so accesses to that member
//  have "#if WINVER >= 0x0400" around them.  These defined are marked by a "PPC"
//  comment.
//
#if (WINVER >= 0x0400) // !PPC
typedef DRVCONFIGINFOEX   DCI;
typedef PDRVCONFIGINFOEX  PDCI;
typedef LPDRVCONFIGINFOEX LPDCI;
#else
typedef DRVCONFIGINFO     DCI;
typedef PDRVCONFIGINFO    PDCI;
typedef LPDRVCONFIGINFO   LPDCI;
#endif



#ifdef WIN32


/* -------------------------------------------------------------------------
** Handle and memory mapping functions.
** -------------------------------------------------------------------------
*/

//
//  16-bit structures
//

typedef struct {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
#if (WINVER >= 0x0400) // !PPC
    DWORD   dnDevNode;
#endif
} DCI16;



#ifdef WIN4
PVOID FNLOCAL ptrFixMap16To32(const VOID * pv)
{
    return MapSLFix(pv);
}

VOID FNLOCAL ptrUnFix16(const VOID * pv)
{
    UnMapSLFixArray(1, &pv);
}

#else
LPWOWHANDLE32          lpWOWHandle32;
LPWOWHANDLE16          lpWOWHandle16;
LPGETVDMPOINTER        GetVdmPointer;
int                    ThunksInitialized;

PVOID FNLOCAL ptrFixMap16To32(const VOID * pv)
{
    return WOW32ResolveMemory(pv);
}

VOID FNLOCAL ptrUnFix16(const VOID * pv)
{
    return;
}

#endif

//
//  Useful functions
//

#define WaveFormatSize(pv)                                            \
    (((WAVEFORMATEX UNALIGNED *)(pv))->wFormatTag == WAVE_FORMAT_PCM ?\
        sizeof(PCMWAVEFORMAT) :                                       \
        ((WAVEFORMATEX UNALIGNED *)pv)->cbSize + sizeof(WAVEFORMATEX))

PVOID CopyAlloc(
    PVOID   pvSrc,
    UINT    uSize
)
{
    PVOID   pvDest;

    pvDest = (PVOID)LocalAlloc(LMEM_FIXED, uSize);

    if (pvDest != NULL) {
        CopyMemory(pvDest, pvSrc, uSize);
    }

    return pvDest;
}

//
//  Thunking callbacks to WOW32 (or wherever)
//


MMRESULT IThunkFilterDetails
(
    HACMDRIVERID                 hadid,
    ACMFILTERDETAILSA UNALIGNED *pafd16,
    DWORD                        fdwDetails
)
{
    ACMFILTERDETAILSA UNALIGNED *pafd;
    ACMFILTERDETAILSW afdw;
    PWAVEFILTER       pwfl;
    UINT              uRet;

    //
    //  Map pointers to 32-bit
    //

    pafd = ptrFixMap16To32((PVOID)pafd16);
    pwfl = ptrFixMap16To32((PVOID)pafd->pwfltr);

    //
    //  Thunk the format details structure
    //  The validation on the 16-bit side ensures that the 16-bit
    //  structure contains all the necessary fields.
    //
    afdw.cbStruct       = sizeof(afdw);
    afdw.dwFilterIndex  = pafd->dwFilterIndex;
    afdw.dwFilterTag    = pafd->dwFilterTag;
    afdw.fdwSupport     = pafd->fdwSupport;
    afdw.pwfltr         = (PWAVEFILTER)CopyAlloc(pwfl, pafd->cbwfltr);


    if (afdw.pwfltr == NULL) {
	ptrUnFix16((PVOID)pafd->pwfltr);
	ptrUnFix16((PVOID)pafd16);
        return MMSYSERR_NOMEM;
    }

    afdw.cbwfltr        = pafd->cbwfltr;

    //
    //  Copy the string if it's used.
    //
    // Imbstowcs(afdw.szFilter, (LPSTR)pafd->szFilter, sizeof(pafd->szFilter));

    //
    //  Call the driver
    //

    uRet =
        ((PACMDRIVER)hadid)->uHandleType == TYPE_HACMDRIVERID ?
         IDriverMessageId(
            hadid,
            ACMDM_FILTER_DETAILS,
            (DWORD)&afdw,
            fdwDetails) :
         IDriverMessage(
            (HACMDRIVER)hadid,
            ACMDM_FILTER_DETAILS,
            (DWORD)&afdw,
            fdwDetails);

    //
    //  If successful copy back the format info
    //

    if (uRet == MMSYSERR_NOERROR) {
        pafd->dwFilterTag    = afdw.dwFilterTag;
        pafd->fdwSupport     = afdw.fdwSupport;
        CopyMemory((PVOID)pwfl, (PVOID)afdw.pwfltr, afdw.cbwfltr);
        Iwcstombs((LPSTR)pafd->szFilter, afdw.szFilter, sizeof(pafd->szFilter));

    }

    LocalFree((HLOCAL)afdw.pwfltr);

    ptrUnFix16((PVOID)pafd->pwfltr);
    ptrUnFix16((PVOID)pafd16);

    return uRet;
}

MMRESULT IThunkFormatDetails
(
    HACMDRIVERID                 hadid,
    ACMFORMATDETAILSA UNALIGNED *pafd16,
    DWORD                        fdwDetails
)
{
    ACMFORMATDETAILSA UNALIGNED *pafd;
    ACMFORMATDETAILSW afdw;
    PWAVEFORMATEX     pwfx;
    UINT              uRet;

    //
    //  Map pointers to 32-bit
    //

    pafd = ptrFixMap16To32((PVOID)pafd16);
    pwfx = ptrFixMap16To32((PVOID)pafd->pwfx);


    //
    //  Thunk the format details structure
    //  The validation on the 16-bit side ensures that the 16-bit
    //  structure contains all the necessary fields.
    //
    afdw.cbStruct       = sizeof(afdw);
    afdw.dwFormatIndex  = pafd->dwFormatIndex;
    afdw.dwFormatTag    = pafd->dwFormatTag;
    afdw.fdwSupport     = pafd->fdwSupport;
    afdw.pwfx           = (PWAVEFORMATEX)CopyAlloc(pwfx, pafd->cbwfx);

    if (afdw.pwfx == NULL) {
    	ptrUnFix16((PVOID)pafd->pwfx);
	    ptrUnFix16((PVOID)pafd16);
        return MMSYSERR_NOMEM;
    }

    afdw.cbwfx          = pafd->cbwfx;

    //
    //  Copy the string if it's used
    //
    // Imbstowcs(afdw.szFormat, (LPSTR)pafd->szFormat, sizeof(pafd->szFormat));

    //
    //  Call the driver
    //

    uRet =
        ((PACMDRIVER)hadid)->uHandleType == TYPE_HACMDRIVERID ?
         IDriverMessageId(
            hadid,
            ACMDM_FORMAT_DETAILS,
            (DWORD)&afdw,
            fdwDetails) :
         IDriverMessage(
            (HACMDRIVER)hadid,
            ACMDM_FORMAT_DETAILS,
            (DWORD)&afdw,
            fdwDetails);

    //
    //  If successful copy back the format info
    //

    if (uRet == MMSYSERR_NOERROR) {

        //
        //  Someone should be shot for designing interfaces with
        //  inputs and outputs in the same structure!!
        //
        pafd->dwFormatTag    = afdw.dwFormatTag;
        pafd->fdwSupport     = afdw.fdwSupport;
        CopyMemory((PVOID)pwfx, (PVOID)afdw.pwfx, afdw.cbwfx);
        Iwcstombs((LPSTR)pafd->szFormat, afdw.szFormat, sizeof(pafd->szFormat));
    }

    LocalFree((HLOCAL)afdw.pwfx);
    ptrUnFix16((PVOID)pafd->pwfx);
    ptrUnFix16((PVOID)pafd16);

    return uRet;
}
MMRESULT IThunkFormatSuggest
(
    HACMDRIVERID                    hadid,
    ACMDRVFORMATSUGGEST UNALIGNED  *pafs16
)
{
    ACMDRVFORMATSUGGEST UNALIGNED  *pafs;
    ACMDRVFORMATSUGGEST afs;
    PWAVEFORMATEX       pwfxSrc;
    PWAVEFORMATEX       pwfxDst;
    UINT                uRet;

    //
    //  Map pointers to 32-bit
    //

    pafs    = ptrFixMap16To32((PVOID)pafs16);
    pwfxSrc = ptrFixMap16To32((PVOID)pafs->pwfxSrc);
    pwfxDst = ptrFixMap16To32((PVOID)pafs->pwfxDst);

    //
    //  Thunk the format details structure
    //  The validation on the 16-bit side ensures that the 16-bit
    //  structure contains all the necessary fields.
    //
    CopyMemory((PVOID)&afs, (PVOID)pafs, sizeof(afs));

    //
    //  Deal with the wave format pointers
    //
    afs.pwfxSrc        =
        (PWAVEFORMATEX)CopyAlloc((PVOID)pwfxSrc, pafs->cbwfxSrc);

    if (afs.pwfxSrc == NULL) {
    	ptrUnFix16((PVOID)pafs->pwfxDst);
	    ptrUnFix16((PVOID)pafs->pwfxSrc);
    	ptrUnFix16((PVOID)pafs16);
        return MMSYSERR_NOMEM;
    }

    afs.pwfxDst        =
        (PWAVEFORMATEX)CopyAlloc((PVOID)pwfxDst, pafs->cbwfxDst);

    if (afs.pwfxDst == NULL) {
        LocalFree((HLOCAL)afs.pwfxSrc);
	    ptrUnFix16((PVOID)pafs->pwfxDst);
    	ptrUnFix16((PVOID)pafs->pwfxSrc);
	    ptrUnFix16((PVOID)pafs16);
        return MMSYSERR_NOMEM;
    }

    //
    //  Call the driver
    //

    uRet =
        ((PACMDRIVER)hadid)->uHandleType == TYPE_HACMDRIVERID ?
         IDriverMessageId(
            hadid,
            ACMDM_FORMAT_SUGGEST,
            (DWORD)&afs,
            0L) :
         IDriverMessage(
            (HACMDRIVER)hadid,
            ACMDM_FORMAT_SUGGEST,
            (DWORD)&afs,
            0L);

     //
     //  If successful copy back the format info
     //

     if (uRet == MMSYSERR_NOERROR) {
         CopyMemory((PVOID)pwfxDst, (PVOID)afs.pwfxDst, afs.cbwfxDst);
     }

     LocalFree((HLOCAL)afs.pwfxSrc);
     LocalFree((HLOCAL)afs.pwfxDst);
     ptrUnFix16((PVOID)pafs->pwfxDst);
     ptrUnFix16((PVOID)pafs->pwfxSrc);
     ptrUnFix16((PVOID)pafs16);

     return uRet;
}

LRESULT IThunkConfigure
(
    HACMDRIVERID      hadid,
    HWND              hwnd,
    DCI16 UNALIGNED * pdci1616
)
{
    DCI16 UNALIGNED * pdci16 = NULL;
    DCI           dci;
    LRESULT       lResult;
    LPSTR         lpszDCISectionNameA;
    LPSTR         lpszDCIAliasNameA;
    LPWSTR        lpszDCISectionNameW;
    LPWSTR        lpszDCIAliasNameW;

    //
    //  Thunk the hwnd if necessary
    //

    if (hwnd != NULL && hwnd != (HWND)-1L) {
#ifdef WIN4
	//  ??? Don't think I need to do anything for Win4 ???
#else
	hwnd = (HWND)(*lpWOWHandle32)( (WORD)hwnd, WOW_TYPE_HWND);
#endif
    }

    dci.dwDCISize = sizeof(dci);

    //
    //  Thunk the config info if necessary
    //

    if (pdci1616 != NULL) {
	    //
	    //  Map all the pointers
	    //
        pdci16              = ptrFixMap16To32((PVOID)pdci1616);
    	lpszDCISectionNameA = ptrFixMap16To32((PVOID)pdci16->lpszDCISectionName);
    	lpszDCIAliasNameA   = ptrFixMap16To32((PVOID)pdci16->lpszDCIAliasName);
	
        dci.dwDCISize = sizeof(dci);
        lpszDCISectionNameW =
            (LPWSTR)
            LocalAlloc(LPTR,
                       (lstrlenA(lpszDCISectionNameA) + 1) * sizeof(WCHAR));

        if (lpszDCISectionNameW == NULL) {
	    ptrUnFix16((PVOID)pdci16->lpszDCISectionName);
	    ptrUnFix16((PVOID)pdci16->lpszDCIAliasName);
	    ptrUnFix16((PVOID)pdci1616);
	    return MMSYSERR_NOMEM;
        }

        lpszDCIAliasNameW =
            (LPWSTR)
            LocalAlloc(LPTR,
                       (lstrlenA(lpszDCIAliasNameA) + 1) * sizeof(WCHAR));

        if (lpszDCIAliasNameW == NULL) {
            LocalFree((HLOCAL)lpszDCISectionNameW);
	    ptrUnFix16((PVOID)pdci16->lpszDCISectionName);
	    ptrUnFix16((PVOID)pdci16->lpszDCIAliasName);
	    ptrUnFix16((PVOID)pdci1616);
	    return MMSYSERR_NOMEM;
        }

        Imbstowcs(lpszDCISectionNameW,
		  lpszDCISectionNameA,
		  lstrlenA(lpszDCISectionNameA) + 1);

        Imbstowcs(lpszDCIAliasNameW,
		  lpszDCIAliasNameA,
		  lstrlenA(lpszDCIAliasNameA) + 1);

        dci.lpszDCISectionName  = lpszDCISectionNameW;
        dci.lpszDCIAliasName    = lpszDCIAliasNameW;
#if (WINVER >= 0x0400) // !PPC
	dci.dnDevNode	    = pdci16->dnDevNode;
#endif
    }

    //
    //  Make the call
    //

    lResult =
        ((PACMDRIVER)hadid)->uHandleType == TYPE_HACMDRIVERID ?
         IDriverMessageId(
            hadid,
            DRV_CONFIGURE,
            (LPARAM)hwnd,
            (LPARAM)(pdci16 == NULL ? NULL : &dci)) :
         IDriverMessage(
            (HACMDRIVER)hadid,
            DRV_CONFIGURE,
            (LPARAM)hwnd,
            (LPARAM)(pdci16 == NULL ? NULL : &dci));

    if (pdci16 != NULL) {
        LocalFree((HLOCAL)dci.lpszDCISectionName);
        LocalFree((HLOCAL)dci.lpszDCIAliasName);
        ptrUnFix16((PVOID)pdci16->lpszDCISectionName);
        ptrUnFix16((PVOID)pdci16->lpszDCIAliasName);
        ptrUnFix16((PVOID)pdci1616);
    }

    return lResult;
}

BOOL IThunkStreamInstance
(
    ACMDRVSTREAMINSTANCE UNALIGNED *padsi16,
    PACMDRVSTREAMINSTANCE          padsi32
)
{
    PWAVEFORMATEX pwfxSrc;
    PWAVEFORMATEX pwfxDst;
    PWAVEFILTER   pwfltr16;

    pwfxSrc  = (PWAVEFORMATEX)ptrFixMap16To32((PVOID)padsi16->pwfxSrc);
    pwfxDst  = (PWAVEFORMATEX)ptrFixMap16To32((PVOID)padsi16->pwfxDst);
    pwfltr16 = (PWAVEFILTER)  ptrFixMap16To32((PVOID)padsi16->pwfltr);

    //
    //  The 16-bit side has 2 fewer bytes in the stream instance data
    //  because the handle is only 2 bytes
    //

    padsi32->has = NULL;
    CopyMemory((PVOID)padsi32, (PVOID)padsi16, sizeof(*padsi32) - 2);

    //
    //  Fix up the pointers
    //

    if (pwfxSrc != NULL) {
        padsi32->pwfxSrc = CopyAlloc((PVOID)pwfxSrc, WaveFormatSize(pwfxSrc));
        if (padsi32->pwfxSrc == NULL) {
	    ptrUnFix16((PVOID)padsi16->pwfltr);
	    ptrUnFix16((PVOID)padsi16->pwfxDst);
	    ptrUnFix16((PVOID)padsi16->pwfxSrc);
            return FALSE;
        }
    } else {
        padsi32->pwfxSrc = NULL;
    }


    if (pwfxDst != NULL) {
        padsi32->pwfxDst = CopyAlloc((PVOID)pwfxDst, WaveFormatSize(pwfxDst));
        if (padsi32->pwfxDst == NULL) {
            if (padsi32->pwfxSrc != NULL) {
                LocalFree((HLOCAL)padsi32->pwfxSrc);
            }
	    ptrUnFix16((PVOID)padsi16->pwfltr);
	    ptrUnFix16((PVOID)padsi16->pwfxDst);
	    ptrUnFix16((PVOID)padsi16->pwfxSrc);
	    return FALSE;
        }
    } else {
        padsi32->pwfxDst = NULL;
    }


    if (padsi16->pwfltr != NULL) {
        padsi32->pwfltr = CopyAlloc(pwfltr16, pwfltr16->cbStruct);

        if (padsi32->pwfltr == NULL) {
            if (padsi32->pwfxSrc != NULL) {
                LocalFree((HLOCAL)padsi32->pwfxSrc);
            }
            if (padsi32->pwfxDst != NULL) {
                LocalFree((HLOCAL)padsi32->pwfxDst);
            }
	        ptrUnFix16((PVOID)padsi16->pwfltr);
	        ptrUnFix16((PVOID)padsi16->pwfxDst);
	        ptrUnFix16((PVOID)padsi16->pwfxSrc);
            return FALSE;
        }
    } else {
        padsi32->pwfltr = NULL;
    }

    ptrUnFix16((PVOID)padsi16->pwfltr);
    ptrUnFix16((PVOID)padsi16->pwfxDst);
    ptrUnFix16((PVOID)padsi16->pwfxSrc);
    return TRUE;
}

VOID IUnThunkStreamInstance
(
    PACMDRVSTREAMINSTANCE  padsi
)
{
    if (padsi->pwfxSrc != NULL) {
        LocalFree((HLOCAL)padsi->pwfxSrc);
    }
    if (padsi->pwfxDst != NULL) {
        LocalFree((HLOCAL)padsi->pwfxDst);
    }
    if (padsi->pwfltr != NULL) {
        LocalFree((HLOCAL)padsi->pwfltr);
    }

}

//--------------------------------------------------------------------------;
//
//  LRESULT IOpenDriver32
//
//  Description:
//
//      Open a 32-bit driver
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;
MMRESULT IDriverOpen32
(
    HACMDRIVER UNALIGNED * phad16,
    HACMDRIVERID           hadid,
    DWORD                  fdwOpen
)
{
    HACMDRIVER UNALIGNED * phad;
    HACMDRIVER      had;
    MMRESULT        mmr;

    mmr = IDriverOpen(&had, hadid, fdwOpen);

    if (mmr == MMSYSERR_NOERROR) {
        phad = (HACMDRIVER*)ptrFixMap16To32((PVOID)phad16);
        *phad = had;
	ptrUnFix16((PVOID)phad16);
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessageId32
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;
LRESULT FNLOCAL IDriverMessageId32
(
    HACMDRIVERID        hadid,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{

    switch (uMsg) {

    //
    //  Common with IDriverMessage32
    //
    case DRV_CONFIGURE:
        return IThunkConfigure(hadid,
                               (HWND)lParam1,
                               (DCI16 UNALIGNED *)lParam2);

    case ACMDM_FILTER_DETAILS:
        //
        //
        //
        return IThunkFilterDetails(hadid,
                                   (ACMFILTERDETAILSA UNALIGNED *)lParam1,
                                   (DWORD)lParam2);
        break;

    case ACMDM_FORMAT_DETAILS:
        return IThunkFormatDetails(hadid,
                                   (ACMFORMATDETAILSA UNALIGNED *)lParam1,
                                   (DWORD)lParam2);

    case ACMDM_FORMAT_SUGGEST:
        return IThunkFormatSuggest(hadid,
                                   (PACMDRVFORMATSUGGEST)lParam1);



    //
    //
    //
    case DRV_QUERYCONFIGURE:
        //
        //  Just pass the message on
        //
        return IDriverMessageId(hadid, uMsg, lParam1, lParam2);

    case ACMDM_DRIVER_DETAILS:
        {
            ACMDRIVERDETAILSA  acmd;
            MMRESULT uRet;

            acmd.cbStruct = sizeof(acmd);
            uRet = acmDriverDetailsA(hadid, &acmd, 0L);

            if (uRet == MMSYSERR_NOERROR) {
                PVOID pvStart;
                WORD  wicon;

                /*
                **  No async support - we don't want to support callbacks
                */
                acmd.fdwSupport &= ~ACMDRIVERDETAILS_SUPPORTF_ASYNC;

		//
		//  Map pointer from 16- to 32-bits
		//
		pvStart = ptrFixMap16To32((PVOID)lParam1);

                /*
                **  Copy it all back but remember HICON is 16-bit
                **  on the 16-bit side
                */
		
                CopyMemory(pvStart,
                           (PVOID)&acmd,
                           FIELD_OFFSET(ACMDRIVERDETAILSA, hicon) );

                /*
                ** map and copy the icon handle
                **
                ** Note: There is not a WOW_TYPE_ICON in the WOW_HANDLE_TYPE
                ** enumeration.
                */
#ifdef WIN4
		wicon = (WORD)acmd.hicon;
#else
                wicon = (*lpWOWHandle16)( acmd.hicon, WOW_TYPE_HWND);
#endif

                CopyMemory((PVOID)((PBYTE)pvStart +
			   FIELD_OFFSET(ACMDRIVERDETAILSA, hicon)),
			   &wicon,
                           sizeof(WORD) );

                CopyMemory((PVOID)((PBYTE)pvStart +
                               FIELD_OFFSET(ACMDRIVERDETAILSA, hicon) +
                               sizeof(WORD)),
                           (PVOID)acmd.szShortName,
                           sizeof(acmd) -
                               FIELD_OFFSET(ACMDRIVERDETAILSA, szShortName[0]));

		//
		//  Unmap pointer
		//
		ptrUnFix16((PVOID)lParam1);
            }
            return uRet;
        }

    case ACMDM_FORMATTAG_DETAILS:
        {
            ACMFORMATTAGDETAILS             acmf;
            ACMFORMATTAGDETAILSA UNALIGNED *pvacmf;
            MMRESULT                        uRet;

            pvacmf = (ACMFORMATTAGDETAILSA UNALIGNED *)
                          ptrFixMap16To32((PVOID)lParam1);

#ifdef TRUE	// UNICODE
            CopyMemory((PVOID)&acmf, (PVOID)pvacmf,
                       FIELD_OFFSET(ACMFORMATTAGDETAILS, szFormatTag[0]));

            acmf.cbStruct = sizeof(acmf);

	    //
	    //	szFormatTag is never an input arg so no need to thunk it
	    //
	    // Imbstowcs(acmf.szFormatTag,
	    //		 (LPSTR)pvacmf->szFormatTag,
	    //           sizeof(pvacmf->szFormatTag));
	    //
#else
	    CopyMemory((PVOID)&acmf, (PVOID)pvacmf, sizeof(acmf));
	    acmf.cbStruct = sizeof(acmf);
#endif

            uRet = IDriverMessageId(hadid,
                                    uMsg,
                                    (LPARAM)&acmf,
                                    lParam2);

            if (uRet == MMSYSERR_NOERROR) {
#ifdef TRUE	// UNICODE
                CopyMemory((PVOID)pvacmf, (PVOID)&acmf,
                           FIELD_OFFSET(ACMFORMATTAGDETAILS, szFormatTag[0]));

		pvacmf->cbStruct = sizeof(*pvacmf);
		
                Iwcstombs((LPSTR)pvacmf->szFormatTag,
                         acmf.szFormatTag,
                         sizeof(pvacmf->szFormatTag));
#else
		CopyMemory((PVOID)pvacmf, (PVOID)&acmf, sizeof(acmf));
		pvacmf->cbStruct = sizeof(*pvacmf);
#endif
            }
	    ptrUnFix16((PVOID)lParam1);
            return uRet;
        }
        break;

    case ACMDM_FILTERTAG_DETAILS:
        {
            ACMFILTERTAGDETAILS             acmf;
            ACMFILTERTAGDETAILSA UNALIGNED *pvacmf;
            MMRESULT                        uRet;

            pvacmf = (ACMFILTERTAGDETAILSA UNALIGNED *)
			 ptrFixMap16To32((PVOID)lParam1);

#ifdef TRUE	// UNICODE
            CopyMemory((PVOID)&acmf, (PVOID)pvacmf,
                       FIELD_OFFSET(ACMFILTERTAGDETAILS, szFilterTag[0]));

            acmf.cbStruct = sizeof(acmf);

	    //
	    //	szFilterTag is never an input arg so no need to thunk it
	    //
	    // Imbstowcs(acmf.szFilterTag,
	    //           (LPSTR)pvacmf->szFilterTag,
	    //           sizeof(pvacmf->szFilterTag));
	    //
#else
	    CopyMemory((PVOID)&acmf, (PVOID)pvacmf, sizeof(acmf));
	    acmf.cbStruct = sizeof(acmf);
#endif

            uRet = IDriverMessageId(hadid,
                                    uMsg,
                                    (LPARAM)&acmf,
                                    lParam2);


            if (uRet == MMSYSERR_NOERROR) {
#ifdef TRUE	// UNICODE
                CopyMemory((PVOID)pvacmf, (PVOID)&acmf,
                           FIELD_OFFSET(ACMFILTERTAGDETAILS, szFilterTag[0]));

		pvacmf->cbStruct = sizeof(*pvacmf);
		
                Iwcstombs((LPSTR)pvacmf->szFilterTag,
                         acmf.szFilterTag,
                         sizeof(pvacmf->szFilterTag));
#else
		CopyMemory((PVOID)pvacmf, (PVOID)&acmf, sizeof(acmf));
		pvacmf->cbStruct = sizeof(*pvacmf);
#endif
            }
	    ptrUnFix16((PVOID)lParam1);
            return uRet;
        }
        break;

    case ACMDM_HARDWARE_WAVE_CAPS_INPUT:
        {
            //
            //  wave input
            //
            WAVEINCAPSA  wica;
            WAVEINCAPSW  wicw;
            MMRESULT     uRet;

            uRet = IDriverMessageId(hadid,
                                    uMsg,
                                    (LPARAM)&wicw,
                                    sizeof(wicw));

            if (uRet == MMSYSERR_NOERROR) {
                CopyMemory((PVOID)&wica, (PVOID)&wicw,
                           FIELD_OFFSET(WAVEINCAPS, szPname[0]));

                Iwcstombs(wica.szPname, wicw.szPname, sizeof(wica.szPname));

                CopyMemory(ptrFixMap16To32((PVOID)lParam1),
                           (PVOID)&wica,
                           lParam2);
		ptrUnFix16((PVOID)lParam1);
            }

            return uRet;
        }

    case ACMDM_HARDWARE_WAVE_CAPS_OUTPUT:
        {
            //
            //  wave output
            //
            WAVEOUTCAPSA  woca;
            WAVEOUTCAPSW  wocw;
            MMRESULT uRet;

            uRet = IDriverMessageId(hadid,
                                    uMsg,
                                    (LPARAM)&wocw,
                                    sizeof(wocw));

            if (uRet == MMSYSERR_NOERROR) {
                CopyMemory((PVOID)&woca, (PVOID)&wocw,
                           FIELD_OFFSET(WAVEOUTCAPS, szPname[0]));

                Iwcstombs(woca.szPname, wocw.szPname, sizeof(woca.szPname));

                CopyMemory(ptrFixMap16To32((PVOID)lParam1),
                           (PVOID)&woca,
                           lParam2);
		ptrUnFix16((PVOID)lParam1);
            }

            return uRet;
        }
        break;

    case ACMDM_DRIVER_ABOUT:

        //
        //  Map the window handle
        //
#ifndef WIN4
        lParam1 = (LPARAM)(*lpWOWHandle32)( (WORD)lParam1, WOW_TYPE_HWND);
#endif

        return IDriverMessageId(hadid, uMsg, lParam1, lParam2);

    case ACMDM_DRIVER_NOTIFY:
    default:
        return MMSYSERR_NOTSUPPORTED;

    }

}

//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessage32
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;
LRESULT FNLOCAL IDriverMessage32
(
    HACMDRIVER          had,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    DWORD		dwSave;

    switch (uMsg) {
    //
    //  Common with IDriverMessageId32
    //
    case DRV_CONFIGURE:
        //
        //  16-bit apps can configure 32-bit drivers
        //
        return IThunkConfigure((HACMDRIVERID)had,
                               (HWND)lParam1,
                               (DCI16 UNALIGNED *)lParam2);

    case ACMDM_FILTER_DETAILS:
        //
        //
        //
        return IThunkFilterDetails((HACMDRIVERID)had,
                                   (ACMFILTERDETAILSA UNALIGNED *)lParam1,
                                   (DWORD)lParam2);
        break;

    case ACMDM_FORMAT_DETAILS:
        return IThunkFormatDetails((HACMDRIVERID)had,
                                   (ACMFORMATDETAILSA UNALIGNED *)lParam1,
                                   (DWORD)lParam2);

    case ACMDM_FORMAT_SUGGEST:
        return IThunkFormatSuggest((HACMDRIVERID)had,
                                   (ACMDRVFORMATSUGGEST UNALIGNED *)lParam1);


    //
    //
    //
    case ACMDM_STREAM_OPEN:
    case ACMDM_STREAM_CLOSE:
    case ACMDM_STREAM_RESET:
    case ACMDM_STREAM_SIZE:
        //
        //  Passes in PACMDRVSTREAMINSTANCE in lPararm1
        //
        {
            ACMDRVSTREAMINSTANCE  adsi;
            ACMDRVSTREAMINSTANCE UNALIGNED *padsi;    // unaligned 16-bit version
            MMRESULT              uRet;
            ACMDRVSTREAMSIZE      adss;
            ACMDRVSTREAMSIZE UNALIGNED *lpadss16;     // unaligned 16-bit version

            padsi = (ACMDRVSTREAMINSTANCE*)ptrFixMap16To32((PVOID)lParam1);

            if (!IThunkStreamInstance(padsi, &adsi)) {
		ptrUnFix16((PVOID)lParam1);
                return MMSYSERR_NOMEM;
            }

            if (uMsg == ACMDM_STREAM_SIZE) {
                lpadss16 = (LPACMDRVSTREAMSIZE)ptrFixMap16To32((PVOID)lParam2);
                CopyMemory( (PVOID)&adss, (PVOID)lpadss16, sizeof(adss));
            }

            //
            //  Call the driver
            //

            uRet = IDriverMessage(had,
                                  uMsg,
                                  (LPARAM)&adsi,
                                  uMsg == ACMDM_STREAM_SIZE ?
                                      (LPARAM)&adss : lParam2);

            IUnThunkStreamInstance(&adsi);

            if (uRet == MMSYSERR_NOERROR) {

                //
                //  Don't lose data the driver may have set up
                //
                padsi->fdwDriver = adsi.fdwDriver;
                padsi->dwDriver  = adsi.dwDriver;

                //
                //  Return the size stuff if requested
                //

                if (uMsg == ACMDM_STREAM_SIZE) {
                    CopyMemory( (PVOID)lpadss16, (PVOID)&adss, sizeof(adss) );
                }
            }

	    ptrUnFix16((PVOID)lParam2);
	    ptrUnFix16((PVOID)lParam1);
            return uRet;
        }

    case ACMDM_STREAM_PREPARE:
    case ACMDM_STREAM_UNPREPARE:
    case ACMDM_STREAM_CONVERT:
        //
        //  Passes in PACMDRVSTREAMINSTANCE in lPararm1
        //
        {
            ACMDRVSTREAMINSTANCE  adsi;
            ACMDRVSTREAMINSTANCE UNALIGNED *padsi;    // unaligned 16-bit version
            MMRESULT              uRet;
            ACMDRVSTREAMHEADER UNALIGNED *padsh;
            PACMDRVSTREAMHEADER   padsh32;

            padsi = ptrFixMap16To32((PVOID)lParam1);
            padsh = ptrFixMap16To32((PVOID)lParam2);

            if (!IThunkStreamInstance(padsi, &adsi)) {
		ptrUnFix16((PVOID)lParam2);
		ptrUnFix16((PVOID)lParam1);
                return MMSYSERR_NOMEM;
            }

            //
            //  If this not prepare we already have a 32-bit
            //  stream header.
            //

            if (uMsg == ACMDM_STREAM_PREPARE) {
                padsh->dwDriver = (DWORD)LocalAlloc(LMEM_FIXED, sizeof(*padsh));
            }
            padsh32 = (PACMDRVSTREAMHEADER)padsh->dwDriver;

            if (padsh32 != NULL) {

                //  Thunk the stream header
                //
                //  NOTE - NO ATTEMPT is made to align the byte fields,
                //  this is up to the drivers.
                //
		
		dwSave = padsh32->dwDriver;
                CopyMemory((PVOID)padsh32, (PVOID)padsh, sizeof(*padsh));
		padsh32->dwDriver = dwSave;

                padsh32->pbSrc  = (PBYTE)ptrFixMap16To32((PVOID)padsh32->pbSrc);
                padsh32->pbDst  = (PBYTE)ptrFixMap16To32((PVOID)padsh32->pbDst);

                //
                //  Call the driver
                //

                uRet = IDriverMessage(had,
                                      uMsg,
                                      (LPARAM)&adsi,
                                      (LPARAM)padsh32);
            } else {
                uRet = MMSYSERR_NOMEM;
            }

            IUnThunkStreamInstance(&adsi);

            if (uRet == MMSYSERR_NOERROR) {

                //
                //  Don't lose data the driver may have set up
                //
                padsi->fdwDriver = adsi.fdwDriver;
                padsi->dwDriver  = adsi.dwDriver;

                //
                //  Copy back the stream header (don't mess up the pointers
                //  or driver instance data though!).
                //

                padsh32->pbSrc    = padsh->pbSrc;
                padsh32->pbDst    = padsh->pbDst;
		dwSave = padsh32->dwDriver;
                padsh32->dwDriver = padsh->dwDriver;
                CopyMemory((PVOID)padsh, (PVOID)padsh32, sizeof(*padsh));
		padsh32->dwDriver = dwSave;

            }

            //
            //  Free if this is unprepare (note that this must be done
            //  whether the driver succeeds of not since the driver may not
            //  support unprepare.
            //

            if (uMsg == ACMDM_STREAM_UNPREPARE) {
                LocalFree((HLOCAL)padsh->dwDriver);
                padsh->dwDriver = 0;
            }

	    if (NULL != padsh32)
	    {
		ptrUnFix16((PVOID)padsh->pbDst);
		ptrUnFix16((PVOID)padsh->pbSrc);
	    }
	    ptrUnFix16((PVOID)lParam2);
	    ptrUnFix16((PVOID)lParam1);
	    return uRet;
        }
	
    }

    return MMSYSERR_NOTSUPPORTED;       // None of the switchs hit.  Return not supported
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetNext32
//
//  Description:
//	Called on 32-bit side of thunk to get the next hadid in the
//	driver list.
//
//  Arguments:
//	PACMGARB pag:
//
//      LPHACMDRIVERID phadidNext:
//
//      HACMDRIVERID hadid:
//
//      DWORD fdwGetNext:
//
//  Return (MMRESULT):
//
//  History:
//      06/25/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverGetNext32
(
    PACMGARB		    pag,
    LPHACMDRIVERID          phadidNext,
    HACMDRIVERID            hadid,
    DWORD                   fdwGetNext
)
{
    ASSERT(NULL != phadidNext);
    return IDriverGetNext(pag, phadidNext, hadid, fdwGetNext);
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetInfo32
//
//  Description:
//	Gets the szAlias, fnDriverProc, dnDevNode, and fdwAdd for
//	a 32-bit hadid.
//
//  Arguments:
//	PACMGARB pag: Usual garbage pointer.
//
//      HACMDRIVERID hadid: handle to driver id for which to get info.
//
//	LPSTR lpstrAlias: pointer to buffer to receive alias string.
//
//	LPACMDRIVERPROC lpfnDriverProc: pointer to ACMDRIVERPROC variable
//	    to receive the driver proc pointer.
//
//	LPDWORD lpdnDevNode: pointer to a DWORD to receive dnDevNode.
//
//      LPDWORD lpfdwAdd: pointer to DWORD to receive the add flags.
//
//  Return (MMRESULT):
//	MMSYSERR_NOERROR:
//	MMSYSERR_INVALHANDLE: hadid not in driver list.
//
//  History:
//      06/25/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverGetInfo32
(
    PACMGARB		pag,
    HACMDRIVERID	hadid,
    LPSTR           lpstrAlias,
    LPACMDRIVERPROC	lpfnDriverProc,
    LPDWORD         lpdnDevNode,
    LPDWORD         lpfdwAdd
)
{
    HACMDRIVERID	hadidT;
    PACMDRIVERID	padid;
    DWORD		fdwEnum;

    ASSERT( (NULL != lpstrAlias) &&
	    (NULL != lpfnDriverProc) &&
	    (NULL != lpdnDevNode) &&
	    (NULL != lpfdwAdd) );

    //
    //	Search for this hadid in the driver list.  If found,
    //	return some information on it.
    //

    hadidT = NULL;
    fdwEnum = ACM_DRIVERENUMF_DISABLED;
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadidT, hadidT, fdwEnum))
    {
	if (hadidT == hadid)
	{
	    padid = (PACMDRIVERID)hadid;

	    Iwcstombs(lpstrAlias, padid->szAlias, MAX_DRIVER_NAME_CHARS);

	    *lpfnDriverProc = padid->fnDriverProc;

	    *lpdnDevNode = padid->dnDevNode;

	    *lpfdwAdd = padid->fdwAdd;

	    return MMSYSERR_NOERROR;
	}
    }

    return MMSYSERR_INVALHANDLE;
}
	

//--------------------------------------------------------------------------;
//
//  DWORD acmMessage32
//
//  Description:
//
//      32-bit function dispatcher for thunks.
//
//  Arguments:
//      DWORD dwThunkId:
//
//      DWORD dw1:
//
//      DWORD dw2:
//
//      DWORD dw3:
//
//      DWORD dw4:
//
//	DWORD dw5:
//
//  Return (DWORD):
//
//  History:
//
//--------------------------------------------------------------------------;

#ifdef WIN4
DWORD WINAPI acmMessage32
#else
DWORD acmMessage32
#endif
(
    DWORD dwThunkId,
    DWORD dw1,
    DWORD dw2,
    DWORD dw3,
    DWORD dw4,
    DWORD dw5
)
{
    // DPF(4,"acmMessage32(dwThunkId=%08lxh, dw1=%08lxh, dw2=%08lxh, dw3=%08lxh, dw4=%08lxh, dw5=%08lxh);", dwThunkId, dw1, dw2, dw3, dw4, dw5);
#ifndef WIN4
    //
    //  Make sure we've got thunking functionality
    //

    if (ThunksInitialized <= 0) {

        HMODULE hMod;

        if (ThunksInitialized == -1) {
            return MMSYSERR_ERROR;
        }

        hMod = GetModuleHandle(GET_MAPPING_MODULE_NAME);
        if (hMod != NULL) {

            GetVdmPointer =
                (LPGETVDMPOINTER)GetProcAddress(hMod, GET_VDM_POINTER_NAME);
            lpWOWHandle32 =
                (LPWOWHANDLE32)GetProcAddress(hMod, GET_HANDLE_MAPPER32 );
            lpWOWHandle16 =
                (LPWOWHANDLE16)GetProcAddress(hMod, GET_HANDLE_MAPPER16 );
        }

        if ( GetVdmPointer == NULL
          || lpWOWHandle16 == NULL
          || lpWOWHandle32 == NULL ) {

            ThunksInitialized = -1;
            return MMSYSERR_ERROR;

        } else {
            ThunksInitialized = 1;
        }
    }
#endif


    //
    //  Perform the requested function
    //

    switch (dwThunkId) {

        case acmThunkDriverMessageId32:
            return (DWORD)IDriverMessageId32(
                              (HACMDRIVERID)dw1,
                              (UINT)dw2,
                              (LPARAM)dw3,
                              (LPARAM)dw4);

        case acmThunkDriverMessage32:
            return (DWORD)IDriverMessage32(
                              (HACMDRIVER)dw1,
                              (UINT)dw2,
                              (LPARAM)dw3,
                              (LPARAM)dw4);

	case acmThunkDriverGetNext32:
	{
	    PACMGARB	            pag;
	    HACMDRIVERID UNALIGNED* lphadidNext;
	    HACMDRIVERID            hadid;
	    DWORD	            fdwGetNext;
	    HACMDRIVERID            hadidNext;
	    DWORD	            dwReturn;

	    pag = pagFind();
	    if (NULL == pag)
	    {
		DPF(0, "acmThunkDriverGetNext32: NULL pag!!!");
		return (MMSYSERR_ERROR);
	    }

	    //
	    //	parameters from 16-bit side
	    //
	    lphadidNext	= (HACMDRIVERID UNALIGNED*)ptrFixMap16To32((PVOID)dw1);
	    hadid	= (HACMDRIVERID)dw2;
	    fdwGetNext	= (DWORD)dw3;
	
	    //
	    //	in parameters
	    //	    hadid
	    //	    fdwGetNext
	    //
	    //	out parameters
	    //	    lphadidNext	    *
	    //
	    //	* Need to use aligned buffers, therefore use local buffers
	    //

	    dwReturn = (DWORD)IDriverGetNext32(pag,
					       &hadidNext,
					       hadid,
					       fdwGetNext);

	    //
	    //	Copy output data from aligned buffers to unaligned
	    //	buffers (on 16-bit side).
	    //
	    *lphadidNext = hadidNext;

	    //
	    //	Unmap pointers from 16-bit side
	    //
	    ptrUnFix16((PVOID)dw1);

	    return (dwReturn);
	}

	case acmThunkDriverGetInfo32:
	{
	    PACMGARB	             pag;
	    HACMDRIVERID             hadid;
	    LPSTR	             lpstrAlias;
	    ACMDRIVERPROC UNALIGNED* lpfnDriverProc;
	    DWORD UNALIGNED*	     lpdnDevNode;
	    DWORD UNALIGNED*         lpfdwAdd;
	    ACMDRIVERPROC            fnDriverProc;
	    DWORD                    dnDevNode;
	    DWORD                    fdwAdd;
	    DWORD	             dwReturn;

	    pag = pagFind();
	    if (NULL == pag)
	    {
		DPF(0, "acmDriverGetInfo32: NULL pag!!!");
		return (MMSYSERR_ERROR);
	    }

	    //
	    //	parameters from 16-bit side
	    //
	    hadid	    = (HACMDRIVERID)dw1;
	    lpstrAlias	    = (LPSTR)ptrFixMap16To32((PVOID)dw2);
	    lpfnDriverProc  = (ACMDRIVERPROC UNALIGNED*)ptrFixMap16To32((PVOID)dw3);
	    lpdnDevNode	    = (DWORD UNALIGNED*)ptrFixMap16To32((PVOID)dw4);
	    lpfdwAdd	    = (DWORD UNALIGNED*)ptrFixMap16To32((PVOID)dw5);

	    //
	    //	in parameters
	    //	    hadid
	    //
	    //	out parameters
	    //	    lpstrAlias
	    //	    lpfnDriverProc  *
	    //	    lpdnDevNode	    *
	    //	    lpfdwAdd	    *
	    //
	    //	* Need to use aligned buffers, therefore use local buffers
	    //

	    //
	    //	make the call
	    //
	    dwReturn = (DWORD)IDriverGetInfo32(pag, hadid, lpstrAlias, &fnDriverProc, &dnDevNode, &fdwAdd);

	    //
	    //	Copy output data from aligned buffers to unaligned
	    //	buffers (on 16-bit side).
	    //
	    *lpfnDriverProc = fnDriverProc;
	    *lpdnDevNode    = dnDevNode;
	    *lpfdwAdd       = fdwAdd;

	    //
	    //	Unmap pointers from 16-bit side
	    //
	    ptrUnFix16((PVOID)dw5);
	    ptrUnFix16((PVOID)dw4);
	    ptrUnFix16((PVOID)dw3);
	    ptrUnFix16((PVOID)dw2);

	    return dwReturn;
	}

        case acmThunkDriverLoad32:
        {
	    PACMGARB	    pag;
            PACMDRIVERID    padid;

            //
            //
            //
	    pag = pagFind();
	    if (NULL == pag)
	    {
		DPF(1, "acmThunkDriverLoad32: NULL pag!!!");
		return (DWORD)(MMSYSERR_ERROR);
	    }
	
            for (padid = pag->padidFirst;
                 padid != NULL;
                 padid = padid->padidNext)
            {
		if (padid == (PACMDRIVERID)(dw1))
		{
		    return (MMSYSERR_NOERROR);
		}
            }
            return (DWORD)(MMSYSERR_NODRIVER);
        }

	case acmThunkDriverOpen32:
            return (DWORD)IDriverOpen32(
                              (HACMDRIVER UNALIGNED *)dw1,
                              (HACMDRIVERID)dw2,
                              (DWORD)dw3);

        case acmThunkDriverClose32:

            //
            //  Call close directly
            //
            return (DWORD)IDriverClose((HACMDRIVER)dw1, dw2);

	case acmThunkDriverPriority32:
	    return (DWORD)IDriverPriority( (PACMGARB)((PACMDRIVERID)dw1)->pag,
					   (PACMDRIVERID)dw1,
					   (DWORD)dw2,
					   (DWORD)dw3 );
	
	case acmThunkFindAndBoot32:
	{
	    PACMGARB	pag;
	
	    //
	    //
	    //
	    pag = pagFind();
	    if (NULL == pag)
	    {
		DPF(1, "acmThunkFindAndBoot32: NULL pag!!!");
		return (DWORD)(MMSYSERR_ERROR);
	    }

	    if (NULL == pag->lpdw32BitChangeNotify)
	    {
		pag->lpdw32BitChangeNotify = ptrFixMap16To32((PVOID)dw1);
	    }
	
	    pagFindAndBoot();
	
	    return (DWORD)(MMSYSERR_NOERROR);
	}

    }
    return MMSYSERR_NOTSUPPORTED;       // None of the switchs hit.  Return not supported
}

#else // !WIN32

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
//  MMRESULT acmBootDrivers32
//
//  Description:
//
//  Arguments:
//	PACMGARB pag:
//
//  Return (MMRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;
MMRESULT FNGLOBAL pagFindAndBoot32
(
    PACMGARB pag
)
{
    MMRESULT mmr;

    DPF(5,"pagFindAndBoot32();");

#ifdef WIN4
    mmr = (MMRESULT) acmMessage32(acmThunkFindAndBoot32,
				  (DWORD)(LPUINT)&pag->dw32BitChangeNotify,
				  (DWORD)0,
				  (DWORD)0,
				  (DWORD)0,
				  (DWORD)0 );

#else
    mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkFindAndBoot32,
					      (DWORD)(LPUINT)&pag->dw32BitChangeNotify,
					      (DWORD)0,
					      (DWORD)0,
					      (DWORD)0,
					      (DWORD)0,
					      pag->lpvAcmThunkEntry,
					      0L,    // Don't map pointers
					      6L);
#endif

    return mmr;
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetNext32
//
//  Description:
//	Called on 16-bit side of thunk to get the next 32-bit hadid in the
//	32-bit driver list.
//
//  Arguments:
//	PACMGARB pag:
//
//      LPDWORD phadid32Next:
//
//      DWORD hadid:
//
//      DWORD fdwGetNext:
//
//  Return (MMRESULT):
//
//  History:
//      06/25/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverGetNext32
(
    PACMGARB		    pag,
    LPDWORD		    phadid32Next,
    DWORD		    hadid32,
    DWORD                   fdwGetNext
)
{
    MMRESULT mmr;

    DPF(5,"IDriverGetNext32();");

#ifdef WIN4
    mmr = (MMRESULT) acmMessage32(acmThunkDriverGetNext32,
				  (DWORD)phadid32Next,
				  (DWORD)hadid32,
				  (DWORD)fdwGetNext,
				  (DWORD)0,
				  (DWORD)0 );

#else
    mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverGetNext32,
					      (DWORD)phadid32Next,
					      (DWORD)hadid32,
					      (DWORD)fdwGetNext,
					      (DWORD)0,
					      (DWORD)0,
					      pag->lpvAcmThunkEntry,
					      0L,    // Don't map pointers
					      6L);
#endif

    return mmr;
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetInfo32
//
//  Description:
//	16-bit side.  Gets the alias and the add flags for a 32-bit hadid.
//
//  Arguments:
//	PACMGARB pag:
//
//      DWORD hadid32:
//
//	LPSTR lpstrAlias:
//
//	LPACMDRIVERPROC lpfnDriverProc:
//
//      LPDWORD lpfdwAdd:
//
//  Return (MMRESULT):
//
//  History:
//      06/25/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverGetInfo32
(
    PACMGARB		pag,
    DWORD		hadid32,
    LPSTR		lpstrAlias,
    LPACMDRIVERPROC	lpfnDriverProc,
    LPDWORD		lpdnDevNode,
    LPDWORD		lpfdwAdd
)
{
    MMRESULT mmr;

    DPF(5,"IDriverGetInfo32();");

#ifdef WIN4
    mmr = (MMRESULT) acmMessage32(acmThunkDriverGetInfo32,
				  (DWORD)hadid32,
				  (DWORD)lpstrAlias,
				  (DWORD)lpfnDriverProc,
				  (DWORD)lpdnDevNode,
				  (DWORD)lpfdwAdd);

#else
    mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverGetInfo32,
					      (DWORD)hadid32,
					      (DWORD)lpstrAlias,
					      (DWORD)lpfnDriverProc,
					      (DWORD)lpdnDevNode,
					      (DWORD)lpfdwAdd,
					      pag->lpvAcmThunkEntry,
					      0L,    // Don't map pointers
					      6L);
#endif

    return mmr;
}


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverPriority32
//
//  Description:
//	16-bit side.
//
//  Arguments:
//	PACMGARB pag:
//
//      DWORD padid32:
//
//	DWORD dwPriority:
//
//	DWORD fdwPriority:
//
//  Return (MMRESULT):
//
//  History:
//      10/28/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;
MMRESULT FNGLOBAL IDriverPriority32
(
    PACMGARB	pag,
    DWORD       padid32,
    DWORD	dwPriority,
    DWORD	fdwPriority
)
{
    MMRESULT mmr;

    DPF(5,"IDriverPriority32();");

#ifdef WIN4
    mmr = (MMRESULT) acmMessage32(acmThunkDriverPriority32,
				  (DWORD)padid32,
				  (DWORD)dwPriority,
				  (DWORD)fdwPriority,
				  (DWORD)0,
				  (DWORD)0);

#else
    mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverPriority32,
					      (DWORD)padid32,
					      (DWORD)dwPriority,
					      (DWORD)fdwPriority,
					      (DWORD)0,
					      (DWORD)0,
					      pag->lpvAcmThunkEntry,
					      0L,    // Don't map pointers
					      6L);
#endif

    return mmr;
}


//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessageId32
//
//  Description:
//
//      Pass a message to a 32-bit driver using the driver id.
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverMessageId32
(
    DWORD               hadid,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    LRESULT lr;

    DPF(5,"IDriverMessageId32();");

#ifdef WIN4
    lr = acmMessage32(acmThunkDriverMessageId32,
		      (DWORD)hadid,
		      (DWORD)uMsg,
		      (DWORD)lParam1,
		      (DWORD)lParam2,
		      (DWORD)0 );

#else
    {
        PACMGARB pag;

        pag = pagFind();
        lr = (LRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverMessageId32,
					        (DWORD)hadid,
					        (DWORD)uMsg,
					        (DWORD)lParam1,
					        (DWORD)lParam2,
					        (DWORD) 0,
					        pag->lpvAcmThunkEntry,
					        0L,    // Don't map pointers
					        6L);
    }
#endif

    return lr;
}


//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessage32
//
//  Description:
//
//      Pass a message to a 32-bit driver using the instance handle.
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverMessage32
(
    DWORD               hadid,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    LRESULT lr;

    DPF(5,"IDriverMessage32();");

#ifdef WIN4
    lr = acmMessage32(acmThunkDriverMessage32,
		      (DWORD)hadid,
		      (DWORD)uMsg,
		      (DWORD)lParam1,
		      (DWORD)lParam2,
		      (DWORD)0 );

#else
    {
        PACMGARB pag;

        pag = pagFind();
        lr = (LRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverMessage32,
					        (DWORD)hadid,
					        (DWORD)uMsg,
					        (DWORD)lParam1,
					        (DWORD)lParam2,
					        (DWORD)0,
					        pag->lpvAcmThunkEntry,
					        0L,    // Don't map pointers
					        6L);
    }
#endif

    return (lr);

}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverLoad32
//
//  Description:
//
//      Load a 32-bit ACM driver (actually just find its hadid)
//
//  Arguments:
//	DWORD hadid32:
//      DWORD  fdwFlags
//
//  Return (HDRVR):
//
//  History:
//
//--------------------------------------------------------------------------;
MMRESULT FNGLOBAL IDriverLoad32
(
    DWORD   hadid32,
    DWORD   fdwFlags
)
{
#ifdef WIN4
    MMRESULT mmr;

    DPF(5,"IDriverLoad(hadid32=%08lxh,fdwFlags=%08lxh);", hadid32, fdwFlags);

    mmr = (MMRESULT)acmMessage32(acmThunkDriverLoad32,
				 (DWORD)hadid32,
				 (DWORD)fdwFlags,
				 (DWORD)0L,
				 (DWORD)0L,
				 (DWORD)0L );

#else
    MMRESULT mmr;
    PACMGARB pag;

    DPF(5,"IDriverLoad(hadid32=%08lxh,fdwFlags=%08lxh);", hadid32, fdwFlags);

    pag = pagFind();
    mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverLoad32,
					      (DWORD)hadid32,
					      (DWORD)fdwFlags,
					      (DWORD)0L,
					      (DWORD)0L,
					      (DWORD)0L,
					      pag->lpvAcmThunkEntry,
					      0L,    // Don't map pointers
					      6L);

#endif

    return (mmr);
}

//--------------------------------------------------------------------------;
//
//  MMERESULT IDriverOpen32
//
//  Description:
//
//      Open a 32-bit ACM driver
//
//  Arguments:
//      LPHACMDRIVER lphadNew:
//
//      HACMDRIVERID hadid:
//
//      DWORD fdwOpen:
//
//  Return (MMRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverOpen32
(
    LPDWORD             lphadNew,
    DWORD               hadid,
    DWORD               fdwOpen
)
{
    MMRESULT mmr;

    DPF(5,"IDriverOpen32();");

#ifdef WIN4
    mmr = (MMRESULT)acmMessage32(acmThunkDriverOpen32,
				 (DWORD)lphadNew,
				 (DWORD)hadid,
				 (DWORD)fdwOpen,
				 (DWORD)0L,
				 (DWORD)0L );

#else
    {
        PACMGARB pag;

        pag = pagFind();
        mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverOpen32,
						  (DWORD)lphadNew,
						  (DWORD)hadid,
						  (DWORD)fdwOpen,
						  (DWORD)0L,
						  (DWORD)0L,
						  pag->lpvAcmThunkEntry,
						  0L,    // Don't map pointers
						  6L);
    }
#endif

    return (mmr);

}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverClose32
//
//  Description:
//
//      Cloase a 32-bit ACM driver
//
//  Arguments:
//      HDRVR hdrvr:
//
//      DWORD fdwClose:
//
//  Return (MMRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverClose32
(
    DWORD               hdrvr,
    DWORD               fdwClose
)
{
#ifdef WIN4
    LRESULT lr;

    DPF(5,"IDriverClose32();");

    lr = acmMessage32(acmThunkDriverClose32,
		      (DWORD)hdrvr,
		      (DWORD)fdwClose,
		      (DWORD)0L,
		      (DWORD)0L,
		      (DWORD)0L);

#else
    LRESULT lr;
    PACMGARB pag;

    DPF(5,"IDriverClose32();");

    pag = pagFind();
    lr = (LRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverClose32,
					    (DWORD)hdrvr,
					    (DWORD)fdwClose,
					    (DWORD)0L,
					    (DWORD)0L,
					    (DWORD)0L,
					    pag->lpvAcmThunkEntry,
					    0L,    // Don't map pointers
					    6L);

#endif

    return (lr);

}


#endif // !WIN32

#endif // !_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\acmfmt.c ===
/****************************************************************************
 *
 *   acmfmt.c
 *
 *   Copyright (c) 1991-1998 Microsoft Corporation
 *
 *   This module provides the wave format enumeration and string API's.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include "msacm.h"
#include "msacmdrv.h"
#include <stdlib.h>
#include "acmi.h"
#include "pcm.h"
#include "uchelp.h"
#include "debug.h"



/**************************************************************
 *
 *  Special case PCM enumeration for no codec case.
 *
 **************************************************************/


#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))

//
//  array of _standard_ sample rates supported
//
//
static const UINT auFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

#define CODEC_MAX_SAMPLE_RATES  SIZEOF_ARRAY(auFormatIndexToSampleRate)

//
//
//
//
#define CODEC_MAX_CHANNELS      (MSPCM_MAX_CHANNELS)

//
//  array of bits per sample supported
//
//
static const UINT auFormatIndexToBitsPerSample[] =
{
    8,
    16
};

#define CODEC_MAX_BITSPERSAMPLE_PCM SIZEOF_ARRAY(auFormatIndexToBitsPerSample)




//
//  number of formats we enumerate per channels is number of sample rates
//  times number of channels times number of
//  (bits per sample) types.
//
#define CODEC_MAX_STANDARD_FORMATS_PCM  (CODEC_MAX_SAMPLE_RATES *   \
                                         CODEC_MAX_CHANNELS *       \
                                         CODEC_MAX_BITSPERSAMPLE_PCM)

//
//
//
#ifdef WIN32
WCHAR BCODE gszWavemapper[] = L"wavemapper";
#else
char  BCODE gszWavemapper[] = "wavemapper";
#endif






/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types WAVEFORMATEX | The <t WAVEFORMATEX> structure defines the
 *      format of waveform data. Only format information common to all
 *      waveform data formats is included in this structure. For formats
 *      that require additional information, this structure is included
 *      as the first member in another structure, along with the additional
 *      information.
 *
 *  @field WORD | wFormatTag | Specifies the waveform format type. Format
 *      tags are registered with Microsoft for many compression algorithms.
 *      A complete list of format tags can be found in the MMREG.H header
 *      file available from Microsoft. For more information on format
 *      tags, contact Microsoft for availability of the Multimedia Developer
 *      Registration Kit:
 *
 *          Microsoft Corporation
 *          Advanced Consumer Technology
 *          Product Marketing
 *          One Microsoft Way
 *          Redmond, WA 98052-6399
 *
 *  @field WORD | nChannels | Specifies the number of channels in the
 *      waveform data. Monaural data uses one channel and stereo data uses
 *      two channels.
 *
 *  @field DWORD | nSamplesPerSec | Specifies the sample rate, in samples
 *      per second (Hertz), that each channel should be played or recorded.
 *      If <e WAVEFORMATEX.wFormatTag> is WAVE_FORMAT_PCM, then common values
 *      for <e WAVEFORMATEX.nSamplesPerSec> are 8.0 kHz, 11.025 kHz,
 *      22.05 kHz, and 44.1 kHz. For non-PCM formats, this member must be
 *      computed according to the manufacturer's specification of the format
 *      tag.
 *
 *  @field DWORD | nAvgBytesPerSec | Specifies the required average
 *      data-transfer rate, in bytes per second, for the format tag. If
 *      <e WAVEFORMATEX.wFormatTag> is WAVE_FORMAT_PCM, then
 *      <e WAVEFORMATEX.nAvgBytesPerSec> should be equal to the product
 *      of <e WAVEFORMATEX.nSamplesPerSec> and <e WAVEFORMATEX.nBlockAlign>.
 *      For non-PCM formats, this member must be computed according to the
 *      manufacturer's specification of the format tag.
 *
 *      Playback and record software can estimate buffer sizes using the
 *      <e WAVEFORMATEX.nAvgBytesPerSec> member.
 *
 *  @field WORD | nBlockAlign | Specifies the block alignment, in bytes.
 *      The block alignment is the minimum atomic unit of data for the
 *      <e WAVEFORMATEX.wFormatTag>. If <e WAVEFORMATEX.wFormatTag> is
 *      WAVE_FORMAT_PCM, then <e WAVEFORMATEX.nBlockAlign> should be equal
 *      to the product of <e WAVEFORMATEX.nChannels> and
 *      <e WAVEFORMATEX.wBitsPerSample> divided by 8 (bits per byte).
 *      For non-PCM formats, this member must be computed according to the
 *      manufacturer's specification of the format tag.
 *
 *      Playback and record software must process a multiple of
 *      <e WAVEFORMATEX.nBlockAlign> bytes of data at a time. Data written
 *      and read from a device must always start at the beginning of a
 *      block. For example, it is illegal to start playback of PCM data
 *      in the middle of a sample (that is, on a non-block-aligned boundary).
 *
 *  @field WORD | wBitsPerSample | Specifies the bits per sample for the
 *      <e WAVEFORMATEX.wFormatTag>. If <e WAVEFORMATEX.wFormatTag> is
 *      WAVE_FORMAT_PCM, then <e WAVEFORMATEX.wBitsPerSample> should be
 *      equal to 8 or 16. For non-PCM formats, this member must be set
 *      according to the manufacturer's specification of the format tag.
 *      Note that some compression schemes cannot define a value for
 *      <e WAVEFORMATEX.wBitsPerSample>, so this member can be zero.
 *
 *  @field WORD | cbSize | Specifies the size, in bytes, of extra format
 *      information appended to the end of the <t WAVEFORMATEX> structure.
 *      This information can be used by non-PCM formats to store extra
 *      attributes for the <e WAVEFORMATEX.wFormatTag>. If no extra
 *      information is required by the <e WAVEFORMATEX.wFormatTag>, then
 *      this member must be set to zero. Note that for WAVE_FORMAT_PCM
 *      formats (and only WAVE_FORMAT_PCM formats), this member is ignored.
 *
 *      An example of a format that uses extra information is the
 *      Microsoft Adaptive Delta Pulse Code Modulation (MS-ADPCM) format.
 *      The <e WAVEFORMATEX.wFormatTag> for MS-ADPCM is WAVE_FORMAT_ADPCM.
 *      The <e WAVEFORMATEX.cbSize> member will normally be set to 32.
 *      The extra information stored for WAVE_FORMAT_ADPCM is coefficient
 *      pairs required for encoding and decoding the waveform data.
 *
 *  @tagname tWAVEFORMATEX
 *
 *  @othertype WAVEFORMATEX FAR * | LPWAVEFORMATEX | A pointer to a
 *      <t WAVEFORMATEX> structure.
 *
 *  @xref <t WAVEFORMAT> <t PCMWAVEFORMAT> <t WAVEFILTER>
 *
 ****************************************************************************/


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api DWORD | acmGetVersion | This function returns the version number of the Audio
 *      Compression Manager (ACM).
 *
 *  @rdesc The version number is returned as a hexadecimal number of the form
 *      0xAABBCCCC, where AA is the major version number, BB is the minor
 *      version number, and CCCC is the build number.
 *
 *  @comm An application must verify that the ACM version is at least
 *      0x02000000 or greater before attempting to use any other ACM
 *      functions. Versions earlier than version 2.00 of the ACM only support
 *      <f acmGetVersion>. Also note that the build number (CCCC) is always
 *      zero for the retail (non-debug) version of the ACM. The debug
 *      version of the ACM will always return a non-zero value for the
 *      build number.
 *
 *  @ex To display the ACM version for a user, an application
 *      should use the following format (note that the values should be printed
 *      as unsigned decimals). |
 *      {
 *          DWORD   dw;
 *          char    ach[10];
 *
 *          dw = acmGetVersion();
 *          wsprintf(ach, "%u.%.02u", HIWORD(dw) >> 8, HIWORD(dw) & 0x00FF);
 *      }
 *
 ***************************************************************************/

DWORD ACMAPI acmGetVersion(void)
{
    //
    //	We only do pagFind instead of pagFindAndBoot cuz there's no real
    //	to get the driver's booted just for a version call.
    //
    if (NULL == pagFind())
    {
	DPF(1, "acmGetVersion: NULL pag!!!");
	return (0);
    }

    DPF(3, "acmGetVersion() called--returning Version %u.%.02u.%.03u",
        VERSION_MSACM_MAJOR,
        VERSION_MSACM_MINOR,
        VERSION_MSACM_BUILD);

    return (VERSION_MSACM);
}


//--------------------------------------------------------------------------;
//
//  MMRESULT IMetricsMaxSizeFormat
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag: Can be NULL if caller doesn't have one available
//	    to pass.
//
//	HACMOBJECT had:
//
//	LPDWORD pdwSize:
//
//  Return (MMRESULT):
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IMetricsMaxSizeFormat
(
    PACMGARB		pag,	    // NULL is OK.
    HACMDRIVER          had,        // NULL is OK.
    LPDWORD             pdwSize
)
{
    PACMDRIVERID	padid;
    DWORD		cbFormatSizeLargest;
    UINT		u;

    ASSERT( NULL != pdwSize );

    if (NULL == pag) {
	pag = pagFind();
    }
    ASSERT( NULL != pag );


    cbFormatSizeLargest = 0;

    if (NULL == had)
    {
	HACMDRIVERID	hadid;
	
	hadid = NULL;
	while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
	{
	    padid = (PACMDRIVERID)hadid;

	    for (u=0; u<padid->cFormatTags; u++)
	    {
		if (padid->paFormatTagCache[u].cbFormatSize > cbFormatSizeLargest)
		{
		    cbFormatSizeLargest = padid->paFormatTagCache[u].cbFormatSize;
		}
	    }
	}
    }
    else
    {
        V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

        if (TYPE_HACMDRIVERID == ((PACMDRIVER)had)->uHandleType)
        {
            padid = (PACMDRIVERID)had;
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
            padid = (PACMDRIVERID)((PACMDRIVER)had)->hadid;
        }
	

	for (u=0; u<padid->cFormatTags; u++)
	{
	    if (padid->paFormatTagCache[u].cbFormatSize > cbFormatSizeLargest)
	    {
		cbFormatSizeLargest = padid->paFormatTagCache[u].cbFormatSize;
	    }
	}
    }


    *pdwSize = cbFormatSizeLargest;

    return ( 0 == cbFormatSizeLargest ? ACMERR_NOTPOSSIBLE : MMSYSERR_NOERROR );

}


//--------------------------------------------------------------------------;
//
//  MMRESULT IMetricsMaxSizeFilter
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag: Can be NULL if caller doesn't have one available
//	    to pass.
//
//	HACMOBJECT had:
//
//	LPDWORD pdwSize:
//
//  Return (MMRESULT):
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IMetricsMaxSizeFilter
(
    PACMGARB		pag,	    // NULL is OK.
    HACMDRIVER          had,        // NULL is OK.
    LPDWORD             pdwSize
)
{
    PACMDRIVERID	padid;
    DWORD		cbFilterSizeLargest;
    UINT		u;

    ASSERT( NULL != pdwSize );

    if (NULL == pag) {
	pag = pagFind();
    }
    ASSERT( NULL != pag );


    cbFilterSizeLargest = 0;

    if (NULL == had)
    {
	HACMDRIVERID	hadid;
	
	hadid = NULL;
	while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
	{
	    padid = (PACMDRIVERID)hadid;

	    for (u=0; u<padid->cFilterTags; u++)
	    {
		if (padid->paFilterTagCache[u].cbFilterSize > cbFilterSizeLargest)
		{
		    cbFilterSizeLargest = padid->paFilterTagCache[u].cbFilterSize;
		}
	    }
	}
    }
    else
    {
        V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

        if (TYPE_HACMDRIVERID == ((PACMDRIVER)had)->uHandleType)
        {
            padid = (PACMDRIVERID)had;
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
            padid = (PACMDRIVERID)((PACMDRIVER)had)->hadid;
        }
	

	for (u=0; u<padid->cFilterTags; u++)
	{
	    if (padid->paFilterTagCache[u].cbFilterSize > cbFilterSizeLargest)
	    {
		cbFilterSizeLargest = padid->paFilterTagCache[u].cbFilterSize;
	    }
	}
    }


    *pdwSize = cbFilterSizeLargest;

    return ( 0 == cbFilterSizeLargest ? ACMERR_NOTPOSSIBLE : MMSYSERR_NOERROR );

}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmMetrics | This function returns various metrics for the Audio
 *      Compression Manager (ACM) or related ACM objects.
 *
 *  @parm HACMOBJ | hao | Specifies the ACM object to query for the metric
 *      specified in <p uMetric>. This argument may be NULL for some
 *      queries.
 *
 *  @parm UINT | uMetric | Specifies the metric index to be returned in
 *      <p pMetric>.
 *
 *      @flag ACM_METRIC_COUNT_DRIVERS | Specifies that the returned value is
 *      the total number of enabled global ACM drivers (of all support types)
 *      in the system. The <p hao> argument must be NULL for this metric
 *      index. The <p pMetric> argument must point to buffer of size equal
 *      to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_CODECS | Specifies that the returned value is
 *      the number of global ACM compressor or decompressor drivers in
 *      the system. The <p hao> argument must be NULL for this metric index.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD.
 *
 *      @flag ACM_METRIC_COUNT_CONVERTERS | Specifies that the returned value
 *      is the number of global ACM converter drivers in the system. The
 *      <p hao> argument must be NULL for this metric index. The <p pMetric>
 *      argument must point to a buffer of a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_FILTERS | Specifies that the returned value
 *      is the number of global ACM filter drivers in the system. The <p hao>
 *      argument must be NULL for this metric index. The <p pMetric> argument
 *      must point to buffer of size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_DISABLED | Specifies that the returned value
 *      is the total number of global disabled ACM drivers (of all support
 *      types) in the system. The <p hao> argument must be NULL for this
 *      metric index. The <p pMetric> argument must point to a buffer of a size
 *      equal to a DWORD. The sum of the ACM_METRIC_COUNT_DRIVERS and
 *      ACM_METRIC_COUNT_DISABLED metrics is the total number of globally
 *      installed ACM drivers.
 *
 *      @flag ACM_METRIC_COUNT_HARDWARE | Specifies that the returned value
 *      is the number of global ACM hardware drivers in the system. The <p hao>
 *      argument must be NULL for this metric index. The <p pMetric> argument
 *      must point to buffer of size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_LOCAL_DRIVERS | Specifies that the returned
 *      value is the total number of enabled local ACM drivers (of all
 *      support types) for the calling task. The <p hao> argument must be
 *      NULL for this metric index. The <p pMetric> argument must point to
 *      a buffer of a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_LOCAL_CODECS | Specifies that the returned
 *      value is the number of local ACM compressor and/or decompressor
 *      drivers for the calling task. The <p hao> argument must be NULL for
 *      this metric index. The <p pMetric> argument must point to a buffer of
 *      a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_LOCAL_CONVERTERS | Specifies that the returned
 *      value is the number of local ACM converter drivers for the calling
 *      task. The <p hao> argument must be NULL for this metric index. The
 *      <p pMetric> argument must point to a buffer of a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_LOCAL_FILTERS | Specifies that the returned
 *      value is the number of local ACM filter drivers for the calling
 *      task. The <p hao> argument must be NULL for this metric index. The
 *      <p pMetric> argument must point to a buffer of a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_LOCAL_DISABLED | Specifies that the returned
 *      value is the total number of local disabled ACM drivers, of all
 *      support types, for the calling task. The <p hao> argument must be
 *      NULL for this metric index. The <p pMetric> argument must point to a
 *      buffer of a size equal to a DWORD. The sum of the
 *      ACM_METRIC_COUNT_LOCAL_DRIVERS and ACM_METRIC_COUNT_LOCAL_DISABLED
 *      metrics is the total number of locally installed ACM drivers.
 *
 *      @flag ACM_METRIC_HARDWARE_WAVE_INPUT | Specifies that the returned
 *      value is the waveform input device identifier associated with the
 *      specified driver. The <p hao> argument must be a valid ACM driver
 *      identifier (<t HACMDRIVERID>) that supports the
 *      ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no waveform input device
 *      is associated with the driver, then MMSYSERR_NOTSUPPORTED is returned.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD.
 *
 *      @flag ACM_METRIC_HARDWARE_WAVE_OUTPUT | Specifies that the returned
 *      value is the waveform output device identifier associated with the
 *      specified driver. The <p hao> argument must be a valid ACM driver
 *      identifier (<t HACMDRIVERID>) that supports the
 *      ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no waveform output device
 *      is associated with the driver, then MMSYSERR_NOTSUPPORTED is returned.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD.
 *
 *      @flag ACM_METRIC_MAX_SIZE_FORMAT | Specifies that the returned value
 *      is the size of the largest <t WAVEFORMATEX> structure. If <p hao>
 *      is NULL, then the return value is the largest <t WAVEFORMATEX>
 *      structure in the system. If <p hao> identifies an open instance
 *      of an ACM driver (<t HACMDRIVER>) or an ACM driver identifier
 *      (<t HACMDRIVERID>), then the largest <t WAVEFORMATEX>
 *      structure for that driver is returned. The <p pMetric> argument must
 *      point to a buffer of a size equal to a DWORD. This metric is not allowed
 *      for an ACM stream handle (<t HACMSTREAM>).
 *
 *      @flag ACM_METRIC_MAX_SIZE_FILTER | Specifies that the returned value
 *      is the size of the largest <t WAVEFILTER> structure. If <p hao>
 *      is NULL, then the return value is the largest <t WAVEFILTER> structure
 *      in the system. If <p hao> identifies an open instance of an ACM
 *      driver (<t HACMDRIVER>) or an ACM driver identifier (<t HACMDRIVERID>),
 *      then the largest <t WAVEFILTER> structure for that driver is returned.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD. This metric is not allowed for an ACM stream handle
 *      (<t HACMSTREAM>).
 *
 *      @flag ACM_METRIC_DRIVER_SUPPORT | Specifies that the returned value
 *      is the <e ACMDRIVERDETAILS.fdwSupport> flags for the specified driver.
 *      The <p hao> argument must be a valid ACM driver identifier
 *      (<t HACMDRIVERID>). The <p pMetric> argument must point to a buffer of
 *      a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_DRIVER_PRIORITY | Specifies that the returned value
 *      is the current priority for the specified driver.
 *      The <p hao> argument must be a valid ACM driver identifier
 *      (<t HACMDRIVERID>). The <p pMetric> argument must point to a buffer of
 *      a size equal to a DWORD.
 *
 *  @parm LPVOID | pMetric | Specifies a pointer to the buffer that will
 *      receive the metric details. The exact definition depends on the
 *      <p uMetric> index.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_NOTSUPPORTED | The <p uMetric> index is not supported.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The <p uMetric> index cannot be returned
 *      for the specified <p hao>.
 *
 *  @xref <f acmDriverDetails> <f acmFormatTagDetails> <f acmFormatDetails>
 *      <f acmFilterTagDetails> <f acmFilterDetails>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmMetrics
(
    HACMOBJ                 hao,
    UINT                    uMetric,
    LPVOID                  pMetric
)
{
    PACMGARB		pag;
    MMRESULT            mmr;
    DWORD               fdwSupport;
    DWORD               fdwEnum;
    PACMDRIVERID        padid;
    BOOL                f;
    HTASK               htask;


    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmMetrics: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //
    //
    if (NULL != hao)
    {
        V_HANDLE(hao, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);
    }

    //
    //
    //
    mmr = ACMERR_NOTPOSSIBLE;

    //
    //
    //
    switch (uMetric)
    {
        case ACM_METRIC_COUNT_LOCAL_DRIVERS:
        case ACM_METRIC_COUNT_DRIVERS:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
acm_Metrics_Rip_Non_Null_Handle:

                DebugErr(DBF_ERROR, "acmMetrics: ACM object handle must be NULL for specified metric.");
                *((LPDWORD)pMetric) = 0L;
                mmr = MMSYSERR_INVALHANDLE;
                break;
            }

            //
            //  include all global enabled drivers
            //
            fdwSupport = 0L;
            if (ACM_METRIC_COUNT_LOCAL_DRIVERS == uMetric)
            {
                fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
            }

            fdwEnum    = 0L;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;

        case ACM_METRIC_COUNT_LOCAL_CODECS:
        case ACM_METRIC_COUNT_CODECS:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
                goto acm_Metrics_Rip_Non_Null_Handle;
            }

            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            if (ACM_METRIC_COUNT_LOCAL_CODECS == uMetric)
            {
                fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
            }

            fdwEnum    = 0L;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;

        case ACM_METRIC_COUNT_LOCAL_CONVERTERS:
        case ACM_METRIC_COUNT_CONVERTERS:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
                goto acm_Metrics_Rip_Non_Null_Handle;
            }

            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CONVERTER;
            if (ACM_METRIC_COUNT_LOCAL_CONVERTERS == uMetric)
            {
                fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
            }

            fdwEnum    = 0L;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;

        case ACM_METRIC_COUNT_LOCAL_FILTERS:
        case ACM_METRIC_COUNT_FILTERS:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
                goto acm_Metrics_Rip_Non_Null_Handle;
            }

            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_FILTER;
            if (ACM_METRIC_COUNT_LOCAL_FILTERS == uMetric)
            {
                fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
            }

            fdwEnum    = 0L;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;

        case ACM_METRIC_COUNT_LOCAL_DISABLED:
        case ACM_METRIC_COUNT_DISABLED:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
                goto acm_Metrics_Rip_Non_Null_Handle;
            }

            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_DISABLED;
            if (ACM_METRIC_COUNT_LOCAL_DISABLED == uMetric)
            {
                fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
            }

            fdwEnum    = ACM_DRIVERENUMF_DISABLED;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;


        case ACM_METRIC_COUNT_HARDWARE:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
                goto acm_Metrics_Rip_Non_Null_Handle;
            }

            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_HARDWARE;
            fdwEnum    = 0L;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;


        case ACM_METRIC_HARDWARE_WAVE_INPUT:
        case ACM_METRIC_HARDWARE_WAVE_OUTPUT:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            *((LPDWORD)pMetric) = (DWORD)-1L;

            V_HANDLE(hao, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

            f = (ACM_METRIC_HARDWARE_WAVE_INPUT == uMetric);
            mmr = IDriverGetWaveIdentifier((HACMDRIVERID)hao, pMetric, f);
            break;


        case ACM_METRIC_MAX_SIZE_FORMAT:

            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            mmr = IMetricsMaxSizeFormat( pag, (HACMDRIVER)hao, (LPDWORD)pMetric );

            break;


        case ACM_METRIC_MAX_SIZE_FILTER:

            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            mmr = IMetricsMaxSizeFilter( pag, (HACMDRIVER)hao, (LPDWORD)pMetric );

            break;


        case ACM_METRIC_DRIVER_SUPPORT:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            *((LPDWORD)pMetric) = 0L;

            V_HANDLE(hao, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

            mmr = IDriverSupport((HACMDRIVERID)hao, pMetric, TRUE);
            break;

        case ACM_METRIC_DRIVER_PRIORITY:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            *((LPDWORD)pMetric) = 0L;

            V_HANDLE(hao, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);


            //
            //  Restore the priorities, just in case some other instance
            //  has re-written them.  We don't do this if someone has
            //  the priorities lock, even if it's us!
            //
	    if (!threadQueryInListShared(pag))
	    {
		htask = GetCurrentTask();
		if( IDriverLockPriority( pag, htask, ACMPRIOLOCK_GETLOCK ) )
		{
		    ENTER_LIST_EXCLUSIVE;
            if( IDriverPrioritiesRestore(pagFind()) ) { // Something changed!
                IDriverBroadcastNotify( pag );
            }
		    LEAVE_LIST_EXCLUSIVE;

                    IDriverLockPriority( pag, htask, ACMPRIOLOCK_RELEASELOCK );
		}
            }


            padid = (PACMDRIVERID)hao;

            *((LPDWORD)pMetric) = (UINT)padid->uPriority;
            mmr = MMSYSERR_NOERROR;
            break;

        default:
            mmr = MMSYSERR_NOTSUPPORTED;
            break;
    }

    return (mmr);
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IFormatTagDetails
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//	HACMDRIVERID hadid:
//
//      LPACMFORMATTAGDETAILS pafd:
//
//	DWORD fdwDetails:
//
//  Return (UINT):
//
//  History:
//      08/31/94    frankye
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IFormatTagDetails
(
    PACMGARB		    pag,
    HACMDRIVERID	    hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    PACMDRIVERID            padid;
    UINT                    u;
    DWORD                   fdwQuery;
    MMRESULT		    mmr;

    ASSERT( NULL != pag );
    ASSERT( NULL != hadid );


    padid	= (PACMDRIVERID)hadid;
    fdwQuery	= (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails);
    mmr		= ACMERR_NOTPOSSIBLE;
	
    switch (fdwQuery)
    {
	case ACM_FORMATTAGDETAILSF_FORMATTAG:
	{
	    for (u=0; u<padid->cFormatTags; u++)
	    {
		if (padid->paFormatTagCache[u].dwFormatTag == paftd->dwFormatTag)
		{
		    mmr = MMSYSERR_NOERROR;
		    break;
		}
	    }
	    break;
	}

	case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
	case ACM_FORMATTAGDETAILSF_INDEX:
	    mmr = MMSYSERR_NOERROR;
	    break;
    }

    //
    //
    //
    if (MMSYSERR_NOERROR == mmr)
    {
	EnterHandle((HACMDRIVERID)padid);
	mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)padid,
					 ACMDM_FORMATTAG_DETAILS,
					 (LPARAM)(LPVOID)paftd,
					 fdwDetails);
	LeaveHandle((HACMDRIVERID)padid);
    }
	

    if (MMSYSERR_NOERROR != mmr)
    {
	return (mmr);
    }

    switch (paftd->dwFormatTag)
    {
	case WAVE_FORMAT_UNKNOWN:
	    DebugErr(DBF_ERROR, "IDriverGetFormatTags(): driver returned format tag 0!");
	    return (MMSYSERR_ERROR);

	case WAVE_FORMAT_PCM:
	    if ('\0' != paftd->szFormatTag[0])
	    {
		DebugErr1(DBF_WARNING, "IDriverGetFormatTags(): driver returned custom PCM format tag name (%s)! ignoring it!", (LPSTR)paftd->szFormatTag);
	    }

#if defined(WIN32) && !defined(UNICODE)
	    LoadStringW(pag->hinst,
			IDS_FORMAT_TAG_PCM,
			paftd->szFormatTag,
			SIZEOFW(paftd->szFormatTag));
#else
	    LoadString(pag->hinst,
		       IDS_FORMAT_TAG_PCM,
		       paftd->szFormatTag,
		       SIZEOF(paftd->szFormatTag));
#endif
	    break;

	case WAVE_FORMAT_DEVELOPMENT:
	    DebugErr(DBF_WARNING, "IDriverGetFormatTags(): driver returned DEVELOPMENT format tag--do not ship this way.");
	    break;

    }

    return(mmr);

}


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMFORMATTAGDETAILS | The <t ACMFORMATTAGDETAILS> structure
 *      details a wave format tag for an Audio Compression Manager (ACM)
 *      driver.
 *
 *  @field DWORD | cbStruct | Specifies the size in bytes of the
 *      <t ACMFORMATTAGDETAILS> structure. This member must be initialized
 *      before calling the <f acmFormatTagDetails> or <f acmFormatTagEnum>
 *      functions. The size specified in this member must be large enough to
 *      contain the base <t ACMFORMATTAGDETAILS> structure. When the
 *      <f acmFormatTagDetails> function returns, this member contains the
 *      actual size of the information returned. The returned information
 *      will never exceed the requested size.
 *
 *  @field DWORD | dwFormatTagIndex | Specifies the index of the format tag
 *      for which details will be retrieved. The index ranges from zero to one
 *      less than the number of format tags supported by an ACM driver. The
 *      number of format tags supported by a driver is contained in the
 *      <e ACMDRIVERDETAILS.cFormatTags> member of the <t ACMDRIVERDETAILS>
 *      structure. The <e ACMFORMATTAGDETAILS.dwFormatTagIndex> member is
 *      only used when querying format tag details on a driver by index;
 *      otherwise, this member should be zero.
 *
 *  @field DWORD | dwFormatTag | Specifies the wave format tag that the
 *      <t ACMFORMATTAGDETAILS> structure describes. This member is used
 *      as an input for the ACM_FORMATTAGDETAILSF_FORMATTAG and
 *      ACM_FORMATTAGDETAILSF_LARGESTSIZE query flags. This member is always
 *      returned if the <f acmFormatTagDetails>  function is successful. This member
 *      should be set to WAVE_FORMAT_UNKNOWN for all other query flags.
 *
 *  @field DWORD | cbFormatSize | Specifies the largest total size in bytes
 *      of a wave format of the <e ACMFORMATTAGDETAILS.dwFormatTag> type.
 *      For example, this member will be 16 for WAVE_FORMAT_PCM and 50 for
 *      WAVE_FORMAT_ADPCM.
 *
 *  @field DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the format tag. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure. This argument may be some combination of the following
 *      values and refer to what operations the driver supports with the
 *      format tag:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags where one of
 *      the tags is the specified format tag. For example, if a driver
 *      supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM,
 *      then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      specified format tag. For example, if a driver supports resampling
 *      of WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on the specified format tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified format tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output of the specified format tag
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @field DWORD | cStandardFormats | Specifies the number of standard
 *      formats of the <e ACMFORMATTAGDETAILS.dwFormatTag> type; that is, the
 *      combination of all sample rates, bits per sample, channels, and so on.
 *      This value can specify all formats supported by the driver, but not necessarily.
 *
 *  @field char | szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS] |
 *      Specifies a string that describes the <e ACMFORMATTAGDETAILS.dwFormatTag>
 *      type. This string is always returned if the <f acmFormatTagDetails>
 *      function is successful.
 *
 *  @xref <f acmFormatTagDetails> <f acmFormatTagEnum>
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatTagDetails | This function queries the Audio Compression
 *      Manager (ACM) for details on a specific wave format tag.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave format tag details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver. Note that
 *      an application must specify a valid <t HACMDRIVER> or <t HACMDRIVERID>
 *      when using the ACM_FORMATTAGDETAILSF_INDEX query type. Driver
 *      identifiers for disabled drivers are not allowed.
 *
 *  @parm LPACMFORMATTAGDETAILS | paftd | Specifies a pointer to the
 *      <t ACMFORMATTAGDETAILS> structure that is to receive the format
 *      tag details.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for getting the details.
 *
 *      @flag ACM_FORMATTAGDETAILSF_INDEX | Indicates that a format tag index
 *      was given in the <e ACMFORMATTAGDETAILS.dwFormatTagIndex> member of
 *      the <t ACMFORMATTAGDETAILS> structure. The format tag and details
 *      will be returned in the structure defined by <p paftd>. The index
 *      ranges from zero to one less than the <e ACMDRIVERDETAILS.cFormatTags>
 *      member returned in the <t ACMDRIVERDETAILS> structure for an ACM
 *      driver. An application must specify a driver handle (<p had>) when
 *      retrieving format tag details with this flag.
 *
 *      @flag ACM_FORMATTAGDETAILSF_FORMATTAG | Indicates that a format tag
 *      was given in the <e ACMFORMATTAGDETAILS.dwFormatTag> member of
 *      the <t ACMFORMATTAGDETAILS> structure. The format tag details will
 *      be returned in the structure defined by <p paftd>. If an application
 *      specifies an ACM driver handle (<p had>), then details on the format
 *      tag will be returned for that driver. If an application specifies
 *      NULL for <p had>, then the ACM finds the first acceptable driver
 *      to return the details.
 *
 *      @flag ACM_FORMATTAGDETAILSF_LARGESTSIZE | Indicates that the details
 *      on the format tag with the largest format size in bytes is to be
 *      returned. The <e ACMFORMATTAGDETAILS.dwFormatTag> member must either
 *      be WAVE_FORMAT_UNKNOWN or the format tag to find the largest size
 *      for. If an application specifies an ACM driver handle (<p had>), then
 *      details on the largest format tag will be returned for that driver.
 *      If an application specifies NULL for <p had>, then the ACM finds an
 *      acceptable driver with the largest format tag requested to return
 *      the details.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details requested are not available.
 *
 *  @xref <f acmDriverDetails> <f acmDriverOpen> <f acmFormatDetails>
 *      <f acmFormatTagEnum> <f acmFilterTagDetails>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFormatTagDetails
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    PACMGARB		    pag;
    PACMDRIVER              pad;
    HACMDRIVERID            hadid;
    PACMDRIVERID            padid;
    DWORD                   fdwQuery;
    MMRESULT		    mmr;
    UINT                    u;

    pad		= NULL;
    padid	= NULL;

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFormatTagDetails: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }


    //
    //
    //
    V_DFLAGS(fdwDetails, ACM_FORMATTAGDETAILSF_VALID, acmFormatTagDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFORMATTAGDETAILS) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatTagDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    if (0L != paftd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFormatTagDetails: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    //
    fdwQuery = (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails);

    switch (fdwQuery)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  we don't (currently) support index based enumeration across
            //  all drivers... may never support this. so validate the
            //  handle and fail if not valid (like NULL).
            //
            V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

            if (WAVE_FORMAT_UNKNOWN != paftd->dwFormatTag)
            {
                DebugErr(DBF_ERROR, "acmFormatTagDetails: dwFormatTag must be WAVE_FORMAT_UNKNOWN for index query.");
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            if (WAVE_FORMAT_UNKNOWN == paftd->dwFormatTag)
            {
                DebugErr(DBF_ERROR, "acmFormatTagDetails: dwFormatTag cannot be WAVE_FORMAT_UNKNOWN for tag query.");
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            break;


        //
        //  we don't (currently) support the requested query type--so return
        //  not supported.
        //
        default:
            DebugErr(DBF_ERROR, "acmFormatTagDetails: unknown query type specified.");
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //
    //
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

        pad = (PACMDRIVER)had;
        if (TYPE_HACMDRIVERID == pad->uHandleType)
        {
            padid = (PACMDRIVERID)pad;
	    pad	  = NULL;

            if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
            {
                DebugErr1(DBF_ERROR, "acmFormatTagDetails: driver (%.04Xh) is disabled.", padid);
                return (MMSYSERR_NOTENABLED);
            }
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
            padid = (PACMDRIVERID)pad->hadid;
        }
    }

    if (NULL == padid)
    {
	PACMDRIVERID    padidT;
	DWORD		cbFormatSizeLargest;

	padidT		    = NULL;
	cbFormatSizeLargest = 0;
	hadid = NULL;
		
	ENTER_LIST_SHARED;

	while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
	{
	    padidT = (PACMDRIVERID)hadid;
	
	    switch (fdwQuery)
	    {
		case ACM_FORMATTAGDETAILSF_FORMATTAG:
		{
		    for (u=0; u<padidT->cFormatTags; u++)
		    {
			if (padidT->paFormatTagCache[u].dwFormatTag == paftd->dwFormatTag)
			{
			    padid = padidT;
			    break;
			}
		    }
		    break;
		}

		case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
		{
		    for (u=0; u<padidT->cFormatTags; u++)
		    {
			if (WAVE_FORMAT_UNKNOWN != paftd->dwFormatTag)
			{
			    if (padidT->paFormatTagCache[u].dwFormatTag != paftd->dwFormatTag)
			    {
				continue;
			    }
			}
			if (padidT->paFormatTagCache[u].cbFormatSize > cbFormatSizeLargest)
			{
			    cbFormatSizeLargest = padidT->paFormatTagCache[u].cbFormatSize;
			    padid = padidT;
			}
		    }
		    break;
		}

		default:
		{
		    DPF(0, "!acmFormatTagDetails(): unknown query type got through param validation?!?!");
		}
	    }
	}

	LEAVE_LIST_SHARED;
    }

    if (NULL != padid)
    {

	mmr = IFormatTagDetails(pag, (HACMDRIVERID)padid, paftd, fdwDetails);
	
    }
    else
    {
	//
	//  Caller didn't pass us a driver, nor could we find a driver.
	//  Unless caller was requesting a specific format tag other than
	//  PCM, let's go ahead and return PCM.
	//

        if ((ACM_FORMATTAGDETAILSF_FORMATTAG == fdwQuery) &&
            (WAVE_FORMAT_PCM != paftd->dwFormatTag))
        {
            return (ACMERR_NOTPOSSIBLE);
        }

        paftd->dwFormatTagIndex = 0;
        paftd->dwFormatTag      = WAVE_FORMAT_PCM;
        paftd->cbFormatSize     = sizeof(PCMWAVEFORMAT);
        paftd->fdwSupport       = 0;
        paftd->cStandardFormats = CODEC_MAX_STANDARD_FORMATS_PCM;
	
#if defined(WIN32) && !defined(UNICODE)
	LoadStringW(pag->hinst,
		    IDS_FORMAT_TAG_PCM,
		    paftd->szFormatTag,
		    SIZEOFW(paftd->szFormatTag));
#else
	LoadString(pag->hinst,
		   IDS_FORMAT_TAG_PCM,
		   paftd->szFormatTag,
		   SIZEOF(paftd->szFormatTag));
#endif
	
        mmr = MMSYSERR_NOERROR;
    }

    return(mmr);

} // acmFormatTagDetails()


#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFormatTagDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT                mmr;
    ACMFORMATTAGDETAILSW    aftdW;

    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*paftd) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatTagDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    aftdW.cbStruct = sizeof(aftdW);
    memcpy(&aftdW.dwFormatTagIndex,
           &paftd->dwFormatTagIndex,
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, szFormatTag) -
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, dwFormatTagIndex));

    mmr = acmFormatTagDetailsW(had, &aftdW, fdwDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        memcpy(&paftd->dwFormatTagIndex,
               &aftdW.dwFormatTagIndex,
               FIELD_OFFSET(ACMFORMATTAGDETAILSA, szFormatTag) -
               FIELD_OFFSET(ACMFORMATTAGDETAILSA, dwFormatTagIndex));

        paftd->cbStruct = min(paftd->cbStruct, sizeof(*paftd));
        Iwcstombs(paftd->szFormatTag, aftdW.szFormatTag, sizeof(paftd->szFormatTag));
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFormatTagDetailsW
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSW  paftd,
    DWORD                   fdwDetails
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


//--------------------------------------------------------------------------;
//
//  UINT IFormatDetailsToString
//
//  Description:
//
//
//  Arguments:
//      LPACMFORMATDETAILS pafd:
//
//  Return (UINT):
//
//  History:
//      08/01/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

TCHAR BCODE gszIntl[]           = TEXT("Intl");
TCHAR BCODE gszIntlList[]       = TEXT("sList");
TCHAR BCODE gszIntlDecimal[]    = TEXT("sDecimal");
TCHAR       gchIntlList         = ',';
TCHAR       gchIntlDecimal      = '.';

UINT FNLOCAL IFormatDetailsToString
(
    LPACMFORMATDETAILS      pafd
)
{
    PACMGARB	    pag;
    TCHAR           ach[ACMFORMATDETAILS_FORMAT_CHARS];
    TCHAR           szChannels[24];
    UINT            u;
    LPWAVEFORMATEX  pwfx;
    UINT            uBits;
    UINT            uIds;


    //
    //
    //
    //
{
    TCHAR       ach[2];

    ach[0] = gchIntlList;
    ach[1] = '\0';

    GetProfileString(gszIntl, gszIntlList, ach, ach, SIZEOF_ARRAY(ach));
    gchIntlList = ach[0];

    ach[0] = gchIntlDecimal;
    ach[1] = '\0';

    GetProfileString(gszIntl, gszIntlDecimal, ach, ach, SIZEOF_ARRAY(ach));
    gchIntlDecimal = ach[0];
}

    //
    //
    //
    pag = pagFind();
    if (NULL == pag)
    {
	return (0);
    }

    pwfx = pafd->pwfx;

    uBits = pwfx->wBitsPerSample;
#if 0
    uBits = (UINT)(pwfx->nAvgBytesPerSec * 8 /
                    pwfx->nSamplesPerSec /
                    pwfx->nChannels);
#endif

    if ((1 == pwfx->nChannels) || (2 == pwfx->nChannels))
    {
        if (0 == uBits)
            uIds = IDS_FORMAT_FORMAT_MONOSTEREO_0BIT;
        else
            uIds = IDS_FORMAT_FORMAT_MONOSTEREO;

        LoadString(pag->hinst, uIds, ach, SIZEOF(ach));

        u = (1 == pwfx->nChannels) ? IDS_FORMAT_CHANNELS_MONO : IDS_FORMAT_CHANNELS_STEREO;
        LoadString(pag->hinst, u, szChannels, SIZEOF(szChannels));

        if (0 == uBits)
	{
#if defined(WIN32) && !defined(UNICODE)
	    u = Iwsprintfmbstowcs(SIZEOFW(pafd->szFormat),
#else
	    u = wsprintf(
#endif
			 pafd->szFormat, ach,
			 pwfx->nSamplesPerSec / 1000,
			 gchIntlDecimal,
			 (UINT)(pwfx->nSamplesPerSec % 1000),
			 gchIntlList,
			 (LPSTR)szChannels);
        }
        else
        {
#if defined(WIN32) && !defined(UNICODE)
	    u = Iwsprintfmbstowcs(SIZEOFW(pafd->szFormat),
#else
	    u = wsprintf(
#endif
			 pafd->szFormat, ach,
			 pwfx->nSamplesPerSec / 1000,
			 gchIntlDecimal,
			 (UINT)(pwfx->nSamplesPerSec % 1000),
			 gchIntlList,
			 uBits,
			 gchIntlList,
			 (LPSTR)szChannels);
        }
    }
    else
    {
        if (0 == uBits)
            uIds = IDS_FORMAT_FORMAT_MULTICHANNEL_0BIT;
        else
            uIds = IDS_FORMAT_FORMAT_MULTICHANNEL;

        LoadString(pag->hinst, uIds, ach, SIZEOF(ach));

        if (0 == uBits)
        {
#if defined(WIN32) && !defined(UNICODE)
	    //	
	    u = Iwsprintfmbstowcs(SIZEOFW(pafd->szFormat),
#else
	    u = wsprintf(
#endif
			 pafd->szFormat, ach,
			 pwfx->nSamplesPerSec / 1000,
			 gchIntlDecimal,
			 (UINT)(pwfx->nSamplesPerSec % 1000),
			 gchIntlList,
			 pwfx->nChannels);
        }
        else
        {
#if defined(WIN32) && !defined(UNICODE)
	    u = Iwsprintfmbstowcs(SIZEOFW(pafd->szFormat),
#else
	    u = wsprintf(
#endif
			 pafd->szFormat, ach,
			 pwfx->nSamplesPerSec / 1000,
			 gchIntlDecimal,
			 (UINT)(pwfx->nSamplesPerSec % 1000),
			 gchIntlList,
			 uBits,
			 gchIntlList,
			 pwfx->nChannels);
        }

    }

    return (u);
} // IFormatDetailsToString()


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMFORMATDETAILS | The <t ACMFORMATDETAILS> structure details a
 *      wave format for a specific format tag for an Audio Compression
 *      Manager (ACM) driver.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t ACMFORMATDETAILS> structure. This member must be initialized
 *      before calling the <f acmFormatDetails> or <f acmFormatEnum>
 *      functions. The size specified in this member must be large enough to
 *      contain the base <t ACMFORMATDETAILS> structure. When the
 *      <f acmFormatDetails> function returns, this member contains the
 *      actual size of the information returned. The returned information
 *      will never exceed the requested size.
 *
 *  @field DWORD | dwFormatIndex | Specifies the index of the format
 *      to retrieve details for. The index ranges from zero to one
 *      less than the number of standard formats supported by an ACM driver
 *      for a format tag. The number of standard formats supported by a
 *      driver for a format tag is contained in the
 *      <e ACMFORMATTAGDETAILS.cStandardFormats> member of the
 *      <t ACMFORMATTAGDETAILS> structure. The
 *      <e ACMFORMATDETAILS.dwFormatIndex> member is only used when querying
 *      standard format details on a driver by index; otherwise, this member
 *      should be zero. Also note that this member will be set to zero
 *      by the ACM when an application queries for details on a format. In
 *      other words, this member is only used as an input argument and is
 *      never returned by the ACM or an ACM driver.
 *
 *  @field DWORD | dwFormatTag | Specifies the wave format tag that the
 *      <t ACMFORMATDETAILS> structure describes. This member is used
 *      as an input for the ACM_FORMATDETAILSF_INDEX query flag.  For
 *      the ACM_FORMATDETAILSF_FORMAT query flag, this member
 *      must be initialized to the same format tag as the
 *      <e ACMFORMATDETAILS.pwfx> member specifies.  This member is always
 *      returned if the <f acmFormatDetails> is successful. This member
 *      should be set to WAVE_FORMAT_UNKNOWN for all other query flags.
 *
 *  @field DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the specified format. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure. This argument can be a combination of the following
 *      values and indicates which operations the driver supports for the
 *      format tag:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags for the
 *      specified format. For example, if a driver supports compression
 *      from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specifed
 *      format, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified format. For example, if a
 *      driver supports resampling of WAVE_FORMAT_PCM to the specified
 *      format, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (which modifies data without changing any
 *      format attributes) with the specified format. For example,
 *      if a driver supports volume or echo operations on WAVE_FORMAT_PCM,
 *      then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified format.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output of the specified format
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @field LPWAVEFORMATEX | pwfx | Specifies a pointer to a <t WAVEFORMATEX>
 *      data structure that will receive the format details. This structure requires no initialization
 *      by the application unless the ACM_FORMATDETAILSF_FORMAT flag is specified
 *      to <f acmFormatDetails>. In this case, the<e WAVEFORMATEX.wFormatTag> must be
 *      equal to the <e ACMFORMATDETAILS.dwFormatTag> of the <t ACMFORMATDETAILS>
 *      structure.
 *
 *  @field DWORD | cbwfx | Specifies the size, in bytes, available for
 *      the <e ACMFORMATDETAILS.pwfx> to receive the format details. The
 *      <f acmMetrics> and <f acmFormatTagDetails> functions can be used to
 *      determine the maximum size required for any format available for the
 *      specified driver (or for all installed ACM drivers).
 *
 *  @field char | szFormat[ACMFORMATDETAILS_FORMAT_CHARS] |
 *      Specifies a string that describes the format for the
 *      <e ACMFORMATDETAILS.dwFormatTag> type. This string is always returned
 *      if the <f acmFormatDetails> function is successful.
 *
 *  @xref <f acmFormatDetails> <f acmFormatEnum> <f acmFormatTagDetails>
 *      <f acmFormatTagEnum>
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatDetails | This function queries the Audio Compression
 *      Manager (ACM) for details on format for a specific wave format tag.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave format details for a format tag. If this argument is NULL,
 *      then the ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFORMATDETAILS | pafd | Specifies a pointer to the
 *      <t ACMFORMATDETAILS> structure that is to receive the format
 *      details for the given format tag.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for getting the wave format tag details.
 *
 *      @flag ACM_FORMATDETAILSF_INDEX | Indicates that a format index for
 *      the format tag was given in the <e ACMFORMATDETAILS.dwFormatIndex>
 *      member of the <t ACMFORMATDETAILS> structure. The format details
 *      will be returned in the structure defined by <p pafd>. The index
 *      ranges from zero to one less than the
 *      <e ACMFORMATTAGDETAILS.cStandardFormats> member returned in the
 *      <t ACMFORMATTAGDETAILS> structure for a format tag. An application
 *      must specify a driver handle (<p had>) when retrieving
 *      format details with this flag. Refer to the description for the
 *      <t ACMFORMATDETAILS> structure for information on what members
 *      should be initialized before calling this function.
 *
 *      @flag ACM_FORMATDETAILSF_FORMAT | Indicates that a <t WAVEFORMATEX>
 *      structure pointed to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure was given and the remaining details
 *      should be returned. The <e ACMFORMATDETAILS.dwFormatTag> member
 *      of the <t ACMFORMATDETAILS> structure must be initialized to the same format
 *      tag as the <e ACMFORMATDETAILS.pwfx> member specifies. This
 *      query type can be used to get a string description of an arbitrary
 *      format structure. If an application specifies an ACM driver handle
 *      (<p had>), then details on the format will be returned for that
 *      driver. If an application specifies NULL for <p had>, then the ACM
 *      finds the first acceptable driver to return the details.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details requested are not available.
 *
 *  @xref <f acmFormatTagDetails> <f acmDriverDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFormatDetails
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    DWORD                   fdwDetails
)
{
    PACMGARB	    pag;
    MMRESULT        mmr;
    PACMDRIVER      pad;
    HACMDRIVERID    hadid;
    DWORD           dwQuery;
    BOOL            fNone;

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFormatDetails: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //
    //
    V_DFLAGS(fdwDetails, ACM_FORMATDETAILSF_VALID, acmFormatDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFORMATDETAILS) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(PCMWAVEFORMAT) > pafd->cbwfx)
    {
        DebugErr(DBF_ERROR, "acmFormatDetails: cbwfx member must be at least sizeof(PCMWAVEFORMAT).");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd->pwfx, pafd->cbwfx, MMSYSERR_INVALPARAM);

    if (0L != pafd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFormatDetails: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    dwQuery = ACM_FORMATDETAILSF_QUERYMASK & fdwDetails;

    switch (dwQuery)
    {
        case ACM_FORMATDETAILSF_FORMAT:
            if (pafd->dwFormatTag != pafd->pwfx->wFormatTag)
            {
                DebugErr(DBF_ERROR, "acmFormatDetails: format tags must match.");
                return  (MMSYSERR_INVALPARAM);
            }

            // -- fall through -- //

        case ACM_FORMATDETAILSF_INDEX:
            if (WAVE_FORMAT_UNKNOWN == pafd->dwFormatTag)
            {
                DebugErr(DBF_ERROR, "acmFormatDetails: dwFormatTag cannot be WAVE_FORMAT_UNKNOWN for requested details query.");
                return (MMSYSERR_INVALPARAM);
            }

            //
            //  we don't (currently) support index based enumeration across
            //  all drivers... may never support this. so validate the
            //  handle and fail if not valid (like NULL).
            //
            if (ACM_FORMATDETAILSF_INDEX == dwQuery)
            {
                ACMFORMATTAGDETAILS aftd;

                V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

                _fmemset(&aftd, 0, sizeof(aftd));
                aftd.cbStruct    = sizeof(aftd);
                aftd.dwFormatTag = pafd->dwFormatTag;
                mmr = acmFormatTagDetails(had, &aftd, ACM_FORMATTAGDETAILSF_FORMATTAG);
                if (MMSYSERR_NOERROR != mmr)
                {
                    return (mmr);
                }

                if (pafd->dwFormatIndex >= aftd.cStandardFormats)
                {
                    DebugErr1(DBF_ERROR, "acmFormatTagDetails: dwFormatIndex (%lu) out of range.", pafd->dwFormatIndex);
                    return (MMSYSERR_INVALPARAM);
                }
            }
            break;

        default:
            DebugErr(DBF_ERROR, "acmFormatDetails: unknown query type specified.");
            return  (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  if we are passed a driver handle, then use it
    //
    if (NULL != had)
    {
        pafd->szFormat[0] = '\0';

        pad = (PACMDRIVER)had;

        EnterHandle(had);
        if (TYPE_HACMDRIVERID == pad->uHandleType)
        {
            V_HANDLE(had, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

            //
            //
            //
            mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)had,
                                             ACMDM_FORMAT_DETAILS,
                                             (LPARAM)pafd,
                                             fdwDetails);
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

            //
            //
            //
            mmr = (MMRESULT)IDriverMessage(had,
                                           ACMDM_FORMAT_DETAILS,
                                           (LPARAM)pafd,
                                           fdwDetails);
        }

        LeaveHandle(had);

        if (MMSYSERR_NOERROR == mmr)
        {
            if ('\0' == pafd->szFormat[0])
            {
                IFormatDetailsToString(pafd);
            }

            //
            //  if caller is asking for details on a specific format, then
            //  always return index equal to zero (it means nothing)
            //
            if (ACM_FORMATDETAILSF_FORMAT == dwQuery)
            {
                pafd->dwFormatIndex = 0;
            }
        }

        return (mmr);
    }


    //
    //
    //
    fNone = TRUE;
    hadid = NULL;
    mmr   = MMSYSERR_NODRIVER;

    ENTER_LIST_SHARED;

    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
    {
        fNone = FALSE;

        //
        //
        //
        pafd->szFormat[0] = '\0';

        EnterHandle(hadid);
        mmr = (MMRESULT)IDriverMessageId(hadid,
                                         ACMDM_FORMAT_DETAILS,
                                         (LPARAM)pafd,
                                         fdwDetails);
        LeaveHandle(hadid);

        if (MMSYSERR_NOERROR == mmr)
        {
            if ('\0' == pafd->szFormat[0])
            {
                IFormatDetailsToString(pafd);
            }

            //
            //  if caller is asking for details on a specific format, then
            //  always return index equal to zero (it means nothing)
            //
            if (ACM_FORMATDETAILSF_FORMAT == dwQuery)
            {
                pafd->dwFormatIndex = 0;
            }
            break;
        }
    }

    LEAVE_LIST_SHARED;

    if( fNone && (dwQuery == ACM_FORMATDETAILSF_FORMAT) &&
                (pafd->dwFormatTag == WAVE_FORMAT_PCM) ) {
        pafd->dwFormatIndex = 0;
        pafd->dwFormatTag   = WAVE_FORMAT_PCM;
        pafd->fdwSupport    = 0;
        pafd->cbwfx         = sizeof( PCMWAVEFORMAT );

        if ( FIELD_OFFSET(ACMFORMATDETAILS, szFormat) <
                    pafd->cbStruct ) {
            pafd->szFormat[0] = '\0';
            IFormatDetailsToString(pafd);
        }
        return( MMSYSERR_NOERROR );
    }

    return (mmr);
} // acmFormatDetails()


#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFormatDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT                mmr;
    ACMFORMATDETAILSW       afdW;

    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*pafd) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    afdW.cbStruct = sizeof(afdW);
    memcpy(&afdW.dwFormatIndex,
           &pafd->dwFormatIndex,
           FIELD_OFFSET(ACMFORMATDETAILSA, szFormat) -
           FIELD_OFFSET(ACMFORMATDETAILSA, dwFormatIndex));

    mmr = acmFormatDetailsW(had, &afdW, fdwDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        memcpy(&pafd->dwFormatIndex,
               &afdW.dwFormatIndex,
               FIELD_OFFSET(ACMFORMATDETAILSA, szFormat) -
               FIELD_OFFSET(ACMFORMATDETAILSA, dwFormatIndex));

        pafd->cbStruct = min(pafd->cbStruct, sizeof(*pafd));
        Iwcstombs(pafd->szFormat, afdW.szFormat, sizeof(pafd->szFormat));
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFormatDetailsW
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    DWORD                   fdwDetails
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif



/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api BOOL ACMFORMATTAGENUMCB | acmFormatTagEnumCallback |
 *      The <f acmFormatTagEnumCallback> function refers to the callback function used for
 *      Audio Compression Manager (ACM) wave format tag enumeration. The
 *      <f acmFormatTagEnumCallback> function is a placeholder for the application-supplied
 *      function name.
 *
 *  @parm HACMDRIVERID | hadid | Specifies an ACM driver identifier.
 *
 *  @parm  LPACMFORMATTAGDETAILS | paftd | Specifies a pointer to an
 *      <t ACMFORMATTAGDETAILS> structure that contains the enumerated
 *      format tag details.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f acmFormatTagEnum> function.
 *
 *  @parm DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the format tag. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure. This argument can be a combination of the following
 *      values and indicates which operations the driver supports with the
 *      format tag:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags where one of
 *      the tags is the specified format tag. For example, if a driver
 *      supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM,
 *      then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      specified format tag. For example, if a driver supports resampling
 *      of WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on the specified format tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified format tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output of the specified format tag
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f acmFormatTagEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no format tags are to be enumerated. Moreover, the callback
 *      function will not be called.
 *
 *  @xref <f acmFormatTagEnum> <f acmFormatTagDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatTagEnum | The <f acmFormatTagEnum> function
 *      enumerates wave format tags available from an Audio Compression
 *      Manager (ACM) driver. The <f acmFormatTagEnum> function continues
 *      enumerating until there are no more suitable format tags or the
 *      callback function returns FALSE.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave format tag details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFORMATTAGDETAILS | paftd | Specifies a pointer to the
 *      <t ACMFORMATTAGDETAILS> structure that is to receive the format
 *      tag details passed to the <p fnCallback> function. This structure
 *      must have the <e ACMFORMATTAGDETAILS.cbStruct> member of the
 *      <t ACMFORMATTAGDETAILS> structure initialized.
 *
 *  @parm ACMFORMATTAGENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function. The callback
 *      address must be created by the <f MakeProcInstance> function; or
 *      the callback function must contain the proper prolog and epilog code
 *      for callbacks.
 *
 *  @parm DWORD | dwInstance | Specifies a 32-bit, application-defined value
 *      that is passed to the callback function along with ACM format tag
 *      details.
 *
 *  @parm DWORD | fdwEnum | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *  @comm The <f acmFormatTagEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no suitable ACM drivers are installed. Moreover, the
 *      callback function will not be called.
 *
 *  @xref <f acmFormatTagEnumCallback> <f acmFormatTagDetails>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFormatTagEnum
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    ACMFORMATTAGENUMCB      fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
)
{
    PACMGARB		pag;
    PACMDRIVER          pad;
    PACMDRIVERID        padid;
    UINT                uIndex;
    UINT                uFormatTag;
    BOOL                f;
    HACMDRIVERID        hadid;
    PACMDRIVERID        padidCur;
    HACMDRIVERID        hadidCur;
    BOOL                fSent;
    BOOL                fNone;
    DWORD               cbaftd;
    DWORD               fdwSupport;
    MMRESULT		mmr;

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFormatTagEnum: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //
    //
    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwEnum, ACM_FORMATTAGENUMF_VALID, acmFormatTagEnum, MMSYSERR_INVALFLAG);
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFORMATTAGDETAILS) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatTagEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    if (0L != paftd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFormatTagEnum: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    cbaftd = min(paftd->cbStruct, sizeof(ACMFORMATTAGDETAILS));


    //
    //
    //
    //
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

        //
        //  enum format tags for this driver only.
        //
        pad   = (PACMDRIVER)had;
        padid = (PACMDRIVERID)pad->hadid;

        //
        //  do NOT include the 'disabled' bit!
        //
        fdwSupport = padid->fdwSupport;

        //
        //  while there are Formats to enumerate and we have not been
        //  told to stop (client returns FALSE to stop enum)
        //
	mmr = MMSYSERR_NOERROR;
        for (uIndex = 0; uIndex < padid->cFormatTags; uIndex++)
        {
	    paftd->cbStruct = cbaftd;
	    paftd->dwFormatTagIndex = uIndex;
	    mmr = IFormatTagDetails(pag, (HACMDRIVERID)padid, paftd, ACM_FORMATTAGDETAILSF_INDEX);
	    if (MMSYSERR_NOERROR != mmr) {
		break;
	    }
	
            f = (* fnCallback)(pad->hadid, paftd, dwInstance, fdwSupport);
            if (FALSE == f)
                break;
        }

        return (mmr);
    }


    //
    //
    //
    //
    hadidCur = NULL;
    fNone = TRUE;

    ENTER_LIST_SHARED;

    while (!IDriverGetNext(pag, &hadidCur, hadidCur, 0L))
    {
        padidCur = (PACMDRIVERID)hadidCur;

        for (uIndex = 0; uIndex < padidCur->cFormatTags; uIndex++)
        {
            fNone = FALSE;
            uFormatTag = (UINT)(padidCur->paFormatTagCache[uIndex].dwFormatTag);
            fSent = FALSE;
            hadid = NULL;
            while (!fSent && !IDriverGetNext(pag, &hadid, hadid, 0L))
            {
                UINT    u;

                //
                //  same driver ?
                //
                if (hadid == hadidCur)
                    break;


                //
                //  for every previous driver
                //
                padid = (PACMDRIVERID)hadid;

                for (u = 0; u < padid->cFormatTags; u++)
                {
                    //
                    //  for every FormatTag in the driver
                    //
                    if (uFormatTag == padid->paFormatTagCache[u].dwFormatTag)
                    {
                        //
                        //  we have a match, but this was already given.
                        //
                        fSent = TRUE;
                        break;
                    }
                }
            }

            if (!fSent)
            {
                //
                //  we have a format that has not been sent yet.
                //
		paftd->dwFormatTagIndex = uIndex;
		paftd->cbStruct = cbaftd;
		mmr = IFormatTagDetails(pag, (HACMDRIVERID)padidCur,
					paftd, ACM_FORMATTAGDETAILSF_INDEX);
		if (MMSYSERR_NOERROR != mmr)
		{
		    LEAVE_LIST_SHARED;
		    return mmr;
		}

                //
		//  do NOT include the 'disabled' bit!
                //
                fdwSupport = padidCur->fdwSupport;

                f = (* fnCallback)(hadidCur, paftd, dwInstance, fdwSupport);
                if (FALSE == f) {
                    LEAVE_LIST_SHARED;
                    return (MMSYSERR_NOERROR);
            }
        }
    }
    }

    LEAVE_LIST_SHARED;

    if( fNone ) {
        /* No codecs enabled */
        /* Enum PCM as default */

        fdwSupport = 0L;

        paftd->dwFormatTagIndex = 0;
        paftd->dwFormatTag      = WAVE_FORMAT_PCM;
        paftd->cbFormatSize     = sizeof(PCMWAVEFORMAT);
        paftd->fdwSupport       = fdwSupport;
        paftd->cStandardFormats = CODEC_MAX_STANDARD_FORMATS_PCM;

        //
        //  the ACM is responsible for the PCM format tag name
        //
#if defined(WIN32) && !defined(UNICODE)
	LoadStringW(pag->hinst,
		    IDS_FORMAT_TAG_PCM,
		    paftd->szFormatTag,
		    SIZEOFW(paftd->szFormatTag));
#else
	LoadString(pag->hinst,
                   IDS_FORMAT_TAG_PCM,
                   paftd->szFormatTag,
                   SIZEOF(paftd->szFormatTag));
#endif
	
        (* fnCallback)(NULL, paftd, dwInstance, fdwSupport);
    }

    return (MMSYSERR_NOERROR);
}


#ifdef WIN32
#if TRUE    // defined(UNICODE)

typedef struct tIFORMATTAGENUMCBINSTANCEW
{
    ACMFORMATTAGENUMCBA         fnCallback;
    DWORD_PTR                   dwInstance;
    LPACMFORMATTAGDETAILSA      paftd;

} IFORMATTAGENUMCBINSTANCEW, *PIFORMATTAGENUMCBINSTANCEW;

BOOL FNWCALLBACK IFormatTagEnumCallbackW
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILSW  paftdW,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    PIFORMATTAGENUMCBINSTANCEW  pfti;
    BOOL                        f;

    pfti = (PIFORMATTAGENUMCBINSTANCEW)dwInstance;

    memcpy(&pfti->paftd->dwFormatTagIndex,
           &paftdW->dwFormatTagIndex,
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, szFormatTag) -
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, dwFormatTagIndex));

    pfti->paftd->cbStruct = sizeof(*pfti->paftd);
    Iwcstombs(pfti->paftd->szFormatTag, paftdW->szFormatTag, sizeof(pfti->paftd->szFormatTag));

    f = pfti->fnCallback(hadid, pfti->paftd, pfti->dwInstance, fdwSupport);

    return (f);
}


MMRESULT ACMAPI acmFormatTagEnumA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    ACMFORMATTAGENUMCBA     fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
)
{
    MMRESULT                    mmr;
    ACMFORMATTAGDETAILSW        aftdW;
    IFORMATTAGENUMCBINSTANCEW   fti;

    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*paftd) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatTagEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    aftdW.cbStruct = sizeof(aftdW);
    memcpy(&aftdW.dwFormatTagIndex,
           &paftd->dwFormatTagIndex,
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, szFormatTag) -
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, dwFormatTagIndex));

    fti.fnCallback = fnCallback;
    fti.dwInstance = dwInstance;
    fti.paftd      = paftd;

    mmr = acmFormatTagEnumW(had, &aftdW, IFormatTagEnumCallbackW, (DWORD_PTR)&fti, fdwEnum);

    return (mmr);
}
#else
MMRESULT ACMAPI acmFormatTagEnumW
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSW  paftd,
    ACMFORMATTAGENUMCBW     fnCallback,
    DWORD                   dwInstance,
    DWORD                   fdwEnum
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


//--------------------------------------------------------------------------;
//
//  BOOL ISupported
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvrMapper:
//
//      LPWAVEFORMATEX pwfx:
//
//      DWORD fdwEnum:
//
//  Return (BOOL):
//
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL ISupported
(
    HDRVR                   hdrvrMapper,
    LPWAVEFORMATEX          pwfx,
    DWORD                   fdwEnum
)
{
    UINT                cWaveDevs;
    MMRESULT            mmr;
    DWORD               dw;
    BOOL                fPrefOnly;
    UINT                uIdPref;
    UINT                u;


    //
    //  if the 'hardware' bit is not set, then simply test for support
    //  through the mapper..
    //
    if (0 == (ACM_FORMATENUMF_HARDWARE & fdwEnum))
    {
        if (0 != (ACM_FORMATENUMF_OUTPUT & fdwEnum))
        {
            mmr = waveOutOpen(NULL, (UINT)WAVE_MAPPER,
#ifndef _WIN32
                              (LPWAVEFORMAT)pwfx,
#else
                              pwfx,
#endif
                              0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);
            if (MMSYSERR_NOERROR == mmr)
            {
                return (TRUE);
            }
        }

        if (0 != (ACM_FORMATENUMF_INPUT & fdwEnum))
        {
            mmr = waveInOpen(NULL, (UINT)WAVE_MAPPER,
#ifndef _WIN32
                             (LPWAVEFORMAT)pwfx,
#else
                             pwfx,
#endif
                             0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);
            if (MMSYSERR_NOERROR == mmr)
            {
                return (TRUE);
            }
        }

        return (FALSE);
    }


    //
    //  output device...
    //
    if ((0 != (fdwEnum & ACM_FORMATENUMF_OUTPUT)) &&
        (0 != (cWaveDevs = waveOutGetNumDevs())))
    {
        dw = MAKELONG(LOWORD(WAVE_MAPPER), FALSE);
        if (NULL != hdrvrMapper)
        {
            SendDriverMessage(hdrvrMapper,
                              DRV_MAPPER_PREFERRED_OUTPUT_GET,
                              (LPARAM)(LPVOID)&dw, 0L);
        }

        fPrefOnly = (BOOL)(int)HIWORD(dw);

        if (fPrefOnly)
        {
            uIdPref = (UINT)(int)(short)LOWORD(dw);

            mmr = waveOutOpen(NULL, uIdPref,
#ifndef _WIN32
                              (LPWAVEFORMAT)pwfx,
#else
                              pwfx,
#endif
                              0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);

            if (MMSYSERR_NOERROR == mmr)
            {
                return (TRUE);
            }
        }
        else
        {
            for (u = 0; u < cWaveDevs; u++)
            {
                mmr = waveOutOpen(NULL, u,
#ifndef _WIN32
                                  (LPWAVEFORMAT)pwfx,
#else
                                  pwfx,
#endif
                                  0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);

                if (MMSYSERR_NOERROR == mmr)
                {
                    return (TRUE);
                }
            }
        }
    }


    //
    //  input device
    //
    if ((0 != (fdwEnum & ACM_FORMATENUMF_INPUT)) &&
        (0 != (cWaveDevs = waveInGetNumDevs())))
    {
        //
        //
        //
        dw = MAKELONG(LOWORD(WAVE_MAPPER), FALSE);
        if (NULL != hdrvrMapper)
        {
            SendDriverMessage(hdrvrMapper,
                              DRV_MAPPER_PREFERRED_INPUT_GET,
                              (LPARAM)(LPVOID)&dw, 0L);
        }

        //
        //
        //
        fPrefOnly = (BOOL)(int)HIWORD(dw);

        if (fPrefOnly)
        {
            uIdPref = (UINT)(int)(short)LOWORD(dw);

            mmr  = waveInOpen(NULL, uIdPref,
#ifndef _WIN32
                              (LPWAVEFORMAT)pwfx,
#else
                              pwfx,
#endif
                              0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);

            if (MMSYSERR_NOERROR == mmr)
            {
                return (TRUE);
            }
        }
        else
        {
            for (u = 0; u < cWaveDevs; u++)
            {
                mmr = waveInOpen(NULL, u,
#ifndef _WIN32
                                 (LPWAVEFORMAT)pwfx,
#else
                                 pwfx,
#endif
                                 0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);

                if (MMSYSERR_NOERROR == mmr)
                {
                    return (TRUE);
                }
            }
        }
    }

    return (FALSE);
} // ISupported()




//--------------------------------------------------------------------------;
//
//  MMRESULT ISuggestEnum
//
//  Description:
//
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL ISuggestEnum
(
    HDRVR                   hdrvrMapper,
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    LPWAVEFORMATEX          pwfxSrc,
    DWORD                   fdwEnum
)
{
    MMRESULT            mmr;
    BOOL                f;
    DWORD               fdwSuggest;
    DWORD               fdwSupport;
    HACMDRIVERID        hadid;

    DV_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

    hadid = ((PACMDRIVER)had)->hadid;

    fdwSupport = ((PACMDRIVERID)hadid)->fdwSupport;

    pafd->dwFormatTag       = paftd->dwFormatTag;
    pafd->fdwSupport        = 0L;
    pafd->pwfx->wFormatTag  = (WORD)(paftd->dwFormatTag);

    fdwSuggest = ACM_FORMATSUGGESTF_WFORMATTAG;
    if( fdwEnum & ACM_FORMATENUMF_NCHANNELS ) {
        fdwSuggest |= ACM_FORMATSUGGESTF_NCHANNELS;
    }
    if( fdwEnum & ACM_FORMATENUMF_NSAMPLESPERSEC ) {
        fdwSuggest |= ACM_FORMATSUGGESTF_NSAMPLESPERSEC;
    }
    if( fdwEnum & ACM_FORMATENUMF_WBITSPERSAMPLE ) {
        fdwSuggest |= ACM_FORMATSUGGESTF_WBITSPERSAMPLE;
    }

    mmr = acmFormatSuggest(had, pwfxSrc, pafd->pwfx, pafd->cbwfx, fdwSuggest);
    if( mmr != MMSYSERR_NOERROR )
    {
        return (MMSYSERR_NOERROR);
    }

    mmr = acmFormatDetails(had, pafd, ACM_FORMATDETAILSF_FORMAT);
    if (MMSYSERR_NOERROR != mmr)
    {
        return (MMSYSERR_NOERROR);
    }

    if (0 != ((ACM_FORMATENUMF_INPUT | ACM_FORMATENUMF_OUTPUT) & fdwEnum))
    {
        if (!ISupported(hdrvrMapper, pafd->pwfx, fdwEnum))
        {
            return (MMSYSERR_NOERROR);
        }
    }

    f = (* fnCallback)(hadid, pafd, dwInstance, fdwSupport);
    if (!f)
        return (MMSYSERR_ERROR);

    return (MMSYSERR_NOERROR);
} // ISuggestEnum()


//--------------------------------------------------------------------------;
//
//  MMRESULT IFormatEnum
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPACMFORMATTAGDETAILS paftd:
//
//      LPACMFORMATDETAILS pafd:
//
//      ACMFORMATENUMCB fnCallback:
//
//      DWORD_PTR dwInstance:
//
//  Return (MMRESULT):
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IFormatEnum
(
    HDRVR                   hdrvrMapper,
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    LPWAVEFORMATEX          pwfxSrc,
    DWORD                   fdwEnum
)
{
    MMRESULT            mmr;
    BOOL                f;
    DWORD               cbafd;
    LPWAVEFORMATEX      pwfx;
    DWORD               cbwfx;
    UINT                u;
    UINT                nChannels;
    DWORD               nSamplesPerSec;
    UINT                uBitsPerSample;
    LPWAVEFORMATEX      pwfxSuggest;
    DWORD               cbwfxSuggest;
    DWORD               fdwSupport;
    DWORD               fdwSuggest;
    HACMDRIVERID        hadid;

    DV_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

    //
    //
    //
    //
    pwfxSuggest = NULL;
    if (0 != (ACM_FORMATENUMF_CONVERT & fdwEnum))
    {
        mmr = IMetricsMaxSizeFormat( NULL, had, &cbwfxSuggest );
        if (MMSYSERR_NOERROR == mmr)
        {
            pwfxSuggest = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfxSuggest);

            DPF(5, "allocating %lu bytes for pwfxSuggest=%.08lXh", cbwfxSuggest, pwfxSuggest);

            if (NULL != pwfxSuggest)
            {
                fdwSuggest = ACM_FORMATSUGGESTF_WFORMATTAG;
                pwfxSuggest->wFormatTag = LOWORD(paftd->dwFormatTag);

                if (0 != (ACM_FORMATENUMF_NCHANNELS & fdwEnum))
                {
                    fdwSuggest |= ACM_FORMATSUGGESTF_NCHANNELS;
                    pwfxSuggest->nChannels = pwfxSrc->nChannels;
                }
                if (0 != (ACM_FORMATENUMF_NSAMPLESPERSEC & fdwEnum))
                {
                    fdwSuggest |= ACM_FORMATSUGGESTF_NSAMPLESPERSEC;
                    pwfxSuggest->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
                }
                if (0 != (ACM_FORMATENUMF_WBITSPERSAMPLE & fdwEnum))
                {
                    fdwSuggest |= ACM_FORMATSUGGESTF_WBITSPERSAMPLE;
                    pwfxSuggest->wBitsPerSample = pwfxSrc->wBitsPerSample;
                }

                DPF(5, "calling acmFormatSuggest pwfxSuggest=%.08lXh--fdwSuggest=%.08lXh", pwfxSuggest, fdwSuggest);

                mmr = acmFormatSuggest(had, pwfxSrc, pwfxSuggest, cbwfxSuggest, fdwSuggest);
                if (MMSYSERR_NOERROR != mmr)
                {
                    DPF(5, "FREEING pwfxSuggest=%.08lXh--no suggested format!", pwfxSuggest);
                    GlobalFreePtr(pwfxSuggest);
                    pwfxSuggest = NULL;

                    //
                    //  if no 'suggestions', there better not be any
                    //  possible conversions that we would find below...
                    //
                    return (MMSYSERR_NOERROR);
                }

                DPF(5, "******* suggestion--%u to %u", pwfxSrc->wFormatTag, pwfxSuggest->wFormatTag);
                cbwfxSuggest = SIZEOF_WAVEFORMATEX(pwfxSuggest);
            }
        }
    }


    hadid = ((PACMDRIVER)had)->hadid;

    fdwSupport = ((PACMDRIVERID)hadid)->fdwSupport;

    //
    //  be a bit paranoid and save some stuff so we can always reinit
    //  the structure between calling the driver (i just don't trust
    //  driver writers... though Media Vision is bound to find a way
    //  to cause trouble anyway)
    //
    cbafd = pafd->cbStruct;
    pwfx  = pafd->pwfx;
    cbwfx = pafd->cbwfx;
    nChannels = pwfxSrc->nChannels;
    nSamplesPerSec = pwfxSrc->nSamplesPerSec;
    uBitsPerSample = pwfxSrc->wBitsPerSample;


    //
    //
    //
    for (u = 0; u < paftd->cStandardFormats; u++)
    {
        pafd->cbStruct      = cbafd;
        pafd->dwFormatIndex = u;
        pafd->dwFormatTag   = paftd->dwFormatTag;
        pafd->fdwSupport    = 0;
        pafd->pwfx          = pwfx;
        pafd->cbwfx         = cbwfx;
        pafd->szFormat[0]   = '\0';

        mmr = acmFormatDetails(had, pafd, ACM_FORMATDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
        {
            continue;
        }

        if ((fdwEnum & ACM_FORMATENUMF_NCHANNELS) &&
            (pwfx->nChannels != nChannels))
        {
            continue;
        }
        if ((fdwEnum & ACM_FORMATENUMF_NSAMPLESPERSEC) &&
            (pwfx->nSamplesPerSec != nSamplesPerSec))
        {
            continue;
        }
        if ((fdwEnum & ACM_FORMATENUMF_WBITSPERSAMPLE) &&
            (pwfx->wBitsPerSample != uBitsPerSample))
        {
            continue;
        }

        if (0 != (fdwEnum & ACM_FORMATENUMF_CONVERT))
        {
            mmr = acmStreamOpen(NULL,
                                had,
                                pwfxSrc,
                                pwfx,
                                NULL,
                                0L,
                                0L,
                                ACM_STREAMOPENF_NONREALTIME |
                                ACM_STREAMOPENF_QUERY);

            if (MMSYSERR_NOERROR != mmr)
                continue;

            if ((NULL != pwfxSuggest) &&
                (SIZEOF_WAVEFORMATEX(pwfx) == cbwfxSuggest))
            {
                if (0 == _fmemcmp(pwfx, pwfxSuggest, (UINT)cbwfxSuggest))
                {
                    DPF(5, "FREEING pwfxSuggest=%.08lXh--DUPLICATE!", pwfxSuggest);
                    GlobalFreePtr(pwfxSuggest);
                    pwfxSuggest = NULL;
                }
            }
        }

        if (0 != ((ACM_FORMATENUMF_INPUT | ACM_FORMATENUMF_OUTPUT) & fdwEnum))
        {
            if (!ISupported(hdrvrMapper, pwfx, fdwEnum))
            {
                continue;
            }
        }

        DPF(3, "doing callback--%lu, %s", pafd->dwFormatTag, (LPSTR)pafd->szFormat);
        f = (* fnCallback)(hadid, pafd, dwInstance, fdwSupport);
        if (!f)
        {
            if (NULL != pwfxSuggest)
            {
                DPF(5, "FREEING pwfxSuggest=%.08lXh--CALLBACK CANCELED!", pwfxSuggest);
                GlobalFreePtr(pwfxSuggest);
            }
            return (MMSYSERR_ERROR);
        }
    }

    //
    //  if we have not passed back the 'suggested' format for the convert
    //  case, then do it now
    //
    //  this is a horribly gross fix, and i know it...
    //
    if (NULL != pwfxSuggest)
    {
        DPF(5, "pwfxSuggest=%.08lXh--attempting callback (%u)", pwfxSuggest, pwfxSuggest->wFormatTag);

        pafd->cbStruct      = cbafd;
        pafd->dwFormatIndex = 0;
        pafd->dwFormatTag   = pwfxSuggest->wFormatTag;
        pafd->fdwSupport    = 0;
        pafd->pwfx          = pwfxSuggest;
        pafd->cbwfx         = cbwfxSuggest;
        pafd->szFormat[0]   = '\0';

        f   = TRUE;
        mmr = acmFormatDetails(had, pafd, ACM_FORMATDETAILSF_FORMAT);
        if (MMSYSERR_NOERROR == mmr)
        {
            if (0 != ((ACM_FORMATENUMF_INPUT | ACM_FORMATENUMF_OUTPUT) & fdwEnum))
            {
                if (!ISupported(hdrvrMapper, pwfxSuggest, fdwEnum))
                {
                    DPF(5, "FREEING pwfxSuggest=%.08lXh--attempting callback NOT SUPPPORTED", pwfxSuggest);

                    GlobalFreePtr(pwfxSuggest);
                    pafd->cbwfx = cbwfx;
                    return (MMSYSERR_NOERROR);
                }
            }

            DPF(5, "doing SUGGEST callback--%lu, %s", pafd->dwFormatTag, (LPSTR)pafd->szFormat);
            f = (* fnCallback)(hadid, pafd, dwInstance, fdwSupport);
        }

        //
        //  reset these things or bad things will happen
        //
        pafd->pwfx  = pwfx;
        pafd->cbwfx = cbwfx;

        GlobalFreePtr(pwfxSuggest);

        if (!f)
        {
            return (MMSYSERR_ERROR);
        }
    }

    return (MMSYSERR_NOERROR);
} // IFormatEnum()


//--------------------------------------------------------------------------;
//
//  MMRESULT IHardwareEnum
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvrMapper:
//
//      LPACMFORMATDETAILS pafd:
//
//      ACMFORMATENUMCB fnCallback:
//
//      DWORD_PTR dwInstance:
//
//      LPWAVEFORMATEX pwfxSrc:
//
//      DWORD fdwEnum:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IHardwareEnum
(
    HDRVR                   hdrvrMapper,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    LPWAVEFORMATEX          pwfxSrc,
    DWORD                   fdwEnum
)
{
    BOOL                f;
    DWORD               cbafd;
    LPWAVEFORMATEX      pwfx;
    DWORD               cbwfx;
    UINT                u1, u2;
    UINT                nChannels;
    DWORD               nSamplesPerSec;
    UINT                uBitsPerSample;


    //
    //  be a bit paranoid and save some stuff so we can always reinit
    //  the structure between calling the driver (i just don't trust
    //  driver writers... though Media Vision is bound to find a way
    //  to cause trouble anyway)
    //
    cbafd = pafd->cbStruct;
    pwfx  = pafd->pwfx;
    cbwfx = pafd->cbwfx;
    nChannels = pwfxSrc->nChannels;
    nSamplesPerSec = pwfxSrc->nSamplesPerSec;
    uBitsPerSample = pwfxSrc->wBitsPerSample;

    //
    //
    //
    for (u1 = 0; u1 < CODEC_MAX_STANDARD_FORMATS_PCM; u1++)
    {
        pafd->cbStruct      = cbafd;
        pafd->dwFormatIndex = 0;
        pafd->dwFormatTag   = WAVE_FORMAT_PCM;
        pafd->fdwSupport    = 0L;
        pafd->pwfx          = pwfx;
        pafd->cbwfx         = cbwfx;

        //
        //  now fill in the format structure
        //
        pwfx->wFormatTag      = WAVE_FORMAT_PCM;

        u2 = u1 / (CODEC_MAX_BITSPERSAMPLE_PCM * CODEC_MAX_CHANNELS);
        pwfx->nSamplesPerSec  = auFormatIndexToSampleRate[u2];

        u2 = u1 % CODEC_MAX_CHANNELS;
        pwfx->nChannels       = u2 + 1;

        u2 = (u1 / CODEC_MAX_CHANNELS) % CODEC_MAX_CHANNELS;
        pwfx->wBitsPerSample  = (WORD)auFormatIndexToBitsPerSample[u2];

        pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx);
        pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

        //
        //  note that the cbSize field is NOT valid for PCM formats
        //
        //  pwfx->cbSize      = 0;


        pafd->cbStruct    = min(pafd->cbStruct, sizeof(*pafd));
        IFormatDetailsToString(pafd);

        if( (fdwEnum & ACM_FORMATENUMF_NCHANNELS)
            && (pwfx->nChannels != nChannels) ) {
            continue;
        }
        if( (fdwEnum & ACM_FORMATENUMF_NSAMPLESPERSEC)
            && (pwfx->nSamplesPerSec != nSamplesPerSec) ) {
            continue;
        }
        if( (fdwEnum & ACM_FORMATENUMF_WBITSPERSAMPLE)
            && (pwfx->wBitsPerSample != uBitsPerSample) ) {
            continue;
        }

        if (0 != ((ACM_FORMATENUMF_INPUT | ACM_FORMATENUMF_OUTPUT) & fdwEnum))
        {
            if (!ISupported(hdrvrMapper, pwfx, fdwEnum))
            {
                continue;
            }
        }

        f = (* fnCallback)(NULL, pafd, dwInstance, 0L);
        if (!f)
        {
            return (MMSYSERR_ERROR);
        }
    }

    return (MMSYSERR_NOERROR);
} // IHardwareEnum()


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api BOOL ACMFORMATENUMCB | acmFormatEnumCallback |
 *      The <f acmFormatEnumCallback> function refers to the callback function used for
 *      Audio Compression Manager (ACM) wave format detail enumeration. The
 *      <f acmFormatEnumCallback> is a placeholder for the application-supplied
 *      function name.
 *
 *  @parm HACMDRIVERID | hadid | Specifies an ACM driver identifier.
 *
 *  @parm  LPACMFORMATDETAILS | pafd | Specifies a pointer to an
 *      <t ACMFORMATDETAILS> structure that contains the enumerated
 *      format details for a format tag.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f acmFormatEnum> function.
 *
 *  @parm DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the driver identifier <p hadid> for the specified format. These flags
 *      are identical to the <e ACMDRIVERDETAILS.fdwSupport> flags of the
 *      <t ACMDRIVERDETAILS> structure, but are specific to the format that
 *      is being enumerated. This argument can be a combination of the
 *      following values and indicates which operations the driver supports
 *      for the format tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags for the
 *      specified format. For example, if a driver supports compression
 *      from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specifed
 *      format, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified format. For example, if a
 *      driver supports resampling of WAVE_FORMAT_PCM to the specified
 *      format, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes) with the specified format. For example,
 *      if a driver supports volume or echo operations on WAVE_FORMAT_PCM,
 *      then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified format.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output of the specified format tag
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f acmFormatEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no formats are to be enumerated. Moreover, the callback
 *      function will not be called.
 *
 *  @xref <f acmFormatEnum> <f acmFormatTagDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatEnum | The <f acmFormatEnum> function
 *      enumerates wave formats available for a given format tag from
 *      an Audio Compression Manager (ACM) driver. The <f acmFormatEnum>
 *      function continues enumerating until there are no more suitable
 *      formats for the format tag or the callback function returns FALSE.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave format details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFORMATDETAILS | pafd | Specifies a pointer to the
 *      <t ACMFORMATDETAILS> structure that is to receive the format details
 *      passed to the <p fnCallback> function. This structure must have the
 *      <e ACMFORMATDETAILS.cbStruct>, <e ACMFORMATDETAILS.pwfx>, and
 *      <e ACMFORMATDETAILS.cbwfx> members of the <t ACMFORMATDETAILS>
 *      structure initialized. The <e ACMFORMATDETAILS.dwFormatTag> member
 *      must also be initialized to either WAVE_FORMAT_UNKNOWN or a
 *      valid format tag.
 *
 *  @parm ACMFORMATENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function. The callback
 *      address must be created by the <f MakeProcInstance> function; or
 *      the callback function must contain the proper prolog and epilog code
 *      for callbacks.
 *
 *  @parm DWORD | dwInstance | Specifies a 32-bit, application-defined value
 *      that is passed to the callback function along with ACM format details.
 *
 *  @parm DWORD | fdwEnum | Specifies flags for enumerating the formats for
 *      a given format tag.
 *
 *      @flag ACM_FORMATENUMF_WFORMATTAG | Specifies that the
 *      <e WAVEFORMATEX.wFormatTag> member of the <t WAVEFORMATEX> structure
 *      referred to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will only
 *      enumerate a format that conforms to this attribute. Note that the
 *      <e ACMFORMATDETAILS.dwFormatTag> member of the <t ACMFORMATDETAILS>
 *      structure must be equal to the <e WAVEFORMATEX.wFormatTag> member.
 *
 *      @flag ACM_FORMATENUMF_NCHANNELS | Specifies that the
 *      <e WAVEFORMATEX.nChannels> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will only
 *      enumerate a format that conforms to this attribute.
 *
 *      @flag ACM_FORMATENUMF_NSAMPLESPERSEC | Specifies that the
 *      <e WAVEFORMATEX.nSamplesPerSec> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will only
 *      enumerate a format that conforms to this attribute.
 *
 *      @flag ACM_FORMATENUMF_WBITSPERSAMPLE | Specifies that the
 *      <e WAVEFORMATEX.wBitsPerSample> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will only
 *      enumerate a format that conforms to this attribute.
 *
 *      @flag ACM_FORMATENUMF_CONVERT | Specifies that the <t WAVEFORMATEX>
 *      structure referenced by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will only
 *      enumerate destination formats that can be converted from the given
 *      <e ACMFORMATDETAILS.pwfx> format.
 *
 *      @flag ACM_FORMATENUMF_SUGGEST | Specifies that the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will
 *      enumerate all suggested destination formats for the given
 *      <e ACMFORMATDETAILS.pwfx> format. This can be used instead of
 *      <f acmFormatSuggest> to allow an application to choose the best
 *      suggested format for conversion. Note that the
 *      <e ACMFORMATDETAILS.dwFormatIndex> member will always be set to
 *      zero on return.
 *
 *      @flag ACM_FORMATENUMF_HARDWARE | Specifies that the enumerator should
 *      only enumerate formats that are supported as native input or output
 *      formats on one or more of the installed wave devices. This provides
 *      a way for an application to choose only formats native to an
 *      installed wave device. This flag must be used with one or both
 *      of the ACM_FORMATENUMF_INPUT and ACM_FORMATENUMF_OUTPUT flags.
 *      Note that specifying both ACM_FORMATENUMF_INPUT and
 *      ACM_FORMATENUMF_OUTPUT will enumerate only formats that can be
 *      opened for input or output.
 *      This is true regardless of of whether the ACM_FORMATENUMF_HARDWARE
 *      flag is specified.
 *
 *      @flag ACM_FORMATENUMF_INPUT | Specifies that the enumerator should
 *      only enumerate formats that are supported for input (recording).
 *
 *      @flag ACM_FORMATENUMF_OUTPUT | Specifies that the enumerator should
 *      only enumerate formats that are supported for output (playback).
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details for the format cannot be
 *      returned.
 *
 *  @comm The <f acmFormatEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no suitable ACM drivers are installed. Moreover, the
 *      callback function will not be called.
 *
 *  @xref <f acmFormatEnumCallback> <f acmFormatDetails> <f acmFormatSuggest>
 *      <f acmFormatTagDetails> <f acmFilterEnum>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFormatEnum
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
)
{
    PACMGARB		    pag;
    MMRESULT                mmr;
    PACMDRIVERID            padid;
    HACMDRIVERID            hadid;
    UINT                    u;
    UINT                    uIndex;
    UINT                    uFormatSize;
    UINT                    uFormatTag;
    LPWAVEFORMATEX          pwfxSrc;
    BOOL                    fNoDrivers;
    DWORD                   cbwfxRqd;
    HDRVR                   hdrvrMapper;
    BOOL                    fFormatTag;
    BOOL                    fConvert;
    BOOL                    fSuggest;
    ACMFORMATTAGDETAILS	    aftd;


    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFormatEnum: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFORMATDETAILS) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
    }
    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwEnum, ACM_FORMATENUMF_VALID, acmFormatEnum, MMSYSERR_INVALFLAG);

    if (0 != (ACM_FORMATENUMF_HARDWARE & fdwEnum))
    {
        if (0 == ((ACM_FORMATENUMF_INPUT|ACM_FORMATENUMF_OUTPUT) & fdwEnum))
        {
            DebugErr(DBF_ERROR, "acmFormatEnum: ACM_FORMATENUMF_HARDWARE requires _INPUT and/or _OUTPUT flag.");
            return (MMSYSERR_INVALFLAG);
        }
    }

    //
    //
    //
    mmr = IMetricsMaxSizeFormat( pag, had, &cbwfxRqd );
    if (MMSYSERR_NOERROR != mmr)
    {
        return (mmr);
    }
    if (pafd->cbwfx < cbwfxRqd)
    {
        DebugErr1(DBF_ERROR, "acmFormatEnum: cbwfx member must be at least %lu for requested enumeration.", cbwfxRqd);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd->pwfx, pafd->cbwfx, MMSYSERR_INVALPARAM);

    if (0L != pafd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFormatEnum: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }


    DPF(1, "***** FORMAT ENUM fdwEnum=%.08lXh *****************************", fdwEnum);

    //
    //  Get the restrictions on the enum.
    //
    uFormatTag = WAVE_FORMAT_UNKNOWN;
    fFormatTag = (0 != (fdwEnum & ACM_FORMATENUMF_WFORMATTAG));

    if (fFormatTag)
    {
        uFormatTag = (UINT)pafd->pwfx->wFormatTag;

        if (WAVE_FORMAT_UNKNOWN == uFormatTag)
        {
            DebugErr(DBF_ERROR, "acmFormatEnum: ACM_FORMATENUMF_WFORMATTAG cannot be used with WAVE_FORMAT_UNKNOWN.");
            return (MMSYSERR_INVALPARAM);
        }

        if (pafd->dwFormatTag != uFormatTag)
        {
            DebugErr(DBF_ERROR, "acmFormatEnum: format tags must match.");
            return  (MMSYSERR_INVALPARAM);
        }
    }


    //
    //
    //
    fConvert = (0 != (fdwEnum & ACM_FORMATENUMF_CONVERT));
    fSuggest = (0 != (fdwEnum & ACM_FORMATENUMF_SUGGEST));

    // find the size of the source format for restrictions
    if (fConvert || fSuggest)
    {
        uFormatSize = SIZEOF_WAVEFORMATEX(pafd->pwfx);
        V_RWAVEFORMAT(pafd->pwfx, MMSYSERR_INVALPARAM);

        if (WAVE_FORMAT_UNKNOWN == pafd->pwfx->wFormatTag)
        {
            DebugErr(DBF_ERROR, "acmFormatEnum: _CONVERT and _SUGGEST cannot be used with WAVE_FORMAT_UNKNOWN.");
            return (MMSYSERR_INVALPARAM);
        }
    }
    else
    {
        // if we are not using the convert or suggest restrictions
        // then we do not need the full format
        uFormatSize = sizeof(PCMWAVEFORMAT);
    }

    // Alloc a copy of the source format for restrictions
    pwfxSrc = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, uFormatSize);
    if (NULL == pwfxSrc)
    {
        return (MMSYSERR_NOMEM);
    }

    // Init the copy
    _fmemcpy(pwfxSrc, pafd->pwfx, uFormatSize);


    //
    //
    //
    mmr = MMSYSERR_NOERROR;

    hdrvrMapper = NULL;
    if (0 != (fdwEnum & ACM_FORMATENUMF_HARDWARE))
    {
#ifdef WIN32
	hdrvrMapper = OpenDriver(gszWavemapper, gszSecDriversW, 0L);
#else
	hdrvrMapper = OpenDriver(gszWavemapper, gszSecDrivers, 0L);
#endif
	
    }

    //
    //  IF a driver is specified, then enum from that driver only.
    //
    //
    if (NULL != had)
    {
        fNoDrivers = FALSE;

        padid = (PACMDRIVERID)((PACMDRIVER)had)->hadid;

        //
        //  step through all format tags that the caller is interested in
        //  and enumerate the formats...
        //
        for (u = 0; u < padid->cFormatTags; u++)
        {
            if (fFormatTag)
            {
                if (uFormatTag != padid->paFormatTagCache[u].dwFormatTag)
                    continue;
            }

	    aftd.cbStruct = sizeof(aftd);
	    aftd.dwFormatTagIndex   = u;
	    mmr = IFormatTagDetails(pag, (HACMDRIVERID)padid,
				    &aftd, ACM_FORMATTAGDETAILSF_INDEX);

	    if (MMSYSERR_NOERROR == mmr)
	    {
		
		if (fSuggest)
		{
		    mmr = ISuggestEnum(hdrvrMapper,
				       had,
				       &aftd,
				       pafd,
				       fnCallback,
				       dwInstance,
				       pwfxSrc,
				       fdwEnum);
		}
		else
		{
		    mmr = IFormatEnum(hdrvrMapper,
				      had,
				      &aftd,
				      pafd,
				      fnCallback,
				      dwInstance,
				      pwfxSrc,
				      fdwEnum);
		}
	    }

	    if ((mmr == MMSYSERR_ERROR) || fFormatTag)
	    {
		// Returned generic error to stop the enumeration.
		mmr = MMSYSERR_NOERROR;
		break;
	    }
        }
    }
    else if (fFormatTag)
    {
        PACMDRIVERID    padidBestCount;
        UINT            uBestCountFormat;
	DWORD		cBestCount;

        hadid = NULL;
        fNoDrivers = (!fConvert && !fSuggest);
        padidBestCount = NULL;
	cBestCount = 0;

        ENTER_LIST_SHARED;

        while (!IDriverGetNext(pag, &hadid, hadid, 0L))
        {
            fNoDrivers = FALSE;

            padid = (PACMDRIVERID)hadid;

            //
            //  find the format tag that caller is interested in and
            //  enumerate the formats...
            //
            for (u = 0; u < padid->cFormatTags; u++)
            {
                if (uFormatTag != padid->paFormatTagCache[u].dwFormatTag)
                    continue;

		aftd.cbStruct = sizeof(aftd);
		aftd.dwFormatTagIndex   = u;
		mmr = IFormatTagDetails(pag, (HACMDRIVERID)padid,
					&aftd, ACM_FORMATTAGDETAILSF_INDEX);

		if (MMSYSERR_NOERROR == mmr)
		{

		    if ( !padidBestCount ||
			 (aftd.cStandardFormats > cBestCount ) )
		    {
			padidBestCount	    = padid;
			cBestCount	    = aftd.cStandardFormats;
			uBestCountFormat    = u;
		    }
		}

                break;

            }
        }

        if (NULL != padidBestCount)
        {
            HACMDRIVER  had;

	    aftd.cbStruct = sizeof(aftd);
	    aftd.dwFormatTagIndex   = uBestCountFormat;
	    mmr = IFormatTagDetails(pag, (HACMDRIVERID)padidBestCount,
				    &aftd, ACM_FORMATTAGDETAILSF_INDEX);

	    if (MMSYSERR_NOERROR == mmr) {
		mmr = acmDriverOpen(&had, (HACMDRIVERID)padidBestCount, 0L);
	    }
	
            if (MMSYSERR_NOERROR == mmr)
            {
                if (fSuggest)
                {
                    mmr = ISuggestEnum(hdrvrMapper,
                                       had,
				       &aftd,
                                       pafd,
                                       fnCallback,
                                       dwInstance,
                                       pwfxSrc,
                                       fdwEnum);
                }
                else
                {
                    mmr = IFormatEnum(hdrvrMapper,
                                      had,
                                      &aftd,
                                      pafd,
                                      fnCallback,
                                      dwInstance,
                                      pwfxSrc,
                                      fdwEnum);
                }

                acmDriverClose(had, 0L);

                if (MMSYSERR_ERROR == mmr)
                {
                    // Returned generic error to stop the enumeration.
                    mmr = MMSYSERR_NOERROR;
                }
            }
        }

        if (fNoDrivers && (WAVE_FORMAT_PCM != uFormatTag))
        {
            fNoDrivers = FALSE;
        }

        LEAVE_LIST_SHARED;
    }
    else
    {
        // Enum formats across all drivers.

        fNoDrivers = (!fConvert && !fSuggest);
        hadid = NULL;

        ENTER_LIST_SHARED;

        while (!IDriverGetNext(pag, &hadid, hadid, 0L))
        {
            HACMDRIVER  had;

            fNoDrivers = FALSE;
            padid = (PACMDRIVERID)hadid;

            if (fConvert || fSuggest)
            {
                uFormatTag = pwfxSrc->wFormatTag;

                //
                //  for every FormatTag in the driver
                //
                for (u = 0; u < padid->cFormatTags; u++)
                {
		    if (uFormatTag == padid->paFormatTagCache[u].dwFormatTag)
                    {
                        //
                        //  flag that this driver supports that tag
                        //
                        uFormatTag = WAVE_FORMAT_UNKNOWN;
                        break;
                    }
                }

                if (WAVE_FORMAT_UNKNOWN != uFormatTag)
                {
                    //
                    //  the current driver does not support the format
                    //  tag, so skip to the next driver...
                    //
                    continue;
                }
            }

            mmr = acmDriverOpen(&had, hadid, 0L);
            if (MMSYSERR_NOERROR != mmr)
            {
                continue;
            }

            for (uIndex = 0; uIndex < padid->cFormatTags; uIndex++)
            {
		aftd.cbStruct = sizeof(aftd);
		aftd.dwFormatTagIndex   = uIndex;
		mmr = IFormatTagDetails(pag, (HACMDRIVERID)padid,
					&aftd, ACM_FORMATTAGDETAILSF_INDEX);


		if (MMSYSERR_NOERROR == mmr)
		{
		    //
		    //  we have a format that has not been sent yet.
		    //
		    if (fSuggest)
		    {
			mmr = ISuggestEnum(hdrvrMapper,
					   had,
					   &aftd,
					   pafd,
					   fnCallback,
					   dwInstance,
					   pwfxSrc,
					   fdwEnum);
		    }
		    else
		    {
			mmr = IFormatEnum(hdrvrMapper,
					  had,
					  &aftd,
					  pafd,
					  fnCallback,
					  dwInstance,
					  pwfxSrc,
					  fdwEnum);
		    }
		}

                if (MMSYSERR_ERROR == mmr)
                {
                    // Returned generic error to stop the enumeration.
                    break;
                }
            }

            acmDriverClose(had, 0L);

            if (MMSYSERR_ERROR == mmr)
            {
                mmr = MMSYSERR_NOERROR;
                break;
            }
        }

        LEAVE_LIST_SHARED;

    }

    //
    //
    //
    if (fNoDrivers)
    {
        IHardwareEnum(hdrvrMapper, pafd, fnCallback, dwInstance, pwfxSrc, fdwEnum);
    }


    if (NULL != hdrvrMapper)
    {
        CloseDriver(hdrvrMapper, 0L, 0L);
    }

    // Free the copy of the source format
    GlobalFreePtr(pwfxSrc);

    //
    //
    //
    return (mmr);
}

#ifdef WIN32
#if TRUE    // defined(UNICODE)

typedef struct tIFORMATENUMCBINSTANCEW
{
    ACMFORMATENUMCBA            fnCallback;
    DWORD_PTR                   dwInstance;
    LPACMFORMATDETAILSA         pafd;

} IFORMATENUMCBINSTANCEW, *PIFORMATENUMCBINSTANCEW;

BOOL FNWCALLBACK IFormatEnumCallbackW
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILSW     pafdW,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    PIFORMATENUMCBINSTANCEW     pfi;
    BOOL                        f;

    pfi = (PIFORMATENUMCBINSTANCEW)dwInstance;

    memcpy(&pfi->pafd->dwFormatIndex,
           &pafdW->dwFormatIndex,
           FIELD_OFFSET(ACMFORMATDETAILSA, szFormat) -
           FIELD_OFFSET(ACMFORMATDETAILSA, dwFormatIndex));

    pfi->pafd->cbStruct = sizeof(*pfi->pafd);
    Iwcstombs(pfi->pafd->szFormat, pafdW->szFormat, sizeof(pfi->pafd->szFormat));

    f = pfi->fnCallback(hadid, pfi->pafd, pfi->dwInstance, fdwSupport);

    return (f);
}


MMRESULT ACMAPI acmFormatEnumA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    ACMFORMATENUMCBA        fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
)
{
    MMRESULT                    mmr;
    ACMFORMATDETAILSW           afdW;
    IFORMATENUMCBINSTANCEW      fi;

    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*pafd) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    afdW.cbStruct = sizeof(afdW);
    memcpy(&afdW.dwFormatIndex,
           &pafd->dwFormatIndex,
           FIELD_OFFSET(ACMFORMATDETAILSA, szFormat) -
           FIELD_OFFSET(ACMFORMATDETAILSA, dwFormatIndex));

    fi.fnCallback = fnCallback;
    fi.dwInstance = dwInstance;
    fi.pafd       = pafd;

    mmr = acmFormatEnumW(had, &afdW, IFormatEnumCallbackW, (DWORD_PTR)&fi, fdwEnum);

    return (mmr);
}
#else
MMRESULT ACMAPI acmFormatEnumW
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    ACMFORMATENUMCBW        fnCallback,
    DWORD                   dwInstance,
    DWORD                   fdwEnum
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\acmthunk.h ===
//==========================================================================;
//
//  acmthunk.h
//
//  Copyright (c) 1991-1995 Microsoft Corporation
//
//  Description:
//      Definitions for thunking between 16-bit (WOW) and 32-bit (WOW)
//      ACMs.
//
//  History:
//
//==========================================================================;

//
//  Function ids for calling across the thunking layer (used by both sides)
//
enum {
   acmThunkDriverMessageId32 = 1,
   acmThunkDriverMessage32,
   acmThunkDriverGetNext32,
   acmThunkDriverGetInfo32,
   acmThunkDriverPriority32,
   acmThunkDriverLoad32,
   acmThunkDriverOpen32,
   acmThunkDriverClose32,
   acmThunkFindAndBoot32
};


//
//  Thunking support
//
//

#ifdef WIN4
//
//  The thunked function prototype
//
DWORD WINAPI acmMessage32(DWORD dwThunkId, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5);

//
//  Thunk message to our thunk window
//
#define WM_ACMMESSAGETHUNK  (WM_USER)
#endif



#ifdef WIN32

//
//  Some protos
//
PVOID FNLOCAL ptrFixMap16To32(const VOID * pv);
VOID  FNLOCAL ptrUnFix16(const VOID * pv);

#ifdef WIN4
//
//	--== Chicago specific ==--
//

//
//  Thunk helper routines in Chicago kernel
//
extern PVOID WINAPI MapSL(const VOID * pv);
extern PVOID WINAPI MapSLFix(const VOID * pv);
extern VOID  WINAPI UnMapSLFixArray(DWORD dwCnt, const VOID * lpSels[]);


#else	// WIN4 else
//
//	--== NT WOW specific ==--
//

#define GET_VDM_POINTER_NAME            "WOWGetVDMPointer"
#define GET_HANDLE_MAPPER16             "WOWHandle16"
#define GET_HANDLE_MAPPER32             "WOWHandle32"
#define GET_MAPPING_MODULE_NAME         TEXT("wow32.dll")

typedef LPVOID (APIENTRY *LPGETVDMPOINTER)( DWORD Address, DWORD dwBytes, BOOL fProtectMode );
#define WOW32ResolveMemory( p ) (LPVOID)(GetVdmPointer( (DWORD)(p), 0, TRUE ))

typedef HANDLE  (APIENTRY *LPWOWHANDLE32)(WORD, WOW_HANDLE_TYPE);
typedef WORD    (APIENTRY *LPWOWHANDLE16)(HANDLE, WOW_HANDLE_TYPE);

#endif	// !WIN4

#endif	// WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\chooseri.h ===
// Copyright (c) 1994-1995 Microsoft Corporation
//
//  Context-sensitive help is only available for WINVER>=0x0400
//
#if WINVER>=0x0400
#define USECONTEXTHELP
#endif


/*
 * Format storage
 */
 
/*
 *  this pragma disables the warning issued by the Microsoft C compiler
 *  when using a zero size array as place holder when compiling for
 *  C++ or with -W4.
 *
 */
#ifdef _MSC_VER
#pragma warning(disable:4200)
#endif

/* Custom Format Name Body */
typedef struct tNameStore {
    unsigned short cbSize;          // SizeOf this structure
    TCHAR       achName[];          // The name
} NameStore, *PNameStore, FAR * LPNameStore;

#ifdef _MSC_VER
#pragma warning(default:4200)
#endif

#define NAMELEN(x) (((x)->cbSize-sizeof(NameStore))/sizeof(TCHAR))
#define STRING_LEN 128

/* Custom Format Body */
typedef struct tCustomFormatStore {
    DWORD           cbSize;         // SizeOf this structure
    NameStore       ns;             // Custom name
    
//  WAVEFORMATEX    wfx;            // Custom format (concatenated)
//          or
//  WAVEFILTER      wf;             // Custom filter
    
} CustomFormatStore, *PCustomFormatStore, FAR * LPCustomFormatStore;

//
//  This structure is just CustomFormatStore without the NameStore.  It is
//  used only by GetCustomFormat() and SetCustomFormat(), and is used to
//  separate the name from the Format or Filter structure so that it can
//  be stored in a separate key in msacm.ini.  That way we don't have to
//  worry about whether the name is unicode or ansi...
//
typedef struct tCustomFormatStoreNoName {
    DWORD           cbSize;         // SizeOf this structure
//  WAVEFORMATEX    wfx;            // Custom format (concatenated)
//          or
//  WAVEFILTER      wf;             // Custom filter
} CustomFormatStoreNoName, *PCustomFormatStoreNoName, FAR * LPCustomFormatStoreNoName;

/* Custom Format Header - this is what matters */
typedef struct tCustomFormat {
    struct tCustomFormat FAR * pcfNext;
    struct tCustomFormat FAR * pcfPrev;
    LPNameStore     pns;            // Pointer to the description
    union {
        LPBYTE          pbody;          // Pointer to the stored format
        LPWAVEFORMATEX  pwfx;
        LPWAVEFILTER    pwfltr;
    };
} CustomFormat, *PCustomFormat, FAR * LPCustomFormat;

/* Extended Custom Format Header for body offset */
typedef struct tCustomFormatEx {
    struct tCustomFormat FAR * pcfNext;
    struct tCustomFormat FAR * pcfPrev;
    LPNameStore     pns;            // Pointer to the description
    union {
        LPBYTE          pbody;          // Pointer to the stored format
        LPWAVEFORMATEX  pwfx;
        LPWAVEFILTER    pwfltr;
    };
    CustomFormatStore cfs;          // The actual data
} CustomFormatEx, *PCustomFormatEx, FAR * LPCustomFormatEx;

/*
 * Custom format pool structures
 */

/* A description of the format pool */
typedef struct tCustomFormatPool {
    LPCustomFormat  pcfHead;        // Head
    LPCustomFormat  pcfTail;        // Tail
} CustomFormatPool, *PCustomFormatPool, FAR *LPCustomFormatPool;

typedef UINT (WINAPI *CHOOSEHOOKPROC)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

/*****************************************************************************
 * @doc INTERNAL
 * 
 * @types InstData | This stores global variables for a filter chooser
 * instance.  GetProp/SetProp will be used to assign this to a dialog.
 *
 * @field UINT | uType | Specifies the type of the instance data
 *
 * @field LPCustomFormat | pcf | Pointer the current custom choice
 *
 * @field HWND | hwnd | Window handle of the dialog.
 *
 * @field HWND | hFormatTags | Window handle to the FormatTags dropdown listbox
 *     
 * @field HWND | hFormats | Window handle to the Formats dropdown listbox
 *     
 * @field UINT | uiFormatTab | Tabstop for the Formats dropdown listbox
 *
 * @field HWND | hCustomFormats | Window handle to the Custom dropdown listbox
 *
 * @field HWND | hOk | Window handle to the OK button
 *
 * @field HWND | hCancel | Window handle to the Cancel button
 *
 * @field HWND | hHelp | Window handle to the Help button
 *
 * @field HWND | hSetName | Window handle to the Set Name button
 *
 * @field HWND | hDelName | Window handle to the Delete Name button
 *
 * @field HWND * | pahNotify | The array of windows that will be notified
 * when custom changes are made.
 *
 * @field HANDLE | hFileMapping | Handle to a file mapping if used (Win32 only)
 *
 * @field PNameStore | pnsTemp | Temporary string storage
 *
 * @field PNameStore | pnsStrOut | Temporary string storage
 *
 * @field CustomFormatPool | cfp | Global CustomFormat Pool
 *
 * @field UINT | uUpdateMsg | Private message to communicate CF changes.
 *
 * @field LPACMFORMATCHOOSE | pcfmtc | Initialization structure
 * @field LPACMFILTERCHOOSE | pcfltrc | Initialization structure
 *
 * @field PACMGARB | pag | Pointer to the ACMGARB structure associated
 * with this instance of the ACM.
 *
 ****************************************************************************/

typedef struct tInstData {
    UINT            uType;
    MMRESULT        mmrSubFailure;   // Failure in an acm subfunction
    LPCustomFormat  pcf;        // Current custom format
    HWND            hwnd;
    HWND            hFormatTags;
    int             iPrevFormatTagsSel; // previous selection
    
    HWND            hFormats;
    UINT            uiFormatTab;
    
    HWND            hCustomFormats;

    HWND            hOk;
    HWND            hCancel;
    HWND            hHelp;

    HWND            hSetName;
    HWND            hDelName;

    /* Instance data */
    HWND *          pahNotify;  // The array of HWND's to notify.
    
#ifdef WIN32
    HANDLE          hFileMapping;
#endif
    
    PNameStore      pnsTemp;    // Walk all over this.
    PNameStore      pnsStrOut;  // Another temporary NameStore
    CustomFormatPool cfp;       // Global CustomFormat Pool
    UINT            uUpdateMsg; // Private WM_WININICHANGE
    UINT            uHelpMsg;   // Help button to parent
#ifdef USECONTEXTHELP
    UINT            uHelpContextMenu;   // Help context menu to parent
    UINT            uHelpContextHelp;   // Help context help to parent
#endif // USECONTEXTHELP
    HKEY            hkeyFormats;    // HKEY corresponding to key name.
    CHOOSEHOOKPROC  pfnHook;        // Hook proc
    BOOL            fEnableHook;    // Hook enabled.
    LPBYTE          lpbSel;         // return data
    DWORD           dwTag;          // Generic 'Tag'

#if defined(WIN32) && !defined(UNICODE)
    LPWSTR          pszName;        // Choice name buffer
#else
    LPTSTR          pszName;        // Choice name buffer
#endif
    DWORD           cchName;         // Choice buffer length
    BOOL            fTagFilter;     // Filter for an explicit 'Tag'.

    UINT            cdwTags;          // count of tags
    DWORD *         pdwTags;        // pointer to array of tags
    UINT            cbwfxEnum;
    UINT            cbwfltrEnum;
    LPACMFORMATDETAILS  pafdSimple;

    union {
        LPACMFORMATCHOOSE pfmtc;    // Initialization structure
        LPACMFILTERCHOOSE pafltrc;  // Initialization structure
    };                              // Chooser Specific

    PACMGARB	    pag;
    
} InstData, *PInstData, FAR * LPInstData;

enum { FILTER_CHOOSE, FORMAT_CHOOSE };

#define MAX_HWND_NOTIFY             100
#define MAX_CUSTOM_FORMATS          100
#define MAX_FORMAT_KEY               64

/*
 * Save instance data in a property to give others access to the DWL_USER
 */
#ifdef WIN32
    #define SetInstData(hwnd, p) SetProp(hwnd,gszInstProp,(HANDLE)(p))
    #define GetInstData(hwnd)    (PInstData)(LPVOID)GetProp(hwnd, gszInstProp)
    #define RemoveInstData(hwnd) RemoveProp(hwnd,gszInstProp)
#else
    #define SetInstData(hwnd, p) SetProp(hwnd,gszInstProp,(HANDLE)(p))
    #define GetInstData(hwnd)    (PInstData)GetProp(hwnd, gszInstProp)
    #define RemoveInstData(hwnd) RemoveProp(hwnd,gszInstProp)
#endif


/*
 * For passing near pointers in lparams
 */
#ifdef WIN32
    #define PTR2LPARAM(x)       (LPARAM)(VOID *)(x)
    #define LPARAM2PTR(x)       (VOID *)(x)    
#else
    #define PTR2LPARAM(x)       MAKELPARAM(x,0)
    #define LPARAM2PTR(x)       (VOID *)LOWORD(x)
#endif


//
//  This routine deleted a NameStore object allocated by NewNameStore().
//
__inline void
DeleteNameStore ( PNameStore pns )
{
    LocalFree((HLOCAL)pns);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1995 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef WIN32
#define DEBUG_MODULE_NAME       "MSACM32"   // key name and prefix for output
#else
#define DEBUG_MODULE_NAME       "MSACM"     // key name and prefix for output
#endif

#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//  #pragma message(REMIND("this is a reminder"))
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define DEBUG_QUOTE(x)      #x
#define DEBUG_QQUOTE(y)     DEBUG_QUOTE(y)
#define REMIND(sz)          __FILE__ "(" DEBUG_QQUOTE(__LINE__) ") : " sz

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef RDEBUG
#ifdef WIN32
    #define DebugErr(flags, sz)		DPF(0, sz)
    #define DebugErr1(flags, sz, a)	DPF(0, sz, a)
    #define DebugErr2(flags, sz, a, b)  DPF(0, sz, a, b)
#else
    #define DebugErr(flags, sz)         {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx);}
    #define DebugErr1(flags, sz, a)     {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx, a);}
    #define DebugErr2(flags, sz, a, b)  {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx, a, b);}
#endif
#else
    #define DebugErr(flags, sz)
    #define DebugErr1(flags, sz, a)
    #define DebugErr2(flags, sz, a, b)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\locks.h ===
//==========================================================================;
//
//  locks.h
//
//  Copyright (c) 1994-1999 Microsoft Corporation
//
//  Description:
//      Implement simplified lock objects for win32
//
//  History:
//
//==========================================================================;

#pragma pack(push, 8)

typedef struct {
    CRITICAL_SECTION CriticalSection;      // Protects these fields
    HANDLE           SharedEvent;          // Wait on this for shared
    BOOL             SharedEventSet;       // State of shared event (optimize)
    HANDLE           ExclusiveEvent;       // Wait on this for exclusive
    BOOL             ExclusiveEventSet;    // State of non-shared event (optimize)
    LONG             NumberOfActive;       // > 0 if shared, < 0 if exclusive
    DWORD            ExclusiveOwnerThread; // Whose got it exclusive
} LOCK_INFO, *PLOCK_INFO;

#pragma pack(pop)

BOOL InitializeLock		(PLOCK_INFO);
VOID AcquireLockShared		(PLOCK_INFO);
VOID AcquireLockExclusive	(PLOCK_INFO);
VOID ReleaseLock		(PLOCK_INFO);
VOID DeleteLock			(PLOCK_INFO);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\chooser.c ===
//==========================================================================;
//
//  chooser.c
//
//  (C) Copyright (c) 1992-1999 Microsoft Corporation
//
//  Description:
//      This is the sound format chooser dialog.
//
//  History:
//      05/13/93 JYG     Created
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#ifdef WIN32
#include <wchar.h>
#else
#include <ctype.h>
#endif
#include <stdlib.h>
#include <stdarg.h>
#include <winuserp.h>

#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "msacmdlg.h"
#include "uchelp.h"
#include "chooseri.h"
#include "profile.h"
#include "debug.h"


enum { ChooseCancel = 0,
       ChooseOk,
       ChooseSubFailure,
       ChooseNoMem };
//
//
//
#if defined(WIN32) && defined(UNICODE)
#define istspace iswspace
#else
#define istspace isspace
#endif

//
//  to quickly hack around overlapping and unimaginative defines..
//
#define IDD_BTN_HELP        IDD_ACMFORMATCHOOSE_BTN_HELP
#define IDD_CMB_CUSTOM      IDD_ACMFORMATCHOOSE_CMB_CUSTOM
#define IDD_CMB_FORMATTAG   IDD_ACMFORMATCHOOSE_CMB_FORMATTAG
#define IDD_CMB_FORMAT      IDD_ACMFORMATCHOOSE_CMB_FORMAT
#define IDD_BTN_SETNAME     IDD_ACMFORMATCHOOSE_BTN_SETNAME
#define IDD_BTN_DELNAME     IDD_ACMFORMATCHOOSE_BTN_DELNAME



/* Property string */
TCHAR BCODE gszInstProp[]        = TEXT("MSACM Chooser Prop");

/* Chooser notify message */
TCHAR BCODE gszFilterRegMsg[]    = TEXT("MSACM Filter Notify");
TCHAR BCODE gszFormatRegMsg[]    = TEXT("MSACM Format Notify");

/* Registry key and value names */
TCHAR BCODE gszKeyWaveFormats[]	= TEXT("WaveFormats");
TCHAR BCODE gszKeyWaveFilters[]	= TEXT("WaveFilters");
TCHAR BCODE gszValueDefaultFormat[] = TEXT("DefaultFormat");
TCHAR BCODE gszValueSystemFormats[] = TEXT("SystemFormats");

#if 0
/* Help files and keys */
#if (WINVER >= 0x0400)
TCHAR BCODE gszFormatHelp[]      = TEXT("CHOOSER.HLP");
TCHAR BCODE gszFilterHelp[]      = TEXT("FILTER.HLP");
#else
TCHAR BCODE gszFormatHelp[]      = TEXT("CHOO_WIN.HLP");
TCHAR BCODE gszFilterHelp[]      = TEXT("FIL_WIN.HLP");
#endif
#endif

/* Arbitrary maximum on number of windows to notify. */
#ifndef WIN32
static HWND ahNotify[MAX_HWND_NOTIFY];
#else
TCHAR BCODE gszChooserFileMapping[] = TEXT("MSACM Chooser File Mapping");
#endif

/*      -       -       -       -       -       -       -       -       -   */
/*
 * Function Declarations
 */
INT_PTR FNWCALLBACK NewSndDlgProc(HWND hwnd,
				  unsigned msg,
				  WPARAM wParam,
				  LPARAM lParam);

INT_PTR FNWCALLBACK NewNameDlgProc(HWND hwnd,
				   unsigned msg,
				   WPARAM wParam,
				   LPARAM lParam);

void FNLOCAL InitCustomFormats(PInstData pInst);

LPCustomFormat FNLOCAL GetCustomFormat(PInstData pInst,
                                       LPCTSTR lpszName);

LPCustomFormat FNLOCAL NewCustomFormat(PInstData pInst,
                                       PNameStore pnsName,
                                       LPBYTE lpBuffer);

BOOL FNLOCAL AddCustomFormat(PInstData pInst,
                             LPCustomFormat pcf);

BOOL FNLOCAL RemoveCustomFormat(PInstData pInst,
                                LPCustomFormat pcf);

void FNLOCAL DeleteCustomFormat(LPCustomFormat pcf);
void FNLOCAL EmptyCustomFormats(PInstData pInst);

void FNGLOBAL AppProfileWriteBytes(HKEY hkeyFormats,
                                   LPCTSTR pszKey,
                                   LPBYTE pbStruct,
                                   UINT cbStruct);

BOOL FNGLOBAL AppProfileReadBytes(HKEY hkey,
                                  LPCTSTR pszKey,
                                  LPBYTE pbStruct,
                                  UINT cbStruct,
                                  BOOL fChecksum);

void FNLOCAL SetName(PInstData pInst);
void FNLOCAL DelName(PInstData pInst);

PNameStore FNLOCAL NewNameStore(UINT cchLen);

LRESULT FNLOCAL InitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
BOOL FNWCALLBACK FormatTagsCallback(HACMDRIVERID hadid,
                                      LPACMFORMATDETAILS paftd,
                                      DWORD_PTR dwInstance,
                                      DWORD fdwSupport);

BOOL FNWCALLBACK FormatTagsCallbackSimple
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);


BOOL FNWCALLBACK FormatsCallback(HACMDRIVERID hadid,
                                   LPACMFORMATDETAILS pafd,
                                   DWORD_PTR dwInstance,
                                   DWORD fdwSupport);

BOOL FNWCALLBACK FilterTagsCallback(HACMDRIVERID hadid,
                                      LPACMFILTERTAGDETAILS paftd,
                                      DWORD_PTR dwInstance,
                                      DWORD fdwSupport);

BOOL FNWCALLBACK FiltersCallback(HACMDRIVERID hadid,
                                   LPACMFILTERDETAILS pafd,
                                   DWORD_PTR dwInstance,
                                   DWORD fdwSupport);


void FNLOCAL RefreshCustomFormats(PInstData pInst,BOOL fCheckEnum);
MMRESULT FNLOCAL RefreshFormatTags(PInstData pInst);
void FNLOCAL RefreshFormats(PInstData pInst);
void FNLOCAL EmptyFormats(PInstData pInst);

static int FAR cdecl ErrorResBox(HWND hwnd,
				 HINSTANCE hInst,
				 WORD flags,
				 WORD idAppName,
				 WORD idErrorStr, ...);

PInstData FNLOCAL NewInstance(LPBYTE pbChoose,UINT uType);

LPBYTE FNLOCAL CopyStruct(LPBYTE lpDest,
                       LPBYTE lpByte, UINT uType);

void FNLOCAL UpdateCustomFormats(PInstData pInst);
void FNLOCAL SelectCustomFormat(PInstData pInst);
void FNLOCAL SelectFormatTag(PInstData pInst);
void FNLOCAL SelectFormat(PInstData pInst);
void FNLOCAL FindSelCustomFormat(PInstData pInst);

BOOL FNLOCAL FindFormat(PInstData pInst,LPWAVEFORMATEX lpwfx,BOOL fExact);
BOOL FNLOCAL FindFilter(PInstData pInst,LPWAVEFILTER lpwf,BOOL fExact);

void FNLOCAL MashNameWithRate(PInstData pInst,
                              PNameStore pnsDest,
                              PNameStore pnsSrc,
                              LPWAVEFORMATEX pwfx);

void FNLOCAL RegisterUpdateNotify(PInstData pInst);
void FNLOCAL UnRegisterUpdateNotify(PInstData pInst);

BOOL FNLOCAL FindInitCustomFormat(PInstData pInst);
void FNLOCAL TagUnavailable(PInstData pInst);
/*      -       -       -       -       -       -       -       -       -   */
/* Custom Format Stuff */

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | IsSystemName | Determines whether the name is
 *	system name.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPNameStore | pns | Pointer to name store
 *
 *  @parm DWORD | dwFlags | Flags
 *
 *  @flag ISSYSTEMNAMEF_DEFAULT | See if this name matches the system
 *	default name.
 *
 *  @rdesc Returns TRUE if and only if the name is a system name.
 *
 *  @comm System format names are names that are defined by the system.
 *	We should not allow users to remove these names.  The names of the
 *	system formats are stored as a string in the registry
 *	under the value named SystemFormats.  Currently, we don't have
 *	system filter names, only system format names.
 *
 ****************************************************************************/
#define ISSYSTEMNAMEF_DEFAULT 0x00000001L
BOOL FNLOCAL
IsSystemName ( PInstData pInst,
	     LPNameStore pns,
	     DWORD dwFlags)
{
    HKEY hkey;
    DWORD dwType;
    DWORD cbData;
    LPTSTR lpstrFormatNames;
    LPCTSTR lpstrValueName;
    BOOL fIsSystemName;
    LONG lError;

    //
    //	This stuff only defined for formats, not filters
    //
    if (pInst->uType != FORMAT_CHOOSE)
	return FALSE;

    //
    //
    //
    hkey = IRegOpenKeyAudio(NULL);
    if (NULL == hkey) {
	return FALSE;
    }

    //
    //
    //
    if (ISSYSTEMNAMEF_DEFAULT && dwFlags) {
	lpstrValueName = gszValueDefaultFormat;
    } else {
	lpstrValueName = gszValueSystemFormats;
    }

    //
    //	Determine size of buffer required to hold the string of
    //	system format names.
    //
    fIsSystemName = FALSE;
    lError = XRegQueryValueEx( hkey,
			      (LPTSTR)lpstrValueName,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData );

    if ( (ERROR_SUCCESS == lError) && (REG_SZ == dwType) )
    {
	//
	//  Allocate buffer to receive string of system format names plus an
	//  extra terminator.
	//
	cbData += sizeof(TCHAR);
	lpstrFormatNames = GlobalAllocPtr(GHND, cbData);
	if (NULL != lpstrFormatNames)
	{
	    lError = XRegQueryValueEx( hkey,
				      (LPTSTR)lpstrValueName,
				      NULL,
				      &dwType,
				      (LPBYTE)lpstrFormatNames,
				      &cbData );
	    if ( (ERROR_SUCCESS == lError) && (REG_SZ == dwType) )
	    {
		LPTSTR psz;

		//
		//  The string contains the system format names delimited
		//  by commas.  We walk psz through the string looking for
		//  the comma delimiter and replace the delimiter with
		//  a NULL terminator.  Then add an extra terminator at
		//  the end.  This makes the subsequent processing easier.
		//
		psz = lpstrFormatNames;
		while (*psz != TEXT('\0')) {
		    if (*psz == TEXT(',')) *psz = TEXT('\0');
		    psz++;
		}
		*(++psz) = TEXT('\0');
		

		psz = lpstrFormatNames;
		while (*psz != TEXT('\0'))
		{
		    //
		    //	See if it compares to the selected name.
		    //
		    if (!lstrcmp(psz, pns->achName)) {
			fIsSystemName = TRUE;
			break;
		    }

		    //
		    //	Bump psz to next name string
		    //
		    while (*psz++ != TEXT('\0'));
		}
	    }

	    GlobalFreePtr(lpstrFormatNames);
	}
    }

    XRegCloseKey(hkey);

	
    return fIsSystemName;
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api VOID FNLOCAL | SetSystemDefaultName | Sets the user's default name
 *	to the system defined default name (ie, the default default).
 *
 *  @parm PInstData | pInst |
 *
 *  @rdesc void
 *
 *  @comm The default format name is selected via the control panel.  The
 *	selected default format name is stored as a string in the registry
 *	under the value named DefaultFormat.  Currently, we don't have
 *	default filter names, only default format names.  If the user deletes
 *	the format name that is currently selected as the default, then we
 *	call this function to set the default to the system-defined default.
 *
 ****************************************************************************/
VOID FNLOCAL
SetSystemDefaultName ( PInstData pInst )
{
    HKEY hkey;
    DWORD dwType;
    DWORD cbData;
    LPTSTR lpstrSystemFormats;
    BOOL fIsSystemName;
    LONG lError;

    //
    //	This stuff only defined for formats, not filters
    //
    if (pInst->uType != FORMAT_CHOOSE)
	return;

    //
    //
    //
    hkey = IRegOpenKeyAudio(NULL);
    if (NULL == hkey) {
	return;
    }

    //
    //	Determine size of buffer required to hold the string of
    //	system format names.
    //
    fIsSystemName = FALSE;
    lError = XRegQueryValueEx( hkey,
			      (LPTSTR)gszValueSystemFormats,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData );

    if ( (ERROR_SUCCESS == lError) && (REG_SZ == dwType) )
    {
	//
	//  Allocate buffer to receive string of system format names plus an
	//  extra terminator.
	//
	cbData += sizeof(TCHAR);
	lpstrSystemFormats = GlobalAllocPtr(GHND, cbData);
	if (NULL != lpstrSystemFormats)
	{
	    lError = XRegQueryValueEx( hkey,
				      (LPTSTR)gszValueSystemFormats,
				      NULL,
				      &dwType,
				      (LPBYTE)lpstrSystemFormats,
				      &cbData );
	    if ( (ERROR_SUCCESS == lError) && (REG_SZ == dwType) )
	    {
		LPTSTR psz;

		//
		//  The string contains the system format names delimited
		//  by commas.  We walk psz through the string looking for
		//  the comma delimiter and replace the delimiter with
		//  a NULL terminator.  Then add an extra terminator at
		//  the end.  This makes the subsequent processing easier.
		//
		psz = lpstrSystemFormats;
		while (*psz != TEXT('\0')) {
		    if (*psz == TEXT(',')) *psz = TEXT('\0');
		    psz++;
		}
		*(++psz) = TEXT('\0');
		

		psz = lpstrSystemFormats;

        IRegWriteString( hkey, gszValueDefaultFormat, psz );
	    }
	
	    GlobalFreePtr(lpstrSystemFormats);
	}
    }

    XRegCloseKey(hkey);

	
    return;
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | IsCustomName | Walks the list to detect name clashes.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm PNameStore | pns |
 *
 ****************************************************************************/
BOOL FNLOCAL
IsCustomName ( PInstData pInst,
               PNameStore pns )
{
    BOOL            fHit = FALSE;
    LPCustomFormat  pcf;

    /* search the list for hits */
    pcf = pInst->cfp.pcfHead;
    while (pcf != NULL && !fHit)
    {
        fHit = (lstrcmp(pns->achName,pcf->pns->achName) == 0);
        pcf = pcf->pcfNext;
    }
    return (fHit);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | IsValidName | Checks for particular names that we
 *	    do not want to allow.  In particular, "[untitled]".
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm PNameStore | pns |
 *
 ****************************************************************************/
BOOL FNLOCAL
IsValidName ( PInstData pInst,
	      PNameStore pns )
{
    TCHAR   ach[STRING_LEN];

    LoadString(pInst->pag->hinst, IDS_TXT_UNTITLED, ach, STRING_LEN);

    return (0 != lstrcmp(pns->achName, ach));

}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | RemoveOutsideWhitespace | Removes leading and
 *		trailing whitespace
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm PNameStore | pns |
 *
 *  @rdesc  Returns FALSE if blank.
 *
 ****************************************************************************/
BOOL FNLOCAL
RemoveOutsideWhitespace ( PInstData pInst,
			  PNameStore pns )
{
    LPTSTR      lpchName;


    /* eat leading white space */

    lpchName = pns->achName;
    while (*lpchName && istspace(*lpchName))
        lpchName = CharNext(lpchName);

    if (!*lpchName)
        return (FALSE);

    if (lpchName != pns->achName)
        lstrcpy (pns->achName, lpchName);


    /* eat trailing white space */

    //	Walk lpchName to last char in string
    lpchName = pns->achName;
    while (*lpchName) lpchName = CharNext(lpchName);
    lpchName = CharPrev(pns->achName, lpchName);
    //	Now back up, replacing each white space char with a NULL char, til
    //	we back up to the first non-white space char.
    while (istspace(*lpchName))
    {
	*lpchName = 0;
	lpchName = CharPrev(pns->achName, lpchName);
    }

    return (TRUE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api LPCustomFormat FNLOCAL | NewCustomFormat | Given a Name and a Format,
 *  create a CustomFormat that can be saved in a single data block
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm PNameStore | pnsName |
 *
 *  @parm LPBYTE | lpBuffer |
 *
 ****************************************************************************/
LPCustomFormat FNLOCAL
NewCustomFormat ( PInstData     pInst,
                  PNameStore    pnsName,
                  LPBYTE        lpBuffer )
{
    DWORD               cbSize;
    DWORD               cbBody;
    UINT                cbName;
    LPCustomFormatEx    pcf;

    if (!pnsName || !lpBuffer)
        return (NULL);

    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
        {
            LPWAVEFORMATEX pwfxFormat = (LPWAVEFORMATEX)lpBuffer;

            // sizeof WAVEFORMATEX
            cbBody = SIZEOF_WAVEFORMATEX(pwfxFormat);
            break;
        }
        case FILTER_CHOOSE:
        {
            LPWAVEFILTER pwfltr = (LPWAVEFILTER)lpBuffer;

            // sizeof WAVEFFILTER
            cbBody = pwfltr->cbStruct;
            break;
        }
    }

    // sizeof NameStore
    cbName = (lstrlen(pnsName->achName)+1)*sizeof(TCHAR) + sizeof(NameStore);
    // sizeof CustomFormatStore = sizeof(cbSize) + NAME + BODY
    cbSize = sizeof(DWORD) + cbName + cbBody;

    pcf = (LPCustomFormatEx)GlobalAllocPtr(GHND,cbSize+sizeof(CustomFormat));

    if (pcf)
    {
        /* point the CustomFormat header to the right places */
        pcf->cfs.cbSize = cbSize;
        pcf->pns = &pcf->cfs.ns;
        pcf->pbody = ((LPBYTE)pcf->pns + cbName);

        /* copy in the name and format */
        _fmemcpy((LPBYTE)pcf->pns, (LPBYTE)pnsName, cbName);
        pcf->pns->cbSize = (unsigned short)cbName;
        _fmemcpy(pcf->pbody, lpBuffer, (UINT)cbBody);

        pcf->pcfNext = NULL;
        pcf->pcfPrev = NULL;
    }
    return ((LPCustomFormat)pcf);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | DeleteCustomFormat
 *
 *  @parm LPCustomFormat | pcf |
 *
 ****************************************************************************/
void FNLOCAL
DeleteCustomFormat ( LPCustomFormat pcf )
{
    GlobalFreePtr(pcf);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | InitCustomFormats | Load all the custom formats into
 *  instance dependant data
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @comm The custom formats are found by enumerating all the value names
 *	under the registry key
 *
 ****************************************************************************/
void FNLOCAL
InitCustomFormats ( PInstData pInst )
{
    LPCustomFormat  pcf;
    DWORD	    dwIndex;
    TCHAR	    szName[STRING_LEN];
    DWORD	    cchName;
    LONG	    lr;


    //
    //  If the registry key is not open, we can't read anything...
    //
    if( NULL == pInst->hkeyFormats )
    {
        DPF(1,"InitCustomFormats: can't read registry, hkey==NULL.");
        return;
    }


    //
    //	Format names correspond to the value names in the registry.
    //	Enumerate all value names to find all the format names.
    //
    dwIndex = 0;
    cchName = STRING_LEN;
    while( ERROR_NO_MORE_ITEMS != (lr = XRegEnumValue( pInst->hkeyFormats,
	                                              dwIndex,
	                                              szName,
	                                              &cchName,
	                                              NULL, NULL, NULL, NULL) ) )
    {
	if (ERROR_SUCCESS == lr)
	{
	    pcf = GetCustomFormat(pInst, szName);
	    if (pcf)
	    {
		AddCustomFormat(pInst, pcf);
	    }
	}

	dwIndex++;
	cchName = STRING_LEN;
    }

    return;
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | AddCustomFormat | Add a custom format to the format
 *  pool.  This must be a shared function that maintains a shared memory to
 *  prevent actual munging of the WIN.INI section and coordination.  Adding
 *  also causes updates to open instances.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPCustomFormat | pcf |
 *
 ****************************************************************************/
BOOL FNLOCAL
AddCustomFormat ( PInstData pInst,
                  LPCustomFormat pcf )
{
    if (pInst->cfp.pcfHead == NULL)
    {
        /* add it to the head/tail */
        pInst->cfp.pcfHead = pcf;
        pInst->cfp.pcfTail = pcf;
        pcf->pcfNext = NULL;
        pcf->pcfPrev = NULL;
    }
    else
    {
        /* add it to the tail */
        pInst->cfp.pcfTail->pcfNext = pcf;
        pcf->pcfPrev = pInst->cfp.pcfTail;
        pInst->cfp.pcfTail = pcf;
        pcf->pcfNext = NULL;
    }

    return (TRUE);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | RemoveCustomFormat | Remove a custom format element
 *  from the pool
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPCustomFormat | pcf |
 *
 ****************************************************************************/
BOOL FNLOCAL
RemoveCustomFormat ( PInstData pInst,
                     LPCustomFormat pcf )
{
    if (pInst->cfp.pcfHead == pcf)
    {
        /* we are the head */
        pInst->cfp.pcfHead = pcf->pcfNext;
    }
    if (pInst->cfp.pcfTail == pcf)
    {
        /* we are the tail */
        pInst->cfp.pcfTail = pcf->pcfPrev;
    }

    /* Unlink */
    if (pcf->pcfPrev)
        pcf->pcfPrev->pcfNext = pcf->pcfNext;
    if (pcf->pcfNext)
        pcf->pcfNext->pcfPrev = pcf->pcfPrev;

    //
    //	If we are deleting the user default name, then we should
    //	set the system-defined default name.
    //
    if (IsSystemName(pInst, pcf->pns, ISSYSTEMNAMEF_DEFAULT)) {
	SetSystemDefaultName(pInst);
    }

    //
    //	Remove name from registry
    //
    XRegDeleteValue(pInst->hkeyFormats, pcf->pns->achName);

    //
    //
    //
    DeleteCustomFormat(pcf);
    return (TRUE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api LPCustomFormat FNLOCAL | GetCustomFormat | Grab from the registry the
 *  binary data associated with the custom name.  Return a structure that
 *  points to right offsets in the chunk.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPCTSTR | lpstrName | The custom format name.
 *
 ****************************************************************************/
LPCustomFormat FNLOCAL
GetCustomFormat ( PInstData pInst,
                  LPCTSTR lpstrName )   // The custom format name
{
    LPCustomFormatEx            pcf;
    LPCustomFormatStore         pcfs;
    DWORD                       cbSize;
    LPCustomFormatStoreNoName   pnn;
    PNameStore                  pns;
    UINT                        cchName;
    DWORD			dwValueType;
    LPTSTR                      psz;


    //
    //  We assume that we won't be called if we can't access the registry.
    //
    ASSERT( NULL != pInst->hkeyFormats );


    //
    //  First, let's store the name of the Format or Filter.
    //
    cchName = lstrlen( lpstrName );
    pns     = NewNameStore( cchName+1 );
    if( NULL == pns )
        return NULL;

    psz     = (LPTSTR)( ((LPBYTE)pns) + sizeof(NameStore) );
    lstrcpy(psz, lpstrName);
    pns->cbSize = (unsigned short)( (cchName+1) * sizeof(TCHAR) +
                                        sizeof(NameStore) );


    //
    //  Now find out the size of the CustomFormatStoreNoName.  This would be
    //	the sizeof(CustomFormatStoreNoName) + the size of the data in
    //	the registry.
    //
    if ( (ERROR_SUCCESS != XRegQueryValueEx( pInst->hkeyFormats,
					    psz,
					    NULL,
					    &dwValueType,
					    NULL,
					    &cbSize )) ||
	 (REG_BINARY != dwValueType) )
    {
        DeleteNameStore( pns );
        return (NULL);
    }
    cbSize += sizeof(CustomFormatStoreNoName);


    //
    //  Allocate the CustomFormat structure (the one we return).
    //
    pcf = (LPCustomFormatEx)GlobalAllocPtr( GHND,
                        cbSize + pns->cbSize + sizeof(CustomFormat) );
    if (!pcf)
    {
        DeleteNameStore( pns );
        return (NULL);
    }
    pcfs = &pcf->cfs;


    //
    //  Copy the custom name into the structure.
    //
    pcf->pns = &pcfs->ns;
    _fmemcpy( (LPBYTE)pcf->pns, (LPBYTE)pns, pns->cbSize );
    DeleteNameStore( pns );


    //
    //  Now read in the full CustomFormatStoreNoName structure.  We must
    //  allocate cbSize bytes for it, as read in previously.
    //
    pnn = (LPCustomFormatStoreNoName)GlobalAllocPtr( GHND, cbSize );
    if( NULL == pnn )
    {
        GlobalFreePtr( pcf );
        return NULL;
    }
    pnn->cbSize = cbSize;
    cbSize -= sizeof(CustomFormatStoreNoName);
    if (ERROR_SUCCESS != XRegQueryValueEx( pInst->hkeyFormats,
					  pcf->pns->achName,
					  NULL,
					  &dwValueType,
					  ((LPBYTE)&pnn->cbSize) + sizeof(pnn->cbSize),
					  &cbSize))
    {
        GlobalFreePtr( pnn );
        GlobalFreePtr(pcf);
        return (NULL);
    }


    //
    //  Now copy the format data into the CustomFormatStore of pcf.
    //
    pcfs->cbSize    = pnn->cbSize + pcfs->ns.cbSize;
    pcf->pbody      = ((LPBYTE)&pcfs->ns) + pcfs->ns.cbSize;
    _fmemcpy( (LPBYTE)pcf->pbody,
              ((LPBYTE)pnn) + sizeof(pnn->cbSize),
              (int)pnn->cbSize - sizeof(pnn->cbSize) );
    GlobalFreePtr( pnn );

    return ((LPCustomFormat)pcf);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | SetCustomFormat | Write a custom format to the registry
 *
 *  @parm   HKEY | hkey | handle to registry key in which to write
 *
 *  @parm   LPCustomFormat | pcf | ptr to CustomFormat
 *
 *  @rdesc  Returns TRUE if and only if successful
 *
 ****************************************************************************/
BOOL FNLOCAL
SetCustomFormat ( HKEY hkey,
                  LPCustomFormat pcf )
{
    LPCustomFormatEx	pcfx = (LPCustomFormatEx)pcf;
    LONG		lr;


    //
    //  We assume that we won't be called if we can't access the registry.
    //
    ASSERT( NULL != hkey );

    //
    //
    //
    lr = XRegSetValueEx( hkey,
			pcfx->pns->achName,
			0L,
			REG_BINARY,
			pcfx->pbody,
			pcfx->cfs.cbSize );

    return (ERROR_SUCCESS == lr);
}


/*  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api PInstData | NewInstance |
 *
 *  @parm LPBYTE | pbChoose |
 *
 *  @parm UINT | uType |
 *
 ****************************************************************************/
PInstData FNLOCAL
NewInstance(LPBYTE pbChoose, UINT uType)
{
    PInstData   pInst;
    PACMGARB	pag;

    pag = pagFind();
    if (NULL == pag)
    {
	return (NULL);
    }

    pInst = (PInstData)LocalAlloc(LPTR,sizeof(InstData));
    if (!pInst)
        return (NULL);

    pInst->pag = pag;

    pInst->pnsTemp = NewNameStore(STRING_LEN);
    if (!pInst->pnsTemp)
        goto exitfail;

    pInst->pnsStrOut = NewNameStore(STRING_LEN);
    if (!pInst->pnsStrOut)
    {
        DeleteNameStore(pInst->pnsTemp);
        goto exitfail;
    }

    switch (uType)
    {
        case FORMAT_CHOOSE:
            pInst->pfmtc = (LPACMFORMATCHOOSE)pbChoose;
            pInst->uUpdateMsg = RegisterWindowMessage(gszFormatRegMsg);
            pInst->hkeyFormats = IRegOpenKeyAudio( gszKeyWaveFormats );
            pInst->fEnableHook = (pInst->pfmtc->fdwStyle &
                                  ACMFORMATCHOOSE_STYLEF_ENABLEHOOK) != 0;
            pInst->pfnHook = pInst->pfmtc->pfnHook;
            pInst->pszName = pInst->pfmtc->pszName;
            pInst->cchName = pInst->pfmtc->cchName;

            break;
        case FILTER_CHOOSE:
            pInst->pafltrc = (LPACMFILTERCHOOSE)pbChoose;
            pInst->uUpdateMsg = RegisterWindowMessage(gszFilterRegMsg);
            pInst->hkeyFormats = IRegOpenKeyAudio( gszKeyWaveFilters );
            pInst->fEnableHook = (pInst->pafltrc->fdwStyle &
                                  ACMFILTERCHOOSE_STYLEF_ENABLEHOOK) != 0;
            pInst->pfnHook = pInst->pafltrc->pfnHook;
            pInst->pszName = pInst->pafltrc->pszName;
            pInst->cchName = pInst->pafltrc->cchName;

            break;
    }

    pInst->mmrSubFailure = MMSYSERR_NOERROR;
    pInst->uType = uType;
    pInst->cfp.pcfHead = NULL;
    pInst->cfp.pcfTail = NULL;
    pInst->pcf = NULL;
    return (pInst);

exitfail:
    LocalFree((HLOCAL)pInst);
    return (NULL);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | DeleteInstance |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
DeleteInstance ( PInstData pInst )
{
    EmptyCustomFormats(pInst);
    DeleteNameStore(pInst->pnsTemp);
    DeleteNameStore(pInst->pnsStrOut);
    IRegCloseKey( pInst->hkeyFormats );
    LocalFree((HLOCAL)pInst);
}

/*  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | EmptyCustomFormats |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
EmptyCustomFormats ( PInstData pInst )
{
    LPCustomFormat pcf;
    LPCustomFormat pcfNext;

    pcf = pInst->cfp.pcfHead;
    while (pcf != NULL)
    {
        pcfNext = pcf->pcfNext;
        DeleteCustomFormat(pcf);
        pcf = pcfNext;
    }
    pInst->cfp.pcfHead = NULL;
    pInst->cfp.pcfTail = NULL;
    pInst->pcf = NULL;
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | FlushCustomForamts | Write out all custom formats to INI
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
FlushCustomFormats ( PInstData pInst )
{
    LPCustomFormat      pcf;
    PCustomFormatPool   pcfp = &pInst->cfp;


    //
    //  We can't save anything if we can't access the registry key.
    //
    if( NULL == pInst->hkeyFormats )
    {
        DPF(1,"FlushCustomFormats: Can't access registry, hkeyFormats==NULL.");
        return;
    }

    //
    //  Write out the currently-defined formats.
    //
    pcf = pcfp->pcfHead;
    while (pcf != NULL)
    {
	SetCustomFormat(pInst->hkeyFormats,pcf);
	pcf = pcf->pcfNext;
    }

}



/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | RegisterUpdateNotify | Register this window as
 *  requesting a private notification when changes take place in our section
 *  of the INI file.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
RegisterUpdateNotify ( PInstData pInst )
{
    int         i;

#ifdef WIN32
    //a. Get or Create the memory mapping that has all the hwnd's
    HANDLE      hMap;

    hMap = CreateFileMapping(INVALID_HANDLE_VALUE,
                             NULL,
                             PAGE_READWRITE,
                             0L,
                             sizeof(HWND)*MAX_HWND_NOTIFY,
                             (LPTSTR)gszChooserFileMapping);

    pInst->hFileMapping = hMap;
    pInst->pahNotify = NULL;

    if (hMap)
    {
        pInst->pahNotify = (HWND *)MapViewOfFile(hMap,
                                                 FILE_MAP_ALL_ACCESS,
                                                 0L,
                                                 0L,
                                                 0L);
    }

    if (!pInst->pahNotify)
        return;

#else
    //a. Add this hwnd to the static array of hwnds.

    pInst->pahNotify = ahNotify;
#endif

    //NOTE: since this is shared data, it is reusable and generally
    // stepped on while MSACM is resident, which means forever.  This
    // means that we should be extra sure that there aren't duplicate
    // hwnd values in the array.

    /* Scan the array for an invalid value and reuse it */
    for (i = 0; i < MAX_HWND_NOTIFY; i++)
        if (pInst->pahNotify[i] == 0 || pInst->pahNotify[i] == pInst->hwnd ||
            !IsWindow(pInst->pahNotify[i]))
        {
            pInst->pahNotify[i] = pInst->hwnd;
            break;
        }
    for (i++; i < MAX_HWND_NOTIFY; i++)
        if (pInst->pahNotify[i] == pInst->hwnd)
        {
            pInst->pahNotify[i] = 0;
        }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void | UnRegisterUpdateNotify | Unregister this window from the
 *  global shared pool of window handles.  This removes us from further
 *  notificiations.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
UnRegisterUpdateNotify ( PInstData pInst )
{
    int         i;
    if (pInst->pahNotify)
    {
        for (i = 0; i < MAX_HWND_NOTIFY; i++)
            if (pInst->pahNotify[i] == pInst->hwnd)
            {
                pInst->pahNotify[i] = 0;
                break;
            }

#ifdef WIN32
        UnmapViewOfFile((LPVOID)pInst->pahNotify);
#endif
    }

#ifdef WIN32
    if (pInst->hFileMapping)
        CloseHandle(pInst->hFileMapping);
#endif
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | NotifyINIChange |  Notify all ACM common choosers of
 *  this "type" to update from the INI cache as a global name change has occured.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
NotifyINIChange ( PInstData pInst )
{
    int         i;

    /* Tell sibling instances */
    if (!pInst->pahNotify)
        return;

    for (i = 0; i < MAX_HWND_NOTIFY; i++)
    {
        if (pInst->pahNotify[i] == 0 || pInst->pahNotify[i] == pInst->hwnd)
            continue;

        if (IsWindow(pInst->pahNotify[i]))
        {
            PostMessage(pInst->pahNotify[i],pInst->uUpdateMsg,0,0L);
        }
        else
            pInst->pahNotify[i] = 0;
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | CopyStruct | Depending upon the "type" of structure
 *  (FORMAT|FILTER) allocate or  reallocate and copy.
 *
 *  @parm LPBYTE | lpDest |
 *
 *  @parm LPBYTE | lpSrc |
 *
 *  @parm UINT | uType |
 *
 ****************************************************************************/
LPBYTE FNLOCAL
CopyStruct ( LPBYTE     lpDest,
             LPBYTE     lpSrc,
             UINT       uType )
{
    LPBYTE      lpBuffer;
    DWORD       cbSize;

    if (!lpSrc)
        return (NULL);

    switch (uType)
    {
        case FORMAT_CHOOSE:
        {
            LPWAVEFORMATEX lpwfx = (LPWAVEFORMATEX)lpSrc;
            cbSize = SIZEOF_WAVEFORMATEX(lpwfx);
            break;
        }
        case FILTER_CHOOSE:
        {
            LPWAVEFILTER lpwf = (LPWAVEFILTER)lpSrc;
            cbSize = lpwf->cbStruct;
            break;
        }
    }

    if (lpDest)
    {
        lpBuffer = (LPBYTE)GlobalReAllocPtr(lpDest,cbSize,GHND);
    }
    else
    {
        lpBuffer = (LPBYTE)GlobalAllocPtr(GHND,cbSize);
    }

    if (!lpBuffer)
        return (NULL);

    _fmemcpy(lpBuffer, lpSrc, (UINT)cbSize);
    return (lpBuffer);
}

/*  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/
/* misc. */


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api PNameStore FNLOCAL | NewNameStore | Allocates a sized string buffer
 *
 *  @parm UINT | cchLen | Maximum number of characters in string (inc. NULL)
 *
 ****************************************************************************/
PNameStore FNLOCAL
NewNameStore ( UINT cchLen )
{
    UINT        cbSize;
    PNameStore  pName;

    cbSize = cchLen*sizeof(TCHAR) + sizeof(NameStore);

    pName = (PNameStore)LocalAlloc(LPTR,cbSize);
    if (pName)
        pName->cbSize = (unsigned short)cbSize;

    return (pName);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | DeleteNameStore |
 *
 *  @parm PNameStore | pns |
 *
 ****************************************************************************/
//
//  This routine is now inlined in chooseri.h.
//


/*      -       -       -       -       -       -       -       -       -   */

/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMFILTERCHOOSE | The <t ACMFILTERCHOOSE> structure contains
 *      information the Audio Compression Manager (ACM) uses to initialize
 *      the system-defined wave filter selection dialog box. After the
 *      user closes the dialog box, the system returns information about
 *      the user's selection in this structure.
 *
 *  @field DWORD | cbStruct | Specifies the size in bytes of the
 *      <t ACMFILTERCHOOSE> structure. This member must be initialized
 *      before calling the <f acmFilterChoose> function. The size specified
 *      in this member must be large enough to contain the base
 *      <t ACMFILTERCHOOSE> structure.
 *
 *  @field DWORD | fdwStyle | Specifies optional style flags for the
 *      <f acmFilterChoose> function. This member must be initialized to
 *      a valid combination of the following flags before calling the
 *      <f acmFilterChoose> function.
 *
 *      @flag ACMFILTERCHOOSE_STYLEF_ENABLEHOOK | Enables the hook function
 *      specified in the <e ACMFILTERCHOOSE.pfnHook> member. An application
 *      can use hook functions for a variety of customizations, including
 *      answering the <f MM_ACM_FILTERCHOOSE> message.
 *
 *      @flag ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE | Causes the ACM to
 *      create the dialog box template identified by the
 *      <e ACMFILTERCHOOSE.hInstance> and <e ACMFILTERCHOOSE.pszTemplateName>
 *      members.
 *
 *      @flag ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE | Indicates that
 *      the <e ACMFILTERCHOOSE.hInstance> member identifies a data block that
 *      contains a preloaded dialog box template. The ACM ignores the
 *      <e ACMFILTERCHOOSE.pszTemplateName> member if this flag is specified.
 *
 *      @flag ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT | Indicates that the
 *      buffer pointed to by <e ACMFILTERCHOOSE.pwfltr> contains a valid
 *      <t WAVEFILTER> structure that the dialog will use as the initial
 *      selection.
 *
 *      @flag ACMFILTERCHOOSE_STYLEF_SHOWHELP | Indicates that a help button
 *      will appear in the dialog box. To use a custom Help file, an application
 *      must register the <c ACMHELPMSGSTRING> constant
 *      with <f RegisterWindowMessage>.  When the user presses the help button,
 *      the registered message is posted to the owner.
 *
 *  @field HWND | hwndOwner | Identifies the window that owns the dialog
 *      box. This member can be any valid window handle, or NULL if the
 *      dialog box has no owner. This member must be initialized before
 *      calling the <f acmFilterChoose> function.
 *
 *  @field LPWAVEFILTER | pwfltr | Specifies a pointer to a <t WAVEFILTER>
 *      structure. If the ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT flag is
 *      specified in the <e ACMFILTERCHOOSE.fdwStyle> member, then this
 *      structure must be initialized to a valid filter. When the
 *      <f acmFilterChoose> function returns, this buffer contains the
 *      selected filter. If the user cancels the dialog, no changes will
 *      be made to this buffer.
 *
 *  @field DWORD | cbwfltr | Specifies the size in bytes of the buffer pointed
 *      to by the <e ACMFILTERCHOOSE.pwfltr> member. The <f acmFilterChoose>
 *      function returns ACMERR_NOTPOSSIBLE if the buffer is too small to
 *      contain the filter information; also, the ACM copies the required size
 *      into this member. An application can use the <f acmMetrics> and
 *      <f acmFilterTagDetails> functions to determine the largest size
 *      required for this buffer.
 *
 *  @field LPCSTR | pszTitle | Points to a string to be placed in the title
 *      bar of the dialog box. If this member is NULL, the ACM uses the
 *      default title (that is, "Filter Selection").
 *
 *  @field char | szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS] |
 *      When the <f acmFilterChoose> function returns, this buffer contains
 *      a NULL-terminated string describing the filter tag of the filter
 *      selection. This string is equivalent to the
 *      <e ACMFILTERTAGDETAILS.szFilterTag> member of the <t ACMFILTERTAGDETAILS>
 *      structure returned by <f acmFilterTagDetails>. If the user cancels
 *      the dialog, this member will contain a NULL string.
 *
 *  @field char | szFilter[ACMFILTERDETAILS_FILTER_CHARS] | When the
 *      <f acmFilterChoose> function returns, this buffer contains a
 *      NULL-terminated string describing the filter attributes of the
 *      filter selection. This string is equivalent to the
 *      <e ACMFILTERDETAILS.szFilter> member of the <t ACMFILTERDETAILS>
 *      structure returned by <f acmFilterDetails>. If the user cancels
 *      the dialog, this member will contain a NULL string.
 *
 *  @field LPSTR | pszName | Points to a string for a user-defined filter
 *      name. If this is a non-NULL string, then the ACM attempts to
 *      match the name with a previously saved user-defined filter name.
 *      If a match is found, then the dialog is initialized to that filter.
 *      If a match is not found or this member is a NULL string, then this
 *      member is ignored for input. When the <f acmFilterChoose> function
 *      returns, this buffer contains a NULL-terminated string describing
 *      the user-defined filter. If the filter name is untitled (that is,
 *      the user has not given a name for the filter), then this member will
 *      be a NULL string on return. If the user cancels the dialog, no
 *      changes will be made to this buffer.
 *
 *      If the ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT flag is specified in
 *      the <e ACMFILTERCHOOSE.fdwStyle> member, then the
 *      <e ACMFILTERCHOOSE.pszName> is ignored as an input parameter.
 *
 *  @field DWORD | cchName | Specifies the size, in characters, of the
 *      buffer identified by the <e ACMFILTERCHOOSE.pszName> member. This
 *      buffer should be at least 128 characters long. This parameter is
 *      ignored if the <e ACMFILTERCHOOSE.pszName> member is NULL.
 *
 *  @field DWORD | fdwEnum | Specifies optional flags for restricting the
 *      type of filters listed in the dialog. These flags are identical to
 *      the <p fdwEnum> flags for the <f acmFilterEnum> function. This
 *      member should be zero if <e ACMFILTERCHOOSE.pwfltrEnum> is NULL.
 *
 *      @flag ACM_FILTERENUMF_DWFILTERTAG | Specifies that the
 *      <e WAVEFILTER.dwFilterTag> member of the <t WAVEFILTER> structure
 *      referred to by the <e ACMFILTERCHOOSE.pwfltrEnum> member is valid. The
 *      enumerator will only enumerate a filter that conforms to this
 *      attribute.
 *
 *  @field LPWAVEFILTER | pwfltrEnum | Points to a <t WAVEFILTER> structure
 *      that will be used to restrict the filters listed in the dialog. The
 *      <e ACMFILTERCHOOSE.fdwEnum> member defines which fields from the
 *      <e ACMFILTERCHOOSE.pwfltrEnum> structure should be used for the
 *      enumeration restrictions. The <e WAVEFILTER.cbStruct> member of this
 *      <t WAVEFILTER> structure must be initialized to the size of the
 *      <t WAVEFILTER> structure. This member can be NULL if no special
 *      restrictions are desired.
 *
 *  @field HINSTANCE | hInstance | Identifies a data block that contains
 *      a dialog box template specified by the <e ACMFILTERCHOOSE.pszTemplateName>
 *      member. This member is used only if the <e ACMFILTERCHOOSE.fdwStyle>
 *      member specifies the ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE or the
 *      ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE flag; otherwise, this
 *      member should be NULL on input.
 *
 *  @field LPCSTR | pszTemplateName | Points to a NULL-terminated string that
 *      specifies the name of the resource file for the dialog box template
 *      that is to be substituted for the dialog box template in the ACM.
 *      An application can use the <f MAKEINTRESOURCE> macro for numbered
 *      dialog box resources. This member is used only if the
 *      <e ACMFILTERCHOOSE.fdwStyle> member specifies the
 *      ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE flag; otherwise, this
 *      member should be NULL on input.
 *
 *  @field LPARAM | lCustData | Specifies application-defined data that the
 *      ACM passes to the hook function identified by the
 *      <e ACMFILTERCHOOSE.pfnHook> member. The system passes the data in
 *      the <p lParam> argument of the <f WM_INITDIALOG> message.
 *
 *  @field ACMFILTERCHOOSEHOOKPROC | pfnHook | Points to a hook function that
 *      processes messages intended for the dialog box. An application must
 *      specify the ACMFILTERCHOOSE_STYLEF_ENABLEHOOK flag in the
 *      <e ACMFILTERCHOOSE.fdwStyle> member to enable the hook; otherwise,
 *      this member should be NULL. The hook function should return FALSE
 *      to pass a message to the standard dialog box procedure, or TRUE
 *      to discard the message.
 *
 *  @xref <f acmFilterChoose> <f acmFilterChooseHookProc> <f acmMetrics>
 *      <f acmFilterTagDetails> <f acmFilterDetails> <f acmFilterEnum>
 *      <f acmFormatChoose>
 *
 ****************************************************************************/

/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @msg MM_ACM_FILTERCHOOSE | This message notifies an <f acmFilterChoose> dialog hook
 *      function before adding an element to one of the three drop-down
 *      list boxes. This message allows an application to further customize
 *      the selections available through the user interface.
 *
 *  @parm WPARAM | wParam | Specifies the drop-down list box being initialized
 *      and a verify or add operation.
 *
 *      @flag FILTERCHOOSE_FILTERTAG_VERIFY | Specifies that <p lParam> is a
 *      wave filter tag to be listed in the Filter Tag drop-down list box.
 *
 *      @flag FILTERCHOOSE_FILTER_VERIFY | Specifies that <p lParam> is a
 *      pointer to a <t WAVEFILTER> structure to be added to the Filter
 *      drop-down list box.
 *
 *      @flag FILTERCHOOSE_CUSTOM_VERIFY | The <p lParam> value is a pointer
 *      to a <t WAVEFILTER> structure to be added to the custom Name
 *      drop-down list box.
 *
 *      @flag FILTERCHOOSE_FILTERTAG_ADD | Specifies that <p lParam> is a
 *      pointer to a <t DWORD> that will accept a wave filter tag to be added
 *      to the Filter Tag drop-down list box.
 *
 *      @flag FILTERCHOOSE_FILTER_ADD | Specifies that <p lParam> is a
 *      pointer to a buffer that will accept a <t WAVEFILTER> structure to be
 *      added to the Filter drop-down list box. The application must copy the
 *      filter structure to be added into this buffer.
 *
 *  @parm LPARAM | lParam | Defined by the listbox specified in the
 *      <p wParam> argument.
 *
 *  @rdesc If an application handles this message, it must return TRUE;
 *      otherwise, it must return FALSE.
 *      If processing a verify operation, the application must precede the
 *      return with
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)FALSE)> to prevent the
 *      dialog from listing this selection, or
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)TRUE)> to allow the
 *      dialog to list this selection.
 *      If processing an add operation, the application must precede the
 *      return with
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)FALSE)> to indicate that
 *      no more additions are required, or
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)TRUE)> if more additions
 *      are required.
 *
 *  @comm If processing the <m FILTERCHOOSE_FILTER_ADD> operation, the size of
 *      the memory buffer supplied in <p lParam> will be determined from
 *      <f acmMetrics>.
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api UINT ACMFILTERCHOOSEHOOKPROC | acmFilterChooseHookProc |
 *      The <f acmFilterChooseHookProc> function is a placeholder for a user-defined
 *      function to hook the <f acmFilterChoose> dialog box. Usage is
 *      equivalent to Windows Common Dialog hook functions for customizing
 *      common dialogs. See the Microsoft Windows Software Development Kit for more
 *      information about the <p uMsg>, <p wParam>, and <p lParam> parameters.
 *
 *  @parm HWND | hwnd | Specifies the window handle for the dialog box.
 *
 *  @parm UINT | uMsg | Specifies the window message.
 *
 *  @parm WPARAM | wParam | The first message parameter.
 *
 *  @parm LPARAM | lParam | The second message parameter.
 *
 *  @comm If the hook function processes the <f WM_CTLCOLOR> message, this
 *      function must return a handle of the brush that should be used to
 *      paint the control background.
 *
 *      A hook function can optionally process the <f MM_ACM_FILTERCHOOSE>
 *      message to customize the dialog selections.
 *
 *  @xref <f acmFilterChoose> <t ACMFILTERCHOOSE> <f MM_ACM_FILTERCHOOSE>
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFilterChoose | The <f acmFilterChoose> function creates
 *      an Audio Compression Manager (ACM) defined dialog box that enables
 *      the user to select a wave filter.
 *
 *  @parm LPACMFILTERCHOOSE | pafltrc | Points to an <t ACMFILTERCHOOSE>
 *      structure that contains information used to initialize the dialog
 *      box. When <f acmFilterChoose> returns, this structure contains
 *      information about the user's filter selection.
 *
 *  @rdesc Returns <c MMSYSERR_NOERROR> if the function was successful.
 *      Otherwise, it returns an error value. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_NODRIVER | A suitable driver is not available to
 *      provide valid filter selections.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The buffer identified by the
 *      <e ACMFILTERCHOOSE.pwfltr> member of the <t ACMFILTERCHOOSE> structure
 *      is too small to contain the selected filter.
 *
 *      @flag ACMERR_CANCELED | The user chose the Cancel button or the
 *      Close command on the System menu to close the dialog box.
 *
 *  @comm The <e ACMFILTERCHOOSE.pwfltr> member must be filled in with a valid
 *      pointer to a memory location that will contain the returned filter
 *      header structure. Moreover, the <e ACMFILTERCHOOSE.cbwfltr> member must
 *      be filled in with the size in bytes of this memory buffer.
 *
 *  @xref <t ACMFILTERCHOOSE> <f acmFilterChooseHookProc> <f acmFormatChoose>
 *
 ***************************************************************************/

MMRESULT ACMAPI
acmFilterChoose ( LPACMFILTERCHOOSE pafltrc )
{
    INT_PTR     iRet;
    PInstData   pInst;
#if defined(WIN32) && !defined(UNICODE)
    LPCWSTR     lpDlgTemplate = MAKEINTRESOURCEW(DLG_ACMFILTERCHOOSE_ID);
#else
    LPCTSTR     lpDlgTemplate = MAKEINTRESOURCE(DLG_ACMFILTERCHOOSE_ID);
#endif
    HINSTANCE   hInstance = NULL;
    MMRESULT    mmrResult = MMSYSERR_NOERROR;
    UINT        cbwfltrEnum;

    //
    //
    //
    if (NULL == pagFindAndBoot())
    {
	DPF(1, "acmFilterChoose: NULL pag!!!");
	return (0);
    }

    /* Begin Parameter Validation */

    V_WPOINTER(pafltrc, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pafltrc, pafltrc->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(*pafltrc) > pafltrc->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterChoose: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    V_DFLAGS(pafltrc->fdwStyle, ACMFILTERCHOOSE_STYLEF_VALID, acmFilterChoose, MMSYSERR_INVALFLAG);
    V_WPOINTER(pafltrc->pwfltr, pafltrc->cbwfltr, MMSYSERR_INVALPARAM);
#if defined(WIN32) && !defined(UNICODE)
    V_STRINGW(pafltrc->szFilter,    SIZEOFW(pafltrc->szFilter),    MMSYSERR_INVALPARAM);
    V_STRINGW(pafltrc->szFilterTag, SIZEOFW(pafltrc->szFilterTag), MMSYSERR_INVALPARAM);
#else
    V_STRING(pafltrc->szFilter,    SIZEOF(pafltrc->szFilter),    MMSYSERR_INVALPARAM);
    V_STRING(pafltrc->szFilterTag, SIZEOF(pafltrc->szFilterTag), MMSYSERR_INVALPARAM);
#endif

    // Name parm can be NULL
    if ( pafltrc->pszName )
#if defined(WIN32) && !defined(UNICODE)
	V_STRINGW(pafltrc->pszName, (UINT)pafltrc->cchName, MMSYSERR_INVALPARAM);
#else
        V_STRING(pafltrc->pszName, (UINT)pafltrc->cchName, MMSYSERR_INVALPARAM);
#endif


    V_DFLAGS(pafltrc->fdwEnum, ACM_FILTERENUMF_VALID, acmFilterChoose, MMSYSERR_INVALFLAG);


    //
    //  validate fdwEnum and pwfltrEnum so the chooser doesn't explode when
    //  an invalid combination is specified.
    //
    cbwfltrEnum = 0L;
    if (0 != (pafltrc->fdwEnum & ACM_FILTERENUMF_DWFILTERTAG))
    {
        if (NULL == pafltrc->pwfltrEnum)
        {
            DebugErr1(DBF_ERROR, "acmFilterChoose: specified fdwEnum (%.08lXh) flags require valid pwfltrEnum.", pafltrc->pwfltrEnum);
            return (MMSYSERR_INVALPARAM);
        }

        V_RWAVEFILTER(pafltrc->pwfltrEnum, MMSYSERR_INVALPARAM);
        cbwfltrEnum = (UINT)pafltrc->cbStruct;
    }
    else
    {
        if (NULL != pafltrc->pwfltrEnum)
        {
            DebugErr(DBF_ERROR, "acmFilterChoose: pwfltrEnum must be NULL for specified fdwEnum flags.");
            return (MMSYSERR_INVALPARAM);
        }
    }

    // pfnHook is valid only when ENABLEHOOK is specified
    if (pafltrc->fdwStyle & ACMFILTERCHOOSE_STYLEF_ENABLEHOOK)
        V_CALLBACK((FARPROC)pafltrc->pfnHook, MMSYSERR_INVALPARAM);

    /* End Parameter Validation */

    pInst = NewInstance((LPBYTE)pafltrc,FILTER_CHOOSE);
    if (!pInst)
    {
        mmrResult = MMSYSERR_NOMEM;
        goto afcexit;
    }

    pInst->cbwfltrEnum = cbwfltrEnum;

    hInstance = pInst->pag->hinst;
    if (pafltrc->fdwStyle & ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE)
    {
        /* ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE indicate that hInstance and
         * pszTemplateName specify a dialog template.
         */
        lpDlgTemplate = pafltrc->pszTemplateName;
        hInstance = pafltrc->hInstance;
    }


    //
    //  Restore priorities, in case another instance has modified them
    //  recently.
    //
    if( IDriverPrioritiesRestore(pInst->pag) ) {   // Something changed!
        IDriverBroadcastNotify( pInst->pag );
    }


    if (pafltrc->fdwStyle & (ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE))
    {
        /* ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE indicates that hInstance is
         * a data block containing a dialog box template.
         */
        iRet = DialogBoxIndirectParam(pInst->pag->hinst,
#ifdef WIN32
                                      (LPDLGTEMPLATE)pafltrc->hInstance,
#else
                                      pafltrc->hInstance,
#endif
                                      pafltrc->hwndOwner,
                                      NewSndDlgProc,
                                      PTR2LPARAM(pInst));

    }
    else
    {
#ifdef WIN32
	iRet = DialogBoxParamW(hInstance,
#else
        iRet = DialogBoxParam(hInstance,
#endif
                              lpDlgTemplate,
                              pafltrc->hwndOwner,
                              NewSndDlgProc,
                              PTR2LPARAM(pInst));
    }

    switch (iRet)
    {
        case -1:
            mmrResult = MMSYSERR_INVALPARAM;
            break;
        case ChooseOk:
            mmrResult = MMSYSERR_NOERROR;
            break;
        case ChooseCancel:
            mmrResult = ACMERR_CANCELED;
            break;
        case ChooseSubFailure:
            mmrResult = pInst->mmrSubFailure;
            break;
        default:
            mmrResult = MMSYSERR_NOMEM;
            break;
    }

    if (ChooseOk == iRet)
    {
        DWORD cbSize;
        LPWAVEFILTER lpwfltr = (LPWAVEFILTER)pInst->lpbSel;
        ACMFILTERDETAILS adf;
        ACMFILTERTAGDETAILS adft;

        cbSize = lpwfltr->cbStruct;

        if (pafltrc->cbwfltr > cbSize)
            pafltrc->cbwfltr = cbSize;
        else if (cbSize > pafltrc->cbwfltr)
        {
            mmrResult = ACMERR_NOTPOSSIBLE;
            goto afcexit;
        }

        if (!IsBadWritePtr((LPVOID)((LPWAVEFILTER)pafltrc->pwfltr),
                           (UINT)pafltrc->cbwfltr))
            _fmemcpy(pafltrc->pwfltr, lpwfltr, (UINT)pafltrc->cbwfltr);

        _fmemset(&adft, 0, sizeof(adft));

        adft.cbStruct = sizeof(adft);
        adft.dwFilterTag = lpwfltr->dwFilterTag;
        if (!acmFilterTagDetails(NULL,
                                 &adft,
                                 ACM_FILTERTAGDETAILSF_FILTERTAG))
#ifdef WIN32
	    lstrcpyW(pafltrc->szFilterTag,adft.szFilterTag);
#else
            lstrcpy(pafltrc->szFilterTag,adft.szFilterTag);
#endif

        adf.cbStruct      = sizeof(adf);
        adf.dwFilterIndex = 0;
        adf.dwFilterTag   = lpwfltr->dwFilterTag;
        adf.fdwSupport    = 0;
        adf.pwfltr        = lpwfltr;
        adf.cbwfltr       = cbSize;

        if (!acmFilterDetails(NULL,
                              &adf,
                              ACM_FILTERDETAILSF_FILTER))
#ifdef WIN32
	    lstrcpyW(pafltrc->szFilter,adf.szFilter);
#else
	    lstrcpy(pafltrc->szFilter,adf.szFilter);
#endif

        GlobalFreePtr(lpwfltr);
    }
afcexit:
    if (pInst)
        DeleteInstance(pInst);

    return (mmrResult);
}

#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFilterChooseA
(
    LPACMFILTERCHOOSEA      pafc
)
{
    MMRESULT            mmr;
    ACMFILTERCHOOSEW    afcW;

    V_WPOINTER(pafc, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pafc, pafc->cbStruct, MMSYSERR_INVALPARAM);
    if (sizeof(*pafc) > pafc->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterChoose: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    memset(&afcW, 0, sizeof(afcW));

    afcW.cbStruct       = sizeof(afcW);
    afcW.fdwStyle       = pafc->fdwStyle;
    afcW.hwndOwner      = pafc->hwndOwner;
    afcW.pwfltr         = pafc->pwfltr;
    afcW.cbwfltr        = pafc->cbwfltr;

    if (NULL != pafc->pszTitle)
    {
        UINT        cb;

        cb = (lstrlenA(pafc->pszTitle) + 1) * sizeof(WCHAR);

        afcW.pszTitle = (LPCWSTR)LocalAlloc(LPTR, cb);

        if (NULL != afcW.pszTitle)
        {
            Imbstowcs((LPWSTR)afcW.pszTitle, pafc->pszTitle, cb / sizeof(WCHAR));
        }
    }

    afcW.szFilterTag[0] = '\0';
    afcW.szFilter[0]    = '\0';

    if (NULL != pafc->pszName)
    {
        afcW.pszName    = (LPWSTR)LocalAlloc(LPTR, pafc->cchName * sizeof(WCHAR));
        afcW.cchName    = pafc->cchName;

        if (NULL != afcW.pszName)
        {
            Imbstowcs(afcW.pszName, pafc->pszName, pafc->cchName);
        }
    }

    afcW.fdwEnum        = pafc->fdwEnum;
    afcW.pwfltrEnum     = pafc->pwfltrEnum;
    afcW.hInstance      = pafc->hInstance;

    if (0 == HIWORD(pafc->pszTemplateName))
    {
        afcW.pszTemplateName = (LPCWSTR)pafc->pszTemplateName;
    }
    else
    {
        UINT        cb;

        cb = (lstrlenA(pafc->pszTemplateName) + 1) * sizeof(WCHAR);

        afcW.pszTemplateName = (LPCWSTR)LocalAlloc(LPTR, cb);

        if (NULL != afcW.pszTemplateName)
        {
            Imbstowcs((LPWSTR)afcW.pszTemplateName, pafc->pszTemplateName, cb / sizeof(WCHAR));
        }
    }

    afcW.lCustData      = pafc->lCustData;

    //
    //  !!! wrong !!! bad curt, bad bad bad !!!
    //
    afcW.pfnHook        = (ACMFILTERCHOOSEHOOKPROCW)pafc->pfnHook;

    mmr = acmFilterChooseW(&afcW);
    if (MMSYSERR_NOERROR == mmr)
    {
        if (NULL != afcW.pszName)
        {
            Iwcstombs(pafc->pszName, afcW.pszName, pafc->cchName);
        }

        Iwcstombs(pafc->szFilterTag, afcW.szFilterTag, sizeof(pafc->szFilterTag));
        Iwcstombs(pafc->szFilter,    afcW.szFilter,    sizeof(pafc->szFilter));
    }

    if (NULL != afcW.pszName)
    {
        LocalFree((HLOCAL)afcW.pszName);
    }

    if (NULL != afcW.pszTitle)
    {
        LocalFree((HLOCAL)afcW.pszTitle);
    }

    if (0 == HIWORD(afcW.pszTemplateName))
    {
        LocalFree((HLOCAL)afcW.pszTemplateName);
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFilterChooseW
(
    LPACMFILTERCHOOSEW      pafc
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMFORMATCHOOSE | The <t ACMFORMATCHOOSE> structure contains
 *      information the Audio Compression Manager (ACM) uses to initialize
 *      the system-defined wave format selection dialog box. After the
 *      user closes the dialog box, the system returns information about
 *      the user's selection in this structure.
 *
 *  @field DWORD | cbStruct | Specifies the size in bytes of the
 *      <t ACMFORMATCHOOSE> structure. This member must be initialized
 *      before calling the <f acmFormatChoose> function. The size specified
 *      in this member must be large enough to contain the base
 *      <t ACMFORMATCHOOSE> structure.
 *
 *  @field DWORD | fdwStyle | Specifies optional style flags for the
 *      <f acmFormatChoose> function. This member must be initialized to
 *      a valid combination of the following flags before calling the
 *      <f acmFormatChoose> function.
 *
 *      @flag ACMFORMATCHOOSE_STYLEF_ENABLEHOOK | Enables the hook function
 *      specified in the <e ACMFORMATCHOOSE.pfnHook> member. An application
 *      can use hook functions for a variety of customizations, including
 *      answering the <f MM_ACM_FORMATCHOOSE> message.
 *
 *      @flag ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE | Causes the ACM to
 *      create the dialog box template identified by the
 *      <e ACMFORMATCHOOSE.hInstance> and <e ACMFORMATCHOOSE.pszTemplateName>
 *      members.
 *
 *      @flag ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE | Indicates that
 *      the <e ACMFORMATCHOOSE.hInstance> member identifies a data block that
 *      contains a preloaded dialog box template. The ACM ignores the
 *      <e ACMFORMATCHOOSE.pszTemplateName> member if this flag is specified.
 *
 *      @flag ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT | Indicates that the
 *      buffer pointed to by <e ACMFORMATCHOOSE.pwfx> contains a valid
 *      <t WAVEFORMATEX> structure that the dialog will use as the initial
 *      selection.
 *
 *      @flag ACMFORMATCHOOSE_STYLEF_SHOWHELP | Indicates that a help button
 *      will appear in the dialog box. To use a custom Help file, an application must
 *      register the <c ACMHELPMSGSTRING> constant
 *      with <f RegisterWindowMessage>.  When the user presses the help button,
 *      the registered message will be posted to the owner.
 *
 *  @field HWND | hwndOwner | Identifies the window that owns the dialog
 *      box. This member can be any valid window handle, or NULL if the
 *      dialog box has no owner. This member must be initialized before
 *      calling the <f acmFormatChoose> function.
 *
 *  @field LPWAVEFORMATEX | pwfx | Specifies a pointer to a <t WAVEFORMATEX>
 *      structure. If the ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT flag is
 *      specified in the <e ACMFORMATCHOOSE.fdwStyle> member, then this
 *      structure must be initialized to a valid format. When the
 *      <f acmFormatChoose> function returns, this buffer contains the
 *      selected format. If the user cancels the dialog, no changes will
 *      be made to this buffer.
 *
 *  @field DWORD | cbwfx | Specifies the size in bytes of the buffer pointed
 *      to by the <e ACMFORMATCHOOSE.pwfx> member. The <f acmFormatChoose>
 *      function returns ACMERR_NOTPOSSIBLE if the buffer is too small to
 *      contain the format information; also, the ACM copies the required size
 *      into this member. An application can use the <f acmMetrics> and
 *      <f acmFormatTagDetails> functions to determine the largest size
 *      required for this buffer.
 *
 *  @field LPCSTR | pszTitle | Points to a string to be placed in the title
 *      bar of the dialog box. If this member is NULL, the ACM uses the
 *      default title (that is, "Sound Selection").
 *
 *  @field char | szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS] |
 *      When the <f acmFormatChoose> function returns, this buffer contains
 *      a NULL-terminated string describing the format tag of the format
 *      selection. This string is equivalent to the
 *      <e ACMFORMATTAGDETAILS.szFormatTag> member of the <t ACMFORMATTAGDETAILS>
 *      structure returned by <f acmFormatTagDetails>. If the user cancels
 *      the dialog, this member will contain a NULL string.
 *
 *  @field char | szFormat[ACMFORMATDETAILS_FORMAT_CHARS] | When the
 *      <f acmFormatChoose> function returns, this buffer contains a
 *      NULL-terminated string describing the format attributes of the
 *      format selection. This string is equivalent to the
 *      <e ACMFORMATDETAILS.szFormat> member of the <t ACMFORMATDETAILS>
 *      structure returned by <f acmFormatDetails>. If the user cancels
 *      the dialog, this member will contain a NULL string.
 *
 *  @field LPSTR | pszName | Points to a string for a user-defined format
 *      name. If this is a non-NULL string, then the ACM will attempt to
 *      match the name with a previously saved user-defined format name.
 *      If a match is found, then the dialog is initialized to that format.
 *      If a match is not found or this member is a NULL string, then this
 *      member is ignored for input. When the <f acmFormatChoose> function
 *      returns, this buffer contains a NULL-terminated string describing
 *      the user-defined format. If the format name is untitled (that is,
 *      the user has not given a name for the format), then this member will
 *      be a NULL string on return. If the user cancels the dialog, no
 *      changes will be made to this buffer.
 *
 *      If the ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT flag is specified in
 *      the <e ACMFORMATCHOOSE.fdwStyle> member, then the
 *      <e ACMFORMATCHOOSE.pszName> is ignored as an input parameter.
 *
 *  @field DWORD | cchName | Specifies the size, in characters, of the
 *      buffer identified by the <e ACMFORMATCHOOSE.pszName> member. This
 *      buffer should be at least 128 characters long. This parameter is
 *      ignored if the <e ACMFORMATCHOOSE.pszName> member is NULL.
 *
 *  @field DWORD | fdwEnum | Specifies optional flags for restricting the
 *      type of formats listed in the dialog. These flags are identical to
 *      the <p fdwEnum> flags for the <f acmFormatEnum> function. This
 *      member should be zero if <e ACMFORMATCHOOSE.pwfxEnum> is NULL.
 *
 *      @flag ACM_FORMATENUMF_WFORMATTAG | Specifies that the
 *      <e WAVEFORMATEX.wFormatTag> member of the <t WAVEFORMATEX> structure
 *      referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is valid. The
 *      enumerator will only enumerate a format that conforms to this
 *      attribute.
 *
 *      @flag ACM_FORMATENUMF_NCHANNELS | Specifies that the
 *      <e WAVEFORMATEX.nChannels> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is
 *      valid. The enumerator will only enumerate a format that conforms to
 *      this attribute.
 *
 *      @flag ACM_FORMATENUMF_NSAMPLESPERSEC | Specifies that the
 *      <e WAVEFORMATEX.nSamplesPerSec> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is
 *      valid. The enumerator will only enumerate a format that conforms to
 *      this attribute.
 *
 *      @flag ACM_FORMATENUMF_WBITSPERSAMPLE | Specifies that the
 *      <e WAVEFORMATEX.wBitsPerSample> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is
 *      valid. The enumerator will only enumerate a format that conforms to
 *      this attribute.
 *
 *      @flag ACM_FORMATENUMF_CONVERT | Specifies that the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is
 *      valid. The enumerator will only enumerate destination formats that
 *      can be converted from the given <e ACMFORMATCHOOSE.pwfxEnum> format.
 *
 *      @flag ACM_FORMATENUMF_SUGGEST | Specifies that the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is
 *      valid. The enumerator will enumerate all suggested destination
 *      formats for the given <e ACMFORMATCHOOSE.pwfxEnum> format.
 *
 *      @flag ACM_FORMATENUMF_HARDWARE | Specifies that the enumerator should
 *      only enumerate formats that are supported in hardware by one or
 *      more of the installed wave devices. This provides a way for an
 *      application to choose only formats native to an installed wave
 *      device.
 *
 *      @flag ACM_FORMATENUMF_INPUT | Specifies that the enumerator should
 *      only enumerate formats that are supported for input (recording).
 *
 *      @flag ACM_FORMATENUMF_OUTPUT | Specifies that the enumerator should
 *      only enumerate formats that are supported for output (playback).
 *
 *  @field LPWAVEFORMATEX | pwfxEnum | Points to a <t WAVEFORMATEX> structure
 *      that will be used to restrict the formats listed in the dialog. The
 *      <e ACMFORMATCHOOSE.fdwEnum> member defines the fields of the
 *      <e ACMFORMATCHOOSE.pwfxEnum> structure that should be used for the
 *      enumeration restrictions. This member can be NULL if no special
 *      restrictions are desired. See the description for <f acmFormatEnum>
 *      for other requirements associated with the <e ACMFORMATCHOOSE.pwfxEnum>
 *      member.
 *
 *  @field HINSTANCE | hInstance | Identifies a data block that contains
 *      a dialog box template specified by the <e ACMFORMATCHOOSE.pszTemplateName>
 *      member. This member is used only if the <e ACMFORMATCHOOSE.fdwStyle>
 *      member specifies the ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE or the
 *      ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE flag; otherwise, this
 *      member should be NULL on input.
 *
 *  @field LPCSTR | pszTemplateName | Points to a NULL-terminated string that
 *      specifies the name of the resource file for the dialog box template
 *      that is to be substituted for the dialog box template in the ACM.
 *      An application can use the <f MAKEINTRESOURCE> macro for numbered
 *      dialog box resources. This member is used only if the
 *      <e ACMFORMATCHOOSE.fdwStyle> member specifies the
 *      ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE flag; otherwise, this
 *      member should be NULL on input.
 *
 *  @field LPARAM | lCustData | Specifies application-defined data that the
 *      ACM passes to the hook function identified by the
 *      <e ACMFORMATCHOOSE.pfnHook> member. The system passes the data in
 *      the <p lParam> argument of the <f WM_INITDIALOG> message.
 *
 *  @field ACMFORMATCHOOSEHOOKPROC | pfnHook | Points to a hook function that
 *      processes messages intended for the dialog box. An application must
 *      specify the ACMFORMATCHOOSE_STYLEF_ENABLEHOOK flag in the
 *      <e ACMFORMATCHOOSE.fdwStyle> member to enable the hook; otherwise,
 *      this member should be NULL. The hook function should return FALSE
 *      to pass a message to the standard dialog box procedure, or TRUE
 *      to discard the message.
 *
 *  @xref <f acmFormatChoose> <f acmFormatChooseHookProc> <f acmMetrics>
 *      <f acmFormatTagDetails> <f acmFormatDetails> <f acmFormatEnum>
 *      <f acmFilterChoose>
 *
 ****************************************************************************/

/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @msg MM_ACM_FORMATCHOOSE | This message notifies an <f acmFormatChoose> dialog hook
 *      function before adding an element to one of the three drop-down
 *      list boxes. This message allows an application to further customize
 *      the selections available through the user interface.
 *
 *  @parm WPARAM | wParam | Specifies the drop-down listbox being initialized
 *      and a verify or add operation.
 *
 *      @flag FORMATCHOOSE_FORMATTAG_VERIFY | Specifies that <p lParam> is a
 *      wave format tag to be listed int the Format Tag drop-down list box.
 *
 *      @flag FORMATCHOOSE_FORMAT_VERIFY | Specifies that <p lParam> is a
 *      pointer to a <t WAVEFORMATEX> structure to be added to the Format
 *      drop-down list box.
 *
 *      @flag FORMATCHOOSE_CUSTOM_VERIFY | The <p lParam> value is a pointer
 *      to a <t WAVEFORMATEX> structure to be added to the custom Name
 *      drop-down list box.
 *
 *      @flag FORMATCHOOSE_FORMATTAG_ADD | Specifies that <p lParam> is a
 *      pointer to a <t DWORD> that will accept a wave format tag to be added
 *      to the Format Tag drop-down list box.
 *
 *      @flag FORMATCHOOSE_FORMAT_ADD | Specifies that <p lParam> is a
 *      pointer to a buffer that will accept a <t WAVEFORMATEX> to be added
 *      to the Format drop-down list box. The application must copy the
 *      format structre to be added into this buffer.
 *
 *  @parm LPARAM | lParam | Defined by the listbox specified in the
 *      <p wParam> parameter.
 *
 *  @rdesc If an application handles this message, it must return TRUE;
 *      otherwise, it must return FALSE.
 *      If processing a verify operation, the application must precede the
 *      return with
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)FALSE)> to prevent the
 *      dialog from listing this selection, or
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)TRUE)> to allow the
 *      dialog to list this selection.
 *      If processing an add operation, the application must precede the
 *      return with
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)FALSE)> to indicate that
 *      no more additions are required or
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)TRUE)> if more additions
 *      are required.
 *
 *  @comm If processing the <m FILTERCHOOSE_FORMAT_ADD> operation, the size
 *      of the memory buffer supplied in <p lParam> will be determined from
 *      <f acmMetrics>.
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api UINT ACMFORMATCHOOSEHOOKPROC | acmFormatChooseHookProc |
 *      The <f acmFormatChooseHookProc>  function is a placeholder for a user-defined
 *      function to hook the <f acmFormatChoose> dialog box. Usage is
 *      equivalent to the Windows Common Dialog hook functions for customizing
 *      common dialogs. See the Microsoft Windows Software Development Kit for more
 *      information about the <p uMsg>, <p wParam>, and <p lParam> parameters.
 *
 *  @parm HWND | hwnd | Specifies the window handle for the dialog box.
 *
 *  @parm UINT | uMsg | Specifies the window message.
 *
 *  @parm WPARAM | wParam | The first message parameter.
 *
 *  @parm LPARAM | lParam | The second message parameter.
 *
 *  @comm If the hook function processes the <f WM_CTLCOLOR> message, this
 *      function must return a handle of the brush that should be used to
 *      paint the control background.
 *
 *      A hook function can optionally process the <f MM_ACM_FORMATCHOOSE>
 *      message.
 *
 *  @xref <f acmFormatChoose> <t ACMFORMATCHOOSE> <f MM_ACM_FORMATCHOOSE>
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatChoose | The <f acmFormatChoose> function creates
 *      an Audio Compression Manager (ACM) defined dialog box that enables
 *      the user to select a wave format.
 *
 *  @parm LPACMFORMATCHOOSE | pfmtc | Points to an <t ACMFORMATCHOOSE>
 *      structure that contains information used to initialize the dialog
 *      box. When <f acmFormatChoose> returns, this structure contains
 *      information about the user's format selection.
 *
 *  @rdesc Returns <c MMSYSERR_NOERROR> if the function was successful.
 *      Otherwise, it returns an error value. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_NODRIVER | A suitable driver is not available to
 *      provide valid format selections.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The buffer identified by the
 *      <e ACMFORMATCHOOSE.pwfx> member of the <t ACMFORMATCHOOSE> structure
 *      is too small to contain the selected format.
 *
 *      @flag ACMERR_CANCELED | The user chose the Cancel button or the
 *      Close command on the System menu to close the dialog box.
 *
 *  @comm The <e ACMFORMATCHOOSE.pwfx> member must be filled in with a valid
 *      pointer to a memory location that will contain the returned
 *      format header structure. Moreover, the <e ACMFORMATCHOOSE.cbwfx>
 *      member must be filled in with the size in bytes of this memory buffer.
 *
 *  @xref <t ACMFORMATCHOOSE> <f acmFormatChooseHookProc> <f acmFilterChoose>
 *
 ***************************************************************************/

MMRESULT ACMAPI
acmFormatChoose ( LPACMFORMATCHOOSE pfmtc )
{
    INT_PTR     iRet;
    PInstData   pInst;
#if defined(WIN32) && !defined(UNICODE)
    LPCWSTR     lpDlgTemplate = MAKEINTRESOURCEW(DLG_ACMFORMATCHOOSE_ID);
#else
    LPCTSTR     lpDlgTemplate = MAKEINTRESOURCE(DLG_ACMFORMATCHOOSE_ID);
#endif
    HINSTANCE   hInstance = NULL;
    MMRESULT    mmrResult = MMSYSERR_NOERROR;
    UINT        cbwfxEnum;

    //
    //
    //
    if (NULL == pagFindAndBoot())
    {
	DPF(1, "acmFormatChoose: NULL pag!!!");
	return (0);
    }

    /* Begin Parameter Validation */

    V_WPOINTER(pfmtc, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pfmtc, pfmtc->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(*pfmtc) > pfmtc->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatChoose: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    V_DFLAGS(pfmtc->fdwStyle, ACMFORMATCHOOSE_STYLEF_VALID, acmFormatChoose, MMSYSERR_INVALFLAG);
    V_WPOINTER(pfmtc->pwfx, pfmtc->cbwfx, MMSYSERR_INVALPARAM);
#if defined(WIN32) && !defined(UNICODE)
    V_STRINGW(pfmtc->szFormat, SIZEOFW(pfmtc->szFormat), MMSYSERR_INVALPARAM);
    V_STRINGW(pfmtc->szFormatTag, SIZEOFW(pfmtc->szFormatTag), MMSYSERR_INVALPARAM);
#else
    V_STRING(pfmtc->szFormat, SIZEOF(pfmtc->szFormat), MMSYSERR_INVALPARAM);
    V_STRING(pfmtc->szFormatTag, SIZEOF(pfmtc->szFormatTag), MMSYSERR_INVALPARAM);
#endif

    // Name parm can be NULL
    if ( pfmtc->pszName )
#if defined(WIN32) && !defined(UNICODE)
	V_STRINGW(pfmtc->pszName, (UINT)pfmtc->cchName, MMSYSERR_INVALPARAM);
#else
	V_STRING(pfmtc->pszName, (UINT)pfmtc->cchName, MMSYSERR_INVALPARAM);
#endif

    V_DFLAGS(pfmtc->fdwEnum, ACM_FORMATENUMF_VALID, acmFormatChoose, MMSYSERR_INVALFLAG);

    //
    //  validate fdwEnum and pwfxEnum so the chooser doesn't explode when
    //  an invalid combination is specified.
    //
    if (0 != (ACM_FORMATENUMF_HARDWARE & pfmtc->fdwEnum))
    {
        if (0 == ((ACM_FORMATENUMF_INPUT|ACM_FORMATENUMF_OUTPUT) & pfmtc->fdwEnum))
        {
            DebugErr(DBF_ERROR, "acmFormatChoose: ACM_FORMATENUMF_HARDWARE requires _INPUT and/or _OUTPUT flag.");
            return (MMSYSERR_INVALFLAG);
        }
    }

    cbwfxEnum = 0;
    if (0 != (pfmtc->fdwEnum & (ACM_FORMATENUMF_WFORMATTAG |
                                ACM_FORMATENUMF_NCHANNELS |
                                ACM_FORMATENUMF_NSAMPLESPERSEC |
                                ACM_FORMATENUMF_WBITSPERSAMPLE |
                                ACM_FORMATENUMF_CONVERT |
                                ACM_FORMATENUMF_SUGGEST)))
    {
        if (NULL == pfmtc->pwfxEnum)
        {
            DebugErr1(DBF_ERROR, "acmFormatChoose: specified fdwEnum (%.08lXh) flags require valid pwfxEnum.", pfmtc->fdwEnum);
            return (MMSYSERR_INVALPARAM);
        }

        if (0 == (pfmtc->fdwEnum & (ACM_FORMATENUMF_CONVERT |
                                    ACM_FORMATENUMF_SUGGEST)))
        {
            cbwfxEnum = sizeof(PCMWAVEFORMAT);
            V_RPOINTER(pfmtc->pwfxEnum, cbwfxEnum, MMSYSERR_INVALPARAM);
        }
        else
        {
            V_RWAVEFORMAT(pfmtc->pwfxEnum, MMSYSERR_INVALPARAM);
            cbwfxEnum = SIZEOF_WAVEFORMATEX(pfmtc->pwfxEnum);
        }
    }
    else
    {
        if (NULL != pfmtc->pwfxEnum)
        {
            DebugErr(DBF_ERROR, "acmFormatChoose: pwfxEnum must be NULL for specified fdwEnum flags.");
            return (MMSYSERR_INVALPARAM);
        }
    }

    // pfnHook is valid only when ENABLEHOOK is specified
    if (pfmtc->fdwStyle & ACMFORMATCHOOSE_STYLEF_ENABLEHOOK)
        V_CALLBACK((FARPROC)pfmtc->pfnHook, MMSYSERR_INVALPARAM);

    /* End Parameter Validation */

    /* Allocate a chooser Inst structure */
    pInst = NewInstance((LPBYTE)pfmtc,FORMAT_CHOOSE);
    if (!pInst)
    {
        mmrResult = MMSYSERR_NOMEM;
        goto afcexit;
    }

    pInst->cbwfxEnum = cbwfxEnum;

    hInstance = pInst->pag->hinst;
    if (pfmtc->fdwStyle & ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE)
    {
        /* ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE indicate that hInstance and
         * pszTemplateName specify a dialog template.
         */
        lpDlgTemplate = pfmtc->pszTemplateName;
        hInstance = pfmtc->hInstance;
    }


    //
    //  Restore priorities, in case another instance has modified them
    //  recently.
    //
    if( IDriverPrioritiesRestore(pInst->pag) ) {   // Something changed!
        IDriverBroadcastNotify( pInst->pag );
    }


    if (pfmtc->fdwStyle & (ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE))
    {
        /* ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE indicates that hInstance is
         * a data block containing a dialog box template.
         */
        iRet = DialogBoxIndirectParam(pInst->pag->hinst,
#ifdef WIN32
                                      (LPDLGTEMPLATE)pfmtc->hInstance,
#else
                                      pfmtc->hInstance,
#endif
                                      pfmtc->hwndOwner,
                                      NewSndDlgProc,
                                      PTR2LPARAM(pInst));

    }
    else
    {
#ifdef WIN32
	iRet = DialogBoxParamW(hInstance,
#else
        iRet = DialogBoxParam(hInstance,
#endif
                              lpDlgTemplate,
                              pfmtc->hwndOwner,
                              NewSndDlgProc,
                              PTR2LPARAM(pInst));
    }

    switch (iRet)
    {
        case -1:
            mmrResult = MMSYSERR_INVALPARAM;
            break;
        case ChooseOk:
            mmrResult = MMSYSERR_NOERROR;
            break;
        case ChooseCancel:
            mmrResult = ACMERR_CANCELED;
            break;
        case ChooseSubFailure:
            mmrResult = pInst->mmrSubFailure;
            break;
        default:
            mmrResult = MMSYSERR_NOMEM;
            break;
    }

    if (ChooseOk == iRet)
    {
        UINT                cbSize;
        LPWAVEFORMATEX      lpwfx = (LPWAVEFORMATEX)pInst->lpbSel;
        ACMFORMATDETAILS    adf;
        ACMFORMATTAGDETAILS adft;

        cbSize = SIZEOF_WAVEFORMATEX(lpwfx);

        /* pInst has a valid wave format selected */

        if (pfmtc->cbwfx > cbSize)
            pfmtc->cbwfx = cbSize;
        else if (cbSize > pfmtc->cbwfx)
        {
            mmrResult = ACMERR_NOTPOSSIBLE;
            goto afcexit;
        }

        if (!IsBadWritePtr((LPVOID)((LPWAVEFORMATEX)pfmtc->pwfx),
                           (UINT)pfmtc->cbwfx))
            _fmemcpy(pfmtc->pwfx, lpwfx, (UINT)pfmtc->cbwfx);

        _fmemset(&adft, 0, sizeof(adft));

        adft.cbStruct = sizeof(adft);
        adft.dwFormatTag = lpwfx->wFormatTag;
        if (!acmFormatTagDetails(NULL,
                                &adft,
                                ACM_FORMATTAGDETAILSF_FORMATTAG))
#ifdef WIN32
	    lstrcpyW(pfmtc->szFormatTag,adft.szFormatTag);
#else
	    lstrcpy(pfmtc->szFormatTag,adft.szFormatTag);
#endif

        adf.cbStruct      = sizeof(adf);
        adf.dwFormatIndex = 0;
        adf.dwFormatTag   = lpwfx->wFormatTag;
        adf.fdwSupport    = 0;
        adf.pwfx          = lpwfx;
        adf.cbwfx         = cbSize;

        if (!acmFormatDetails(NULL,
                              &adf,
                              ACM_FORMATDETAILSF_FORMAT))
#ifdef WIN32
	    lstrcpyW(pfmtc->szFormat,adf.szFormat);
#else
	    lstrcpy(pfmtc->szFormat,adf.szFormat);
#endif

        GlobalFreePtr(lpwfx);
    }
afcexit:
    if (pInst)
        DeleteInstance(pInst);

    return (mmrResult);
}

#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFormatChooseA
(
    LPACMFORMATCHOOSEA      pafc
)
{
    MMRESULT            mmr;
    ACMFORMATCHOOSEW    afcW;

    V_WPOINTER(pafc, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pafc, pafc->cbStruct, MMSYSERR_INVALPARAM);
    if (sizeof(*pafc) > pafc->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatChoose: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    memset(&afcW, 0, sizeof(afcW));

    afcW.cbStruct       = sizeof(afcW);
    afcW.fdwStyle       = pafc->fdwStyle;
    afcW.hwndOwner      = pafc->hwndOwner;
    afcW.pwfx           = pafc->pwfx;
    afcW.cbwfx          = pafc->cbwfx;

    if (NULL != pafc->pszTitle)
    {
        UINT        cb;

        cb = (lstrlenA(pafc->pszTitle) + 1) * sizeof(WCHAR);

        afcW.pszTitle = (LPCWSTR)LocalAlloc(LPTR, cb);

        if (NULL != afcW.pszTitle)
        {
            Imbstowcs((LPWSTR)afcW.pszTitle, pafc->pszTitle, cb / sizeof(WCHAR));
        }
    }

    afcW.szFormatTag[0] = '\0';
    afcW.szFormat[0]    = '\0';

    if (NULL != pafc->pszName)
    {
        afcW.pszName    = (LPWSTR)LocalAlloc(LPTR, pafc->cchName * sizeof(WCHAR));
        afcW.cchName    = pafc->cchName;

        if (NULL != afcW.pszName)
        {
            Imbstowcs(afcW.pszName, pafc->pszName, pafc->cchName);
        }
    }

    afcW.fdwEnum        = pafc->fdwEnum;
    afcW.pwfxEnum       = pafc->pwfxEnum;
    afcW.hInstance      = pafc->hInstance;

    if (0 == HIWORD(pafc->pszTemplateName))
    {
        afcW.pszTemplateName = (LPCWSTR)pafc->pszTemplateName;
    }
    else
    {
        UINT        cb;

        cb = (lstrlenA(pafc->pszTemplateName) + 1) * sizeof(WCHAR);

        afcW.pszTemplateName = (LPCWSTR)LocalAlloc(LPTR, cb);

        if (NULL != afcW.pszTemplateName)
        {
            Imbstowcs((LPWSTR)afcW.pszTemplateName, pafc->pszTemplateName, cb / sizeof(WCHAR));
        }
    }

    afcW.lCustData      = pafc->lCustData;

    //
    //  !!! wrong !!! bad curt, bad bad bad !!!
    //
    afcW.pfnHook        = (ACMFORMATCHOOSEHOOKPROCW)pafc->pfnHook;

    mmr = acmFormatChooseW(&afcW);
    if (MMSYSERR_NOERROR == mmr)
    {
        if (NULL != afcW.pszName)
        {
            Iwcstombs(pafc->pszName, afcW.pszName, pafc->cchName);
        }

        Iwcstombs(pafc->szFormatTag, afcW.szFormatTag, sizeof(pafc->szFormatTag));
        Iwcstombs(pafc->szFormat,    afcW.szFormat,    sizeof(pafc->szFormat));
    }

    if (NULL != afcW.pszName)
    {
        LocalFree((HLOCAL)afcW.pszName);
    }

    if (NULL != afcW.pszTitle)
    {
        LocalFree((HLOCAL)afcW.pszTitle);
    }

    if (0 != HIWORD(pafc->pszTemplateName))
    {
        LocalFree((HLOCAL)afcW.pszTemplateName);
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFormatChooseW
(
    LPACMFORMATCHOOSEW      pafc
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


/*      -       -       -       -       -       -       -       -       -   */

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | MeasureItem |
 *
 *  @parm HWND | hwnd |
 *
 *  @parm MEASUREITEMSTRUCT FAR * | lpmis |
 *
 *  @comment Do you REALLY WANT TO KNOW why this is owner draw?
 *  Because DROPDOWN LISTBOX's are bad!  You can't tell'em to use tabs!
 *
 ****************************************************************************/
BOOL FNLOCAL
MeasureItem ( HWND hwnd,
              MEASUREITEMSTRUCT FAR * lpmis )
{
    TEXTMETRIC tm;
    HDC hdc;
    HWND hwndCtrl;

    hwndCtrl = GetDlgItem(hwnd,lpmis->CtlID);

    hdc = GetWindowDC(hwndCtrl);
    
    if (NULL == hdc)
    {
        return(FALSE);
    }
    
    GetTextMetrics(hdc,(TEXTMETRIC FAR *)&tm);
    ReleaseDC(hwndCtrl,hdc);
    //Note: the "+1" is a fudge.
    lpmis->itemHeight = tm.tmAscent + tm.tmExternalLeading + 1;

    return (TRUE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | DrawItem |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm DRAWITEMSTRUCT FAR * | pDIS |
 *
 ****************************************************************************/
BOOL FNLOCAL
DrawItem ( PInstData pInst,
           DRAWITEMSTRUCT FAR *pDIS )
{
    HBRUSH  hbr;
    UINT    cchTextLen;
    TCHAR   szFormat[ACMFORMATDETAILS_FORMAT_CHARS];


    COLORREF crfBkPrev;         // previous HDC bkgnd color
    COLORREF crfTextPrev;       // previous HDC text color

    /* set the correct colors and draw the background */
    if (pDIS->itemState & ODS_SELECTED)
    {
        crfBkPrev = SetBkColor(pDIS->hDC,GetSysColor(COLOR_HIGHLIGHT));
        crfTextPrev = SetTextColor(pDIS->hDC,GetSysColor(COLOR_HIGHLIGHTTEXT));
        hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
    }
    else
    {
        hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    }

    if (NULL == hbr)
    {
        return (FALSE);
    }

    switch (pDIS->itemAction)
    {
        case ODA_SELECT:
        case ODA_DRAWENTIRE:
            /* Get the text and draw it */
            FillRect(pDIS->hDC,&pDIS->rcItem,hbr);
	    cchTextLen = (UINT)ComboBox_GetLBTextLen(pDIS->hwndItem,
						     pDIS->itemID);

	    if (cchTextLen == LB_ERR || cchTextLen == 0)
                break;

	    IComboBox_GetLBText(pDIS->hwndItem,
				pDIS->itemID,
				szFormat);

            //NOTE: uiFormatTab is calculated in WM_INITDIALOG
            TabbedTextOut(pDIS->hDC,
                          pDIS->rcItem.left,
                          pDIS->rcItem.top,
                          (LPCTSTR)szFormat,
                          cchTextLen,
                          1,
                          (int FAR *)&pInst->uiFormatTab,
                          pDIS->rcItem.left);

            break;

        case ODA_FOCUS:
            DrawFocusRect(pDIS->hDC,&pDIS->rcItem);
            break;
    }

    DeleteObject(hbr);

    if (pDIS->itemState & ODS_SELECTED)
    {
        SetBkColor(pDIS->hDC, crfBkPrev);
        SetTextColor(pDIS->hDC, crfTextPrev);
    }

    return (TRUE);
} /* DrawItem() */


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNWCALLBACK | NewSndDlgProc | Dialog Procedure for the Chooser
 *
 ****************************************************************************/
INT_PTR FNWCALLBACK
NewSndDlgProc( HWND hwnd,
               unsigned msg,
               WPARAM wParam,
               LPARAM lParam )
{
    UINT        CmdCommandId;  // WM_COMMAND ID
    UINT        CmdCmd;        // WM_COMMAND Command
    PInstData   pInst;

	
    pInst = GetInstData(hwnd);

    if (pInst)
    {
        /* Pass everything to the hook function first
         */
        if (pInst->fEnableHook)
        {
            if (pInst->pfnHook)
            {
                if ((*pInst->pfnHook)(hwnd, msg, wParam, lParam))
                    return (TRUE);
            }
        }

        if (msg == pInst->uUpdateMsg)
        {
	    UpdateCustomFormats(pInst);

            return (TRUE);
        }
    }

    switch (msg)
    {

	case MM_ACM_FILTERCHOOSE: // case MM_ACM_FORMATCHOOSE:
            switch (wParam)
            {
                case FORMATCHOOSE_FORMAT_ADD:
                case FORMATCHOOSE_FORMATTAG_ADD:
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE);
                    break;

                case FORMATCHOOSE_FORMAT_VERIFY:
                case FORMATCHOOSE_FORMATTAG_VERIFY:
                case FORMATCHOOSE_CUSTOM_VERIFY:
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
                    break;
            }
            return (TRUE);

        case WM_INITDIALOG:
            /* Stuff our instance data pointer into the right place */
            if (SetInstData(hwnd,lParam))
            {
                LRESULT     lr;
#ifdef DEBUG
                DWORD       dw;

                dw = timeGetTime();
#endif

                lr = HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, InitDialog);

		//
		//  Note:  Unfortunately, I can't think of the right way
		//  to do this.  It seems as though the IDD_CMB_FORMAT control
		//  does not receive WM_SETFONT before we get WM_MEASUREITEM,
		//  so the WM_MEASUREITEM handler ends up computing a height
		//  that may not be correct.  So, I'll just make height of
		//  our owner draw format combobox the same as the height of
		//  the formattag combobox.
		//
		{
		    int i;
		
		    i = (int)SendMessage(GetDlgItem(hwnd, IDD_CMB_FORMATTAG), CB_GETITEMHEIGHT, 0, (LPARAM)0);
		    SendMessage(GetDlgItem(hwnd, IDD_CMB_FORMAT), CB_SETITEMHEIGHT, 0, (LPARAM)i);

		    i = (int)SendMessage(GetDlgItem(hwnd, IDD_CMB_FORMATTAG), CB_GETITEMHEIGHT, (WPARAM)(-1), (LPARAM)0);
		    SendMessage(GetDlgItem(hwnd, IDD_CMB_FORMAT), CB_SETITEMHEIGHT, (WPARAM)(-1), (LPARAM)i);
		}

#ifdef DEBUG
                dw = timeGetTime() - dw;
                DPF(0, "CHOOSER TIME: took %lu milliseconds to init", dw);
#endif

                return (0L != lr);
            }
            else
                EndDialog(hwnd,ChooseNoMem);
            return (TRUE);

        case WM_DESTROY:
            if (pInst)
            {
                EmptyFormats(pInst);
                UnRegisterUpdateNotify(pInst);
                RemoveInstData(hwnd);
            }
            /* We don't post quit */
            return (FALSE);

        case WM_MEASUREITEM:
            if ((int)wParam != IDD_CMB_FORMAT)
                return (FALSE);

            MeasureItem(hwnd,(MEASUREITEMSTRUCT FAR *)lParam);
            return (TRUE);

        case WM_DRAWITEM:
            if ((int)wParam != IDD_CMB_FORMAT)
                return (FALSE);

            DrawItem(pInst,(DRAWITEMSTRUCT FAR *)lParam);
            return (TRUE);


#ifdef USECONTEXTHELP

        //
        //  Notify caller of context-sensitive help messages.
        //
        case WM_CONTEXTMENU:
        case WM_HELP:
            {
                HWND hOwner;
                switch (pInst->uType)
                {
                    case FORMAT_CHOOSE:
                        hOwner = pInst->pfmtc->hwndOwner;
                        break;
                    case FILTER_CHOOSE:
                        hOwner = pInst->pafltrc->hwndOwner;
                        break;
                }
                PostMessage( hOwner,
                             (msg==WM_HELP) ? pInst->uHelpContextHelp :
                                              pInst->uHelpContextMenu,
                             wParam,
                             lParam );
                return (TRUE);
            }

#endif // USECONTEXTHELP


        case WM_COMMAND:
            CmdCommandId = GET_WM_COMMAND_ID(wParam,lParam);
            CmdCmd       = GET_WM_COMMAND_CMD(wParam,lParam);

            switch (CmdCommandId)
            {
                case IDD_BTN_HELP:
                    /* launch the default help */
                {
                    HWND hOwner;
                    switch (pInst->uType)
                    {
                        case FORMAT_CHOOSE:
                            hOwner = pInst->pfmtc->hwndOwner;
                            break;
                        case FILTER_CHOOSE:
                            hOwner = pInst->pafltrc->hwndOwner;
                            break;
                    }
                    PostMessage(hOwner,pInst->uHelpMsg,0,0L);
                    return (TRUE);
                }
                case IDOK:
                {
                    BOOL fOk;
                    fOk = pInst->lpbSel != NULL;

                    if (fOk && pInst->cchName != 0 && pInst->pszName != NULL)
                    {
                        int index;
                        index = ComboBox_GetCurSel(pInst->hCustomFormats);
                        if (index != 0 )
                        {
                            int cchBuf;
                            cchBuf = ComboBox_GetLBTextLen(pInst->hCustomFormats, index);
                            cchBuf ++;
                            if (cchBuf * sizeof(TCHAR) < pInst->cchName)
				IComboBox_GetLBTextW32(pInst->hCustomFormats,
				                       index,
				                       pInst->pszName);
                            else
                            {
                                TCHAR *pchBuf = (TCHAR*)LocalAlloc(LPTR,
                                                                   cchBuf*sizeof(TCHAR));
                                if (!pchBuf)
                                    *pInst->pszName = '\0';
                                else
                                {
				    IComboBox_GetLBText(pInst->hCustomFormats,
					                index,
                                                        pchBuf);

                                    _fmemcpy(pInst->pszName,
                                             pchBuf,
                                             (UINT)pInst->cchName);

                                    pInst->pszName[(pInst->cchName/sizeof(TCHAR))-1] = '\0';

                                    LocalFree((HLOCAL)pchBuf);
                                }
                            }
                        }
                        else
                            *pInst->pszName = '\0';
                    }
                    if (!fOk)
                    {
                        pInst->mmrSubFailure = MMSYSERR_ERROR;
                        EndDialog(hwnd,ChooseSubFailure);
                    }
                    else
                        EndDialog(hwnd,ChooseOk);
                    return (TRUE);
                }
                case IDCANCEL:
                    if (pInst->lpbSel)
                    {
                        GlobalFreePtr(pInst->lpbSel);
                        pInst->lpbSel = NULL;
                    }
                    EndDialog(hwnd,ChooseCancel);
                    return (TRUE);

                case IDD_BTN_SETNAME:
                    /* Attempt to set a new format */
                    SetName(pInst);
                    return (TRUE);

                case IDD_BTN_DELNAME:
                    /* Attempt to remove the custom format */
                    DelName(pInst);
                    return (TRUE);

                case IDD_CMB_CUSTOM:
                    if (CmdCmd == CBN_SELCHANGE)
                    {
                        int index;
                        /* CBN_SELCHANGE only comes from the user! */
                        SelectCustomFormat(pInst);
                        FindSelCustomFormat(pInst);

                        index = ComboBox_GetCurSel(pInst->hFormatTags);
                        if (ComboBox_GetItemData(pInst->hFormatTags,0) == 0)
                        {
                            int     cTags;

                            cTags = ComboBox_GetCount(pInst->hFormatTags);
                            if (cTags > 1)
                            {
                                /* We've inserted an "[unavailable]" so make
                                 * sure we remove it and reset the current
                                 * selection.
                                 */
                                if (0 != index)
                                {
                                    ComboBox_DeleteString(pInst->hFormatTags,0);
                                    ComboBox_SetCurSel(pInst->hFormatTags,index-1);
                                }
                            }
                        }
                        return (TRUE);
                    }
                    return (FALSE);

                case IDD_CMB_FORMATTAG:
                    if (CmdCmd == CBN_SELCHANGE)
                    {
                        int index;
                        index = ComboBox_GetCurSel(pInst->hFormatTags);

                        if (index == pInst->iPrevFormatTagsSel)
                            return (FALSE);

                        if (ComboBox_GetItemData(pInst->hFormatTags,0) == 0)
                        {
                            /* We've inserted an "[unavailable]" so make
                             * sure we remove it and reset the current
                             * selection.
                             */
                            ComboBox_DeleteString(pInst->hFormatTags,0);
                            ComboBox_SetCurSel(pInst->hFormatTags,index-1);
                        }

                        /* CBN_SELCHANGE only comes from the user! */
                        SelectFormatTag(pInst);

                        /* Custom Format == "<none>" */
                        ComboBox_SetCurSel(pInst->hCustomFormats,0);
                        SelectCustomFormat(pInst);

                        /* Format == first choice */
                        RefreshFormats(pInst);
                        ComboBox_SetCurSel(pInst->hFormats,0);
                        SelectFormat(pInst);

                        return (TRUE);
                    }
                    return (FALSE);

                case IDD_CMB_FORMAT:
                    if (CmdCmd == CBN_SELCHANGE)
                    {
			int index;
			
                        /* CBN_SELCHANGE only comes from the user! */
                        SelectFormat(pInst);

			/* If we have "unavailable" in list, remove it */
                        index = ComboBox_GetCurSel(pInst->hFormats);
                        if (ComboBox_GetItemData(pInst->hFormats,0) == 0)
                        {
                            int     cFormats;

                            cFormats = ComboBox_GetCount(pInst->hFormats);
                            if (cFormats > 1)
                            {
                                /* We've inserted an "[unavailable]" so make
                                 * sure we remove it and reset the current
                                 * selection.
                                 */
                                if (0 != index)
                                {
                                    ComboBox_DeleteString(pInst->hFormats,0);
                                    ComboBox_SetCurSel(pInst->hFormats,index-1);
                                }
                            }
                        }

			/* Custom Format == "<none>" */
                        ComboBox_SetCurSel(pInst->hCustomFormats,0);
                        SelectCustomFormat(pInst);

                        return (TRUE);
                    }
                    return (FALSE);
	    }
    }
    return (FALSE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SetTitle | Set the title of the dialog box if the
 *  pszTitle field is non-NULL.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SetTitle ( PInstData pInst )
{
#if defined(WIN32) && !defined(UNICODE)
    LPCWSTR  pszTitle;
#else
    LPCTSTR  pszTitle;
#endif

    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
            pszTitle = (pInst->pfmtc->pszTitle);
            break;
        case FILTER_CHOOSE:
            pszTitle = (pInst->pafltrc->pszTitle);
            break;
    }

    if (pszTitle)
    {
#if defined(WIN32) && !defined(UNICODE)
	LPSTR	pstrTitle;
	UINT	cchTitle;

	cchTitle = lstrlenW(pszTitle)+1;
	pstrTitle = (LPSTR)GlobalAlloc(GPTR, cchTitle);
	if (NULL == pstrTitle)
	    return;
	Iwcstombs(pstrTitle, pszTitle, cchTitle);
        SendMessage(pInst->hwnd,WM_SETTEXT,0,(LPARAM)pstrTitle);
	GlobalFree((HGLOBAL)pstrTitle);
#else
        SendMessage(pInst->hwnd,WM_SETTEXT,0,(LPARAM)pszTitle);
#endif
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SetHelp | Hide/Show the help.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SetHelp ( PInstData pInst )
{
    BOOL        fHideHelp;
    BOOL        fCenterButtons;


#ifdef USECONTEXTHELP
    //
    //  Set the messages to send back to caller.
    //
    {
        BOOL    fContextHelp = FALSE;

        switch (pInst->uType)
        {
            case FORMAT_CHOOSE:
                if( pInst->pfmtc->fdwStyle & ACMFORMATCHOOSE_STYLEF_CONTEXTHELP )
                    fContextHelp = TRUE;
                break;

            case FILTER_CHOOSE:
                if( pInst->pafltrc->fdwStyle & ACMFILTERCHOOSE_STYLEF_CONTEXTHELP )
                    fContextHelp = TRUE;
                break;
        }

        if( fContextHelp )
        {
#if defined(WIN32) && !defined(UNICODE)
            pInst->uHelpContextMenu = RegisterWindowMessage(ACMHELPMSGCONTEXTMENUA);
            pInst->uHelpContextHelp = RegisterWindowMessage(ACMHELPMSGCONTEXTHELPA);
#else
            pInst->uHelpContextMenu = RegisterWindowMessage(ACMHELPMSGCONTEXTMENU);
            pInst->uHelpContextHelp = RegisterWindowMessage(ACMHELPMSGCONTEXTHELP);
#endif
        }
    }
#endif // USECONTEXTHELP


    //
    //  The rest of this stuff is for the STYLEF_SHOWHELP selection.
    //
    if (!pInst->hHelp)
        return;

    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
            fHideHelp = !(pInst->pfmtc->fdwStyle &
                          ACMFORMATCHOOSE_STYLEF_SHOWHELP);
            fCenterButtons = fHideHelp &&
                             !(pInst->pfmtc->fdwStyle &
                               ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE);
            break;
        case FILTER_CHOOSE:
            fHideHelp = !(pInst->pafltrc->fdwStyle &
                          ACMFILTERCHOOSE_STYLEF_SHOWHELP);
            fCenterButtons = fHideHelp &&
                             !(pInst->pafltrc->fdwStyle &
                               ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE);
            break;
    }

    if (fHideHelp)
    {
        ShowWindow(pInst->hHelp,SW_HIDE);
    }
    else
    {
#if defined(WIN32) && !defined(UNICODE)
        pInst->uHelpMsg = RegisterWindowMessage(ACMHELPMSGSTRINGA);
#else
        pInst->uHelpMsg = RegisterWindowMessage(ACMHELPMSGSTRING);
#endif
    }

    /* Center OK and Cancel buttons if the default dialog template is used. */
    if (fCenterButtons)
    {
        RECT rc,rcOk,rcCancel;
        POINT pt;
#ifdef WIN32
        LONG iDlgWidth,iBtnsWidth,iRightShift;
#else
        int iDlgWidth,iBtnsWidth,iRightShift;
#endif

        GetWindowRect(pInst->hwnd,&rc);
        GetWindowRect(pInst->hOk,&rcOk);
        GetWindowRect(pInst->hCancel,&rcCancel);

        /* note: we expect Cancel to be right of Ok */

        iDlgWidth = rc.right - rc.left;
        iBtnsWidth = rcCancel.right - rcOk.left;

        iRightShift = (iDlgWidth - iBtnsWidth)/2;

        pt.x = rc.left + iRightShift;
        pt.y = rcOk.top;
        ScreenToClient(pInst->hwnd,&pt);

        MoveWindow(pInst->hOk,
                   pt.x,
                   pt.y,
                   rcOk.right-rcOk.left,
                   rcOk.bottom-rcOk.top,
                   FALSE);

        pt.x = rc.left + (rcCancel.left - rcOk.left) + iRightShift;
        pt.y = rcCancel.top;
        ScreenToClient(pInst->hwnd,&pt);

        MoveWindow(pInst->hCancel,
                   pt.x,
                   pt.y,
                   rcCancel.right-rcCancel.left,
                   rcCancel.bottom-rcCancel.top,
                   FALSE);
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | InitDialog | Initialize everything
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm HWND | hwnd |
 *
 ****************************************************************************/

LRESULT FNLOCAL InitDialog
(
    HWND                    hwnd,
    HWND                    hwndFocus,
    LPARAM                  lParam
)
{
    RECT                rc;
    BOOL                fReturn;
    PInstData           pInst;
    MMRESULT            mmrEnumStatus;
#ifdef DEBUG
    DWORD               dw;
#endif

    pInst = GetInstData(hwnd);

    pInst->hwnd = hwnd;

    pInst->hCustomFormats = GetDlgItem(hwnd,IDD_CMB_CUSTOM);
    pInst->hFormatTags = GetDlgItem(hwnd,IDD_CMB_FORMATTAG);
    pInst->hFormats = GetDlgItem(hwnd,IDD_CMB_FORMAT);

    GetWindowRect(pInst->hFormats,(RECT FAR *)&rc);
    pInst->uiFormatTab = ((rc.right - rc.left)*2)/3;

    pInst->hOk = GetDlgItem(hwnd,IDOK);
    pInst->hCancel = GetDlgItem(hwnd,IDCANCEL);
    pInst->hHelp = GetDlgItem(hwnd,IDD_BTN_HELP);
    pInst->hSetName = GetDlgItem(hwnd,IDD_BTN_SETNAME);
    pInst->hDelName = GetDlgItem(hwnd,IDD_BTN_DELNAME);

    SetTitle(pInst);
    SetHelp(pInst);

    fReturn = TRUE;

    /* give to the hook function */
    if (pInst->fEnableHook)
    {
        if (pInst->pfnHook)
        {
            switch (pInst->uType)
            {
                case FORMAT_CHOOSE:
                    lParam = pInst->pfmtc->lCustData;
                    break;

                case FILTER_CHOOSE:
                    lParam = pInst->pafltrc->lCustData;
                    break;

                default:
                    lParam = 0L;
                    break;
            }

            fReturn = FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, pInst->pfnHook);
        }
    }


#ifdef USECONTEXTHELP
    //
    //  We need to specify the DS_CONTEXTHELP dialog style in our template
    //  to get the little "?" to show up on the title bar.
    //
    {
        BOOL    fInsertContextMenu = FALSE;
        LONG    lWindowStyle;

        switch (pInst->uType)
        {
            case FORMAT_CHOOSE:
                if( pInst->pfmtc->fdwStyle & ACMFORMATCHOOSE_STYLEF_CONTEXTHELP )
                    fInsertContextMenu = TRUE;
                break;

            case FILTER_CHOOSE:
                if( pInst->pafltrc->fdwStyle & ACMFILTERCHOOSE_STYLEF_CONTEXTHELP )
                    fInsertContextMenu = TRUE;
                break;
        }

        if( fInsertContextMenu )
        {
            //
            //  Get current style, insert DS_CONTEXTHELP, set style.
            //
            lWindowStyle = GetWindowLong( pInst->hwnd, GWL_EXSTYLE );
            lWindowStyle |= WS_EX_CONTEXTHELP;
            SetWindowLong( pInst->hwnd, GWL_EXSTYLE, lWindowStyle );
        }
    }
#endif // USECONTEXTHELP


    /*
     * RefreshFormatTags is the first real call to acmFormatEnum, so we
     * need to get out fast if this fails, also pass back the error
     * we got so the user can figure out what went wrong.
     */
#ifdef DEBUG
    dw = timeGetTime();
#endif
    mmrEnumStatus = RefreshFormatTags(pInst);
#ifdef DEBUG
    dw = timeGetTime() - dw;
    DPF(0, "    InitDialog: RefreshFormatTags took %lu milliseconds", dw);
#endif

    if (mmrEnumStatus != MMSYSERR_NOERROR)
    {
        pInst->mmrSubFailure = mmrEnumStatus;
        EndDialog (hwnd,ChooseSubFailure);
        return (fReturn);
    }

#ifdef DEBUG
    dw = timeGetTime();
#endif
    RefreshFormats(pInst);
#ifdef DEBUG
    dw = timeGetTime() - dw;
    DPF(0, "    InitDialog: RefreshFormats took %lu milliseconds", dw);
#endif

#ifdef DEBUG
    dw = timeGetTime();
#endif
    InitCustomFormats(pInst);
#ifdef DEBUG
    dw = timeGetTime() - dw;
    DPF(0, "    InitDialog: InitCustomFormats took %lu milliseconds", dw);
#endif

#ifdef DEBUG
    dw = timeGetTime();
#endif
    RefreshCustomFormats(pInst,FALSE);
#ifdef DEBUG
    dw = timeGetTime() - dw;
    DPF(0, "    InitDialog: RefreshCustomFormats took %lu milliseconds", dw);
#endif

    if (pInst->hDelName)
        EnableWindow(pInst->hDelName,FALSE);

    /* Make a selection */

#ifdef DEBUG
    dw = timeGetTime();
#endif
    if (!FindInitCustomFormat(pInst))
    {
        int         cTags;
        int         n;

        ComboBox_SetCurSel(pInst->hCustomFormats,0);
        SelectCustomFormat(pInst);

        cTags = ComboBox_GetCount(pInst->hFormatTags);
        if (0 == cTags)
        {
            TagUnavailable(pInst);
        }

        //
        //  try to default to tag 1 (PCM for format, Volume for filter)
        //
        for (n = cTags; (0 != n); n--)
        {
	    INT_PTR Tag;
            Tag = ComboBox_GetItemData(pInst->hFormatTags, n);
            if (1 == Tag)
            {
                break;
            }
        }

        ComboBox_SetCurSel(pInst->hFormatTags, n);
        SelectFormatTag(pInst);

        RefreshFormats(pInst);
        ComboBox_SetCurSel(pInst->hFormats,0);
        SelectFormat(pInst);
    }
#ifdef DEBUG
    dw = timeGetTime() - dw;
    DPF(0, "    InitDialog: FindInitCustomFormat took %lu milliseconds", dw);
#endif

    RegisterUpdateNotify(pInst);

#if 0
    //
    //  why are you doing this john?? we have to allow templates to set
    //  the focus where they want it (and by the way, this is NOT how
    //  you set the initial focus during WM_INITDIALOG).
    //
    if (pInst->hOk)
        SetFocus(pInst->hOk);
#endif

    return (fReturn);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SelectCustomFormat | Process a selection from custom
 *  format combo
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SelectCustomFormat ( PInstData pInst )
{
    int             index;
    LPCustomFormat  pcf;
    LPBYTE          lpSet;

    index = ComboBox_GetCurSel(pInst->hCustomFormats);
    pcf = (LPCustomFormat)ComboBox_GetItemData(pInst->hCustomFormats,index);

    ASSERT( NULL != pcf );
    
    /* Disable delete button if [untitled] selected or
     *  a system name is selected
     */
    if (pInst->hDelName)
    {
	BOOL fDisable;

	fDisable = (index == 0) || IsSystemName(pInst, pcf->pns, 0L);
	
        if (fDisable && IsWindowEnabled(pInst->hDelName))
        {
            DWORD dwStyle;
            dwStyle = GetWindowLong(pInst->hDelName, GWL_STYLE);
            if (dwStyle & BS_DEFPUSHBUTTON)
            {
                HWND hNewDef;
                hNewDef = (IsWindowEnabled(pInst->hOk))?pInst->hOk:pInst->hCancel;
                SendMessage(pInst->hwnd, DM_SETDEFID, GetDlgCtrlID(hNewDef), 0L);
                dwStyle ^= BS_DEFPUSHBUTTON;
                Button_SetStyle(pInst->hDelName, dwStyle, TRUE);
                dwStyle = GetWindowLong(hNewDef, GWL_STYLE);
                Button_SetStyle(hNewDef, dwStyle|BS_DEFPUSHBUTTON, TRUE);
            }
            if (GetFocus() == pInst->hDelName)
                SendMessage(pInst->hwnd, WM_NEXTDLGCTL, 0, FALSE);
        }
        EnableWindow(pInst->hDelName, !fDisable);
    }


    if (pcf == pInst->pcf)
        return;

    pInst->pcf = pcf;

    if (pInst->pcf)
    {
        lpSet = CopyStruct(pInst->lpbSel,pcf->pbody,pInst->uType);
        if (lpSet)
            pInst->lpbSel = lpSet;
    }
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SelectFormatTag | Process a selection from format tag combo.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SelectFormatTag ( PInstData pInst )
{
    int         index;

    index = ComboBox_GetCurSel(pInst->hFormatTags);
    if (CB_ERR == index)
    {
        pInst->dwTag = 0L;
        return;
    }

    pInst->dwTag = (DWORD)ComboBox_GetItemData(pInst->hFormatTags,index);
    pInst->iPrevFormatTagsSel = index;
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SelectFormat | Process a selection from format combo.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SelectFormat ( PInstData pInst )
{
    int         index;
    LPBYTE      lpbytes;
    LPBYTE      lpSet;

    index = ComboBox_GetCurSel(pInst->hFormats);
    if (CB_ERR == index)
    {
        if (pInst->lpbSel)
            GlobalFreePtr(pInst->lpbSel);
        pInst->lpbSel = NULL;
        return;
    }
    lpbytes = (LPBYTE)ComboBox_GetItemData(pInst->hFormats,
                                           index);

    lpSet = CopyStruct(pInst->lpbSel,lpbytes,pInst->uType);
    if (lpSet)
    {
        pInst->lpbSel = lpSet;
    }

    EnableWindow(pInst->hOk,(NULL!=lpSet));
    EnableWindow(pInst->hSetName,(NULL!=lpSet));
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | UpdateCustomFormats | Update everything we know about
 *  custom formats.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
UpdateCustomFormats ( PInstData pInst )
{
    int index;
    PNameStore pns;

    /* 1. Empty our pool.
     * 2. Reinitialize our pool.
     * 3. Reinitialize our combobox.
     * 4. Try and reselect the same name as selected before update was called.
     */
    pns = NewNameStore(STRING_LEN);

    if (pns)
    {
        index = ComboBox_GetCurSel(pInst->hCustomFormats);
        IComboBox_GetLBText(pInst->hCustomFormats, index, pns->achName);
    }

    EmptyCustomFormats(pInst);
    InitCustomFormats(pInst);
    RefreshCustomFormats(pInst,FALSE);

    if (pns)
    {
        index = IComboBox_FindStringExact(pInst->hCustomFormats, -1,
					  pns->achName);
        if (index == CB_ERR)
            index = 0;

        DeleteNameStore(pns);
    }
    else
        index = 0;

    ComboBox_SetCurSel(pInst->hCustomFormats,index);
    SelectCustomFormat(pInst);
    FindSelCustomFormat(pInst);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | MashNameWithRate |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm PNameStore | pnsDest |
 *
 *  @parm PNameStore | pnsSrc |
 *
 *  @parm LPWAVEFORMATEX | pwfx |
 *
 ****************************************************************************/
void FNLOCAL
MashNameWithRate ( PInstData        pInst,
                   PNameStore       pnsDest,
                   PNameStore       pnsSrc,
                   LPWAVEFORMATEX   pwfx )
{
    TCHAR   szMashFmt[30];

    pnsDest->achName[0] = TEXT('\0');

    ASSERT( NULL != pInst->pag );
    if( LoadString( pInst->pag->hinst,
                    IDS_FORMAT_MASH,
                    szMashFmt,
                    SIZEOF(szMashFmt)) )
    {
        wsprintf((LPTSTR)pnsDest->achName,
                (LPTSTR)szMashFmt,
                (LPTSTR)pnsSrc->achName,
                pwfx->nAvgBytesPerSec / 1024L);
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | FindSelCustomFormat | Find the custom format based
 *  upon the current selection.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
FindSelCustomFormat ( PInstData pInst )
{
    if (pInst->pcf)
    {
        switch (pInst->uType)
        {
            case FORMAT_CHOOSE:
                FindFormat(pInst,pInst->pcf->pwfx,TRUE);
                break;
            case FILTER_CHOOSE:
                FindFilter(pInst,pInst->pcf->pwfltr,TRUE);
                break;
        }
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | FindInitCustomFormat | Initializing to a format.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @rdesc Called once, during WM_INITDIALOG, this function will set the
 *  current selections IFF the init struct has the proper flags set.
 *  Else it will return FALSE.
 *
 ****************************************************************************/
BOOL FNLOCAL
FindInitCustomFormat ( PInstData pInst )
{
    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
            if (pInst->pfmtc->fdwStyle
                & ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT)
            {
                FindFormat(pInst,pInst->pfmtc->pwfx,FALSE);
                ComboBox_SetCurSel(pInst->hCustomFormats,0);
                return (TRUE);
            }
            break;

        case FILTER_CHOOSE:
            if (pInst->pafltrc->fdwStyle
                & ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT)
            {
                FindFilter(pInst,pInst->pafltrc->pwfltr,FALSE);
                ComboBox_SetCurSel(pInst->hCustomFormats,0);
                return (TRUE);
            }
            break;
    }

    /* init to pszName */
#ifdef WIN32
    if (pInst->pszName != NULL && lstrlenW(pInst->pszName) != 0 && pInst->cchName != 0)
#else
    if (pInst->pszName != NULL && lstrlen(pInst->pszName) != 0 && pInst->cchName != 0)
#endif
    {
        int index;
        index = IComboBox_FindStringExactW32(pInst->hCustomFormats,
					     -1,
					     pInst->pszName);
         if (index == CB_ERR)
            return (FALSE);

        ComboBox_SetCurSel(pInst->hCustomFormats,index);
        SelectCustomFormat(pInst);
        FindSelCustomFormat(pInst);
        return (TRUE);
    }
    return (FALSE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | TagUnavailable | Inserts the Tag failure message.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
TagUnavailable ( PInstData pInst )
{
    int index;
    /* Select [not available] for format tag */
    LoadString(pInst->pag->hinst,
               IDS_TXT_UNAVAILABLE,
               (LPTSTR)pInst->pnsTemp->achName,
               NAMELEN(pInst->pnsTemp));
    index = IComboBox_InsertString(pInst->hFormatTags,
				   0,
				   pInst->pnsTemp->achName);
    ComboBox_SetItemData(pInst->hFormatTags,index,NULL);
}

void FNLOCAL
FormatUnavailable ( PInstData pInst)
{
    int index;
    LoadString(pInst->pag->hinst,
               IDS_TXT_UNAVAILABLE,
               (LPTSTR)pInst->pnsTemp->achName,
               NAMELEN(pInst->pnsTemp));
    index = IComboBox_InsertString(pInst->hFormats,
				   0,
				   pInst->pnsTemp->achName);
    ComboBox_SetItemData(pInst->hFormats,index,NULL);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | FindFormat | Finds the format string that matches a
 *  format in the comboboxes. Defaults to the first element in the comboboxes.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPWAVEFORMATEX | pwfx |
 *
 *  @parm BOOL | fExact |
 *
 ****************************************************************************/
BOOL FNLOCAL
FindFormat( PInstData       pInst,
            LPWAVEFORMATEX  pwfx,
            BOOL            fExact )
{
    int                 index;
    BOOL                fOk;
    ACMFORMATTAGDETAILS adft;
    MMRESULT            mmr;
    ACMFORMATDETAILS    adf;

    PNameStore pns = pInst->pnsTemp;

    /* Adjust the Format and FormatTag comboboxes to correspond to the
     * Custom Format selection
     */
    _fmemset(&adft, 0, sizeof(adft));

    adft.cbStruct = sizeof(adft);
    adft.dwFormatTag = pwfx->wFormatTag;
    mmr = acmFormatTagDetails(NULL, &adft, ACM_FORMATTAGDETAILSF_FORMATTAG);
    fOk = (MMSYSERR_NOERROR == mmr);
    if (fOk)
    {
        index = IComboBox_FindStringExactW32(pInst->hFormatTags,
					     -1,
					     adft.szFormatTag);
        fOk = (CB_ERR != index);
    }

    index = fOk?index:0;

    if (!fOk && fExact && ComboBox_GetItemData(pInst->hFormatTags,0))
        TagUnavailable(pInst);

    ComboBox_SetCurSel(pInst->hFormatTags,index);
    SelectFormatTag((PInstData)pInst);

    RefreshFormats((PInstData)pInst);

    if (fOk)
    {
        //
        //
        //
        adf.cbStruct      = sizeof(adf);
        adf.dwFormatIndex = 0;
        adf.dwFormatTag   = pwfx->wFormatTag;
        adf.fdwSupport    = 0;
        adf.pwfx          = pwfx;
        adf.cbwfx         = SIZEOF_WAVEFORMATEX(pwfx);

        mmr = acmFormatDetails(NULL, &adf, ACM_FORMATDETAILSF_FORMAT);

        fOk = (MMSYSERR_NOERROR == mmr);
        if (fOk)
        {
#if defined(WIN32) && !defined(UNICODE)
	    Iwcstombs(pns->achName, adf.szFormat, pns->cbSize);
#else
            lstrcpy(pns->achName, adf.szFormat);
#endif
            MashNameWithRate(pInst,pInst->pnsStrOut,pns,pwfx);
            index = IComboBox_FindStringExact(pInst->hFormats,-1,
					      pInst->pnsStrOut->achName);

            fOk = (CB_ERR != index);
        }
        index = fOk?index:0;
    }
    if (!fOk && fExact && ComboBox_GetItemData(pInst->hFormats,0))
    {
        FormatUnavailable(pInst);
    }

    ComboBox_SetCurSel(pInst->hFormats,index);
    SelectFormat((PInstData)pInst);

    return (fOk);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void | FindFilter | Finds the format string that matches a format in
 *  the comboboxes. Defaults to the first element in the comboboxes
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPWAVEFILTER | pwf |
 *
 *  @parm BOOL | fExact |
 *
 ****************************************************************************/
BOOL FNLOCAL
FindFilter ( PInstData      pInst,
             LPWAVEFILTER   pwf,
             BOOL           fExact )
{
    int                 index;
    BOOL                fOk;
    ACMFILTERTAGDETAILS adft;
    MMRESULT            mmr;
    ACMFILTERDETAILS    adf;

    /* Adjust the Filter and FilterTag comboboxes to correspond to the
     * Custom Filter selection
     */
    _fmemset(&adft, 0, sizeof(adft));

    adft.cbStruct = sizeof(adft);
    adft.dwFilterTag = pwf->dwFilterTag;
    mmr = acmFilterTagDetails(NULL,
                               &adft,
                               ACM_FILTERTAGDETAILSF_FILTERTAG);
    fOk = (MMSYSERR_NOERROR == mmr);
    if (fOk)
    {
        index = IComboBox_FindStringExactW32(pInst->hFormatTags,
					     -1,
					     adft.szFilterTag);
        fOk = (CB_ERR != index);
    }

    index = fOk?index:0;

    if (!fOk && fExact && ComboBox_GetItemData(pInst->hFormatTags,0))
        TagUnavailable(pInst);

    ComboBox_SetCurSel(pInst->hFormatTags,index);
    SelectFormatTag((PInstData)pInst);

    RefreshFormats((PInstData)pInst);

    if (fOk)
    {
        //
        //
        //
        adf.cbStruct      = sizeof(adf);
        adf.dwFilterIndex = 0;
        adf.dwFilterTag   = pwf->dwFilterTag;
        adf.fdwSupport    = 0;
        adf.pwfltr        = pwf;
        adf.cbwfltr       = pwf->cbStruct;

        mmr = acmFilterDetails(NULL, &adf, ACM_FILTERDETAILSF_FILTER);
        fOk = (MMSYSERR_NOERROR == mmr);
        if (fOk)
        {
	    index = IComboBox_FindStringExactW32(pInst->hFormats, -1, adf.szFilter);

            fOk = (CB_ERR != index);
        }
        index = fOk?index:0;
    }

    ComboBox_SetCurSel(pInst->hFormats,index);
    SelectFormat((PInstData)pInst);
    return (TRUE);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | RefreshCustomFormats | Fills the CustomFormat combo
 *  with custom formats.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
BOOL FNLOCAL
InEnumSet (PInstData pInst, LPWAVEFORMATEX pwfxCustom, LPWAVEFORMATEX pwfxBuf, DWORD cbSize);

void FNLOCAL
RefreshCustomFormats ( PInstData pInst , BOOL fCheckEnum )
{
    LPCustomFormat  pcf;
    int             index;

    MMRESULT        mmr;

    ASSERT( NULL != pInst->pag);

    SetWindowRedraw(pInst->hCustomFormats,FALSE);

    ComboBox_ResetContent(pInst->hCustomFormats);

    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
        {
            DWORD           cbwfx;
            DWORD           cbwfxCustom;
            LPWAVEFORMATEX  pwfx;

            mmr = IMetricsMaxSizeFormat( pInst->pag, NULL, &cbwfx );
            if (MMSYSERR_NOERROR != mmr)
                goto fexit;

            pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)cbwfx);
            if (!pwfx)
                goto fexit;

//#pragma message(REMIND("Speed up InEnumSet or Yield"))
            for (pcf = pInst->cfp.pcfHead; pcf != NULL; pcf = pcf->pcfNext )
            {
                cbwfxCustom = SIZEOF_WAVEFORMATEX(pcf->pwfx);
                if (cbwfx < cbwfxCustom)
                {
                    LPWAVEFORMATEX  pwfxCustom;

                    pwfxCustom = GlobalReAllocPtr(pwfx, cbwfxCustom, GHND);
                    if (NULL == pwfxCustom)
                        break;

                    pwfx  = pwfxCustom;
                    cbwfx = cbwfxCustom;
                }

                if (fCheckEnum && !InEnumSet(pInst, pcf->pwfx, pwfx, cbwfx))
                    continue;

                if (pInst->fEnableHook &&
                    !SendMessage(pInst->hwnd,
                                 MM_ACM_FORMATCHOOSE,
                                 FORMATCHOOSE_CUSTOM_VERIFY,
                                 (LPARAM)pcf->pbody))
                    continue;

                index = IComboBox_AddString(pInst->hCustomFormats,
					    pcf->pns->achName);
                ComboBox_SetItemData(pInst->hCustomFormats,index, (LPARAM)pcf);
            }
            GlobalFreePtr(pwfx);
            break;
        }
        case FILTER_CHOOSE:
        {
            for (pcf = pInst->cfp.pcfHead; pcf != NULL; pcf = pcf->pcfNext )
            {
                if (fCheckEnum &&
                    (pInst->pafltrc->fdwEnum & ACM_FILTERENUMF_DWFILTERTAG))
                {
                    /* considerably easier than the format stuff.
                     * just check to see if the filter tag matches.
                     */
                    if (pInst->pafltrc->pwfltrEnum->dwFilterTag !=
                        pcf->pwfltr->dwFilterTag)
                        continue;
                }

                if (pInst->fEnableHook &&
                    !SendMessage(pInst->hwnd,
                                 MM_ACM_FILTERCHOOSE,
                                 FILTERCHOOSE_CUSTOM_VERIFY,
                                 (LPARAM)pcf->pbody))
                    continue;

                index = IComboBox_AddString(pInst->hCustomFormats,
					    pcf->pns->achName);
                ComboBox_SetItemData(pInst->hCustomFormats,index,(LPARAM)pcf);
            }
            break;
        }
    }

    /* Insert the "[untitled]" selection at the top.
     */
    LoadString(pInst->pag->hinst, IDS_TXT_UNTITLED, (LPTSTR)pInst->pnsTemp->achName,
               NAMELEN(pInst->pnsTemp));

    index = IComboBox_InsertString(pInst->hCustomFormats,0,
				   pInst->pnsTemp->achName);

    ComboBox_SetItemData(pInst->hCustomFormats,index,0L);

fexit:
    SetWindowRedraw(pInst->hCustomFormats,TRUE);
}
/*
 * N = number of custom formats.
 * K = number of formats in the enumeration.
 */

/* slow method.
 * FOREACH format, is there a matching format in the enumeration?
 * cost? - Many calls to enumeration apis as N increases (linear search).
 * O(N)*O(K)
 * Best case:   All formats hit early in the enumeration. < O(K) multiplier
 * Worst case:  All formats hit late in the enumeration.  Hard O(K)*O(N)
 */
/* alternate method.
 * FOREACH enumerated format, is there a hit in the custom formats?
 * cost? - Call to lookup function for all enumerated types.
 * O(K)*O(N)
 * Best case:   A cheap lookup will mean < O(N) multiplier
 * Worst case:  Hard O(K)*O(N)
 */
typedef struct tResponse {
    LPWAVEFORMATEX pwfx;
    BOOL fHit;
} Response ;

BOOL FNWCALLBACK
CustomCallback ( HACMDRIVERID           hadid,
                 LPACMFORMATDETAILS     pafd,
                 DWORD_PTR              dwInstance,
                 DWORD                  fdwSupport )
{
    Response FAR * presp = (Response FAR *)dwInstance;
    if (_fmemcmp(presp->pwfx,pafd->pwfx,SIZEOF_WAVEFORMATEX(presp->pwfx)) == 0)
    {
        presp->fHit = TRUE;
        return (FALSE);
    }
    return (TRUE);
}

BOOL FNLOCAL
InEnumSet (PInstData        pInst,
           LPWAVEFORMATEX   pwfxCustom,
           LPWAVEFORMATEX   pwfxBuf,
           DWORD            cbwfx )
{
    ACMFORMATDETAILS    afd;
    DWORD               cbSize;
    DWORD               dwEnumFlags;
    BOOL                fOk;
    Response            resp;
    Response FAR *     presp;

    _fmemset(&afd, 0, sizeof(afd));

    afd.cbStruct    = sizeof(afd);
    afd.pwfx        = pwfxBuf;
    afd.cbwfx       = cbwfx;
    dwEnumFlags     = pInst->pfmtc->fdwEnum;

    /* optional filtering for a waveformat template */
    if ( pInst->pfmtc->pwfxEnum )
    {
        cbSize = min (pInst->cbwfxEnum, afd.cbwfx );
        _fmemcpy(afd.pwfx, pInst->pfmtc->pwfxEnum, (UINT)cbSize);
    }

    if (dwEnumFlags & (ACM_FORMATENUMF_CONVERT | ACM_FORMATENUMF_SUGGEST))
    {
        ;
    }
    else
    {
        /* if we don't really need this information, we can use
         * it to restrict the enumeration and hopefully speed things
         * up.
         */
        dwEnumFlags |= ACM_FORMATENUMF_WFORMATTAG;
        afd.pwfx->wFormatTag = pwfxCustom->wFormatTag;
        dwEnumFlags |= ACM_FORMATENUMF_NCHANNELS;
        afd.pwfx->nChannels = pwfxCustom->nChannels;
        dwEnumFlags |= ACM_FORMATENUMF_NSAMPLESPERSEC;
        afd.pwfx->nSamplesPerSec = pwfxCustom->nSamplesPerSec;
        dwEnumFlags |= ACM_FORMATENUMF_WBITSPERSAMPLE;
        afd.pwfx->wBitsPerSample = pwfxCustom->wBitsPerSample;
    }

    resp.fHit = FALSE;
    resp.pwfx = pwfxCustom;

    afd.dwFormatTag = afd.pwfx->wFormatTag;

    presp = &resp;
    fOk = (acmFormatEnum(NULL,
                         &afd,
                         CustomCallback,
                         (LPARAM)presp,
                         dwEnumFlags)== 0L);

    return (resp.fHit);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | RefreshFormatTags |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
MMRESULT FNLOCAL
RefreshFormatTags ( PInstData pInst )
{
    MMRESULT    mmr;
    DWORD       dwEnumFlags = 0L;
    MMRESULT    mmrEnumStatus = MMSYSERR_NOERROR;

    ASSERT( NULL != pInst->pag );

    SetWindowRedraw(pInst->hFormatTags,FALSE);

    ComboBox_ResetContent(pInst->hFormatTags);

    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
        {
            ACMFORMATDETAILS    afd;
            LPWAVEFORMATEX      pwfx;
            DWORD               cbSize;

            /*
             * Enumerate the format tags for the FormatTag combobox.
             * This might seem weird, to call acmFormatEnum, but we have
             * to because it has the functionality to restrict formats and
             * acmFormatTagEnum doesn't.
             */

            _fmemset(&afd, 0, sizeof(afd));

            mmr = IMetricsMaxSizeFormat( pInst->pag, NULL, &afd.cbwfx );
            if (MMSYSERR_NOERROR == mmr)
            {
                afd.cbwfx = max(afd.cbwfx, pInst->cbwfxEnum);

                pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)afd.cbwfx);
                if (!pwfx)
                    break;

                afd.cbStruct    = sizeof(afd);
                afd.pwfx        = pwfx;

                /* optional filtering for a waveformat template */
                if ( pInst->pfmtc->pwfxEnum )
                {
                    cbSize = min (pInst->cbwfxEnum, afd.cbwfx);
                    _fmemcpy(pwfx, pInst->pfmtc->pwfxEnum, (UINT)cbSize);
                    afd.dwFormatTag = pwfx->wFormatTag;
                }

                dwEnumFlags = pInst->pfmtc->fdwEnum;

                if (0 == (dwEnumFlags & (ACM_FORMATENUMF_CONVERT |
                                         ACM_FORMATENUMF_SUGGEST)))
                {
                    ACMFORMATTAGDETAILS aftd;

                    _fmemset(&aftd, 0, sizeof(aftd));

                    /* Enumerate the format tags */
                    aftd.cbStruct = sizeof(aftd);

                    /* Was a format tag specified?
                    * This means they only want one format tag.
                    */
                    pInst->fTagFilter = (pInst->pfmtc->pwfxEnum &&
                                        (pInst->pfmtc->fdwEnum & ACM_FORMATENUMF_WFORMATTAG));

                    pInst->pafdSimple = &afd;

                    mmrEnumStatus = acmFormatTagEnum(NULL,
                                                     &aftd,
                                                     FormatTagsCallbackSimple,
                                                     PTR2LPARAM(pInst),
                                                     0L);
                    pInst->pafdSimple = NULL;
                }
                else
                {
                    mmrEnumStatus = acmFormatEnum(NULL,
                                                  &afd,
                                                  FormatTagsCallback,
                                                  PTR2LPARAM(pInst),
                                                  dwEnumFlags);
                }

                if (MMSYSERR_NOERROR == mmrEnumStatus)
                {
                    //
                    //  add format that we are asked to init to (this has every
                    //  chance of being a 'non-standard' format, so we have to do
                    //  this in the following way..)
                    //
                    if (0 != (ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT & pInst->pfmtc->fdwStyle))
                    {
                        afd.cbStruct    = sizeof(afd);
                        afd.dwFormatTag = pInst->pfmtc->pwfx->wFormatTag;
                        afd.pwfx        = pInst->pfmtc->pwfx;
                        afd.cbwfx       = SIZEOF_WAVEFORMATEX(pInst->pfmtc->pwfx);
                        afd.fdwSupport  = 0L;

                        mmr = acmFormatDetails(NULL, &afd, ACM_FORMATDETAILSF_FORMAT);
                        if (MMSYSERR_NOERROR == mmr)
                        {
                            FormatTagsCallback(NULL, &afd, PTR2LPARAM(pInst), afd.fdwSupport);
                        }
                    }

                    //
                    //
                    //
                    if (0 != (pInst->pfmtc->fdwEnum & (ACM_FORMATENUMF_CONVERT |
                                                       ACM_FORMATENUMF_SUGGEST)))
                    {
                        afd.cbStruct    = sizeof(afd);
                        afd.dwFormatTag = pInst->pfmtc->pwfxEnum->wFormatTag;
                        afd.pwfx        = pInst->pfmtc->pwfxEnum;
                        afd.cbwfx       = SIZEOF_WAVEFORMATEX(pInst->pfmtc->pwfxEnum);
                        afd.fdwSupport  = 0L;

                        mmr = acmFormatDetails(NULL, &afd, ACM_FORMATDETAILSF_FORMAT);
                        if (MMSYSERR_NOERROR == mmr)
                        {
                            FormatTagsCallback(NULL, &afd, PTR2LPARAM(pInst), afd.fdwSupport);
                        }
                    }
                }
                GlobalFreePtr(pwfx);
            }
            break;
        }
        case FILTER_CHOOSE:
        {
            ACMFILTERTAGDETAILS aftd;

            _fmemset(&aftd, 0, sizeof(aftd));

            /* Enumerate the filter tags */
            aftd.cbStruct = sizeof(aftd);

            /* Was a filter tag specified?
             * This means they only want one filter tag.
             */
            pInst->fTagFilter = (pInst->pafltrc->pwfltrEnum &&
                                 (pInst->pafltrc->fdwEnum & ACM_FILTERENUMF_DWFILTERTAG));

            mmrEnumStatus = acmFilterTagEnum(NULL,
                                              &aftd,
                                              FilterTagsCallback,
                                              PTR2LPARAM(pInst),
                                              dwEnumFlags);
            if (MMSYSERR_NOERROR == mmrEnumStatus)
            {
                //
                //  add filter that we are asked to init to (this has every
                //  chance of being a 'non-standard' filter, so we have to do
                //  this in the following way..)
                //
                if (0 != (ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT & pInst->pafltrc->fdwStyle))
                {
                    _fmemset(&aftd, 0, sizeof(aftd));

                    aftd.cbStruct    = sizeof(aftd);
                    aftd.dwFilterTag = pInst->pafltrc->pwfltr->dwFilterTag;

                    mmr = acmFilterTagDetails(NULL, &aftd, ACM_FILTERTAGDETAILSF_FILTERTAG);
                    if (MMSYSERR_NOERROR == mmr)
                    {
                        FilterTagsCallback(NULL, &aftd, PTR2LPARAM(pInst), aftd.fdwSupport);
                    }
                }
            }
            break;
        }
    }

    if (MMSYSERR_NOERROR == mmrEnumStatus)
    {
        /*
         * perhaps we made it through but, darn it, we just didn't find
         * any suitable tags!  Well there must not have been an acceptable
         * driver configuration.  We just quit and tell the caller.
         */
        if (ComboBox_GetCount(pInst->hFormatTags) == 0)
            mmrEnumStatus = MMSYSERR_NODRIVER;
    }

    SetWindowRedraw(pInst->hFormatTags,TRUE);
    return (mmrEnumStatus);
}


//--------------------------------------------------------------------------;
//
//  BOOL FormatTagsCallbackSimpleOnlyOne
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPACMFORMATDETAILS pafd:
//
//      DWORD_PTR dwInstance:
//
//      DWORD fdwSupport:
//
//  Return (BOOL):
//
//
//--------------------------------------------------------------------------;

BOOL FNWCALLBACK FormatTagsCallbackSimpleOnlyOne
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILS      pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    //
    //  only need ONE callback!
    //
    *((LPDWORD)dwInstance) = 1;

    DPF(1, "FormatTagsCallbackSimpleOnlyOne: %lu, %s", pafd->dwFormatTag, pafd->szFormat);

    return (FALSE);
} // FormatTagsCallbackSimpleOnlyOne()


//--------------------------------------------------------------------------;
//
//  BOOL FormatTagsCallbackSimple
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPACMFILTERTAGDETAILS paftd:
//
//      DWORD_PTR dwInstance:
//
//      DWORD fdwSupport:
//
//  Return (BOOL):
//
//
//--------------------------------------------------------------------------;

BOOL FNWCALLBACK FormatTagsCallbackSimple
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    MMRESULT            mmr;
    int                 n;
    PInstData           pInst;
    LPWAVEFORMATEX	pwfxSave;
    DWORD		cbwfxSave;
    BOOL                f;
    DWORD               dw;

    //
    //
    //
    pInst = (PInstData)LPARAM2PTR(dwInstance);

    /* Explicitly filtering for a tag?
     */
    if (pInst->fTagFilter && (paftd->dwFormatTag != pInst->pfmtc->pwfxEnum->wFormatTag))
        return (TRUE);

    n = IComboBox_FindStringExactW32(pInst->hFormatTags, -1, paftd->szFormatTag);
    if (CB_ERR != n)
    {
        return (TRUE);
    }

    dw = 0;
    pInst->pafdSimple->dwFormatTag = paftd->dwFormatTag;
    pInst->pafdSimple->fdwSupport  = 0L;
    pInst->pafdSimple->pwfx->wFormatTag = (UINT)paftd->dwFormatTag;

    //
    //
    //
    cbwfxSave = pInst->pafdSimple->cbwfx;
    pwfxSave = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfxSave);
    if (NULL == pwfxSave) {
	return (TRUE);
    }
    _fmemcpy(pwfxSave, pInst->pafdSimple->pwfx, (int)cbwfxSave);

    mmr = acmFormatEnum(NULL,
                        pInst->pafdSimple,
                        FormatTagsCallbackSimpleOnlyOne,
                        (DWORD_PTR)(LPDWORD)&dw,
                        pInst->pfmtc->fdwEnum | ACM_FORMATENUMF_WFORMATTAG);

    _fmemcpy(pInst->pafdSimple->pwfx, pwfxSave, (int)cbwfxSave);
    GlobalFreePtr(pwfxSave);

    //
    //
    //
    if (0 == dw)
    {
        return (TRUE);
    }

    //
    //
    //
    if (pInst->fEnableHook)
    {
        f = (BOOL)SendMessage(pInst->hwnd,
                              MM_ACM_FORMATCHOOSE,
                              FORMATCHOOSE_FORMATTAG_VERIFY,
                              (LPARAM)paftd->dwFormatTag);
        if (!f)
        {
            return (TRUE);
        }
    }

    n = IComboBox_AddStringW32(pInst->hFormatTags, paftd->szFormatTag);
    ComboBox_SetItemData(pInst->hFormatTags, n, paftd->dwFormatTag);

    // Keep going
    return (TRUE);
} // FormatTagsCallbackSimple()



/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNWCALLBACK | FormatTagsCallback | Callback entry point for
 *  format tags.  We only enumerate formats upon refresh.
 *
 ****************************************************************************/

BOOL FNWCALLBACK
FormatTagsCallback ( HACMDRIVERID           hadid,
                     LPACMFORMATDETAILS     pafd,
                     DWORD_PTR              dwInstance,
                     DWORD                  fdwSupport )
{
    int                 index;
    PInstData           pInst = (PInstData)LPARAM2PTR(dwInstance);
    ACMFORMATTAGDETAILS aftd;
    MMRESULT            mmr;

    /* We are being called by acmFormatEnum.  Why not acmFormatTagEnum?
     * because we can't enumerate tags based upon the same restrictions
     * as acmFormatEnum.  So we use the pwfx->wFormatTag and lookup
     * the combobox to determine if we've had a hit.  This is slow, but
     * it only happens once during initialization.
     */

    _fmemset(&aftd, 0, sizeof(aftd));
    aftd.cbStruct = sizeof(aftd);
    aftd.dwFormatTag = pafd->pwfx->wFormatTag;

    mmr = acmFormatTagDetails(NULL,
                              &aftd,
                              ACM_FORMATTAGDETAILSF_FORMATTAG);
    if (MMSYSERR_NOERROR != mmr)
        return (TRUE);

    index = IComboBox_FindStringExactW32(pInst->hFormatTags,
					 -1,
					 aftd.szFormatTag);

    /*
     * if this isn't there try to add it.
     */
    if (CB_ERR == index)
    {
        /*
         * Ask any hook proc's to verify this tag.
         */
        if (pInst->fEnableHook &&
            !SendMessage(pInst->hwnd,
                         MM_ACM_FORMATCHOOSE,
                         FORMATCHOOSE_FORMATTAG_VERIFY,
                         (LPARAM)aftd.dwFormatTag))
            return (TRUE);

	index = IComboBox_AddStringW32(pInst->hFormatTags, aftd.szFormatTag);
        ComboBox_SetItemData(pInst->hFormatTags,index, aftd.dwFormatTag);

    }

    /* Keep going
     */
    return (TRUE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void | FilterTagsCallback | Callback entry point for filter tags.
 *  We only enumerate formats upon refresh.
 *
 ****************************************************************************/
BOOL FNWCALLBACK
FilterTagsCallback ( HACMDRIVERID           hadid,
                     LPACMFILTERTAGDETAILS  paftd,
                     DWORD_PTR              dwInstance,
                     DWORD                  fdwSupport )
{
    int             index;
    PInstData       pInst = (PInstData)LPARAM2PTR(dwInstance);

    /* Explicitly filtering for a tag?
     */
    if (pInst->fTagFilter &&
        paftd->dwFilterTag != pInst->pafltrc->pwfltrEnum->dwFilterTag)
        return (TRUE);

    index = IComboBox_FindStringExactW32(pInst->hFormatTags, -1, paftd->szFilterTag);

    /*
     * if this isn't there try to add it.
     */
    if (CB_ERR == index)
    {
        if (pInst->fEnableHook &&
            !SendMessage(pInst->hwnd,
                        MM_ACM_FILTERCHOOSE,
                        FILTERCHOOSE_FILTERTAG_VERIFY,
                        (LPARAM)paftd->dwFilterTag))
            return (TRUE);

	index = IComboBox_AddStringW32(pInst->hFormatTags, paftd->szFilterTag);
        ComboBox_SetItemData(pInst->hFormatTags,index, paftd->dwFilterTag);
    }

    // Keep going
    return (TRUE);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | RefreshFormats |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
RefreshFormats ( PInstData pInst )
{
    BOOL            fOk;
    HCURSOR         hCur;
    MMRESULT        mmr;
    DWORD           dwEnumFlags;
    DWORD           cbSize;

    ASSERT( NULL != pInst->pag );

    hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));

    SetWindowRedraw(pInst->hFormats,FALSE);

    /* Remove all wave formats */
    EmptyFormats(pInst);

    ComboBox_ResetContent(pInst->hFormats);

    /* Brief explanation:
     *  RefreshFormats() updates the Format/Filter combobox.  This
     *  combobox is *THE* selection for the dialog.  This is where we
     *  call the enumeration API's to limit the user's selection.
     *
     *  IF the user has passed in fdwEnum flags to "match", we just copy
     *  the p*Enum add our current tag and OR the ACM_*ENUMF_*TAG flag
     *  to their fdwEnum flags.
     *
     *  IF the user has passed in fdwEnum flags to convert or suggest,
     *  we just let it go untouched through the acmFormatEnum API.
     */

    fOk = (pInst->dwTag != 0L);
    /* If there's an evil tag selected.  Just skip this junk
     */

    if (fOk)
        switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
        {
            ACMFORMATDETAILS    afd;
            LPWAVEFORMATEX      pwfx;

            fOk = FALSE;

            mmr = IMetricsMaxSizeFormat( pInst->pag, NULL, &afd.cbwfx );
            if (MMSYSERR_NOERROR == mmr)
            {
                afd.cbwfx = max(afd.cbwfx, pInst->cbwfxEnum);

                pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)afd.cbwfx);
                if (NULL == pwfx)
                    break;

                afd.cbStruct    = sizeof(afd);
                afd.pwfx        = pwfx;
                afd.fdwSupport  = 0L;

                /* optional filtering for a waveformat template */
                if ( pInst->pfmtc->pwfxEnum )
                {
                    cbSize = min(pInst->cbwfxEnum, afd.cbwfx);
                    _fmemcpy(pwfx, pInst->pfmtc->pwfxEnum, (UINT)cbSize);
                }

                dwEnumFlags = pInst->pfmtc->fdwEnum;

                fOk = TRUE;

                if ( pInst->pfmtc->fdwEnum &
                     (ACM_FORMATENUMF_CONVERT | ACM_FORMATENUMF_SUGGEST))
                {
                    /* enumerate over all formats and exclude
                     * undesireable ones in the callback.
                     */
                    ;
                }
                else
                {
                    /* enumerate over only ONE format
                     */
                    dwEnumFlags |= ACM_FORMATENUMF_WFORMATTAG;
                    afd.pwfx->wFormatTag = (WORD)pInst->dwTag;
                }

                afd.dwFormatTag = pwfx->wFormatTag;

                fOk = (acmFormatEnum(NULL,
                                    &afd,
                                    FormatsCallback,
                                    PTR2LPARAM(pInst),
                                    dwEnumFlags)== 0L);

                GlobalFreePtr(pwfx);
            }

            //
            //  add format that we are asked to init to (this has every
            //  chance of being a 'non-standard' format, so we have to do
            //  this in the following way..)
            //
            if (0 != (ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT & pInst->pfmtc->fdwStyle))
            {
                if (pInst->pfmtc->pwfx->wFormatTag == (WORD)pInst->dwTag)
                {
                    afd.cbStruct    = sizeof(afd);
                    afd.dwFormatTag = pInst->dwTag;
                    afd.pwfx        = pInst->pfmtc->pwfx;
                    afd.cbwfx       = SIZEOF_WAVEFORMATEX(pInst->pfmtc->pwfx);
                    afd.fdwSupport  = 0L;

                    mmr = acmFormatDetails(NULL, &afd, ACM_FORMATDETAILSF_FORMAT);
                    if (MMSYSERR_NOERROR == mmr)
                    {
                        FormatsCallback(NULL, &afd, PTR2LPARAM(pInst), afd.fdwSupport);
                    }
                }
            }

            //
            //
            //
            if (0 != (pInst->pfmtc->fdwEnum & (ACM_FORMATENUMF_CONVERT |
                                               ACM_FORMATENUMF_SUGGEST)))
            {
                if (pInst->pfmtc->pwfxEnum->wFormatTag == (WORD)pInst->dwTag)
                {
                    afd.cbStruct    = sizeof(afd);
                    afd.dwFormatTag = pInst->dwTag;
                    afd.pwfx        = pInst->pfmtc->pwfxEnum;
                    afd.cbwfx       = SIZEOF_WAVEFORMATEX(pInst->pfmtc->pwfxEnum);
                    afd.fdwSupport  = 0L;

                    mmr = acmFormatDetails(NULL, &afd, ACM_FORMATDETAILSF_FORMAT);
                    if (MMSYSERR_NOERROR == mmr)
                    {
                        FormatsCallback(NULL, &afd, PTR2LPARAM(pInst), afd.fdwSupport);
                    }
                }
            }
            break;
        }
        case FILTER_CHOOSE:
        {
            ACMFILTERDETAILS    afd;
            LPWAVEFILTER         pwfltr;

            fOk = FALSE;

            mmr = IMetricsMaxSizeFilter( pInst->pag, NULL, &afd.cbwfltr );
            if (MMSYSERR_NOERROR == mmr)
            {
                afd.cbwfltr = max(afd.cbwfltr, pInst->cbwfltrEnum);

                pwfltr = (LPWAVEFILTER)GlobalAllocPtr(GHND, (UINT)afd.cbwfltr);
                if (NULL != pwfltr)
                {
                    afd.cbStruct   = sizeof(afd);
                    afd.pwfltr     = pwfltr;
                    afd.fdwSupport = 0L;

                    /* optional filtering for a wavefilter template */
                    if ( pInst->pafltrc->pwfltrEnum )
                    {
                        cbSize = pInst->pafltrc->pwfltrEnum->cbStruct;
                        cbSize = min (cbSize, afd.cbwfltr);
                        _fmemcpy(pwfltr, pInst->pafltrc->pwfltrEnum, (UINT)cbSize);
                    }

                    dwEnumFlags = ACM_FILTERENUMF_DWFILTERTAG;
                    afd.pwfltr->dwFilterTag = pInst->dwTag;

                    fOk = (acmFilterEnum(NULL,
                                         &afd,
                                         FiltersCallback,
                                         PTR2LPARAM(pInst),
                                         dwEnumFlags) == 0L);
                    GlobalFreePtr(pwfltr);
                }
            }

            //
            //  add filter that we are asked to init to (this has every
            //  chance of being a 'non-standard' filter, so we have to do
            //  this in the following way..)
            //
            if (0 != (ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT & pInst->pafltrc->fdwStyle))
            {
                if (pInst->pafltrc->pwfltr->dwFilterTag == pInst->dwTag)
                {
                    afd.cbStruct    = sizeof(afd);
                    afd.dwFilterTag = pInst->dwTag;
                    afd.pwfltr      = pInst->pafltrc->pwfltr;
                    afd.cbwfltr     = pInst->pafltrc->pwfltr->cbStruct;
                    afd.fdwSupport  = 0L;

                    mmr = acmFilterDetails(NULL, &afd, ACM_FILTERDETAILSF_FILTER);
                    if (MMSYSERR_NOERROR == mmr)
                    {
                        FiltersCallback(NULL, &afd, PTR2LPARAM(pInst), afd.fdwSupport);
                    }
                }
            }
            break;
        }
    }
    if (fOk)
        fOk = (ComboBox_GetCount(pInst->hFormats) > 0);

    if (!fOk)
    {
        int index;

        // The codec has probably been disabled or there are no supported
        // formats.
        LoadString(pInst->pag->hinst,
                   IDS_TXT_NONE,
                   (LPTSTR)pInst->pnsTemp->achName,
                   NAMELEN(pInst->pnsTemp));
        index = IComboBox_InsertString(pInst->hFormats,0,
				       pInst->pnsTemp->achName);
        ComboBox_SetItemData(pInst->hFormats,index,0L);
    }

    // Don't let the user OK or assign name, only cancel

    EnableWindow(pInst->hOk,fOk);
    EnableWindow(pInst->hSetName,fOk);

    SetWindowRedraw(pInst->hFormats,TRUE);

    SetCursor(hCur);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | EmptyFormats | Remove all formats
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
EmptyFormats ( PInstData pInst )
{
    int index;
    LPWAVEFORMATEX lpwfx;
    for (index = ComboBox_GetCount(pInst->hFormats);
        index > 0;
        index--)
    {
        lpwfx = (LPWAVEFORMATEX)ComboBox_GetItemData(pInst->hFormats,index-1);
        if (lpwfx)
            GlobalFreePtr(lpwfx);
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNWCALLBACK | FormatsCallback | Callback entry point for formats.
 *  We only enumerate formats upon refresh.
 *
 *
 ****************************************************************************/
BOOL FNWCALLBACK
FormatsCallback ( HACMDRIVERID hadid,
                  LPACMFORMATDETAILS pafd,
                  DWORD_PTR dwInstance,
                  DWORD fdwSupport )
{
    PInstData       pInst = (PInstData)LPARAM2PTR(dwInstance);
    PNameStore      pns = pInst->pnsTemp;
    LPWAVEFORMATEX  lpwfx;
    UINT            index;

    /* Check for the case when something like CONVERT or SUGGEST
     * is used and we get called back for non matching tags.
     */
    if ((WORD)pInst->dwTag != pafd->pwfx->wFormatTag)
        return (TRUE);

    // we get the details from the callback
#if defined(WIN32) && !defined(UNICODE)
    Iwcstombs(pns->achName, pafd->szFormat, pns->cbSize);
#else
    lstrcpy(pns->achName, pafd->szFormat);
#endif

    MashNameWithRate(pInst,pInst->pnsStrOut,pns,(pafd->pwfx));
    index = IComboBox_FindStringExact(pInst->hFormats,-1,
				      pInst->pnsStrOut->achName);

    //
    //  if already in combobox, don't add another instance
    //
    if (CB_ERR != index)
        return (TRUE);


    if (pInst->fEnableHook && !SendMessage(pInst->hwnd,
                                           MM_ACM_FORMATCHOOSE,
                                           FORMATCHOOSE_FORMAT_VERIFY,
                                           (LPARAM)pafd->pwfx))
        return (TRUE);

    lpwfx = (LPWAVEFORMATEX)CopyStruct(NULL,(LPBYTE)(pafd->pwfx),FORMAT_CHOOSE);

    if (!lpwfx)
        return (TRUE);

    index = IComboBox_AddString(pInst->hFormats,
				pInst->pnsStrOut->achName);

    ComboBox_SetItemData(pInst->hFormats,index,(LPARAM)lpwfx);

    // Keep going
    return (TRUE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNWCALLBACK | FiltersCallback() | Callback entry point for
 *  formats.  We only enumerate formats upon refresh.
 *
 *
 ****************************************************************************/
BOOL FNWCALLBACK
FiltersCallback ( HACMDRIVERID          hadid,
                  LPACMFILTERDETAILS    pafd,
                  DWORD_PTR             dwInstance,
                  DWORD                 fdwSupport )
{
    PInstData       pInst = (PInstData)LPARAM2PTR(dwInstance);
    PNameStore      pns = pInst->pnsTemp;
    UINT            index;
    LPWAVEFILTER    lpwf;

    if (pInst->dwTag != pafd->pwfltr->dwFilterTag)
        return (TRUE);

    index = IComboBox_FindStringExactW32(pInst->hFormats, -1, pafd->szFilter);

    //
    //  if already in combobox, don't add another instance
    //
    if (CB_ERR != index)
        return (TRUE);

    if (pInst->fEnableHook && !SendMessage(pInst->hwnd,
                                           MM_ACM_FILTERCHOOSE,
                                           FILTERCHOOSE_FILTER_VERIFY,
                                           (LPARAM)pafd->pwfltr))
        return (TRUE);

    /*
     * Filter depending upon the flags.
     */
    lpwf = (LPWAVEFILTER)CopyStruct(NULL,(LPBYTE)(pafd->pwfltr),FILTER_CHOOSE);

    if (!lpwf)
        return (TRUE);

    // we get the details from the callback
#if defined(WIN32) && !defined(UNICODE)
    Iwcstombs(pns->achName, pafd->szFilter, pns->cbSize);
#else
    lstrcpy(pns->achName, pafd->szFilter);
#endif

    index = IComboBox_AddString(pInst->hFormats, pns->achName);
    ComboBox_SetItemData(pInst->hFormats,index,(LPARAM)lpwf);

    // Keep going
    return (TRUE);
}

/*      -       -       -       -       -       -       -       -       -   */
/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | DelName | Delete the currently selected name.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
DelName ( PInstData pInst )
{
    if (!pInst->pcf)
        return;

    if (!RemoveCustomFormat(pInst,pInst->pcf))
    {
        /* This format is selected elsewhere in another
         * instance.
         */
        ErrorResBox(pInst->hwnd,pInst->pag->hinst,MB_ICONEXCLAMATION|
                    MB_OK, IDS_CHOOSEFMT_APPTITLE, IDS_ERR_FMTSELECTED);
    }
    else
    {
        FlushCustomFormats(pInst);
        NotifyINIChange(pInst);
        RefreshCustomFormats(pInst,FALSE);
        ComboBox_SetCurSel(pInst->hCustomFormats,0);
        SelectCustomFormat(pInst);
    }
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SetName | Launch the set name dialog box
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SetName ( PInstData pInst )
{
    LPCustomFormat  pcf;
    INT_PTR         iRet;
    int             index;

    HFONT	    hfont;
    HRSRC	    hrsrcDlgO;
    HGLOBAL	    hglbDlgO;
    LPVOID	    lpDlgO;
    LPBYTE	    lpO;
    DWORD	    cbDlgO;
    LPVOID	    lpDlgN;
    LPBYTE	    lpN;
    DWORD	    cbDlgN;
    UINT	    uLogPixelsPerInch;
    WORD	    wPoint;
    LOGFONT	    lf;
    HDC		    hdc;
    UINT	    cb;

    hglbDlgO = NULL;
    lpDlgO = NULL;
    lpDlgN = NULL;

    //
    //	--== Build a dialog resource ==--
    //
    //	This will be a modified version of an existing resource.  We do
    //	this for the sole purpose of using the same font as the owner
    //	window.  A lot of work, just for this!!!
    //
    //	Note: The "O" and "N" suffixes on some of the variables are for
    //	Old and New.
    //

    hrsrcDlgO = FindResource( pInst->pag->hinst, DLG_CHOOSE_SAVE_NAME, RT_DIALOG );
    if (NULL == hrsrcDlgO) goto Destruct;

    cbDlgO = SizeofResource( pInst->pag->hinst, hrsrcDlgO );
    if (0 == cbDlgO) goto Destruct;

    hglbDlgO = LoadResource( pInst->pag->hinst, hrsrcDlgO );
    if (NULL == hglbDlgO) goto Destruct;

    lpDlgO = LockResource( hglbDlgO );
    if (NULL == lpDlgO) goto Destruct;

    if ( ((LPDLGTEMPLATE2)lpDlgO)->wSignature != 0xFFFF) { // Dialog Template

    //
    //	Obtain font of owner window.  Get logical height of the font, then
    //	convert it to a point size based on the DC's logical pixels per inch.
    //
    hfont = (HFONT)SendMessage(pInst->hwnd, WM_GETFONT, 0, 0L);
    if (NULL == hfont) goto Destruct;

    if (0 == GetObject( hfont, sizeof(lf), &lf )) goto Destruct;

    hdc = GetDC(pInst->hwnd);
    uLogPixelsPerInch = GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(pInst->hwnd, hdc);

    ASSERT( 0 != uLogPixelsPerInch );			// I'm scared!
    if (0 == uLogPixelsPerInch) goto Destruct;		// I'm scared!

    wPoint = (WORD)((-lf.lfHeight) * 72 / uLogPixelsPerInch);

    //
    //	Allocate memory for new resource.  We'll make it the size of the
    //	existing resource plus room for the new font information (this may
    //	be overkill since there may already be font information in the
    //	existing resource.
    //
#ifdef WIN32
    cbDlgN = cbDlgO + (lstrlen(lf.lfFaceName)+1)*sizeof(WCHAR);
#else
    cbDlgN = cbDlgO + (lstrlen(lf.lfFaceName)+1)*sizeof(TCHAR);
#endif

    lpDlgN = GlobalAllocPtr(GMEM_FIXED, cbDlgN);
    if (NULL == lpDlgN) goto Destruct;

    //
    //	lpO and lpN walk through the resources
    //
    lpO = lpDlgO;
    lpN = lpDlgN;

    //
    //	Copy the initial DLGTEMPLATE structure
    //
#ifdef WIN32
    _fmemcpy(lpN, lpO, 18);	// 18 bytes in win32
    lpN += 18;
    lpO += 18;
#else
    _fmemcpy(lpN, lpO, 13);	// 13 bytes in win16
    lpN += 13;
    lpO += 13;
#endif

    //
    //	menu array
    //
#ifdef WIN32
    if (0xFFFF == *(LPWORD)lpO) {
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
    } else {
	cb = (lstrlenW((LPCWSTR)lpO)+1) * sizeof(WCHAR);
	_fmemcpy(lpN, lpO, cb);
	lpN += cb;
	lpO += cb;
    }
#else
    if (0xFF == *lpO) {
	*lpN++ = *lpO++;
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
    } else {
	cb = (lstrlen(lpO)+1) * sizeof(char);
	_fmemcpy(lpN, lpO, cb);
	lpN += cb;
	lpO += cb;
    }
#endif
	
    //
    //	class array
    //
#ifdef WIN32
    if (0xFFFF == *(LPWORD)lpO) {
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
    } else {
	cb = (lstrlenW((LPCWSTR)lpO)+1) * sizeof(WCHAR);
	_fmemcpy(lpN, lpO, cb);
	lpN += cb;
	lpO += cb;
    }
#else
    if (0xFF == *lpO) {
	*lpN++ = *lpO++;
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
    } else {
	cb = (lstrlen(lpO)+1) * sizeof(char);
	_fmemcpy(lpN, lpO, cb);
	lpN += cb;
	lpO += cb;
    }
#endif
	
    //
    //	title array
    //
#ifdef WIN32
    cb = (lstrlenW((LPCWSTR)lpO)+1) * sizeof(WCHAR);
#else
    cb = (lstrlen(lpO)+1) * sizeof(char);
#endif
    _fmemcpy(lpN, lpO, cb);
    lpN += cb;
    lpO += cb;

    //
    //	point size and font face name - skip original
    //	information _if_ it's there (ie DS_SETFONT style flag is set).
    //
    if (*(LPDWORD)lpDlgO & DS_SETFONT) {
	lpO += 2;
#ifdef WIN32
	cb = (lstrlenW((LPCWSTR)lpO)+1) * sizeof(WCHAR);
#else
	cb = (lstrlen(lpO)+1) * sizeof(char);
#endif
	lpO += cb;
    }

    //
    //	point size
    //
    *(LPWORD)lpN = wPoint;
    lpN += 2;

    //
    //	font face name
    //
#if defined(WIN32) && !defined(UNICODE)
    Imbstowcs((LPWSTR)lpN, lf.lfFaceName, lstrlen(lf.lfFaceName));
    lpN += (lstrlen(lf.lfFaceName)+1)*sizeof(WCHAR);
#else
    lstrcpy( (LPTSTR)lpN, lf.lfFaceName);
    lpN += (lstrlen(lf.lfFaceName)+1)*sizeof(TCHAR);
#endif

    //
    //	all remaining data
    //
#ifdef WIN32
    //	remaining data is dword aligned.
    lpN = (LPBYTE)(((((UINT_PTR)lpN)+3) >> 2) << 2);
    lpO = (LPBYTE)(((((UINT_PTR)lpO)+3) >> 2) << 2);
#endif
    _fmemcpy(lpN, lpO, (UINT)(cbDlgO-(lpO-(LPBYTE)lpDlgO)));

    } // End of Dialog template
    else { // DialogEx template
         lpDlgN = lpDlgO;  // Nothing to do with dialogEx template.
    } // End of DialogEx template

    //
    //	--== Finally!! Done building the new resource ==--
    //

    iRet = DialogBoxIndirectParam( pInst->pag->hinst,
#ifdef WIN32
				   lpDlgN,
#else
				   GlobalPtrHandle(lpDlgN),
#endif
				   pInst->hwnd,
				   NewNameDlgProc,
				   PTR2LPARAM(pInst) );

    if (iRet <= 0) goto Destruct;

    /* A name has been selected.  The result is in pInst->pnsTemp
     * Create a CustomFormat for the selection and add it to the Global
     * FormatPool.
     */

    pcf = NewCustomFormat(pInst,pInst->pnsTemp,pInst->lpbSel);
    if (pcf)
        AddCustomFormat(pInst, pcf);

    FlushCustomFormats(pInst);
    NotifyINIChange(pInst);
    RefreshCustomFormats(pInst,FALSE);
    if (pcf)
    {
        index = IComboBox_FindStringExact(pInst->hCustomFormats,
				        -1,
				        pcf->pns->achName);
    }
    else
    {
        index = CB_ERR;
    }
    index = (index == CB_ERR)?0:index;
    ComboBox_SetCurSel(pInst->hCustomFormats,index);
    SelectCustomFormat(pInst);

    //
    //
    //
Destruct:
    if (NULL != lpDlgN) {
	GlobalFreePtr(lpDlgN);
    }
    if (NULL != lpDlgO) {
	UnlockResource( hglbDlgO );
    }
    if (NULL != hglbDlgO) {
	FreeResource( hglbDlgO );
    }

    return;

}


/*      -       -       -       -       -       -       -       -       -   */


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNWCALLBACK | NewNameDlgProc | Dialog proc to let the user type in
 *  a format name
 *
 ****************************************************************************/
INT_PTR FNWCALLBACK
NewNameDlgProc ( HWND       hwnd,
                 unsigned   msg,
                 WPARAM     wParam,
                 LPARAM     lParam)
{
    UINT        CmdCommandId;  // WM_COMMAND ID
    UINT        CmdCmd;        // WM_COMMAND Command
    HWND        CmdHwnd;
    HWND        hctrlEdit;
    PInstData   pInst;
    PNameStore  pName;

    pInst = GetInstData(hwnd);

    switch (msg)
    {
        case WM_INITDIALOG:
            if (!pInst)
            {
                if (SetInstData(hwnd,lParam))
                {
                    TCHAR ach[128];

                    pInst = (PInstData)lParam;
                    pName = pInst->pnsTemp;

                    EnableWindow(GetDlgItem(hwnd,IDOK),FALSE);
                    hctrlEdit = GetDlgItem(hwnd,IDD_EDT_NAME);
                    Edit_LimitText(hctrlEdit,NAMELEN(pName));
                    LoadString(pInst->pag->hinst,
                               (pInst->uType==FORMAT_CHOOSE)?
                                IDS_CHOOSE_FORMAT_DESC:
                                IDS_CHOOSE_FILTER_DESC,
                               ach, SIZEOF(ach));
                    SetDlgItemText(hwnd, IDD_STATIC_DESC,(LPTSTR)ach);
                    return (FALSE);
                }
            }
            EndDialog(hwnd,FALSE);
            return (TRUE);

        case WM_COMMAND:
            CmdCommandId = GET_WM_COMMAND_ID(wParam,lParam);
            CmdCmd       = GET_WM_COMMAND_CMD(wParam,lParam);
            CmdHwnd      = GET_WM_COMMAND_HWND(wParam,lParam);
            switch (CmdCommandId)
            {
                case IDD_EDT_NAME:
                    if (EN_CHANGE == CmdCmd)
                        EnableWindow(GetDlgItem(hwnd,IDOK),
                                     (Edit_GetTextLength(CmdHwnd)?TRUE:FALSE));
                    return (FALSE);

                case IDOK:
                {
                    pName = pInst->pnsTemp;
                    hctrlEdit = GetDlgItem(hwnd,IDD_EDT_NAME);
                    Edit_GetText(hctrlEdit, pName->achName, NAMELEN(pName));

                    if (!RemoveOutsideWhitespace(pInst,pName))
                    {
                        ErrorResBox(hwnd,
                                    pInst->pag->hinst,
                                    MB_ICONEXCLAMATION | MB_OK,
                                    IDS_CHOOSEFMT_APPTITLE,
                                    IDS_ERR_BLANKNAME);
                    }
                    else if (IsCustomName(pInst,pName))
                    {
                        /* This custom name exists */
                        ErrorResBox(hwnd,
                                    pInst->pag->hinst,
                                    MB_ICONEXCLAMATION | MB_OK,
                                    IDS_CHOOSEFMT_APPTITLE,
                                    IDS_ERR_FMTEXISTS);
                    }
		    else if (!IsValidName(pInst, pName))
		    {
			/* This is not a valid name */
			ErrorResBox(hwnd,
				    pInst->pag->hinst,
				    MB_ICONEXCLAMATION | MB_OK,
				    IDS_CHOOSEFMT_APPTITLE,
				    IDS_ERR_INVALIDNAME);
		    }
                    else
                        EndDialog(hwnd,TRUE);

                    return (TRUE);
                }
                case IDCANCEL:
                    EndDialog(hwnd,FALSE);
                    return (TRUE);
            }
            break;

        case WM_DESTROY:
            if (pInst)
                RemoveInstData(hwnd);
            return (FALSE);
    }
    return (FALSE);
}


/*      -       -       -       -       -       -       -       -       -   */


/*
 * @doc INTERNAL
 *
 * @func short | ErrorResBox | This function displays a message box using
 * program resource error strings.
 *
 * @parm HWND | hwnd | Specifies the message box parent window.
 *
 * @parm HANDLE | hInst | Specifies the instance handle of the module
 * that contains the resource strings specified by <p idAppName> and
 * <p idErrorStr>.  If this value is NULL, the instance handle is
 * obtained from <p hwnd> (in which case <p hwnd> may not be NULL).
 *
 * @parm WORD | flags | Specifies message box types controlling the
 * message box appearance.  All message box types valid for <f MessageBox> are
 * valid.
 *
 * @parm WORD | idAppName | Specifies the resource ID of a string that
 * is to be used as the message box caption.
 *
 * @parm WORD | idErrorStr | Specifies the resource ID of a error
 * message format string.  This string is of the style passed to
 * <f wsprintf>, containing the standard C argument formatting
 * TCHARacters.  Any procedure parameters following <p idErrorStr> will
 * be taken as arguments for this format string.
 *
 * @parm arguments | [ arguments, ... ] | Specifies additional
 * arguments corresponding to the format specification given by
 * <p idErrorStr>.  All string arguments must be FAR pointers.
 *
 * @rdesc Returns the result of the call to <f MessageBox>.  If an
 * error occurs, returns zero.
 *
 * @comm This is a variable arguments function, the parameters after
 * <p idErrorStr> being taken for arguments to the <f printf> format
 * string specified by <p idErrorStr>.  The string resources specified
 * by <p idAppName> and <p idErrorStr> must be loadable using the
 * instance handle <p hInst>.  If the strings cannot be
 * loaded, or <p hwnd> is not valid, the function will fail and return
 * zero.
 *
 */

#define STRING_SIZE 256

static int FAR cdecl ErrorResBox(HWND hwnd,
				 HINSTANCE    hInst,
				 WORD flags,
				 WORD idAppName,
				 WORD idErrorStr, ...)
{
    PSTR    sz = NULL;
    PSTR    szFmt = NULL;
    int     i;
    va_list va;

    if (hInst == NULL)
    {
        if (hwnd == NULL)
        {
            MessageBeep(0);
            return FALSE;
        }

        hInst = GetWindowInstance(hwnd);
    }

    i = 0;

    sz = (PSTR) LocalAlloc(LPTR, STRING_SIZE * sizeof(TCHAR));
    szFmt = (PSTR) LocalAlloc(LPTR, STRING_SIZE * sizeof(TCHAR));
    if (!sz || !szFmt)
    goto ExitError; // no mem, get out

    if (!LoadString(hInst, idErrorStr, (LPTSTR)szFmt, STRING_SIZE))
    goto ExitError;

    va_start(va, idErrorStr);
    wvsprintf((LPTSTR)sz, (LPTSTR)szFmt, va);
    va_end(va);

    if (!LoadString(hInst, idAppName, (LPTSTR)szFmt, STRING_SIZE))
        goto ExitError;

    i = MessageBox(hwnd, (LPTSTR)sz, (LPTSTR)szFmt,
#ifdef BIDI
                   MB_RTL_READING |
#endif
                   flags);

ExitError:
    if (sz) LocalFree((HANDLE) sz);
    if (szFmt) LocalFree((HANDLE) szFmt);

    return i;
}

/*      -       -       -       -       -       -       -       -       -   */

#if 0

//--------------------------------------------------------------------------;
//
//  void AppProfileWriteBytes
//
//  Description:
//      This function writes a raw structure of bytes to the application's
//      ini section that can later be retrieved using AppProfileReadBytes.
//      This gives an application the ability to write any structure to
//      the ini file and restore it later--very useful.
//
//  Arguments:
//      PCTSTR pszKey: Pointer to key name for the stored data.
//
//      LPBYTE pbStruct: Pointer to the data to be saved.
//
//      UINT cbStruct: Count in bytes of the data to store.
//
//  History:
//       3/10/93   cjp     [curtisp]
//
//--------------------------------------------------------------------------;
#define APP_MAX_STRING_RC_CHARS 256
void FNGLOBAL AppProfileWriteBytes
(
    HKEY                hkey,
    LPCTSTR             pszKey,
    LPBYTE              pbStruct,
    UINT                cbStruct
)
{
    static TCHAR achNibbleToChar[] =
    {
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
    };
    #define     NIBBLE2CHAR(x)      (achNibbleToChar[x])

    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    LPTSTR      psz;
    LPTSTR      pch;
    BOOL        fAllocated;
    UINT        cchTemp;
    BYTE        b;
    BYTE        bChecksum;

    ASSERT( NULL != hkey );
    ASSERT( NULL != pszKey );
    ASSERT( NULL != pbStruct );
    ASSERT( cbStruct > 0 );


    fAllocated = FALSE;

    //
    //  check if the quick buffer can be used for formatting the output
    //  text--if it cannot, then alloc space for it. note that space
    //  must be available for an ending checksum byte (2 bytes for high
    //  and low nibble) as well as a null terminator.
    //
    psz     = (LPTSTR)ach;
    cchTemp = cbStruct * 2 + 3;
    if (cchTemp > SIZEOF(ach))
    {
        psz = (LPTSTR)GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR));
        if (NULL == psz)
            return;

        fAllocated = TRUE;
    }

    //
    //  step through all bytes in the structure and convert it to
    //  a string of hex numbers...
    //
    bChecksum = 0;
    for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++)
    {
        //
        //  grab the next byte and add into checksum...
        //
        bChecksum += (b = *pbStruct);

        *pch++ = NIBBLE2CHAR((b >> (BYTE)4) & (BYTE)0x0F);
        *pch++ = NIBBLE2CHAR(b & (BYTE)0x0F);
    }

    //
    //  add the checksum byte to the end and null terminate the hex
    //  dumped string...
    //
    *pch++ = NIBBLE2CHAR((bChecksum >> (BYTE)4) & (BYTE)0x0F);
    *pch++ = NIBBLE2CHAR(bChecksum & (BYTE)0x0F);
    *pch   = '\0';


    //
    //  write the string of hex bytes out to the ini file...
    //
    IRegWriteString( hkey, pszKey, psz );

    //
    //  free the temporary buffer if one was allocated (lots of bytes!)
    //
    if (fAllocated)
        GlobalFreePtr(psz);
}


//--------------------------------------------------------------------------;
//
//  BOOL AppProfileReadBytes
//
//  Description:
//      This function reads a previously stored structure of bytes from
//      the application's ini file. This data must have been written with
//      the AppProfileWriteBytes function--it is checksumed to keep bad
//      data from blowing up the application.
//
//  Arguments:
//      PCTSTR pszKey: Pointer to key that contains the data.
//
//      LPBYTE pbStruct: Pointer to buffer to receive the data.
//
//      UINT cbStruct: Number of bytes expected.
//
//  Return (BOOL):
//      The return value is TRUE if the function is successful. It is FALSE
//      if the function fails (bad checksum, missing key, etc).
//
//  History:
//       3/10/93   cjp     [curtisp]
//       5/06/93   jyg     Flag to disable CHECKSUM on read
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppProfileReadBytes
(
    HKEY                hkey,
    LPCTSTR             pszKey,
    LPBYTE              pbStruct,
    UINT                cbStruct,
    BOOL                fChecksum
)
{
    //
    //  note that the following works for both upper and lower case, and
    //  will return valid values for garbage chars
    //
    #define CHAR2NIBBLE(ch) (BYTE)( ((ch) >= '0' && (ch) <= '9') ?  \
                                (BYTE)((ch) - '0') :                \
                                ((BYTE)(10 + (ch) - 'A') & (BYTE)0x0F) )

    LPTSTR      psz;
    LPTSTR      pch;
    DWORD       cbValue;
    DWORD       dwType;
    BOOL        fReturn;
    BYTE        b;
    BYTE        bChecksum;
    TCHAR       ch;

    ASSERT( NULL != hkey );
    ASSERT( NULL != pszKey );
    ASSERT( NULL != pbStruct );
    ASSERT( cbStruct > 0 );


    //
    //  add one the the number of bytes needed to accomodate the checksum
    //  byte placed at the end by AppProfileWriteBytes...
    //
    cbStruct++;

    //
    //  Find out how big the data value is, then allocate a buffer for it.
    //
    dwType = REG_SZ;
    if( ERROR_SUCCESS != XRegQueryValueEx( hkey, (LPTSTR)pszKey, NULL,
                                            &dwType, NULL, &cbValue ) )
    {
        return FALSE;
    }

    psz = (LPTSTR)GlobalAllocPtr( GPTR, cbValue );
    if( NULL == psz )
        return FALSE;


    //
    //  read the hex string
    //
    fReturn = FALSE;

    dwType = REG_SZ;
    if( ERROR_SUCCESS == XRegQueryValueEx( hkey, (LPTSTR)pszKey,
                                            NULL, &dwType,
                                            (LPBYTE)psz, &cbValue ) )
    {
        //
        //  We read it successfully.  Check that we have enough data to
        //  fill the return structure.
        //
        if( cbStruct <= (UINT)lstrlen(psz)/2 )
        {
            //
            //  We have enough.  Decode the data and calculate checksum.
            //
            bChecksum = 0;
            for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++)
            {
                ch = *pch++;
                b  = CHAR2NIBBLE(ch) << (BYTE)4;
                ch = *pch++;
                b |= CHAR2NIBBLE(ch);

                //
                //  if this is not the final byte (the checksum byte), then
                //  store it and accumulate checksum..
                //
                if (cbStruct != 1)
                    bChecksum += (*pbStruct = b);
            }

            //
            //  check the last byte read against the checksum that we calculated
            //  if they are not equal then return error...
            //
            if (fChecksum)
                fReturn = (bChecksum == b);
            else
                fReturn = TRUE;
        }
    }


    GlobalFreePtr(psz);

    return (fReturn);
}

#endif // 0

//==========================================================================;
//
//
//
//
//==========================================================================;

#ifndef WIN32

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void | SelectFormat | Process a selection from format combo.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
//--------------------------------------------------------------------------;
//
//  LRESULT acmChooseFormat
//
//  Description:
//      This function simply thunks to the new acmFormatChoose() API for
//      Sound Recorder that ships with Bombay.
//
//  Arguments:
//      LPACMFORMATCHOOSE pfmtc:
//
//  Return (LRESULT):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT ACMAPI acmChooseFormat
(
    LPACMFORMATCHOOSE pfmtc
)
{
    ACMFORMATCHOOSE afc;
    //
    //  thunk to the new acmFormatChoose api
    //
    //  The v1.x chooser used the following structure:
    //
    //
//
//struct tACMCHOOSEWAVEFORMAT
//{
//    DWORD           cbStruct;       // sizeof(ACMCHOOSEWAVEFORMAT)
//    DWORD           dwFlags;        // various flags
//
//    HWND            hwndOwner;      // caller's window handle
//
//    LPWAVEFORMATEX  lpwfx;          // ptr to wfx buf to receive choice
//    DWORD           cbwfx;          // size of mem buf for lpwfx
///////////////////////////////////////////////////////////////////////////////
//    //
//    //  the following members are used for custom templates only--which
//    //  are enabled by specifying CWF_ENABLEHOOK in the dwFlags member.
//    //
//    //  these members are IGNORED if CWF_ENABLEHOOK is not specified.
//    //
//    HINSTANCE       hInstance;      // .EXE containing cust. dlg. template
//    LPSTR           lpTemplateName; // custom template name
//    LPARAM          lCustData;      // data passed to hook fn.
//    LPCWFHOOKPROC   lpfnHook;       // ptr to hook function
//
//    char            ach[100];       // padding for expansion
//
//}
//
//Lucky us, only Soundreck used used this and really only the members above
//cbwfx.
//
    _fmemset(&afc,0,sizeof(ACMFORMATCHOOSE));
    afc.cbStruct = sizeof(ACMFORMATCHOOSE);

    // The behavior of the style stuff seems to have changed a bit.
    // The low word is safe, though the old soundrec hooks things and
    // the help behavior might get funny (f1 gives old help, Help gives
    // real help).
#pragma message("No help for old acmchoose")
    afc.fdwStyle = LOWORD(pfmtc->fdwStyle);
    afc.hwndOwner = pfmtc->hwndOwner;
    afc.pwfx = pfmtc->pwfx;
    afc.cbwfx = pfmtc->cbwfx;
    afc.fdwEnum = ACM_FORMATENUMF_INPUT;

    return ((LRESULT)acmFormatChoose(&afc));
} // acmChooseFormat()

#endif // #ifndef WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\locks.c ===
//==========================================================================;
//
//  locks.c
//
//  Copyright (c) 1994-1998 Microsoft Corporation
//
//  Description:
//      Implement lock objects for win32
//
//  History:
//
//==========================================================================;


/*
    Implementation notes

    The scheme here rests on the handling of the Lock event.
    This event is non-autoreset.

    It is RESET whenever a thread can't proceed :

        - Want shared access and Lock is in use non-shared

        - Want non-shared access and the Lock is in use and we're not the
          owner

    and this is ALWAYS inside the Lock critical section.

    It is SET whenever NumberOfActive goes to 0.

    The key question is :  If it gets reset can we guarantee it will get
    set again (provided all threads eventually release their Locks

    To ensure this we make sure the following are always true when the
    Lock critical section is not held.

        (a) NumberOfActive == 0 => Nonshared event set
        (b) NumberOfActive >= 0 => Shared event set

    So it is guaranteed that nobody waits if they can proceed.

*/

#include <windows.h>
#include "locks.h"

#include "debug.h"

BOOL InitializeLock(PLOCK_INFO plock)
{

    //
    //  Everyone waiting for something interesting to happen gets
    //  dispatched every time something interesting happens
    //

    plock->SharedEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    if (plock->SharedEvent == NULL) {
        return FALSE;
    }


    plock->ExclusiveEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    if (plock->ExclusiveEvent == NULL) {
        CloseHandle(plock->SharedEvent);
        return FALSE;
    }

    try {
	InitializeCriticalSection(&plock->CriticalSection);
    } except(EXCEPTION_EXECUTE_HANDLER) {
	CloseHandle(plock->ExclusiveEvent);
	CloseHandle(plock->SharedEvent);
	return FALSE;
    }

    plock->ExclusiveOwnerThread = 0;
    plock->NumberOfActive       = 0;
    plock->SharedEventSet       = TRUE;
    plock->ExclusiveEventSet    = TRUE;

    return (TRUE);
}

VOID AcquireLockShared(PLOCK_INFO plock)
{
    while (1) {
        //
        //  Go into the critical section and see if conditions are right
        //
        EnterCriticalSection(&plock->CriticalSection);

        //
        //  NumberOfActive >= 0 means it's not held exclusive
        //

        if (plock->NumberOfActive >= 0) {
            plock->NumberOfActive++;
            LeaveCriticalSection(&plock->CriticalSection);
            return;
        }

        //
        //  We might be the non-shared owner in which case just add one
        //  to the count (ie subtract one since we've got it exclusive).
        //

        if (plock->ExclusiveOwnerThread == GetCurrentThreadId()) {
            plock->NumberOfActive--;
            LeaveCriticalSection(&plock->CriticalSection);
            return;
        }

        //
        //  Otherwise we've got to wait lazily.  Note that the event is
        //  ALWAYS set (see prologue) if the count if NumberOfActive >= 0.
        //

        plock->SharedEventSet = FALSE;
        ResetEvent(plock->SharedEvent);

        LeaveCriticalSection(&plock->CriticalSection);

        //
        //  Wait for the count to reach 0.
        //

        WaitForSingleObject(plock->SharedEvent, INFINITE);
    }
}

VOID AcquireLockExclusive(PLOCK_INFO plock)
{
    while (1) {
        //
        //  Go into the critical section and see if conditions are right
        //
        EnterCriticalSection(&plock->CriticalSection);

        //
        //  It's OK if NumberOfActive is 0 or we're the owner
        //

        if (plock->NumberOfActive == 0 ||
            GetCurrentThreadId() == plock->ExclusiveOwnerThread) {
            plock->ExclusiveOwnerThread = GetCurrentThreadId();
            plock->NumberOfActive--;
            LeaveCriticalSection(&plock->CriticalSection);
            return;
        }

        plock->ExclusiveEventSet = FALSE;
        ResetEvent(plock->ExclusiveEvent);
        LeaveCriticalSection(&plock->CriticalSection);

        //
        //  Wait for something interesting to happen
        //

        WaitForSingleObject(plock->ExclusiveEvent, INFINITE);
    }
}

VOID ReleaseLock(PLOCK_INFO plock)
{
    EnterCriticalSection(&plock->CriticalSection);
    if (plock->NumberOfActive < 0) {
        plock->NumberOfActive++;
        //
        //  Actually only need to set the Shared event if the count was < 0
        //  and since this is a common case we will do this.  Note we
        //  proved in the preamble that this even can only be reset if
        //  NumberOfActive is < 0.
        //
        if (plock->NumberOfActive == 0) {
            plock->ExclusiveOwnerThread = 0;

            if (!plock->SharedEventSet) {
                plock->SharedEventSet = TRUE;
                SetEvent(plock->SharedEvent);
            }
        }
    } else {
        plock->NumberOfActive--;
    }

    if (plock->NumberOfActive == 0 && !plock->ExclusiveEventSet) {
        plock->ExclusiveEventSet = TRUE;
        SetEvent(plock->ExclusiveEvent);
    }
    LeaveCriticalSection(&plock->CriticalSection);
}

VOID DeleteLock(PLOCK_INFO plock)
{
    CloseHandle(plock->SharedEvent);
    CloseHandle(plock->ExclusiveEvent);
    DeleteCriticalSection(&plock->CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\msacmdlg.h ===
/***************************************************************************
 *
 *  msacmdlg.h
 *
 *  Copyright (c) 1991-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  Description:
 *      Audio Compression Manager Common Dialogs Identifiers
 *
 ***************************************************************************/


#define DLG_ACMFORMATCHOOSE_ID              70
#define IDD_ACMFORMATCHOOSE_BTN_HELP        9
#define IDD_ACMFORMATCHOOSE_CMB_CUSTOM      100
#define IDD_ACMFORMATCHOOSE_CMB_FORMATTAG   101
#define IDD_ACMFORMATCHOOSE_CMB_FORMAT      102
#define IDD_ACMFORMATCHOOSE_BTN_SETNAME     103
#define IDD_ACMFORMATCHOOSE_BTN_DELNAME     104


#define DLG_ACMFILTERCHOOSE_ID              71
#define IDD_ACMFILTERCHOOSE_BTN_HELP        9
#define IDD_ACMFILTERCHOOSE_CMB_CUSTOM      100
#define IDD_ACMFILTERCHOOSE_CMB_FILTERTAG   101
#define IDD_ACMFILTERCHOOSE_CMB_FILTER      102
#define IDD_ACMFILTERCHOOSE_BTN_SETNAME     103
#define IDD_ACMFILTERCHOOSE_BTN_DELNAME     104
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
    #define wsprintfA           wsprintf
    #define MessageBoxA         MessageBox
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

#ifndef WIN32
#pragma warning(disable:4704)
#endif

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static char     ach[300];       // debug output (avoid stack overflow)
    int	            id;
#ifndef WIN32
    int             iExitCode;
#endif

    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
#ifndef WIN32
        iExitCode = 0;
        _asm
        {
	        mov	ah, 4Ch
	        mov	al, BYTE PTR iExitCode
	        int     21h
        }
#else
        FatalAppExit(0, TEXT("Good Bye"));
#endif // WIN16
		break;

	case IDRETRY:               // Break into the debugger.
#if DBG
		DebugBreak();
#endif
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#ifndef WIN32
#pragma warning(default:4704)
#endif

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\init.c ===
//==========================================================================;
//
//  init.c
//
//  Copyright (c) 1991-1999 Microsoft Corporation
//
//  Description:
//
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//==========================================================================;

//
//  If we're in Daytona, manually initialize friendly name stuff into
//  HKCU.
//
#if defined(WIN32) && !defined(WIN4)
#define USEINITFRIENDLYNAMES
#endif

#ifdef USEINITFRIENDLYNAMES
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#endif


#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#ifdef WIN4
#include <mmdevldr.h>
#endif
#include <memory.h>
#include <process.h>
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "chooseri.h"
#include "uchelp.h"
#include "pcm.h"
#include "profile.h"

#include "debug.h"



#ifdef WIN4
//
//  Chicago thunk connect function protos
//
#ifdef WIN32
BOOL PASCAL acmt32c_ThunkConnect32(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);
#else
BOOL FAR PASCAL acmt32c_ThunkConnect16(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);
#endif
#endif

//
//
//
//
PACMGARB            gplag = NULL;
TCHAR   CONST       gszNull[]   = TEXT("");

//
//
//
//
#ifdef WIN4
char  BCODE   gmbszMsacm[]	      = "msacm.dll";
char  BCODE   gmbszMsacm32[]	      = "msacm32.dll";
#endif

TCHAR BCODE   gszAllowThunks[]	      = TEXT("AllowThunks");
TCHAR BCODE   gszSecACM[]             = TEXT("MSACM");
TCHAR BCODE   gszKeyNoPCMConverter[]  = TEXT("NoPCMConverter");

TCHAR BCODE   gszSecPriority[]        = TEXT("Priority v4.00");
TCHAR BCODE   gszKeyPriority[]        = TEXT("Priority%u");

#if defined(WIN32) && !defined(UNICODE)
TCHAR BCODE   gszPriorityFormat[]     = TEXT("%u, %ls");
#else
TCHAR BCODE   gszPriorityFormat[]     = TEXT("%u, %s");
#endif

CONST TCHAR   gszIniSystem[]          = TEXT("SYSTEM.INI");
#ifdef WIN32
TCHAR BCODE   gszWinMM[]	      = TEXT("WINMM");
CONST WCHAR   gszSecDriversW[]	      = L"Drivers32";
CONST TCHAR   gszSecDrivers[]	      = DRIVERS_SECTION;
#else
CONST TCHAR   gszSecDrivers[]         = TEXT("Drivers");
CONST TCHAR   gszSecDrivers32[]       = TEXT("Drivers32");
TCHAR BCODE   gszKernel[]             = TEXT("KERNEL");
TCHAR BCODE   gszLoadLibraryEx32W[]   = TEXT("LoadLibraryEx32W");
TCHAR BCODE   gszGetProcAddress32W[]  = TEXT("GetProcAddress32W");
TCHAR BCODE   gszCallproc32W[]        = TEXT("CallProc32W");
TCHAR BCODE   gszFreeLibrary32W[]     = TEXT("FreeLibrary32W");
TCHAR BCODE   gszAcmThunkEntry[]      = TEXT("acmMessage32");
TCHAR BCODE   gszXRegThunkEntry[]     = TEXT("XRegThunkEntry");
TCHAR BCODE   gszMsacm32[]            = TEXT("msacm32.dll");
#endif
TCHAR BCODE   gszTagDrivers[]         = TEXT("msacm.");
#ifdef WIN32
WCHAR BCODE   gszPCMAliasName[]       = L"Internal PCM Converter";
#else
char  BCODE   gszPCMAliasName[]       = "Internal PCM Converter";
#endif

#ifdef USEINITFRIENDLYNAMES
TCHAR BCODE gszFriendlyAudioKey[] = TEXT("Software\\Microsoft\\Multimedia\\Audio");
TCHAR BCODE gszFriendlySystemFormatsValue[] = TEXT("SystemFormats");
TCHAR BCODE gszFriendlyDefaultFormatValue[] = TEXT("DefaultFormat");
TCHAR BCODE gszFriendlyWaveFormatsKey[] = TEXT("WaveFormats");
const PCMWAVEFORMAT gwfFriendlyCDQualityData = {{WAVE_FORMAT_PCM,2,44100,176400,4},16};
const PCMWAVEFORMAT gwfFriendlyRadioQualityData = {{WAVE_FORMAT_PCM,1,22050,22050,1},8};
const PCMWAVEFORMAT gwfFriendlyTelephoneQualityData = {{WAVE_FORMAT_PCM,1,11025,11025,1},8};
#endif // USEINITFRIENDLYNAMES




//--------------------------------------------------------------------------;
//
//  VOID IDriverPrioritiesWriteHadid
//
//  Description:
//      This routine writes an entry for the given driver into the given
//      key.  The section is in gszSecPriority.
//
//  Arguments:
//      HKEY hkey:          An open registry key.
//      LPTSTR szKey:       The key name.
//      HACMDRIVERID hadid: The driver's hadid.
//
//--------------------------------------------------------------------------;

VOID IDriverPrioritiesWriteHadid
(
    HKEY                    hkey,
    LPTSTR                  szKey,
    HACMDRIVERID            hadid
)
{
    PACMDRIVERID            padid;
    BOOL                    fEnabled;
    TCHAR                   ach[ 16 + ACMDRIVERDETAILS_SHORTNAME_CHARS +
                                      ACMDRIVERDETAILS_LONGNAME_CHARS   ];

    ASSERT( NULL != szKey );
    ASSERT( NULL != hadid );

    padid = (PACMDRIVERID)hadid;


    fEnabled = (0 == (padid->fdwDriver & ACMDRIVERID_DRIVERF_DISABLED));

    wsprintf( ach,
	      gszPriorityFormat,
	      fEnabled ? 1 : 0,
	      (LPTSTR)padid->szAlias );

    IRegWriteString( hkey, szKey, ach );
}


//--------------------------------------------------------------------------;
//
//  BOOL IDriverPrioritiesIsMatch
//
//  Description:
//      This routine determines whether a priorities string (read from
//      the INI file, as written by IDriverPrioritiesWriteHadid) matches
//      a currently installed driver.
//
//  Arguments:
//      HACMDRIVERID hadid: Handle to installed driver.
//      LPTSTR szPrioText:  Text read from INI file.
//
//  Return (BOOL):  TRUE if hadid matches szPrioText.
//
//--------------------------------------------------------------------------;

BOOL IDriverPrioritiesIsMatch
(
    HACMDRIVERID            hadid,
    LPTSTR                  szPrioText
)
{
    PACMDRIVERID            padid;
    TCHAR                   ach[ 16 + ACMDRIVERDETAILS_SHORTNAME_CHARS +
                                      ACMDRIVERDETAILS_LONGNAME_CHARS   ];

    ASSERT( NULL != hadid );
    ASSERT( NULL != szPrioText );

    padid           = (PACMDRIVERID)hadid;


    //
    //  Create a priorities string and compare it to the one we read in.
    //
    wsprintf( ach,
              gszPriorityFormat,
              0,                // We ignore this value in the comparison.
              (LPTSTR)padid->szAlias );

    if( ( szPrioText[0]==TEXT('0') || szPrioText[0]==TEXT('1') ) &&
        0 == lstrcmp( &szPrioText[1], &ach[1] ) )
    {
        return TRUE;
    }

    return FALSE;
}


#ifdef USETHUNKLIST

//--------------------------------------------------------------------------;
//
//  VOID IPrioritiesThunklistFree
//
//  Description:
//      This routine frees the elements of the thunklist, including any
//      strings which have been allocated.
//
//  Arguments:
//      PPRIORITIESTHUNKLIST ppt:       The first element to free.
//
//--------------------------------------------------------------------------;

VOID IPrioritiesThunklistFree
(
    PPRIORITIESTHUNKLIST    ppt         // NULL is OK.
)
{
    PPRIORITIESTHUNKLIST    pptKill;

    while( NULL != ppt )
    {
        pptKill     = ppt;
        ppt         = ppt->pptNext;

        if( pptKill->fFakeDriver )
        {
            ASSERT( NULL != pptKill->pszPrioritiesText );
            LocalFree( (HLOCAL)pptKill->pszPrioritiesText );
        }
        LocalFree( (HLOCAL)pptKill );
    }
} // IPrioritiesThunklistFree()


//--------------------------------------------------------------------------;
//
//  VOID IPrioritiesThunklistCreate
//
//  Description:
//      This routine creates the thunklist by reading the [Priority]
//      section, and matching up the entries with installed drivers.  If
//      any entries don't match, then it is assumed to be the entry for
//      a 16-bit driver.
//
//      Note that if we can't allocate memory at any point, we simply
//      return pptRoot with as much of the list as we could allocate.
//
//  Arguments:
//      PACMGARB pag
//      PPRIORITIESTHUNKLIST pptRoot:  Pointer to the dummy root element.
//
//  Return:  None.
//
//--------------------------------------------------------------------------;

VOID IPrioritiesThunklistCreate
(
    PACMGARB                pag,
    PPRIORITIESTHUNKLIST    pptRoot
)
{
    PPRIORITIESTHUNKLIST    ppt;
    UINT                    uPriority;
    DWORD                   fdwEnum;
    TCHAR                   szKey[MAXPNAMELEN];
    TCHAR                   ach[16 + ACMDRIVERDETAILS_SHORTNAME_CHARS + ACMDRIVERDETAILS_LONGNAME_CHARS];
    BOOL                    fFakeDriver;
    HACMDRIVERID            hadid;
    HKEY                    hkeyPriority;

    ASSERT( NULL != pptRoot );
    ASSERT( NULL == pptRoot->pptNext );  // We're gonna over-write this!


    ppt     = pptRoot;
    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;

    hkeyPriority = IRegOpenKeyAcm( gszSecPriority );

    //
    //  Loop through the PriorityX values.
    //
    for( uPriority=1; ; uPriority++ )
    {
        wsprintf(szKey, gszKeyPriority, uPriority);
        if( !IRegReadString(hkeyPriority, szKey, ach, SIZEOF(ach) ) )
        {
            //
            //  No more values - time to quit.
            //

            break;
        }

        //
        //  Determine whether the value corresponds to an installed driver.
        //
        fFakeDriver = TRUE;
        hadid = NULL;

        while (!IDriverGetNext(pag, &hadid, hadid, fdwEnum))
        {
            if( IDriverPrioritiesIsMatch( hadid, ach ) )
            {
                fFakeDriver = FALSE;
                break;
            }
        }


        //
        //  Create a new entry in the thunklist for this driver.  Save the
        //  string if we didn't match it with an installed driver.
        //
        ASSERT( NULL == ppt->pptNext );
        ppt->pptNext = (PPRIORITIESTHUNKLIST)LocalAlloc( LPTR,
                                        sizeof(PRIORITIESTHUNKLIST) );
        if( NULL == ppt->pptNext )
        {
            IRegCloseKey( hkeyPriority );
            return;
        }

        ppt->pptNext->pptNext       = NULL;
        ppt->pptNext->fFakeDriver   = fFakeDriver;

        if( !fFakeDriver )
        {
            ppt->pptNext->hadid     = hadid;
        }
        else
        {
            ppt->pptNext->pszPrioritiesText = (LPTSTR)LocalAlloc( LPTR,
                                        (1+lstrlen(ach)) * sizeof(TCHAR) );
            if( NULL == ppt->pptNext->pszPrioritiesText )
            {
                //
                //  Remove the new entry, exit.
                //
                LocalFree( (HLOCAL)ppt->pptNext );
                ppt->pptNext = NULL;
                IRegCloseKey( hkeyPriority );
                return;
            }

            lstrcpy( ppt->pptNext->pszPrioritiesText, ach );
        }


        //
        //  Advance ppt to the end of the list.
        //
        ppt = ppt->pptNext;
    }

    IRegCloseKey( hkeyPriority );

} // IPrioritiesThunklistCreate()


//--------------------------------------------------------------------------;
//
//  VOID IPrioritiesThunklistRemoveHadid
//
//  Description:
//      This routine removes an installed driver from the priorities
//      thunklist.  If an entry does not exist with the specified hadid,
//      the thunklist remains unchanged.
//
//  Arguments:
//      PPRIORITIESTHUNKLIST pptRoot:   The root of the list.
//      HACMDRIVERID hadid:             The hadid of the driver to remove.
//
//  Return:
//
//--------------------------------------------------------------------------;

VOID IPrioritiesThunklistRemoveHadid
(
    PPRIORITIESTHUNKLIST    pptRoot,
    HACMDRIVERID            hadid
)
{
    PPRIORITIESTHUNKLIST    ppt;
    PPRIORITIESTHUNKLIST    pptRemove;

    ASSERT( NULL != pptRoot );
    ASSERT( NULL != hadid );


    //
    //  Find the right driver.
    //
    ppt = pptRoot;
    while( NULL != ppt->pptNext )
    {
        if( hadid == ppt->pptNext->hadid )
            break;
        ppt = ppt->pptNext;
    }

    if( NULL != ppt->pptNext )
    {
        //
        //  We found it.
        //
        pptRemove       = ppt->pptNext;
        ppt->pptNext    = pptRemove->pptNext;

        ASSERT( NULL != pptRemove );
        LocalFree( (HLOCAL)pptRemove );
    }
}


//--------------------------------------------------------------------------;
//
//  HACMDRIVERID IPrioritiesThunklistGetNextHadid
//
//  Description:
//      This routine returns the next hadid in the thunklist (skipping all
//      fake drivers), or NULL if we get to the end of the list without
//      finding a real driver.
//
//  Arguments:
//      PPRIORITIESTHUNKLIST pptRoot:   The root of the list.
//
//  Return:
//
//--------------------------------------------------------------------------;

HACMDRIVERID IPrioritiesThunklistGetNextHadid
(
    PPRIORITIESTHUNKLIST    pptRoot
)
{
    HACMDRIVERID            hadid = NULL;

    ASSERT( NULL != pptRoot );


    while( NULL != pptRoot->pptNext )
    {
        pptRoot = pptRoot->pptNext;
        if( !pptRoot->fFakeDriver )
            return pptRoot->hadid;
    }

    //
    //  We didn't find a real driver.
    //
    return NULL;
}


//--------------------------------------------------------------------------;
//
//  BOOL IDriverPrioritiesSave
//
//  Description:
//
//      This routine saves the priorities by comparing the list of
//      installed drivers to the list of priorities currently written
//      out.  The two lists are then merged according to the following
//      algorithm.
//
//          List1 = the current list of priorities - may include some drivers
//                      which aren't installed, ie. 16-bit drivers.
//          List2 = the list of currently-installed global drivers.
//
//      Algorithm:  repeat the following until List1 and List2 are empty:
//
//          1.  If *p1 is an installed driver and *p2 is the same driver,
//                  then write out the priority and advance p1 and p2.
//          2.  If *p1 is an installed driver and *p2 is a different driver,
//                  then write out *p2, remove *p2 from List1 (if it's
//                  there) so that we won't be tempted to write it later,
//                  and advance p2.
//          3.  If *p1 is a fake driver and the next real driver after
//                  *p1 is the same as *p2, then write out *p1 and advance p1.
//          4.  If *p1 is a fake driver and the next real driver after
//                  *p1 is different from *p2, then write out *p2 and
//                  advance p2.
//
//  Arguments:
//      PACMGARB pag:
//
//  Return (BOOL):
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IDriverPrioritiesSave
(
    PACMGARB pag
)
{
    PRIORITIESTHUNKLIST     ptRoot;
    PPRIORITIESTHUNKLIST    ppt;
    TCHAR                   szKey[MAXPNAMELEN];
    UINT                    uPriority;
    HACMDRIVERID            hadid;
    DWORD                   fdwEnum;
    HKEY                    hkeyPriority;

    DPF(1, "IDriverPrioritiesSave: saving priorities...");

    hkeyPriority = IRegOpenKeyAcm( gszSecPriority );

    if( NULL == hkeyPriority )
    {
        DPF(1,"IDriverPrioritiesSave: Priorities hkey is NULL - can't save priorities.");
        return FALSE;
    }


    ptRoot.pptNext  = NULL;
    fdwEnum         = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;


    //
    //  Create a thunklist out of the old priorities.
    //
    IPrioritiesThunklistCreate( pag, &ptRoot );


    //
    //  Initialize the two lists: ppt and hadid.
    //
    ppt = ptRoot.pptNext;
    IDriverGetNext( pag, &hadid, NULL, fdwEnum );

    if( NULL == hadid )
        DPF(1,"IDriverPrioritiesSave:  No drivers installed?!");


    //
    //  Merge the lists.  Each iteration writes a single PriorityX value.
    //
    for( uPriority=1; ; uPriority++ )
    {
        //
        //  Ending condition:  both hadid and ppt are NULL.
        //
        if( NULL == ppt  &&  NULL == hadid )
            break;

        //
        //  Generate the "PriorityX" string.
        //
        wsprintf(szKey, gszKeyPriority, uPriority);


        //
        //  Figure out which entry to write out next.
        //
        if( NULL == ppt  ||  !ppt->fFakeDriver )
        {
            ASSERT( NULL != hadid );
            IDriverPrioritiesWriteHadid( hkeyPriority, szKey, hadid );

            //
            //  Advance the list pointers.
            //
            if( NULL != ppt )
            {
                if( hadid == ppt->hadid )
                {
                    ppt = ppt->pptNext;
                }
                else
                {
                    IPrioritiesThunklistRemoveHadid( ppt, hadid );
                }
            }
            IDriverGetNext( pag, &hadid, hadid, fdwEnum );
        }
        else
        {
            if( NULL != hadid  &&
                hadid != IPrioritiesThunklistGetNextHadid( ppt ) )
            {
                IDriverPrioritiesWriteHadid( hkeyPriority, szKey, hadid );
                IPrioritiesThunklistRemoveHadid( ppt, hadid );
                IDriverGetNext( pag, &hadid, hadid, fdwEnum );
            }
            else
            {
                //
                //  Write out the thunklist string.
                //
                ASSERT( NULL != ppt->pszPrioritiesText );
                IRegWriteString( hkeyPriority,
                                    szKey,
                                    ppt->pszPrioritiesText );
                ppt = ppt->pptNext;
            }
        }
    }


    //
    //  If there are any "PriorityX" strings hanging around from a
    //  previous save, delete them.
    //
    for( ; ; uPriority++ )
    {
        //
        //  If we can open the value, then delete it and continue on
        //  to the next value.  If we can't open it, then we assume
        //  that we have deleted them all and we exit the loop.
        //
        wsprintf(szKey, gszKeyPriority, uPriority);
        if( !IRegValueExists( hkeyPriority, szKey ) )
        {
            break;
        }

        XRegDeleteValue( hkeyPriority, szKey );
    }

    IRegCloseKey( hkeyPriority );


    //
    //  Free the thunklist that we allocated.
    //
    IPrioritiesThunklistFree( ptRoot.pptNext );

    return TRUE;
} // IDriverPrioritiesSave()



#else // !USETHUNKLIST


//--------------------------------------------------------------------------;
//
//  BOOL IDriverPrioritiesSave
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//  Return (BOOL):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IDriverPrioritiesSave
(
    PACMGARB pag
)
{
    TCHAR               szKey[MAXPNAMELEN];
    UINT                uPriority;
    HACMDRIVERID        hadid;
    DWORD               fdwEnum;
    HKEY                hkeyPriority;

    DPF(1, "IDriverPrioritiesSave: saving priorities...");

    hkeyPriority   = IRegOpenKeyAcm( gszSecPriority );

    if( NULL == hkeyPriority )
    {
        DPF(1,"IDriverPrioritiesSave: Priorities hkey is NULL - can't save priorities.");
        return FALSE;
    }


    uPriority = 1;

    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;
    hadid     = NULL;
    while (!IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        //
        //  We should always have padid->uPriority correctly set.  Let's
        //  just check that we do.  If we don't, then there is someplace
        //  where we shoulda called IDriverRefreshPriority but didn't.
        //
        ASSERT( uPriority == ((PACMDRIVERID)hadid)->uPriority );

        wsprintf(szKey, gszKeyPriority, uPriority);
        IDriverPrioritiesWriteHadid( hkeyPriority, szKey, hadid );

        uPriority++;
    }


    //
    //  If there are any "PriorityX" strings hanging around from a
    //  previous save, delete them.
    //
    for( ; ; uPriority++ )
    {
        //
        //  If we can open the value, then delete it and continue on
        //  to the next value.  If we can't open it, then we assume
        //  that we have deleted them all and we exit the loop.
        //
        wsprintf(szKey, gszKeyPriority, uPriority);
        if( !IRegValueExists( hkeyPriority, szKey ) )
        {
            break;
        }

        XRegDeleteValue( hkeyPriority, szKey );
    }

    IRegCloseKey( hkeyPriority );

    return (TRUE);
} // IDriverPrioritiesSave()


#endif // !USETHUNKLIST



//--------------------------------------------------------------------------;
//
//  BOOL IDriverPrioritiesRestore
//
//  Description:
//
//
//  Arguments:
//      PACMGARB pag:
//
//  Return (BOOL):  If TRUE, then the priorities actually changed.
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//  Note:  This routine is NOT re-entrant.  We rely on the calling routine
//          to surround us with a critical section.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IDriverPrioritiesRestore
(
    PACMGARB pag
)
{
    TCHAR               ach[16 + ACMDRIVERDETAILS_SHORTNAME_CHARS + ACMDRIVERDETAILS_LONGNAME_CHARS];
    MMRESULT            mmr;
    TCHAR               szKey[MAXPNAMELEN];
    UINT                uPriority;
    UINT                u;
    BOOL                fEnabled;
    HACMDRIVERID        hadid;
    PACMDRIVERID        padid;
    DWORD               fdwEnum;
    DWORD               fdwPriority;
    HKEY                hkeyPriority;

    BOOL                fReturn = FALSE;


    DPF(1, "IDriverPrioritiesRestore: restoring priorities...");

    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;

    hkeyPriority = IRegOpenKeyAcm( gszSecPriority );
    uPriority = 1;
    for (u = 1; ; u++)
    {
        wsprintf(szKey, gszKeyPriority, u);

        if( !IRegReadString( hkeyPriority, szKey, ach, SIZEOF(ach) ) )
        {
            //
            //  No more values - time to quit.
            //
            break;
        }


        hadid = NULL;
        while (!IDriverGetNext(pag, &hadid, hadid, fdwEnum))
        {
            if( IDriverPrioritiesIsMatch( hadid, ach ) )
            {
                //
                //  We found a match - set the priority.
                //
                fEnabled    = ('1' == ach[0]);
                fdwPriority = fEnabled ? ACM_DRIVERPRIORITYF_ENABLE :
                                         ACM_DRIVERPRIORITYF_DISABLE;

                ASSERT( NULL != hadid );
                padid = (PACMDRIVERID)hadid;
                if( uPriority != padid->uPriority ) {
                    fReturn = TRUE;                     // Changed one!
                }

                //
                //  Note:  This call is NOT re-entrant.  We rely on having
                //  this whole routine surrounded by a critical section!
                //
                mmr = IDriverPriority( pag,
                                    (PACMDRIVERID)hadid,
                                    (DWORD)uPriority,
                                    fdwPriority );
                if (MMSYSERR_NOERROR != mmr)
                {
                    DPF(0, "!IDriverPrioritiesRestore: IDriverPriority(%u) failed! mmr=%u", uPriority, mmr);
                    continue;
                }

                uPriority++;
                break;
            }
        }
    }

    IRegCloseKey( hkeyPriority );

    //
    //  Update the priority value themselves; the previous code only
    //  re-arranged the drivers in the list.
    //
    IDriverRefreshPriority( pag );

    return fReturn;
} // IDriverPrioritiesRestore()


//--------------------------------------------------------------------------;
//
//  VOID acmFindDrivers
//
//  Description:
//
//
//  Arguments:
//	PACMGARB    pag:
//      LPTSTR	    pszSection: Section (drivers)
//
//  Return nothing:
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;
MMRESULT FNLOCAL acmFindDrivers
(
    PACMGARB pag,
    LPCTSTR  pszSection
)
{
    UINT            cchBuffer;
    HACMDRIVERID    hadid;
    UINT            cbBuffer;
    LPTSTR          pszBuf;
    LPTSTR	    pszBufOrig;
    TCHAR           szValue[2];

    //
    //  read all the keys. from [Drivers] (or [Drivers32] for NT)
    //
    cbBuffer = 256 * sizeof(TCHAR);
    for (;;)
    {
        //
        //  don't use realloc because handling error case is too much
        //  code.. besides, for small objects it's really no faster
        //
        pszBufOrig = pszBuf = (LPTSTR)GlobalAlloc(GMEM_FIXED, cbBuffer);
        if (NULL == pszBuf)
            return (MMSYSERR_NOMEM);

        //
        //
        //
        pszBuf[0] = '\0';
        cchBuffer = (UINT)GetPrivateProfileString(pszSection,
                                                  NULL,
                                                  gszNull,
                                                  pszBuf,
                                                  cbBuffer / sizeof(TCHAR),
                                                  gszIniSystem);
        if (cchBuffer < ((cbBuffer / sizeof(TCHAR)) - 5))
            break;

        DPF(3, "acmBootDrivers: increase buffer profile buffer.");

        GlobalFree(pszBufOrig);
        pszBufOrig = pszBuf = NULL;


        //
        //  if cannot fit drivers section in 32k, then something is horked
        //  with the section... so let's bail.
        //
        if (cbBuffer >= 0x8000)
            return (MMSYSERR_NOMEM);

        cbBuffer *= 2;
    }

    //
    //  look for any 'msacm.xxxx' keys
    //
    if ('\0' != *pszBuf)
    {
#ifdef WIN32
        CharLowerBuff(pszBuf, cchBuffer);
#else
        AnsiLowerBuff(pszBuf, cchBuffer);
#endif
        for ( ; '\0' != *pszBuf; pszBuf += lstrlen(pszBuf) + 1)
        {
	    // check for "msacm."
            if (_fmemcmp(pszBuf, gszTagDrivers, sizeof(gszTagDrivers) - sizeof(TCHAR)))
                continue;

	    // skip dummy driver lines (value starts with '*')
	    GetPrivateProfileString(pszSection, pszBuf, gszNull, szValue, sizeof(szValue)/sizeof(szValue[0]), gszIniSystem);
	    if (TEXT('*') == szValue[0]) continue;

            //
            //  this key is for the ACM
            //
            IDriverAdd(pag,
		       &hadid,
                       NULL,
                       (LPARAM)(LPTSTR)pszBuf,
                       0L,
                       ACM_DRIVERADDF_NAME | ACM_DRIVERADDF_GLOBAL);
        }
    }

    GlobalFree(pszBufOrig);

    return MMSYSERR_NOERROR;

} // acmFindDrivers

#if !defined(WIN32)
//--------------------------------------------------------------------------;
//
//  BOOL acmThunkTerminate
//
//  Description:
//	Thunk termination under NT WOW or Chicago
//
//  Arguments:
//	HINSTANCE hinst:
//	DWORD dwReason:
//
//  Return (BOOL):
//
//  History:
//
//--------------------------------------------------------------------------;
BOOL FNLOCAL acmThunkTerminate(HINSTANCE hinst, DWORD dwReason)
{
    BOOL    f = TRUE;

#ifdef WIN4
    //
    //	Do final thunk disconnect after 16-bit msacm termination.
    //
    f = (acmt32c_ThunkConnect16(gmbszMsacm, gmbszMsacm32, hinst, dwReason));

    if (f)
	DPF(1, "acmt32c_ThunkConnect16 disconnect successful");
    else
	DPF(1, "acmt32c_ThunkConnect16 disconnect failure");
#endif

    return (f);
}

//--------------------------------------------------------------------------;
//
//  BOOL acmThunkInit
//
//  Description:
//	Thunk initialization under NT WOW or Chicago
//
//  Arguments:
//	PACMGARB pag:
//	HINSTANCE hinst:
//	DWORD dwReason:
//
//  Return (BOOL):
//
//  History:
//
//--------------------------------------------------------------------------;
BOOL FNLOCAL acmThunkInit
(
    PACMGARB	pag,
    HINSTANCE	hinst,
    DWORD	dwReason
)
{
#ifdef WIN4
    BOOL    f;

    //
    //	Do chicago thunk connect
    //
    f = (0 != acmt32c_ThunkConnect16(gmbszMsacm, gmbszMsacm32, hinst, dwReason));

    if (f)
	DPF(1, "acmt32c_ThunkConnect16 connect successful");
    else
	DPF(1, "acmt32c_ThunkConnect16 connect failure");

    return(f);

#else
    HMODULE   hmodKernel;
    DWORD     (FAR PASCAL *lpfnLoadLibraryEx32W)(LPCSTR, DWORD, DWORD);
    LPVOID    (FAR PASCAL *lpfnGetProcAddress32W)(DWORD, LPCSTR);

    //
    //  Check if we're WOW
    //

    if (!(GetWinFlags() & WF_WINNT)) {
        return FALSE;
    }

    //
    //  See if we can find the thunking routine entry points in KERNEL
    //

    hmodKernel = GetModuleHandle(gszKernel);

    if (hmodKernel == NULL)
    {
        return FALSE;   // !!!!
    }

    *(FARPROC *)&lpfnLoadLibraryEx32W =
        GetProcAddress(hmodKernel, gszLoadLibraryEx32W);

    if (lpfnLoadLibraryEx32W == NULL)
    {
        return FALSE;
    }

    *(FARPROC *)&lpfnGetProcAddress32W = GetProcAddress(hmodKernel, gszGetProcAddress32W);

    if (lpfnGetProcAddress32W == NULL)
    {
        return FALSE;
    }

    *(FARPROC *)&pag->lpfnCallproc32W_6 = GetProcAddress(hmodKernel, gszCallproc32W);

    if (pag->lpfnCallproc32W_6 == NULL)
    {
        return FALSE;
    }

    *(FARPROC *)&pag->lpfnCallproc32W_9 = GetProcAddress(hmodKernel, gszCallproc32W);

    if (pag->lpfnCallproc32W_9 == NULL)
    {
        return FALSE;
    }

    //
    //  See if we can get a pointer to our thunking entry points
    //

    pag->dwMsacm32Handle = (*lpfnLoadLibraryEx32W)(gszMsacm32, 0L, 0L);

    if (pag->dwMsacm32Handle == 0)
    {
        return FALSE;
    }

    pag->lpvAcmThunkEntry = (*lpfnGetProcAddress32W)(pag->dwMsacm32Handle, gszAcmThunkEntry);

    if (pag->lpvAcmThunkEntry == NULL)
    {
        // acmFreeLibrary32();
        return FALSE;
    }

    pag->lpvXRegThunkEntry = (*lpfnGetProcAddress32W)(pag->dwMsacm32Handle, gszXRegThunkEntry);

    if (pag->lpvXRegThunkEntry == NULL)
    {
        // acmFreeLibrary32();
	ASSERT( FALSE );
        return FALSE;
    }

    return TRUE;
#endif
}
#endif // !WIN32


//==========================================================================;
//
//  Driver boot routines.  There are three type of drivers we need to boot.
//
//	acmBootPnpDrivers:	Called to boot pnp drivers.  Doesn't do
//				anything in 16-bit compiles.
//
//	acmBoot32BitDrivers:	Called by 16-bit ACM to boot all the
//				32-bit drivers in the 32-bit ACM.
//
//	acmBootDrivers:		Called by all compilations of the ACM
//				to boot non-pnp native bitness drivers.
//
//==========================================================================;


//--------------------------------------------------------------------------;
//
//  MMRESULT acmBootPnpDrivers
//
//  Description:
//	[re]boots Chicago plug and play drivers.
//	Parses the SYSTEM\CurrentControlSet\Control\MediaResources\acm
//	registry key to see if there are any Pnp drivers to add or remove.
//
//  Arguments:
//      PACMGARB pag:
//	    Pointer to the ACMGARB structure for this process.
//
//  Return (MMRESULT):
//
//  History:
//      06/24/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL acmBootPnpDrivers
(
    PACMGARB pag
)
{
#ifdef WIN32
    LONG	    lr;
    HKEY	    hkeyAcm;
    TCHAR	    achDriverKey[MAX_DRIVER_NAME_CHARS];
    TCHAR	    szAlias[MAX_DRIVER_NAME_CHARS];
    DWORD	    cchDriverKey;
    HACMDRIVERID    hadid;
    HACMDRIVERID    hadidPrev;
    PACMDRIVERID    padid;
    DWORD	    fdwEnum;
    UINT	    i;
    MMRESULT	    mmr;
	
    BOOL	    fSomethingChanged;

    DPF(0, "acmBootPnpDrivers: begin");

    //
    //	This flag indicates whether we have removed or added a driver.  After
    //	doing any adds or removes, we check this flag to determine whether
    //	we should do IDriverBroadcastNotify.
    //
    fSomethingChanged = FALSE;

    //
    //	Open the SYSTEM\CurrentControlSet\Control\MediaResources\acm key
    //
    //
    lr = XRegOpenKeyEx(HKEY_LOCAL_MACHINE,
		      gszKeyDrivers,
		      0L,
		      KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
		      &hkeyAcm);

    if (ERROR_SUCCESS != lr)
    {
	//
	//  If we can't open the registry, I guess we better scrap any
	//  pnp drivers that might be around.  Flag this by setting
	//  hkeyAcm = NULL;
	//
	DPF(0, "acmBootPnpDrivers: could not open MediaResources\\acm key");
	hkeyAcm = NULL;
    }


    //
    //	--== Remove drivers that have disappeared ==--
    //

    //
    //	Walk the driver list and make sure any pnp drivers in the list
    //	are still in the registry.  If not in the registry then we need
    //	to remove the driver from the list.
    //
    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_REMOVED;
    hadidPrev = NULL;
	
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadidPrev, fdwEnum))
    {
	HKEY		hkeyDriver;

	padid = (PACMDRIVERID)hadid;
	if (ACM_DRIVERADDF_PNP & padid->fdwAdd)
	{
	    //
	    //  This is a Pnp driver, make sure the alias is still in
	    //  the registry.
	    //
#ifdef UNICODE
	    lstrcpy(szAlias, padid->szAlias);
#else
	    Iwcstombs(szAlias, padid->szAlias, SIZEOF(szAlias));
#endif
	    DPF(2, "acmBootPnpDrivers: found pnp driver %s in driver list", szAlias);

	    if ( (padid->fRemove) ||
		 (NULL == hkeyAcm) ||
		 (ERROR_SUCCESS != XRegOpenKeyEx(hkeyAcm, szAlias, 0L, KEY_QUERY_VALUE, &hkeyDriver)) )
	    {
		//
		//  Couldn't open the registry key for this pnp driver (or
		//  it was already flagged to be removed). Let's try to
		//  remove it...
		//
		DPF(1, "acmBootPnpDrivers: removing pnp driver %s", szAlias);
		mmr = IDriverRemove(hadid, 0L);
		if (MMSYSERR_NOERROR == mmr)
		{
		    //
		    //
		    //
		    fSomethingChanged = fSomethingChanged ||
					(0 == (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));
		
		    //
		    //  Since we've removed hadid, let's continue on to get
		    //  the next hadid after the same hadidPrev.
		    //
		    continue;
		}

		//
		//  We couldn't remove the driver, so let's flag it to
		//  be removed next chance.
		//
		padid->fRemove = TRUE;

		//
		// Backup so we try again on next API call
		//
		pag->dwPnpLastChangeNotify--;
	    }

	    if (FALSE == padid->fRemove)
	    {
		//
		//  We must have opened the key.  Confusing, but that's the
		//  way it is.
		//
		XRegCloseKey(hkeyDriver);
	    }
	
	}
	
	hadidPrev = hadid;
    }


    //
    //	--== Add any new drivers that have arrived ==--
    //

    //
    //	Enumerate all keys and make sure all the pnp drivers in the registry
    //	are in the driver list.  If not in the driver list, then we need to
    //	add the driver to the list.
    //
    for (i=0; ; i++)
    {
	HKEY	hkeyDriver;
	
	cchDriverKey = SIZEOF(achDriverKey);

	lr = XRegEnumKeyEx(hkeyAcm,
			  i,
			  achDriverKey,
			  &cchDriverKey,
			  NULL,
			  NULL,
			  NULL,
			  NULL);

	if (ERROR_SUCCESS != lr)
	{
	    //
	    //	Couldn't open ...\MediaResources\acm, bail out
	    //
	    break;
	}

	lr = XRegOpenKeyEx(hkeyAcm, achDriverKey, 0L, KEY_QUERY_VALUE, &hkeyDriver);
	if (ERROR_SUCCESS == lr)
	{
	    lr = XRegQueryValueEx(hkeyDriver, (LPTSTR)gszDevNode, NULL, NULL, NULL, NULL);
	    XRegCloseKey(hkeyDriver);
	}

	if (ERROR_SUCCESS != lr) {
	    continue;
	}

	DPF(2, "acmBootPnpDrivers: found driver %s in registry", achDriverKey);

	//
	//  We use the subkey name as the alias for pnp drivers.  Attempt to
	//  add this driver.
	//
	mmr = IDriverAdd(pag,
			 &hadid,
			 NULL,
			 (LPARAM)(LPTSTR)achDriverKey,
			 0L,
			 ACM_DRIVERADDF_PNP | ACM_DRIVERADDF_NAME | ACM_DRIVERADDF_GLOBAL);
	if (MMSYSERR_NOERROR == mmr)
	{
	    fSomethingChanged = TRUE;
	}
    }
			
    //
    //	--==  ==--
    //
    XRegCloseKey(hkeyAcm);

    //
    //	--== Change broadcast ==--
    //
    if( fSomethingChanged )
    {
	if ( IDriverPrioritiesRestore( pag ) )
	{
	    if( !IDriverLockPriority( pag,
				      GetCurrentTask(),
				      ACMPRIOLOCK_ISLOCKED ) )
	    {
		IDriverBroadcastNotify( pag );
	    }
	}
    }

    DPF(0, "acmBootPnpDrivers: end");

#endif	// WIN32

    //
    //	--== Outta here ==--
    //
    return MMSYSERR_NOERROR;
}

#ifndef WIN32
//--------------------------------------------------------------------------;
//
//  MMRESULT acmBoot32BitDrivers
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//  Return (MMRESULT):
//
//  History:
//      06/26/94    fdy	    [frankye]
//
//  NOTE:  This code assumes that there is a critical section around
//          this routine!  Since it plays with the driver list, it is not
//          re-entrant.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL acmBoot32BitDrivers
(
    PACMGARB    pag
)
{
    HACMDRIVERID    hadid;
    HACMDRIVERID    hadidPrev;
    PACMDRIVERID    padid;
    DWORD	    hadid32;
    DWORD	    fdwEnum;
    MMRESULT	    mmr;

    BOOL	    fSomethingChanged;


    if (!pag->fWOW)
    {
	return MMSYSERR_NOERROR;
    }

    //
    //	This flag indicates whether we have removed or added a driver.  After
    //	doing any adds or removes, we check this flag to determine whether
    //	we should do IDriverBroadcastNotify.
    //
    fSomethingChanged = FALSE;

    //
    //	--== Remove drivers that have disappeared ==--
    //

    //
    //	Walk the driver list and make sure any 32-bit drivers in the list
    //	are still in the 32-bit ACM.  If not in the 32-bit ACM then we need
    //	to remove the driver from the list.
    //
    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_REMOVED;
    hadidPrev = NULL;

    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadidPrev, fdwEnum))
    {
	TCHAR		szAlias[MAX_DRIVER_NAME_CHARS];
	ACMDRIVERPROC	fnDriverProc;
	DWORD		dnDevNode;
	DWORD		fdwAdd32;
	DWORD		fdwAddType;

	padid = (PACMDRIVERID)hadid;
	if (ACM_DRIVERADDF_32BIT & padid->fdwAdd)
	{
	    //
	    //  This is a 32-bit driver, make sure the hadid32 is still
	    //  valid in our 32-bit partner.
	    //
	    fdwAddType = ACM_DRIVERADDF_TYPEMASK & padid->fdwAdd;
	    if (ACM_DRIVERADDF_FUNCTION == fdwAddType)
	    {
		DPF(2, "acmBoot32BitDrivers: found 32-bit driver function %08lx in list", padid->fnDriverProc);
	    }
	    else
	    {
		DPF(2, "acmBoot32BDrivers: found 32-bit driver name %s in list", (LPCTSTR)padid->szAlias);
	    }

	    if ( (padid->fRemove) ||
		 (MMSYSERR_NOERROR != IDriverGetInfo32(pag, padid->hadid32, szAlias, &fnDriverProc, &dnDevNode, &fdwAdd32)) ||
		 (fdwAddType != (ACM_DRIVERADDF_TYPEMASK & fdwAdd32)) ||
		 (dnDevNode  != padid->dnDevNode) ||
		 ( (ACM_DRIVERADDF_FUNCTION == fdwAddType) &&
		   (padid->fnDriverProc != fnDriverProc) ) ||
		 ( (ACM_DRIVERADDF_NAME == fdwAddType) &&
		   (lstrcmp(padid->szAlias, szAlias)) ) )
	    {
		//
		//  Let's try to remove it...
		//
		DPF(1, "acmBoot32BitDrivers: removing 32-bit driver.");
		
		mmr = IDriverRemove(hadid, 0L);
		if (MMSYSERR_NOERROR == mmr)
		{
		    //
		    //
		    //
		    fSomethingChanged = fSomethingChanged ||
					(0 == (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));
		
		    //
		    //  Since we've removed hadid, let's continue on to get
		    //  the next hadid after the same hadidPrev.
		    //
		    continue;
		}

		//
		//  We couldn't remove the driver, so let's flag it to
		//  be removed next chance.
		//
		padid->fRemove = TRUE;

		//
		// Backup so we try again on next API call
		//
		pag->dw32BitLastChangeNotify--;
	    }

	}

	hadidPrev = hadid;

    }


    //
    //	--== Add any new drivers that have arrived ==--
    //

    //
    //	Enumerate and add all 32-bit drivers.
    //
    fdwEnum = ACM_DRIVERENUMF_DISABLED;
    hadid32 = NULL;

    while (MMSYSERR_NOERROR == IDriverGetNext32(pag, &hadid32, hadid32, fdwEnum))
    {
	DPF(2, "acmBoot32BitDrivers: IDriverAdd(hadid32=%08lx)", hadid32);

	mmr = IDriverAdd(pag,
			 &hadid,
			 NULL,
			 (LPARAM)hadid32,
			 0L,
			 ACM_DRIVERADDF_32BIT);

	padid = (PACMDRIVERID)hadid;

	if (MMSYSERR_NOERROR == mmr)
	{
	    fSomethingChanged = fSomethingChanged ||
				(0 == (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));
	}
		
    }


    //
    //	--== Change broadcast ==--
    //
    if( fSomethingChanged )
    {
	if ( IDriverPrioritiesRestore( pag ) )
	{
	    if( !IDriverLockPriority( pag,
				      GetCurrentTask(),
				      ACMPRIOLOCK_ISLOCKED ) )
	    {
		IDriverBroadcastNotify( pag );
	    }
	}
    }


    //
    //	--== Outta here ==--
    //
    return MMSYSERR_NOERROR;

}
#endif // !WIN32


//--------------------------------------------------------------------------;
//
//  MMRESULT acmBootDrivers
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//  Return (MMRESULT):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//  NOTE:  This code assumes that there is a critical section around
//          this routine!  Since it plays with the driver list, it is not
//          re-entrant.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL acmBootDrivers
(
    PACMGARB    pag
)
{
    MMRESULT	mmr;

    DPF(1, "acmBootDrivers: begin");


    //
    //  Pull out the drivers
    //
    mmr = acmFindDrivers(pag, gszSecDrivers);

    if (mmr != MMSYSERR_NOERROR)
    {
        return mmr;
    }

    //
    //	-= Load PCM converter =-
    //

    //
    //
    //	16-bit Chicago:
    //	    We don't even compile in the 16-bit PCM converter, so we don't
    //	    try to load it.
    //
    //	16-bit Daytona:
    //	    if thunks aren't working, then we try to load the 16-bit PCM
    //	    converter.
    //
    //	32-bit Chicago and Daytona:
    //	    Load it.
    //
#if defined(WIN32) || defined(NTWOW)
    {
        BOOL            fLoadPCM;
        HKEY            hkeyACM;

        hkeyACM = IRegOpenKeyAcm(gszSecACM);
        fLoadPCM = (FALSE == (BOOL)IRegReadDwordDefault( hkeyACM, gszKeyNoPCMConverter, FALSE ) );
        IRegCloseKey(hkeyACM);

#if !defined(WIN32) && defined(NTWOW)
	fLoadPCM = ( fLoadPCM && !pag->fWOW );
#endif

	if( fLoadPCM )
	{
	    HACMDRIVERID hadid;   // Dummy - return value not used

	    //
	    //  load the 'internal' PCM converter
	    //
	    mmr = IDriverAdd(pag,
		       &hadid,
		       pag->hinst,
		       (LPARAM)pcmDriverProc,
		       0L,
		       ACM_DRIVERADDF_FUNCTION | ACM_DRIVERADDF_GLOBAL);

            if( MMSYSERR_NOERROR == mmr )
            {
                //
                //  This is a bit of a hack - manually set the PCM
                //  converter's alias name.  If we don't do this, then the
                //  priorities won't get saved correctly because the alias
                //  name will be different for the 16 and 32-bit ACMs.
                //
                PACMDRIVERID padid = (PACMDRIVERID)hadid;

                ASSERT( NULL != padid );
#ifdef WIN32
                lstrcpyW( padid->szAlias, gszPCMAliasName );
#else
                lstrcpy( padid->szAlias, gszPCMAliasName );
#endif
            }
	}
    }
#endif	// WIN32 || NTWOW


    //
    //  Set the driver priorities according to the INI file.
    //
    IDriverPrioritiesRestore(pag);

    DPF(1, "acmBootDrivers: end");

    return (MMSYSERR_NOERROR);
} // acmBootDrivers()


//--------------------------------------------------------------------------;
//
//  BOOL acmTerminate
//
//  Description:
//      Termination routine for ACM interface
//
//  Arguments:
//      HINSTANCE hinst:
//	DWORD dwReason:
//
//  Return (BOOL):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL acmTerminate
(
    HINSTANCE               hinst,
    DWORD		    dwReason
)
{
    PACMDRIVERID        padid;
    PACMGARB		pag;
    UINT                uGonzo;

    DPF(1, "acmTerminate: termination begin");
    DPF(5, "!*** break for debugging ***");


    //
    //
    //
    pag = pagFind();
    if (NULL == pag)
    {
	DPF(1, "acmTerminate: NULL pag!!!");
	return (FALSE);
    }

    if (--pag->cUsage > 0)
    {
#if !defined(WIN32) && defined(WIN4)
	//
	//  On Chicago, still call thunk terminate code even when usage > 0.
	//
	acmThunkTerminate(hinst, dwReason);
#endif
	return (TRUE);
    }

    //
    //	If we've booted the drivers...
    //
    if (pag->fDriversBooted)
    {

#ifndef WIN32
	acmApplicationExit(NULL, DRVEA_NORMALEXIT);
#endif


    //
    //  Free the drivers, one by one.  This code is NOT re-entrant, since
    //  it messes with the drivers list.
    //
    ENTER_LIST_EXCLUSIVE;
	uGonzo = 666;
	while (NULL != pag->padidFirst)
	{
	    padid = pag->padidFirst;

	    padid->htask = NULL;

	    pag->hadidDestroy = (HACMDRIVERID)padid;

	    IDriverRemove(pag->hadidDestroy, 0L);

	    uGonzo--;
	    if (0 == uGonzo)
	    {
		DPF(0, "!acmTerminate: PROBLEMS REMOVING DRIVERS--TERMINATION UNORTHODOX!");
		pag->padidFirst = NULL;
	    }
	}
    LEAVE_LIST_EXCLUSIVE;


	//
	//
	//
	pag->fDriversBooted = FALSE;

    }


    //
    //
    //
#ifndef WIN32
    if (pag->fWOW)
    {
	acmThunkTerminate(hinst, dwReason);
    }
#endif

#ifdef WIN32
    DeleteLock(&pag->lockDriverIds);
#endif // WIN32

    //
    //
    //
    threadTerminate(pag);	    // this-thread termination of tls stuff
    threadTerminateProcess(pag);    // per-process termination of tls stuff


    //
    //  blow away all previous garbage
    //
#if defined(WIN32) && defined(WIN4)
    DeleteCriticalSection(&pag->csBoot);
#endif
    pagDelete(pag);

    DPF(1, "acmTerminate: termination end");
    return (TRUE);
} // acmTerminate()


//--------------------------------------------------------------------------;
//
//  BOOL acmInitialize
//
//  Description:
//      Initialization routine for ACM interface.
//
//  Arguments:
//      HINSTANCE hinst: Module instance handle of ACM.
//	DWORD dwReason:
//
//  Return (BOOL):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL acmInitialize
(
    HINSTANCE   hinst,
    DWORD	dwReason
)
{
#ifndef WIN4
    MMRESULT    mmr;
#endif
#if defined(WIN32) && defined(WIN4)
    HANDLE	hMMDevLdr;
#endif
    PACMGARB	pag;

    DPF(1, "acmInitialize: initialization begin");
    DPF(5, "!*** break for debugging ***");


#ifdef USEINITFRIENDLYNAMES
    //
    //  If the friendly names aren't in the registry, stick them there.
    //  We have to do this for NT, because we can't dink with the
    //  user profiles at setup time.
    //
    {
        HANDLE CurrentUserKey;
        HKEY hkeyAudio;
        HKEY hkeyWaveFormats;
        LONG lRet;

        if (NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &CurrentUserKey)))
        {
            lRet = RegCreateKeyEx( CurrentUserKey, gszFriendlyAudioKey, 0,
                NULL, 0, KEY_QUERY_VALUE|KEY_WRITE, NULL, &hkeyAudio, NULL );
            if( lRet == ERROR_SUCCESS )
            {
                //
                //  Check to see if "SystemFormats" value is there.
                //
                if( !IRegValueExists( hkeyAudio, gszFriendlySystemFormatsValue ) )
                {
                    DPF(1,"acmInitialize: Detected lack of friendly name stuff in HKCU, attempting to write out default values.");
                    lRet = RegCreateKeyEx( hkeyAudio,
                                gszFriendlyWaveFormatsKey, 0, NULL, 0,
                                KEY_WRITE, NULL, &hkeyWaveFormats, NULL );
                    if( lRet == ERROR_SUCCESS )
                    {
			TCHAR achFriendlyName[STRING_LEN];
			TCHAR achFriendlySystemNames[STRING_LEN*3+3];
			int   cch;

			achFriendlySystemNames[0] = '\0';

			//
			//  We will write out wave format structures into the
			//  registry for each of the friendly format names.
			//  Simultaneously, we'll create a string having the
			//  form "CD Quality,Radio Quality,Telephone Quality"
			//
			
			if (LoadString(hinst, IDS_CHOOSE_QUALITY_CD, achFriendlyName, SIZEOF(achFriendlyName))) {
			    if (!RegSetValueEx( hkeyWaveFormats,
						achFriendlyName,
						0, REG_BINARY,
						(LPBYTE)&gwfFriendlyCDQualityData,
						sizeof(PCMWAVEFORMAT) )) {
				lstrcat(achFriendlySystemNames, achFriendlyName);
				lstrcat(achFriendlySystemNames, TEXT(","));
			    }
			}

			if (LoadString(hinst, IDS_CHOOSE_QUALITY_RADIO, achFriendlyName, SIZEOF(achFriendlyName))) {
			    if (!RegSetValueEx( hkeyWaveFormats,
						achFriendlyName,
						0, REG_BINARY,
						(LPBYTE)&gwfFriendlyRadioQualityData,
						sizeof(PCMWAVEFORMAT) )) {
				lstrcat(achFriendlySystemNames, achFriendlyName);
				lstrcat(achFriendlySystemNames, TEXT(","));
			    }
			}
			
			if (LoadString(hinst, IDS_CHOOSE_QUALITY_TELEPHONE, achFriendlyName, SIZEOF(achFriendlyName))) {
			    if (!RegSetValueEx( hkeyWaveFormats,
						achFriendlyName,
						0, REG_BINARY,
						(LPBYTE)&gwfFriendlyTelephoneQualityData,
						sizeof(PCMWAVEFORMAT) )) {
				lstrcat(achFriendlySystemNames, achFriendlyName);
				lstrcat(achFriendlySystemNames, TEXT(","));
			    }
			}

                        RegCloseKey( hkeyWaveFormats );

			cch = lstrlen(achFriendlySystemNames);
			if ( (0 != cch) && (TEXT(',') == achFriendlySystemNames[cch-1]) ) {
			    achFriendlySystemNames[cch-1] = TEXT('\0');
			}
			
			//
			//
			//
			if (LoadString(hinst, IDS_CHOOSE_QUALITY_DEFAULT, achFriendlyName, SIZEOF(achFriendlyName))) {
			    IRegWriteString( hkeyAudio,
					     gszFriendlyDefaultFormatValue,
					     achFriendlyName );
			}

			if (lstrlen(achFriendlySystemNames) != 0) {
			    IRegWriteString( hkeyAudio,
					     gszFriendlySystemFormatsValue,
					     achFriendlySystemNames );
			}
                    }
#ifdef DEBUG
                    else
                    {
                        DWORD dw = GetLastError();
                        DPF(1,"!acmInitialize: Unable to open WaveFormats key (last error=%u) - not writing friendly names stuff.",dw);
                    }
#endif
                }
                else
                {
                    DPF(3,"acmInitialize:  Friendly name stuff is already set up.");
                }

                RegCloseKey( hkeyAudio );
            }
#ifdef DEBUG
            else
            {
                DWORD dw = GetLastError();
                DPF(1,"!acmInitialize: Unable to open Audio key (last error=%u) - not checking friendly names stuff.",dw);
            }
#endif
            NtClose(CurrentUserKey);
        }
#ifdef DEBUG
        else
        {
            DWORD dw = GetLastError();
            DPF(1,"!acmInitialize: Unable to open current user key (last error=%u) - not checking friendly names stuff.",dw);
        }
#endif
    }
#endif  //  USEINITFRIENDLYNAMES



    //
    //
    //
    pag = pagFind();
    if (NULL != pag)
    {
	//
	//  we've already initialized (or are in the middle of initializing)
	//  in this process.  Just bump usage (and call thunk init for Chicago)
	//
	pag->cUsage++;
#if !defined(WIN32) && defined(WIN4)
	acmThunkInit(pag, hinst, dwReason);
#endif
	return (TRUE);
    }


    //
    // Still no side effects to undo, so it's safe to return here if failure.
    //
    pag = pagNew();
    if (NULL == pag) {
	return FALSE;
    }


    //
    //
    //
    pag->cUsage		    = 1;
    pag->hinst		    = hinst;
    pag->fDriversBooted	    = FALSE;
#ifdef DEBUG
    pag->fDriversBooting    = FALSE;
#endif
#if defined(WIN32) && defined(WIN4)
    try {
	InitializeCriticalSection(&pag->csBoot);
    } except (EXCEPTION_EXECUTE_HANDLER) {
	// The only side effect to undo is the allocation of the pag
	pagDelete(pag);
	pag = NULL;
	return FALSE;
    }
#endif

    //
    //
    //
    threadInitializeProcess(pag);	// Per-process init of tls stuff
    threadInitialize(pag);		// This-thread init of tls stuff

    //
    //
    //
#ifdef WIN32
    //
    //
    //
    if (!InitializeLock(&pag->lockDriverIds))
    {
        return FALSE;
    }

#ifndef WIN4
    //	NOTE: Not compiling pnp support
#else
    //
    //	Obtain pointer to MMDevLdr's driver change notify counter.
    //
    hMMDevLdr = CreateFile(TEXT("\\\\.\\MMDEVLDR"), // magic name to attach to an already loaded vxd
			   GENERIC_WRITE,
			   FILE_SHARE_WRITE,
			   NULL,
			   OPEN_EXISTING,
			   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
			   NULL);
    if (INVALID_HANDLE_VALUE == hMMDevLdr)
    {
	DPF(0, "acmInitialize: Could not CreateFile(MMDevLdr)");
    }
    else
    {
	DWORD	cbRet;
	BOOL	f;

	cbRet = 0;
	f = DeviceIoControl (hMMDevLdr,
			     MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR,
			     NULL,
			     0,
			     &pag->lpdwPnpChangeNotify,
			     sizeof(pag->lpdwPnpChangeNotify),
			     &cbRet,
			     NULL);
	
	if ( (!f) ||
	     (sizeof(pag->lpdwPnpChangeNotify)!=cbRet) ||
	     (NULL==pag->lpdwPnpChangeNotify) )
	{
	    //
	    //	Failed to get ptr to mmdevldr change notify counter
	    //
	    if (!f)
	    {
		DPF(0, "acmInitialize: DeviceIoControl to MMDevLdr failed!");
	    }
	    else if (sizeof(pag->lpdwPnpChangeNotify)!=cbRet)
	    {
		DPF(0, "acmInitialize: MMDEVLDR_IOCTL_GETCHANENOTIFYPTR returned wrong cbRet!");
	    }
	    else
	    {
		DPF(0, "acmInitialize: MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR returned NULL ptr");
	    }

	    //
	    //	Point back to a safe, innocuous place
	    //
	    pag->lpdwPnpChangeNotify = &pag->dwPnpLastChangeNotify;
	}

	CloseHandle(hMMDevLdr);
    }
#endif	// WIN4
#endif	// WIN32

#ifndef WIN32
    pag->fWOW = acmThunkInit(pag, hinst, dwReason);
#endif

#ifndef WIN4
#ifndef WIN32
    //
    //  For 16-bit find any 32-bit drivers if we're on WOW
    //
    if (pag->fWOW)
    {
	acmBoot32BitDrivers(pag);
    }
#endif
    mmr = acmBootDrivers(pag);
    if (MMSYSERR_NOERROR == mmr)
    {
	mmr = acmBootPnpDrivers(pag);
    }
    pag->fDriversBooted = TRUE;
    
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!acmInitialize: acmBootDrivers failed! mrr=%.04Xh", mmr);
#ifdef WIN32
        DeleteLock(&pag->lockDriverIds);
#endif // WIN32
	pagDelete(pag);
        return (FALSE);
    }
#endif

    DPF(1, "acmInitialize: initialization end");

    //
    //  success!
    //
    return (TRUE);
} // acmInitialize()


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef WIN32

#ifdef WIN4
//--------------------------------------------------------------------------;
//
//
//
//
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
//  BOOL DllEntryPoint
//
//  Description:
//	This is a special 16-bit entry point called by the Chicago kernel
//	for thunk initialization and cleanup.  It is called on each usage
//	increment or decrement.  Do not call GetModuleUsage within this
//	function as it is undefined whether the usage is updated before
//	or after this DllEntryPoint is called.
//
//  Arguments:
//	DWORD dwReason:
//		1 - attach (usage increment)
//		0 - detach (usage decrement)
//
//	HINSTANCE hinst:
//
//	WORD wDS:
//
//	WORD wHeapSize:
//
//	DWORD dwReserved1:
//
//	WORD wReserved2:
//
//  Return (BOOL):
//
//  Notes:
//	!!! WARNING !!! This code may be reentered due to thunk connections.
//
//  History:
//      02/02/94    [frankye]
//
//--------------------------------------------------------------------------;
#pragma message ("--- Remove secret MSACM.INI AllowThunks ini switch")

BOOL FNEXPORT DllEntryPoint
(
 DWORD	    dwReason,
 HINSTANCE  hinst,
 WORD	    wDS,
 WORD	    wHeapSize,
 DWORD	    dwReserved1,
 WORD	    wReserved2
)
{
    BOOL fSuccess	    = TRUE;


    DPF(1,"DllEntryPoint(dwReason=%08lxh, hinst=%04xh, wDS=%04xh, wHeapSize=%04xh, dwReserved1=%08lxh, wReserved2=%04xh", dwReason, hinst, wDS, wHeapSize, dwReserved1, wReserved2);
    DPF(5, "!*** break for debugging ***");


    //
    //	Initialize or terminate 16-bit msacm
    //
    switch (dwReason)
    {
	case 0:
	    fSuccess = acmTerminate(hinst, dwReason);
	    break;

	case 1:
	    fSuccess = acmInitialize(hinst, dwReason);
	    break;

	default:
	    fSuccess = TRUE;
	    break;
    }

    DPF(1,"DllEntryPoint exiting");

    return (fSuccess);
}
#endif

//--------------------------------------------------------------------------;
//
//
//
//
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
//  int WEP
//
//  Description:
//      The infamous useless WEP(). Note that this procedure needs to be
//      in a FIXED segment under Windows 3.0. Under Windows 3.1 this is
//      not necessary.
//
//  Arguments:
//      BOOL fWindowsExiting: Should tell whether Windows is exiting or not.
//
//  Return (int):
//      Always return non-zero.
//
//  History:
//      04/29/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C int FNEXPORT WEP
(
    BOOL                    fWindowsExiting
)
{
    DPF(1, "WEP(fWindowsExiting=%u)", fWindowsExiting);

    //
    //  we RIP on exit if we are not loaded by the mapper because
    //  davidds decided to free our drivers for us instead of leaving
    //  them alone like we tried to tell him.. i have no idea what
    //  chicago will do. note that this RIP is ONLY if an app that
    //  is linked to us is running during the shutdown of windows.
    //
    if (!fWindowsExiting)
    {
#ifndef WIN4
	PACMGARB    pag;

	pag = pagFind();
	acmTerminate(pag->hinst, 0);
#endif
    }

    _cexit();

    //
    //  always return non-zero
    //
    return (1);
} // WEP()


//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//      This routine must guarantee the following things so CODEC's don't
//      have to special case code everywhere:
//
//          o   will only run in Windows 3.10 or greater (our exehdr is
//              marked appropriately).
//
//          o   will only run on >= 386 processor. only need to check
//              on Win 3.1.
//
//  Arguments:
//      HINSTANCE hinst: Our module instance handle.
//
//      WORD wDataSeg: Our data segment selector.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE               hinst,
    WORD                    wDataSeg,
    WORD                    cbHeapSize,
    LPSTR                   pszCmdLine
)
{
    BOOL                f;

    //
    //  we ONLY work on >= 386. if we are on a wimpy processor, scream in
    //  pain and die a horrible death!
    //
    //  NOTE! do this check first thing and get out if on a 286. we are
    //  compiling with -G3 and C8's libentry garbage does not check for
    //  >= 386 processor. the following code does not execute any 386
    //  instructions (not complex enough)..
    //

    //
    // This binary now runs on NT.  The software emulator on MIPS
    // and Alpha machines only support 286 chips !!
    //
    if (!(GetWinFlags() & WF_WINNT)) {

        //
        // We are not running on NT so fail for 286 machines
        //
        if (GetWinFlags() & WF_CPU286) {
            return (FALSE);
        }
    }


    //
    //
    //
    DbgInitialize(TRUE);

    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);
    DPF(5, "!*** break for debugging ***");

#ifndef WIN4
    f = acmInitialize(hinst, 1);
#endif

    return (f);
} // LibMain()

#else // WIN32

//==========================================================================;
//
//  WIN 32 SPECIFIC SUPPORT
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL DllMain
//
//  Description:
//      This is the standard DLL entry point for Win 32.
//
//  Arguments:
//      HINSTANCE hinst: Our instance handle.
//
//      DWORD dwReason: The reason we've been called--process/thread attach
//      and detach.
//
//      LPVOID lpReserved: Reserved. Should be NULL--so ignore it.
//
//  Return (BOOL):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp]
//	    initial
//	04/18/94    fdy	    [frankye]
//	    major mods for Chicago.  Yes, it looks real ugly now cuz of all
//	    the conditional compilation for chicago, daytona, etc.  Don't
//	    have time to think of good way to structure all this right now.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT DllMain
(
    HINSTANCE               hinst,
    DWORD                   dwReason,
    LPVOID                  lpReserved
)
{
    BOOL		f = TRUE;
#ifdef WIN4
    static HINSTANCE	hWinMM = NULL;
#endif // WIN4


    //
    //
    //
    switch (dwReason)
    {
	//
	//
	//
	case DLL_PROCESS_ATTACH:
	{
	    DbgInitialize(TRUE);
#ifdef DEBUG
	    {
		char strModuleFilename[80];
		GetModuleFileNameA(NULL, (LPSTR) strModuleFilename, 80);
		DPF(1, "DllMain: DLL_PROCESS_ATTACH: HINSTANCE=%08lx ModuleFilename=%s", hinst, strModuleFilename);
	    }
#endif
	
#ifdef WIN4
	    //
	    //  Even though we are implicitly linked to winmm.dll (via static
	    //	link to winmm.lib), doing explicit LoadLibrary on winmm helps
	    //	make sure its around all the way through our DllMain on
	    //	DLL_PROCESS_DETACH.
	    //
	    hWinMM = LoadLibrary(gszWinMM);
#endif

	    f = acmInitialize(hinst, dwReason);

#ifdef WIN4
	    //
	    //  thunk connect
	    //
	    if (f)
	    {
		acmt32c_ThunkConnect32(gmbszMsacm, gmbszMsacm32, hinst, dwReason);
	    }
#endif
	    break;
	}


	//
	//
	//
	case DLL_THREAD_ATTACH:
	{
	    threadInitialize(pagFind());
	    break;
	}


	//
	//
	//
	case DLL_THREAD_DETACH:
	{
	    threadTerminate(pagFind());
	    break;
	}

	
	//
	//
	//
	case DLL_PROCESS_DETACH:
	{
	    DPF(1, "DllMain: DLL_PROCESS_DETACH");
	
	    f = acmTerminate(hinst, dwReason);

#ifdef WIN4
	    //
	    //  thunk disconnect
	    //
	    acmt32c_ThunkConnect32(gmbszMsacm, gmbszMsacm32, hinst, dwReason);

	    FreeLibrary(hWinMM);
#endif
	    break;
	}


	//
	//
	//
	default:
	{
	    break;
	}

    }
	return (f);
	
} // DllMain()

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\pcm.c ===
//==========================================================================;
//
//  pcm.c
//
//  Description:
//      This is the 'PCM' converter.  it is just like any other 'real'
//      audio converter.  It has a standard ConverterProc.
//
//      the ACM calls
//
//      acmDriverAdd(pcmDriverProc,
//                   ACM_DRIVERADDF_FUNCTION | ACM_DRIVERADDF_GLOBAL);
//
//      when it is loaded.
//
//  History:
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include "muldiv32.h"
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "uchelp.h"
#include "pcm.h"
#include "debug.h"

//
//  We don't want to include the 16-bit PCM converter in Chicago msacm.dll.
//
#if defined(WIN32) || defined(NTWOW)


//
//  we use this dwId to determine when we where opened as an audio codec
//  by the ACM or from the control panel, etc. see acmdDriverOpen for more
//  information.
//
#define BOGUS_DRIVER_ID     1L


#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))

//
//  array of WAVE format tags supported.
//
//  NOTE! if you change anything in this structure (order, addition, removal)
//  you must also fix acmdFormatTagDetails!
//
static const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM
};

#define CODEC_MAX_FORMAT_TAGS   SIZEOF_ARRAY(gauFormatTagIndexToTag)


//
//  array of _standard_ sample rates supported
//
//
static const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

#define CODEC_MAX_SAMPLE_RATES  SIZEOF_ARRAY(gauFormatIndexToSampleRate)

//
//
//
//
#define CODEC_MAX_CHANNELS      (MSPCM_MAX_CHANNELS)

//
//  array of bits per sample supported
//
//
static const UINT gauFormatIndexToBitsPerSample[] =
{
    8,
    16
};

#define CODEC_MAX_BITSPERSAMPLE_PCM SIZEOF_ARRAY(gauFormatIndexToBitsPerSample)




//
//  number of formats we enumerate per channels is number of sample rates
//  times number of channels times number of
//  (bits per sample) types.
//
#define CODEC_MAX_STANDARD_FORMATS_PCM  (CODEC_MAX_SAMPLE_RATES *   \
                                         CODEC_MAX_CHANNELS *       \
                                         CODEC_MAX_BITSPERSAMPLE_PCM)



//
//  array of WAVE filter tags supported.
//
//static DWORD gauFilterIndexToTag[] =
//{
//};
#define CODEC_MAX_FILTER_TAGS   0


//
//
//
//
typedef struct tCODECINST
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the codec will be easier to combine
    //  with other types of codecs (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of codec: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your codec requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           dwFlags;        // flags from open description

} CODECINST, *PCODECINST, FAR *LPCODECINST;



//
//
//
#if defined(WIN32) || defined(DEBUG)
    EXTERN_C DWORD FNGLOBAL pcmConvert_C
    (
        LPPCMWAVEFORMAT pwfSrc,
        LPBYTE          pbSrc,
        LPPCMWAVEFORMAT pwfDst,
        LPBYTE          pbDst,
        DWORD           dwSrcSamples,
        BOOL            fPartialSampleAtTheEnd,
        LPBYTE          pbDstEnd
    );

#if defined(WIN32)
    #define pcmConvert          pcmConvert_C
#endif
#endif

#if !defined(WIN32)
#error Somebody's got to add a fPartialSampleAtTheEnd thingy to the 386-assembly PCM converter!
    EXTERN_C DWORD FNGLOBAL pcmConvert_386
    (
        LPPCMWAVEFORMAT pwfSrc,
        LPBYTE          pbSrc,
        LPPCMWAVEFORMAT pwfDst,
        LPBYTE          pbDst,
        DWORD           dwSrcSamples
    );

    #define pcmConvert          pcmConvert_386
#endif


typedef DWORD (FNGLOBAL *CONVERTPROC)
(
    LPPCMWAVEFORMAT,
    LPBYTE,
    LPPCMWAVEFORMAT,
    LPBYTE,
    DWORD,
    BOOL,
    LPBYTE
);


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX  pwfx
)
{
    UINT    uBlockAlign;

    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > MSPCM_MAX_CHANNELS))
        return (FALSE);

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if ((8 != pwfx->wBitsPerSample) && (16 != pwfx->wBitsPerSample))
        return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    uBlockAlign = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx);
    if (uBlockAlign != (UINT)pwfx->nBlockAlign)
        return (FALSE);

    if ((0L == pwfx->nSamplesPerSec) || (0x3FFFFFFF < pwfx->nSamplesPerSec))
    {
        return (FALSE);
    }


    //
    //  finally, verify that avg bytes per second is correct
    //
    if ((pwfx->nSamplesPerSec * uBlockAlign) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//==========================================================================;
//
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can and will be opened on a single
//      open _driver instance_. Do not store create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR               hdrvr,
    LPACMDRVOPENDESC    paod
)
{
    PCODECINST      pci;

    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  return a special non-zero value (it will be passed back as dwId
    //  to the DriverProc on following messages).
    //
    if (NULL == paod)
        return (BOGUS_DRIVER_ID);

    //
    //  the open description that is passed to this driver can be from
    //  multiple 'managers.' for example, AVI looks for installable drivers
    //  that are tagged with 'vidc' and 'vcap'. we need to verify that we
    //  are being opened as an Audio Compression Manager driver.
    //
    //  refuse to open if we are not being opened as an ACM driver. note
    //  that we do NOT modify the value of paod->dwError in this case.
    //
    if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        return (0L);


    //
    //  we are being opened as an ACM driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure.
    //
    pci = (PCODECINST)LocalAlloc(LPTR, sizeof(*pci));

    //
    //  if we cannot allocate our instance structure, then we must fail
    //  the open request. however, we also want to give the reason why
    //  we are failing the open--so we fill in the dwError member of
    //  the ACMDRVOPENDESC structure...
    //
    if (NULL == pci)
    {
        paod->dwError = MMSYSERR_NOMEM;
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pci->fccType      = paod->fccType;
    pci->fnDriverProc = (DRIVERPROC)NULL;

    pci->hdrvr        = hdrvr;              // driver handle to our driver
    pci->vdwACM       = paod->dwVersion;    // version of ACM opening us
    pci->dwFlags      = paod->dwFlags;      // flags opened with


    //
    //  finally, succeed the open... return our instance data pointer.
    //  this pointer will be passed as the dwId argument of our driver
    //  procedure on all following messages for this open instance.
    //
    paod->dwError = MMSYSERR_NOERROR;


    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)(UINT_PTR)pci);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PCODECINST              pci
)
{
    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (NULL != pci)
    {
        //
        //  close down the driver instance. this driver simply needs
        //  to free the instance data structure... note that if this
        //  'free' fails, then this ACM driver probably trashed its
        //  heap; assume we didn't do that.
        //
        LocalFree((HLOCAL)pci);
    }


    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      some configuration information was changed. however, the driver
//      does not require Windows to be restarted--the changes have already
//      been applied.
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PCODECINST              pci,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
    //
    //  first check to see if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a configuration dialog box, so
        //  return zero...
        //
        return (0L);
    }


    //
    //  we are being asked to bring up our configuration dialog. if this
    //  driver supports a configuration dialog box, then after the dialog
    //  is dismissed we must return one of the following values:
    //
    //  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
    //  and canceled by the user. this value should also be returned if
    //  no configuration information was modified.
    //
    //  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
    //  some configuration information was changed. however, the driver
    //  does not require Windows to be restarted--the changes have already
    //  been applied.
    //
    //  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
    //  and some configuration information was changed that requires
    //  Windows to be restarted before the changes take affect. the driver
    //  should remain configured with current values until the driver
    //  has been 'rebooted'.
    //
    //
    //  return DRVCNF_CANCEL--this ACM driver does not support configuration
    //
    return (DRVCNF_CANCEL);
} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PCODECINST              pci,
    LPACMDRIVERDETAILS      paddOut
)
{
    LPACMDRIVERDETAILS  padd;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.  we allocate this dynamically instead of automatically
    //  because it is a very large structure.
    //
    padd = (LPACMDRIVERDETAILS)LocalAlloc(LPTR, sizeof(*padd));
    if (NULL == padd) return MMSYSERR_NOMEM;

    cbStruct              = min(paddOut->cbStruct, sizeof(ACMDRIVERDETAILS));
    padd->cbStruct        = cbStruct;


    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    padd->fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    padd->fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    padd->wMid            = MM_MICROSOFT;
    padd->wPid            = MM_MSFT_ACM_PCM;


    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    padd->vdwACM          = VERSION_MSACM_REQ; // required level, not the actual level
    padd->vdwDriver       = VERSION_CODEC;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    padd->fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CONVERTER;


    //
    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.
    //
    padd->cFormatTags     = CODEC_MAX_FORMAT_TAGS;

    //
    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.
    //
    padd->cFilterTags     = CODEC_MAX_FILTER_TAGS;


    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
	PACMGARB pag;
	
        //
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        padd->hicon = NULL;

	pag = pagFind();
	if (NULL == pag)
	{
	    DPF(1, "acmdDriverDetails: NULL pag!!!");
	}
	else
	{
	    //
	    //  the short name and long name are used to represent the driver
	    //  in a unique description. the short name is intended for small
	    //  display areas (for example, in a menu or combo box). the long
	    //  name is intended for more descriptive displays (for example,
	    //  in an 'about box').
	    //
	    //  NOTE! an ACM driver should never place formatting characters
	    //  of any sort in these strings (for example CR/LF's, etc). it
	    //  is up to the application to format the text.
	    //
#ifdef WIN32
	    LoadStringW(pag->hinst, IDS_CODEC_SHORTNAME, padd->szShortName, SIZEOFW(padd->szShortName));
	    LoadStringW(pag->hinst, IDS_CODEC_LONGNAME,  padd->szLongName,  SIZEOFW(padd->szLongName));
#else
	    LoadString(pag->hinst, IDS_CODEC_SHORTNAME, padd->szShortName, SIZEOF(padd->szShortName));
	    LoadString(pag->hinst, IDS_CODEC_LONGNAME,  padd->szLongName,  SIZEOF(padd->szLongName));
#endif

	    //
	    //  the last three members are intended for 'about box' information.
	    //  these members are optional and may be zero length strings if
	    //  the driver wishes.
	    //
	    //  NOTE! an ACM driver should never place formatting characters
	    //  of any sort in these strings (for example CR/LF's, etc). it
	    //  is up to the application to format the text.
	    //
	    if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
	    {
#ifdef WIN32
		LoadStringW(pag->hinst, IDS_CODEC_COPYRIGHT, padd->szCopyright, SIZEOFW(padd->szCopyright));
		LoadStringW(pag->hinst, IDS_CODEC_LICENSING, padd->szLicensing, SIZEOFW(padd->szLicensing));
		LoadStringW(pag->hinst, IDS_CODEC_FEATURES,  padd->szFeatures,  SIZEOFW(padd->szFeatures));
#else
		LoadString(pag->hinst, IDS_CODEC_COPYRIGHT, padd->szCopyright, SIZEOF(padd->szCopyright));
		LoadString(pag->hinst, IDS_CODEC_LICENSING, padd->szLicensing, SIZEOF(padd->szLicensing));
		LoadString(pag->hinst, IDS_CODEC_FEATURES,  padd->szFeatures,  SIZEOF(padd->szFeatures));
#endif
	    }
	}
    }


    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(paddOut, padd, (UINT)padd->cbStruct);

    //
    //  free our temporary structure
    //
    LocalFree((HLOCAL)padd);


    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PCODECINST              pci,
    HWND                    hwnd
)
{
    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a custom about box, so
        //  return MMSYSERR_NOTSUPPORTED...
        //
        return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  this driver does not support a custom dialog, so tell the ACM or
    //  calling application to display one for us. note that this is the
    //  _recommended_ method for consistency and simplicity of ACM drivers.
    //  why write code when you don't have to?
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM, a wave mapper or
//      an application to quickly get a destination format that this driver
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible. This message is normally
//      sent in response to an acmFormatSuggest function call.
//
//      Another way to think about this message is: what format would this
//      driver like to convert the source format to?
//
//      The caller may place restrictions on the destination format that
//      should be suggested. The padfs->fdwSuggest member contains the
//      restriction bits passed by the caller--see the description for
//      the return value for more information.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to an ACMDRVFORMATSUGGEST
//      structure that describes the source and destination (possibly with
//      restrictions) for a conversion.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if one or more of
//      the destination restriction bits is not supported. It is strongly
//      recommended that the driver support at least the following suggestion
//      restriction bits:
//
//      ACM_FORMATSUGGESTF_WFORMATTAG: The destination format tag must be
//      the same as the wFormatTag member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NCHANNELS: The destination channel count must be
//      the same as the nChannels member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NSAMPLESPERSEC: The destination samples per
//      second must be the same as the nSamplesPerSec member in the
//      destination format header.
//
//      ACM_FORMATSUGGESTF_WBITSPERSAMPLE: The destination bits per sample
//      must be the same as the wBitsPerSample member in the destination
//      format header.
//
//      If no destintation format can be suggested, then the driver should
//      return ACMERR_NOTPOSSIBLE.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PCODECINST              pci,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    DWORD                   fdwSuggest;


    //
    //  grab the suggestion restriction bits and verify that we support
    //  the ones that are specified... an ACM driver must return the
    //  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
    //  are not supported.
    //
    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  get the source and destination formats in more convenient variables
    //
    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;


    //
    //
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!pcmIsValidFormat(pwfxSrc))
                break;


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is only able to convert PCM
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_PCM != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is only able to deal with 1 and 2 channels.
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if ((pwfxDst->nChannels < 1) ||
                    (pwfxDst->nChannels > MSPCM_MAX_CHANNELS))
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver does any sample rate conversions...
            //
            if (0 == (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest))
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is only able to convert to 16 or 8 bit
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if ((16 != pwfxDst->wBitsPerSample) &&
                    (8  != pwfxDst->wBitsPerSample))
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = pwfxSrc->wBitsPerSample;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize              !!! not used for PCM !!!
            //
            pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfxDst);
            pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec *
                                       pwfxDst->nBlockAlign;

            // pwfxDst->cbSize       = not used;

            return (MMSYSERR_NOERROR);
    }


    //
    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this ACM driver
    //  cannot deal with.
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdFormatSuggest()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PCODECINST              pci,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format.  return error.
            //
            if (CODEC_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            if (WAVE_FORMAT_PCM != padft->dwFormatTag)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = WAVE_FORMAT_PCM;
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CONVERTER;
            padft->cStandardFormats = CODEC_MAX_STANDARD_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0]   =  '\0';
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PCODECINST              pci,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX      pwfx;
    UINT                uFormatIndex;
    UINT                u;


    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  verify that the format tag is something we know about
            //
            if (WAVE_FORMAT_PCM != padf->dwFormatTag)
                return (ACMERR_NOTPOSSIBLE);

            if (CODEC_MAX_STANDARD_FORMATS_PCM <= padf->dwFormatIndex)
                return (ACMERR_NOTPOSSIBLE);

            //
            //  put some stuff in more accessible variables--note that we
            //  bring variable sizes down to a reasonable size for 16 bit
            //  code...
            //
            pwfx = padf->pwfx;
            uFormatIndex = (UINT)padf->dwFormatIndex;

            //
            //  now fill in the format structure
            //
            pwfx->wFormatTag      = WAVE_FORMAT_PCM;

            u = uFormatIndex / (CODEC_MAX_BITSPERSAMPLE_PCM * CODEC_MAX_CHANNELS);
            pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

            u = uFormatIndex % CODEC_MAX_CHANNELS;
            pwfx->nChannels       = u + 1;

            u = (uFormatIndex / CODEC_MAX_CHANNELS) % CODEC_MAX_CHANNELS;
            pwfx->wBitsPerSample  = (WORD)gauFormatIndexToBitsPerSample[u];

            pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx);
            pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

            //
            //  note that the cbSize field is NOT valid for PCM formats
            //
            //  pwfx->cbSize      = 0;
            break;


        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            if (!pcmIsValidFormat(padf->pwfx))
                return (ACMERR_NOTPOSSIBLE);

            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.
    //
    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CONVERTER;
    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    BOOL                fRealTime;


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));


    //
    //  the most important condition to check before doing anything else
    //  is that this ACM driver can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this driver.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a driver that is suitable for the conversion. also note that
    //  the ACM may call this driver several times with slightly different
    //  format specifications before giving up.
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    if (!pcmIsValidFormat(pwfxSrc) || !pcmIsValidFormat(pwfxDst))
    {
        //
        //  either the source or destination format is illegal for this
        //  codec--or the conversion between the formats can not be
        //  performed by this codec.
        //
        return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (ACM_STREAMOPENF_QUERY & padsi->fdwOpen)
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //



    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure.
    //
    padsi->dwDriver = (DWORD_PTR)pcmConvert;

#if !defined(WIN32) && defined(DEBUG)
    if (0 != GetProfileInt("mspcm", "useccode", 0))
    {
        padsi->dwDriver = (DWORD)pcmConvert_C;
    }
#endif

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose). The ACM driver should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      NOTE! It is _strongly_ recommended that a driver not fail to close
//      a conversion stream.
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    DWORD               cbSrc;
    DWORD               cbDst;

    //
    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;


    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            cbSrc = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)pwfxSrc, padss->cbSrcLength);

            if (0L == cbSrc)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            //
            //  Check for overflow condition.
            //
            if (pwfxDst->nAvgBytesPerSec >= pwfxSrc->nAvgBytesPerSec)
            {
                cbDst = (0xFFFFFFFFL / pwfxDst->nAvgBytesPerSec) - pwfxDst->nBlockAlign;

                if ((padss->cbSrcLength / pwfxSrc->nAvgBytesPerSec) > cbDst)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
            }

            cbDst = MulDivRU(cbSrc,
                             pwfxDst->nSamplesPerSec,
                             pwfxSrc->nSamplesPerSec);

            cbDst = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)pwfxDst, cbDst);

            if (0L == cbDst)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            padss->cbDstLength = cbDst;
            return (MMSYSERR_NOERROR);


        case ACM_STREAMSIZEF_DESTINATION:
            cbDst = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)pwfxDst, padss->cbDstLength);

            if (0L == cbDst)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            //
            //  Check for overflow condition.
            //
            if (pwfxSrc->nAvgBytesPerSec >= pwfxDst->nAvgBytesPerSec)
            {
                cbSrc = (0xFFFFFFFFL / pwfxSrc->nAvgBytesPerSec) - pwfxSrc->nBlockAlign;

                if ((padss->cbDstLength / pwfxDst->nAvgBytesPerSec) > cbSrc)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
            }

            //
            //  Usually, we round down when calculating the size of the
            //  source buffer.  Unfortunately, this leads to a difficult
            //  problem with PCM conversion.  Normally, the calling app
            //  should be able to allocate a block-aligned dest buffer,
            //  call acmStreamSize to find out the required source buffer
            //  size, use that size, and always receive a full dest buffer.
            //  However, suppose that the app wants to record 22kHz data
            //  from a 11kHz card and provides a dest buffer with an odd
            //  number of samples.  If we round down in figuring out the
            //  source size, then the output will be one sample less than
            //  the size of the dest buffer.  BAD NEWS!  So here we round
            //  up, and then check for this case in the acmdStreamConvert
            //  function.
            //
            cbSrc = MulDivRU(cbDst,
                             pwfxSrc->nSamplesPerSec,
                             pwfxDst->nSamplesPerSec);

            cbSrc = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)pwfxSrc, cbSrc);

            if (0L == cbSrc)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            padss->cbSrcLength = cbSrc;
            return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamConvert
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamConvert
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    LPPCMWAVEFORMAT     pwfSrc;
    LPPCMWAVEFORMAT     pwfDst;
    CONVERTPROC         fnConvert;
    DWORD               cb;
    DWORD               cbDst;
    DWORD               dwSrcSamples;

    BOOL                fPartialSampleAtTheEnd;
    BOOL                fDstIsBlockAligned;
    DWORD               dwDstSamples;


    //
    //  our instance data is a pointer to the conversion procedure
    //  needed to convert the pwfxSrc data to pwfxDst. the correct
    //  procedure to use was decided in acmdStreamOpen..
    //
    fnConvert = (CONVERTPROC)padsi->dwDriver;

    pwfSrc    = (LPPCMWAVEFORMAT)padsi->pwfxSrc;
    pwfDst    = (LPPCMWAVEFORMAT)padsi->pwfxDst;


    //
    //  Check if we have to hack the destination buffer to make it full -
    //  see the big comment near the end of acmdStreamSize() for more
    //  details.
    //
    dwSrcSamples    = PCM_BYTESTOSAMPLES( pwfSrc, padsh->cbSrcLength );
    dwDstSamples    = PCM_BYTESTOSAMPLES( pwfDst, padsh->cbDstLength );
    fDstIsBlockAligned = ( padsh->cbDstLength ==
                            PCM_SAMPLESTOBYTES( pwfDst, dwDstSamples )  );

    if( fDstIsBlockAligned  &&
        (dwSrcSamples == MulDivRU( dwDstSamples, pwfSrc->wf.nSamplesPerSec,
                                            pwfDst->wf.nSamplesPerSec ) )  &&
        (dwSrcSamples >  MulDivRD( dwDstSamples, pwfSrc->wf.nSamplesPerSec,
                                            pwfDst->wf.nSamplesPerSec ) )  )
    {
        fPartialSampleAtTheEnd = TRUE;
    }
    else
    {
        fPartialSampleAtTheEnd = FALSE;

        //
        //  we will only use complete samples, so drop unused partial samples
        //  
        //
        dwSrcSamples = PCM_BYTESTOSAMPLES(pwfSrc, padsh->cbSrcLength);

        DPF(4, "adjust source samples: BEGIN %lu", dwSrcSamples);
        for (;;)
        {
            cbDst = MulDivRU(dwSrcSamples,
                            pwfDst->wf.nSamplesPerSec,
                            pwfSrc->wf.nSamplesPerSec);

            cbDst = PCM_SAMPLESTOBYTES(pwfDst, cbDst);

            if (padsh->cbDstLength >= cbDst)
            {
                break;
            }

            DPF(4, "adjusting source samples");
            dwSrcSamples--;
        }
        DPF(4, "adjust source samples: END %lu", dwSrcSamples);
    }

    cb = PCM_SAMPLESTOBYTES(pwfSrc, dwSrcSamples);

    padsh->cbSrcLengthUsed = cb;

    cb = (* fnConvert)( pwfSrc,
                        padsh->pbSrc,
                        pwfDst,
                        padsh->pbDst,
                        dwSrcSamples,
                        fPartialSampleAtTheEnd,
                        padsh->pbDst + padsh->cbDstLength );


    //
    //  If we used the fPartialSampleAtTheEnd flag, then we should have
    //  completely filled the destination block.
    //
    ASSERT( (!fPartialSampleAtTheEnd) || (cb==padsh->cbDstLength) );


    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in acmdStreamSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = cb;

    return (MMSYSERR_NOERROR);
} // acmdStreamConvert()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT pcmDriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNWCALLBACK pcmDriverProc
(
    DWORD_PTR               dwId,
    HACMDRIVERID            hadid,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PCODECINST          pci;

    //
    //  make pci either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on BOGUS_DRIVER_ID.
    //
    pci = (dwId == BOGUS_DRIVER_ID) ? NULL : (PCODECINST)dwId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
        case DRV_FREE:
            return (1L);


        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            lr = acmdDriverOpen(NULL, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
            lr = acmdDriverClose(pci);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            lr = acmdDriverConfigure(pci, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            lr = acmdDriverDetails(pci, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            lr = acmdDriverAbout(pci, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
       case ACMDM_FORMAT_SUGGEST:
            lr = acmdFormatSuggest(pci, (LPACMDRVFORMATSUGGEST)lParam1);
            return (lr);


        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
            lr = acmdFormatTagDetails(pci, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            lr = acmdFormatDetails(pci, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            lr = acmdStreamOpen(pci, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            lr = acmdStreamClose(pci, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
            lr = acmdStreamSize(pci, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
            lr = acmdStreamConvert(pci, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMHEADER)lParam2);
            return (lr);
    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);

#if 0
    return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
#else
    //
    //  if installed as a _function_ instead of as an installable driver,
    //  just return 0L for non-ACM messages we don't handle
    //
    return (0L);
#endif
} // pcmDriverProc()


#endif // WIN32 || NTWOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\pcm.h ===
//==========================================================================;
//
//  pcm.h
//
//  Description:
//
//
//  History:
//      11/15/92    cjp     [curtisp] 
//
//==========================================================================;


//
//  misc. defines
//
//
#define VERSION_CODEC_MAJOR     MMVERSION
#define VERSION_CODEC_MINOR     MMREVISION
#define VERSION_CODEC_BUILD	0

#define VERSION_CODEC       MAKE_ACM_VERSION(VERSION_CODEC_MAJOR,   \
                                             VERSION_CODEC_MINOR,   \
                                             VERSION_CODEC_BUILD)

#define ICON_CODEC              RCID(12)

#define MSPCM_MAX_CHANNELS          2           // max channels we deal with


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwf argument is a pointer to a PCMWAVEFORMAT structure.
//
#define PCM_BLOCKALIGNMENT(pwf)     (UINT)(((pwf)->wBitsPerSample >> 3) << ((pwf)->wf.nChannels >> 1))
#define PCM_BYTESTOSAMPLES(pwf, dw) (DWORD)(dw / PCM_BLOCKALIGNMENT(pwf))
#define PCM_SAMPLESTOBYTES(pwf, dw) (DWORD)(dw * PCM_BLOCKALIGNMENT(pwf))



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef IDS_MSPCM_TAG
    #define IDS_MSPCM_TAG           0
#endif

#define IDS_CODEC_SHORTNAME         (IDS_MSPCM_TAG+0)
#define IDS_CODEC_LONGNAME          (IDS_MSPCM_TAG+1)
#define IDS_CODEC_COPYRIGHT         (IDS_MSPCM_TAG+2)
#define IDS_CODEC_LICENSING         (IDS_MSPCM_TAG+3)
#define IDS_CODEC_FEATURES          (IDS_MSPCM_TAG+5)


//
//
//
EXTERN_C LRESULT FNWCALLBACK pcmDriverProc
(
    DWORD_PTR               dwID,
    HACMDRIVERID            hadid,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\prmval32.c ===
/****************************************************************************
    prmval32.c

    msacm

    Copyright (c) 1993-1998 Microsoft Corporation

****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "acmi.h"
#include "debug.h"


void FAR _cdecl DebugOutput
(
    UINT                    flags,
    LPCSTR                  lpsz,
    ...
)
{

    //
    //  what should we do???
    //

}




/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateReadPointer | validates that a pointer is valid to
 *  read from.
 *
 * @parm LPVOID | lpPoint| pointer to validate
 * @parm DWORD  | dLen   | supposed length of said pointer
 *
 * @rdesc Returns TRUE  if <p> is a valid pointer
 *        Returns FALSE if <p> is not a valid pointer
 *
 * @comm will generate error if the pointer is invalid
 *
 ***************************************************************************/

BOOL FNGLOBAL ValidateReadPointer(const void FAR* pPoint, DWORD Len)
{
    // For now just check access to first and last byte

    try {
        volatile BYTE b;
        b = ((PBYTE)pPoint)[0];
        b = ((PBYTE)pPoint)[Len - 1];
    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_PTR, 0, pPoint);
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateWritePointer | validates that a pointer is valid to
 *  write to.
 *
 * @parm LPVOID | lpPoint| pointer to validate
 * @parm DWORD  | dLen   | supposed length of said pointer
 *
 * @rdesc Returns TRUE  if <p> is a valid pointer
 *        Returns FALSE if <p> is not a valid pointer
 *
 * @comm will generate error if the pointer is invalid
 *
 ***************************************************************************/
BOOL FNGLOBAL ValidateWritePointer(const void FAR* pPoint, DWORD Len)
{
    // For now just check read and write access to first and last byte

    try {
           volatile BYTE b;
           b = ((PBYTE)pPoint)[0];
           ((PBYTE)pPoint)[0] = b;
           b = ((PBYTE)pPoint)[Len - 1];
           ((PBYTE)pPoint)[Len - 1] = b;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_PTR, 0, pPoint);
        return FALSE;
    }
    return TRUE;
}


BOOL FNGLOBAL ValidateReadWaveFormat(LPWAVEFORMATEX pwfx)
{
    //
    //
    //
    if (!ValidateReadPointer(pwfx, sizeof(PCMWAVEFORMAT)))
    {
	return (FALSE);
    }

    if (WAVE_FORMAT_PCM == pwfx->wFormatTag)
    {
	return (TRUE);
    }

    if (!ValidateReadPointer(&(pwfx->cbSize), sizeof(pwfx->cbSize)))
    {
	return (FALSE);
    }

    if (0 == pwfx->cbSize)
    {
	return (TRUE);
    }

    if (!ValidateReadPointer(&(pwfx->cbSize), pwfx->cbSize + sizeof(pwfx->cbSize)))
    {
	return (FALSE);
    }

    return (TRUE);
}


BOOL FNGLOBAL ValidateReadWaveFilter(LPWAVEFILTER pwf)
{
    //
    //
    //
    if (!ValidateReadPointer(&(pwf->cbStruct), sizeof(pwf->cbStruct)))
    {
	return (FALSE);
    }

    if (pwf->cbStruct < sizeof(WAVEFILTER))
    {
	return (FALSE);
    }

    if (!ValidateReadPointer(pwf, pwf->cbStruct))
    {
	return (FALSE);
    }

    return (TRUE);
}


BOOL FNGLOBAL ValidateCallback(FARPROC lpfnCallback)
{
    if (IsBadCodePtr(lpfnCallback))
    {
        LogParamError(ERR_BAD_CALLBACK, 0, lpfnCallback);
        return FALSE;
    }

    return (TRUE);
}

/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidDriverCallback |
 *
 *  validates that a driver callback is valid, to be valid a driver
 *  callback must be a valid window, task, or a function in a FIXED DLL
 *  code segment.
 *
 * @parm DWORD  | dwCallback | callback to validate
 * @parm DWORD  | wFlags     | driver callback flags
 *
 * @rdesc Returns 0  if <dwCallback> is a valid callback
 *        Returns error condition if <dwCallback> is not a valid callback
 ***************************************************************************/

BOOL FNGLOBAL ValidateDriverCallback(DWORD_PTR hCallback, UINT dwFlags)
{
    switch (dwFlags & DCB_TYPEMASK) {
    case DCB_WINDOW:
        if (!IsWindow((HWND)hCallback)) {
            LogParamError(ERR_BAD_HWND, 0, hCallback);
            return FALSE;
        }
        break;

    case DCB_TASK:
        //if (IsBadCodePtr((FARPROC)hCallback)) {
        //    LogParamError(ERR_BAD_CALLBACK, 0, hCallback);
        //    return FALSE;
        //}
        break;

    case DCB_FUNCTION:
        if (IsBadCodePtr((FARPROC)hCallback)) {
            LogParamError(ERR_BAD_CALLBACK, 0, hCallback);
            return FALSE;
        }
        break;
    }

    return TRUE;
}

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateString |
 *
 **************************************************************************/
BOOL FNGLOBAL ValidateStringA(LPCSTR pPoint, UINT Len)
{
    // For now just check access - do a 'strnlen'

    try {
           volatile BYTE b;
           LPCSTR p = pPoint;

           while (Len--) {
               b = *p;
               if (!b) {
                   break;
               }
               p++;
           }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_STRING_PTR, 0, pPoint);
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateStringW |
 *
 **************************************************************************/
BOOL FNGLOBAL ValidateStringW(LPCWSTR pPoint, UINT Len)
{
    // For now just check access - do a 'strnlen'

    try {
           volatile WCHAR b;
           LPCWSTR p = pPoint;

           while (Len--) {
               b = *p;
               if (!b) {
                   break;
               }
               p++;
           }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_STRING_PTR, 0, pPoint);
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateHandle | validates a handle created with NewHandle
 *
 * @parm PHNDL | hLocal | handle returned from NewHandle
 * @parm UINT  | wType  | unique id describing handle type
 *
 * @rdesc Returns TRUE  if <h> is a valid handle of type <wType>
 *        Returns FALSE if <h> is not a valid handle
 *
 * @comm  if the handle is invalid an error will be generated.
 *
 **************************************************************************/
BOOL FNGLOBAL ValidateHandle(HANDLE hLocal, UINT uType)
{
   BOOL OK;

   try {
#if 0
       OK = HtoPH(hLocal)->uHandleType == uType;
#else
        if (TYPE_HACMOBJ == uType)
        {
            switch (((PACMDRIVERID)hLocal)->uHandleType)
            {
                case TYPE_HACMDRIVERID:
                case TYPE_HACMDRIVER:
                case TYPE_HACMSTREAM:
                    OK = TRUE;
                    break;

                default:
                    OK = FALSE;
                    break;
            }
        }
        else
        {
            OK = (uType == ((PACMDRIVERID)hLocal)->uHandleType);
        }
#endif

    } except(EXCEPTION_EXECUTE_HANDLER) {
      LogParamError(ERR_BAD_HANDLE, 0, hLocal);
      return FALSE;
   }

   return OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\profile.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1994-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  profile.c
//
//  Description:
//      This file contains routines to access the registry directly.  You
//      must include profile.h to use these routines.
//
//      All keys are opened under the following key:
//
//          HKEY_CURRENT_USER\Software\Microsoft\Multimedia\Audio
//                                                  Compression Manager
//
//      Keys should be opened at boot time, and closed at shutdown.
//
//==========================================================================;

#if defined(WIN32) && !defined(WIN4)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#endif

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <process.h>
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "uchelp.h"
#include "pcm.h"
#include "profile.h"

#include "debug.h"


const TCHAR gszAcmProfileKey[] =
        TEXT("Software\\Microsoft\\Multimedia\\Audio Compression Manager\\");

const TCHAR gszAudioProfileKey[] =
	TEXT("Software\\Microsoft\\Multimedia\\Audio\\");



//--------------------------------------------------------------------------;
//
//  HKEY IRegOpenKeyAcm
//
//  Description:
//      This routine opens a sub key under the default ACM key.  We allow
//      all access to the key.
//
//  Arguments:
//      LPCTSTR pszKeyName:  Name of the sub key.
//
//  Return (HKEY):  Handle to the opened key, or NULL if the request failed.
//
//--------------------------------------------------------------------------;

DWORD MsacmError = 0;
LPSTR MsacmErrorDesc = NULL;

HKEY FNGLOBAL IRegOpenKeyAcm
(
    LPCTSTR             pszKeyName
)
{
    LONG    lReturn;
    HKEY    hkeyAcm = NULL;
    HKEY    hkeyRet = NULL;

    ASSERT( NULL != pszKeyName );


#if defined(WIN32) && !defined(WIN4)
    {
        HANDLE  hRoot;

        if(!NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hRoot)))
        {
            DPF(1,"IRegOpenKeyAcm: Unable to open current user profile.");
	    MsacmError = GetLastError();
	    MsacmErrorDesc = "IRegOpenKeyAcm: Unable to open current user profile.";
	    ASSERT(FALSE);
            return NULL;
        }

	lReturn = RegCreateKeyEx( hRoot, gszAcmProfileKey, 0, NULL, 0,
				  KEY_WRITE, NULL, &hkeyAcm, NULL );
	if (lReturn)
	{
	    MsacmError = lReturn;
	    MsacmErrorDesc = "IRegOpenKeyAcm: Unable to create gszAcmProfileKey";
	    ASSERT(FALSE);
	}
	
        NtClose(hRoot);
    }
#else
    XRegCreateKeyEx( HKEY_CURRENT_USER, gszAcmProfileKey, 0, NULL, 0,
                       KEY_WRITE, NULL, &hkeyAcm, NULL );
#endif


    if( NULL != hkeyAcm )
    {
        if (XRegCreateKeyEx( hkeyAcm, pszKeyName, 0, NULL, 0,
			      KEY_WRITE | KEY_READ, NULL, &hkeyRet, NULL ))
	{
	    MsacmError = GetLastError();
	    MsacmErrorDesc = "IRegOpenKeyAcm: Unable to create pszKeyName";
	    ASSERT(FALSE);
	}

        XRegCloseKey( hkeyAcm );
    }

    return hkeyRet;
}


//--------------------------------------------------------------------------;
//
//  HKEY IRegOpenKeyAudio
//
//  Description:
//      This routine opens the multimedia Audio key or one of its subkeys.
//	We allow all access to the key.
//
//  Arguments:
//      LPCTSTR pszKeyName:  Name of the sub key.  NULL to open the audio key.
//
//  Return (HKEY):  Handle to the opened key, or NULL if the request failed.
//
//--------------------------------------------------------------------------;

HKEY FNGLOBAL IRegOpenKeyAudio
(
    LPCTSTR             pszKeyName
)
{
    HKEY    hkeyAudio	= NULL;
    HKEY    hkeyRet	= NULL;

    XRegCreateKeyEx( HKEY_CURRENT_USER, gszAudioProfileKey, 0, NULL, 0,
                       KEY_WRITE, NULL, &hkeyAudio, NULL );

    if (NULL == pszKeyName) {
	return hkeyAudio;
    }

    if( NULL != hkeyAudio )
    {
        XRegCreateKeyEx( hkeyAudio, pszKeyName, 0, NULL, 0,
                    KEY_WRITE | KEY_READ, NULL, &hkeyRet, NULL );

        XRegCloseKey( hkeyAudio );
    }

    return hkeyRet;
}


//--------------------------------------------------------------------------;
//
//  BOOL IRegReadString
//
//  Description:
//      This routine reads a value from an opened registry key.  The return
//      value indicates success or failure.  If the HKEY is NULL, we return
//      a failure.  Note that there is no default string...
//
//  Arguments:
//      HKEY hkey:          An open registry key.  If NULL, we fail.
//      LPCTSTR pszValue:   Name of the value.
//      LPTSTR pszData:     Buffer to store the data in.
//      DWORD cchData:      Size (in chars) of the buffer.
//
//  Return (BOOL):  TRUE indicates success.  If the return is FALSE, you
//      can't count on the data in pszData - it might be something weird.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IRegReadString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPTSTR              pszData,
    DWORD               cchData
)
{

    DWORD   dwType = (DWORD)~REG_SZ;  // Init to anything but REG_SZ.
    DWORD   cbData;
    LONG    lError;

    ASSERT( NULL != hkey );
    ASSERT( NULL != pszValue );
    ASSERT( NULL != pszData );
    ASSERT( cchData > 0 );


    cbData = sizeof(TCHAR) * cchData;

    lError = XRegQueryValueEx( hkey,
                              (LPTSTR)pszValue,
                              NULL,
                              &dwType,
                              (LPBYTE)pszData,
                              &cbData );

    return ( ERROR_SUCCESS == lError  &&  REG_SZ == dwType );
}


//--------------------------------------------------------------------------;
//
//  DWORD IRegReadDwordDefault
//
//  Description:
//      This routine reads a given value from the registry, and returns a
//      default value if the read is not successful.
//
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPCTSTR  pszValue:
//      DWORD   dwDefault:
//
//  Return (DWORD):
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL IRegReadDwordDefault
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwDefault
)
{
    DWORD   dwType = (DWORD)~REG_DWORD;  // Init to anything but REG_DWORD.
    DWORD   cbSize = sizeof(DWORD);
    DWORD   dwRet  = 0;
    LONG    lError;

    ASSERT( NULL != hkey );
    ASSERT( NULL != pszValue );


    lError = XRegQueryValueEx( hkey,
                              (LPTSTR)pszValue,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwRet,
                              &cbSize );

    //
    //  Really we should have a test like this:
    //
    //      if( ERROR_SUCCESS != lError  ||  REG_DWORD != dwType )
    //
    //  But, the Chicago RegEdit will not let you enter REG_DWORD values,
    //  it will only let you enter REG_BINARY values, so that test is
    //  too strict.  Just test for no error instead.
    //
    if( ERROR_SUCCESS != lError )
        dwRet = dwDefault;

    return dwRet;
}

#ifndef _WIN64
//==========================================================================;
//
//  XReg... thunks
//
//--------------------------------------------------------------------------;
//
//  The 16-bit code calls XRegCloseKey, XRegCreateKey, etc, functions to
//  access the registry.  These functions are implemented below.
//
//  We have one function on the 32-bit side that we call from the 16-bit
//  side.  This function is XRegThunkEntry.  All of the 16-bit XRegXXX
//  call the 32-bit XRegThunkEntry.  When calling XRegThunkEntry we
//  pass a value which identifies the real 32-bit registry API we wish to
//  call along with all the associated parameters for the API.
//
//==========================================================================;

//
//  These identify which registry API we want to call via
//  the thunked function.
//

enum {
    XREGTHUNKCLOSEKEY,
    XREGTHUNKCREATEKEY,
    XREGTHUNKDELETEKEY,
    XREGTHUNKDELETEVALUE,
    XREGTHUNKENUMKEYEX,
    XREGTHUNKENUMVALUE,
    XREGTHUNKOPENKEY,
    XREGTHUNKOPENKEYEX,
    XREGTHUNKQUERYVALUEEX,
    XREGTHUNKSETVALUEEX
};


#ifdef WIN32
//--------------------------------------------------------------------------;
//
//  32-bit
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
//  XRegThunkEntry
//
//  This function is called from the 16-bit side.  All calls from 16-bit to
//  registry APIs pass thru this function.
//
//  Arguments:
//	DWORD iThunk : identifies which registry API to call.
//
//	DWORD dw1, ..., dwN : parameters to pass to the registry API
//	    identified by iThunk.  Any necessary translation of the
//	    parameters (eg, segmented to linear pointer) has already
//	    been done.
//
//  Return value(DWORD) :
//	Return code from the called registry API
//
//---------------------------------------------------------------------------;
DWORD XRegThunkEntry(DWORD iThunk, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5, DWORD dw6, DWORD dw7, DWORD dw8)
{
    DWORD Rc;

    switch (iThunk)
    {
	case XREGTHUNKCLOSEKEY:
	    return (DWORD)RegCloseKey( (HKEY)dw1 );
	case XREGTHUNKCREATEKEY:
        {
            HKEY hKey;
	    Rc = (DWORD)RegCreateKeyA( (HKEY)dw1, (LPCSTR)dw2, &hKey );

            if ( Rc == ERROR_SUCCESS ) {
              *((UNALIGNED HKEY *)dw3) = hKey;
            }
            return Rc;
        }
	case XREGTHUNKDELETEKEY:
	    return (DWORD)RegDeleteKeyA( (HKEY)dw1, (LPCSTR)dw2 );
	case XREGTHUNKDELETEVALUE:
	    return (DWORD)RegDeleteValueA( (HKEY)dw1, (LPSTR)dw2 );
	case XREGTHUNKENUMKEYEX:
        {
            DWORD    dwTemp4 ;
            DWORD    dwTemp7 ;
            FILETIME FileTime;
	    Rc = (DWORD)RegEnumKeyExA( (HKEY)dw1,
                                       (DWORD)dw2,
                                       (LPSTR)dw3,
                                       dw4 == 0 ? NULL : &dwTemp4,
                                       (LPDWORD)dw5,
                                       (LPSTR)dw6,
                                       dw7 == 0 ? NULL : &dwTemp7,
                                       dw8 == 0 ? NULL : &FileTime );
            if ( Rc == ERROR_SUCCESS ) {
                if ( dw4 != 0 )
                    *((UNALIGNED DWORD *) dw4) = dwTemp4 ;
                if ( dw7 != 0 )
                    *((UNALIGNED DWORD *) dw7) = dwTemp7 ;
                if ( dw8 != 0 )
                    *((UNALIGNED FILETIME *)dw8) = FileTime ;
            }

            return Rc ;
        }
	case XREGTHUNKENUMVALUE:
        {
            DWORD dwTemp4, dwTemp6, dwTemp8;
	    Rc = (DWORD) RegEnumValueA( (HKEY)dw1,
                                        (DWORD)dw2,
                                        (LPSTR)dw3,
                                        dw4 == 0 ? NULL : &dwTemp4,
                                        (LPDWORD)dw5,
                                        dw6 == 0 ? NULL : &dwTemp6,
                                        (LPBYTE)dw7,
                                        dw8 == 0 ? NULL : &dwTemp8 );
            if ( Rc == ERROR_SUCCESS ) {
                if ( dw4 != 0 )
                    *((UNALIGNED DWORD *) dw4) = dwTemp4 ;
                if ( dw6 != 0 )
                    *((UNALIGNED DWORD *) dw6) = dwTemp6 ;
                if ( dw8 != 0 )
                    *((UNALIGNED DWORD *) dw8) = dwTemp8 ;
            }

            return Rc ;
        }
	case XREGTHUNKOPENKEY:
        {
            HKEY hKey;
	    Rc = (DWORD)RegOpenKeyA( (HKEY)dw1, (LPCSTR)dw2, &hKey );

            if ( Rc == ERROR_SUCCESS ) {
              *((UNALIGNED HKEY *)dw3) = hKey;
            }
            return Rc ;
        }
	case XREGTHUNKOPENKEYEX:
        {
            HKEY hKey;
	    Rc = (DWORD)RegOpenKeyExA( (HKEY)dw1, (LPCSTR)dw2, dw3, (REGSAM)dw4, &hKey );

            if ( Rc == ERROR_SUCCESS ) {
              *((UNALIGNED HKEY *) dw5) = hKey;
            }
            return Rc ;
        }
	case XREGTHUNKQUERYVALUEEX:
        {
            DWORD dwTemp4, dwTemp6 ;
	    Rc = (DWORD) RegQueryValueExA( (HKEY)dw1,
                                           (LPSTR)dw2,
                                           (LPDWORD)dw3,
                                           dw4 == 0 ? NULL : &dwTemp4,
                                           (LPBYTE)dw5,
                                           dw6 == 0 ? NULL : &dwTemp6);

            if ( Rc == ERROR_SUCCESS  || Rc == ERROR_MORE_DATA ) {
                if ( dw4 != 0 )
                    *((UNALIGNED DWORD *) dw4) = dwTemp4 ;
                if ( dw6 != 0 )
                    *((UNALIGNED DWORD *) dw6) = dwTemp6 ;
            }

            return Rc ;
        }
	case XREGTHUNKSETVALUEEX:
	    return (DWORD)RegSetValueExA( (HKEY)dw1,
                                          (LPCSTR)dw2,
                                          (DWORD)dw3,
                                          (DWORD)dw4,
                                          (CONST BYTE *)dw5,
                                          (DWORD)dw6 );
	default:
	    ASSERT( FALSE );
	    return (DWORD)ERROR_BADDB;
    }
}

#else	// WIN32
//---------------------------------------------------------------------------;
//
//  16-bit
//
//---------------------------------------------------------------------------;

#ifdef XREGTHUNK

//
//  If we want to use this code for Windows 95 then we'll probably need
//  to GlobalFix all the pointers before they are thunked.  So, just to set
//  off an alarm, let's generate an error when this code gets compiled not
//  for NTWOW
//
#ifndef NTWOW
#error REGISTRY THUNKS WON'T WORK IN WINDOWS 95
#endif

//---------------------------------------------------------------------------;
//
//  XReg funcions
//
//  These are analogous to the 32-bit registry APIs.  Each of these simply
//  thnks to the corresponding 32-bit registry API.
//
//---------------------------------------------------------------------------;

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegCloseKey( HKEY hkey )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKCLOSEKEY,
                                          (DWORD)hkey,
					  0, 0, 0, 0, 0, 0, 0,
					  pag->lpvXRegThunkEntry,
					  0, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegCreateKey( HKEY hkey, LPCTSTR lpszSubKey, PHKEY phkResult )
{
    PACMGARB pag;
    LONG     lr;

    DPF(4, "XRegCreateKey()");

    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKCREATEKEY,
                                         (DWORD)hkey,
					 (DWORD)lpszSubKey,
					 (DWORD)phkResult,
					 0, 0, 0, 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000060L, 9 );

    return (lr);

}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegDeleteKey( HKEY hkey, LPCTSTR lpszSubKey )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKDELETEKEY,
                                         (DWORD)hkey,
					 (DWORD)lpszSubKey,
					 0, 0, 0, 0, 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000040, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegDeleteValue( HKEY hkey, LPTSTR lpszValue )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKDELETEVALUE,
                                         (DWORD)hkey,
					 (DWORD)lpszValue,
					 0, 0, 0, 0, 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000040, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegEnumKeyEx( HKEY hkey, DWORD iSubKey, LPTSTR lpszName, LPDWORD lpcchName, LPDWORD lpdwReserved, LPTSTR lpszClass, LPDWORD lpcchClass, PFILETIME lpftLastWrite )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKENUMKEYEX,
                                         (DWORD)hkey,
					 (DWORD)iSubKey,
					 (DWORD)lpszName,
					 (DWORD)lpcchName,
					 (DWORD)lpdwReserved,
					 (DWORD)lpszClass,
					 (DWORD)lpcchClass,
					 (DWORD)lpftLastWrite,
					 pag->lpvXRegThunkEntry,
					 0x0000003F, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegEnumValue( HKEY hkey, DWORD iValue, LPTSTR lpszValue, LPDWORD lpcchValue, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKENUMVALUE,
                                         (DWORD)hkey,
					 (DWORD)iValue,
					 (DWORD)lpszValue,
					 (DWORD)lpcchValue,
					 (DWORD)lpdwReserved,
					 (DWORD)lpdwType,
					 (DWORD)lpbData,
					 (DWORD)lpcbData,
					 pag->lpvXRegThunkEntry,
					 0x0000003F, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegOpenKey( HKEY hkey, LPCTSTR lpszSubKey, PHKEY phkResult )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKOPENKEY,
                                         (DWORD)hkey,
					 (DWORD)lpszSubKey,
					 (DWORD)phkResult,
					 0, 0, 0, 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000060, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegOpenKeyEx( HKEY hkey, LPCTSTR lpszSubKey, DWORD dwReserved, REGSAM samDesired, PHKEY phkResult )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKOPENKEYEX,
                                         (DWORD)hkey,
					 (DWORD)lpszSubKey,
					 (DWORD)dwReserved,
					 (DWORD)samDesired,
					 (DWORD)phkResult,
					 0, 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000048, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegQueryValueEx( HKEY hkey, LPTSTR lpszValueName, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKQUERYVALUEEX,
                                         (DWORD)hkey,
					 (DWORD)lpszValueName,
					 (DWORD)lpdwReserved,
					 (DWORD)lpdwType,
					 (DWORD)lpbData,
					 (DWORD)lpcbData,
					 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x0000007C, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegSetValueEx
(
 HKEY hkey,
 LPCTSTR lpszValueName,
 DWORD dwReserved, DWORD fdwType, CONST LPBYTE lpbData, DWORD cbData )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKSETVALUEEX,
                                         (DWORD)hkey,
					 (DWORD)lpszValueName,
					 (DWORD)dwReserved,
					 (DWORD)fdwType,
					 (DWORD)lpbData,
					 (DWORD)cbData,
					 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000048, 9 );

    return (lr);
}

#endif // XREGTHUNK

#endif // !_WIN32
#endif // !_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\profile.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1994-1995 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  profile.h
//
//  Description:
//
//      This file contains definitions supporting the code in profile.c
//      which accesses the registry directly.
//
//==========================================================================;

#ifndef _PROFILE_H_
#define _PROFILE_H_

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#ifndef INLINE
    #define INLINE __inline
#endif

//--------------------------------------------------------------------------;
//
//  We really need to clean up all these #defines and typdefs!!!
//
    
//
//  The Chicago Win16 header files are messed up somehow, so we have to
//  define this stuff ourselves.
//
#ifndef REG_DWORD
#pragma message("profile.h: Manually defining REG_DWORD!!!")
#define REG_DWORD  ( 4 )
#endif

#ifndef REG_BINARY
#pragma message("profile.h: Manually defining REG_BINARY!!!")
#define REG_BINARY  ( 3 )
#endif

#ifndef HKEY_LOCAL_MACHINE
#pragma message("profile.h: Manually defining HKEY_LOCAL_MACHINE!!!")
#define HKEY_LOCAL_MACHINE (( HKEY ) 0x80000002 )
#endif

#ifndef HKEY_CURRENT_USER
#pragma message("profile.h: Manually defining HKEY_CURRENT_USER!!!")
#define HKEY_CURRENT_USER (( HKEY ) 0x80000001 )
#endif

#ifndef KEY_QUERY_VALUE
#pragma message("profile.h: Manually defining KEY_*!!!")
     
#define KEY_QUERY_VALUE         (0x0001)
#define KEY_SET_VALUE           (0x0002)
#define KEY_CREATE_SUB_KEY      (0x0004)
#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
#define KEY_NOTIFY              (0x0010)
#define KEY_CREATE_LINK         (0x0020)

#define KEY_READ                ( KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY )

#define KEY_WRITE               ( KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY )
#endif

#ifndef ERROR_SUCCESS
#pragma message("profile.h: Manually defining ERROR_SUCCESS!!!")
#define ERROR_SUCCESS  0L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#pragma message("profile.h: Manually defining ERROR_NO_MORE_ITEMS!!!")
#define ERROR_NO_MORE_ITEMS 259L
#endif


//--------------------------------------------------------------------------;
//
//  Ghost registry APIs.  Since NTWOW doesn't support most of the registry
//  APIs, we use XRegBlahBlahBlah instead of RegBlahBlahBlah in all the ACM
//  source code.  For NTWOW, these XReg calls are thunked to the 32-bit
//  side; for other builds, they are simply #define-d to the normal
//  registry calls.
//
//  If you define XREGTHUNK, the thunks get compiled in.
//  
//--------------------------------------------------------------------------;

#ifdef NTWOW
#define XREGTHUNK
#endif


#ifdef XREGTHUNK

#if (WINVER < 0x0400)
typedef HKEY FAR* PHKEY;
typedef struct tFILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR* PFILETIME;
#endif
typedef ULONG ACCESS_MASK;
typedef ACCESS_MASK REGSAM;

LONG FNGLOBAL XRegCloseKey( HKEY hkey );
LONG FNGLOBAL XRegCreateKey( HKEY hkey, LPCTSTR lpszSubKey, PHKEY phkResult );
LONG FNGLOBAL XRegDeleteKey( HKEY hkey, LPCTSTR lpszSubKey );
LONG FNGLOBAL XRegDeleteValue( HKEY hkey, LPTSTR lpszValue );
LONG FNGLOBAL XRegEnumKeyEx( HKEY hkey, DWORD iSubKey, LPTSTR lpszName, LPDWORD lpcchName, LPDWORD lpdwReserved, LPTSTR lpszClass, LPDWORD lpcchClass, PFILETIME lpftLastWrite );
LONG FNGLOBAL XRegEnumValue( HKEY hkey, DWORD iValue, LPTSTR lpszValue, LPDWORD lpcchValue, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData );
LONG FNGLOBAL XRegOpenKey( HKEY hkey, LPCTSTR lpszSubKey, PHKEY phkResult );
LONG FNGLOBAL XRegOpenKeyEx( HKEY hkey, LPCTSTR lpszSubKey, DWORD dwReserved, REGSAM samDesired, PHKEY phkResult );
LONG FNGLOBAL XRegQueryValueEx( HKEY hkey, LPTSTR lpszValueName, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData );
LONG FNGLOBAL XRegSetValueEx( HKEY hkey, LPCTSTR lpszValueName, DWORD dwReserved, DWORD fdwType, CONST LPBYTE lpbData, DWORD cbData );

//  This way we don't have to thunk RegCreateKeyEx.
#define XRegCreateKeyEx( hkey, lpszSubKey, a, b, c, d, e, phkResult, f ) XRegCreateKey( hkey, lpszSubKey, phkResult )


#else // !XREGTHUNK


#define XRegCloseKey        RegCloseKey
#define XRegCreateKey       RegCreateKey
#define XRegDeleteKey       RegDeleteKey
#define XRegDeleteValue     RegDeleteValue
#define XRegEnumKeyEx       RegEnumKeyEx
#define XRegEnumValue       RegEnumValue
#define XRegOpenKey         RegOpenKey
#define XRegOpenKeyEx       RegOpenKeyEx
#define XRegQueryValueEx    RegQueryValueEx
#define XRegSetValueEx      RegSetValueEx

#ifndef WIN32   // Chicago Win16 doesn't support RegCreateKeyEx.
#define XRegCreateKeyEx( hkey, lpszSubKey, a, b, c, d, e, phkResult, f ) RegCreateKey( hkey, lpszSubKey, phkResult )
#else
#define XRegCreateKeyEx     RegCreateKeyEx
#endif


#endif // !XREGTHUNK




//--------------------------------------------------------------------------;
//
//  Function Prototypes from profile.c
//  
//--------------------------------------------------------------------------;

HKEY FNGLOBAL IRegOpenKeyAcm
(
    LPCTSTR pszKeyName
);

HKEY FNGLOBAL IRegOpenKeyAudio
(
    LPCTSTR pszKeyName
);

BOOL FNGLOBAL IRegReadString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPTSTR              pszData,
    DWORD               cchData
);

DWORD FNGLOBAL IRegReadDwordDefault
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwDefault
);



//--------------------------------------------------------------------------;
//  
//  VOID IRegWriteString
//  
//  Description:
//      This routine writes a value to an opened registry key.  If the key
//      is NULL, we return without doing anything.
//  
//  Arguments:
//      HKEY hkey:          An open registry key.
//      LPCTSTR pszValue:   Name of the value.
//      LPCTSTR pszData:    The data to write.
//  
//--------------------------------------------------------------------------;

INLINE VOID IRegWriteString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPCTSTR             pszData
)
{
    XRegSetValueEx( hkey, pszValue, 0L, REG_SZ, (LPBYTE)pszData,
                    sizeof(TCHAR) * (1+lstrlen(pszData)) );
}


//--------------------------------------------------------------------------;
//  
//  VOID IRegWriteDword
//  
//  Description:
//      This routine writes a DWORD to the given value an open key.
//  
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPCTSTR  pszValue:
//      DWORD   dwData:
//  
//  Return (DWORD):
//  
//--------------------------------------------------------------------------;

INLINE VOID IRegWriteDword
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwData
)
{
    XRegSetValueEx( hkey, pszValue, 0, REG_DWORD,
                    (LPBYTE)&dwData, sizeof(DWORD) );
}


//--------------------------------------------------------------------------;
//  
//  VOID IRegWriteBinary
//  
//  Description:
//      This routine writes a binary data to the given value in an open key.
//  
//  Arguments:
//      HKEY hkey:               Registry key to read from.
//      LPCTSTR pszValue:
//      LPBYTE lpData:
//	DWORD cbSize:
//  
//  Return (DWORD):
//  
//--------------------------------------------------------------------------;

INLINE VOID IRegWriteBinary
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPBYTE		lpData,
    DWORD		cbSize
)
{
    XRegSetValueEx( hkey, pszValue, 0, REG_BINARY, lpData, cbSize );
}


//--------------------------------------------------------------------------;
//  
//  BOOL IRegValueExists
//  
//  Description:
//      This routine returns TRUE if the specified value exists in the
//      key; otherwise FALSE is returned.
//  
//  Arguments:
//      HKEY hkey:          An open registry key.
//      LPCTSTR pszValue:   Name of the value.
//
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

INLINE BOOL IRegValueExists
(
    HKEY                hkey,
    LPCTSTR             pszValue
)
{
    return ( ERROR_SUCCESS == XRegQueryValueEx( hkey, (LPTSTR)pszValue,
                                               NULL, NULL, NULL, NULL ) );
}


//--------------------------------------------------------------------------;
//  
//  VOID IRegCloseKey
//  
//  Description:
//      Closes an open key (but only if it's non-NULL).
//  
//--------------------------------------------------------------------------;

INLINE VOID IRegCloseKey
(
    HKEY                hkey
)
{
    if( NULL != hkey )
    {
        XRegCloseKey( hkey );
    }
}


#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\pcmconv.c ===
/* Copyright (c) 1994 Microsoft Corporation */
//==========================================================================;
//
//  pcmconv.c
//
//  Description:
//      This module contains conversion routines for PCM data.
//
//  History:
//      11/21/92    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "pcm.h"
#include "debug.h"

#ifdef WIN32
#define HUGE_T  UNALIGNED
#else
#define HUGE_T  _huge
#endif

//
//
//
//
#if defined(WIN32) || defined(DEBUG)


//--------------------------------------------------------------------------;
//
//  LPBYTE pcmReadSample_dddsss
//
//  Description:
//      These functions read a sample from the source stream in the format
//      specified by 'sss' and return the data in the destination 'ddd'
//      format in *pdw.
//
//      For example, the pcmReadSample_M16S08 function reads source data
//      that is in Stereo 8 Bit format and returns an appropriate sample
//      for the destination as Mono 16 Bit.
//
//  Arguments:
//      LPBYTE pb:
//
//      LPDWORD pdw:
//
//  Return (LPBYTE):
//
//
//  History:
//      11/21/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LPBYTE FNLOCAL pcmReadSample_M08M08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    *(LPBYTE)pdw = ((BYTE HUGE *)pb)[0];

    return ((LPBYTE)&((BYTE HUGE *)pb)[1]);
} // pcmReadSample_M08M08()

LPBYTE FNLOCAL pcmReadSample_S08M08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD    w;

    w = (WORD)((BYTE HUGE *)pb)[0];

    *(LPWORD)pdw = (w << 8) | w;

    return ((LPBYTE)&((BYTE HUGE *)pb)[1]);
} // pcmReadSample_S08M08()

LPBYTE FNLOCAL pcmReadSample_M16M08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    *(LPWORD)pdw = (WORD)(((BYTE HUGE *)pb)[0] ^ (BYTE)0x80) << 8;

    return ((LPBYTE)&((BYTE HUGE *)pb)[1]);
} // pcmReadSample_M16M08()

LPBYTE FNLOCAL pcmReadSample_S16M08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD    w;

    w = (WORD)(((BYTE HUGE *)pb)[0] ^ (BYTE)0x80) << 8;

    *pdw = MAKELONG(w, w);

    return ((LPBYTE)&((BYTE HUGE *)pb)[1]);
} // pcmReadSample_S16M08()


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LPBYTE FNLOCAL pcmReadSample_M08S08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD            w;
    int             n;

    w = ((WORD HUGE_T *)pb)[0] ^ 0x8080;

    n = (int)(char)w + (int)(char)(w >> 8);

    if (n > 127)
    {
        *(LPBYTE)pdw = 255;
    }
    else if (n < -128)
    {
        *(LPBYTE)pdw = 0;
    }
    else
    {
        *(LPBYTE)pdw = (BYTE)n ^ (BYTE)0x80;
    }

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_M08S08()

LPBYTE FNLOCAL pcmReadSample_S08S08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    *(LPWORD)pdw = ((WORD HUGE_T *)pb)[0];

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_S08S08()

LPBYTE FNLOCAL pcmReadSample_M16S08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    LONG            l;
    WORD            w;

    w = ((WORD HUGE_T *)pb)[0] ^ 0x8080;

    l = (long)(short)(w << 8) + (long)(short)(w & 0xFF00);

    if (l > 32767)
    {
        *(LPWORD)pdw = 32767;
    }
    else if (l < -32768)
    {
        *(LPWORD)pdw = (WORD)-32768;
    }
    else
    {
        *(LPWORD)pdw = LOWORD(l);
    }

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_M16S08()

LPBYTE FNLOCAL pcmReadSample_S16S08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD    w;

    w = ((WORD HUGE_T *)pb)[0] ^ 0x8080;

    *pdw = MAKELONG(w << 8, w & 0xFF00);

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_S16S08()


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LPBYTE FNLOCAL pcmReadSample_M08M16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    BYTE            b;

    b = (BYTE)(((WORD HUGE_T *)pb)[0] >> 8);

    *(LPBYTE)pdw = b ^ (BYTE)0x80;

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_M08M16()

LPBYTE FNLOCAL pcmReadSample_S08M16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD    w;

    w = ((WORD HUGE_T *)pb)[0] & 0xFF00;

    *(LPWORD)pdw = (w | (w >> 8)) ^ 0x8080;

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_S08M16()

LPBYTE FNLOCAL pcmReadSample_M16M16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    *(LPWORD)pdw = ((WORD HUGE_T *)pb)[0];

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_M16M16()

LPBYTE FNLOCAL pcmReadSample_S16M16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD    w;

    w = ((WORD HUGE_T *)pb)[0];

    *pdw = MAKELONG(w, w);

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_S16M16()


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LPBYTE FNLOCAL pcmReadSample_M08S16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    DWORD           dw;
    LONG            l;

    dw = ((DWORD HUGE_T *)pb)[0];

    l = (long)(short)LOWORD(dw) + (long)(short)HIWORD(dw);

    if (l > 32767)
    {
        *(LPBYTE)pdw = 255;
    }
    else if (l < -32768)
    {
        *(LPBYTE)pdw = 0;
    }
    else
    {
        *(LPBYTE)pdw = (BYTE)(l >> 8) ^ (BYTE)0x80;
    }

    return ((LPBYTE)&((DWORD HUGE_T *)pb)[1]);
} // pcmReadSample_M08S16()

LPBYTE FNLOCAL pcmReadSample_S08S16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    DWORD   dw;
    WORD    w1;
    WORD    w2;

    dw = ((DWORD HUGE_T *)pb)[0];

    w1 = LOWORD(dw) >> 8;
    w2 = HIWORD(dw) & 0xFF00;

    *(LPWORD)pdw = (w1 | w2) ^ 0x8080;

    return ((LPBYTE)&((DWORD HUGE_T *)pb)[1]);
} // pcmReadSample_S08S16()

LPBYTE FNLOCAL pcmReadSample_M16S16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    DWORD           dw;
    LONG            l;


    dw = ((DWORD HUGE_T *)pb)[0];

    l = (long)(short)LOWORD(dw) + (long)(short)HIWORD(dw);

    if (l > 32767)
    {
        *(LPWORD)pdw = 32767;
    }
    else if (l < -32768)
    {
        *(LPWORD)pdw = (WORD)-32768;
    }
    else
    {
        *(LPWORD)pdw = LOWORD(l);
    }

    return ((LPBYTE)&((DWORD HUGE_T *)pb)[1]);
} // pcmReadSample_M16M16()

LPBYTE FNLOCAL pcmReadSample_S16S16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    *pdw = ((DWORD HUGE_T *)pb)[0];

    return ((LPBYTE)&((DWORD HUGE_T *)pb)[1]);
} // pcmReadSample_S16S16()


//--------------------------------------------------------------------------;
//
//  LPBYTE pcmWriteSample_ddd
//
//  Description:
//
//
//  Arguments:
//      LPBYTE pb:
//
//      DWORD dw:
//
//  Return (LPBYTE):
//
//
//  History:
//      11/21/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LPBYTE FNLOCAL pcmWriteSample_M08
(
    LPBYTE              pb,
    DWORD               dw
)
{
    ((BYTE HUGE *)pb)[0] = (BYTE)dw;

    return ((LPBYTE)&((BYTE HUGE *)pb)[1]);
} // pcmWriteSample_M08()

LPBYTE FNLOCAL pcmWriteSample_S08
(
    LPBYTE              pb,
    DWORD               dw
)
{
    ((WORD HUGE_T *)pb)[0] = LOWORD(dw);

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmWriteSample_S08()

LPBYTE FNLOCAL pcmWriteSample_M16
(
    LPBYTE              pb,
    DWORD               dw
)
{
    ((WORD HUGE_T *)pb)[0] = LOWORD(dw);

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmWriteSample_M16()

LPBYTE FNLOCAL pcmWriteSample_S16
(
    LPBYTE              pb,
    DWORD               dw
)
{
    ((DWORD HUGE_T *)pb)[0] = dw;

    return ((LPBYTE)&((DWORD HUGE_T *)pb)[1]);
} // pcmWriteSample_S16()



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//  the following table is indexed by the wave format flags
//
//      x x x x
//      | | | |
//      | | | +------------ output is 1=stereo, 0=mono
//      | | +-------------- output is 1=16 bit, 0=8bit
//      | +---------------- input  is 1=stereo, 0=mono
//      +------------------ input  is 1=16 bit, 0=8bit
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef LPBYTE (FNLOCAL *PCMREADSAMPLE)(LPBYTE pb, LPDWORD pdw);

static PCMREADSAMPLE pcmReadSample_Table[] =
{
    pcmReadSample_M08M08,
    pcmReadSample_S08M08,
    pcmReadSample_M16M08,
    pcmReadSample_S16M08,

    pcmReadSample_M08S08,
    pcmReadSample_S08S08,
    pcmReadSample_M16S08,
    pcmReadSample_S16S08,

    pcmReadSample_M08M16,
    pcmReadSample_S08M16,
    pcmReadSample_M16M16,
    pcmReadSample_S16M16,

    pcmReadSample_M08S16,
    pcmReadSample_S08S16,
    pcmReadSample_M16S16,
    pcmReadSample_S16S16,
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//  the following table is indexed by the wave format flags
//
//      x x
//      | |
//      | +------------ output is 1=stereo, 0=mono
//      +-------------- output is 1=16 bit, 0=8bit
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef LPBYTE (FNLOCAL *PCMWRITESAMPLE)(LPBYTE pb, DWORD dw);

static PCMWRITESAMPLE pcmWriteSample_Table[] =
{
    pcmWriteSample_M08,
    pcmWriteSample_S08,
    pcmWriteSample_M16,
    pcmWriteSample_S16,
};



//--------------------------------------------------------------------------;
//
//  DWORD pcmConvert_C
//
//  Description:
//
//      The wave data must be PCM format with the following:
//          nSamplesPerSecond   :   1 - 0FFFFFFFFh
//          wBitsPerSample      :   8 or 16
//          nChannels           :   1 or 2
//
//  Arguments:
//      LPPCMWAVEFORMAT pwfSrc: Source PCM format.
//
//      LPBYTE pbSrc: Pointer to source bytes to convert.
//
//      LPPCMWAVEFORMAT pwfDst: Destination PCM format.
//
//      LPBYTE pbDst: Pointer to destination buffer.
//
//      DWORD dwSrcSamples: Source number of samples to convert.
//
//  Return (DWORD):
//      The return value is the total number of converted BYTES that were
//      placed in the destination buffer (pbDst).
//
//  History:
//      11/21/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

#define PCM_WF_STEREO       0x0001
#define PCM_WF_16BIT        0x0002

EXTERN_C DWORD FNGLOBAL pcmConvert_C
(
    LPPCMWAVEFORMAT     pwfSrc,
    LPBYTE              pbSrc,
    LPPCMWAVEFORMAT     pwfDst,
    LPBYTE              pbDst,
    DWORD               dwSrcSamples,
    BOOL                fPartialSampleAtTheEnd,
    LPBYTE              pbDstEnd
)
{
    DWORD           dwSpsSrc;           // samples per second
    DWORD           dwSpsDst;           //
    LONG            lCurSample;
    LONG            lDecSample;
    UINT            wfSrc;              // wave format flags
    UINT            wfDst;              //
    PCMREADSAMPLE   fnReadSample;       // function to read a sample
    PCMWRITESAMPLE  fnWriteSample;      // function to write a sample
    DWORD           dwSample;
    LPBYTE          pbDstStart;


    //
    //  check for an easy out...
    //
    if (0L == dwSrcSamples)
        return (0L);

    //
    //  initialize a couple of things...
    //
    dwSpsSrc = pwfSrc->wf.nSamplesPerSec;
    dwSpsDst = pwfDst->wf.nSamplesPerSec;

    wfDst = (pwfDst->wf.nChannels >> 1);
    if (16 == pwfDst->wBitsPerSample)
        wfDst |= PCM_WF_16BIT;

    fnWriteSample = pcmWriteSample_Table[wfDst];

    wfSrc = (pwfSrc->wf.nChannels >> 1);
    if (16 == pwfSrc->wBitsPerSample)
        wfSrc |= PCM_WF_16BIT;

    fnReadSample = pcmReadSample_Table[(wfSrc << 2) | wfDst];


    //
    //
    //
    if( fPartialSampleAtTheEnd ) {
        //
        //  We'll convert the partial one individually.
        //
        dwSrcSamples--;
    }


    //
    //
    //
    pbDstStart   = pbDst;


    //
    //  all set to convert the wave data, either do a major or minor DDA
    //
    //      if (dwSpsSrc < dwSpsDst) --> DDA Major
    //      if (dwSpsSrc > dwSpsDst) --> DDA Minor
    //
    if (dwSpsSrc <= dwSpsDst)
    {
        //
        //  DDA major (dwSpsSrc < dwSpsDst)
        //
        //      start at dwSpsDst / 2
        //      decrement by dwSpsSrc
        //
        lCurSample = (dwSpsDst >> 1);
        lDecSample = dwSpsSrc;

        while (dwSrcSamples--)
        {
            pbSrc = fnReadSample(pbSrc, &dwSample);

            do
            {
                pbDst = fnWriteSample(pbDst, dwSample);
                lCurSample -= lDecSample;
            } while (lCurSample >= 0);

            lCurSample += dwSpsDst;
        }
    }
    else
    {
        //
        //  DDA minor (dwSpsSrc > dwSpsDst)
        //
        //      start at dwSpsSrc / 2
        //      decrement by dwSpsDst
        //
        lCurSample = (dwSpsSrc >> 1);
        lDecSample = dwSpsDst;

        while (dwSrcSamples--)
        {
            pbSrc = fnReadSample(pbSrc, &dwSample);

            lCurSample -= lDecSample;
            if (lCurSample >= 0)
                continue;

            pbDst = fnWriteSample(pbDst, dwSample);
            lCurSample += dwSpsSrc;
        }

    }


    //
    //
    //
    if( fPartialSampleAtTheEnd )
    {
        //
        //  Convert the partial sample.
        //
        pbSrc = fnReadSample( pbSrc, &dwSample );

        while( pbDst < pbDstEnd ) {
            pbDst = fnWriteSample( pbDst, dwSample );
        }

        ASSERT( pbDst == pbDstEnd );
    }


    //
    //
    //
    return ((DWORD)((BYTE HUGE *)pbDst - (BYTE HUGE *)pbDstStart));
} // pcmConvert_C()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\uchelp.c ===
//==========================================================================;
//
//  uchelp.c
//
//  Copyright (c) 1994-1995 Microsoft Corporation
//
//  Description:
//	This module provides various unicode helper functions that can
//	be used when similar APIs are not available from the OS.
//
//  Notes:
//	Intended for win32 only
//
//  History:
//	02/24/94    [frankye]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <stdlib.h>
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "uchelp.h"
#include "debug.h"

#ifdef WIN32


#ifndef UNICODE
//--------------------------------------------------------------------------;
//
//  int IlstrcmpW
//
//  Description:
//	Internal implementaion of the Win32 lstrmpW API.
//
//  Arguments:
//	LPCWSTR lpwstr1:
//
//	LPCWSTR lpwstr2:
//
//  Return (int):
//
//  History:
//	03/09/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL IlstrcmpW(LPCWSTR lpwstr1, LPCWSTR lpwstr2)
{
    int iReturn;
    
    do
    {
	iReturn = *lpwstr1 - *lpwstr2;
    }
    while (iReturn==0 && 0!=*(lpwstr1++) && 0!=*(lpwstr2++));

    return iReturn;
}


//--------------------------------------------------------------------------;
//
//  LPWSTR IlstrcpyW
//
//  Description:
//	Internal implementaion of the Win32 lstrcpyW API.
//
//  Arguments:
//	LPWSTR lpDst:
//
//	LPCWSTR lpSrc:
//
//  Return (LPWSTR):
//
//  History:
//	03/09/94    [frankye]
//
//--------------------------------------------------------------------------;

LPWSTR FNGLOBAL IlstrcpyW(LPWSTR lpDst, LPCWSTR lpSrc)
{
    LPWSTR lpOrgDst = lpDst;
    
    while (*lpSrc != 0)
    {
	*lpDst = *lpSrc;
	lpSrc++;
	lpDst++;
    }
    *lpDst = *lpSrc;

    return lpOrgDst;
}


//--------------------------------------------------------------------------;
//
//  int IlstrlenW
//
//  Description:
//	Internal implementaion of the Win32 lstrlenW API.
//
//  Arguments:
//	LPCWSTR lpWideCharStr:
//
//  Return (int):
//
//  History:
//	03/09/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL IlstrlenW(LPCWSTR lpwstr)
{
    int i=0;
    while (*lpwstr != 0)
	{
	    i++;
	    lpwstr++;
	}
    return i;
}


//--------------------------------------------------------------------------;
//
//  int ILoadStringW
//
//  Description:
//	Internal implementation of Win32 LoadStringW API.  Calls
//	LoadStringA and converts ansi to wide.
//
//  Arguments:
//	HINSTANCE hinst:
//
//	UINT uID:
//
//	LPWSTR lpwstr:
//
//	int cch:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL ILoadStringW
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
	Imbstowcs(lpwstr, lpstr, cch);
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}


//--------------------------------------------------------------------------;
//
//  int IDialogBoxParamW
//
//  Description:
//	Unicode version of DialogBoxParam.
//
//  Arguments:
//	HANDLE hinst:
//
//	LPCWSTR lpwstrTemplate:
//
//	HWND hwndOwner:
//
//	DLGPROC dlgprc:
//
//	LPARAM lParamInit:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL IDialogBoxParamW
(
 HANDLE hinst,
 LPCWSTR lpwstrTemplate,
 HWND hwndOwner,
 DLGPROC dlgprc,
 LPARAM lParamInit)
{
    LPSTR   lpstrTemplate;
    UINT    cchTemplate;
    int	    iReturn;

    if (0 == HIWORD(lpwstrTemplate))
    {
	return DialogBoxParamA(hinst, (LPCSTR)lpwstrTemplate, hwndOwner, dlgprc, lParamInit);
    }

    cchTemplate = lstrlenW(lpwstrTemplate)+1;
    lpstrTemplate = (LPSTR)GlobalAlloc(GPTR, cchTemplate);
    if (NULL == lpstrTemplate)
    {
	return (-1);
    }
    Iwcstombs(lpstrTemplate, lpwstrTemplate, cchTemplate);
    iReturn = DialogBoxParamA(hinst, lpstrTemplate, hwndOwner, dlgprc, lParamInit);
    GlobalFree((HGLOBAL)lpstrTemplate);
    return iReturn;
}

//--------------------------------------------------------------------------;
//
//  int IComboBox_GetLBText_mbstowcs
//
//  Description:
//
//  Arguments:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;
int FNGLOBAL IComboBox_GetLBText_mbstowcs(HWND hwndCtl, int index, LPWSTR lpwszBuffer)
{
    int	    cch;
    LPSTR   lpstr;
    
    cch = ComboBox_GetLBTextLen(hwndCtl, index);
    if (CB_ERR != cch)
    {
	lpstr = (LPSTR)GlobalAlloc(GPTR, cch+1);
	if (NULL == lpstr)
	{
	    return (CB_ERR);
	}
	
	cch = IComboBox_GetLBText(hwndCtl, index, lpstr);
	if (CB_ERR != cch)
	{
	    Imbstowcs(lpwszBuffer, lpstr, cch+1);
	}

	GlobalFree((HGLOBAL)lpstr);
    }

    return (cch);
}

//--------------------------------------------------------------------------;
//
//  int IComboBox_FindStringExact_wcstombs
//
//  Description:
//
//  Arguments:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;
int FNGLOBAL IComboBox_FindStringExact_wcstombs(HWND hwndCtl, int indexStart, LPCWSTR lpwszFind)
{
    int	    cch;
    int	    index;
    LPSTR   lpszFind;
    
    cch = IlstrlenW(lpwszFind);
    lpszFind = (LPSTR)GlobalAlloc(GPTR, cch+1);
    if (NULL == lpszFind)
    {
	return (CB_ERR);
    }
    Iwcstombs(lpszFind, lpwszFind, cch+1);
    index = IComboBox_FindStringExact(hwndCtl, indexStart, lpszFind);
    GlobalFree((HGLOBAL)lpszFind);
    return(index);
}

//--------------------------------------------------------------------------;
//
//  int IComboBox_AddString_wcstombs
//
//  Description:
//
//  Arguments:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;
int FNGLOBAL IComboBox_AddString_wcstombs(HWND hwndCtl, LPCWSTR lpwsz)
{
    int	    cch;
    int	    index;
    LPSTR   lpsz;

    cch = IlstrlenW(lpwsz);
    lpsz = GlobalAlloc(GPTR, cch+1);
    if (NULL == lpsz)
    {
	return (CB_ERR);
    }
    Iwcstombs(lpsz, lpwsz, cch+1);
    index = IComboBox_AddString(hwndCtl, lpsz);
    GlobalFree((HGLOBAL)lpsz);
    return(index);
}

#endif	// !UNICODE


//--------------------------------------------------------------------------;
//
//  int Imbstowcs
//
//  Description:
//	Internal implementation of the C runtime function mbstowcs.
//	Calls the Win32 MultiByteToWideChar API.
//
//  Arguments:
//	LPWSTR lpWideCharStr:
//
//	LPCSTR lpMultiByteStr:
//
//	int cch:
//
//  Return (int):
//
//  History:
//	03/09/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL Imbstowcs(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cch)
{
    return MultiByteToWideChar(GetACP(), 0, lpMultiByteStr, -1, lpWideCharStr, cch);
}


//--------------------------------------------------------------------------;
//
//  int Iwcstombs
//
//  Description:
//	Internal implementation of C runtime function mbstowcs.
//	Calls the Win32 WideCharTMultiByte API.
//
//  Arguments:
//	LPSTR lpMultiByteStr:
//
//	LPCWSTR lpWideCharStr:
//
//	int cch:
//
//  Return (int):
//
//  History:
//	03/09/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL Iwcstombs(LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr, int cch)
{
    return WideCharToMultiByte(GetACP(), 0, lpWideCharStr, -1, lpMultiByteStr, cch, NULL, NULL);
}


//--------------------------------------------------------------------------;
//
//  int Iwsprintfmbstowcs
//
//  Description:
//	Like wsprintfA, except the destination buffer receives
//	a unicode string.  Also requires an argument describing the
//	size of the desitination buffer.
//
//  Arguments:
//	int cch:
//
//	LPWSTR lpwstrDst:
//
//	LPSTR lpstrFmt:
//
//	...:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;

int Iwsprintfmbstowcs(int cch, LPWSTR lpwstrDst, LPSTR lpstrFmt, ...)
{
    LPSTR   lpstrDst;
    int	    iReturn;
    va_list vargs;

    va_start(vargs, lpstrFmt);

    lpstrDst = (LPSTR)GlobalAlloc(GPTR, cch);
    
    if (NULL != lpstrDst)
    {
        iReturn = wvsprintfA(lpstrDst, lpstrFmt, vargs);
        if (iReturn > 0)
	    Imbstowcs(lpwstrDst, lpstrDst, cch);
        GlobalFree((HGLOBAL)lpstrDst);
    }
    else
    {
        iReturn = 0;
    }

    return iReturn;
}


//--------------------------------------------------------------------------;
//
//  int Ilstrcmpwcstombs
//
//  Description:
//	Similar to lstrcmp except compares a wide character string
//	to a multibyte string by first converting the wide character
//	string to a multibyte string.
//
//  Arguments:
//	LPCSTR lpstr1:
//
//	LPCWSTR lpwstr2:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL Ilstrcmpwcstombs(LPCSTR lpstr1, LPCWSTR lpwstr2)
{
    LPSTR   lpstr2;
    UINT    cch;
    int	    iReturn;

    cch = lstrlenW(lpwstr2)+1;
    lpstr2 = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr2)
	return 1;
    
    Iwcstombs(lpstr2, lpwstr2, cch);
    iReturn = lstrcmpA(lpstr1, lpstr2);
    
    GlobalFree((HGLOBAL)lpstr2);
    
    return iReturn;
}


#endif	// WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "MSACMMAP"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacm\uchelp.h ===
//==========================================================================;
//
//  uchelp.h
//
//  Copyright (c) 1994 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//	This module provides the prototypes for various unicode helper
//	functions that can be used when similar APIs are not available
//	from the OS.
//
//  History:
//	02/24/94    [frankye]
//
//==========================================================================;

#ifndef _INC_UCHELP
#define _INC_UCHELP     /* #defined if ucapi.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */


#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#ifdef WIN32
//==========================================================================;
//
//
//
//
//==========================================================================;


#ifndef UNICODE
int FNGLOBAL IlstrcmpW(LPCWSTR lpwstr1, LPCWSTR lpwstr2);

LPWSTR FNGLOBAL IlstrcpyW(LPWSTR lpDst, LPCWSTR lpSrc);

int FNGLOBAL IlstrlenW(LPCWSTR lpwstr);

int FNGLOBAL IDialogBoxParamW(HANDLE hinst, LPCWSTR lpwstrTemplate, HWND hwndOwner, DLGPROC dlgprc, LPARAM lParamInit);

int FNGLOBAL ILoadStringW(HINSTANCE hinst, UINT uID, LPWSTR lpwstr, int cch);

int FNGLOBAL IComboBox_GetLBText_mbstowcs(HWND hwndCtl, int index, LPWSTR lpwszBuffer);

int FNGLOBAL IComboBox_FindStringExact_wcstombs(HWND hwndCtl, int indexStart, LPCWSTR lpwszFind);

int FNGLOBAL IComboBox_AddString_wcstombs(HWND hwndCtl, LPCWSTR lpwsz);
#endif

int FNGLOBAL Iwcstombs(LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr, int cch);

int FNGLOBAL Imbstowcs(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cch);

int          Iwsprintfmbstowcs(int cch, LPWSTR lpwstrDst, LPSTR lpstrFmt, ...);

int FNGLOBAL Ilstrcmpwcstombs(LPCSTR lpstr1, LPCWSTR lpwstr2);

//==========================================================================;
//
//
//
//
//==========================================================================;
#endif	// WIN32


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_UCHELP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\msacmmap.h ===
//==========================================================================;
//
//  msacmmap.h
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       8/ 2/93    cjp     [curtisp]
//
//==========================================================================;


#ifndef _INC_MSACMMAP
#define _INC_MSACMMAP            // #defined if msacmmap.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                 // assume byte packing throughout
#endif  // RC_INVOKED


#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif


#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif  // __cplusplus


#ifndef MMVERSION
#include <verinfo.h>
#endif

#define VERSION_MSACMMAP_MAJOR  MMVERSION
#define VERSION_MSACMMAP_MINOR  MMREVISION

#define VERSION_MSACMMAP        ((VERSION_MSACMMAP_MAJOR << 8) | VERSION_MSACMMAP_MINOR)


//
//
//
#ifndef SIZEOF_WAVEFORMATEX
#define SIZEOF_WAVEFORMATEX(pwfx)   ((WAVE_FORMAT_PCM==(pwfx)->wFormatTag)?sizeof(PCMWAVEFORMAT):(sizeof(WAVEFORMATEX)+(pwfx)->cbSize))
#endif



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#ifdef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNCALLBACK  CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE
    #define BDATA
    #define BSTACK

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
        ((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
        #define DEVFMT_STR  "%ls"
    #else
        #define SIZEOF(x)   sizeof(x)
        #define DEVFMT_STR  "%s"
    #endif

    #define GetCurrentTask  (HTASK)GetCurrentThreadId

#endif // #ifdef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNCALLBACK  FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _loadds _export
    #else
        #define FNCALLBACK  FAR PASCAL
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif


    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))
    #define BDATA           _based(_segname("_DATA"))
    #define BSTACK          _based(_segname("_STACK"))

    #define HUGE            _huge


    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif


    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef const PTSTR     PCTSTR;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define DEVFMT_STR      "%s"

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
        DWORD   dw;                                                 \
        dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
        *pnE = (int)HIWORD(dw);                                     \
        *pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef WIN32
#endif // #ifndef RC_INVOKED


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Resource defines
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
//
//  Be compatible with multimed.cpl in Windows NT
//
#define ICON_MSACM                  RCID(3004)
#else
#define ICON_MSACM                  RCID(10)
#endif
#define ICON_INPUT                  RCID(11)
#define ICON_OUTPUT                 RCID(12)
#define ICON_MSACMMAP               RCID(13)


#define DLG_CPL_MSACM               RCID(50)
#define IDD_CPL_STATIC_DRIVERS      100
#define IDD_CPL_LIST_DRIVERS        101
#define IDD_CPL_BTN_CONFIGURE       102
#define IDD_CPL_BTN_ABOUT           103
#define IDD_CPL_BTN_PRIORITY        104
#define IDD_CPL_BTN_HELP            105
#define IDD_CPL_BTN_RESTART         106
#define IDD_CPL_BTN_ABLE            107
#define IDD_CPL_BTN_BUMPTOTOP       108
#define IDD_CPL_BTN_INSTALL         109
#define IDD_CPL_BTN_APPLY           110
#define IDD_CPL_STATIC_PRIORITY     111
#define IDD_CPL_COMBO_PLAYBACK      120
#define IDD_CPL_COMBO_RECORD        121
#define IDD_CPL_CHECK_PREFERRED     122

#define DLG_RESTART_MSACM           RCID(55)

#define DLG_ABOUT_MSACM             RCID(60)
#define IDD_ABOUT_ICON_DRIVER       100
#define IDD_ABOUT_TXT_DESCRIPTION   101
#define IDD_ABOUT_TXT_VERSION       102
#define IDD_ABOUT_TXT_COPYRIGHT     103
#define IDD_ABOUT_TXT_LICENSING     104
#define IDD_ABOUT_TXT_FEATURES      105

#define IDS_ABOUT_TAG               200
#define IDS_ABOUT_TITLE             (IDS_ABOUT_TAG + 0)
#define IDS_ABOUT_VERSION           (IDS_ABOUT_TAG + 1)



//
//  string resource defines, etc.
//
#define IDS_ACM_CAPS_TAG            50
#define IDS_ACM_CAPS_DESCRIPTION    (IDS_ACM_CAPS_TAG+0)

#ifdef WIN32
//
//  Be compatible with NT's multimed.cpl
//
#define IDS_CPL_TAG                 3001
#define IDS_CPL_HELPFILE            3003
#else
#define IDS_CPL_TAG                 100
#endif
#define IDS_CPL_NAME                (IDS_CPL_TAG+0)
#define IDS_CPL_INFO                (IDS_CPL_TAG+1)

#define IDS_TXT_TAG                 150
#define IDS_TXT_NONE                (IDS_TXT_TAG+0)
#define IDS_TXT_DISABLED            (IDS_TXT_TAG+1)


#define DLG_PRIORITY_SET            RCID(80)
#define IDD_PRIORITY_TXT_DRIVER     100
#define IDD_PRIORITY_TXT_FROMTO     101
#define IDD_PRIORITY_COMBO_PRIORITY 102
#define IDD_PRIORITY_CHECK_DISABLE  103

#define IDS_PRIORITY_FROMTO         (IDS_CPL_TAG+6)






//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  Note: These fields were taken out of ACMGARB b/c they are common to all
//        instances of the mapper and change in one instance should reflect
//        change in all instances.
//

typedef struct tACMGLOBALINFO
{
    BOOL            fPreferredOnly;
    BOOL            fSyncOnlyOut;
    UINT            uIdPreferredOut;
    BOOL            fSyncOnlyIn;
    UINT            uIdPreferredIn;
} ACMGLOBALINFO, *PACMGLOBALINFO;

// To simplify Win16/Win32 code

#ifndef WIN32

    #define WAIT_FOR_MUTEX(a)
    #define RELEASE_MUTEX(a)

#else   //  WIN32

    #define WAIT_FOR_MUTEX(a)   if(NULL != a) WaitForSingleObject(a, INFINITE)
    #define RELEASE_MUTEX(a)    if(NULL != a) ReleaseMutex(a)

#endif  //  WIN32

typedef struct tACMGARB
{
    HINSTANCE       hinst;              // hinst of ACM module

    BOOL            fEnabled;           // whether mapper driver is enabled

    BOOL            fPrestoSyncAsync;   // allow async opens on sync devs

    UINT            cInputStreams;      // ref count for input mapping task
#ifndef WIN32
    HTASK           htaskInput;         // input mapping task
#else
    HANDLE          hMutexSettings;     // handle to mutex for settings
#endif
#ifdef DEBUG
    BOOL            fFaultAndDie;
#endif

    UINT            cWaveOutDevs;       // value from waveOutGetNumDevs
    UINT            cWaveInDevs;        // value from waveInGetNumDevs

    PACMGLOBALINFO  pSettings;

//    BOOL            fPreferredOnly;
//    BOOL            fSyncOnlyOut;
//    UINT            uIdPreferredOut;
//    BOOL            fSyncOnlyIn;
//    UINT            uIdPreferredIn;
//
//    TCHAR           szPreferredWaveOut[MAXPNAMELEN];
//    TCHAR           szPreferredWaveIn[MAXPNAMELEN];

} ACMGARB, *PACMGARB, FAR *LPACMGARB;


typedef MMRESULT FAR * LPMMRESULT;

//
//
//
extern PACMGARB         gpag;
extern TCHAR            gszNull[];






//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  structure/flag definitions used for GetWaveFormats and FindBestPCMFormat
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tZYZPCMFORMAT
{
    PUINT   uFlagsInput;
    PUINT   uFlagsOutput;
    UINT    uSamplesPerSec;

} ZYZPCMFORMAT, *PZYZPCMFORMAT, FAR LPZYZPCMFORMAT;

//
//  note that the _order_ of these bits is very important--they map 1 to 1
//  with the format bits in dwFormats of the waveformat structure
//
#define ZYZPCMF_OUT_M08     0x0001
#define ZYZPCMF_OUT_S08     0x0002
#define ZYZPCMF_OUT_M16     0x0004
#define ZYZPCMF_OUT_S16     0x0008
#define ZYZPCMF_IN_M08      0x0100
#define ZYZPCMF_IN_S08      0x0200
#define ZYZPCMF_IN_M16      0x0400
#define ZYZPCMF_IN_S16      0x0800

#define ZYZPCMF_OUT_FORMATS (ZYZPCMF_OUT_M08 | ZYZPCMF_OUT_S08 | ZYZPCMF_OUT_M16 | ZYZPCMF_OUT_S16)
#define ZYZPCMF_OUT_STEREO  (ZYZPCMF_OUT_S08 | ZYZPCMF_OUT_S16)
#define ZYZPCMF_OUT_MONO    (ZYZPCMF_OUT_M08 | ZYZPCMF_OUT_M16)
#define ZYZPCMF_OUT_8BIT    (ZYZPCMF_OUT_M08 | ZYZPCMF_OUT_S08)
#define ZYZPCMF_OUT_16BIT   (ZYZPCMF_OUT_M16 | ZYZPCMF_OUT_S16)

#define ZYZPCMF_IN_FORMATS  (ZYZPCMF_IN_M08 | ZYZPCMF_IN_S08 | ZYZPCMF_IN_M16 | ZYZPCMF_IN_S16)
#define ZYZPCMF_IN_STEREO   (ZYZPCMF_IN_S08 | ZYZPCMF_IN_S16)
#define ZYZPCMF_IN_MONO     (ZYZPCMF_IN_M08 | ZYZPCMF_IN_M16)
#define ZYZPCMF_IN_8BIT     (ZYZPCMF_IN_M08 | ZYZPCMF_IN_S08)
#define ZYZPCMF_IN_16BIT    (ZYZPCMF_IN_M16 | ZYZPCMF_IN_S16)


extern ZYZPCMFORMAT gaPCMFormats[];



//
//
//
//
//
typedef MMRESULT (WINAPI *MAPPEDWAVEOPEN)
(
    HWAVE              FAR *phw,
    UINT                    uId,
    LPWAVEFORMATEX          pwfx,
    DWORD_PTR               dwCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwOpen
);

typedef MMRESULT (WINAPI *MAPPEDWAVECLOSE)
(
    HWAVE                   hw
);

typedef MMRESULT (WINAPI *MAPPEDWAVEPREPAREHEADER)
(
    HWAVE                   hw,
    LPWAVEHDR               pwh,
    UINT                    cbwh
);

typedef MMRESULT (WINAPI *MAPPEDWAVEUNPREPAREHEADER)
(
    HWAVE                   hw,
    LPWAVEHDR               pwh,
    UINT                    cbwh
);

typedef MMRESULT (WINAPI *MAPPEDWAVEWRITE)
(
    HWAVE                   hw,
    LPWAVEHDR               pwh,
    UINT                    cbwh
);

typedef MMRESULT (WINAPI *MAPPEDWAVEGETPOSITION)
(
    HWAVE                   hw,
    LPMMTIME                pmmt,
    UINT                    cbmmt
);

typedef MMRESULT (WINAPI *MAPPEDWAVEMESSAGE)
(
    HWAVE                   hw,
    UINT                    msg,
    DWORD_PTR               dw1,
    DWORD_PTR               dw2
);

//
//
//
//
//
typedef struct tMAPSTREAM      FAR *LPMAPSTREAM;
typedef struct tMAPSTREAM
{
////LPMAPSTREAM         pmsNext;        // next stream for mapper

    MMRESULT            mmrClient;

    UINT                uHeuristic;

    HACMDRIVER          had;            // handle to ACM driver we chose
    HACMSTREAM          has;            // handle to ACM conversion stream
    LPWAVEFORMATEX      pwfxSrc;        // source format when mapping
    LPWAVEFORMATEX      pwfxDst;        // destination format when mapping
    DWORD               fdwSupport;     // support required for conversion

    BOOL                fInput;         // TRUE if input
#ifdef WIN32
    DWORD               htaskInput;	// Thread id of input
    HANDLE              hInput;         // Thread handle of input
    HANDLE              hStoppedEvent;  // Input stopped
    volatile LONG       nOutstanding;   // Input buffers outstanding
#else
    HTASK               htaskInput;     // for input mapping....
#endif
    DWORD               fdwOpen;        // client's allocation flags

    UINT                uMappedDeviceID;// device to map to if WAVE_MAPPED flag
    DWORD_PTR           dwCallback;     // client callback
    DWORD_PTR           dwInstance;     // client callback instance data

    LPWAVEFORMATEX      pwfxClient;     // format of client wave data
    union
    {
        HWAVE           hwClient;       // client's handle to ACM
        HWAVEOUT        hwoClient;
        HWAVEIN         hwiClient;
    };


    LPWAVEFORMATEX      pwfxReal;       // format of device wave data
    DWORD               cbwfxReal;
    UINT                uIdReal;
    union
    {
        HWAVE           hwReal;         // device wave handle
        HWAVEOUT        hwoReal;
        HWAVEIN         hwiReal;
    };

    MAPPEDWAVEOPEN              fnWaveOpen;
    MAPPEDWAVECLOSE             fnWaveClose;
    MAPPEDWAVEPREPAREHEADER     fnWavePrepareHeader;
    MAPPEDWAVEUNPREPAREHEADER   fnWaveUnprepareHeader;
    MAPPEDWAVEWRITE             fnWaveWrite;
    MAPPEDWAVEGETPOSITION       fnWaveGetPosition;
    MAPPEDWAVEMESSAGE           fnWaveMessage;

} MAPSTREAM;



BOOL FNGLOBAL GetWaveFormats(PZYZPCMFORMAT pzpf);

MMRESULT FNGLOBAL mapWaveGetDevCaps(BOOL fInput, LPWAVEOUTCAPS pwc, UINT cbSize);


//
//
//
//
MMRESULT FNLOCAL FindConverterMatch(LPMAPSTREAM pms);

MMRESULT FNLOCAL mapWaveGetPosition(LPMAPSTREAM pms,LPMMTIME pmmt,UINT cbmmt);

DWORD FNLOCAL mapWaveOpen(BOOL fInput, UINT uId, DWORD_PTR dwUser, LPWAVEOPENDESC pwod, DWORD fdwOpen);
DWORD FNLOCAL mapWaveClose(LPMAPSTREAM pms);
DWORD FNLOCAL mapWavePrepareHeader(LPMAPSTREAM pms, LPWAVEHDR pwh);
DWORD FNLOCAL mapWaveUnprepareHeader(LPMAPSTREAM pms, LPWAVEHDR pwh);
DWORD FNLOCAL mapWaveWriteBuffer(LPMAPSTREAM pms, LPWAVEHDR pwh);

EXTERN_C BOOL FNGLOBAL mapWaveDriverCallback
(
    LPMAPSTREAM         pms,
    UINT                uMsg,
    DWORD_PTR           dw1,
    DWORD_PTR           dw2
);


// Task proc for hidden input mapping window
EXTERN_C LRESULT FNCALLBACK mapWaveInputConvertProc
(
    DWORD               dwInst
);


EXTERN_C void FNCALLBACK mapWaveCallback
(
    HWAVE               hw,
    UINT                uMsg,
    DWORD_PTR           dwUser,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2
);


//
//
//
//
BOOL FNGLOBAL mapSettingsRestore(void);
BOOL FNGLOBAL mapSettingsSave(void);

LRESULT FNGLOBAL mapDriverEnable(HDRVR hdrvr);
LRESULT FNGLOBAL mapDriverDisable(HDRVR hdrvr);
LRESULT FNGLOBAL mapDriverInstall(HDRVR hdrvr);
LRESULT FNGLOBAL mapDriverRemove(HDRVR hdrvr);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Misc defines and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define MAX_HEURISTIC           6

//
//
//
//
#define WAVE_FORMAT_STEREO8     (WAVE_FORMAT_1S08 | WAVE_FORMAT_2S08 | WAVE_FORMAT_4S08)
#define WAVE_FORMAT_STEREO16    (WAVE_FORMAT_1S16 | WAVE_FORMAT_2S16 | WAVE_FORMAT_4S16)

#define WAVE_FORMAT_MONO8       (WAVE_FORMAT_1M08 | WAVE_FORMAT_2M08 | WAVE_FORMAT_4M08)
#define WAVE_FORMAT_MONO16      (WAVE_FORMAT_1M16 | WAVE_FORMAT_2M16 | WAVE_FORMAT_4M16)

#define WAVE_FORMAT_44k         (WAVE_FORMAT_4M16 | WAVE_FORMAT_4S16 | WAVE_FORMAT_4M08 | WAVE_FORMAT_4S08)
#define WAVE_FORMAT_22k         (WAVE_FORMAT_2M16 | WAVE_FORMAT_2S16 | WAVE_FORMAT_2M08 | WAVE_FORMAT_2S08)
#define WAVE_FORMAT_11k         (WAVE_FORMAT_1M16 | WAVE_FORMAT_1S16 | WAVE_FORMAT_1M08 | WAVE_FORMAT_1S08)

#define WAVE_FORMAT_MONO_44k    (WAVE_FORMAT_4M16 | WAVE_FORMAT_4M08)
#define WAVE_FORMAT_MONO_22k    (WAVE_FORMAT_2M16 | WAVE_FORMAT_2M08)
#define WAVE_FORMAT_MONO_11k    (WAVE_FORMAT_1M16 | WAVE_FORMAT_1M08)

#define WAVE_FORMAT_STEREO_44k  (WAVE_FORMAT_4S16 | WAVE_FORMAT_4S08)
#define WAVE_FORMAT_STEREO_22k  (WAVE_FORMAT_2S16 | WAVE_FORMAT_2S08)
#define WAVE_FORMAT_STEREO_11k  (WAVE_FORMAT_1S16 | WAVE_FORMAT_1S08)

#define WAVE_FORMAT_STEREO      (WAVE_FORMAT_STEREO16 | WAVE_FORMAT_STEREO8)
#define WAVE_FORMAT_MONO        (WAVE_FORMAT_MONO16   | WAVE_FORMAT_MONO8)
#define WAVE_FORMAT_16BIT       (WAVE_FORMAT_STEREO16 | WAVE_FORMAT_MONO16)
#define WAVE_FORMAT_8BIT        (WAVE_FORMAT_STEREO8  | WAVE_FORMAT_MONO8)


#ifndef RC_INVOKED
#pragma pack()                  // revert to default packing
#endif  // RC_INVOKED

#ifdef __cplusplus
}                               // end of extern "C" {
#endif  // __cplusplus

#endif  // _INC_MSACMMAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\msacmhlp.h ===
//==========================================================================;
//
//  msacmhlp.h
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       9/29/93    cjp     [curtisp] 
//
//==========================================================================;

//
//
//
//
//
#define IDH_AUDIOCOMP_DRIVER	2417
#define IDH_AUDIOCOMP_PLAYBACK	2418
#define IDH_AUDIOCOMP_RECORDING 2419
#define IDH_AUDIOCOMP_PREFERRED 2420
#define IDH_PRIORITY_CHANGE	2421
#define IDH_PRIORITY_DISABLE	2422
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\msacmmap.c ===
//==========================================================================;
//
//  msacmmap.c
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       9/18/93    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <memory.h>

#include "muldiv32.h"
#include "msacmmap.h"

#include "debug.h"

extern ACMGARB acmgarb;

//
//
//
ZYZPCMFORMAT gaPCMFormats[] =
{
    { NULL, NULL,   5510},
    { NULL, NULL,   6620},
    { NULL, NULL,   8000},
    { NULL, NULL,   9600},
    { NULL, NULL,  11025},
    { NULL, NULL,  16000},
    { NULL, NULL,  18900},
    { NULL, NULL,  22050},
    { NULL, NULL,  27420},
    { NULL, NULL,  32000},
    { NULL, NULL,  33075},
    { NULL, NULL,  37800},
    { NULL, NULL,  44100},
    { NULL, NULL,  48000},
    { NULL, NULL,      0}   // terminator

    //  WARNING!!!  WARNING!!!
    //  If you change this array size update the size in:
    //      init.c:mapSettingsRestore
};

typedef struct tACMFORMATRESULTS
{
    WAVEFORMATEX        wfx;
    BOOL                fSuccess;
} ACMFORMATRESULTS, *PACMFORMATRESULTS;

//==========================================================================;
//
//                 -= INTERRUPT TIME CODE FOR WIN 16 =-
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL mapWaveDriverCallback
//
//  Description:
//      This calls DriverCallback for a WAVEHDR.
//
//      NOTE! this routine must be in a FIXED segment in Win 16.
//
//  Arguments:
//      LPMAPSTREAM pms: Pointer to instance data.
//
//      UINT uMsg: The message.
//
//      DWORD dw1: Message DWORD (dw2 is always set to 0).
//
//  Return (BOOL):
//      The result is non-zero if the function was able to do the callback.
//      Zero is returned if no callback was made.
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#pragma alloc_text(FIX_TEXT, mapWaveDriverCallback)

//
//  NOTE! we *DO NOT* turn off optimization for Win 3.1 builds to keep the
//  compiler from using extended registers (we compile with -G3). this
//  function causes no extended registers to be used (like mapWaveCallback
//  does).
//
//  !!! IF YOU TOUCH ANY OF THIS CODE, YOU MUST VERIFY THAT NO EXTENDED
//  !!! REGISTERS GET USED IN WIN 3.1 OR YOU WILL BREAK EVERYTHING !!!
//
//  #if (WINVER <= 0x030A)
//  #pragma optimize("", off)
//  #endif
//
#endif

EXTERN_C BOOL FNGLOBAL mapWaveDriverCallback
(
    LPMAPSTREAM         pms,
    UINT                uMsg,
    DWORD_PTR           dw1,
    DWORD_PTR           dw2
)
{
    BOOL    f;

    //
    //  invoke the callback function, if it exists.  dwFlags contains
    //  wave driver specific flags in the LOWORD and generic driver
    //  flags in the HIWORD
    //
    if (0L == pms->dwCallback)
        return (FALSE);

    f = DriverCallback(pms->dwCallback,         // user's callback DWORD
                       HIWORD(pms->fdwOpen),    // callback flags
                       (HDRVR)pms->hwClient,    // handle to the wave device
                       uMsg,                    // the message
                       pms->dwInstance,         // user's instance data
                       dw1,                     // first DWORD
                       dw2);                    // second DWORD

    return (f);
} // mapWaveDriverCallback()

//
//  #ifndef WIN32
//  #if (WINVER <= 0x030A)
//  #pragma optimize("", on)
//  #endif
//  #endif
//


//--------------------------------------------------------------------------;
//
//  void mapWaveCallback
//
//  Description:
//
//
//  Arguments:
//      HWAVE hw:
//
//      UINT uMsg:
//
//      DWORD dwUser:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (void):
//
//  History:
//      08/02/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#pragma alloc_text(FIX_TEXT, mapWaveCallback)

//
//  NOTE! we turn off optimization for Win 3.1 builds to keep the compiler
//  from using extended registers (we compile with -G3). it is not safe
//  in Win 3.1 to use extended registers at DriverCallback time unless we
//  save them ourselves. i don't feel like writing the assembler code for
//  that when it buys us almost nothing..
//
//  everything is cool under Win 4.0 since DriverCallback is 386 aware.
//
#if (WINVER <= 0x030A)
#pragma optimize("", off)
#endif
#endif

EXTERN_C void FNCALLBACK mapWaveCallback
(
    HWAVE               hw,
    UINT                uMsg,
    DWORD_PTR           dwUser,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2
)
{
    LPWAVEHDR       pwh;
    LPMAPSTREAM     pms;

#if !defined(WIN32) && (WINVER <= 0x030A)
    _asm _emit 0x66  ; pushad
    _asm _emit 0x60
#endif

    //
    //  WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER WARNING
    //
    //       THIS IS AT INTERRUPT TIME--DO NOT CALL ANY FUNCTIONS THAT
    //      YOU ARE NOT ABSOLUTELY SURE YOU CAN CALL AT INTERRUPT TIME!
    //
    //      out debugging 'DPF' stuff is NOT interrupt safe
    //
    //  WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER WARNING
    //
    pms = (LPMAPSTREAM)dwUser;


    //
    //
    //
    switch (uMsg)
    {
        //
        //  eat the WIM_OPEN and WIM_CLOSE messages for 'mapped' input
        //  since we must deal with them specially (due to our background
        //  task).
        //
        case WIM_OPEN:
        case WIM_CLOSE:
	    if (NULL != pms->has)
		break;
            mapWaveDriverCallback(pms, uMsg, 0L, 0L);
            break;

	//
	//  eat the WOM_OPEN and WOM_CLOSE messages for 'mapped' output
	//  because we deal with them specially in mapWaveOpen and
	//  mapWaveClose.  See comments in those functions.
	//
	//  note that we're checking pms->had, not pms->has, cuz this message
	//  may come thru on the physical device open after we've decidec that
	//  we wish to map (using the acm driver represented by had) but
	//  before we've opened a stream (which would be represented by has).
	//
        case WOM_OPEN:
        case WOM_CLOSE:
	    if (NULL != pms->had)
		break;
	    mapWaveDriverCallback(pms, uMsg, 0L, 0L);
	    break;

        //
        //  dwParam1 is the 'shadow' LPWAVEHDR that is done.
        //
        case WOM_DONE:
            //
            //  get the shadow header
            //
            pwh = (LPWAVEHDR)dwParam1;

            //
            //  passthrough mode?
            //
            if (NULL != pms->has)
            {
                //
                //  get the client's header and set done bit
                //
                pwh = (LPWAVEHDR)pwh->dwUser;

                pwh->dwFlags |= WHDR_DONE;
                pwh->dwFlags &= ~WHDR_INQUEUE;
            }

            //
            //  nofify the client that the block is done
            //
            mapWaveDriverCallback(pms, WOM_DONE, (DWORD_PTR)pwh, 0);
            break;


        //
        //  dwParam1 is the 'shadow' LPWAVEHDR that is done.
        //
        case WIM_DATA:
            //DPF(2, "WIM_DATA: callback");
            if (NULL == pms->has)
            {
                //
                //  passthrough mode--notify the client that the block is
                //  done
                //
                mapWaveDriverCallback(pms, WIM_DATA, dwParam1, 0L);
                break;
            }

            //
            //  convert mode--convert data then callback user.
            //
            if (!PostAppMessage(pms->htaskInput, WIM_DATA, 0, dwParam1))
            {
                //
                //  !!! ERROR what can we do....?
                //
                //DPF(0, "!WIM_DATA: XXXXXXXXXXX ERROR Post message failed XXXXXX");
            } else {
#ifdef WIN32
                InterlockedIncrement((LPLONG)&pms->nOutstanding);
#endif // WIN32
            }
            break;

        default:
            mapWaveDriverCallback(pms, uMsg, dwParam1, dwParam2);
            break;

    }

#if !defined(WIN32) && (WINVER <= 0x030A)
    _asm _emit 0x66  ; popad
    _asm _emit 0x61
#endif

} // mapWaveCallback()

#if !defined(WIN32) && (WINVER <= 0x030A)
#pragma optimize("", on)
#endif


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT mapWaveGetPosition
//
//  Description:
//      Get the stream position in samples or bytes.
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      LPMMTIME pmmt: Pointer to an MMTIME structure.
//
//      UINT uSize: Size of the MMTIME structure.
//
//  Return (DWORD):
//
//  History:
//      07/19/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapWaveGetPosition
(
    LPMAPSTREAM         pms,
    LPMMTIME            pmmt,
    UINT                cbmmt
)
{
    MMRESULT    mmr;
    DWORD       dw;

    if (cbmmt < sizeof(MMTIME))
    {
        DPF(0, "!mapWaveGetPosition: bad size passed for MMTIME (%u)", cbmmt);
        return (MMSYSERR_ERROR);
    }

    if ((TIME_SAMPLES != pmmt->wType) && (TIME_BYTES != pmmt->wType))
    {
        DPF(1, "mapWaveGetPosition: time format %u?!? forcing TIME_BYTES!", pmmt->wType);
        pmmt->wType = TIME_BYTES;
    }


    //
    //  get the position in samples or bytes..
    //
    //  if an error occured .OR. we are passthrough mode (has is NULL)
    //  then just return result--otherwise we need to convert the real
    //  time to the client's time...
    //
    mmr = pms->fnWaveGetPosition(pms->hwReal, pmmt, cbmmt);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!mapWaveGetPosition: physical get position failed? mmr=%u", mmr);
        return (mmr);
    }

    //
    //  in passthrough mode?
    //
    if (NULL == pms->has)
    {
        return (mmr);
    }

    //
    //  convert real time to client's time
    //
    switch (pmmt->wType)
    {
        case TIME_SAMPLES:
            dw = pmmt->u.sample;
            pmmt->u.sample = MulDivRN(dw,
                                      pms->pwfxClient->nSamplesPerSec,
                                      pms->pwfxReal->nSamplesPerSec);

            DPF(4, "GetPos(SAMPLES) real=%lu, client=%lu", dw, pmmt->u.sample);
            break;

        case TIME_BYTES:
            dw = pmmt->u.cb;
            pmmt->u.cb = MulDivRN(dw,
                                  pms->pwfxClient->nAvgBytesPerSec,
                                  pms->pwfxReal->nAvgBytesPerSec);
            DPF(4, "GetPos(BYTES) real=%lu, client=%lu", dw, pmmt->u.cb);
            break;

        default:
            DPF(0, "!mapWaveGetPosition() received unrecognized return format!");
            return (MMSYSERR_ERROR);
    }

    return (MMSYSERR_NOERROR);
} // mapWaveGetPosition()


//==========================================================================;
//
//  Notes on error code priorities	FrankYe	    09/28/94
//
//  The error code that is returned to the client and the error code
//  that is returned by internal functions are not always the same.  The
//  primary reason for this is the way we handle MMSYSERR_ALLOCATED and
//  WAVERR_BADFORMAT in multiple device situations.
//
//  For example, suppose we have two devices.  If one returns ALLOCATED and
//  the other returns BADFORMAT then we prefer to return ALLOCATED to the
//  client because BADFORMAT implies no devices understand the format.  So,
//  for the client, we prefer to return ALLOCATED over BADFORMAT.
//
//  On the other hand, we want the mapper to be able to take advantage of
//  situations where all the devices are allocated.  If all devices are
//  allocated then there is no need to continue trying to find a workable
//  map stream.  So, for internal use, we prefer BADFORMAT over ALLOCATED.
//  That way if we see ALLOCATED then we know _all_ devices are allocated
//  and we can abort trying to create a map stream.  (If the client sees
//  ALLOCATED, it only means that at least one device is allocated.)
//
//  Client return codes are usually stored in the mmrClient member of the
//  MAPSTREAM structure.  Internal return codes are returned via
//  function return values.
//
//  Below are functions that prioritize error codes and update error codes
//  given the last err, the current err, and the priorities of the errs.
//  Notice that the prioritization of the err codes for the client is very
//  similar to for internal use.  The only difference is the ordering of
//  MMSYSERR_ALLOCATED and WAVERR_BADFORMAT for reasons stated above.
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  UINT mapErrGetClientPriority
//
//  Description:
//
//  Arguments:
//      MMRESULT mmr :
//
//  Return (VOID):
//
//  History:
//	09/29/94    Frankye	Created
//
//--------------------------------------------------------------------------;
UINT FNLOCAL mapErrGetClientPriority( MMRESULT mmr )
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return 6;
    case MMSYSERR_ALLOCATED:
        return 5;
    case WAVERR_BADFORMAT:
        return 4;
    case WAVERR_SYNC:
        return 3;
    case MMSYSERR_NOMEM:
        return 2;
    default:
        return 1;
    case MMSYSERR_ERROR:
        return 0;
    }
}

//--------------------------------------------------------------------------;
//
//  VOID mapErrSetClientError
//
//  Description:
//
//  Arguments:
//      LPMMRESULT lpmmr :
//
//	MMRESULT mmr :
//
//  Return (VOID):
//
//  History:
//	09/29/94    Frankye	Created
//
//--------------------------------------------------------------------------;
VOID FNLOCAL mapErrSetClientError( LPMMRESULT lpmmr, MMRESULT mmr )
{
    if (mapErrGetClientPriority(mmr) > mapErrGetClientPriority(*lpmmr))
    {
        *lpmmr = mmr;
    }
}

//--------------------------------------------------------------------------;
//
//  UINT mapErrGetPriority
//
//  Description:
//
//  Arguments:
//      MMRESULT mmr :
//
//  Return (VOID):
//
//  History:
//	09/29/94    Frankye	Created
//
//--------------------------------------------------------------------------;
UINT FNLOCAL mapErrGetPriority( MMRESULT mmr )
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return 6;
    case WAVERR_BADFORMAT:
        return 5;
    case MMSYSERR_ALLOCATED:
        return 4;
    case WAVERR_SYNC:
        return 3;
    case MMSYSERR_NOMEM:
        return 2;
    default:
        return 1;
    case MMSYSERR_ERROR:
        return 0;
    }
}

//--------------------------------------------------------------------------;
//
//  VOID mapErrSetError
//
//  Description:
//
//  Arguments:
//      LPMMRESULT lpmmr :
//
//	MMRESULT mmr :
//
//  Return (VOID):
//
//  History:
//	09/29/94    Frankye	Created
//
//--------------------------------------------------------------------------;
VOID FNLOCAL mapErrSetError( LPMMRESULT lpmmr, MMRESULT mmr )
{
    if (mapErrGetPriority(mmr) > mapErrGetPriority(*lpmmr))
    {
        *lpmmr = mmr;
    }
}


//--------------------------------------------------------------------------;
//
//  UINT mapDriverOpenWave
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      LPWAVEFORMATEX pwfx:
//
//  Return (UINT):
//
//
//--------------------------------------------------------------------------;

UINT FNLOCAL mapDriverOpenWave
(
    LPMAPSTREAM         pms,
    LPWAVEFORMATEX      pwfx
)
{
    MMRESULT        mmr;
    MMRESULT        mmrReturn;
    BOOL            fPrefOnly;
    BOOL            fQuery;
    UINT            uPrefDevId;
    UINT            uDevId;
    UINT            cNumDevs;
    BOOL            fTriedMappableId;
    BOOL            fFoundNonmappableId;


    fQuery = (0 != (WAVE_FORMAT_QUERY & pms->fdwOpen));

    //
    //  there are four different cases we need to handle when trying
    //  to open a compatible wave device (for either input or output):
    //
    //  1.  the normal case is 'no preference'--which means that
    //      the user has selected '[none]' in the combo box for
    //      the preferred wave device. in this case, gpag->uIdPreferredXXX
    //      will be -1 (and gpag->fPreferredOnly is ignored).
    //
    //  2.  the next two cases are when a device has been chosen as the
    //      'preferred device'--so gpag->uIdPreferredXXX will be the device
    //      id of this preferred device. so the two cases are then:
    //
    //      a.  if gpag->pSettings->fPreferredOnly is FALSE, then try the
    //          'preferred' device first, and if that fails, try all
    //          remaining devices.
    //
    //      b.  if gpag->pSettings->fPreferredOnly is TRUE, then we will
    //          ONLY try the preferred device--if that fails, we do NOT
    //          continue.
    //
    //	3.  a device ID to which the mapper should map may have been
    //	    specified using the WAVE_MAPPED flag.
    //

    //
    //
    //	--== See if we are supposed to map to a specified device ==--
    //
    //
    if (pms->fdwOpen & WAVE_MAPPED)
    {
        DWORD   fdwOpen;

        DPF(3, "mapDriverOpenWave: WAVE_MAPPED flag specified");

        //
        //  The device ID to which to map was specified by MMSYSTEM in the
        //  uMappedDeviceID member of the WAVEOPENDESC structure passed in
        //  the WODM_OPEN message.  It was saved in pms->uMappedDeviceID by
        //  mapWaveOpen().
        //
        uDevId = pms->uMappedDeviceID;
        fdwOpen = CALLBACK_FUNCTION | LOWORD(pms->fdwOpen);
        fdwOpen &= ~WAVE_MAPPED;

        mmrReturn = pms->fnWaveOpen(&pms->hwReal,
                                    uDevId,
                                    pwfx,
                                    (DWORD_PTR)mapWaveCallback,
                                    (DWORD_PTR)pms,
                                    fdwOpen);

        DPF(3, "--->opening device %d--mmr=%u", uDevId, mmrReturn);

        if (MMSYSERR_NOERROR == mmrReturn)
        {
            pms->uIdReal = uDevId;
        }

        mapErrSetClientError(&pms->mmrClient, mmrReturn);
        return (mmrReturn);
    }

    //
    //	--==	==--
    //

    //
    //	Init some local vars
    //

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    if (pms->fInput)
    {
        uPrefDevId = gpag->pSettings->uIdPreferredIn;
        cNumDevs   = gpag->cWaveInDevs;
    }
    else
    {
        uPrefDevId = gpag->pSettings->uIdPreferredOut;
        cNumDevs   = gpag->cWaveOutDevs;
    }

    fTriedMappableId = FALSE;
    fFoundNonmappableId = FALSE;

    fPrefOnly = (WAVE_MAPPER == uPrefDevId) ? FALSE : gpag->pSettings->fPreferredOnly;

    mmrReturn = MMSYSERR_ERROR;

    RELEASE_MUTEX(gpag->hMutexSettings);

    //
    //	--== If we have a prefered device Id, then try opening it ==--
    //
    if (WAVE_MAPPER != uPrefDevId)
    {
        mmr = MMSYSERR_NOERROR;
        if (!fQuery)
        {
            mmr = pms->fnWaveOpen(&pms->hwReal,
        	                      uPrefDevId,
        	                      pwfx,
        	                      0L,
        	                      0L,
        	                      WAVE_FORMAT_QUERY | LOWORD(pms->fdwOpen));
            DPF(4, "---> querying preferred device %d--mmr=%u", uPrefDevId, mmr);
            DPF(4, "---> opened with flags = %08lx", WAVE_FORMAT_QUERY | LOWORD(pms->fdwOpen));

        }

        if (MMSYSERR_NOERROR == mmr)
        {
            mmr = pms->fnWaveOpen(&pms->hwReal,
                                  uPrefDevId,
                                  pwfx,
                                  (DWORD_PTR)mapWaveCallback,
                                  (DWORD_PTR)pms,
                                  CALLBACK_FUNCTION | LOWORD(pms->fdwOpen));
        }

        DPF(3, "---> opening preferred device %d--mmr=%u", uPrefDevId, mmr);
        DPF(3, "---> opened with flags = %08lx", CALLBACK_FUNCTION | LOWORD(pms->fdwOpen));

        mapErrSetClientError(&pms->mmrClient, mmr);
        mapErrSetError(&mmrReturn, mmr);

        if ((WAVERR_SYNC == mmr) && (fPrefOnly || (1 == cNumDevs)))
        {
            WAIT_FOR_MUTEX(gpag->hMutexSettings);

            if (pms->fInput)
            {
                DPF(1, "--->preferred only INPUT device is SYNCRONOUS!");
                gpag->pSettings->fSyncOnlyIn  = TRUE;
            }
            else
            {
                DPF(1, "--->preferred only OUTPUT device is SYNCRONOUS!");
                gpag->pSettings->fSyncOnlyOut = TRUE;
            }

            RELEASE_MUTEX(gpag->hMutexSettings);

            return (mmrReturn);
        }

        if ((MMSYSERR_NOERROR == mmr) || fPrefOnly)
        {
            if (MMSYSERR_NOERROR == mmr)
            {
                pms->uIdReal = uPrefDevId;
            }

            return (mmrReturn);
        }

        fTriedMappableId = TRUE;
    }

    //
    //	The prefered ID didn't work.  Now we will step through each device
    //	ID and try to open it.  We'll skip the uPrefDevId since we already
    //	tried it above.  We will also skip device IDs that are not mappable
    //	devices (determined by sending DRV_QUERYMAPPABLE to the ID).
    //
    for (uDevId = 0; uDevId < cNumDevs; uDevId++)
    {

        if (uDevId == uPrefDevId)
            continue;

        mmr = pms->fnWaveMessage((HWAVE)LongToHandle(uDevId), DRV_QUERYMAPPABLE, 0L, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(3, "--->skipping non-mappable device %d", uDevId);
            fFoundNonmappableId = TRUE;
            continue;
        }

        if (!fQuery)
        {
            mmr = pms->fnWaveOpen(&pms->hwReal,
                                  uDevId,
                                  pwfx,
                                  0L,
                                  0L,
                                  WAVE_FORMAT_QUERY | LOWORD(pms->fdwOpen));
            DPF(4, "---> querying device %d--mmr=%u", uDevId, mmr);
        }

        if (MMSYSERR_NOERROR == mmr)
        {
            mmr = pms->fnWaveOpen(&pms->hwReal,
        	                      uDevId,
        	                      pwfx,
        	                      (DWORD_PTR)mapWaveCallback,
        	                      (DWORD_PTR)pms,
        	                      CALLBACK_FUNCTION | LOWORD(pms->fdwOpen));

            DPF(3, "---> opening device %d--mmr=%u", uDevId, mmr);
        }

        mapErrSetClientError(&pms->mmrClient, mmr);
        mapErrSetError( &mmrReturn, mmr );

        if (MMSYSERR_NOERROR == mmr)
        {
            pms->uIdReal = uDevId;
            return (mmrReturn);
        }

        fTriedMappableId = TRUE;

    }

    if (fFoundNonmappableId && !fTriedMappableId)
    {
        mapErrSetClientError(&pms->mmrClient, MMSYSERR_ALLOCATED);
        mapErrSetError(&mmrReturn, MMSYSERR_ALLOCATED);
    }

    return (mmrReturn);

} // mapDriverOpenWave()


//--------------------------------------------------------------------------;
//
//  BOOL FindBestPCMFormat
//
//  Description:
//
//
//  Arguments:
//      LPWAVEFORMATEX pwfx:
//
//      LPWAVEFORMATEX pwfPCM:
//
//      BOOL fInput:
//
//	UINT uDeviceId:
//
//
//  Return (BOOL):
//
//  History:
//	03/13/94    fdy	    [frankye]
//	    Expanded interface and function to take uDeviceId which specifies
//	    the wave device for which we want to FindBestPCMFormat.  fInput
//	    specifies whether this device is an input or output device.
//
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL FindBestPCMFormat
(
    LPWAVEFORMATEX      pwfx,
    LPWAVEFORMATEX      pwfxPCM,
    BOOL                fInput,
    UINT		uDeviceId
)
{
    BYTE            bChannels;
    BYTE            bBitsPerSample;
    UINT            uBlockAlign;
    UINT            i, j;
    UINT            w;
    UINT            uNeededBits;
    DWORD           dwPrevError;
    DWORD           dwError;
    DWORD           dwSamplesPerSec;
    UINT	    uFlags;

    //
    //  -= the PCM mis-mapper =-
    //
    //  i'm sure this will generate all sorts of neat bug reports and
    //  complaints, but this is the algorithm we use to choose a PCM
    //  format:
    //
    //  o   we regard stereo as very important to maintain. the reason
    //      for this is that if a file was authored as stereo, there
    //      was probably a good reason for doing so...
    //
    //  o   the next most important component is the sample frequency;
    //      we try to find the closest supported sample frequency
    //
    //  o   finally, we don't care about bits per sample
    //      so we'll try to maintain the input size and change it if
    //      we need to
    //
    dwSamplesPerSec = pwfx->nSamplesPerSec;
    bChannels       = (BYTE)pwfx->nChannels;


    //
    //  build a bit pattern that we can look for..
    //
findbest_Loop:

    uNeededBits = ZYZPCMF_OUT_M08 | ZYZPCMF_OUT_M16;
    if (bChannels == 2)
        uNeededBits <<= 1;

    if (fInput)
        uNeededBits <<= 8;

    dwPrevError = (DWORD)-1;

    //
    //  first find the closest sample rate that supports the current number
    //  of channels
    //
    for (j = (UINT)-1, i = 0; gaPCMFormats[i].uSamplesPerSec; i++)
    {
        //
        //  if no bits that we are looking for are set, then continue
        //  searching--if any of our bits are set, then check if this
        //  sample rate is better than our previous choice...
        //
	uFlags = fInput ? gaPCMFormats[i].uFlagsInput[uDeviceId] : gaPCMFormats[i].uFlagsOutput[uDeviceId];
        if (uFlags & uNeededBits)
        {
            if (dwSamplesPerSec > (DWORD)gaPCMFormats[i].uSamplesPerSec)
                dwError = dwSamplesPerSec - gaPCMFormats[i].uSamplesPerSec;
            else
                dwError = (DWORD)gaPCMFormats[i].uSamplesPerSec - dwSamplesPerSec;

            if (dwError < dwPrevError)
            {
                j = i;
                dwPrevError = dwError;
            }
        }
    }


    //
    //  if we didn't find a format that will work, then shift the channels
    //  around and try again...
    //
    if (j == (UINT)-1)
    {
        //
        //  if we already tried channel shifting, then we're hosed... this
        //  would probably mean that no wave devices are installed that
        //  can go in fInput... like if the person only has the PC
        //  Squeaker--you cannot record...
        //
        if ((BYTE)pwfx->nChannels != bChannels)
        {
            DPF(0, "!FindBestPCMFormat: failed to find suitable format!");
            return (FALSE);
        }

        //
        //  shift the channels and try again
        //
        bChannels = (bChannels == (BYTE)2) ? (BYTE)1 : (BYTE)2;
        goto findbest_Loop;
    }


    //
    //  j           = the index to the format that we should be using
    //  uNeededBits = the bits used to find 'j'
    //  fInput      = the direction we are trying to go with the data
    //  bChannels   = the number of channels that we need to use
    //
    uFlags = fInput ? gaPCMFormats[j].uFlagsInput[uDeviceId] : gaPCMFormats[j].uFlagsOutput[uDeviceId];
    w = uFlags & uNeededBits;

    //
    //  normalize our bits to Mono Output--relative bit positions are the
    //  same for input/output stereo/mono
    //
    if (fInput)
        w >>= 8;

    if (bChannels == 2)
        w >>= 1;

    //
    //  if both 8 and 16 bit are supported by the out device AND the source
    //  format is PCM, then use the one that matches the source format
    //
    if ((pwfx->wFormatTag == WAVE_FORMAT_PCM) && ((w & ZYZPCMF_OUT_MONO) == ZYZPCMF_OUT_MONO))
    {
        bBitsPerSample = (BYTE)pwfx->wBitsPerSample;
    }

    //
    //  either not PCM source or device does not support both 8 and 16 bit;
    //  so choose whatever is available for the destination
    //
    else
    {
        bBitsPerSample  = (w & ZYZPCMF_OUT_M16) ? (BYTE)16 : (BYTE)8;
    }

    dwSamplesPerSec = gaPCMFormats[j].uSamplesPerSec;
    uBlockAlign     = ((bBitsPerSample >> 3) << (bChannels >> 1));


    //
    //  finally fill in the PCM destination format structure with the PCM
    //  format we decided is 'best'
    //
    pwfxPCM->wFormatTag      = WAVE_FORMAT_PCM;
    pwfxPCM->nChannels       = bChannels;
    pwfxPCM->nBlockAlign     = (WORD)uBlockAlign;
    pwfxPCM->nSamplesPerSec  = dwSamplesPerSec;
    pwfxPCM->nAvgBytesPerSec = dwSamplesPerSec * uBlockAlign;
    pwfxPCM->wBitsPerSample  = bBitsPerSample;

    return (TRUE);
} // FindBestPCMFormat()



//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod0
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod0
(
    LPMAPSTREAM         pms
)
{
    MMRESULT        mmr;

    //
    //  suggest anything!
    //
    mmr = acmFormatSuggest(pms->had,
                           pms->pwfxClient,
                           pms->pwfxReal,
                           pms->cbwfxReal,
                           0L);

    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  can it open real time?
        //
        mmr = acmStreamOpen(NULL,
                            pms->had,
                            pms->pwfxSrc,
                            pms->pwfxDst,
                            NULL,
                            0L,
                            0L,
                            ACM_STREAMOPENF_QUERY);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (WAVERR_BADFORMAT);
        }

        mmr = mapDriverOpenWave(pms, pms->pwfxReal);
    }
    else
    {
        mmr = WAVERR_BADFORMAT;
    }

    return (mmr);
} // mapDriverFindMethod0()


//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod1
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod1
(
    LPMAPSTREAM         pms
)
{
    MMRESULT    mmr;

    //
    //  suggest PCM format for the Client
    //
    pms->pwfxReal->wFormatTag = WAVE_FORMAT_PCM;

    mmr = acmFormatSuggest(pms->had,
                           pms->pwfxClient,
                           pms->pwfxReal,
                           pms->cbwfxReal,
                           ACM_FORMATSUGGESTF_WFORMATTAG);

    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  can it open real time?
        //
        mmr = acmStreamOpen(NULL,
                            pms->had,
                            pms->pwfxSrc,
                            pms->pwfxDst,
                            NULL,
                            0L,
                            0L,
                            ACM_STREAMOPENF_QUERY);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (WAVERR_BADFORMAT);
        }

        mmr = mapDriverOpenWave(pms, pms->pwfxReal);
    }
    else
    {
        mmr = WAVERR_BADFORMAT;
    }

    return (mmr);
} // mapDriverFindMethod1()


//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod2
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod2
(
    LPMAPSTREAM         pms
)
{
    MMRESULT    mmr;

    //
    //  suggest MONO PCM format for the Client
    //
    pms->pwfxReal->wFormatTag = WAVE_FORMAT_PCM;
    pms->pwfxReal->nChannels  = 1;

    mmr = acmFormatSuggest(pms->had,
                           pms->pwfxClient,
                           pms->pwfxReal,
                           pms->cbwfxReal,
                           ACM_FORMATSUGGESTF_WFORMATTAG |
                           ACM_FORMATSUGGESTF_NCHANNELS);

    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  can it open real time?
        //
        mmr = acmStreamOpen(NULL,
                            pms->had,
                            pms->pwfxSrc,
                            pms->pwfxDst,
                            NULL,
                            0L,
                            0L,
                            ACM_STREAMOPENF_QUERY);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (WAVERR_BADFORMAT);
        }

        mmr = mapDriverOpenWave(pms, pms->pwfxReal);
    }
    else
    {
        mmr = WAVERR_BADFORMAT;
    }

    return (mmr);
} // mapDriverFindMethod2()


//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod3
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod3
(
    LPMAPSTREAM         pms
)
{
    MMRESULT    mmr;

    //
    //  suggest 8 bit PCM format for the Client
    //
    pms->pwfxReal->wFormatTag     = WAVE_FORMAT_PCM;
    pms->pwfxReal->wBitsPerSample = 8;

    mmr = acmFormatSuggest(pms->had,
                           pms->pwfxClient,
                           pms->pwfxReal,
                           pms->cbwfxReal,
                           ACM_FORMATSUGGESTF_WFORMATTAG |
                           ACM_FORMATSUGGESTF_WBITSPERSAMPLE);

    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  can it open real time?
        //
        mmr = acmStreamOpen(NULL,
                            pms->had,
                            pms->pwfxSrc,
                            pms->pwfxDst,
                            NULL,
                            0L,
                            0L,
                            ACM_STREAMOPENF_QUERY);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (WAVERR_BADFORMAT);
        }

        mmr = mapDriverOpenWave(pms, pms->pwfxReal);
    }
    else
    {
        mmr = WAVERR_BADFORMAT;
    }

    return (mmr);
} // mapDriverFindMethod3()


//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod4
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod4
(
    LPMAPSTREAM         pms
)
{
    MMRESULT    mmr;

    //
    //  suggest 8 bit MONO PCM format for the Client
    //
    pms->pwfxReal->wFormatTag     = WAVE_FORMAT_PCM;
    pms->pwfxReal->nChannels      = 1;
    pms->pwfxReal->wBitsPerSample = 8;

    mmr = acmFormatSuggest(pms->had,
                           pms->pwfxClient,
                           pms->pwfxReal,
                           pms->cbwfxReal,
                           ACM_FORMATSUGGESTF_WFORMATTAG |
                           ACM_FORMATSUGGESTF_NCHANNELS |
                           ACM_FORMATSUGGESTF_WBITSPERSAMPLE);

    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  can it open real time?
        //
        mmr = acmStreamOpen(NULL,
                            pms->had,
                            pms->pwfxSrc,
                            pms->pwfxDst,
                            NULL,
                            0L,
                            0L,
                            ACM_STREAMOPENF_QUERY);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (WAVERR_BADFORMAT);
        }

        mmr = mapDriverOpenWave(pms, pms->pwfxReal);
    }
    else
    {
        mmr = WAVERR_BADFORMAT;
    }

    return (mmr);
} // mapDriverFindMethod4()


//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod5
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//	03/13/94    fdy	    [frankye]
//	    Modified function to first try to find the best pcm format for
//	    the prefered device, and if that fails, then try for each wave
//	    device that exists in the system.
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod5
(
    LPMAPSTREAM             pms
)
{
    MMRESULT            mmr;
    UINT		uPrefDevId;
    UINT		cNumDevs;
    BOOL		fPrefOnly;
    UINT		i;
    PACMFORMATRESULTS   pafr;

    //
    //
    //

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    if (pms->fInput)
    {
        uPrefDevId = gpag->pSettings->uIdPreferredIn;
        cNumDevs   = gpag->cWaveInDevs;
    }
    else
    {
        uPrefDevId = gpag->pSettings->uIdPreferredOut;
        cNumDevs   = gpag->cWaveOutDevs;
    }
    fPrefOnly = (WAVE_MAPPER == uPrefDevId) ? FALSE : gpag->pSettings->fPreferredOnly;

    //
    //
    //
    
    pafr = (PACMFORMATRESULTS)GlobalAllocPtr(GMEM_FIXED|GMEM_SHARE|GMEM_ZEROINIT, cNumDevs * sizeof(ACMFORMATRESULTS));
    if (NULL == pafr)
    {
        RELEASE_MUTEX(gpag->hMutexSettings);
        return (MMSYSERR_NOMEM);
    }

    for (i=0; i < cNumDevs; i++)
    {
        pafr[i].fSuccess = FindBestPCMFormat(pms->pwfxClient, &(pafr[i].wfx), pms->fInput, i);
    }

    RELEASE_MUTEX(gpag->hMutexSettings);

    //
    //
    //
    mmr = WAVERR_BADFORMAT;
    if ((-1) != uPrefDevId)
    {
        pms->pwfxReal->wFormatTag      = pafr[uPrefDevId].wfx.wFormatTag;
        pms->pwfxReal->nChannels       = pafr[uPrefDevId].wfx.nChannels;
        pms->pwfxReal->nBlockAlign     = pafr[uPrefDevId].wfx.nBlockAlign;
        pms->pwfxReal->nSamplesPerSec  = pafr[uPrefDevId].wfx.nSamplesPerSec;
        pms->pwfxReal->nAvgBytesPerSec = pafr[uPrefDevId].wfx.nAvgBytesPerSec;
        pms->pwfxReal->wBitsPerSample  = pafr[uPrefDevId].wfx.wBitsPerSample;
        
	if (pafr[uPrefDevId].fSuccess)
	{
	    mmr = acmStreamOpen(NULL,
				pms->had,
				pms->pwfxSrc,
				pms->pwfxDst,
				NULL,
				0L,
				0L,
				ACM_STREAMOPENF_QUERY);
	    if (MMSYSERR_NOERROR == mmr)
	    {
		mmr = mapDriverOpenWave(pms, pms->pwfxReal);
	    }
	    else
	    {
		mmr = WAVERR_BADFORMAT;
	    }
	}
    }

    if ( (MMSYSERR_NOERROR != mmr) && (!fPrefOnly) )
    {
	for (i=0; i < cNumDevs; i++)
	{
	    if (i == uPrefDevId)
	    {
		//
		//  Already tried this one.
		//
		continue;
	    }
	
            pms->pwfxReal->wFormatTag      = pafr[i].wfx.wFormatTag;
            pms->pwfxReal->nChannels       = pafr[i].wfx.nChannels;
            pms->pwfxReal->nBlockAlign     = pafr[i].wfx.nBlockAlign;
            pms->pwfxReal->nSamplesPerSec  = pafr[i].wfx.nSamplesPerSec;
            pms->pwfxReal->nAvgBytesPerSec = pafr[i].wfx.nAvgBytesPerSec;
            pms->pwfxReal->wBitsPerSample  = pafr[i].wfx.wBitsPerSample;
        
	    if (pafr[i].fSuccess)
	    {
		mmr = acmStreamOpen(NULL,
				    pms->had,
				    pms->pwfxSrc,
				    pms->pwfxDst,
				    NULL,
				    0L,
				    0L,
				    ACM_STREAMOPENF_QUERY);
		if (MMSYSERR_NOERROR == mmr)
		{
		    mmr = mapDriverOpenWave(pms, pms->pwfxReal);
		}
		else
		{
		    mmr = WAVERR_BADFORMAT;
		}
	    }
	
	    if (MMSYSERR_NOERROR == mmr)
	    {
		break;
	    }
	}
    }

    GlobalFreePtr(pafr);

    return (mmr);
} // mapDriverFindMethod5()


//--------------------------------------------------------------------------;
//
//  BOOL mapDriverEnumCallback
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD_PTR dwInstance:
//
//      DWORD fdwSupport:
//
//  Return (BOOL):
//
//  History:
//      09/18/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNCALLBACK mapDriverEnumCallback
(
    HACMDRIVERID            hadid,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    LPMAPSTREAM         pms;
    MMRESULT            mmr;
    ACMFORMATTAGDETAILS aftd;


    pms = (LPMAPSTREAM)dwInstance;

    //
    //  check if support required
    //
    if (0 == (pms->fdwSupport & fdwSupport))
    {
        //
        //  skip to next driver..
        //
        return (TRUE);
    }

    aftd.cbStruct    = sizeof(aftd);
    aftd.dwFormatTag = pms->pwfxClient->wFormatTag;
    aftd.fdwSupport  = 0L;

    mmr = acmFormatTagDetails((HACMDRIVER)hadid,
                              &aftd,
                              ACM_FORMATTAGDETAILSF_FORMATTAG);
    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    if (0 == (pms->fdwSupport & aftd.fdwSupport))
    {
        return (TRUE);
    }

    mmr = acmDriverOpen(&pms->had, hadid, 0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    switch (pms->uHeuristic)
    {
        case 0:
            //
            //  try 'any' suggested destination
            //
            mmr = mapDriverFindMethod0(pms);
            break;

        case 1:
            //
            //  try 'any PCM' suggested destination
            //
            mmr = mapDriverFindMethod1(pms);
            break;

        case 2:
            //
            //  try 'any mono PCM' suggested destination
            //
            mmr = mapDriverFindMethod2(pms);
            break;

        case 3:
            //
            //  try 'any 8 bit PCM' suggested destination
            //
            mmr = mapDriverFindMethod3(pms);
            break;

        case 4:
            //
            //  try 'any mono 8 bit PCM' suggested destination
            //
            mmr = mapDriverFindMethod4(pms);
            break;

        case 5:
            //
            //  search for best PCM format available by wave hardware
            //
            mmr = mapDriverFindMethod5(pms);
            break;
    }

    pms->mmrClient = mmr;

    if (MMSYSERR_NOERROR == mmr)
    {
        return (FALSE);
    }

    acmDriverClose(pms->had, 0L);
    pms->had = NULL;

    return (TRUE);
} // mapDriverEnumCallback()


//--------------------------------------------------------------------------;
//
//  MMRESULT FindConverterMatch
//
//  Description:
//      Test all drivers to see if one can convert the requested format
//      into a format supported by an available wave device
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL FindConverterMatch
(
    LPMAPSTREAM      pms
)
{
    MMRESULT        mmr;
    int             iHeuristic;
    DWORD           fdwSupport;


    //
    //  for the 'suggest PCM ' passes, allow what is needed
    //
    if (WAVE_FORMAT_PCM == pms->pwfxClient->wFormatTag)
    {
        fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CONVERTER;
    }
    else
    {
        fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    }


    //
    //
    //
    //
    //
    pms->mmrClient = WAVERR_BADFORMAT;

    pms->had  = NULL;
    for (iHeuristic = 0; iHeuristic < MAX_HEURISTIC; iHeuristic++)
    {
        pms->uHeuristic = iHeuristic;

        if (0 == iHeuristic)
        {
            //
            //  for the 'suggest anything' pass, allow converters and codecs
            //
            pms->fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CONVERTER |
                              ACMDRIVERDETAILS_SUPPORTF_CODEC;
        }
        else
        {
            //
            //  for the 'suggest PCM ' passes, allow what is needed
            //
            pms->fdwSupport = fdwSupport;
        }

        mmr = acmDriverEnum(mapDriverEnumCallback, (DWORD_PTR)pms, 0L);
        if (MMSYSERR_NOERROR == mmr)
        {
            if (NULL != pms->had)
            {
                return (MMSYSERR_NOERROR);
            }
        }
    }

    return (pms->mmrClient);
} // FindConverterMatch()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD mapWaveClose
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (DWORD):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL mapWaveClose
(
    LPMAPSTREAM             pms
)
{
    MMRESULT            mmr;

    //
    //
    //
    mmr = pms->fnWaveClose(pms->hwReal);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!mapWaveClose: physical device failed close! mmr=%u", mmr);
        return (mmr);
    }

    //
    //  if this is input and its background task is alive, kill it
    //
    if (pms->fInput && (0 != pms->htaskInput))
    {
#ifdef WIN32
        PostAppMessage(pms->htaskInput, WM_QUIT, 0, 0L);
        WaitForSingleObject(pms->hInput, INFINITE);
        CloseHandle(pms->hInput);
        CloseHandle(pms->hStoppedEvent);
#else
        if ((0 == gpag->cInputStreams) || (NULL == gpag->htaskInput))
        {
            DPF(0, "!input mapping htask=%.04Xh, reference count=%u?!?",
                gpag->htaskInput, gpag->cInputStreams);

            //
            //  should NEVER happen, but if it does make sure we don't blow
            //
            gpag->cInputStreams = 0;
            gpag->htaskInput    = NULL;

            pms->htaskInput     = NULL;
        }
        else
        {
#ifdef DEBUG
            if (pms->htaskInput != gpag->htaskInput)
            {
                DPF(0, "!pms->htaskInput=%.04Xh != gpag->htaskInput%.04Xh!",
                    pms->htaskInput, gpag->htaskInput);
            }
#endif

            gpag->cInputStreams--;

            if (0 != gpag->cInputStreams)
            {
                //
                //  yield to input mapping task--this will allow all
                //  unserviced messages to be processed. this could be made
                //  better and will have to be for win 32...
                //
                DPF(1, "YIELDING to background input mapping task=%.04Xh", gpag->htaskInput);
                if (IsTask(gpag->htaskInput))
                {
                    DirectedYield(gpag->htaskInput);
                }
                else
                {
                    DPF(0, "!gpag->taskInput=%.04Xh is dead!", gpag->htaskInput);

                    gpag->cInputStreams = 0;
                    gpag->htaskInput    = NULL;
                }
                DPF(1, "done YIELDING to background input mapping task=%.04Xh", gpag->htaskInput);
            }
            else
            {
                //
                //  destroy converter task and yield to it until all
                //  messages get pumped through...
                //
                DPF(1, "KILLING background input mapping task=%.04Xh", gpag->htaskInput);

                if (gpag->htaskInput != NULL) {
                    PostAppMessage(gpag->htaskInput, WM_QUIT, 0, 0L);
                    while (IsTask(gpag->htaskInput))
                    {
                        DirectedYield(gpag->htaskInput);
                    }
                }

                DPF(1, "done killing background input mapping task=%.04Xh", gpag->htaskInput);
                gpag->htaskInput = NULL;
            }

            pms->htaskInput = NULL;
        }
#endif // !WIN32
    }

    //
    //  done with stream (and driver)...
    //
    if (NULL != pms->has)
    {
        acmStreamClose(pms->has, 0L);
        acmDriverClose(pms->had, 0L);

        if (pms->fInput)
        {
            //
            //  this must be done _AFTER_ destroying our background input
            //  mapping task
            //
            mapWaveDriverCallback(pms, WIM_CLOSE, 0L, 0L);
        }
	else
	{
	    //
	    //	this must be done _AFTER_ the calls the ACM APIs since
	    //	some versions of the ACM will yield within its APIs.
	    //	Otherwise, for MCIWAVE, the signal to the MCIWAVE background
	    //	task would occur prematurely.
	    //
	    mapWaveDriverCallback(pms, WOM_CLOSE, 0L, 0L);
	}
    }

    //
    //  free the allocated memory for our mapping stream instance
    //
    GlobalFreePtr(pms);

    return (MMSYSERR_NOERROR);
} // mapWaveClose()


//--------------------------------------------------------------------------;
//
//  DWORD mapWaveOpen
//
//  Description:
//
//
//  Arguments:
//      BOOL fInput:
//
//      UINT uId:
//
//      DWORD dwUser:
//
//      LPWAVEOPENDESC pwod:
//
//      DWORD fdwOpen:
//
//  Return (DWORD):
//
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL mapWaveOpen
(
    BOOL                    fInput,
    UINT                    uId,
    DWORD_PTR               dwUser,
    LPWAVEOPENDESC          pwod,
    DWORD                   fdwOpen
)
{
    MMRESULT            mmr;
    LPMAPSTREAM         pms;        // pointer to per-instance info struct
    LPMAPSTREAM         pmsT;       // temp stream pointer
    DWORD               cbms;
    LPWAVEFORMATEX      pwfx;       // pointer to passed format
    UINT                cbwfxSrc;
    DWORD               cbwfxDst;
    BOOL                fQuery;
    BOOL                fAsync;


    //
    //
    //
    fQuery = (0 != (WAVE_FORMAT_QUERY & fdwOpen));
    fAsync = (0 == (WAVE_ALLOWSYNC & fdwOpen));
    pwfx   = (LPWAVEFORMATEX)pwod->lpFormat;

    DPF(2, "mapWaveOpen(%s,%s,%s): Tag=%u, %lu Hz, %u Bit, %u Channel(s)",
            fInput ? (LPSTR)"in" : (LPSTR)"out",
            fQuery ? (LPSTR)"query" : (LPSTR)"real",
            fAsync ? (LPSTR)"async" : (LPSTR)"SYNC",
            pwfx->wFormatTag,
            pwfx->nSamplesPerSec,
            pwfx->wBitsPerSample,
            pwfx->nChannels);

    if (gpag->fPrestoSyncAsync)
    {
        fdwOpen |= WAVE_ALLOWSYNC;
        fAsync   = FALSE;
    }

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    if (fAsync)
    {
        if (fInput)
        {
            if (gpag->pSettings->fSyncOnlyIn)
            {
                DPF(1, "--->failing because input device is syncronous!");
                RELEASE_MUTEX(gpag->hMutexSettings);
                return (WAVERR_SYNC);
            }
        }
        else
        {
            if (gpag->pSettings->fSyncOnlyOut)
            {
                DPF(1, "--->failing because output device is syncronous!");
                RELEASE_MUTEX(gpag->hMutexSettings);
                return (WAVERR_SYNC);
            }
        }
    }

    RELEASE_MUTEX(gpag->hMutexSettings);


    //
    //  determine how big the complete wave format header is--this is the
    //  size of the extended waveformat structure plus the cbSize field.
    //  note that for PCM, this is only sizeof(PCMWAVEFORMAT)
    //
    if (WAVE_FORMAT_PCM == pwfx->wFormatTag)
    {
        cbwfxSrc = sizeof(PCMWAVEFORMAT);
    }
    else
    {
        //
        //  because MMSYSTEM does not (currently) validate for the extended
        //  format information, we validate this pointer--this will keep
        //  noelc and davidmay from crashing Windows with corrupt files.
        //
        cbwfxSrc = sizeof(WAVEFORMATEX) + pwfx->cbSize;
        if (IsBadReadPtr(pwfx, cbwfxSrc))
        {
            return (MMSYSERR_INVALPARAM);
        }
    }


    //
    //  allocate mapping stream instance structure
    //
    //  for Win 16, this structure must be _page locked in global space_
    //  so our low level interrupt time callbacks can munge the headers
    //  without exploding
    //
    //  size is the struct size + size of one known format + largest
    //  possible mapped destination format size.  We don't determine
    //	the size of the largest possible mapped destination format until
    //	we know we do in fact have to map this format.  When we make this
    //	determination, we will realloc this.
	//
    cbms = sizeof(*pms) + cbwfxSrc;
    pms  = (LPMAPSTREAM)GlobalAllocPtr(GMEM_FIXED|GMEM_SHARE|GMEM_ZEROINIT, cbms);
    if (NULL == pms)
    {
        DPF(0, "!mapWaveOpen(): could not alloc %lu bytes for map stream!", cbms);
        return (MMSYSERR_NOMEM);
    }


    //
    //  now fill it with info
    //
    pms->fInput      = fInput;
    pms->fdwOpen     = fdwOpen;
    pms->dwCallback  = pwod->dwCallback;
    pms->dwInstance  = pwod->dwInstance;
    pms->hwClient    = pwod->hWave;
    if (fdwOpen & WAVE_MAPPED)
    {
	    pms->uMappedDeviceID = pwod->uMappedDeviceID;
    }
    pms->pwfxClient  = (LPWAVEFORMATEX)(pms + 1);
    pms->pwfxReal    = NULL;	// filled in later if needed
    pms->cbwfxReal   = 0;	// filled in later if needed
    pms->uIdReal     = (UINT)-1;

    _fmemcpy(pms->pwfxClient, pwfx, cbwfxSrc);


    //
    //  set up our function jump table so we don't have to constantly
    //  check for input vs output--makes for smaller and faster code.
    //
    if (fInput)
    {
        pms->fnWaveOpen            = (MAPPEDWAVEOPEN)waveInOpen;
        pms->fnWaveClose           = (MAPPEDWAVECLOSE)waveInClose;
        pms->fnWavePrepareHeader   = (MAPPEDWAVEPREPAREHEADER)waveInPrepareHeader;
        pms->fnWaveUnprepareHeader = (MAPPEDWAVEUNPREPAREHEADER)waveInUnprepareHeader;
        pms->fnWaveWrite           = (MAPPEDWAVEWRITE)waveInAddBuffer;
        pms->fnWaveGetPosition     = (MAPPEDWAVEGETPOSITION)waveInGetPosition;
        pms->fnWaveMessage         = (MAPPEDWAVEMESSAGE)waveInMessage;
    }
    else
    {
        pms->fnWaveOpen            = (MAPPEDWAVEOPEN)waveOutOpen;
        pms->fnWaveClose           = (MAPPEDWAVECLOSE)waveOutClose;
        pms->fnWavePrepareHeader   = (MAPPEDWAVEPREPAREHEADER)waveOutPrepareHeader;
        pms->fnWaveUnprepareHeader = (MAPPEDWAVEUNPREPAREHEADER)waveOutUnprepareHeader;
        pms->fnWaveWrite           = (MAPPEDWAVEWRITE)waveOutWrite;
        pms->fnWaveGetPosition     = (MAPPEDWAVEGETPOSITION)waveOutGetPosition;
        pms->fnWaveMessage         = (MAPPEDWAVEMESSAGE)waveOutMessage;
    }


    //
    //  give mmsystem an instance dword that will be passed back to the
    //  mapper on all subsequent calls..
    //
    *((PDWORD_PTR)dwUser) = (DWORD_PTR)pms;


    //
    //  try to open another *real* wave device with this format
    //  if another device can deal with the format we will do
    //  nothing but act as a pass through
    //
    //  if someone could open the format, go into passthrough mode.
    //
    pms->mmrClient = MMSYSERR_ERROR;
    mmr = mapDriverOpenWave(pms, pwfx);
    if (MMSYSERR_NOERROR == mmr)
    {
#ifdef DEBUG
{
        if (DbgGetLevel() > 2)
        {
            if (fInput)
            {
                WAVEINCAPS      wic;

                waveInGetDevCaps(pms->uIdReal, &wic, sizeof(wic));
                wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

                DPF(3, "--->'" DEVFMT_STR "' native support succeeded.", (LPTSTR)wic.szPname);
            }
            else
            {
                WAVEOUTCAPS     woc;

                waveOutGetDevCaps(pms->uIdReal, &woc, sizeof(woc));
                woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

                DPF(3, "--->'" DEVFMT_STR "' native support succeeded.", (LPTSTR)woc.szPname);
            }
        }
}
#endif

        if (fQuery)
        {
            GlobalFreePtr(pms);
        }
        return (MMSYSERR_NOERROR);
    }

    //
    //	If this was a WAVE_FORMAT_DIRECT then don't bother
    //	trying to setup a conversion stream.  Note WAVE_FORMAT_DIRECT is
    //	new for Win95.
    //
    if (0 != (WAVE_FORMAT_DIRECT & pms->fdwOpen))
    {
	    mmr = pms->mmrClient;
	    GlobalFreePtr(pms);
	    return mmr;
    }

    //
    //	If all devices are allocated, don't go on to try to create
    //	a conversion stream.
    //
    if (MMSYSERR_ALLOCATED == mmr)
    {
        mmr = pms->mmrClient;
        GlobalFreePtr(pms);
        return mmr;
    }

    //
    //	There was at least one unallocated device that could not open
    //	the format.
    //
    //  determine size of largest possible mapped destination format and
    //	fill in all the necessary remaining pms information required
    //	for mapping.
    //

    mmr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &cbwfxDst);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!mapWaveOpen() FAILING BECAUSE MAX FORMAT SIZE UNKNOWN?");
		GlobalFreePtr(pms);
        return (MMSYSERR_ERROR);
    }

    cbms = sizeof(*pms) + cbwfxSrc + cbwfxDst;
    pmsT = pms;
    pms  = (LPMAPSTREAM)GlobalReAllocPtr(pmsT, cbms, GMEM_MOVEABLE|GMEM_ZEROINIT);
    if (NULL == pms)
    {
        DPF(0, "!mapWaveOpen(): could not realloc %lu bytes for map stream!", cbms);
		GlobalFreePtr(pmsT);
        return (MMSYSERR_NOMEM);
    }

    //
    //  now fill in remaining info necessary for mapping.
    //
    pms->pwfxClient  = (LPWAVEFORMATEX)(pms + 1);
    pms->pwfxReal    = (LPWAVEFORMATEX)((LPBYTE)(pms + 1) + cbwfxSrc);
    pms->cbwfxReal   = cbwfxDst;
    if (fInput)
    {
        pms->pwfxSrc = pms->pwfxReal;
        pms->pwfxDst = pms->pwfxClient;
    }
    else
    {
        pms->pwfxSrc = pms->pwfxClient;
        pms->pwfxDst = pms->pwfxReal;
    }


    //
    //  give mmsystem an instance dword that will be passed back to the
    //  mapper on all subsequent calls.  this was done earlier but pms
    //	may have changed since we've done a GlobalReAllocPtr.
    //
    *((PDWORD_PTR)dwUser) = (DWORD_PTR)pms;

    //
    //  no one could open the format
    //
    mmr = FindConverterMatch(pms);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(2, "--->failing open, unable to find supporting ACM driver!");

        //
        //  return the error we got when attempting to open a
        //  converter /  wave driver...
        //
        GlobalFreePtr(pms);
        return (mmr);
    }


    //
    //
    //
    DPF(2, "--->MAPPING TO: Tag=%u, %lu Hz, %u Bit, %u Channel(s)",
            pms->pwfxReal->wFormatTag,
            pms->pwfxReal->nSamplesPerSec,
            pms->pwfxReal->wBitsPerSample,
            pms->pwfxReal->nChannels);

    if (fQuery)
    {
        acmDriverClose(pms->had, 0L);
        GlobalFreePtr(pms);

        return (MMSYSERR_NOERROR);
    }


    //
    //
    //
    mmr = acmStreamOpen(&pms->has,
                        pms->had,
                        pms->pwfxSrc,
                        pms->pwfxDst,
                        NULL,
                        0L,
                        0L,
                        0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!mapWaveOpen: opening stream failed! mmr=%u", mmr);

        pms->fnWaveClose(pms->hwReal);

        acmDriverClose(pms->had, 0L);
        GlobalFreePtr(pms);

        if (mmr < WAVERR_BASE)
        {
            return (mmr);
        }

        return (WAVERR_BADFORMAT);
    }

    //
    //
    //
    if (fInput)
    {
#ifndef WIN32
        if ((NULL == gpag->htaskInput) || !IsTask(gpag->htaskInput))
#endif
	{
#ifndef WIN32
	    if (0 != gpag->cInputStreams)
	    {
                DPF(0, "!cInputStreams=%u and should be zero! (gpag->htaskInput=%.04Xh)",
                    gpag->cInputStreams, gpag->htaskInput);

                gpag->cInputStreams = 0;
            }
#endif

#ifdef DEBUG
            gpag->fFaultAndDie = (BOOL)GetPrivateProfileInt(TEXT("msacm.drv"), TEXT("FaultAndDie"), 0, TEXT("system.ini"));
#endif

            //
            //  create the task to do the conversion in..
            //
#ifdef WIN32
            pms->nOutstanding = 0;
            if ((pms->hStoppedEvent = CreateEvent(NULL, FALSE, FALSE, NULL))
                == NULL ||
                (pms->hInput =
                   CreateThread(NULL,
                                300,
                                (LPTHREAD_START_ROUTINE)
                                   mapWaveInputConvertProc,
                                (LPVOID)pms->hStoppedEvent,
                                0,
                                (LPDWORD)&pms->htaskInput)) == NULL)
	    {
		if (pms->hStoppedEvent != NULL)
		{
		    CloseHandle(pms->hStoppedEvent);
                }
#else
	    gpag->htaskInput = NULL;
            if (mmTaskCreate((LPTASKCALLBACK)mapWaveInputConvertProc,
                             (HTASK FAR *)&gpag->htaskInput,
                             0L))
	    {
#endif
		DPF(0, "!mapWaveOpen: unable to create task for input mapping!");

		pms->fnWaveClose(pms->hwReal);

		acmStreamClose(pms->has, 0L);
		acmDriverClose(pms->had, 0L);

                GlobalFreePtr(pms);

                return (MMSYSERR_NOMEM);
	    }

            //
            //  make sure _at least one_ message is present in the background
            //  task's queue--this will keep DirectedYield from hanging
            //  in GetMessage if an app opens input with no callback and
            //  immediately closes the handle (like testing if the device
            //  is available--ACMAPP and WaveTst do this!).
            //
#ifndef WIN32
            PostAppMessage(gpag->htaskInput, WM_NULL, 0, 0L);
            DirectedYield(gpag->htaskInput);
#else
            //
            //  Make sure the thread has started - otherwise PostAppMessage
            //  won't work because the thread won't have a message queue.
            //

            WaitForSingleObject(pms->hStoppedEvent, INFINITE);
#endif // !WIN32
	}

	gpag->cInputStreams++;

#ifndef WIN32
	pms->htaskInput = gpag->htaskInput;
#endif


        //
        //  NOTE! we *MUST* send the WIM_OPEN callback _AFTER_ creating the
        //  input mapping task. our function callback (mapWaveCallback)
        //  simply eats the physical WIM_OPEN message. if this is not done
        //  this way, we get into a task lock with MCIWAVE's background
        //  task...
        //
        mapWaveDriverCallback(pms, WIM_OPEN, 0L, 0L);
    }
    else
    {
	//
	//  We send the WOM_OPEN callback here after opening the stream
	//  instead of in our function callback (mapWaveCallback).  Some
	//  versions of the acm cause a yield to occur within its APIs, and
	//  this would allow a signal to reach the MCIWAVE background task
	//  prematurely (it would get to the MCIWAVE background task before
	//  its state had changed from TASKIDLE to TASKBUSY).
	//
	mapWaveDriverCallback(pms, WOM_OPEN, 0L, 0L);
    }


    //
    //  made it! succeed the open
    //
    return (MMSYSERR_NOERROR);
} // mapWaveOpen()


//--------------------------------------------------------------------------;
//
//  DWORD mapWavePrepareHeader
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      LPWAVEHDR pwh:
//
//  Return (DWORD):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL mapWavePrepareHeader
(
    LPMAPSTREAM             pms,
    LPWAVEHDR               pwh
)
{
    MMRESULT            mmr;
    LPWAVEHDR           pwhShadow;
    LPACMSTREAMHEADER   pash;
    DWORD               cbShadow;
    DWORD               dwLen;
    DWORD               fdwSize;

    //
    //  if we are in convert mode, allocate a 'shadow' wave header
    //  and buffer to hold the converted wave bits
    //
    //  we need to pagelock the callers header but *not* his buffer
    //  because we touch it in wXdWaveMapCallback (to set the DONE bit)
    //
    //  here is the state of the dwUser and reserved fields in
    //  both buffers.
    //
    //      client's header (sent to the wavemapper by the 'user')
    //
    //          reserved        points to the stream header used for
    //                          conversions with the ACM. the wavemapper
    //                          is the driver so we can use this.
    //          dwUser          for use by the 'user' (client)
    //
    //      shadow header (sent to the real device by the wavemapper)
    //
    //          reserved        for use by the real device
    //          dwUser          points to the client's header. (the
    //                          wavemapper is the user in this case)
    //
    //      acm stream header (created by us for conversion work)
    //
    //          dwUser          points to mapper stream instance (pms)
    //          dwSrcUser       points to shadow header
    //          dwDstUser       original source buffer size (prepared with)
    //
    if (NULL == pms->has)
    {
        //
        //  no conversion required just pass through
        //
        mmr = pms->fnWavePrepareHeader(pms->hwReal, pwh, sizeof(WAVEHDR));

        return (mmr);
    }


    //
    //
    //
    //
    dwLen = pwh->dwBufferLength;
    if (pms->fInput)
    {
        UINT        u;

#ifndef WIN32
        if (!IsTask(pms->htaskInput))
        {
            DPF(0, "mapWavePrepareHeader: background task died! pms->htaskInput=%.04Xh", pms->htaskInput);

            pms->htaskInput = NULL;
            return (MMSYSERR_NOMEM);
        }
#endif // !WIN32

        //
        //  block align the destination buffer if the caller didn't read
        //  our documentation...
        //
        u = pms->pwfxClient->nBlockAlign;
        dwLen = (dwLen / u) * u;

#ifdef DEBUG
        if (dwLen != pwh->dwBufferLength)
        {
            DPF(1, "mapWavePrepareHeader: caller passed _unaligned_ buffer for recording (%lu->%lu)!",
                    pwh->dwBufferLength, dwLen);
        }
#endif

        //
        //  determine size for shadow buffer (the buffer that we will give
        //  to the _real_ device). give a _block aligned_ destination buffer
        //
        fdwSize = ACM_STREAMSIZEF_DESTINATION;
    }
    else
    {
        //
        //  determine size for the shadow buffer (this will be the buffer
        //  that we convert to before writing the data to the underlying
        //  device).
        //
        fdwSize = ACM_STREAMSIZEF_SOURCE;
    }

    mmr = acmStreamSize(pms->has, dwLen, &dwLen, fdwSize);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!mapWavePrepareHeader: failed to get conversion size! mmr=%u", mmr);
        return (MMSYSERR_NOMEM);
    }



    //
    //
    //
    DPF(2, "mapWavePrepareHeader(%s): Client=%lu Bytes, Shadow=%lu Bytes",
            pms->fInput ? (LPSTR)"in" : (LPSTR)"out",
            pwh->dwBufferLength,
            dwLen);


    //
    //  allocate the shadow WAVEHDR
    //
    //  NOTE: add four bytes to guard against GP faulting with stos/lods
    //  code that accesses the last byte/word/dword in a segment--very
    //  easy to do...
    //
    cbShadow  = sizeof(WAVEHDR) + sizeof(ACMSTREAMHEADER) + dwLen + 4;
    pwhShadow = (LPWAVEHDR)GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, cbShadow);
    if (NULL == pwhShadow)
    {
        DPF(0, "!mapWavePrepareHeader(): could not alloc %lu bytes for shadow!", cbShadow);
        return (MMSYSERR_NOMEM);
    }

    //
    //
    //
    pash = (LPACMSTREAMHEADER)(pwhShadow + 1);

    pash->cbStruct  = sizeof(*pash);
    pash->fdwStatus = 0L;
    pash->dwUser    = (DWORD_PTR)pms;


    //
    //  fill in the shadow wave header, the dwUser field will point
    //  back to the original header, so we can get back to it
    //
    pwhShadow->lpData          = (LPBYTE)(pash + 1);
    pwhShadow->dwBufferLength  = dwLen;
    pwhShadow->dwBytesRecorded = 0;
    pwhShadow->dwUser          = (DWORD_PTR)pwh;


    //
    //  now prepare the shadow wavehdr
    //
    if (pms->fInput)
    {
        pwhShadow->dwFlags = 0L;
        pwhShadow->dwLoops = 0L;

        //
        //  input: our source is the shadow (we get data from the
        //  physical device and convert it into the clients buffer)
        //
        pash->pbSrc         = pwhShadow->lpData;
        pash->cbSrcLength   = pwhShadow->dwBufferLength;
        pash->dwSrcUser     = (DWORD_PTR)pwhShadow;
        pash->pbDst         = pwh->lpData;
        pash->cbDstLength   = pwh->dwBufferLength;
        pash->dwDstUser     = pwhShadow->dwBufferLength;
    }
    else
    {
        pwhShadow->dwFlags = pwh->dwFlags & (WHDR_BEGINLOOP|WHDR_ENDLOOP);
        pwhShadow->dwLoops = pwh->dwLoops;

        //
        //  output: our source is the client (we get data from the
        //  client and convert it into something for the physical
        //  device)
        //
        pash->pbSrc         = pwh->lpData;
        pash->cbSrcLength   = pwh->dwBufferLength;
        pash->dwSrcUser     = (DWORD_PTR)pwhShadow;
        pash->pbDst         = pwhShadow->lpData;
        pash->cbDstLength   = pwhShadow->dwBufferLength;
        pash->dwDstUser     = pwh->dwBufferLength;
    }

    mmr = pms->fnWavePrepareHeader(pms->hwReal, pwhShadow, sizeof(WAVEHDR));
    if (MMSYSERR_NOERROR == mmr)
    {
        mmr = acmStreamPrepareHeader(pms->has, pash, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            pms->fnWaveUnprepareHeader(pms->hwReal, pwhShadow, sizeof(WAVEHDR));
        }
    }

    //
    //
    //
    if (MMSYSERR_NOERROR != mmr)
    {
        GlobalFreePtr(pwhShadow);
        return (mmr);
    }


    //
    //  now pagelock the callers header, only the header!!!
    //
    //  globalpagelock will pagelock the complete object--and this could
    //  be bad if the caller allocated the header as the first part
    //  of a large memory block. also globalpagelock only works on the
    //  _first_ selector of the tile...
    //
    //  not necessary in win 32.
    //
#ifndef WIN32
    acmHugePageLock((LPBYTE)pwh, sizeof(*pwh));
#endif

    //
    //  the reserved field of the callers WAVEHDR will contain the
    //  shadow LPWAVEHDR
    //
    pwh->reserved = (DWORD_PTR)pash;
    pwh->dwFlags |= WHDR_PREPARED;

    return (MMSYSERR_NOERROR);
} // mapWavePrepareHeader()


//--------------------------------------------------------------------------;
//
//  DWORD mapWaveUnprepareHeader
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      LPWAVEHDR pwh:
//
//  Return (DWORD):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL mapWaveUnprepareHeader
(
    LPMAPSTREAM         pms,
    LPWAVEHDR           pwh
)
{
    MMRESULT            mmr;
    LPWAVEHDR           pwhShadow;
    LPACMSTREAMHEADER   pash;
    DWORD               cbShadowData;

    //
    //  if we are not in convert mode, then passthrough to physical device
    //  otherwise, free the 'shadow' wave header and buffer, etc
    //
    if (NULL == pms->has)
    {
        //
        //  no conversion required just pass through
        //
        mmr = pms->fnWaveUnprepareHeader(pms->hwReal, pwh, sizeof(WAVEHDR));

        return (mmr);
    }

    //
    //
    //
    //
    //
    pash      = (LPACMSTREAMHEADER)pwh->reserved;
    pwhShadow = (LPWAVEHDR)pash->dwSrcUser;

    if (pms->fInput)
    {
        cbShadowData = (DWORD)pash->dwDstUser;

        pash->cbSrcLength = (DWORD)pash->dwDstUser;
////////pash->cbDstLength = xxx;        !!! don't touch this !!!
    }
    else
    {
        cbShadowData = pash->cbDstLength;

        pash->cbSrcLength = (DWORD)pash->dwDstUser;
////////pash->cbDstLength = xxx;        !!! don't touch this !!!
    }

    acmStreamUnprepareHeader(pms->has, pash, 0L);

    pwhShadow->dwBufferLength = cbShadowData;
    pms->fnWaveUnprepareHeader(pms->hwReal, pwhShadow, sizeof(WAVEHDR));


    //
    //  unprepare the shadow and caller's buffers (for the caller, this
    //  just means un-page lock the WAVEHDR)
    //
    //  we only page lock stuff in Win 16--not Win 32.
    //
#ifndef WIN32
    acmHugePageUnlock((LPBYTE)pwh, sizeof(*pwh));
#endif

    //
    //  free the shadow buffer--mark caller's wave header as unprepared
    //  and succeed the call
    //
    GlobalFreePtr(pwhShadow);

    pwh->reserved = 0L;
    pwh->dwFlags &= ~WHDR_PREPARED;

    return (MMSYSERR_NOERROR);
} // mapWaveUnprepareHeader()


//--------------------------------------------------------------------------;
//
//  DWORD mapWaveWriteBuffer
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      LPWAVEHDR pwh:
//
//  Return (DWORD):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL mapWaveWriteBuffer
(
    LPMAPSTREAM         pms,
    LPWAVEHDR           pwh
)
{
    MMRESULT            mmr;
    LPWAVEHDR           pwhShadow;
    LPACMSTREAMHEADER   pash;
    DWORD               cbShadowData;

    //
    //  no conversion required just pass through
    //
    if (NULL == pms->has)
    {
        mmr = pms->fnWaveWrite(pms->hwReal, pwh, sizeof(WAVEHDR));
        return (mmr);
    }

    //
    //
    //
    DPF(2, "mapWaveWriteBuffer(%s): Flags=%.08lXh, %lu Bytes, %lu Loops",
            pms->fInput ? (LPSTR)"in" : (LPSTR)"out",
            pwh->dwFlags,
            pwh->dwBufferLength,
            pwh->dwLoops);

    //
    //  get the conversion stream header...
    //
    pash = (LPACMSTREAMHEADER)pwh->reserved;
    if (NULL == pash)
    {
        DPF(0, "!mapWaveWriteBuffer: very strange--reserved field is 0???");
        return (WAVERR_UNPREPARED);
    }

    pwhShadow = (LPWAVEHDR)pash->dwSrcUser;

    if (pms->fInput)
    {
        UINT        u;

#ifndef WIN32
        if (!IsTask(pms->htaskInput))
        {
            DPF(0, "mapWaveWriteBuffer: background task died! pms->htaskInput=%.04Xh", pms->htaskInput);

            pms->htaskInput = NULL;
            return (MMSYSERR_NOMEM);
        }
#endif // !WIN32

        //
        //  again, we must block align the input buffer
        //
        //
        u = pms->pwfxClient->nBlockAlign;
        cbShadowData = (pwh->dwBufferLength / u) * u;

#ifdef DEBUG
        if (cbShadowData != pwh->dwBufferLength)
        {
            DPF(1, "mapWaveWriteBuffer: caller passed _unaligned_ buffer for recording (%lu->%lu)!",
                    pwh->dwBufferLength, cbShadowData);
        }
#endif

        //
        //  determine amount of data we need from the _real_ device. give a
        //  _block aligned_ destination buffer...
        //
        mmr = acmStreamSize(pms->has,
                            cbShadowData,
                            &cbShadowData,
                            ACM_STREAMSIZEF_DESTINATION);

        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(0, "!mapWaveWriteBuffer: failed to get conversion size! mmr=%u", mmr);
            return (MMSYSERR_NOMEM);
        }

        pwhShadow->dwBufferLength  = cbShadowData;
        pwhShadow->dwBytesRecorded = 0L;

        //
        //  clear the done bit of the caller's wave header (not done) and
        //  add the shadow buffer to the real (maybe) device's queue...
        //
        //  note that mmsystem _should_ be doing this for us, but alas
        //  it does not in win 3.1... i might fix this for chicago.
        //
        pwh->dwFlags &= ~WHDR_DONE;
    }
    else
    {
        //
        //  do the conversion
        //
        pash->cbDstLengthUsed = 0L;
        if (0L != pwh->dwBufferLength)
        {
            pash->pbSrc       = pwh->lpData;
            pash->cbSrcLength = pwh->dwBufferLength;
            pash->pbDst       = pwhShadow->lpData;
////////////pash->cbDstLength = xxx;        !!! leave as is !!!

            mmr = acmStreamConvert(pms->has, pash, 0L);
            if (MMSYSERR_NOERROR != mmr)
            {
                DPF(0, "!waveOutWrite: conversion failed! mmr=%.04Xh", mmr);
                pash->cbDstLengthUsed = 0L;
            }
        }

        if (0L == pash->cbDstLengthUsed)
        {
            DPF(1, "waveOutWrite: nothing converted--no data in output buffer.");
        }

        pwhShadow->dwFlags = pwh->dwFlags;
        pwhShadow->dwLoops = pwh->dwLoops;

        pwhShadow->dwBufferLength = pash->cbDstLengthUsed;
    }

    pwh->dwFlags |= WHDR_INQUEUE;
    mmr = pms->fnWaveWrite(pms->hwReal, pwhShadow, sizeof(WAVEHDR));
    if (MMSYSERR_NOERROR != mmr)
    {
        pwh->dwFlags &= ~WHDR_INQUEUE;
        DPF(0, "!pms->fnWaveWrite failed!, pms=%.08lXh, mmr=%u!", pms, mmr);
    }

    return (mmr);
} // mapWaveWriteBuffer()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      that the driver is opened, through the DrvOpen API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR           dwId,
    HDRVR               hdrvr,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    LRESULT         lr;
    LPDWORD         pdw;

    switch (uMsg)
    {
        case DRV_INSTALL:
            lr = mapDriverInstall(hdrvr);
            return (lr);

        case DRV_REMOVE:
            lr = mapDriverRemove(hdrvr);
            return (lr);

        case DRV_LOAD:
        case DRV_FREE:
            return (1L);

        case DRV_OPEN:
        case DRV_CLOSE:
            return (1L);

        case DRV_CONFIGURE:
        case DRV_QUERYCONFIGURE:
            return (0L);

        case DRV_ENABLE:
            lr = mapDriverEnable(hdrvr);
            return (lr);

        case DRV_DISABLE:
            lr = mapDriverDisable(hdrvr);
            return (lr);

#ifndef WIN32
        case DRV_EXITAPPLICATION:
            lr = acmApplicationExit(GetCurrentTask(), lParam1);
            return (lr);
#endif

        case DRV_MAPPER_PREFERRED_INPUT_GET:
            pdw  = (LPDWORD)lParam1;
            if (NULL != pdw)
            {
                WAIT_FOR_MUTEX(gpag->hMutexSettings);

                *pdw = MAKELONG(LOWORD(gpag->pSettings->uIdPreferredIn),
				LOWORD(gpag->pSettings->fPreferredOnly));

                RELEASE_MUTEX(gpag->hMutexSettings);

                return (MMSYSERR_NOERROR);
            }
            return (MMSYSERR_INVALPARAM);

        case DRV_MAPPER_PREFERRED_OUTPUT_GET:
            pdw  = (LPDWORD)lParam1;
            if (NULL != pdw)
            {
                WAIT_FOR_MUTEX(gpag->hMutexSettings);

                *pdw = MAKELONG(LOWORD(gpag->pSettings->uIdPreferredOut),
				LOWORD(gpag->pSettings->fPreferredOnly));

                RELEASE_MUTEX(gpag->hMutexSettings);

                return (MMSYSERR_NOERROR);
            }
            return (MMSYSERR_INVALPARAM);
    }

    if (uMsg >= DRV_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\init.c ===
//==========================================================================;
//
//  init.c
//
//  Copyright (c) 1991-1999 Microsoft Corporation
//
//  Description:
//
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#ifdef USE_ACMTHUNK
#include "acmthunk.h"
#endif
#include "msacmmap.h"
#include "profile.h"

#include "debug.h"


//
//
//
//

ACMGLOBALINFO       acmglobalinfo;
ACMGARB             acmgarb;
PACMGARB            gpag;


//--------------------------------------------------------------------------;
//
//  LRESULT mapWaveGetDevCaps
//
//  Description:
//
//
//  Arguments:
//      BOOL fInput: TRUE if input.
//
//      LPWAVEOUTCAPS pwc: Pointer to a WAVEOUTCAPS structure to receive
//      the information. Used for both input and output. Output structure
//      contains input structure plus extras....
//
//      UINT cbSize: Size of the WAVEOUTCAPS structure.
//
//  Return (MMRESULT):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL mapWaveGetDevCaps
(
    BOOL                    fInput,
    LPWAVEOUTCAPS           pwc,
    UINT                    cbSize
)
{
    MMRESULT        mmr;
    WAVEOUTCAPS     woc;
    UINT            cWaveDevs;
    BOOL            fFoundOnlyOneMappableDeviceID;
    UINT            uMappableDeviceID;
    UINT            i;

    if (fInput)
    {
        cbSize = min(sizeof(WAVEINCAPS), cbSize);
        cWaveDevs = gpag->cWaveInDevs;
    }
    else
    {
        cbSize = min(sizeof(WAVEOUTCAPS), cbSize);
        cWaveDevs = gpag->cWaveOutDevs;
    }

    //
    //  Determine if there is only one mappable device ID.  If there is only
    //  one, then set fFoundOnlyOneMappableID=TRUE and put the device ID
    //  in uMappableDeviceID.
    //
    fFoundOnlyOneMappableDeviceID = FALSE;
    for (i=0; i < cWaveDevs; i++)
    {
            if (fInput)
            {
                mmr = (MMRESULT)waveInMessage((HWAVEIN)LongToHandle(i), DRV_QUERYMAPPABLE, 0L, 0L);
            }
            else
            {
            mmr = (MMRESULT)waveOutMessage((HWAVEOUT)LongToHandle(i), DRV_QUERYMAPPABLE, 0L, 0L);
            }

            if (MMSYSERR_NOERROR == mmr)
            {
                if (fFoundOnlyOneMappableDeviceID)
                {
                    fFoundOnlyOneMappableDeviceID = FALSE;
                    break;
                }
                uMappableDeviceID = i;
                fFoundOnlyOneMappableDeviceID = TRUE;
            }
    }


    //
    //  If there is only one mappable device ID, then get the caps from it to
    //  fill in the dwSupport fields.  Otherwise, let's hardcode the dwSupport
    //  field.
    //
    if (fFoundOnlyOneMappableDeviceID)
    {
        if (fInput)
        {
            mmr = waveInGetDevCaps(uMappableDeviceID, (LPWAVEINCAPS)&woc, cbSize);
        }
        else
        {
            mmr = waveOutGetDevCaps(uMappableDeviceID, &woc, cbSize);
        }
    }
    else
    {
        woc.dwSupport = WAVECAPS_VOLUME | WAVECAPS_LRVOLUME;
        mmr           = MMSYSERR_NOERROR;
    }

    //
    //  Bail on error
    //
    if (MMSYSERR_NOERROR != mmr)
    {
        return (mmr);
    }

    //
    //
    //
    woc.wMid           = MM_MICROSOFT;
    woc.wPid           = MM_WAVE_MAPPER;
    woc.vDriverVersion = VERSION_MSACMMAP;
    woc.wChannels      = 2;

    LoadString(gpag->hinst, IDS_ACM_CAPS_DESCRIPTION, woc.szPname, SIZEOF(woc.szPname));

    //
    //
    //
    woc.dwFormats      = WAVE_FORMAT_1M08 |
                         WAVE_FORMAT_1S08 |
                         WAVE_FORMAT_1M16 |
                         WAVE_FORMAT_1S16 |
                         WAVE_FORMAT_2M08 |
                         WAVE_FORMAT_2S08 |
                         WAVE_FORMAT_2M16 |
                         WAVE_FORMAT_2S16 |
                         WAVE_FORMAT_4M08 |
                         WAVE_FORMAT_4S08 |
                         WAVE_FORMAT_4M16 |
                         WAVE_FORMAT_4S16;

    _fmemcpy(pwc, &woc, cbSize);

    return (MMSYSERR_NOERROR);
} // waveGetDevCaps()


//--------------------------------------------------------------------------;
//
//  UINT GetPCMSupportFlags
//
//  Description:
//
//
//  Arguments:
//      PZYZPCMFORMATS pzpf
//      UINT iaPCMFormats:
//
//  Return (VOID):
//
//  History:
//      06/14/93    cjp     [curtisp]
//      03/13/94    fdy     [frankye]
//          Modifed the interface to take pzpf and an index into it.
//          Modifed the function to set flags to indicate which wave
//          devices support the format in question.
//
//--------------------------------------------------------------------------;

VOID FNLOCAL GetPCMSupportFlags
(
    PZYZPCMFORMAT       pzpf,
    UINT                iaPCMFormats
)
{
    PCMWAVEFORMAT       wfPCM;
    UINT                uSamplesPerSec;
    UINT                u, n, i;

    #define WFQFLAGS  (WAVE_FORMAT_QUERY | WAVE_ALLOWSYNC)

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    //
    //  set all supported formats to 'not supported'
    //
    for (i = gpag->cWaveInDevs; i; i--)
        pzpf[iaPCMFormats].uFlagsInput[i-1]  = 0;
    for (i = gpag->cWaveOutDevs; i; i--)
        pzpf[iaPCMFormats].uFlagsOutput[i-1] = 0;

    //
    //  we need to try 4 different format types:
    //      Mono 8 Bit
    //      Stereo 8 Bit
    //      Mono 16 Bit
    //      Stereo 16 Bit
    //
    for (u = 0; u < 4; u++)
    {
        //
        //  set the stuff that is constant for all 4 formats
        //
        uSamplesPerSec = pzpf[iaPCMFormats].uSamplesPerSec;

        wfPCM.wf.wFormatTag     = WAVE_FORMAT_PCM;
        wfPCM.wf.nSamplesPerSec = uSamplesPerSec;

        switch (u)
        {
            case 0:
                wfPCM.wf.nChannels      = 1;
                wfPCM.wf.nAvgBytesPerSec= uSamplesPerSec;
                wfPCM.wf.nBlockAlign    = 1;
                wfPCM.wBitsPerSample    = 8;
                break;

            case 1:
                wfPCM.wf.nChannels      = 2;
                wfPCM.wf.nAvgBytesPerSec= uSamplesPerSec * 2;
                wfPCM.wf.nBlockAlign    = 2;
                wfPCM.wBitsPerSample    = 8;
                break;

            case 2:
                wfPCM.wf.nChannels      = 1;
                wfPCM.wf.nAvgBytesPerSec= uSamplesPerSec * 2;
                wfPCM.wf.nBlockAlign    = 2;
                wfPCM.wBitsPerSample    = 16;
                break;

            case 3:
                wfPCM.wf.nChannels      = 2;
                wfPCM.wf.nAvgBytesPerSec= uSamplesPerSec * 4;
                wfPCM.wf.nBlockAlign    = 4;
                wfPCM.wBitsPerSample    = 16;
                break;
        }

        //
        //  first query ALL ENABLED INPUT devices for the wfPCM format
        //
        if (gpag->pSettings->fPreferredOnly &&
           (gpag->pSettings->uIdPreferredIn != -1))
        {
            i = gpag->pSettings->uIdPreferredIn;
            n = gpag->pSettings->uIdPreferredIn + 1;
        }
        else
        {
            i = 0;
            n = gpag->cWaveInDevs;
        }

        for (; i < n; i++)
        {
#ifndef _WIN32
            if (!waveInOpen(NULL, i, (LPWAVEFORMAT)&wfPCM, 0L, 0L, WFQFLAGS))
#else
            if (!waveInOpen(NULL, i, (LPWAVEFORMATEX)&wfPCM, 0L, 0L, WFQFLAGS))
#endif
            {
                pzpf[iaPCMFormats].uFlagsInput[i] |= (ZYZPCMF_IN_M08 << u);
            }
        }

        //
        //  now query ALL ENABLED OUTPUT devices for the wfPCM format
        //
        if (gpag->pSettings->fPreferredOnly &&
           (gpag->pSettings->uIdPreferredOut != -1))
        {
            i = gpag->pSettings->uIdPreferredOut;
            n = gpag->pSettings->uIdPreferredOut + 1;
        }
        else
        {
            i = 0;
            n = gpag->cWaveOutDevs;
        }

        for (; i < n; i++)
        {
#ifndef _WIN32
            if (!waveOutOpen(NULL, i, (LPWAVEFORMAT)&wfPCM, 0L, 0L, WFQFLAGS))
#else
            if (!waveOutOpen(NULL, i, (LPWAVEFORMATEX)&wfPCM, 0L, 0L, WFQFLAGS))
#endif
            {
                pzpf[iaPCMFormats].uFlagsOutput[i] |= (ZYZPCMF_OUT_M08 << u);
            }
        }
    }

    //
    //  finally return
    //
#if 0    // def DEBUG
    DPF(3, "PCM Support: %uHz, In[%d]=%04xh, Out[%d]=%04xh",
        pzpf[iaPCMFormats].uSamplesPerSec,
        iaPCMFormats,
        *pzpf[iaPCMFormats].uFlagsInput,
        iaPCMFormats,
        *pzpf[iaPCMFormats].uFlagsOutput);
#endif

    RELEASE_MUTEX(gpag->hMutexSettings);

    return;
} // GetPCMSupportFlags()


//--------------------------------------------------------------------------;
//
//  BOOL GetWaveFormats
//
//  Description:
//
//
//  Arguments:
//      PZYZPCMFORMAT pzpf:
//
//  Return (BOOL):
//
//  History:
//      06/14/93    cjp     [curtisp]
//      03/13/94    fdy     [frankye]
//          Expanded the ZYZPCMFORMAT structure to include flags which
//          indicate which wave device supports a given format.  This
//          function will now set these flags.  Note that
//          the code that is #if 0'd WILL NOT WORK given these changes, so
//          if anybody ever resuscitates that code, you better modify it!
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL GetWaveFormats
(
    PZYZPCMFORMAT           pzpf
)
{
    UINT                u;

#if 0
    WAVEOUTCAPS         woc;
    WAVEINCAPS          wic;
    UINT                n;
    DWORD               dwInFormats;
    DWORD               dwOutFormats;

    //
    //  first things first: get all 'standard' supported formats from the
    //  current selected devices for input and output...
    //
    dwInFormats = 0L;
    if (gpag->fPreferredOnly && (gpag->uIdPreferredIn != -1))
    {
        if (!waveInGetDevCaps(gpag->uIdPreferredIn, &wic, sizeof(wic)))
            dwInFormats = wic.dwFormats;
    }
    else
    {
        n = gpag->cWaveInDevs;
        for (i = 0; i < n; i++)
        {
            if (!waveInGetDevCaps(i, &wic, sizeof(wic)))
                dwInFormats |= wic.dwFormats;
        }
    }

    dwOutFormats = 0L;
    if (gpag->fPreferredOnly && (gpag->uIdPreferredOut != -1))
    {
        if (!waveOutGetDevCaps(gpag->uIdPreferredOut, &woc, sizeof(woc)))
            dwOutFormats = woc.dwFormats;
    }
    else
    {
        n = gpag->cWaveOutDevs;
        for (i = 0; i < n; i++)
        {
            if (!waveOutGetDevCaps(i, &woc, sizeof(woc)))
                dwOutFormats |= woc.dwFormats;
        }
    }
#endif


    //
    //  now step through each sample rate in the pzpf structure and set all
    //  the appropriate bits for whether it is supported, etc..
    //
    for (u = 0; pzpf[u].uSamplesPerSec; u++)
    {
        //
        //  we need to special case a few of the sample rates, etc to get
        //  this whole thing working--once the grunt work is done here
        //  (and only once during initialization), then the data is easily
        //  accessible/used...
        //

        switch (pzpf[u].uSamplesPerSec)
        {
            //
            //  NOTE! it would be nice if we could rely on the caps
            //  structure being correct on drivers.... but alas, Media Vision
            //  found a way to mess that up also (on some of their hundreds
            //  of releases of their drivers). so ALWAYS query for the
            //  format support.
            //
            //  by the way, the reason they ship their drivers with this
            //  bug (and possibly other OEM's) is due to Sound Recorder
            //  (apparently their only test app?!?) only doing queries
            //  and never looking at the caps bits.
            //
#if 0
            case 11025:
                pzpf[u].uFlags  = (WORD)(dwInFormats  & WAVE_FORMAT_11k) << 8;
                pzpf[u].uFlags |= (WORD)(dwOutFormats & WAVE_FORMAT_11k);
                break;

            case 22050:
                pzpf[u].uFlags  =
                        (WORD)(dwInFormats  & WAVE_FORMAT_22k) >> 4 << 8;
                pzpf[u].uFlags |= (WORD)(dwOutFormats & WAVE_FORMAT_22k) >> 4;
                break;

            case 44100:
                pzpf[u].uFlags  =
                        (WORD)(dwInFormats  & WAVE_FORMAT_44k) >> 8 << 8;
                pzpf[u].uFlags |= (WORD)(dwOutFormats & WAVE_FORMAT_44k) >> 8;
                break;
#else
            case 11025:
            case 22050:
            case 44100:
#endif
            case 5510:
            case 6620:
            case 8000:
            case 9600:
            case 16000:
            case 18900:
            case 27420:
            case 32000:
            case 33075:
            case 37800:
            case 48000:
                GetPCMSupportFlags(pzpf, u);
                break;
        }
    }

    //
    //  reset these--they are auto determined while the mapper is being
    //  used...
    //

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    gpag->pSettings->fSyncOnlyOut = FALSE;
    gpag->pSettings->fSyncOnlyIn  = FALSE;

    RELEASE_MUTEX(gpag->hMutexSettings);

    return (TRUE);
} // GetWaveFormats()


//--------------------------------------------------------------------------;
//
//  BOOL mapSettingsRestore
//
//  Description:
//
//
//  Arguments:
//      None.
//
//  Return (BOOL):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL mapSettingsRestore
(
    void
)
{
    DWORD   dwFlags;
    UINT    ii;
    DWORD   cbSize;
    PUINT   pFlags;

    DPF(1, "mapSettingsRestore:");

    //
    //
    //

    gpag->cWaveOutDevs = waveOutGetNumDevs();
    gpag->cWaveInDevs  = waveInGetNumDevs();

    //  Number of devices per sampling rate...
    cbSize  = gpag->cWaveOutDevs + gpag->cWaveInDevs;

    //  Number of total flags...
//    cbSize *= (sizeof(gaPCMFormats)/sizeof(gaPCMFormats[0]));
    cbSize *= 15;   //  It's fifteen; Trust Me - Fwong.

    //  Size in bytes...
    cbSize *= sizeof(UINT);

    pFlags = (PUINT)GlobalAllocPtr(GHND, cbSize);

    if (NULL == pFlags)
    {
        //
        //  Hmm... How do we cope.
        //

        return FALSE;
    }

    ZeroMemory(pFlags, cbSize);

    if (NULL != gaPCMFormats[0].uFlagsInput)
    {
        GlobalFreePtr(gaPCMFormats[0].uFlagsInput);
    }

    for (ii = 0; ;ii++)
    {
        if (0 == gaPCMFormats[ii].uSamplesPerSec)
        {
            break;
        }

        gaPCMFormats[ii].uFlagsInput  = pFlags;
        pFlags += gpag->cWaveInDevs;

        gaPCMFormats[ii].uFlagsOutput = pFlags;
        pFlags += gpag->cWaveOutDevs;
    }

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    // gpag->fPrestoSyncAsync = (BOOL)IRegReadDwordDefault( hkeyMapper, gszKeyPrestoSyncAsync, 0 );
    gpag->fPrestoSyncAsync = FALSE;


    //
    //  find the waveOut device that is selected as preferred
    //
    if (!waveOutMessage((HWAVEOUT)LongToHandle(WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&gpag->pSettings->uIdPreferredOut, (DWORD_PTR)&dwFlags)) {
	gpag->pSettings->fPreferredOnly = (0 != (DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));
    } else {
	gpag->pSettings->uIdPreferredOut = (UINT)(-1);
	gpag->pSettings->fPreferredOnly = TRUE;
    }
    
    //
    //  find the waveIn device that is selected as preferred
    //
    if (!waveInMessage((HWAVEIN)LongToHandle(WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&gpag->pSettings->uIdPreferredIn, (DWORD_PTR)&dwFlags)) {
	gpag->pSettings->fPreferredOnly = (0 != (DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));
    } else {
	gpag->pSettings->uIdPreferredOut = (UINT)(-1);
	gpag->pSettings->fPreferredOnly = TRUE;
    }

    //
    //  reread/cache all the PCM format info from the devices selected, etc.
    //
    GetWaveFormats(gaPCMFormats);

    RELEASE_MUTEX(gpag->hMutexSettings);

    return (TRUE);
} // mapSettingsRestore()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT mapDriverEnable
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvr:
//
//  Return (LRESULT):
//
//  History:
//      09/18/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL mapDriverEnable
(
    HDRVR                   hdrvr
)
{
#ifdef USE_ACMTHUNK
    BOOL                f;
#endif
    DWORD               dw;

    DPF(1, "mapDriverEnable(hdrvr=%.04Xh)", hdrvr);


#ifdef USE_ACMTHUNK
    f = acmThunkInitialize();
    if (!f)
    {
        DPF(0, "!ACM thunk cannot be initialized!");
        return (0L);
    }
#endif

    dw = acmGetVersion();
    if (VERSION_MSACMMAP > HIWORD(dw))
    {
        DPF(0, "!requires version %u.%.02u of the ACM!",
            VERSION_MSACMMAP_MAJOR, VERSION_MSACMMAP_MINOR);

#ifdef USE_ACMTHUNK
        acmThunkTerminate();
#endif

        return (0L);
    }

    mapSettingsRestore();
    gpag->fEnabled = TRUE;

    //
    //  the return value is ignored, but return non-zero anyway
    //
    return (1L);
} // mapDriverEnable()


//--------------------------------------------------------------------------;
//
//  LRESULT mapDriverDisable
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvr:
//
//  Return (LRESULT):
//
//  History:
//      09/18/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL mapDriverDisable
(
    HDRVR           hdrvr
)
{
    DPF(1, "mapDriverDisable(hdrvr=%.04Xh)", hdrvr);

    if (gpag->fEnabled)
    {
        gpag->fEnabled = FALSE;
    }

#ifdef USE_ACMTHUNK
    acmThunkTerminate();
#endif

    //
    //  the return value is ignored, but return non-zero anyway
    //
    return (1L);
} // mapDriverDisable()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT mapDriverInstall
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvr:
//
//  Return (LRESULT):
//
//  History:
//      09/25/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL mapDriverInstall
(
    HDRVR           hdrvr
)
{
    DPF(1, "mapDriverInstall(hdrvr=%.04Xh)", hdrvr);


    //
    //
    //
    return (DRVCNF_RESTART);
} // mapDriverInstall()


//--------------------------------------------------------------------------;
//
//  LRESULT mapDriverRemove
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvr:
//
//  Return (LRESULT):
//
//  History:
//      09/25/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL mapDriverRemove
(
    HDRVR           hdrvr
)
{
    DPF(1, "mapDriverRemove(hdrvr=%.04Xh)", hdrvr);


    //
    //
    //
    return (DRVCNF_RESTART);
} // mapDriverRemove()


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef WIN32

//--------------------------------------------------------------------------;
//
//  int WEP
//
//  Description:
//      The infamous useless WEP(). Note that this procedure needs to be
//      in a FIXED segment under Windows 3.0. Under Windows 3.1 this is
//      not necessary.
//
//  Arguments:
//      WORD wUseless: Should tell whether Windows is exiting or not.
//
//  Return (int):
//      Always return non-zero.
//
//  History:
//      04/29/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C int FNEXPORT WEP
(
    WORD    wUseless
)
{
    DPF(1, "WEP(wUseless=%u)", wUseless);

    //
    //  always return non-zero
    //
    return (1);
} // WEP()


//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//      This routine must guarantee the following things so CODEC's don't
//      have to special case code everywhere:
//
//          o   will only run in Windows 3.10 or greater (our exehdr is
//              marked appropriately).
//
//          o   will only run on >= 386 processor. only need to check
//              on Win 3.1.
//
//  Arguments:
//      HINSTANCE hinst: Our module instance handle.
//
//      WORD wDataSeg: Our data segment selector.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE               hinst,
    WORD                    wDataSeg,
    WORD                    cbHeapSize,
    LPSTR                   pszCmdLine
)
{
    //
    //  we ONLY work on >= 386. if we are on a wimpy processor, scream in
    //  pain and die a horrible death!
    //
    //  NOTE! do this check first thing and get out if on a 286. we are
    //  compiling with -G3 and C8's libentry garbage does not check for
    //  >= 386 processor. the following code does not execute any 386
    //  instructions (not complex enough)..
    //
#if (WINVER < 0x0400)
    if (GetWinFlags() & WF_CPU286)
    {
        return (FALSE);
    }
#endif

    DbgInitialize(TRUE);

    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);

    DPF(5, "!*** break for debugging ***");


    //
    //  everything looks good to go in Win 16 land.
    //
    gpag = &acmgarb;
    gpag->hinst = hinst;

    //  Note: in Win16 there's only one instance of the mapper
    gpag->pSettings = &(acmglobalinfo);

    return (TRUE);
} // LibMain()

#else // WIN32

//==========================================================================;
//
//  WIN 32 SPECIFIC SUPPORT
//
//==========================================================================;


//--------------------------------------------------------------------------;
//
//  PACMGLOBALINFO mapAllocateGlobalInfo
//
//  Description:
//      Either creates the common buffer among all instances of the mapper
//      or it finds the common buffer.
//
//  Arguments:
//      None.
//
//  Return (PACMGLOBALINFO):
//      Returns a pointer to global info structure.
//
//  History:
//      01/21/98    Fwong   Adding multi-instance support.
//      01/24/99    FrankYe Back to simple single process support, since
//                          since winmm has been modified to hold the
//                          preferred device settings.
//
//--------------------------------------------------------------------------;

PACMGLOBALINFO mapAllocateGlobalInfo
(
    void
)
{
    // We could actually use a critical section instead of a mutex here.
    gpag->hMutexSettings = CreateMutex(NULL, FALSE, NULL);
    return &(acmglobalinfo);
} // mapAllocateGlobalInfo()


//--------------------------------------------------------------------------;
//
//  void mapFreeGlobalInfo
//
//  Description:
//      Cleans up the objects associated with the global memory buffer.
//
//  Arguments:
//      PACMGLOBALINFO pagi: Base buffer for global info.
//
//  Return (void):
//
//  History:
//      01/21/98    Fwong   Adding multi-instance support.
//      01/24/99    FrankYe Back to simple single process support, since
//                          since winmm has been modified to hold the
//                          preferred device settings.
//
//--------------------------------------------------------------------------;

void mapFreeGlobalInfo
(
    PACMGLOBALINFO  pagi
)
{
    if(NULL != gpag->hMutexSettings) CloseHandle(gpag->hMutexSettings);
} // mapFreeGlobalInfo()


//--------------------------------------------------------------------------;
//
//  BOOL DllEntryPoint
//
//  Description:
//      This is the standard DLL entry point for Win 32.
//
//  Arguments:
//      HINSTANCE hinst: Our instance handle.
//
//      DWORD dwReason: The reason we've been called--process/thread attach
//      and detach.
//
//      LPVOID lpReserved: Reserved. Should be NULL--so ignore it.
//
//  Return (BOOL):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT DllEntryPoint
(
    HINSTANCE       hinst,
    DWORD           dwReason,
    LPVOID          lpReserved
)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DbgInitialize(TRUE);

            gpag = &acmgarb;
            gpag->hinst = hinst;
            gpag->pSettings = mapAllocateGlobalInfo();

            DisableThreadLibraryCalls(hinst);

            DPF(1, "DllEntryPoint(hinst=%.08lXh, DLL_PROCESS_ATTACH)", hinst);
            return (TRUE);

        case DLL_PROCESS_DETACH:
            mapFreeGlobalInfo(gpag->pSettings);

            DPF(1, "DllEntryPoint(hinst=%.08lXh, DLL_PROCESS_DETACH)", hinst);
            return (TRUE);
    }

    return (TRUE);
} // DllEntryPoint()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\profile.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1994-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  profile.h
//
//  Description:
//
//      This file contains definitions supporting the code in profile.c
//      which accesses the registry directly.
//
//==========================================================================;

#ifndef _PROFILE_H_
#define _PROFILE_H_

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#ifndef INLINE
    #define INLINE __inline
#endif


//
//  The Chicago Win16 header files are messed up somehow, so we have to
//  define this stuff ourselves.
//
#ifndef REG_DWORD
#pragma message("profile.h: Manually defining REG_DWORD!!!")
#define REG_DWORD  ( 4 )
#endif

#ifndef ERROR_SUCCESS
#pragma message("profile.h: Manually defining ERROR_SUCCESS!!!")
#define ERROR_SUCCESS  0L
#endif



//--------------------------------------------------------------------------;
//
//  Function Prototypes from profile.c
//  
//--------------------------------------------------------------------------;

HKEY FNGLOBAL IRegOpenKey
(
    LPCTSTR pszKeyName
);

BOOL FNGLOBAL IRegReadString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPTSTR              pszData,
    DWORD               cchData
);

DWORD FNGLOBAL IRegReadDwordDefault
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwDefault
);



//--------------------------------------------------------------------------;
//  
//  VOID IRegWriteString
//  
//  Description:
//      This routine writes a value to an opened registry key.  If the key
//      is NULL, we return without doing anything.
//  
//  Arguments:
//      HKEY hkey:          An open registry key.
//      LPCTSTR pszValue:   Name of the value.
//      LPCTSTR pszData:    The data to write.
//
//  Return (BOOL): TRUE indicates success. FALSE otherwise.
//  
//--------------------------------------------------------------------------;

INLINE BOOL IRegWriteString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPCTSTR             pszData
)
{
    LONG lResult;
    
    lResult = RegSetValueEx( hkey, pszValue, 0L, REG_SZ, (LPBYTE)pszData,
			     sizeof(TCHAR) * (1+lstrlen(pszData)) );

    return (ERROR_SUCCESS == lResult);
}


//--------------------------------------------------------------------------;
//  
//  VOID IRegWriteDword
//  
//  Description:
//      This routine writes a DWORD to the given value an open key.
//  
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPCTSTR  pszValue:
//      DWORD   dwData:
//  
//  Return (BOOL): TRUE if successfull.  FALSE otherwise
//  
//--------------------------------------------------------------------------;

INLINE BOOL IRegWriteDword
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwData
)
{
    LONG lResult;
    
    lResult = RegSetValueEx( hkey, pszValue, 0, REG_DWORD,
			     (LPBYTE)&dwData, sizeof(DWORD) );

    return (ERROR_SUCCESS == lResult);
}


//--------------------------------------------------------------------------;
//  
//  BOOL IRegValueExists
//  
//  Description:
//      This routine returns TRUE if the specified value exists in the
//      key; otherwise FALSE is returned.
//  
//  Arguments:
//      HKEY hkey:          An open registry key.
//      LPCTSTR pszValue:   Name of the value.
//
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

INLINE BOOL IRegValueExists
(
    HKEY                hkey,
    LPCTSTR             pszValue
)
{
    return ( ERROR_SUCCESS == RegQueryValueEx( hkey, (LPTSTR)pszValue,
                                               NULL, NULL, NULL, NULL ) );
}


//--------------------------------------------------------------------------;
//  
//  VOID IRegCloseKey
//  
//  Description:
//      Closes an open key (but only if it's non-NULL).
//  
//--------------------------------------------------------------------------;

INLINE VOID IRegCloseKey
(
    HKEY                hkey
)
{
    if( NULL != hkey )
    {
        RegCloseKey( hkey );
    }
}


#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\wavein.c ===
//==========================================================================;
//
//  wavein.c
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       9/18/93    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <memory.h>
#ifdef DEBUG
#include <stdlib.h>
#endif

#include "msacmmap.h"

#include "debug.h"


//--------------------------------------------------------------------------;
//
//  LRESULT mapWaveInputConvertProc
//
//  Description:
//      Window Proc for hidden window...
//
//      It should just recieve WIM_DATA messages from mapWaveDriverCallback
//
//      Real driver has filled the shadow buffer
//      Now convert it and call back the app/client.
//
//  Arguments:
//      DWORD dwInstance:
//
//  Return (LONG):
//
//  History:
//      11/15/92    gpd     [geoffd]
//      08/02/93    cjp     [curtisp] rewrote for new mapper
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNCALLBACK mapWaveInputConvertProc
(
    DWORD                   dwInstance
)
{
    MMRESULT            mmr;
    MSG                 msg;
    LPACMSTREAMHEADER   pash;
    LPWAVEHDR           pwh;
    LPWAVEHDR           pwhShadow;
    LPMAPSTREAM         pms;


#ifndef WIN32
    DPF(1, "mapWaveInputConvertProc: creating htask=%.04Xh, dwInstance=%.08lXh",
	    gpag->htaskInput, dwInstance);
#endif // !WIN32

    if (!SetMessageQueue(64))
    {
	DPF(0, "!mapWaveInputConvertProc: SetMessageQueue() failed!");
	return (0L);
    }

#ifdef WIN32
    //
    //  Make sure we have a message queue for this thread and signal the
    //  caller when we're ready to go
    //
    GetDesktopWindow();       // Makes sure we've got a message queue
    SetEvent(LongToHandle(dwInstance));
#endif
    //
    //
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
#ifdef DEBUG
	if (gpag->fFaultAndDie)
	{
	    if ((rand() & 0x7) == 0)
	    {
		gpag->fFaultAndDie = (BOOL)*((LPBYTE)0);

		DPF(1, "mapWaveInputConvertProc: fault was ignored...");

		gpag->fFaultAndDie = TRUE;
	    }
	}
#endif
	//
	//  if not a 'data' message, then translate and dispatch it...
	//
	if (msg.message != WIM_DATA)
	{
	    DPF(1, "mapWaveInputConvertProc: ignoring message [%.04Xh]", msg.message);

	    TranslateMessage(&msg);
	    DispatchMessage(&msg);

	    continue;
	}

	//
	//  lParam is the waveheader of the shadow buffer
	//
	pwhShadow = (LPWAVEHDR)msg.lParam;

	//
	//  client wave header is user data of shadow wave header
	//  the stream header for this client/shadow pair is in the client's
	//  'reserved' member
	//
	//  and finally, our stream header's dwUser member contains a
	//  reference to our mapping stream instance data.
	//
	pwh  = (LPWAVEHDR)pwhShadow->dwUser;
	pash = (LPACMSTREAMHEADER)pwh->reserved;
	pms  = (LPMAPSTREAM)pash->dwUser;

	DPF(4, "mapWaveInputConvertProc: WIM_DATA htask=%.04Xh, pms=%.08lXh, pwh=%.08lXh, pwhShadow=%.08lXh",
		pms->htaskInput, pms, pwh, pwhShadow);


	//
	//  do the conversion (if there is data in the input buffer)
	//
	pash->cbDstLengthUsed = 0L;
	if (0L != pwhShadow->dwBytesRecorded)
	{
	    pash->pbSrc       = pwhShadow->lpData;
	    pash->cbSrcLength = pwhShadow->dwBytesRecorded;
	    pash->pbDst       = pwh->lpData;
////////////pash->cbDstLength = pwh->dwBufferLength;

	    mmr = acmStreamConvert(pms->has, pash, ACM_STREAMCONVERTF_BLOCKALIGN);
	    if (MMSYSERR_NOERROR != mmr)
	    {
		DPF(0, "!mapWaveInputConvertProc: conversion failed! mmr=%.04Xh, pms=%.08lXh", mmr, pms);

		pash->cbDstLengthUsed = 0L;
	    }
	    else if (pash->cbSrcLength != pash->cbSrcLengthUsed)
	    {
		DPF(1, "mapWaveInputConvertProc: discarding %lu bytes of input! pms=%.08lXh",
			pash->cbSrcLength - pash->cbSrcLengthUsed, pms);
	    }
	}

	if (0L == pash->cbDstLengthUsed)
	{
	    DPF(1, "mapWaveInputConvertProc: nothing converted--no data in input buffer. pms=%.08lXh", pms);
	}

	//
	//  update the 'real' header and send the WIM_DATA callback
	//
	//
	pwh->dwBytesRecorded = pash->cbDstLengthUsed;
	pwh->dwFlags        |= WHDR_DONE;
	pwh->dwFlags        &= ~WHDR_INQUEUE;

	mapWaveDriverCallback(pms, WIM_DATA, (DWORD_PTR)pwh, 0L);
#ifdef WIN32
	if (InterlockedDecrement((PLONG)&pms->nOutstanding) == 0) {
	    SetEvent(pms->hStoppedEvent);
	}
#endif // WIN32
    }

#ifndef WIN32
    DPF(1, "mapWaveInputConvertProc: being KILLED htask=%.04Xh", gpag->htaskInput);
#endif // !WIN32

    return (0L);
} // mapWaveInputConvertProc()


//--------------------------------------------------------------------------;
//
//  DWORD widmMapperStatus
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      DWORD dwStatus:
//
//      LPDWORD pdw:
//
//  Return (DWORD):
//
//  History:
//      08/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL widmMapperStatus
(
    LPMAPSTREAM             pms,
    DWORD                   dwStatus,
    LPDWORD                 pdw
)
{
    MMRESULT            mmr;

//  V_WPOINTER(pdw, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if ((NULL == pms) || (NULL == pdw))
    {
	return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    switch (dwStatus)
    {
	case WAVEIN_MAPPER_STATUS_DEVICE:
	{
	    UINT        uId = (UINT)(-1);       // Invalid value

	    mmr = waveInGetID(pms->hwiReal, &uId);
	    if (MMSYSERR_NOERROR != mmr)
	    {
		return (mmr);
	    }

	    *pdw = uId;
	    return (MMSYSERR_NOERROR);
	}

	case WAVEIN_MAPPER_STATUS_MAPPED:
	    *pdw = (NULL != pms->has);
	    return (MMSYSERR_NOERROR);

	case WAVEIN_MAPPER_STATUS_FORMAT:
	    if (NULL != pms->has)
		_fmemcpy(pdw, pms->pwfxReal, sizeof(PCMWAVEFORMAT));
	    else
		_fmemcpy(pdw, pms->pwfxClient, sizeof(PCMWAVEFORMAT));

	    ((LPWAVEFORMATEX)pdw)->cbSize = 0;
	    return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // widmMapperStatus()


//--------------------------------------------------------------------------;
//
//  DWORD widMessage
//
//  Description:
//      This function conforms to the standard Wave Input driver message
//      procedure (widMessage), which is documented in mmddk.d.
//
//  Arguments:
//      UINT uId:
//
//      UINT uMsg:
//
//      DWORD dwUser:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (DWORD):
//
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C DWORD FNEXPORT widMessage
(
    UINT                uId,
    UINT                uMsg,
    DWORD_PTR           dwUser,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2
)
{
#ifndef WIN32 // Doesn't work for multithread
    static short    fSem = 0;
#endif // !WIN32
    LPMAPSTREAM     pms;        // pointer to per-instance info structure
    DWORD           dw;

    if (!gpag->fEnabled)
    {
	DPF(1, "widMessage: called while disabled!");
	return ((WIDM_GETNUMDEVS == uMsg) ? 0L : MMSYSERR_NOTENABLED);
    }

#ifndef WIN32
    //
    //  we call back into the mmsystem wave APIs so protect ourself
    //  from being re-entered!
    //
    if (fSem)
    {
	DPF(0, "!widMessage(uMsg=%u, dwUser=%.08lXh) being reentered! fSem=%d", uMsg, dwUser, fSem);
//      return (MMSYSERR_NOTSUPPORTED);
    }
#endif // !WIN32

    pms = (LPMAPSTREAM)dwUser;

    switch (uMsg)
    {
	case WIDM_GETNUMDEVS:
	    return (1L);

	case WIDM_GETDEVCAPS:
	    return mapWaveGetDevCaps(TRUE, (LPWAVEOUTCAPS)dwParam1, (UINT)dwParam2);

	case WIDM_OPEN:
#ifndef WIN32
	    fSem++;

	    DPF(1, "**** >> WIDM_OPEN(uMsg=%u, dwUser=%.08lXh, fSem=%d)", uMsg, dwUser, fSem);

#endif // !WIN32
	    //
	    //  dwParam1 contains a pointer to a WAVEOPENDESC
	    //  dwParam2 contains wave driver specific flags in the LOWORD
	    //  and generic driver flags in the HIWORD
	    //
	    dw = mapWaveOpen(TRUE, uId, dwUser, (LPWAVEOPENDESC)dwParam1, (DWORD)(PtrToLong((PVOID)dwParam2)) );

#ifndef WIN32
	    fSem--;

	    DPF(1, "**** << WIDM_OPEN(uMsg=%u, dwUser=%.08lXh, *dwUser=%.08lXh, fSem=%d)", uMsg, dwUser, *(LPDWORD)dwUser, fSem);
#endif // !WIN32
	    return (dw);

	case WIDM_CLOSE:
	    return (mapWaveClose(pms));

	case WIDM_PREPARE:
	    return (mapWavePrepareHeader(pms, (LPWAVEHDR)dwParam1));

	case WIDM_UNPREPARE:
	    return (mapWaveUnprepareHeader(pms, (LPWAVEHDR)dwParam1));

	case WIDM_ADDBUFFER:
	    return (mapWaveWriteBuffer(pms, (LPWAVEHDR)dwParam1));

	case WIDM_START:
	    DPF(4, "WIDM_START received...");
	    return waveInStart(pms->hwiReal);

	case WIDM_STOP:
	    DPF(4, "WIDM_STOP received..");
	    dw = waveInStop(pms->hwiReal);

#pragma message("----try to kill DirectedYield..")

	    //
	    //  yield enough to get all input messages processed
	    //
	    if (pms->htaskInput)
	    {
#ifdef WIN32
		ResetEvent(pms->hStoppedEvent);
		if (pms->nOutstanding != 0) {
		    WaitForSingleObject(pms->hStoppedEvent, INFINITE);
		}
#else
		if (IsTask(pms->htaskInput))
		{
		    DirectedYield(pms->htaskInput);
		}
		else
		{
		    DPF(0, "!WIDM_STOP: pms=%.08lXh, htask=%.04Xh is not valid!",
			pms, pms->htaskInput);
		    pms->htaskInput = NULL;
		}
#endif // !WIN32
	    }
	    return (dw);

	case WIDM_RESET:
	    DPF(4, "WIDM_RESET received...");
	    dw = waveInReset(pms->hwiReal);

	    //
	    //  yield enough to get all input messages processed
	    //
	    if (pms->htaskInput)
	    {
#ifdef WIN32
		ResetEvent(pms->hStoppedEvent);
		if (pms->nOutstanding != 0) {
		    WaitForSingleObject(pms->hStoppedEvent, INFINITE);
		}
#else
		if (IsTask(pms->htaskInput))
		{
		    DirectedYield(pms->htaskInput);
		}
		else
		{
		    DPF(0, "!WIDM_RESET: pms=%.08lXh, htask=%.04Xh is not valid!",
			pms, pms->htaskInput);
		    pms->htaskInput = NULL;
		}
#endif // !WIN32
	    }
	    return (dw);

	case WIDM_GETPOS:
	    return mapWaveGetPosition(pms, (LPMMTIME)dwParam1, (UINT)dwParam2);

	case WIDM_MAPPER_STATUS:
	    dw = widmMapperStatus(pms, (DWORD)(PtrToLong((PVOID)dwParam1)), (LPDWORD)dwParam2);
	    return (dw);

#if (WINVER >= 0x0400)
	case DRVM_MAPPER_RECONFIGURE:
	    mapDriverDisable(NULL);
	    mapDriverEnable(NULL);
	    return (0);
#endif
    }

    if (!pms || !pms->hwiReal)
	return (MMSYSERR_NOTSUPPORTED);

    return waveInMessage(pms->hwiReal, uMsg, dwParam1, dwParam2);
} // widMessage()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\profile.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1994-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  profile.c
//
//  Description:
//      This file contains routines to access the registry directly.  You
//      must include profile.h to use these routines. 
//
//      All keys are opened under the following key:
//
//          HKEY_CURRENT_USER\Software\Microsoft\Multimedia\Audio
//                                                  Compression Manager
//
//      Keys should be opened at boot time, and closed at shutdown.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "msacmmap.h"
#include "profile.h"

#include "debug.h"


#define ACM_PROFILE_ROOTKEY     HKEY_CURRENT_USER

const TCHAR gszAcmProfileKey[] =
        TEXT("Software\\Microsoft\\Multimedia");


//
//  Chicago Win16 does not appear to support RegCreateKeyEx, so we implement
//  it using this define.
//
#ifndef _WIN32

#define RegCreateKeyEx( hkey, lpszSubKey, a, b, c, d, e, phkResult, f ) \
        RegCreateKey( hkey, lpszSubKey, phkResult )

#endif



//--------------------------------------------------------------------------;
//  
//  HKEY IRegOpenKey
//  
//  Description:
//      This routine opens a sub key under the default ACM key.  We allow
//      all access to the key.
//  
//  Arguments:
//      LPCTSTR pszKeyName:  Name of the sub key.
//  
//  Return (HKEY):  Handle to the opened key, or NULL if the request failed.
//  
//--------------------------------------------------------------------------;

HKEY FNGLOBAL IRegOpenKey
(
    LPCTSTR             pszKeyName
)
{
    HKEY    hkeyAcm = NULL;
    HKEY    hkeyRet = NULL;


    RegCreateKeyEx( ACM_PROFILE_ROOTKEY, gszAcmProfileKey, 0, NULL, 0,
                       KEY_WRITE, NULL, &hkeyAcm, NULL );

    if( NULL != hkeyAcm )
    {
        RegCreateKeyEx( hkeyAcm, pszKeyName, 0, NULL, 0,
                    KEY_WRITE | KEY_READ, NULL, &hkeyRet, NULL );

        RegCloseKey( hkeyAcm );
    }

    return hkeyRet;
}


//--------------------------------------------------------------------------;
//  
//  BOOL IRegReadString
//  
//  Description:
//      This routine reads a value from an opened registry key.  The return
//      value indicates success or failure.  If the HKEY is NULL, we return
//      a failure.  Note that there is no default string...
//  
//  Arguments:
//      HKEY hkey:          An open registry key.  If NULL, we fail.
//      LPCTSTR pszValue:   Name of the value.
//      LPTSTR pszData:     Buffer to store the data in.
//      DWORD cchData:      Size (in chars) of the buffer.
//
//  Return (BOOL):  TRUE indicates success.  If the return is FALSE, you
//      can't count on the data in pszData - it might be something weird.
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IRegReadString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPTSTR              pszData,
    DWORD               cchData
)
{

    DWORD   dwType = (DWORD)~REG_SZ;  // Init to anything but REG_SZ.
    DWORD   cbData;
    LONG    lError;

    cbData = sizeof(TCHAR) * cchData;

    lError = RegQueryValueEx( hkey,
                              (LPTSTR)pszValue,
                              NULL,
                              &dwType,
                              (LPBYTE)pszData,
                              &cbData );

    return ( ERROR_SUCCESS == lError  &&  REG_SZ == dwType );
}


//--------------------------------------------------------------------------;
//  
//  DWORD IRegReadDwordDefault
//  
//  Description:
//      This routine reads a given value from the registry, and returns a
//      default value if the read is not successful.
//  
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPCTSTR  pszValue:
//      DWORD   dwDefault:
//  
//  Return (DWORD):
//  
//--------------------------------------------------------------------------;

DWORD FNGLOBAL IRegReadDwordDefault
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwDefault
)
{
    DWORD   dwType = (DWORD)~REG_DWORD;  // Init to anything but REG_DWORD.
    DWORD   cbSize = sizeof(DWORD);
    DWORD   dwRet  = 0;
    LONG    lError;


    lError = RegQueryValueEx( hkey,
                              (LPTSTR)pszValue,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwRet,
                              &cbSize );

    //
    //  Really we should have a test like this:
    //
    //      if( ERROR_SUCCESS != lError  ||  REG_DWORD != dwType )
    //
    //  But, the Chicago RegEdit will not let you enter REG_DWORD values,
    //  it will only let you enter REG_BINARY values, so that test is
    //  too strict.  Just test for no error instead.
    //
    if( ERROR_SUCCESS != lError )
        dwRet = dwDefault;

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msadpcm\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static CHAR     ach[300];       // debug output (avoid stack overflow)
    int	            id;


    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
        FatalAppExit(0, TEXT("Good Bye"));
		break;

	case IDRETRY:               // Break into the debugger.
#if DBG
                DebugBreak();
#endif
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msadpcm\codec.c ===
//==========================================================================;
//
//  codec.c
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  Description:
//
//
//  History:
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <ctype.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "codec.h"
#include "msadpcm.h"

#include "debug.h"


#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))


const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM,
    WAVE_FORMAT_ADPCM
};

#define CODEC_MAX_FORMAT_TAGS   SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define CODEC_MAX_FILTER_TAGS   0


//
//  array of sample rates supported
//
//
const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

#define CODEC_MAX_SAMPLE_RATES  SIZEOF_ARRAY(gauFormatIndexToSampleRate)


//
//  array of bits per sample supported
//
//
const UINT gauFormatIndexToBitsPerSample[] =
{
    8,
    16
};

#define CODEC_MAX_BITSPERSAMPLE_PCM     SIZEOF_ARRAY(gauFormatIndexToBitsPerSample)
#define CODEC_MAX_BITSPERSAMPLE_ADPCM   1


#define CODEC_MAX_CHANNELS      MSADPCM_MAX_CHANNELS


//
//  number of formats we enumerate per channels is number of sample rates
//  times number of channels times number of
//  (bits per sample) types.
//
#define CODEC_MAX_FORMATS_PCM   (CODEC_MAX_SAMPLE_RATES *   \
                                 CODEC_MAX_CHANNELS *       \
                                 CODEC_MAX_BITSPERSAMPLE_PCM)

#define CODEC_MAX_FORMATS_ADPCM (CODEC_MAX_SAMPLE_RATES *   \
                                 CODEC_MAX_CHANNELS *       \
                                 CODEC_MAX_BITSPERSAMPLE_ADPCM)


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // WIN32


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that our PCM converter can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//  History:
//      11/21/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX  pwfx
)
{
    UINT    uBlockAlign;

    if (!pwfx)
        return (FALSE);

    if (pwfx->wFormatTag != WAVE_FORMAT_PCM)
        return (FALSE);

    if ((pwfx->wBitsPerSample != 8) && (pwfx->wBitsPerSample != 16))
        return (FALSE);

    if ((pwfx->nChannels < 1) || (pwfx->nChannels > MSADPCM_MAX_CHANNELS))
        return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    uBlockAlign = PCM_BLOCKALIGNMENT(pwfx);
    if (uBlockAlign != (UINT)pwfx->nBlockAlign)
        return (FALSE);

    //
    //  finally, verify that avg bytes per second is correct
    //
    if ((pwfx->nSamplesPerSec * uBlockAlign) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  WORD adpcmBlockAlign
//
//  Description:
//      This function computes the standard block alignment that should
//      be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid MS-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels
//          nSamplesPerSec
//
//  Arguments:
//      LPWAVEFORMATEX pwfx:
//
//  Return (WORD):
//      The return value is the block alignment that should be placed in
//      the pwfx->nBlockAlign field.
//
//  History:
//      06/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

WORD FNLOCAL adpcmBlockAlign
(
    LPWAVEFORMATEX      pwfx
)
{
    UINT        uBlockAlign;
    UINT        uChannelShift;

    //
    //
    //
    uChannelShift  = pwfx->nChannels >> 1;
    uBlockAlign    = 256 << uChannelShift;

    //
    //  choose a block alignment that makes sense for the sample rate
    //  that the original PCM data is. basically, this needs to be
    //  some reasonable number to allow efficient streaming, etc.
    //
    //  don't let block alignment get too small...
    //
    if (pwfx->nSamplesPerSec > 11025)
    {
        uBlockAlign *= (UINT)(pwfx->nSamplesPerSec / 11000);
    }

    return (WORD)(uBlockAlign);
} // adpcmBlockAlign()



//--------------------------------------------------------------------------;
//
//  WORD adpcmSamplesPerBlock
//
//  Description:
//      This function computes the Samples Per Block that should be used
//      given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid MS-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels       = must be 1 or 2!
//          nSamplesPerSec
//          nBlockAlign
//
//  Arguments:
//      LPWAVEFORMATEX pwfx:
//
//  Return (DWORD):
//      The return value is the average bytes per second that should be
//      placed in the pwfx->nAvgBytesPerSec field.
//
//  History:
//      06/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

WORD FNLOCAL adpcmSamplesPerBlock
(
    LPWAVEFORMATEX      pwfx
)
{
    UINT        uSamplesPerBlock;
    UINT        uChannelShift;
    UINT        uHeaderBytes;
    UINT        uBitsPerSample;

    //
    //
    //
    uChannelShift  = pwfx->nChannels >> 1;
    uHeaderBytes   = 7 << uChannelShift;
    uBitsPerSample = MSADPCM_BITS_PER_SAMPLE << uChannelShift;

    //
    //
    //
    uSamplesPerBlock  = (pwfx->nBlockAlign - uHeaderBytes) * 8;
    uSamplesPerBlock /= uBitsPerSample;
    uSamplesPerBlock += 2;

    return (WORD)(uSamplesPerBlock);
} // adpcmSamplesPerBlock()


//--------------------------------------------------------------------------;
//
//  UINT adpcmAvgBytesPerSec
//
//  Description:
//      This function computes the Average Bytes Per Second that should
//      be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid MS-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels       = must be 1 or 2!
//          nSamplesPerSec
//          nBlockAlign
//
//  Arguments:
//      LPWAVEFORMATEX pwfx:
//
//  Return (DWORD):
//      The return value is the average bytes per second that should be
//      placed in the pwfx->nAvgBytesPerSec field.
//
//  History:
//      06/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL adpcmAvgBytesPerSec
(
    LPWAVEFORMATEX      pwfx
)
{
    DWORD       dwAvgBytesPerSec;
    UINT	uSamplesPerBlock;

    //
    //
    //
    uSamplesPerBlock	= adpcmSamplesPerBlock(pwfx);


    //
    //  compute bytes per second including header bytes
    //
    dwAvgBytesPerSec	= (pwfx->nSamplesPerSec * pwfx->nBlockAlign) /
			    uSamplesPerBlock;
    return (dwAvgBytesPerSec);
} // adpcmAvgBytesPerSec()



//--------------------------------------------------------------------------;
//
//  BOOL adpcmIsValidFormat
//
//  Description:
//
//
//  Arguments:
//
//
//  Return (BOOL FNLOCAL):
//
//
//  History:
//       1/26/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL adpcmIsValidFormat
(
    LPWAVEFORMATEX  pwfx
)
{
	LPADPCMWAVEFORMAT   pwfADPCM = (LPADPCMWAVEFORMAT)pwfx;

	if (!pwfx)
        return (FALSE);

    if (pwfx->wFormatTag != WAVE_FORMAT_ADPCM)
        return (FALSE);

    //
    //  check wBitsPerSample
    //
    if (pwfx->wBitsPerSample != MSADPCM_BITS_PER_SAMPLE)
        return (FALSE);

    //
    //  check channels
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > MSADPCM_MAX_CHANNELS))
        return (FALSE);

    //
    //  verify that there is at least enough space specified in cbSize
    //  for the extra info for the ADPCM header...
    //
    if (pwfx->cbSize < MSADPCM_WFX_EXTRA_BYTES)
        return (FALSE);

	//
    //  Verifying nBlockAlign and wSamplesPerBlock are consistent.
    //
    if ( (pwfADPCM->wSamplesPerBlock != adpcmSamplesPerBlock(pwfx)) )
        return FALSE;



    return (TRUE);
} // adpcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL adpcmIsMagicFormat
//
//  Description:
//
//
//  Arguments:
//
//
//  Return (BOOL FNLOCAL):
//
//
//  History:
//       1/27/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL adpcmIsMagicFormat
(
    LPADPCMWAVEFORMAT   pwfADPCM
)
{
    UINT        u;

    //
    //  verify that there is at least enough space specified in cbSize
    //  for the extra info for the ADPCM header...
    //
    if (pwfADPCM->wfx.cbSize < MSADPCM_WFX_EXTRA_BYTES)
        return (FALSE);

    //
    //  check coef's to see if it is Microsoft's standard ADPCM
    //
    if (pwfADPCM->wNumCoef != MSADPCM_MAX_COEFFICIENTS)
        return (FALSE);

    for (u = 0; u < MSADPCM_MAX_COEFFICIENTS; u++)
    {
        if (pwfADPCM->aCoef[u].iCoef1 != gaiCoef1[u])
            return (FALSE);

        if (pwfADPCM->aCoef[u].iCoef2 != gaiCoef2[u])
            return (FALSE);
    }

    return (TRUE);
} // adpcmIsMagicFormat()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL adpcmCopyCoefficients
//
//  Description:
//
//
//  Arguments:
//      LPADPCMWAVEFORMAT pwfadpcm:
//
//  Return (BOOL):
//
//  History:
//      06/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL adpcmCopyCoefficients
(
    LPADPCMWAVEFORMAT   pwfadpcm
)
{
    UINT        u;

    pwfadpcm->wNumCoef = MSADPCM_MAX_COEFFICIENTS;

    for (u = 0; u < MSADPCM_MAX_COEFFICIENTS; u++)
    {
        pwfadpcm->aCoef[u].iCoef1 = (short)gaiCoef1[u];
        pwfadpcm->aCoef[u].iCoef2 = (short)gaiCoef2[u];
    }

    return (TRUE);
} // adpcmCopyCoefficients()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PCODECINST  pci;

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (NULL != paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        {
            return (0L);
        }
    }


    //
    //  we are being opened as an installable driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure. note that we
    //  rely on allocating the memory as zero-initialized!
    //
    pci = (PCODECINST)LocalAlloc(LPTR, sizeof(*pci));
    if (NULL == pci)
    {
        //
        //  if this open attempt was as an ACM driver, then return the
        //  reason we are failing in the open description structure..
        //
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        //
        //  fail to open
        //
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pci->hdrvr          = hdrvr;
    pci->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.

    if (NULL != paod)
    {
        pci->DriverProc   = NULL;
        pci->fccType      = paod->fccType;
        pci->vdwACM       = paod->dwVersion;
        pci->dwFlags      = paod->dwFlags;

        paod->dwError     = MMSYSERR_NOERROR;
    }


    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)pci);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the codec. The
//      codec receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen).
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the codec instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the codec never fail to
//      close.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PCODECINST      pci
)
{
    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (pci != NULL)
    {
        //
        //  close down the conversion instance. this codec simply needs
        //  to free the instance data structure...
        //
        LocalFree((HLOCAL)pci);
    }

    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'hardware configuration' support of the
//      codec. That is, a dialog should be displayed to configure ports,
//      IRQ's, memory mappings, etc if it needs to.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      HWND hwnd: Handle to parent window to use when displaying hardware
//      configuration dialog box. A codec is _required_ to display a modal
//      dialog box using this hwnd argument as the parent. This argument
//      may be (HWND)-1 which tells the codec that it is only being
//      queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the codec should invent its own
//      storage location.
//
//  Return (LRESULT):
//      A non-zero return values specifies that either configuration is
//      supported or that the dialog was successfully displayed and
//      dismissed. A zero return indicates either configuration is not
//      supported or some other failure.
//
//  History:
//       1/25/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PCODECINST      pci,
    HWND            hwnd,
    LPDRVCONFIGINFO pdci
)
{
    //
    //  first check to see if we are only being queried for hardware
    //  configuration support. if hwnd == (HWND)-1 then we are being
    //  queried and should return zero for 'not supported' and non-zero
    //  for 'supported'.
    //
    if (hwnd == (HWND)-1)
    {
        //
        //  this codec does not support hardware configuration so return
        //  zero...
        //
        return (0L);
    }

    //
    //  we are being asked to bring up our hardware configuration dialog.
    //  if this codec can bring up a dialog box, then after the dialog
    //  is dismissed we return non-zero. if we are not able to display a
    //  dialog, then return zero.
    //
    return (0L);
} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The codec
//      is responsible for filling in the ACMDRIVERDETAILS structure with
//      various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your codec is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the codec with acmConverterOpen.
//
//          o   check for the proper uMid and uPid using acmConverterInfo
//
//          o   send the 'user defined' message with acmConverterMessage
//              to retrieve additional information, etc.
//
//          o   close the codec with acmConverterClose.
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to fill in
//      for caller. This structure may be larger or smaller than the
//      current definition of ACMDRIVERDETAILS--cbStruct specifies the valid
//      size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. A non-zero
//      return signifies an error which is either an MMSYSERR_* or an
//      ACMERR_*.
//
//      Note that this function should never fail. There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The codec does not need to check for these
//      conditions.
//
//  History:
//       1/23/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PCODECINST          pci,
    LPACMDRIVERDETAILS  padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;

    //
    //  for the current implementation of an ACM codec, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC ('audc')
    //  and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;

    //
    //  the manufacturer id (uMid) and product id (uPid) must be filled
    //  in with your company's _registered_ id's. for more information
    //  on these id's and how to get them registered contact Microsoft
    //  and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Systems Group
    //      Product Marketing
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Phone: 800-227-4679 x11771
    //
    //  note that during the development phase or your codec, you may
    //  use the reserved value of '0' for both uMid and uPid.
    //
    add.wMid            = MM_MICROSOFT;
    add.wPid            = MM_MSFT_ACM_MSADPCM;

    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM must contain the version of the *ACM* that the codec was
    //  designed for.
    //
    //  vdwDriver is the version of the driver.
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_CODEC;

    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the converter/codec/filter supports. these are placed in the
    //  fdwSupport field of the ACMDRIVERDETAILS structure. note that a converter
    //  can support one or more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the converter supports
    //  conversions from one format tag to another format tag. for example,
    //  if a converter compresses WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, then
    //  this bit should be set.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the converter
    //  supports conversions on the same format tag. as an example, the PCM
    //  converter that is built into the ACM sets this bit (and only this
    //  bit) because it converts only PCM formats (bits, sample rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the converter supports
    //  'in place' transformations on a single format tag without changing
    //  the size of the resulting data. for example, a converter that changed
    //  the 'volume' of PCM data would set this bit. note that this is a
    //  _destructive_ action--but it saves memory, etc.
    //
    //  this converter only supports compression and decompression.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;


    //
    //  Return the number of format tags this converter supports
    //  (In the case of PCM only this is 1)
    //
    add.cFormatTags     = CODEC_MAX_FORMAT_TAGS;

    //
    //  Return the number of filter tags this converter supports
    //  (In the case of a codec (only) it is 0)
    //
    add.cFilterTags     = CODEC_MAX_FILTER_TAGS;



    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //
        //  this codec has no custom icon
        //
        add.hicon = NULL;

        LoadStringCodec(pci->hinst, IDS_CODEC_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pci->hinst, IDS_CODEC_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pci->hinst, IDS_CODEC_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pci->hinst, IDS_CODEC_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pci->hinst, IDS_CODEC_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }

    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(padd, &add, (UINT)add.cbStruct);

    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      A codec has the option of displaying its own 'about box' or letting
//      the ACM display one for it.
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      HWND hwnd: Handle to parent window to use when displaying custom
//      about box. If a codec displays its own dialog, it is _required_
//      to display a modal dialog box using this hwnd argument as the
//      parent.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM should display
//      a generic about box using the information contained in the codec
//      capabilities structure.
//
//      If the codec chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//  History:
//       1/24/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PCODECINST      pci,
    HWND            hwnd
)
{
    //
    //  this codec does not need any special dialog, so tell the ACM to
    //  display one for us. note that this is the _recommended_ method
    //  for consistency and simplicity of codecs. why write code when
    //  you don't have to?
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM (wave mapper) or
//      an application to quickly get a destination format that this codec
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible.
//
//      Another way to think about this message is: what format would this
//      codec like to convert the source format to?
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to ACMDRVFORMATSUGGEST structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero ACMERR_*
//      or MMSYSERR_* if the function fails.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PCODECINST              pci,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    LPWAVEFORMATEX  pwfxSrc;
    LPWAVEFORMATEX  pwfxDst;
    LPADPCMWAVEFORMAT   pwfadpcm;
    LPPCMWAVEFORMAT     pwfpcm;

    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;

    //
    //
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            //
            //  verify source format is acceptable for this driver
            //
            if (!pcmIsValidFormat(pwfxSrc))
                break;


            //
            // Verify that you are not asking for a particular dest format
            //  that is not ADPCM.
            //
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_WFORMATTAG) &&
                (pwfxDst->wFormatTag != WAVE_FORMAT_ADPCM) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }

            // Verify that if other restrictions are given, they
            // match to the source.  (Since we do not convert
            // the nChannels or nSamplesPerSec
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_NCHANNELS) &&
                (pwfxSrc->nChannels != pwfxDst->nChannels) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_NSAMPLESPERSEC) &&
                (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }

            // Verify that if we are asking for a specific number of bits
            // per sample, that it is the correct #
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_WBITSPERSAMPLE) &&
                (pwfxDst->wBitsPerSample != 4) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }

            //
            //  suggest an ADPCM format that has most of the same details
            //  as the source PCM format
            //
            pwfxDst->wFormatTag      = WAVE_FORMAT_ADPCM;
            pwfxDst->nSamplesPerSec  = pwfxSrc->nSamplesPerSec;
            pwfxDst->nChannels       = pwfxSrc->nChannels;
            pwfxDst->wBitsPerSample  = MSADPCM_BITS_PER_SAMPLE;

            pwfxDst->nBlockAlign     = adpcmBlockAlign(pwfxDst);
            pwfxDst->nAvgBytesPerSec = adpcmAvgBytesPerSec(pwfxDst);
            pwfxDst->cbSize          = MSADPCM_WFX_EXTRA_BYTES;

            pwfadpcm = (LPADPCMWAVEFORMAT)pwfxDst;
            pwfadpcm->wSamplesPerBlock = adpcmSamplesPerBlock(pwfxDst);

            adpcmCopyCoefficients(pwfadpcm);
            return (MMSYSERR_NOERROR);


        case WAVE_FORMAT_ADPCM:
            //
            //  verify source format is acceptable for this driver
            //
            if (!adpcmIsValidFormat(pwfxSrc) ||
                !adpcmIsMagicFormat((LPADPCMWAVEFORMAT)pwfxSrc))
                break;

            //
            // Verify that you are not asking for a particular dest format
            //  that is not PCM.
            //
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_WFORMATTAG) &&
                (pwfxDst->wFormatTag != WAVE_FORMAT_PCM) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }

            // Verify that if other restrictions are given, they
            // match to the source.  (Since we do not convert
            // the nChannels or nSamplesPerSec
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_NCHANNELS) &&
                (pwfxSrc->nChannels != pwfxDst->nChannels) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_NSAMPLESPERSEC) &&
                (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }

            //
            //  suggest a PCM format that has most of the same details
            //  as the source ADPCM format
            //
            pwfxDst->wFormatTag      = WAVE_FORMAT_PCM;
            pwfxDst->nSamplesPerSec  = pwfxSrc->nSamplesPerSec;
            pwfxDst->nChannels       = pwfxSrc->nChannels;

            // Verify that if we are asking for a specific number of bits
            // per sample, that it is the correct #
            if( padfs->fdwSuggest & ACM_FORMATSUGGESTF_WBITSPERSAMPLE ) {
                if( (pwfxDst->wBitsPerSample != 8) &&
                    (pwfxDst->wBitsPerSample != 16) ) {
                    return (ACMERR_NOTPOSSIBLE);
                }
            } else {
                // Default to 16 bit decode
                pwfxDst->wBitsPerSample  = 16;
            }

            pwfpcm = (LPPCMWAVEFORMAT)pwfxDst;

            pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfxDst);
            pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec *
                                       pwfxDst->nBlockAlign;
            return (MMSYSERR_NOERROR);
    }

    //
    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this converter
    //  cannot deal with.
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdFormatSuggest()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//
//
//  Arguments:
//      PCODECINST pci:
//
//      LPACMFORMATTAGDETAILS padft:
//
//      DWORD fdwDetails:
//
//  Return (LRESULT):
//
//  History:
//      08/01/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PCODECINST              pci,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format.  return error.
            //
            if (CODEC_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_ADPCM:
                    uFormatTag = WAVE_FORMAT_ADPCM;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_ADPCM:
                    uFormatTag = WAVE_FORMAT_ADPCM;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this converter does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = CODEC_MAX_FORMATS_PCM;


            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0] = '\0';
            break;

        case WAVE_FORMAT_ADPCM:
            padft->dwFormatTagIndex = 1;
            padft->dwFormatTag      = WAVE_FORMAT_ADPCM;
            padft->cbFormatSize     = sizeof(WAVEFORMATEX) +
                                      MSADPCM_WFX_EXTRA_BYTES;
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = CODEC_MAX_FORMATS_ADPCM;

            LoadStringCodec(pci->hinst, IDS_CODEC_NAME, padft->szFormatTag, SIZEOFACMSTR(padft->szFormatTag));
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//
//
//  Arguments:
//      PCODECINST pci:
//
//      LPACMFORMATDETAILS padf:
//
//      DWORD fdwDetails:
//
//  Return (LRESULT):
//
//  History:
//      06/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PCODECINST              pci,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX      pwfx;
    LPADPCMWAVEFORMAT   pwfadpcm;
    UINT                uFormatIndex;
    UINT                u;

    pwfx = padf->pwfx;

    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  enumerate by index
            //
            //  for this converter, this is more code than necessary... just
            //  verify that the format tag is something we know about
            //
            switch (padf->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (CODEC_MAX_FORMATS_PCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    //
                    //  put some stuff in more accessible variables--note
                    //  that we bring variable sizes down to a reasonable
                    //  size for 16 bit code...
                    //
                    uFormatIndex = (UINT)padf->dwFormatIndex;
                    pwfx         = padf->pwfx;

                    //
                    //  now fill in the format structure
                    //
                    pwfx->wFormatTag      = WAVE_FORMAT_PCM;

                    u = uFormatIndex / (CODEC_MAX_BITSPERSAMPLE_PCM * CODEC_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % CODEC_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;

                    u = (uFormatIndex / CODEC_MAX_CHANNELS) % CODEC_MAX_CHANNELS;
                    pwfx->wBitsPerSample  = (WORD)gauFormatIndexToBitsPerSample[u];

                    pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfx);
                    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

                    //
                    //  note that the cbSize field is NOT valid for PCM
                    //  formats
                    //
                    //  pwfx->cbSize      = 0;
                    break;


                case WAVE_FORMAT_ADPCM:
                    if (CODEC_MAX_FORMATS_ADPCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    //
                    //  put some stuff in more accessible variables--note that we
                    //  bring variable sizes down to a reasonable size for 16 bit
                    //  code...
                    //
                    uFormatIndex = (UINT)padf->dwFormatIndex;
                    pwfx         = padf->pwfx;
                    pwfadpcm     = (LPADPCMWAVEFORMAT)pwfx;

                    //
                    //
                    //
                    pwfx->wFormatTag      = WAVE_FORMAT_ADPCM;

                    u = uFormatIndex / (CODEC_MAX_BITSPERSAMPLE_ADPCM * CODEC_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % CODEC_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;
                    pwfx->wBitsPerSample  = MSADPCM_BITS_PER_SAMPLE;

                    pwfx->nBlockAlign     = adpcmBlockAlign(pwfx);
                    pwfx->nAvgBytesPerSec = adpcmAvgBytesPerSec(pwfx);
                    pwfx->cbSize          = MSADPCM_WFX_EXTRA_BYTES;

                    pwfadpcm->wSamplesPerBlock = adpcmSamplesPerBlock(pwfx);

                    adpcmCopyCoefficients(pwfadpcm);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        case ACM_FORMATDETAILSF_FORMAT:
            //
            //  must want to verify that the format passed in is supported
            //  and return a string description...
            //
            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (!pcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                case WAVE_FORMAT_ADPCM:
                    if (!adpcmIsValidFormat(pwfx) ||
                        !adpcmIsMagicFormat((LPADPCMWAVEFORMAT)pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc)
    //
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    padf->szFormat[0] = '\0';
    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamQuery
//
//  Description:
//      This is an internal helper used by the ACMDM_STREM_OPEN
//      and ACMDM_STREAM_SIZE messages.
//      The purpose of this function is to tell the caller if the proposed
//      conversion can be handled by this codec.
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPWAVEFORMATEX pwfxSrc:
//
//      LPWAVEFORMATEX pwfxDst:
//
//      LPWAVEFILTER   pwfltr:
//
//      DWORD fdwOpen:
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero ACMERR_*
//      or MMSYSERR_* if the function fails.
//
//      A return value of ACMERR_NOTPOSSIBLE must be returned if the conversion
//      cannot be performed by this codec.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamQuery
(
    PCODECINST      pci,
    LPWAVEFORMATEX  pwfxSrc,
    LPWAVEFORMATEX  pwfxDst,
    LPWAVEFILTER    pwfltr,
    DWORD           fdwOpen
)
{
    LPADPCMWAVEFORMAT   pwfADPCM;
    LPPCMWAVEFORMAT     pwfPCM;

    //
    //  check to see if this
    //  codec can convert from the source to the destination.
    //
    //  first check if source is ADPCM so destination must be PCM..
    //
    if (adpcmIsValidFormat(pwfxSrc))
    {
        if (!pcmIsValidFormat(pwfxDst))
            return (ACMERR_NOTPOSSIBLE);

        //
        //  converting from ADPCM to PCM...
        //
        pwfADPCM = (LPADPCMWAVEFORMAT)pwfxSrc;
        pwfPCM   = (LPPCMWAVEFORMAT)pwfxDst;

        if (pwfADPCM->wfx.nChannels != pwfPCM->wf.nChannels)
            return (ACMERR_NOTPOSSIBLE);

        if (pwfADPCM->wfx.nSamplesPerSec != pwfPCM->wf.nSamplesPerSec)
            return (ACMERR_NOTPOSSIBLE);

        if (!adpcmIsMagicFormat(pwfADPCM))
            return (ACMERR_NOTPOSSIBLE);

        return (MMSYSERR_NOERROR);
    }

    //
    //  now try source as PCM so destination must be ADPCM..
    //
    else if (pcmIsValidFormat(pwfxSrc))
    {
        if (!adpcmIsValidFormat(pwfxDst))
            return (ACMERR_NOTPOSSIBLE);

        //
        //  converting from PCM to ADPCM...
        //
        pwfPCM   = (LPPCMWAVEFORMAT)pwfxSrc;
        pwfADPCM = (LPADPCMWAVEFORMAT)pwfxDst;

        if (pwfADPCM->wfx.nChannels != pwfPCM->wf.nChannels)
            return (ACMERR_NOTPOSSIBLE);

        if (pwfADPCM->wfx.nSamplesPerSec != pwfPCM->wf.nSamplesPerSec)
            return (ACMERR_NOTPOSSIBLE);

        if (!adpcmIsMagicFormat(pwfADPCM))
            return (ACMERR_NOTPOSSIBLE);

        return (MMSYSERR_NOERROR);
    }

    //
    //  we are unable to perform the conversion we are being queried for
    //  so return ACMERR_NOTPOSSIBLE to signify this...
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdStreamQuery()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmOpenConversion. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPACMDRVINSTANCE padi: Pointer to instance data for the conversion
//      stream. This structure was allocated by the ACM and filled with
//      the most common instance data needed for conversions.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero ACMERR_*
//      or MMSYSERR_* if the function fails.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;

    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    //
    //  the most important condition to check before doing anything else
    //  is that this codec can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this codec.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a codec that is suitable for the conversion. also note that
    //  the ACM may call this codec several times with slightly different
    //  format specifications before giving up.
    //
    //  this codec first verifies that the src and dst formats are
    //  acceptable...
    //
    if (acmdStreamQuery(pci,
                         pwfxSrc,
                         pwfxDst,
                         padsi->pwfltr,
                         padsi->fdwOpen))
    {
        //
        //  either the source or destination format is illegal for this
        //  codec--or the conversion between the formats can not be
        //  performed by this codec.
        //
        return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  we have decided that this codec can handle the conversion stream.
    //  so we want to do _as much work as possible_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this codec is very simple, so we only figure out what conversion
    //  function that should be used for converting from the src format
    //  to the dst format and place this in the dwDrvInstance member
    //  of the ACMDRVINSTANCE structure. we then only need to 'call'
    //  this function during the ACMDM_STREAM_CONVERT message.
    //
    if (pwfxSrc->wFormatTag == WAVE_FORMAT_ADPCM)
    {
#ifdef WIN32
        switch (pwfxDst->nChannels)
        {
            case 1:
                if (8 == pwfxDst->wBitsPerSample)
                    padsi->dwDriver = (DWORD_PTR)adpcmDecode4Bit_M08;
                else
                    padsi->dwDriver = (DWORD_PTR)adpcmDecode4Bit_M16;
                break;

            case 2:
                if (8 == pwfxDst->wBitsPerSample)
                    padsi->dwDriver = (DWORD_PTR)adpcmDecode4Bit_S08;
                else
                    padsi->dwDriver = (DWORD_PTR)adpcmDecode4Bit_S16;
                break;

            default:
                return ACMERR_NOTPOSSIBLE;
        }
#else
        padsi->dwDriver = (DWORD_PTR)DecodeADPCM_4Bit_386;
#endif
        return (MMSYSERR_NOERROR);
    }
    else if (pwfxSrc->wFormatTag == WAVE_FORMAT_PCM)
    {
        //
        //  Check to see if we will be doing this conversion in realtime.
        //  (The default is yes)
        //
        if (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME)
        {
            switch (pwfxSrc->nChannels)
            {
                case 1:
                    if (8 == pwfxSrc->wBitsPerSample)
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_M08_FullPass;
                    else
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_M16_FullPass;
                    break;

                case 2:
                    if (8 == pwfxSrc->wBitsPerSample)
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_S08_FullPass;
                    else
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_S16_FullPass;
                    break;

                default:
                    return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
#ifdef WIN32
            switch (pwfxSrc->nChannels)
            {
                case 1:
                    if (8 == pwfxSrc->wBitsPerSample)
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_M08_OnePass;
                    else
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_M16_OnePass;
                    break;

                case 2:
                    if (8 == pwfxSrc->wBitsPerSample)
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_S08_OnePass;
                    else
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_S16_OnePass;
                    break;

                default:
                    return ACMERR_NOTPOSSIBLE;
            }
#else
            padsi->dwDriver = (DWORD_PTR)EncodeADPCM_4Bit_386;
#endif
        }

        return (MMSYSERR_NOERROR);
    }

    //
    //  fail--we cannot perform the conversion
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmCloseConversion). The codec should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPACMDRVINSTANCE padi: Pointer to instance data for the conversion
//      stream.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero ACMERR_*
//      or MMSYSERR_* if the function fails.
//
//      NOTE! It is _strongly_ recommended that a codec not fail to close
//      a conversion stream.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    //
    //  the codec should clean up all resources that were allocated for
    //  the stream instance.
    //
    //  this codec did not allocate any resources, so we succeed immediately
    //
    return (MMSYSERR_NOERROR);
} // acmdStreamClose()




//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    LPADPCMWAVEFORMAT       pwfadpcm;
    DWORD                   cb;
    DWORD                   cBlocks;
    DWORD                   cbBytesPerBlock;


    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;


    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            cb = padss->cbSrcLength;

            if (WAVE_FORMAT_ADPCM == pwfxSrc->wFormatTag)
            {
                //
                //  how many destination PCM bytes are needed to hold
                //  the decoded ADPCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                cBlocks = cb / pwfxSrc->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfadpcm = (LPADPCMWAVEFORMAT)pwfxSrc;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxDst->nBlockAlign;

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                if (0 == (cb % pwfxSrc->nBlockAlign))
                {
                    cb = cBlocks * cbBytesPerBlock;
                }
                else
                {
                    cb = (cBlocks + 1) * cbBytesPerBlock;
                }
            }
            else
            {
                //
                //  how many destination ADPCM bytes are needed to hold
                //  the encoded PCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                pwfadpcm = (LPADPCMWAVEFORMAT)pwfxDst;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxSrc->nBlockAlign;

                cBlocks = cb / cbBytesPerBlock;

                if (0 == (cb % cbBytesPerBlock))
                {
                    cb = cBlocks * pwfxDst->nBlockAlign;
                }
                else
                {
                    cb = (cBlocks + 1) * pwfxDst->nBlockAlign;
                }

                if (0L == cb)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
            }

            padss->cbDstLength = cb;
            return (MMSYSERR_NOERROR);


        case ACM_STREAMSIZEF_DESTINATION:
            cb = padss->cbDstLength;

            if (WAVE_FORMAT_ADPCM == pwfxDst->wFormatTag)
            {
                //
                //  how many source PCM bytes can be encoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                cBlocks = cb / pwfxDst->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfadpcm = (LPADPCMWAVEFORMAT)pwfxDst;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxSrc->nBlockAlign;

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * cbBytesPerBlock;
            }
            else
            {
                //
                //  how many source ADPCM bytes can be decoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                pwfadpcm = (LPADPCMWAVEFORMAT)pwfxSrc;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxDst->nBlockAlign;

                cBlocks = cb / cbBytesPerBlock;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * pwfxSrc->nBlockAlign;
            }

            padss->cbSrcLength = cb;
            return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamConvert
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing a codec--to convert data. This message is
//      sent after a stream has been opened (the codec receives and succeeds
//      the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPACMDRVSTREAMHEADER pdsh: Pointer to a conversion stream instance
//      structure.
//
//      DWORD fdwConvert: Misc. flags for how conversion should be done.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero ACMERR_*
//      or MMSYSERR_* if the function fails.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamConvert
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    CONVERTPROC_C       fpConvertC;
#ifndef WIN32
    CONVERTPROC_ASM     fpConvertAsm;
    BOOL                fRealTime;
#endif
    BOOL                fBlockAlign;
    BOOL                fDecode;
    LPWAVEFORMATEX      pwfpcm;
    LPADPCMWAVEFORMAT   pwfadpcm;
    DWORD               dw;

    fBlockAlign = (0 != (ACM_STREAMCONVERTF_BLOCKALIGN & padsh->fdwConvert));
    fDecode     = ( WAVE_FORMAT_PCM == padsi->pwfxDst->wFormatTag );

    if( !fDecode )
    {
        //
        //  encode
        //
        pwfpcm   = padsi->pwfxSrc;
        pwfadpcm = (LPADPCMWAVEFORMAT)padsi->pwfxDst;

        dw = PCM_BYTESTOSAMPLES(pwfpcm, padsh->cbSrcLength);

        if (fBlockAlign)
        {
            dw = (dw / pwfadpcm->wSamplesPerBlock) * pwfadpcm->wSamplesPerBlock;
        }

        //
        //  Look for an easy exit.  We can only handle an even number of
        //  samples.
        //
        if( dw < 2 )
        {
            padsh->cbDstLengthUsed = 0;

            if( fBlockAlign )
                padsh->cbSrcLengthUsed = 0;
            else
                padsh->cbSrcLengthUsed = padsh->cbSrcLength;

            return MMSYSERR_NOERROR;
        }

        //
        //  Make sure we have an even number of samples.
        //
        dw &= ~1;


        dw  = PCM_SAMPLESTOBYTES(pwfpcm, dw);

        padsh->cbSrcLengthUsed = dw;
    }
    else
    {
        //
        //  Decode.
        //

        pwfadpcm = (LPADPCMWAVEFORMAT)padsi->pwfxSrc;
        pwfpcm   = padsi->pwfxDst;

        //
        // Determine the number of samples to convert.
        //
        dw = padsh->cbSrcLength;
        if (fBlockAlign) {
            dw = (dw / pwfadpcm->wfx.nBlockAlign) * pwfadpcm->wfx.nBlockAlign;
        }
        padsh->cbSrcLengthUsed = dw;
    }

    //
    //  Call the conversion routine.
    //
#ifdef WIN32

    fpConvertC = (CONVERTPROC_C)padsi->dwDriver;
    padsh->cbDstLengthUsed = (*fpConvertC)(
                (HPBYTE)padsh->pbSrc,
                padsh->cbSrcLengthUsed,
                (HPBYTE)padsh->pbDst,
                (UINT)pwfadpcm->wfx.nBlockAlign,
                (UINT)pwfadpcm->wSamplesPerBlock,
                (UINT)pwfadpcm->wNumCoef,
                (LPADPCMCOEFSET)&(pwfadpcm->aCoef[0])
    );

#else

    fRealTime = (0L == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME) );
    if( fDecode || fRealTime ) {
        fpConvertAsm = (CONVERTPROC_ASM)padsi->dwDriver;
        padsh->cbDstLengthUsed = (*fpConvertAsm)(
                padsi->pwfxSrc,
                padsh->pbSrc,
                padsi->pwfxDst,
                padsh->pbDst,
                padsh->cbSrcLengthUsed
        );
    } else {
        fpConvertC = (CONVERTPROC_C)padsi->dwDriver;
        padsh->cbDstLengthUsed = (*fpConvertC)(
                (HPBYTE)padsh->pbSrc,
                padsh->cbSrcLengthUsed,
                (HPBYTE)padsh->pbDst,
                (UINT)pwfadpcm->wfx.nBlockAlign,
                (UINT)pwfadpcm->wSamplesPerBlock,
                (UINT)pwfadpcm->wNumCoef,
                (LPADPCMCOEFSET)&(pwfadpcm->aCoef[0])
        );
    }

#endif

    return (MMSYSERR_NOERROR);
} // acmdStreamConvert()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD_PTR dwId: For most messages, dwId is the DWORD_PTR value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      that the driver is opened, through the DrvOpen API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message.  Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message.  Defined separately for
//      each message.
//
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNEXPORT DriverProc
(
    DWORD_PTR   dwId,
    HDRVR       hdrvr,
    UINT        uMsg,
    LPARAM      lParam1,
    LPARAM      lParam2
)
{
    LRESULT             lr;
    PCODECINST          pci;

    //
    //  make pci either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwId is for other
    //  messages (instance data).
    //
    pci = (PCODECINST)dwId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef WIN32
            DbgInitialize(TRUE);
#endif
            DPF(4, "DRV_LOAD");
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
            DPF(4, "DRV_FREE");
            return (1L);

        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            DPF(4, "DRV_OPEN");
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
            DPF(4, "DRV_CLOSE");
            lr = acmdDriverClose(pci);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            DPF(4, "DRV_INSTALL");
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            DPF(4, "DRV_REMOVE");
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            DPF(4, "DRV_QUERYCONFIGURE");
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for hardware configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            DPF(4, "DRV_CONFIGURE");
            lr = acmdDriverConfigure(pci, (HWND)lParam1,
                    (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            DPF(4, "ACMDM_DRIVER_DETAILS");
            lr = acmdDriverDetails(pci, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            DPF(4, "ACMDM_DRIVER_ABOUT");
            lr = acmdDriverAbout(pci, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_FORMAT_SUGGEST:
            DPF(4, "ACMDM_FORMAT_SUGGEST");
            lr = acmdFormatSuggest(pci, (LPACMDRVFORMATSUGGEST)lParam1 );
            return (lr);


        //
        //  lParam1: FORMATTAGDETAILS
        //
        //  lParam2: Not used.
        //
        case ACMDM_FORMATTAG_DETAILS:
            DPF(4, "ACMDM_FORMATTAG_DETAILS");
            lr = acmdFormatTagDetails(pci, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

        //
        //  lParam1: FORMATDETAILS
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            DPF(4, "ACMDM_FORMAT_DETAILS");
            lr = acmdFormatDetails(pci, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            DPF(4, "ACMDM_STREAM_OPEN");
            lr = acmdStreamOpen(pci, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            DPF(4, "ACMDM_STREAM_CLOSE");
            lr = acmdStreamClose(pci, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
            DPF(4, "ACMDM_STREAM_SIZE");
            lr = acmdStreamSize(pci, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
            DPF(4, "ACMDM_STREAM_CONVERT");
            lr = acmdStreamConvert(pci, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMHEADER)lParam2);
            return (lr);
    }

    //
    //  if we are executing the following code, then this codec does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if a codec does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   Other installable driver messages: if a codec does not answer
    //      a message that is NOT in the ACM driver message range, then
    //      it must call DefDriverProc and return that result.
    //
    DPF(4, "OTHER MESSAGE RECEIVED BY DRIVERPROC");
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msadpcm\codec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.h
//
//  Description:
//      This file contains codec definitions, Win16/Win32 compatibility
//      definitions, and instance structure definitions.
//
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//==========================================================================;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_CODEC is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_CODEC	    MAKE_ACM_VERSION(4,  0, 0)
#else
 #define VERSION_CODEC	    MAKE_ACM_VERSION(3, 51, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_CODEC	    MAKE_ACM_VERSION(2, 1, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwf argument is a pointer to a WAVEFORMATEX structure.
//
#define PCM_BLOCKALIGNMENT(pwfx)        (UINT)(((pwfx)->wBitsPerSample >> 3) << ((pwfx)->nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwfx)        (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwfx, cb)    (DWORD)(cb / PCM_BLOCKALIGNMENT(pwfx))
#define PCM_SAMPLESTOBYTES(pwfx, dw)    (DWORD)(dw * PCM_BLOCKALIGNMENT(pwfx))


//
//
//
#define MAX_ERR_STRING      250     // used in various places for errors



//
//
//
//
typedef struct tCODECINST
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the codec will be easier to combine
    //  with other types of codecs (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of codec: 'audc'
    DRIVERPROC      DriverProc;     // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your codec requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           dwFlags;        // flags from open description

} CODECINST, *PCODECINST, FAR *LPCODECINST;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  typedefs
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  This define deals with unaligned data for Win32, and huge data for Win16.
//  Basically, any time you cast an HPBYTE to a non-byte variable (ie long or
//  short), you should cast it to ( {short,long} HUGE_T *).  This will cast
//  it to _huge for Win16, and make sure that there are no alignment problems
//  for Win32 on MIPS and Alpha machines.
//

typedef BYTE HUGE *HPBYTE;

#ifdef WIN32
    #define HUGE_T  UNALIGNED
#else
    #define HUGE_T  _huge
#endif


typedef DWORD (FNGLOBAL *CONVERTPROC_ASM)(LPWAVEFORMATEX, LPBYTE, LPWAVEFORMATEX, LPBYTE, DWORD);
typedef DWORD (FNGLOBAL *CONVERTPROC_C)
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);



//
//  resource id's
//
//
#define ICON_CODEC                  RCID(10)

#define IDS_CODEC_SHORTNAME         (1)     // ACMCONVINFO.szShortName
#define IDS_CODEC_LONGNAME          (2)     // ACMCONVINFO.szLongName
#define IDS_CODEC_COPYRIGHT         (3)     // ACMCONVINFO.szCopyright
#define IDS_CODEC_LICENSING         (4)     // ACMCONVINFO.szLicensing
#define IDS_CODEC_FEATURES          (5)     // ACMCONVINFO.szFeatures

#define IDS_CODEC_NAME              (10)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msacmmap\waveout.c ===
//==========================================================================;
//
//  waveout.c
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       9/18/93    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "msacmmap.h"

#include "debug.h"


//--------------------------------------------------------------------------;
//
//  DWORD wodmMapperStatus
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      DWORD dwStatus:
//
//      LPDWORD pdw:
//
//  Return (DWORD):
//
//  History:
//      08/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL wodmMapperStatus
(
    LPMAPSTREAM     pms,
    DWORD           dwStatus,
    LPDWORD         pdw
)
{
    MMRESULT        mmr;

//  V_WPOINTER(pdw, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if ((NULL == pms) || (NULL == pdw))
    {
	return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    switch (dwStatus)
    {
	case WAVEOUT_MAPPER_STATUS_DEVICE:
	{
	    UINT        uId = (UINT)(-1);   // Invalid value

	    mmr = waveOutGetID(pms->hwoReal, &uId);
	    if (MMSYSERR_NOERROR != mmr)
	    {
		return (mmr);
	    }

	    *pdw = uId;
	    return (MMSYSERR_NOERROR);
	}

	case WAVEOUT_MAPPER_STATUS_MAPPED:
	    *pdw = (NULL != pms->has);
	    return (MMSYSERR_NOERROR);

	case WAVEOUT_MAPPER_STATUS_FORMAT:
	    if (NULL != pms->has)
		_fmemcpy(pdw, pms->pwfxReal, sizeof(PCMWAVEFORMAT));
	    else
		_fmemcpy(pdw, pms->pwfxClient, sizeof(PCMWAVEFORMAT));

	    ((LPWAVEFORMATEX)pdw)->cbSize = 0;
	    return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // wodmMapperStatus()


//--------------------------------------------------------------------------;
//
//  DWORD wodMessage
//
//  Description:
//      This function conforms to the standard Wave output driver message
//      procedure (wodMessage), which is documented in mmddk.d.
//
//  Arguments:
//      UINT uId:
//
//      UINT uMsg:
//
//      DWORD dwUser:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (DWORD):
//
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C DWORD FNEXPORT wodMessage
(
    UINT                    uId,
    UINT                    uMsg,
    DWORD_PTR               dwUser,
    DWORD_PTR               dwParam1,
    DWORD_PTR               dwParam2
)
{
#ifndef WIN32  // Mechanism doesn't work for multithread
    static int          fSem = 0;
#endif // !WIN32
    DWORD               dw;
    LPMAPSTREAM         pms;    // pointer to per-instance info structure

    if (!gpag->fEnabled)
    {
	DPF(1, "wodMessage: called while disabled!");
	return ((WODM_GETNUMDEVS == uMsg) ? 0L : MMSYSERR_NOTENABLED);
    }

#ifndef WIN32
    //
    //  we call back into the mmsystem wave APIs so protect ourself
    //  from being re-entered!
    //
    if (fSem)
    {
	DPF(0, "!wodMessage() being reentered! fSem=%d", fSem);
	return (MMSYSERR_NOTSUPPORTED);
    }
#endif

    pms = (LPMAPSTREAM)dwUser;

    switch (uMsg)
    {
	case WODM_GETNUMDEVS:
	    return (1L);

	case WODM_GETDEVCAPS:
	    return mapWaveGetDevCaps(FALSE, (LPWAVEOUTCAPS)dwParam1, (UINT)dwParam2);

	case WODM_OPEN:
#ifndef WIN32
	    fSem++;
#endif // !WIN32

	    //
	    //  dwParam1 contains a pointer to a WAVEOPENDESC
	    //  dwParam2 contains wave driver specific flags in the LOWORD
	    //  and generic driver flags in the HIWORD
	    //
	    dw = mapWaveOpen(FALSE, uId, dwUser, (LPWAVEOPENDESC)dwParam1, (DWORD)(PtrToLong((PVOID)dwParam2)));

#ifndef WIN32
	    fSem--;
#endif // !WIN32
	    return (dw);

	case WODM_CLOSE:
	    return (mapWaveClose(pms));

	case WODM_PREPARE:
	    return (mapWavePrepareHeader(pms, (LPWAVEHDR)dwParam1));

	case WODM_UNPREPARE:
	    return (mapWaveUnprepareHeader(pms, (LPWAVEHDR)dwParam1));

	case WODM_WRITE:
	    return (mapWaveWriteBuffer(pms, (LPWAVEHDR)dwParam1));

	case WODM_PAUSE:
	    return waveOutPause(pms->hwoReal);

	case WODM_RESTART:
	    return waveOutRestart(pms->hwoReal);

	case WODM_RESET:
	    return waveOutReset(pms->hwoReal);

	case WODM_BREAKLOOP:
	    return waveOutBreakLoop(pms->hwoReal);

	case WODM_GETPOS:
	    return mapWaveGetPosition(pms, (LPMMTIME)dwParam1, (UINT)dwParam2);

	case WODM_GETVOLUME:
	    if (NULL != pms)
	    {
#if (WINVER < 0x0400)
		UINT    uDevId;

		waveOutGetID(pms->hwoReal, &uDevId);
		return waveOutGetVolume(uDevId, (LPDWORD)dwParam1);
#else
		return waveOutGetVolume(pms->hwoReal, (LPDWORD)dwParam1);
#endif
	    }
	    else
        {
        UINT    uDevId;

        WAIT_FOR_MUTEX(gpag->hMutexSettings);
        uDevId = gpag->pSettings->uIdPreferredOut;
        RELEASE_MUTEX(gpag->hMutexSettings);

        if ((UINT)WAVE_MAPPER != uDevId)
	    {
#if (WINVER < 0x0400)
		return waveOutGetVolume(uDevId, (LPDWORD)dwParam1);
#else
		return waveOutGetVolume((HWAVEOUT)LongToHandle(uDevId), (LPDWORD)dwParam1);
#endif
        }
	    }

	    return (MMSYSERR_NOTSUPPORTED);

	case WODM_SETVOLUME:
	    if (NULL != pms)
	    {
#if (WINVER < 0x0400)
		UINT    uDevId;

		waveOutGetID(pms->hwoReal, &uDevId);
		return waveOutSetVolume(uDevId, (DWORD)(PtrToLong((PVOID)dwParam1)) );
#else
		return waveOutSetVolume(pms->hwoReal, (DWORD)(PtrToLong((PVOID)dwParam1)) );
#endif
	    }
	    else
        {
        UINT    uDevId;

        WAIT_FOR_MUTEX(gpag->hMutexSettings);
        uDevId = gpag->pSettings->uIdPreferredOut;
        RELEASE_MUTEX(gpag->hMutexSettings);

        if ((UINT)WAVE_MAPPER != uDevId)
    	{
#if (WINVER < 0x0400)
    	return waveOutSetVolume(uDevId, (DWORD)(PtrToLong((PVOID)dwParam1)) );
#else
    	return waveOutSetVolume((HWAVEOUT)(UINT_PTR)uDevId, (DWORD)(PtrToLong((PVOID)dwParam1)) );
#endif
    	}
        }

	    return (MMSYSERR_NOTSUPPORTED);

	case WODM_GETPITCH:
	    return waveOutGetPitch(pms->hwoReal, (LPDWORD)dwParam1);
	    
	case WODM_SETPITCH:
	    return waveOutSetPitch(pms->hwoReal, (DWORD)(PtrToLong((PVOID)dwParam1)) );
	    
	case WODM_GETPLAYBACKRATE:
	    return waveOutGetPlaybackRate(pms->hwoReal, (LPDWORD)dwParam1);
	    
	case WODM_SETPLAYBACKRATE:
	    return waveOutSetPlaybackRate(pms->hwoReal, (DWORD)(PtrToLong((PVOID)dwParam1)) );

	case WODM_MAPPER_STATUS:
	    dw = wodmMapperStatus(pms, (DWORD)(PtrToLong((PVOID)dwParam1)), (LPDWORD)dwParam2);
	    return (dw);

#if (WINVER >= 0x0400)
	case DRVM_MAPPER_RECONFIGURE:
	    mapDriverDisable(NULL);
	    mapDriverEnable(NULL);
	    return (0);
#endif
    }

    if (!pms || !pms->hwoReal)
	return (MMSYSERR_NOTSUPPORTED);

    return waveOutMessage(pms->hwoReal, uMsg, dwParam1, dwParam2);
} // wodMessage()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msadpcm\debug.h ===
// Copyright (c) 1994 Microsoft Corporation
//==========================================================================;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define DEBUG_SECTION       "Debug"         // section name for 
#define DEBUG_MODULE_NAME   "MSADPCM"       // key name and prefix for output
#define DEBUG_MAX_LINE_LEN  255             // max line length (bytes)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define DPF      dprintf
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #pragma warning(disable:4002)
    #define DPF()
    #define ASSERT(x)
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msadpcm\init.c ===
//==========================================================================;
//
//  init.c
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//  Description:
//
//
//  History:
//      11/16/92    cjp     [curtisp] 
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "codec.h"

#include "debug.h"


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef WIN32

//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//  Arguments:
//      HINSTANCE hinst: Our module handle.
//
//      WORD wDataSeg: Specifies the DS value for this DLL.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp] 
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE   hinst, 
    WORD        wDataSeg, 
    WORD        cbHeapSize,
    LPSTR       pszCmdLine
)
{
    DbgInitialize(TRUE);

    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);

    return (TRUE);
} // LibMain()


//--------------------------------------------------------------------------;
//  
//  int WEP
//  
//  Description:
//  
//  
//  Arguments:
//      WORD wUselessParam:
//  
//  Return (int):
//  
//  History:
//      03/28/93    cjp     [curtisp]
//  
//--------------------------------------------------------------------------;

int FNEXPORT WEP
(
    WORD    wUselessParam
)
{
    DPF(1, "WEP(wUselessParam=%u)", wUselessParam);

    //
    //  always return 1.
    //
    return (1);
} // WEP()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msadpcm\msadpcm.h ===
//==========================================================================;
//
//  msadpcm.h
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//  Description:
//
//
//  History:
//
//==========================================================================;


//
//
//

#define MSADPCM_MAX_CHANNELS        2
#define MSADPCM_MAX_COEFFICIENTS    7
#define MSADPCM_BITS_PER_SAMPLE     4
#define MSADPCM_WFX_EXTRA_BYTES     32
#define MSADPCM_HEADER_LENGTH       7       // in Bytes, per channel.

#define CSCALE_NUM                  256
#define PSCALE_NUM                  256
#define CSCALE                      8
#define PSCALE                      8

#define DELTA4START                 128
#define DELTA8START                 16

#define DELTA4MIN                   16
#define DELTA8MIN                   1

#define OUTPUT4MASK                 (0x0F)
#define OUTPUT4MAX                  7
#define OUTPUT4MIN                  (-8)
#define OUTPUT8MAX                  127
#define OUTPUT8MIN                  (-128)


//
//  note that these constants are used for encoding only. decode must take
//  all info from the file. note that then number of samples/bytes must be
//  small enough to let all stored arrays be DS ??? !!!
//
#define BPS4_COMPRESSED         4
#define BPS8_COMPRESSED         8
#define BLOCK4_SAMPLES          500
#define BLOCK4_STREAM_SAMPLES   498
#define BLOCK4_BYTES            256


//
//  These are defined as integers (even though they will fit in shorts)
//  because they are accessed so often - this will speed stuff up.
//
#ifdef WIN32
extern const int gaiCoef1[];
extern const int gaiCoef2[];
extern const int gaiP4[];
#else
extern short gaiCoef1[];
extern short gaiCoef2[];
extern short gaiP4[];
#endif


//
//  Function Prototypes.
//

DWORD FNGLOBAL adpcmEncode4Bit_M08_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_M16_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_S08_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_S16_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);


#ifdef WIN32

DWORD FNGLOBAL adpcmEncode4Bit_M08_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_M16_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_S08_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_S16_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);


DWORD FNGLOBAL adpcmDecode4Bit_M08
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmDecode4Bit_M16
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmDecode4Bit_S08
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmDecode4Bit_S16
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);


#else

//
//  These prototypes are for assembler routines in dec386.asm and enc386.asm
//

DWORD FNGLOBAL DecodeADPCM_4Bit_386
(
    LPADPCMWAVEFORMAT   pwfADPCM,
    LPBYTE              pbSrc,
    LPPCMWAVEFORMAT     pwfPCM,
    LPBYTE              pbDst,
    DWORD               cbSrcLen
);

DWORD FNGLOBAL EncodeADPCM_4Bit_386
(
    LPPCMWAVEFORMAT     pwfPCM,
    LPBYTE              pbSrc,
    LPADPCMWAVEFORMAT   pwfADPCM,
    LPBYTE              pbDst,
    DWORD               cbSrcLen
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msadpcm\msadpcm.c ===
//==========================================================================;
//
//  msadpcm.c
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//  Description:
//
//
//  History:
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "codec.h"
#include "msadpcm.h"

#include "debug.h"


//
//  these are in dec386.asm for Win 16
//
//  _gaiCoef1   dw  256,  512,  0, 192, 240,  460,  392
//  _gaiCoef2   dw    0, -256,  0,  64,   0, -208, -232
//
//  _gaiP4      dw  230, 230, 230, 230, 307, 409, 512, 614
//              dw  768, 614, 512, 409, 307, 230, 230, 230
//
#ifdef WIN32
    const int gaiCoef1[]= {256,  512, 0, 192, 240,  460,  392};
    const int gaiCoef2[]= {  0, -256, 0,  64,   0, -208, -232};

    const int gaiP4[]   = {230, 230, 230, 230, 307, 409, 512, 614,
                           768, 614, 512, 409, 307, 230, 230, 230};
#endif


#ifndef INLINE
#define INLINE __inline
#endif


                    
//--------------------------------------------------------------------------;
//  
//  DWORD pcmM08BytesToSamples
//  DWORD pcmM16BytesToSamples
//  DWORD pcmS08BytesToSamples
//  DWORD pcmS16BytesToSamples
//  
//  Description:
//      These functions return the number of samples in a buffer of PCM
//      of the specified format.  For efficiency, it is declared INLINE.
//      Note that, depending on the optimization flags, it may not
//      actually be implemented as INLINE.  Optimizing for speed (-Oxwt)
//      will generally obey the INLINE specification.
//  
//  Arguments:
//      DWORD cb: The length of the buffer, in bytes.
//  
//  Return (DWORD):  The length of the buffer in samples.
//  
//--------------------------------------------------------------------------;

INLINE DWORD pcmM08BytesToSamples( DWORD cb )
{
    return cb;
}

INLINE DWORD pcmM16BytesToSamples( DWORD cb )
{
    return cb / ((DWORD)2);
}

INLINE DWORD pcmS08BytesToSamples( DWORD cb )
{
    return cb / ((DWORD)2);
}

INLINE DWORD pcmS16BytesToSamples( DWORD cb )
{
    return cb / ((DWORD)4);
}



//--------------------------------------------------------------------------;
//  
//  int     pcmRead08
//  int     pcmRead16
//  int     pcmRead16Unaligned
//  
//  Description:
//      These functions read an 8 or 16 bit PCM value from the specified
//      buffer.  Note that the buffers are either HUGE or UNALIGNED in all
//      cases.  However, if a single 16-bit value crosses a segment boundary
//      in Win16, then pcmRead16 will wrap around; use pcmRead16Unaligned
//      instead.
//  
//  Arguments:
//      HPBYTE pb:  Pointer to the input buffer.
//  
//  Return (int):  The PCM value converted to 16-bit format.
//  
//--------------------------------------------------------------------------;

INLINE int pcmRead08( HPBYTE pb )
{
    return ( (int)*pb - 128 ) << 8;
}

INLINE int pcmRead16( HPBYTE pb )
{
    return (int)*(short HUGE_T *)pb;
}

#ifdef WIN32

#define pcmRead16Unaligned pcmRead16

#else

INLINE int pcmRead16Unaligned( HPBYTE pb )
{
    return (int)(short)( ((WORD)*pb) | (((WORD)*(pb+1))<<8) );
}

#endif



//--------------------------------------------------------------------------;
//  
//  void    pcmWrite08
//  void    pcmWrite16
//  void    pcmWrite16Unaligned
//
//  Description:
//      These functions write a PCM sample (a 16-bit integer) into the
//      specified buffer in the appropriate format.  Note that the buffers
//      are either HUGE or UNALIGNED.  However, if a single 16-bit value is
//      written across a segment boundary, then pcmWrite16 will not handle
//      it correctly; us pcmWrite16Unaligned instead.
//  
//  Arguments:
//      HPBYTE  pb:     Pointer to the output buffer.
//      int     iSamp:  The sample.
//  
//  Return (int):  The PCM value converted to 16-bit format.
//  
//--------------------------------------------------------------------------;

INLINE void pcmWrite08( HPBYTE pb, int iSamp )
{
    *pb = (BYTE)((iSamp >> 8) + 128);
}

INLINE void pcmWrite16( HPBYTE pb, int iSamp )
{
    *(short HUGE_T *)pb = (short)iSamp;
}

#ifdef WIN32

#define pcmWrite16Unaligned pcmWrite16

#else

INLINE void pcmWrite16Unaligned( HPBYTE pb, int iSamp )
{
    *pb     = (BYTE)( iSamp&0x00FF );
    *(pb+1) = (BYTE)( iSamp>>8 );
}

#endif



//--------------------------------------------------------------------------;
//
//  int adpcmCalcDelta
//
//  Description:
//      This function computes the next Adaptive Scale Factor (ASF) value
//      based on the the current ASF and the current encoded sample.
//
//  Arguments:
//      int iEnc:  The current encoded sample (as a signed integer).
//      int iDelta:  The current ASF.
//
//  Return (int):  The next ASF.
//      
//--------------------------------------------------------------------------;

INLINE int adpcmCalcDelta
(
    int iEnc,
    int iDelta
)
{
    int iNewDelta;

    iNewDelta = (int)((gaiP4[iEnc&OUTPUT4MASK] * (long)iDelta) >> PSCALE);
    if( iNewDelta < DELTA4MIN )
        iNewDelta = DELTA4MIN;

    return iNewDelta;
}



//--------------------------------------------------------------------------;
//
//  long adpcmCalcPrediction
//
//  Description:
//      This function calculates the predicted sample value based on the
//      previous two samples and the current coefficients.
//
//  Arguments:
//      int iSamp1:  The previous decoded sample.
//      int iCoef1:  The coefficient for iSamp1.
//      int iSamp2:  The decoded sample before iSamp1.
//      int iCoef2:  The coefficient for iSamp2.
//
//  Return (long):  The predicted sample.
//      
//--------------------------------------------------------------------------;

INLINE long adpcmCalcPrediction
(
    int iSamp1,
    int iCoef1,
    int iSamp2,
    int iCoef2
)
{
    return ((long)iSamp1 * iCoef1 + (long)iSamp2 * iCoef2) >> CSCALE;
}



//--------------------------------------------------------------------------;
//
//  int adpcmDecodeSample
//
//  Description:
//      This function decodes a single 4-bit encoded ADPCM sample.  There
//      are three steps:
//
//          1.  Sign-extend the 4-bit iInput.
//
//          2.  predict the next sample using the previous two
//              samples and the predictor coefficients:
//
//              Prediction = (iSamp1 * aiCoef1 + iSamp2 * iCoef2) / 256;
//
//          3.  reconstruct the original PCM sample using the encoded
//              sample (iInput), the Adaptive Scale Factor (aiDelta)
//              and the prediction value computed in step 1 above.
//
//              Sample = (iInput * iDelta) + Prediction;
//
//  Arguments:
//      int iSamp1:  The previous decoded sample.
//      int iCoef1:  The coefficient for iSamp1.
//      int iSamp2:  The decoded sample before iSamp1.
//      int iCoef2:  The coefficient for iSamp2.
//      int iInput:  The current encoded sample (lower 4 bits).
//      int iDelta:  The current ASF.
//
//  Return (int):  The decoded sample.
//      
//--------------------------------------------------------------------------;

INLINE int adpcmDecodeSample
(
    int iSamp1,
    int iCoef1,
    int iSamp2,
    int iCoef2,
    int iInput,
    int iDelta
)
{
    long lSamp;

    iInput = (int)( ((signed char)(iInput<<4)) >> 4 );

    lSamp = ((long)iInput * iDelta)  +
            adpcmCalcPrediction(iSamp1,iCoef1,iSamp2,iCoef2);

    if (lSamp > 32767)
        lSamp = 32767;
    else if (lSamp < -32768)
        lSamp = -32768;

    return (int)lSamp;
}

    

//--------------------------------------------------------------------------;
//
//  int adpcmEncode4Bit_FirstDelta
//
//  Description:
//      
//
//  Arguments:
//      
//
//  Return (short FNLOCAL):
//
//
//  History:
//       1/27/93    cjp     [curtisp] 
//
//--------------------------------------------------------------------------;

INLINE int FNLOCAL adpcmEncode4Bit_FirstDelta
(
    int iCoef1,
    int iCoef2,
    int iP5,
    int iP4,
    int iP3,
    int iP2,
    int iP1
)
{
    long    lTotal;
    int     iRtn;
    long    lTemp;

    //
    //  use average of 3 predictions
    //
    lTemp  = (((long)iP5 * iCoef2) + ((long)iP4 * iCoef1)) >> CSCALE;
    lTotal = (lTemp > iP3) ? (lTemp - iP3) : (iP3 - lTemp);

    lTemp   = (((long)iP4 * iCoef2) + ((long)iP3 * iCoef1)) >> CSCALE;
    lTotal += (lTemp > iP2) ? (lTemp - iP2) : (iP2 - lTemp);

    lTemp   = (((long)iP3 * iCoef2) + ((long)iP2 * iCoef1)) >> CSCALE;
    lTotal += (lTemp > iP1) ? (lTemp - iP1) : (iP1 - lTemp);
    
    //
    //  optimal iDelta is 1/4 of prediction error
    //
    iRtn = (int)(lTotal / 12);
    if (iRtn < DELTA4MIN)
        iRtn = DELTA4MIN;

    return (iRtn);
} // adpcmEncode4Bit_FirstDelta()




//==========================================================================;
//
//     NON-REALTIME ENCODE ROUTINES
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD adpcmEncode4Bit_M08_FullPass
//  DWORD adpcmEncode4Bit_M16_FullPass
//  DWORD adpcmEncode4Bit_S08_FullPass
//  DWORD adpcmEncode4Bit_S16_FullPass
//
//  Description:
//      These functions encode a buffer of data from PCM to MS ADPCM in the
//      specified format.  These functions use a fullpass algorithm which
//      tries each set of coefficients in order to determine which set
//      produces the smallest coding error.  The appropriate function is
//      called once for each ACMDM_STREAM_CONVERT message received.
//      
//
//  Arguments:
//      
//
//  Return (DWORD):  The number of bytes used in the destination buffer.
//
//--------------------------------------------------------------------------;

#define ENCODE_DELTA_LOOKAHEAD      5

DWORD FNGLOBAL adpcmEncode4Bit_M08_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    HPBYTE              pbSrcThisBlock;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 aiSamples[ENCODE_DELTA_LOOKAHEAD];
    int                 aiFirstDelta[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalError[MSADPCM_MAX_COEFFICIENTS];

    int                 iCoef1;
    int                 iCoef2;
    int                 iSamp1;
    int                 iSamp2;
    int                 iDelta;
    int                 iOutput1;
    int                 iOutput2;
    int                 iBestPredictor;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;
    DWORD               dw;
    UINT                i,n;


    pbDstStart = pbDst;
    cSrcSamples = pcmM08BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  We need the first ENCODE_DELTA_LOOKAHEAD samples in order to
        //  calculate the first iDelta value.  Therefore we put these samples
        //  into a more accessible array: aiSamples[].  Note: if we don't
        //  have ENCODE_DELTA_LOOKAHEAD samples, we pretend that the samples
        //  that we don't have are actually zeros.  This is important not
        //  only for the iDelta calculation, but also for the case where
        //  there is only 1 sample to encode ... in this case, there is not
        //  really enough data to complete the ADPCM block header, but since
        //  the two delay samples for the block header will be taken from
        //  the aiSamples[] array, iSamp1 [the second sample] will be taken
        //  as zero and there will no problem.
        //
        pbSrcThisBlock = pbSrc;
        for (n = 0; n < ENCODE_DELTA_LOOKAHEAD; n++)
        {
            if( n < cBlockSamples )
                aiSamples[n] = pcmRead08(pbSrcThisBlock++);
            else
                aiSamples[n] = 0;
        }


        //
        //  find the optimal predictor for each channel: to do this, we
        //  must step through and encode using each coefficient set (one
        //  at a time) and determine which one has the least error from
        //  the original data. the one with the least error is then used
        //  for the final encode (the 8th pass done below).
        //
        //  NOTE: keeping the encoded data of the one that has the least
        //  error at all times is an obvious optimization that should be
        //  done. in this way, we only need to do 7 passes instead of 8.
        //
        for (i = 0; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            //
            //  Reset source pointer to the beginning of the block.
            //
            pbSrcThisBlock = pbSrc;

            //
            //  Reset variables for this pass.
            //
            adwTotalError[i]    = 0L;
            iCoef1              = lpCoefSet[i].iCoef1;
            iCoef2              = lpCoefSet[i].iCoef2;

            //
            //  We need to choose the first iDelta--to do this, we need
            //  to look at the first few samples.
            //
            iDelta = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamples[0], aiSamples[1], aiSamples[2],
                                aiSamples[3], aiSamples[4]);
            aiFirstDelta[i] = iDelta;

            //
            //  Set up first two samples - these have already been converted
            //  to 16-bit values in aiSamples[], but make sure to increment
            //  pbSrcThisBlock so that it keeps in sync.
            //
            iSamp1          = aiSamples[1];
            iSamp2          = aiSamples[0];
            pbSrcThisBlock += 2*sizeof(BYTE);

            //
            //  now encode the rest of the PCM data in this block--note
            //  we start 2 samples ahead because the first two samples are
            //  simply copied into the ADPCM block header...
            //
            for (n = 2; n < cBlockSamples; n++)
            {
                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1, iCoef1,
                                                   iSamp2, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample = pcmRead08(pbSrcThisBlock++);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutput1 = (int)(lError / iDelta);
                if (iOutput1 > OUTPUT4MAX)
                    iOutput1 = OUTPUT4MAX;
                else if (iOutput1 < OUTPUT4MIN)
                    iOutput1 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput1);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput1,iDelta);
        
                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalError[i] += (lError * lError) >> 7;
            }
        }


        //
        //  WHEW! we have now made 7 passes over the data and calculated
        //  the error for each--so it's time to find the one that produced
        //  the lowest error and use that predictor.
        //
        iBestPredictor = 0;
        dw = adwTotalError[0];
        for (i = 1; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            if (adwTotalError[i] < dw)
            {
                iBestPredictor = i;
                dw = adwTotalError[i];
            }
        }
        iCoef1 = lpCoefSet[iBestPredictor].iCoef1;
        iCoef2 = lpCoefSet[iBestPredictor].iCoef2;
        
        
        //
        //  grab first iDelta from our precomputed first deltas that we
        //  calculated above
        //
        iDelta = aiFirstDelta[iBestPredictor];


        //
        //  Set up first two samples - these have already been converted
        //  to 16-bit values in aiSamples[], but make sure to increment
        //  pbSrc so that it keeps in sync.
        //
        iSamp1          = aiSamples[1];
        iSamp2          = aiSamples[0];
        pbSrc          += 2*sizeof(BYTE);

        ASSERT( cBlockSamples != 1 );
        cBlockSamples  -= 2;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)iBestPredictor;

        pcmWrite16Unaligned(pbDst,iDelta);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp1);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples>0 )
        {
            //
            //  Sample 1.
            //
            iSample = pcmRead08(pbSrc++);
            cBlockSamples--;

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1,iCoef1,iSamp2,iCoef2);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutput1 = (int)(lError / iDelta);
            if (iOutput1 > OUTPUT4MAX)
                iOutput1 = OUTPUT4MAX;
            else if (iOutput1 < OUTPUT4MIN)
                iOutput1 = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDelta * iOutput1);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDelta = adpcmCalcDelta(iOutput1,iDelta);

            //
            //  Save updated delay samples.
            //
            iSamp2 = iSamp1;
            iSamp1 = (int)lSamp;


            //
            //  Sample 2.
            //
            if( cBlockSamples>0 ) {

                iSample = pcmRead08(pbSrc++);
                cBlockSamples--;

                //
                //  calculate the prediction based on the previous two samples
                //
                lPrediction = adpcmCalcPrediction(iSamp1,iCoef1,iSamp2,iCoef2);

                //
                //  encode the sample
                //
                lError = (long)iSample - lPrediction;
                iOutput2 = (int)(lError / iDelta);
                if (iOutput2 > OUTPUT4MAX)
                    iOutput2 = OUTPUT4MAX;
                else if (iOutput2 < OUTPUT4MIN)
                    iOutput2 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput2);
            
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;

                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput2,iDelta);

                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;
            
            } else {
                iOutput2 = 0;
            }


            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutput1&OUTPUT4MASK)<<4) |
                                (iOutput2&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_M08_FullPass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_M16_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    HPBYTE              pbSrcThisBlock;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 aiSamples[ENCODE_DELTA_LOOKAHEAD];
    int                 aiFirstDelta[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalError[MSADPCM_MAX_COEFFICIENTS];

    int                 iCoef1;
    int                 iCoef2;
    int                 iSamp1;
    int                 iSamp2;
    int                 iDelta;
    int                 iOutput1;
    int                 iOutput2;
    int                 iBestPredictor;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;
    DWORD               dw;
    UINT                i,n;


    pbDstStart = pbDst;
    cSrcSamples = pcmM16BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  We need the first ENCODE_DELTA_LOOKAHEAD samples in order to
        //  calculate the first iDelta value.  Therefore we put these samples
        //  into a more accessible array: aiSamples[].  Note: if we don't
        //  have ENCODE_DELTA_LOOKAHEAD samples, we pretend that the samples
        //  that we don't have are actually zeros.  This is important not
        //  only for the iDelta calculation, but also for the case where
        //  there is only 1 sample to encode ... in this case, there is not
        //  really enough data to complete the ADPCM block header, but since
        //  the two delay samples for the block header will be taken from
        //  the aiSamples[] array, iSamp1 [the second sample] will be taken
        //  as zero and there will no problem.
        //
        pbSrcThisBlock = pbSrc;
        for (n = 0; n < ENCODE_DELTA_LOOKAHEAD; n++)
        {
            if( n < cBlockSamples )
            {
                aiSamples[n]    = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);
            }
            else
                aiSamples[n] = 0;
        }


        //
        //  find the optimal predictor for each channel: to do this, we
        //  must step through and encode using each coefficient set (one
        //  at a time) and determine which one has the least error from
        //  the original data. the one with the least error is then used
        //  for the final encode (the 8th pass done below).
        //
        //  NOTE: keeping the encoded data of the one that has the least
        //  error at all times is an obvious optimization that should be
        //  done. in this way, we only need to do 7 passes instead of 8.
        //
        for (i = 0; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            //
            //  Reset source pointer to the beginning of the block.
            //
            pbSrcThisBlock = pbSrc;

            //
            //  Reset variables for this pass.
            //
            adwTotalError[i]    = 0L;
            iCoef1              = lpCoefSet[i].iCoef1;
            iCoef2              = lpCoefSet[i].iCoef2;

            //
            //  We need to choose the first iDelta--to do this, we need
            //  to look at the first few samples.
            //
            iDelta = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamples[0], aiSamples[1], aiSamples[2],
                                aiSamples[3], aiSamples[4]);
            aiFirstDelta[i] = iDelta;

            //
            //  Set up first two samples - these have already been converted
            //  to 16-bit values in aiSamples[], but make sure to increment
            //  pbSrcThisBlock so that it keeps in sync.
            //
            iSamp1          = aiSamples[1];
            iSamp2          = aiSamples[0];
            pbSrcThisBlock += 2*sizeof(short);

            //
            //  now encode the rest of the PCM data in this block--note
            //  we start 2 samples ahead because the first two samples are
            //  simply copied into the ADPCM block header...
            //
            for (n = 2; n < cBlockSamples; n++)
            {
                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1, iCoef1,
                                                   iSamp2, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample         = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutput1 = (int)(lError / iDelta);
                if (iOutput1 > OUTPUT4MAX)
                    iOutput1 = OUTPUT4MAX;
                else if (iOutput1 < OUTPUT4MIN)
                    iOutput1 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput1);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput1,iDelta);
        
                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalError[i] += (lError * lError) >> 7;
            }
        }


        //
        //  WHEW! we have now made 7 passes over the data and calculated
        //  the error for each--so it's time to find the one that produced
        //  the lowest error and use that predictor.
        //
        iBestPredictor = 0;
        dw = adwTotalError[0];
        for (i = 1; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            if (adwTotalError[i] < dw)
            {
                iBestPredictor = i;
                dw = adwTotalError[i];
            }
        }
        iCoef1 = lpCoefSet[iBestPredictor].iCoef1;
        iCoef2 = lpCoefSet[iBestPredictor].iCoef2;
        
        
        //
        //  grab first iDelta from our precomputed first deltas that we
        //  calculated above
        //
        iDelta = aiFirstDelta[iBestPredictor];


        //
        //  Set up first two samples - these have already been converted
        //  to 16-bit values in aiSamples[], but make sure to increment
        //  pbSrc so that it keeps in sync.
        //
        iSamp1          = aiSamples[1];
        iSamp2          = aiSamples[0];
        pbSrc          += 2*sizeof(short);

        ASSERT( cBlockSamples != 1 );
        cBlockSamples  -= 2;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)iBestPredictor;

        pcmWrite16Unaligned(pbDst,iDelta);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp1);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples>0 )
        {
            //
            //  Sample 1.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);
            cBlockSamples--;

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1,iCoef1,iSamp2,iCoef2);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutput1 = (int)(lError / iDelta);
            if (iOutput1 > OUTPUT4MAX)
                iOutput1 = OUTPUT4MAX;
            else if (iOutput1 < OUTPUT4MIN)
                iOutput1 = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDelta * iOutput1);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDelta = adpcmCalcDelta(iOutput1,iDelta);

            //
            //  Save updated delay samples.
            //
            iSamp2 = iSamp1;
            iSamp1 = (int)lSamp;


            //
            //  Sample 2.
            //
            if( cBlockSamples>0 ) {

                iSample     = pcmRead16(pbSrc);
                pbSrc      += sizeof(short);
                cBlockSamples--;

                //
                //  calculate the prediction based on the previous two samples
                //
                lPrediction = adpcmCalcPrediction(iSamp1,iCoef1,iSamp2,iCoef2);

                //
                //  encode the sample
                //
                lError = (long)iSample - lPrediction;
                iOutput2 = (int)(lError / iDelta);
                if (iOutput2 > OUTPUT4MAX)
                    iOutput2 = OUTPUT4MAX;
                else if (iOutput2 < OUTPUT4MIN)
                    iOutput2 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput2);
            
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;

                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput2,iDelta);

                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;
            
            } else {
                iOutput2 = 0;
            }


            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutput1&OUTPUT4MASK)<<4) |
                                (iOutput2&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_M16_FullPass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_S08_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    HPBYTE              pbSrcThisBlock;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 aiSamplesL[ENCODE_DELTA_LOOKAHEAD];
    int                 aiSamplesR[ENCODE_DELTA_LOOKAHEAD];
    int                 aiFirstDeltaL[MSADPCM_MAX_COEFFICIENTS];
    int                 aiFirstDeltaR[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalErrorL[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalErrorR[MSADPCM_MAX_COEFFICIENTS];
    int                 iCoef1;
    int                 iCoef2;

    int                 iCoef1L;
    int                 iCoef2L;
    int                 iSamp1L;
    int                 iSamp2L;
    int                 iDeltaL;
    int                 iOutputL;
    int                 iBestPredictorL;

    int                 iCoef1R;
    int                 iCoef2R;
    int                 iSamp1R;
    int                 iSamp2R;
    int                 iDeltaR;
    int                 iOutputR;
    int                 iBestPredictorR;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;
    DWORD               dwL, dwR;
    UINT                i,n;


    pbDstStart = pbDst;
    cSrcSamples = pcmS08BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  We need the first ENCODE_DELTA_LOOKAHEAD samples in order to
        //  calculate the first iDelta value.  Therefore we put these samples
        //  into a more accessible array: aiSamples[].  Note: if we don't
        //  have ENCODE_DELTA_LOOKAHEAD samples, we pretend that the samples
        //  that we don't have are actually zeros.  This is important not
        //  only for the iDelta calculation, but also for the case where
        //  there is only 1 sample to encode ... in this case, there is not
        //  really enough data to complete the ADPCM block header, but since
        //  the two delay samples for the block header will be taken from
        //  the aiSamples[] array, iSamp1 [the second sample] will be taken
        //  as zero and there will no problem.
        //
        pbSrcThisBlock = pbSrc;
        for (n = 0; n < ENCODE_DELTA_LOOKAHEAD; n++)
        {
            if( n < cBlockSamples )
            {
                aiSamplesL[n] = pcmRead08(pbSrcThisBlock++);
                aiSamplesR[n] = pcmRead08(pbSrcThisBlock++);
            }
            else
            {
                aiSamplesL[n] = 0;
                aiSamplesR[n] = 0;
            }
        }


        //
        //  find the optimal predictor for each channel: to do this, we
        //  must step through and encode using each coefficient set (one
        //  at a time) and determine which one has the least error from
        //  the original data. the one with the least error is then used
        //  for the final encode (the 8th pass done below).
        //
        //  NOTE: keeping the encoded data of the one that has the least
        //  error at all times is an obvious optimization that should be
        //  done. in this way, we only need to do 7 passes instead of 8.
        //
        for (i = 0; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            //
            //  Reset source pointer to the beginning of the block.
            //
            pbSrcThisBlock = pbSrc;

            //
            //  Reset variables for this pass (coefs are the same for L, R).
            //
            adwTotalErrorL[i]   = 0L;
            adwTotalErrorR[i]   = 0L;
            iCoef1              = lpCoefSet[i].iCoef1;
            iCoef2              = lpCoefSet[i].iCoef2;

            //
            //  We need to choose the first iDelta--to do this, we need
            //  to look at the first few samples.
            //
            iDeltaL = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamplesL[0], aiSamplesL[1], aiSamplesL[2],
                                aiSamplesL[3], aiSamplesL[4]);
            iDeltaR = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamplesR[0], aiSamplesR[1], aiSamplesR[2],
                                aiSamplesR[3], aiSamplesR[4]);
            aiFirstDeltaL[i] = iDeltaL;
            aiFirstDeltaR[i] = iDeltaR;

            //
            //  Set up first two samples - these have already been converted
            //  to 16-bit values in aiSamples[], but make sure to increment
            //  pbSrcThisBlock so that it keeps in sync.
            //
            iSamp1L         = aiSamplesL[1];
            iSamp1R         = aiSamplesR[1];
            iSamp2L         = aiSamplesL[0];
            iSamp2R         = aiSamplesR[0];
            pbSrcThisBlock += 2*sizeof(BYTE) * 2; // Last 2 = # of channels.

            //
            //  now encode the rest of the PCM data in this block--note
            //  we start 2 samples ahead because the first two samples are
            //  simply copied into the ADPCM block header...
            //
            for (n = 2; n < cBlockSamples; n++)
            {
                //
                //  LEFT channel.
                //

                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1L, iCoef1,
                                                   iSamp2L, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample = pcmRead08(pbSrcThisBlock++);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutputL = (int)(lError / iDeltaL);
                if (iOutputL > OUTPUT4MAX)
                    iOutputL = OUTPUT4MAX;
                else if (iOutputL < OUTPUT4MIN)
                    iOutputL = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDeltaL * iOutputL);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);
        
                //
                //  Save updated delay samples.
                //
                iSamp2L = iSamp1L;
                iSamp1L = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalErrorL[i] += (lError * lError) >> 7;


                //
                //  RIGHT channel.
                //

                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1R, iCoef1,
                                                   iSamp2R, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample = pcmRead08(pbSrcThisBlock++);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutputR = (int)(lError / iDeltaR);
                if (iOutputR > OUTPUT4MAX)
                    iOutputR = OUTPUT4MAX;
                else if (iOutputR < OUTPUT4MIN)
                    iOutputR = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDeltaR * iOutputR);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);
        
                //
                //  Save updated delay samples.
                //
                iSamp2R = iSamp1R;
                iSamp1R = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalErrorR[i] += (lError * lError) >> 7;
            }
        }


        //
        //  WHEW! we have now made 7 passes over the data and calculated
        //  the error for each--so it's time to find the one that produced
        //  the lowest error and use that predictor.
        //
        iBestPredictorL = 0;
        iBestPredictorR = 0;
        dwL = adwTotalErrorL[0];
        dwR = adwTotalErrorR[0];
        for (i = 1; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            if (adwTotalErrorL[i] < dwL)
            {
                iBestPredictorL = i;
                dwL = adwTotalErrorL[i];
            }

            if (adwTotalErrorR[i] < dwR)
            {
                iBestPredictorR = i;
                dwR = adwTotalErrorR[i];
            }
        }
        iCoef1L = lpCoefSet[iBestPredictorL].iCoef1;
        iCoef1R = lpCoefSet[iBestPredictorR].iCoef1;
        iCoef2L = lpCoefSet[iBestPredictorL].iCoef2;
        iCoef2R = lpCoefSet[iBestPredictorR].iCoef2;
        
        
        //
        //  grab first iDelta from our precomputed first deltas that we
        //  calculated above
        //
        iDeltaL = aiFirstDeltaL[iBestPredictorL];
        iDeltaR = aiFirstDeltaR[iBestPredictorR];


        //
        //  Set up first two samples - these have already been converted
        //  to 16-bit values in aiSamples[], but make sure to increment
        //  pbSrc so that it keeps in sync.
        //
        iSamp1L         = aiSamplesL[1];
        iSamp1R         = aiSamplesR[1];
        iSamp2L         = aiSamplesL[0];
        iSamp2R         = aiSamplesR[0];
        pbSrc          += 2*sizeof(BYTE) * 2;  // Last 2 = # of channels.

        ASSERT( cBlockSamples != 1 );
        cBlockSamples  -= 2;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)iBestPredictorL;
        *pbDst++ = (BYTE)iBestPredictorR;

        pcmWrite16Unaligned(pbDst,iDeltaL);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iDeltaR);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp1L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp1R);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp2R);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples-- )
        {
            //
            //  LEFT channel.
            //
            iSample = pcmRead08(pbSrc++);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1L,iCoef1L,iSamp2L,iCoef2L);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputL = (int)(lError / iDeltaL);
            if (iOutputL > OUTPUT4MAX)
                iOutputL = OUTPUT4MAX;
            else if (iOutputL < OUTPUT4MIN)
                iOutputL = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaL * iOutputL);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);

            //
            //  Save updated delay samples.
            //
            iSamp2L = iSamp1L;
            iSamp1L = (int)lSamp;


            //
            //  RIGHT channel.
            //
            iSample = pcmRead08(pbSrc++);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1R,iCoef1R,iSamp2R,iCoef2R);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputR = (int)(lError / iDeltaR);
            if (iOutputR > OUTPUT4MAX)
                iOutputR = OUTPUT4MAX;
            else if (iOutputR < OUTPUT4MIN)
                iOutputR = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaR * iOutputR);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);

            //
            //  Save updated delay samples.
            //
            iSamp2R = iSamp1R;
            iSamp1R = (int)lSamp;
            

            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutputL&OUTPUT4MASK)<<4) |
                                (iOutputR&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_S08_FullPass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_S16_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    HPBYTE              pbSrcThisBlock;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 aiSamplesL[ENCODE_DELTA_LOOKAHEAD];
    int                 aiSamplesR[ENCODE_DELTA_LOOKAHEAD];
    int                 aiFirstDeltaL[MSADPCM_MAX_COEFFICIENTS];
    int                 aiFirstDeltaR[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalErrorL[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalErrorR[MSADPCM_MAX_COEFFICIENTS];
    int                 iCoef1;
    int                 iCoef2;

    int                 iCoef1L;
    int                 iCoef2L;
    int                 iSamp1L;
    int                 iSamp2L;
    int                 iDeltaL;
    int                 iOutputL;
    int                 iBestPredictorL;

    int                 iCoef1R;
    int                 iCoef2R;
    int                 iSamp1R;
    int                 iSamp2R;
    int                 iDeltaR;
    int                 iOutputR;
    int                 iBestPredictorR;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;
    DWORD               dwL, dwR;
    UINT                i,n;


    pbDstStart = pbDst;
    cSrcSamples = pcmS16BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  We need the first ENCODE_DELTA_LOOKAHEAD samples in order to
        //  calculate the first iDelta value.  Therefore we put these samples
        //  into a more accessible array: aiSamples[].  Note: if we don't
        //  have ENCODE_DELTA_LOOKAHEAD samples, we pretend that the samples
        //  that we don't have are actually zeros.  This is important not
        //  only for the iDelta calculation, but also for the case where
        //  there is only 1 sample to encode ... in this case, there is not
        //  really enough data to complete the ADPCM block header, but since
        //  the two delay samples for the block header will be taken from
        //  the aiSamples[] array, iSamp1 [the second sample] will be taken
        //  as zero and there will no problem.
        //
        pbSrcThisBlock = pbSrc;
        for (n = 0; n < ENCODE_DELTA_LOOKAHEAD; n++)
        {
            if( n < cBlockSamples )
            {
                aiSamplesL[n]   = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);
                aiSamplesR[n]   = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);
            }
            else
            {
                aiSamplesL[n] = 0;
                aiSamplesR[n] = 0;
            }
        }


        //
        //  find the optimal predictor for each channel: to do this, we
        //  must step through and encode using each coefficient set (one
        //  at a time) and determine which one has the least error from
        //  the original data. the one with the least error is then used
        //  for the final encode (the 8th pass done below).
        //
        //  NOTE: keeping the encoded data of the one that has the least
        //  error at all times is an obvious optimization that should be
        //  done. in this way, we only need to do 7 passes instead of 8.
        //
        for (i = 0; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            //
            //  Reset source pointer to the beginning of the block.
            //
            pbSrcThisBlock = pbSrc;

            //
            //  Reset variables for this pass (coefs are the same for L, R).
            //
            adwTotalErrorL[i]   = 0L;
            adwTotalErrorR[i]   = 0L;
            iCoef1              = lpCoefSet[i].iCoef1;
            iCoef2              = lpCoefSet[i].iCoef2;

            //
            //  We need to choose the first iDelta--to do this, we need
            //  to look at the first few samples.
            //
            iDeltaL = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamplesL[0], aiSamplesL[1], aiSamplesL[2],
                                aiSamplesL[3], aiSamplesL[4]);
            iDeltaR = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamplesR[0], aiSamplesR[1], aiSamplesR[2],
                                aiSamplesR[3], aiSamplesR[4]);
            aiFirstDeltaL[i] = iDeltaL;
            aiFirstDeltaR[i] = iDeltaR;

            //
            //  Set up first two samples - these have already been converted
            //  to 16-bit values in aiSamples[], but make sure to increment
            //  pbSrcThisBlock so that it keeps in sync.
            //
            iSamp1L         = aiSamplesL[1];
            iSamp1R         = aiSamplesR[1];
            iSamp2L         = aiSamplesL[0];
            iSamp2R         = aiSamplesR[0];
            pbSrcThisBlock += 2*sizeof(short) * 2; // Last 2 = # of channels.

            //
            //  now encode the rest of the PCM data in this block--note
            //  we start 2 samples ahead because the first two samples are
            //  simply copied into the ADPCM block header...
            //
            for (n = 2; n < cBlockSamples; n++)
            {
                //
                //  LEFT channel.
                //

                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1L, iCoef1,
                                                   iSamp2L, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample         = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutputL = (int)(lError / iDeltaL);
                if (iOutputL > OUTPUT4MAX)
                    iOutputL = OUTPUT4MAX;
                else if (iOutputL < OUTPUT4MIN)
                    iOutputL = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDeltaL * iOutputL);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);
        
                //
                //  Save updated delay samples.
                //
                iSamp2L = iSamp1L;
                iSamp1L = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalErrorL[i] += (lError * lError) >> 7;


                //
                //  RIGHT channel.
                //

                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1R, iCoef1,
                                                   iSamp2R, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample         = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutputR = (int)(lError / iDeltaR);
                if (iOutputR > OUTPUT4MAX)
                    iOutputR = OUTPUT4MAX;
                else if (iOutputR < OUTPUT4MIN)
                    iOutputR = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDeltaR * iOutputR);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);
        
                //
                //  Save updated delay samples.
                //
                iSamp2R = iSamp1R;
                iSamp1R = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalErrorR[i] += (lError * lError) >> 7;
            }
        }


        //
        //  WHEW! we have now made 7 passes over the data and calculated
        //  the error for each--so it's time to find the one that produced
        //  the lowest error and use that predictor.
        //
        iBestPredictorL = 0;
        iBestPredictorR = 0;
        dwL = adwTotalErrorL[0];
        dwR = adwTotalErrorR[0];
        for (i = 1; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            if (adwTotalErrorL[i] < dwL)
            {
                iBestPredictorL = i;
                dwL = adwTotalErrorL[i];
            }

            if (adwTotalErrorR[i] < dwR)
            {
                iBestPredictorR = i;
                dwR = adwTotalErrorR[i];
            }
        }
        iCoef1L = lpCoefSet[iBestPredictorL].iCoef1;
        iCoef1R = lpCoefSet[iBestPredictorR].iCoef1;
        iCoef2L = lpCoefSet[iBestPredictorL].iCoef2;
        iCoef2R = lpCoefSet[iBestPredictorR].iCoef2;
        
        
        //
        //  grab first iDelta from our precomputed first deltas that we
        //  calculated above
        //
        iDeltaL = aiFirstDeltaL[iBestPredictorL];
        iDeltaR = aiFirstDeltaR[iBestPredictorR];


        //
        //  Set up first two samples - these have already been converted
        //  to 16-bit values in aiSamples[], but make sure to increment
        //  pbSrc so that it keeps in sync.
        //
        iSamp1L         = aiSamplesL[1];
        iSamp1R         = aiSamplesR[1];
        iSamp2L         = aiSamplesL[0];
        iSamp2R         = aiSamplesR[0];
        pbSrc          += 2*sizeof(short) * 2;  // Last 2 = # of channels.

        ASSERT( cBlockSamples != 1 );
        cBlockSamples  -= 2;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)iBestPredictorL;
        *pbDst++ = (BYTE)iBestPredictorR;

        pcmWrite16Unaligned(pbDst,iDeltaL);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iDeltaR);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp1L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp1R);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp2R);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples-- )
        {
            //
            //  LEFT channel.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1L,iCoef1L,iSamp2L,iCoef2L);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputL = (int)(lError / iDeltaL);
            if (iOutputL > OUTPUT4MAX)
                iOutputL = OUTPUT4MAX;
            else if (iOutputL < OUTPUT4MIN)
                iOutputL = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaL * iOutputL);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);

            //
            //  Save updated delay samples.
            //
            iSamp2L = iSamp1L;
            iSamp1L = (int)lSamp;


            //
            //  RIGHT channel.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1R,iCoef1R,iSamp2R,iCoef2R);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputR = (int)(lError / iDeltaR);
            if (iOutputR > OUTPUT4MAX)
                iOutputR = OUTPUT4MAX;
            else if (iOutputR < OUTPUT4MIN)
                iOutputR = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaR * iOutputR);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);

            //
            //  Save updated delay samples.
            //
            iSamp2R = iSamp1R;
            iSamp1R = (int)lSamp;
            

            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutputL&OUTPUT4MASK)<<4) |
                                (iOutputR&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_S16_FullPass()




//==========================================================================;
//
//      The code below this point is only compiled into WIN32 builds.  Win16
//      builds will call 386 assembler routines instead; see the routine
//      acmdStreamOpen() in codec.c for more details.
//
//==========================================================================;

#ifdef WIN32


//==========================================================================;
//
//      REALTIME ENCODE ROUTINES
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD FNGLOBAL adpcmEncode4Bit_M08_OnePass
//  DWORD FNGLOBAL adpcmEncode4Bit_M16_OnePass
//  DWORD FNGLOBAL adpcmEncode4Bit_S08_OnePass
//  DWORD FNGLOBAL adpcmEncode4Bit_S16_OnePass
//
//  Description:
//      
//
//  Arguments:
//      
//
//  Return (DWORD FNGLOBAL):
//
//
//  History:
//       1/27/93    cjp     [curtisp] 
//       3/03/94    rmh     [bobhed]
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_M08_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 iSamp1;
    int                 iSamp2;
    int                 iDelta;
    int                 iOutput1;
    int                 iOutput2;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;


    pbDstStart = pbDst;
    cSrcSamples = pcmM08BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)1;

        iDelta = DELTA4START;
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDelta.
        pbDst += sizeof(short);

        //
        //  Note that iSamp2 comes before iSamp1.  If we only have one
        //  sample, then set iSamp1 to zero.
        // 
        iSamp2 = pcmRead08(pbSrc++);
        if( --cBlockSamples > 0 ) {
            iSamp1 = pcmRead08(pbSrc++);
            cBlockSamples--;
        } else {
            iSamp1 = 0;
        }

        pcmWrite16Unaligned(pbDst,iSamp1);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples>0 )
        {
            //
            //  Sample 1.
            //
            iSample = pcmRead08(pbSrc++);
            cBlockSamples--;

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1<<1) - iSamp2;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutput1 = (int)(lError / iDelta);
            if (iOutput1 > OUTPUT4MAX)
                iOutput1 = OUTPUT4MAX;
            else if (iOutput1 < OUTPUT4MIN)
                iOutput1 = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDelta * iOutput1);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDelta = adpcmCalcDelta(iOutput1,iDelta);

            //
            //  Save updated delay samples.
            //
            iSamp2 = iSamp1;
            iSamp1 = (int)lSamp;


            //
            //  Sample 2.
            //
            if( cBlockSamples>0 ) {

                iSample = pcmRead08(pbSrc++);
                cBlockSamples--;

                //
                //  calculate the prediction based on the previous two samples
                //
                lPrediction = ((long)iSamp1<<1) - iSamp2;

                //
                //  encode the sample
                //
                lError = (long)iSample - lPrediction;
                iOutput2 = (int)(lError / iDelta);
                if (iOutput2 > OUTPUT4MAX)
                    iOutput2 = OUTPUT4MAX;
                else if (iOutput2 < OUTPUT4MIN)
                    iOutput2 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput2);
            
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;

                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput2,iDelta);

                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;
            
            } else {
                iOutput2 = 0;
            }


            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutput1&OUTPUT4MASK)<<4) |
                                (iOutput2&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_M08_OnePass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_M16_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 iSamp1;
    int                 iSamp2;
    int                 iDelta;
    int                 iOutput1;
    int                 iOutput2;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;


    pbDstStart = pbDst;
    cSrcSamples = pcmM16BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)1;

        iDelta = DELTA4START;
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDelta;
        pbDst += sizeof(short);

        //
        //  Note that iSamp2 comes before iSamp1.  If we only have one
        //  sample, then set iSamp1 to zero.
        // 
        iSamp2 = pcmRead16(pbSrc);
        pbSrc += sizeof(short);
        if( --cBlockSamples > 0 ) {
            iSamp1 = pcmRead16(pbSrc);
            pbSrc += sizeof(short);
            cBlockSamples--;
        } else {
            iSamp1 = 0;
        }

        pcmWrite16Unaligned(pbDst,iSamp1);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples>0 )
        {
            //
            //  Sample 1.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);
            cBlockSamples--;

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1<<1) - iSamp2;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutput1 = (int)(lError / iDelta);
            if (iOutput1 > OUTPUT4MAX)
                iOutput1 = OUTPUT4MAX;
            else if (iOutput1 < OUTPUT4MIN)
                iOutput1 = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDelta * iOutput1);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDelta = adpcmCalcDelta(iOutput1,iDelta);

            //
            //  Save updated delay samples.
            //
            iSamp2 = iSamp1;
            iSamp1 = (int)lSamp;


            //
            //  Sample 2.
            //
            if( cBlockSamples>0 ) {

                iSample     = pcmRead16(pbSrc);
                pbSrc      += sizeof(short);
                cBlockSamples--;

                //
                //  calculate the prediction based on the previous two samples
                //
                lPrediction = ((long)iSamp1<<1) - iSamp2;

                //
                //  encode the sample
                //
                lError = (long)iSample - lPrediction;
                iOutput2 = (int)(lError / iDelta);
                if (iOutput2 > OUTPUT4MAX)
                    iOutput2 = OUTPUT4MAX;
                else if (iOutput2 < OUTPUT4MIN)
                    iOutput2 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput2);
            
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;

                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput2,iDelta);

                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;
            
            } else {
                iOutput2 = 0;
            }


            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutput1&OUTPUT4MASK)<<4) |
                                (iOutput2&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_M16_OnePass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_S08_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 iSamp1L;
    int                 iSamp2L;
    int                 iDeltaL;
    int                 iOutputL;

    int                 iSamp1R;
    int                 iSamp2R;
    int                 iDeltaR;
    int                 iOutputR;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;


    pbDstStart = pbDst;
    cSrcSamples = pcmS08BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)1;
        *pbDst++ = (BYTE)1;

        iDeltaL = DELTA4START;
        iDeltaR = DELTA4START;
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDeltaL.
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDeltaR.
        pbDst += sizeof(short);

        //
        //  Note that iSamp2 comes before iSamp1.  If we only have one
        //  sample, then set iSamp1 to zero.
        // 
        iSamp2L = pcmRead08(pbSrc++);
        iSamp2R = pcmRead08(pbSrc++);
        if( --cBlockSamples > 0 ) {
            iSamp1L = pcmRead08(pbSrc++);
            iSamp1R = pcmRead08(pbSrc++);
            cBlockSamples--;
        } else {
            iSamp1L = 0;
            iSamp1R = 0;
        }

        pcmWrite16Unaligned(pbDst,iSamp1L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp1R);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp2R);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples-- )
        {
            //
            //  LEFT channel.
            //
            iSample = pcmRead08(pbSrc++);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1L<<1) - iSamp2L;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputL = (int)(lError / iDeltaL);
            if (iOutputL > OUTPUT4MAX)
                iOutputL = OUTPUT4MAX;
            else if (iOutputL < OUTPUT4MIN)
                iOutputL = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaL * iOutputL);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);

            //
            //  Save updated delay samples.
            //
            iSamp2L = iSamp1L;
            iSamp1L = (int)lSamp;


            //
            //  RIGHT channel.
            //
            iSample = pcmRead08(pbSrc++);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1R<<1) - iSamp2R;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputR = (int)(lError / iDeltaR);
            if (iOutputR > OUTPUT4MAX)
                iOutputR = OUTPUT4MAX;
            else if (iOutputR < OUTPUT4MIN)
                iOutputR = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaR * iOutputR);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);

            //
            //  Save updated delay samples.
            //
            iSamp2R = iSamp1R;
            iSamp1R = (int)lSamp;
            

            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutputL&OUTPUT4MASK)<<4) |
                                (iOutputR&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_S08_OnePass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_S16_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 iSamp1L;
    int                 iSamp2L;
    int                 iDeltaL;
    int                 iOutputL;

    int                 iSamp1R;
    int                 iSamp2R;
    int                 iDeltaR;
    int                 iOutputR;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;


    pbDstStart = pbDst;
    cSrcSamples = pcmS16BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)1;
        *pbDst++ = (BYTE)1;

        iDeltaL = DELTA4START;
        iDeltaR = DELTA4START;
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDeltaL.
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDeltaR.
        pbDst += sizeof(short);

        //
        //  Note that iSamp2 comes before iSamp1.  If we only have one
        //  sample, then set iSamp1 to zero.
        // 
        iSamp2L = pcmRead16(pbSrc);
        pbSrc += sizeof(short);
        iSamp2R = pcmRead16(pbSrc);
        pbSrc += sizeof(short);
        if( --cBlockSamples > 0 ) {
            iSamp1L = pcmRead16(pbSrc);
            pbSrc += sizeof(short);
            iSamp1R = pcmRead16(pbSrc);
            pbSrc += sizeof(short);
            cBlockSamples--;
        } else {
            iSamp1L = 0;
            iSamp1R = 0;
        }

        pcmWrite16Unaligned(pbDst,iSamp1L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp1R);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp2R);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples-- )
        {
            //
            //  LEFT channel.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1L<<1) - iSamp2L;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputL = (int)(lError / iDeltaL);
            if (iOutputL > OUTPUT4MAX)
                iOutputL = OUTPUT4MAX;
            else if (iOutputL < OUTPUT4MIN)
                iOutputL = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaL * iOutputL);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);

            //
            //  Save updated delay samples.
            //
            iSamp2L = iSamp1L;
            iSamp1L = (int)lSamp;


            //
            //  RIGHT channel.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1R<<1) - iSamp2R;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputR = (int)(lError / iDeltaR);
            if (iOutputR > OUTPUT4MAX)
                iOutputR = OUTPUT4MAX;
            else if (iOutputR < OUTPUT4MIN)
                iOutputR = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaR * iOutputR);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);

            //
            //  Save updated delay samples.
            //
            iSamp2R = iSamp1R;
            iSamp1R = (int)lSamp;
            

            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutputL&OUTPUT4MASK)<<4) |
                                (iOutputR&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_S16_OnePass()




//==========================================================================;
//
//      DECODE ROUTINES
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD adpcmDecode4Bit_M08
//  DWORD adpcmDecode4Bit_M16
//  DWORD adpcmDecode4Bit_S08
//  DWORD adpcmDecode4Bit_S16
//
//  Description:
//      These functions decode a buffer of data from MS ADPCM to PCM in the
//      specified format.  The appropriate function is called once for each
//      ACMDM_STREAM_CONVERT message received.
//      
//
//  Arguments:
//      
//
//  Return (DWORD):  The number of bytes used in the destination buffer.
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmDecode4Bit_M08
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE  pbDstStart;
    UINT    cbHeader;
    UINT    cbBlockLength;

    UINT    nPredictor;
    BYTE    bSample;
    int     iInput;
    int     iSamp;

    int     iSamp1;
    int     iSamp2;
    int     iCoef1;
    int     iCoef2;
    int     iDelta;


    pbDstStart  = pbDst;
    cbHeader    = MSADPCM_HEADER_LENGTH * 1;  // 1 = number of channels.


    //
    //
    //
    while( cbSrcLength >= cbHeader )
    {
        //
        //  We have at least enough data to read a full block header.
        //
        //  the header looks like this:
        //      1 byte predictor per channel  (determines coefficients).
        //      2 byte delta per channel
        //      2 byte first sample per channel
        //      2 byte second sample per channel
        //
        //  this gives us (7 * bChannels) bytes of header information. note
        //  that as long as there is _at least_ (7 * bChannels) of header
        //  info, we will grab the two samples from the header.  We figure
        //  out how much data we have in the rest of the block, ie. whether
        //  we have a full block or not.  That way we don't have to test
        //  each sample to see if we have run out of data.
        //
        cbBlockLength   = (UINT)min(cbSrcLength,nBlockAlignment);
        cbSrcLength    -= cbBlockLength;
        cbBlockLength  -= cbHeader;
        
    
        //
        //  Process the block header.
        //
        nPredictor = (UINT)(BYTE)(*pbSrc++);
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1  = lpCoefSet[nPredictor].iCoef1;
        iCoef2  = lpCoefSet[nPredictor].iCoef2;
        
        iDelta  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);

        iSamp1  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);
        
        iSamp2  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);
        

        //
        //  write out first 2 samples.
        //
        //  NOTE: the samples are written to the destination PCM buffer
        //  in the _reverse_ order that they are in the header block:
        //  remember that iSamp2 is the _previous_ sample to iSamp1.
        //
        pcmWrite08(pbDst,iSamp2);
        pcmWrite08(pbDst,iSamp1);


        //
        //  we now need to decode the 'data' section of the ADPCM block.
        //  this consists of packed 4 bit nibbles.  The high-order nibble
        //  contains the first sample; the low-order nibble contains the
        //  second sample.
        //
        while( cbBlockLength-- )
        {
            bSample = *pbSrc++;

            //
            //  Sample 1.
            //
            iInput  = (int)(((signed char)bSample) >> 4);      //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1,iCoef1,
                                         iSamp2,iCoef2,
                                         iInput,iDelta );
            iDelta      = adpcmCalcDelta( iInput,iDelta );
            pcmWrite08(pbDst++,iSamp);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2 = iSamp1;
            iSamp1 = iSamp;
            

            //
            //  Sample 2.
            //
            iInput  = (int)(((signed char)(bSample<<4)) >> 4); //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1,iCoef1,
                                         iSamp2,iCoef2,
                                         iInput,iDelta );
            iDelta      = adpcmCalcDelta( iInput,iDelta );
            pcmWrite08(pbDst++,iSamp);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2 = iSamp1;
            iSamp1 = iSamp;
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmDecode4Bit_M08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmDecode4Bit_M16
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE  pbDstStart;
    UINT    cbHeader;
    UINT    cbBlockLength;

    UINT    nPredictor;
    BYTE    bSample;
    int     iInput;
    int     iSamp;

    int     iSamp1;
    int     iSamp2;
    int     iCoef1;
    int     iCoef2;
    int     iDelta;


    pbDstStart  = pbDst;
    cbHeader    = MSADPCM_HEADER_LENGTH * 1;  // 1 = number of channels.


    //
    //
    //
    while( cbSrcLength >= cbHeader )
    {
        //
        //  We have at least enough data to read a full block header.
        //
        //  the header looks like this:
        //      1 byte predictor per channel  (determines coefficients).
        //      2 byte delta per channel
        //      2 byte first sample per channel
        //      2 byte second sample per channel
        //
        //  this gives us (7 * bChannels) bytes of header information. note
        //  that as long as there is _at least_ (7 * bChannels) of header
        //  info, we will grab the two samples from the header.  We figure
        //  out how much data we have in the rest of the block, ie. whether
        //  we have a full block or not.  That way we don't have to test
        //  each sample to see if we have run out of data.
        //
        cbBlockLength   = (UINT)min(cbSrcLength,nBlockAlignment);
        cbSrcLength    -= cbBlockLength;
        cbBlockLength  -= cbHeader;
        
    
        //
        //  Process the block header.
        //
        nPredictor = (UINT)(BYTE)(*pbSrc++);
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1  = lpCoefSet[nPredictor].iCoef1;
        iCoef2  = lpCoefSet[nPredictor].iCoef2;
        
        iDelta  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);

        iSamp1  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);
        
        iSamp2  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);
        

        //
        //  write out first 2 samples.
        //
        //  NOTE: the samples are written to the destination PCM buffer
        //  in the _reverse_ order that they are in the header block:
        //  remember that iSamp2 is the _previous_ sample to iSamp1.
        //
        pcmWrite16(pbDst,iSamp2);
        pbDst += sizeof(short);

        pcmWrite16(pbDst,iSamp1);
        pbDst += sizeof(short);


        //
        //  we now need to decode the 'data' section of the ADPCM block.
        //  this consists of packed 4 bit nibbles.  The high-order nibble
        //  contains the first sample; the low-order nibble contains the
        //  second sample.
        //
        while( cbBlockLength-- )
        {
            bSample = *pbSrc++;

            //
            //  Sample 1.
            //
            iInput  = (int)(((signed char)bSample) >> 4);      //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1,iCoef1,
                                         iSamp2,iCoef2,
                                         iInput,iDelta );
            iDelta      = adpcmCalcDelta( iInput,iDelta );
            pcmWrite16(pbDst,iSamp);
            pbDst += sizeof(short);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2 = iSamp1;
            iSamp1 = iSamp;
            

            //
            //  Sample 2.
            //
            iInput  = (int)(((signed char)(bSample<<4)) >> 4); //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1,iCoef1,
                                         iSamp2,iCoef2,
                                         iInput,iDelta );
            iDelta      = adpcmCalcDelta( iInput,iDelta );
            pcmWrite16(pbDst,iSamp);
            pbDst += sizeof(short);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2 = iSamp1;
            iSamp1 = iSamp;
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmDecode4Bit_M16()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmDecode4Bit_S08
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE  pbDstStart;
    UINT    cbHeader;
    UINT    cbBlockLength;

    UINT    nPredictor;
    BYTE    bSample;
    int     iInput;
    int     iSamp;

    int     iSamp1L;
    int     iSamp2L;
    int     iCoef1L;
    int     iCoef2L;
    int     iDeltaL;

    int     iSamp1R;
    int     iSamp2R;
    int     iCoef1R;
    int     iCoef2R;
    int     iDeltaR;


    pbDstStart  = pbDst;
    cbHeader    = MSADPCM_HEADER_LENGTH * 2;  // 2 = number of channels.


    //
    //
    //
    while( cbSrcLength >= cbHeader )
    {
        //
        //  We have at least enough data to read a full block header.
        //
        //  the header looks like this:
        //      1 byte predictor per channel  (determines coefficients).
        //      2 byte delta per channel
        //      2 byte first sample per channel
        //      2 byte second sample per channel
        //
        //  this gives us (7 * bChannels) bytes of header information. note
        //  that as long as there is _at least_ (7 * bChannels) of header
        //  info, we will grab the two samples from the header.  We figure
        //  out how much data we have in the rest of the block, ie. whether
        //  we have a full block or not.  That way we don't have to test
        //  each sample to see if we have run out of data.
        //
        cbBlockLength   = (UINT)min(cbSrcLength,nBlockAlignment);
        cbSrcLength    -= cbBlockLength;
        cbBlockLength  -= cbHeader;
        
    
        //
        //  Process the block header.
        //
        nPredictor = (UINT)(BYTE)(*pbSrc++);            // Left.
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1L = lpCoefSet[nPredictor].iCoef1;
        iCoef2L = lpCoefSet[nPredictor].iCoef2;
        
        nPredictor = (UINT)(BYTE)(*pbSrc++);            // Right.
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1R = lpCoefSet[nPredictor].iCoef1;
        iCoef2R = lpCoefSet[nPredictor].iCoef2;
        
        iDeltaL = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);

        iDeltaR = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);

        iSamp1L = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);
        
        iSamp1R = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);
        
        iSamp2L = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);
        
        iSamp2R = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);
        

        //
        //  write out first 2 samples (per channel).
        //
        //  NOTE: the samples are written to the destination PCM buffer
        //  in the _reverse_ order that they are in the header block:
        //  remember that iSamp2 is the _previous_ sample to iSamp1.
        //
        pcmWrite08(pbDst++,iSamp2L);
        pcmWrite08(pbDst++,iSamp2R);
        pcmWrite08(pbDst++,iSamp1L);
        pcmWrite08(pbDst++,iSamp1R);


        //
        //  we now need to decode the 'data' section of the ADPCM block.
        //  this consists of packed 4 bit nibbles.  The high-order nibble
        //  contains the left sample; the low-order nibble contains the
        //  right sample.
        //
        while( cbBlockLength-- )
        {
            bSample = *pbSrc++;

            //
            //  Left sample.
            //
            iInput  = (int)(((signed char)bSample) >> 4);      //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1L,iCoef1L,
                                         iSamp2L,iCoef2L,
                                         iInput,iDeltaL );
            iDeltaL     = adpcmCalcDelta( iInput,iDeltaL );
            pcmWrite08(pbDst++,iSamp);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2L = iSamp1L;
            iSamp1L = iSamp;
            

            //
            //  Right sample.
            //
            iInput  = (int)(((signed char)(bSample<<4)) >> 4); //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1R,iCoef1R,
                                         iSamp2R,iCoef2R,
                                         iInput,iDeltaR );
            iDeltaR     = adpcmCalcDelta( iInput,iDeltaR );
            pcmWrite08(pbDst++,iSamp);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2R = iSamp1R;
            iSamp1R = iSamp;
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmDecode4Bit_S08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmDecode4Bit_S16
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE  pbDstStart;
    UINT    cbHeader;
    UINT    cbBlockLength;

    UINT    nPredictor;
    BYTE    bSample;
    int     iInput;
    int     iSamp;

    int     iSamp1L;
    int     iSamp2L;
    int     iCoef1L;
    int     iCoef2L;
    int     iDeltaL;

    int     iSamp1R;
    int     iSamp2R;
    int     iCoef1R;
    int     iCoef2R;
    int     iDeltaR;


    pbDstStart  = pbDst;
    cbHeader    = MSADPCM_HEADER_LENGTH * 2;  // 2 = number of channels.


    //
    //
    //
    while( cbSrcLength >= cbHeader )
    {
        //
        //  We have at least enough data to read a full block header.
        //
        //  the header looks like this:
        //      1 byte predictor per channel  (determines coefficients).
        //      2 byte delta per channel
        //      2 byte first sample per channel
        //      2 byte second sample per channel
        //
        //  this gives us (7 * bChannels) bytes of header information. note
        //  that as long as there is _at least_ (7 * bChannels) of header
        //  info, we will grab the two samples from the header.  We figure
        //  out how much data we have in the rest of the block, ie. whether
        //  we have a full block or not.  That way we don't have to test
        //  each sample to see if we have run out of data.
        //
        cbBlockLength   = (UINT)min(cbSrcLength,nBlockAlignment);
        cbSrcLength    -= cbBlockLength;
        cbBlockLength  -= cbHeader;
        
    
        //
        //  Process the block header.
        //
        nPredictor = (UINT)(BYTE)(*pbSrc++);            // Left.
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1L = lpCoefSet[nPredictor].iCoef1;
        iCoef2L = lpCoefSet[nPredictor].iCoef2;
        
        nPredictor = (UINT)(BYTE)(*pbSrc++);            // Right.
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1R = lpCoefSet[nPredictor].iCoef1;
        iCoef2R = lpCoefSet[nPredictor].iCoef2;
        
        iDeltaL = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);

        iDeltaR = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);

        iSamp1L = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);
        
        iSamp1R = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);
        
        iSamp2L = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);
        
        iSamp2R = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);
        

        //
        //  write out first 2 samples (per channel).
        //
        //  NOTE: the samples are written to the destination PCM buffer
        //  in the _reverse_ order that they are in the header block:
        //  remember that iSamp2 is the _previous_ sample to iSamp1.
        //
        pcmWrite16(pbDst,iSamp2L);
        pbDst += sizeof(short);
        pcmWrite16(pbDst,iSamp2R);
        pbDst += sizeof(short);
        pcmWrite16(pbDst,iSamp1L);
        pbDst += sizeof(short);
        pcmWrite16(pbDst,iSamp1R);
        pbDst += sizeof(short);


        //
        //  we now need to decode the 'data' section of the ADPCM block.
        //  this consists of packed 4 bit nibbles.  The high-order nibble
        //  contains the left sample; the low-order nibble contains the
        //  right sample.
        //
        while( cbBlockLength-- )
        {
            bSample = *pbSrc++;

            //
            //  Left sample.
            //
            iInput  = (int)(((signed char)bSample) >> 4);      //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1L,iCoef1L,
                                         iSamp2L,iCoef2L,
                                         iInput,iDeltaL );
            iDeltaL     = adpcmCalcDelta( iInput,iDeltaL );
            pcmWrite16(pbDst,iSamp);
            pbDst += sizeof(short);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2L = iSamp1L;
            iSamp1L = iSamp;
            

            //
            //  Right sample.
            //
            iInput  = (int)(((signed char)(bSample<<4)) >> 4); //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1R,iCoef1R,
                                         iSamp2R,iCoef2R,
                                         iInput,iDeltaR );
            iDeltaR     = adpcmCalcDelta( iInput,iDeltaR );
            pcmWrite16(pbDst,iSamp);
            pbDst += sizeof(short);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2R = iSamp1R;
            iSamp1R = iSamp;
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmDecode4Bit_S16()
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msfilter\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "MSFILTER"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msfilter\codec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.h
//
//  Description:
//      This file contains codec definitions, Win16/Win32 compatibility
//      definitions, and instance structure definitions.
//
//
//==========================================================================;

#ifndef _INC_CODEC
#define _INC_CODEC                  // #defined if codec.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_ACM_DRIVER is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(4,  0, 0)
#else
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(3, 51, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(2, 1, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge


    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE                   CONST

    #define HUGE                    UNALIGNED
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))
#endif


//
//  This define deals with unaligned data for Win32, and huge data for Win16.
//  Basically, any time you cast an HPBYTE to a non-byte variable (ie long or
//  short), you should cast it to (UNALIGNED *) for WIN32.  This will make
//  sure that there are no alignment problems for Win32 on MIPA and Alpha
//  machines.
//

typedef BYTE HUGE *HPBYTE;

#ifdef WIN32
    typedef short UNALIGNED *HPSHORT;
#else
    typedef short HUGE *HPSHORT;
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwf argument is a pointer to a PCMWAVEFORMAT structure.
//
#define PCM_BLOCKALIGNMENT(pwfx)        (UINT)(((pwfx)->wBitsPerSample >> 3) << ((pwfx)->nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwfx)        (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwfx, cb)    (DWORD)(cb / PCM_BLOCKALIGNMENT(pwfx))
#define PCM_SAMPLESTOBYTES(pwfx, dw)    (DWORD)(dw * PCM_BLOCKALIGNMENT(pwfx))



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tDRIVERINSTANCE
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the driver will be easier to combine
    //  with other types of drivers (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of driver: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your driver requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           fdwOpen;        // flags from open description

    LPDRVCONFIGINFO pdci;
    DWORD           fdwConfig;      // driver instance configuration flags

} DRIVERINSTANCE, *PDRIVERINSTANCE, FAR *LPDRIVERINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;


//
//
//
//
typedef LRESULT (FNGLOBAL *STREAMCONVERTPROC)
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);


//
//
//
//
typedef struct tSTREAMINSTANCE
{
    STREAMCONVERTPROC   fnConvert;  // stream instance conversion proc
    DWORD               fdwConfig;  // stream instance configuration flags


    //
    //  only used on echo filter..
    //
    HPBYTE              hpbHistory;
    DWORD               dwPlace;
    DWORD	        	dwHistoryDone;
} STREAMINSTANCE, *PSTREAMINSTANCE, FAR *LPSTREAMINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  resource id's
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ICON_ACM_DRIVER             RCID(10)

#define IDS_ACM_DRIVER_SHORTNAME    (1)     // ACMDRIVERDETAILS.szShortName
#define IDS_ACM_DRIVER_LONGNAME     (2)     // ACMDRIVERDETAILS.szLongName
#define IDS_ACM_DRIVER_COPYRIGHT    (3)     // ACMDRIVERDETAILS.szCopyright
#define IDS_ACM_DRIVER_LICENSING    (4)     // ACMDRIVERDETAILS.szLicensing
#define IDS_ACM_DRIVER_FEATURES     (5)     // ACMDRIVERDETAILS.szFeatures

//
//  ACMFILTERTAGDETAILS.szFilterTag
//
//
#define IDS_ACM_DRIVER_TAG_NAME_VOLUME  (20)
#define IDS_ACM_DRIVER_FORMAT_VOLUME    (21)

//
//  ACMFILTERTAGDETAILS.szFilterTag
//
//
#define IDS_ACM_DRIVER_TAG_NAME_ECHO    (40)
#define IDS_ACM_DRIVER_FORMAT_ECHO      (41)

//
//  About dialog box IDs
//
#define IDD_ABOUT                   RCID(100)
#define IDC_STATIC                  -1
#define IDC_ABOUT_CATCHTHEWAVE      1001



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_CODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msfilter\msfilter.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  msfilter.h
//
//  Description:
//      This file contains prototypes for the filtering routines.
//
//
//==========================================================================;

#ifndef _MSFILTER_H_
#define _MSFILTER_H_

#ifdef __cplusplus
extern "C"
{
#endif


#define MSFILTER_MAX_CHANNELS   2   // max number of channels allowed
 
//
//  function prototypes from MSFILTER.C
//
// 
LRESULT FNGLOBAL msfilterVolume
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    pdsh
);

LRESULT FNGLOBAL msfilterEcho
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    pdsh
);


#ifdef __cplusplus
}
#endif

#endif // _MSFILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msfilter\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code to support easy-to-use debugging support
//      which works for both Win16 and Win32.  All code compiles to
//      nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\media\msacm\msfilter\codec.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.c
//
//  Description:
//      This file contains the DriverProc and other routines which respond
//      to ACM messages.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <memory.h>

#include "codec.h"
#include "msfilter.h"

#include "debug.h"


//
//  array of WAVE format tags supported.
//
//  NOTE! if you change anything in this structure (order, addition, removal)
//  you must also fix acmdFormatTagDetails!
//
const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM
};

#define ACM_DRIVER_MAX_FORMAT_TAGS  SIZEOF_ARRAY(gauFormatTagIndexToTag)


//
//  array of _standard_ sample rates supported
//
//
const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

#define ACM_DRIVER_MAX_SAMPLE_RATES SIZEOF_ARRAY(gauFormatIndexToSampleRate)

//
//
//
//
#define ACM_DRIVER_MAX_CHANNELS     (MSFILTER_MAX_CHANNELS)


//
//  array of bits per sample supported
//
//
const UINT gauFormatIndexToBitsPerSample[] =
{
    8,
    16
};

#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM    SIZEOF_ARRAY(gauFormatIndexToBitsPerSample)


//
//  number of formats we enumerate per channel is number of sample rates
//  times number of channels times number of types (bits per sample).
//
#define ACM_DRIVER_MAX_STANDARD_FORMATS_PCM (ACM_DRIVER_MAX_SAMPLE_RATES *  \
                                             ACM_DRIVER_MAX_CHANNELS *      \
                                             ACM_DRIVER_MAX_BITSPERSAMPLE_PCM)


//
//  Array of WAVE filter tags supported.
//
const DWORD gadwFilterTagIndexToTag[] =
{
    WAVE_FILTER_VOLUME,
    WAVE_FILTER_ECHO
};

#define ACM_DRIVER_MAX_FILTER_TAGS          SIZEOF_ARRAY(gadwFilterTagIndexToTag)


//
//  Array of filters supported.
//
const DWORD gdwFilterIndexToVolume[] =
{
    0x00001000,
    0x00002000,
    0x00004000,
    0x00006000,
    0x00008000,
    0x0000A000,
    0x0000C000,
    0x0000E000,
    0x0000F000,
    0x00011000,
    0x00012000,
    0x00014000,
    0x00016000,
    0x00018000,
    0x0001A000,
    0x0001C000,
    0x00020000
};
#define ACM_DRIVER_MAX_VOLUME_FILTERS   SIZEOF_ARRAY(gdwFilterIndexToVolume)

const DWORD gdwFilterIndexToDelay[] =
{
    0x00000040,
    0x00000080,
    0x00000100,
    0x00000180,
    0x00000200,
    0x00000300,
    0x00000400,
    0x00000800,
};
#define ACM_DRIVER_NUM_DELAY            SIZEOF_ARRAY(gdwFilterIndexToDelay)

const DWORD gdwFilterIndexToEchoVol[] =
{
    0x00001000,
    0x00002000,
    0x00004000,
    0x00008000,
    0x0000C000
};
#define ACM_DRIVER_NUM_ECHOVOL          SIZEOF_ARRAY(gdwFilterIndexToEchoVol)

#define ACM_DRIVER_MAX_ECHO_FILTERS     (ACM_DRIVER_NUM_DELAY *     \
                                         ACM_DRIVER_NUM_ECHOVOL)



//==========================================================================;
//
//  SUPPORT ROUTINES FOR COMMON-BINARY CODECS.
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // WIN32


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX  pwfx
)
{
    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if ((8 != pwfx->wBitsPerSample) && (16 != pwfx->wBitsPerSample))
        return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    if (PCM_BLOCKALIGNMENT(pwfx) != pwfx->nBlockAlign)
        return (FALSE);

    //
    //  verify samples per second is within our capabilities
    //
    if ((0L == pwfx->nSamplesPerSec) || (0x3FFFFFFF < pwfx->nSamplesPerSec))
    {
        return (FALSE);
    }

    //
    //  finally, verify that avg bytes per second is correct
    //
    if (PCM_AVGBYTESPERSEC(pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL volumeIsValidFilter
//
//  Description:
//      This function verifies that a wave filter header is a valid volume
//      header that our volume converter can deal with.
//
//  Arguments:
//      LPWAVEFILTER pwf: Pointer to filter header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//  History:
//      06/05/93    Created.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL volumeIsValidFilter
(
    LPWAVEFILTER  pwf
)
{
    if (!pwf)
        return (FALSE);

    if (pwf->cbStruct < sizeof(VOLUMEWAVEFILTER))
        return (FALSE);

    if (pwf->dwFilterTag != WAVE_FILTER_VOLUME)
        return (FALSE);

    if (0L != pwf->fdwFilter)
        return (FALSE);

    return (TRUE);
} // volumeIsValidFilter()



//--------------------------------------------------------------------------;
//
//  BOOL echoIsValidFilter
//
//  Description:
//      This function verifies that a wave filter header is a valid echo
//      header that our echo converter can deal with.
//
//  Arguments:
//      LPWAVEFILTER pwf: Pointer to filter header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//  History:
//      06/05/93    Created.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL echoIsValidFilter
(
    LPWAVEFILTER  pwf
)
{
    LPECHOWAVEFILTER    pwfEcho;

    if (!pwf)
        return (FALSE);

    if (pwf->cbStruct < sizeof(ECHOWAVEFILTER))
        return (FALSE);

    if (pwf->dwFilterTag != WAVE_FILTER_ECHO)
        return (FALSE);

    if (0L != pwf->fdwFilter)
        return (FALSE);

    pwfEcho = (LPECHOWAVEFILTER)pwf;
    // We only support a delay value up to 10 sec or 10 000 msec.
    if (pwfEcho->dwDelay > 10000L)
        return (FALSE);

    return (TRUE);
} // echoIsValidFilter()


//==========================================================================;
//
//
//
//
//==========================================================================;


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PDRIVERINSTANCE     pdi;

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (NULL != paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        {
            return (0L);
        }
    }


    //
    //  we are being opened as an installable driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure. note that we
    //  rely on allocating the memory as zero-initialized!
    //
    pdi = (PDRIVERINSTANCE)LocalAlloc(LPTR, sizeof(*pdi));
    if (NULL == pdi)
    {
        //
        //  if this open attempt was as an ACM driver, then return the
        //  reason we are failing in the open description structure..
        //
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        //
        //  fail to open
        //
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pdi->hdrvr          = hdrvr;
    pdi->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.

    if (NULL != paod)
    {
        pdi->fnDriverProc = NULL;
        pdi->fccType      = paod->fccType;
        pdi->vdwACM       = paod->dwVersion;
        pdi->fdwOpen      = paod->dwFlags;

        paod->dwError     = MMSYSERR_NOERROR;
    }


    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)pdi);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PDRIVERINSTANCE         pdi
)
{
    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (NULL != pdi)
    {
        //
        //  close down the driver instance. this driver simply needs
        //  to free the instance data structure... note that if this
        //  'free' fails, then this ACM driver probably trashed its
        //  heap; assume we didn't do that.
        //
        LocalFree((HLOCAL)pdi);
    }


    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      the user pressed OK.  This value should be returned even if the
//      user didn't change anything - otherwise, the driver may not
//      install properly.
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
    //
    //  first check to see if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does not support a configuration dialog box, so
        //  return zero...
        //
        return (0L);
    }


    //
    //  we are being asked to bring up our configuration dialog. if this
    //  driver supports a configuration dialog box, then after the dialog
    //  is dismissed we must return one of the following values:
    //
    //  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
    //  and canceled by the user. this value should also be returned if
    //  no configuration information was modified.
    //
    //  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
    //  the user pressed OK.  This value should be returned even if the
    //  user didn't change anything - otherwise, the driver may not
    //  install properly.
    //
    //  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
    //  and some configuration information was changed that requires
    //  Windows to be restarted before the changes take affect. the driver
    //  should remain configured with current values until the driver
    //  has been 'rebooted'.
    //
    //
    return (DRVCNF_CANCEL);
} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMDRIVERDETAILS      padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;


    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    add.wMid            = MM_MICROSOFT;
    add.wPid            = MM_MSFT_ACM_MSFILTER;


    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_FILTER;


    //
    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.
    //
    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

    //
    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.
    //
    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;


    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        add.hicon = LoadIcon(pdi->hinst, ICON_ACM_DRIVER);

        //
        //  the short name and long name are used to represent the driver
        //  in a unique description. the short name is intended for small
        //  display areas (for example, in a menu or combo box). the long
        //  name is intended for more descriptive displays (for example,
        //  in an 'about box').
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
    	LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

        //
        //  the last three members are intended for 'about box' information.
        //  these members are optional and may be zero length strings if
        //  the driver wishes.
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }


    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(padd, &add, (UINT)add.cbStruct);


    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  INT_PTR acmdDlgProcAbout
//
//  Description:
//
//      This dialog procedure is used for the ubiquitous about box.
//
//      Note that we need to create a brush and store the handle between
//      messages.  In order to avoid using global memory, we store the
//      handle to this brush in the Window structure using the DWLP_USER
//      index.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (INT_PTR):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.  Note, however, that we must return an HBRUSH for Windows
//      to use for painting the background for the WM_CTLCOLORxxx messages.
//
//
//--------------------------------------------------------------------------;

#define ABOUT_BACKGROUNDCOLOR                   RGB(128,128,128)
#define ABOUT_HILIGHTCOLOR                      RGB(0,255,255)

INT_PTR FNEXPORT acmdDlgProcAbout
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    HBRUSH      hbr;
    HWND        hctrl;
    UINT        u;


    hbr = (HBRUSH)GetWindowLongPtr( hwnd, DWLP_USER );

    switch (uMsg)
    {
        case WM_INITDIALOG:
            hbr = CreateSolidBrush( ABOUT_BACKGROUNDCOLOR );
            SetWindowLongPtr( hwnd, DWLP_USER, (LONG_PTR)hbr );
            return TRUE;

        case WM_CTLCOLORSTATIC:
            hctrl = GetDlgItem( hwnd, IDC_ABOUT_CATCHTHEWAVE );
            if( (HWND)lParam == hctrl )
            {
                SetTextColor( (HDC)wParam, ABOUT_HILIGHTCOLOR );
            }
            // Fall through...

        case WM_CTLCOLORDLG:
        case WM_CTLCOLORBTN:
            SetBkColor( (HDC)wParam, ABOUT_BACKGROUNDCOLOR );
            return (INT_PTR)hbr;

        case WM_COMMAND:
            u = GET_WM_COMMAND_ID(wParam, lParam);
            if ((IDOK == u) || (IDCANCEL == u))
            {
                EndDialog(hwnd, (IDOK == u));
            }
            return FALSE;

        case WM_DESTROY:
            DeleteObject( hbr );
            return FALSE;
    }

    return (FALSE);
} // acmdDlgProcAbout()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd
)
{
    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver supports a custom about box, so
        //  return MMSYSERR_NOERROR...
        //
        return (MMSYSERR_NOERROR);
    }


    //
    //  this driver does support a custom dialog, so display it.  Note,
    //  however, that it is better to let the ACM display the About box
    //  for us - that means smaller code, and fewer bugs!
    //
    DialogBox( pdi->hinst, IDD_ABOUT, hwnd, acmdDlgProcAbout );

    return (MMSYSERR_NOERROR);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format.  return error.
            //
            if (ACM_DRIVER_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            if (WAVE_FORMAT_PCM != padft->dwFormatTag)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = WAVE_FORMAT_PCM;
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_FILTER;
            padft->cStandardFormats = ACM_DRIVER_MAX_STANDARD_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0]   =  '\0';
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX      pwfx;
    UINT                uFormatIndex;
    UINT                u;


    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  verify that the format tag is something we know about
            //
            if (WAVE_FORMAT_PCM != padf->dwFormatTag)
                return (ACMERR_NOTPOSSIBLE);

            if (ACM_DRIVER_MAX_STANDARD_FORMATS_PCM <= padf->dwFormatIndex)
                return (ACMERR_NOTPOSSIBLE);

            //
            //  put some stuff in more accessible variables--note that we
            //  bring variable sizes down to a reasonable size for 16 bit
            //  code...
            //
            pwfx = padf->pwfx;
            uFormatIndex = (UINT)padf->dwFormatIndex;

            //
            //  now fill in the format structure
            //
            pwfx->wFormatTag      = WAVE_FORMAT_PCM;

            u = uFormatIndex / (ACM_DRIVER_MAX_BITSPERSAMPLE_PCM * ACM_DRIVER_MAX_CHANNELS);
            pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
            pwfx->nChannels       = u + 1;

            u = (uFormatIndex / ACM_DRIVER_MAX_CHANNELS) % ACM_DRIVER_MAX_CHANNELS;
            pwfx->wBitsPerSample  = (WORD)gauFormatIndexToBitsPerSample[u];

            pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfx);
            pwfx->nAvgBytesPerSec = PCM_AVGBYTESPERSEC(pwfx);


            //
            //  note that the cbSize field is NOT valid for PCM formats
            //
            //  pwfx->cbSize      = 0;
            break;


        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            if (!pcmIsValidFormat(padf->pwfx))
                return (ACMERR_NOTPOSSIBLE);

            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.
    //
    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_FILTER;
    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFilterTagDetails
//
//  Description:
//
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFILTERTAGDETAILS padft:
//
//      DWORD fdwDetails:
//
//  Return (LRESULT):
//
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFilterTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFILTERTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uIds;
    UINT                uFilterTag;

    //
    //
    //
    //
    //
    switch (ACM_FILTERTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FILTERTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant filter.  return error.
            //
            if (ACM_DRIVER_MAX_FILTER_TAGS <= padft->dwFilterTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFilterTag = (UINT)gadwFilterTagIndexToTag[(UINT)padft->dwFilterTagIndex];
            break;


        case ACM_FILTERTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFilterTag)
            {
                case WAVE_FILTER_UNKNOWN:
                case WAVE_FILTER_ECHO:
                    uFilterTag = WAVE_FILTER_ECHO;
                    break;

                case WAVE_FILTER_VOLUME:
                    uFilterTag = WAVE_FILTER_VOLUME;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FILTERTAGDETAILSF_FILTERTAG:
            switch (padft->dwFilterTag)
            {
                case WAVE_FILTER_VOLUME:
                    uFilterTag = WAVE_FILTER_VOLUME;
                    break;

                case WAVE_FILTER_ECHO:
                    uFilterTag = WAVE_FILTER_ECHO;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFilterTag)
    {
        case WAVE_FILTER_VOLUME:
            padft->dwFilterTagIndex = 0;
            padft->dwFilterTag      = WAVE_FILTER_VOLUME;
            padft->cbFilterSize     = sizeof(VOLUMEWAVEFILTER);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_FILTER;
            padft->cStandardFilters = ACM_DRIVER_MAX_VOLUME_FILTERS;

            uIds = IDS_ACM_DRIVER_TAG_NAME_VOLUME;
            break;

        case WAVE_FILTER_ECHO:
            padft->dwFilterTagIndex = 1;
            padft->dwFilterTag      = WAVE_FILTER_ECHO;
            padft->cbFilterSize     = sizeof(ECHOWAVEFILTER);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_FILTER;
            padft->cStandardFilters = ACM_DRIVER_MAX_ECHO_FILTERS;

            uIds = IDS_ACM_DRIVER_TAG_NAME_ECHO;
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFILTERTAGDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));

    LoadStringCodec(pdi->hinst, uIds, padft->szFilterTag, SIZEOFACMSTR(padft->szFilterTag));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFilterTagDetails()


//--------------------------------------------------------------------------;
//
//  UINT acmdFilterDetailsToString
//
//  Description:
//      This function has a special UNICODE string implementation for common
//      binary codecs between Chicago and Daytona.
//
//  Arguments:
//      LPWAVEFILTER pwf:
//
//      LPTSTR szFilter:
//
//  Return (UINT):
//
//
//--------------------------------------------------------------------------;

#if defined(WIN32) && !defined(UNICODE)

UINT FNLOCAL acmdFilterDetailsToString
(
    PDRIVERINSTANCE         pdi,
    LPWAVEFILTER            pwf,
    LPWSTR                  szFilter
)
{
    UINT                u;
    CHAR                ach1[ACMFILTERDETAILS_FILTER_CHARS];
    CHAR                ach2[ACMFILTERDETAILS_FILTER_CHARS];
    LPVOLUMEWAVEFILTER  pwfVol;
    LPECHOWAVEFILTER    pwfEcho;


    if( !szFilter ) {
        return 0L;
    }

    *szFilter = L'\0';
    if (volumeIsValidFilter(pwf))
    {
        pwfVol = (LPVOLUMEWAVEFILTER)pwf;
        LoadStringA(pdi->hinst, IDS_ACM_DRIVER_FORMAT_VOLUME, ach1, SIZEOF(ach1));
        u = wsprintfA( ach2, ach1,
                 (WORD)(((pwfVol->dwVolume * 100) / 0x10000)) );
    	MultiByteToWideChar( GetACP(), 0, ach2, u+1, szFilter,
                                        ACMFILTERDETAILS_FILTER_CHARS );
        return( u );
    }
    else if (echoIsValidFilter(pwf))
    {
        pwfEcho = (LPECHOWAVEFILTER)pwf;
        LoadStringA(pdi->hinst, IDS_ACM_DRIVER_FORMAT_ECHO, ach1, SIZEOF(ach1));
        u = wsprintfA( ach2, ach1,
                 (WORD)(((pwfEcho->dwVolume * 100) / 0x10000)),
                     (WORD)pwfEcho->dwDelay );
    	MultiByteToWideChar( GetACP(), 0, ach2, u+1, szFilter,
                                        ACMFILTERDETAILS_FILTER_CHARS );
        return( u );
    }
    return ( 0 );
} // acmdFilterDetailsToString()

#else

UINT FNLOCAL acmdFilterDetailsToString
(
    PDRIVERINSTANCE         pdi,
    LPWAVEFILTER            pwf,
    LPTSTR                  szFilter
)
{
    UINT                u;
    TCHAR               ach[ACMFILTERDETAILS_FILTER_CHARS];
    LPVOLUMEWAVEFILTER  pwfVol;
    LPECHOWAVEFILTER    pwfEcho;


    if( !szFilter ) {
        return 0L;
    }

    *szFilter = TEXT('\0');
    if (volumeIsValidFilter(pwf))
    {
        pwfVol = (LPVOLU